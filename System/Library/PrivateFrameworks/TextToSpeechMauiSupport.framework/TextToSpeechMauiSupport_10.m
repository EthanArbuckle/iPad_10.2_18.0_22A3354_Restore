uint64_t forward_highways(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  unsigned int *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t bytes;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  size_t __len;

  LODWORD(__len) = 0;
  if (!a2)
    return 0;
  v8 = *(uint64_t **)a2;
  v9 = *(unsigned int **)(a2 + 120);
  if (!v9)
  {
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v22);
    return 7;
  }
  v12 = *(_QWORD *)(a2 + 240);
  v13 = *v9;
  bytes = fi_shape_get_bytes((int *)(a2 + 20), &__len);
  if (!(_DWORD)bytes)
  {
    if ((_DWORD)v13)
    {
      v15 = 0;
      while (1)
      {
        v16 = (void *)((((_BYTE)v13 + (_BYTE)v15) & 1) != 0 ? a4 : v12);
        cstdlib_memset(v16, 0, __len);
        v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)v9 + 2) + 8 * v15) + 128))(a1);
        if ((_DWORD)v17)
          break;
        if (v13 == ++v15)
          return 0;
      }
      bytes = v17;
      log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"highways forward sub-highway layer failed!", v18, v19, v20, v22);
      return bytes;
    }
    return 0;
  }
  return bytes;
}

_QWORD *free_highways(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (unsigned int *)result[15];
      if (v3)
      {
        v4 = *v3;
        if ((_DWORD)v4)
        {
          v5 = 0;
          v6 = 8 * v4;
          do
          {
            fi_layer_free(*(_QWORD *)(*((_QWORD *)v3 + 2) + v5));
            v5 += 8;
          }
          while (v6 != v5);
        }
        if (*((_QWORD *)v3 + 2))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *((_QWORD *)v3 + 2) = 0;
        }
        (*(void (**)(_QWORD, unsigned int *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t highways_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t *v9;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;

  v8 = *(unsigned int **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  if (!v8)
  {
    v14 = *v9;
    v15 = "NULL param!";
    goto LABEL_11;
  }
  v12 = *v8;
  v13 = (_DWORD *)(a1 + 20);
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 > 2u)
  {
    v14 = *v9;
    v15 = "Currently highway layer only support 1D or 2D input";
LABEL_11:
    log_OutText(v14, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, a6, a7, a8, v20);
    return 7;
  }
  if (!(_DWORD)v12)
  {
LABEL_9:
    if (*v13 < 3u)
    {
      cstdlib_memcpy((void *)(a1 + 40), v13, 0x14uLL);
      return 0;
    }
    v14 = *v9;
    v15 = "final output shape error: Currently highways only support 1D or 2D output";
    goto LABEL_11;
  }
  v16 = 0;
  v17 = *((_QWORD *)v8 + 2);
  v18 = 8 * v12;
  while (1)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v17 + v16) + 144))();
    if ((_DWORD)result)
      return result;
    v17 = *((_QWORD *)v8 + 2);
    v13 = (_DWORD *)(*(_QWORD *)(v17 + v16) + 40);
    v16 += 8;
    if (v18 == v16)
      goto LABEL_9;
  }
}

uint64_t highways_wanted_wb_len(uint64_t a1, unsigned int *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v12;
  uint64_t v13;
  unsigned int padded_bytes;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v12 = *v9;
    if ((_DWORD)v12)
    {
      v13 = 0;
      padded_bytes = 0;
      v15 = 8 * v12;
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v9 + 2) + v13) + 152))();
        if ((_DWORD)result)
          break;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        v13 += 8;
        if (v15 == v13)
          goto LABEL_9;
      }
    }
    else
    {
      padded_bytes = 0;
LABEL_9:
      *a2 = padded_bytes;
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"num_highways: %d\n", a6, a7, a8, *v9);
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v17, v18, v19, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v20, v21, v22, *a2);
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v23);
    return 7;
  }
  return result;
}

uint64_t highways_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(void);
  uint64_t result;
  uint64_t v17;
  int v18;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v10 = *v9;
    if ((_DWORD)v10)
    {
      v11 = 0;
      v12 = 0;
      v13 = *((_QWORD *)v9 + 2);
      v14 = 8 * v10;
      do
      {
        v15 = *(uint64_t (**)(void))(*(_QWORD *)(v13 + v11) + 160);
        if (v15)
        {
          result = v15();
          if ((_DWORD)result)
            return result;
          v13 = *((_QWORD *)v9 + 2);
          if (*(_DWORD *)(*(_QWORD *)(v13 + v11) + 248) > v12)
            v12 = *(_DWORD *)(*(_QWORD *)(v13 + v11) + 248);
        }
        v11 += 8;
      }
      while (v14 != v11);
    }
    else
    {
      v12 = 0;
    }
    v18 = 0;
    result = fi_shape_get_bytes((int *)(a1 + 20), &v18);
    if (!(_DWORD)result)
      *(_DWORD *)(a1 + 248) = v18 + v12;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t highways_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v8 = *(unsigned int **)(a1 + 120);
  if (v8)
  {
    v9 = *v8;
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = *(_QWORD *)(a1 + 72);
      v12 = 8 * v9;
      while (1)
      {
        v13 = *(_QWORD *)(*((_QWORD *)v8 + 2) + v10);
        if (!v13)
          break;
        result = fi_layer_find_weights_via_offset(v13, v11, &padded_bytes);
        if ((_DWORD)result)
          return result;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        v10 += 8;
        if (v12 == v10)
          return 0;
      }
      return 10;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v15);
    return 7;
  }
}

uint64_t highways_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(void);
  uint64_t v17;
  unsigned int v18;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v10 = *v9;
    v18 = 0;
    result = fi_shape_get_bytes((int *)(a1 + 20), &v18);
    if (!(_DWORD)result)
    {
      if ((_DWORD)v10)
      {
        v12 = 0;
        v13 = v18;
        v14 = 8 * v10;
        do
        {
          v15 = *(_QWORD *)(*((_QWORD *)v9 + 2) + v12);
          *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v13;
          *(_DWORD *)(v15 + 248) = *(_DWORD *)(a1 + 248) - v13;
          v16 = *(void (**)(void))(v15 + 168);
          if (v16)
            v16();
          v12 += 8;
        }
        while (v14 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t highways_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t config_highways_layer(int a1, int a2, int a3, _DWORD *a4)
{
  a4[1] = a2;
  a4[2] = a3;
  *a4 = a1;
  return 0;
}

uint64_t create_repeat_layer(uint64_t *a1, const void *a2, _DWORD *a3, const void *a4, uint64_t ***a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t **v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v21;

  if (!*a3)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Repeat count should be positive, got %d", a6, a7, a8, 0);
    v17 = 0;
    v19 = 7;
LABEL_9:
    free_repeat_buffer(v17);
    goto LABEL_10;
  }
  v13 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v17 = v13;
  if (!v13)
    goto LABEL_8;
  *v13 = a1;
  cstdlib_memcpy(v13 + 1, a2, 0xCuLL);
  if (a4)
    cstdlib_memcpy((char *)v17 + 60, a4, 8uLL);
  v18 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4);
  v17[15] = v18;
  if (!v18)
  {
LABEL_8:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v21);
    v19 = 10;
    goto LABEL_9;
  }
  cstdlib_memcpy(v18, a3, 4uLL);
  v19 = 0;
  v17[16] = (uint64_t *)forward_repeat_layer;
  v17[17] = (uint64_t *)free_repeat_buffer;
  v17[18] = (uint64_t *)repeat_layer_update_shape;
LABEL_10:
  *a5 = v17;
  return v19;
}

uint64_t forward_repeat_layer(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  unsigned int *v6;
  uint64_t input_dim;
  unsigned int v8;
  unsigned int v10;

  v6 = *(unsigned int **)(a2 + 120);
  v10 = 0;
  input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v10);
  if (!(_DWORD)input_dim && *v6)
  {
    v8 = 0;
    do
      cstdlib_memcpy((void *)(a4 + 4 * v10 * v8++), a3, 4 * v10);
    while (v8 < *v6);
  }
  return input_dim;
}

_QWORD *free_repeat_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t repeat_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;

  v4 = *(_DWORD **)(a1 + 120);
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 == 1)
  {
    if (a2[1])
    {
      result = 0;
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = a2[1] * *v4;
      *(_DWORD *)(a1 + 56) = a2[4];
      return result;
    }
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Repeat layer only works on data which dimension > 0", v5, v6, v7, v9);
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Repeat layer only works on 1D data, got %d", v5, v6, v7, *a2);
  }
  return 7;
}

uint64_t create_blstm_layer(uint64_t *a1, unsigned int *a2, const void *a3, const void *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  uint64_t v27;

  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v15)
    goto LABEL_10;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v16)
    goto LABEL_10;
  v17 = (_QWORD *)v16;
  v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 40);
  if (!v18)
    goto LABEL_10;
  v19 = (_QWORD *)v18;
  cstdlib_memcpy((void *)(v15 + 8), a2, 0xCuLL);
  *(_QWORD *)v15 = a1;
  if (a4)
    cstdlib_memcpy((void *)(v15 + 60), a4, 8uLL);
  v20 = 2 * get_padded_len(a2[1], 8u);
  v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v20, 4);
  *v17 = v21;
  if (v21
    && (v17[1] = v19,
        v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v20, 4),
        (v19[4] = v22) != 0))
  {
    cstdlib_memcpy(v19, a3, 0x1CuLL);
    *(_QWORD *)(v15 + 120) = v17;
    *(_QWORD *)(v15 + 128) = forward_blstm_layer;
    *(_QWORD *)(v15 + 136) = free_blstm_buffer;
    *(_QWORD *)(v15 + 144) = blstm_layer_update_shape;
    *(_QWORD *)(v15 + 152) = blstm_layer_wanted_wb_len;
    *(_QWORD *)(v15 + 160) = blstm_layer_request_glbBuf;
    if (a5)
    {
      result = 0;
      *(_QWORD *)(v15 + 256) = *(_QWORD *)(a5 + 24);
      *(_DWORD *)(v15 + 264) = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v23, v24, v25, v27);
      result = 0;
      *(_QWORD *)(v15 + 256) = 0;
      *(_DWORD *)(v15 + 264) = 0;
    }
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v27);
    free_blstm_buffer((_QWORD *)v15);
    result = 10;
  }
  *a6 = v15;
  return result;
}

uint64_t forward_blstm_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  _BOOL4 is_enabled;
  char *v11;
  uint64_t input_dim;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t lstm_step_f;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  const char *v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  _BOOL4 v43;
  char *v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  unint64_t v48;
  _BOOL4 v49;
  int v50;
  unsigned int v51;
  char *v52;
  char *v53;
  int step;
  _BOOL4 v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int *v65;
  unint64_t v66;
  uint64_t v67;
  int padded_len;
  char *v69;
  uint64_t v71[4];
  unsigned int v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  char *v79;
  char *v80;
  uint64_t v81;
  _OWORD *v82;
  _OWORD *v83;
  uint64_t v84[4];
  unsigned int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int *v90;
  uint64_t v91;
  char *v92;
  char *v93;
  uint64_t v94;
  _OWORD *v95;
  _OWORD *v96;
  _OWORD v97[2];
  _OWORD v98[2];
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  uint64_t v102;
  unsigned int v103[3];

  v6 = *(uint64_t **)a2;
  v7 = *(_QWORD *)(*(_QWORD *)(a2 + 120) + 8);
  v103[0] = 0;
  v8 = *(unsigned int *)(a2 + 12);
  padded_len = get_padded_len(v8, 8u);
  v66 = *(unsigned int *)(a2 + 248);
  v67 = *(_QWORD *)(a2 + 240);
  v69 = *(char **)(v7 + 32);
  v9 = *(_DWORD *)(a2 + 16) & 0xFFFFFFFD;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a2 + 256), 4u, *(_DWORD *)(a2 + 264));
  v11 = **(char ***)(a2 + 120);
  v101 = a3;
  v102 = 0;
  v100 = 1;
  v99 = 0;
  memset(v98, 0, sizeof(v98));
  memset(v97, 0, sizeof(v97));
  input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)v103);
  if ((_DWORD)input_dim)
  {
    v16 = input_dim;
    v17 = *v6;
    v18 = "get input dim function failed!";
LABEL_3:
    log_OutText(v17, (uint64_t)"FastInfer", 0, 0, (uint64_t)v18, v13, v14, v15, v56);
    goto LABEL_5;
  }
  v64 = v7;
  v16 = lstm_layer_impl_type(a2, &v100);
  if (!(_DWORD)v16)
  {
    lstm_step_f = get_lstm_step_f(&v99, v100);
    if ((_DWORD)lstm_step_f)
    {
      v16 = lstm_step_f;
      v17 = *v6;
      v18 = "get lstm step forward function failed!";
      goto LABEL_3;
    }
    v21 = get_padded_len(v103[0], 8u);
    v22 = v100;
    v23 = v103[0];
    v24 = get_padded_len(v103[0], 8u);
    v28 = *(unsigned int **)(a2 + 72);
    if (v28)
    {
      v29 = (*((unsigned __int8 *)v28 + 4) >> 1) & 1;
      if (!is_enabled)
        v29 = 0;
      if ((v29 & 1) != 0 || v9 != 1)
      {
        if (v29)
        {
          if (!v22)
          {
            v63 = (uint64_t)v6;
            v30 = v8;
            v31 = 4 * get_padded_len(v8, 8u);
            v32 = 4;
            goto LABEL_27;
          }
          if (v22 == 3 || v22 == 1)
          {
            v63 = (uint64_t)v6;
            v30 = v8;
            v31 = get_padded_len((4 * v8), 8u);
            v32 = 1;
LABEL_27:
            v28 = *(unsigned int **)(a2 + 72);
            if (v28)
              v42 = *v28;
            else
              v42 = 0;
            v47 = v42 * v32;
            v36 = (uint64_t)&v28[v31 * v23 + v47];
            v48 = *(unsigned int *)(a2 + 96);
            v38 = (uint64_t)v28 + ((v48 >> 1) & 0x7FFFFFFC);
            v39 = v38 + 4 * v31 * v23 + 4 * v47;
            v40 = (uint64_t)v28 + (v48 & 0xFFFFFFFC);
            v41 = v40 + (((unint64_t)*(unsigned int *)(a2 + 112) >> 1) & 0x7FFFFFFC);
            DWORD1(v98[0]) = v9 == 1;
            goto LABEL_31;
          }
          v33 = *v6;
          v34 = "SVD impl not supported by row major";
LABEL_22:
          log_OutText(v33, (uint64_t)"FastInfer", 0, 0, (uint64_t)v34, v25, v26, v27, v56);
          v16 = 7;
          goto LABEL_5;
        }
LABEL_23:
        v63 = (uint64_t)v6;
        v30 = v8;
        v35 = 4 * v8 * v24;
        v36 = (uint64_t)&v28[v35];
        v37 = *(unsigned int *)(a2 + 96);
        v38 = (uint64_t)v28 + ((v37 >> 1) & 0x7FFFFFFC);
        v39 = v38 + 4 * v35;
        v40 = (uint64_t)v28 + (v37 & 0xFFFFFFFC);
        v41 = v40 + (((unint64_t)*(unsigned int *)(a2 + 112) >> 1) & 0x7FFFFFFC);
        DWORD1(v98[0]) = v9 == 1;
        if (!is_enabled)
        {
          v58 = v40;
          v59 = v41;
          v57 = (uint64_t)&v28[v35];
          v61 = v38 + 4 * v35;
          v62 = v38;
          v65 = (int *)v28;
          v60 = 0;
          v43 = 1;
          LODWORD(v98[0]) = 0;
          DWORD2(v98[0]) = 1;
          *(_QWORD *)&v97[0] = 0;
          v44 = v69;
          v45 = v64;
          v46 = padded_len;
LABEL_38:
          v52 = &v44[4 * v46];
          DWORD2(v97[0]) = v43;
          v53 = &v11[4 * v46];
          if (!*(_DWORD *)(v45 + 24))
          {
            cstdlib_memset(v11, 0, 4 * v30);
            cstdlib_memset(v53, 0, 4 * v30);
          }
          cstdlib_memset(v44, 0, 4 * v30);
          cstdlib_memset(v52, 0, 4 * v30);
          step = fi_shape_get_step((_DWORD *)(a2 + 20));
          v6 = (uint64_t *)v63;
          v16 = createAlignedInputs(v63, v103[0], v21, step, &v101, &v102);
          if (!(_DWORD)v16)
          {
            v84[0] = a2;
            v84[1] = v99;
            v84[2] = v101;
            v84[3] = a4;
            v85 = v103[0];
            v86 = v8;
            v87 = v60;
            v88 = v67;
            v89 = v66 >> 1;
            v90 = v65;
            v91 = v58;
            v92 = v11;
            v93 = v69;
            v94 = v57;
            v95 = v98;
            v96 = v97;
            v71[2] = v101;
            v71[3] = a4;
            v72 = v103[0];
            v73 = v8;
            v74 = v60;
            v75 = v67 + ((v66 >> 1) & 0x7FFFFFFC);
            v76 = v89;
            v77 = v62;
            v78 = v59;
            v79 = v53;
            v80 = v52;
            v81 = v61;
            v82 = v98;
            v83 = v97;
            v55 = *(_QWORD *)(v63 + 24) != 0;
            v71[0] = a2;
            v71[1] = v99;
            v16 = doPasses(v63, v55, v84, v71);
          }
          goto LABEL_5;
        }
        v42 = 0;
LABEL_31:
        v44 = v69;
        v49 = 1;
        v60 = v42;
        v58 = v40;
        v59 = v41;
        if (v28)
        {
          v50 = v28[1] & 1;
          v49 = ((v28[1] >> 1) & 1) == 0;
        }
        else
        {
          v50 = 0;
        }
        v46 = padded_len;
        LODWORD(v98[0]) = v50;
        DWORD2(v98[0]) = v49;
        DWORD1(v97[0]) = 0;
        v65 = (int *)v28;
        v61 = v39;
        v62 = v38;
        if (v36)
        {
          v57 = v36;
          v51 = *(_DWORD *)(v36 + 4);
          LODWORD(v97[0]) = v51 & 1;
          v43 = ((v51 >> 1) & 1) == 0;
        }
        else
        {
          v57 = 0;
          LODWORD(v97[0]) = 0;
          v43 = 1;
        }
        v45 = v64;
        goto LABEL_38;
      }
    }
    else if (v9 != 1)
    {
      goto LABEL_23;
    }
    v33 = *v6;
    v34 = "onehot trick only supports row major";
    goto LABEL_22;
  }
LABEL_5:
  if (v102)
    (*(void (**)(uint64_t))(v6[1] + 48))(v6[2]);
  return v16;
}

_QWORD *free_blstm_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        v4 = v3[1];
        if (v4)
        {
          if (*(_QWORD *)(v4 + 32))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v4 + 32) = 0;
          }
          (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v4);
        }
        if (*v3)
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *v3 = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t blstm_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t result;
  int v12;
  int v13;
  uint64_t v14;

  if (*a2 == 2)
  {
    v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 12);
    cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
    result = 0;
    if (v10 == 1)
    {
      *(_DWORD *)(a1 + 40) = 2;
      v12 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = a2[1];
      *(_DWORD *)(a1 + 48) = v12;
    }
    else
    {
      v13 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v13;
    }
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only supports 2D LSTM, BLSTM!", a6, a7, a8, v14);
    return 7;
  }
  return result;
}

uint64_t blstm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, int *a3)
{
  uint64_t result;

  result = lstm_layer_wanted_wb_len(a1, a2, a3);
  if (!(_DWORD)result)
  {
    *a2 *= 2;
    *a3 *= 2;
  }
  return result;
}

uint64_t blstm_layer_request_glbBuf(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v2 = *(_DWORD **)(*(_QWORD *)(a1 + 120) + 8);
  v3 = *(unsigned int *)(a1 + 12);
  v9 = 0;
  result = get_lstm_glbBufBytes(*(uint64_t **)a1, *v2, v3, &v9);
  if ((_DWORD)result)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"get lstm gobal buffer bytes failed!", v5, v6, v7, v8);
    return 7;
  }
  else
  {
    *(_DWORD *)(a1 + 248) = 2 * v9;
  }
  return result;
}

uint64_t createAlignedInputs(uint64_t a1, unsigned int a2, int a3, int a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v10;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;

  if (a2 == a3)
    return 0;
  LODWORD(v10) = a4;
  v14 = (**(uint64_t (***)(_QWORD, uint64_t))(a1 + 8))(*(_QWORD *)(a1 + 16), 4 * (a4 * a3));
  *a6 = v14;
  if (v14)
  {
    if ((_DWORD)v10)
    {
      v18 = 0;
      v19 = 0;
      v10 = v10;
      do
      {
        cstdlib_memcpy((void *)(*a6 + 4 * v18), (const void *)(*a5 + 4 * v19), 4 * a2);
        v19 += a2;
        v18 += a3;
        --v10;
      }
      while (v10);
      v14 = *a6;
    }
    v7 = 0;
    *a5 = v14;
  }
  else
  {
    log_OutText(*(_QWORD *)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v6);
    return 10;
  }
  return v7;
}

__n128 blstmpassparamset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, int a10, __int128 a11, __int128 a12, __n128 a13, uint64_t a14)
{
  __n128 result;

  result = a13;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a5;
  *(_DWORD *)(a1 + 32) = a6;
  *(_DWORD *)(a1 + 36) = a7;
  *(_DWORD *)(a1 + 40) = a8;
  *(_QWORD *)(a1 + 48) = a9;
  *(_DWORD *)(a1 + 56) = a10;
  *(_OWORD *)(a1 + 64) = a11;
  *(_OWORD *)(a1 + 80) = a12;
  *(__n128 *)(a1 + 96) = a13;
  *(_QWORD *)(a1 + 112) = a14;
  return result;
}

uint64_t doForwardSteps(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int padded_len;
  unsigned int step;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v24;
  uint64_t *v25;

  v4 = *a2;
  v5 = *(_QWORD *)(*(_QWORD *)(*a2 + 120) + 8);
  v6 = *(_DWORD *)(v5 + 12);
  padded_len = get_padded_len(*((unsigned int *)a2 + 8), 8u);
  step = fi_shape_get_step((_DWORD *)(v4 + 20));
  if (!step)
    return 0;
  v25 = a1;
  v9 = 0;
  v10 = 0;
  v11 = 2 * step;
  while (1)
  {
    v12 = a2[3];
    v13 = *((unsigned int *)a2 + 9);
    v14 = v12 + 4 * (v10 * v13);
    if (v6 != 1)
      v14 = a2[3];
    v15 = v12 + 4 * v13;
    v16 = v12 + 4 * (v13 + v13 * v10);
    if (v6 != 1)
      v16 = v15;
    v17 = *(_DWORD *)(v5 + 20) == 1 ? v16 : v14;
    v24 = *(_OWORD *)(a2 + 9);
    v18 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))a2[1])(*(_QWORD *)v4, a2[2] + 4 * v9, v17, *((unsigned int *)a2 + 8));
    if ((_DWORD)v18)
      break;
    v10 += 2;
    v9 += padded_len;
    if (v11 == v10)
      return 0;
  }
  v22 = v18;
  log_OutText(*v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lstm forward failed!", v19, v20, v21, v24);
  return v22;
}

uint64_t doBackwardSteps(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int padded_len;
  unsigned int step;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v22;
  uint64_t *v23;

  v4 = *a2;
  v5 = *(_QWORD *)(*(_QWORD *)(*a2 + 120) + 8);
  v6 = *(_DWORD *)(v5 + 12);
  padded_len = get_padded_len(*((unsigned int *)a2 + 8), 8u);
  step = fi_shape_get_step((_DWORD *)(v4 + 20));
  if (!step)
    return 0;
  v23 = a1;
  v9 = step;
  v10 = 2 * step - 2;
  v11 = padded_len * (step - 1);
  while (1)
  {
    v12 = a2[3];
    v13 = *((unsigned int *)a2 + 9);
    v14 = v12 + 4 * v13;
    if (v6 == 1)
    {
      v14 = v12 + 4 * (v13 + v13 * v10);
      v12 += 4 * (v10 * v13);
    }
    v15 = *(_DWORD *)(v5 + 20) == 1 ? v12 : v14;
    v22 = *(_OWORD *)(a2 + 9);
    v16 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, _QWORD))a2[1])(*(_QWORD *)v4, a2[2] + 4 * v11, v15, *((unsigned int *)a2 + 8));
    if ((_DWORD)v16)
      break;
    v10 -= 2;
    v11 -= padded_len;
    if (!--v9)
      return 0;
  }
  v20 = v16;
  log_OutText(*v23, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lstm backward failed!", v17, v18, v19, v22);
  return v20;
}

uint64_t doPasses(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4)
{
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;

  if (a2 == 1 && *(_DWORD *)(a1 + 96) >= 2u)
  {
    fi_rsc_checkCreateSecondThread(a1);
    v7 = fi_thread_checkQueueTask(a1 + 24, (uint64_t)a4, (uint64_t)blstmPass);
    if (v7)
    {
      if (!v7)
        return 0;
      v8 = doForwardSteps((uint64_t *)a1, a3);
      v9 = fi_thread_wait4Task(a1 + 24);
      if (!(_DWORD)v8)
        return v9;
      return v8;
    }
  }
  v8 = doForwardSteps((uint64_t *)a1, a3);
  if ((_DWORD)v8)
    return v8;
  return doBackwardSteps((uint64_t *)a1, a4);
}

uint64_t create_invpreemph_layer(uint64_t *a1, const void *a2, const void *a3, uint64_t ***a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t **v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t result;
  uint64_t v15;

  v11 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11
    && (v12 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8)) != 0)
  {
    v13 = v12;
    cstdlib_memcpy(v12, a3, 8uLL);
    v11[15] = v13;
    cstdlib_memcpy(v11 + 1, a2, 0xCuLL);
    result = 0;
    *v11 = a1;
    v11[16] = (uint64_t *)forward_invpreemph_layer;
    v11[17] = (uint64_t *)free_invpreemph_buffer;
    v11[18] = (uint64_t *)invpreemph_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v15);
    free_invpreemph_buffer(v11);
    result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_invpreemph_layer(int a1, uint64_t a2, void *__src, void *__dst, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  float v10;
  uint64_t i;
  float v12;
  float v13;

  v8 = *(unsigned int *)(a2 + 44);
  v9 = *(_QWORD *)(a2 + 120);
  v10 = *(float *)v9;
  cstdlib_memcpy(__dst, __src, 4 * v8);
  if (v10 > 0.01)
    _inv_preemphasis((float *)__dst, v8, v10);
  if (*(_DWORD *)(v9 + 4) == 1)
  {
    if (v10 >= 0.01)
    {
      _scale_to_pcm16((float *)__dst, v8);
    }
    else if ((_DWORD)v8)
    {
      for (i = 0; i != v8; ++i)
      {
        v12 = *((float *)__dst + i) * 32767.0;
        if (v12 > 32767.0)
          v12 = 32767.0;
        if (v12 >= -32767.0)
          v13 = v12 + 0.5;
        else
          v13 = -32766.0;
        *((_WORD *)__dst + i) = (int)v13;
      }
    }
    *(_DWORD *)(a5 + 20) = 1;
    *(_DWORD *)(a2 + 56) = 2;
  }
  else
  {
    _scale_to_one((float *)__dst, v8);
  }
  return 0;
}

_QWORD *free_invpreemph_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t invpreemph_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;

  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 == 1)
  {
    result = 0;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = a2[1];
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently invpreemph layer only support 1D input", v4, v5, v6, v8);
    return 7;
  }
  return result;
}

uint64_t create_nest_layer(uint64_t *a1, int a2, int a3, uint64_t a4, uint64_t ***a5)
{
  uint64_t **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t **v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;

  v10 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v14 = v10;
  if (v10
    && (*v10 = a1,
        v10[1] = (uint64_t *)25,
        (v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16)) != 0))
  {
    v16 = v15;
    result = 0;
    *(_DWORD *)v16 = a2;
    *(_DWORD *)(v16 + 4) = a3;
    *(_QWORD *)(v16 + 8) = a4;
    v14[15] = (uint64_t *)v16;
    v14[16] = (uint64_t *)forward_nest_layer;
    v14[17] = (uint64_t *)free_nest_layer;
    v14[18] = (uint64_t *)nest_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v11, v12, v13, v18);
    free_nest_layer(v14);
    result = 10;
  }
  *a5 = v14;
  return result;
}

uint64_t forward_nest_layer(uint64_t a1, int *a2, const void *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unsigned int *v11;
  unint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t bytes;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t size;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  float v49;
  float v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  int i;
  unsigned int v60;
  uint64_t j;
  uint64_t v62;
  float v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v68;
  unint64_t v69;
  _QWORD *v70;
  int v71;
  unsigned int __n;
  unsigned int __n_4;
  unsigned int v74;

  v10 = *(_QWORD *)a2;
  v11 = (unsigned int *)*((_QWORD *)a2 + 15);
  if (v11[1])
  {
    v13 = 0;
    v14 = 0;
    while (1)
    {
      v15 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * v13);
      __n = 0;
      bytes = fi_shape_get_bytes((int *)(v15 + 72), &__n);
      if ((_DWORD)bytes)
        break;
      if (!__n)
      {
        log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"error: nest layer get input length=0 bytes!", a6, a7, a8, v68);
        v30 = 7;
        goto LABEL_34;
      }
      v17 = (void *)(**(uint64_t (***)(_QWORD))(v10 + 8))(*(_QWORD *)(v10 + 16));
      if (v17)
      {
        v21 = v17;
        cstdlib_memcpy(v17, a3, __n);
        v14 = v21;
      }
      else
      {
        log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v18, v19, v20, v68);
      }
      *(_QWORD *)(v15 + 160) = v14;
      v22 = fi_net_forward((uint64_t **)v15);
      if ((_DWORD)v22)
      {
        v30 = v22;
        v43 = *(_QWORD *)v10;
        v44 = "nest layer forward submodel failed!";
        goto LABEL_63;
      }
      ++v13;
      v23 = v11[1];
      if (v13 >= v23)
        goto LABEL_12;
    }
    v30 = bytes;
LABEL_34:
    v43 = *(_QWORD *)v10;
    v44 = "nest layer get submodel input failed!";
    goto LABEL_63;
  }
  LODWORD(v23) = 0;
LABEL_12:
  v24 = *v11;
  v25 = (_QWORD *)*((_QWORD *)v11 + 1);
  if ((v24 - 1) < 3)
  {
    v74 = 0;
    size = fi_shape_get_size(a2 + 10, (int *)&v74);
    if ((_DWORD)size)
    {
      v30 = size;
      v31 = *(_QWORD *)v10;
      v32 = "nest layer mode %d submodel output failed!";
      v68 = v24;
LABEL_15:
      log_OutText(v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)v32, v27, v28, v29, v68);
      goto LABEL_62;
    }
    cstdlib_memcpy(a4, *(const void **)(*v25 + 144), 4 * v74);
    v45 = v74;
    if (v74)
    {
      v46 = 0;
      while (v23 < 2)
      {
LABEL_47:
        if ((_DWORD)v24 == 3)
          *(float *)&a4[4 * v46] = *(float *)&a4[4 * v46] / (float)v23;
        if (++v46 == v45)
          return 0;
      }
      v47 = v25 + 1;
      v48 = v23 - 1;
      while (1)
      {
        v49 = *(float *)(*(_QWORD *)(*v47 + 144) + 4 * v46);
        if ((_DWORD)v24 == 3)
          break;
        if ((_DWORD)v24 == 2)
        {
          v50 = v49 * *(float *)&a4[4 * v46];
          goto LABEL_45;
        }
        if ((_DWORD)v24 == 1)
          break;
LABEL_46:
        ++v47;
        if (!--v48)
          goto LABEL_47;
      }
      v50 = v49 + *(float *)&a4[4 * v46];
LABEL_45:
      *(float *)&a4[4 * v46] = v50;
      goto LABEL_46;
    }
    return 0;
  }
  if ((_DWORD)v24 == 4)
  {
    v51 = *(_QWORD *)(*v25 + 144);
    v52 = *(_QWORD *)(v25[1] + 144);
    v53 = *(_DWORD *)(*v25 + 96);
    v54 = *(unsigned int *)(*v25 + 100);
    cstdlib_memset(a4, 0, 4 * (v54 * v53));
    if (v53)
    {
      v58 = 0;
      for (i = 0; i != v53; ++i)
      {
        if ((_DWORD)v54)
        {
          v60 = 0;
          for (j = 0; j != v54; ++j)
          {
            v62 = (i * v54 + j);
            v63 = *(float *)&a4[4 * v62];
            v64 = v58;
            v65 = v60;
            v66 = v54;
            do
            {
              v63 = v63 + (float)(*(float *)(v51 + 4 * v64) * *(float *)(v52 + 4 * v65));
              *(float *)&a4[4 * v62] = v63;
              ++v65;
              ++v64;
              --v66;
            }
            while (v66);
            v60 += v54;
          }
        }
        v58 += v54;
      }
    }
    log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 3, 0, (uint64_t)"nest dot output done!", v55, v56, v57, v68);
    return 0;
  }
  if (!(_DWORD)v24)
  {
    __n_4 = 0;
    if ((_DWORD)v23)
    {
      v33 = 0;
      v34 = 0;
      v23 = v23;
      v69 = v23;
      v70 = v25;
      while (1)
      {
        v35 = v25[v33];
        v36 = fi_shape_get_bytes((int *)(v35 + 92), &__n_4);
        if ((_DWORD)v36)
        {
          v30 = v36;
          goto LABEL_67;
        }
        if (!__n_4)
          break;
        v37 = *(_DWORD *)(v35 + 92);
        if (v37 == 2)
        {
          v38 = a2[11];
          if (v38)
          {
            v71 = v34;
            v39 = 0;
            v40 = 0;
            v41 = a2[14];
            v42 = a2[12];
            do
            {
              cstdlib_memcpy(&a4[((v39 + v33 * *(_DWORD *)(v35 + 100)) * v41)], (const void *)(*(_QWORD *)(v35 + 144) + (*(_DWORD *)(v35 + 100) * v41 * v40++)), (*(_DWORD *)(v35 + 100) * v41));
              v39 += v42;
            }
            while (v38 != v40);
            v23 = v69;
            v25 = v70;
            v34 = v71;
          }
        }
        else if (v37 == 1)
        {
          cstdlib_memcpy(&a4[v34], *(const void **)(v35 + 144), __n_4);
          v34 += __n_4;
        }
        else
        {
          log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"nest layer now only support conat 1d, 2d data", v27, v28, v29, v68);
        }
        if (++v33 == v23)
          return 0;
      }
      log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", __n_4, 0, (uint64_t)"nest layer submodel output length=0!", v27, v28, v29, v68);
      v30 = 7;
LABEL_67:
      v31 = *(_QWORD *)v10;
      v32 = "nest layer concat submodel output failed!";
      goto LABEL_15;
    }
    return 0;
  }
  log_OutText(*(_QWORD *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"error: non supported nest mode: %d", a6, a7, a8, *v11);
  v30 = 7;
LABEL_62:
  v43 = *(_QWORD *)v10;
  v44 = "nest layer gen output failed!";
LABEL_63:
  log_OutText(v43, (uint64_t)"FastInfer", 0, 0, (uint64_t)v44, a6, a7, a8, v68);
  return v30;
}

_QWORD *free_nest_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    v3 = result[15];
    if (*(_DWORD *)(v3 + 4))
    {
      v4 = 0;
      do
        fi_net_destroy(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4++));
      while (v4 < *(unsigned int *)(v3 + 4));
    }
    if (*(_QWORD *)(v3 + 8))
    {
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      *(_QWORD *)(v3 + 8) = 0;
    }
    (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
    return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
  }
  return result;
}

uint64_t nest_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t *v4;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t **v12;
  int step;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t updated;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _DWORD *v24;
  BOOL v25;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;

  v4 = *(uint64_t **)a1;
  v5 = *(unsigned int **)(a1 + 120);
  v6 = v5[1];
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if ((_DWORD)v6)
  {
    v10 = 0;
    v11 = 8 * v6;
    while (1)
    {
      v12 = *(uint64_t ***)(*((_QWORD *)v5 + 1) + v10);
      if (!*((_DWORD *)v12 + 18))
        cstdlib_memcpy(v12 + 9, a2, 0x14uLL);
      step = fi_shape_get_step(a2);
      updated = fi_net_update_shape(v12, step, v14, v15, v16, v17, v18, v19);
      if ((_DWORD)updated)
        break;
      v10 += 8;
      if (v11 == v10)
        goto LABEL_7;
    }
    v29 = updated;
    v30 = *v4;
    v31 = "submodels update shape failed!";
  }
  else
  {
LABEL_7:
    v21 = *v5;
    v22 = (_QWORD *)*((_QWORD *)v5 + 1);
    v23 = v5[1];
    v24 = (_DWORD *)(a1 + 40);
    switch((int)v21)
    {
      case 0:
        if (!(_DWORD)v23)
          return 0;
        v37 = 0;
        v38 = 8 * v23;
        do
        {
          v39 = v22[v37 / 8];
          if (v37)
          {
            v40 = fi_shape_merge((_DWORD *)(v39 + 92), v24);
            if ((_DWORD)v40)
            {
              v29 = v40;
              log_OutText(*v4, (uint64_t)"FastInfer", 0, 0, (uint64_t)"submodels outputs not able to nest!", v41, v42, v43, v73);
              fi_shape_dump(v4, v22[v37 / 8] + 92, (uint64_t)"shape to be nestd", v57, v58, v59, v60, v61);
              fi_shape_dump(v4, (uint64_t)v24, (uint64_t)"shape", v62, v63, v64, v65, v66);
              log_OutText(*v4, (uint64_t)"FastInfer", 0, 0, (uint64_t)"concat submodels output shape failed!", v67, v68, v69, v74);
              goto LABEL_26;
            }
          }
          else
          {
            cstdlib_memcpy(v24, (const void *)(v39 + 92), 0x14uLL);
          }
          v37 += 8;
        }
        while (v38 != v37);
        return 0;
      case 1:
      case 2:
      case 3:
      case 5:
        if ((_DWORD)v23)
          v25 = v4 == 0;
        else
          v25 = 1;
        if (v25 || v22 == 0)
          goto LABEL_16;
        if (v23 < 2)
          goto LABEL_22;
        v32 = v23 - 1;
        v33 = v22;
        break;
      case 4:
        if ((_DWORD)v23 == 2)
        {
          if (fi_shape_is_same((unsigned int *)(*v22 + 92), (_DWORD *)(v22[1] + 92)))
          {
            fi_shape_copy((void *)(a1 + 40), (const void *)(*v22 + 92));
            v29 = 0;
            *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 44);
            return v29;
          }
          v55 = *v4;
          v23 = 2;
          v56 = "dot nest requires 2 submodels has the same shape, but , but got: %d";
        }
        else
        {
          v55 = *v4;
          v56 = "dot nest requires 2 submodels, but got: %d";
        }
        log_OutText(v55, (uint64_t)"FastInfer", 0, 0, (uint64_t)v56, v7, v8, v9, v23);
        log_OutText(*v4, (uint64_t)"FastInfer", 0, 0, (uint64_t)"update submodels' shape failed for nest mode %d", v70, v71, v72, 4);
        goto LABEL_25;
      default:
        v27 = *v4;
        v28 = "error: non supported nest mode: %d";
        goto LABEL_24;
    }
    while (fi_shape_is_same((unsigned int *)(*v33 + 92), (_DWORD *)(v33[1] + 92)))
    {
      ++v33;
      if (!--v32)
      {
LABEL_22:
        fi_shape_copy(v24, (const void *)(*v22 + 92));
        return 0;
      }
    }
    log_OutText(*v4, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Only shapes with same shape can be sum nestd!", v34, v35, v36, v73);
    fi_shape_dump(v4, *v33 + 92, (uint64_t)"previous shape", v45, v46, v47, v48, v49);
    fi_shape_dump(v4, *v33 + 92, (uint64_t)"shape", v50, v51, v52, v53, v54);
LABEL_16:
    v27 = *v4;
    v28 = "submodel outshape must be the same for nest mode %d";
LABEL_24:
    log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v7, v8, v9, v21);
LABEL_25:
    v29 = 7;
LABEL_26:
    v30 = *v4;
    v31 = "udpate nest layer output shape failed!";
  }
  log_OutText(v30, (uint64_t)"FastInfer", 0, 0, (uint64_t)v31, v7, v8, v9, v73);
  return v29;
}

uint64_t lstm_layer_impl_type(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  _DWORD *v3;
  uint64_t result;

  if (!a1)
    return 7;
  v2 = *(_QWORD *)(a1 + 120);
  if (!v2)
    return 7;
  v3 = *(_DWORD **)(v2 + 8);
  if (!v3)
    return 7;
  result = 0;
  *a2 = *v3;
  return result;
}

_QWORD *free_lstm_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        v4 = v3[1];
        if (v4)
        {
          if (*(_QWORD *)(v4 + 32))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v4 + 32) = 0;
          }
          (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v4);
        }
        if (*v3)
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *v3 = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t forward_lstm_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;

  v8 = *(_QWORD *)(a2 + 120);
  v9 = *(_QWORD *)(v8 + 8);
  if (*(_DWORD *)(v9 + 24))
  {
    if (!a1)
      goto LABEL_7;
  }
  else
  {
    cstdlib_memset(*(void **)v8, 0, 4 * *(unsigned int *)(a2 + 12));
    if (!a1)
      goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 8))
    return 0;
LABEL_7:
  cstdlib_memset(*(void **)(v9 + 32), 0, 4 * *(unsigned int *)(a2 + 12));
  return forward_lstm_layer_f32(a2, a3, a4);
}

uint64_t reset_lstm_layer_hidden(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  void *v10;
  uint64_t v12;
  const char *v13;
  uint64_t v14;

  v9 = **(void ***)(a1 + 120);
  if (v9)
  {
    cstdlib_memset(v9, 0, 4 * *(unsigned int *)(a1 + 12));
    v10 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 32);
    if (v10)
    {
      cstdlib_memset(v10, 0, 4 * *(unsigned int *)(a1 + 12));
      return 0;
    }
    v12 = **(_QWORD **)a1;
    v13 = "lstm cell resetting null pointer!";
  }
  else
  {
    v12 = **(_QWORD **)a1;
    v13 = "lstm state resetting null pointer!";
  }
  log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, v14);
  return 10;
}

uint64_t create_bgru_layer(uint64_t *a1, _DWORD *a2, const void *a3, const void *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t result;
  uint64_t v28;

  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v15)
    goto LABEL_9;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v16)
    goto LABEL_9;
  v17 = (_QWORD *)v16;
  v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 20);
  if (!v18)
    goto LABEL_9;
  v19 = (void *)v18;
  cstdlib_memcpy((void *)(v15 + 8), a2, 0xCuLL);
  v20 = (2 * a2[1]);
  *(_QWORD *)v15 = a1;
  if (a4)
    cstdlib_memcpy((void *)(v15 + 60), a4, 8uLL);
  v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v20, 4);
  *v17 = v21;
  if (v21)
  {
    v17[1] = v19;
    cstdlib_memcpy(v19, a3, 0x14uLL);
    *(_QWORD *)(v15 + 120) = v17;
    *(_QWORD *)(v15 + 128) = forward_bgru_layer;
    *(_QWORD *)(v15 + 136) = free_bgru_buffer;
    if (a5)
    {
      v25 = *(_QWORD *)(a5 + 24);
      v26 = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v22, v23, v24, v28);
      v25 = 0;
      v26 = 0;
    }
    result = 0;
    *(_QWORD *)(v15 + 256) = v25;
    *(_DWORD *)(v15 + 264) = v26;
    *(_QWORD *)(v15 + 144) = bgru_layer_update_shape;
    *(_QWORD *)(v15 + 152) = bgru_layer_wanted_wb_len;
    *(_QWORD *)(v15 + 160) = bgru_layer_request_glbBuf;
  }
  else
  {
LABEL_9:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v28);
    free_bgru_buffer((_QWORD *)v15);
    result = 10;
  }
  *a6 = v15;
  return result;
}

uint64_t forward_bgru_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char **v6;
  uint64_t v7;
  size_t v8;
  char *v9;
  char *v10;
  unsigned int padded_bytes;
  uint64_t input_dim;
  unsigned int padded_len;
  unsigned int step;
  int v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  const char *v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  size_t __len;
  unint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t *v54;
  int v56;
  void *v57;
  int v58;
  void *v59;
  unsigned int v60[3];

  v54 = *(uint64_t **)a2;
  v6 = *(char ***)(a2 + 120);
  v60[0] = 0;
  v7 = *(unsigned int *)(a2 + 12);
  v57 = *(void **)(a2 + 240);
  v8 = *(unsigned int *)(a2 + 248);
  v10 = *v6;
  v9 = v6[1];
  v56 = *((_DWORD *)v9 + 3);
  v59 = 0;
  v58 = 1;
  v53 = *(_QWORD *)(a2 + 72);
  padded_bytes = get_padded_bytes(*(_DWORD *)(a2 + 96), 8u);
  v50 = *(_DWORD *)(a2 + 96);
  v51 = *(_QWORD *)(a2 + 72);
  v48 = *(unsigned int *)(a2 + 112);
  if (!*((_DWORD *)v9 + 4))
  {
    cstdlib_memset(v10, 0, 4 * v7);
    cstdlib_memset(&v10[4 * v7], 0, 4 * v7);
    cstdlib_memset(v10, 0, 4 * (2 * v7));
  }
  input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)v60);
  if ((_DWORD)input_dim)
    goto LABEL_52;
  padded_len = get_padded_len(v60[0], 8u);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  input_dim = gru_layer_impl_type(a2, &v58);
  if ((_DWORD)input_dim)
    goto LABEL_52;
  v15 = v58;
  if (v60[0] == padded_len)
  {
    v16 = v54;
  }
  else
  {
    v16 = v54;
    if (v58 != 4)
    {
      v59 = (void *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v54[1] + 16))(v54[2], padded_len, 4);
      if (!v59)
      {
LABEL_45:
        log_OutText(*v16, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v17, v18, v19, v42);
        input_dim = 10;
        goto LABEL_52;
      }
      v15 = v58;
    }
  }
  __len = v8;
  if (v15 == 4)
    v20 = step * padded_len;
  else
    v20 = v60[0];
  v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v16[1] + 16))(v16[2], v20, 4);
  if (!v21)
    goto LABEL_45;
  v22 = (char *)v21;
  if (!step)
  {
    input_dim = 0;
    goto LABEL_51;
  }
  v23 = 0;
  v24 = step;
  v25 = 0;
  v45 = v53 + 4 * (padded_bytes >> 3);
  v26 = (v48 >> 1) & 0x7FFFFFFC;
  v49 = v51 + (v50 & 0xFFFFFFFC);
  v44 = v49 + v26;
  v52 = v24;
  v46 = v24;
  while (1)
  {
    v27 = v56 == 1 ? 2 * v7 * v25 : 0;
    if (v58 == 4)
      break;
    v23 = a3 + 4 * v60[0] * v25;
    if (v60[0] != padded_len)
    {
      if (!v59)
      {
        input_dim = 0;
        v40 = "empty new input memory!";
        goto LABEL_50;
      }
      cstdlib_memcpy(v59, (const void *)(a3 + 4 * v60[0] * v25), 4 * v60[0]);
      v23 = (uint64_t)v59;
    }
LABEL_30:
    v32 = v58;
    if ((v58 - 5) <= 0xFFFFFFFD)
    {
      cstdlib_memset(v57, 0, __len);
      v32 = v58;
    }
    v33 = gru_step_f32((uint64_t **)a2, v32, v23, a4 + 4 * v27, v60[0], v7, (uint64_t)v57, v53, v49, (uint64_t)v10);
    if ((_DWORD)v33)
    {
      input_dim = v33;
      v40 = "gru step forward failed!";
LABEL_50:
      log_OutText(*v16, (uint64_t)"FastInfer", 0, 0, (uint64_t)v40, v17, v18, v19, v42);
      goto LABEL_51;
    }
    if (++v25 == v52)
    {
      v34 = 0;
      v35 = v7 * (2 * v52 - 1);
      v36 = v52 - 1;
      while (1)
      {
        v37 = v56 == 1 ? v35 : v7;
        if (v58 == 4)
        {
          v38 = 4;
        }
        else
        {
          cstdlib_memcpy(v22, (const void *)(a3 + 4 * v60[0] * v36), 4 * v60[0]);
          v38 = v58;
          if ((v58 - 5) <= 0xFFFFFFFD)
          {
            cstdlib_memset(v57, 0, __len);
            v38 = v58;
          }
        }
        v39 = gru_step_f32((uint64_t **)a2, v38, (uint64_t)v22, a4 + 4 * v37, v60[0], v7, (uint64_t)v57 + ((__len >> 1) & 0x7FFFFFFC), v45, v44, (uint64_t)&v10[4 * v7]);
        if ((_DWORD)v39)
          break;
        ++v34;
        v35 -= 2 * v7;
        --v36;
        if (v46 == v34)
        {
          input_dim = 0;
          v16 = v54;
          goto LABEL_51;
        }
      }
      input_dim = v39;
      v16 = v54;
      v40 = "gru backward failed!";
      goto LABEL_50;
    }
  }
  if (v25)
    goto LABEL_30;
  v28 = a3;
  if (v60[0] == padded_len)
  {
LABEL_24:
    v43 = v28;
    v30 = 0;
    v31 = v46;
    do
    {
      cstdlib_memcpy(&v22[4 * v30], (const void *)(a3 + 4 * v60[0] * --v31), 4 * v60[0]);
      v30 += padded_len;
    }
    while (v31);
    v16 = v54;
    v23 = v43;
    goto LABEL_30;
  }
  v29 = realign_inData(v16, v52, v60[0], (uint64_t *)&v59, a3);
  if (!(_DWORD)v29)
  {
    v28 = (uint64_t)v59;
    goto LABEL_24;
  }
  input_dim = v29;
LABEL_51:
  (*(void (**)(uint64_t, char *))(v16[1] + 48))(v16[2], v22);
LABEL_52:
  if (v59)
    (*(void (**)(uint64_t))(v54[1] + 48))(v54[2]);
  return input_dim;
}

_QWORD *free_bgru_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        if (v3[1])
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        if (*v3)
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *v3 = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t bgru_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t result;
  int v12;
  int v13;
  uint64_t v14;

  if (*a2 == 2)
  {
    v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 12);
    cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
    result = 0;
    if (v10 == 1)
    {
      *(_DWORD *)(a1 + 40) = 2;
      v12 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = a2[1];
      *(_DWORD *)(a1 + 48) = v12;
    }
    else
    {
      v13 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v13;
    }
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only supports 2D GRU, BGRU!", a6, a7, a8, v14);
    return 7;
  }
  return result;
}

uint64_t bgru_layer_wanted_wb_len(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t v5;

  v5 = gru_layer_wanted_wb_len(a1, a2, a3);
  if (!(_DWORD)v5)
  {
    *a2 += get_padded_bytes(*a2, 8u);
    *a3 *= 2;
  }
  return v5;
}

uint64_t bgru_layer_request_glbBuf(_DWORD *a1)
{
  uint64_t v2;
  _DWORD *v3;
  uint64_t result;
  int step;
  int v6;
  uint64_t v7;

  v2 = a1[3];
  v7 = 0;
  v6 = 0;
  v3 = a1 + 5;
  result = fi_shape_get_input_dim(a1 + 5, (int *)&v7 + 1);
  if (!(_DWORD)result)
  {
    step = fi_shape_get_step(v3);
    result = gru_layer_impl_type((uint64_t)a1, &v7);
    if (!(_DWORD)result)
    {
      result = get_gru_glbBufBytes(v7, HIDWORD(v7), step, v2, &v6);
      if (!(_DWORD)result)
        a1[62] = 2 * v6;
    }
  }
  return result;
}

uint64_t create_pqmf_layer(uint64_t *a1, const void *a2, uint64_t ***a3)
{
  uint64_t **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  void *v11;
  uint64_t result;
  uint64_t v13;

  v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v10 = v6;
  if (v6
    && (*v6 = a1,
        v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    cstdlib_memcpy(v11, a2, 8uLL);
    result = 0;
    *((_DWORD *)v10 + 2) = 71;
    v10[16] = (uint64_t *)forward_pqmf_layer;
    v10[17] = (uint64_t *)free_pqmf_buffer;
    v10[18] = (uint64_t *)pqmf_layer_update_shape;
    v10[19] = (uint64_t *)pqmf_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v13);
    free_pqmf_buffer(v10);
    result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_pqmf_layer(uint64_t a1, uint64_t a2, uint64_t a3, float *a4)
{
  unsigned int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t padded_len;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  float *v17;

  v6 = *(unsigned int **)(a2 + 120);
  v7 = *(_DWORD *)(a2 + 24);
  v8 = *(_QWORD *)(a2 + 88);
  v9 = v6[1];
  padded_len = get_padded_len(*v6, 8u);
  v17 = a4;
  cstdlib_memset(a4, 0, 4 * (v9 * v7));
  if (v7 != padded_len / v9)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      if ((_DWORD)v9)
      {
        v13 = 0;
        v14 = v9;
        v15 = v11;
        do
        {
          axpy(padded_len, (float *)(v8 + 4 * v13), 1, &v17[(v9 * v12)], 1, *(float *)(a3 + 4 * v15));
          v13 += padded_len;
          ++v15;
          --v14;
        }
        while (v14);
      }
      ++v12;
      v11 += v9;
    }
    while (v12 != v7 - padded_len / v9);
  }
  return 0;
}

_QWORD *free_pqmf_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t pqmf_layer_update_shape(uint64_t a1, _DWORD *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  int v11;
  uint64_t v12;
  int v13;

  v13 = 0;
  if (*__src == 2 && __src[2] == *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4))
  {
    cstdlib_memcpy((void *)(a1 + 20), __src, 0x14uLL);
    result = fi_shape_get_size(__src, &v13);
    if (!(_DWORD)result)
    {
      v11 = v13;
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v11;
      *(_DWORD *)(a1 + 56) = __src[4];
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"pqmf input must be exactly 2 dimensional and matches the pqmf bands!", a6, a7, a8, v12);
    return 7;
  }
  return result;
}

uint64_t pqmf_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v5 = *(unsigned int **)(a1 + 120);
  *a2 = 4 * get_padded_len(*v5, 8u) * v5[1];
  *a3 = 0;
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"len : %d\n", v6, v7, v8, *v5);
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"bands : %d\n", v9, v10, v11, v5[1]);
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v12, v13, v14, *(unsigned int *)(a1 + 96));
  return 0;
}

uint64_t fi_get_model_type(const char *a1)
{
  if (!cstdlib_strcmp(a1, "gmm_type2"))
    return 1;
  cstdlib_strcmp(a1, "multinomial");
  return 0;
}

uint64_t fi_get_sampling_method(const char *a1)
{
  uint64_t v2;

  v2 = 3;
  if (cstdlib_strcmp(a1, "argmax"))
  {
    if (cstdlib_strcmp(a1, "random"))
      return 3;
    else
      return 4;
  }
  return v2;
}

uint64_t create_sampling_layer(uint64_t *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t result;
  uint64_t v15;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11
    && (v12 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16)) != 0)
  {
    v13 = v12;
    cstdlib_memcpy(v12, a2, 8uLL);
    result = 0;
    v13[1] = a3;
    *(_QWORD *)v11 = a1;
    *(_DWORD *)(v11 + 8) = 28;
    *(_QWORD *)(v11 + 120) = v13;
    *(_QWORD *)(v11 + 128) = forward_sampling_layer;
    *(_QWORD *)(v11 + 136) = free_sampling_buffer;
    *(_QWORD *)(v11 + 144) = sampling_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v15);
    free_sampling_buffer((_QWORD *)v11);
    result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_sampling_layer(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  int *v7;
  int v8;
  int v9;
  unsigned int *v10;
  int *v11;
  int step;
  uint64_t result;
  float v14;
  int i;
  char *v16;
  char *v17;
  int v18[2];

  *(_QWORD *)v18 = 0;
  v7 = *(int **)(a2 + 120);
  v9 = *v7;
  v8 = v7[1];
  v10 = (unsigned int *)*((_QWORD *)v7 + 1);
  v11 = (int *)(a2 + 20);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  result = fi_shape_get_size((int *)(a2 + 40), &v18[1]);
  if (!(_DWORD)result)
  {
    result = fi_shape_get_input_dim(v11, v18);
    if (!(_DWORD)result)
    {
      if (*v11 == 1)
      {
        if (v9)
        {
          if (v9 == 1)
            gmm_type2(a3, v18[0], v10, a4, v8);
        }
        else
        {
          multinomial((uint64_t)a3, v18[0], v10, (float *)a4, v8, v14);
        }
      }
      else if (step)
      {
        for (i = 0; i != step; ++i)
        {
          v16 = &a3[4 * v18[0] * i];
          v17 = &a4[4 * *(_DWORD *)(a2 + 48) * i];
          if (v9)
          {
            if (v9 == 1)
              gmm_type2(v16, v18[0], v10, v17, v8);
          }
          else
          {
            v14 = multinomial((uint64_t)v16, v18[0], v10, (float *)v17, v8, v14);
          }
        }
      }
      return 0;
    }
  }
  return result;
}

_QWORD *free_sampling_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t sampling_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  int v4;
  int *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;

  v14 = 0;
  v4 = **(_DWORD **)(a1 + 120);
  v5 = (int *)(a1 + 20);
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  result = fi_shape_get_input_dim(v5, (int *)&v14);
  if ((_DWORD)result)
    return result;
  if (v4 == 1)
  {
    v10 = v14 >> 2;
    goto LABEL_6;
  }
  if (!v4)
  {
    v10 = 1;
LABEL_6:
    v14 = v10;
  }
  if (*a2 == 2)
  {
    result = 0;
    *(_DWORD *)(a1 + 40) = 2;
    v12 = v14;
    *(_DWORD *)(a1 + 44) = a2[1];
    *(_DWORD *)(a1 + 48) = v12;
    goto LABEL_11;
  }
  if (*a2 == 1)
  {
    result = 0;
    v11 = v14;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v11;
LABEL_11:
    *(_DWORD *)(a1 + 56) = a2[4];
    return result;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently sampling layer only support 1D or 2D input", v7, v8, v9, v13);
  return 7;
}

void gmm_type2(void *__src, unsigned int a2, unsigned int *a3, char *__dst, int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  char v15;
  char v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  float *v25;
  float v26;
  float v27;
  unsigned int v28;

  v10 = a2 >> 2;
  if (a2 < 4)
  {
LABEL_9:
    cstdlib_memcpy(__dst, __src, a2 & 0xFFFFFFFC);
    if (a5 != 4)
    {
      if (a5 == 3 && a2 >= 4)
      {
        v19 = 0;
        if (v10 <= 1)
          v20 = 1;
        else
          v20 = v10;
        do
        {
          if (*((float *)__src + v10 + v19) <= fmaxf(*((float *)__src + v19), 0.0))
            v21 = 2;
          else
            v21 = 3;
          *(_DWORD *)&__dst[4 * v19] = *((_DWORD *)__src + (v19 + v10 * v21));
          ++v19;
        }
        while (v20 != v19);
      }
      return;
    }
    if (a2 < 4)
      return;
    v22 = (2 * v10);
    v23 = *a3;
    if (v10 <= 1)
      v24 = 1;
    else
      v24 = v10;
    v25 = (float *)__src;
    while (1)
    {
      v23 = (1103515245 * v23 + 12345) & 0x7FFFFFFF;
      v26 = (float)v23 * 4.6566e-10;
      v27 = *v25 + 0.0;
      if (v27 > v26)
        break;
      v28 = v10;
      if ((float)(v27 + v25[v10]) > v26)
        goto LABEL_28;
LABEL_29:
      ++v25;
      __dst += 4;
      ++v22;
      if (!--v24)
      {
        *a3 = v23;
        return;
      }
    }
    v28 = 0;
LABEL_28:
    *(_DWORD *)__dst = *((_DWORD *)__src + v22 + v28);
    goto LABEL_29;
  }
  v11 = 0;
  if (v10 <= 1)
    v12 = 1;
  else
    v12 = v10;
  while (1)
  {
    v13 = 0;
    v14 = 0.0;
    v15 = 1;
    do
    {
      v16 = v15;
      v17 = v11 + v13 * v10;
      v18 = exp_fdlibm(*((float *)__src + v17));
      v15 = 0;
      *(float *)&v18 = v18;
      *((_DWORD *)__src + v17) = LODWORD(v18);
      v14 = v14 + *(float *)&v18;
      v13 = 1;
    }
    while ((v16 & 1) != 0);
    if (v14 == 0.0)
      break;
    *((float *)__src + v11) = *((float *)__src + v11) / v14;
    *((float *)__src + v11 + v10) = *((float *)__src + v11 + v10) / v14;
    if (++v11 == v12)
      goto LABEL_9;
  }
}

float multinomial(uint64_t a1, int a2, unsigned int *a3, float *a4, int a5, float result)
{
  unsigned int v7;
  uint64_t v8;
  float v9;

  if (a5 == 3)
  {
    LODWORD(v8) = fi_argmax(a1, a2);
LABEL_9:
    result = (float)v8;
    *a4 = (float)v8;
    return result;
  }
  if (a5 == 4)
  {
    v7 = (1103515245 * *a3 + 12345) & 0x7FFFFFFF;
    *a3 = v7;
    if (a2)
    {
      v8 = 0;
      result = (float)v7 * 4.6566e-10;
      v9 = 0.0;
      while (1)
      {
        v9 = v9 + *(float *)(a1 + 4 * v8);
        if (v9 > result)
          break;
        if (a2 == ++v8)
          return result;
      }
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t trans_dec_dispatch_weights(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(uint64_t **)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(v1[7], v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(v1[8], v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(v1[9], v2, &padded_bytes);
      if (!(_DWORD)result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t create_trans_dec_layer(uint64_t *a1, _DWORD *a2, const void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _BYTE v33[20];
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 80);
      v19 = v15;
      if (!v15)
      {
        v26 = *a1;
        v27 = "out of memory!";
        goto LABEL_11;
      }
      cstdlib_memcpy(v15, a2, 0x34uLL);
      v39 = 0u;
      v38 = 0u;
      v20 = *((_QWORD *)a2 + 2);
      v36 = *((_QWORD *)a2 + 3);
      memset(v33, 0, sizeof(v33));
      v37 = 0;
      v35 = 1;
      v34 = v20;
      *(float *)&v38 = (float)a2[8];
      *((_QWORD *)&v39 + 1) = 0;
      v40 = 1;
      if (create_att_layer(a1, (unsigned int *)&v34, a3, a4, v19 + 7))
        goto LABEL_7;
      v37 = 1;
      v35 = 1;
      v24 = *((_QWORD *)a2 + 2);
      v36 = *((_QWORD *)a2 + 3);
      v34 = v24;
      *(float *)&v38 = (float)a2[8];
      *((_QWORD *)&v39 + 1) = 0;
      LODWORD(v40) = 1;
      if (create_att_layer(a1, (unsigned int *)&v34, a3, a4, v19 + 8))
      {
LABEL_7:
        v25 = "create trans_dec att layer failed!";
LABEL_8:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v21, v22, v23, v31);
        v26 = *a1;
        v27 = "trans_dec network init failed!";
LABEL_11:
        log_OutText(v26, (uint64_t)"FastInfer", 0, 0, (uint64_t)v27, v16, v17, v18, v31);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_dec init param failed!", v28, v29, v30, v32);
        result = 7;
        goto LABEL_12;
      }
      *(_DWORD *)v33 = *a2;
      *(int8x16_t *)&v33[4] = vextq_s8(*(int8x16_t *)(a2 + 1), *(int8x16_t *)(a2 + 1), 0xCuLL);
      if (create_ffn_layer(a1, (int32x2_t *)v33, a3, a4, v19 + 9))
      {
        v25 = "create trans_dec ffn layer failed!";
        goto LABEL_8;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 37;
      *(_QWORD *)(v7 + 128) = forward_trans_dec_layer;
      *(_QWORD *)(v7 + 136) = free_trans_dec_layer;
      *(_QWORD *)(v7 + 144) = trans_dec_layer_update_shape;
      *(_QWORD *)(v7 + 152) = trans_dec_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = trans_dec_request_glbBuf;
      *(_QWORD *)(v7 + 168) = trans_dec_assign_glbBuf;
      *(_QWORD *)(v7 + 176) = trans_dec_layer_reset;
      *(_QWORD *)(v7 + 184) = trans_dec_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v21, v22, v23, v31);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v31);
      result = 10;
    }
  }
LABEL_12:
  *a5 = v7;
  return result;
}

uint64_t forward_trans_dec_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t *v7;
  _QWORD *v8;
  uint64_t bytes;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v16;
  size_t __len;

  LODWORD(__len) = 0;
  if (!a2)
    return 0;
  v7 = *(uint64_t **)a2;
  v8 = *(_QWORD **)(a2 + 120);
  bytes = fi_shape_get_bytes((int *)(v8[7] + 40), &__len);
  if (!(_DWORD)bytes)
  {
    cstdlib_memset(*(void **)(a2 + 240), 0, (2 * __len));
    v10 = (*(uint64_t (**)(uint64_t))(v8[7] + 128))(a1);
    if ((_DWORD)v10 || (v10 = (*(uint64_t (**)(uint64_t))(v8[8] + 128))(a1), (_DWORD)v10))
    {
      bytes = v10;
      v14 = "trans_dec forward att layer failed!";
LABEL_6:
      log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, v11, v12, v13, v16);
      return bytes;
    }
    bytes = fi_shape_get_bytes((int *)(v8[9] + 40), &__len);
    if (!(_DWORD)bytes)
    {
      cstdlib_memset(a4, 0, __len);
      bytes = (*(uint64_t (**)(uint64_t))(v8[9] + 128))(a1);
      if ((_DWORD)bytes)
      {
        v14 = "trans_dec forward ffn layer failed!";
        goto LABEL_6;
      }
    }
  }
  return bytes;
}

_QWORD *free_trans_dec_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[9]);
        fi_layer_free(v3[7]);
        fi_layer_free(v3[8]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t trans_dec_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  _QWORD *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t result;
  uint64_t v12;
  const void *v13;
  int v14;
  uint64_t v15;
  _QWORD __dst[2];
  int v17;

  v4 = *(_QWORD **)(a1 + 120);
  __dst[0] = 0;
  __dst[1] = 0;
  v17 = 0;
  v5 = *(uint64_t **)a1;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  cstdlib_memcpy(__dst, a2, 0x14uLL);
  HIDWORD(__dst[0]) = 1;
  if (*a2 >= 3u)
  {
    v9 = *v5;
    v10 = "Currently trans_dec layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v10, v6, v7, v8, v15);
    return 7;
  }
  result = (*(uint64_t (**)(void))(v4[7] + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(v4[8] + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(v4[9] + 144))();
      if (!(_DWORD)result)
      {
        v12 = v4[9];
        v14 = *(_DWORD *)(v12 + 40);
        v13 = (const void *)(v12 + 40);
        if ((v14 - 1) >= 2)
        {
          v9 = **(_QWORD **)a1;
          v10 = "dense out: output shape error";
          goto LABEL_3;
        }
        cstdlib_memcpy((void *)(a1 + 40), v13, 0x14uLL);
        return 0;
      }
    }
  }
  return result;
}

uint64_t trans_dec_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v6 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v6[7] + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(v6[8] + 152))();
    if (!(_DWORD)result)
    {
      v9 = get_padded_bytes(padded_bytes, 8u);
      result = (*(uint64_t (**)(void))(v6[9] + 152))();
      if (!(_DWORD)result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v10, v11, v12, *(unsigned int *)(a1 + 96));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v13, v14, v15, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t trans_dec_request_glbBuf(uint64_t a1)
{
  _QWORD *v2;
  uint64_t result;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  v2 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v2[7] + 160))();
  if (!(_DWORD)result)
  {
    v4 = *(_DWORD *)(v2[7] + 248);
    result = (*(uint64_t (**)(void))(v2[8] + 160))();
    if (!(_DWORD)result)
    {
      v5 = *(_DWORD *)(v2[8] + 248);
      result = (*(uint64_t (**)(void))(v2[9] + 160))();
      if (!(_DWORD)result)
      {
        v6 = *(_DWORD *)(v2[9] + 248);
        v8 = v6;
        result = trans_dec_get_reserved_glbBuf_bytes(a1, &v8);
        if (!(_DWORD)result)
        {
          if (v5 <= v4)
            v7 = v4;
          else
            v7 = v5;
          if (v6 > v7)
            v7 = v6;
          *(_DWORD *)(a1 + 248) = v8 + v7;
        }
      }
    }
  }
  return result;
}

uint64_t trans_dec_assign_glbBuf(uint64_t a1)
{
  _QWORD *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;

  v2 = *(_QWORD **)(a1 + 120);
  v8 = 0;
  result = trans_dec_get_reserved_glbBuf_bytes(a1, &v8);
  if (!(_DWORD)result)
  {
    v4 = v8;
    v5 = v2[7];
    v6 = v2[8];
    *(_QWORD *)(v5 + 240) = *(_QWORD *)(a1 + 240) + v8;
    *(_DWORD *)(v5 + 248) = *(_DWORD *)(a1 + 248) - v4;
    *(_QWORD *)(v6 + 240) = *(_QWORD *)(a1 + 240) + v4;
    *(_DWORD *)(v6 + 248) = *(_DWORD *)(a1 + 248) - v4;
    v7 = v2[9];
    *(_QWORD *)(v7 + 240) = *(_QWORD *)(a1 + 240) + v4;
    *(_DWORD *)(v7 + 248) = *(_DWORD *)(a1 + 248) - v4;
  }
  return result;
}

uint64_t trans_dec_layer_reset(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 120);
  if ((*(unsigned int (**)(void))(*(_QWORD *)(v2 + 56) + 176))()
    || (result = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 64) + 176))(), (_DWORD)result))
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_dec network reset failed!", v3, v4, v5, v7);
    return 7;
  }
  return result;
}

uint64_t trans_dec_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t trans_dec_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t bytes;
  int v6;

  v3 = *(_QWORD *)(a1 + 120);
  v6 = 0;
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 56) + 40), &v6);
  if (!(_DWORD)bytes)
    *a2 = get_padded_bytes(2 * v6, 8u);
  return bytes;
}

uint64_t create_att_layer(uint64_t *a1, unsigned int *a2, const void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int padded_len;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  int v36;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 160);
      v19 = v15;
      if (!v15)
      {
        v25 = *a1;
        v26 = "out of memory!";
        goto LABEL_9;
      }
      cstdlib_memcpy(v15, a2, 0x40uLL);
      v36 = 0;
      *((_DWORD *)v19 + 38) = 0;
      padded_len = get_padded_len(*a2, 8u);
      v21 = *a2;
      HIDWORD(v34) = 40;
      v35 = v21;
      if (create_norm_layer(a1, (char *)&v34 + 4, (_QWORD *)v19 + 8))
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create att norm layer failed!", v22, v23, v24, v34);
        v25 = *a1;
        v26 = "att network init failed!";
LABEL_9:
        log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v16, v17, v18, v34);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att init param failed!", v27, v28, v29, v34);
        result = 7;
        goto LABEL_10;
      }
      cstdlib_memset((char *)&v34 + 4, 0, 0xCuLL);
      HIDWORD(v34) = 5;
      v35 = padded_len;
      *(_OWORD *)(v19 + 120) = 0u;
      *(_OWORD *)(v19 + 136) = 0u;
      if (a2[2])
      {
        v33 = a2[5];
        if (v33 == 1)
        {
          if (!a2[14])
          {
            *((_QWORD *)v19 + 17) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
            *((_QWORD *)v19 + 18) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
          }
        }
        else if (!v33 && !a2[14])
        {
          *((_QWORD *)v19 + 15) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
          *((_QWORD *)v19 + 16) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
        }
      }
      *((_DWORD *)v19 + 28) = 0;
      if (!*((_QWORD *)a2 + 6))
        *((_QWORD *)v19 + 13) = 0;
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_att_layer;
      *(_QWORD *)(v7 + 136) = free_att_layer;
      *(_QWORD *)(v7 + 8) = 34;
      *(_QWORD *)(v7 + 144) = att_layer_update_shape;
      *(_QWORD *)(v7 + 152) = att_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = att_request_glbBuf;
      *(_QWORD *)(v7 + 176) = att_layer_reset;
      *(_QWORD *)(v7 + 184) = att_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v30, v31, v32, v34);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v34);
      result = 10;
    }
  }
LABEL_10:
  *a5 = v7;
  return result;
}

uint64_t forward_att_layer(uint64_t a1, uint64_t a2, void *a3, float32x4_t *a4)
{
  uint64_t *v7;
  unsigned int *v8;
  uint64_t step;
  unsigned int v10;
  uint64_t padded_len;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  BOOL v21;
  unsigned int v22;
  float32x4_t *v23;
  float32x4_t *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float *v32;
  float32x4_t *v33;
  float32x4_t *v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  int v42;
  uint64_t v43;
  BOOL v44;
  float32x4_t *v45;
  float32x4_t *v46;
  uint64_t v47;
  size_t v48;
  float32x4_t *v49;
  uint64_t v50;
  char *v51;
  int v52;
  int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v60;
  unsigned int v61;
  float32x4_t *v62;
  int v63;
  unsigned int *v64;
  uint64_t __len;
  unsigned int v66;
  unsigned int v67;
  float32x4_t *v68;
  unsigned int v69;
  uint64_t v70;
  void *__src;
  char *v72;
  float32x4_t *__b;
  float *__ba;
  float32x4_t *v75;
  int v76;
  int v77;
  float32x4_t *v78;
  float32x4_t *v79;
  unsigned int v81;
  uint64_t *v82;

  if (!a2)
    return 0;
  v7 = *(uint64_t **)a2;
  v8 = *(unsigned int **)(a2 + 120);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  v10 = step;
  padded_len = get_padded_len(step, 8u);
  v12 = *v8;
  v13 = get_padded_len(*v8, 8u);
  v14 = v8[3];
  v15 = get_padded_len(v14, 8u);
  v19 = v8[5];
  v20 = v8[2];
  if (v20)
    v21 = 0;
  else
    v21 = v19 == 1;
  if (v21)
  {
    log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"encoder decoder attention is possible only if isDecoder option has been set to 1", v16, v17, v18, v60);
    return 7;
  }
  v81 = v10;
  v70 = v8[1];
  __src = a3;
  v82 = v7;
  v69 = v8[5];
  v67 = v12;
  v76 = v15;
  if (v19 == 1)
  {
    v22 = fi_shape_get_step(v8 + 7);
    v23 = *(float32x4_t **)(a2 + 240);
    if (v8[2])
    {
      v78 = (float32x4_t *)*((_QWORD *)v8 + 17);
      v24 = (float32x4_t *)*((_QWORD *)v8 + 18);
LABEL_13:
      v68 = v24;
      __b = v23;
      v26 = v10;
      v27 = v13;
      goto LABEL_15;
    }
  }
  else
  {
    v22 = v10 + v10 * v8[38];
    v23 = *(float32x4_t **)(a2 + 240);
    if (v20)
    {
      v78 = (float32x4_t *)*((_QWORD *)v8 + 15);
      v24 = (float32x4_t *)*((_QWORD *)v8 + 16);
      goto LABEL_13;
    }
  }
  v27 = v13;
  v26 = v10;
  cstdlib_memset(&v23->f32[v13 * v10], 0, 4 * v13 * v10);
  v68 = 0;
  v78 = (float32x4_t *)((char *)v23 + 4 * v13 * v10);
  __b = v78;
LABEL_15:
  cstdlib_memset(v23, 0, 4 * (v27 * v26));
  v28 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v8 + 8) + 128))(a1);
  if ((_DWORD)v28)
  {
    v25 = v28;
    log_OutText(*v82, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att forward norm layer failed!", v29, v30, v31, v60);
  }
  else
  {
    v77 = v76 * v14;
    v32 = &__b->f32[(v27 * v26)];
    cstdlib_memset(a4, 0, 4 * (v27 * v26));
    gemm_v2((uint64_t)v82, 0, v26, v27, v27, (uint64_t)v23, v27, *((_QWORD *)v8 + 10), v27, a4, v27);
    __len = 4 * (v27 * v26);
    __ba = v32;
    v75 = v23;
    if (v69 == 1)
    {
      v34 = (float32x4_t *)*((_QWORD *)v8 + 17);
      v33 = (float32x4_t *)*((_QWORD *)v8 + 18);
      v35 = v70;
      v68 = v33;
      if (!v8[28])
      {
        cstdlib_memset(v34, 0, 4 * v22 * v27);
        cstdlib_memset(v33, 0, 4 * v22 * v27);
        gemm_v2((uint64_t)v82, 0, v22, v27, v27, *((_QWORD *)v8 + 13), v27, *((_QWORD *)v8 + 9), v27, v34, v27);
        gemm_v2((uint64_t)v82, 0, v22, v27, v27, *((_QWORD *)v8 + 13), v27, *((_QWORD *)v8 + 11), v27, v33, v27);
        v8[28] = 1;
      }
      v36 = v77;
    }
    else
    {
      v34 = v78;
      cstdlib_memset(&v78->f32[v8[38] * v27], 0, 4 * (v27 * v26));
      gemm_v2((uint64_t)v82, 0, v26, v27, v27, (uint64_t)v23, v27, *((_QWORD *)v8 + 9), v27, (float32x4_t *)((char *)v78 + 4 * v8[38] * v27), v27);
      v35 = v70;
      v36 = v77;
    }
    v66 = v27;
    v72 = (char *)&v32[v36];
    cstdlib_memset(v32, 0, 4 * (v36 + v36 * v35));
    v37 = v67 / v35;
    if (v35)
    {
      v38 = 0;
      v39 = 0;
      v79 = v34;
      v40 = v70;
      do
      {
        gemm_v2((uint64_t)v82, 1, v81, v22, v37, (uint64_t)a4->i64 + 4 * (v37 * v39), v27, (uint64_t)v79->i64 + 4 * (v37 * v39), v27, (float32x4_t *)&__ba[v38], padded_len);
        ++v39;
        v38 += v77;
        --v40;
      }
      while (v40);
      v41 = v70 - 1;
      if ((int)v70 - 1 >= 0)
      {
        do
        {
          if (v81)
          {
            v42 = 0;
            v43 = v81;
            do
            {
              softmax(&__ba[v41 * v77 + v42], v22, 1, (float *)&v72[4 * v41 * v77 + 4 * v42], *((float *)v8 + 6));
              v42 += padded_len;
              --v43;
            }
            while (v43);
          }
          v44 = __OFSUB__(v41--, 1);
        }
        while (v41 < 0 == v44);
      }
    }
    v64 = v8;
    if (v69)
    {
      v45 = v68;
      v46 = v75;
      v47 = v70;
      v48 = __len;
    }
    else
    {
      v49 = v68;
      if (!v8[2])
        v49 = a4;
      v48 = __len;
      cstdlib_memset(&v49->f32[v8[38] * v66], 0, __len);
      v45 = v49;
      v46 = v75;
      gemm_v2((uint64_t)v82, 0, v81, v66, v66, (uint64_t)v75, v66, *((_QWORD *)v8 + 11), v66, (float32x4_t *)((char *)v49 + 4 * v8[38] * v66), v66);
      v47 = v70;
    }
    cstdlib_memset(v46, 0, v48);
    v50 = v66;
    v51 = v72;
    if ((_DWORD)v47)
    {
      v52 = 0;
      v53 = 0;
      do
      {
        v54 = (uint64_t)v45->i64 + 4 * (v37 * v53);
        v63 = v50;
        v61 = v50;
        v62 = (float32x4_t *)((char *)v75 + 4 * (v37 * v53));
        v55 = v37;
        v56 = v50;
        v57 = v37;
        v58 = v51;
        gemm_v2((uint64_t)v82, 0, v81, v55, v22, (uint64_t)&v51[4 * v52], padded_len, v54, v61, v62, v63);
        v51 = v58;
        v37 = v57;
        v50 = v56;
        ++v53;
        v52 += v77;
        --v47;
      }
      while (v47);
    }
    cstdlib_memcpy(a4, __src, __len);
    gemm_v2((uint64_t)v82, 0, v81, v50, v50, (uint64_t)v75, v50, *((_QWORD *)v64 + 12), v50, a4, v50);
    v25 = 0;
    ++v64[38];
  }
  return v25;
}

_QWORD *free_att_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  _QWORD *v5;

  if (!result)
    return result;
  v1 = result;
  v2 = *result;
  if (!*result)
    return result;
  v3 = result[15];
  if (v3)
  {
    fi_layer_free(*(_QWORD *)(v3 + 64));
    if (*(_QWORD *)(v3 + 48))
    {
      if (!*(_QWORD *)(v3 + 104))
        goto LABEL_8;
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
    }
    *(_QWORD *)(v3 + 104) = 0;
LABEL_8:
    if (*(_DWORD *)(v3 + 8))
    {
      v4 = *(_DWORD *)(v3 + 20);
      if (v4 == 1)
      {
        if (*(_DWORD *)(v3 + 56))
          goto LABEL_22;
        if (*(_QWORD *)(v3 + 136))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 136) = 0;
        }
        v5 = (_QWORD *)(v3 + 144);
        if (!*(_QWORD *)(v3 + 144))
          goto LABEL_22;
      }
      else
      {
        if (v4 || *(_DWORD *)(v3 + 56))
          goto LABEL_22;
        if (*(_QWORD *)(v3 + 120))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 120) = 0;
        }
        v5 = (_QWORD *)(v3 + 128);
        if (!*(_QWORD *)(v3 + 128))
          goto LABEL_22;
      }
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      *v5 = 0;
    }
LABEL_22:
    (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
  }
  if (*((_DWORD *)v1 + 29))
  {
    if (v1[9])
    {
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      v1[9] = 0;
    }
    cstdlib_memset(v1 + 9, 0, 0x30uLL);
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
}

uint64_t att_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  uint64_t v9;
  const char *v10;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v8 = *(uint64_t **)a1;
  if (*a2 >= 3u)
  {
    v9 = *v8;
    v10 = "Currently att layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v10, a6, a7, a8, v15);
    return 7;
  }
  v13 = *(_QWORD *)(a1 + 120);
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v13 + 64) + 144))();
  if (!(_DWORD)result)
  {
    v14 = *(_QWORD *)(v13 + 64);
    if (*(_DWORD *)(v13 + 20) == 1)
    {
      *(_DWORD *)(v13 + 28) = 2;
      if (!v14)
      {
        v9 = *v8;
        v10 = "Must set external pointers before shape update for enc_dec att.";
        goto LABEL_3;
      }
    }
    cstdlib_memcpy((void *)(a1 + 40), (const void *)(v14 + 40), 0x14uLL);
    return 0;
  }
  return result;
}

uint64_t att_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int *v6;
  uint64_t v7;
  int padded_bytes;
  uint64_t padded_len;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v6 = *(unsigned int **)(a1 + 120);
  v7 = (*(uint64_t (**)(void))(*((_QWORD *)v6 + 8) + 152))();
  if (!(_DWORD)v7)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    padded_len = get_padded_len(*v6, 8u);
    *a2 = padded_bytes + 16 * padded_len * padded_len;
    *a3 = 0;
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"att k kernel size: %d\n", v10, v11, v12, padded_len);
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
  }
  return v7;
}

uint64_t att_request_glbBuf(uint64_t a1)
{
  _DWORD *v2;
  int v3;
  int *v4;
  unsigned int step;
  uint64_t v6;
  uint64_t result;
  int padded_len;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  int v14;
  int v15;
  int padded_bytes;
  uint64_t v17;
  unsigned int v18;

  v2 = *(_DWORD **)(a1 + 120);
  v3 = v2[1];
  v4 = (int *)(a1 + 20);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v6 = v2[3];
  v18 = 0;
  result = fi_shape_get_input_dim(v4, (int *)&v18);
  if (!(_DWORD)result)
  {
    padded_len = get_padded_len(v18, 8u);
    if (v18 != *v2)
    {
      v12 = **(_QWORD **)a1;
      v13 = "att input sample dim mismatch! inshape: %d, but config: %d";
      v17 = v18;
      goto LABEL_6;
    }
    if (step > v6)
    {
      v12 = **(_QWORD **)a1;
      v13 = "att: input len longer than maximum!";
LABEL_6:
      log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, v9, v10, v11, v17);
      return 7;
    }
    v14 = (padded_len * (_DWORD)v6) << (v2[2] == 0);
    v15 = get_padded_len(v6, 8u);
    padded_bytes = get_padded_bytes(4 * (v14 + ((int)v6 + (int)v6 * v3) * v15), 8u);
    result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes;
  }
  return result;
}

uint64_t att_dispatch_weights(uint64_t a1)
{
  uint64_t *v2;
  int padded_len;
  uint64_t v4;
  uint64_t weights_via_offset;
  unsigned int padded_bytes;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v12;

  v12 = 0;
  v2 = *(uint64_t **)(a1 + 120);
  padded_len = get_padded_len(*(unsigned int *)v2, 8u);
  v4 = *(_QWORD *)(a1 + 72);
  weights_via_offset = fi_layer_find_weights_via_offset(v2[8], v4, &v12);
  if (!(_DWORD)weights_via_offset)
  {
    padded_bytes = get_padded_bytes(v12, 8u);
    v2[9] = v4 + padded_bytes;
    v7 = padded_len * padded_len;
    v12 = padded_bytes + 4 * v7;
    v8 = get_padded_bytes(v12, 8u);
    v2[12] = v4 + v8;
    v12 = v8 + 4 * v7;
    v9 = get_padded_bytes(v12, 8u);
    v2[10] = v4 + v9;
    v12 = v9 + 4 * v7;
    v10 = get_padded_bytes(v12, 8u);
    v2[11] = v4 + v10;
    v12 = v10 + 4 * v7;
    get_padded_bytes(v12, 8u);
  }
  return weights_via_offset;
}

uint64_t att_layer_reset(uint64_t a1)
{
  uint64_t v1;

  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 120);
    if (*(_DWORD *)(v1 + 20) == 1)
    {
      *(_QWORD *)(v1 + 104) = 0;
      *(_DWORD *)(v1 + 112) = 0;
      *(_OWORD *)(v1 + 120) = 0u;
      *(_OWORD *)(v1 + 136) = 0u;
    }
  }
  return 0;
}

uint64_t att_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t config_conv1d_layer(int a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8)
{
  return config_conv_layer(a1, a2, 0, a3, 0, a4, a5, a6, a7, a8);
}

uint64_t create_conv1d_layer(uint64_t *a1, const void *a2, const void *a3, uint64_t a4, uint64_t ***a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t **v12;
  uint64_t v14;
  uint64_t **v15;

  v15 = 0;
  v11 = create_conv_layer(a1, a2, a3, &v15);
  if ((_DWORD)v11)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create conv layer failed!", v8, v9, v10, v14);
    v12 = v15;
  }
  else
  {
    v12 = v15;
    v15[1] = 0;
    v12[16] = (uint64_t *)forward_conv_layer;
    v12[17] = (uint64_t *)free_conv_buffer;
    v12[18] = (uint64_t *)conv1d_layer_update_shape;
    v12[19] = (uint64_t *)conv_layer_wanted_wb_len;
    if (a4)
    {
      v12[32] = *(uint64_t **)(a4 + 24);
      *((_DWORD *)v12 + 66) = *(_DWORD *)(a4 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v8, v9, v10, v14);
      v12 = v15;
      v15[32] = 0;
      *((_DWORD *)v12 + 66) = 0;
    }
  }
  *a5 = v12;
  return v11;
}

uint64_t conv1d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v10;
  uint64_t result;
  int v12;
  uint64_t v13;

  if (*a2 == 2)
  {
    v10 = *(_DWORD **)(a1 + 120);
    cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
    v10[1] = a2[2];
    v10[3] = 1;
    result = get_padding_size(*(uint64_t **)a1, v10, *(_DWORD *)(a1 + 8), a2, v10 + 14, v10 + 15, v10 + 9);
    v12 = v10[14] * v10[15];
    *(_DWORD *)(a1 + 40) = 2;
    *(_DWORD *)(a1 + 44) = v12;
    *(_DWORD *)(a1 + 48) = v10[4];
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d requires input 2D input data", a6, a7, a8, v13);
    return 7;
  }
  return result;
}

uint64_t create_pooling2d_layer(uint64_t *a1, int a2, const void *a3, const void *a4, uint64_t ***a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t **v11;
  uint64_t v13;
  uint64_t **v14;

  v14 = 0;
  v10 = create_pooling_layer(a1, a2, a3, a4, &v14);
  if ((_DWORD)v10)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create pooling layer failed!", v7, v8, v9, v13);
    v11 = v14;
  }
  else
  {
    v11 = v14;
    v14[18] = (uint64_t *)pooling2d_layer_update_shape;
  }
  *a5 = v11;
  return v10;
}

uint64_t pooling2d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v10;
  int v11;
  uint64_t result;
  int channel;
  uint64_t v14;

  if (*a2 == 3)
  {
    v10 = *(_DWORD **)(a1 + 120);
    v11 = *(_DWORD *)(a1 + 8);
    cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
    if ((v11 & 0xFFFFFFFE) == 0x12)
    {
      *v10 = a2[2];
      v10[1] = a2[3];
    }
    result = get_padding_size(*(uint64_t **)a1, v10, v11, a2, v10 + 14, v10 + 15, v10 + 9);
    if (!(_DWORD)result)
    {
      *(_DWORD *)(a1 + 40) = 3;
      channel = fi_shape_get_channel(a2);
      result = 0;
      *(_DWORD *)(a1 + 44) = channel;
      *(_DWORD *)(a1 + 48) = v10[15];
      *(_DWORD *)(a1 + 52) = v10[14];
      *(_DWORD *)(a1 + 56) = a2[4];
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Current conv layer only support input dim 2 or 3", a6, a7, a8, v14);
    return 7;
  }
  return result;
}

uint64_t forward_mulaw_layer(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t size;
  uint64_t v12;
  float v13;
  uint64_t v15;
  unsigned int v16;

  v16 = 0;
  v7 = *(_QWORD *)(a2 + 72);
  size = fi_shape_get_size((int *)(a2 + 40), (int *)&v16);
  if ((_DWORD)size)
  {
    log_OutText(**(_QWORD **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"input shape of mulaw layer is illegal", v8, v9, v10, v15);
  }
  else
  {
    v12 = v16;
    if (v16)
    {
      do
      {
        v13 = *a3++;
        *a4++ = (float)*(int *)(v7 + 4 * v13);
        --v12;
      }
      while (v12);
    }
  }
  return size;
}

_QWORD *free_mulaw_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_mulaw_layer(uint64_t *a1, const void *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;

  v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4);
  if (v6
    && (v10 = (void *)v6,
        (v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272)) != 0))
  {
    v12 = v11;
    cstdlib_memcpy(v10, a2, 4uLL);
    result = 0;
    *(_QWORD *)v12 = a1;
    *(_DWORD *)(v12 + 8) = 32;
    *(_QWORD *)(v12 + 120) = v10;
    *(_QWORD *)(v12 + 128) = forward_mulaw_layer;
    *(_QWORD *)(v12 + 136) = free_mulaw_buffer;
    *(_QWORD *)(v12 + 144) = mulaw_layer_update_shape;
    *(_QWORD *)(v12 + 152) = mulaw_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v14);
    free_mulaw_buffer(0);
    v12 = 0;
    result = 10;
  }
  *a3 = v12;
  return result;
}

uint64_t mulaw_layer_update_shape(uint64_t **a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;

  if (a2)
  {
    cstdlib_memcpy((char *)a1 + 20, a2, 0x14uLL);
    cstdlib_memcpy(a1 + 5, a2, 0x14uLL);
    return 0;
  }
  else
  {
    log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"mulaw layer cant accept this input shape", a6, a7, a8, v11);
    return 7;
  }
}

uint64_t mulaw_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v8 = **(unsigned int **)(a1 + 120);
  if (v8 > 0x20)
    return 7;
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"mu-law bits: %d\n", a6, a7, a8, v8);
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
  *a2 = 4 << v8;
  *a3 = 0;
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbBytes bBytes: %d %d\n", v16, v17, v18, *a2);
  return 0;
}

uint64_t create_albert_ffn_layer(uint64_t *a1, int32x2_t *a2, const void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  __int32 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  __int32 v27;
  __int32 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int32x2_t v34;
  int __b;
  __int32 v36;
  int v37;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 48);
      v19 = v15;
      if (!v15)
      {
        v25 = *a1;
        v26 = "out of memory!";
LABEL_14:
        log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v16, v17, v18, v32);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_ffn init param failed!", v29, v30, v31, v33);
        result = 7;
        goto LABEL_15;
      }
      cstdlib_memcpy(v15, a2, 0x14uLL);
      v20 = a2->i32[1];
      __b = 40;
      v36 = v20;
      v37 = 0;
      if (create_norm_layer(a1, &__b, v19 + 3))
      {
        v24 = "create albert_ffn norm layer failed!";
LABEL_13:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v24, v21, v22, v23, v32);
        v25 = *a1;
        v26 = "albert_ffn network init failed!";
        goto LABEL_14;
      }
      cstdlib_memset(&__b, 0, 0xCuLL);
      v27 = a2->i32[0];
      __b = 5;
      v36 = v27;
      v34 = vrev64_s32(a2[1]);
      if (create_fc_layer(a1, &__b, &v34, a3, a4, v19 + 4))
      {
        v24 = "create albert_ffn o1 dense layer failed!";
        goto LABEL_13;
      }
      cstdlib_memset(&__b, 0, 0xCuLL);
      v28 = a2->i32[1];
      __b = 5;
      v36 = v28;
      v34.i32[0] = a2[2].i32[0];
      if (create_fc_layer(a1, &__b, &v34, a3, a4, v19 + 5))
      {
        v24 = "create albert_ffn o2 dense layer failed!";
        goto LABEL_13;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 44;
      *(_QWORD *)(v7 + 128) = forward_albert_ffn_layer;
      *(_QWORD *)(v7 + 136) = free_albert_ffn_layer;
      *(_QWORD *)(v7 + 144) = albert_ffn_layer_update_shape;
      *(_QWORD *)(v7 + 152) = albert_ffn_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = albert_ffn_request_glbBuf;
      *(_QWORD *)(v7 + 184) = albert_ffn_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v21, v22, v23, v32);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v32);
      result = 10;
    }
  }
LABEL_15:
  *a5 = v7;
  return result;
}

uint64_t forward_albert_ffn_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t *v7;
  unsigned int *v8;
  int step;
  uint64_t v10;
  char *v11;
  int padded_len;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;

  if (!a2)
    return 0;
  v7 = *(uint64_t **)a2;
  v8 = *(unsigned int **)(a2 + 120);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  v10 = v8[1];
  v11 = *(char **)(a2 + 240);
  padded_len = get_padded_len(v10, 8u);
  v13 = get_padded_len(v10, 8u);
  cstdlib_memset(v11, 0, 4 * (v13 * step));
  v14 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v8 + 3) + 128))(a1);
  if ((_DWORD)v14)
  {
    v18 = v14;
    v19 = *v7;
    v20 = "albert_ffn forward norm layer failed!";
  }
  else
  {
    v21 = get_padded_len(*v8, 8u);
    cstdlib_memset(&v11[4 * padded_len * step], 0, 4 * (v21 * step));
    v22 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v8 + 4) + 128))(a1);
    if ((_DWORD)v22)
    {
      v18 = v22;
      v19 = *v7;
      v20 = "albert_ffn forward dense o1 failed!";
    }
    else
    {
      v23 = (v10 * step);
      cstdlib_memset(a4, 0, 4 * v23);
      v18 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v8 + 5) + 128))(a1);
      if (!(_DWORD)v18)
      {
        axpy(v23, (float *)v11, 1, (float *)a4, 1, 1.0);
        return v18;
      }
      v19 = *v7;
      v20 = "albert_ffn forward dense o2 layer failed!";
    }
  }
  log_OutText(v19, (uint64_t)"FastInfer", 0, 0, (uint64_t)v20, v15, v16, v17, v25);
  return v18;
}

_QWORD *free_albert_ffn_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[3]);
        fi_layer_free(v3[4]);
        fi_layer_free(v3[5]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t albert_ffn_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t result;
  uint64_t v11;
  const void *v12;
  unsigned int v13;
  uint64_t v14;

  v4 = *(_QWORD **)(a1 + 120);
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 >= 3u)
  {
    v8 = **(_QWORD **)a1;
    v9 = "Currently albert_ffn layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)v9, v5, v6, v7, v14);
    return 7;
  }
  result = (*(uint64_t (**)(void))(v4[3] + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(v4[4] + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(v4[5] + 144))();
      if (!(_DWORD)result)
      {
        v11 = v4[5];
        v13 = *(_DWORD *)(v11 + 40);
        v12 = (const void *)(v11 + 40);
        if (v13 >= 3)
        {
          v8 = **(_QWORD **)a1;
          v9 = "o2 output shape error: Currently albert_ffn layer only support 1D or 2D output";
          goto LABEL_3;
        }
        cstdlib_memcpy((void *)(a1 + 40), v12, 0x14uLL);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_ffn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v6 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v6[3] + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(v6[4] + 152))();
    if (!(_DWORD)result)
    {
      v9 = get_padded_bytes(padded_bytes, 8u);
      result = (*(uint64_t (**)(void))(v6[5] + 152))();
      if (!(_DWORD)result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"albert_ffn filter size: %d\n", v10, v11, v12, *(unsigned int *)(v6[4] + 12));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_ffn_request_glbBuf(uint64_t a1)
{
  unsigned int *v2;
  int *v3;
  int step;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int padded_len;
  int v10;
  int padded_bytes;
  uint64_t v12;
  unsigned int v13;

  v2 = *(unsigned int **)(a1 + 120);
  v3 = (int *)(a1 + 20);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v13 = 0;
  result = fi_shape_get_input_dim(v3, (int *)&v13);
  if (!(_DWORD)result)
  {
    if (v13 == v2[1])
    {
      padded_len = get_padded_len(v13, 8u);
      v10 = get_padded_len(*v2, 8u);
      padded_bytes = get_padded_bytes(4 * step * (v10 + padded_len), 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes;
    }
    else
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_ffn: input sample dim mismatch!", v6, v7, v8, v12);
      return 7;
    }
  }
  return result;
}

uint64_t albert_ffn_dispatch_weights(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(uint64_t **)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(v1[3], v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(v1[4], v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(v1[5], v2, &padded_bytes);
      if (!(_DWORD)result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_trans_enc_dispatch_weights(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(uint64_t **)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(v1[6], v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(v1[7], v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(v1[8], v2, &padded_bytes);
      if (!(_DWORD)result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

_QWORD *free_albert_trans_enc_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[7]);
        fi_layer_free(v3[6]);
        fi_layer_free(v3[8]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_albert_trans_enc_layer(uint64_t *a1, int32x4_t *a2, const void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned __int32 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  __int128 v29;
  __int32 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  __int128 v36;
  __int32 v37;
  unsigned int v38[4];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 72);
      v19 = v15;
      if (!v15)
      {
        v27 = *a1;
        v28 = "out of memory!";
LABEL_14:
        log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v16, v17, v18, v34);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert trans_enc init param failed!", v31, v32, v33, v34);
        result = 7;
        goto LABEL_15;
      }
      cstdlib_memcpy(v15, a2, 0x30uLL);
      v41 = 0u;
      v40 = 0u;
      v39 = 0u;
      v35 = 0;
      v34 = 0;
      v21 = a2[1].u32[2];
      v20 = a2[1].u32[3];
      v38[2] = 0;
      v38[3] = v20;
      v38[0] = a2->i32[0];
      v38[1] = v21;
      v22 = a2->u32[2];
      DWORD1(v39) = 0;
      *((_QWORD *)&v39 + 1) = v22;
      LODWORD(v40) = a2[2].i32[0];
      *((_QWORD *)&v41 + 1) = 0;
      v42 = 0;
      if (create_att_albert_layer(a1, v38, a3, a4, v19 + 6))
      {
        v26 = "create albert trans_enc att layer failed!";
LABEL_13:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v34);
        v27 = *a1;
        v28 = "albert trans_enc network init failed!";
        goto LABEL_14;
      }
      v37 = a2[1].i32[0];
      *(_QWORD *)&v29 = vrev64q_s32(*a2).u64[0];
      *((_QWORD *)&v29 + 1) = a2->i64[1];
      v36 = v29;
      if (create_albert_ffn_layer(a1, (int32x2_t *)&v36, a3, a4, v19 + 7))
      {
        v26 = "create albert trans_enc ffn layer failed!";
        goto LABEL_13;
      }
      v30 = a2[1].i32[1];
      LODWORD(v34) = 40;
      HIDWORD(v34) = v30;
      if (create_norm_layer(a1, &v34, v19 + 8))
      {
        v26 = "create albert trans_enc norm layer failed!";
        goto LABEL_13;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 42;
      *(_QWORD *)(v7 + 128) = forward_albert_trans_enc_layer;
      *(_QWORD *)(v7 + 136) = free_albert_trans_enc_layer;
      *(_QWORD *)(v7 + 144) = albert_trans_enc_layer_update_shape;
      *(_QWORD *)(v7 + 152) = albert_trans_enc_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = albert_trans_enc_request_glbBuf;
      *(_QWORD *)(v7 + 168) = albert_trans_enc_assign_glbBuf;
      *(_QWORD *)(v7 + 176) = albert_trans_enc_layer_reset;
      *(_QWORD *)(v7 + 184) = albert_trans_enc_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v23, v24, v25, v34);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v34);
      result = 10;
    }
  }
LABEL_15:
  *a5 = v7;
  return result;
}

uint64_t forward_albert_trans_enc_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t *v6;
  _QWORD *v7;
  char *v8;
  uint64_t v9;
  uint64_t bytes;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  int padded_bytes;
  uint64_t v18;
  uint64_t v19;
  size_t __len;

  LODWORD(__len) = 0;
  if (!a2)
    return 0;
  v6 = *(uint64_t **)a2;
  v7 = *(_QWORD **)(a2 + 120);
  v8 = *(char **)(a2 + 240);
  v9 = v7[6];
  *(_DWORD *)(*(_QWORD *)(v9 + 120) + 192) = 0;
  bytes = fi_shape_get_bytes((int *)(v9 + 40), &__len);
  if (!(_DWORD)bytes)
  {
    cstdlib_memset(v8, 0, __len);
    v11 = (*(uint64_t (**)(uint64_t))(v7[6] + 128))(a1);
    if ((_DWORD)v11)
    {
      bytes = v11;
      v15 = "albert trans_enc forward att layer failed!";
    }
    else
    {
      padded_bytes = get_padded_bytes(__len, 8u);
      bytes = fi_shape_get_bytes((int *)(v7[7] + 40), &__len);
      if ((_DWORD)bytes)
        return bytes;
      cstdlib_memset(&v8[padded_bytes & 0xFFFFFFFC], 0, __len);
      v18 = (*(uint64_t (**)(uint64_t))(v7[7] + 128))(a1);
      if ((_DWORD)v18)
      {
        bytes = v18;
        v15 = "albert trans_enc forward ffn layer failed!";
      }
      else
      {
        cstdlib_memset(a4, 0, __len);
        bytes = (*(uint64_t (**)(uint64_t))(v7[8] + 128))(a1);
        if (!(_DWORD)bytes)
          return bytes;
        v15 = "albert trans_enc forward norm layer failed!";
      }
    }
    log_OutText(*v6, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, v12, v13, v14, v19);
  }
  return bytes;
}

uint64_t albert_trans_enc_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  _QWORD *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t result;
  uint64_t v12;

  v4 = *(_QWORD **)(a1 + 120);
  v5 = *(uint64_t **)a1;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 >= 3u)
  {
    v9 = *v5;
    v10 = "Currently albert trans_enc layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v10, v6, v7, v8, v12);
    return 7;
  }
  result = (*(uint64_t (**)(void))(v4[6] + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(v4[7] + 144))();
    if (!(_DWORD)result)
    {
      if ((*(_DWORD *)(v4[7] + 40) - 1) >= 2)
      {
        v9 = **(_QWORD **)a1;
        v10 = "dense out: output shape error";
        goto LABEL_3;
      }
      result = (*(uint64_t (**)(void))(v4[8] + 144))();
      if (!(_DWORD)result)
      {
        cstdlib_memcpy((void *)(a1 + 40), (const void *)(v4[8] + 40), 0x14uLL);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_trans_enc_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v6 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v6[6] + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(v6[7] + 152))();
    if (!(_DWORD)result)
    {
      v9 = get_padded_bytes(padded_bytes, 8u);
      result = (*(uint64_t (**)(void))(v6[8] + 152))();
      if (!(_DWORD)result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v10, v11, v12, *(unsigned int *)(a1 + 96));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v13, v14, v15, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_trans_enc_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  v2 = *(_QWORD *)(a1 + 120);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 48) + 160))();
  if (!(_DWORD)result)
  {
    v4 = *(_DWORD *)(*(_QWORD *)(v2 + 48) + 248);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 56) + 160))();
    if (!(_DWORD)result)
    {
      v5 = *(_DWORD *)(*(_QWORD *)(v2 + 56) + 248);
      v7 = v5;
      result = albert_trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
      if (!(_DWORD)result)
      {
        if (v5 <= v4)
          v6 = v4;
        else
          v6 = v5;
        *(_DWORD *)(a1 + 248) = v7 + v6;
      }
    }
  }
  return result;
}

uint64_t albert_trans_enc_assign_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;

  v2 = *(_QWORD *)(a1 + 120);
  v7 = 0;
  result = albert_trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
  if (!(_DWORD)result)
  {
    v4 = v7;
    v5 = *(_QWORD *)(v2 + 48);
    v6 = *(_QWORD *)(v2 + 56);
    *(_QWORD *)(v5 + 240) = *(_QWORD *)(a1 + 240) + v7;
    *(_DWORD *)(v5 + 248) = *(_DWORD *)(a1 + 248) - v4;
    *(_QWORD *)(v6 + 240) = *(_QWORD *)(a1 + 240) + v4;
    *(_DWORD *)(v6 + 248) = *(_DWORD *)(a1 + 248) - v4;
  }
  return result;
}

uint64_t albert_trans_enc_layer_reset(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 48) + 176))();
  if ((_DWORD)result)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert trans_enc network reset failed!", v3, v4, v5, v6);
    return 7;
  }
  return result;
}

uint64_t albert_trans_enc_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t albert_trans_enc_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t result;
  int padded_bytes;
  int v6;
  unsigned int v7;

  v3 = *(_QWORD *)(a1 + 120);
  v7 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 48) + 40), &v7);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(v7, 8u);
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 56) + 40), &v7);
    if (!(_DWORD)result)
    {
      v6 = get_padded_bytes(v7, 8u);
      result = 0;
      *a2 = v6 + padded_bytes;
    }
  }
  return result;
}

uint64_t tee_param_alloc_sources(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;

  v3 = *(unsigned int *)(a2 + 68);
  if ((_DWORD)v3)
  {
    v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 24 * v3);
    *(_QWORD *)(a2 + 72) = v5;
    if (v5)
    {
      return 0;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v10);
      return 10;
    }
  }
  else
  {
    result = 0;
    *(_QWORD *)(a2 + 72) = 0;
  }
  return result;
}

uint64_t config_tee_layer_param(uint64_t *a1, uint64_t a2, char *__s, int a4, int a5, const char *a6, uint64_t *a7, uint64_t a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  const char *v26;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  unsigned __int8 *v36;
  int v37;
  const char *v38;
  int v39;
  unsigned __int8 *v40;
  int v41;
  const char *v42;
  int v43;
  uint64_t v44;
  int *v45;
  int v46;
  uint64_t v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  size_t v53;
  const char *v54;
  char __dst[64];
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  if (cstdlib_strlen(__s) >= 0x40)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tee layer name is too long!", v16, v17, v18, v49);
    return 7;
  }
  cstdlib_strcpy((char *)a2, __s);
  *(_DWORD *)(a2 + 64) = a4;
  *(_DWORD *)(a2 + 68) = a5;
  v52 = a1;
  result = tee_param_alloc_sources(a1, a2);
  if (!(_DWORD)result)
  {
    if (!*(_DWORD *)(a2 + 68))
      return 0;
    v20 = 0;
    v50 = a2;
    v51 = a8;
    do
    {
      v21 = cstdlib_strlen(a6);
      v25 = *(unsigned __int8 *)a6;
      v26 = a6;
      if (*a6)
      {
        v26 = a6;
        do
        {
          if (v25 == 32)
            break;
          if (v25 == 91)
            break;
          if (v25 == 124)
            break;
          v27 = *(unsigned __int8 *)++v26;
          v25 = v27;
        }
        while (v27);
      }
      v28 = *(_QWORD *)(a2 + 72);
      v54 = v26;
      if ((unint64_t)(v26 - a6) >= 0x40)
      {
        v47 = *v52;
        v48 = "source layer name in '%s' is too long!";
        goto LABEL_51;
      }
      v53 = v21;
      v29 = (_QWORD *)(v28 + 24 * v20);
      cstdlib_memcpy(__dst, a6, v26 - a6);
      __dst[v26 - a6] = 0;
      *v29 = 0;
      if (!(_DWORD)a8)
      {
LABEL_45:
        log_OutText(*v52, (uint64_t)"FastInfer", 0, 0, (uint64_t)"source layer '%s' cannot be found!", v22, v23, v24, (uint64_t)__dst);
        return 7;
      }
      v30 = a8;
      v31 = a7;
      v32 = a7;
      v33 = v51;
      do
      {
        v34 = *v32;
        if (*(_DWORD *)(*v32 + 8) == 26 && !cstdlib_strcmp(__dst, *(const char **)(v34 + 120)))
        {
          *v29 = v34;
          a8 = v30;
          a7 = v31;
          goto LABEL_22;
        }
        ++v32;
        --v33;
      }
      while (v33);
      a8 = v30;
      a7 = v31;
      if (!*v29)
        goto LABEL_45;
LABEL_22:
      if (*v26 == 91)
      {
        v37 = *((unsigned __int8 *)v26 + 1);
        v36 = (unsigned __int8 *)(v26 + 1);
        v35 = v37;
        v38 = (const char *)v36;
        if (v37)
        {
          v38 = (const char *)v36;
          do
          {
            if (v35 == 58)
              break;
            v39 = *(unsigned __int8 *)++v38;
            v35 = v39;
          }
          while (v39);
        }
        v54 = v38;
        if (*v38 != 58)
        {
          v47 = *v52;
          v48 = "Character : expected and not found in '%s'!";
          goto LABEL_51;
        }
        *(_DWORD *)(v28 + 24 * v20 + 8) = cstdlib_atoi(v36);
        v40 = (unsigned __int8 *)(v54 + 1);
        v41 = *((unsigned __int8 *)v54 + 1);
        v42 = v54 + 1;
        if (v54[1])
        {
          v42 = v54 + 1;
          do
          {
            if (v41 == 93)
              break;
            v43 = *(unsigned __int8 *)++v42;
            v41 = v43;
          }
          while (v43);
        }
        v54 = v42;
        if (*v42 != 93)
        {
          v47 = *v52;
          v48 = "Character ] expected and not found in '%s'!";
          goto LABEL_51;
        }
        *(_DWORD *)(v28 + 24 * v20 + 12) = cstdlib_atoi(v40);
        v26 = v42 + 1;
        v54 = v42 + 1;
      }
      else
      {
        *(_QWORD *)(v28 + 24 * v20 + 8) = 0xFFFFFFFF00000000;
      }
      v44 = v28 + 24 * v20;
      *(_DWORD *)(v44 + 16) = 0;
      v45 = (int *)(v44 + 16);
      if (*v26 == 124)
      {
        v54 = v26 + 1;
        if (!isStringEqualAdvance(&v54, "transform="))
        {
          v47 = *v52;
          v48 = "Invalid source layer configuration specified in '%s'!";
          goto LABEL_51;
        }
        if (isStringEqualAdvance(&v54, "none"))
        {
          v46 = 0;
        }
        else
        {
          if (!isStringEqualAdvance(&v54, "exp"))
          {
            v47 = *v52;
            v48 = "Invalid transformation specified in '%s'!";
LABEL_51:
            log_OutText(v47, (uint64_t)"FastInfer", 0, 0, (uint64_t)v48, v22, v23, v24, (uint64_t)a6);
            return 7;
          }
          v46 = 1;
        }
        *v45 = v46;
      }
      result = 0;
      a6 += v53 + 1;
      ++v20;
      a2 = v50;
    }
    while (v20 < *(unsigned int *)(v50 + 68));
  }
  return result;
}

uint64_t tee_source_cfg_get_source_layer(uint64_t *a1, _QWORD *a2, char *__s1, uint64_t *a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t result;

  *a2 = 0;
  if (a5)
  {
    v12 = a5;
    do
    {
      v13 = *a4;
      if (*(_DWORD *)(*a4 + 8) == 26)
      {
        result = cstdlib_strcmp(__s1, *(const char **)(v13 + 120));
        if (!(_DWORD)result)
        {
          *a2 = v13;
          return result;
        }
      }
      ++a4;
      --v12;
    }
    while (v12);
    if (!*a2)
      goto LABEL_8;
    return 0;
  }
  else
  {
LABEL_8:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"source layer '%s' cannot be found!", a6, a7, a8, (uint64_t)__s1);
    return 7;
  }
}

uint64_t create_tee_param(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 96);
  *a2 = v4;
  if (v4)
    return 0;
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v5, v6, v7, v9);
  return 10;
}

uint64_t free_tee_param(uint64_t result, uint64_t a2)
{
  if (a2)
    return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(result + 8) + 48))(*(_QWORD *)(result + 16));
  return result;
}

uint64_t create_tee_layer_take_param_ownership(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;

  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v9)
  {
    result = 0;
    *(_QWORD *)v9 = a1;
    v11 = *a2;
    *(_QWORD *)(v9 + 120) = *a2;
    *a2 = 0;
    *(_QWORD *)(v11 + 80) = 0;
    *(_DWORD *)(v11 + 88) = 0;
    *(_DWORD *)(v9 + 8) = 26;
    *(_QWORD *)(v9 + 128) = forward_tee_layer;
    *(_QWORD *)(v9 + 136) = free_tee_buffer;
    *(_QWORD *)(v9 + 144) = tee_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v12);
    free_tee_buffer(0);
    result = 10;
  }
  *a3 = v9;
  return result;
}

uint64_t forward_tee_layer(uint64_t a1, uint64_t a2, float *a3, float *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  int v8;
  uint64_t v9;
  uint64_t result;
  unsigned int v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  _DWORD *v28;
  _DWORD *v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  int v34;
  float v35;
  uint64_t v36;
  _DWORD *v37;
  int v38;
  float *v39;
  unsigned int v40;
  float v41;
  void *v42;
  unsigned int v43;
  size_t v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _DWORD *v59;
  int v60;
  unsigned int v61;
  int v62;
  int v63;

  v5 = a2;
  v6 = *(_QWORD *)(a2 + 120);
  v51 = *(uint64_t **)a2;
  if (*(_DWORD *)(v6 + 68))
  {
    v8 = *(_DWORD *)(a2 + 40);
    v9 = (v8 - 1);
    if (v8 == 2)
    {
      v62 = *(_DWORD *)(a2 + 48);
      v54 = v62 * 4 * *(_DWORD *)(a2 + 44);
    }
    else
    {
      v54 = 4 * *(_DWORD *)(a2 + 44);
      v62 = 0;
    }
    v14 = 0;
    v15 = 0;
    v52 = (v8 - 1);
    v53 = *(_QWORD *)(a2 + 120);
    do
    {
      v16 = *(_QWORD *)(v6 + 72);
      v17 = (_DWORD *)(v16 + 24 * v14);
      v18 = *(_QWORD *)v17;
      v19 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v17 + 120) + 80);
      v20 = v17[3];
      if (v20 >= *(_DWORD *)(v18 + 4 * v9 + 44))
        v21 = *(_DWORD *)(v18 + 4 * v9 + 44);
      else
        v21 = v20;
      v61 = v21;
      if (*(_DWORD *)(v5 + 40) == 2)
      {
        v22 = *(_DWORD *)(v5 + 44);
        if (v22)
        {
          v23 = 0;
          v24 = v15;
          v25 = 0;
          v26 = *(_DWORD *)(v18 + 48);
          v56 = v14;
          v57 = *(_QWORD *)(v6 + 72);
          v27 = v16 + 24 * v14;
          v28 = (_DWORD *)(v27 + 8);
          v29 = (_DWORD *)(v27 + 16);
          v55 = v24;
          v30 = v24;
          v60 = v26;
          v59 = (_DWORD *)(v27 + 8);
          do
          {
            v31 = v21 - *v28;
            if (v21 > *v28)
            {
              v32 = v5;
              v33 = *v28 + v23;
              v34 = v30;
              do
              {
                v35 = *(float *)(v19 + 4 * v33);
                if (*v29 == 1)
                  v35 = exp_fdlibm(v35);
                a4[v34++] = v35;
                ++v33;
                --v31;
              }
              while (v31);
              v5 = v32;
              v22 = *(_DWORD *)(v32 + 44);
              v26 = v60;
              v21 = v61;
              v28 = v59;
            }
            ++v25;
            v30 += v62;
            v23 += v26;
          }
          while (v25 < v22);
          v9 = v52;
          v6 = v53;
          v14 = v56;
          v16 = v57;
          v15 = v55;
        }
      }
      else
      {
        v54 = 4 * *(_DWORD *)(v5 + 44);
        v36 = *(unsigned int *)(v16 + 24 * v14 + 8);
        if (v21 > v36)
        {
          v58 = *(_QWORD *)(v6 + 72);
          v37 = (_DWORD *)(v16 + 24 * v14 + 16);
          v38 = v21 - v36;
          v39 = (float *)(v19 + 4 * v36);
          v40 = v15;
          do
          {
            v41 = *v39;
            if (*v37 == 1)
              v41 = exp_fdlibm(v41);
            a4[v40++] = v41;
            ++v39;
            --v38;
          }
          while (v38);
          v16 = v58;
          v21 = v61;
        }
      }
      v15 = v21 + v15 - *(_DWORD *)(v16 + 24 * v14++ + 8);
    }
    while (v14 < *(unsigned int *)(v6 + 68));
    a3 = a4;
    v13 = v54;
  }
  else
  {
    v63 = 0;
    result = fi_shape_get_size((int *)(a2 + 20), &v63);
    if ((_DWORD)result)
      return result;
    *(_DWORD *)(a5 + 16) = 0;
    v13 = 4 * v63;
  }
  v42 = *(void **)(v6 + 80);
  if (v42)
  {
    if (*(_DWORD *)(v6 + 88) >= v13)
    {
      v44 = v13;
      goto LABEL_36;
    }
    v43 = v13;
    (*(void (**)(uint64_t))(v51[1] + 48))(v51[2]);
    v13 = v43;
    *(_QWORD *)(v6 + 80) = 0;
  }
  v44 = v13;
  v45 = v13;
  v46 = (*(uint64_t (**)(uint64_t, _QWORD))v51[1])(v51[2], v13);
  *(_QWORD *)(v6 + 80) = v46;
  if (v46)
  {
    v42 = (void *)v46;
    *(_DWORD *)(v6 + 88) = v45;
LABEL_36:
    cstdlib_memcpy(v42, a3, v44);
    return 0;
  }
  log_OutText(*v51, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tee layer allocation failed!", v47, v48, v49, v50);
  return 10;
}

_QWORD *free_tee_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        if (*(_QWORD *)(v3 + 72))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 80))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 72) = 0;
        }
        if (*(_QWORD *)(v3 + 80))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 80) = 0;
        }
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t tee_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  BOOL v19;
  int v20;

  v4 = *(_QWORD *)(a1 + 120);
  v20 = 0;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  result = fi_shape_get_size(a2, &v20);
  if (!(_DWORD)result)
  {
    if (*(_DWORD *)(v4 + 68))
    {
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = *(_QWORD *)(v4 + 72);
        if (!v13)
        {
          v15 = *(_QWORD *)(v14 + v9);
          v13 = *(_DWORD *)(v15 + 40);
          cstdlib_memcpy((void *)(a1 + 40), (const void *)(v15 + 40), 0x14uLL);
          v11 = v13 - 1;
        }
        v16 = *(_QWORD *)(v14 + v9);
        if (*(_DWORD *)(v16 + 40) != v13)
          break;
        v17 = *(_DWORD *)(v16 + 4 * v11 + 44);
        if (*(_DWORD *)(v14 + v9 + 12) < v17)
          v17 = *(_DWORD *)(v14 + v9 + 12);
        v12 = v12 - *(_DWORD *)(v14 + v9 + 8) + v17;
        ++v10;
        v9 += 24;
        if (v10 >= *(unsigned int *)(v4 + 68))
        {
          *(_DWORD *)(a1 + 4 * v11 + 44) = v12;
          goto LABEL_12;
        }
      }
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Soure layer %d has wrong number of dimensions!", v6, v7, v8, v10);
    }
    else
    {
      cstdlib_memcpy((void *)(a1 + 40), a2, 0x14uLL);
      v12 = *(_DWORD *)(a1 + 4 * (*a2 - 1) + 44);
LABEL_12:
      v18 = *(unsigned int *)(v4 + 64);
      if ((_DWORD)v18)
        v19 = v12 == (_DWORD)v18;
      else
        v19 = 1;
      if (v19)
        return 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Output dimension %d does not match calculated output dimension %d for layer %s!", v6, v7, v8, v18);
    }
    return 7;
  }
  return result;
}

uint64_t tee_layer_get_output_buffer(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 120) + 80);
}

uint64_t isStringEqualAdvance(const char **a1, char *__s)
{
  const char *v4;
  size_t v5;

  v4 = *a1;
  v5 = cstdlib_strlen(__s);
  if (cstdlib_strncmp(v4, __s, v5))
    return 0;
  *a1 += v5;
  return 1;
}

uint64_t config_merge_layer_param(uint64_t *a1, uint64_t a2, unsigned int a3, const char *a4, uint64_t *a5, unsigned int a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  const char *v28;
  uint64_t v29;

  *(_DWORD *)a2 = a3;
  v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 8 * a3);
  *(_QWORD *)(a2 + 8) = v11;
  if (v11)
  {
    if (a3)
    {
      v15 = 0;
      v29 = a3;
      v28 = a4;
      v16 = a4;
      while (1)
      {
        v17 = cstdlib_strlen(v16);
        v21 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(v21 + 8 * v15) = 0;
        if (!a6)
          break;
        v22 = v17;
        v23 = a5;
        v24 = a6;
        do
        {
          v25 = *v23;
          if (*(_DWORD *)(*v23 + 8) == 26 && !cstdlib_strcmp(v16, *(const char **)(v25 + 120)))
          {
            *(_QWORD *)(v21 + 8 * v15) = v25;
            goto LABEL_12;
          }
          ++v23;
          --v24;
        }
        while (v24);
        if (!*(_QWORD *)(v21 + 8 * v15))
          goto LABEL_16;
LABEL_12:
        v16 += v22 + 1;
        if (++v15 == v29)
          return 0;
      }
      v16 = v28;
LABEL_16:
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"source layer '%s' cannot be found!", v18, v19, v20, (uint64_t)v16);
      return 7;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v27);
    return 10;
  }
}

uint64_t merge_layer_get_binstream_data(uint64_t *a1, unsigned int *a2, _DWORD *a3, _DWORD *a4, uint64_t *a5)
{
  uint64_t v8;
  char v9;
  char *v10;
  char i;
  char v12;
  unint64_t v13;
  uint64_t v14;
  const char *v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;

  if (a3)
    *a3 = *a2;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  for (i = 1; ; i = 0)
  {
    v12 = v9;
    if (*a2)
    {
      v13 = 0;
      do
      {
        v14 = *(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * v13);
        if (*(_DWORD *)(v14 + 8) == 26)
        {
          v15 = *(const char **)(v14 + 120);
          v16 = cstdlib_strlen(v15) + 1;
          if ((i & 1) != 0)
          {
            v8 += v16;
          }
          else if (v10)
          {
            cstdlib_memcpy(v10, v15, v16);
            v10 += v16;
          }
        }
        ++v13;
      }
      while (v13 < *a2);
    }
    if ((i & 1) == 0)
      goto LABEL_16;
    v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], v8);
    if (!v17)
      break;
    v10 = (char *)v17;
    *a5 = v17;
    if (a4)
      *a4 = v8;
LABEL_16:
    v9 = 1;
    if ((v12 & 1) != 0)
      return 0;
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v18, v19, v20, v22);
  return 10;
}

uint64_t create_merge_layer(uint64_t *a1, const void *a2, uint64_t ***a3)
{
  uint64_t **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  void *v11;
  uint64_t result;
  uint64_t v13;

  v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v10 = v6;
  if (v6
    && (*v6 = a1,
        v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    cstdlib_memcpy(v11, a2, 0x10uLL);
    result = 0;
    *((_DWORD *)v10 + 2) = 31;
    v10[16] = (uint64_t *)forward_merge_layer;
    v10[17] = (uint64_t *)free_merge_buffer;
    v10[18] = (uint64_t *)merge_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v13);
    free_merge_buffer(v10);
    result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_merge_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  int v20;
  int v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t output_buffer;
  uint64_t v30;
  size_t __n;

  v10 = *(unsigned int **)(a2 + 120);
  LODWORD(__n) = 0;
  v11 = *(_DWORD *)(a2 + 40);
  if (v11 == 2)
  {
    v20 = *(_DWORD *)(a2 + 44);
    if (v20)
    {
      v21 = 0;
      v22 = *(_DWORD *)(a2 + 48);
      LODWORD(v23) = *v10;
      do
      {
        if ((_DWORD)v23)
        {
          v24 = 0;
          v25 = 0;
          do
          {
            v26 = *(_QWORD *)(*((_QWORD *)v10 + 1) + 8 * v24);
            v27 = *(_DWORD *)(v26 + 56);
            v28 = *(_DWORD *)(v26 + 48);
            output_buffer = tee_layer_get_output_buffer(v26);
            cstdlib_memcpy((void *)(a4 + (v27 * (v25 + v21 * v22))), (const void *)(output_buffer + (v28 * v27 * v21)), (v28 * v27));
            v25 += v28;
            ++v24;
            v23 = *v10;
          }
          while (v24 < v23);
        }
        ++v21;
      }
      while (v21 != v20);
    }
    return 0;
  }
  if (v11 != 1)
  {
    log_OutText(**(_QWORD **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"merge layer only support concatenation of 1d and 2d data", a6, a7, a8, v30);
    return 0;
  }
  if (!*v10)
    return 0;
  v12 = 0;
  v13 = 0;
  while (1)
  {
    v14 = *(_QWORD *)(*((_QWORD *)v10 + 1) + 8 * v12);
    result = fi_shape_get_bytes((int *)(v14 + 40), &__n);
    if ((_DWORD)result)
      break;
    if (!(_DWORD)__n)
    {
      log_OutText(**(_QWORD **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"merge layer source layer output length=0!", v16, v17, v18, v30);
      return 7;
    }
    v19 = (const void *)tee_layer_get_output_buffer(v14);
    cstdlib_memcpy((void *)(a4 + v13), v19, __n);
    v13 += __n;
    if (++v12 >= (unint64_t)*v10)
      return 0;
  }
  return result;
}

_QWORD *free_merge_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        if (*(_QWORD *)(v3 + 8))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 80))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 8) = 0;
        }
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t merge_layer_update_shape(uint64_t a1, void *a2)
{
  unsigned int *v4;
  uint64_t size;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  int v28;

  v4 = *(unsigned int **)(a1 + 120);
  v28 = 0;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  size = fi_shape_get_size((int *)a2, &v28);
  if (!(_DWORD)size)
  {
    if (*v4)
    {
      cstdlib_memcpy((void *)(a1 + 40), (const void *)(**((_QWORD **)v4 + 1) + 40), 0x14uLL);
      v6 = **((_QWORD **)v4 + 1);
      v7 = (*(_DWORD *)(v6 + 40) - 1);
      v8 = *(_DWORD *)(v6 + 40 + 4 * v7 + 4);
      if (*v4 < 2)
      {
LABEL_7:
        size = 0;
        *(_DWORD *)(a1 + 4 * v7 + 44) = v8;
      }
      else
      {
        v9 = 1;
        while (1)
        {
          v10 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)v4 + 1) + 8 * v9) + 40);
          v11 = v10[v7 + 1];
          v12 = fi_shape_merge(v10, (_DWORD *)(a1 + 40));
          if ((_DWORD)v12)
            break;
          v8 += v11;
          if (++v9 >= (unint64_t)*v4)
            goto LABEL_7;
        }
        size = v12;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"source layer outputs cannot be merged!", v13, v14, v15, v27);
        fi_shape_dump(*(uint64_t **)a1, *(_QWORD *)(*((_QWORD *)v4 + 1) + 8 * v9) + 40, (uint64_t)"shape to be merged", v16, v17, v18, v19, v20);
        fi_shape_dump(*(uint64_t **)a1, a1 + 40, (uint64_t)"shape", v21, v22, v23, v24, v25);
      }
    }
    else
    {
      return 7;
    }
  }
  return size;
}

uint64_t config_label_layer(uint64_t *a1, unsigned int a2, const char **a3, const void *a4, const void *a5, uint64_t a6)
{
  const char **v9;
  uint64_t v12;
  uint64_t v13;
  const char **v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  const char *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v33;

  v9 = a3;
  v12 = 0;
  if (a2)
  {
    v13 = a2;
    v14 = a3;
    do
    {
      v15 = *v14++;
      v12 += cstdlib_strlen(v15) + 1;
      --v13;
    }
    while (v13);
  }
  *(_DWORD *)a6 = a2;
  *(_DWORD *)(a6 + 4) = v12;
  *(_DWORD *)(a6 + 16) = 0;
  *(_DWORD *)(a6 + 32) = 0;
  *(_QWORD *)(a6 + 24) = 0;
  *(_QWORD *)(a6 + 40) = 0;
  *(_DWORD *)(a6 + 48) = 1;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v12, 4);
  *(_QWORD *)(a6 + 8) = v16;
  if (!v16)
    goto LABEL_13;
  if (a2)
  {
    v20 = 0;
    v21 = a2;
    do
    {
      v22 = cstdlib_strlen(*v9);
      v23 = *v9++;
      cstdlib_memcpy((void *)(*(_QWORD *)(a6 + 8) + v20), v23, v22);
      v20 += v22 + 1;
      --v21;
    }
    while (v21);
  }
  if (!a4)
    return 0;
  *(_DWORD *)(a6 + 16) = 1;
  v24 = (void *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2 * a2, 4);
  *(_QWORD *)(a6 + 24) = v24;
  if (!v24)
    goto LABEL_13;
  cstdlib_memcpy(v24, a4, 4 * a2 * a2);
  log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"LABEL viterbi enabled", v25, v26, v27, v33);
  if (!a5)
  {
    *(_QWORD *)(a6 + 40) = 0;
    goto LABEL_15;
  }
  *(_DWORD *)(a6 + 32) = 1;
  v31 = (void *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2, 4);
  *(_QWORD *)(a6 + 40) = v31;
  if (!v31)
  {
LABEL_13:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v17, v18, v19, v33);
    return 10;
  }
  cstdlib_memcpy(v31, a5, 4 * a2);
LABEL_15:
  log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"LABEL viterbi enabled with initp", v28, v29, v30, v33);
  return 0;
}

uint64_t create_label_layer(uint64_t *a1, _QWORD *a2, const void *a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t result;
  uint64_t v20;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v11)
    goto LABEL_10;
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64);
  if (!v12)
    goto LABEL_10;
  v13 = (_QWORD *)v12;
  if (a3)
    cstdlib_memcpy((void *)(v11 + 60), a3, 8uLL);
  cstdlib_memcpy(v13, a2, 0x38uLL);
  v14 = *(unsigned int *)a2;
  v15 = 8 * v14;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t))a1[1])(a1[2], 8 * v14);
  v13[7] = v16;
  if (v16)
  {
    if ((_DWORD)v14)
    {
      v17 = 0;
      v18 = 0;
      do
      {
        *(_QWORD *)(v13[7] + v17) = a2[1] + v18;
        v18 += cstdlib_strlen(*(const char **)(v13[7] + v17)) + 1;
        v17 += 8;
      }
      while (v15 != v17);
    }
    result = 0;
    *(_DWORD *)(v11 + 8) = 20;
    *(_QWORD *)v11 = a1;
    *(_QWORD *)(v11 + 120) = v13;
    *(_QWORD *)(v11 + 128) = forward_label_layer;
    *(_QWORD *)(v11 + 136) = free_label_buffer;
    *(_QWORD *)(v11 + 144) = label_layer_update_shape;
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v20);
    free_label_buffer((_QWORD *)v11);
    result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_label_layer(uint64_t a1, uint64_t a2, float *a3, _QWORD *a4, uint64_t a5)
{
  uint64_t *v9;
  uint64_t v10;
  int *v11;
  unsigned int step;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t input_dim;
  int v17;
  BOOL v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  float v26;
  uint64_t v27;
  uint64_t *v28;
  unsigned int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float *v47;
  float *v48;
  uint64_t v49;
  float v50;
  float v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  _BOOL4 v56;
  uint64_t v57;
  int v58;
  float v59;
  unsigned int v60;
  float v61;
  double v62;
  double v63;
  float v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  double v68;
  float v69;
  float v70;
  double v71;
  float v72;
  float v73;
  uint64_t v74;
  int LargestIdx;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  uint64_t v81;
  uint64_t v83;
  int v84;
  unsigned int *v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  float *v89;
  uint64_t v90;
  uint64_t i;
  unsigned int v92;
  uint64_t *v93;
  uint64_t v94;
  float *v95;
  uint64_t v96;
  int v97[3];

  v9 = *(uint64_t **)a2;
  v97[0] = 0;
  v10 = *(_QWORD *)(a2 + 120);
  v11 = (int *)(a2 + 20);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  input_dim = fi_shape_get_input_dim(v11, v97);
  if ((_DWORD)input_dim)
    return input_dim;
  v17 = *(_DWORD *)(v10 + 16);
  if (v17)
    v18 = step >= 2;
  else
    v18 = 0;
  if (v18)
  {
    v89 = a3;
    v28 = *(uint64_t **)a2;
    v29 = *(unsigned int **)(a2 + 120);
    v30 = *v29;
    v31 = *((_QWORD *)v29 + 3);
    v96 = *((_QWORD *)v29 + 5);
    v35 = fi_shape_get_step(v11);
    if (v35 > 1)
    {
      v88 = (v35 - 1);
      v39 = ((v35 - 1) * v30);
      v94 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v28[1] + 16))(v28[2], v39, 4);
      if (v94)
      {
        v43 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v28[1] + 16))(v28[2], (v35 * v30), 4);
        v47 = (float *)v43;
        if (v43)
        {
          v86 = v39;
          v87 = v9;
          v93 = v28;
          v95 = (float *)v43;
          v85 = v29;
          if ((_DWORD)v30)
          {
            v48 = v89;
            v49 = v30;
            do
            {
              v50 = *v48++;
              v51 = log_fdlibm(v50);
              *v47++ = v51;
              --v49;
            }
            while (v49);
            v52 = v30;
          }
          else
          {
            v52 = 0;
          }
          v92 = 0;
          v84 = v35;
          v90 = v35;
          for (i = 1; i != v90; ++i)
          {
            if ((_DWORD)v30)
            {
              v54 = 0;
              v56 = i == 1 && v96 != 0;
              do
              {
                v57 = 0;
                v58 = -1;
                v59 = -3.4028e38;
                v60 = v54;
                do
                {
                  v61 = *(float *)(v31 + 4 * v60);
                  v62 = log_fdlibm(v89[(v30 * i) + v54]);
                  v63 = v62;
                  v64 = v95[v92 + v57];
                  *(float *)&v62 = v61;
                  if (!almost_equal_floats(v62, 0.0))
                  {
                    if (!v56 || (LODWORD(v68) = *(_DWORD *)(v96 + 4 * v57), !almost_equal_floats(v68, 0.0)))
                    {
                      v69 = v63;
                      v70 = v64 + v69;
                      v71 = v61;
                      v72 = log_fdlibm(v71);
                      if ((float)(v70 + v72) > v59)
                      {
                        v73 = log_fdlibm(v71);
                        v59 = v70 + v73;
                        v58 = v57;
                      }
                    }
                  }
                  ++v57;
                  v60 += v30;
                }
                while (v52 != v57);
                if (v58 == -1)
                {
                  log_OutText(*v93, (uint64_t)"FastInfer", 0, 0, (uint64_t)"No valid path for %d node at step %d", v65, v66, v67, v54);
                }
                else
                {
                  *(_DWORD *)(v94 + 4 * ((i - 1) * v30 + v54)) = v58;
                  v95[(v30 * i + v54)] = v59;
                }
                ++v54;
              }
              while (v54 != v52);
            }
            v92 += v30;
          }
          v74 = v88;
          if ((v88 & 0x80000000) != 0)
          {
            v53 = 0;
            input_dim = 7;
            v9 = v87;
            v28 = v93;
            v47 = v95;
          }
          else
          {
            v47 = v95;
            LargestIdx = getLargestIdx((uint64_t)&v95[v86], v30);
            if (LargestIdx == -1)
            {
              v28 = v93;
              log_OutText(*v93, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Cannot find a valid value from output at %d", v76, v77, v78, v88);
              v53 = 0;
              input_dim = 7;
            }
            else
            {
              v79 = LargestIdx;
              v80 = v30 * (v84 - 2);
              v28 = v93;
              if ((LargestIdx & 0x80000000) == 0)
                goto LABEL_56;
LABEL_55:
              log_OutText(*v93, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Best path broken at step %d", v76, v77, v78, v74);
LABEL_56:
              while (1)
              {
                v81 = *(_QWORD *)(*((_QWORD *)v85 + 7) + 8 * v79);
                if (!v74)
                  break;
                a4[v74--] = v81;
                v79 = *(_DWORD *)(v94 + 4 * (v79 + v80));
                v80 -= v30;
                if (v79 < 0)
                  goto LABEL_55;
              }
              input_dim = 0;
              *a4 = v81;
              v53 = 1;
            }
            v9 = v87;
          }
        }
        else
        {
          log_OutText(*v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v44, v45, v46, v83);
          v53 = 0;
          input_dim = 10;
        }
        (*(void (**)(uint64_t, uint64_t))(v28[1] + 48))(v28[2], v94);
        if (v47)
          (*(void (**)(uint64_t, float *))(v28[1] + 48))(v28[2], v47);
        if ((v53 & 1) != 0)
          return 0;
      }
      else
      {
        log_OutText(*v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v40, v41, v42, v83);
        input_dim = 10;
      }
    }
    else
    {
      log_OutText(*v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)"forward label layer using viterbi with invalid step = %d!", v32, v33, v34, v35);
      input_dim = 7;
    }
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"forward label layer viterbi failed!", v36, v37, v38, v83);
    return input_dim;
  }
  if (v17)
    v19 = step > 1;
  else
    v19 = 1;
  if (!v19)
    log_OutText(*v9, (uint64_t)"FastInfer", 1, 0, (uint64_t)"Disable viterbi when step < 2", v13, v14, v15, v83);
  if (!step)
    return 0;
  v20 = 0;
  while (1)
  {
    v24 = getLargestIdx((uint64_t)&a3[(v97[0] * v20)], v97[0]);
    v25 = *v9;
    if (v24 == -1)
      break;
    log_OutText(v25, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Label score: %f", v21, v22, v23, COERCE__INT64(a3[(v24 + v97[0] * v20)]));
    v26 = *(float *)(a5 + 24);
    if (v26 <= 0.0 || a3[(v24 + v97[0] * v20)] >= v26)
      v27 = *(_QWORD *)(*(_QWORD *)(v10 + 56) + 8 * v24);
    else
      v27 = 0;
    a4[v20++] = v27;
    if (step == v20)
      return 0;
  }
  log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Cannot find a valid value from output at %d", v21, v22, v23, v20);
  return 7;
}

_QWORD *free_label_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        if (*(_QWORD *)(v3 + 56))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 56) = 0;
        }
        if (*(_DWORD *)(v3 + 48))
        {
          if (*(_QWORD *)(v3 + 8))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v3 + 8) = 0;
          }
          if (*(_QWORD *)(v3 + 24))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v3 + 24) = 0;
          }
          if (*(_QWORD *)(v3 + 40))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v3 + 40) = 0;
          }
        }
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t label_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int step;
  int v17;

  v9 = **(unsigned int **)(a1 + 120);
  v17 = 0;
  a2[4] = 8;
  *(_DWORD *)(a1 + 56) = 8;
  v10 = *a2;
  if ((v10 - 1) >= 2)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"label layer only supports 1D/2D input, got %d", a6, a7, a8, v10);
    return 7;
  }
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  result = fi_shape_get_input_dim((int *)(a1 + 20), &v17);
  if ((_DWORD)result)
    return result;
  if (v17 != (_DWORD)v9)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"NUM of LABEL: %d not same with input data dim %d", v13, v14, v15, v9);
    return 7;
  }
  if (*a2 == 2)
  {
    *(_DWORD *)(a1 + 40) = 1;
    step = fi_shape_get_step((_DWORD *)(a1 + 20));
    result = 0;
    *(_DWORD *)(a1 + 44) = step;
    goto LABEL_12;
  }
  if (*a2 == 1)
  {
    result = 0;
    *(_QWORD *)(a1 + 40) = 0x100000001;
LABEL_12:
    *(_DWORD *)(a1 + 56) = a2[4];
    return result;
  }
  return 0;
}

uint64_t create_embedding_layer(uint64_t *a1, const void *a2, uint64_t ***a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t result;
  uint64_t v13;

  v9 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v9
    && (v10 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8)) != 0)
  {
    v11 = v10;
    cstdlib_memcpy(v10, a2, 8uLL);
    result = 0;
    *v9 = a1;
    v9[1] = (uint64_t *)39;
    v9[15] = v11;
    v9[16] = (uint64_t *)forward_embedding_layer;
    v9[17] = (uint64_t *)free_embedding_buffer;
    v9[18] = (uint64_t *)embedding_layer_update_shape;
    v9[19] = (uint64_t *)embedding_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v13);
    free_embedding_buffer(v9);
    result = 10;
  }
  *a3 = v9;
  return result;
}

uint64_t forward_embedding_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  int *v8;
  int step;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t result;
  int padded_len;
  int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  unsigned int v23;

  v7 = *(_QWORD *)(a2 + 120);
  v8 = (int *)(a2 + 40);
  step = fi_shape_get_step((_DWORD *)(a2 + 40));
  v23 = 0;
  if (v7)
  {
    v13 = step;
    v14 = *(_QWORD *)(a2 + 88);
    result = fi_shape_get_input_dim(v8, (int *)&v23);
    if ((_DWORD)result)
      return result;
    padded_len = get_padded_len(v23, 8u);
    if (!v13)
      return 0;
    v17 = padded_len;
    v18 = 0;
    while (1)
    {
      v19 = *(float *)(a3 + 4 * v18);
      if (*(_DWORD *)(v7 + 4) <= v19)
        break;
      cstdlib_memcpy((void *)(a4 + 4 * v23 * v18++), (const void *)(v14 + 4 * v17 * v19), 4 * v23);
      if (v13 == v18)
        return 0;
    }
    v20 = **(_QWORD **)a2;
    v21 = "invalid key!";
  }
  else
  {
    v20 = **(_QWORD **)a2;
    v21 = "invalid param!";
  }
  log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v10, v11, v12, v22);
  return 7;
}

_QWORD *free_embedding_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t embedding_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t result;
  int v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;

  v9 = *(int **)(a1 + 120);
  if (!v9)
  {
    v13 = **(_QWORD **)a1;
    v14 = "invalid param!";
LABEL_7:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v15);
    return 7;
  }
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 != 1)
  {
    v13 = **(_QWORD **)a1;
    v14 = "Currently embedding layer only support 1D input";
    goto LABEL_7;
  }
  result = 0;
  if (a2[1] == 1)
  {
    v12 = *v9;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v12;
  }
  else
  {
    *(_DWORD *)(a1 + 40) = 2;
    *(_DWORD *)(a1 + 44) = a2[1];
    *(_DWORD *)(a1 + 48) = *v9;
  }
  *(_DWORD *)(a1 + 56) = 4;
  return result;
}

uint64_t embedding_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  int padded_len;
  uint64_t result;
  uint64_t v15;

  v8 = *(unsigned int **)(a1 + 120);
  if (v8 && (v9 = v8[1]) != 0 && (v10 = *v8, (_DWORD)v10))
  {
    padded_len = get_padded_len(v10, 8u);
    result = 0;
    *a2 = 4 * v9 * padded_len;
    *a3 = 0;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"invalid param!", a6, a7, a8, v15);
    return 7;
  }
  return result;
}

uint64_t trans_enc_dispatch_weights(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(_QWORD *)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v1 + 48), v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v1 + 56), v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      get_padded_bytes(padded_bytes, 8u);
      return 0;
    }
  }
  return result;
}

uint64_t create_trans_enc_layer(uint64_t *a1, int *a2, const void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int8x16_t v33;
  uint64_t v34;
  int v35;
  int v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64);
      v19 = v15;
      if (!v15)
      {
        v25 = *a1;
        v26 = "out of memory!";
LABEL_12:
        log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v16, v17, v18, v30);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_enc init param failed!", v27, v28, v29, v31);
        result = 7;
        goto LABEL_13;
      }
      cstdlib_memcpy(v15, a2, 0x2CuLL);
      v38 = 0u;
      v39 = 0u;
      v37 = 0u;
      DWORD1(v37) = 0;
      v20 = a2[6];
      v35 = 0;
      v36 = v20;
      v34 = *((_QWORD *)a2 + 2);
      *((float *)&v37 + 2) = (float)a2[7];
      *(_QWORD *)&v39 = 0;
      DWORD2(v39) = 0;
      if (create_att_layer(a1, (unsigned int *)&v34, a3, a4, v19 + 6))
      {
        v24 = "create trans_enc att layer failed!";
LABEL_11:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v24, v21, v22, v23, v30);
        v25 = *a1;
        v26 = "trans_enc network init failed!";
        goto LABEL_12;
      }
      v32 = *a2;
      v33 = vextq_s8(*(int8x16_t *)(a2 + 1), *(int8x16_t *)(a2 + 1), 0xCuLL);
      if (create_ffn_layer(a1, (int32x2_t *)&v32, a3, a4, v19 + 7))
      {
        v24 = "create trans_enc ffn layer failed!";
        goto LABEL_11;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 35;
      *(_QWORD *)(v7 + 128) = forward_trans_enc_layer;
      *(_QWORD *)(v7 + 136) = free_trans_enc_layer;
      *(_QWORD *)(v7 + 144) = trans_enc_layer_update_shape;
      *(_QWORD *)(v7 + 152) = trans_enc_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = trans_enc_request_glbBuf;
      *(_QWORD *)(v7 + 168) = trans_enc_assign_glbBuf;
      *(_QWORD *)(v7 + 176) = trans_enc_layer_reset;
      *(_QWORD *)(v7 + 184) = trans_enc_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v21, v22, v23, v30);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v30);
      result = 10;
    }
  }
LABEL_13:
  *a5 = v7;
  return result;
}

uint64_t forward_trans_enc_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t bytes;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v17;
  size_t __len;

  LODWORD(__len) = 0;
  if (!a2)
    return 0;
  v6 = *(uint64_t **)a2;
  v7 = *(_QWORD *)(a2 + 120);
  v8 = *(void **)(a2 + 240);
  v9 = *(_QWORD *)(v7 + 48);
  *(_DWORD *)(*(_QWORD *)(v9 + 120) + 152) = 0;
  bytes = fi_shape_get_bytes((int *)(v9 + 40), &__len);
  if (!(_DWORD)bytes)
  {
    cstdlib_memset(v8, 0, __len);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v7 + 48) + 128))(a1);
    if ((_DWORD)v11)
    {
      bytes = v11;
      v15 = "trans_enc forward att layer failed!";
LABEL_5:
      log_OutText(*v6, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, v12, v13, v14, v17);
      return bytes;
    }
    bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v7 + 56) + 40), &__len);
    if (!(_DWORD)bytes)
    {
      cstdlib_memset(a4, 0, __len);
      bytes = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v7 + 56) + 128))(a1);
      if ((_DWORD)bytes)
      {
        v15 = "trans_enc forward ffn layer failed!";
        goto LABEL_5;
      }
    }
  }
  return bytes;
}

_QWORD *free_trans_enc_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 56));
        fi_layer_free(*(_QWORD *)(v3 + 48));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t trans_enc_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t result;
  uint64_t v12;
  const void *v13;
  int v14;
  uint64_t v15;

  v4 = *(_QWORD *)(a1 + 120);
  v5 = *(uint64_t **)a1;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 >= 3u)
  {
    v9 = *v5;
    v10 = "Currently trans_enc layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v10, v6, v7, v8, v15);
    return 7;
  }
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 48) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 56) + 144))();
    if (!(_DWORD)result)
    {
      v12 = *(_QWORD *)(v4 + 56);
      v14 = *(_DWORD *)(v12 + 40);
      v13 = (const void *)(v12 + 40);
      if ((v14 - 1) >= 2)
      {
        v9 = **(_QWORD **)a1;
        v10 = "dense out: output shape error";
        goto LABEL_3;
      }
      cstdlib_memcpy((void *)(a1 + 40), v13, 0x14uLL);
      return 0;
    }
  }
  return result;
}

uint64_t trans_enc_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6;
  uint64_t result;
  unsigned int padded_bytes;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = *(_QWORD *)(a1 + 120);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v6 + 48) + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v6 + 56) + 152))();
    if (!(_DWORD)result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v9, v10, v11, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v12, v13, v14, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t trans_enc_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  v2 = *(_QWORD *)(a1 + 120);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 48) + 160))();
  if (!(_DWORD)result)
  {
    v4 = *(_DWORD *)(*(_QWORD *)(v2 + 48) + 248);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v2 + 56) + 160))();
    if (!(_DWORD)result)
    {
      v5 = *(_DWORD *)(*(_QWORD *)(v2 + 56) + 248);
      v7 = v5;
      result = trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
      if (!(_DWORD)result)
      {
        if (v5 <= v4)
          v6 = v4;
        else
          v6 = v5;
        *(_DWORD *)(a1 + 248) = v7 + v6;
      }
    }
  }
  return result;
}

uint64_t trans_enc_assign_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;

  v2 = *(_QWORD *)(a1 + 120);
  v7 = 0;
  result = trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
  if (!(_DWORD)result)
  {
    v4 = v7;
    v5 = *(_QWORD *)(v2 + 48);
    v6 = *(_QWORD *)(v2 + 56);
    *(_QWORD *)(v5 + 240) = *(_QWORD *)(a1 + 240) + v7;
    *(_DWORD *)(v5 + 248) = *(_DWORD *)(a1 + 248) - v4;
    *(_QWORD *)(v6 + 240) = *(_QWORD *)(a1 + 240) + v4;
    *(_DWORD *)(v6 + 248) = *(_DWORD *)(a1 + 248) - v4;
  }
  return result;
}

uint64_t trans_enc_layer_reset(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 48) + 176))();
  if ((_DWORD)result)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_enc network reset failed!", v3, v4, v5, v6);
    return 7;
  }
  return result;
}

uint64_t trans_enc_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t trans_enc_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t bytes;
  unsigned int v6;

  v3 = *(_QWORD *)(a1 + 120);
  v6 = 0;
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 48) + 40), &v6);
  if (!(_DWORD)bytes)
    *a2 = get_padded_bytes(v6, 8u);
  return bytes;
}

_QWORD *free_att_albert_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  _QWORD *v5;

  if (!result)
    return result;
  v1 = result;
  v2 = *result;
  if (!*result)
    return result;
  v3 = result[15];
  if (v3)
  {
    fi_layer_free(*(_QWORD *)(v3 + 72));
    if (*(_QWORD *)(v3 + 56))
    {
      if (!*(_QWORD *)(v3 + 144))
        goto LABEL_8;
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
    }
    *(_QWORD *)(v3 + 144) = 0;
LABEL_8:
    if (*(_DWORD *)(v3 + 8))
    {
      v4 = *(_DWORD *)(v3 + 20);
      if (v4 == 1)
      {
        if (*(_DWORD *)(v3 + 64))
          goto LABEL_22;
        if (*(_QWORD *)(v3 + 176))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 176) = 0;
        }
        v5 = (_QWORD *)(v3 + 184);
        if (!*(_QWORD *)(v3 + 184))
          goto LABEL_22;
      }
      else
      {
        if (v4 || *(_DWORD *)(v3 + 64))
          goto LABEL_22;
        if (*(_QWORD *)(v3 + 160))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 160) = 0;
        }
        v5 = (_QWORD *)(v3 + 168);
        if (!*(_QWORD *)(v3 + 168))
          goto LABEL_22;
      }
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      *v5 = 0;
    }
LABEL_22:
    (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
  }
  if (*((_DWORD *)v1 + 29))
  {
    if (v1[9])
    {
      (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      v1[9] = 0;
    }
    cstdlib_memset(v1 + 9, 0, 0x30uLL);
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
}

uint64_t create_att_albert_layer(uint64_t *a1, unsigned int *a2, const void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int padded_len;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 200);
      v19 = v15;
      if (!v15)
      {
        v25 = *a1;
        v26 = "out of memory!";
        goto LABEL_15;
      }
      cstdlib_memcpy(v15, a2, 0x48uLL);
      v35 = 0;
      v34 = 0;
      v19[48] = 0;
      padded_len = get_padded_len(*a2, 8u);
      if (a2[7] == 1)
      {
        v21 = *a2;
        LODWORD(v34) = 40;
        HIDWORD(v34) = v21;
        if (create_norm_layer(a1, &v34, (_QWORD *)v19 + 9))
        {
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create att norm layer failed!", v22, v23, v24, v34);
          v25 = *a1;
          v26 = "att network init failed!";
LABEL_15:
          log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v16, v17, v18, v34);
          *(_QWORD *)(v7 + 120) = v19;
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att init param failed!", v31, v32, v33, v34);
          result = 7;
          goto LABEL_25;
        }
      }
      cstdlib_memset(&v34, 0, 0xCuLL);
      LODWORD(v34) = 5;
      HIDWORD(v34) = padded_len;
      *((_OWORD *)v19 + 10) = 0u;
      *((_OWORD *)v19 + 11) = 0u;
      if (a2[2])
      {
        v30 = a2[5];
        if (v30 == 1)
        {
          if (!a2[16])
          {
            *((_QWORD *)v19 + 22) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
            *((_QWORD *)v19 + 23) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
          }
        }
        else if (!v30 && !a2[16])
        {
          *((_QWORD *)v19 + 20) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
          *((_QWORD *)v19 + 21) = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
        }
      }
      v19[38] = 0;
      if (!*((_QWORD *)a2 + 7))
        *((_QWORD *)v19 + 18) = 0;
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_att_albert_layer;
      *(_QWORD *)(v7 + 136) = free_att_albert_layer;
      *(_QWORD *)(v7 + 8) = 41;
      *(_QWORD *)(v7 + 144) = att_albert_layer_update_shape;
      *(_QWORD *)(v7 + 152) = att_albert_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = att_albert_request_glbBuf;
      *(_QWORD *)(v7 + 176) = att_albert_layer_reset;
      *(_QWORD *)(v7 + 184) = att_albert_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v27, v28, v29, v34);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v34);
      result = 10;
    }
  }
LABEL_25:
  *a5 = v7;
  return result;
}

uint64_t forward_att_albert_layer(uint64_t a1, uint64_t a2, void *a3, float32x4_t *a4)
{
  uint64_t *v7;
  unsigned int *v8;
  uint64_t step;
  unsigned int v10;
  uint64_t padded_len;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  BOOL v20;
  unsigned int v21;
  float32x4_t *v22;
  float32x4_t *v23;
  uint64_t v24;
  float32x4_t *v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float32x4_t *v31;
  int v32;
  uint64_t v33;
  char *v34;
  float32x4_t *v35;
  float32x4_t *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  float32x4_t *v48;
  int v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  float32x4_t *v53;
  int v54;
  int v55;
  float v56;
  uint64_t v57;
  int v58;
  int v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  BOOL v65;
  float32x4_t *v66;
  float32x4_t *v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  char *v71;
  int v72;
  unsigned int v73;
  unsigned int v74;
  char *v75;
  int v76;
  uint64_t v77;
  uint64_t v79;
  void *__src;
  unsigned int *v81;
  uint64_t v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t __len;
  float32x4_t *v86;
  uint64_t v87;
  float32x4_t *v88;
  uint64_t v89;
  float32x4_t *v90;
  int v91;
  char *v92;
  float32x4_t *__b;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  unsigned int v98;

  if (!a2)
    return 0;
  v7 = *(uint64_t **)a2;
  v8 = *(unsigned int **)(a2 + 120);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  v10 = step;
  padded_len = get_padded_len(step, 8u);
  v89 = *v8;
  v12 = get_padded_len(v89, 8u);
  v13 = v8[3];
  v14 = get_padded_len(v13, 8u);
  v18 = v8[5];
  v19 = v8[2];
  if (v19)
    v20 = 0;
  else
    v20 = v18 == 1;
  if (v20)
  {
    log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"encoder decoder attention is possible only if isDecoder option has been set to 1", v15, v16, v17, v79);
    return 7;
  }
  v94 = v13;
  v87 = v8[1];
  v83 = v8[5];
  v91 = v14;
  if (v18 == 1)
  {
    v21 = fi_shape_get_step(v8 + 9);
    v22 = *(float32x4_t **)(a2 + 240);
    if (v8[2])
    {
      v90 = (float32x4_t *)*((_QWORD *)v8 + 22);
      v23 = (float32x4_t *)*((_QWORD *)v8 + 23);
LABEL_13:
      v88 = v23;
      v25 = v22;
      goto LABEL_15;
    }
  }
  else
  {
    v21 = v10 + v10 * v8[48];
    v22 = *(float32x4_t **)(a2 + 240);
    if (v19)
    {
      v90 = (float32x4_t *)*((_QWORD *)v8 + 20);
      v23 = (float32x4_t *)*((_QWORD *)v8 + 21);
      goto LABEL_13;
    }
  }
  v25 = (float32x4_t *)((char *)v22 + 4 * v12 * v10);
  cstdlib_memset(v25, 0, 4 * v12 * v10);
  v88 = 0;
  v90 = v25;
LABEL_15:
  v84 = v12;
  v82 = v12 * v10;
  v26 = 4 * v82;
  cstdlib_memset(v22, 0, 4 * v82);
  __src = a3;
  if (v8[7] == 1)
  {
    v27 = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v8 + 9) + 128))(a1);
    if ((_DWORD)v27)
    {
      v24 = v27;
      log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att forward norm layer failed!", v28, v29, v30, v79);
      return v24;
    }
  }
  else
  {
    cstdlib_memcpy(v22, a3, v26);
  }
  v96 = (uint64_t)v7;
  __b = v22;
  __len = 4 * v82;
  cstdlib_memset(a4, 0, v26);
  v31 = a4;
  if (v8[6] == 1 && v10)
  {
    v32 = 0;
    v33 = v10;
    do
    {
      cstdlib_memcpy(&v31->f32[v32], *((const void **)v8 + 14), 4 * v89);
      v32 += v84;
      --v33;
    }
    while (v33);
  }
  v95 = v91 * v94;
  v34 = &v25->i8[4 * v82];
  gemm_v2((uint64_t)v7, 0, v10, v84, v84, (uint64_t)__b, v84, *((_QWORD *)v8 + 11), v84, v31, v84);
  v86 = v31;
  if (v83 == 1)
  {
    v36 = (float32x4_t *)*((_QWORD *)v8 + 22);
    v35 = (float32x4_t *)*((_QWORD *)v8 + 23);
    v37 = v87;
    v88 = v35;
    v90 = v36;
    if (v8[38])
      goto LABEL_42;
    cstdlib_memset(v36, 0, 4 * v21 * v84);
    cstdlib_memset(v35, 0, 4 * v21 * v84);
    if (v8[6] == 1 && v21)
    {
      v38 = 0;
      v39 = v21;
      do
      {
        cstdlib_memcpy(&v36->f32[v38], *((const void **)v8 + 13), 4 * v89);
        v38 += v84;
        --v39;
      }
      while (v39);
    }
    gemm_v2(v96, 0, v21, v84, v84, *((_QWORD *)v8 + 18), v84, *((_QWORD *)v8 + 10), v84, v36, v84);
    if (v8[6] == 1 && v21 != 0)
    {
      v41 = 0;
      v42 = v21;
      do
      {
        cstdlib_memcpy(&v88->f32[v41], *((const void **)v8 + 15), 4 * v89);
        v41 += v84;
        --v42;
      }
      while (v42);
    }
    gemm_v2(v96, 0, v21, v84, v84, *((_QWORD *)v8 + 18), v84, *((_QWORD *)v8 + 12), v84, v88, v84);
    v8[38] = 1;
  }
  else
  {
    cstdlib_memset(&v90->f32[v8[48] * v84], 0, __len);
    if (v8[6] == 1 && v10)
    {
      v43 = 0;
      v44 = v10;
      do
      {
        cstdlib_memcpy(&v90->f32[v43], *((const void **)v8 + 13), 4 * v89);
        v43 += v84;
        --v44;
      }
      while (v44);
    }
    gemm_v2((uint64_t)v7, 0, v10, v84, v84, (uint64_t)__b, v84, *((_QWORD *)v8 + 10), v84, (float32x4_t *)((char *)v90 + 4 * v8[48] * v84), v84);
  }
  v37 = v87;
LABEL_42:
  v45 = (v37 + 1);
  v81 = v8;
  v92 = &v34[4 * v95];
  if ((_DWORD)v37 == -1)
  {
    v46 = v84;
    v47 = v89 == -1;
    v48 = v31;
  }
  else
  {
    v49 = 0;
    do
    {
      cstdlib_memset(&v34[4 * v49], 0, 4 * padded_len * v10);
      v49 += v95;
      --v45;
    }
    while (v45);
    v47 = v89 / v37;
    v48 = v86;
    v46 = v84;
  }
  v50 = 0;
  v51 = 0;
  v52 = v37;
  v98 = v47;
  do
  {
    v53 = v48;
    gemm_v2(v96, 1, v10, v21, v98, (uint64_t)v48->i64 + 4 * v50, v46, (uint64_t)v90->i64 + 4 * v50, v46, (float32x4_t *)&v34[4 * v51], padded_len);
    v48 = v53;
    v51 += v95;
    v50 += v98;
    --v52;
  }
  while (v52);
  v54 = 0;
  v55 = 0;
  v56 = 1.0 / sqrt((double)v98);
  v57 = v87;
  do
  {
    if ((_DWORD)padded_len)
    {
      v58 = 0;
      v59 = v54;
      do
      {
        if (v21)
        {
          v60 = v21;
          v61 = v59;
          do
          {
            *(float *)&v34[4 * v61] = *(float *)&v34[4 * v61] * v56;
            ++v61;
            --v60;
          }
          while (v60);
        }
        ++v58;
        v59 += v10;
      }
      while (v58 != (_DWORD)padded_len);
    }
    ++v55;
    v54 += v95;
  }
  while (v55 != (_DWORD)v87);
  v62 = v87 - 1;
  if ((int)v87 - 1 >= 0)
  {
    do
    {
      if (v10)
      {
        v63 = 0;
        v64 = v10;
        do
        {
          softmax((float *)&v34[4 * v62 * v95 + 4 * v63], v21, 1, (float *)&v92[4 * v62 * v95 + 4 * v63], *((float *)v8 + 8));
          v63 += padded_len;
          --v64;
        }
        while (v64);
      }
      v65 = __OFSUB__(v62--, 1);
    }
    while (v62 < 0 == v65);
    v48 = v86;
    v57 = v87;
    v46 = v84;
  }
  v66 = __b;
  v67 = v88;
  if (v83)
  {
    v68 = v46;
  }
  else
  {
    if (!v8[2])
      v67 = v48;
    cstdlib_memset(&v67->f32[v8[48] * v46], 0, __len);
    if (v8[6] == 1 && v10)
    {
      v69 = 0;
      v70 = v10;
      do
      {
        cstdlib_memcpy(&v67->f32[v69], *((const void **)v8 + 15), 4 * v89);
        v69 += v46;
        --v70;
      }
      while (v70);
    }
    v88 = v67;
    v66 = __b;
    v68 = v46;
    gemm_v2(v96, 0, v10, v46, v46, (uint64_t)__b, v46, *((_QWORD *)v81 + 12), v46, (float32x4_t *)((char *)v67 + 4 * v81[48] * v46), v46);
    v57 = v87;
  }
  cstdlib_memset(v66, 0, __len);
  v71 = v92;
  v72 = v98;
  v73 = 0;
  v74 = 0;
  do
  {
    v75 = v71;
    gemm_v2(v96, 0, v10, v72, v21, (uint64_t)&v71[4 * v73], padded_len, (uint64_t)v88->i64 + 4 * v74, v68, (float32x4_t *)((char *)__b + 4 * v74), v68);
    v71 = v75;
    v72 = v98;
    v74 += v98;
    v73 += v95;
    --v57;
  }
  while (v57);
  cstdlib_memcpy(v86, __src, __len);
  gemm_v2(v96, 0, v10, v68, v68, (uint64_t)__b, v68, *((_QWORD *)v81 + 17), v68, v86, v68);
  cstdlib_memset(__b, 0, __len);
  if (v10)
  {
    v76 = 0;
    v77 = v10;
    do
    {
      cstdlib_memcpy(&__b->f32[v76], *((const void **)v81 + 16), 4 * v68);
      v76 += v68;
      --v77;
    }
    while (v77);
  }
  if (v81[6] == 1)
    axpy(v82, __b->f32, 1, v86->f32, 1, 1.0);
  v24 = 0;
  ++v81[48];
  return v24;
}

uint64_t att_albert_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  uint64_t v9;
  const char *v10;
  uint64_t result;
  uint64_t v13;
  const void *v14;
  int v15;
  void *v16;
  const void *v17;
  uint64_t v18;

  v8 = *(uint64_t **)a1;
  if (*a2 >= 3u)
  {
    v9 = *v8;
    v10 = "Currently att layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v10, a6, a7, a8, v18);
    return 7;
  }
  v13 = *(_QWORD *)(a1 + 120);
  v14 = (const void *)(a1 + 20);
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*(_DWORD *)(v13 + 28) != 1
    || (result = (*(uint64_t (**)(void))(*(_QWORD *)(v13 + 72) + 144))(), !(_DWORD)result))
  {
    if (*(_DWORD *)(v13 + 20) == 1)
    {
      *(_DWORD *)(v13 + 36) = 2;
      v15 = *(_DWORD *)(v13 + 28);
      if (!*(_QWORD *)(v13 + 72))
      {
        if (v15 == 1)
        {
          v9 = *v8;
          v10 = "Must set external pointers before shape update for enc_dec att.";
          goto LABEL_3;
        }
        goto LABEL_13;
      }
    }
    else
    {
      v15 = *(_DWORD *)(v13 + 28);
    }
    if (v15 == 1)
    {
      v16 = (void *)(a1 + 40);
      v17 = (const void *)(*(_QWORD *)(v13 + 72) + 40);
LABEL_14:
      cstdlib_memcpy(v16, v17, 0x14uLL);
      return 0;
    }
LABEL_13:
    v16 = (void *)(a1 + 40);
    v17 = v14;
    goto LABEL_14;
  }
  return result;
}

uint64_t att_albert_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int *v6;
  uint64_t result;
  int padded_bytes;
  uint64_t padded_len;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v6 = *(unsigned int **)(a1 + 120);
  if (v6[7] != 1 || (result = (*(uint64_t (**)(void))(*((_QWORD *)v6 + 9) + 152))(), !(_DWORD)result))
  {
    padded_bytes = get_padded_bytes(0, 8u);
    padded_len = get_padded_len(*v6, 8u);
    *a2 = padded_bytes + 16 * (padded_len + padded_len * padded_len);
    *a3 = 0;
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"att k kernel size: %d\n", v10, v11, v12, padded_len);
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
    return 0;
  }
  return result;
}

uint64_t att_albert_request_glbBuf(uint64_t a1)
{
  _DWORD *v2;
  int v3;
  int *v4;
  unsigned int step;
  uint64_t v6;
  uint64_t result;
  int padded_len;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  int v14;
  int v15;
  int padded_bytes;
  uint64_t v17;
  unsigned int v18;

  v2 = *(_DWORD **)(a1 + 120);
  v3 = v2[1];
  v4 = (int *)(a1 + 20);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v6 = v2[3];
  v18 = 0;
  result = fi_shape_get_input_dim(v4, (int *)&v18);
  if (!(_DWORD)result)
  {
    padded_len = get_padded_len(v18, 8u);
    if (v18 != *v2)
    {
      v12 = **(_QWORD **)a1;
      v13 = "att input sample dim mismatch! inshape: %d, but config: %d";
      v17 = v18;
      goto LABEL_6;
    }
    if (step > v6)
    {
      v12 = **(_QWORD **)a1;
      v13 = "att: input len longer than maximum!";
LABEL_6:
      log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, v9, v10, v11, v17);
      return 7;
    }
    v14 = (padded_len * (_DWORD)v6) << (v2[2] == 0);
    v15 = get_padded_len(v6, 8u);
    padded_bytes = get_padded_bytes(4 * (v14 + ((int)v6 + (int)v6 * v3) * v15), 8u);
    result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes;
  }
  return result;
}

uint64_t att_albert_dispatch_weights(uint64_t a1)
{
  unsigned int *v2;
  int padded_len;
  unsigned int padded_bytes;
  uint64_t v5;
  uint64_t result;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;

  v15 = 0;
  v2 = *(unsigned int **)(a1 + 120);
  padded_len = get_padded_len(*v2, 8u);
  padded_bytes = 0;
  v5 = *(_QWORD *)(a1 + 72);
  if (v2[7] == 1)
  {
    result = fi_layer_find_weights_via_offset(*((_QWORD *)v2 + 9), v5, &v15);
    if ((_DWORD)result)
      return result;
    padded_bytes = get_padded_bytes(v15, 8u);
  }
  *((_QWORD *)v2 + 11) = v5 + padded_bytes;
  v7 = 4 * padded_len * padded_len;
  v15 = padded_bytes + v7;
  v8 = get_padded_bytes(padded_bytes + v7, 8u);
  *((_QWORD *)v2 + 14) = v5 + v8;
  v15 = v8 + 4 * padded_len;
  v9 = get_padded_bytes(v15, 8u);
  *((_QWORD *)v2 + 10) = v5 + v9;
  v15 = v9 + v7;
  v10 = get_padded_bytes(v9 + v7, 8u);
  *((_QWORD *)v2 + 13) = v5 + v10;
  v15 = v10 + 4 * padded_len;
  v11 = get_padded_bytes(v15, 8u);
  *((_QWORD *)v2 + 12) = v5 + v11;
  v15 = v11 + v7;
  v12 = get_padded_bytes(v11 + v7, 8u);
  *((_QWORD *)v2 + 15) = v5 + v12;
  v15 = v12 + 4 * padded_len;
  v13 = get_padded_bytes(v15, 8u);
  *((_QWORD *)v2 + 17) = v5 + v13;
  v15 = v13 + v7;
  v14 = get_padded_bytes(v13 + v7, 8u);
  *((_QWORD *)v2 + 16) = v5 + v14;
  get_padded_bytes(v14 + 4 * padded_len, 8u);
  return 0;
}

uint64_t att_albert_layer_reset(uint64_t a1)
{
  uint64_t v1;

  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 120);
    if (*(_DWORD *)(v1 + 20) == 1)
    {
      *(_QWORD *)(v1 + 144) = 0;
      *(_DWORD *)(v1 + 152) = 0;
      *(_OWORD *)(v1 + 160) = 0u;
      *(_OWORD *)(v1 + 176) = 0u;
    }
  }
  return 0;
}

uint64_t att_albert_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t config_convtrans1d_layer(int a1, int a2, int a3, int a4, int a5, int a6, int a7, uint64_t a8)
{
  uint64_t result;

  *(_DWORD *)a8 = a2;
  *(_DWORD *)(a8 + 4) = 0;
  if (a3 != 1)
    return 7;
  *(_QWORD *)(a8 + 8) = 1;
  *(_DWORD *)(a8 + 16) = a1;
  if (a2 != 2 * a4)
    return 7;
  *(_DWORD *)(a8 + 20) = a4;
  *(_DWORD *)(a8 + 24) = a5;
  if (a6 != 1)
    return 7;
  result = 0;
  *(_DWORD *)(a8 + 28) = 1;
  *(_DWORD *)(a8 + 32) = a7;
  return result;
}

uint64_t forward_convtrans1d_layer(uint64_t a1, uint64_t a2, float *a3, float32x4_t *a4, uint64_t a5)
{
  _DWORD *v8;
  char *v9;
  unsigned int v10;
  uint64_t v11;
  _BOOL4 is_enabled;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  _BOOL4 v18;
  char *v19;
  uint64_t result;
  unsigned int step;
  unsigned int v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  _DWORD *v28;
  uint64_t v29;
  const char *v30;
  int v31;
  float *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  unsigned int v36;
  char *v37;
  uint64_t *v39;
  _OWORD v40[2];
  uint64_t v41;

  v39 = *(uint64_t **)a2;
  v8 = *(_DWORD **)(a2 + 120);
  v9 = *(char **)(a2 + 72);
  v41 = 0;
  v11 = v8[4];
  v10 = v8[5];
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a2 + 256), 4u, *(_DWORD *)(a2 + 264));
  v13 = fi_feat_is_enabled(*(_QWORD *)(a2 + 256), 7u, *(_DWORD *)(a2 + 264));
  memset(v40, 0, sizeof(v40));
  v17 = *(const void **)(a2 + 104);
  v18 = is_enabled || v13;
  if ((is_enabled || v13) && v9)
  {
    v19 = &v9[4 * *(unsigned int *)v9];
  }
  else
  {
    v19 = v9;
    if (!v9)
    {
      v29 = **(_QWORD **)a2;
      v30 = "convtrans1d weight not found";
LABEL_18:
      log_OutText(v29, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v14, v15, v16, v33);
      return 7;
    }
  }
  v37 = v19;
  result = fi_shape_get_size((int *)(a2 + 40), (int *)&v41);
  if ((_DWORD)result)
    return result;
  v36 = v10;
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  if (!step)
  {
    v29 = **(_QWORD **)a2;
    v30 = "steps must > 0, but it is: %d";
    v33 = 0;
    goto LABEL_18;
  }
  v22 = step;
  result = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v41 + 1);
  if ((_DWORD)result)
    return result;
  if (v22 >= 2)
  {
    v23 = HIDWORD(v41);
    if (get_padded_len(HIDWORD(v41), 8u) != v23)
    {
      v29 = *v39;
      v30 = "If code reaches here, then there is possibility that GEMM in convtrans1d is incorrect!";
      goto LABEL_18;
    }
  }
  v35 = v22;
  v34 = a5;
  if (v8[6] == 1)
  {
    v24 = v36 + v36 * v22;
    if ((_DWORD)v24)
    {
      v25 = 0;
      do
      {
        cstdlib_memcpy(&a4->f32[v25], v17, 4 * v11);
        v25 += v11;
        --v24;
      }
      while (v24);
    }
  }
  if (v18)
  {
    v26 = v34;
    v27 = v36;
    DWORD2(v40[0]) = ((*((_DWORD *)v9 + 1) >> 1) & 1) == 0;
    v28 = v40;
  }
  else
  {
    v28 = 0;
    v26 = v34;
    v27 = v36;
  }
  v31 = HIDWORD(v41);
  if (v31 == get_padded_len(HIDWORD(v41), 8u))
    v32 = a3;
  else
    v32 = 0;
  gemm_ex(v39, v35, *v8 * v11, v8[1], v32, v8[1], v37, v8[1], a4, (*v8 * v11) >> 1, v28);
  cstdlib_memmove(a4, &a4->f32[(v27 >> 1) * v11], 4 * (v41 - v27 * (_DWORD)v11));
  fi_activate_array(a4->f32, v41 - v27 * (_DWORD)v11, v8[8]);
  result = 0;
  *(_DWORD *)(a2 + 44) = v35 * v27;
  *(_DWORD *)(v26 + 20) = 1;
  return result;
}

_QWORD *free_convtrans1d_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_convtrans1d_layer(uint64_t *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11
    && (v12 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64)) != 0)
  {
    *(_QWORD *)(v11 + 120) = v12;
    *(_QWORD *)v11 = a1;
    cstdlib_memcpy(v12, a2, 0x24uLL);
    *(_QWORD *)(v11 + 8) = 69;
    *(_QWORD *)(v11 + 144) = convtrans1d_layer_update_shape;
    *(_QWORD *)(v11 + 152) = conv_layer_wanted_wb_len;
    *(_QWORD *)(v11 + 128) = forward_convtrans1d_layer;
    *(_QWORD *)(v11 + 136) = free_convtrans1d_layer;
    if (a3)
    {
      result = 0;
      *(_QWORD *)(v11 + 256) = *(_QWORD *)(a3 + 24);
      *(_DWORD *)(v11 + 264) = *(_DWORD *)(a3 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v13, v14, v15, v17);
      result = 0;
      *(_QWORD *)(v11 + 256) = 0;
      *(_DWORD *)(v11 + 264) = 0;
    }
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v17);
    free_convtrans1d_layer((_QWORD *)v11);
    result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t convtrans1d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v10;
  uint64_t result;
  uint64_t v12;

  if (*a2 == 2)
  {
    v10 = *(_DWORD **)(a1 + 120);
    cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
    result = 0;
    v10[1] = a2[2];
    v10[3] = 1;
    *(_DWORD *)(a1 + 40) = 2;
    *(_DWORD *)(a1 + 44) = *v10 - v10[5] + a2[1] * v10[5];
    *(_DWORD *)(a1 + 48) = v10[4];
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"convtrans1d requires input 2D input data", a6, a7, a8, v12);
    return 7;
  }
  return result;
}

uint64_t create_rnn_layer(uint64_t *a1, unsigned int *a2, const void *a3, const void *a4, uint64_t ***a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t **v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  uint64_t v23;

  v13 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v13)
    goto LABEL_10;
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v14)
    goto LABEL_10;
  v15 = (uint64_t *)v14;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 32);
  if (!v16)
    goto LABEL_10;
  v17 = (_QWORD *)v16;
  *v13 = a1;
  v18 = a2[1];
  cstdlib_memcpy(v13 + 1, a2, 0xCuLL);
  if (a4)
    cstdlib_memcpy((char *)v13 + 60, a4, 8uLL);
  v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v18, 4);
  *v15 = v19;
  if (v19
    && (v15[1] = (uint64_t)v17,
        v20 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[1], 4),
        (v17[2] = v20) != 0)
    && (v21 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], a2[1], 4),
        (v17[3] = v21) != 0))
  {
    cstdlib_memcpy(v17, a3, 0xCuLL);
    result = 0;
    v13[15] = v15;
    v13[16] = (uint64_t *)forward_rnn_layer;
    v13[17] = (uint64_t *)free_rnn_buffer;
    v13[18] = (uint64_t *)rnn_layer_update_shape;
    v13[19] = (uint64_t *)rnn_layer_wanted_wb_len;
    *a5 = v13;
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v23);
    *a5 = v13;
    free_rnn_buffer(v13);
    return 10;
  }
  return result;
}

uint64_t forward_rnn_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  float32x4_t *v12;
  float32x4_t *v13;
  _DWORD *v14;
  uint64_t result;
  unsigned int padded_len;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  unsigned int v23;
  int v24;
  float *v25;
  int v26;
  unsigned int v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  float *v32;
  char *v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  int step;
  void *__b;
  unsigned int v41;

  v7 = *(uint64_t **)a2;
  v8 = *(_QWORD *)(*(_QWORD *)(a2 + 120) + 8);
  __b = **(void ***)(a2 + 120);
  v10 = *(_DWORD *)v8;
  v9 = *(_DWORD *)(v8 + 4);
  v11 = *(_DWORD *)(v8 + 8);
  v12 = *(float32x4_t **)(v8 + 16);
  v13 = *(float32x4_t **)(v8 + 24);
  v41 = 0;
  v14 = (_DWORD *)(a2 + 20);
  result = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v41);
  if (!(_DWORD)result)
  {
    v31 = v7;
    v35 = v10;
    v36 = v9;
    v37 = a3;
    padded_len = get_padded_len(v41, 8u);
    v17 = *(unsigned int *)(a2 + 12);
    v18 = get_padded_len(v17, 8u);
    v38 = *(char **)(a2 + 72);
    if (!v11)
      cstdlib_memset(__b, 0, 4 * v17);
    step = fi_shape_get_step(v14);
    if (v41 == padded_len)
    {
      v22 = 0;
    }
    else
    {
      v22 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))v7[1])(v7[2], 4 * padded_len);
      if (!v22)
      {
        log_OutText(*v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)"empty new input memory!", v19, v20, v21, v29);
        return 10;
      }
    }
    v34 = a4;
    if (step)
    {
      v23 = 0;
      v24 = 0;
      v33 = &v38[4 * v17 * padded_len];
      v32 = (float *)&v33[4 * (v18 * v17)];
      do
      {
        v25 = (float *)(v37 + 4 * v41 * v24);
        if (v41 == padded_len)
        {
          v26 = v36;
        }
        else
        {
          v26 = v36;
          if (!v22)
          {
            log_OutText(*v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)"empty new input memory!", v19, v20, v21, v29);
            return 0;
          }
          cstdlib_memcpy(v22, (const void *)(v37 + 4 * v41 * v24), 4 * v41);
          v25 = (float *)v22;
        }
        if (v26 == 1)
          v27 = v23;
        else
          v27 = 0;
        v28 = (void *)(v34 + 4 * v27);
        cstdlib_memset(v12, 0, 4 * v17);
        cstdlib_memset(v13, 0, 4 * v17);
        gemm(*(uint64_t **)a2, 1, v17, v41, v25, v38, v12, 0, v29);
        gemm(*(uint64_t **)a2, 1, v17, v17, (float *)__b, v33, v13, 0, v30);
        axpy(v17, v12->f32, 1, v13->f32, 1, 1.0);
        axpy(v17, v32, 1, v13->f32, 1, 1.0);
        fi_activate_array(v13->f32, v17, v35);
        cstdlib_memcpy(__b, v13, 4 * v17);
        cstdlib_memcpy(v28, v13, 4 * v17);
        ++v24;
        v23 += v17;
      }
      while (step != v24);
    }
    if (v22)
      (*(void (**)(uint64_t, void *))(v31[1] + 48))(v31[2], v22);
    return 0;
  }
  return result;
}

_QWORD *free_rnn_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        v4 = v3[1];
        if (v4)
        {
          if (*(_QWORD *)(v4 + 16))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v4 + 16) = 0;
          }
          if (*(_QWORD *)(v4 + 24))
          {
            (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
            *(_QWORD *)(v4 + 24) = 0;
          }
          (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v4);
        }
        if (*v3)
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *v3 = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t rnn_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t result;
  int v12;
  int v13;
  uint64_t v14;

  if (*a2 == 2)
  {
    v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 4);
    cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
    result = 0;
    if (v10 == 1)
    {
      *(_DWORD *)(a1 + 40) = *a2;
      v12 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = a2[1];
      *(_DWORD *)(a1 + 48) = v12;
    }
    else
    {
      v13 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v13;
    }
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only 2D RNN is supported", a6, a7, a8, v14);
    return 7;
  }
  return result;
}

uint64_t rnn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t input_dim;
  int padded_len;
  uint64_t v8;
  unsigned int v10;

  v10 = 0;
  input_dim = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v10);
  if (!(_DWORD)input_dim)
  {
    padded_len = get_padded_len(v10, 8u);
    v8 = *(unsigned int *)(a1 + 12);
    *a2 = 4 * v8 * (get_padded_len(v8, 8u) + padded_len);
    *a3 = 4 * v8;
  }
  return input_dim;
}

uint64_t trans_encoder_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(void);
  uint64_t v17;
  unsigned int v18;

  v9 = *(unsigned int **)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    v10 = *v9;
    result = trans_dec_get_reserved_glbBuf_bytes(a1, &v18);
    if (!(_DWORD)result)
    {
      if ((_DWORD)v10)
      {
        v12 = 0;
        v13 = v18;
        v14 = 8 * v10;
        do
        {
          v15 = *(_QWORD *)(*((_QWORD *)v9 + 6) + v12);
          *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v13;
          *(_DWORD *)(v15 + 248) = *(_DWORD *)(a1 + 248) - v13;
          v16 = *(void (**)(void))(v15 + 168);
          if (v16)
            v16();
          v12 += 8;
        }
        while (v14 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t create_trans_encoder(uint64_t *a1, int *a2, const void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 88);
      v19 = v15;
      if (!v15)
      {
        v29 = *a1;
        v30 = "out of memory!";
LABEL_20:
        log_OutText(v29, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v16, v17, v18, v35);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_encoder init param failed!", v32, v33, v34, v36);
        result = 7;
        goto LABEL_21;
      }
      cstdlib_memcpy(v15, a2, 0x30uLL);
      v20 = *a2;
      v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v20, 8);
      *((_QWORD *)v19 + 6) = v21;
      if (!v21)
      {
        v27 = *a1;
        v28 = "out of memory!";
        goto LABEL_19;
      }
      if ((_DWORD)v20)
      {
        v25 = 0;
        v26 = 8 * v20;
        while (!create_trans_enc_layer(a1, a2 + 1, a3, a4, (uint64_t *)(*((_QWORD *)v19 + 6) + v25)))
        {
          v25 += 8;
          if (v26 == v25)
            goto LABEL_10;
        }
        v27 = *a1;
        v28 = "create trans_encoder trans_enc layer failed!";
        goto LABEL_19;
      }
LABEL_10:
      v40 = 0;
      v39 = 40;
      if (create_norm_layer(a1, &v39, (_QWORD *)v19 + 7))
      {
        v27 = *a1;
        v28 = "create trans_encoder norm layer failed!";
LABEL_19:
        log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v22, v23, v24, v35);
        v29 = *a1;
        v30 = "trans_encoder network init failed!";
        goto LABEL_20;
      }
      v31 = a2[10];
      v37 = a2[5];
      v38 = v31;
      if (create_embedding_layer(a1, &v37, (uint64_t ***)v19 + 9)
        || (v37 = a2[5], v38 = 32, create_embedding_layer(a1, &v37, (uint64_t ***)v19 + 8)))
      {
        v27 = *a1;
        v28 = "create trans_encoder target_space_id emb layer failed!";
        goto LABEL_19;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 8) = 36;
      *(_QWORD *)(v7 + 128) = forward_trans_encoder;
      *(_QWORD *)(v7 + 136) = free_trans_encoder;
      *(_QWORD *)(v7 + 144) = trans_encoder_update_shape;
      *(_QWORD *)(v7 + 152) = trans_encoder_wanted_wb_len;
      *(_QWORD *)(v7 + 160) = trans_encoder_request_glbBuf;
      *(_QWORD *)(v7 + 168) = trans_encoder_assign_glbBuf;
      *(_QWORD *)(v7 + 176) = trans_encoder_reset;
      *(_QWORD *)(v7 + 184) = trans_encoder_dispatch_weights;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v22, v23, v24, v35);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v35);
      result = 10;
    }
  }
LABEL_21:
  *a5 = v7;
  return result;
}

uint64_t forward_trans_encoder(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t bytes;
  uint64_t v16;
  const char *v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t updated;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  float *v36;
  char *v37;
  int step;
  unsigned int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  float *v49;
  int v50;
  float v51;
  unint64_t v52;
  float *v53;
  float *v54;
  uint64_t v55;
  uint64_t v56;
  _QWORD __dst[2];
  int v58;
  float v59;
  size_t __len;

  LODWORD(__len) = 0;
  if (!a2)
    return 0;
  if (a5)
    *(_DWORD *)(a5 + 20) = 1;
  __dst[0] = 0;
  __dst[1] = 0;
  v58 = 0;
  v11 = *(uint64_t **)a2;
  v12 = *(unsigned int **)(a2 + 120);
  if (!v12)
  {
    v16 = *v11;
    v17 = "config empty";
    goto LABEL_14;
  }
  v13 = 1;
  while (v12[11] != *(float *)(a3 + 4 * (v13 - 1)))
  {
    if (v13++ > v12[7])
      return 7;
  }
  if (v13 <= 1)
  {
    v16 = *v11;
    v17 = "No input given to encoder.";
LABEL_14:
    log_OutText(v16, (uint64_t)"FastInfer", 0, 0, (uint64_t)v17, a6, a7, a8, v56);
    return 7;
  }
  cstdlib_memcpy(__dst, (const void *)(a2 + 20), 0x14uLL);
  v25 = v12[7];
  if (v13 < v25)
    v25 = v13;
  HIDWORD(__dst[0]) = v25;
  updated = trans_encoder_update_shape(a2, __dst, v19, v20, v21, v22, v23, v24);
  if ((_DWORD)updated)
  {
    bytes = updated;
    v27 = *v11;
    v28 = fi_layer_type_to_name(*(_DWORD *)(a2 + 8));
    v32 = "update shape of %s layer failed!";
    v56 = (uint64_t)v28;
    v33 = v27;
  }
  else
  {
    v34 = v12[9];
    v59 = (float)v34;
    v35 = *v12;
    bytes = fi_shape_get_bytes((int *)(*((_QWORD *)v12 + 9) + 40), &__len);
    if ((_DWORD)bytes)
      return bytes;
    v36 = *(float **)(a2 + 240);
    v37 = (char *)v36 + (__len & 0xFFFFFFFC);
    step = fi_shape_get_step((_DWORD *)(*((_QWORD *)v12 + 9) + 40));
    (*(void (**)(uint64_t))(*((_QWORD *)v12 + 9) + 128))(a1);
    if (step)
    {
      v39 = 0;
      v40 = 0;
      v41 = v12[5];
      do
      {
        if ((_DWORD)v41)
        {
          v42 = *((_QWORD *)v12 + 10);
          v43 = v41;
          v44 = v39;
          do
          {
            *(float *)&v37[4 * v44] = *(float *)(v42 + 4 * v44) + *(float *)&v37[4 * v44];
            ++v44;
            --v43;
          }
          while (v43);
        }
        ++v40;
        v39 += v41;
      }
      while (v40 != step);
    }
    if ((v34 & 0x80000000) == 0)
    {
      (*(void (**)(uint64_t))(*((_QWORD *)v12 + 8) + 128))(a1);
      if (step)
      {
        v45 = 0;
        v46 = 0;
        v47 = v12[5];
        do
        {
          if ((_DWORD)v47)
          {
            v48 = v47;
            v49 = v36;
            v50 = v45;
            do
            {
              v51 = *v49++;
              *(float *)&v37[4 * v50] = v51 + *(float *)&v37[4 * v50];
              ++v50;
              --v48;
            }
            while (v48);
          }
          ++v46;
          v45 += v47;
        }
        while (v46 != step);
      }
    }
    if ((_DWORD)v35)
    {
      v52 = 0;
      if ((v35 & 1) != 0)
        v53 = v36;
      else
        v53 = a4;
      while (1)
      {
        v54 = v53;
        cstdlib_memset(v53, 0, __len);
        v55 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)v12 + 6) + 8 * v52) + 128))(a1);
        if ((_DWORD)v55)
          break;
        if (v54 == a4)
          v53 = v36;
        else
          v53 = a4;
        if (v52 >= (v35 - 1))
          v53 = v54;
        if (v35 == ++v52)
          goto LABEL_47;
      }
      bytes = v55;
      v33 = *v11;
      v32 = "trans_encoder forward trans_enc layer failed!";
    }
    else
    {
LABEL_47:
      cstdlib_memset(a4, 0, __len);
      bytes = (*(uint64_t (**)(uint64_t))(*((_QWORD *)v12 + 7) + 128))(a1);
      if (!(_DWORD)bytes)
        return bytes;
      v33 = *v11;
      v32 = "trans_encoder forward norm layer failed!";
    }
  }
  log_OutText(v33, (uint64_t)"FastInfer", 0, 0, (uint64_t)v32, v29, v30, v31, v56);
  return bytes;
}

_QWORD *free_trans_encoder(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (_QWORD *)result[15];
      if (v3)
      {
        v4 = *(unsigned int *)v3;
        fi_layer_free(v3[7]);
        fi_layer_free(v3[8]);
        fi_layer_free(v3[9]);
        if ((_DWORD)v4)
        {
          v5 = 0;
          v6 = 8 * v4;
          do
          {
            fi_layer_free(*(_QWORD *)(v3[6] + v5));
            v5 += 8;
          }
          while (v6 != v5);
        }
        if (v3[6])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v3[6] = 0;
        }
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t trans_encoder_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t *v9;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  const char *v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  int v28;

  v8 = *(unsigned int **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  v24 = 0;
  if (!v8)
  {
    v14 = *v9;
    v15 = "out of memory!";
    goto LABEL_7;
  }
  v12 = *v8;
  v13 = (int *)(a1 + 20);
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 >= 2u)
  {
    v14 = *v9;
    v15 = "Currently trans_encoder layer only support 1D input";
LABEL_7:
    log_OutText(v14, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, a6, a7, a8, v23);
    return 7;
  }
  fi_shape_get_input_dim(v13, (int *)&v24);
  if (v24 > v8[7])
  {
    v14 = *v9;
    v15 = "Encoder input shape dimension must be maximum %d. Found %d";
    v23 = v8[7];
    goto LABEL_7;
  }
  result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 9) + 144))();
  if (!(_DWORD)result)
  {
    if ((_DWORD)v12)
    {
      v17 = 0;
      v18 = *((_QWORD *)v8 + 6);
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v18 + v17) + 144))();
        if ((_DWORD)result)
          break;
        v18 = *((_QWORD *)v8 + 6);
        v17 += 8;
        if (8 * v12 == v17)
          goto LABEL_14;
      }
    }
    else
    {
LABEL_14:
      result = (*(uint64_t (**)(void))(*((_QWORD *)v8 + 7) + 144))();
      if (!(_DWORD)result)
      {
        v19 = *((_QWORD *)v8 + 7);
        v21 = *(_DWORD *)(v19 + 40);
        v20 = (const void *)(v19 + 40);
        if ((v21 - 1) < 2)
        {
          cstdlib_memcpy((void *)(a1 + 40), v20, 0x14uLL);
          v25 = 0x100000001;
          v22 = v8[5];
          v26 = 32;
          v27 = v22;
          v28 = 4;
          return (*(uint64_t (**)(void))(*((_QWORD *)v8 + 8) + 144))();
        }
        v14 = **(_QWORD **)a1;
        v15 = "dense out: output shape error";
        goto LABEL_7;
      }
    }
  }
  return result;
}

uint64_t trans_encoder_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v12;
  uint64_t v13;
  int padded_bytes;
  uint64_t v15;
  uint64_t result;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v27 = 0;
  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v12 = *v9;
    if ((_DWORD)v12)
    {
      v13 = 0;
      padded_bytes = 0;
      v15 = 8 * v12;
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v9 + 6) + v13) + 152))();
        if ((_DWORD)result)
          break;
        padded_bytes = get_padded_bytes(HIDWORD(v27) + padded_bytes + (int)v27, 8u);
        v13 += 8;
        if (v15 == v13)
          goto LABEL_9;
      }
    }
    else
    {
      padded_bytes = 0;
LABEL_9:
      result = (*(uint64_t (**)(void))(*((_QWORD *)v9 + 7) + 152))();
      if (!(_DWORD)result)
      {
        v17 = get_padded_bytes(HIDWORD(v27) + padded_bytes + (int)v27, 8u);
        result = (*(uint64_t (**)(void))(*((_QWORD *)v9 + 8) + 152))();
        if (!(_DWORD)result)
        {
          v18 = get_padded_bytes(HIDWORD(v27) + (int)v27 + v17, 8u);
          result = (*(uint64_t (**)(_QWORD, char *, uint64_t *))(*((_QWORD *)v9 + 8) + 152))(*((_QWORD *)v9 + 9), (char *)&v27 + 4, &v27);
          if (!(_DWORD)result)
          {
            v19 = get_padded_bytes(HIDWORD(v27) + (int)v27 + v18, 8u);
            *a2 = get_padded_bytes(v19 + 4 * v9[7] * v9[5], 8u);
            *a3 = 0;
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v20, v21, v22, *(unsigned int *)(a1 + 96));
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v23, v24, v25, *a2);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v26);
    return 7;
  }
  return result;
}

uint64_t trans_encoder_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(void);
  uint64_t result;
  int padded_bytes;
  uint64_t v19;
  unsigned int v20;

  v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    v10 = *v9;
    if ((_DWORD)v10)
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v14 = *((_QWORD *)v9 + 6);
      v15 = 8 * v10;
      do
      {
        v16 = *(uint64_t (**)(void))(*(_QWORD *)(v14 + v11) + 160);
        if (v16)
        {
          result = v16();
          if ((_DWORD)result)
            return result;
          v14 = *((_QWORD *)v9 + 6);
          v13 = *(_DWORD *)(*(_QWORD *)(v14 + v11) + 248);
          if (v13 > v12)
            v12 = *(_DWORD *)(*(_QWORD *)(v14 + v11) + 248);
        }
        v11 += 8;
      }
      while (v15 != v11);
    }
    else
    {
      v13 = 0;
      v12 = 0;
    }
    v20 = v13;
    result = trans_dec_get_reserved_glbBuf_bytes(a1, &v20);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(v20 + v12, 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v19);
    return 7;
  }
  return result;
}

uint64_t trans_encoder_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int padded_bytes;

  v8 = *(unsigned int **)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    *((_QWORD *)v8 + 10) = v9;
    padded_bytes = get_padded_bytes(4 * v8[5] * v8[7], 8u);
    result = fi_layer_find_weights_via_offset(*((_QWORD *)v8 + 9), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      v11 = *v8;
      if ((_DWORD)v11)
      {
        v12 = 0;
        v13 = 8 * v11;
        while (1)
        {
          v14 = *(_QWORD *)(*((_QWORD *)v8 + 6) + v12);
          if (!v14)
            return 10;
          result = fi_layer_find_weights_via_offset(v14, v9, &padded_bytes);
          if ((_DWORD)result)
            return result;
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          v12 += 8;
          if (v13 == v12)
            goto LABEL_8;
        }
      }
      else
      {
LABEL_8:
        result = fi_layer_find_weights_via_offset(*((_QWORD *)v8 + 7), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*((_QWORD *)v8 + 8), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            get_padded_bytes(padded_bytes, 8u);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v15);
    return 7;
  }
  return result;
}

uint64_t trans_encoder_reset(uint64_t a1)
{
  unsigned int *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  v1 = *(unsigned int **)(a1 + 120);
  v2 = *v1;
  if (!(_DWORD)v2)
    return 0;
  v4 = 0;
  v5 = 8 * v2;
  while (!(*(unsigned int (**)(void))(*(_QWORD *)(*((_QWORD *)v1 + 6) + v4) + 176))())
  {
    v4 += 8;
    if (v5 == v4)
      return 0;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_encoder network reset failed!", v6, v7, v8, v10);
  return 7;
}

uint64_t trans_encoder_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t get_lstm_step_f(_QWORD *a1, unsigned int a2)
{
  uint64_t result;

  if (a2 > 3)
    return 7;
  result = 0;
  *a1 = off_24D29AFB8[a2];
  return result;
}

uint64_t lstm_step_f32_4_small_matrix(uint64_t *a1, float *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, float *a9, float *a10, float *a11, int a12, int a13, uint64_t a14, unsigned int a15, _DWORD *a16, _DWORD *a17)
{
  int padded_len;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  char *v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  float32x4_t *v29;
  float32x4_t *v30;
  float32x4_t *v31;
  size_t v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *__len;
  char *v44;
  float *v45;
  char *v46;
  char *v47;
  float *v48;
  char *v49;
  float *v50;
  char *v52;

  padded_len = get_padded_len(a4, 8u);
  v21 = get_padded_len(a5, 8u);
  v22 = v21;
  if (a16[1] == 1 && !*a16)
    v23 = v21;
  else
    v23 = a5;
  v24 = (char *)(a14 + 4 * a15);
  v25 = (char *)(a8 + 4 * a15);
  if (a16[2])
    v26 = padded_len * a5;
  else
    v26 = v21 * a4;
  v27 = v26 + a15;
  __len = &v25[4 * v27];
  v28 = a15 + v21 * a5;
  v49 = &v25[12 * v27];
  v44 = &v24[4 * v28];
  v46 = &v25[8 * v27];
  v47 = &v24[8 * v28];
  v45 = &a9[v23];
  v48 = &a9[2 * v23];
  v50 = &a9[3 * v23];
  v52 = &v24[12 * v28];
  cstdlib_memset(a7, 0, 16 * v21);
  v29 = (float32x4_t *)((char *)a7 + 4 * v22);
  v30 = (float32x4_t *)((char *)a7 + 8 * v22);
  v31 = (float32x4_t *)((char *)a7 + 12 * v22);
  gemm(a1, 1, a5, a4, a2, v25, a7, a16, v34);
  gemm(a1, 1, a5, a5, a10, v24, v30, a17, v35);
  axpy(a5, a9, 1, a7->f32, 1, 1.0);
  axpy(a5, v30->f32, 1, a7->f32, 1, 1.0);
  fi_activate_array(a7->f32, a5, a13);
  gemm(a1, 1, a5, a4, a2, __len, v31, a16, v36);
  cstdlib_memset(v30, 0, 4 * a5);
  gemm(a1, 1, a5, a5, a10, v44, v30, a17, v37);
  axpy(a5, v45, 1, v31->f32, 1, 1.0);
  axpy(a5, v30->f32, 1, v31->f32, 1, 1.0);
  fi_activate_array(v31->f32, a5, a13);
  gemm(a1, 1, a5, a4, a2, v46, v29, a16, v38);
  v32 = 4 * a5;
  cstdlib_memset(v30, 0, v32);
  gemm(a1, 1, a5, a5, a10, v47, v30, a17, v39);
  axpy(a5, v48, 1, v29->f32, 1, 1.0);
  axpy(a5, v30->f32, 1, v29->f32, 1, 1.0);
  fi_activate_array(v29->f32, a5, a12);
  xmy(a5, a11, 1, v31->f32, 1);
  xmy(a5, a7->f32, 1, v29->f32, 1);
  axpy(a5, v31->f32, 1, v29->f32, 1, 1.0);
  cstdlib_memset(v30, 0, v32);
  gemm(a1, 1, a5, a4, a2, v49, v30, a16, v40);
  cstdlib_memset(v31, 0, v32);
  gemm(a1, 1, a5, a5, a10, v52, v31, a17, v41);
  axpy(a5, v50, 1, v30->f32, 1, 1.0);
  axpy(a5, v31->f32, 1, v30->f32, 1, 1.0);
  fi_activate_array(v30->f32, a5, a13);
  cstdlib_memcpy(a11, v29, v32);
  fi_activate_array(v29->f32, a5, a12);
  xmy(a5, v30->f32, 1, v29->f32, 1);
  cstdlib_memcpy(a10, v29, v32);
  cstdlib_memcpy(a3, v29, v32);
  return 0;
}

uint64_t lstm_step_f32_1_big_matrix_x_4h(uint64_t *a1, float *a2, void *a3, unsigned int a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, const void *a9, float *a10, float *a11, int a12, int a13, uint64_t a14, unsigned int a15, _DWORD *a16, _DWORD *a17)
{
  char *v20;
  int padded_len;
  float32_t *v22;
  float32_t *v23;
  float32_t *v24;
  uint64_t v26;
  uint64_t v27;

  v20 = (char *)(a8 + 4 * a15);
  padded_len = get_padded_len(a5, 8u);
  cstdlib_memcpy(a7, a9, 4 * (4 * a5));
  cstdlib_memset(&a7->f32[4 * padded_len], 0, 4 * (4 * padded_len));
  gemm(a1, 1, 4 * a5, a4, a2, v20, a7, a16, v26);
  gemm(a1, 1, 4 * a5, a5, a10, (char *)(a14 + 4 * a15), a7, a17, v27);
  v22 = &a7->f32[padded_len];
  cstdlib_memmove(v22, &a7->f32[a5], 4 * (3 * a5));
  v23 = &a7->f32[2 * padded_len];
  cstdlib_memmove(v23, &v22[a5], 4 * (2 * a5));
  v24 = &a7->f32[3 * padded_len];
  cstdlib_memmove(v24, &v23[a5], 4 * a5);
  fi_activate_array(a7->f32, a5, a13);
  fi_activate_array(v22, a5, a13);
  fi_activate_array(v23, a5, a12);
  fi_activate_array(v24, a5, a13);
  xmy(a5, a11, 1, v22, 1);
  xmy(a5, a7->f32, 1, v23, 1);
  axpy(a5, v22, 1, v23, 1, 1.0);
  cstdlib_memcpy(a11, v23, 4 * a5);
  fi_activate_array(v23, a5, a12);
  xmy(a5, v24, 1, v23, 1);
  cstdlib_memcpy(a10, v23, 4 * a5);
  cstdlib_memcpy(a3, v23, 4 * a5);
  return 0;
}

uint64_t lstm_step_f32_svd(uint64_t *a1, float *a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7, char *a8, const void *a9, float *a10, float *a11, int a12, int a13, uint64_t a14, uint64_t a15, _DWORD *a16, _DWORD *a17)
{
  int padded_len;
  unsigned int v24;
  char *v25;
  float32x4_t *v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  uint64_t v30;
  float *v31;
  float *v32;
  float *v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  padded_len = get_padded_len(a4, 8u);
  v24 = get_padded_len(a5, 8u);
  v25 = &a8[4 * (padded_len * a6)];
  cstdlib_memset(a7, 0, 32 * v24);
  v26 = &a7[v24];
  gemm(a1, 1, a6, a4, a2, a8, a7, a16, v35);
  gemm(a1, 1, a6, a5, a10, v25, v26, a17, v36);
  axpy(a6, v26->f32, 1, a7->f32, 1, 1.0);
  cstdlib_memcpy(v26, a9, 4 * (4 * a5));
  gemm(a1, 1, 4 * a5, a6, a7->f32, &v25[4 * v24 * a6], v26, a17, v37);
  if (v24 == (_DWORD)a5)
  {
    v27 = v24;
    v28 = 2 * v24;
    v29 = 4 * a5;
    v30 = 3 * v24;
  }
  else
  {
    v30 = 3 * v24;
    v29 = 4 * a5;
    cstdlib_memmove(&v26->f32[v30], &v26->f32[(3 * a5)], v29);
    v28 = 2 * v24;
    cstdlib_memmove(&v26->f32[v28], &v26->f32[(2 * a5)], v29);
    v27 = v24;
    cstdlib_memmove(&v26->f32[v24], (char *)v26 + v29, v29);
  }
  v31 = &v26->f32[v27];
  v32 = &v26->f32[v28];
  v33 = &v26->f32[v30];
  fi_activate_array(v26->f32, a5, a13);
  fi_activate_array(v31, a5, a13);
  fi_activate_array(v32, a5, a12);
  fi_activate_array(v33, a5, a13);
  fi_multiply_multiply_add_ansic(a11, v31, v26->f32, v32, a3, a5);
  cstdlib_memcpy(a11, a3, v29);
  fi_activate_array(a3, a5, a12);
  xmy(a5, v33, 1, a3, 1);
  cstdlib_memcpy(a10, a3, v29);
  return 0;
}

uint64_t lstm_step_f32_1_big_matrix_x_4h_peephole(uint64_t *a1, float *a2, float *a3, unsigned int a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, const void *a9, float *a10, float *a11, int a12, int a13, uint64_t a14, unsigned int a15, _DWORD *a16, _DWORD *a17, int a18)
{
  uint64_t v19;
  float *v21;
  float *v22;
  unsigned int padded_len;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  float *v27;
  float *v28;
  float *v29;
  float *v30;
  float v31;
  float v32;
  float v33;
  float v34;
  uint64_t v37;
  char *v38;
  int v40;
  char *v41;
  uint64_t v43;

  v19 = a5;
  v21 = a11;
  v22 = a10;
  v38 = (char *)(a8 + 4 * a15);
  v41 = (char *)(a14 + 4 * a15);
  padded_len = get_padded_len(a5, 8u);
  v40 = get_padded_len((4 * v19), 8u);
  v24 = a1;
  cstdlib_memcpy(a7, a9, 16 * padded_len);
  cstdlib_memset(&a7[padded_len], 0, 16 * padded_len);
  gemm(a1, 1, 4 * v19, a4, a2, v38, a7, a16, (uint64_t)a1);
  if (a18 == 1)
    gemm(v24, 1, 4 * v19, v19, a10, v41, a7, a17, v37);
  v25 = padded_len;
  if (padded_len == (_DWORD)v19)
  {
    v43 = 2 * padded_len;
    v26 = 3 * padded_len;
  }
  else
  {
    cstdlib_memmove(&a7->f32[padded_len], &a7->f32[v19], 4 * (3 * v19));
    v43 = 2 * padded_len;
    cstdlib_memmove(&a7->f32[v43], &a7->f32[padded_len + v19], 4 * (2 * v19));
    v26 = 3 * padded_len;
    cstdlib_memmove(&a7->f32[v26], &a7->f32[v43 + v19], 4 * v19);
  }
  v27 = (float *)&v41[4 * (v40 * v19)];
  fi_multiply_add_ansic(a7->f32, a11, v27, v19);
  v28 = &a7->f32[v25];
  fi_multiply_add_ansic(v28, a11, &v27[v25], v19);
  v29 = &a7->f32[v43];
  v30 = &a7->f32[v26];
  fi_activate_array(a7->f32, v19, a13);
  fi_activate_array(v28, v19, a13);
  fi_activate_array(v29, v19, a12);
  fi_multiply_multiply_add_ansic(a11, v28, a7->f32, v29, a11, v19);
  fi_multiply_add_ansic(v30, a11, &v27[v43], v19);
  fi_activate_array(v30, v19, a13);
  if ((_DWORD)v19)
  {
    v19 = v19;
    do
    {
      v31 = *v30++;
      v32 = v31;
      v33 = *v21++;
      v34 = v32 * tanhf(v33);
      *v22++ = v34;
      *a3++ = v34;
      --v19;
    }
    while (v19);
  }
  return 0;
}

uint64_t gru_impl_u32_to_enum(uint64_t *a1, int a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  int v9;
  uint64_t vars0;

  switch(a2)
  {
    case 0:
      result = 0;
      *a3 = 0;
      return result;
    case 1:
      result = 0;
      v9 = 1;
      goto LABEL_8;
    case 2:
      result = 0;
      v9 = 2;
      goto LABEL_8;
    case 3:
      result = 0;
      v9 = 3;
      goto LABEL_8;
    case 4:
      result = 0;
      v9 = 4;
LABEL_8:
      *a3 = v9;
      break;
    default:
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Invalid GRU implementation: %d, expected: 0 (basic), 1 (fast), 2(basic reset-after), 3(fast reset-after)!", a6, a7, a8, vars0);
      result = 7;
      break;
  }
  return result;
}

uint64_t gru_layer_impl_type(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  _DWORD *v3;
  uint64_t result;

  if (!a1)
    return 7;
  v2 = *(_QWORD *)(a1 + 120);
  if (!v2)
    return 7;
  v3 = *(_DWORD **)(v2 + 8);
  if (!v3)
    return 7;
  result = 0;
  *a2 = *v3;
  return result;
}

uint64_t gru_layer_wanted_wb_len(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t is_enabled;
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL4 v11;
  BOOL v12;
  uint64_t *v13;
  uint64_t v14;
  const char *v15;
  uint64_t *v16;
  int *v17;
  int v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t *v28;
  int padded_len;
  int v30;
  int v31;
  int v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t mat_length;
  int v37;
  uint64_t v38;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  int v56;
  int v57;
  unsigned int v58;
  int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;

  v71 = 0;
  is_enabled = fi_feat_is_enabled((uint64_t)a1[32], 4u, *((_DWORD *)a1 + 66));
  v7 = fi_feat_is_enabled((uint64_t)a1[32], 7u, *((_DWORD *)a1 + 66));
  v11 = (is_enabled | v7) != 0;
  if (is_enabled | v7)
    v12 = ((_DWORD)a1[2] & 0xFFFFFFFD) == 1;
  else
    v12 = 0;
  if (!v12 || (v13 = a1[9]) != 0 && (*((_BYTE *)v13 + 4) & 2) != 0)
  {
    v16 = a1[15];
    if (!v16)
      return 7;
    v17 = (int *)v16[1];
    if (!v17)
      return 7;
    v18 = *v17;
    result = fi_shape_get_input_dim((int *)a1 + 5, (int *)&v71);
    if ((_DWORD)result)
      return result;
    v20 = *((unsigned int *)a1 + 3);
    if (v18 == 2)
    {
      v28 = a1[9];
      v21 = v71;
      v22 = **a1;
      if (v28 && (*((_BYTE *)v28 + 4) & 2) != 0)
      {
        v51 = get_padded_len(*((unsigned int *)a1 + 3), 8u) * v21;
        *a2 = ((3 * (v51 + get_padded_len(v20, 8u) * (_DWORD)v20)) << (~(*((_DWORD *)v28 + 1) >> 2) & 2))
            + 24 * *(_DWORD *)v28;
        *a3 = 12 * get_padded_len(v20, 8u);
        get_padded_len(v21, 8u);
        get_padded_len(v20, 8u);
        v55 = "basic reset-after GRU impl (rowMajor): x=%u, padded_x=%u, h=%u, padded_h=%u, wBytes=(3 * padded_h * x + 3 "
              "* padded_h * h) * sizeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*6=%u, bBytes=3 * padded_h * sizeof"
              "(f32)=%u, wBytes+bBytes=%u";
      }
      else
      {
        padded_len = get_padded_len(v71, 8u);
        v30 = 3 * v20 * (get_padded_len(v20, 8u) + padded_len);
        LOBYTE(v31) = 2;
        if (v28)
        {
          v31 = ~(*((_DWORD *)v28 + 1) >> 2) & 2;
          v32 = 24 * *(_DWORD *)v28;
        }
        else
        {
          v32 = 0;
        }
        *a2 = (v30 << v31) + v32;
        *a3 = 24 * get_padded_len(v20, 8u);
        get_padded_len(v21, 8u);
        get_padded_len(v20, 8u);
        v55 = "basic reset-after GRU impl (colMajor):x=%u, h=%u, padded_x=%u, padded_h=%u,wBytes=(3 * PAD(x) * h + 3 * PA"
              "D(h) * h) * sizeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*6=%u, bBytes=3*PAD(h)*sizeof(f32)*2=%u, "
              "wBytes+bBytes=%u";
      }
      goto LABEL_49;
    }
    if (v18 != 1)
    {
      if (v18)
      {
        if ((v18 - 3) <= 1)
          return calc_GRU_IMPL_FAST_RESETAFTER_weights_size(v11, (uint64_t)a1[9], v71, *((unsigned int *)a1 + 3), **a1, a2, a3, v10);
        return 7;
      }
      v21 = v71;
      v22 = **a1;
      if ((_DWORD)is_enabled)
      {
        v23 = a1[9];
        if (v23 && (*((_BYTE *)v23 + 4) & 2) != 0)
        {
          v56 = get_padded_len(*((unsigned int *)a1 + 3), 8u) * v21;
          *a2 = ((3 * (v56 + get_padded_len(v20, 8u) * (_DWORD)v20)) << (~(*((_DWORD *)v23 + 1) >> 2) & 2))
              + 24 * *(_DWORD *)v23;
          *a3 = 12 * get_padded_len(v20, 8u);
          get_padded_len(v21, 8u);
          get_padded_len(v20, 8u);
          v55 = "basic GRU impl: x=%u, padded_x=%u, h=%u, padded_h=%u, wBytes=4*(3*padded_h*x + 3*padded_h*h)=%u, bBytes="
                "4*3*padded_h=%u, wBytes+bBytes=%u";
LABEL_49:
          log_OutText(v22, (uint64_t)"FastInfer", 4, 0, (uint64_t)v55, v52, v53, v54, v21);
          return 0;
        }
        v24 = get_padded_len(v71, 8u);
        v25 = 3 * v20 * (get_padded_len(v20, 8u) + v24);
        LOBYTE(v26) = 2;
        if (v23)
        {
          v26 = ~(*((_DWORD *)v23 + 1) >> 2) & 2;
          v27 = 24 * *(_DWORD *)v23;
        }
        else
        {
          v27 = 0;
        }
        v50 = (v25 << v26) + v27;
      }
      else
      {
        v49 = get_padded_len(v71, 8u);
        v50 = 12 * v20 * (get_padded_len(v20, 8u) + v49);
      }
      *a2 = v50;
      *a3 = 12 * get_padded_len(v20, 8u);
      get_padded_len(v21, 8u);
      get_padded_len(v20, 8u);
      v55 = "basic GRU impl: x=%u, padded_x=%u, h=%u, padded_h=%u, wBytes=4*(3*h*padded_x + 3*h*padded_h)=%u, bBytes=4*3*"
            "padded_h=%u, wBytes+bBytes=%u";
      goto LABEL_49;
    }
    v33 = a1[9];
    v34 = v71;
    v35 = **a1;
    if ((_DWORD)is_enabled && v33)
    {
      is_enabled = *((unsigned int *)v33 + 2);
      if ((_DWORD)is_enabled)
      {
        if ((*((_BYTE *)v33 + 4) & 8) != 0)
        {
          v15 = "Currently not support quantization for block sparse!";
          v14 = **a1;
          goto LABEL_9;
        }
        mat_length = get_mat_length((int *)a1[9]);
        v37 = get_padded_len(mat_length, 8u);
        v38 = get_mat_length((int *)v33);
        v39 = (int *)v33 + get_padded_len(v38, 8u);
        v40 = v39[2];
        *a2 = 4 * (get_mat_length(v39) + v37);
        *a3 = 12 * get_padded_len(v20, 8u);
        v44 = (v34 + v20);
        goto LABEL_55;
      }
    }
    else
    {
      if (!(_DWORD)is_enabled)
      {
        v44 = v71 + v20;
        v59 = get_padded_len(v44, 8u);
        *a2 = 4 * v20 * (get_padded_len(v44, 8u) + 2 * v59);
        v60 = get_padded_len(v20, 8u);
LABEL_54:
        v40 = 0;
        *a3 = 12 * v60;
LABEL_55:
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"hidden : %d\n", v41, v42, v43, v20);
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_1 : %d\n", v61, v62, v63, is_enabled);
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_2 : %d\n", v64, v65, v66, v40);
        get_padded_len(v44, 8u);
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"fast GRU impl: x=%u, h=%u, padded_xh=%u, wBytes=(padded_xh*2h + padded_xh*h)=%u, bBytes=3*h=%u, wBytes+bBytes=%u", v67, v68, v69, v34);
        return 0;
      }
      if (!v33)
        goto LABEL_37;
    }
    if ((*((_BYTE *)v33 + 4) & 2) != 0)
    {
      v44 = v71 + v20;
      v57 = get_padded_len((2 * v20), 8u);
      v58 = (((get_padded_len(v20, 8u) + v57) * (_DWORD)v44) << (~(*((_DWORD *)v33 + 1) >> 2) & 2))
          + 8 * *(_DWORD *)v33;
LABEL_53:
      *a2 = v58;
      v60 = get_padded_len(v20, 8u);
      is_enabled = 0;
      goto LABEL_54;
    }
LABEL_37:
    v44 = v71 + v20;
    v45 = get_padded_len(v44, 8u);
    v46 = (get_padded_len(v44, 8u) + 2 * v45) * v20;
    LOBYTE(v47) = 2;
    if (v33)
    {
      v47 = ~(*((_DWORD *)v33 + 1) >> 2) & 2;
      v48 = 8 * *(_DWORD *)v33;
    }
    else
    {
      v48 = 0;
    }
    v58 = (v46 << v47) + v48;
    goto LABEL_53;
  }
  v14 = **a1;
  v15 = "Model desired row-major weights, which mismatch with provided column-major weights";
LABEL_9:
  log_OutText(v14, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, v8, v9, v10, v70);
  return 7;
}

uint64_t calc_GRU_IMPL_FAST_RESETAFTER_weights_size(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v14;
  uint64_t mat_length;
  int padded_len;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;

  if (a1 && a2)
  {
    v14 = *(unsigned int *)(a2 + 8);
    if ((_DWORD)v14)
    {
      if ((*(_BYTE *)(a2 + 4) & 8) != 0)
      {
        log_OutText(a5, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", (uint64_t)a6, (uint64_t)a7, a8, v50);
        return 7;
      }
      mat_length = get_mat_length((int *)a2);
      padded_len = get_padded_len(mat_length, 8u);
      v17 = get_mat_length((int *)a2);
      v18 = a2 + 4 * get_padded_len(v17, 8u);
      v19 = *(unsigned int *)(v18 + 8);
      *a6 = 4 * (get_mat_length((int *)v18) + padded_len);
      v20 = get_padded_len(a4, 8u);
      goto LABEL_15;
    }
LABEL_8:
    v24 = *(_DWORD *)(a2 + 4);
    if ((v24 & 2) != 0)
    {
      v28 = (3 * a4);
      if ((v24 & 8) != 0)
      {
        v35 = get_padded_len(v28, 0x20u) * a3;
        v30 = v35 + get_padded_len((3 * a4), 0x20u) * a4;
      }
      else
      {
        v29 = get_padded_len(v28, 8u) * a3;
        v30 = 4 * (v29 + get_padded_len((3 * a4), 8u) * a4);
      }
      *a6 = v30 + 8 * *(_DWORD *)a2;
      *a7 = 24 * get_padded_len(a4, 8u);
      get_padded_len(a3, 8u);
      get_padded_len(a4, 8u);
      v39 = a3;
      v40 = "fast resetafter GRU impl(rowMajor): x=%u, h=%u, padded_x=%u, padded_h=%u, wBytes=(x*PAD(3*h) + h*PAD(3*h))*s"
            "izeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*2 = %u, bBytes=3*PAD(h)*sizeof(f32)*2 = %u, wBytes+bBytes=%u";
      goto LABEL_23;
    }
    if ((v24 & 8) != 0)
    {
      v33 = get_padded_len(a3, 0x20u);
      v34 = 3 * a4 * (get_padded_len(a4, 0x20u) + v33) + 8 * *(_DWORD *)a2;
LABEL_22:
      *a6 = v34;
      *a7 = 24 * get_padded_len(a4, 8u);
      get_padded_len(a3, 8u);
      get_padded_len(a4, 8u);
      v39 = a3;
      v40 = "fast resetafter GRU impl(colMajor): x=%u, h=%u, padded_x=%u, padded_h=%u, wBytes=(PAD(x) * (3*h) + PAD(h) * "
            "(3*h)) * sizeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*2 = %u, bBytes=3*PAD(h)*sizeof(f32)*2 = %u, wBytes+bBytes=%u";
LABEL_23:
      log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)v40, v36, v37, v38, v39);
      v14 = 0;
      v19 = 0;
      goto LABEL_24;
    }
LABEL_10:
    v25 = get_padded_len(a3, 8u);
    v26 = 12 * a4 * (get_padded_len(a4, 8u) + v25);
    if (a2)
      v27 = 8 * *(_DWORD *)a2;
    else
      v27 = 0;
    v34 = v27 + v26;
    goto LABEL_22;
  }
  if (a1)
  {
    if (!a2)
      goto LABEL_10;
    goto LABEL_8;
  }
  v31 = get_padded_len(a3, 8u);
  *a6 = 12 * a4 * (get_padded_len(a4, 8u) + v31);
  v20 = get_padded_len(a4, 8u);
  v14 = 0;
  v19 = 0;
LABEL_15:
  *a7 = 24 * v20;
LABEL_24:
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"hidden : %d\n", v21, v22, v23, a4);
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_1 : %d\n", v41, v42, v43, v14);
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_2 : %d\n", v44, v45, v46, v19);
  get_padded_len(a3, 8u);
  get_padded_len(a4, 8u);
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"fast GRU impl: x=%u, h=%u, padded_x=%u, padded_h=%u,wBytes=(padded_x*3h + padded_h*3h)=%u, bBytes=3*padded_h*2=%u, wBytes+bBytes=%u", v47, v48, v49, a3);
  return 0;
}

uint64_t get_gru_glbBufBytes(int a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  int padded_len;
  int v10;
  uint64_t result;
  int v12;
  int v13;

  padded_len = get_padded_len(a2, 8u);
  v10 = get_padded_len(a4, 8u);
  if ((a1 & 0xFFFFFFFD) != 0)
  {
    switch(a1)
    {
      case 4:
        v12 = get_padded_len((3 * a4), 8u);
        padded_len = v12 + v12 * a3;
        v10 = get_padded_len(a4, 8u);
        break;
      case 3:
        v13 = padded_len + 2 * get_padded_len((3 * a4), 8u);
        padded_len = 3 * get_padded_len(a4, 8u);
        goto LABEL_8;
      case 1:
        break;
      default:
        return 7;
    }
  }
  v13 = 3 * v10;
LABEL_8:
  result = 0;
  *a5 = 4 * (v13 + padded_len);
  return result;
}

uint64_t create_gru_layer(uint64_t *a1, unsigned int *a2, const void *a3, const void *a4, uint64_t a5, uint64_t ***a6)
{
  uint64_t **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t **v16;
  uint64_t v17;
  uint64_t *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  int v24;
  uint64_t result;
  uint64_t v26;

  v12 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v16 = v12;
  if (!v12)
    goto LABEL_9;
  *v12 = a1;
  v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v17)
    goto LABEL_9;
  v18 = (uint64_t *)v17;
  v19 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 20);
  if (!v19)
    goto LABEL_9;
  v20 = (uint64_t)v19;
  cstdlib_memcpy(v19, a3, 0x14uLL);
  cstdlib_memcpy(v16 + 1, a2, 0xCuLL);
  v21 = a2[1];
  if (a4)
    cstdlib_memcpy((char *)v16 + 60, a4, 8uLL);
  v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v21, 4);
  *v18 = v22;
  if (v22)
  {
    v18[1] = v20;
    v16[20] = (uint64_t *)gru_layer_request_glbBuf;
    v16[15] = v18;
    v16[16] = (uint64_t *)forward_gru_layer;
    v16[17] = (uint64_t *)free_gru_buffer;
    if (a5)
    {
      v23 = *(uint64_t **)(a5 + 24);
      v24 = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v13, v14, v15, v26);
      v23 = 0;
      v24 = 0;
    }
    result = 0;
    v16[32] = v23;
    *((_DWORD *)v16 + 66) = v24;
    v16[18] = (uint64_t *)gru_layer_update_shape;
    v16[19] = (uint64_t *)gru_layer_wanted_wb_len;
    v16[22] = (uint64_t *)gru_layer_reset;
  }
  else
  {
LABEL_9:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v26);
    free_gru_buffer(v16);
    result = 10;
  }
  *a6 = v16;
  return result;
}

uint64_t gru_layer_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  uint64_t result;
  int step;
  uint64_t v6;
  int *v7;
  unsigned int v8;

  v2 = *(unsigned int *)(a1 + 12);
  v8 = 0;
  v3 = (_DWORD *)(a1 + 20);
  result = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v8);
  if (!(_DWORD)result)
  {
    step = fi_shape_get_step(v3);
    v6 = *(_QWORD *)(a1 + 120);
    if (v6 && (v7 = *(int **)(v6 + 8)) != 0)
      return get_gru_glbBufBytes(*v7, v8, step, v2, (_DWORD *)(a1 + 248));
    else
      return 7;
  }
  return result;
}

uint64_t forward_gru_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  _BOOL4 is_enabled;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t input_dim;
  int step;
  uint64_t v20;
  unsigned int *v21;
  int v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  unsigned int v38;

  v5 = *(uint64_t **)a2;
  v6 = *(_QWORD *)(a2 + 120);
  v7 = *(void **)(a2 + 240);
  v9 = *(void **)v6;
  v8 = *(_QWORD *)(v6 + 8);
  v35 = *(_DWORD *)(v8 + 12);
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a2 + 256), 7u, *(_DWORD *)(a2 + 264));
  v38 = 0;
  if (!v7)
  {
    log_OutText(*v5, (uint64_t)"FastInfer", 0, 0, (uint64_t)"gru buf is NULL, do you forget to set pNet->glbBuf?", v11, v12, v13, v30);
    return 7;
  }
  v14 = *(unsigned int *)(a2 + 12);
  v15 = *(_QWORD *)(a2 + 72);
  if (is_enabled && v15 && (*(_BYTE *)(v15 + 4) & 8) != 0)
    v16 = *(unsigned int *)(a2 + 96);
  else
    v16 = *(_DWORD *)(a2 + 96) & 0xFFFFFFFC;
  v34 = v15 + v16;
  v32 = v5;
  if (!*(_DWORD *)(v8 + 16))
    cstdlib_memset(v9, 0, 4 * v14);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v38);
  if ((_DWORD)input_dim)
    return input_dim;
  v20 = *(_QWORD *)(a2 + 120);
  if (!v20)
    return 7;
  v21 = *(unsigned int **)(v20 + 8);
  if (!v21)
    return 7;
  if (!step)
    return 0;
  v22 = 0;
  v23 = 0;
  v33 = *v21;
  while (1)
  {
    v24 = a3 + 4 * v38 * v23;
    v25 = v35 == 1 ? v22 : 0;
    v26 = a4 + 4 * v25;
    cstdlib_memset(v7, 0, *(unsigned int *)(a2 + 248));
    input_dim = gru_step_f32((uint64_t **)a2, v33, v24, v26, v38, v14, (uint64_t)v7, v15, v34, (uint64_t)v9);
    if ((_DWORD)input_dim)
      break;
    ++v23;
    v22 += v14;
    if (step == v23)
      return input_dim;
  }
  log_OutText(*v32, (uint64_t)"FastInfer", 0, 0, (uint64_t)"gru step forward failed!", v27, v28, v29, v31);
  return input_dim;
}

_QWORD *free_gru_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    v3 = (_QWORD *)result[15];
    if (v3)
    {
      if (v3[1])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      if (*v3)
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        *v3 = 0;
      }
      (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      v1[15] = 0;
    }
    return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
  }
  return result;
}

uint64_t gru_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  int v4;
  int v5;
  int v6;

  v4 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 12);
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (v4 == 1)
  {
    *(_DWORD *)(a1 + 40) = 2;
    v5 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 44) = a2[1];
    *(_DWORD *)(a1 + 48) = v5;
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v6;
  }
  *(_DWORD *)(a1 + 56) = a2[4];
  return 0;
}

uint64_t gru_layer_reset(uint64_t a1)
{
  cstdlib_memset(**(void ***)(a1 + 120), 0, 4 * *(unsigned int *)(a1 + 12));
  return 0;
}

uint64_t realign_inData(uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, _QWORD, uint64_t);
  int padded_len;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;

  if (a2 < 2)
    return 0;
  if (get_padded_len(a3, 8u) == (_DWORD)a3)
    return 0;
  v11 = a1[2];
  v12 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16);
  padded_len = get_padded_len(a3, 8u);
  v14 = v12(v11, padded_len * a2, 4);
  *a4 = v14;
  if (v14)
  {
    v18 = 0;
    v19 = 0;
    do
    {
      v20 = *a4;
      v21 = get_padded_len(a3, 8u);
      cstdlib_memcpy((void *)(v20 + 4 * (v21 * v19++)), (const void *)(a5 + 4 * v18), 4 * a3);
      v18 += a3;
    }
    while (a2 != v19);
    return 0;
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v5);
  return 10;
}

uint64_t gru_step_f32(uint64_t **a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v14;

  v10 = *a1;
  if (a2 > 4)
  {
    v11 = 7;
    v12 = "get lstm step forward function failed!";
    goto LABEL_5;
  }
  v14 = a10;
  v11 = ((uint64_t (*)(void))off_24D29AFD8[a2])();
  if ((_DWORD)v11)
  {
    v12 = "gru step forward failed!";
LABEL_5:
    log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v14);
  }
  return v11;
}

uint64_t gru_step_f32_basic(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5, float32x4_t *a6, int *a7, float *a8, float *a9, int a10, int a11, int a12)
{
  int padded_len;
  unsigned int v19;
  _BOOL4 is_enabled;
  _BOOL4 v21;
  unsigned int v22;
  uint64_t v23;
  int *v24;
  uint64_t mat_length;
  int *v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  unsigned int v43;
  uint64_t v44;
  _DWORD *v45;
  float32x4_t *v46;
  float32x4_t *v47;
  float32_t *v48;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _DWORD *v56;
  _DWORD *v57;
  _DWORD *v58;
  char *v59;
  char *v60;
  _DWORD *v61;
  _DWORD *v62;
  char *v63;
  char *v64;
  char *v65;
  float *v66;
  uint64_t *v68;
  void *__dst;
  _OWORD v71[2];
  _OWORD v72[2];
  _OWORD v73[2];
  _OWORD v74[2];
  _OWORD v75[2];
  _OWORD v76[3];

  v68 = *(uint64_t **)a1;
  padded_len = get_padded_len(a4, 8u);
  v19 = get_padded_len(a5, 8u);
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v21 = (*(_DWORD *)(a1 + 16) & 0xFFFFFFFD) == 1;
  memset(v76, 0, 32);
  memset(v75, 0, sizeof(v75));
  memset(v74, 0, sizeof(v74));
  memset(v73, 0, sizeof(v73));
  memset(v72, 0, sizeof(v72));
  memset(v71, 0, sizeof(v71));
  __dst = a3;
  if (is_enabled)
  {
    if (a7)
    {
      v23 = *a7;
      v22 = a7[1];
      DWORD1(v76[0]) = v21;
      DWORD2(v76[0]) = ((v22 >> 1) & 1) == 0;
      LODWORD(v76[0]) = v22 & 1;
      v24 = &a7[v23];
      mat_length = get_mat_length(a7);
      v26 = &a7[get_padded_len(mat_length, 8u)];
      v28 = *v26;
      v27 = v26[1];
      DWORD1(v75[0]) = v21;
      DWORD2(v75[0]) = ((v27 >> 1) & 1) == 0;
      LODWORD(v75[0]) = v27 & 1;
      v64 = (char *)&v26[v28];
      v29 = get_mat_length(v26);
      v30 = &v26[get_padded_len(v29, 8u)];
      v32 = *v30;
      v31 = v30[1];
      DWORD1(v74[0]) = v21;
      DWORD2(v74[0]) = ((v31 >> 1) & 1) == 0;
      LODWORD(v74[0]) = v31 & 1;
      v65 = (char *)&v30[v32];
      v33 = get_mat_length(v30);
      v34 = &v30[get_padded_len(v33, 8u)];
      v36 = *v34;
      v35 = v34[1];
      DWORD1(v73[0]) = v21;
      DWORD2(v73[0]) = ((v35 >> 1) & 1) == 0;
      LODWORD(v73[0]) = v35 & 1;
      v59 = (char *)&v34[v36];
      v37 = get_mat_length(v34);
      v38 = &v34[get_padded_len(v37, 8u)];
      v40 = *v38;
      v39 = v38[1];
      DWORD1(v72[0]) = v21;
      DWORD2(v72[0]) = ((v39 >> 1) & 1) == 0;
      LODWORD(v72[0]) = v39 & 1;
      v60 = (char *)&v38[v40];
      v41 = get_mat_length(v38);
      v42 = &v38[get_padded_len(v41, 8u)];
      v44 = *v42;
      v43 = v42[1];
      DWORD1(v71[0]) = v21;
      DWORD2(v71[0]) = ((v43 >> 1) & 1) == 0;
      v63 = (char *)&v42[v44];
      v45 = v76;
      v56 = v73;
      v57 = v75;
      LODWORD(v71[0]) = v43 & 1;
      v58 = v72;
      v61 = v74;
      v62 = v71;
      a7 = v24;
    }
    else
    {
      a7 = 0;
      v64 = 0;
      v65 = 0;
      v59 = 0;
      v60 = 0;
      v63 = 0;
      *(_QWORD *)((char *)v76 + 4) = v21 | 0x100000000;
      LODWORD(v76[0]) = 0;
      *(_QWORD *)((char *)v75 + 4) = *(_QWORD *)((char *)v76 + 4);
      LODWORD(v75[0]) = 0;
      *(_QWORD *)((char *)v74 + 4) = *(_QWORD *)((char *)v76 + 4);
      LODWORD(v74[0]) = 0;
      *(_QWORD *)((char *)v73 + 4) = *(_QWORD *)((char *)v76 + 4);
      LODWORD(v73[0]) = 0;
      *(_QWORD *)((char *)v72 + 4) = *(_QWORD *)((char *)v76 + 4);
      v45 = v76;
      LODWORD(v72[0]) = 0;
      v56 = v73;
      v57 = v75;
      v58 = v72;
      *(_QWORD *)((char *)v71 + 4) = *(_QWORD *)((char *)v76 + 4);
      v61 = v74;
      v62 = v71;
    }
  }
  else
  {
    v61 = 0;
    v62 = 0;
    v57 = 0;
    v58 = 0;
    v56 = 0;
    v45 = 0;
    v64 = (char *)&a7[(padded_len * a5)];
    v65 = &v64[4 * (padded_len * a5)];
    v59 = &v65[4 * (padded_len * a5)];
    v60 = &v59[4 * v19 * a5];
    v63 = &v60[4 * v19 * a5];
  }
  v46 = (float32x4_t *)((char *)a6 + 4 * v19);
  v47 = (float32x4_t *)((char *)v46 + 4 * v19);
  v48 = &v47->f32[v19];
  v66 = &a8[v19];
  cstdlib_memcpy(v48, a2, 4 * a4);
  cstdlib_memset(a6, 0, 4 * a5);
  gemm(v68, 1, a5, a4, v48, (char *)a7, a6, v45, v50);
  cstdlib_memset(v46, 0, 4 * a5);
  gemm(v68, 1, a5, a5, a9, v59, v46, v56, v51);
  axpy(a5, a6->f32, 1, v46->f32, 1, 1.0);
  axpy(a5, a8, 1, v46->f32, 1, 1.0);
  fi_activate_array(v46->f32, a5, a12);
  cstdlib_memset(a6, 0, 4 * a5);
  gemm(v68, 1, a5, a4, v48, v64, a6, v57, v52);
  cstdlib_memset(v47, 0, 4 * a5);
  gemm(v68, 1, a5, a5, a9, v60, v47, v58, v53);
  axpy(a5, a6->f32, 1, v47->f32, 1, 1.0);
  axpy(a5, v66, 1, v47->f32, 1, 1.0);
  fi_activate_array(v47->f32, a5, a12);
  xmy(a5, a9, 1, v47->f32, 1);
  cstdlib_memset(a6, 0, 4 * a5);
  gemm(v68, 1, a5, a5, v47->f32, v63, a6, v61, v54);
  cstdlib_memset(v47, 0, 4 * a5);
  gemm(v68, 1, a5, a4, v48, v65, v47, v62, v55);
  axpy(a5, a6->f32, 1, v47->f32, 1, 1.0);
  axpy(a5, &v66[v19], 1, v47->f32, 1, 1.0);
  fi_activate_array(v47->f32, a5, a11);
  fill_array_f32(a6->f32, a5, 1.0);
  axpy(a5, v46->f32, 1, a6->f32, 1, -1.0);
  xmy(a5, a6->f32, 1, v47->f32, 1);
  xmy(a5, a9, 1, v46->f32, 1);
  axpy(a5, v47->f32, 1, v46->f32, 1, 1.0);
  cstdlib_memcpy(a9, v46, 4 * a5);
  cstdlib_memcpy(__dst, v46, 4 * a5);
  return 0;
}

uint64_t gru_step_f32_fast(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, char *a6, int *a7, char *a8, void *a9, int a10, int a11, int a12)
{
  unsigned int v15;
  uint64_t *v19;
  uint64_t v20;
  int v21;
  _BOOL4 is_enabled;
  int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;
  int *v29;
  int v30;
  unsigned int *v31;
  _BOOL4 v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t mat_length;
  int *v36;
  unsigned int v37;
  uint64_t v38;
  const void *v39;
  char *v40;
  char *v41;
  float32x4_t *v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  int *v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _DWORD *v54;
  char *v55;
  int *v56;
  _DWORD *v57;
  int v58;
  void *__src;
  unsigned int v60;
  unsigned int v61;
  void *v62;
  float32_t *v63;
  void *v64;
  int v65;
  int padded_len;
  uint64_t *v68;
  _OWORD v69[2];
  _OWORD v70[2];
  char *v71;
  uint64_t v72[2];

  v15 = a4;
  v19 = *(uint64_t **)a1;
  padded_len = get_padded_len(a4, 8u);
  v65 = get_padded_len(a5, 8u);
  v20 = a5 + v15;
  v21 = get_padded_len(v20, 8u);
  v71 = 0;
  v72[0] = 0;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  memset(v70, 0, sizeof(v70));
  memset(v69, 0, sizeof(v69));
  v68 = v19;
  if (!is_enabled)
  {
    v60 = 2 * a5;
    v61 = v20;
    __src = a2;
    v62 = a3;
    v58 = 0;
    v56 = a7;
    v57 = 0;
    v54 = 0;
    v55 = (char *)&a7[(2 * a5 * v21)];
LABEL_11:
    HIDWORD(v52) = 1;
    v38 = a5;
    goto LABEL_12;
  }
  if (!a7)
  {
    v60 = 2 * a5;
    v61 = v20;
    __src = a2;
    v62 = a3;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 1;
    v33 = *(_DWORD *)(a1 + 16) & 0xFFFFFFFD;
    LODWORD(v70[0]) = 0;
    DWORD1(v70[0]) = v33 == 1;
    DWORD2(v70[0]) = 1;
LABEL_10:
    v55 = (char *)v31;
    v56 = v29;
    v58 = 0;
    DWORD2(v69[0]) = v32;
    LODWORD(v69[0]) = v30;
    DWORD1(v69[0]) = v33 == 1;
    v54 = v70;
    v57 = v69;
    goto LABEL_11;
  }
  v23 = a7[2];
  if (!v23)
  {
    v60 = 2 * a5;
    v61 = v20;
    __src = a2;
    v62 = a3;
    v34 = a7[1];
    v29 = &a7[*a7];
    *(_QWORD *)&v70[0] = __PAIR64__((*(_DWORD *)(a1 + 16) & 0xFFFFFFFD) == 1, v34 & 1);
    DWORD2(v70[0]) = ((v34 >> 1) & 1) == 0;
    mat_length = get_mat_length(a7);
    v36 = &a7[get_padded_len(mat_length, 8u)];
    v37 = v36[1];
    v31 = (unsigned int *)&v36[*v36];
    v30 = v37 & 1;
    v32 = ((v37 >> 1) & 1) == 0;
    v33 = *(_DWORD *)(a1 + 16) & 0xFFFFFFFD;
    goto LABEL_10;
  }
  v24 = (2 * a5);
  v64 = (void *)a5;
  v25 = a7[1];
  DWORD2(v70[0]) = ((v25 >> 1) & 1) == 0;
  *(_QWORD *)&v70[0] = v25 & 1;
  v26 = get_padded_len(v20, 8u);
  v27 = (uint64_t)&a7[*a7];
  if ((v25 & 2) != 0)
  {
    result = pack_bsr_data((uint64_t)v68, v23, v26, v24, v27, v72);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    result = pack_bsc_data((uint64_t)v68, v23, v26, v24, v27, v72);
    if ((_DWORD)result)
      return result;
  }
  v46 = get_mat_length(a7);
  v47 = &a7[get_padded_len(v46, 8u)];
  v48 = v47[1];
  v49 = v47[2];
  DWORD2(v69[0]) = ((v48 >> 1) & 1) == 0;
  *(_QWORD *)&v69[0] = v48 & 1;
  v50 = get_padded_len(v20, 8u);
  v51 = (uint64_t)&v47[*v47];
  if ((v25 & 2) != 0)
  {
    result = pack_bsr_data((uint64_t)v68, v49, v50, (uint64_t)v64, v51, (uint64_t *)&v71);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    result = pack_bsc_data((uint64_t)v68, v49, v50, (uint64_t)v64, v51, (uint64_t *)&v71);
    if ((_DWORD)result)
      return result;
  }
  v60 = v24;
  v61 = v20;
  __src = a2;
  v62 = a3;
  HIDWORD(v52) = 0;
  v58 = v49;
  v55 = 0;
  v56 = 0;
  v54 = v70;
  v57 = v69;
  v38 = (uint64_t)v64;
LABEL_12:
  v39 = a8;
  v40 = &a8[4 * v65];
  v41 = &a6[4 * padded_len];
  v42 = (float32x4_t *)&v41[4 * v65];
  v43 = &a6[4 * v15];
  v63 = &v42->f32[v65];
  cstdlib_memcpy(a6, __src, 4 * v15);
  cstdlib_memcpy(v43, a9, 4 * v38);
  cstdlib_memcpy(v42, v39, 4 * v38);
  cstdlib_memcpy(&v42->f32[v38], v40, 4 * v38);
  if (HIDWORD(v52))
    v44 = (char *)v56;
  else
    v44 = (char *)v72[0];
  gemm(v68, 1, v60, v61, (float *)a6, v44, v42, v54, v52);
  fi_activate_array(v42->f32, v60, a12);
  cstdlib_memmove(v41, v43, 4 * v38);
  cstdlib_memmove(v63, &v42->f32[v38], 4 * v38);
  xmy(v38, v42->f32, 1, (float *)v41, 1);
  cstdlib_memmove(v43, v41, 4 * v38);
  cstdlib_memcpy(v42, &v40[4 * v65], 4 * v38);
  if (v58)
    v45 = v71;
  else
    v45 = v55;
  gemm(v68, 1, v38, v61, (float *)a6, v45, v42, v57, v53);
  fi_activate_array(v42->f32, v38, a11);
  fill_array_f32((float *)a6, v38, 1.0);
  axpy(v38, v63, 1, (float *)a6, 1, -1.0);
  xmy(v38, (float *)a6, 1, v42->f32, 1);
  xmy(v38, (float *)a9, 1, v63, 1);
  axpy(v38, v42->f32, 1, v63, 1, 1.0);
  cstdlib_memcpy(a9, v63, 4 * v38);
  cstdlib_memcpy(v62, v63, 4 * v38);
  if (v72[0])
  {
    (*(void (**)(uint64_t))(v68[1] + 80))(v68[2]);
    v72[0] = 0;
  }
  if (v71)
    (*(void (**)(uint64_t))(v68[1] + 80))(v68[2]);
  return 0;
}

uint64_t gru_step_f32_basic_resetafter(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5, float32x4_t *a6, int *a7, float *a8, float *a9, int a10, int a11, int a12)
{
  int padded_len;
  unsigned int v19;
  int *v20;
  uint64_t mat_length;
  int *v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  int v30;
  const void *v31;
  float32x4_t *v32;
  float32x4_t *v33;
  float32_t *v34;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  char *v45;
  float *v46;
  float *v47;
  float *v48;
  float *v49;
  uint64_t *v51;

  v51 = *(uint64_t **)a1;
  padded_len = get_padded_len(a4, 8u);
  v19 = get_padded_len(a5, 8u);
  if (fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264)))
  {
    if (a7)
    {
      v20 = &a7[*a7];
      mat_length = get_mat_length(a7);
      v22 = &a7[get_padded_len(mat_length, 8u)];
      v44 = (char *)&v22[*v22];
      v23 = get_mat_length(v22);
      v24 = &v22[get_padded_len(v23, 8u)];
      v45 = (char *)&v24[*v24];
      v25 = get_mat_length(v24);
      v26 = &v24[get_padded_len(v25, 8u)];
      v36 = (uint64_t)&v26[*v26];
      v27 = get_mat_length(v26);
      v28 = &v26[get_padded_len(v27, 8u)];
      v42 = (char *)&v28[*v28];
      v29 = get_mat_length(v28);
      v30 = get_padded_len(v29, 8u);
      v43 = (char *)&v28[v30 + v28[v30]];
      a7 = v20;
    }
    else
    {
      v44 = 0;
      v45 = 0;
      v36 = 0;
      v42 = 0;
      v43 = 0;
    }
  }
  else
  {
    v44 = (char *)&a7[(padded_len * a5)];
    v45 = &v44[4 * (padded_len * a5)];
    v36 = (uint64_t)&v45[4 * (padded_len * a5)];
    v42 = (char *)(v36 + 4 * v19 * a5);
    v43 = &v42[4 * v19 * a5];
  }
  v31 = a2;
  v32 = (float32x4_t *)((char *)a6 + 4 * v19);
  v33 = (float32x4_t *)((char *)v32 + 4 * v19);
  v47 = &a8[v19];
  v49 = &v47[v19];
  v46 = &v49[v19];
  v48 = &v46[v19];
  v34 = &v33->f32[v19];
  cstdlib_memcpy(v34, v31, 4 * a4);
  cstdlib_memset(a6, 0, 4 * a5);
  gemm(v51, 1, a5, a4, v34, (char *)a7, a6, 0, v36);
  cstdlib_memset(v32, 0, 4 * a5);
  gemm(v51, 1, a5, a5, a9, v37, v32, 0, (uint64_t)v37);
  axpy(a5, a6->f32, 1, v32->f32, 1, 1.0);
  axpy(a5, a8, 1, v32->f32, 1, 1.0);
  axpy(a5, v46, 1, v32->f32, 1, 1.0);
  fi_activate_array(v32->f32, a5, a12);
  cstdlib_memset(a6, 0, 4 * a5);
  gemm(v51, 1, a5, a4, v34, v44, a6, 0, v38);
  cstdlib_memset(v33, 0, 4 * a5);
  gemm(v51, 1, a5, a5, a9, v42, v33, 0, v39);
  axpy(a5, a6->f32, 1, v33->f32, 1, 1.0);
  axpy(a5, v47, 1, v33->f32, 1, 1.0);
  axpy(a5, v48, 1, v33->f32, 1, 1.0);
  fi_activate_array(v33->f32, a5, a12);
  cstdlib_memset(a6, 0, 4 * a5);
  gemm(v51, 1, a5, a5, a9, v43, a6, 0, v40);
  xmy(a5, a6->f32, 1, v33->f32, 1);
  axpy(a5, &v48[v19], 1, v33->f32, 1, 1.0);
  cstdlib_memset(a6, 0, 4 * a5);
  gemm(v51, 1, a5, a4, v34, v45, a6, 0, v41);
  axpy(a5, a6->f32, 1, v33->f32, 1, 1.0);
  axpy(a5, v49, 1, v33->f32, 1, 1.0);
  fi_activate_array(v33->f32, a5, a11);
  fill_array_f32(a6->f32, a5, 1.0);
  axpy(a5, v32->f32, 1, a6->f32, 1, -1.0);
  xmy(a5, a6->f32, 1, v33->f32, 1);
  xmy(a5, a9, 1, v32->f32, 1);
  axpy(a5, v33->f32, 1, v32->f32, 1, 1.0);
  cstdlib_memcpy(a9, v32, 4 * a5);
  cstdlib_memcpy(a3, v32, 4 * a5);
  return 0;
}

uint64_t gru_step_f32_fast_resetafter(uint64_t a1, void *a2, float *a3, uint64_t a4, uint64_t a5, char *a6, int *a7, char *a8, float *a9, int a10, int a11, int a12)
{
  int v17;
  uint64_t v18;
  _BOOL4 is_enabled;
  _BOOL4 v20;
  void *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  int v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  int v33;
  char *v34;
  int v35;
  unsigned int v36;
  char *v37;
  float32x4_t *v38;
  float32x4_t *v39;
  char *v40;
  unsigned int v41;
  unsigned int v42;
  size_t v43;
  float32_t *v44;
  char *v45;
  __int128 *v46;
  float *v47;
  int v48;
  int v49;
  char *v50;
  char *v51;
  __int128 *v52;
  uint64_t v53;
  float *v54;
  size_t v55;
  float *v56;
  float *v57;
  float *v58;
  float *v59;
  float *v60;
  float *v61;
  uint64_t v62;
  uint64_t v63;
  _DWORD *v64;
  int v66;
  unsigned int v67;
  _DWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t mat_length;
  unsigned int *v74;
  unsigned int *v75;
  _BOOL4 v76;
  uint64_t v77;
  unsigned int v78;
  _DWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int v83;
  uint64_t v84;
  unsigned int *v85;
  unsigned int v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  char *v94;
  int v95;
  float *v96;
  uint64_t v97;
  int v98;
  unsigned int v99;
  int v100;
  unsigned int padded_len;
  char *v102;
  int v104;
  float *v105;
  uint64_t v106;
  float32_t *__dsta;
  float *v110;
  _BOOL4 v111;
  uint64_t *v112;
  uint64_t __src;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  char *v118;
  uint64_t v119[2];

  v112 = *(uint64_t **)a1;
  padded_len = get_padded_len(a4, 8u);
  v17 = get_padded_len(a5, 8u);
  v18 = a2 & 0x1F;
  v118 = 0;
  v119[0] = 0;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v20 = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  v100 = get_padded_len(a4, 8u);
  v99 = get_padded_len((3 * a5), 8u);
  __src = (3 * a5);
  v21 = a2;
  v104 = get_padded_len(__src, 8u);
  v22 = get_padded_len(a5, 8u);
  v98 = get_padded_len(a5, 8u);
  v116 = 0u;
  v117 = 0u;
  v114 = 0u;
  v115 = 0u;
  v106 = v18;
  if (v18)
    cstdlib_memcpy(a6, v21, 4 * a4);
  v110 = (float *)a6;
  v111 = is_enabled || v20;
  if (!is_enabled && !v20)
  {
    v95 = v22;
    v96 = (float *)v21;
    v97 = a4;
    v93 = 0;
    v32 = a8;
    v94 = (char *)&a7[padded_len * __src];
    v33 = 1;
    v102 = (char *)a7;
LABEL_10:
    v34 = a6;
    v36 = v99;
    v35 = v100;
LABEL_11:
    v37 = &v32[4 * v17];
    v38 = (float32x4_t *)&v34[4 * v35];
    v39 = (float32x4_t *)((char *)v38 + 4 * v36);
    v40 = &v37[4 * v17 + 4 * v17];
    v41 = 2 * a5;
    __dsta = &v39->f32[v104];
    if (v17 == (_DWORD)a5)
    {
      v42 = __src;
      v43 = 4 * __src;
      v44 = (float32_t *)&v34[4 * v35];
    }
    else
    {
      cstdlib_memcpy(v38, v32, 4 * a5);
      cstdlib_memcpy(&v38->f32[a5], v37, 4 * a5);
      v44 = &v38->f32[v41];
      v32 = &v37[4 * v17];
      v43 = 4 * a5;
      v42 = __src;
    }
    cstdlib_memcpy(v44, v32, v43);
    v105 = &__dsta[v95];
    if (v33)
      v45 = v102;
    else
      v45 = (char *)v119[0];
    if (v111)
      v46 = &v116;
    else
      v46 = 0;
    if (v106)
      v47 = v110;
    else
      v47 = v96;
    v26 = v112;
    gemm(v112, 1, v42, v97, v47, v45, v38, v46, v91);
    if (v17 == (_DWORD)a5)
    {
      cstdlib_memcpy(v39, v40, 4 * v42);
      v48 = v42;
      v49 = v17;
    }
    else
    {
      v49 = v17;
      v50 = &v40[4 * v17];
      cstdlib_memcpy(v39, v40, 4 * a5);
      cstdlib_memcpy(&v39->f32[a5], v50, 4 * a5);
      v26 = v112;
      v48 = __src;
      cstdlib_memcpy(&v39->f32[v41], &v50[4 * v49], 4 * a5);
    }
    if (v93)
      v51 = v118;
    else
      v51 = v94;
    if (v111)
      v52 = &v114;
    else
      v52 = 0;
    gemm(v26, 1, v48, a5, a9, v51, v39, v52, v92);
    axpy((2 * a5), v38->f32, 1, v39->f32, 1, 1.0);
    fi_activate_array(v39->f32, (2 * a5), a12);
    v53 = v41;
    v54 = &v39->f32[v41];
    if (v49 == (_DWORD)a5)
    {
      xmy(a5, v39->f32, 1, &v39->f32[v41], 1);
      axpy(a5, &v38->f32[v41], 1, &v39->f32[v41], 1, 1.0);
      fi_activate_array(&v39->f32[v41], a5, a11);
      fill_array_f32(v105, a5, 1.0);
      v55 = 4 * a5;
      axpy(a5, &v39->f32[v55 / 4], 1, v105, 1, -1.0);
      v56 = a9;
      v57 = a9;
      v58 = &v39->f32[v55 / 4];
      v59 = &__dsta[v95];
      v60 = v54;
    }
    else
    {
      v61 = &v105[v98];
      v55 = 4 * a5;
      cstdlib_memcpy(__dsta, v54, v55);
      xmy(a5, v39->f32, 1, __dsta, 1);
      cstdlib_memcpy(v105, &v38->f32[v53], v55);
      axpy(a5, v105, 1, __dsta, 1, 1.0);
      fi_activate_array(__dsta, a5, a11);
      cstdlib_memcpy(v61, (char *)v39 + v55, v55);
      fill_array_f32(v105, a5, 1.0);
      axpy(a5, v61, 1, v105, 1, -1.0);
      v56 = a9;
      v57 = a9;
      v58 = v61;
      v59 = &__dsta[v95];
      v60 = __dsta;
    }
    fi_multiply_multiply_add_ansic(v57, v58, v59, v60, a3, a5);
    cstdlib_memcpy(v56, a3, v55);
    v62 = 0;
    v63 = 0;
    v64 = (_DWORD *)*((_QWORD *)&v117 + 1);
    if (*((_QWORD *)&v117 + 1))
      goto LABEL_36;
    goto LABEL_37;
  }
  v26 = v112;
  if (!a7)
  {
    v102 = 0;
    v66 = 0;
    *(_QWORD *)&v116 = 0;
    DWORD2(v116) = 1;
    LODWORD(v117) = 0;
LABEL_46:
    DWORD1(v117) = v66 ^ 1;
    v68 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v112[1] + 64))(v112[2], 2, 4);
    *((_QWORD *)&v117 + 1) = v68;
    if (!v68)
    {
      log_OutText(*v112, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v69, v70, v71, v91);
      v63 = 10;
      goto LABEL_37;
    }
    v64 = v68;
    if (a7)
    {
      *v68 = a7[7];
      v68[1] = a7[8];
      v72 = v17;
      if ((a7[1] & 8) != 0)
      {
        v77 = *a7;
        v74 = (unsigned int *)((char *)&a7[v77] + get_weight_length(a7));
      }
      else
      {
        mat_length = get_mat_length(a7);
        v74 = (unsigned int *)&a7[get_padded_len(mat_length, 8u)];
      }
      v78 = v74[1];
      v75 = &v74[*v74];
      *(_QWORD *)&v114 = v78 & 1;
      DWORD2(v114) = ((v78 >> 1) & 1) == 0;
      LODWORD(v115) = (v78 >> 3) & 1;
      v76 = ((v78 >> 4) & 1) == 0;
    }
    else
    {
      v72 = v17;
      v74 = 0;
      v75 = 0;
      *(_QWORD *)v68 = 0;
      v76 = 1;
      *(_QWORD *)&v114 = 0;
      DWORD2(v114) = 1;
      LODWORD(v115) = 0;
    }
    DWORD1(v115) = v76;
    v79 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v112[1] + 64))(v112[2], 2, 4);
    *((_QWORD *)&v115 + 1) = v79;
    if (!v79)
    {
      log_OutText(*v112, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v80, v81, v82, v91);
      v62 = 10;
LABEL_36:
      (*(void (**)(uint64_t, _DWORD *))(v26[1] + 80))(v26[2], v64);
      *((_QWORD *)&v117 + 1) = 0;
      v63 = v62;
      goto LABEL_37;
    }
    v96 = (float *)v21;
    v97 = a4;
    v95 = v22;
    v94 = (char *)v75;
    if (a7)
    {
      *v79 = v74[7];
      v83 = v74[8];
    }
    else
    {
      *v79 = 0;
      v83 = 0;
    }
    v17 = v72;
    v34 = a6;
    v32 = a8;
    v36 = v99;
    v35 = v100;
    v93 = 0;
    v79[1] = v83;
    v33 = 1;
    goto LABEL_11;
  }
  v27 = a7[2];
  if (!v27)
  {
    v67 = a7[1];
    v102 = (char *)&a7[*a7];
    *(_QWORD *)&v116 = v67 & 1;
    DWORD2(v116) = ((v67 >> 1) & 1) == 0;
    LODWORD(v117) = (v67 >> 3) & 1;
    v66 = (v67 >> 4) & 1;
    goto LABEL_46;
  }
  v28 = v17;
  v29 = a7[1];
  DWORD2(v116) = ((v29 >> 1) & 1) == 0;
  *(_QWORD *)&v116 = v29 & 1;
  if ((v29 & 8) != 0)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", v23, v24, v25, v91);
    v63 = 7;
    goto LABEL_37;
  }
  v30 = (uint64_t)&a7[*a7];
  if ((v29 & 2) != 0)
    v31 = pack_bsr_data((uint64_t)v112, v27, padded_len, __src, v30, v119);
  else
    v31 = pack_bsc_data((uint64_t)v112, v27, padded_len, __src, v30, v119);
  v63 = v31;
  if (!(_DWORD)v31)
  {
    v84 = get_mat_length(a7);
    v85 = (unsigned int *)&a7[get_padded_len(v84, 8u)];
    v86 = v85[1];
    v87 = v85[2];
    v88 = *v85;
    DWORD2(v114) = ((v86 >> 1) & 1) == 0;
    *(_QWORD *)&v114 = v86 & 1;
    v89 = (uint64_t)&v85[v88];
    v90 = (v29 & 2) != 0
        ? pack_bsr_data((uint64_t)v112, v87, padded_len, __src, v89, (uint64_t *)&v118)
        : pack_bsc_data((uint64_t)v112, v87, padded_len, __src, v89, (uint64_t *)&v118);
    v63 = v90;
    v32 = a8;
    if (!(_DWORD)v90)
    {
      v93 = v87;
      v95 = v22;
      v96 = (float *)v21;
      v97 = a4;
      v33 = 0;
      v102 = 0;
      v94 = 0;
      v17 = v28;
      goto LABEL_10;
    }
  }
LABEL_37:
  if (*((_QWORD *)&v115 + 1))
  {
    (*(void (**)(uint64_t))(v26[1] + 80))(v26[2]);
    *((_QWORD *)&v115 + 1) = 0;
  }
  if (v119[0])
  {
    (*(void (**)(uint64_t))(v26[1] + 80))(v26[2]);
    v119[0] = 0;
  }
  if (v118)
    (*(void (**)(uint64_t))(v26[1] + 80))(v26[2]);
  return v63;
}

uint64_t gru_step_f32_fast_resetafter_precompute(uint64_t a1, float *a2, float *a3, uint64_t a4, uint64_t a5, float32x4_t *a6, char *a7, char *a8, float *a9, int a10, int a11, int a12)
{
  uint64_t *v17;
  uint64_t padded_len;
  int v19;
  unsigned int v20;
  unsigned int v21;
  _BOOL4 is_enabled;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 *v32;
  char *v33;
  char *v34;
  int v35;
  unsigned int v36;
  _DWORD *v37;
  uint64_t mat_length;
  unsigned int *v39;
  _BOOL4 v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  _DWORD *v44;
  unsigned int v45;
  char *v46;
  char *v47;
  char *v48;
  float32x4_t *v49;
  float32_t *v50;
  uint64_t v51;
  int v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  __int128 *v57;
  int v58;
  float *v59;
  float *v60;
  size_t v61;
  float *v62;
  float *v63;
  float *v64;
  float *v65;
  float *v66;
  float *v67;
  int v68;
  size_t v69;
  uint64_t v70;
  float32_t *v71;
  uint64_t v72;
  unsigned int *v73;
  unsigned int v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v81;
  __int128 *v82;
  int v83;
  char *v84;
  unsigned int v85;
  float32x4_t *v86;
  uint64_t **v87;
  unsigned int *v89;
  int v90;
  _BOOL4 v91;
  uint64_t *v92;
  unsigned int step;
  float *v94;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  char *v101;
  uint64_t v102[2];

  v17 = *(uint64_t **)a1;
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v85 = a4;
  padded_len = get_padded_len(a4, 8u);
  v19 = get_padded_len(a5, 8u);
  v20 = 3 * a5;
  v21 = get_padded_len((3 * a5), 8u);
  v101 = 0;
  v102[0] = 0;
  LODWORD(a4) = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v87 = (uint64_t **)a1;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  v99 = 0u;
  v100 = 0u;
  v97 = 0u;
  v98 = 0u;
  v91 = (a4 | is_enabled) != 0;
  if (!(a4 | is_enabled))
  {
    v32 = 0;
    v90 = 0;
    v89 = (unsigned int *)&a7[4 * padded_len * v20];
    v84 = a7;
    v33 = a8;
    goto LABEL_21;
  }
  if (!a7)
  {
    v34 = 0;
    v35 = 0;
    *(_QWORD *)&v99 = 0;
    DWORD2(v99) = 1;
    LODWORD(v100) = 0;
LABEL_10:
    DWORD1(v100) = v35 ^ 1;
    v37 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v17[1] + 64))(v17[2], 2, 4);
    *((_QWORD *)&v100 + 1) = v37;
    v84 = v34;
    if (a7)
    {
      *v37 = *((_DWORD *)a7 + 7);
      v37[1] = *((_DWORD *)a7 + 8);
      if ((a7[4] & 8) != 0)
      {
        v42 = *(unsigned int *)a7;
        v39 = (unsigned int *)&a7[4 * v42 + get_weight_length(a7)];
      }
      else
      {
        mat_length = get_mat_length((int *)a7);
        v39 = (unsigned int *)&a7[4 * get_padded_len(mat_length, 8u)];
      }
      v43 = v39[1];
      v89 = &v39[*v39];
      *(_QWORD *)&v97 = v43 & 1;
      DWORD2(v97) = ((v43 >> 1) & 1) == 0;
      LODWORD(v98) = (v43 >> 3) & 1;
      v40 = ((v43 >> 4) & 1) == 0;
    }
    else
    {
      v39 = 0;
      v89 = 0;
      *(_QWORD *)v37 = 0;
      v40 = 1;
      *(_QWORD *)&v97 = 0;
      DWORD2(v97) = 1;
      LODWORD(v98) = 0;
    }
    DWORD1(v98) = v40;
    v44 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v17[1] + 64))(v17[2], 2, 4);
    *((_QWORD *)&v98 + 1) = v44;
    if (a7)
    {
      *v44 = v39[7];
      v45 = v39[8];
    }
    else
    {
      *v44 = 0;
      v45 = 0;
    }
    v33 = a8;
    v90 = 0;
    v44[1] = v45;
    v32 = &v99;
    goto LABEL_21;
  }
  v26 = *((_DWORD *)a7 + 2);
  if (!v26)
  {
    v36 = *((_DWORD *)a7 + 1);
    v34 = &a7[4 * *(unsigned int *)a7];
    *(_QWORD *)&v99 = v36 & 1;
    DWORD2(v99) = ((v36 >> 1) & 1) == 0;
    LODWORD(v100) = (v36 >> 3) & 1;
    v35 = (v36 >> 4) & 1;
    goto LABEL_10;
  }
  v27 = *((_DWORD *)a7 + 1);
  DWORD2(v99) = ((v27 >> 1) & 1) == 0;
  *(_QWORD *)&v99 = v27 & 1;
  if ((v27 & 8) != 0)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", v23, v24, v25, v81);
    v41 = 7;
    goto LABEL_51;
  }
  v28 = v19;
  v29 = (uint64_t)&a7[4 * *(unsigned int *)a7];
  v30 = (3 * a5);
  if ((v27 & 2) != 0)
    v31 = pack_bsr_data((uint64_t)v17, v26, padded_len, v30, v29, v102);
  else
    v31 = pack_bsc_data((uint64_t)v17, v26, padded_len, v30, v29, v102);
  v41 = v31;
  if ((_DWORD)v31)
    goto LABEL_51;
  v72 = get_mat_length((int *)a7);
  v73 = (unsigned int *)&a7[4 * get_padded_len(v72, 8u)];
  v74 = v73[1];
  v75 = v73[2];
  v76 = *v73;
  DWORD2(v97) = ((v74 >> 1) & 1) == 0;
  *(_QWORD *)&v97 = v74 & 1;
  v77 = (uint64_t)&v73[v76];
  v78 = (3 * a5);
  v79 = (v27 & 2) != 0
      ? pack_bsr_data((uint64_t)v17, v75, padded_len, v78, v77, (uint64_t *)&v101)
      : pack_bsc_data((uint64_t)v17, v75, padded_len, v78, v77, (uint64_t *)&v101);
  v41 = v79;
  v33 = a8;
  if ((_DWORD)v79)
    goto LABEL_51;
  v90 = v75;
  v89 = 0;
  v32 = &v99;
  v84 = (char *)v102[0];
  v19 = v28;
LABEL_21:
  v46 = &v33[4 * v19];
  v47 = &v46[4 * v19];
  v92 = v17;
  if (!a10)
  {
    v82 = v32;
    v83 = v19;
    if (step)
    {
      v68 = 0;
      v69 = 4 * a5;
      v70 = step;
      do
      {
        v71 = &a6->f32[v68];
        cstdlib_memcpy(v71, a8, v69);
        cstdlib_memcpy(&v71[a5], v46, v69);
        cstdlib_memcpy(&v71[(2 * a5)], v47, v69);
        v68 += v21;
        --v70;
      }
      while (v70);
    }
    if ((a2 & 0x1F) != 0)
    {
      log_OutText(**v87, (uint64_t)"FastInfer", 0, 0, (uint64_t)"gru input not aligned!", v23, v24, v25, v81);
      v41 = 7;
      v17 = v92;
      goto LABEL_51;
    }
    v20 = 3 * a5;
    v17 = v92;
    gemm_ex(v92, step, 3 * a5, v85, a2, v85, v84, v85, a6, v21, v82);
    v19 = v83;
  }
  v48 = &v47[4 * v19];
  v49 = (float32x4_t *)((char *)a6 + 4 * v21 * step);
  v50 = &v49->f32[v21];
  v94 = &v50[v19];
  if (v19 == (_DWORD)a5)
  {
    cstdlib_memcpy(v49, v48, 4 * v20);
    v51 = (2 * a5);
    v52 = v19;
  }
  else
  {
    v53 = &v48[4 * v19];
    v86 = a6;
    v54 = &v53[4 * v19];
    v52 = v19;
    cstdlib_memcpy(v49, v48, 4 * a5);
    cstdlib_memcpy(&v49->f32[a5], v53, 4 * a5);
    v51 = (2 * a5);
    v55 = v54;
    a6 = v86;
    cstdlib_memcpy(&v49->f32[v51], v55, 4 * a5);
  }
  if (v90)
    v56 = v101;
  else
    v56 = (char *)v89;
  if (v91)
    v57 = &v97;
  else
    v57 = 0;
  v58 = v20;
  v59 = a9;
  gemm(v17, 1, v58, a5, a9, v56, v49, v57, v81);
  v60 = &a6->f32[v21 * a10];
  axpy(v51, v60, 1, v49->f32, 1, 1.0);
  fi_activate_array(v49->f32, v51, a12);
  if (v52 == (_DWORD)a5)
  {
    xmy(a5, v49->f32, 1, &v49->f32[v51], 1);
    axpy(a5, &v60[v51], 1, &v49->f32[v51], 1, 1.0);
    fi_activate_array(&v49->f32[v51], a5, a11);
    fill_array_f32(v94, a5, 1.0);
    v61 = 4 * a5;
    axpy(a5, &v49->f32[v61 / 4], 1, v94, 1, -1.0);
    v62 = a9;
    v63 = &v49->f32[v61 / 4];
    v64 = &v50[v19];
    v65 = &v49->f32[v51];
    v66 = a3;
  }
  else
  {
    v67 = &v94[v52];
    v61 = 4 * a5;
    cstdlib_memcpy(v50, &v49->f32[v51], v61);
    xmy(a5, v49->f32, 1, v50, 1);
    cstdlib_memcpy(v94, &v60[v51], v61);
    axpy(a5, v94, 1, v50, 1, 1.0);
    fi_activate_array(v50, a5, a11);
    cstdlib_memcpy(v67, (char *)v49 + v61, v61);
    fill_array_f32(v94, a5, 1.0);
    axpy(a5, v67, 1, v94, 1, -1.0);
    v66 = a3;
    v62 = a9;
    v63 = v67;
    v59 = a9;
    v64 = &v50[v19];
    v65 = &v49->f32[v21];
  }
  fi_multiply_multiply_add_ansic(v62, v63, v64, v65, v66, a5);
  cstdlib_memcpy(v59, a3, v61);
  v17 = v92;
  if (v102[0])
  {
    (*(void (**)(uint64_t))(v92[1] + 80))(v92[2]);
    v102[0] = 0;
  }
  if (v101)
  {
    (*(void (**)(uint64_t))(v92[1] + 80))(v92[2]);
    v41 = 0;
    v101 = 0;
  }
  else
  {
    v41 = 0;
  }
LABEL_51:
  if (*((_QWORD *)&v100 + 1))
  {
    (*(void (**)(uint64_t))(v17[1] + 80))(v17[2]);
    *((_QWORD *)&v100 + 1) = 0;
  }
  if (*((_QWORD *)&v98 + 1))
    (*(void (**)(uint64_t))(v17[1] + 80))(v17[2]);
  return v41;
}

uint64_t forward_fc_layer_f32(uint64_t a1, float *a2, float32x4_t *a3)
{
  unsigned int *v6;
  uint64_t v7;
  _BOOL4 v8;
  int *v9;
  uint64_t *v10;
  _BOOL4 is_enabled;
  _BOOL4 v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  const void *v17;
  const void *v18;
  int v19;
  BOOL v20;
  int v21;
  unsigned int *v22;
  uint64_t size;
  unsigned int step;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int *v34;
  unsigned int v35;
  uint64_t v36;
  char *v37;
  __int128 *v38;
  uint64_t v39;
  uint64_t (*v40)(uint64_t, _QWORD, uint64_t);
  int padded_len;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  float *v49;
  uint64_t v51;
  unsigned int v52;
  float *v53;
  int v54;
  float *v55;
  float32x4_t *v56;
  uint64_t v57;
  int *v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;
  char *v62;

  v6 = *(unsigned int **)(a1 + 72);
  v61 = 0;
  v62 = 0;
  v7 = *(unsigned int *)(a1 + 12);
  v8 = (*(_DWORD *)(a1 + 16) & 0xFFFFFFFD) == 1;
  v9 = *(int **)(a1 + 120);
  v10 = *(uint64_t **)a1;
  is_enabled = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  v12 = fi_feat_is_enabled(*(_QWORD *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  v59 = 0u;
  v60 = 0u;
  if (v12 && v6)
  {
    v55 = a2;
    v13 = v6[1];
    v14 = *(_QWORD *)(a1 + 72);
    v15 = *(unsigned int *)(a1 + 96);
    v16 = (const void *)(v14 + v15);
    v17 = (const void *)(v14 + (v15 & 0xFFFFFFFC));
    if ((v13 & 8) != 0)
      v18 = v16;
    else
      v18 = v17;
  }
  else
  {
    if (!v6)
    {
LABEL_46:
      size = 0;
      goto LABEL_47;
    }
    v55 = a2;
    v18 = (const void *)(*(_QWORD *)(a1 + 72) + (*(_DWORD *)(a1 + 96) & 0xFFFFFFFC));
    v13 = v6[1];
  }
  v54 = v8;
  v58 = v9;
  v56 = a3;
  v19 = v12 || is_enabled;
  v20 = !v12 && !is_enabled || v6 == 0;
  v21 = !v20;
  v22 = v6;
  if (!v20)
    v22 = &v6[*v6];
  v57 = (uint64_t)v22;
  size = fi_shape_get_size((int *)(a1 + 40), (int *)&v61);
  if (!(_DWORD)size)
  {
    step = fi_shape_get_step((_DWORD *)(a1 + 20));
    if (!step)
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"steps must > 0, but it is: %d", v25, v26, v27, 0);
      size = 7;
      goto LABEL_47;
    }
    v52 = step;
    size = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v61 + 1);
    if (!(_DWORD)size)
    {
      if (!v21
        || (v28 = v6[2]) == 0
        || ((v29 = get_padded_len(HIDWORD(v61), 8u), (v13 & 3) != 3)
          ? (v30 = pack_bsc_data((uint64_t)v10, v28, v29, v7, v57, (uint64_t *)&v62))
          : (v30 = pack_bsr_data((uint64_t)v10, v28, v29, v7, v57, (uint64_t *)&v62)),
            size = v30,
            !(_DWORD)v30))
      {
        if (v52 < 2 || (v31 = HIDWORD(v61), get_padded_len(HIDWORD(v61), 8u) == (_DWORD)v31))
        {
          v53 = 0;
        }
        else
        {
          v39 = v10[2];
          v40 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v10[1] + 16);
          padded_len = get_padded_len(v31, 8u);
          v42 = v40(v39, padded_len * v52, 4);
          if (!v42)
          {
            log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v43, v44, v45, v51);
LABEL_53:
            size = 10;
            goto LABEL_47;
          }
          v46 = 0;
          v53 = (float *)v42;
          v47 = 0;
          do
          {
            v48 = get_padded_len(v31, 8u);
            cstdlib_memcpy(&v53[(v48 * v47++)], &v55[v46], 4 * v31);
            v46 += v31;
          }
          while (v52 != v47);
        }
        if (v58[1] == 1)
        {
          v32 = 0;
          if (v52 <= 1)
            v33 = 1;
          else
            v33 = v52;
          do
          {
            cstdlib_memcpy(&v56->f32[v32], v18, 4 * v7);
            v32 += v7;
            --v33;
          }
          while (v33);
        }
        if (!v19)
        {
          v38 = 0;
          v36 = v57;
          v34 = v58;
          v37 = (char *)v57;
          v49 = v55;
          v35 = v52;
LABEL_45:
          fc_gemm_wrapper(a1, v35, HIDWORD(v61), v7, v37, v49, v49, v53, v36, v56, v38);
          fi_activate_array(v56->f32, v61, *v34);
          goto LABEL_46;
        }
        if (pack_gemm_params((uint64_t)v10, v54, v6, (uint64_t)&v59))
        {
          v34 = v58;
          v35 = v52;
          v36 = v57;
          if ((v6[1] & 1) != 0)
            v37 = v62;
          else
            v37 = (char *)v57;
          v38 = &v59;
          v49 = v55;
          goto LABEL_45;
        }
        goto LABEL_53;
      }
    }
  }
LABEL_47:
  if (v62)
  {
    (*(void (**)(uint64_t))(v10[1] + 80))(v10[2]);
    v62 = 0;
  }
  if (*((_QWORD *)&v60 + 1))
    (*(void (**)(uint64_t))(v10[1] + 80))(v10[2]);
  return size;
}

uint64_t pack_gemm_params(uint64_t a1, int a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v6;
  _DWORD *v7;

  v4 = a4;
  *(_DWORD *)(a4 + 4) = a2;
  if (!a3)
  {
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 8) = 1;
    *(_QWORD *)(a4 + 16) = 0x100000000;
    goto LABEL_6;
  }
  *(_DWORD *)a4 = a3[1] & 1;
  *(_DWORD *)(a4 + 8) = ((a3[1] >> 1) & 1) == 0;
  v6 = a3[1];
  *(_DWORD *)(a4 + 16) = (v6 >> 3) & 1;
  *(_DWORD *)(a4 + 20) = ((a3[1] >> 4) & 1) == 0;
  if (((v6 >> 3) & 1) == 0)
  {
LABEL_6:
    *(_QWORD *)(a4 + 24) = 0;
    return v4;
  }
  v7 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 64))(*(_QWORD *)(a1 + 16), 2, 4);
  *(_QWORD *)(v4 + 24) = v7;
  if (!v7)
    return 0;
  *v7 = a3[7];
  v7[1] = a3[8];
  return v4;
}

void fc_gemm_wrapper(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, char *a5, float *a6, float *a7, float *a8, uint64_t a9, float32x4_t *a10, _DWORD *a11)
{
  _DWORD *v17;
  float32x4_t *v18;
  float *v19;
  float *v20;
  int padded_len;
  int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t *v25;
  uint64_t v26;
  float *v27;

  v18 = a10;
  v17 = a11;
  if (a2 < 2)
    goto LABEL_3;
  v25 = *(uint64_t **)a1;
  v27 = a8;
  v19 = a6;
  v20 = a7;
  padded_len = get_padded_len(a3, 8u);
  a7 = v20;
  v17 = a11;
  v18 = a10;
  a6 = v19;
  if (padded_len == (_DWORD)a3)
  {
LABEL_3:
    v22 = *(_DWORD *)(a1 + 16);
    if (v22 == 2)
    {
      v24 = a7[1];
      axpy(a4, (float *)(a9 + 4 * *a7 * a4), 1, v18->f32, 1, 1.0);
      v23 = v24 * a4;
      goto LABEL_9;
    }
    if (v22 == 1)
    {
      v23 = *a7 * a4;
LABEL_9:
      axpy(a4, (float *)(a9 + 4 * v23), 1, v18->f32, 1, 1.0);
      return;
    }
    gemm(*(uint64_t **)a1, a2, a4, a3, a6, a5, v18, v17, a9);
  }
  else
  {
    gemm(*(uint64_t **)a1, a2, a4, a3, v27, a5, a10, a11, (uint64_t)v25);
    if (v27)
      (*(void (**)(_QWORD, float *))(*(_QWORD *)(v26 + 8) + 48))(*(_QWORD *)(v26 + 16), v27);
  }
}

uint64_t create_flatten_layer(uint64_t *a1, const void *a2, uint64_t ***a3)
{
  uint64_t **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  void *v11;
  uint64_t result;
  uint64_t v13;

  v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v10 = v6;
  if (v6
    && (*v6 = a1,
        v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    cstdlib_memcpy(v11, a2, 4uLL);
    result = 0;
    *((_DWORD *)v10 + 2) = 7;
    v10[16] = (uint64_t *)forward_flatten_layer;
    v10[17] = (uint64_t *)free_flatten_buffer;
    v10[18] = (uint64_t *)flatten_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v13);
    free_flatten_buffer(v10);
    result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_flatten_layer(uint64_t a1, uint64_t a2, const void *a3, void *a4)
{
  uint64_t size;
  unsigned int v8;

  v8 = 0;
  size = fi_shape_get_size((int *)(a2 + 40), (int *)&v8);
  if (!(_DWORD)size)
    cstdlib_memcpy(a4, a3, 4 * v8);
  return size;
}

_QWORD *free_flatten_buffer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
        v1[15] = 0;
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t flatten_layer_update_shape(_DWORD *a1, _DWORD *a2)
{
  uint64_t result;
  int v5;
  int v6;

  v6 = 0;
  cstdlib_memcpy(a1 + 5, a2, 0x14uLL);
  result = fi_shape_get_size(a2, &v6);
  if (!(_DWORD)result)
  {
    v5 = v6;
    a1[10] = 1;
    a1[11] = v5;
    a1[14] = a2[4];
  }
  return result;
}

uint64_t create_norm_layer(uint64_t *a1, const void *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t result;
  uint64_t v12;

  v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  v10 = (_QWORD *)v6;
  if (v6)
  {
    cstdlib_memcpy((void *)(v6 + 8), a2, 0xCuLL);
    result = 0;
    *v10 = a1;
    v10[16] = forward_norm_layer;
    v10[17] = free_norm_buffer;
    v10[18] = norm_layer_update_shape;
    v10[19] = norm_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v12);
    result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_norm_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v9;
  int *v10;
  int step;
  float *v12;
  float *v13;
  uint64_t input_dim;
  unsigned int padded_len;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int i;
  uint64_t v26;
  void *v27;
  void *v28;
  int v29;
  double v31;
  uint64_t v32;
  float *v33;
  float v34;
  float v35;
  double v36;
  uint64_t v37;
  float *v38;
  float v39;
  float v40;
  uint64_t v41;
  float *v42;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  int v49;

  v9 = *(uint64_t **)a2;
  v49 = 0;
  v10 = (int *)(a2 + 40);
  step = fi_shape_get_step((_DWORD *)(a2 + 40));
  v48 = 0;
  v12 = *(float **)(a2 + 88);
  v13 = *(float **)(a2 + 104);
  input_dim = fi_shape_get_input_dim(v10, (int *)&v48);
  if (!(_DWORD)input_dim)
  {
    v47 = a3;
    padded_len = get_padded_len(v48, 8u);
    v19 = padded_len;
    v20 = v48;
    if (a5 && !*(_DWORD *)(a5 + 16) && v48 != padded_len)
    {
      log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Normalization layer cannot work with swapNeeded equal to 0 and an input dimension not multiple of the padding (%d).", v16, v17, v18, 8);
      v20 = v48;
    }
    v46 = a4;
    if (v20 == v19)
    {
      v21 = 0;
    }
    else
    {
      v21 = (void *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v9[1] + 16))(v9[2], v19, 4);
      if (!v21)
      {
        log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory in normalization layer!", v22, v23, v24, v44);
        return 10;
      }
    }
    input_dim = fi_shape_get_size(v10, &v49);
    if (!(_DWORD)input_dim)
    {
      if (!step)
      {
        input_dim = 0;
        if (!v21)
          return input_dim;
        goto LABEL_34;
      }
      v45 = v9;
      for (i = 0; i != step; ++i)
      {
        v26 = v48 * i;
        v27 = (void *)(v47 + 4 * v26);
        v28 = v21;
        if (v48 == v19)
        {
          if (!a5 || (v28 = (void *)(v47 + 4 * v26), *(_DWORD *)(a5 + 16)))
            v28 = (void *)(v46 + 4 * v26);
        }
        cstdlib_memcpy(v28, (const void *)(v47 + 4 * v26), 4 * v48);
        v29 = v48;
        if (*(_DWORD *)(a2 + 8) == 40 && v48 != 0)
        {
          v31 = 0.0;
          v32 = v48;
          v33 = (float *)v28;
          do
          {
            v34 = *v33++;
            v31 = v31 + v34;
            --v32;
          }
          while (v32);
          v35 = v31 / (double)v48;
          v36 = 0.0;
          v37 = v48;
          v38 = (float *)v28;
          do
          {
            v39 = *v38++;
            v36 = v36 + (float)(v39 - v35) * (float)(v39 - v35);
            --v37;
          }
          while (v37);
          v40 = sqrt(v36 / (double)v48) + 1.0e-30;
          v41 = v48;
          v42 = (float *)v28;
          do
          {
            *v42 = (float)(*v42 - v35) / v40;
            ++v42;
            --v41;
          }
          while (v41);
        }
        xmy(v29, v12, 1, (float *)v28, 1);
        axpy(v48, v13, 1, (float *)v28, 1, 1.0);
        if (v48 != v19)
        {
          if (!a5 || *(_DWORD *)(a5 + 16))
            v27 = (void *)(v46 + 4 * v48 * i);
          cstdlib_memcpy(v27, v28, 4 * v48);
          cstdlib_memset(v21, 0, 4 * v48);
        }
      }
      input_dim = 0;
      v9 = v45;
    }
    if (v21)
LABEL_34:
      (*(void (**)(uint64_t, void *))(v9[1] + 48))(v9[2], v21);
  }
  return input_dim;
}

uint64_t free_norm_buffer(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(*(_QWORD *)result + 8) + 48))(*(_QWORD *)(*(_QWORD *)result + 16), result);
  return result;
}

uint64_t norm_layer_update_shape(uint64_t a1, const void *a2)
{
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  cstdlib_memcpy((void *)(a1 + 40), a2, 0x14uLL);
  return 0;
}

uint64_t norm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t input_dim;
  unsigned int v7;

  v7 = 0;
  input_dim = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v7);
  if (!(_DWORD)input_dim)
  {
    *a2 = 4 * get_padded_len(v7, 8u);
    *a3 = 4 * v7;
  }
  return input_dim;
}

uint64_t gl_get_glType(const char *a1)
{
  uint64_t result;

  result = cstdlib_strcmp(a1, "ORIGIN");
  if ((_DWORD)result)
    return cstdlib_strcmp(a1, "ADMM") == 0;
  return result;
}

uint64_t create_gl_layer(uint64_t *a1, const void *a2, const void *a3, uint64_t ***a4)
{
  uint64_t **v5;
  uint64_t v6;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v16;

  v5 = 0;
  v6 = 7;
  if (!a2 || !a3)
    goto LABEL_7;
  v5 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v5
    || (v13 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 24)) == 0)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v16);
    v6 = 10;
LABEL_7:
    free_gl_layer(v5);
    goto LABEL_8;
  }
  v14 = v13;
  cstdlib_memcpy(v13, a3, 0x18uLL);
  v5[15] = v14;
  cstdlib_memcpy(v5 + 1, a2, 0xCuLL);
  v6 = 0;
  *v5 = a1;
  v5[16] = (uint64_t *)forward_gl_layer;
  v5[17] = (uint64_t *)free_gl_layer;
  v5[18] = (uint64_t *)gl_layer_update_shape;
  v5[20] = (uint64_t *)gl_request_glbBuf;
LABEL_8:
  *a4 = v5;
  return v6;
}

uint64_t forward_gl_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float *v12;
  unsigned int v13;
  uint64_t *v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  float32x2_t *v19;
  float *v20;
  unsigned int i;
  float v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t result;
  float32x2_t *v30;
  uint64_t v31;
  float *v32;
  float v33;
  float v34;
  float v35;
  BOOL v36;
  float v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float v47;
  uint64_t v48;
  int v49;
  int j;
  uint64_t v51;
  int v52;
  float v53;
  float v54;
  float v55;
  uint64_t v56;
  float *v57;
  int v58;
  char *v59;
  float32x2_t v60;
  float32x2_t v61;
  float *v62;
  uint64_t v63;
  uint64_t v64;
  float32x2_t v65;
  float32x2_t v66;
  float v67;
  float32x2_t v68;
  float v69;
  uint64_t v70;
  const char *v71;
  uint64_t v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  void *__dst;
  float *__dsta;
  uint64_t *v79;
  float *v80;
  unsigned int v81;
  uint64_t v82;
  float *v83;
  uint64_t *v84;
  float *v85;
  int v86;
  float *__b;
  uint64_t __ba;
  unsigned int v89;
  unsigned int v90;
  unsigned int step;
  float32x2_t v92;
  unsigned int v93;
  unsigned int v94[3];

  v12 = *(float **)(a2 + 120);
  v13 = *((_DWORD *)v12 + 5);
  if (v13 != 1)
  {
    if (v13)
    {
      v70 = **(_QWORD **)a2;
      v71 = "must offer correct gl_type input!";
LABEL_76:
      log_OutText(v70, (uint64_t)"FastInfer", 0, 0, (uint64_t)v71, a6, a7, a8, v72);
      return 7;
    }
    v93 = 0;
    v14 = *(uint64_t **)a2;
    step = fi_shape_get_step((_DWORD *)(a2 + 20));
    v16 = *(unsigned int *)v12;
    v15 = *((_DWORD *)v12 + 1);
    fi_shape_get_size((int *)(a2 + 40), (int *)&v93);
    v17 = v93 - v16;
    v93 -= v16;
    if (*(_DWORD *)(a2 + 36) == 4)
    {
      v18 = *(_DWORD *)(a2 + 28);
      if (*(_DWORD *)v12 == 2 * v18 - 2)
      {
        v79 = v14;
        v81 = v15;
        v75 = a5;
        __dst = a4;
        v19 = *(float32x2_t **)(a2 + 240);
        v89 = v16 * step;
        v83 = (float *)&v19[v16 * step];
        __b = &v83[v16 * step];
        v20 = &__b[v17 + v16];
        cstdlib_memset(v19, 0, 8 * v16 * step);
        v85 = v20;
        cstdlib_memset(v20, 0, 8 * v16 + 4 * (3 * v16));
        if (v18)
        {
          for (i = 0; i != v18; ++i)
          {
            if (step)
            {
              v22 = v12[2];
              v23 = i;
              v24 = i;
              v25 = step;
              do
              {
                v19[v24].f32[0] = powf(*(float *)(a3 + 4 * v23), v22);
                v24 += v16;
                v23 += v18;
                --v25;
              }
              while (v25);
            }
          }
        }
        v27 = (uint64_t)v85;
        v26 = (uint64_t)&v83[v16 * step];
        fi_istft(v79, v85, (uint64_t)v19, __b, step, *((unsigned int *)v12 + 4), v16, v81);
        get_amp((uint64_t)v19, v83, v89);
        if (*((_DWORD *)v12 + 3))
        {
          v28 = 0;
          do
          {
            result = fi_stft((uint64_t)v79, v27, v26, (uint64_t)v19, v93, *((unsigned int *)v12 + 4), v16, v81);
            if ((_DWORD)result)
              return result;
            if (v89)
            {
              v30 = v19;
              v31 = v16 * step;
              v32 = (float *)&v19[v31];
              do
              {
                v33 = v30->f32[0];
                v34 = v30->f32[1];
                if (v34 == 0.0)
                {
                  v36 = v33 <= 0.0;
                  if (v33 != 0.0)
                  {
                    v37 = *v32;
                    if (v36)
                      v37 = -*v32;
                    v30->f32[0] = v37;
                  }
                }
                else
                {
                  v35 = Q_rsqrt((float)(v34 * v34) + (float)(v33 * v33));
                  if (v35 >= 10000000.0)
                    *v30 = 0;
                  else
                    *v30 = vmul_n_f32(*v30, v35 * *v32);
                }
                ++v32;
                ++v30;
                --v31;
              }
              while (v31);
            }
            v26 = (uint64_t)&v83[v16 * step];
            cstdlib_memset(__b, 0, 4 * (v93 + v16));
            v27 = (uint64_t)v85;
            result = fi_istft(v79, v85, (uint64_t)v19, __b, step, *((unsigned int *)v12 + 4), v16, v81);
            if ((_DWORD)result)
              return result;
          }
          while (++v28 < *((_DWORD *)v12 + 3));
        }
        cstdlib_memmove(__dst, (const void *)(v26 + ((2 * v16) & 0x1FFFFFFFCLL)), 4 * (v93 + v81));
        result = 0;
        *(_DWORD *)(a2 + 44) = v93 + v81;
        v38 = v75;
LABEL_29:
        *(_DWORD *)(v38 + 20) = 1;
        return result;
      }
      v70 = *v14;
      goto LABEL_75;
    }
    v70 = *v14;
LABEL_72:
    v71 = "only support f32 input!";
    goto LABEL_76;
  }
  v94[0] = 0;
  v39 = *(uint64_t **)a2;
  v90 = fi_shape_get_step((_DWORD *)(a2 + 20));
  v40 = *(unsigned int *)v12;
  v41 = *((_DWORD *)v12 + 1);
  fi_shape_get_size((int *)(a2 + 40), (int *)v94);
  v94[0] -= v40;
  if (*(_DWORD *)(a2 + 36) != 4)
  {
    v70 = *v39;
    goto LABEL_72;
  }
  v84 = v39;
  v42 = *(unsigned int *)(a2 + 28);
  if (*(_DWORD *)v12 != 2 * (_DWORD)v42 - 2)
  {
    v70 = *v84;
LABEL_75:
    v71 = "wrong number of spec n_freqs!";
    goto LABEL_76;
  }
  v74 = a2;
  v76 = a5;
  v43 = *(char **)(a2 + 240);
  v44 = (uint64_t)&v43[8 * v40 * v90];
  v45 = v44 + 8 * v40 * v90;
  v82 = v40 * v90;
  __ba = v40;
  v80 = (float *)(v45 + 4 * v82);
  v73 = v41;
  if ((_DWORD)v40)
  {
    v46 = 0;
    v47 = (float)__ba;
    do
    {
      *(float *)(v45 + 4 * v82 + 4 * __ba + 4 * v46) = window_function(*((_DWORD *)v12 + 4), (float)v46, v47);
      ++v46;
    }
    while (__ba != v46);
    v48 = 0;
    do
    {
      v80[v48] = (float)(v80[__ba + v48] * v80[__ba + v48]) * v47;
      ++v48;
    }
    while (__ba != v48);
  }
  __dsta = (float *)a4;
  cstdlib_memset(v43, 0, 4 * v82 + 8 * (2 * v82));
  if (v90)
  {
    v49 = 0;
    for (j = 0; j != v90; ++j)
    {
      if ((_DWORD)v42)
      {
        v51 = 0;
        v52 = j * __ba;
        do
        {
          v53 = v12[2];
          if (v53 >= 1.751 || v53 <= 1.699)
          {
            v55 = *(float *)(a3 + 4 * (v49 + v51));
            if (v53 >= 1.501 || v53 <= 1.499)
              v54 = powf(v55, v53);
            else
              v54 = (float)(v55 * v55) * Q_rsqrt(v55);
          }
          else
          {
            v54 = Q_powf_1_75(*(float *)(a3 + 4 * (v49 + v51)));
          }
          v56 = 8 * (v51 + v52);
          *(float *)&v43[v56] = v54;
          *(float *)(v44 + v56) = v54;
          *(float *)(v45 + 4 * (v51++ + v52)) = v54;
        }
        while (v42 != v51);
      }
      v49 += v42;
    }
  }
  v57 = __dsta;
  if (!*((_DWORD *)v12 + 3))
  {
LABEL_66:
    result = fi_istft(v84, v80, v44, v57, v90, *((unsigned int *)v12 + 4), __ba, v73);
    if ((_DWORD)result)
      return result;
    cstdlib_memmove(v57, &v57[__ba >> 1], 4 * (v94[0] + v73));
    *(_DWORD *)(v74 + 44) = v94[0] + v73;
    v38 = v76;
    if (!v76)
      return 0;
    result = 0;
    goto LABEL_29;
  }
  v58 = 0;
  v59 = &v43[8 * v82];
  v60 = (float32x2_t)vdup_n_s32(0xBF51745C);
  v61 = (float32x2_t)vdup_n_s32(0x3FE8BA2Eu);
  while (1)
  {
    v86 = v58;
    result = fi_istft(v84, v80, v44, v57, v90, *((unsigned int *)v12 + 4), __ba, v73);
    if ((_DWORD)result)
      return result;
    v62 = v57;
    result = fi_stft((uint64_t)v84, (uint64_t)v80, (uint64_t)v57, (uint64_t)v43, v94[0], *((unsigned int *)v12 + 4), __ba, v73);
    if ((_DWORD)result)
      return result;
    if ((int)v82 >= 1)
    {
      v63 = 0;
      v64 = 16 * v82;
      do
      {
        v65 = *(float32x2_t *)&v59[v63];
        v66 = vmla_f32(vmul_f32(v65, v60), v61, *(float32x2_t *)&v43[v63]);
        *(float32x2_t *)&v59[v63] = vmul_f32(vsub_f32(v65, v66), (float32x2_t)0x3F0000003F000000);
        if (v66.f32[1] == 0.0)
        {
          if (v66.f32[0] != 0.0)
          {
            v69 = *(float *)&v43[v64];
            if (v66.f32[0] <= 0.0)
              v69 = -v69;
            v66.f32[0] = v69;
          }
          v68 = v66;
        }
        else
        {
          v92 = v66;
          v67 = Q_rsqrt(vmul_f32(v66, v66).f32[0] + (float)(v66.f32[1] * v66.f32[1]));
          v68 = 0;
          if (v67 < 10000000.0)
            v68 = vmul_n_f32(v92, v67 * *(float *)&v43[v64]);
        }
        *(float32x2_t *)&v59[v63] = vadd_f32(v68, *(float32x2_t *)&v59[v63]);
        v64 += 4;
        v63 += 8;
      }
      while (8 * v82 != v63);
    }
    ++v58;
    v57 = v62;
    if ((v86 + 1) >= *((_DWORD *)v12 + 3))
      goto LABEL_66;
  }
}

_QWORD *free_gl_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      if (result[15])
        (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t gl_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;

  v4 = *(_DWORD **)(a1 + 120);
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 == 2)
  {
    result = 0;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = *v4 + (a2[1] - 1) * v4[1];
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently gl layer only support 2D input", v5, v6, v7, v9);
    return 7;
  }
  return result;
}

uint64_t gl_request_glbBuf(uint64_t a1)
{
  int *v2;
  int step;
  int v4;
  uint64_t result;
  int v6;
  int v7;
  int v8;

  v2 = *(int **)(a1 + 120);
  v8 = 0;
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v4 = *v2;
  result = fi_shape_get_size((int *)(a1 + 40), &v8);
  if (!(_DWORD)result)
  {
    v6 = v4 * step;
    if (v2[5])
      v7 = (4 * step + 20) * v4 + 16 * v6;
    else
      v7 = 4 * (v8 + v4 * (step + 4)) + 8 * (3 * v6 + v4);
    *(_DWORD *)(a1 + 248) = v7;
  }
  return result;
}

_QWORD *free_tacotron_stream(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[33]);
        fi_layer_free(v3[34]);
        fi_layer_free(v3[35]);
        fi_layer_free(v3[36]);
        fi_layer_free(v3[37]);
        fi_layer_free(v3[38]);
        fi_layer_free(v3[39]);
        fi_layer_free(v3[40]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_tacotron_stream(uint64_t *a1, int32x2_t *a2, const void *a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  __int32 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD __b[2];

  v7 = 0;
  v8 = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v17 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 376);
      v21 = v17;
      if (!v17)
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v18, v19, v20, v34);
        v8 = 10;
        goto LABEL_12;
      }
      cstdlib_memcpy(v17, a2, 0x108uLL);
      *((_QWORD *)v21 + 41) = 0;
      *((_DWORD *)v21 + 90) = a2[28].i32[1];
      *((_QWORD *)v21 + 43) = 0;
      *((_QWORD *)v21 + 46) = 0;
      v37 = 0;
      memset(__b, 0, 12);
      cstdlib_memset(__b, 0, 0xCuLL);
      v22 = a2[1].i32[0];
      LODWORD(__b[0]) = 5;
      HIDWORD(__b[0]) = v22;
      LODWORD(__b[1]) = 0;
      if (create_fc_layer(a1, __b, &v37, 0, a4, (uint64_t *)v21 + 33)
        || (HIDWORD(__b[0]) = a2[1].i32[1],
            v37 = 0x100000003,
            create_fc_layer(a1, __b, &v37, 0, a4, (uint64_t *)v21 + 34))
        || (HIDWORD(__b[0]) = a2[2].i32[0], create_fc_layer(a1, __b, &v37, 0, a4, (uint64_t *)v21 + 35)))
      {
        v26 = "create pre dense failed!";
LABEL_9:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v34);
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron init failed!", v27, v28, v29, v35);
        v8 = 7;
LABEL_12:
        *(_QWORD *)(v7 + 120) = v21;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron_stream init param failed!", v30, v31, v32, v36);
        goto LABEL_13;
      }
      HIDWORD(__b[0]) = a2[26].i32[0];
      LODWORD(v37) = a2[10].i32[0] == 1;
      if (create_fc_layer(a1, __b, &v37, 0, a4, (uint64_t *)v21 + 40))
      {
        v26 = "create post dense failed!";
        goto LABEL_9;
      }
      if (create_cbhg_layer(a1, (char *)&a2[2] + 4, a3, a4, (uint64_t ***)v21 + 36))
      {
        v26 = "create encoder cbhg failed!";
        goto LABEL_9;
      }
      if (create_tacodecoder_layer(a1, &a2[7], a4, (uint64_t *)v21 + 37))
      {
        v26 = "create decoder failed!";
        goto LABEL_9;
      }
      LODWORD(__b[0]) = 3;
      *(int32x2_t *)((char *)__b + 4) = vrev64_s32(a2[25]);
      if (create_lstm_layer(a1, __b, &a2[18], a3, a4, v21 + 304))
      {
        v26 = "create LSTM1 layer failed!";
        goto LABEL_9;
      }
      if (create_lstm_layer(a1, __b, &a2[21].u8[4], a3, a4, v21 + 312))
      {
        v26 = "create LSTM2 layer failed!";
        goto LABEL_9;
      }
      *(_QWORD *)(v7 + 120) = v21;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      v8 = 0;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_tacotron_stream;
      *(_QWORD *)(v7 + 136) = free_tacotron_stream;
      *(_QWORD *)(v7 + 144) = tacotron_stream_update_shape;
      *(_QWORD *)(v7 + 152) = tacotron_stream_wanted_wb_len;
      *(_QWORD *)(v7 + 184) = tacotron_stream_dispatch_weights;
      *(_DWORD *)(v7 + 8) = a5;
      *(_DWORD *)(v7 + 12) = 0;
      *(_QWORD *)(v7 + 160) = tacotron_stream_request_glbBuf;
      *(_QWORD *)(v7 + 168) = tacotron_stream_assign_glbBuf;
      *(_QWORD *)(v7 + 224) = tacotron_stream_update_param;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v34);
      v8 = 10;
    }
  }
LABEL_13:
  *a6 = v7;
  return v8;
}

uint64_t forward_tacotron_stream(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t *v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t bytes;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  const char *v31;
  float v33;
  float v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unint64_t v40;
  int v41;
  size_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  void *v46;
  uint64_t *v47;
  void *v48;
  uint64_t v49;
  unsigned int v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  size_t v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  const void *v61;
  void *v62;
  size_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  unsigned int padded_len;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t alignment;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  _DWORD *v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  unsigned int *v90;
  __n128 v91;
  uint64_t v92;
  char *v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t *v97;
  unsigned int v98;
  int v99;
  uint64_t (*v100)(void);
  uint64_t (*v101)(void);
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  const void *v122;
  uint64_t v123;
  float *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  int v131;
  unsigned int v132;
  uint64_t v133;
  float *v134;
  float v135;
  int *v136;
  int v137;
  _DWORD *v138;
  uint64_t v139;
  unsigned int *v140;
  size_t __len;
  unint64_t v142;
  unint64_t v143;
  char *v144;
  _DWORD *v145;
  size_t v146;
  unint64_t v147;
  int v148;
  uint64_t v149;
  int v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  char *__dst;
  uint64_t v155;
  unsigned int v156;
  _QWORD v157[2];
  int v158;
  uint64_t v159;
  int v160;
  int v161;
  uint64_t v162;
  uint64_t v163;

  v163 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a2 + 120);
  v11 = *(uint64_t **)a2;
  v155 = 0;
  v160 = 0;
  v159 = 0;
  v12 = *(_DWORD *)(a2 + 24);
  v13 = *(_DWORD *)(v10 + 60);
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v11[1] + 16))(v11[2], 1, 64);
  if (!v14)
  {
    log_OutText(*v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v139);
    return 10;
  }
  v18 = v14;
  v151 = a5;
  v152 = a1;
  v150 = v13;
  v153 = v10;
  __dst = a4;
  v19 = *(uint64_t **)a2;
  v20 = *(_QWORD *)(a2 + 120);
  LODWORD(v157[0]) = 0;
  v21 = *(_QWORD *)(a2 + 240);
  *(_QWORD *)(v14 + 16) = v21;
  v22 = *(_DWORD *)(v20 + 224) * get_padded_len(*(unsigned int *)(v20 + 68), 8u);
  *(_QWORD *)(v18 + 24) = v21 + 4 * v22;
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v20 + 296) + 40), v157);
  if ((_DWORD)bytes)
    goto LABEL_6;
  v27 = v22 + (get_padded_bytes(v157[0], 8u) >> 2);
  *(_QWORD *)(v18 + 32) = v21 + 4 * v27;
  v28 = get_padded_len((*(_DWORD *)(v20 + 208) * *(_DWORD *)(v20 + 212)), 8u) + v27;
  *(_QWORD *)(v18 + 40) = v21 + 4 * v28;
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v20 + 304) + 40), v157);
  if ((_DWORD)bytes
    || (v29 = v28 + (get_padded_bytes(v157[0], 8u) >> 2),
        *(_QWORD *)(v18 + 48) = v21 + 4 * v29,
        bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v20 + 312) + 40), v157),
        (_DWORD)bytes)
    || (*(_QWORD *)(v18 + 56) = v21 + 4 * (v29 + (get_padded_bytes(v157[0], 8u) >> 2)),
        bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v20 + 296) + 216))(),
        (_DWORD)bytes))
  {
LABEL_6:
    v30 = *v19;
    v31 = "tacotron stream pack buf manager failed!";
LABEL_7:
    log_OutText(v30, (uint64_t)"FastInfer", 0, 0, (uint64_t)v31, v23, v24, v25, v139);
    goto LABEL_8;
  }
  *(_QWORD *)v18 = a3;
  *(_QWORD *)(v18 + 8) = __dst;
  if (v12 == 3)
  {
    v33 = *(float *)(a3 + 4 * (*(_DWORD *)(a2 + 28) + 1));
    v34 = *(float *)(a3 + 4);
    if (v33 < (float)(v34 + 0.0001) && v33 > (float)(v34 + -0.0001))
    {
      **(_DWORD **)(v153 + 368) = 1;
      v35 = *(_DWORD *)(v153 + 208);
      LODWORD(v159) = 1;
      HIDWORD(v159) = v35;
      *(_DWORD *)(v151 + 20) = 1;
      bytes = fi_shape_set(2, &v159, 4, (_DWORD *)(a2 + 40));
      if (!(_DWORD)bytes)
      {
        cstdlib_memset(__dst, 0, 4 * (HIDWORD(v159) * v159));
        **(_QWORD **)(v153 + 344) = 1;
        *(_DWORD *)(v153 + 356) = 10000;
      }
      goto LABEL_8;
    }
  }
  v36 = v153;
  if (!*(_DWORD *)(v153 + 328))
  {
    v44 = *(_QWORD *)(a2 + 120);
    *(_DWORD *)(v44 + 352) = *(_DWORD *)v44;
    *(_DWORD *)(v44 + 356) = 0;
    v45 = *(_DWORD **)(v44 + 368);
    *v45 = 0;
    if (!*(_DWORD *)(v44 + 332))
    {
      *(_DWORD *)(v44 + 360) = *(_DWORD *)(v44 + 228);
      *v45 = 1;
    }
    v46 = *(void **)(v18 + 24);
    v47 = *(uint64_t **)a2;
    v48 = *(void **)(a2 + 240);
    bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v44 + 264) + 40), (_DWORD *)&v155 + 1);
    if ((_DWORD)bytes)
      goto LABEL_8;
    cstdlib_memset(v48, 0, HIDWORD(v155));
    v49 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v44 + 264) + 128))(v152);
    if ((_DWORD)v49)
    {
      bytes = v49;
      v31 = "tacotron_stream pre dense o1 forward failed!";
    }
    else
    {
      bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v44 + 272) + 40), (_DWORD *)&v155 + 1);
      if ((_DWORD)bytes)
        goto LABEL_8;
      cstdlib_memset(v46, 0, HIDWORD(v155));
      v94 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v44 + 272) + 128))(v152);
      if ((_DWORD)v94)
      {
        bytes = v94;
        v31 = "tacotron_stream pre dense o2 forward failed!";
      }
      else
      {
        bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v44 + 280) + 40), (_DWORD *)&v155 + 1);
        if ((_DWORD)bytes)
          goto LABEL_8;
        cstdlib_memset(v48, 0, HIDWORD(v155));
        v110 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v44 + 280) + 128))(v152);
        if ((_DWORD)v110)
        {
          bytes = v110;
          v31 = "tacotron_stream pre dense o3 forward failed!";
        }
        else
        {
          bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v44 + 288) + 176))();
          if ((_DWORD)bytes)
            goto LABEL_8;
          bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v44 + 288) + 40), (_DWORD *)&v155 + 1);
          if ((_DWORD)bytes)
            goto LABEL_8;
          cstdlib_memset(v46, 0, HIDWORD(v155));
          v111 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v44 + 288) + 128))(v152);
          if (!(_DWORD)v111)
          {
            v36 = v153;
            if (v12)
            {
              v120 = 0;
              v121 = 0;
              v122 = (const void *)(*(_QWORD *)(a2 + 72) + 4 * (*(_DWORD *)(v153 + 4) * *(_DWORD *)v153));
              do
              {
                cstdlib_memcpy((void *)(*(_QWORD *)(v18 + 16) + 4 * (*(_DWORD *)(v153 + 68) * v121)), (const void *)(*(_QWORD *)(v18 + 24) + 4 * (v120 * *(_DWORD *)(v153 + 48))), 4 * (2 * *(_DWORD *)(v153 + 48)));
                cstdlib_memcpy((void *)(*(_QWORD *)(v18 + 16)+ 4 * (*(_DWORD *)(v153 + 68) * v121++)+ 4 * (2 * *(_DWORD *)(v153 + 48))), v122, 4 * *(unsigned int *)(v153 + 4));
                v120 += 2;
              }
              while (v12 != v121);
            }
            goto LABEL_17;
          }
          bytes = v111;
          v31 = "tacotron_stream encoder cbhg forward failed!";
        }
      }
    }
    v30 = *v47;
    goto LABEL_7;
  }
LABEL_17:
  v37 = *(_QWORD *)(v36 + 344);
  v38 = *(_QWORD *)(a2 + 120);
  LODWORD(v157[0]) = 0;
  v39 = *(_DWORD *)(v38 + 244);
  v147 = *(unsigned int *)(v38 + 240);
  v40 = *(unsigned int *)(a2 + 24);
  v41 = *(_DWORD *)(v38 + 56);
  v149 = *(unsigned int *)(v38 + 60);
  v42 = (4 * v41 * *(_DWORD *)(v38 + 212));
  v43 = *(_QWORD *)(v38 + 296);
  if (*(_DWORD *)(v38 + 328))
  {
    bytes = (*(uint64_t (**)(uint64_t, _QWORD))(v43 + 200))(v43, *(_QWORD *)(v18 + 56));
    if ((_DWORD)bytes)
      goto LABEL_8;
  }
  else
  {
    bytes = (*(uint64_t (**)(void))(v43 + 176))();
    if ((_DWORD)bytes)
      goto LABEL_8;
    cstdlib_memset(*(void **)(v18 + 32), 0, v42);
  }
  cstdlib_memcpy(__dst, *(const void **)(v18 + 32), v42);
  v50 = *(_DWORD *)(v38 + 356);
  LODWORD(v51) = *(_DWORD *)(v38 + 228);
  if (v50 < v51)
  {
    v146 = (4 * v149 * v41);
    __len = (v42 - v146);
    v144 = &__dst[v42];
    v143 = (v39 + v147);
    v142 = (7 * v40);
    v140 = (unsigned int *)(v37 + 8);
    v139 = v149 - 1;
    v148 = v149 * (v50 - v147);
    v52 = v152;
    v53 = *(unsigned int *)(v38 + 356);
    v54 = v42;
    v145 = (_DWORD *)(v37 + 4);
    while (1)
    {
      v55 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v38 + 296) + 128))(v52);
      if ((_DWORD)v55)
        goto LABEL_72;
      v56 = *(_DWORD *)(v38 + 212);
      if (v56)
      {
        v57 = *(_DWORD *)(v38 + 60);
        v58 = *(char **)(v18 + 32);
        if (v56 <= v57)
        {
          v64 = *(_QWORD *)(v18 + 24);
          v61 = (const void *)(v64
                             + 4 * get_padded_len(1, 8u)
                             + 4
                             * ((*(_DWORD *)(v38 + 60) - *(_DWORD *)(v38 + 212)) * *(_DWORD *)(v38 + 56)));
          v62 = v58;
          v63 = v54;
        }
        else
        {
          cstdlib_memmove(*(void **)(v18 + 32), &v58[4 * *(_DWORD *)(v38 + 56) * v57], __len);
          v59 = *(_QWORD *)(v18 + 24);
          v60 = *(_QWORD *)(v18 + 32)
              + 4 * ((*(_DWORD *)(v38 + 212) - *(_DWORD *)(v38 + 60)) * *(_DWORD *)(v38 + 56));
          v61 = (const void *)(v59 + 4 * get_padded_len(1, 8u));
          v62 = (void *)v60;
          v63 = v146;
        }
        cstdlib_memcpy(v62, v61, v63);
      }
      v65 = &v144[((v53 - *(_DWORD *)(v38 + 356)) * v146)];
      v66 = *(_QWORD *)(v18 + 24);
      padded_len = get_padded_len(1, 8u);
      cstdlib_memcpy(v65, (const void *)(v66 + 4 * padded_len), v146);
      alignment = get_alignment(*(_QWORD *)(v38 + 296), v68, v69, v70, v71, v72, v73, v74);
      if (v40 < 2)
      {
        v82 = 0;
        v84 = v147;
        v85 = v149;
        v86 = v145;
      }
      else
      {
        v82 = 0;
        v83 = 1;
        v84 = v147;
        v85 = v149;
        v86 = v145;
        do
        {
          if (*(float *)(alignment + 4 * v83) > *(float *)(alignment + 4 * v82))
            v82 = v83;
          ++v83;
        }
        while (v40 != v83);
      }
      if (v53 <= v84)
      {
        if (v53 == v84)
        {
          *v86 = 0;
          if (v85 >= 2)
          {
            v89 = v149 - 1;
            v90 = v140;
            do
            {
              *v90++ = v82;
              --v89;
            }
            while (v89);
          }
        }
      }
      else
      {
        if (v82 <= v86[((v53 - v84) * v85 - 1)])
          v82 = v86[((v53 - v84) * v85 - 1)];
        if ((_DWORD)v85)
        {
          v87 = v85;
          v88 = v148;
          do
          {
            v86[v88++] = v82;
            --v87;
          }
          while (v87);
        }
      }
      v91.n128_f32[0] = get_last_alignment(*(_QWORD *)(v38 + 296), (float *)v157, v76, v77, v78, v79, v80, v81);
      if ((_DWORD)v55)
      {
LABEL_72:
        bytes = v55;
        goto LABEL_8;
      }
      v52 = v152;
      if (v53 > v40 >> 2)
      {
        if (**(float **)(v18 + 24) > *(float *)(v38 + 232)
          || (v91.n128_u32[0] = v157[0], *(float *)v157 > *(float *)(v38 + 236)))
        {
LABEL_73:
          LODWORD(v53) = v53 + 1;
          v93 = __dst;
          cstdlib_memset(&__dst[((v53 - *(_DWORD *)(v38 + 356)) * v146)], 0, v146);
          **(_DWORD **)(v38 + 368) = 1;
LABEL_74:
          v92 = v153;
          LODWORD(v51) = *(_DWORD *)(v38 + 228);
          goto LABEL_75;
        }
        if (v53 <= v143)
        {
          if (v53 > v142)
            goto LABEL_73;
        }
        else if (v53 > v142 || v86[((v53 - v143) * v149)] == (_DWORD)v40 - 1)
        {
          goto LABEL_73;
        }
      }
      if (v53 >= *(unsigned int *)(v38 + 360)
        && v53 > ((int)v149 - 1 + *(_DWORD *)(v38 + 212)) / v149 + v84
        && v86[((v53 - v84) * v149)] > v86[((v53 - v84 - 1) * v149)])
      {
        break;
      }
      ++v53;
      v51 = *(unsigned int *)(v38 + 228);
      v148 += v149;
      if (v53 >= v51)
      {
        v92 = v153;
        v93 = __dst;
        goto LABEL_75;
      }
    }
    bytes = (*(uint64_t (**)(__n128))(*(_QWORD *)(v38 + 296) + 208))(v91);
    if (!(_DWORD)bytes)
    {
      **(_DWORD **)(v38 + 368) = 0;
      LODWORD(v53) = v53 + 1;
      v93 = __dst;
      goto LABEL_74;
    }
    goto LABEL_8;
  }
  v93 = __dst;
  LODWORD(v53) = *(_DWORD *)(v38 + 356);
  v92 = v153;
LABEL_75:
  if (v53 >= v51)
    **(_DWORD **)(v38 + 368) = 1;
  v95 = v53 - *(_DWORD *)(v92 + 356);
  v96 = *(_QWORD *)(a2 + 120);
  v97 = *(uint64_t **)a2;
  v157[0] = 0;
  v157[1] = 0;
  v158 = 0;
  v156 = 0;
  v98 = *(_DWORD *)(v96 + 56);
  v99 = *(_DWORD *)(v96 + 60) * v95;
  v161 = v99;
  v162 = v98;
  if ((*(_DWORD *)(v96 + 356) + v95) < *(_DWORD *)(v96 + 228) && **(_DWORD **)(v96 + 368) == 1)
  {
    cstdlib_memset(&v93[4 * (*(_DWORD *)(v96 + 212) + v99) * v98], 0, 4 * *(_DWORD *)(v96 + 212) * v98);
    v161 = *(_DWORD *)(v96 + 212) + v99;
  }
  bytes = fi_shape_set(2, &v161, 4, v157);
  if (!(_DWORD)bytes)
  {
    bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v96 + 304) + 144))();
    if (!(_DWORD)bytes)
    {
      bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v96 + 312) + 144))();
      if (!(_DWORD)bytes)
      {
        v100 = *(uint64_t (**)(void))(*(_QWORD *)(v96 + 304) + 160);
        if (!v100 || (bytes = v100(), !(_DWORD)bytes))
        {
          v101 = *(uint64_t (**)(void))(*(_QWORD *)(v96 + 312) + 160);
          if (!v101 || (bytes = v101(), !(_DWORD)bytes))
          {
            bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v96 + 304) + 40), &v156);
            if (!(_DWORD)bytes)
            {
              cstdlib_memset(*(void **)(v18 + 40), 0, v156);
              bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v96 + 312) + 40), &v156);
              if (!(_DWORD)bytes)
              {
                cstdlib_memset(*(void **)(v18 + 48), 0, v156);
                if (*(_DWORD *)(v96 + 328)
                  || (bytes = reset_lstm_layer_hidden(*(_QWORD *)(v96 + 304), v102, v103, v104, v105, v106, v107, v108),
                      !(_DWORD)bytes)
                  && (bytes = reset_lstm_layer_hidden(*(_QWORD *)(v96 + 312), v112, v113, v114, v115, v116, v117, v118),
                      !(_DWORD)bytes))
                {
                  v109 = forward_lstm_layer_f32(*(_QWORD *)(v96 + 304), (uint64_t)&v93[4 * *(_DWORD *)(v96 + 212) * *(_DWORD *)(v96 + 56)], *(_QWORD *)(v18 + 40));
                  if ((_DWORD)v109)
                  {
                    bytes = v109;
                    v31 = "tacotron_stream post lstm1 forward failed!";
LABEL_106:
                    v30 = *v97;
                    goto LABEL_7;
                  }
                  v119 = forward_lstm_layer_f32(*(_QWORD *)(v96 + 312), *(_QWORD *)(v18 + 40), *(_QWORD *)(v18 + 48));
                  if ((_DWORD)v119)
                  {
                    bytes = v119;
                    v31 = "tacotron_stream post lstm2 forward failed!";
                    goto LABEL_106;
                  }
                  if (*(_DWORD *)(v96 + 216))
                    axpy(v156 >> 2, *(float **)(v18 + 40), 1, *(float **)(v18 + 48), 1, 1.0);
                  bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v96 + 320) + 144))();
                  if ((_DWORD)bytes)
                    goto LABEL_8;
                  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v96 + 320) + 40), (_DWORD *)&v155 + 1);
                  if ((_DWORD)bytes)
                    goto LABEL_8;
                  if (*(_DWORD *)(v96 + 208) == *(_DWORD *)(v96 + 56))
                  {
                    v123 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v97[1] + 16))(v97[2], (unint64_t)HIDWORD(v155) >> 2, 4);
                    if (!v123)
                    {
                      bytes = 10;
                      v31 = "Memory allocation failed!";
                      goto LABEL_106;
                    }
                    v124 = (float *)v123;
                    v125 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v96 + 320) + 128))(v152);
                    if ((_DWORD)v125)
                    {
                      bytes = v125;
                      log_OutText(*v97, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron_stream post dense forward failed!", v126, v127, v128, v139);
                      goto LABEL_129;
                    }
                    axpy(HIDWORD(v155) >> 2, v124, 1, (float *)__dst, 1, 1.0);
                  }
                  else
                  {
                    cstdlib_memset(__dst, 0, HIDWORD(v155));
                    v129 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v96 + 320) + 128))(v152);
                    if ((_DWORD)v129)
                    {
                      bytes = v129;
                      v31 = "tacotron_stream post dense forward failed!";
                      goto LABEL_106;
                    }
                    v124 = 0;
                  }
                  if (*(_DWORD *)(v96 + 80) == 2 && *(_DWORD *)(v96 + 220) != 1)
                    relu_array_f32(HIDWORD(v155) >> 2, (float *)__dst);
                  if (!v124)
                  {
                    v130 = v153;
                    goto LABEL_132;
                  }
                  bytes = 0;
LABEL_129:
                  (*(void (**)(uint64_t, float *))(v97[1] + 48))(v97[2], v124);
                  v130 = v153;
                  if ((_DWORD)bytes)
                    goto LABEL_8;
LABEL_132:
                  if (*(_DWORD *)(v130 + 328) && (*(_DWORD *)(v153 + 356) || **(_DWORD **)(v153 + 368)))
                  {
                    v131 = 0;
                  }
                  else if (v95 * v150 >= (*(_DWORD *)(v153 + 212) + *(_DWORD *)(v153 + 240) * v150))
                  {
                    v131 = *(_DWORD *)(v153 + 212) + *(_DWORD *)(v153 + 240) * v150;
                  }
                  else
                  {
                    v131 = v95 * v150;
                  }
                  if (*(_DWORD *)(v153 + 220) == 1)
                  {
                    v132 = HIDWORD(v155) >> 2;
                    if (HIDWORD(v155) >= 4)
                    {
                      if (v132 <= 1)
                        v133 = 1;
                      else
                        v133 = v132;
                      v134 = (float *)__dst;
                      do
                      {
                        v135 = *v134;
                        if (*v134 > 1.0)
                          v135 = 1.0;
                        if (v135 < 0.0)
                          v135 = 0.0;
                        *v134++ = (float)(v135 * 11.513) + -9.2103;
                        --v133;
                      }
                      while (v133);
                    }
                    fast_exp((float *)__dst, v132, (float *)__dst);
                  }
                  v136 = (int *)(a2 + 40);
                  bytes = fi_shape_get_bytes(v136, &v155);
                  if (!(_DWORD)bytes)
                  {
                    if ((_DWORD)v155 != HIDWORD(v155))
                      *(_DWORD *)(v151 + 20) = 1;
                    LODWORD(v159) = v95 * v150 - v131;
                    if (**(_DWORD **)(v153 + 368) == 1)
                      LODWORD(v159) = *(_DWORD *)(v153 + 212) + v95 * v150 - v131;
                    HIDWORD(v159) = *(_DWORD *)(v153 + 208);
                    bytes = fi_shape_set(2, &v159, 4, v136);
                    if (!(_DWORD)bytes)
                    {
                      if (v131)
                        cstdlib_memmove(__dst, &__dst[4 * HIDWORD(v159) * v131], 4 * (v159 * HIDWORD(v159)));
                      v137 = (v53 - *(_DWORD *)(v153 + 240)) * v150;
                      v138 = *(_DWORD **)(v153 + 344);
                      *v138 = v137;
                      if (!**(_DWORD **)(v153 + 368))
                        *v138 = v137 - *(_DWORD *)(v153 + 212);
                      bytes = 0;
                      *(_DWORD *)(v153 + 356) = v53;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_8:
  (*(void (**)(uint64_t, uint64_t))(v11[1] + 48))(v11[2], v18);
  return bytes;
}

uint64_t tacotron_stream_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t result;
  int step;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _QWORD v27[2];
  int v28;
  _QWORD v29[2];
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 120);
  v33 = 0;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  v5 = *(_DWORD *)(v4 + 224);
  if (*(_DWORD *)(a1 + 24) > v5)
    *(_DWORD *)(a1 + 24) = v5;
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 264) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 272) + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 280) + 144))();
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 288) + 144))();
        if (!(_DWORD)result)
        {
          v29[0] = 0;
          v29[1] = 0;
          v30 = 0;
          v27[0] = 0;
          v27[1] = 0;
          v28 = 0;
          step = fi_shape_get_step(a2);
          v8 = *(_DWORD *)(v4 + 4) + 2 * *(_DWORD *)(v4 + 48);
          v31 = step;
          v32 = v8;
          result = fi_shape_set(2, &v31, 4, v27);
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 296) + 144))(*(_QWORD *)(v4 + 296), v27, v9, v10, v11, v12);
            if (!(_DWORD)result)
            {
              v13 = *(_DWORD *)(v4 + 56);
              v31 = *(_DWORD *)(v4 + 60) + *(_DWORD *)(v4 + 60) * *(_DWORD *)(v4 + 228) + *(_DWORD *)(v4 + 212);
              v32 = v13;
              result = fi_shape_set(2, &v31, 4, v29);
              if (!(_DWORD)result)
              {
                result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 304) + 144))(*(_QWORD *)(v4 + 304), v29, v14, v15, v16, v17);
                if (!(_DWORD)result)
                {
                  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 312) + 144))(*(_QWORD *)(v4 + 312), *(_QWORD *)(v4 + 304) + 40, v18, v19, v20, v21);
                  if (!(_DWORD)result)
                  {
                    result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 320) + 144))(*(_QWORD *)(v4 + 320), *(_QWORD *)(v4 + 312) + 40, v22, v23, v24, v25);
                    if (!(_DWORD)result)
                    {
                      v26 = *(_DWORD *)(v4 + 208);
                      if (v26 <= 0x100)
                        v26 = 256;
                      v32 = v26;
                      return fi_shape_set(2, &v31, 4, (_DWORD *)(a1 + 40));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacotron_stream_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int padded_len;
  uint64_t result;
  int padded_bytes;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;

  v8 = *(_QWORD *)(a1 + 120);
  v22 = 0;
  if (v8)
  {
    padded_len = get_padded_len(*(unsigned int *)(v8 + 4), 8u);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 264) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(HIDWORD(v22) + (padded_len << 9) + (int)v22, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 272) + 152))();
      if (!(_DWORD)result)
      {
        v14 = get_padded_bytes(HIDWORD(v22) + (int)v22 + padded_bytes, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 280) + 152))();
        if (!(_DWORD)result)
        {
          v15 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v14, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 288) + 152))();
          if (!(_DWORD)result)
          {
            v16 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v15, 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 296) + 152))();
            if (!(_DWORD)result)
            {
              v17 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v16, 8u);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 304) + 152))();
              if (!(_DWORD)result)
              {
                v18 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v17, 8u);
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 312) + 152))();
                if (!(_DWORD)result)
                {
                  v19 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v18, 8u);
                  result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 320) + 152))();
                  if (!(_DWORD)result)
                  {
                    v20 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v19, 8u);
                    result = 0;
                    *a2 = v20;
                    *a3 = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v21);
    return 7;
  }
  return result;
}

uint64_t tacotron_stream_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t (*v14)(void);
  int v15;
  int padded_bytes;
  uint64_t v17;
  int v18;

  v9 = *(_QWORD *)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    result = tacotron_stream_get_reserved_glbBuf_bytes(a1, &v18);
    if (!(_DWORD)result)
    {
      v11 = 0;
      v12 = 0;
      v13 = v9 + 264;
      do
      {
        v14 = *(uint64_t (**)(void))(*(_QWORD *)(v13 + v11) + 160);
        if (v14)
        {
          result = v14();
          if ((_DWORD)result)
            return result;
          if (*(_DWORD *)(*(_QWORD *)(v13 + v11) + 248) > v12)
            v12 = *(_DWORD *)(*(_QWORD *)(v13 + v11) + 248);
        }
        v11 += 8;
      }
      while (v11 != 64);
      v15 = v18;
      padded_bytes = get_padded_bytes(v12, 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes + v15;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t tacotron_stream_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int padded_bytes;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    padded_bytes = get_padded_len(*(unsigned int *)(v8 + 4), 8u) << 9;
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 264), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 272), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 280), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 288), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            padded_bytes = get_padded_bytes(padded_bytes, 8u);
            result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 296), v9, &padded_bytes);
            if (!(_DWORD)result)
            {
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 304), v9, &padded_bytes);
              if (!(_DWORD)result)
              {
                padded_bytes = get_padded_bytes(padded_bytes, 8u);
                result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 312), v9, &padded_bytes);
                if (!(_DWORD)result)
                {
                  padded_bytes = get_padded_bytes(padded_bytes, 8u);
                  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 320), v9, &padded_bytes);
                  if (!(_DWORD)result)
                  {
                    get_padded_bytes(padded_bytes, 8u);
                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t tacotron_stream_assign_glbBuf(uint64_t a1)
{
  _QWORD *v2;
  uint64_t reserved_glbBuf_bytes;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(void);
  uint64_t v7;
  void (*v8)(void);
  uint64_t v9;
  void (*v10)(void);
  uint64_t v11;
  void (*v12)(void);
  uint64_t v13;
  void (*v14)(void);
  uint64_t v15;
  void (*v16)(void);
  uint64_t v17;
  void (*v18)(void);
  uint64_t v19;
  void (*v20)(void);
  unsigned int v22;

  v2 = *(_QWORD **)(a1 + 120);
  v22 = 0;
  reserved_glbBuf_bytes = tacotron_stream_get_reserved_glbBuf_bytes(a1, &v22);
  if (!(_DWORD)reserved_glbBuf_bytes)
  {
    v4 = v2[33];
    v5 = v22;
    *(_QWORD *)(v4 + 240) = *(_QWORD *)(a1 + 240) + v22;
    v6 = *(void (**)(void))(v4 + 168);
    if (v6)
      v6();
    v7 = v2[34];
    *(_QWORD *)(v7 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v8 = *(void (**)(void))(v7 + 168);
    if (v8)
      v8();
    v9 = v2[35];
    *(_QWORD *)(v9 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v10 = *(void (**)(void))(v9 + 168);
    if (v10)
      v10();
    v11 = v2[36];
    *(_QWORD *)(v11 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v12 = *(void (**)(void))(v11 + 168);
    if (v12)
      v12();
    v13 = v2[37];
    *(_QWORD *)(v13 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v14 = *(void (**)(void))(v13 + 168);
    if (v14)
      v14();
    v15 = v2[38];
    *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v16 = *(void (**)(void))(v15 + 168);
    if (v16)
      v16();
    v17 = v2[39];
    *(_QWORD *)(v17 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v18 = *(void (**)(void))(v17 + 168);
    if (v18)
      v18();
    v19 = v2[40];
    *(_QWORD *)(v19 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v20 = *(void (**)(void))(v19 + 168);
    if (v20)
      v20();
  }
  return reserved_glbBuf_bytes;
}

uint64_t tacotron_stream_update_param(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t result;
  int v8;
  int v9;

  if (*(_DWORD *)(a1 + 8) != a4)
    return 0;
  if (a3 != 40)
    return 7;
  v4 = *(_QWORD *)(a1 + 120);
  v5 = *(_DWORD *)(a2 + 20);
  if (v5 == 1)
  {
    v6 = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(v4 + 328) = v6 == 0;
    *(_DWORD *)(v4 + 332) = 1;
    if (!v6)
    {
      result = 0;
      *(_DWORD *)(v4 + 360) = *(_DWORD *)(a2 + 28) / *(_DWORD *)(v4 + 60) + *(_DWORD *)(v4 + 356);
      v8 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)v4 = v8;
      *(_DWORD *)(v4 + 352) = v8;
      return result;
    }
  }
  else
  {
    *(_DWORD *)(v4 + 328) = 0;
    *(_DWORD *)(v4 + 332) = v5;
  }
  *(_DWORD *)(v4 + 360) = *(_DWORD *)(a2 + 28) / *(_DWORD *)(v4 + 60);
  v9 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)v4 = v9;
  *(_DWORD *)(v4 + 352) = v9;
  if (v5)
  {
    if (*(_DWORD *)(a2 + 24) != 1)
      return 0;
  }
  result = 0;
  *(_QWORD *)(v4 + 344) = *(_QWORD *)a2;
  *(_QWORD *)(v4 + 368) = *(_QWORD *)(a2 + 32);
  return result;
}

uint64_t tacotron_stream_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t tacotron_stream_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  int v4;
  uint64_t result;
  int v6;
  unsigned int v7;

  v3 = *(_QWORD *)(a1 + 120);
  v7 = 0;
  v4 = 4 * get_padded_len(*(unsigned int *)(v3 + 68), 8u) * *(_DWORD *)(v3 + 224);
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 296) + 40), &v7);
  if (!(_DWORD)result)
  {
    v6 = get_padded_bytes(v7, 8u) + v4;
    v4 = v6 + get_padded_bytes(4 * *(_DWORD *)(v3 + 212) * *(_DWORD *)(v3 + 208), 8u);
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 304) + 40), &v7);
    if (!(_DWORD)result)
    {
      v4 += get_padded_bytes(v7, 8u);
      result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 312) + 40), &v7);
      if (!(_DWORD)result)
      {
        v4 += get_padded_bytes(v7, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 296) + 216))();
        if (!(_DWORD)result)
          v4 += 4 * v7;
      }
    }
  }
  *a2 = v4;
  return result;
}

uint64_t create_multiband_lpcnet_layer(uint64_t *a1, int *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  __int128 v47;
  __int128 v48;
  int v49;
  int v50;
  int v51;
  uint64_t __b;
  int v53;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11)
  {
    v12 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 416);
    v16 = v12;
    if (v12)
    {
      cstdlib_memcpy(v12, a2, 0xF4uLL);
      v49 = 0;
      v47 = 0u;
      v48 = 0u;
      if (a2)
      {
        v53 = 0;
        __b = 0;
        cstdlib_memset(&__b, 0, 0xCuLL);
        v20 = a2[25];
        v21 = a2[26];
        LODWORD(__b) = 5;
        HIDWORD(__b) = v20;
        v53 = 0;
        v50 = v21;
        v51 = 1;
        v22 = create_fc_layer(a1, &__b, &v50, 0, a3, (uint64_t *)v16 + 33);
        if ((_DWORD)v22)
        {
          v26 = v22;
          v27 = *a1;
          v28 = "create feature_dense1 failed!";
        }
        else
        {
          v35 = a2[28];
          HIDWORD(__b) = a2[27];
          v50 = v35;
          v51 = 1;
          v36 = create_fc_layer(a1, &__b, &v50, 0, a3, (uint64_t *)v16 + 34);
          if ((_DWORD)v36)
          {
            v26 = v36;
            v27 = *a1;
            v28 = "create feature_dense2 failed!";
          }
          else
          {
            v37 = a2[30];
            HIDWORD(__b) = a2[29];
            v50 = v37;
            v51 = 1;
            v38 = create_fc_layer(a1, &__b, &v50, 0, a3, (uint64_t *)v16 + 35);
            if ((_DWORD)v38)
            {
              v26 = v38;
              v27 = *a1;
              v28 = "create gru_a_dense failed!";
            }
            else
            {
              HIDWORD(__b) = 2 * a2[44];
              v50 = a2[46];
              v51 = 1;
              v39 = create_fc_layer(a1, &__b, &v50, 0, a3, (uint64_t *)v16 + 36);
              if ((_DWORD)v39)
              {
                v26 = v39;
                v27 = *a1;
                v28 = "create dual_fc_a failed!";
              }
              else
              {
                v40 = create_fc_layer(a1, &__b, &v50, 0, a3, (uint64_t *)v16 + 37);
                if ((_DWORD)v40)
                {
                  v26 = v40;
                  v27 = *a1;
                  v28 = "create dual_fc_b failed!";
                }
                else
                {
                  v41 = create_fc_layer(a1, &__b, &v50, 0, a3, (uint64_t *)v16 + 38);
                  if ((_DWORD)v41)
                  {
                    v26 = v41;
                    v27 = *a1;
                    v28 = "create dual_fc_c failed!";
                  }
                  else
                  {
                    if (a2[48] == 1)
                    {
                      HIDWORD(__b) = a2[44];
                      v50 = a2[47];
                      v51 = 1;
                    }
                    v42 = create_fc_layer(a1, &__b, &v50, 0, a3, (uint64_t *)v16 + 39);
                    if ((_DWORD)v42)
                    {
                      v26 = v42;
                      v27 = *a1;
                      v28 = "create dual_fc_d failed!";
                    }
                    else
                    {
                      v43 = config_conv1d_layer(a2[20], a2[19], 1, 1, 1, 1, a2[21], &v47);
                      if ((_DWORD)v43)
                      {
                        v26 = v43;
                        v27 = *a1;
                        v28 = "create conv1d_proj sub-conv1d_norm1 cfg failed!";
                      }
                      else
                      {
                        v44 = create_conv1d_layer(a1, &v47, 0, a3, (uint64_t ***)v16 + 31);
                        if ((_DWORD)v44)
                        {
                          v26 = v44;
                          v27 = *a1;
                          v28 = "create feature_conv1 layer failed!";
                        }
                        else
                        {
                          v45 = a2[23];
                          v49 = a2[24];
                          LODWORD(v47) = a2[22];
                          LODWORD(v48) = v45;
                          v26 = create_conv1d_layer(a1, &v47, 0, a3, (uint64_t ***)v16 + 32);
                          if (!(_DWORD)v26)
                          {
                            *(_QWORD *)v11 = a1;
                            *(_QWORD *)(v11 + 8) = 67;
                            *(_QWORD *)(v11 + 120) = v16;
                            *(_QWORD *)(v11 + 128) = forward_multiband_lpcnet_layer;
                            *(_QWORD *)(v11 + 136) = free_multiband_lpcnet;
                            *(_QWORD *)(v11 + 144) = multiband_lpcnet_update_shape;
                            *(_DWORD *)(v11 + 16) = 0;
                            *(_QWORD *)(v11 + 152) = multiband_lpcnet_wanted_wb_len;
                            *(_QWORD *)(v11 + 160) = multiband_lpcnet_request_glbBuf;
                            *(_QWORD *)(v11 + 184) = multiband_lpcnet_dispatch_weights;
                            *(_QWORD *)(v11 + 168) = multiband_lpcnet_assign_glbBuf;
                            *(_QWORD *)(v11 + 224) = multiband_lpcnet_update_param;
                            goto LABEL_32;
                          }
                          v27 = *a1;
                          v28 = "create feature_conv2 layer failed!";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v23, v24, v25, v47);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", v17, v18, v19, v47);
        v26 = 7;
      }
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"LPCNet init failed!", v32, v33, v34, v47);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v47);
      v26 = 10;
    }
    *(_QWORD *)(v11 + 120) = v16;
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"multiband_lpcnet init param failed!", v29, v30, v31, v47);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v47);
    v26 = 10;
  }
LABEL_32:
  *a4 = v11;
  return v26;
}

uint64_t forward_multiband_lpcnet_layer(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5)
{
  uint64_t *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int step;
  int padded_len;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  int v42;
  unint64_t v43;
  int v44;
  char v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t weights_via_offset;
  int v51;
  int padded_bytes;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  const char *v62;
  uint64_t *v63;
  int v64;
  BOOL v65;
  int v67;
  int v68;
  uint64_t v69;
  const void *v70;
  const void *v71;
  const void *v72;
  const void *v73;
  const void *v74;
  const void *v75;
  uint64_t *v76;
  _DWORD *v77;
  uint64_t v78;
  float *v79;
  uint64_t v80;
  uint64_t v81;
  float *v82;
  float *v83;
  uint64_t v84;
  float v85;
  float v86;
  float *v87;
  uint64_t v88;
  float v89;
  float *v90;
  _DWORD *v91;
  uint64_t v92;
  unsigned int v93;
  uint64_t v94;
  uint64_t v95;
  float32x4_t *v96;
  float32x2_t *v97;
  float32x2_t *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  float32x2_t *v103;
  float32x2_t *v104;
  float32_t v105;
  int8x16_t *v106;
  uint64_t v107;
  float *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  float v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  float32x2_t *v119;
  float32x2_t *v120;
  float32_t v121;
  float v122;
  uint64_t v123;
  float *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  _DWORD *v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  float v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  float32x2_t *v136;
  float32x2_t *v137;
  float32_t v138;
  uint64_t v139;
  float *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  float v146;
  uint64_t v147;
  uint64_t v148;
  float32x2_t *v149;
  float32x2_t *v150;
  float32_t v151;
  uint64_t v152;
  float *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t *v156;
  uint64_t v157;
  uint64_t v158;
  unsigned int v159;
  uint64_t v160;
  int v161;
  BOOL v162;
  float (*v163)(float);
  uint64_t (*v164)(float);
  unsigned int v165;
  float v166;
  BOOL v167;
  int v168;
  float *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unsigned int v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  int v181;
  uint64_t v182;
  uint64_t (*v183)(_QWORD, uint64_t, float *, uint64_t, _QWORD);
  uint64_t v184;
  int v185;
  uint64_t v186;
  uint64_t v187;
  int v188;
  uint64_t v189;
  unsigned int v190;
  uint64_t v191;
  int v192;
  unint64_t v193;
  int v194;
  _BOOL4 v195;
  unint64_t v196;
  int v197;
  float v198;
  unsigned int v199;
  unsigned int v200;
  unsigned int v201;
  unsigned int v202;
  unsigned int v203;
  uint64_t v204;
  uint64_t v205;
  unsigned int v206;
  unsigned int v207;
  float v208;
  float *v209;
  float *v210;
  uint64_t v211;
  float v212;
  float v213;
  float v214;
  unsigned int v215;
  float v216;
  float *v217;
  uint64_t v218;
  float v219;
  unsigned int v220;
  float v221;
  float *v222;
  float v223;
  uint64_t i;
  int v225;
  int v226;
  int v227;
  int v228;
  float *v229;
  unsigned int v230;
  uint64_t v231;
  float *v232;
  int v233;
  float *v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  unsigned int v244;
  uint64_t v245;
  int v246;
  unsigned int v247;
  uint64_t v248;
  unsigned int v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  unsigned int v267;
  unsigned int v268;
  uint64_t v269;
  unsigned int v270;
  uint64_t v271;
  int v272;
  float v273;
  _BOOL4 v274;
  unsigned int v275;
  unsigned int v276;
  float v277;
  float v278;
  float v279;
  float v280;
  float v281;
  float v282;
  float v283;
  float v284;
  float v285;
  float v286;
  float v287;
  float v288;
  uint64_t v289;
  unint64_t v290;
  unint64_t v291;
  int v292;
  uint64_t v293;
  uint64_t v294;
  int v295;
  int v296;
  int v297;
  float v298;
  uint64_t j;
  float v300;
  unsigned int v301;
  unsigned int v302;
  int v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  int v308;
  unsigned int v309;
  uint64_t *v310;
  int v311;
  _DWORD *__dst;
  uint64_t v313;
  float (*v314)(float);
  int v315;
  unsigned int v316;
  size_t v317;
  unsigned int v318;
  unsigned int v319;
  float *v320;
  _DWORD *v321;
  float *v322;
  uint64_t __len;
  float *__lena;
  int8x16_t *__src;
  float *__srca;
  int v327;
  char *v328;
  unsigned int v329;
  float *v330;
  unsigned int v331;
  unsigned int **v332;
  unsigned int v333;
  float *v334;
  unsigned int v335;
  float *v336;
  unsigned int v337;
  uint64_t v338;
  int v339;
  float *v340;
  char *v341;
  uint64_t v342;
  uint64_t (*v343)(float);
  unsigned int v344;
  uint64_t v345;
  uint64_t v346;
  _BOOL4 v347;
  int *v348;
  uint64_t v349;
  uint64_t *v350;
  int v351;
  uint64_t *v352;
  uint64_t v353;
  uint64_t *v354;
  unint64_t v355;
  __int128 v356;
  uint64_t v357;
  int32x4_t v358;
  int v359;
  int v360;
  int v361;
  int v362;
  _DWORD v363[4];
  uint64_t v364;

  v364 = *MEMORY[0x24BDAC8D0];
  v9 = *(uint64_t **)a2;
  v10 = *(_QWORD *)(a2 + 120);
  v354 = 0;
  v11 = *(_DWORD *)(a2 + 24);
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9[1] + 16))(v9[2], 1, 352);
  if (!v15)
  {
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v304);
    weights_via_offset = 10;
    goto LABEL_33;
  }
  if (!*(_DWORD *)(v10 + 320))
    goto LABEL_9;
  v16 = *(_DWORD *)(v10 + 332);
  if ((v16 - 1) < 2)
    goto LABEL_6;
  if (v16)
  {
    if (v16 != 5)
    {
      weights_via_offset = 7;
      goto LABEL_33;
    }
LABEL_6:
    if (v11 >= 2)
      v11 -= 2;
    else
      v11 = 0;
  }
LABEL_9:
  v346 = a3;
  v348 = a4;
  v344 = v11;
  v345 = a5;
  v352 = v9;
  v353 = v10;
  v349 = a2;
  v350 = *(uint64_t **)a2;
  v17 = *(_QWORD *)(a2 + 120);
  v18 = *(_QWORD *)(a2 + 240);
  v19 = *(_DWORD *)(v17 + 36);
  v20 = *(_QWORD *)(a2 + 72);
  LODWORD(v355) = 0;
  v21 = *(_DWORD *)(v17 + 204);
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  *(_QWORD *)(v15 + 16) = v18;
  padded_len = get_padded_len(*(unsigned int *)(v17 + 136), 8u);
  *(_QWORD *)(v15 + 24) = v18 + (4 * padded_len);
  v24 = get_padded_len(*(unsigned int *)(v17 + 152), 8u) + padded_len;
  *(_QWORD *)(v15 + 32) = v18 + (4 * v24);
  v25 = get_padded_len((3 * *(_DWORD *)(v17 + 172)), 8u) + v24;
  *(_QWORD *)(v15 + 40) = v18 + (4 * v25);
  v26 = get_padded_len((3 * *(_DWORD *)(v17 + 172)), 8u) + v25;
  *(_QWORD *)(v15 + 48) = v18 + (4 * v26);
  v27 = get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) + v26;
  *(_QWORD *)(v15 + 56) = v18 + (4 * v27);
  v28 = get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) + v27;
  *(_QWORD *)(v15 + 64) = v18 + (4 * v28);
  v29 = get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) + v28;
  *(_QWORD *)(v15 + 72) = v18 + (4 * v29);
  v30 = 12 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) + 4 * v29;
  *(_QWORD *)(v15 + 80) = v18 + v30;
  v31 = get_padded_len((3 * *(_DWORD *)(v17 + 152)), 8u);
  *(_QWORD *)(v15 + 88) = v18 + (v30 + 4 * v31);
  v32 = get_padded_len((2 * *(_DWORD *)(v17 + 176)), 8u) + v31;
  *(_QWORD *)(v15 + 96) = v18 + (v30 + 4 * v32);
  v33 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v32;
  *(_QWORD *)(v15 + 104) = v18 + (v30 + 4 * v33);
  v34 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v33;
  *(_QWORD *)(v15 + 112) = v18 + (v30 + 4 * v34);
  v35 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v34;
  *(_QWORD *)(v15 + 120) = v18 + (v30 + 4 * v35);
  v36 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v35;
  *(_QWORD *)(v15 + 168) = v18 + (v30 + 4 * v36);
  v37 = get_padded_len((*(_DWORD *)(v17 + 44) * step * *(_DWORD *)(v17 + 56)), 8u) + v36;
  *(_QWORD *)(v15 + 152) = v18 + (v30 + 4 * v37);
  v38 = get_padded_len((*(_DWORD *)(v17 + 108) * step), 8u) + v37;
  v39 = v18 + (v30 + 4 * v38);
  *(_QWORD *)(v15 + 160) = v39;
  *(_QWORD *)(v15 + 128) = v39;
  v40 = get_padded_len((*(_DWORD *)(v17 + 80) * step), 8u) + v38;
  *(_QWORD *)(v15 + 136) = v18 + (v30 + 4 * v40);
  *(_QWORD *)(v15 + 144) = v18
                         + v30
                         + 4 * (get_padded_len((*(_DWORD *)(v17 + 92) * step), 8u) + v40);
  get_padded_len((*(_DWORD *)(v17 + 100) * step), 8u);
  v41 = *(_DWORD *)(v17 + 116);
  if (v41 <= *(_DWORD *)(v17 + 92) + *(_DWORD *)(v17 + 80) + *(_DWORD *)(v17 + 100))
    v41 = *(_DWORD *)(v17 + 92) + *(_DWORD *)(v17 + 80) + *(_DWORD *)(v17 + 100);
  if (v41 <= 0x14A)
    v41 = 330;
  *(_QWORD *)(v15 + 176) = v18 + v30 + 4 * (get_padded_len(v41 * step, 8u) + v38);
  get_padded_bytes((*(_DWORD *)(v17 + 24) & 0xFFFFFFF8)+ 8 * *(_DWORD *)(v17 + 44)+ (*(_DWORD *)(v17 + 24) & 0xFFFFFFFC)+ 4 * (*(_DWORD *)(v17 + 28) + v19)+ 2 * (*(_DWORD *)(v17 + 24) & 0xFFFFFFFC)+ 20, 8u);
  v42 = v355;
  v43 = (unint64_t)v355 >> 2;
  *(_QWORD *)(v15 + 184) = v20 + 4 * v43;
  v44 = *(_DWORD *)(v17 + 124) * get_padded_len(*(unsigned int *)(v17 + 116), 8u);
  if (v21 == 1)
    v45 = 1;
  else
    v45 = 2;
  *(_QWORD *)(v15 + 192) = v20 + 4 * (((v44 << v45) + (_DWORD)v43) & 0x3FFFFFFF);
  v46 = v44 + *(_DWORD *)(v17 + 128) * get_padded_len(*(unsigned int *)(v17 + 116), 8u);
  *(_QWORD *)(v15 + 200) = v20 + 4 * (((v46 << v45) + (_DWORD)v43) & 0x3FFFFFFF);
  LODWORD(v355) = v42
                + 4
                * ((v46 + *(_DWORD *)(v17 + 132) * get_padded_len(*(unsigned int *)(v17 + 116), 8u)) << v45);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 248), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 256), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 264), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 272), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 280), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 208) = v20 + (v355 & 0xFFFFFFFC);
  v51 = *(_DWORD *)(v17 + 140);
  LODWORD(v355) = v355 + 4 * (v51 + (get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) >> 4));
  padded_bytes = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 216) = v20 + (padded_bytes & 0xFFFFFFFC);
  LODWORD(v355) = padded_bytes + 12 * *(_DWORD *)(v17 + 136);
  v53 = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 224) = v20 + (v53 & 0xFFFFFFFC);
  LODWORD(v355) = v53 + (*(_DWORD *)(v17 + 140) << 6);
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 232) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u);
  v54 = get_padded_bytes(v355, 8u);
  LODWORD(v355) = v54;
  v55 = *(_DWORD *)(v17 + 160);
  *(_QWORD *)(v15 + 240) = v20 + (v54 & 0xFFFFFFFC);
  if (v55 == 1)
  {
    LODWORD(v355) = v54 + (*(_DWORD *)(v17 + 164) << 6);
    v56 = get_padded_bytes(v355, 8u);
    *(_QWORD *)(v15 + 272) = v20 + (v56 & 0xFFFFFFFC);
    LODWORD(v355) = v56 + 4 * (*(_DWORD *)(v17 + 164) + ((3 * *(_DWORD *)(v17 + 152) + 15) >> 4));
    v57 = get_padded_bytes(v355, 8u);
    *(_QWORD *)(v15 + 288) = v20 + (v57 & 0xFFFFFFFC);
    LODWORD(v355) = v57 + (*(_DWORD *)(v17 + 168) << 6);
    v58 = get_padded_bytes(v355, 8u);
    *(_QWORD *)(v15 + 280) = v20 + (v58 & 0xFFFFFFFC);
    v59 = v58 + 4 * (*(_DWORD *)(v17 + 168) + ((3 * *(_DWORD *)(v17 + 152) + 15) >> 4));
  }
  else
  {
    v60 = *(_DWORD *)(v17 + 152);
    v59 = v355 + 12 * v60 * get_padded_len((*(_DWORD *)(v17 + 136) + *(_DWORD *)(v17 + 108)), 8u);
  }
  LODWORD(v355) = v59;
  LODWORD(v355) = get_padded_bytes(v59, 8u);
  *(_QWORD *)(v15 + 248) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len((3 * *(_DWORD *)(v17 + 152)), 8u);
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 256) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 12 * get_padded_len(*(unsigned int *)(v17 + 152), 8u) * *(_DWORD *)(v17 + 152);
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 264) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len((3 * *(_DWORD *)(v17 + 152)), 8u);
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 288), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 296) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 296), v20, &v355);
  if ((_DWORD)weights_via_offset)
    goto LABEL_30;
  LODWORD(v355) = get_padded_bytes(v355, 8u);
  *(_QWORD *)(v15 + 304) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 304), v20, &v355);
  if ((_DWORD)weights_via_offset
    || (LODWORD(v355) = get_padded_bytes(v355, 8u),
        *(_QWORD *)(v15 + 312) = v20 + (v355 & 0xFFFFFFFC),
        LODWORD(v355) = v355 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180),
        weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v17 + 312), v20, &v355),
        (_DWORD)weights_via_offset))
  {
LABEL_30:
    v61 = *v350;
    v62 = "multiband_lpcnet pack buf manager failed!";
LABEL_31:
    log_OutText(v61, (uint64_t)"FastInfer", 0, 0, (uint64_t)v62, v47, v48, v49, v304);
    goto LABEL_32;
  }
  v67 = get_padded_bytes(v355, 8u);
  LODWORD(v355) = v67;
  if (*(_DWORD *)(v17 + 192))
  {
    *(_QWORD *)(v15 + 320) = 0;
  }
  else
  {
    *(_QWORD *)(v15 + 320) = v20 + (v67 & 0xFFFFFFFC);
    v67 = v355 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180);
    LODWORD(v355) = v67;
  }
  *(_QWORD *)(v15 + 328) = v20 + (v67 & 0xFFFFFFFC);
  v68 = get_padded_len(4096, 8u);
  LODWORD(v355) = v355 + 4 * v68;
  *(_QWORD *)(v15 + 336) = v20 + (v355 & 0xFFFFFFFC);
  LODWORD(v355) = v355 + 4 * get_padded_len(*(unsigned int *)(v17 + 60), 8u) * *(_DWORD *)(v17 + 56);
  *(_QWORD *)(v15 + 344) = v20 + (v355 & 0xFFFFFFFC);
  get_padded_len(*(unsigned int *)(v17 + 36), 8u);
  *(_QWORD *)v15 = v346;
  *(_QWORD *)(v15 + 8) = v348;
  v69 = *(_QWORD *)(v349 + 120);
  if (*(_DWORD *)(v353 + 320))
  {
    v70 = *(const void **)(v69 + 336);
    if (v70)
      cstdlib_memcpy(*(void **)(v15 + 96), v70, 4 * *(unsigned int *)(v69 + 44));
    v71 = *(const void **)(v69 + 344);
    if (v71)
      cstdlib_memcpy(*(void **)(v15 + 104), v71, 4 * *(unsigned int *)(v69 + 44));
    v72 = *(const void **)(v69 + 352);
    if (v72)
      cstdlib_memcpy(*(void **)(v15 + 112), v72, 4 * *(unsigned int *)(v69 + 44));
    v73 = *(const void **)(v69 + 360);
    if (v73)
      cstdlib_memcpy(*(void **)(v15 + 120), v73, 4 * *(unsigned int *)(v69 + 44));
    v74 = *(const void **)(v69 + 368);
    if (v74)
      cstdlib_memcpy(*(void **)(v15 + 16), v74, 4 * *(unsigned int *)(v69 + 136));
    v75 = *(const void **)(v69 + 376);
    if (v75)
      cstdlib_memcpy(*(void **)(v15 + 24), v75, 4 * *(unsigned int *)(v69 + 152));
  }
  else
  {
    cstdlib_memset(*(void **)(v15 + 96), 0, 4 * *(unsigned int *)(v69 + 44));
    cstdlib_memset(*(void **)(v15 + 104), 0, 4 * *(unsigned int *)(v69 + 44));
    cstdlib_memset(*(void **)(v15 + 112), 0, 4 * *(unsigned int *)(v69 + 44));
    cstdlib_memset(*(void **)(v15 + 120), 0, 4 * *(unsigned int *)(v69 + 44));
    cstdlib_memset(*(void **)(v15 + 16), 0, 4 * *(unsigned int *)(v69 + 136));
    cstdlib_memset(*(void **)(v15 + 24), 0, 4 * *(unsigned int *)(v69 + 152));
  }
  v76 = *(uint64_t **)v349;
  v77 = *(_DWORD **)(v349 + 120);
  v311 = *(_DWORD *)(v349 + 24);
  v363[0] = 0;
  __dst = v77;
  weights_via_offset = opus_fft_alloc_twiddles(v76, v77[6] / v77[14], (uint64_t *)(*(_QWORD *)(v15 + 176) + 4 * v77[9]));
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  v310 = v76;
  v78 = v349;
  if (v311)
  {
    v351 = 0;
    do
    {
      v327 = __dst[11];
      v315 = __dst[14];
      v341 = *(char **)(v15 + 344);
      v79 = *(float **)(v15 + 176);
      v313 = *(_QWORD *)(v15 + 168);
      v80 = *(_QWORD *)(v78 + 120);
      v81 = *(unsigned int *)(v80 + 36);
      if ((_DWORD)v81)
      {
        v82 = (float *)(*(_QWORD *)v15 + 4 * (__dst[18] * v351));
        v83 = *(float **)(v15 + 176);
        v84 = *(unsigned int *)(v80 + 36);
        do
        {
          v85 = *v82++;
          v86 = v85;
          if (v85 > 1.0)
            v86 = 1.0;
          if (v86 < 0.0)
            v86 = 0.0;
          *v83++ = (float)(v86 * 11.513) + -9.2103;
          --v84;
        }
        while (v84);
      }
      fast_exp(v79, v81, v79);
      if ((_DWORD)v81)
      {
        v87 = v79;
        v88 = v81;
        v89 = 32768.0 / (float)*(unsigned int *)(v80 + 24);
        do
        {
          *v87 = v89 * *v87;
          ++v87;
          --v88;
        }
        while (v88);
      }
      else
      {
        v81 = 0;
      }
      v338 = v81;
      v90 = &v79[v81];
      v91 = *(_DWORD **)(v78 + 120);
      v92 = v91[7];
      v93 = v91[14];
      v94 = v91[6] / v93;
      v319 = ((int)v92 - 1) / v93;
      v95 = v319 + 1;
      v336 = v90 + 2;
      v317 = v91[11];
      v332 = (unsigned int **)v90;
      v334 = &v90[v317 + 3];
      v96 = (float32x4_t *)&v334[v317];
      v330 = &v96->f32[v92];
      v97 = (float32x2_t *)&v330[v94];
      v355 = 0;
      v98 = &v97[v95];
      v356 = xmmword_214FAEBE0;
      v357 = 0;
      cstdlib_memset(v96, 0, 4 * v92);
      v321 = v91;
      v340 = v79;
      gemm(*(uint64_t **)v349, 1, v92, v91[9], v79, v341, v96, &v355, v304);
      __len = 8 * v95;
      cstdlib_memset(v97, 0, 8 * v95);
      if (v319 != -1)
      {
        v99 = 0;
        do
        {
          v97[v99].f32[0] = v96->f32[v99] * v96->f32[v99];
          ++v99;
        }
        while (v95 != v99);
        v100 = 0;
        v101 = v319 + 1;
        do
        {
          v98[v100] = v97[v100];
          ++v100;
          --v101;
        }
        while (v101);
      }
      v102 = v319 + 1;
      if (v95 < v94)
      {
        do
        {
          v103 = &v98[(v94 - v102)];
          v104 = &v98[v102];
          v105 = -v103->f32[1];
          v104->i32[0] = v103->i32[0];
          v104->f32[1] = v105;
          ++v102;
        }
        while (v102 != v94);
      }
      v106 = (int8x16_t *)&v98[v94];
      opus_fft_c(*v332, &v97[v95], v106);
      *v330 = *(float *)v106->i32;
      v342 = 2 * v317;
      if (v94 >= 2)
      {
        v107 = v94 - 1;
        v108 = &v79[v92 + 4 + v338 + v342];
        v109 = 1;
        do
        {
          *v108++ = *(float *)&v106->i32[2 * (v94 - v109++)];
          --v107;
        }
        while (v107);
      }
      __src = (int8x16_t *)&v98[v94];
      v110 = (v317 + 1);
      if ((_DWORD)v317 != -1)
      {
        v111 = (uint64_t)&v340[v338 + 3];
        v112 = (v317 + 1);
        do
        {
          *(_DWORD *)(v111 - 4) = *(_DWORD *)(v111 + v342 * 4 + 4 * v92);
          v111 += 4;
          --v112;
        }
        while (v112);
      }
      v328 = (char *)(v313 + 4 * (v327 * v351 * v315));
      celt_lpc(v328, v334, v336, v317);
      cstdlib_memset(v97, 0, __len);
      if ((_DWORD)v95)
      {
        v113 = 0;
        v114 = v319 + 1;
        do
        {
          v115 = v96->f32[2 * v319 - v113];
          v97[v113++].f32[0] = v115 * v115;
          --v114;
        }
        while (v114);
        v116 = 0;
        v117 = v319 + 1;
        do
        {
          v98[v116] = v97[v116];
          ++v116;
          --v117;
        }
        while (v117);
      }
      v118 = v319 + 1;
      if (v95 < v94)
      {
        do
        {
          v119 = &v98[(v94 - v118)];
          v120 = &v98[v118];
          v121 = -v119->f32[1];
          v120->i32[0] = v119->i32[0];
          v120->f32[1] = v121;
          ++v118;
        }
        while (v118 != v94);
      }
      opus_fft_c(*v332, &v97[v95], __src);
      v122 = (float)v94;
      *v330 = *(float *)__src->i32 * (float)v94;
      if (v94 >= 2)
      {
        v123 = v94 - 1;
        v124 = &v340[v92 + 4 + v338 + v342];
        v125 = 1;
        do
        {
          *v124++ = *(float *)&__src->i32[2 * (v94 - v125++)] * v122;
          --v123;
        }
        while (v123);
      }
      if ((_DWORD)v317 != -1)
      {
        v126 = (uint64_t)&v340[v338 + 3];
        v127 = (v317 + 1);
        do
        {
          *(_DWORD *)(v126 - 4) = *(_DWORD *)(v126 + v342 * 4 + 4 * v92);
          v126 += 4;
          --v127;
        }
        while (v127);
      }
      celt_lpc(&v328[4 * v317], v334, v336, v317);
      v128 = v321;
      if (v321[49] == 1)
      {
        cstdlib_memset(v97, 0, __len);
        v129 = v351;
        if ((_DWORD)v95)
        {
          v130 = 0;
          v131 = v319 + 1;
          do
          {
            v132 = v96->f32[2 * v319 + v130];
            v97[v130++].f32[0] = v132 * v132;
            --v131;
          }
          while (v131);
          v133 = 0;
          v134 = v319 + 1;
          do
          {
            v98[v133] = v97[v133];
            ++v133;
            --v134;
          }
          while (v134);
        }
        v135 = v319 + 1;
        if (v95 < v94)
        {
          do
          {
            v136 = &v98[(v94 - v135)];
            v137 = &v98[v135];
            v138 = -v136->f32[1];
            v137->i32[0] = v136->i32[0];
            v137->f32[1] = v138;
            ++v135;
          }
          while (v135 != v94);
        }
        opus_fft_c(*v332, &v97[v95], __src);
        *v330 = *(float *)__src->i32 * v122;
        if (v94 >= 2)
        {
          v139 = v94 - 1;
          v140 = &v340[v92 + 4 + v338 + v342];
          v141 = 1;
          do
          {
            *v140++ = *(float *)&__src->i32[2 * (v94 - v141++)] * v122;
            --v139;
          }
          while (v139);
        }
        if ((_DWORD)v317 != -1)
        {
          v142 = (uint64_t)&v340[v338 + 3];
          v143 = (v317 + 1);
          do
          {
            *(_DWORD *)(v142 - 4) = *(_DWORD *)(v142 + v342 * 4 + 4 * v92);
            v142 += 4;
            --v143;
          }
          while (v143);
        }
        celt_lpc(&v328[4 * (2 * v317)], v334, v336, v317);
        v128 = v321;
      }
      else
      {
        cstdlib_memset(&v328[4 * (2 * v317)], 0, v317);
        v129 = v351;
      }
      if (v128[50] == 1)
      {
        cstdlib_memset(v97, 0, __len);
        if ((_DWORD)v95)
        {
          v144 = 0;
          v145 = v319 + 1;
          do
          {
            v146 = v96->f32[4 * v319 - v144];
            v97[v144++].f32[0] = v146 * v146;
            --v145;
          }
          while (v145);
          v147 = 0;
          v148 = v319 + 1;
          do
          {
            v98[v147] = v97[v147];
            ++v147;
            --v148;
          }
          while (v148);
        }
        if (v95 < v94)
        {
          do
          {
            v149 = &v98[(v94 - v95)];
            v150 = &v98[v95];
            v151 = -v149->f32[1];
            v150->i32[0] = v149->i32[0];
            v150->f32[1] = v151;
            ++v95;
          }
          while (v95 != v94);
        }
        opus_fft_c(*v332, v98, __src);
        *v330 = *(float *)__src->i32 * v122;
        if (v94 >= 2)
        {
          v152 = v94 - 1;
          v153 = &v340[v92 + 4 + v338 + v342];
          v154 = 1;
          do
          {
            *v153++ = *(float *)&__src->i32[2 * (v94 - v154++)] * v122;
            --v152;
          }
          while (v152);
        }
        v78 = v349;
        if ((_DWORD)v317 != -1)
        {
          v155 = (uint64_t)&v340[v338 + 3];
          do
          {
            *(_DWORD *)(v155 - 4) = *(_DWORD *)(v155 + v342 * 4 + 4 * v92);
            v155 += 4;
            --v110;
          }
          while (v110);
        }
        celt_lpc(&v328[4 * (3 * v317)], v334, v336, v317);
      }
      else
      {
        cstdlib_memset(&v328[4 * (3 * v317)], 0, v317);
        v78 = v349;
      }
      v351 = v129 + 1;
    }
    while (v129 + 1 != v311);
  }
  v156 = (uint64_t *)(*(_QWORD *)(v15 + 176) + 4 * __dst[9]);
  v157 = *v156;
  if (*v156)
  {
    if (*(_QWORD *)(v157 + 48))
    {
      (*(void (**)(uint64_t))(v310[1] + 80))(v310[2]);
      *(_QWORD *)(v157 + 48) = 0;
    }
    if ((*(_DWORD *)(v157 + 8) & 0x80000000) != 0 && *(_QWORD *)(v157 + 56))
    {
      (*(void (**)(uint64_t))(v310[1] + 80))(v310[2]);
      *(_QWORD *)(v157 + 56) = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(v310[1] + 80))(v310[2], v157);
    *v156 = 0;
  }
  weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)__dst + 31) + 40), v363);
  v76 = v310;
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  cstdlib_memset(*(void **)(v15 + 128), 0, v363[0]);
  weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)__dst + 31) + 128))(0);
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)__dst + 32) + 40), v363);
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  cstdlib_memset(*(void **)(v15 + 136), 0, v363[0]);
  weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)__dst + 32) + 128))(0);
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  axpy((__dst[18] * v311), *(float **)v15, 1, *(float **)(v15 + 136), 1, 1.0);
  weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)__dst + 33) + 40), v363);
  if ((_DWORD)weights_via_offset)
    goto LABEL_164;
  cstdlib_memset(*(void **)(v15 + 144), 0, v363[0]);
  weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)__dst + 33) + 128))(0);
  if ((_DWORD)weights_via_offset
    || (weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)__dst + 34) + 40), v363),
        (_DWORD)weights_via_offset)
    || (cstdlib_memset(*(void **)(v15 + 152), 0, v363[0]),
        weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)__dst + 34) + 128))(0),
        (_DWORD)weights_via_offset)
    || (weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)__dst + 35) + 40), v363),
        (_DWORD)weights_via_offset)
    || (cstdlib_memset(*(void **)(v15 + 160), 0, v363[0]),
        weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)__dst + 35) + 128))(0),
        (_DWORD)weights_via_offset))
  {
LABEL_164:
    v61 = *v76;
    v62 = "multiband_lpcnet forward frame network failed!";
    goto LABEL_31;
  }
  v158 = *(_QWORD *)(v349 + 120);
  v159 = *(_DWORD *)(v349 + 24);
  v160 = *(_QWORD *)(v15 + 8);
  __lena = *(float **)(v15 + 104);
  __srca = *(float **)(v15 + 96);
  v320 = *(float **)(v15 + 120);
  v322 = *(float **)(v15 + 112);
  v161 = *(_DWORD *)(v158 + 124);
  v162 = v161 == 256;
  if (v161 == 256)
    v163 = ulaw2lin8;
  else
    v163 = ulaw2lin7;
  v314 = v163;
  v164 = lin2ulaw7;
  if (v162)
    v164 = lin2ulaw8;
  v343 = v164;
  v165 = *(_DWORD *)(v158 + 320);
  if (v165)
  {
    weights_via_offset = 7;
    v335 = *(_DWORD *)(v158 + 392);
    v337 = *(_DWORD *)(v158 + 396);
    v331 = *(_DWORD *)(v158 + 400);
    v333 = *(_DWORD *)(v158 + 404);
    v166 = *(float *)(v158 + 408);
    v9 = v352;
    v10 = v353;
    switch(*(_DWORD *)(v158 + 332))
    {
      case 0:
        v318 = 0;
        v165 = v159 - 2;
        if (v159 < 2)
          v165 = 0;
        goto LABEL_184;
      case 1:
        v165 = v159 - 4;
        if (v159 < 4)
          v165 = 0;
        v167 = v159 >= 2;
        v159 -= 2;
        if (!v167)
          v159 = 0;
        v318 = 2;
        goto LABEL_184;
      case 2:
      case 5:
        v167 = v159 >= 2;
        v159 -= 2;
        if (!v167)
          v159 = 0;
        v318 = 2;
        v165 = v159;
        goto LABEL_184;
      case 3:
      case 4:
        goto LABEL_33;
      default:
        goto LABEL_32;
    }
    goto LABEL_33;
  }
  v318 = 0;
  v166 = 0.0;
  v331 = *(_DWORD *)(v158 + 132) >> 1;
  v337 = v331;
  v333 = v331;
  v335 = v331;
LABEL_184:
  v309 = v318 + v159;
  if (v318 >= v318 + v159)
  {
LABEL_261:
    v301 = *(_DWORD *)(v353 + 12);
    if (v301 == 22050)
    {
      v302 = *(_DWORD *)(v353 + 16) * v344;
    }
    else
    {
      v9 = v352;
      weights_via_offset = src_generate(v352, 0xBu, v301 / 0x7D0, (uint64_t *)&v354);
      v10 = v353;
      if ((_DWORD)weights_via_offset)
        goto LABEL_33;
      if (*(_DWORD *)(v353 + 320) == 1 && *(_DWORD *)(v353 + 332))
        cstdlib_memcpy((void *)v354[4], *(const void **)(v353 + 384), 4 * *((unsigned int *)v354 + 10));
      v302 = src_filt(v354, v348, *(_DWORD *)(v353 + 16) * v344, *(_QWORD *)(v15 + 160));
      cstdlib_memcpy(v348, *(const void **)(v15 + 160), 4 * v302);
      if (*(_DWORD *)(v353 + 320) == 1)
      {
        v303 = *(_DWORD *)(v353 + 332);
        if (v303 != 2 && v303 != 5)
          cstdlib_memcpy(*(void **)(v353 + 384), (const void *)v354[4], 4 * *((unsigned int *)v354 + 10));
      }
    }
    weights_via_offset = 0;
    *(_DWORD *)(v349 + 44) = v302;
    *(_DWORD *)(v345 + 20) = 1;
    goto LABEL_32;
  }
  v168 = 0;
  v308 = v318 + v165 - 1;
  while (1)
  {
    v169 = (float *)(*(_QWORD *)(v15 + 152) + 4 * *(_DWORD *)(v158 + 108) * v318);
    cstdlib_memcpy(*(void **)(v15 + 80), *(const void **)(v15 + 248), 4 * (3 * *(_DWORD *)(v158 + 152)));
    if (*(_DWORD *)(v158 + 160) == 1)
      sparse_sgemv_accum16(*(_QWORD *)(v15 + 80), *(_QWORD *)(v15 + 288), (3 * *(_DWORD *)(v158 + 152)), *(_QWORD *)(v15 + 280), v169);
    else
      gemm_ex(*(uint64_t **)v349, 1, 3 * *(_DWORD *)(v158 + 152), *(_DWORD *)(v158 + 108), v169, *(unsigned int *)(v158 + 108), (char *)(*(_QWORD *)(v15 + 240) + 4 * *(unsigned int *)(v158 + 136)), *(unsigned int *)(v158 + 148), *(float32x4_t **)(v15 + 80), 3 * *(_DWORD *)(v158 + 152), 0);
    if (*(_DWORD *)(v158 + 204) == 1)
      break;
LABEL_195:
    v193 = *(unsigned int *)(v158 + 36);
    if ((_DWORD)v193)
    {
      v194 = *(_DWORD *)(v158 + 40);
      if (*(float *)(*(_QWORD *)v15 + 4 * v194 * v318) > 0.01)
      {
        v195 = 1;
LABEL_202:
        v347 = v195;
        goto LABEL_204;
      }
      v196 = 0;
      v197 = v194 * v318 + 1;
      while (v193 - 1 != v196)
      {
        v198 = *(float *)(*(_QWORD *)v15 + 4 * (v197 + v196++));
        if (v198 > 0.01)
        {
          v195 = v196 < v193;
          goto LABEL_202;
        }
      }
    }
    cstdlib_memset(*(void **)(v15 + 16), 0, 4 * *(unsigned int *)(v158 + 136));
    cstdlib_memset(*(void **)(v15 + 24), 0, 4 * *(unsigned int *)(v158 + 152));
    v347 = 0;
LABEL_204:
    v199 = *(_DWORD *)(v158 + 56);
    if (v199 <= *(_DWORD *)(v158 + 16))
    {
      v329 = 0;
      do
      {
        v339 = v168;
        v355 = 0;
        *(_QWORD *)&v356 = 0;
        if (*(_DWORD *)(v158 + 208) == 1)
          v316 = *(_DWORD *)(v158 + 152) / v199;
        else
          v316 = 0;
        v200 = *(_DWORD *)(v158 + 132) >> 1;
        v358 = vdupq_n_s32(v200);
        v201 = v200;
        v202 = v200;
        v203 = v200;
        if (v347)
        {
          v204 = *(unsigned int *)(v158 + 44);
          if ((_DWORD)v204)
          {
            v205 = *(_QWORD *)(v15 + 168);
            v206 = v318 * v199 * v204;
            v207 = v204 + v206;
            v208 = 0.0;
            v210 = __lena;
            v209 = __srca;
            v211 = *(unsigned int *)(v158 + 44);
            v212 = 0.0;
            do
            {
              v213 = *v209++;
              v212 = v212 - (float)(v213 * *(float *)(v205 + 4 * v206));
              v214 = *v210++;
              v208 = v208 - (float)(v214 * *(float *)(v205 + 4 * v207++));
              ++v206;
              --v211;
            }
            while (v211);
            v355 = __PAIR64__(LODWORD(v208), LODWORD(v212));
            if (*(_DWORD *)(v158 + 196) == 1)
            {
              v215 = v204 * (v318 * v199 + 2);
              v216 = 0.0;
              v217 = v322;
              v218 = v204;
              do
              {
                v219 = *v217++;
                v216 = v216 - (float)(v219 * *(float *)(v205 + 4 * v215++));
                --v218;
              }
              while (v218);
              *(float *)&v356 = v216;
            }
            if (*(_DWORD *)(v158 + 200) == 1)
            {
              v220 = v204 * (v318 * v199 + 3);
              v221 = 0.0;
              v222 = v320;
              do
              {
                v223 = *v222++;
                v221 = v221 - (float)(v223 * *(float *)(v205 + 4 * v220++));
                --v204;
              }
              while (v204);
              *((float *)&v356 + 1) = v221;
            }
          }
          else
          {
            LODWORD(v355) = 0;
          }
          for (i = 0; i != 16; i += 4)
            *(int *)((char *)&v359 + i) = v343(*(float *)((char *)&v355 + i));
          v225 = v343(*__srca);
          v226 = v343(*__lena);
          v227 = v343(*v322);
          v228 = v343(*v320);
          v229 = *(float **)(v15 + 32);
          v230 = *(_DWORD *)(v158 + 116);
          v231 = *(_QWORD *)(v15 + 184);
          v232 = (float *)(v231 + 4 * v230 * v225);
          v233 = *(_DWORD *)(v158 + 124);
          v234 = (float *)(v231 + 4 * (v233 + v226) * v230);
          if (*(_DWORD *)(v158 + 204) == 1)
          {
            accum4(v230, v232, v234, (float *)(*(_QWORD *)(v15 + 192) + 4 * v359 * v230), (float *)(*(_QWORD *)(v15 + 192) + 4 * (v360 + *(_DWORD *)(v158 + 128)) * v230), *(float **)(v15 + 48));
            accum4(*(_DWORD *)(v158 + 116), (float *)(*(_QWORD *)(v15 + 200) + 4 * *(_DWORD *)(v158 + 116) * v335), (float *)(*(_QWORD *)(v15 + 200) + 4 * (*(_DWORD *)(v158 + 132) + v337) * *(_DWORD *)(v158 + 116)), (float *)(*(_QWORD *)(v15 + 160) + 4 * *(_DWORD *)(v158 + 116) * v318), *(float **)(v15 + 48), v229);
            multiband_lpcnet_compute_sparse_gru_a(v349, v15);
            multiband_lpcnet_compute_gru_b(v349, v15);
            multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 288), v15, *(float **)(v15 + 296), *(_QWORD *)(v15 + 24), v235, v236, v237, v238, v304);
            v203 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (v339 & 0xFFF)));
            v358.i32[0] = v203;
            multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 296), v15, *(float **)(v15 + 304), *(_QWORD *)(v15 + 24) + 4 * ((2 * *(_DWORD *)(v158 + 152)) / *(_DWORD *)(v158 + 56)), v239, v240, v241, v242, v305);
            v202 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 1) & 0xFFF)));
            v358.i32[1] = v202;
            v243 = *(_QWORD *)(v15 + 72);
            v244 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
            v201 = sample_cdf(v243 + 4 * v244, *(_DWORD *)(v158 + 176), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 2) & 0xFFF)));
            v358.i32[2] = v201;
            v245 = *(_QWORD *)(v15 + 72);
            v246 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
            v200 = sample_cdf(v245 + 4 * (2 * v246), *(_DWORD *)(v158 + 176), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 3) & 0xFFF)));
          }
          else
          {
            accum4(v230, v232, v234, (float *)(v231 + 4 * (v227 + 2 * v233) * v230), (float *)(v231 + 4 * (3 * v233 + v228) * v230), *(float **)(v15 + 48));
            v247 = *(_DWORD *)(v158 + 116);
            v248 = *(_QWORD *)(v15 + 192);
            accum4(v247, (float *)(v248 + 4 * v359 * v247), (float *)(v248 + 4 * (v360 + *(_DWORD *)(v158 + 128)) * v247), (float *)(v248 + 4 * (v361 + 2 * *(_DWORD *)(v158 + 128)) * v247), (float *)(v248 + 4 * (v362 + 3 * *(_DWORD *)(v158 + 128)) * v247), *(float **)(v15 + 56));
            v249 = *(_DWORD *)(v158 + 116);
            v250 = *(_QWORD *)(v15 + 200);
            accum4(v249, (float *)(v250 + 4 * v249 * v335), (float *)(v250 + 4 * (*(_DWORD *)(v158 + 132) + v337) * v249), (float *)(v250 + 4 * (v331 + 2 * *(_DWORD *)(v158 + 132)) * v249), (float *)(v250 + 4 * (3 * *(_DWORD *)(v158 + 132) + v333) * v249), *(float **)(v15 + 64));
            accum4(*(_DWORD *)(v158 + 116), (float *)(*(_QWORD *)(v15 + 160) + 4 * *(_DWORD *)(v158 + 116) * v318), *(float **)(v15 + 48), *(float **)(v15 + 56), *(float **)(v15 + 64), v229);
            multiband_lpcnet_compute_sparse_gru_a(v349, v15);
            multiband_lpcnet_compute_gru_b(v349, v15);
            multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 288), v15, *(float **)(v15 + 296), *(_QWORD *)(v15 + 24), v251, v252, v253, v254, v304);
            v203 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (v339 & 0xFFF)));
            v358.i32[0] = v203;
            multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 296), v15, *(float **)(v15 + 304), *(_QWORD *)(v15 + 24) + 4 * v316, v255, v256, v257, v258, v306);
            v202 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 1) & 0xFFF)));
            v358.i32[1] = v202;
            multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 304), v15, *(float **)(v15 + 312), *(_QWORD *)(v15 + 24) + 8 * v316, v259, v260, v261, v262, v307);
            v201 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 2) & 0xFFF)));
            v358.i32[2] = v201;
            if (*(_DWORD *)(v158 + 192))
            {
              cstdlib_memset(*(void **)(v15 + 72), 0, 4 * *(unsigned int *)(v158 + 176));
              v186 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v158 + 312) + 128))(0);
              if ((_DWORD)v186)
                goto LABEL_264;
            }
            else
            {
              multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 312), v15, *(float **)(v15 + 320), *(_QWORD *)(v15 + 24) + 12 * v316, v263, v264, v265, v266, v304);
            }
            v200 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(_QWORD *)(v15 + 328) + 4 * (((_WORD)v339 + 3) & 0xFFF)));
          }
          v358.i32[3] = v200;
        }
        v267 = *(_DWORD *)(v158 + 124);
        v333 = v200;
        v268 = *(_DWORD *)(v158 + 176);
        v331 = v201;
        v337 = v202;
        v335 = v203;
        if (v267 != v268)
        {
          v269 = 0;
          v270 = v267 / v268;
          v271 = *(_QWORD *)(v15 + 328);
          do
          {
            v272 = v358.i32[v269] * v270;
            v358.i32[v269] = v272;
            v273 = *(float *)(v271 + 4 * (((_WORD)v339 + (_WORD)v269) & 0xFFF));
            v274 = v347;
            if (v273 >= 0.7)
              v274 = 0;
            if (v274)
            {
              v275 = v272 + (float)(v273 * (float)v270);
              v276 = *(_DWORD *)(v158 + 128);
              if (v275 >= v276)
                v275 = v276 - 1;
              v358.i32[v269] = v275;
            }
            ++v269;
          }
          while (v269 != 4);
          v337 = v358.u32[1];
          v335 = v358.i32[0];
          v333 = v358.u32[3];
          v331 = v358.u32[2];
        }
        v277 = *(float *)&v355;
        v278 = *(float *)(v158 + 212);
        v279 = v277 + (float)(v278 * v314((float)v335));
        *(float *)v363 = v279;
        v280 = *((float *)&v355 + 1);
        v281 = *(float *)(v158 + 216);
        v282 = v280 + (float)(v281 * v314((float)v337));
        *(float *)&v363[1] = v282;
        v283 = *(float *)&v356;
        v284 = *(float *)(v158 + 220);
        v285 = v283 + (float)(v284 * v314((float)v331));
        *(float *)&v363[2] = v285;
        v286 = *((float *)&v356 + 1);
        v287 = *(float *)(v158 + 224);
        v288 = v286 + (float)(v287 * v314((float)v333));
        *(float *)&v363[3] = v288;
        cstdlib_memmove(__srca + 1, __srca, 4 * (*(_DWORD *)(v158 + 44) - 1));
        cstdlib_memmove(__lena + 1, __lena, 4 * (*(_DWORD *)(v158 + 44) - 1));
        cstdlib_memmove(v322 + 1, v322, 4 * (*(_DWORD *)(v158 + 44) - 1));
        cstdlib_memmove(v320 + 1, v320, 4 * (*(_DWORD *)(v158 + 44) - 1));
        v289 = 0;
        v290 = 0;
        *__srca = v279;
        *__lena = v282;
        *v322 = v285;
        *v320 = v288;
        v291 = *(unsigned int *)(v158 + 60);
        do
        {
          v292 = get_padded_len(v291, 8u);
          v363[v290] = 0;
          v291 = *(unsigned int *)(v158 + 60);
          if (v290 < v291)
          {
            v293 = 0;
            v295 = v292 + v290;
            v296 = v292 + v290 + 2 * v292;
            v297 = v290 + 2 * v292;
            v298 = 0.0;
            do
            {
              v294 = *(_QWORD *)(v15 + 336);
              v298 = (float)((float)((float)(v298
                                           + (float)(*(float *)(v294 + v289 + 4 * v293)
                                                   * *(float *)(*(_QWORD *)(v15 + 96) + v293)))
                                   + (float)(*(float *)(v294 + 4 * (v295 + v293))
                                           * *(float *)(*(_QWORD *)(v15 + 104) + v293)))
                           + (float)(*(float *)(v294 + 4 * (v297 + v293))
                                   * *(float *)(*(_QWORD *)(v15 + 112) + v293)))
                   + (float)(*(float *)(v294 + 4 * (v296 + v293))
                           * *(float *)(*(_QWORD *)(v15 + 120) + v293));
              v293 += 4;
            }
            while (v290 + v293 < v291);
            *(float *)&v363[v290] = v298;
          }
          ++v290;
          v289 += 4;
        }
        while (v290 != 4);
        for (j = 0; j != 4; ++j)
        {
          v166 = *(float *)&v363[j] + (float)(*(float *)(v158 + 52) * v166);
          if (v166 >= -32767.0)
            v300 = v166;
          else
            v300 = -32767.0;
          if (v300 > 32767.0)
            v300 = 32767.0;
          *(float *)&v363[j] = v300;
          *(float *)(v160 + 4 * (v339 + j)) = v300 * 0.000030518;
        }
        v199 = *(_DWORD *)(v158 + 56);
        v168 = v339 + 4;
        ++v329;
      }
      while (v329 < *(_DWORD *)(v158 + 16) / v199);
      v168 = v339 + 4;
    }
    if (v318 == v308 && *(_DWORD *)(v158 + 320))
    {
      *(_DWORD *)(v158 + 392) = v335;
      *(_DWORD *)(v158 + 396) = v337;
      *(_DWORD *)(v158 + 400) = v331;
      *(_DWORD *)(v158 + 404) = v333;
      *(float *)(v158 + 408) = v166;
      cstdlib_memcpy(*(void **)(v158 + 336), __srca, 4 * *(unsigned int *)(v158 + 44));
      cstdlib_memcpy(*(void **)(v158 + 344), __lena, 4 * *(unsigned int *)(v158 + 44));
      cstdlib_memcpy(*(void **)(v158 + 352), v322, 4 * *(unsigned int *)(v158 + 44));
      cstdlib_memcpy(*(void **)(v158 + 360), v320, 4 * *(unsigned int *)(v158 + 44));
      cstdlib_memcpy(*(void **)(v158 + 368), *(const void **)(v15 + 16), 4 * *(unsigned int *)(v158 + 136));
      cstdlib_memcpy(*(void **)(v158 + 376), *(const void **)(v15 + 24), 4 * *(unsigned int *)(v158 + 152));
    }
    if (++v318 == v309)
      goto LABEL_261;
  }
  multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 304), v15, *(float **)(v15 + 312), (uint64_t)v169, v170, v171, v172, v173, v304);
  v174 = *(_QWORD *)(v15 + 72);
  v175 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
  cstdlib_memcpy((void *)(v174 + 4 * v175), *(const void **)(v15 + 72), 4 * *(unsigned int *)(v158 + 176));
  if (!*(_DWORD *)(v158 + 192))
  {
    multiband_lpcnet_compute_dual_fc(*(_QWORD *)(v158 + 312), v15, *(float **)(v15 + 320), (uint64_t)v169, v176, v177, v178, v179, v304);
    v187 = *(_QWORD *)(v15 + 72);
    v188 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
    cstdlib_memcpy((void *)(v187 + 4 * (2 * v188)), *(const void **)(v15 + 72), 4 * *(unsigned int *)(v158 + 176));
    goto LABEL_194;
  }
  v180 = *(_QWORD *)(v15 + 72);
  v181 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
  cstdlib_memset((void *)(v180 + 4 * (2 * v181)), 0, 4 * *(unsigned int *)(v158 + 176));
  v182 = *(_QWORD *)(v158 + 312);
  v183 = *(uint64_t (**)(_QWORD, uint64_t, float *, uint64_t, _QWORD))(v182 + 128);
  v184 = *(_QWORD *)(v15 + 72);
  v185 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
  v186 = v183(0, v182, v169, v184 + 4 * (2 * v185), 0);
  if (!(_DWORD)v186)
  {
LABEL_194:
    v189 = *(_QWORD *)(v15 + 72);
    v190 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
    prepare_cdf((float *)(v189 + 4 * v190), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48));
    v191 = *(_QWORD *)(v15 + 72);
    v192 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
    prepare_cdf((float *)(v191 + 4 * (2 * v192)), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48));
    goto LABEL_195;
  }
LABEL_264:
  weights_via_offset = v186;
LABEL_32:
  v9 = v352;
  v10 = v353;
LABEL_33:
  v63 = v354;
  if (v354)
  {
    if (*v354)
    {
      (*(void (**)(uint64_t, _QWORD))(v9[1] + 48))(v9[2], *v354);
      *v354 = 0;
      *v354 = 0;
      v63 = v354;
    }
    if (v63[4])
    {
      (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v63[4]);
      v354[4] = 0;
    }
    (*(void (**)(uint64_t))(v9[1] + 48))(v9[2]);
    v354 = 0;
  }
  if (v15)
    (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v15);
  if ((_DWORD)weights_via_offset
    || *(_DWORD *)(v10 + 320) == 1 && ((v64 = *(_DWORD *)(v10 + 332), v64 != 5) ? (v65 = v64 == 2) : (v65 = 1), v65))
  {
    if (*(_QWORD *)(v10 + 336))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 336) = 0;
    }
    if (*(_QWORD *)(v10 + 368))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 368) = 0;
    }
    if (*(_QWORD *)(v10 + 376))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 376) = 0;
    }
    if (*(_QWORD *)(v10 + 384))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 384) = 0;
    }
  }
  return weights_via_offset;
}

uint64_t multiband_lpcnet_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unsigned int v11;
  uint64_t result;
  int v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD v16[2];
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(a1 + 120);
  v16[0] = 0;
  v16[1] = 0;
  v17 = 0;
  v20 = 0;
  if (*a2 != 2)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently multiband_lpcnet layer only support 2D input", a6, a7, a8, v15);
    return 7;
  }
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  v11 = *(_DWORD *)(v9 + 72);
  v18 = a2[1];
  v19 = v11;
  fi_shape_set(2, &v18, 4, v16);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 248) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 256) + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 264) + 144))();
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 272) + 144))();
        if (!(_DWORD)result)
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 280) + 144))();
          if (!(_DWORD)result)
          {
            v18 = 1;
            v13 = *(_DWORD *)(v9 + 208);
            v14 = *(_DWORD *)(v9 + 152);
            if (*(_DWORD *)(v9 + 204) == 1)
            {
              if (v13 == 1)
                v14 = 2 * v14 / *(_DWORD *)(v9 + 56);
              v19 = v14;
              result = fi_shape_set(2, &v18, 4, v16);
              if (!(_DWORD)result)
              {
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 288) + 144))();
                if (!(_DWORD)result)
                {
                  result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 296) + 144))();
                  if (!(_DWORD)result)
                  {
                    v19 = *(_DWORD *)(*(_QWORD *)(v9 + 272) + 48);
                    result = fi_shape_set(2, &v18, 4, v16);
                    if (!(_DWORD)result)
                    {
LABEL_21:
                      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 304) + 144))();
                      if (!(_DWORD)result)
                      {
                        result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 312) + 144))();
                        if (!(_DWORD)result)
                        {
                          result = 0;
                          *(_DWORD *)(a1 + 40) = 1;
                          *(_DWORD *)(a1 + 44) = 330 * a2[1];
                          *(_DWORD *)(a1 + 56) = 4;
                        }
                      }
                    }
                  }
                }
              }
            }
            else
            {
              if (v13 == 1)
                v14 /= *(_DWORD *)(v9 + 56);
              v19 = v14;
              fi_shape_set(2, &v18, 4, v16);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 288) + 144))();
              if (!(_DWORD)result)
              {
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 296) + 144))();
                if (!(_DWORD)result)
                  goto LABEL_21;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

_QWORD *free_multiband_lpcnet(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[31]);
        fi_layer_free(v3[32]);
        fi_layer_free(v3[33]);
        fi_layer_free(v3[34]);
        fi_layer_free(v3[35]);
        fi_layer_free(v3[36]);
        fi_layer_free(v3[37]);
        fi_layer_free(v3[38]);
        fi_layer_free(v3[39]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t multiband_lpcnet_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v11;
  int padded_len;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t result;
  char v19;
  unsigned int padded_bytes;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v11 = *(_DWORD *)(v8 + 204);
    padded_len = get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    v13 = *(_DWORD *)(v8 + 124);
    v14 = get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    v15 = *(_DWORD *)(v8 + 128);
    v16 = get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    v17 = *(_DWORD *)(v8 + 132);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 248) + 152))();
    if (!(_DWORD)result)
    {
      v19 = v11 == 1 ? 1 : 2;
      padded_bytes = get_padded_bytes(4 * ((v13 * padded_len + v15 * v14 + v17 * v16) << v19), 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 256) + 152))();
      if (!(_DWORD)result)
      {
        v21 = get_padded_bytes(padded_bytes, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 264) + 152))();
        if (!(_DWORD)result)
        {
          v22 = get_padded_bytes(v21, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 272) + 152))();
          if (!(_DWORD)result)
          {
            v23 = get_padded_bytes(v22, 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 280) + 152))();
            if (!(_DWORD)result)
            {
              v24 = get_padded_bytes(v23, 8u);
              v25 = *(_DWORD *)(v8 + 140);
              v26 = get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u);
              v27 = get_padded_bytes(v24 + 4 * (v25 + (v26 >> 4)), 8u);
              v28 = get_padded_bytes(v27 + 12 * *(_DWORD *)(v8 + 136), 8u);
              v29 = get_padded_bytes(v28 + (*(_DWORD *)(v8 + 140) << 6), 8u);
              v30 = get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u);
              if (*(_DWORD *)(v8 + 160) == 1)
              {
                v31 = get_padded_bytes(v29 + 4 * v30 + (*(_DWORD *)(v8 + 164) << 6), 8u);
                v32 = get_padded_bytes(v31 + 4 * (*(_DWORD *)(v8 + 164) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4)), 8u);
                v29 = get_padded_bytes(v32 + (*(_DWORD *)(v8 + 168) << 6), 8u);
                v33 = *(_DWORD *)(v8 + 168) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4);
              }
              else
              {
                v34 = *(_DWORD *)(v8 + 152);
                v33 = 3 * v34 * get_padded_len((*(_DWORD *)(v8 + 136) + *(_DWORD *)(v8 + 108)), 8u) + v30;
              }
              v35 = get_padded_bytes(v29 + 4 * v33, 8u);
              v36 = get_padded_len((3 * *(_DWORD *)(v8 + 152)), 8u);
              v37 = get_padded_len(*(unsigned int *)(v8 + 152), 8u);
              v38 = 3 * *(_DWORD *)(v8 + 152);
              v39 = get_padded_len(v38, 8u);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 288) + 152))();
              if (!(_DWORD)result)
              {
                v40 = get_padded_bytes(v35 + 4 * (v36 + v38 * v37 + v39), 8u);
                v41 = get_padded_len(*(unsigned int *)(v8 + 176), 8u);
                v42 = *(_DWORD *)(v8 + 180);
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 296) + 152))();
                if (!(_DWORD)result)
                {
                  v43 = get_padded_bytes(v40 + 4 * v41 * v42, 8u);
                  v44 = get_padded_len(*(unsigned int *)(v8 + 176), 8u);
                  v45 = *(_DWORD *)(v8 + 180);
                  result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 304) + 152))();
                  if (!(_DWORD)result)
                  {
                    v46 = get_padded_bytes(v43 + 4 * v44 * v45, 8u);
                    v47 = get_padded_len(*(unsigned int *)(v8 + 176), 8u);
                    v48 = *(_DWORD *)(v8 + 180);
                    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 312) + 152))();
                    if (!(_DWORD)result)
                    {
                      v49 = get_padded_bytes(v46 + 4 * v47 * v48, 8u);
                      if (!*(_DWORD *)(v8 + 192))
                        v49 += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                      v50 = get_padded_len(4096, 8u);
                      v51 = v50 + *(_DWORD *)(v8 + 56) * get_padded_len(*(unsigned int *)(v8 + 60), 8u);
                      v52 = get_padded_len(*(unsigned int *)(v8 + 36), 8u);
                      result = 0;
                      *a2 = v49 + 4 * (v51 + *(_DWORD *)(v8 + 28) * v52);
                      *a3 = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"ERROR: param is NULL in wanted_wb_len(multiband_lpcnet)!", a6, a7, a8, v53);
    return 7;
  }
  return result;
}

uint64_t multiband_lpcnet_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t (*v13)(void);
  uint64_t result;
  int v15;
  int padded_bytes;
  uint64_t v17;
  int v18;

  v9 = *(_QWORD *)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    v10 = v9 + 248;
    multiband_lpcnet_get_reserved_glbBuf_bytes(a1, &v18);
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = *(uint64_t (**)(void))(*(_QWORD *)(v10 + v11) + 160);
      if (v13)
      {
        result = v13();
        if ((_DWORD)result)
          return result;
        if (*(_DWORD *)(*(_QWORD *)(v10 + v11) + 248) > v12)
          v12 = *(_DWORD *)(*(_QWORD *)(v10 + v11) + 248);
      }
      v11 += 8;
    }
    while (v11 != 72);
    v15 = v18;
    padded_bytes = get_padded_bytes(v12, 8u);
    result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes + v15;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t multiband_lpcnet_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  char v12;
  int v13;
  uint64_t result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int padded_len;
  uint64_t v20;
  unsigned int padded_bytes;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    v10 = *(_DWORD *)(v8 + 204);
    v11 = *(_DWORD *)(v8 + 124) * get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    if (v10 == 1)
      v12 = 1;
    else
      v12 = 2;
    v13 = v11 + *(_DWORD *)(v8 + 128) * get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    padded_bytes = 4
                 * ((v13 + *(_DWORD *)(v8 + 132) * get_padded_len(*(unsigned int *)(v8 + 116), 8u)) << v12);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 248), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 256), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 264), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 272), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            padded_bytes = get_padded_bytes(padded_bytes, 8u);
            result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 280), v9, &padded_bytes);
            if (!(_DWORD)result)
            {
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              v15 = *(_DWORD *)(v8 + 140);
              padded_bytes += 4
                            * (v15 + (get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u) >> 4));
              padded_bytes = get_padded_bytes(padded_bytes, 8u) + 12 * *(_DWORD *)(v8 + 136);
              padded_bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 140) << 6);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u);
              v16 = get_padded_bytes(padded_bytes, 8u);
              padded_bytes = v16;
              if (*(_DWORD *)(v8 + 160) == 1)
              {
                padded_bytes = v16 + (*(_DWORD *)(v8 + 164) << 6);
                padded_bytes = get_padded_bytes(padded_bytes, 8u)
                             + 4 * (*(_DWORD *)(v8 + 164) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4));
                padded_bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 168) << 6);
                v17 = get_padded_bytes(padded_bytes, 8u)
                    + 4 * (*(_DWORD *)(v8 + 168) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4));
              }
              else
              {
                v18 = *(_DWORD *)(v8 + 152);
                v17 = padded_bytes
                    + 12 * v18 * get_padded_len((*(_DWORD *)(v8 + 136) + *(_DWORD *)(v8 + 108)), 8u);
              }
              padded_bytes = v17;
              padded_bytes = get_padded_bytes(v17, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 152)), 8u);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 12 * get_padded_len(*(unsigned int *)(v8 + 152), 8u) * *(_DWORD *)(v8 + 152);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 152)), 8u);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 288), v9, &padded_bytes);
              if (!(_DWORD)result)
              {
                padded_bytes = get_padded_bytes(padded_bytes, 8u);
                padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 296), v9, &padded_bytes);
                if (!(_DWORD)result)
                {
                  padded_bytes = get_padded_bytes(padded_bytes, 8u);
                  padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 304), v9, &padded_bytes);
                  if (!(_DWORD)result)
                  {
                    padded_bytes = get_padded_bytes(padded_bytes, 8u);
                    padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 312), v9, &padded_bytes);
                    if (!(_DWORD)result)
                    {
                      padded_bytes = get_padded_bytes(padded_bytes, 8u);
                      padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                      padded_len = get_padded_len(4096, 8u);
                      padded_bytes += 4 * padded_len;
                      padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 60), 8u) * *(_DWORD *)(v8 + 56);
                      get_padded_len(*(unsigned int *)(v8 + 36), 8u);
                      return 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v20);
    return 7;
  }
  return result;
}

uint64_t multiband_lpcnet_assign_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(void);
  uint64_t result;
  uint64_t v11;
  unsigned int v12;

  v2 = *(_QWORD *)(a1 + 120) + 248;
  v12 = 0;
  multiband_lpcnet_get_reserved_glbBuf_bytes(a1, &v12);
  v6 = 0;
  v7 = v12;
  while (1)
  {
    v8 = *(_QWORD *)(v2 + v6);
    if (!v8)
      break;
    *(_QWORD *)(v8 + 240) = *(_QWORD *)(a1 + 240) + v7;
    v9 = *(uint64_t (**)(void))(v8 + 168);
    if (v9)
    {
      result = v9();
      if ((_DWORD)result)
        return result;
    }
    v6 += 8;
    if (v6 == 72)
      return 0;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v3, v4, v5, v11);
  return 10;
}

float multiband_lpcnet_update_param(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  float result;

  if (*(_DWORD *)(a1 + 8) == a4 && a3 == 88)
  {
    v4 = *(_QWORD *)(a1 + 120);
    v5 = *a2;
    v6 = a2[1];
    *(_DWORD *)(v4 + 320) = *a2;
    *(_DWORD *)(v4 + 332) = v6;
    if (v5 == 1 && v6 == 0)
    {
      *(_OWORD *)(v4 + 336) = *(_OWORD *)(a2 + 2);
      *(_OWORD *)(v4 + 352) = *(_OWORD *)(a2 + 6);
      *(_OWORD *)(v4 + 368) = *(_OWORD *)(a2 + 10);
      *(_QWORD *)(v4 + 384) = *((_QWORD *)a2 + 7);
      *(int32x4_t *)(v4 + 392) = vdupq_n_s32(*(_DWORD *)(v4 + 132) >> 1);
      result = *((float *)a2 + 20);
      *(float *)(v4 + 408) = result;
    }
  }
  return result;
}

uint64_t multiband_lpcnet_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t multiband_lpcnet_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  _DWORD *v2;
  int step;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t result;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int padded_len;
  int v22;

  v2 = *(_DWORD **)(a1 + 120);
  v22 = v2[9];
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  padded_len = get_padded_len(v2[34], 8u);
  v20 = get_padded_len(v2[38], 8u);
  v19 = get_padded_len((3 * v2[43]), 8u);
  v18 = get_padded_len((3 * v2[34]), 8u);
  v17 = get_padded_len((3 * v2[34]), 8u);
  v16 = get_padded_len((3 * v2[34]), 8u);
  v15 = get_padded_len((3 * v2[43]), 8u);
  v4 = get_padded_len(v2[44], 8u);
  v5 = get_padded_len((3 * v2[38]), 8u);
  v6 = get_padded_len((2 * v2[44]), 8u);
  v7 = get_padded_len(v2[11], 8u);
  v8 = v2[14];
  v9 = get_padded_len((v8 * step * v2[11]), 8u);
  v10 = get_padded_len((v2[27] * step), 8u);
  v11 = v2[29];
  if (v11 <= v2[23] + v2[20] + v2[25])
    v11 = v2[23] + v2[20] + v2[25];
  if (v11 <= 0x14A)
    v11 = 330;
  v12 = 12 * v4;
  v13 = get_padded_len(v11 * step, 8u);
  result = get_padded_bytes((v2[6] & 0xFFFFFFF8)+ 8 * v2[11]+ (v2[6] & 0xFFFFFFFC)+ 4 * (v2[7] + v22)+ 2 * (v2[6] & 0xFFFFFFFC)+ 20, 8u);
  *a2 = v12 + 4 * (v20 + padded_len + v19 + v18 + v17 + v16 + v15 + v5 + v6 + v8 * v7 + v9 + v10 + v13) + result;
  return result;
}

float multiband_lpcnet_compute_dual_fc(uint64_t a1, uint64_t a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t *v12;
  unint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float result;

  v12 = *(uint64_t **)a1;
  v13 = *(unsigned int *)(a1 + 12);
  v14 = *(void **)(a2 + 88);
  v15 = *(void **)(a2 + 72);
  cstdlib_memset(v14, 0, 4 * (v13 & 0xFFFFFFFE));
  if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t, void *, _QWORD))(a1 + 128))(0, a1, a4, v14, 0))
  {
    log_OutText(*v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)"multiband_lpcnet forward dual_fc failed!", v16, v17, v18, a9);
  }
  else
  {
    cstdlib_memset(v15, 0, 4 * (v13 >> 1));
    return fi_multiply_multiply_add_ansic((float *)v14, a3, (float *)v14 + (v13 >> 1), &a3[v13 >> 1], (float *)v15, v13 >> 1);
  }
  return result;
}

float multiband_lpcnet_compute_sparse_gru_a(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  float *v4;
  float *v5;
  void *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  float *v10;

  v3 = *(_QWORD *)(a1 + 120);
  v4 = *(float **)(a2 + 16);
  v5 = *(float **)(a2 + 32);
  v6 = *(void **)(a2 + 40);
  v7 = *(unsigned int *)(v3 + 136);
  cstdlib_memcpy(v6, *(const void **)(a2 + 232), 4 * (3 * v7));
  v8 = 0;
  v9 = 3;
  do
  {
    fi_multiply_add_ansic((float *)v6 + v8, (float *)(*(_QWORD *)(a2 + 216) + 4 * v8), v4, v7);
    v8 += v7;
    --v9;
  }
  while (v9);
  v10 = &v5[v7];
  sparse_sgemv_accum16(v6, *(_QWORD *)(a2 + 224), (3 * v7), *(_QWORD *)(a2 + 208), v4);
  axpy((2 * v7), (float *)v6, 1, v5, 1, 1.0);
  fi_activate_array(v5, (2 * v7), 11);
  fi_multiply_add_ansic(&v10[v7], (float *)v6 + (2 * v7), v10, v7);
  fi_activate_array(&v10[v7], v7, *(_DWORD *)(v3 + 144));
  fill_array_f32(v10, v7, 1.0);
  axpy(v7, v5, 1, v10, 1, -1.0);
  return fi_multiply_multiply_add_ansic(v4, v5, &v10[v7], v10, v4, v7);
}

float multiband_lpcnet_compute_gru_b(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  _DWORD *v4;
  char *v5;
  float32x4_t *v6;
  float32x4_t *v7;
  uint64_t v8;
  float *v9;
  float *v10;
  uint64_t v12;
  float *v13;

  v3 = *(uint64_t **)a1;
  v4 = *(_DWORD **)(a1 + 120);
  v5 = *(char **)(a2 + 240);
  v6 = *(float32x4_t **)(a2 + 32);
  v13 = *(float **)(a2 + 24);
  v7 = *(float32x4_t **)(a2 + 40);
  v8 = v4[38];
  cstdlib_memcpy(v6, *(const void **)(a2 + 80), 4 * (3 * v8));
  v9 = *(float **)(a2 + 16);
  if (v4[40] == 1)
    sparse_sgemv_accum16(v6, v5, (3 * v8), *(_QWORD *)(a2 + 272), v9);
  else
    gemm_ex(v3, 1, 3 * v8, v4[34], v9, v4[34], v5, v4[37], v6, 3 * v8, 0);
  v10 = &v6->f32[v8];
  cstdlib_memcpy(v7, *(const void **)(a2 + 264), 4 * (3 * v8));
  gemm(v3, 1, 3 * v8, v8, v13, *(char **)(a2 + 256), v7, 0, v12);
  axpy((2 * v8), v7->f32, 1, v6->f32, 1, 1.0);
  fi_activate_array(v6->f32, (2 * v8), 11);
  fi_multiply_add_ansic(&v10[v8], &v7->f32[(2 * v8)], v10, v8);
  fi_activate_array(&v10[v8], v8, v4[39]);
  fill_array_f32(v10, v8, 1.0);
  axpy(v8, v6->f32, 1, v10, 1, -1.0);
  return fi_multiply_multiply_add_ansic(v13, v6->f32, &v10[v8], v10, v13, v8);
}

_QWORD *free_tacotron(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[24]);
        fi_layer_free(v3[25]);
        fi_layer_free(v3[26]);
        fi_layer_free(v3[27]);
        fi_layer_free(v3[28]);
        fi_layer_free(v3[29]);
        fi_layer_free(v3[30]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_tacotron(uint64_t *a1, _DWORD *a2, const void *a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t __b;
  int v39;

  v7 = 0;
  v8 = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v17 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 264);
      v21 = v17;
      if (!v17)
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v18, v19, v20, v34);
        v8 = 10;
        goto LABEL_12;
      }
      cstdlib_memcpy(v17, a2, 0xBCuLL);
      v39 = 0;
      v37 = 0;
      __b = 0;
      cstdlib_memset(&__b, 0, 0xCuLL);
      v22 = a2[2];
      LODWORD(__b) = 5;
      HIDWORD(__b) = v22;
      v39 = 0;
      if (create_fc_layer(a1, &__b, &v37, 0, a4, (uint64_t *)v21 + 24)
        || (HIDWORD(__b) = a2[3],
            v37 = 0x100000003,
            create_fc_layer(a1, &__b, &v37, 0, a4, (uint64_t *)v21 + 25))
        || (HIDWORD(__b) = a2[4], create_fc_layer(a1, &__b, &v37, 0, a4, (uint64_t *)v21 + 26)))
      {
        v26 = "create pre dense failed!";
LABEL_9:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v34);
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron init failed!", v27, v28, v29, v35);
        v8 = 7;
LABEL_12:
        *(_QWORD *)(v7 + 120) = v21;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron init param failed!", v30, v31, v32, v36);
        goto LABEL_13;
      }
      HIDWORD(__b) = a2[45];
      LODWORD(v37) = a2[20] == 1;
      if (create_fc_layer(a1, &__b, &v37, 0, a4, (uint64_t *)v21 + 30))
      {
        v26 = "create post dense failed!";
        goto LABEL_9;
      }
      if (create_cbhg_layer(a1, a2 + 5, a3, a4, (uint64_t ***)v21 + 27))
      {
        v26 = "create encoder cbhg failed!";
        goto LABEL_9;
      }
      if (create_tacodecoder_layer(a1, a2 + 14, a4, (uint64_t *)v21 + 28))
      {
        v26 = "create decoder failed!";
        goto LABEL_9;
      }
      if (create_cbhg_layer(a1, a2 + 36, a3, a4, (uint64_t ***)v21 + 29))
      {
        v26 = "create post cbhg failed!";
        goto LABEL_9;
      }
      *(_QWORD *)(v7 + 120) = v21;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      v8 = 0;
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_tacotron;
      *(_QWORD *)(v7 + 136) = free_tacotron;
      *(_QWORD *)(v7 + 144) = tacotron_update_shape;
      *(_QWORD *)(v7 + 152) = tacotron_wanted_wb_len;
      *(_DWORD *)(v7 + 8) = a5;
      *(_DWORD *)(v7 + 12) = 0;
      *(_QWORD *)(v7 + 184) = tacotron_dispatch_weights;
      *(_QWORD *)(v7 + 160) = tacotron_request_glbBuf;
      *(_QWORD *)(v7 + 168) = tacotron_assign_glbBuf;
      *(_QWORD *)(v7 + 224) = tacotron_update_param;
      *(_QWORD *)(v7 + 232) = tacotron_set_align_address;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v34);
      v8 = 10;
    }
  }
LABEL_13:
  *a6 = v7;
  return v8;
}

uint64_t forward_tacotron(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5)
{
  int *v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  float v19;
  float v20;
  float v21;
  float v22;
  uint64_t bytes;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t **v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  float v57;
  uint64_t v58;
  float *v59;
  float v60;
  uint64_t v61;
  float v62;
  uint64_t v63;
  float v64;
  uint64_t i;
  uint64_t v66;
  float j;
  uint64_t v68;
  unsigned int v69;
  uint64_t v70;
  float *v71;
  float v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v76;
  BOOL v77;
  int v78;
  int v79;
  uint64_t v80;
  unsigned int padded_bytes;
  float *v82;
  uint64_t *__src;
  int __srca;
  void *__srcb;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  float *__b;
  int v92;
  int v93;
  size_t __len;
  uint64_t v95;
  int v96;
  uint64_t v97;

  v97 = *MEMORY[0x24BDAC8D0];
  v10 = *(int **)(a2 + 120);
  v11 = *(uint64_t **)a2;
  __len = 0;
  v95 = 0;
  v93 = 0;
  v96 = 0;
  v12 = *(unsigned int *)(a2 + 24);
  v13 = v10[15];
  v14 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v11[1] + 16))(v11[2], (v13 * v12 * v10[46]), 4);
  if (v14)
  {
    v18 = (_DWORD *)v14;
    __b = a4;
    if ((_DWORD)v12 == 3)
    {
      v19 = *(float *)(a3 + 4 * (*(_DWORD *)(a2 + 28) + 1));
      v20 = *(float *)(a3 + 4);
      v21 = v20 + 0.0001;
      v22 = v20 + -0.0001;
      if (v19 < v21 && v19 > v22)
      {
        v31 = v10[45];
        LODWORD(v95) = 1;
        HIDWORD(v95) = v31;
        *(_DWORD *)(a5 + 20) = 1;
        v32 = fi_shape_set(2, &v95, 4, (_DWORD *)(a2 + 40));
        bytes = v32;
        if ((_DWORD)v32)
          goto LABEL_19;
        cstdlib_memset(a4, 0, 4 * (HIDWORD(v95) * v95));
        *v18 = 1065353216;
        v33 = v95;
        v34 = (uint64_t **)a2;
        v35 = 3;
        v36 = (uint64_t)v18;
        v37 = 0;
        goto LABEL_16;
      }
    }
    v88 = a5;
    v89 = *(_QWORD *)(a2 + 240);
    bytes = fi_shape_get_bytes((int *)(*((_QWORD *)v10 + 29) + 40), (_DWORD *)&__len + 1);
    if ((_DWORD)bytes)
      goto LABEL_19;
    padded_bytes = get_padded_bytes(HIDWORD(__len), 8u);
    __src = *(uint64_t **)a2;
    v86 = *(_QWORD **)(a2 + 120);
    v25 = *(void **)(a2 + 240);
    bytes = fi_shape_get_bytes((int *)(v86[24] + 40), &__len);
    if ((_DWORD)bytes)
      goto LABEL_19;
    cstdlib_memset(v25, 0, __len);
    v26 = (*(uint64_t (**)(uint64_t))(v86[24] + 128))(a1);
    if ((_DWORD)v26)
    {
      bytes = v26;
      v30 = "tacotron pre dense o1 forward failed!";
    }
    else
    {
      bytes = fi_shape_get_bytes((int *)(v86[25] + 40), &__len);
      if ((_DWORD)bytes)
        goto LABEL_19;
      cstdlib_memset(__b, 0, __len);
      v40 = (*(uint64_t (**)(uint64_t))(v86[25] + 128))(a1);
      if ((_DWORD)v40)
      {
        bytes = v40;
        v30 = "tacotron pre dense o2 forward failed!";
      }
      else
      {
        bytes = fi_shape_get_bytes((int *)(v86[26] + 40), &__len);
        if ((_DWORD)bytes)
          goto LABEL_19;
        cstdlib_memset(v25, 0, __len);
        v41 = (*(uint64_t (**)(uint64_t))(v86[26] + 128))(a1);
        if ((_DWORD)v41)
        {
          bytes = v41;
          v30 = "tacotron pre dense o3 forward failed!";
        }
        else
        {
          bytes = (*(uint64_t (**)(void))(v86[27] + 176))();
          if ((_DWORD)bytes)
            goto LABEL_19;
          bytes = fi_shape_get_bytes((int *)(v86[27] + 40), &__len);
          if ((_DWORD)bytes)
            goto LABEL_19;
          cstdlib_memset(__b, 0, __len);
          v42 = (*(uint64_t (**)(uint64_t))(v86[27] + 128))(a1);
          if (!(_DWORD)v42)
          {
            v87 = *(_QWORD *)(a2 + 72);
            v43 = v10[1];
            __srca = *v10;
            bytes = fi_shape_get_bytes((int *)(*((_QWORD *)v10 + 28) + 20), &__len);
            if ((_DWORD)bytes)
              goto LABEL_19;
            v82 = (float *)(v89 + 4 * padded_bytes);
            if ((_DWORD)v12)
            {
              v44 = 0;
              v45 = 0;
              __srcb = (void *)(v87 + 4 * (v43 * __srca));
              do
              {
                cstdlib_memcpy((void *)(v89 + 4 * ((v10[1] + 2 * v10[12]) * v45)), &__b[v44 * v10[12]], 4 * (2 * v10[12]));
                v44 += 2;
                cstdlib_memcpy((void *)(v89 + 4 * (v44 * v10[12]) + 4 * (v10[1] * v45++)), __srcb, 4 * v10[1]);
              }
              while ((_DWORD)v12 != v45);
            }
            v92 = v12;
            forward_tacotron_decoder(a1, a2, (char *)__b, &__len, (uint64_t)v18, v82, (unsigned int *)&v92);
            bytes = v46;
            if ((_DWORD)v46)
              goto LABEL_19;
            v47 = *(_DWORD *)(a2 + 8);
            if (v47 == 66)
            {
              v53 = v92;
              if (v92)
              {
                v54 = 0;
                v55 = 0;
                do
                {
                  __b[v55] = 0.0;
                  if ((_DWORD)v12)
                  {
                    v56 = 0;
                    v57 = 0.0;
                    do
                    {
                      v58 = (v54 + v56);
                      if (*(float *)&v18[v58] > v57)
                      {
                        __b[v55] = (float)v56;
                        v57 = *(float *)&v18[v58];
                      }
                      ++v56;
                    }
                    while (v12 != v56);
                  }
                  ++v55;
                  v54 += v12;
                }
                while (v55 != v53);
                if (v53 >= 2)
                {
                  v59 = __b + 1;
                  v60 = *__b;
                  v61 = v53 - 1;
                  do
                  {
                    v62 = *v59;
                    if (*v59 < v60)
                    {
                      *v59 = v60;
                      v62 = v60;
                    }
                    ++v59;
                    v60 = v62;
                    --v61;
                  }
                  while (v61);
                }
                v63 = 0;
                do
                {
                  __b[v63] = __b[v63] + 1.0;
                  ++v63;
                }
                while (v53 != v63);
                v64 = *__b;
                *__b = 1.0;
                if (v53 >= 2)
                {
                  for (i = 1; i != v53; ++i)
                  {
                    if (__b[i] <= v64)
                    {
                      v66 = (float)(v64 + -0.99);
                    }
                    else
                    {
                      do
                      {
                        v64 = v64 + 1.0;
                        v66 = (float)(v64 + -0.99);
                        __b[v66] = 0.0;
                      }
                      while (__b[i] > v64);
                    }
                    __b[v66] = __b[v66] + 1.0;
                  }
                }
              }
              else
              {
                v64 = *__b;
                *__b = 1.0;
              }
              for (j = (float)v12 + -0.1; j > v64; __b[(float)(v64 + -0.99)] = 0.0)
                v64 = v64 + 1.0;
              if ((_DWORD)v12)
              {
                v68 = v12;
                do
                {
                  if (*__b < 0.5)
                    *__b = 1.0;
                  ++__b;
                  --v68;
                }
                while (v68);
              }
              *(_DWORD *)(v88 + 20) = 1;
              LODWORD(v95) = v12;
              v38 = fi_shape_set(1, &v95, 4, (_DWORD *)(a2 + 40));
              goto LABEL_17;
            }
            if (v47 != 63)
            {
              bytes = 0;
              goto LABEL_19;
            }
            v48 = v92;
            bytes = forward_tacotron_postnet(a1, a2, __b, &__len, v92);
            if ((_DWORD)bytes)
              goto LABEL_19;
            if (v10[45] == 20)
            {
              v49 = v48 * v13;
              if ((v48 * v13) < 0xB)
              {
                LODWORD(v51) = 0;
              }
              else
              {
                v50 = 0;
                v51 = v49 - 10;
                v52 = 19;
                while (__b[v52] <= 0.3)
                {
                  ++v50;
                  v52 += 20;
                  if (v51 == v50)
                    goto LABEL_92;
                }
                LODWORD(v51) = v50;
              }
LABEL_92:
              if ((int)v51 + 5 >= v49)
              {
                v74 = 0;
              }
              else
              {
                v74 = 0;
                v75 = v49 - v51 - 5;
                v76 = 20 * v13 * v48 - 1;
                while (__b[v76] <= 0.3)
                {
                  ++v74;
                  v76 -= 20;
                  if (v75 == v74)
                  {
                    v74 = v75;
                    break;
                  }
                }
              }
              v77 = v51 >= 7;
              v78 = v51 - 7;
              if (!v77)
                v78 = 0;
              v90 = v78;
              v73 = v74 >= 5 ? v74 - 5 : 0;
            }
            else
            {
              if (v10[20] == 1)
              {
                v69 = __len >> 2;
                if (__len >= 4)
                {
                  if (v69 <= 1)
                    v70 = 1;
                  else
                    v70 = v69;
                  v71 = __b;
                  do
                  {
                    v72 = *v71;
                    if (*v71 > 1.0)
                      v72 = 1.0;
                    if (v72 < 0.0)
                      v72 = 0.0;
                    *v71++ = (float)(v72 * 11.513) + -9.2103;
                    --v70;
                  }
                  while (v70);
                }
                fast_exp(__b, v69, __b);
              }
              v90 = 0;
              v73 = 0;
            }
            bytes = fi_shape_get_bytes((int *)(a2 + 40), &v93);
            if ((_DWORD)bytes)
              goto LABEL_19;
            if (v93 != (_DWORD)__len)
              *(_DWORD *)(v88 + 20) = 1;
            v79 = v10[45];
            LODWORD(v95) = v48 * v13 - (v90 + v73);
            HIDWORD(v95) = v79;
            bytes = fi_shape_set(2, &v95, 4, (_DWORD *)(a2 + 40));
            if ((_DWORD)bytes)
              goto LABEL_19;
            if (v90)
              cstdlib_memmove(__b, &__b[HIDWORD(v95) * v90], 4 * (v95 * HIDWORD(v95)));
            v33 = v95;
            v34 = (uint64_t **)a2;
            v35 = v12;
            v36 = (uint64_t)v18;
            v37 = v90;
LABEL_16:
            v38 = send_alignment_out(v34, v33, v35, v36, v37);
LABEL_17:
            bytes = v38;
            goto LABEL_19;
          }
          bytes = v42;
          v30 = "tacotron encoder cbhg forward failed!";
        }
      }
    }
    log_OutText(*__src, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v27, v28, v29, v80);
LABEL_19:
    (*(void (**)(uint64_t, _DWORD *))(v11[1] + 48))(v11[2], v18);
    return bytes;
  }
  log_OutText(*v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed!", v15, v16, v17, v80);
  return 10;
}

uint64_t tacotron_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t result;
  int step;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  _QWORD v23[2];
  int v24;
  _QWORD v25[2];
  int v26;
  int v27;
  unsigned int v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 120);
  v29 = 0;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 192) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 200) + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 208) + 144))();
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 216) + 144))();
        if (!(_DWORD)result)
        {
          v25[0] = 0;
          v25[1] = 0;
          v26 = 0;
          v23[0] = 0;
          v23[1] = 0;
          v24 = 0;
          step = fi_shape_get_step(a2);
          v7 = *(_DWORD *)(v4 + 4) + 2 * *(_DWORD *)(v4 + 48);
          v27 = step;
          v28 = v7;
          result = fi_shape_set(2, &v27, 4, v23);
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 224) + 144))(*(_QWORD *)(v4 + 224), v23, v8, v9, v10, v11);
            if (!(_DWORD)result)
            {
              v12 = *(_DWORD *)(v4 + 56);
              v27 = *(_DWORD *)(v4 + 60) * *(_DWORD *)(v4 + 184);
              v28 = v12;
              result = fi_shape_set(2, &v27, 4, v25);
              if (!(_DWORD)result)
              {
                (*(void (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 232)
                                                                                             + 144))(*(_QWORD *)(v4 + 232), v25, v13, v14, v15, v16);
                v17 = 2 * *(_DWORD *)(v4 + 172);
                v27 = *(_DWORD *)(v4 + 60) * *(_DWORD *)(v4 + 184);
                v28 = v17;
                result = fi_shape_set(2, &v27, 4, v25);
                if (!(_DWORD)result)
                {
                  (*(void (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 240)
                                                                                               + 144))(*(_QWORD *)(v4 + 240), v25, v18, v19, v20, v21);
                  v22 = *(_DWORD *)(v4 + 180);
                  if (v22 <= 0x100)
                    v22 = 256;
                  v28 = v22;
                  return fi_shape_set(2, &v27, 4, (_DWORD *)(a1 + 40));
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacotron_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int padded_len;
  uint64_t result;
  int padded_bytes;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;

  v8 = *(_QWORD *)(a1 + 120);
  v21 = 0;
  if (v8)
  {
    padded_len = get_padded_len(*(unsigned int *)(v8 + 4), 8u);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 192) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(HIDWORD(v21) + (padded_len << 9) + (int)v21, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 200) + 152))();
      if (!(_DWORD)result)
      {
        v14 = get_padded_bytes(HIDWORD(v21) + (int)v21 + padded_bytes, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 208) + 152))();
        if (!(_DWORD)result)
        {
          v15 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v14, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 216) + 152))();
          if (!(_DWORD)result)
          {
            v16 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v15, 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 224) + 152))();
            if (!(_DWORD)result)
            {
              v17 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v16, 8u);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 232) + 152))();
              if (!(_DWORD)result)
              {
                v18 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v17, 8u);
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 240) + 152))();
                if (!(_DWORD)result)
                {
                  v19 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v18, 8u);
                  result = 0;
                  *a2 = v19;
                  *a3 = 0;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v20);
    return 7;
  }
  return result;
}

uint64_t tacotron_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t (*v14)(void);
  int v15;
  int padded_bytes;
  uint64_t v17;
  int v18;

  v9 = *(_QWORD *)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    result = tacotron_get_reserved_glbBuf_bytes(a1, &v18);
    if (!(_DWORD)result)
    {
      v11 = 0;
      v12 = 0;
      v13 = v9 + 192;
      do
      {
        v14 = *(uint64_t (**)(void))(*(_QWORD *)(v13 + v11) + 160);
        if (v14)
        {
          result = v14();
          if ((_DWORD)result)
            return result;
          if (*(_DWORD *)(*(_QWORD *)(v13 + v11) + 248) > v12)
            v12 = *(_DWORD *)(*(_QWORD *)(v13 + v11) + 248);
        }
        v11 += 8;
      }
      while (v11 != 56);
      v15 = v18;
      padded_bytes = get_padded_bytes(v12, 8u);
      result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes + v15;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t tacotron_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int padded_bytes;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    padded_bytes = get_padded_len(*(unsigned int *)(v8 + 4), 8u) << 9;
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 192), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 200), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 208), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 216), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            padded_bytes = get_padded_bytes(padded_bytes, 8u);
            result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 224), v9, &padded_bytes);
            if (!(_DWORD)result)
            {
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 232), v9, &padded_bytes);
              if (!(_DWORD)result)
              {
                padded_bytes = get_padded_bytes(padded_bytes, 8u);
                result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 240), v9, &padded_bytes);
                if (!(_DWORD)result)
                {
                  get_padded_bytes(padded_bytes, 8u);
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t tacotron_assign_glbBuf(uint64_t a1)
{
  _QWORD *v2;
  uint64_t reserved_glbBuf_bytes;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(void);
  uint64_t v7;
  void (*v8)(void);
  uint64_t v9;
  void (*v10)(void);
  uint64_t v11;
  void (*v12)(void);
  uint64_t v13;
  void (*v14)(void);
  uint64_t v15;
  void (*v16)(void);
  uint64_t v17;
  void (*v18)(void);
  unsigned int v20;

  v2 = *(_QWORD **)(a1 + 120);
  v20 = 0;
  reserved_glbBuf_bytes = tacotron_get_reserved_glbBuf_bytes(a1, &v20);
  if (!(_DWORD)reserved_glbBuf_bytes)
  {
    v4 = v2[24];
    v5 = v20;
    *(_QWORD *)(v4 + 240) = *(_QWORD *)(a1 + 240) + v20;
    v6 = *(void (**)(void))(v4 + 168);
    if (v6)
      v6();
    v7 = v2[25];
    *(_QWORD *)(v7 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v8 = *(void (**)(void))(v7 + 168);
    if (v8)
      v8();
    v9 = v2[26];
    *(_QWORD *)(v9 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v10 = *(void (**)(void))(v9 + 168);
    if (v10)
      v10();
    v11 = v2[27];
    *(_QWORD *)(v11 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v12 = *(void (**)(void))(v11 + 168);
    if (v12)
      v12();
    v13 = v2[28];
    *(_QWORD *)(v13 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v14 = *(void (**)(void))(v13 + 168);
    if (v14)
      v14();
    v15 = v2[29];
    *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v16 = *(void (**)(void))(v15 + 168);
    if (v16)
      v16();
    v17 = v2[30];
    *(_QWORD *)(v17 + 240) = *(_QWORD *)(a1 + 240) + v5;
    v18 = *(void (**)(void))(v17 + 168);
    if (v18)
      v18();
  }
  return reserved_glbBuf_bytes;
}

uint64_t tacotron_update_param(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  uint64_t result;
  _DWORD *v6;

  if (*(_DWORD *)(a1 + 8) != a4)
    return 0;
  result = 7;
  if (a3 == 4)
  {
    v6 = *(_DWORD **)(a1 + 120);
    if (v6)
    {
      result = 0;
      *v6 = *a2;
    }
  }
  return result;
}

uint64_t tacotron_set_align_address(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 120);
  if (!v2)
    return 7;
  result = 0;
  *(_QWORD *)(v2 + 248) = a2;
  *(_DWORD *)(v2 + 256) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t send_alignment_out(uint64_t **a1, int a2, int a3, uint64_t a4, int a5)
{
  uint64_t *v9;
  uint64_t *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v17;

  v9 = a1[15];
  if (*((_DWORD *)v9 + 64) >= (a3 * a2 + 2))
  {
    v11 = 4 * (a3 * a2);
    cstdlib_memset(*(void **)v9[31], 0, v11 + 8);
    v15 = *(_DWORD **)v9[31];
  }
  else
  {
    v10 = *a1;
    v11 = 4 * (a3 * a2);
    *(_QWORD *)v9[31] = heap_Realloc((uint64_t *)(*a1)[2], *(_QWORD *)v9[31], v11 + 8);
    v15 = *(_DWORD **)v9[31];
    if (!v15)
    {
      log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed!", v12, v13, v14, v17);
      return 10;
    }
  }
  *v15 = a3;
  v15[1] = a2;
  cstdlib_memcpy(v15 + 2, (const void *)(a4 + 4 * (a5 * a3)), v11);
  return 0;
}

void forward_tacotron_decoder(uint64_t a1, uint64_t a2, char *a3, _DWORD *a4, uint64_t a5, float *a6, unsigned int *a7)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  size_t v16;
  float *v17;
  float *v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t alignment;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const void *v34;
  int i;
  int v36;
  unsigned int v37;
  unsigned int v39;
  unsigned int v40;
  int v43;
  float v44;

  v12 = *(_QWORD *)(a2 + 120);
  v44 = 0.0;
  v13 = *(unsigned int *)(a2 + 24);
  v15 = *(_DWORD *)(v12 + 56);
  v14 = *(_DWORD *)(v12 + 60);
  if (!(*(unsigned int (**)(void))(*(_QWORD *)(v12 + 224) + 176))()
    && !fi_shape_get_bytes((int *)(a2 + 40), a4))
  {
    cstdlib_memset(a3, 0, *a4);
    *a7 = 0;
    if (*(_DWORD *)(v12 + 184))
    {
      v43 = 0;
      v16 = (4 * v14 * v15);
      v40 = 10 * v13;
      do
      {
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(v12 + 224) + 128))(a1))
          break;
        v17 = a6;
        v18 = &a6[get_padded_len(1, 8u)];
        v19 = v16;
        cstdlib_memcpy(&a3[v43], v18, v16);
        alignment = get_alignment(*(_QWORD *)(v12 + 224), v20, v21, v22, v23, v24, v25, v26);
        if (v14)
        {
          v34 = (const void *)alignment;
          for (i = 0; i != v14; ++i)
            cstdlib_memcpy((void *)(a5 + 4 * (i + *a7 * v14) * v13), v34, 4 * v13);
        }
        get_last_alignment(*(_QWORD *)(v12 + 224), &v44, v28, v29, v30, v31, v32, v33);
        if (v36)
          break;
        v16 = v19;
        v43 += v19;
        v37 = *a7;
        a6 = v17;
        if (*a7 > v13 >> 2)
        {
          if (*v17 > 0.8 || v44 > 0.8)
            goto LABEL_25;
          if (v37 < 7)
          {
            if (v37 > v40)
              goto LABEL_25;
          }
          else if (*(float *)(a5 + 4 * (v37 - 6) * v14) == (float)(v13 - 1) || v37 > v40)
          {
LABEL_25:
            cstdlib_memset(&a3[v43 - (v16 >> 1)], 0, v16 >> 1);
            ++*a7;
            return;
          }
        }
        v39 = v37 + 1;
        *a7 = v39;
      }
      while (v39 < *(_DWORD *)(v12 + 184));
    }
  }
}

uint64_t forward_tacotron_postnet(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, int a5)
{
  uint64_t v9;
  uint64_t *v10;
  void *v11;
  int v12;
  int v13;
  uint64_t bytes;
  uint64_t v16;
  uint64_t (*v17)(void);
  uint64_t (*v18)(void);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[2];
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(a2 + 120);
  v10 = *(uint64_t **)a2;
  v11 = *(void **)(a2 + 240);
  v35[0] = 0;
  v35[1] = 0;
  v12 = *(_DWORD *)(v9 + 56);
  v13 = *(_DWORD *)(v9 + 60) * a5;
  v36 = 0;
  v37 = v13;
  v38 = v12;
  v39 = 0;
  bytes = fi_shape_set(2, &v37, 4, v35);
  if (!(_DWORD)bytes)
  {
    (*(void (**)(void))(*(_QWORD *)(v9 + 232) + 144))();
    v16 = *(_QWORD *)(v9 + 232);
    v17 = *(uint64_t (**)(void))(v16 + 160);
    if (v17)
    {
      bytes = v17();
      if ((_DWORD)bytes)
        return bytes;
      v16 = *(_QWORD *)(v9 + 232);
    }
    v18 = *(uint64_t (**)(void))(v16 + 168);
    if (v18)
    {
      bytes = v18();
      if ((_DWORD)bytes)
        return bytes;
      v16 = *(_QWORD *)(v9 + 232);
    }
    bytes = fi_shape_get_bytes((int *)(v16 + 40), a4);
    if (!(_DWORD)bytes)
    {
      cstdlib_memset(v11, 0, *a4);
      bytes = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 232) + 176))();
      if (!(_DWORD)bytes)
      {
        v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 232) + 128))(a1);
        if ((_DWORD)v19)
        {
          bytes = v19;
          v23 = *v10;
          v24 = "tacotron post cbhg forward failed!";
LABEL_13:
          log_OutText(v23, (uint64_t)"FastInfer", 0, 0, (uint64_t)v24, v20, v21, v22, v34);
          return bytes;
        }
        v25 = 2 * *(_DWORD *)(v9 + 172);
        v37 = *(_DWORD *)(v9 + 60) * a5;
        v38 = v25;
        bytes = fi_shape_set(2, &v37, 4, v35);
        if (!(_DWORD)bytes)
        {
          (*(void (**)(void))(*(_QWORD *)(v9 + 240) + 144))();
          bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 240) + 40), a4);
          if (!(_DWORD)bytes)
          {
            if (*(_DWORD *)(v9 + 180) != *(_DWORD *)(v9 + 56))
            {
              cstdlib_memset(a3, 0, *a4);
              bytes = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 240) + 128))(a1);
              if (!(_DWORD)bytes)
                return bytes;
              v23 = *v10;
              v24 = "tacotron post dense forward failed!";
              goto LABEL_13;
            }
            v26 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v10[1] + 16))(v10[2], (unint64_t)*a4 >> 2, 4);
            if (v26)
            {
              v30 = (float *)v26;
              bytes = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 240) + 128))(a1);
              if ((_DWORD)bytes)
              {
                log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron post dense forward failed!", v31, v32, v33, v34);
              }
              else
              {
                axpy(*a4 >> 2, v30, 1, (float *)a3, 1, 1.0);
                if (*(_DWORD *)(v9 + 80) == 2)
                  relu_array_f32(*a4 >> 2, (float *)a3);
              }
              (*(void (**)(uint64_t, float *))(v10[1] + 48))(v10[2], v30);
            }
            else
            {
              log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed!", v27, v28, v29, v34);
              return 10;
            }
          }
        }
      }
    }
  }
  return bytes;
}

uint64_t tacotron_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t tacotron_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t result;
  int padded_bytes;
  int v6;
  unsigned int v7;

  v3 = *(_QWORD *)(a1 + 120);
  v7 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 232) + 40), &v7);
  if ((_DWORD)result)
  {
    padded_bytes = 0;
  }
  else
  {
    padded_bytes = get_padded_bytes(v7, 8u);
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 224) + 40), &v7);
    if (!(_DWORD)result)
    {
      v6 = get_padded_bytes(v7, 8u);
      result = 0;
      padded_bytes += v6;
    }
  }
  *a2 = padded_bytes;
  return result;
}

uint64_t create_lpcnet_layer(uint64_t *a1, int *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v35;
  __int128 v36;
  int v37;
  int v38;
  int v39;
  uint64_t __b;
  int v41;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11)
  {
    v12 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 288);
    v16 = v12;
    if (v12)
    {
      cstdlib_memcpy(v12, a2, 0xB4uLL);
      v37 = 0;
      v35 = 0u;
      v36 = 0u;
      if (a2)
      {
        v41 = 0;
        __b = 0;
        cstdlib_memset(&__b, 0, 0xCuLL);
        v20 = a2[22];
        v21 = a2[23];
        LODWORD(__b) = 5;
        HIDWORD(__b) = v20;
        v41 = 0;
        v38 = v21;
        v39 = 1;
        if (create_fc_layer(a1, &__b, &v38, 0, a3, (uint64_t *)v16 + 25))
        {
          v22 = *a1;
          v23 = "create feature_dense1 failed!";
        }
        else
        {
          v28 = a2[25];
          HIDWORD(__b) = a2[24];
          v38 = v28;
          v39 = 1;
          if (create_fc_layer(a1, &__b, &v38, 0, a3, (uint64_t *)v16 + 26))
          {
            v22 = *a1;
            v23 = "create feature_dense2 failed!";
          }
          else
          {
            v29 = a2[27];
            HIDWORD(__b) = a2[26];
            v38 = v29;
            v39 = 1;
            if (create_fc_layer(a1, &__b, &v38, 0, a3, (uint64_t *)v16 + 27))
            {
              v22 = *a1;
              v23 = "create gru_a_dense failed!";
            }
            else
            {
              HIDWORD(__b) = 2 * a2[41];
              v38 = a2[43];
              v39 = 1;
              if (create_fc_layer(a1, &__b, &v38, 0, a3, (uint64_t *)v16 + 28))
              {
                v22 = *a1;
                v23 = "create dual_fc1 failed!";
              }
              else if (config_conv1d_layer(a2[17], a2[16], 1, 1, 1, 1, a2[18], &v35))
              {
                v22 = *a1;
                v23 = "create conv1d_proj sub-conv1d_norm1 cfg failed!";
              }
              else if (create_conv1d_layer(a1, &v35, 0, a3, (uint64_t ***)v16 + 23))
              {
                v22 = *a1;
                v23 = "create feature_conv1 layer failed!";
              }
              else
              {
                v30 = a2[20];
                v37 = a2[21];
                LODWORD(v35) = a2[19];
                LODWORD(v36) = v30;
                if (!create_conv1d_layer(a1, &v35, 0, a3, (uint64_t ***)v16 + 24))
                {
                  v24 = 0;
                  *(_QWORD *)v11 = a1;
                  *(_QWORD *)(v11 + 8) = 65;
                  *(_QWORD *)(v11 + 120) = v16;
                  *(_QWORD *)(v11 + 128) = forward_lpcnet_layer;
                  *(_QWORD *)(v11 + 136) = free_lpcnet;
                  *(_QWORD *)(v11 + 144) = lpcnet_update_shape;
                  *(_DWORD *)(v11 + 16) = 0;
                  *(_QWORD *)(v11 + 152) = lpcnet_wanted_wb_len;
                  *(_QWORD *)(v11 + 160) = lpcnet_request_glbBuf;
                  *(_QWORD *)(v11 + 184) = lpcnet_dispatch_weights;
                  *(_QWORD *)(v11 + 168) = lpcnet_assign_glbBuf;
                  *(_QWORD *)(v11 + 224) = lpcnet_update_param;
                  goto LABEL_23;
                }
                v22 = *a1;
                v23 = "create feature_conv2 layer failed!";
              }
            }
          }
        }
      }
      else
      {
        v22 = *a1;
        v23 = "config empty";
      }
      log_OutText(v22, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, v17, v18, v19, v35);
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"LPCNet init failed!", v31, v32, v33, v35);
      v24 = 7;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v35);
      v24 = 10;
    }
    *(_QWORD *)(v11 + 120) = v16;
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lpcnet init param failed!", v25, v26, v27, v35);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v35);
    v24 = 10;
  }
LABEL_23:
  *a4 = v11;
  return v24;
}

uint64_t forward_lpcnet_layer(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5)
{
  uint64_t *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t weights_via_offset;
  BOOL v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  int step;
  int padded_len;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int padded_bytes;
  int v51;
  unsigned int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  unsigned int v57;
  int v58;
  int v59;
  uint64_t v60;
  const char *v61;
  uint64_t *v62;
  int v63;
  BOOL v64;
  uint64_t v66;
  uint64_t v67;
  const void *v68;
  const void *v69;
  const void *v70;
  unsigned int *v71;
  int v72;
  uint64_t v73;
  int32x2_t v74;
  int v75;
  float *v76;
  float *v77;
  size_t v78;
  float v79;
  uint64_t v80;
  float v81;
  float v82;
  float v83;
  float v84;
  unint64_t v85;
  float v86;
  float v87;
  unsigned int v88;
  unsigned int v89;
  float *v90;
  uint64_t v91;
  int v92;
  unsigned int *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int v97;
  uint64_t v98;
  uint64_t v99;
  float32x2_t v100;
  float *v101;
  int32x2_t v102;
  uint64x2_t v103;
  float32x2_t v104;
  float32x2_t v105;
  float32x2_t v106;
  float32x2_t v107;
  float v108;
  uint64_t v109;
  int v110;
  unsigned int v111;
  uint64_t i;
  float v113;
  unsigned int v114;
  int j;
  const void *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  float *v121;
  unsigned int v122;
  uint64_t k;
  float v124;
  float *v125;
  unsigned int v126;
  uint64_t v127;
  float v128;
  float *v129;
  uint64_t v130;
  unsigned int *v131;
  uint64_t v132;
  uint64_t v133;
  size_t v134;
  char *v135;
  unsigned int v136;
  int v137;
  uint64_t v138;
  unsigned int v139;
  uint64_t v140;
  int v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  float *v145;
  float32x2_t *v146;
  float *v147;
  size_t v148;
  int v149;
  float *v150;
  size_t v151;
  uint64_t v152;
  size_t v153;
  float *v154;
  float32x2_t *v155;
  int8x16_t *v156;
  float v157;
  uint64_t v158;
  float *v159;
  uint64_t v160;
  int v161;
  uint64_t v162;
  size_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t *v167;
  uint64_t v168;
  uint64_t v169;
  float *v170;
  int v171;
  BOOL v172;
  float (*v173)(float);
  uint64_t (*v174)(float);
  unsigned int v175;
  float v176;
  BOOL v177;
  unsigned int v178;
  unsigned int v179;
  unsigned int v180;
  unsigned int v181;
  unsigned int v182;
  uint64_t v183;
  int v184;
  float *v185;
  void *v186;
  unsigned int v187;
  unint64_t v188;
  float *v189;
  uint64_t v190;
  unint64_t v191;
  int v192;
  int v193;
  float v194;
  _BOOL4 v195;
  BOOL v196;
  int v197;
  float v198;
  uint64_t v199;
  int v200;
  unsigned int v201;
  float v202;
  float *v203;
  float v204;
  int v205;
  int v206;
  const void *v207;
  uint64_t v208;
  size_t v209;
  void *v210;
  const void *v211;
  unsigned int v212;
  uint64_t v213;
  float *v214;
  void *v215;
  float *v216;
  uint64_t v217;
  unsigned int v218;
  uint64_t v219;
  float *v220;
  _DWORD *v221;
  char *v222;
  float *v223;
  float32x4_t *v224;
  float32x4_t *v225;
  uint64_t v226;
  float *v227;
  float *v228;
  float v229;
  uint64_t *v230;
  uint64_t v231;
  float *v232;
  float *v233;
  float *v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  unsigned int v239;
  unsigned int v240;
  float v241;
  _BOOL4 v242;
  float v243;
  float v244;
  float v245;
  unsigned int v246;
  unsigned int v247;
  uint64_t v248;
  int v249;
  uint64_t v250;
  uint64_t *v251;
  unsigned int v252;
  unsigned int v253;
  unsigned int v254;
  unsigned int v255;
  void *__dst;
  uint64_t *v257;
  _BOOL4 v258;
  int v259;
  void *v260;
  unsigned int *v261;
  uint64_t v262;
  float *v263;
  uint64_t (*v264)(float);
  unsigned int **v265;
  float (*v266)(float);
  char *v267;
  uint64_t v268;
  float *v269;
  float *v270;
  int64x2_t v271;
  uint64_t v272;
  int v273;
  uint64x2_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  float v278;
  float v279;
  unsigned int v280;
  uint64_t v281;
  float v282;
  float v283;
  int v284;
  int v285;
  uint64_t v286;
  int v287;
  int32x2_t v288;
  uint64_t v289;
  unsigned int v290;
  unsigned int v291;
  uint64_t v292;
  int *v293;
  unsigned int v294;
  uint64_t v295;
  uint64_t *v296;
  uint64_t v297;
  int64x2_t v298;
  uint64_t v299;
  uint64_t *v300;
  uint64_t v301;
  uint64_t *v302;
  unsigned int v303[3];

  v9 = *(uint64_t **)a2;
  v10 = *(_QWORD *)(a2 + 120);
  v302 = 0;
  v11 = *(_DWORD *)(a2 + 24);
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9[1] + 16))(v9[2], 1, 280);
  if (!v15)
  {
    v19 = *v9;
LABEL_6:
    log_OutText(v19, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v250);
    weights_via_offset = 10;
    goto LABEL_27;
  }
  v301 = v10;
  v292 = a5;
  v293 = a4;
  if (*(_DWORD *)(v10 + 232))
  {
    weights_via_offset = 7;
    switch(*(_DWORD *)(v10 + 244))
    {
      case 0:
      case 2:
      case 5:
        v286 = a3;
        v17 = v11 >= 2;
        v18 = v11 - 2;
        goto LABEL_9;
      case 1:
        v286 = a3;
        v17 = v11 >= 4;
        v18 = v11 - 4;
LABEL_9:
        if (!v17)
          v18 = 0;
        v294 = v18;
        goto LABEL_12;
      default:
        goto LABEL_27;
    }
  }
  v286 = a3;
  v294 = v11;
LABEL_12:
  v20 = *(uint64_t **)a2;
  v21 = *(_QWORD *)(a2 + 120);
  v22 = a2;
  v23 = *(_QWORD *)(a2 + 240);
  v24 = *(_DWORD *)(v21 + 32);
  v25 = *(_DWORD *)(v21 + 16);
  v26 = *(_QWORD *)(v22 + 72);
  v303[0] = 0;
  v295 = v22;
  v296 = v20;
  step = fi_shape_get_step((_DWORD *)(v22 + 20));
  *(_QWORD *)(v15 + 16) = v23;
  padded_len = get_padded_len(*(unsigned int *)(v21 + 124), 8u);
  *(_QWORD *)(v15 + 24) = v23 + (4 * padded_len);
  v29 = get_padded_len(*(unsigned int *)(v21 + 140), 8u) + padded_len;
  *(_QWORD *)(v15 + 32) = v23 + (4 * v29);
  v30 = get_padded_len((3 * *(_DWORD *)(v21 + 160)), 8u) + v29;
  *(_QWORD *)(v15 + 40) = v23 + (4 * v30);
  v31 = get_padded_len((3 * *(_DWORD *)(v21 + 160)), 8u) + v30;
  *(_QWORD *)(v15 + 48) = v23 + (4 * v31);
  v32 = get_padded_len(*(unsigned int *)(v21 + 164), 8u) + v31;
  *(_QWORD *)(v15 + 56) = v23 + (4 * v32);
  v33 = get_padded_len((3 * *(_DWORD *)(v21 + 140)), 8u) + v32;
  *(_QWORD *)(v15 + 64) = v23 + (4 * v33);
  v34 = get_padded_len((2 * *(_DWORD *)(v21 + 164)), 8u) + v33;
  *(_QWORD *)(v15 + 72) = v23 + (4 * v34);
  v35 = get_padded_len(*(unsigned int *)(v21 + 40), 8u) + v34;
  *(_QWORD *)(v15 + 128) = v23 + (4 * v35);
  v36 = get_padded_len((*(_DWORD *)(v21 + 40) * step), 8u) + v35;
  *(_QWORD *)(v15 + 112) = v23 + (4 * v36);
  v37 = get_padded_len((*(_DWORD *)(v21 + 96) * step), 8u) + v36;
  v38 = v23 + (4 * v37);
  *(_QWORD *)(v15 + 120) = v38;
  *(_QWORD *)(v15 + 80) = v38;
  v39 = get_padded_len((*(_DWORD *)(v21 + 60) * step), 8u) + v37;
  *(_QWORD *)(v15 + 88) = v23 + (4 * v39);
  v40 = get_padded_len((*(_DWORD *)(v21 + 68) * step), 8u) + v39;
  *(_QWORD *)(v15 + 96) = v23 + (4 * v40);
  *(_QWORD *)(v15 + 104) = v23
                         + 4 * (get_padded_len((*(_DWORD *)(v21 + 80) * step), 8u) + v40);
  get_padded_len((*(_DWORD *)(v21 + 88) * step), 8u);
  v41 = *(_DWORD *)(v21 + 104);
  if (v41 <= *(_DWORD *)(v21 + 68) + *(_DWORD *)(v21 + 60) + *(_DWORD *)(v21 + 80) + *(_DWORD *)(v21 + 88))
    v41 = *(_DWORD *)(v21 + 68) + *(_DWORD *)(v21 + 60) + *(_DWORD *)(v21 + 80) + *(_DWORD *)(v21 + 88);
  if (v41 <= 0x14A)
    v41 = 330;
  *(_QWORD *)(v15 + 136) = v23 + 4 * (get_padded_len(v41 * step, 8u) + v37);
  get_padded_bytes(8 * v24 + 4 * (v25 + v24 * v24) + 8, 8u);
  v42 = v303[0];
  *(_QWORD *)(v15 + 144) = v26 + (v303[0] & 0xFFFFFFFC);
  v43 = v42 + 4 * get_padded_len(*(unsigned int *)(v21 + 56), 8u) * *(_DWORD *)(v21 + 52);
  *(_QWORD *)(v15 + 152) = v26 + (v43 & 0xFFFFFFFC);
  v44 = v43 + 4 * get_padded_len(*(unsigned int *)(v21 + 104), 8u) * *(_DWORD *)(v21 + 112);
  *(_QWORD *)(v15 + 160) = v26 + (v44 & 0xFFFFFFFC);
  v45 = v44 + 4 * get_padded_len(*(unsigned int *)(v21 + 104), 8u) * *(_DWORD *)(v21 + 116);
  *(_QWORD *)(v15 + 168) = v26 + (v45 & 0xFFFFFFFC);
  v303[0] = v45 + 4 * get_padded_len(*(unsigned int *)(v21 + 104), 8u) * *(_DWORD *)(v21 + 120);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 184), v26, v303);
  v10 = v301;
  if ((_DWORD)weights_via_offset)
    goto LABEL_25;
  v303[0] = get_padded_bytes(v303[0], 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 192), v26, v303);
  if ((_DWORD)weights_via_offset)
    goto LABEL_25;
  v303[0] = get_padded_bytes(v303[0], 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 200), v26, v303);
  if ((_DWORD)weights_via_offset)
    goto LABEL_25;
  v303[0] = get_padded_bytes(v303[0], 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 208), v26, v303);
  if ((_DWORD)weights_via_offset)
    goto LABEL_25;
  v303[0] = get_padded_bytes(v303[0], 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 216), v26, v303);
  if ((_DWORD)weights_via_offset)
    goto LABEL_25;
  v303[0] = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 176) = v26 + (v303[0] & 0xFFFFFFFC);
  v49 = *(_DWORD *)(v21 + 128);
  v303[0] += 4 * (v49 + (get_padded_len((3 * *(_DWORD *)(v21 + 124)), 8u) >> 4));
  padded_bytes = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 184) = v26 + (padded_bytes & 0xFFFFFFFC);
  v303[0] = padded_bytes + 12 * *(_DWORD *)(v21 + 124);
  v51 = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 192) = v26 + (v51 & 0xFFFFFFFC);
  v303[0] = v51 + (*(_DWORD *)(v21 + 128) << 6);
  v303[0] = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 200) = v26 + (v303[0] & 0xFFFFFFFC);
  v303[0] += 4 * get_padded_len((3 * *(_DWORD *)(v21 + 124)), 8u);
  v52 = get_padded_bytes(v303[0], 8u);
  v303[0] = v52;
  v53 = *(_DWORD *)(v21 + 148);
  *(_QWORD *)(v15 + 208) = v26 + (v52 & 0xFFFFFFFC);
  if (v53 == 1)
  {
    v303[0] = v52 + (*(_DWORD *)(v21 + 152) << 6);
    v54 = get_padded_bytes(v303[0], 8u);
    *(_QWORD *)(v15 + 240) = v26 + (v54 & 0xFFFFFFFC);
    v303[0] = v54 + 4 * (*(_DWORD *)(v21 + 152) + ((3 * *(_DWORD *)(v21 + 140) + 15) >> 4));
    v55 = get_padded_bytes(v303[0], 8u);
    *(_QWORD *)(v15 + 256) = v26 + (v55 & 0xFFFFFFFC);
    v303[0] = v55 + (*(_DWORD *)(v21 + 156) << 6);
    v56 = get_padded_bytes(v303[0], 8u);
    *(_QWORD *)(v15 + 248) = v26 + (v56 & 0xFFFFFFFC);
    v57 = v56 + 4 * (*(_DWORD *)(v21 + 156) + ((3 * *(_DWORD *)(v21 + 140) + 15) >> 4));
  }
  else
  {
    v58 = *(_DWORD *)(v21 + 140);
    v59 = v58 * get_padded_len((*(_DWORD *)(v21 + 124) + *(_DWORD *)(v21 + 96)), 8u);
    v10 = v301;
    v57 = v303[0] + 12 * v59;
  }
  v303[0] = v57;
  v303[0] = get_padded_bytes(v57, 8u);
  *(_QWORD *)(v15 + 216) = v26 + (v303[0] & 0xFFFFFFFC);
  v303[0] += 4 * get_padded_len((3 * *(_DWORD *)(v21 + 140)), 8u);
  v303[0] = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 224) = v26 + (v303[0] & 0xFFFFFFFC);
  v303[0] += 12 * get_padded_len(*(unsigned int *)(v21 + 140), 8u) * *(_DWORD *)(v21 + 140);
  v303[0] = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 232) = v26 + (v303[0] & 0xFFFFFFFC);
  v303[0] += 4 * get_padded_len((3 * *(_DWORD *)(v21 + 140)), 8u);
  v303[0] = get_padded_bytes(v303[0], 8u);
  weights_via_offset = fi_layer_find_weights_via_offset(*(_QWORD *)(v21 + 224), v26, v303);
  if ((_DWORD)weights_via_offset)
  {
LABEL_25:
    v60 = *v296;
    v61 = "lpcnet pack buf manager failed!";
LABEL_26:
    log_OutText(v60, (uint64_t)"FastInfer", 0, 0, (uint64_t)v61, v46, v47, v48, v250);
    goto LABEL_27;
  }
  v303[0] = get_padded_bytes(v303[0], 8u);
  *(_QWORD *)(v15 + 264) = v26 + (v303[0] & 0xFFFFFFFC);
  v303[0] += 4 * get_padded_len(*(unsigned int *)(v21 + 164), 8u) * *(_DWORD *)(v21 + 168);
  *(_QWORD *)(v15 + 272) = v26 + (v303[0] & 0xFFFFFFFC);
  get_padded_len(1024, 8u);
  *(_QWORD *)v15 = v286;
  *(_QWORD *)(v15 + 8) = v293;
  v66 = v295;
  v67 = *(_QWORD *)(v295 + 120);
  if (*(_DWORD *)(v10 + 232))
  {
    v68 = *(const void **)(v67 + 248);
    if (v68)
      cstdlib_memcpy(*(void **)(v15 + 72), v68, 4 * *(unsigned int *)(v67 + 40));
    v69 = *(const void **)(v67 + 256);
    if (v69)
      cstdlib_memcpy(*(void **)(v15 + 16), v69, 4 * *(unsigned int *)(v67 + 124));
    v70 = *(const void **)(v67 + 264);
    if (v70)
      cstdlib_memcpy(*(void **)(v15 + 24), v70, 4 * *(unsigned int *)(v67 + 140));
  }
  else
  {
    cstdlib_memset(*(void **)(v15 + 72), 0, 4 * *(unsigned int *)(v67 + 40));
    cstdlib_memset(*(void **)(v15 + 16), 0, 4 * *(unsigned int *)(v67 + 124));
    cstdlib_memset(*(void **)(v15 + 24), 0, 4 * *(unsigned int *)(v67 + 140));
  }
  v71 = *(unsigned int **)(v295 + 120);
  v72 = *(_DWORD *)(v295 + 24);
  v281 = *(unsigned int *)(v295 + 28);
  v297 = v71[8];
  v73 = v71[15];
  cstdlib_memset(*(void **)(v15 + 80), 0, 4 * (v73 * v72));
  v287 = v72;
  if (v72)
  {
    v75 = 0;
    v76 = *(float **)(v15 + 80);
    v77 = *(float **)v15;
    v78 = 4 * v297;
    v277 = 4 * v73;
    do
    {
      cstdlib_memcpy(v76, v77, v78);
      v79 = *v76 * *v76;
      if (v297 < 2)
      {
        v81 = *v76 * *v76;
      }
      else
      {
        v80 = 4;
        v81 = *v76 * *v76;
        do
        {
          v82 = v76[(unint64_t)v80 / 4];
          v81 = v81 + (float)(v82 * v82);
          v83 = v82 * 1.4;
          v76[(unint64_t)v80 / 4] = v83;
          v79 = v79 + (float)(v83 * v83);
          v80 += 4;
        }
        while (v78 != v80);
      }
      v84 = Q_rsqrt(v79 / v81);
      if ((_DWORD)v297)
      {
        v85 = 0;
        do
        {
          v76[v85 / 4] = v84 * v76[v85 / 4];
          v85 += 4;
        }
        while (v78 != v85);
      }
      v86 = v77[18];
      v76[36] = v86;
      v76[37] = v77[19];
      v87 = floorf((float)((float)(v86 * 50.0) + 0.1) + 100.0);
      if (v87 <= 0.0)
        v87 = 0.0;
      v88 = v71[13];
      if (v88 <= v87)
        v89 = v88 - 1;
      else
        v89 = v87;
      v90 = &v76[v71[9]];
      v91 = *(_QWORD *)(v15 + 144);
      v92 = get_padded_len(v71[14], 8u);
      cstdlib_memcpy(v90, (const void *)(v91 + 4 * v92 * v89), 4 * v71[14]);
      v77 += v281;
      v76 = (float *)((char *)v76 + v277);
      ++v75;
      v66 = v295;
    }
    while (v75 != v287);
  }
  v257 = *(uint64_t **)v66;
  v93 = *(unsigned int **)(v66 + 120);
  v259 = *(_DWORD *)(v66 + 24);
  v303[0] = 0;
  v94 = *(_QWORD *)(v15 + 136);
  v95 = v93[8];
  v96 = v93[4];
  v97 = v93[5];
  v261 = v93;
  v98 = (v95 * v95);
  if ((_DWORD)v96)
  {
    *(float *)v74.i32 = (float)v96;
    v99 = (v96 + 1) & 0x1FFFFFFFELL;
    v274 = (uint64x2_t)vdupq_n_s64(v96 - 1);
    v100 = (float32x2_t)vdup_lane_s32(v74, 0);
    v101 = (float *)(v94 + 4 * v98 + 4);
    v102 = (int32x2_t)0x100000000;
    v103 = (uint64x2_t)xmmword_214F962F0;
    v104 = (float32x2_t)vdup_n_s32(0x3FC90FDBu);
    v271 = vdupq_n_s64(2uLL);
    do
    {
      v298 = (int64x2_t)v103;
      v288 = vmovn_s64((int64x2_t)vcgeq_u64(v274, v103));
      v105 = vdiv_f32(vmul_f32(vadd_f32(vcvt_f32_u32((uint32x2_t)v102), (float32x2_t)0x3F0000003F000000), v104), v100);
      v278 = v105.f32[0];
      v282 = sinf(v105.f32[1]);
      v106.f32[0] = sinf(v278);
      v106.f32[1] = v282;
      v107 = vmul_f32(v106, vmul_f32(v106, v104));
      v279 = v107.f32[0];
      v283 = sinf(v107.f32[1]);
      v108 = sinf(v279);
      if ((v288.i8[0] & 1) != 0)
        *(v101 - 1) = v108;
      if ((v288.i8[4] & 1) != 0)
        *v101 = v283;
      v103 = (uint64x2_t)vaddq_s64(v298, v271);
      v102 = vadd_s32(v102, (int32x2_t)0x200000002);
      v101 += 2;
      v99 -= 2;
    }
    while (v99);
  }
  v109 = v94 + 4 * v98;
  if ((_DWORD)v95)
  {
    v110 = 0;
    v111 = 0;
    do
    {
      for (i = 0; i != v95; ++i)
      {
        v113 = cosf((float)((float)((float)((float)v111 + 0.5) * (float)i) * 3.1416)/ (float)v95);
        if (!i)
          v113 = v113 * 0.70711;
        *(float *)(v94 + 4 * (v110 + i)) = v113;
      }
      ++v111;
      v110 += v95;
    }
    while (v111 != (_DWORD)v95);
    v66 = v295;
  }
  else
  {
    v95 = 0;
  }
  weights_via_offset = opus_fft_alloc_twiddles(v257, v97, (uint64_t *)(v109 + 4 * v96 + 4 * v95 + 4 * v95));
  v10 = v301;
  v114 = v294;
  if (!(_DWORD)weights_via_offset)
  {
    if (v259)
    {
      for (j = 0; j != v259; j = v161 + 1)
      {
        v280 = v261[10];
        v284 = j;
        v116 = (const void *)(*(_QWORD *)(v15 + 80) + 4 * v261[15] * j);
        v117 = *(_QWORD *)(v15 + 136);
        v275 = *(_QWORD *)(v15 + 128);
        v118 = *(_QWORD *)(v66 + 120);
        v119 = *(unsigned int *)(v118 + 32);
        v272 = (v119 * v119);
        v299 = *(unsigned int *)(v118 + 16);
        v120 = v117 + 4 * v272 + 4 * v299;
        v121 = (float *)(v120 + 4 * v119);
        cstdlib_memcpy(v121, v116, 4 * v119);
        *v121 = *v121 + 4.0;
        if ((_DWORD)v119)
        {
          v122 = 0;
          for (k = 0; k != v119; ++k)
          {
            v124 = 0.0;
            v125 = (float *)(v120 + 4 * v119);
            v126 = v122;
            v127 = v119;
            do
            {
              v128 = *v125++;
              v124 = v124 + (float)(v128 * *(float *)(v117 + 4 * v126++));
              --v127;
            }
            while (v127);
            *(float *)(v120 + 4 * k) = v124 * Q_rsqrt((float)v119 * 0.5);
            v122 += v119;
          }
          v129 = (float *)(v117 + 4 * v272 + 4 * v299);
          v130 = v119;
          do
          {
            *v129 = expf(*v129 * 2.3026);
            ++v129;
            --v130;
          }
          while (v130);
        }
        v131 = *(unsigned int **)(v66 + 120);
        v132 = v131[10];
        v133 = v131[5];
        v134 = v131[6];
        v265 = (unsigned int **)&v121[v119];
        v269 = (float *)(v265 + 1);
        v289 = v132;
        v267 = (char *)v265 + 4 * v132 + 12;
        v135 = &v267[4 * v132];
        v136 = v131[8];
        cstdlib_memset(v135, 0, v134);
        if (v136 != 1)
        {
          v137 = 0;
          v138 = 0;
          v139 = v133 / 0x50;
          do
          {
            v140 = v138++;
            v141 = eband5ms_0[v138];
            v142 = (v141 - v137) * v139;
            if ((_DWORD)v142)
            {
              v143 = 0;
              v144 = v139 * v137;
              do
              {
                *(float *)&v135[4 * (v144 + v143)] = (float)(*(float *)(v120 + 4 * v138)
                                                                         * (float)((float)v143
                                                                                 / (float)v142))
                                                                 + (float)((float)(1.0
                                                                                 - (float)((float)v143
                                                                                         / (float)v142))
                                                                         * *(float *)(v120 + 4 * v140));
                ++v143;
              }
              while (v142 != v143);
            }
            v137 = v141;
          }
          while (v138 != v136 - 1);
        }
        v263 = (float *)&v135[4 * v134];
        v145 = &v263[v133];
        v146 = (float32x2_t *)&v145[2 * v134];
        *(_DWORD *)&v135[4 * (v134 - 1)] = 0;
        cstdlib_memset(v145, 0, 8 * v134);
        if ((_DWORD)v134)
        {
          v147 = &v263[v133];
          v148 = v134;
          do
          {
            v149 = *(_DWORD *)v135;
            v135 += 4;
            *(_DWORD *)v147 = v149;
            v147 += 2;
            --v148;
          }
          while (v148);
          v150 = &v145[2 * v134];
          v151 = v134;
          do
          {
            v152 = *(_QWORD *)v145;
            v145 += 2;
            *(_QWORD *)v150 = v152;
            v150 += 2;
            --v151;
          }
          while (v151);
        }
        if (v134 < v133)
        {
          v153 = v133 - v134;
          v154 = (float *)(v117 + 8 * (v119 + v289) + 20 * v134 + 4 * (v299 + v133 + v272) + 16);
          do
          {
            v155 = &v146[v153];
            *(v154 - 1) = v155->f32[0];
            *v154 = -v155->f32[1];
            v154 += 2;
            --v153;
          }
          while (v153);
        }
        v156 = (int8x16_t *)&v146[v133];
        opus_fft_c(*v265, v146, v156);
        v157 = (float)v133;
        *v263 = *(float *)v156->i32 * (float)v133;
        v158 = 8 * v289;
        if (v133 >= 2)
        {
          v159 = (float *)(v117 + v158 + 8 * v119 + 4 * v134 + 4 * v299 + 4 * v272 + 16);
          do
            *v159++ = *(float *)&v156->i32[2 * --v133] * v157;
          while (v133 != 1);
        }
        v160 = (v289 + 1);
        if ((_DWORD)v289 == -1)
        {
          *v269 = *v269 + (float)((float)(*v269 * 0.0001) + 0.70175);
          v66 = v295;
          v114 = v294;
          v161 = v284;
        }
        else
        {
          v163 = v158 + 4 * v134;
          v164 = v117 + 8 * v119 + 4 * v299 + 4 * v272 + 12;
          v165 = (v289 + 1);
          v114 = v294;
          v161 = v284;
          do
          {
            *(_DWORD *)(v164 - 4) = *(_DWORD *)(v164 + v163);
            v164 += 4;
            --v165;
          }
          while (v165);
          *v269 = *v269 + (float)((float)(*v269 * 0.0001) + 0.70175);
          v66 = v295;
          if (v160 >= 2)
          {
            v166 = 0;
            do
            {
              v162 = v117 + 8 * v119 + 4 * v299 + 4 * v272 + 12;
              *(float *)(v162 + 4 * v166) = *(float *)(v162 + 4 * v166)
                                          * (float)((float)((float)((float)(v166 + 1) * -0.00006)
                                                          * (float)(v166 + 1))
                                                  + 1.0);
              ++v166;
            }
            while (v160 - 1 != v166);
          }
        }
        celt_lpc((void *)(v275 + 4 * v280 * v161), v267, v269, v289);
      }
    }
    weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)v261 + 23) + 40), v303);
    v10 = v301;
    if (!(_DWORD)weights_via_offset)
    {
      cstdlib_memset(*(void **)(v15 + 88), 0, v303[0]);
      weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v261 + 23) + 128))(0);
      if (!(_DWORD)weights_via_offset)
      {
        weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)v261 + 24) + 40), v303);
        if (!(_DWORD)weights_via_offset)
        {
          cstdlib_memset(*(void **)(v15 + 96), 0, v303[0]);
          weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v261 + 24) + 128))(0);
          if (!(_DWORD)weights_via_offset)
          {
            axpy(v261[15] * v259, *(float **)(v15 + 80), 1, *(float **)(v15 + 96), 1, 1.0);
            weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)v261 + 25) + 40), v303);
            if (!(_DWORD)weights_via_offset)
            {
              cstdlib_memset(*(void **)(v15 + 104), 0, v303[0]);
              weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v261 + 25) + 128))(0);
              if (!(_DWORD)weights_via_offset)
              {
                weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)v261 + 26) + 40), v303);
                if (!(_DWORD)weights_via_offset)
                {
                  cstdlib_memset(*(void **)(v15 + 112), 0, v303[0]);
                  weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v261 + 26) + 128))(0);
                  if (!(_DWORD)weights_via_offset)
                  {
                    weights_via_offset = fi_shape_get_bytes((int *)(*((_QWORD *)v261 + 27) + 40), v303);
                    if (!(_DWORD)weights_via_offset)
                    {
                      cstdlib_memset(*(void **)(v15 + 120), 0, v303[0]);
                      weights_via_offset = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v261 + 27) + 128))(0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v167 = (uint64_t *)(*(_QWORD *)(v15 + 136) + 4 * v261[8] * v261[8] + 4 * v261[4] + 4 * v261[8] + 4 * v261[8]);
  v168 = *v167;
  if (*v167)
  {
    if (*(_QWORD *)(v168 + 48))
    {
      (*(void (**)(uint64_t))(v257[1] + 80))(v257[2]);
      *(_QWORD *)(v168 + 48) = 0;
    }
    if ((*(_DWORD *)(v168 + 8) & 0x80000000) != 0 && *(_QWORD *)(v168 + 56))
    {
      (*(void (**)(uint64_t))(v257[1] + 80))(v257[2]);
      *(_QWORD *)(v168 + 56) = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(v257[1] + 80))(v257[2], v168);
    *v167 = 0;
  }
  if ((_DWORD)weights_via_offset)
  {
    v60 = *v257;
    v61 = "lpcnet forward frame network failed!";
    goto LABEL_26;
  }
  v251 = *(uint64_t **)v66;
  v169 = *(_QWORD *)(v66 + 120);
  v254 = *(_DWORD *)(v66 + 24);
  v268 = *(_QWORD *)(v15 + 8);
  v170 = *(float **)(v15 + 72);
  v171 = *(_DWORD *)(v169 + 112);
  v172 = v171 == 256;
  if (v171 == 256)
    v173 = ulaw2lin8;
  else
    v173 = ulaw2lin7;
  v266 = v173;
  v174 = lin2ulaw7;
  if (v172)
    v174 = lin2ulaw8;
  v264 = v174;
  v270 = *(float **)(v15 + 72);
  if (*(_DWORD *)(v169 + 232))
  {
    weights_via_offset = 7;
    v175 = *(_DWORD *)(v169 + 280);
    v176 = *(float *)(v169 + 284);
    switch(*(_DWORD *)(v169 + 244))
    {
      case 0:
        v179 = v254 - 2;
        if (v254 < 2)
          v179 = 0;
        v253 = 0;
        v254 = v179;
        goto LABEL_161;
      case 1:
        v177 = v254 >= 4;
        v178 = v254 - 4;
        goto LABEL_157;
      case 2:
      case 5:
        v177 = v254 >= 2;
        v178 = v254 - 2;
LABEL_157:
        if (v177)
          v180 = v178;
        else
          v180 = 0;
        v253 = 2;
        v254 = v180;
LABEL_161:
        v170 = *(float **)(v15 + 72);
        goto LABEL_162;
      default:
        goto LABEL_27;
    }
  }
  v253 = 0;
  v176 = 0.0;
  v175 = 128;
LABEL_162:
  __dst = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v251[1] + 16))(v251[2], 1, 4 * *(unsigned int *)(v169 + 104));
  if (!__dst)
  {
    v19 = *v251;
    goto LABEL_6;
  }
  v252 = v253 + v254;
  if (v253 < v253 + v254)
  {
    v181 = 0;
    v182 = 0;
    v260 = v170 + 1;
    v183 = v253;
    v262 = v169;
    do
    {
      v290 = v182;
      v255 = v181;
      if (v181 <= 5)
        v184 = 5;
      else
        v184 = v181;
      v276 = v183;
      v185 = (float *)(*(_QWORD *)(v15 + 112) + 4 * (*(_DWORD *)(v169 + 96) * v183));
      cstdlib_memcpy(*(void **)(v15 + 56), *(const void **)(v15 + 216), 4 * (3 * *(_DWORD *)(v169 + 140)));
      if (*(_DWORD *)(v169 + 148) == 1)
        v186 = (void *)sparse_sgemv_accum16(*(_QWORD *)(v15 + 56), *(_QWORD *)(v15 + 256), (3 * *(_DWORD *)(v169 + 140)), *(_QWORD *)(v15 + 248), v185);
      else
        gemm_ex(*(uint64_t **)v66, 1, 3 * *(_DWORD *)(v169 + 140), *(_DWORD *)(v169 + 96), v185, *(unsigned int *)(v169 + 96), (char *)(*(_QWORD *)(v15 + 208) + 4 * *(unsigned int *)(v169 + 124)), *(unsigned int *)(v169 + 136), *(float32x4_t **)(v15 + 56), 3 * *(_DWORD *)(v169 + 140), 0);
      if (v276 - (unint64_t)v253 <= 5)
        v187 = v253;
      else
        v187 = v276 - 5;
      if (v252 >= (int)v276 + 7)
        v188 = (v276 + 7);
      else
        v188 = v252;
      v189 = *(float **)v15;
      if (v187 >= v188)
      {
        v195 = 0;
      }
      else
      {
        v190 = v253 - 5 + v184;
        v191 = v190 + 1;
        v192 = *(_DWORD *)(v66 + 28);
        v193 = v192 * v190 + 19;
        do
        {
          v194 = v189[v193];
          v195 = v194 > 0.3;
          v196 = v194 > 0.3 || v191++ >= v188;
          v193 += v192;
        }
        while (!v196);
      }
      v182 = v290;
      if (*(_DWORD *)(v169 + 12))
      {
        v258 = v195;
        v273 = 0;
        v197 = 0;
        v198 = fmaxf((float)(v189[(20 * v276 + 19)] * 1.5) + -0.5, 0.0);
        do
        {
          v199 = *(unsigned int *)(v169 + 40);
          v291 = v182;
          v285 = v197;
          if ((_DWORD)v199)
          {
            v200 = v276;
            v201 = v276 * v199;
            v202 = 0.0;
            v203 = v170;
            do
            {
              v204 = *v203++;
              v202 = v202 - (float)(v204 * *(float *)(*(_QWORD *)(v15 + 128) + 4 * v201++));
              --v199;
            }
            while (v199);
          }
          else
          {
            v202 = 0.0;
            v200 = v276;
          }
          v205 = ((uint64_t (*)(void *, float))v264)(v186, v202);
          v206 = v264(*v170);
          v207 = *(const void **)(v15 + 32);
          if (v205 == 128 && v206 == 128 && v175 == 128)
          {
            v208 = *(unsigned int *)(v169 + 104);
            if (v273 == 1)
            {
              v209 = 4 * v208;
              v210 = *(void **)(v15 + 32);
              v211 = __dst;
            }
            else
            {
              accum4(v208, (float *)(*(_QWORD *)(v15 + 120) + 4 * (v208 * v200)), (float *)(*(_QWORD *)(v15 + 152) + 4 * ((_DWORD)v208 << 7)), (float *)(*(_QWORD *)(v15 + 160) + 4 * ((_DWORD)v208 << 7)), (float *)(*(_QWORD *)(v15 + 168) + 4 * ((_DWORD)v208 << 7)), *(float **)(v15 + 32));
              v209 = 4 * *(unsigned int *)(v169 + 104);
              v210 = __dst;
              v211 = v207;
            }
            cstdlib_memcpy(v210, v211, v209);
            v273 = 1;
          }
          else
          {
            v212 = *(_DWORD *)(v169 + 104);
            accum4(v212, (float *)(*(_QWORD *)(v15 + 120) + 4 * v212 * v200), (float *)(*(_QWORD *)(v15 + 152) + 4 * v212 * v206), (float *)(*(_QWORD *)(v15 + 160) + 4 * v212 * v205), (float *)(*(_QWORD *)(v15 + 168) + 4 * v212 * v175), *(float **)(v15 + 32));
          }
          v213 = *(_QWORD *)(v66 + 120);
          v214 = *(float **)(v15 + 16);
          v216 = *(float **)(v15 + 32);
          v215 = *(void **)(v15 + 40);
          v217 = *(unsigned int *)(v213 + 124);
          cstdlib_memcpy(v215, *(const void **)(v15 + 200), 4 * (3 * v217));
          v218 = 0;
          v219 = 3;
          do
          {
            fi_multiply_add_ansic((float *)v215 + v218, (float *)(*(_QWORD *)(v15 + 184) + 4 * v218), v214, v217);
            v218 += v217;
            --v219;
          }
          while (v219);
          v220 = &v216[v217];
          sparse_sgemv_accum16(v215, *(_QWORD *)(v15 + 192), (3 * v217), *(_QWORD *)(v15 + 176), v214);
          axpy((2 * v217), (float *)v215, 1, v216, 1, 1.0);
          fi_activate_array(v216, (2 * v217), 11);
          fi_multiply_add_ansic(&v220[v217], (float *)v215 + (2 * v217), v220, v217);
          fi_activate_array(&v220[v217], v217, *(_DWORD *)(v213 + 132));
          fill_array_f32(v220, v217, 1.0);
          axpy(v217, v216, 1, v220, 1, -1.0);
          fi_multiply_multiply_add_ansic(v214, v216, &v220[v217], v220, v214, v217);
          v300 = *(uint64_t **)v295;
          v221 = *(_DWORD **)(v295 + 120);
          v222 = *(char **)(v15 + 208);
          v223 = *(float **)(v15 + 24);
          v224 = *(float32x4_t **)(v15 + 32);
          v225 = *(float32x4_t **)(v15 + 40);
          v226 = v221[35];
          cstdlib_memcpy(v224, *(const void **)(v15 + 56), 4 * (3 * v226));
          v227 = *(float **)(v15 + 16);
          if (v221[37] == 1)
            sparse_sgemv_accum16(v224, v222, (3 * v226), *(_QWORD *)(v15 + 240), v227);
          else
            gemm_ex(v300, 1, 3 * v226, v221[31], v227, v221[31], v222, v221[34], v224, 3 * v226, 0);
          v228 = &v224->f32[v226];
          cstdlib_memcpy(v225, *(const void **)(v15 + 232), 4 * (3 * v226));
          gemm(v300, 1, 3 * v226, v226, v223, *(char **)(v15 + 224), v225, 0, v250);
          axpy((2 * v226), v225->f32, 1, v224->f32, 1, 1.0);
          fi_activate_array(v224->f32, (2 * v226), 11);
          fi_multiply_add_ansic(&v228[v226], &v225->f32[(2 * v226)], v228, v226);
          fi_activate_array(&v228[v226], v226, v221[36]);
          fill_array_f32(v228, v226, 1.0);
          axpy(v226, v224->f32, 1, v228, 1, -1.0);
          v229 = fi_multiply_multiply_add_ansic(v223, v224->f32, &v228[v226], v228, v223, v226);
          v66 = v295;
          v230 = *(uint64_t **)v295;
          v231 = *(_QWORD *)(v295 + 120);
          v232 = *(float **)(v15 + 64);
          v233 = *(float **)(v15 + 264);
          v234 = *(float **)(v15 + 48);
          v235 = *(unsigned int *)(v231 + 164);
          if ((*(unsigned int (**)(_QWORD, float))(*(_QWORD *)(v231 + 224) + 128))(0, v229))
            log_OutText(*v230, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lpcnet forward dual_fc failed!", v236, v237, v238, v250);
          else
            fi_multiply_multiply_add_ansic(v232, v233, &v232[v235], &v233[v235], v234, v235);
          v10 = v301;
          v114 = v294;
          v170 = v270;
          v169 = v262;
          v239 = sample_from_pdf(*(float **)(v15 + 48), *(_DWORD *)(v262 + 164), v198, *(float *)(v262 + 44), *(float *)(*(_QWORD *)(v15 + 272) + 4 * (v291 & 0x3FF)));
          v175 = v239;
          if (*(_DWORD *)(v262 + 164) <= 0xFFu)
          {
            v240 = 0x100u / (unsigned __int16)*(_DWORD *)(v262 + 164);
            v241 = *(float *)(*(_QWORD *)(v15 + 272) + 4 * (v291 & 0x3FF));
            v175 = v239 * v240;
            v242 = v258;
            if (v241 >= 0.5)
              v242 = 0;
            if (v242)
              v175 += (float)((float)((float)(v241 * 2.16) * (float)v240) * 0.5);
          }
          v243 = v202 + v266((float)v175);
          v186 = cstdlib_memmove(v260, v270, 4 * (*(_DWORD *)(v262 + 40) - 1));
          *v270 = v243;
          v176 = v243 + (float)(*(float *)(v262 + 48) * v176);
          if (v176 >= -32767.0)
            v244 = v176;
          else
            v244 = -32767.0;
          if (v244 <= 32767.0)
            v245 = v244 * 0.000030518;
          else
            v245 = 1.0;
          *(float *)(v268 + 4 * v291) = v245;
          v182 = v291 + 1;
          v197 = v285 + 1;
        }
        while ((v285 + 1) < *(_DWORD *)(v262 + 12));
      }
      v183 = v276 + 1;
      v181 = v255 + 1;
    }
    while (v255 + 1 != v254);
  }
  if (*(_DWORD *)(v169 + 232))
  {
    *(_DWORD *)(v169 + 280) = v175;
    *(float *)(v169 + 284) = v176;
    cstdlib_memcpy(*(void **)(v169 + 248), v170, 4 * *(unsigned int *)(v169 + 40));
    cstdlib_memcpy(*(void **)(v169 + 256), *(const void **)(v15 + 16), 4 * *(unsigned int *)(v169 + 124));
    cstdlib_memcpy(*(void **)(v169 + 264), *(const void **)(v15 + 24), 4 * *(unsigned int *)(v169 + 140));
  }
  (*(void (**)(uint64_t, void *))(v251[1] + 48))(v251[2], __dst);
  v246 = *(_DWORD *)(v10 + 8);
  if (v246 == 22000)
  {
    v247 = *(_DWORD *)(v10 + 12) * v114;
    v248 = v292;
  }
  else
  {
    weights_via_offset = src_generate(v9, 0xBu, v246 / 0x7D0, (uint64_t *)&v302);
    if ((_DWORD)weights_via_offset)
      goto LABEL_27;
    if (*(_DWORD *)(v10 + 232) == 1 && *(_DWORD *)(v10 + 244))
      cstdlib_memcpy((void *)v302[4], *(const void **)(v10 + 272), 4 * *((unsigned int *)v302 + 10));
    v247 = src_filt(v302, v293, *(_DWORD *)(v10 + 12) * v294, *(_QWORD *)(v15 + 120));
    cstdlib_memcpy(v293, *(const void **)(v15 + 120), 4 * v247);
    if (*(_DWORD *)(v10 + 232) != 1 || (v249 = *(_DWORD *)(v301 + 244), v249 == 2) || v249 == 5)
    {
      v10 = v301;
    }
    else
    {
      v10 = v301;
      cstdlib_memcpy(*(void **)(v301 + 272), (const void *)v302[4], 4 * *((unsigned int *)v302 + 10));
    }
    v248 = v292;
    v66 = v295;
  }
  weights_via_offset = 0;
  *(_DWORD *)(v66 + 44) = v247;
  *(_DWORD *)(v248 + 20) = 1;
LABEL_27:
  v62 = v302;
  if (v302)
  {
    if (*v302)
    {
      (*(void (**)(uint64_t, _QWORD))(v9[1] + 48))(v9[2], *v302);
      *v302 = 0;
      *v302 = 0;
      v62 = v302;
    }
    if (v62[4])
    {
      (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v62[4]);
      v302[4] = 0;
    }
    (*(void (**)(uint64_t))(v9[1] + 48))(v9[2]);
    v302 = 0;
  }
  if (v15)
    (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v15);
  if ((_DWORD)weights_via_offset
    || *(_DWORD *)(v10 + 232) == 1 && ((v63 = *(_DWORD *)(v10 + 244), v63 != 5) ? (v64 = v63 == 2) : (v64 = 1), v64))
  {
    if (*(_QWORD *)(v10 + 248))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 248) = 0;
    }
    if (*(_QWORD *)(v10 + 256))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 256) = 0;
    }
    if (*(_QWORD *)(v10 + 264))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 264) = 0;
    }
    if (*(_QWORD *)(v10 + 272))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(_QWORD *)(v10 + 272) = 0;
    }
  }
  return weights_via_offset;
}

uint64_t lpcnet_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v11;
  uint64_t result;
  int v13;
  uint64_t v14;
  _QWORD v15[2];
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(a1 + 120);
  v15[0] = 0;
  v15[1] = 0;
  v16 = 0;
  v19 = 0;
  if (*a2 == 2)
  {
    cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
    v11 = *(_DWORD *)(v9 + 56) + *(_DWORD *)(v9 + 32) + 20;
    v17 = a2[1];
    v18 = v11;
    fi_shape_set(2, &v17, 4, v15);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 184) + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 192) + 144))();
      if (!(_DWORD)result)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 200) + 144))();
        if (!(_DWORD)result)
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 208) + 144))();
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 216) + 144))();
            if (!(_DWORD)result)
            {
              v13 = *(_DWORD *)(v9 + 140);
              v17 = 1;
              v18 = v13;
              fi_shape_set(2, &v17, 4, v15);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 224) + 144))();
              if (!(_DWORD)result)
              {
                *(_DWORD *)(a1 + 40) = 1;
                *(_DWORD *)(a1 + 44) = 330 * a2[1];
                *(_DWORD *)(a1 + 56) = 4;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently lpcnet layer only support 2D input", a6, a7, a8, v14);
    return 7;
  }
  return result;
}

_QWORD *free_lpcnet(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[23]);
        fi_layer_free(v3[24]);
        fi_layer_free(v3[25]);
        fi_layer_free(v3[26]);
        fi_layer_free(v3[27]);
        fi_layer_free(v3[28]);
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t lpcnet_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int padded_len;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    padded_len = get_padded_len(*(unsigned int *)(v8 + 56), 8u);
    v11 = *(_DWORD *)(v8 + 52);
    v12 = get_padded_len(*(unsigned int *)(v8 + 104), 8u);
    v13 = *(_DWORD *)(v8 + 112);
    v14 = get_padded_len(*(unsigned int *)(v8 + 104), 8u);
    v15 = *(_DWORD *)(v8 + 116);
    v16 = get_padded_len(*(unsigned int *)(v8 + 104), 8u);
    v17 = *(_DWORD *)(v8 + 120);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 184) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(4 * (v11 * padded_len + v13 * v12 + v15 * v14 + v17 * v16), 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 192) + 152))();
      if (!(_DWORD)result)
      {
        v20 = get_padded_bytes(padded_bytes, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 200) + 152))();
        if (!(_DWORD)result)
        {
          v21 = get_padded_bytes(v20, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 208) + 152))();
          if (!(_DWORD)result)
          {
            v22 = get_padded_bytes(v21, 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 216) + 152))();
            if (!(_DWORD)result)
            {
              v23 = get_padded_bytes(v22, 8u);
              v24 = *(_DWORD *)(v8 + 128);
              v25 = get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u);
              v26 = get_padded_bytes(v23 + 4 * (v24 + (v25 >> 4)), 8u);
              v27 = get_padded_bytes(v26 + 12 * *(_DWORD *)(v8 + 124), 8u);
              v28 = get_padded_bytes(v27 + (*(_DWORD *)(v8 + 128) << 6), 8u);
              v29 = get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u);
              if (*(_DWORD *)(v8 + 148) == 1)
              {
                v30 = get_padded_bytes(v28 + 4 * v29 + (*(_DWORD *)(v8 + 152) << 6), 8u);
                v31 = get_padded_bytes(v30 + 4 * (*(_DWORD *)(v8 + 152) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4)), 8u);
                v28 = get_padded_bytes(v31 + (*(_DWORD *)(v8 + 156) << 6), 8u);
                v32 = *(_DWORD *)(v8 + 156) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4);
              }
              else
              {
                v33 = *(_DWORD *)(v8 + 140);
                v32 = 3 * v33 * get_padded_len((*(_DWORD *)(v8 + 124) + *(_DWORD *)(v8 + 96)), 8u) + v29;
              }
              v34 = get_padded_bytes(v28 + 4 * v32, 8u);
              v35 = get_padded_len((3 * *(_DWORD *)(v8 + 140)), 8u);
              v36 = get_padded_len(*(unsigned int *)(v8 + 140), 8u);
              v37 = 3 * *(_DWORD *)(v8 + 140);
              v38 = get_padded_len(v37, 8u);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 224) + 152))();
              if (!(_DWORD)result)
              {
                v39 = get_padded_bytes(v34 + 4 * (v35 + v37 * v36 + v38), 8u);
                v40 = get_padded_len(*(unsigned int *)(v8 + 164), 8u);
                v41 = *(_DWORD *)(v8 + 168);
                v42 = get_padded_len(1024, 8u);
                result = 0;
                *a2 = v39 + 4 * (v42 + v41 * v40);
                *a3 = 0;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"ERROR: param is NULL in wanted_wb_len(lpcnet)!", a6, a7, a8, v43);
    return 7;
  }
  return result;
}

uint64_t lpcnet_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t (*v13)(void);
  uint64_t result;
  int v15;
  int padded_bytes;
  uint64_t v17;
  int v18;

  v9 = *(_QWORD *)(a1 + 120);
  v18 = 0;
  if (v9)
  {
    v10 = v9 + 184;
    lpcnet_get_reserved_glbBuf_bytes(a1, &v18);
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = *(uint64_t (**)(void))(*(_QWORD *)(v10 + v11) + 160);
      if (v13)
      {
        result = v13();
        if ((_DWORD)result)
          return result;
        if (*(_DWORD *)(*(_QWORD *)(v10 + v11) + 248) > v12)
          v12 = *(_DWORD *)(*(_QWORD *)(v10 + v11) + 248);
      }
      v11 += 8;
    }
    while (v11 != 48);
    v15 = v18;
    padded_bytes = get_padded_bytes(v12, 8u);
    result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes + v15;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t lpcnet_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t result;
  int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int padded_bytes;

  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    v10 = get_padded_len(*(unsigned int *)(v8 + 56), 8u) * *(_DWORD *)(v8 + 52);
    v11 = 4 * get_padded_len(*(unsigned int *)(v8 + 104), 8u) * *(_DWORD *)(v8 + 112) + 4 * v10;
    v12 = v11 + 4 * get_padded_len(*(unsigned int *)(v8 + 104), 8u) * *(_DWORD *)(v8 + 116);
    padded_bytes = v12 + 4 * get_padded_len(*(unsigned int *)(v8 + 104), 8u) * *(_DWORD *)(v8 + 120);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 184), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 192), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 200), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 208), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            padded_bytes = get_padded_bytes(padded_bytes, 8u);
            result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 216), v9, &padded_bytes);
            if (!(_DWORD)result)
            {
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              v14 = *(_DWORD *)(v8 + 128);
              padded_bytes += 4
                            * (v14 + (get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u) >> 4));
              padded_bytes = get_padded_bytes(padded_bytes, 8u) + 12 * *(_DWORD *)(v8 + 124);
              padded_bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 128) << 6);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u);
              v15 = get_padded_bytes(padded_bytes, 8u);
              padded_bytes = v15;
              if (*(_DWORD *)(v8 + 148) == 1)
              {
                padded_bytes = v15 + (*(_DWORD *)(v8 + 152) << 6);
                padded_bytes = get_padded_bytes(padded_bytes, 8u)
                             + 4 * (*(_DWORD *)(v8 + 152) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4));
                padded_bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 156) << 6);
                v16 = get_padded_bytes(padded_bytes, 8u)
                    + 4 * (*(_DWORD *)(v8 + 156) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4));
              }
              else
              {
                v17 = *(_DWORD *)(v8 + 140);
                v16 = padded_bytes
                    + 12 * v17 * get_padded_len((*(_DWORD *)(v8 + 124) + *(_DWORD *)(v8 + 96)), 8u);
              }
              padded_bytes = v16;
              padded_bytes = get_padded_bytes(v16, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 140)), 8u);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 12 * get_padded_len(*(unsigned int *)(v8 + 140), 8u) * *(_DWORD *)(v8 + 140);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 140)), 8u);
              padded_bytes = get_padded_bytes(padded_bytes, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 224), v9, &padded_bytes);
              if (!(_DWORD)result)
              {
                padded_bytes = get_padded_bytes(padded_bytes, 8u);
                padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 164), 8u) * *(_DWORD *)(v8 + 168);
                get_padded_len(1024, 8u);
                return 0;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v18);
    return 7;
  }
  return result;
}

uint64_t lpcnet_assign_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(void);
  uint64_t result;
  uint64_t v11;
  unsigned int v12;

  v2 = *(_QWORD *)(a1 + 120) + 184;
  v12 = 0;
  lpcnet_get_reserved_glbBuf_bytes(a1, &v12);
  v6 = 0;
  v7 = v12;
  while (1)
  {
    v8 = *(_QWORD *)(v2 + v6);
    if (!v8)
      break;
    *(_QWORD *)(v8 + 240) = *(_QWORD *)(a1 + 240) + v7;
    v9 = *(uint64_t (**)(void))(v8 + 168);
    if (v9)
    {
      result = v9();
      if ((_DWORD)result)
        return result;
    }
    v6 += 8;
    if (v6 == 48)
      return 0;
  }
  log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v3, v4, v5, v11);
  return 10;
}

float lpcnet_update_param(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v4;
  float v5;
  int v6;
  float result;

  if (*(_DWORD *)(a1 + 8) == a4 && a3 == 48)
  {
    v4 = *(_QWORD *)(a1 + 120);
    v5 = *(float *)a2;
    v6 = a2[1];
    *(_DWORD *)(v4 + 232) = *a2;
    *(_DWORD *)(v4 + 244) = v6;
    if (LODWORD(v5) == 1 && v6 == 0)
    {
      *(_OWORD *)(v4 + 248) = *(_OWORD *)(a2 + 2);
      *(_OWORD *)(v4 + 264) = *(_OWORD *)(a2 + 6);
      *(_DWORD *)(v4 + 280) = a2[10];
      result = *((float *)a2 + 11);
      *(float *)(v4 + 284) = result;
    }
  }
  return result;
}

uint64_t lpcnet_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t lpcnet_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  _DWORD *v2;
  int v3;
  int step;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t result;
  int v16;
  int padded_len;
  int v18;

  v2 = *(_DWORD **)(a1 + 120);
  v3 = v2[8];
  v18 = v2[4];
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  padded_len = get_padded_len(v2[31], 8u);
  v16 = get_padded_len(v2[35], 8u);
  v5 = get_padded_len((3 * v2[40]), 8u);
  v6 = get_padded_len((3 * v2[40]), 8u);
  v7 = get_padded_len(v2[41], 8u);
  v8 = get_padded_len((3 * v2[35]), 8u);
  v9 = get_padded_len((2 * v2[41]), 8u);
  v10 = get_padded_len(v2[10], 8u);
  v11 = get_padded_len((v2[10] * step), 8u);
  v12 = get_padded_len((v2[24] * step), 8u);
  v13 = v2[26];
  if (v13 <= v2[17] + v2[15] + v2[20] + v2[22])
    v13 = v2[17] + v2[15] + v2[20] + v2[22];
  if (v13 <= 0x14A)
    v13 = 330;
  v14 = v16 + padded_len + v5 + v6 + v7 + v8 + v9 + v10 + v11 + v12 + get_padded_len(v13 * step, 8u);
  result = get_padded_bytes(8 * v3 + 4 * (v18 + v3 * v3) + 8, 8u);
  *a2 = result + 4 * v14;
  return result;
}

uint64_t wavernn_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t create_wavernn_layer(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  const char *v25;
  uint64_t result;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  uint64x2_t v41;
  float *v42;
  int64x2_t v43;
  int64x2_t v44;
  int32x2_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int __b;
  int v55;
  int v56;

  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v13)
  {
    v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 128);
    v18 = v14;
    if (!v14)
    {
      v27 = *a1;
      v28 = "out of memory!";
LABEL_11:
      log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v15, v16, v17, v46);
      *(_QWORD *)(v13 + 120) = v18;
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"wavernn init param failed!", v29, v30, v31, v47);
      result = 7;
      goto LABEL_12;
    }
    cstdlib_memcpy(v14, (const void *)a2, 0x40uLL);
    v22 = *(_DWORD *)(a2 + 16);
    __b = 5;
    v55 = v22;
    if ((*(_DWORD *)(a2 + 28) - 1) >= 2)
    {
      v24 = *a1;
      v25 = "wavernn only support n_samples=1, 2, but got: %d!";
      v46 = *(unsigned int *)(a2 + 28);
      goto LABEL_10;
    }
    v56 = *(_DWORD *)(a2 + 28);
    v53 = 0x100000003;
    v49 = 0;
    if (create_fc_layer(a1, &__b, &v53, 0, a3, (uint64_t *)v18 + 8)
      || (cstdlib_memset(&__b, 0, 0xCuLL),
          v23 = *(_DWORD *)(a2 + 12),
          __b = 5,
          v55 = v23,
          v56 = 0,
          LODWORD(v53) = 3,
          create_fc_layer(a1, &__b, &v53, 0, a3, (uint64_t *)v18 + 9)))
    {
      v24 = *a1;
      v25 = "create wavernn pre input dense layer failed!";
LABEL_10:
      log_OutText(v24, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v19, v20, v21, v46);
      v27 = *a1;
      v28 = "wavernn network init failed!";
      goto LABEL_11;
    }
    cstdlib_memset(&__b, 0, 0xCuLL);
    v32 = *(_DWORD *)(a2 + 8);
    __b = 23;
    v55 = v32;
    v56 = *(_DWORD *)(a2 + 56);
    fi_get_activation("tanh");
    fi_get_activation("hardsigmoid");
    v50 = *(_DWORD *)(a2 + 60);
    v51 = *(_QWORD *)(a2 + 40);
    v52 = 0x100000001;
    if (create_gru_layer(a1, &__b, &v50, 0, a3, (uint64_t ***)v18 + 10))
    {
      v24 = *a1;
      v25 = "create wavernn GRU layer failed!";
      goto LABEL_10;
    }
    cstdlib_memset(&__b, 0, 0xCuLL);
    v33 = *(_DWORD *)(a2 + 20);
    __b = 5;
    v55 = v33;
    v56 = 0;
    LODWORD(v53) = 3;
    if (create_fc_layer(a1, &__b, &v53, 0, a3, (uint64_t *)v18 + 11))
    {
      v24 = *a1;
      v25 = "create wavernn post dense layer 0 failed!";
      goto LABEL_10;
    }
    cstdlib_memset(&__b, 0, 0xCuLL);
    v34 = *(_DWORD *)(a2 + 28) * *(_DWORD *)(a2 + 24);
    __b = 5;
    v55 = v34;
    v56 = *(_DWORD *)(a2 + 56);
    LODWORD(v53) = 0;
    if (create_fc_layer(a1, &__b, &v53, 0, a3, (uint64_t *)v18 + 12))
    {
      v24 = *a1;
      v25 = "create wavernn post dense layer 1 failed!";
      goto LABEL_10;
    }
    v35 = *(_DWORD *)(a2 + 52);
    LODWORD(v49) = 0;
    HIDWORD(v49) = v35;
    if (create_sampling_layer(a1, &v49, a4, (uint64_t *)v18 + 13))
    {
      v24 = *a1;
      v25 = "create wavernn sampling layer failed!";
      goto LABEL_10;
    }
    v48 = *(_DWORD *)(a2 + 36);
    if (create_mulaw_layer(a1, &v48, (uint64_t *)v18 + 14))
    {
      v24 = *a1;
      v25 = "create wavernn mulaw layer failed!";
      goto LABEL_10;
    }
    v36 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[1] + 16))(a1[2], *(unsigned int *)(a2 + 28), 4);
    *((_QWORD *)v18 + 15) = v36;
    if (!v36)
    {
      v24 = *a1;
      v25 = "out of memory!";
      goto LABEL_10;
    }
    v37 = *(unsigned int *)(a2 + 28);
    if ((_DWORD)v37)
    {
      v38 = *(_DWORD *)(a2 + 32);
      v39 = *(_DWORD *)(a2 + 24);
      v40 = (v37 + 1) & 0x1FFFFFFFELL;
      v41 = (uint64x2_t)vdupq_n_s64(v37 - 1);
      v42 = (float *)(v36 + 4);
      v43 = (int64x2_t)xmmword_214F962F0;
      v44 = vdupq_n_s64(2uLL);
      do
      {
        v45 = vmovn_s64((int64x2_t)vcgeq_u64(v41, (uint64x2_t)v43));
        if ((v45.i8[0] & 1) != 0)
          *(v42 - 1) = (float)v38;
        if ((v45.i8[4] & 1) != 0)
          *v42 = (float)(v39 + v38);
        v43 = vaddq_s64(v43, v44);
        v42 += 2;
        v38 += 2 * v39;
        v40 -= 2;
      }
      while (v40);
    }
    result = 0;
    *(_QWORD *)v13 = a1;
    *(_QWORD *)(v13 + 8) = 27;
    *(_QWORD *)(v13 + 120) = v18;
    *(_QWORD *)(v13 + 128) = forward_wavernn_layer;
    *(_QWORD *)(v13 + 136) = free_wavernn_layer;
    *(_QWORD *)(v13 + 144) = wavernn_layer_update_shape;
    *(_QWORD *)(v13 + 152) = wavernn_layer_wanted_wb_len;
    *(_QWORD *)(v13 + 160) = wavernn_request_glbBuf;
    *(_QWORD *)(v13 + 256) = *(_QWORD *)(a3 + 24);
    *(_DWORD *)(v13 + 264) = *(_DWORD *)(a3 + 16);
    *(_QWORD *)(v13 + 224) = wavernn_update_param;
    *(_QWORD *)(v13 + 176) = wavernn_layer_reset;
    *(_QWORD *)(v13 + 184) = wavernn_dispatch_weights;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v46);
    result = 10;
  }
LABEL_12:
  *a5 = v13;
  return result;
}

uint64_t forward_wavernn_layer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t input_dim;
  uint64_t v4;
  uint64_t v5;
  int v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  int *v12;
  int step;
  size_t v14;
  int v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  float *v32;
  unsigned int v33;
  uint64_t v34;
  uint64x2_t v35;
  float *v36;
  int64x2_t v37;
  int64x2_t v38;
  int32x2_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v43;
  uint64_t *v44;
  char *__dst;
  unsigned int v46;
  char *v47;
  unsigned int v48;
  char *__b;
  unsigned int v51;

  input_dim = a2;
  v51 = 0;
  if (!a2)
    return input_dim;
  v44 = *(uint64_t **)a2;
  v4 = *(_QWORD *)(a2 + 120);
  v6 = *(_DWORD *)(v4 + 24);
  v5 = *(unsigned int *)(v4 + 28);
  __dst = *(char **)(a2 + 240);
  v7 = &__dst[4 * get_padded_len(v5, 8u)];
  v8 = &v7[4 * get_padded_len(*(unsigned int *)(v4 + 16), 8u)];
  v9 = &v8[4 * get_padded_len(*(unsigned int *)(v4 + 12), 8u)];
  v10 = &v9[4 * get_padded_len(*(unsigned int *)(v4 + 8), 8u)];
  v11 = &v10[4 * get_padded_len(*(unsigned int *)(v4 + 20), 8u)];
  *(_QWORD *)(*(_QWORD *)(v4 + 80) + 240) = &v11[4
                                                 * get_padded_len((*(_DWORD *)(v4 + 28)* *(_DWORD *)(v4 + 24)), 8u)];
  v12 = (int *)(input_dim + 20);
  step = fi_shape_get_step(v12);
  input_dim = fi_shape_get_input_dim(v12, (int *)&v51);
  if ((_DWORD)input_dim)
    return input_dim;
  __b = v8;
  v47 = v7;
  v14 = 4 * v5;
  cstdlib_memcpy(__dst, *(const void **)(v4 + 120), 4 * v5);
  v48 = *(_DWORD *)(v4 + 4);
  v46 = v48 * step;
  if (!(v48 * step))
  {
    input_dim = 0;
LABEL_24:
    if (*(_DWORD *)(v4 + 48))
    {
      cstdlib_memcpy(*(void **)(v4 + 120), __dst, v14);
    }
    else if ((_DWORD)v5)
    {
      v33 = *(_DWORD *)(v4 + 32);
      v34 = (v5 + 1) & 0x1FFFFFFFELL;
      v35 = (uint64x2_t)vdupq_n_s64(v5 - 1);
      v36 = (float *)(*(_QWORD *)(v4 + 120) + 4);
      v37 = (int64x2_t)xmmword_214F962F0;
      v38 = vdupq_n_s64(2uLL);
      do
      {
        v39 = vmovn_s64((int64x2_t)vcgeq_u64(v35, (uint64x2_t)v37));
        if ((v39.i8[0] & 1) != 0)
          *(v36 - 1) = (float)v33;
        if ((v39.i8[4] & 1) != 0)
          *v36 = (float)(v6 + v33);
        v37 = vaddq_s64(v37, v38);
        v36 += 2;
        v33 += 2 * v6;
        v34 -= 2;
      }
      while (v34);
    }
    return input_dim;
  }
  v15 = 0;
  v16 = 0;
  v17 = __b;
  while (1)
  {
    if (v16 % v48)
    {
      v18 = v47;
      goto LABEL_10;
    }
    cstdlib_memset(v17, 0, 4 * *(unsigned int *)(v4 + 12));
    v19 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 72) + 128))(0);
    if ((_DWORD)v19)
      break;
    a3 += 4 * v51;
    HIDWORD(v23) = -1030792151 * (v15 + 1);
    LODWORD(v23) = HIDWORD(v23);
    v18 = v47;
    ++v15;
    if ((v23 >> 2) <= 0x28F5C28)
      log_OutText(*v44, (uint64_t)"FastInfer", 4, 0, (uint64_t)"step: %d/%d, frame: %d/%d", v20, v21, v22, v16);
LABEL_10:
    cstdlib_memset(v18, 0, 4 * *(unsigned int *)(v4 + 16));
    v24 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 64) + 128))(0);
    if ((_DWORD)v24)
    {
      input_dim = v24;
      v40 = *v44;
      v41 = "wavernn forward input dense failed!";
      goto LABEL_40;
    }
    cstdlib_memset(v9, 0, 4 * *(unsigned int *)(v4 + 8));
    v25 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 80) + 128))(0);
    if ((_DWORD)v25)
    {
      input_dim = v25;
      v40 = *v44;
      v41 = "wavernn forward rnn layer failed!";
      goto LABEL_40;
    }
    cstdlib_memset(v10, 0, 4 * *(unsigned int *)(v4 + 20));
    v26 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 88) + 128))(0);
    if ((_DWORD)v26)
    {
      input_dim = v26;
      v40 = *v44;
      v41 = "wavernn forward first output dense failed!";
      goto LABEL_40;
    }
    cstdlib_memset(v11, 0, 4 * (*(_DWORD *)(v4 + 28) * *(_DWORD *)(v4 + 24)));
    v27 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 96) + 128))(0);
    if ((_DWORD)v27)
    {
      input_dim = v27;
      v40 = *v44;
      v41 = "wavernn forward second dense failed!";
      goto LABEL_40;
    }
    if ((_DWORD)v5)
    {
      v28 = 0;
      do
        fi_activate_array((float *)&v11[4 * *(_DWORD *)(v4 + 24) * v28++], *(unsigned int *)(v4 + 24), 9);
      while ((_DWORD)v5 != v28);
    }
    cstdlib_memset(__dst, 0, 4 * *(unsigned int *)(v4 + 28));
    v29 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 104) + 128))(0);
    if ((_DWORD)v29)
    {
      input_dim = v29;
      v40 = *v44;
      v41 = "wavernn forward sampling failed!";
      goto LABEL_40;
    }
    input_dim = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v4 + 112) + 128))(0);
    if ((_DWORD)v5)
    {
      v30 = 0;
      v31 = v5;
      v32 = (float *)__dst;
      do
      {
        *v32 = (float)(v30 + *v32);
        ++v32;
        v30 += v6;
        --v31;
      }
      while (v31);
    }
    v16 = (v16 + v5);
    v17 = __b;
    if (v16 >= v46)
    {
      v14 = 4 * v5;
      goto LABEL_24;
    }
  }
  input_dim = v19;
  v40 = *v44;
  v41 = "wavernn forward local-condition dense failed!";
LABEL_40:
  log_OutText(v40, (uint64_t)"FastInfer", 0, 0, (uint64_t)v41, v20, v21, v22, v43);
  return input_dim;
}

_QWORD *free_wavernn_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[8]);
        fi_layer_free(v3[9]);
        fi_layer_free(v3[10]);
        fi_layer_free(v3[11]);
        fi_layer_free(v3[12]);
        fi_layer_free(v3[13]);
        fi_layer_free(v3[14]);
        if (v3[15])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v3[15] = 0;
        }
        (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t wavernn_layer_update_shape(uint64_t a1, const void *a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t result;
  int v7;
  unsigned int v8;
  _QWORD v9[2];
  int v10;
  _QWORD __dst[2];
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 120);
  __dst[0] = 0;
  __dst[1] = 0;
  v12 = 0;
  v9[0] = 0;
  v9[1] = 0;
  v10 = 0;
  v8 = 0;
  v5 = *(_DWORD *)(v4 + 28) * *(_DWORD *)(v4 + 24);
  v13 = 1;
  v14 = v5;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  result = fi_shape_set(2, &v13, 4, v9);
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 64) + 144))();
    if (!(_DWORD)result)
    {
      cstdlib_memcpy(__dst, a2, 0x14uLL);
      HIDWORD(__dst[0]) = 1;
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 72) + 144))();
      if (!(_DWORD)result)
      {
        v7 = *(_DWORD *)(v4 + 12) + *(_DWORD *)(v4 + 16);
        v13 = 1;
        LODWORD(v14) = v7;
        fi_shape_set(2, &v13, 4, v9);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 80) + 144))();
        if (!(_DWORD)result)
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 88) + 144))();
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 96) + 144))();
            if (!(_DWORD)result)
            {
              result = fi_shape_get_size((int *)(*(_QWORD *)(v4 + 96) + 40), (int *)&v8);
              if (!(_DWORD)result)
              {
                v13 = *(_DWORD *)(v4 + 28);
                LODWORD(v14) = v8 / v13;
                fi_shape_set(2, &v13, 4, v9);
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 104) + 144))();
                if (!(_DWORD)result)
                {
                  (*(void (**)(void))(*(_QWORD *)(v4 + 112) + 144))();
                  v13 = *(_DWORD *)(v4 + 4) * *(_DWORD *)(a1 + 24);
                  LODWORD(v14) = 1;
                  return fi_shape_set(2, &v13, 4, (_DWORD *)(a1 + 40));
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t wavernn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  _QWORD *v5;
  uint64_t result;
  int padded_bytes;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;

  v13 = 0;
  v5 = *(_QWORD **)(a1 + 120);
  result = (*(uint64_t (**)(void))(v5[8] + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes((int)v13 + HIDWORD(v13), 8u);
    result = (*(uint64_t (**)(void))(v5[9] + 152))();
    if (!(_DWORD)result)
    {
      v8 = get_padded_bytes(HIDWORD(v13) + (int)v13 + padded_bytes, 8u);
      result = (*(uint64_t (**)(void))(v5[10] + 152))();
      if (!(_DWORD)result)
      {
        v9 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v8, 8u);
        result = (*(uint64_t (**)(void))(v5[11] + 152))();
        if (!(_DWORD)result)
        {
          v10 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v9, 8u);
          result = (*(uint64_t (**)(void))(v5[12] + 152))();
          if (!(_DWORD)result)
          {
            v11 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v10, 8u);
            result = (*(uint64_t (**)(void))(v5[14] + 152))();
            if (!(_DWORD)result)
            {
              v12 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v11, 8u);
              result = 0;
              *a2 = v12;
              *a3 = 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t wavernn_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int padded_len;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t (*v9)(uint64_t);
  uint64_t result;
  int padded_bytes;

  v2 = *(_QWORD *)(a1 + 120);
  v3 = *(_QWORD *)(v2 + 80);
  padded_len = get_padded_len(*(unsigned int *)(v2 + 28), 8u);
  v5 = get_padded_len(*(unsigned int *)(v2 + 16), 8u) + padded_len;
  v6 = get_padded_len(*(unsigned int *)(v2 + 12), 8u);
  v7 = v5 + v6 + get_padded_len(*(unsigned int *)(v2 + 8), 8u);
  v8 = v7 + get_padded_len(*(unsigned int *)(v2 + 20), 8u);
  *(_DWORD *)(a1 + 248) = 4 * (v8 + get_padded_len((*(_DWORD *)(v2 + 28) * *(_DWORD *)(v2 + 24)), 8u));
  v9 = *(uint64_t (**)(uint64_t))(v3 + 160);
  if (!v9 || (result = v9(v3), !(_DWORD)result))
  {
    padded_bytes = get_padded_bytes(*(_DWORD *)(v3 + 248), 8u);
    result = 0;
    *(_DWORD *)(a1 + 248) += padded_bytes;
  }
  return result;
}

uint64_t wavernn_layer_reset(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t (*v3)(void);
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  uint64x2_t v9;
  float *v10;
  int64x2_t v11;
  int64x2_t v12;
  int32x2_t v13;

  v1 = *(_QWORD *)(a1 + 120);
  v2 = *(_QWORD *)(v1 + 80);
  if (!v2 || (v3 = *(uint64_t (**)(void))(v2 + 176)) == 0 || (result = v3(), !(_DWORD)result))
  {
    v5 = *(unsigned int *)(v1 + 28);
    if ((_DWORD)v5)
    {
      v6 = *(_DWORD *)(v1 + 32);
      v7 = *(_DWORD *)(v1 + 24);
      v8 = (v5 + 1) & 0x1FFFFFFFELL;
      v9 = (uint64x2_t)vdupq_n_s64(v5 - 1);
      v10 = (float *)(*(_QWORD *)(v1 + 120) + 4);
      v11 = (int64x2_t)xmmword_214F962F0;
      v12 = vdupq_n_s64(2uLL);
      do
      {
        v13 = vmovn_s64((int64x2_t)vcgeq_u64(v9, (uint64x2_t)v11));
        if ((v13.i8[0] & 1) != 0)
          *(v10 - 1) = (float)v6;
        if ((v13.i8[4] & 1) != 0)
          *v10 = (float)(v7 + v6);
        v11 = vaddq_s64(v11, v12);
        v10 += 2;
        v6 += 2 * v7;
        v8 -= 2;
      }
      while (v8);
    }
    return 0;
  }
  return result;
}

uint64_t wavernn_update_param(uint64_t a1, _DWORD *a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t vars0;

  if (*(_DWORD *)(a1 + 8) != a4)
    return 0;
  if (a3 == 4)
  {
    result = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) = *a2;
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"wavernn update param incorrect nbytes (need 4bytes)", a6, a7, a8, vars0);
    return 7;
  }
  return result;
}

uint64_t wavernn_dispatch_weights(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  int v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(uint64_t **)a1;
  v2 = *(uint64_t **)(a1 + 120);
  v3 = *(_QWORD *)(a1 + 72);
  v4 = *(_DWORD *)(a1 + 80);
  result = fi_layer_find_weights_via_offset(v2[8], v3, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(v2[9], v3, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(v2[10], v3, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        result = fi_layer_find_weights_via_offset(v2[11], v3, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(v2[12], v3, &padded_bytes);
          if (!(_DWORD)result)
          {
            padded_bytes = get_padded_bytes(padded_bytes, 8u);
            result = fi_layer_find_weights_via_offset(v2[14], v3, &padded_bytes);
            if (!(_DWORD)result)
            {
              v6 = get_padded_bytes(padded_bytes, 8u);
              padded_bytes = v6;
              if ((_DWORD)v6 == v4)
              {
                return 0;
              }
              else
              {
                log_OutText(*v1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"wavernn weights lentgh error, wanted: %d bytes, but weights file: %d bytes", v7, v8, v9, v6);
                return 7;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t create_conv1d_proj_layer(uint64_t *a1, unsigned int *a2, const void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  int v32;

  v7 = 0;
  result = 7;
  if (!a1 || !a2)
    goto LABEL_19;
  v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v7)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v30);
    result = 10;
    goto LABEL_19;
  }
  v15 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 32);
  v19 = v15;
  if (!v15)
  {
    v24 = *a1;
    v25 = "out of memory!";
LABEL_18:
    log_OutText(v24, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v16, v17, v18, v30);
    *(_QWORD *)(v7 + 120) = v19;
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_proj init param failed!", v27, v28, v29, v30);
    result = 7;
    goto LABEL_19;
  }
  cstdlib_memcpy(v15, a2, 0x10uLL);
  if (!*((_DWORD *)v19 + 1))
  {
    v24 = *a1;
    v25 = "# projection feature1 must be greater than zero!";
    goto LABEL_18;
  }
  if (!*((_DWORD *)v19 + 2))
  {
    v24 = *a1;
    v25 = "# projection feature2 must be greater than zero!";
    goto LABEL_18;
  }
  v32 = 0;
  v30 = 0u;
  v31 = 0u;
  if (config_conv1d_norm_layer(a2[1], *a2, 1, 1, 0, 1, a2[3], &v30))
  {
    v23 = "create conv1d_proj sub-conv1d_norm1 cfg failed!";
LABEL_17:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, v20, v21, v22, v30);
    v24 = *a1;
    v25 = "conv1d_proj network init failed!";
    goto LABEL_18;
  }
  if (create_conv1d_norm_layer(a1, &v30, a3, a4, (uint64_t *)v19 + 2))
  {
    v23 = "create conv1d_proj sub-conv1d_norm1 layer failed!";
    goto LABEL_17;
  }
  v26 = a2[2];
  v32 = 0;
  LODWORD(v31) = v26;
  if (create_conv1d_norm_layer(a1, &v30, a3, a4, (uint64_t *)v19 + 3))
  {
    v23 = "create conv1d_proj sub-conv1d_norm2 layer failed!";
    goto LABEL_17;
  }
  *(_QWORD *)(v7 + 120) = v19;
  if (a3)
    cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
  *(_QWORD *)v7 = a1;
  *(_QWORD *)(v7 + 128) = forward_conv1d_proj_layer;
  *(_QWORD *)(v7 + 136) = free_conv1d_proj_layer;
  *(_QWORD *)(v7 + 144) = conv1d_proj_update_shape;
  *(_QWORD *)(v7 + 152) = conv1d_proj_wanted_wb_len;
  *(_QWORD *)(v7 + 8) = 52;
  *(_QWORD *)(v7 + 184) = conv1d_proj_dispatch_weights;
  *(_QWORD *)(v7 + 160) = conv1d_proj_request_glbBuf;
  *(_QWORD *)(v7 + 168) = conv1d_proj_assign_glbBuf;
  if (a4)
  {
    result = 0;
    *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
    *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v20, v21, v22, v30);
    result = 0;
    *(_QWORD *)(v7 + 256) = 0;
    *(_DWORD *)(v7 + 264) = 0;
  }
LABEL_19:
  *a5 = v7;
  return result;
}

uint64_t forward_conv1d_proj_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  uint64_t v9;
  void *v12;
  uint64_t bytes;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v21;
  size_t __len;

  LODWORD(__len) = 0;
  if (!a2)
    return 0;
  v8 = *(uint64_t **)a2;
  v9 = *(_QWORD *)(a2 + 120);
  if (!v9)
  {
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v21);
    return 7;
  }
  v12 = *(void **)(a2 + 240);
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 16) + 40), &__len);
  if (!(_DWORD)bytes)
  {
    cstdlib_memset(v12, 0, __len);
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 16) + 128))(a1);
    if ((_DWORD)v14)
    {
      bytes = v14;
      v18 = *v8;
      v19 = "conv1d_proj forward sub-conv1d_proj layer 1 failed!";
LABEL_6:
      log_OutText(v18, (uint64_t)"FastInfer", 0, 0, (uint64_t)v19, v15, v16, v17, v21);
      return bytes;
    }
    bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 24) + 40), &__len);
    if (!(_DWORD)bytes)
    {
      cstdlib_memset(a4, 0, __len);
      bytes = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 24) + 128))(a1);
      if ((_DWORD)bytes)
      {
        v18 = *v8;
        v19 = "conv1d_proj forward sub-conv1d_proj layer 2 failed!";
        goto LABEL_6;
      }
    }
  }
  return bytes;
}

_QWORD *free_conv1d_proj_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 16));
        fi_layer_free(*(_QWORD *)(v3 + 24));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t conv1d_proj_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v12;
  const char *v13;
  uint64_t result;
  uint64_t v15;
  const void *v16;
  unsigned int v17;
  uint64_t v18;

  v8 = *(_QWORD *)(a1 + 120);
  v9 = *(uint64_t **)a1;
  if (!v8)
  {
    v12 = *v9;
    v13 = "NULL param!";
    goto LABEL_5;
  }
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 >= 3u)
  {
    v12 = *v9;
    v13 = "Currently conv1d_proj layer only support 1D or 2D input";
LABEL_5:
    log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, v18);
    return 7;
  }
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 16) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 24) + 144))();
    if (!(_DWORD)result)
    {
      v15 = *(_QWORD *)(v8 + 24);
      v17 = *(_DWORD *)(v15 + 40);
      v16 = (const void *)(v15 + 40);
      if (v17 >= 3)
      {
        v12 = *v9;
        v13 = "final output shape error: Currently conv1d_proj only support 1D or 2D output";
        goto LABEL_5;
      }
      cstdlib_memcpy((void *)(a1 + 40), v16, 0x14uLL);
      return 0;
    }
  }
  return result;
}

uint64_t conv1d_proj_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  unsigned int padded_bytes;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 16) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(0, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 24) + 152))();
      if (!(_DWORD)result)
      {
        *a2 = get_padded_bytes(padded_bytes, 8u);
        *a3 = 0;
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"out_feats1: %d\n", v14, v15, v16, *(unsigned int *)(v9 + 4));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"out_feats2: %d\n", v17, v18, v19, *(unsigned int *)(v9 + 8));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v20, v21, v22, *(unsigned int *)(a1 + 96));
        log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v23, v24, v25, *a2);
        return 0;
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v26);
    return 7;
  }
  return result;
}

uint64_t conv1d_proj_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t (*v10)(void);
  uint64_t result;
  unsigned int v12;
  uint64_t (*v13)(void);
  uint64_t v14;
  uint64_t v15;
  int v16;

  v9 = *(_QWORD *)(a1 + 120);
  if (!v9)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v15);
    return 7;
  }
  v10 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 16) + 160);
  if (v10)
  {
    result = v10();
    if ((_DWORD)result)
      return result;
    v12 = *(_DWORD *)(*(_QWORD *)(v9 + 16) + 248);
  }
  else
  {
    v12 = 0;
  }
  v13 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 24) + 160);
  if (v13)
  {
    result = v13();
    if ((_DWORD)result)
      return result;
    if (*(_DWORD *)(*(_QWORD *)(v9 + 24) + 248) > v12)
      v12 = *(_DWORD *)(*(_QWORD *)(v9 + 24) + 248);
  }
  v14 = *(_QWORD *)(a1 + 120);
  v16 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v14 + 16) + 40), &v16);
  if (!(_DWORD)result)
    *(_DWORD *)(a1 + 248) = v16 + v12;
  return result;
}

uint64_t conv1d_proj_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 16), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 24), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t conv1d_proj_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(void);
  uint64_t v14;
  void (*v15)(void);
  uint64_t v16;
  unsigned int v17;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    v17 = 0;
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 16) + 40), &v17);
    if (!(_DWORD)result)
    {
      v11 = v17;
      v12 = *(_QWORD *)(v9 + 16);
      *(_QWORD *)(v12 + 240) = *(_QWORD *)(a1 + 240) + v17;
      v13 = *(void (**)(void))(v12 + 168);
      if (v13)
        v13();
      v14 = *(_QWORD *)(v9 + 24);
      *(_QWORD *)(v14 + 240) = *(_QWORD *)(a1 + 240) + v11;
      v15 = *(void (**)(void))(v14 + 168);
      if (v15)
        v15();
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v16);
    return 7;
  }
  return result;
}

uint64_t conv1d_proj_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t config_conv1d_proj_layer(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  *a5 = a1;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return 0;
}

uint64_t create_mrf_layer(uint64_t *a1, unsigned int *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  const char *v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t __b;
  int v47;
  _OWORD v48[2];
  unsigned int v49;

  v6 = 0;
  result = 7;
  if (a1 && a2)
  {
    v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v6)
    {
      v13 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 144);
      v17 = v13;
      if (!v13)
      {
        v33 = *a1;
        v34 = "out of memory!";
LABEL_37:
        log_OutText(v33, (uint64_t)"FastInfer", 0, 0, (uint64_t)v34, v14, v15, v16, v38);
        *(_QWORD *)(v6 + 120) = v17;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"MRF init param failed!", v35, v36, v37, v39);
        result = 7;
        goto LABEL_38;
      }
      cstdlib_memcpy(v13, a2, 0x78uLL);
      v49 = 0;
      memset(v48, 0, sizeof(v48));
      v47 = 0;
      v45 = 0;
      __b = 0;
      v18 = *a2;
      v19 = a2[4];
      cstdlib_memset(&__b, 0, 0xCuLL);
      v20 = a2[17];
      LODWORD(__b) = 5;
      HIDWORD(__b) = v20;
      v47 = 0;
      cstdlib_memset(&v45, 0, 8uLL);
      v45 = 0x100000000;
      v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 12, 8);
      v17[15] = v21;
      if (!v21
        || (v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 12, 8),
            (v17[16] = v25) == 0))
      {
        v32 = "out of memory!";
LABEL_36:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v32, v22, v23, v24, v38);
        v33 = *a1;
        v34 = "MRF network init failed!";
        goto LABEL_37;
      }
      v41 = a4;
      config_conv1d_layer(a2[17], 1, 1, 1, 1, 1, a2[18], v48);
      if ((_DWORD)v18)
      {
        v43 = 0;
        v44 = 0;
        v40 = (v19 - 1);
        v42 = v19;
        while (!(_DWORD)v19)
        {
LABEL_27:
          ++v43;
          v44 += 4;
          LODWORD(v19) = v42;
          if (v43 == v18)
            goto LABEL_28;
        }
        v26 = v44;
        v27 = v42;
        v28 = v40;
        while (1)
        {
          v29 = a2[v26 + 5];
          LODWORD(v48[0]) = a2[v43 + 1];
          DWORD2(v48[0]) = v29;
          if (a2[20] != 1)
          {
            if (v28 || (v30 = a2[21]) != 0)
            {
              if (a2[22] == 1)
                v30 = 0;
              else
                v30 = a2[18];
            }
            v49 = v30;
          }
          if (create_conv1d_layer(a1, v48, 0, a3, (uint64_t ***)(v17[15] + 8 * v26)))
          {
            a4 = v41;
            v32 = "create MRF sub-conv1d layer failed!";
            goto LABEL_36;
          }
          if (a2[20] == 1)
          {
            if (v28 || (v31 = a2[21]) != 0)
            {
              if (a2[22] == 1)
                v31 = 0;
              else
                v31 = a2[18];
            }
            LODWORD(v45) = v31;
            if (create_fc_layer(a1, &__b, &v45, 0, a3, (uint64_t *)(v17[16] + 8 * v26)))
              break;
          }
          --v28;
          ++v26;
          if (!--v27)
            goto LABEL_27;
        }
        v32 = "create MRF sub-fc layer failed!";
        goto LABEL_35;
      }
LABEL_28:
      LODWORD(v45) = 0;
      if (create_fc_layer(a1, &__b, &v45, 0, a3, v17 + 17))
      {
        v32 = "create MRF sub-residual fc layer failed!";
LABEL_35:
        a4 = v41;
        goto LABEL_36;
      }
      *(_QWORD *)v6 = a1;
      *(_QWORD *)(v6 + 8) = 70;
      *(_QWORD *)(v6 + 120) = v17;
      *(_QWORD *)(v6 + 128) = forward_mrf_layer;
      *(_QWORD *)(v6 + 136) = free_mrf_layer;
      *(_QWORD *)(v6 + 144) = mrf_layer_update_shape;
      *(_QWORD *)(v6 + 152) = mrf_layer_wanted_wb_len;
      *(_QWORD *)(v6 + 160) = mrf_layer_request_glbBuf;
      *(_QWORD *)(v6 + 184) = mrf_layer_dispatch_weights;
      *(_QWORD *)(v6 + 168) = mrf_layer_assign_glbBuf;
      a4 = v41;
      if (a3)
      {
        result = 0;
        *(_QWORD *)(v6 + 256) = *(_QWORD *)(a3 + 24);
        *(_DWORD *)(v6 + 264) = *(_DWORD *)(a3 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v22, v23, v24, v38);
        result = 0;
        *(_QWORD *)(v6 + 256) = 0;
        *(_DWORD *)(v6 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v38);
      result = 10;
    }
  }
LABEL_38:
  *a4 = v6;
  return result;
}

uint64_t forward_mrf_layer(uint64_t a1, uint64_t a2, void *a3, float *a4)
{
  int *v7;
  uint64_t *v8;
  int *v9;
  int v10;
  uint64_t v11;
  uint64_t bytes;
  float *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  float *v21;
  float *v22;
  float *v23;
  uint64_t v24;
  float *v25;
  float *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float *v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  float *v35;
  unint64_t v36;
  uint64_t v37;
  const char *v38;
  unint64_t v40;
  float *v41;
  float *v42;
  unsigned int v43;
  uint64_t v44;
  float *v45;
  float *v46;
  unint64_t v47;
  float *v48;
  float *v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t *v55;
  float *v56;
  float *v57;
  float *v58;
  unsigned int v59;
  float *v60;
  void *v61;
  char *v62;
  uint64_t v63;
  unsigned int __len;
  unsigned int __len_4;

  v7 = *(int **)(a2 + 120);
  v8 = *(uint64_t **)a2;
  v9 = (int *)(a2 + 40);
  if (v7[22] != 1)
  {
    __len_4 = 0;
    v33 = *v7;
    v34 = v7[4];
    bytes = fi_shape_get_bytes(v9, &__len_4);
    if ((_DWORD)bytes)
      return bytes;
    cstdlib_memset(a4, 0, __len_4);
    v35 = *(float **)(a2 + 240);
    v36 = __len_4;
    if (v7[19] == 1)
    {
      cstdlib_memcpy(v35, a3, __len_4);
      fi_activate_array(v35, __len_4 >> 2, 14);
    }
    v15 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v7 + 17) + 128))(0);
    if ((_DWORD)v15)
      goto LABEL_34;
    v63 = v34;
    v55 = v8;
    v52 = v33;
    if (!v33)
    {
LABEL_58:
      v32 = __len_4;
      goto LABEL_59;
    }
    v59 = 0;
    v54 = 0;
    v40 = v36 >> 2;
    v41 = &v35[v36 >> 2];
    v57 = a4;
    v61 = a3;
    while (1)
    {
      v42 = (float *)a3;
      if ((_DWORD)v63)
        break;
LABEL_57:
      a4 = v57;
      axpy(__len_4 >> 2, v42, 1, v57, 1, 1.0);
      v59 += 4;
      ++v54;
      a3 = v61;
      if (v54 == v52)
        goto LABEL_58;
    }
    v43 = v59;
    v44 = v63;
    v45 = (float *)v61;
    v46 = v35;
    while (1)
    {
      v29 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)v7 + 15) + 8 * v43) + 128))(0);
      if ((_DWORD)v29)
        goto LABEL_60;
      if (v7[20] != 1)
        break;
      if (v45 == v41)
        v47 = v40;
      else
        v47 = 0;
      v48 = &v41[v47];
      v30 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)v7 + 16) + 8 * v43) + 128))(0);
      if ((_DWORD)v30)
      {
LABEL_61:
        bytes = v30;
        v37 = *v55;
        v38 = "MRF forward sub-fc layer failed!";
        goto LABEL_35;
      }
      if (!v7[23])
      {
        v46 = v48;
        v49 = v35;
LABEL_55:
        v48 = v45;
        goto LABEL_56;
      }
      axpy(__len_4 >> 2, v45, 1, v48, 1, 1.0);
      v46 = v48;
      v49 = v35;
LABEL_56:
      v42 = v46;
      ++v43;
      v45 = v48;
      v46 = v49;
      if (!--v44)
        goto LABEL_57;
    }
    if (v7[23])
    {
      axpy(__len_4 >> 2, v45, 1, v46, 1, 1.0);
      v45 = v46;
    }
    if (v46 == v35)
      v49 = v41;
    else
      v49 = v35;
    goto LABEL_55;
  }
  __len = 0;
  v10 = *v7;
  v11 = v7[4];
  bytes = fi_shape_get_bytes(v9, &__len);
  if (!(_DWORD)bytes)
  {
    cstdlib_memset(a4, 0, __len);
    v13 = *(float **)(a2 + 240);
    v14 = __len;
    cstdlib_memcpy(v13, a3, __len);
    fi_activate_array(v13, __len >> 2, v7[18]);
    v15 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v7 + 17) + 128))(0);
    if (!(_DWORD)v15)
    {
      v60 = (float *)a3;
      v55 = v8;
      if (v10)
      {
        v19 = 0;
        v51 = v10;
        v53 = 0;
        v20 = v14 & 0xFFFFFFFC;
        v21 = (float *)((char *)v13 + v20);
        v22 = (float *)((char *)v13 + v20 + v20);
        v62 = (char *)v22 + v20;
        v56 = a4;
        v58 = v13;
        while (1)
        {
          v23 = v13;
          if ((_DWORD)v11)
            break;
LABEL_28:
          a4 = v56;
          axpy(__len >> 2, v23, 1, v56, 1, 1.0);
          v19 += 4;
          ++v53;
          v13 = v58;
          if (v53 == v51)
            goto LABEL_29;
        }
        v24 = 0;
        v25 = v21;
        v23 = v58;
        v26 = v60;
        while (1)
        {
          if (v24)
          {
            if (v26 == v22)
              v27 = v62;
            else
              v27 = v22;
            cstdlib_memcpy(v27, v23, __len);
            fi_activate_array((float *)v27, __len >> 2, v7[18]);
          }
          v28 = (v19 + v24);
          v29 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)v7 + 15) + 8 * v28) + 128))(0);
          if ((_DWORD)v29)
            break;
          if (v7[20] == 1)
          {
            if (v26 == v22)
              v25 = (float *)v62;
            else
              v25 = v22;
            v30 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)v7 + 16) + 8 * v28) + 128))(0);
            if ((_DWORD)v30)
              goto LABEL_61;
            if (v7[23])
            {
              axpy(__len >> 2, v26, 1, v25, 1, 1.0);
              v26 = v25;
            }
            v31 = v21;
          }
          else
          {
            if (v7[23])
            {
              axpy(__len >> 2, v26, 1, v25, 1, 1.0);
              v26 = v25;
            }
            if (v25 == v21)
              v31 = v22;
            else
              v31 = v21;
          }
          v23 = v25;
          ++v24;
          v25 = v31;
          if (v11 == v24)
            goto LABEL_28;
        }
LABEL_60:
        bytes = v29;
        v37 = *v55;
        v38 = "MRF forward sub-conv layer failed!";
        goto LABEL_35;
      }
LABEL_29:
      v32 = __len;
LABEL_59:
      fi_activate_array(a4, v32 >> 2, v7[18]);
      return 0;
    }
LABEL_34:
    bytes = v15;
    v37 = *v8;
    v38 = "MRF forward residual fc layer failed!";
LABEL_35:
    log_OutText(v37, (uint64_t)"FastInfer", 0, 0, (uint64_t)v38, v16, v17, v18, v50);
  }
  return bytes;
}

_QWORD *free_mrf_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  int *v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (int *)result[15];
      if (v3)
      {
        v4 = *v3;
        if (*v3)
        {
          v5 = 0;
          v6 = 0;
          LODWORD(v7) = v3[4];
          do
          {
            if ((_DWORD)v7)
            {
              v8 = 0;
              do
              {
                fi_layer_free(*(_QWORD *)(*((_QWORD *)v3 + 15) + 8 * (v5 + v8)));
                fi_layer_free(*(_QWORD *)(*((_QWORD *)v3 + 16) + 8 * (v5 + v8++)));
                v7 = v3[4];
              }
              while (v8 < v7);
              v4 = *v3;
            }
            ++v6;
            v5 += 4;
          }
          while (v6 < v4);
        }
        fi_layer_free(*((_QWORD *)v3 + 17));
        if (*((_QWORD *)v3 + 15))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *((_QWORD *)v3 + 15) = 0;
        }
        if (*((_QWORD *)v3 + 16))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *((_QWORD *)v3 + 16) = 0;
        }
        (*(void (**)(_QWORD, int *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t mrf_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t result;
  uint64_t v18;

  if (*a2 == 2)
  {
    v10 = *(int **)(a1 + 120);
    v11 = *v10;
    v12 = v10[4];
    cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
    if (v11)
    {
      v13 = 0;
      v14 = 0;
      while (!(_DWORD)v12)
      {
LABEL_10:
        ++v14;
        v13 += 4;
        if (v14 == v11)
          goto LABEL_11;
      }
      v15 = v12;
      v16 = v13;
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v10 + 15) + 8 * v16) + 144))();
        if ((_DWORD)result)
          break;
        if (v10[20] == 1)
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v10 + 16) + 8 * v16) + 144))();
          if ((_DWORD)result)
            break;
        }
        ++v16;
        if (!--v15)
          goto LABEL_10;
      }
    }
    else
    {
LABEL_11:
      result = (*(uint64_t (**)(void))(*((_QWORD *)v10 + 17) + 144))();
      if (!(_DWORD)result)
      {
        cstdlib_memcpy((void *)(a1 + 40), a2, 0x14uLL);
        return 0;
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently MRF layer only support 2D input", a6, a7, a8, v18);
    return 7;
  }
  return result;
}

uint64_t mrf_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int *v4;
  int v5;
  unsigned int v7;
  int v8;
  unsigned int padded_bytes;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v4 = *(int **)(a1 + 120);
  v5 = *v4;
  if (*v4)
  {
    v7 = 0;
    v8 = 0;
    padded_bytes = 0;
    v10 = v4[4];
    while (!(_DWORD)v10)
    {
LABEL_10:
      ++v8;
      v7 += 4;
      if (v8 == v5)
        goto LABEL_13;
    }
    v11 = v10;
    v12 = v7;
    while (1)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v4 + 15) + 8 * v12) + 152))();
      if ((_DWORD)result)
        break;
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      if (v4[20] == 1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v4 + 16) + 8 * v12) + 152))();
        if ((_DWORD)result)
          return result;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
      }
      ++v12;
      if (!--v11)
        goto LABEL_10;
    }
  }
  else
  {
    padded_bytes = 0;
LABEL_13:
    result = (*(uint64_t (**)(void))(*((_QWORD *)v4 + 17) + 152))();
    if (!(_DWORD)result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"num_kernels: %d\n", v14, v15, v16, *v4 % 0x64u);
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v17, v18, v19, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v20, v21, v22, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t mrf_layer_request_glbBuf(uint64_t a1)
{
  int *v2;
  int v3;
  uint64_t v4;
  uint64_t result;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t (*v13)(void);
  uint64_t (*v14)(void);
  uint64_t (*v15)(void);
  int v16;

  v2 = *(int **)(a1 + 120);
  v16 = 0;
  v3 = *v2;
  v4 = v2[4];
  result = mrf_layer_get_reserved_glbBuf_bytes(a1, &v16);
  if (!(_DWORD)result)
  {
    v6 = v16;
    if (v3)
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      do
      {
        if ((_DWORD)v4)
        {
          v10 = v4;
          v11 = v7;
          do
          {
            v12 = v11;
            v13 = *(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v2 + 15) + 8 * v11) + 160);
            if (v13)
            {
              result = v13();
              if ((_DWORD)result)
                return result;
              if (*(_DWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 15) + 8 * v12) + 248) > v9)
                v9 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 15) + 8 * v12) + 248);
            }
            if (v2[20] == 1)
            {
              v14 = *(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v2 + 16) + 8 * v12) + 160);
              if (v14)
              {
                result = v14();
                if ((_DWORD)result)
                  return result;
                if (*(_DWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 16) + 8 * v12) + 248) > v9)
                  v9 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v2 + 16) + 8 * v12) + 248);
              }
            }
            v11 = v12 + 1;
            --v10;
          }
          while (v10);
        }
        ++v8;
        v7 += 4;
      }
      while (v8 != v3);
    }
    else
    {
      v9 = 0;
    }
    v15 = *(uint64_t (**)(void))(*((_QWORD *)v2 + 17) + 160);
    if (v15)
    {
      result = v15();
      if ((_DWORD)result)
        return result;
      if (*(_DWORD *)(*((_QWORD *)v2 + 17) + 248) > v9)
        v9 = *(_DWORD *)(*((_QWORD *)v2 + 17) + 248);
    }
    result = 0;
    *(_DWORD *)(a1 + 248) = v9 + v6;
  }
  return result;
}

uint64_t mrf_layer_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int padded_bytes;

  v8 = *(int **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  v10 = *(_QWORD *)(a1 + 72);
  padded_bytes = 0;
  v11 = *v8;
  if (*v8)
  {
    v12 = 0;
    v13 = 0;
    v14 = v8[4];
    while (!(_DWORD)v14)
    {
LABEL_12:
      ++v13;
      v12 += 4;
      if (v13 == v11)
        goto LABEL_13;
    }
    v15 = v14;
    v16 = v12;
    while (1)
    {
      v17 = *(_QWORD *)(*((_QWORD *)v8 + 15) + 8 * v16);
      if (!v17)
        goto LABEL_16;
      result = fi_layer_find_weights_via_offset(v17, v10, &padded_bytes);
      if ((_DWORD)result)
        return result;
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      if (v8[20] == 1)
      {
        v19 = *(_QWORD *)(*((_QWORD *)v8 + 16) + 8 * v16);
        if (!v19)
          goto LABEL_16;
        result = fi_layer_find_weights_via_offset(v19, v10, &padded_bytes);
        if ((_DWORD)result)
          return result;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
      }
      ++v16;
      if (!--v15)
        goto LABEL_12;
    }
  }
LABEL_13:
  v20 = *((_QWORD *)v8 + 17);
  if (!v20)
  {
LABEL_16:
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"mrf: a sublayer is not initialized!", a6, a7, a8, v21);
    return 10;
  }
  result = fi_layer_find_weights_via_offset(v20, v10, &padded_bytes);
  if (!(_DWORD)result)
  {
    get_padded_bytes(padded_bytes, 8u);
    return 0;
  }
  return result;
}

uint64_t mrf_layer_assign_glbBuf(uint64_t a1)
{
  int *v2;
  int v3;
  uint64_t v4;
  uint64_t reserved_glbBuf_bytes;
  uint64_t v6;
  unsigned int v7;
  int i;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  void (*v12)(void);
  uint64_t v13;
  void (*v14)(void);
  uint64_t v15;
  void (*v16)(void);
  unsigned int v18;

  v2 = *(int **)(a1 + 120);
  v18 = 0;
  v3 = *v2;
  v4 = v2[4];
  reserved_glbBuf_bytes = mrf_layer_get_reserved_glbBuf_bytes(a1, (int *)&v18);
  if (!(_DWORD)reserved_glbBuf_bytes)
  {
    v6 = v18;
    if (v3)
    {
      v7 = 0;
      for (i = 0; i != v3; ++i)
      {
        if ((_DWORD)v4)
        {
          v9 = v4;
          v10 = v7;
          do
          {
            v11 = *(_QWORD *)(*((_QWORD *)v2 + 15) + 8 * v10);
            *(_QWORD *)(v11 + 240) = *(_QWORD *)(a1 + 240) + v6;
            v12 = *(void (**)(void))(v11 + 168);
            if (v12)
              v12();
            if (v2[20] == 1)
            {
              v13 = *(_QWORD *)(*((_QWORD *)v2 + 16) + 8 * v10);
              *(_QWORD *)(v13 + 240) = *(_QWORD *)(a1 + 240) + v6;
              v14 = *(void (**)(void))(v13 + 168);
              if (v14)
                v14();
            }
            ++v10;
            --v9;
          }
          while (v9);
        }
        v7 += 4;
      }
    }
    v15 = *((_QWORD *)v2 + 17);
    *(_QWORD *)(v15 + 240) = *(_QWORD *)(a1 + 240) + v6;
    v16 = *(void (**)(void))(v15 + 168);
    if (v16)
      v16();
  }
  return reserved_glbBuf_bytes;
}

uint64_t mrf_layer_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t mrf_layer_get_reserved_glbBuf_bytes(uint64_t a1, int *a2)
{
  uint64_t v3;
  uint64_t result;
  int v5;
  int v6;

  v3 = *(_QWORD *)(a1 + 120);
  v6 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v3 + 136) + 40), &v6);
  if (!(_DWORD)result)
  {
    v5 = 4 * v6;
    if (*(_DWORD *)(v3 + 88) != 1)
      v5 = 3 * v6;
    *a2 = v5;
  }
  return result;
}

uint64_t create_cbhg_layer(uint64_t *a1, void *a2, const void *a3, uint64_t a4, uint64_t ***a5)
{
  uint64_t **v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  int v21;
  int v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 88);
      v19 = v15;
      if (!v15)
      {
        v23 = "out of memory!";
        goto LABEL_27;
      }
      cstdlib_memcpy(v15, a2, 0x24uLL);
      v20 = *((_DWORD *)v19 + 6);
      v21 = *((_DWORD *)v19 + 3);
      v22 = *((_DWORD *)v19 + 4);
      if (v21 == v20)
      {
        if (v22)
        {
LABEL_7:
          v23 = "usage of pre-highway layer mismatch!";
LABEL_27:
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, v16, v17, v18, v27);
          v7[15] = v19;
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"cbhg init param failed!", v24, v25, v26, v28);
          result = 7;
          goto LABEL_28;
        }
      }
      else if (!v22)
      {
        goto LABEL_7;
      }
      if (!*((_DWORD *)v19 + 1))
      {
        v23 = "cb_feats must be greater than zero!";
        goto LABEL_27;
      }
      if (!*((_DWORD *)v19 + 2))
      {
        v23 = "cp_feats1 must be greater than zero!";
        goto LABEL_27;
      }
      if (!v21)
      {
        v23 = "cp_feats2 must be greater than zero!";
        goto LABEL_27;
      }
      if (!*((_DWORD *)v19 + 7))
      {
        v23 = "gru_feats must be greater than zero!";
        goto LABEL_27;
      }
      if (!v20)
      {
        v23 = "hw_feats must be greater than zero!";
        goto LABEL_27;
      }
      if (!*(_DWORD *)v19)
      {
        v23 = "num_cb must be greater than zero!";
        goto LABEL_27;
      }
      if (!*((_DWORD *)v19 + 5))
      {
        v23 = "num_hw must be greater than zero!";
        goto LABEL_27;
      }
      if (init_network(a1, (uint64_t)(v19 + 5), (int *)a2, a3, a4))
      {
        v23 = "cbhg network init failed!";
        goto LABEL_27;
      }
      v7[15] = v19;
      if (a3)
        cstdlib_memcpy((char *)v7 + 60, a3, 8uLL);
      result = 0;
      *v7 = a1;
      v7[16] = (uint64_t *)forward_cbhg_layer;
      v7[17] = (uint64_t *)free_cbhg_layer;
      v7[18] = (uint64_t *)cbhg_update_shape;
      v7[19] = (uint64_t *)cbhg_wanted_wb_len;
      v7[20] = (uint64_t *)cbhg_request_glbBuf;
      v7[21] = (uint64_t *)cbhg_assign_glbBuf;
      v7[22] = (uint64_t *)cbhg_reset;
      v7[23] = (uint64_t *)cbhg_dispatch_weights;
      v7[1] = (uint64_t *)55;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v27);
      result = 10;
    }
  }
LABEL_28:
  *a5 = v7;
  return result;
}

uint64_t forward_cbhg_layer(uint64_t a1, uint64_t a2, float *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v9;
  uint64_t v10;
  char *v14;
  uint64_t bytes;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  size_t __len;

  __len = 0;
  HIDWORD(v29) = 0;
  if (!a2)
    return 0;
  v9 = *(uint64_t **)a2;
  v10 = *(_QWORD *)(a2 + 120);
  if (!v10)
  {
    v22 = *v9;
    v23 = "config empty";
LABEL_9:
    log_OutText(v22, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, a6, a7, a8, v29);
    return 7;
  }
  v14 = *(char **)(a2 + 240);
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v10 + 40) + 40), (_DWORD *)&__len + 1);
  if ((_DWORD)bytes)
    return bytes;
  cstdlib_memset(v14, 0, HIDWORD(__len));
  v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 40) + 128))(a1);
  if ((_DWORD)v16)
  {
    bytes = v16;
    v20 = *v9;
    v21 = "cbhg forward conv1d bank failed!";
LABEL_6:
    log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v17, v18, v19, v29);
    return bytes;
  }
  max_array_f32(((*(_DWORD *)(*(_QWORD *)(v10 + 48) + 24) - 1) * *(_DWORD *)(*(_QWORD *)(v10 + 48) + 28)), (float *)v14, (float *)&v14[4 * *(unsigned int *)(*(_QWORD *)(v10 + 48) + 28)]);
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v10 + 56) + 40), (_DWORD *)&__len + 1);
  if ((_DWORD)bytes)
    return bytes;
  cstdlib_memset(a4, 0, HIDWORD(__len));
  v25 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 56) + 128))(a1);
  if ((_DWORD)v25)
  {
    bytes = v25;
    v20 = *v9;
    v21 = "cbhg forward conv1d projection failed!";
    goto LABEL_6;
  }
  if (fi_shape_is_same((unsigned int *)(a2 + 20), (_DWORD *)(*(_QWORD *)(v10 + 56) + 40)) != 1)
  {
    v22 = *v9;
    v23 = "cbhg residual add size mismatch!";
    goto LABEL_9;
  }
  bytes = fi_shape_get_size((int *)(a2 + 20), (int *)&v29 + 1);
  if (!(_DWORD)bytes)
  {
    axpy(HIDWORD(v29), a3, 1, (float *)a4, 1, 1.0);
    bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v10 + 72) + 40), &__len);
    if (!(_DWORD)bytes)
    {
      if (*(_DWORD *)(v10 + 16) == 1)
      {
        v26 = __len;
        bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v10 + 64) + 40), (_DWORD *)&__len + 1);
        if ((_DWORD)bytes)
          return bytes;
        cstdlib_memset(&v14[v26 & 0xFFFFFFFC], 0, HIDWORD(__len));
        v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 64) + 128))(a1);
        if ((_DWORD)v27)
        {
          bytes = v27;
          v20 = *v9;
          v21 = "cbhg forward pre-highway failed!";
          goto LABEL_6;
        }
      }
      cstdlib_memset(v14, 0, __len);
      v28 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 72) + 128))(a1);
      if ((_DWORD)v28)
      {
        bytes = v28;
        v20 = *v9;
        v21 = "cbhg forward highway failed!";
        goto LABEL_6;
      }
      bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v10 + 80) + 40), (_DWORD *)&__len + 1);
      if (!(_DWORD)bytes)
      {
        cstdlib_memset(a4, 0, HIDWORD(__len));
        bytes = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 80) + 128))(a1);
        if ((_DWORD)bytes)
        {
          v20 = *v9;
          v21 = "cbhg forward bgru failed!";
          goto LABEL_6;
        }
      }
    }
  }
  return bytes;
}

_QWORD *free_cbhg_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 40));
        fi_layer_free(*(_QWORD *)(v3 + 48));
        fi_layer_free(*(_QWORD *)(v3 + 56));
        if (*(_DWORD *)(v3 + 16) == 1)
          fi_layer_free(*(_QWORD *)(v3 + 64));
        fi_layer_free(*(_QWORD *)(v3 + 72));
        fi_layer_free(*(_QWORD *)(v3 + 80));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t cbhg_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v12;
  const char *v13;
  uint64_t result;
  uint64_t v15;
  const void *v16;
  unsigned int v17;
  uint64_t v18;

  v8 = *(_QWORD *)(a1 + 120);
  v9 = *(uint64_t **)a1;
  if (!v8)
  {
    v12 = *v9;
    v13 = "NULL param!";
    goto LABEL_5;
  }
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 >= 3u)
  {
    v12 = *v9;
    v13 = "Currently cbhg layer only support 1D or 2D input";
LABEL_5:
    log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, v18);
    return 7;
  }
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 40) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 48) + 144))();
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 56) + 144))();
      if (!(_DWORD)result)
      {
        if (*(_DWORD *)(v8 + 16) != 1
          || (result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 64) + 144))(), !(_DWORD)result))
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 72) + 144))();
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 80) + 144))();
            if (!(_DWORD)result)
            {
              v15 = *(_QWORD *)(v8 + 80);
              v17 = *(_DWORD *)(v15 + 40);
              v16 = (const void *)(v15 + 40);
              if (v17 >= 3)
              {
                v12 = *v9;
                v13 = "final output shape error: Currently cbhg only support 1D or 2D output";
                goto LABEL_5;
              }
              cstdlib_memcpy((void *)(a1 + 40), v16, 0x14uLL);
              return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t cbhg_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  unsigned int padded_bytes;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 40) + 152))();
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(0, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 56) + 152))();
      if (!(_DWORD)result)
      {
        v14 = get_padded_bytes(padded_bytes, 8u);
        if (*(_DWORD *)(v9 + 16) == 1)
        {
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 64) + 152))();
          if ((_DWORD)result)
            return result;
          v14 = get_padded_bytes(v14, 8u);
        }
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 72) + 152))();
        if (!(_DWORD)result)
        {
          v15 = get_padded_bytes(v14, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v9 + 80) + 152))();
          if (!(_DWORD)result)
          {
            *a2 = get_padded_bytes(v15, 8u);
            *a3 = 0;
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"cb_feats: %d\n", v16, v17, v18, *(unsigned int *)(v9 + 4));
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"cp_feats2: %d\n", v19, v20, v21, *(unsigned int *)(v9 + 12));
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v22, v23, v24, *(unsigned int *)(a1 + 96));
            log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v25, v26, v27, *a2);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v28);
    return 7;
  }
  return result;
}

uint64_t cbhg_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t (*v10)(void);
  uint64_t result;
  unsigned int v12;
  uint64_t (*v13)(void);
  uint64_t (*v14)(void);
  uint64_t (*v15)(void);
  uint64_t (*v16)(void);
  uint64_t v17;
  uint64_t v18;
  int v19;

  v9 = *(_QWORD *)(a1 + 120);
  if (!v9)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v18);
    return 7;
  }
  v10 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 40) + 160);
  if (v10)
  {
    result = v10();
    if ((_DWORD)result)
      return result;
    v12 = *(_DWORD *)(*(_QWORD *)(v9 + 40) + 248);
  }
  else
  {
    v12 = 0;
  }
  v13 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 56) + 160);
  if (v13)
  {
    result = v13();
    if ((_DWORD)result)
      return result;
    if (*(_DWORD *)(*(_QWORD *)(v9 + 56) + 248) > v12)
      v12 = *(_DWORD *)(*(_QWORD *)(v9 + 56) + 248);
  }
  if (*(_DWORD *)(v9 + 16) == 1)
  {
    v14 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 64) + 160);
    if (v14)
    {
      result = v14();
      if ((_DWORD)result)
        return result;
      if (*(_DWORD *)(*(_QWORD *)(v9 + 64) + 248) > v12)
        v12 = *(_DWORD *)(*(_QWORD *)(v9 + 64) + 248);
    }
  }
  v15 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 72) + 160);
  if (v15)
  {
    result = v15();
    if ((_DWORD)result)
      return result;
    if (*(_DWORD *)(*(_QWORD *)(v9 + 72) + 248) > v12)
      v12 = *(_DWORD *)(*(_QWORD *)(v9 + 72) + 248);
  }
  v16 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 80) + 160);
  if (v16)
  {
    result = v16();
    if ((_DWORD)result)
      return result;
    if (*(_DWORD *)(*(_QWORD *)(v9 + 80) + 248) > v12)
      v12 = *(_DWORD *)(*(_QWORD *)(v9 + 80) + 248);
  }
  v17 = *(_QWORD *)(a1 + 120);
  v19 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v17 + 40) + 40), &v19);
  if (!(_DWORD)result)
    *(_DWORD *)(a1 + 248) = v19 + v12;
  return result;
}

uint64_t cbhg_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 72);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 40), v9, &padded_bytes);
    if (!(_DWORD)result)
    {
      padded_bytes = get_padded_bytes(padded_bytes, 8u);
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 56), v9, &padded_bytes);
      if (!(_DWORD)result)
      {
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        if (*(_DWORD *)(v8 + 16) == 1)
        {
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 64), v9, &padded_bytes);
          if ((_DWORD)result)
            return result;
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
        }
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 72), v9, &padded_bytes);
        if (!(_DWORD)result)
        {
          padded_bytes = get_padded_bytes(padded_bytes, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v8 + 80), v9, &padded_bytes);
          if (!(_DWORD)result)
          {
            get_padded_bytes(padded_bytes, 8u);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t cbhg_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(void);
  uint64_t v14;
  void (*v15)(void);
  uint64_t v16;
  void (*v17)(void);
  uint64_t v18;
  void (*v19)(void);
  uint64_t v20;
  void (*v21)(void);
  uint64_t v22;
  unsigned int v23;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    v23 = 0;
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 40) + 40), &v23);
    if (!(_DWORD)result)
    {
      v11 = v23;
      v12 = *(_QWORD *)(v9 + 40);
      *(_QWORD *)(v12 + 240) = *(_QWORD *)(a1 + 240) + v23;
      v13 = *(void (**)(void))(v12 + 168);
      if (v13)
        v13();
      v14 = *(_QWORD *)(v9 + 56);
      *(_QWORD *)(v14 + 240) = *(_QWORD *)(a1 + 240) + v11;
      v15 = *(void (**)(void))(v14 + 168);
      if (v15)
        v15();
      if (*(_DWORD *)(v9 + 16) == 1)
      {
        v16 = *(_QWORD *)(v9 + 64);
        *(_QWORD *)(v16 + 240) = *(_QWORD *)(a1 + 240) + v11;
        v17 = *(void (**)(void))(v16 + 168);
        if (v17)
          v17();
      }
      v18 = *(_QWORD *)(v9 + 72);
      *(_QWORD *)(v18 + 240) = *(_QWORD *)(a1 + 240) + v11;
      v19 = *(void (**)(void))(v18 + 168);
      if (v19)
        v19();
      v20 = *(_QWORD *)(v9 + 80);
      *(_QWORD *)(v20 + 240) = *(_QWORD *)(a1 + 240) + v11;
      v21 = *(void (**)(void))(v20 + 168);
      if (v21)
        v21();
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v22);
    return 7;
  }
  return result;
}

uint64_t cbhg_reset(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 80);
  if (v1 && (v2 = *(uint64_t (**)(void))(v1 + 176)) != 0)
    return v2();
  else
    return 0;
}

uint64_t cbhg_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t config_cbhg_layer(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, _DWORD *a10)
{
  a10[2] = a3;
  a10[3] = a4;
  a10[7] = a8;
  a10[8] = a9;
  a10[5] = a6;
  a10[6] = a7;
  *a10 = a1;
  a10[1] = a2;
  a10[4] = a5;
  return 0;
}

uint64_t init_network(uint64_t *a1, uint64_t a2, int *a3, const void *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t conv1d_bank;
  uint64_t v35;
  uint64_t pooling1d_layer;
  uint64_t v37;
  uint64_t conv1d_proj_layer;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t highways;
  int v43;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;

  v47 = 0;
  v46 = 0;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8);
  if (!v10)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v11, v12, v13, v45);
    return 10;
  }
  v14 = (unsigned int *)v10;
  v50 = 0;
  v48 = 0;
  v49 = 0;
  v18 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v18)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v45);
    v22 = 0;
LABEL_10:
    v26 = 0;
LABEL_11:
    v31 = 10;
    goto LABEL_33;
  }
  v22 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 36);
  if (!v22)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v19, v20, v21, v45);
    goto LABEL_10;
  }
  v26 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 20);
  if (!v26)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v23, v24, v25, v45);
    goto LABEL_11;
  }
  v27 = config_conv1d_bank_layer(*a3, a3[1], v14);
  if ((_DWORD)v27)
  {
    v31 = v27;
    v32 = *a1;
    v33 = "create cbhg: conv1d_bank cfg failed!";
LABEL_32:
    log_OutText(v32, (uint64_t)"FastInfer", 0, 0, (uint64_t)v33, v28, v29, v30, v45);
    goto LABEL_33;
  }
  conv1d_bank = create_conv1d_bank(a1, v14, a4, a5, (uint64_t *)a2);
  if ((_DWORD)conv1d_bank)
  {
    v31 = conv1d_bank;
    v32 = *a1;
    v33 = "create cbhg: conv1d_bank layer failed!";
    goto LABEL_32;
  }
  v35 = config_pooling1d_layer(2, 1, 1, 1, v22);
  if ((_DWORD)v35)
  {
    v31 = v35;
    v32 = *a1;
    v33 = "create cbhg: maxpooling cfg failed!";
    goto LABEL_32;
  }
  pooling1d_layer = create_pooling1d_layer(a1, 10, v22, a4, (uint64_t ***)(a2 + 8));
  if ((_DWORD)pooling1d_layer)
  {
    v31 = pooling1d_layer;
    v32 = *a1;
    v33 = "create cbhg: maxpooling layer failed!";
    goto LABEL_32;
  }
  v37 = config_conv1d_proj_layer(3, a3[2], a3[3], 3, v18);
  if ((_DWORD)v37)
  {
    v31 = v37;
    v32 = *a1;
    v33 = "create cbhg: conv1d_proj cfg failed!";
    goto LABEL_32;
  }
  conv1d_proj_layer = create_conv1d_proj_layer(a1, v18, a4, a5, (uint64_t *)(a2 + 16));
  if ((_DWORD)conv1d_proj_layer)
  {
    v31 = conv1d_proj_layer;
    v32 = *a1;
    v33 = "create cbhg: conv1d_proj layer failed!";
    goto LABEL_32;
  }
  if (a3[4] == 1)
  {
    v39 = a3[6];
    LODWORD(v49) = 5;
    HIDWORD(v49) = v39;
    v50 = 0;
    v48 = 0;
    v40 = create_fc_layer(a1, &v49, &v48, a4, a5, (uint64_t *)(a2 + 24));
    if ((_DWORD)v40)
    {
      v31 = v40;
      v32 = *a1;
      v33 = "create cbhg: pre highway layer failed!";
      goto LABEL_32;
    }
  }
  v41 = config_highways_layer(a3[5], a3[6], 3, &v46);
  if ((_DWORD)v41)
  {
    v31 = v41;
    v32 = *a1;
    v33 = "create cbhg: highways cfg failed!";
    goto LABEL_32;
  }
  highways = create_highways(a1, (int *)&v46, a4, a5, (uint64_t *)(a2 + 32));
  if ((_DWORD)highways)
  {
    v31 = highways;
    v32 = *a1;
    v33 = "create cbhg: highways layer failed!";
    goto LABEL_32;
  }
  v43 = a3[7];
  LODWORD(v49) = 24;
  HIDWORD(v49) = v43;
  v50 = 0;
  *(_OWORD *)(v26 + 4) = xmmword_214FAEE30;
  *(_DWORD *)v26 = a3[8];
  v31 = create_bgru_layer(a1, &v49, v26, a4, a5, (uint64_t *)(a2 + 40));
  if ((_DWORD)v31)
  {
    v32 = *a1;
    v33 = "create cbhg: bgru layer failed!";
    goto LABEL_32;
  }
LABEL_33:
  (*(void (**)(uint64_t, unsigned int *))(a1[1] + 48))(a1[2], v14);
  if (v18)
    (*(void (**)(uint64_t, unsigned int *))(a1[1] + 48))(a1[2], v18);
  if (v22)
    (*(void (**)(uint64_t, _DWORD *))(a1[1] + 48))(a1[2], v22);
  if (v26)
    (*(void (**)(uint64_t, char *))(a1[1] + 48))(a1[2], v26);
  return v31;
}

uint64_t config_conv1d_bank_layer(int a1, int a2, _DWORD *a3)
{
  *a3 = a1;
  a3[1] = a2;
  return 0;
}

uint64_t create_conv1d_bank(uint64_t *a1, unsigned int *a2, const void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  int *v28;
  int v29;
  uint64_t v30;
  int *v31;
  int v32;
  uint64_t v33;
  char v34;
  char v35;
  uint64_t v36;
  int *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _OWORD v44[2];
  int v45;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
      v19 = v15;
      if (!v15)
      {
        v20 = *a1;
        v21 = "out of memory!";
        goto LABEL_44;
      }
      cstdlib_memcpy(v15, a2, 8uLL);
      if (*(_DWORD *)v19 >= 0xC9u)
      {
        v20 = *a1;
        v21 = "number of conv1d_norm exploded!";
LABEL_44:
        log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v16, v17, v18, *(uint64_t *)&v44[0]);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_bank init param failed!", v41, v42, v43, *(uint64_t *)&v44[0]);
        result = 7;
        goto LABEL_45;
      }
      if (!*(_DWORD *)v19)
      {
        v20 = *a1;
        v21 = "number of conv1d_norm must be greater than zero!";
        goto LABEL_44;
      }
      v45 = 0;
      memset(v44, 0, sizeof(v44));
      v22 = *a2 % 0x64;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v22, 8);
      v19[1] = v23;
      if (!v23)
      {
        v25 = *a1;
        v26 = "out of memory!";
LABEL_42:
        log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v16, v17, v18, *(uint64_t *)&v44[0]);
LABEL_43:
        v20 = *a1;
        v21 = "conv1d_bank network init failed!";
        goto LABEL_44;
      }
      v24 = config_conv1d_norm_layer(a2[1], 1, 1, 1, 0, 1, 3, v44);
      switch((int)v22)
      {
        case 0:
          if (v24)
            goto LABEL_43;
          goto LABEL_37;
        case 1:
        case 3:
        case 4:
        case 6:
        case 7:
          goto LABEL_34;
        case 2:
          v33 = 0;
          v34 = 1;
          while (1)
          {
            v35 = v34;
            LODWORD(v44[0]) = dword_214FAEE90[v33];
            if (create_conv1d_norm_layer(a1, v44, a3, a4, (uint64_t *)(v19[1] + 8 * v33)))
              goto LABEL_41;
            v34 = 0;
            v33 = 1;
            if ((v35 & 1) == 0)
              goto LABEL_37;
          }
        case 5:
          v30 = 0;
          v31 = &dword_214FAEEE4;
          while (1)
          {
            v32 = *v31++;
            LODWORD(v44[0]) = v32;
            if (create_conv1d_norm_layer(a1, v44, a3, a4, (uint64_t *)(v19[1] + v30)))
              goto LABEL_41;
            v30 += 8;
            if (v30 == 40)
              goto LABEL_37;
          }
        case 8:
          if (*a2 != 108)
            goto LABEL_34;
          v36 = 0;
          v37 = &dword_214FAEF28;
          break;
        default:
          if ((_DWORD)v22 == 12)
          {
            v27 = 0;
            v28 = &dword_214FAEEF8;
            do
            {
              v29 = *v28++;
              LODWORD(v44[0]) = v29;
              if (create_conv1d_norm_layer(a1, v44, a3, a4, (uint64_t *)(v19[1] + v27)))
                goto LABEL_41;
              v27 += 8;
            }
            while (v27 != 96);
          }
          else
          {
LABEL_34:
            v39 = 0;
            v40 = 0;
            do
            {
              LODWORD(v44[0]) = ++v40;
              if (create_conv1d_norm_layer(a1, v44, a3, a4, (uint64_t *)(v19[1] + v39)))
                goto LABEL_41;
              v39 += 8;
            }
            while (v22 != v40);
          }
          goto LABEL_37;
      }
      do
      {
        v38 = *v37++;
        LODWORD(v44[0]) = v38;
        if (create_conv1d_norm_layer(a1, v44, a3, a4, (uint64_t *)(v19[1] + v36)))
        {
LABEL_41:
          v25 = *a1;
          v26 = "create conv1d_bank sub-conv1d_norm layer failed!";
          goto LABEL_42;
        }
        v36 += 8;
      }
      while (v36 != 64);
LABEL_37:
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_conv1d_bank;
      *(_QWORD *)(v7 + 136) = free_conv1d_bank;
      *(_QWORD *)(v7 + 144) = conv1d_bank_update_shape;
      *(_QWORD *)(v7 + 152) = conv1d_bank_wanted_wb_len;
      *(_QWORD *)(v7 + 8) = 51;
      *(_QWORD *)(v7 + 184) = conv1d_bank_dispatch_weights;
      *(_QWORD *)(v7 + 160) = conv1d_bank_request_glbBuf;
      *(_QWORD *)(v7 + 168) = conv1d_bank_assign_glbBuf;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v16, v17, v18, *(uint64_t *)&v44[0]);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, *(uint64_t *)&v44[0]);
      result = 10;
    }
  }
LABEL_45:
  *a5 = v7;
  return result;
}

uint64_t forward_conv1d_bank(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  int *v9;
  uint64_t v11;
  unsigned int v12;
  uint64_t bytes;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  size_t __len;

  LODWORD(__len) = 0;
  if (!a2)
    return 0;
  v8 = *(uint64_t **)a2;
  v9 = *(int **)(a2 + 120);
  if (!v9)
  {
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v25);
    return 7;
  }
  v11 = *(_QWORD *)(a2 + 240);
  v12 = *v9;
  bytes = fi_shape_get_bytes((int *)(a2 + 40), &__len);
  if (!(_DWORD)bytes)
  {
    cstdlib_memset(a4, 0, __len);
    v27 = v12 % 0x64;
    if ((_DWORD)v27)
    {
      v26 = a4;
      v14 = 0;
      while (1)
      {
        v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)v9 + 1) + 8 * v14) + 128))(a1);
        if ((_DWORD)v15)
          break;
        v19 = *(_QWORD *)(*((_QWORD *)v9 + 1) + 8 * v14);
        v20 = *(unsigned int *)(v19 + 44);
        if ((_DWORD)v20)
        {
          v21 = 0;
          v22 = 0;
          v23 = *(unsigned int *)(v19 + 48);
          do
          {
            cstdlib_memcpy(&v26[4 * (v23 * v14) + 4 * v21], (const void *)(v11 + 4 * v22), 4 * v23);
            v22 += v23;
            v21 += v27 * v23;
            --v20;
          }
          while (v20);
        }
        if (++v14 == v27)
          return 0;
      }
      bytes = v15;
      log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_bank forward sub-conv1d_bank layer failed!", v16, v17, v18, (uint64_t)v8);
      return bytes;
    }
    return 0;
  }
  return bytes;
}

_QWORD *free_conv1d_bank(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        v4 = *(_DWORD *)v3 % 0x64u;
        if ((_DWORD)v4)
        {
          for (i = 0; i != v4; ++i)
            fi_layer_free(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * i));
        }
        if (*(_QWORD *)(v3 + 8))
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          *(_QWORD *)(v3 + 8) = 0;
        }
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t conv1d_bank_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t *v9;
  unsigned int v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;

  v8 = *(int **)(a1 + 120);
  v9 = *(uint64_t **)a1;
  if (!v8)
  {
    v13 = *v9;
    v14 = "NULL param!";
    goto LABEL_11;
  }
  v12 = *v8;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 > 2u)
  {
    v13 = *v9;
    v14 = "Currently conv1d_bank layer only support 1D or 2D input";
LABEL_11:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v20);
    return 7;
  }
  v15 = v12 % 0x64;
  if (!(_DWORD)v15)
  {
LABEL_9:
    v18 = *((_QWORD *)v8 + 1);
    v19 = *(_DWORD *)(*(_QWORD *)v18 + 40);
    if (v19 < 3)
    {
      cstdlib_memcpy((void *)(a1 + 40), (const void *)(*(_QWORD *)v18 + 40), 0x14uLL);
      result = 0;
      *(_DWORD *)(a1 + 4 * (v19 - 1) + 44) *= (_DWORD)v15;
      return result;
    }
    v13 = *v9;
    v14 = "final output shape error: Currently conv1d_bank only support 1D or 2D output";
    goto LABEL_11;
  }
  v16 = 0;
  while (1)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v8 + 1) + 8 * v16) + 144))();
    if ((_DWORD)result)
      return result;
    if (v15 == ++v16)
      goto LABEL_9;
  }
}

uint64_t conv1d_bank_wanted_wb_len(uint64_t a1, unsigned int *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v12;
  uint64_t v13;
  unsigned int padded_bytes;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    v12 = *(_DWORD *)v9 % 0x64u;
    if ((_DWORD)v12)
    {
      v13 = 0;
      padded_bytes = 0;
      while (1)
      {
        result = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(v9 + 8) + 8 * v13) + 152))();
        if ((_DWORD)result)
          break;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        if (v12 == ++v13)
          goto LABEL_9;
      }
    }
    else
    {
      padded_bytes = 0;
LABEL_9:
      *a2 = padded_bytes;
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"num_conv1d_norm: %d\n", a6, a7, a8, *(_DWORD *)v9 % 0x64u);
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v16, v17, v18, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v19, v20, v21, *a2);
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param is NULL!", a6, a7, a8, v22);
    return 7;
  }
  return result;
}

uint64_t conv1d_bank_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  unsigned int v10;
  uint64_t result;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t (*v17)(void);
  uint64_t v18;
  int v19;

  v9 = *(int **)(a1 + 120);
  if (v9)
  {
    v10 = *v9;
    v19 = 0;
    result = fi_shape_get_bytes((int *)(**((_QWORD **)v9 + 1) + 40), &v19);
    if (!(_DWORD)result)
    {
      v12 = v10 % 0x64;
      v13 = v19;
      if ((_DWORD)v12)
      {
        v14 = 0;
        v15 = 0;
        v16 = *((_QWORD *)v9 + 1);
        do
        {
          v17 = *(uint64_t (**)(void))(*(_QWORD *)(v16 + 8 * v14) + 160);
          if (v17)
          {
            result = v17();
            if ((_DWORD)result)
              return result;
            v16 = *((_QWORD *)v9 + 1);
            if (*(_DWORD *)(*(_QWORD *)(v16 + 8 * v14) + 248) > v15)
              v15 = *(_DWORD *)(*(_QWORD *)(v16 + 8 * v14) + 248);
          }
          ++v14;
        }
        while (v12 != v14);
      }
      else
      {
        v15 = 0;
      }
      result = 0;
      *(_DWORD *)(a1 + 248) = v15 + v13;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v18);
    return 7;
  }
  return result;
}

uint64_t conv1d_bank_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v8 = *(_QWORD *)(a1 + 120);
  if (v8)
  {
    v9 = *(_DWORD *)v8 % 0x64u;
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = *(_QWORD *)(a1 + 72);
      while (1)
      {
        v12 = *(_QWORD *)(*(_QWORD *)(v8 + 8) + 8 * v10);
        if (!v12)
          break;
        result = fi_layer_find_weights_via_offset(v12, v11, &padded_bytes);
        if ((_DWORD)result)
          return result;
        padded_bytes = get_padded_bytes(padded_bytes, 8u);
        if (v9 == ++v10)
          return 0;
      }
      return 10;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v14);
    return 7;
  }
}

uint64_t conv1d_bank_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(void);
  uint64_t v16;
  unsigned int v17;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    v17 = 0;
    result = fi_shape_get_bytes((int *)(**(_QWORD **)(v9 + 8) + 40), &v17);
    if (!(_DWORD)result)
    {
      v11 = *(_DWORD *)v9 % 0x64u;
      if ((_DWORD)v11)
      {
        v12 = 0;
        v13 = v17;
        do
        {
          v14 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 8 * v12);
          *(_QWORD *)(v14 + 240) = *(_QWORD *)(a1 + 240) + v13;
          v15 = *(void (**)(void))(v14 + 168);
          if (v15)
            v15();
          ++v12;
        }
        while (v11 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v16);
    return 7;
  }
  return result;
}

uint64_t conv1d_bank_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

uint64_t conv1d_norm_dispatch_weights(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  unsigned int padded_bytes;

  padded_bytes = 0;
  v1 = *(_QWORD *)(a1 + 120);
  v2 = *(_QWORD *)(a1 + 72);
  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v1 + 40), v2, &padded_bytes);
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(padded_bytes, 8u);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v1 + 48), v2, &padded_bytes);
    if (!(_DWORD)result)
    {
      get_padded_bytes(padded_bytes, 8u);
      return 0;
    }
  }
  return result;
}

_QWORD *free_conv1d_norm_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 40));
        fi_layer_free(*(_QWORD *)(v3 + 48));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_conv1d_norm_layer(uint64_t *a1, const void *a2, const void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t ***v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t ***v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _OWORD v29[2];
  int v30;
  int v31;
  uint64_t v32;

  v7 = 0;
  result = 7;
  if (a1 && a2)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      v15 = (uint64_t ***)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 56);
      v19 = v15;
      if (!v15)
      {
        v24 = *a1;
        v25 = "out of memory!";
LABEL_12:
        log_OutText(v24, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v16, v17, v18, *(uint64_t *)&v29[0]);
        *(_QWORD *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_norm init param failed!", v26, v27, v28, *(uint64_t *)&v29[0]);
        result = 7;
        goto LABEL_13;
      }
      cstdlib_memcpy(v15, a2, 0x24uLL);
      v32 = 0;
      v30 = 0;
      memset(v29, 0, sizeof(v29));
      cstdlib_memcpy(v29, a2, 0x24uLL);
      v30 = 0;
      if (create_conv1d_layer(a1, v29, a3, a4, v19 + 5))
      {
        v23 = "create conv1d_norm conv1d layer failed!";
LABEL_11:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, v20, v21, v22, *(uint64_t *)&v29[0]);
        v24 = *a1;
        v25 = "conv1d_norm network init failed!";
        goto LABEL_12;
      }
      v31 = 22;
      if (create_norm_layer(a1, &v31, v19 + 6))
      {
        v23 = "create conv1d_norm norm layer failed!";
        goto LABEL_11;
      }
      *(_QWORD *)(v7 + 120) = v19;
      if (a3)
        cstdlib_memcpy((void *)(v7 + 60), a3, 8uLL);
      *(_QWORD *)v7 = a1;
      *(_QWORD *)(v7 + 128) = forward_conv1d_norm_layer;
      *(_QWORD *)(v7 + 136) = free_conv1d_norm_layer;
      *(_QWORD *)(v7 + 144) = conv1d_norm_layer_update_shape;
      *(_QWORD *)(v7 + 152) = conv1d_norm_layer_wanted_wb_len;
      *(_QWORD *)(v7 + 8) = 50;
      *(_QWORD *)(v7 + 184) = conv1d_norm_dispatch_weights;
      *(_QWORD *)(v7 + 160) = conv1d_norm_request_glbBuf;
      *(_QWORD *)(v7 + 168) = conv1d_norm_assign_glbBuf;
      if (a4)
      {
        result = 0;
        *(_QWORD *)(v7 + 256) = *(_QWORD *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v20, v21, v22, *(uint64_t *)&v29[0]);
        result = 0;
        *(_QWORD *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, *(uint64_t *)&v29[0]);
      result = 10;
    }
  }
LABEL_13:
  *a5 = v7;
  return result;
}

uint64_t forward_conv1d_norm_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t *v7;
  uint64_t v8;
  void *v9;
  uint64_t bytes;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  size_t __len;

  LODWORD(__len) = 0;
  if (!a2)
    return 0;
  v20 = 0;
  v7 = *(uint64_t **)a2;
  v8 = *(_QWORD *)(a2 + 120);
  v9 = *(void **)(a2 + 240);
  bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v8 + 40) + 40), &__len);
  if (!(_DWORD)bytes)
  {
    cstdlib_memset(v9, 0, __len);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v8 + 40) + 128))(a1);
    if ((_DWORD)v11)
    {
      bytes = v11;
      v15 = *v7;
      v16 = "conv1d_norm forward conv1d layer failed!";
LABEL_5:
      log_OutText(v15, (uint64_t)"FastInfer", 0, 0, (uint64_t)v16, v12, v13, v14, v19);
      return bytes;
    }
    bytes = fi_shape_get_bytes((int *)(*(_QWORD *)(v8 + 48) + 40), &__len);
    if ((_DWORD)bytes)
      return bytes;
    cstdlib_memset(a4, 0, __len);
    v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v8 + 48) + 128))(a1);
    if ((_DWORD)v18)
    {
      bytes = v18;
      v15 = *v7;
      v16 = "conv1d_norm forward norm layer failed!";
      goto LABEL_5;
    }
    bytes = fi_shape_get_size((int *)(a2 + 40), (int *)&v20);
    if (!(_DWORD)bytes)
      fi_activate_array((float *)a4, v20, *(_DWORD *)(v8 + 32));
  }
  return bytes;
}

uint64_t conv1d_norm_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t result;
  uint64_t v12;
  const void *v13;
  int v14;
  uint64_t v15;

  v4 = *(_QWORD *)(a1 + 120);
  v5 = *(uint64_t **)a1;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  if (*a2 >= 3u)
  {
    v9 = *v5;
    v10 = "Currently conv1d_norm layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v10, v6, v7, v8, v15);
    return 7;
  }
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 40) + 144))();
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 48) + 144))();
    if (!(_DWORD)result)
    {
      v12 = *(_QWORD *)(v4 + 48);
      v14 = *(_DWORD *)(v12 + 40);
      v13 = (const void *)(v12 + 40);
      if ((v14 - 1) >= 2)
      {
        v9 = **(_QWORD **)a1;
        v10 = "dense out: output shape error";
        goto LABEL_3;
      }
      cstdlib_memcpy((void *)(a1 + 40), v13, 0x14uLL);
      return 0;
    }
  }
  return result;
}

uint64_t conv1d_norm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6;
  uint64_t result;
  unsigned int padded_bytes;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = *(_QWORD *)(a1 + 120);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v6 + 40) + 152))();
  if (!(_DWORD)result)
  {
    padded_bytes = get_padded_bytes(0, 8u);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v6 + 48) + 152))();
    if (!(_DWORD)result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v9, v10, v11, *(unsigned int *)(a1 + 96));
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v12, v13, v14, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t conv1d_norm_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  int v4;
  uint64_t (*v5)(void);
  int v6;

  v2 = *(_QWORD *)(a1 + 120);
  v6 = 0;
  result = fi_shape_get_bytes((int *)(*(_QWORD *)(v2 + 40) + 40), &v6);
  if (!(_DWORD)result)
  {
    v4 = v6;
    v5 = *(uint64_t (**)(void))(*(_QWORD *)(v2 + 40) + 160);
    if (v5)
    {
      result = v5();
      if ((_DWORD)result)
        return result;
      v4 += *(_DWORD *)(*(_QWORD *)(v2 + 40) + 248);
    }
    result = 0;
    *(_DWORD *)(a1 + 248) = v4;
  }
  return result;
}

uint64_t conv1d_norm_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  void (*v12)(void);
  uint64_t v13;
  unsigned int v14;

  v9 = *(_QWORD *)(a1 + 120);
  if (v9)
  {
    v14 = 0;
    result = fi_shape_get_bytes((int *)(*(_QWORD *)(v9 + 40) + 40), &v14);
    if (!(_DWORD)result)
    {
      v11 = *(_QWORD *)(v9 + 40);
      *(_QWORD *)(v11 + 240) = *(_QWORD *)(a1 + 240) + v14;
      v12 = *(void (**)(void))(v11 + 168);
      if (v12)
        v12();
      return 0;
    }
  }
  else
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v13);
    return 7;
  }
  return result;
}

uint64_t conv1d_norm_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

_QWORD *free_tacodecoder_layer(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(_QWORD *)(v3 + 88));
        fi_layer_free(*(_QWORD *)(v3 + 96));
        fi_layer_free(*(_QWORD *)(v3 + 104));
        fi_layer_free(*(_QWORD *)(v3 + 120));
        fi_layer_free(*(_QWORD *)(v3 + 184));
        if (!*(_DWORD *)(v3 + 28))
        {
          fi_layer_free(*(_QWORD *)(v3 + 112));
          if (*(_DWORD *)(v3 + 16))
          {
            fi_layer_free(*(_QWORD *)(v3 + 168));
            fi_layer_free(*(_QWORD *)(v3 + 176));
          }
          if (*(_DWORD *)(v3 + 20))
            fi_layer_free(*(_QWORD *)(v3 + 192));
        }
        fi_layer_free(*(_QWORD *)(v3 + 128));
        fi_layer_free(*(_QWORD *)(v3 + 136));
        fi_layer_free(*(_QWORD *)(v3 + 144));
        fi_layer_free(*(_QWORD *)(v3 + 152));
        fi_layer_free(*(_QWORD *)(v3 + 160));
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9])
        {
          (*(void (**)(_QWORD))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16));
          v1[9] = 0;
        }
        cstdlib_memset(v1 + 9, 0, 0x30uLL);
      }
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)(v2 + 8) + 48))(*(_QWORD *)(v2 + 16), v1);
    }
  }
  return result;
}

uint64_t create_tacodecoder_layer(uint64_t *a1, _DWORD *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t result;
  uint64_t v23;
  const char *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  int v37;
  uint64_t v38[3];
  uint64_t v39;
  uint64_t __b;
  int v41;
  _OWORD v42[2];
  int v43;
  uint64_t v44;
  uint64_t v45;
  int v46;

  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11)
  {
    v12 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 200);
    v16 = v12;
    if (!v12)
    {
      v23 = *a1;
      v24 = "out of memory!";
LABEL_18:
      log_OutText(v23, (uint64_t)"FastInfer", 0, 0, (uint64_t)v24, v13, v14, v15, v38[0]);
      *(_QWORD *)(v11 + 120) = v16;
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Taoctron decoder layer param init failed!", v26, v27, v28, v38[0]);
      result = 7;
      goto LABEL_19;
    }
    cstdlib_memcpy(v12, a2, 0x58uLL);
    v41 = 0;
    v39 = 0x100000003;
    __b = 0;
    memset(v38, 0, 20);
    cstdlib_memset(&__b, 0, 0xCuLL);
    v17 = a2[12];
    LODWORD(__b) = 5;
    HIDWORD(__b) = v17;
    v41 = 0;
    if (create_fc_layer(a1, &__b, &v39, 0, a3, (uint64_t *)v16 + 11))
    {
      v21 = "create tacoDecoder preNet o1 layer failed!";
LABEL_17:
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v18, v19, v20, v38[0]);
      v23 = *a1;
      v24 = "Tacotron decoder layer init failed!";
      goto LABEL_18;
    }
    HIDWORD(__b) = a2[13];
    v39 = 0x100000003;
    if (create_fc_layer(a1, &__b, &v39, 0, a3, (uint64_t *)v16 + 12))
    {
      v21 = "create tacoDecoder preNet o2 layer failed!";
      goto LABEL_17;
    }
    HIDWORD(__b) = a2[16];
    v39 = 0x100000000;
    if (create_fc_layer(a1, &__b, &v39, 0, a3, (uint64_t *)v16 + 16))
    {
LABEL_16:
      v21 = "create tacoDecoder Decoder pre-dense layer failed!";
      goto LABEL_17;
    }
    HIDWORD(__b) = *a2 * a2[1];
    v25 = a2[6];
    if (v25 == 2)
    {
      v25 = 3;
    }
    else if (v25 != 1)
    {
LABEL_15:
      HIDWORD(v39) = 1;
      if (create_fc_layer(a1, &__b, &v39, 0, a3, (uint64_t *)v16 + 17))
        goto LABEL_16;
      cstdlib_memset(&__b, 0, 0xCuLL);
      v29 = a2[14];
      LODWORD(__b) = 23;
      HIDWORD(__b) = v29;
      v41 = 0;
      LODWORD(v38[0]) = a2[21];
      *(uint64_t *)((char *)v38 + 4) = *(_QWORD *)(a2 + 17);
      *(uint64_t *)((char *)&v38[1] + 4) = 0x100000001;
      if (create_gru_layer(a1, (unsigned int *)&__b, v38, 0, a3, (uint64_t ***)v16 + 18))
      {
        v21 = "create tacodecoder attention-GRU layer failed!";
        goto LABEL_17;
      }
      v30 = a2[15];
      LODWORD(__b) = 23;
      HIDWORD(__b) = v30;
      *(uint64_t *)((char *)v38 + 4) = *(_QWORD *)(a2 + 19);
      if (create_gru_layer(a1, (unsigned int *)&__b, v38, 0, a3, (uint64_t ***)v16 + 19))
      {
        v21 = "create tacodecoder deocder-GRU-1 layer failed!";
        goto LABEL_17;
      }
      v31 = a2[15];
      LODWORD(__b) = 23;
      HIDWORD(__b) = v31;
      *(uint64_t *)((char *)v38 + 4) = *(_QWORD *)(a2 + 19);
      if (create_gru_layer(a1, (unsigned int *)&__b, v38, 0, a3, (uint64_t ***)v16 + 20))
      {
        v21 = "create tacodecoder deocder-GRU-2 layer failed!";
        goto LABEL_17;
      }
      v46 = 0;
      v44 = 0;
      v45 = 0;
      v43 = 0;
      memset(v42, 0, sizeof(v42));
      v32 = a2[7];
      if (v32)
      {
        HIDWORD(v45) = 3 * v32;
        v46 = 0;
        LODWORD(v45) = 5;
        v44 = 0x100000000;
        if (!create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)v16 + 13))
        {
          HIDWORD(v45) = a2[2];
          v46 = 0;
          LODWORD(v45) = 5;
          v44 = 0x100000002;
          if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)v16 + 15))
          {
LABEL_29:
            v36 = "create tacodecoder Attention query dense layer failed!";
LABEL_32:
            log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v36, v33, v34, v35, v38[0]);
            v21 = "init attention network failed!";
            goto LABEL_17;
          }
          *((_QWORD *)v16 + 14) = 0;
          *((_QWORD *)v16 + 24) = 0;
          *((_QWORD *)v16 + 21) = 0;
          *((_QWORD *)v16 + 22) = 0;
LABEL_36:
          v39 = 0x100000001;
          __b = 0x100000005;
          result = create_fc_layer(a1, &__b, &v39, 0, a3, (uint64_t *)v16 + 23);
          if (!(_DWORD)result)
          {
            *(_QWORD *)v11 = a1;
            *(_QWORD *)(v11 + 8) = 62;
            *(_QWORD *)(v11 + 120) = v16;
            *(_QWORD *)(v11 + 128) = forward_tacodecoder_layer;
            *(_QWORD *)(v11 + 136) = free_tacodecoder_layer;
            *(_QWORD *)(v11 + 144) = tacodecoder_layer_update_shape;
            *(_QWORD *)(v11 + 152) = tacodecoder_layer_wanted_wb_len;
            *(_QWORD *)(v11 + 160) = tacodecoder_request_glbBuf;
            *(_QWORD *)(v11 + 256) = *(_QWORD *)(a3 + 24);
            *(_DWORD *)(v11 + 264) = *(_DWORD *)(a3 + 16);
            *(_QWORD *)(v11 + 168) = tacodecoder_assign_glbBuf;
            *(_QWORD *)(v11 + 176) = tacodecoder_layer_reset;
            *(_QWORD *)(v11 + 184) = tacodecoder_dispatch_weights;
            *(_QWORD *)(v11 + 200) = tacodecoder_layer_load_state;
            *(_QWORD *)(v11 + 208) = tacodecoder_layer_save_state;
            *(_QWORD *)(v11 + 216) = tacodecoder_layer_sizeof_state;
            goto LABEL_19;
          }
          v21 = "create tacoDecoder stop dense layer failed!";
          goto LABEL_17;
        }
      }
      else
      {
        v44 = 0x100000000;
        v45 = 0x100000005;
        v46 = 0;
        if (!create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)v16 + 13))
        {
          HIDWORD(v45) = a2[2];
          v46 = 0;
          LODWORD(v45) = 5;
          v44 = 0;
          if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)v16 + 14))
          {
            v36 = "create tacodecoder Attention key dense layer failed!";
            goto LABEL_32;
          }
          HIDWORD(v45) = a2[2];
          v46 = 0;
          LODWORD(v45) = 5;
          v44 = 0;
          if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)v16 + 15))
            goto LABEL_29;
          if (a2[4])
          {
            cstdlib_memset(&v45, 0, 0xCuLL);
            v37 = a2[2];
            LODWORD(v45) = 5;
            HIDWORD(v45) = v37;
            v46 = 0;
            v44 = 0;
            if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)v16 + 22))
            {
              v36 = "create tacodecoder Attention location module dense layer failed!";
              goto LABEL_32;
            }
            if (config_conv1d_layer(a2[8], a2[9], 1, a2[10], 0, 1, 0, v42)
              || create_conv1d_layer(a1, v42, 0, a3, (uint64_t ***)v16 + 21))
            {
              v36 = "create tacodecoder Attention location module conv1d config failed!";
              goto LABEL_32;
            }
          }
          else
          {
            *((_QWORD *)v16 + 21) = 0;
            *((_QWORD *)v16 + 22) = 0;
          }
          if (a2[5])
          {
            cstdlib_memset(&v45, 0, 0xCuLL);
            v46 = 0;
            v44 = 0x100000001;
            v45 = 0x100000005;
            if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)v16 + 24))
            {
              v36 = "create tacodecoder Forward Attention agent dense layer failed!";
              goto LABEL_32;
            }
          }
          goto LABEL_36;
        }
      }
      v36 = "create tacodecoder Attention v dense layer failed!";
      goto LABEL_32;
    }
    LODWORD(v39) = v25;
    goto LABEL_15;
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v38[0]);
  result = 10;
LABEL_19:
  *a4 = v11;
  return result;
}

uint64_t forward_tacodecoder_layer(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t step;
  unsigned int *v8;
  uint64_t *v9;
  void *v10;
  unsigned int padded_len;
  void *v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  void *v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unsigned int v28;
  char *v29;
  void *v30;
  unsigned int v31;
  void *v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  void *v39;
  void *v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  float *v49;
  uint64_t v50;
  const void *v52;
  const void *v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  unsigned int v60;
  int v61;
  unsigned int v62;
  uint64_t v63;
  char *v64;
  unsigned int v65;
  char *v66;
  unsigned int v67;
  void *v68;
  unsigned int v69;
  uint64_t v70;
  void *v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  void *v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  int v85;
  uint64_t v86;
  char *v87;
  void *v88;
  void *v89;
  float *v90;
  void *v91;
  uint64_t v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  void *v98[2];
  __int128 v99;
  __int128 v100;
  __int128 __dst;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;

  v105 = 0u;
  v104 = 0u;
  v103 = 0u;
  v102 = 0u;
  __dst = 0u;
  v100 = 0u;
  v99 = 0u;
  *(_OWORD *)v98 = 0u;
  v97 = 0u;
  v96 = 0u;
  v95 = 0u;
  v94 = 0u;
  v93 = 0u;
  step = fi_shape_get_step((_DWORD *)(a2 + 20));
  v8 = *(unsigned int **)(a2 + 120);
  v9 = *(uint64_t **)a2;
  pack_tacodecoder_internal_buffer(a2, &v92);
  v92 = a3;
  v10 = (void *)v96;
  padded_len = get_padded_len(v8[12], 8u);
  cstdlib_memset(v10, 0, 4 * padded_len);
  if (v8[7] && !v8[5])
  {
    v13 = v8[1];
    v14 = v13 != 0;
    v15 = v13 - 1;
    if (v14)
      v16 = v15;
    else
      v16 = 0;
    v12 = (void *)*((_QWORD *)&v93 + 1);
    if (v8[6] == 3)
      relu_array_f32(*v8, (float *)(*((_QWORD *)&v93 + 1) + 4 * *v8 * v16));
  }
  else
  {
    v12 = (void *)*((_QWORD *)&v93 + 1);
    if (v8[6] == 3)
      relu_array_f32(*v8 * v8[1], *((float **)&v93 + 1));
  }
  v20 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 11) + 128))(0);
  if ((_DWORD)v20)
  {
    v21 = *v9;
    v22 = "Tacotron decoder PreNet o1 dense forward failed!";
    goto LABEL_35;
  }
  v23 = (void *)*((_QWORD *)&v96 + 1);
  v24 = get_padded_len(v8[13], 8u);
  cstdlib_memset(v23, 0, 4 * v24);
  v25 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 12) + 128))(0);
  if ((_DWORD)v25)
  {
    v20 = v25;
    v21 = *v9;
    v22 = "Tacotron decoder PreNet o2 dense forward failed!";
    goto LABEL_35;
  }
  v26 = v8[7];
  if (!(_DWORD)v26)
  {
    if (v9)
    {
      v39 = (void *)v93;
      if (*(float *)v93 != 0.0)
        goto LABEL_28;
      if (v8[5])
        *(_DWORD *)v103 = 1056964608;
      v40 = (void *)*((_QWORD *)&v105 + 1);
      v41 = get_padded_len(v8[2] * step, 8u);
      cstdlib_memset(v40, 0, 4 * v41);
      v42 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 14) + 128))(0);
      if (!(_DWORD)v42)
      {
LABEL_28:
        v47 = additive_attention(v9, (_QWORD *)v8 + 11, step, v8, (uint64_t)&v92);
        if ((_DWORD)v47)
        {
          v20 = v47;
          v21 = *v9;
          v22 = "Tacotron Forward Attention Module forward failed!";
          goto LABEL_35;
        }
        v89 = v39;
        v52 = (const void *)*((_QWORD *)&v97 + 1);
        v53 = (const void *)v94;
        goto LABEL_45;
      }
      v20 = v42;
      log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron decoder Key dense forward failed!", v43, v44, v45, v86);
    }
    else
    {
      v20 = 7;
    }
    v21 = *v9;
    v22 = "Tacotron decoder first timestep key forward failed!";
    goto LABEL_35;
  }
  v87 = (char *)*((_QWORD *)&v104 + 1);
  v88 = (void *)v105;
  v89 = (void *)v93;
  v90 = (float *)v104;
  if (*(float *)v93 == 0.0)
    cstdlib_memset(*((void **)&v103 + 1), 0, 4 * v26);
  v27 = (char *)v97;
  v28 = get_padded_len(v8[13], 8u);
  cstdlib_memcpy(v27, v23, 4 * v28);
  v29 = &v27[4 * v8[13]];
  v30 = (void *)v94;
  v31 = get_padded_len(v8[3], 8u);
  cstdlib_memcpy(v29, v30, 4 * v31);
  v32 = (void *)*((_QWORD *)&v97 + 1);
  v33 = get_padded_len(v8[14], 8u);
  cstdlib_memset(v32, 0, 4 * v33);
  v34 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 18) + 128))(0);
  if ((_DWORD)v34)
  {
    v20 = v34;
    v38 = "Tacotron attention rnn forward failed!";
LABEL_34:
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v38, v35, v36, v37, v86);
    v21 = *v9;
    v22 = "Tacotron GMM Attention Module forward failed!";
    goto LABEL_35;
  }
  cstdlib_memset(v98[1], 0, 4 * v8[2]);
  v46 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 15) + 128))(0);
  if ((_DWORD)v46)
  {
    v20 = v46;
    v38 = "Tacotron decoder query dense forward failed!";
    goto LABEL_34;
  }
  v86 = (uint64_t)v32;
  v48 = get_padded_len(3 * v8[7], 8u);
  v49 = v90;
  cstdlib_memset(v90, 0, 4 * v48);
  v50 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 13) + 128))(0);
  if ((_DWORD)v50)
  {
    v20 = v50;
    v38 = "Tacotron attention vec_v dense forward failed!";
    goto LABEL_34;
  }
  if ((_DWORD)v26 != get_padded_len(v26, 8u))
  {
    v54 = get_padded_len(v8[7], 8u);
    cstdlib_memset(v87, 0, 4 * (3 * v54));
    cstdlib_memcpy(v87, v90, 4 * v26);
    v55 = get_padded_len(v26, 8u);
    cstdlib_memcpy(&v87[4 * v55], &v90[v26], 4 * v26);
    v56 = get_padded_len(v26, 8u);
    cstdlib_memcpy(&v87[8 * v56], &v90[(2 * v26)], 4 * v26);
    v49 = (float *)v87;
  }
  v53 = v30;
  fi_activate_array(v49, v26, 9);
  v57 = get_padded_len(v26, 8u);
  fi_activate_array(&v49[v57], v26, 8);
  v58 = get_padded_len(v26, 8u);
  fi_activate_array(&v49[2 * v58], v26, 8);
  v59 = get_padded_len(v26, 8u);
  v91 = (void *)*((_QWORD *)&v103 + 1);
  axpy(v26, &v49[v59], 1, *((float **)&v103 + 1), 1, 1.0);
  v60 = get_padded_len(step, 8u);
  cstdlib_memset(v88, 0, 4 * v60);
  v61 = get_padded_len(v26, 8u);
  gmm_c(step, v26, (uint64_t)v49, (uint64_t)v91, (uint64_t)&v49[2 * v61], (uint64_t)v88);
  v62 = get_padded_len(v8[3], 8u);
  cstdlib_memset(v30, 0, 4 * v62);
  if ((_DWORD)step)
  {
    v63 = 0;
    v52 = (const void *)v86;
    do
    {
      axpy(v8[3], (float *)(a3 + 4 * v8[3] * v63), 1, (float *)v30, 1, *((float *)v88 + v63));
      ++v63;
    }
    while (step != v63);
  }
  else
  {
    v52 = (const void *)v86;
  }
LABEL_45:
  v64 = (char *)v99;
  v65 = get_padded_len(v8[14], 8u);
  cstdlib_memcpy(v64, v52, 4 * v65);
  v66 = &v64[4 * v8[14]];
  v67 = get_padded_len(v8[3], 8u);
  cstdlib_memcpy(v66, v53, 4 * v67);
  v68 = (void *)*((_QWORD *)&v100 + 1);
  v69 = get_padded_len(v8[16], 8u);
  cstdlib_memset(v68, 0, 4 * v69);
  v70 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 16) + 128))(0);
  if ((_DWORD)v70)
  {
    v20 = v70;
    v21 = *v9;
    v22 = "Tacotron decoder pre dense forward failed!";
  }
  else
  {
    v71 = (void *)*((_QWORD *)&v99 + 1);
    v72 = get_padded_len(v8[15], 8u);
    cstdlib_memset(v71, 0, 4 * v72);
    v73 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 19) + 128))(0);
    if ((_DWORD)v73)
    {
      v20 = v73;
      v21 = *v9;
      v22 = "Tacotron decoder rnn1 forward failed!";
    }
    else
    {
      v74 = get_padded_len(v8[15], 8u);
      axpy(v74, (float *)v71, 1, (float *)v68, 1, 1.0);
      v75 = (void *)v100;
      v76 = get_padded_len(v8[15], 8u);
      cstdlib_memset(v75, 0, 4 * v76);
      v77 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 20) + 128))(0);
      if ((_DWORD)v77)
      {
        v20 = v77;
        v21 = *v9;
        v22 = "Tacotron decoder rnn2 forward failed!";
      }
      else
      {
        v78 = get_padded_len(v8[15], 8u);
        axpy(v78, (float *)v75, 1, (float *)v68, 1, 1.0);
        v79 = get_padded_len(*v8 * v8[1], 8u);
        cstdlib_memset(v12, 0, 4 * v79);
        v80 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 17) + 128))(0);
        if ((_DWORD)v80)
        {
          v20 = v80;
          v21 = *v9;
          v22 = "Tacotron decoder post dense forward failed!";
        }
        else
        {
          v81 = __dst;
          cstdlib_memcpy((void *)__dst, v68, 4 * v8[16]);
          v82 = get_padded_len(v8[16], 8u);
          cstdlib_memcpy((void *)(v81 + 4 * v82), v12, 4 * v8[1] * *v8);
          v83 = get_padded_len(1, 8u);
          cstdlib_memset(v89, 0, 4 * v83);
          v20 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)v8 + 23) + 128))(0);
          if (!(_DWORD)v20)
          {
            v84 = get_padded_len(1, 8u);
            cstdlib_memcpy(a4, v89, 4 * v84);
            v85 = get_padded_len(1, 8u);
            cstdlib_memcpy(&a4[4 * v85], v12, 4 * v8[1] * *v8);
            return v20;
          }
          v21 = *v9;
          v22 = "Tacotron stop dense forward failed!";
        }
      }
    }
  }
LABEL_35:
  log_OutText(v21, (uint64_t)"FastInfer", 0, 0, (uint64_t)v22, v17, v18, v19, v86);
  return v20;
}

uint64_t tacodecoder_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  int v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int step;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD v76[2];
  int v77;
  _QWORD v78[2];
  int v79;
  _QWORD v80[2];
  int v81;
  _QWORD v82[2];
  int v83;
  int v84;
  uint64_t v85;
  int v86;
  int v87;
  int v88;
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 120);
  v85 = 0;
  v78[0] = 0;
  v78[1] = 0;
  v79 = 0;
  v76[0] = 0;
  v76[1] = 0;
  v77 = 0;
  cstdlib_memcpy((void *)(a1 + 20), a2, 0x14uLL);
  v84 = 1;
  if (*(_DWORD *)(v4 + 28) && !*(_DWORD *)(v4 + 20))
    v5 = *(_DWORD *)v4;
  else
    v5 = *(_DWORD *)v4 * *(_DWORD *)(v4 + 4);
  LODWORD(v85) = v5;
  result = fi_shape_set(2, &v84, 4, v76);
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 88)
                                                                                             + 144))(*(_QWORD *)(v4 + 88), v76, v7, v8, v9, v10);
    if (!(_DWORD)result)
    {
      result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 96)
                                                                                              + 144))(*(_QWORD *)(v4 + 96), *(_QWORD *)(v4 + 88) + 40, v11, v12, v13, v14);
      if (!(_DWORD)result)
      {
        v15 = *(_QWORD *)(a1 + 120);
        v88 = 0;
        v82[0] = 0;
        v82[1] = 0;
        v83 = 0;
        v80[0] = 0;
        v80[1] = 0;
        v81 = 0;
        step = fi_shape_get_step(a2);
        v17 = *(_DWORD *)(v15 + 12) + *(_DWORD *)(v15 + 52);
        v86 = 1;
        v87 = v17;
        result = fi_shape_set(2, &v86, 4, v82);
        if (!(_DWORD)result)
        {
          result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 144) + 144))(*(_QWORD *)(v15 + 144), v82, v18, v19, v20, v21);
          if (!(_DWORD)result)
          {
            result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 120) + 144))(*(_QWORD *)(v15 + 120), *(_QWORD *)(v15 + 144) + 40, v22, v23, v24, v25);
            if (!(_DWORD)result)
            {
              if (*(_DWORD *)(v15 + 28))
              {
                result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 104) + 144))(*(_QWORD *)(v15 + 104), *(_QWORD *)(v15 + 120) + 40, v26, v27, v28, v29);
                if ((_DWORD)result)
                  return result;
              }
              else
              {
                v54 = *(_DWORD *)(v15 + 12);
                v86 = step;
                v87 = v54;
                result = fi_shape_set(2, &v86, 4, v82);
                if ((_DWORD)result)
                  return result;
                result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 112) + 144))(*(_QWORD *)(v15 + 112), v82, v55, v56, v57, v58);
                if ((_DWORD)result)
                  return result;
                result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 104) + 144))(*(_QWORD *)(v15 + 104), *(_QWORD *)(v15 + 112) + 40, v59, v60, v61, v62);
                if ((_DWORD)result)
                  return result;
              }
              if (*(_DWORD *)(v15 + 28))
                goto LABEL_15;
              if (!*(_DWORD *)(v15 + 16)
                || (v86 = step, v87 = 2, result = fi_shape_set(2, &v86, 4, v80), !(_DWORD)result)
                && (result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 168) + 144))(*(_QWORD *)(v15 + 168), v80, v63, v64, v65, v66), !(_DWORD)result)&& (result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 176) + 144))(*(_QWORD *)(v15 + 176), *(_QWORD *)(v15 + 168) + 40, v67, v68, v69, v70), !(_DWORD)result))
              {
                if (!*(_DWORD *)(v15 + 20)
                  || (v71 = *(_DWORD *)(v15 + 56) + *(_DWORD *)(v15 + 12),
                      v86 = 1,
                      v87 = v71,
                      result = fi_shape_set(2, &v86, 4, v82),
                      !(_DWORD)result)
                  && (result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v15 + 192) + 144))(*(_QWORD *)(v15 + 192), v82, v72, v73, v74, v75), !(_DWORD)result))
                {
LABEL_15:
                  v30 = *(_DWORD *)(v4 + 12) + *(_DWORD *)(v4 + 56);
                  v84 = 1;
                  LODWORD(v85) = v30;
                  result = fi_shape_set(2, &v84, 4, v78);
                  if (!(_DWORD)result)
                  {
                    (*(void (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 128)
                                                                                                 + 144))(*(_QWORD *)(v4 + 128), v78, v31, v32, v33, v34);
                    result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 152) + 144))(*(_QWORD *)(v4 + 152), *(_QWORD *)(v4 + 128) + 40, v35, v36, v37, v38);
                    if (!(_DWORD)result)
                    {
                      result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 160) + 144))(*(_QWORD *)(v4 + 160), *(_QWORD *)(v4 + 128) + 40, v39, v40, v41, v42);
                      if (!(_DWORD)result)
                      {
                        result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 136) + 144))(*(_QWORD *)(v4 + 136), *(_QWORD *)(v4 + 160) + 40, v43, v44, v45, v46);
                        if (!(_DWORD)result)
                        {
                          v84 = 1;
                          LODWORD(v85) = *(_DWORD *)(v4 + 60) + *(_DWORD *)v4 * *(_DWORD *)(v4 + 4);
                          result = fi_shape_set(2, &v84, 4, v78);
                          if (!(_DWORD)result)
                          {
                            result = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 + 184) + 144))(*(_QWORD *)(v4 + 184), v78, v47, v48, v49, v50);
                            if (!(_DWORD)result)
                            {
                              v84 = 1;
                              v53 = v4;
                              v52 = *(_DWORD *)v4;
                              v51 = *(_DWORD *)(v53 + 4);
                              LODWORD(v85) = get_padded_len(1, 8u) + v52 * v51;
                              return fi_shape_set(2, &v84, 4, (_DWORD *)(a1 + 40));
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacodecoder_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int padded_bytes;
  int v12;
  int v13;
  uint64_t result;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;

  v27 = 0;
  v8 = *(_QWORD *)(a1 + 120);
  if (!v8)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Null pointer input!", a6, a7, a8, v26);
    return 7;
  }
  padded_bytes = get_padded_bytes(4 * *(_DWORD *)v8 * *(_DWORD *)(v8 + 4), 8u);
  v12 = get_padded_bytes(padded_bytes + 4 * *(_DWORD *)(v8 + 56), 8u);
  v28 = 8 * *(_DWORD *)(v8 + 60);
  v13 = get_padded_bytes(v12 + v28, 8u);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 88) + 152))();
  if (!(_DWORD)result)
  {
    v15 = get_padded_bytes(v28 + v27 + v13, 8u);
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 96) + 152))();
    if (!(_DWORD)result)
    {
      v16 = get_padded_bytes(v28 + v27 + v15, 8u);
      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 104) + 152))();
      if (!(_DWORD)result)
      {
        v17 = get_padded_bytes(v28 + v27 + v16, 8u);
        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 120) + 152))();
        if (!(_DWORD)result)
        {
          v18 = get_padded_bytes(v28 + v27 + v17, 8u);
          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 128) + 152))();
          if (!(_DWORD)result)
          {
            v19 = get_padded_bytes(v28 + v27 + v18, 8u);
            result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 136) + 152))();
            if (!(_DWORD)result)
            {
              v20 = get_padded_bytes(v28 + v27 + v19, 8u);
              result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 144) + 152))();
              if (!(_DWORD)result)
              {
                v21 = get_padded_bytes(v28 + v27 + v20, 8u);
                result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 152) + 152))();
                if (!(_DWORD)result)
                {
                  v22 = get_padded_bytes(v28 + v27 + v21, 8u);
                  result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 160) + 152))();
                  if (!(_DWORD)result)
                  {
                    v23 = get_padded_bytes(v28 + v27 + v22, 8u);
                    result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 184) + 152))();
                    if (!(_DWORD)result)
                    {
                      v24 = get_padded_bytes(v28 + v27 + v23, 8u);
                      if (*(_DWORD *)(v8 + 28))
                      {
LABEL_13:
                        result = 0;
                        *a2 = v24;
                        *a3 = 0;
                        return result;
                      }
                      result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 112) + 152))();
                      if (!(_DWORD)result)
                      {
                        v24 = get_padded_bytes(v28 + v27 + v24, 8u);
                        if (*(_DWORD *)(v8 + 16))
                        {
                          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 168) + 152))();
                          if ((_DWORD)result)
                            return result;
                          v25 = get_padded_bytes(v28 + v27 + v24, 8u);
                          result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 176) + 152))();
                          if ((_DWORD)result)
                            return result;
                          v24 = get_padded_bytes(v28 + v27 + v25, 8u);
                        }
                        if (!*(_DWORD *)(v8 + 20))
                          goto LABEL_13;
                        result = (*(uint64_t (**)(void))(*(_QWORD *)(v8 + 192) + 152))();
                        if (!(_DWORD)result)
                        {
                          v24 = get_padded_bytes(v28 + v24 + v27, 8u);
                          goto LABEL_13;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacodecoder_request_glbBuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t step;
  int padded_len;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t (*v27)(uint64_t);
  uint64_t result;
  uint64_t (*v29)(uint64_t);
  uint64_t (*v30)(uint64_t);
  int v31;
  int v32;
  int padded_bytes;
  uint64_t (*v34)(void);
  int v35;

  v2 = *(_QWORD *)(a1 + 120);
  v4 = *(_QWORD *)(v2 + 144);
  v3 = *(_QWORD *)(v2 + 152);
  v5 = *(_QWORD *)(v2 + 160);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  padded_len = get_padded_len(1, 8u);
  v8 = get_padded_len((*(_DWORD *)v2 * *(_DWORD *)(v2 + 4)), 8u);
  v9 = padded_len + get_padded_len(*(unsigned int *)(v2 + 12), 8u);
  v10 = v9 + get_padded_len(*(unsigned int *)(v2 + 48), 8u);
  v11 = v10 + get_padded_len(*(unsigned int *)(v2 + 52), 8u);
  v12 = v8 + v11 + get_padded_len((*(_DWORD *)(v2 + 52) + *(_DWORD *)(v2 + 12)), 8u);
  v13 = v12 + get_padded_len(*(unsigned int *)(v2 + 56), 8u);
  v14 = *(unsigned int *)(v2 + 28);
  if ((_DWORD)v14)
  {
    v15 = get_padded_len(v14, 8u);
    v16 = v15 + get_padded_len((3 * *(_DWORD *)(v2 + 28)), 8u);
    v17 = v16 + 3 * get_padded_len(*(unsigned int *)(v2 + 28), 8u) + v13;
    v18 = step;
  }
  else
  {
    v19 = get_padded_len((*(_DWORD *)(v2 + 8) * step), 8u);
    v20 = v19 + get_padded_len(step, 8u);
    v17 = v20 + get_padded_len(step, 8u) + v13;
    v18 = (2 * step);
  }
  v21 = get_padded_len(v18, 8u);
  v22 = get_padded_len(*(unsigned int *)(v2 + 8), 8u) + v21;
  v23 = v17 + get_padded_len((*(_DWORD *)(v2 + 12) + *(_DWORD *)(v2 + 56)), 8u);
  v24 = v22 + get_padded_len(*(unsigned int *)(v2 + 64), 8u);
  v25 = v24 + get_padded_len(*(unsigned int *)(v2 + 60), 8u);
  v26 = v25 + get_padded_len(*(unsigned int *)(v2 + 60), 8u);
  *(_DWORD *)(a1 + 248) = 4
                        * (v26
                         + get_padded_len((*(_DWORD *)(v2 + 60) + *(_DWORD *)v2 * *(_DWORD *)(v2 + 4)), 8u)+ v23);
  v27 = *(uint64_t (**)(uint64_t))(v4 + 160);
  if (!v27 || (result = v27(v4), !(_DWORD)result))
  {
    v29 = *(uint64_t (**)(uint64_t))(v3 + 160);
    if (!v29 || (result = v29(v3), !(_DWORD)result))
    {
      v30 = *(uint64_t (**)(uint64_t))(v5 + 160);
      if (!v30 || (result = v30(v5), !(_DWORD)result))
      {
        v31 = *(_DWORD *)(a1 + 248);
        v32 = get_padded_bytes(*(_DWORD *)(v4 + 248), 8u) + v31;
        padded_bytes = get_padded_bytes(*(_DWORD *)(v3 + 248), 8u);
        *(_DWORD *)(a1 + 248) = v32 + padded_bytes + get_padded_bytes(*(_DWORD *)(v5 + 248), 8u);
        if (*(_DWORD *)(v2 + 28))
          return 0;
        if (*(_DWORD *)(v2 + 16))
          get_padded_len((*(_DWORD *)(v2 + 32) * step), 8u);
        if (*(_DWORD *)(v2 + 20))
        {
          get_padded_len(step, 8u);
          get_padded_len((*(_DWORD *)(v2 + 56) + *(_DWORD *)(v2 + 12)), 8u);
          get_padded_len(1, 8u);
        }
        if (*(_DWORD *)(v2 + 16))
        {
          v34 = *(uint64_t (**)(void))(*(_QWORD *)(v2 + 168) + 160);
          if (!v34)
            goto LABEL_20;
          result = v34();
          if ((_DWORD)result)
            return result;
          if (*(_DWORD *)(v2 + 16))
LABEL_20:
            *(_DWORD *)(a1 + 248) += get_padded_bytes(*(_DWORD *)(*(_QWORD *)(v2 + 168) + 248), 8u);
        }
        v35 = get_padded_len((*(_DWORD *)(v2 + 8) * step), 8u);
        result = 0;
        *(_DWORD *)(a1 + 248) += v35;
      }
    }
  }
  return result;
}

uint64_t tacodecoder_layer_reset(uint64_t a1)
{
  uint64_t v2;
  uint64_t step;
  uint64_t v4;
  uint64_t (*v5)(void);
  uint64_t result;
  uint64_t v7;
  uint64_t (*v8)(void);
  uint64_t v9;
  uint64_t (*v10)(void);
  const void *v11;
  int v12;
  int v13;
  void *v14;
  unsigned int padded_len;
  void *v16;
  unsigned int v17;
  uint64_t v18;
  void *v19;
  unsigned int v20;
  void *v21;
  unsigned int v22;
  void *v23;
  unsigned int v24;
  _DWORD *v25;
  unsigned int v26;
  __int128 v27;
  void *__dst[2];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  v40 = 0;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  *(_OWORD *)__dst = 0u;
  v29 = 0u;
  v27 = 0u;
  pack_tacodecoder_internal_buffer(a1, &v27);
  v2 = *(_QWORD *)(a1 + 120);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  v4 = *(_QWORD *)(v2 + 144);
  if (!v4 || (v5 = *(uint64_t (**)(void))(v4 + 176)) == 0 || (result = v5(), !(_DWORD)result))
  {
    v7 = *(_QWORD *)(v2 + 152);
    if (!v7 || (v8 = *(uint64_t (**)(void))(v7 + 176)) == 0 || (result = v8(), !(_DWORD)result))
    {
      v9 = *(_QWORD *)(v2 + 160);
      if (!v9 || (v10 = *(uint64_t (**)(void))(v9 + 176)) == 0 || (result = v10(), !(_DWORD)result))
      {
        v11 = *(const void **)(a1 + 72);
        if (v11)
        {
          v12 = *(_DWORD *)(v2 + 4) * *(_DWORD *)v2;
          cstdlib_memcpy(__dst[0], v11, (4 * v12));
          cstdlib_memcpy(**(void ***)(*(_QWORD *)(v2 + 144) + 120), (const void *)(*(_QWORD *)(a1 + 72) + (4 * v12)), 4 * *(unsigned int *)(v2 + 56));
          v13 = *(_DWORD *)(v2 + 56) + v12;
          cstdlib_memcpy(**(void ***)(*(_QWORD *)(v2 + 152) + 120), (const void *)(*(_QWORD *)(a1 + 72) + (4 * v13)), 4 * *(unsigned int *)(v2 + 60));
          cstdlib_memcpy(**(void ***)(*(_QWORD *)(v2 + 160) + 120), (const void *)(*(_QWORD *)(a1 + 72) + (4 * *(_DWORD *)(v2 + 60) + 4 * v13)), 4 * *(unsigned int *)(v2 + 60));
          v14 = __dst[1];
          padded_len = get_padded_len(*(unsigned int *)(v2 + 12), 8u);
          cstdlib_memset(v14, 0, 4 * padded_len);
          v16 = (void *)*((_QWORD *)&v27 + 1);
          v17 = get_padded_len(1, 8u);
          cstdlib_memset(v16, 0, 4 * v17);
          v18 = *(unsigned int *)(v2 + 28);
          if ((_DWORD)v18)
          {
            v19 = (void *)v38;
            v20 = get_padded_len(v18, 8u);
            cstdlib_memset(v19, 0, 4 * v20);
          }
          else
          {
            v21 = (void *)v29;
            v22 = get_padded_len(step, 8u);
            cstdlib_memset(v21, 0, 4 * v22);
            v23 = (void *)*((_QWORD *)&v29 + 1);
            v24 = get_padded_len(step, 8u);
            cstdlib_memset(v23, 0, 4 * v24);
            if (*(_DWORD *)(v2 + 20))
            {
              v25 = (_DWORD *)*((_QWORD *)&v36 + 1);
              v26 = get_padded_len(step, 8u);
              cstdlib_memset(v25, 0, 4 * v26);
              if (step < 2)
              {
                if (!(_DWORD)step)
                  return 0;
              }
              else
              {
                memset_pattern16(v25 + 1, &unk_214FAF000, 4 * (step - 2) + 4);
              }
              result = 0;
              *v25 = 1065353216;
              return result;
            }
          }
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t tacodecoder_assign_glbBuf()
{
  return 0;
}

uint64_t tacodecoder_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  int padded_bytes;
  int v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;

  v9 = *(_QWORD *)(a1 + 120);
  if (!v9)
  {
    log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v17);
    return 7;
  }
  v10 = *(_QWORD *)(a1 + 72);
  padded_bytes = get_padded_bytes(4 * *(_DWORD *)v9 * *(_DWORD *)(v9 + 4), 8u);
  v12 = get_padded_bytes(padded_bytes + 4 * *(_DWORD *)(v9 + 56), 8u);
  v18 = get_padded_bytes(v12 + 8 * *(_DWORD *)(v9 + 60), 8u);
  result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 88), v10, &v18);
  if (!(_DWORD)result)
  {
    v18 = get_padded_bytes(v18, 8u);
    result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 96), v10, &v18);
    if (!(_DWORD)result)
    {
      v18 = get_padded_bytes(v18, 8u);
      v19 = v18;
      v14 = *(_QWORD *)(a1 + 120);
      v15 = *(_QWORD *)(a1 + 72);
      if (*(_DWORD *)(v14 + 28))
      {
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 104), v15, &v19);
        if ((_DWORD)result)
          return result;
        v19 = get_padded_bytes(v19, 8u);
        v16 = *(_QWORD *)(v14 + 120);
      }
      else
      {
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 112), v15, &v19);
        if ((_DWORD)result)
          return result;
        v19 = get_padded_bytes(v19, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 104), v15, &v19);
        if ((_DWORD)result)
          return result;
        v19 = get_padded_bytes(v19, 8u);
        if (*(_DWORD *)(v14 + 16))
        {
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 168), v15, &v19);
          if ((_DWORD)result)
            return result;
          v19 = get_padded_bytes(v19, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 176), v15, &v19);
          if ((_DWORD)result)
            return result;
          v19 = get_padded_bytes(v19, 8u);
        }
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 120), v15, &v19);
        if ((_DWORD)result)
          return result;
        v19 = get_padded_bytes(v19, 8u);
        if (!*(_DWORD *)(v14 + 20))
          goto LABEL_9;
        v16 = *(_QWORD *)(v14 + 192);
      }
      result = fi_layer_find_weights_via_offset(v16, v15, &v19);
      if ((_DWORD)result)
        return result;
      v19 = get_padded_bytes(v19, 8u);
LABEL_9:
      result = fi_layer_find_weights_via_offset(*(_QWORD *)(v14 + 144), v15, &v19);
      if (!(_DWORD)result)
      {
        v18 = get_padded_bytes(v19, 8u);
        v18 = get_padded_bytes(v18, 8u);
        result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 128), v10, &v18);
        if (!(_DWORD)result)
        {
          v18 = get_padded_bytes(v18, 8u);
          result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 136), v10, &v18);
          if (!(_DWORD)result)
          {
            v18 = get_padded_bytes(v18, 8u);
            result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 152), v10, &v18);
            if (!(_DWORD)result)
            {
              v18 = get_padded_bytes(v18, 8u);
              result = fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 160), v10, &v18);
              if (!(_DWORD)result)
              {
                v18 = get_padded_bytes(v18, 8u);
                return fi_layer_find_weights_via_offset(*(_QWORD *)(v9 + 184), v10, &v18);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacodecoder_layer_load_state(uint64_t a1, float *a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t step;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  uint64_t v12;
  float *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  char *v28;
  int padded_len;
  uint64_t v30;
  int v31;
  void *v32[2];
  void *__dst[2];
  void *v34[2];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;

  v4 = *(uint64_t **)a1;
  v45 = 0;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v40 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  *(_OWORD *)v34 = 0u;
  v35 = 0u;
  *(_OWORD *)v32 = 0u;
  *(_OWORD *)__dst = 0u;
  v31 = 0;
  pack_tacodecoder_internal_buffer(a1, v32);
  v5 = *(_QWORD *)(a1 + 120);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  if (!a2)
    return 0;
  v10 = step;
  if ((_DWORD)step != (float)(*a2 + 0.00001))
  {
    v25 = *v4;
    v26 = "input step mismatch with stored value!";
LABEL_8:
    log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v7, v8, v9, v30);
    return 7;
  }
  tacodecoder_layer_sizeof_state(a1, &v31);
  if (v31 != (float)(a2[1] + 0.00001))
  {
    v25 = *v4;
    v26 = "state size mismatch with stored value!";
    goto LABEL_8;
  }
  v11 = &a2[get_padded_len(2, 8u)];
  v12 = (*(_DWORD *)(v5 + 4) * *(_DWORD *)v5);
  cstdlib_memcpy(__dst[0], v11, 4 * v12);
  v13 = &v11[get_padded_len(v12, 8u)];
  v14 = *(unsigned int *)(v5 + 56);
  cstdlib_memcpy(**(void ***)(*(_QWORD *)(v5 + 144) + 120), v13, 4 * v14);
  v15 = (char *)&v13[get_padded_len(v14, 8u)];
  v16 = *(unsigned int *)(v5 + 60);
  cstdlib_memcpy(**(void ***)(*(_QWORD *)(v5 + 152) + 120), v15, 4 * v16);
  v17 = &v15[4 * get_padded_len(v16, 8u)];
  v18 = *(unsigned int *)(v5 + 60);
  cstdlib_memcpy(**(void ***)(*(_QWORD *)(v5 + 160) + 120), v17, 4 * v18);
  v19 = &v17[4 * get_padded_len(v18, 8u)];
  v20 = *(unsigned int *)(v5 + 12);
  cstdlib_memcpy(__dst[1], v19, 4 * v20);
  v21 = &v19[4 * get_padded_len(v20, 8u)];
  cstdlib_memcpy(v32[1], v21, 4uLL);
  v22 = &v21[4 * get_padded_len(1, 8u)];
  v23 = *(unsigned int *)(v5 + 28);
  if ((_DWORD)v23)
  {
    cstdlib_memcpy((void *)v43, v22, 4 * v23);
    v24 = v23;
LABEL_11:
    get_padded_len(v24, 8u);
    return 0;
  }
  cstdlib_memcpy(v34[0], v22, 4 * v10);
  v28 = &v22[4 * get_padded_len(v10, 8u)];
  cstdlib_memcpy(v34[1], v28, 4 * v10);
  padded_len = get_padded_len(v10, 8u);
  if (*(_DWORD *)(v5 + 20))
  {
    cstdlib_memcpy(*((void **)&v41 + 1), &v28[4 * padded_len], 4 * v10);
    v24 = v10;
    goto LABEL_11;
  }
  return 0;
}

uint64_t tacodecoder_layer_save_state(uint64_t a1, float *a2)
{
  uint64_t v4;
  uint64_t step;
  uint64_t v6;
  float *v7;
  uint64_t v8;
  float *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  int padded_len;
  unsigned int v23;
  void *v24[2];
  void *__src[2];
  void *v26[2];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = 0;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v32 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  *(_OWORD *)v26 = 0u;
  v27 = 0u;
  *(_OWORD *)v24 = 0u;
  *(_OWORD *)__src = 0u;
  v23 = 0;
  pack_tacodecoder_internal_buffer(a1, v24);
  v4 = *(_QWORD *)(a1 + 120);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  if (a2)
  {
    v6 = step;
    *a2 = (float)step;
    tacodecoder_layer_sizeof_state(a1, &v23);
    a2[1] = (float)v23;
    v7 = &a2[get_padded_len(2, 8u)];
    v8 = (*(_DWORD *)(v4 + 4) * *(_DWORD *)v4);
    cstdlib_memcpy(v7, __src[0], 4 * v8);
    v9 = &v7[get_padded_len(v8, 8u)];
    v10 = *(unsigned int *)(v4 + 56);
    cstdlib_memcpy(v9, **(const void ***)(*(_QWORD *)(v4 + 144) + 120), 4 * v10);
    v11 = (char *)&v9[get_padded_len(v10, 8u)];
    v12 = *(unsigned int *)(v4 + 60);
    cstdlib_memcpy(v11, **(const void ***)(*(_QWORD *)(v4 + 152) + 120), 4 * v12);
    v13 = &v11[4 * get_padded_len(v12, 8u)];
    v14 = *(unsigned int *)(v4 + 60);
    cstdlib_memcpy(v13, **(const void ***)(*(_QWORD *)(v4 + 160) + 120), 4 * v14);
    v15 = &v13[4 * get_padded_len(v14, 8u)];
    v16 = *(unsigned int *)(v4 + 12);
    cstdlib_memcpy(v15, __src[1], 4 * v16);
    v17 = &v15[4 * get_padded_len(v16, 8u)];
    cstdlib_memcpy(v17, v24[1], 4uLL);
    v18 = &v17[4 * get_padded_len(1, 8u)];
    v19 = *(unsigned int *)(v4 + 28);
    if ((_DWORD)v19)
    {
      cstdlib_memcpy(v18, (const void *)v35, 4 * v19);
      v6 = v19;
LABEL_6:
      get_padded_len(v6, 8u);
      return 0;
    }
    cstdlib_memcpy(v18, v26[0], 4 * v6);
    v20 = &v18[4 * get_padded_len(v6, 8u)];
    cstdlib_memcpy(v20, v26[1], 4 * v6);
    padded_len = get_padded_len(v6, 8u);
    if (*(_DWORD *)(v4 + 20))
    {
      cstdlib_memcpy(&v20[4 * padded_len], *((const void **)&v33 + 1), 4 * v6);
      goto LABEL_6;
    }
  }
  return 0;
}

uint64_t tacodecoder_layer_sizeof_state(uint64_t a1, _DWORD *a2)
{
  _DWORD *v4;
  uint64_t step;
  int padded_len;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  _QWORD v17[27];

  pack_tacodecoder_internal_buffer(a1, v17);
  v4 = *(_DWORD **)(a1 + 120);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  padded_len = get_padded_len(2, 8u);
  v7 = get_padded_len((v4[1] * *v4), 8u);
  v8 = padded_len + get_padded_len(v4[14], 8u);
  v9 = v8 + get_padded_len(v4[15], 8u);
  v10 = v9 + get_padded_len(v4[15], 8u);
  v11 = v7 + v10 + get_padded_len(v4[3], 8u);
  v12 = v11 + get_padded_len(1, 8u);
  v13 = v4[7];
  if ((_DWORD)v13)
  {
    v14 = get_padded_len(v13, 8u);
  }
  else
  {
    v15 = get_padded_len(step, 8u);
    v14 = v15 + get_padded_len(step, 8u) + v12;
    v12 = get_padded_len(step, 8u);
  }
  *a2 = v14 + v12;
  return 0;
}

uint64_t tacodecoder_get_config(uint64_t result, _QWORD *a2)
{
  *a2 = result;
  return result;
}

float get_last_alignment(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float result;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  _OWORD v14[2];
  _OWORD v15[10];
  __int128 v16;
  uint64_t v17;

  v17 = 0;
  result = 0.0;
  v16 = 0u;
  memset(v15, 0, sizeof(v15));
  memset(v14, 0, sizeof(v14));
  if (a1)
  {
    if (*(_QWORD *)(a1 + 240))
    {
      pack_tacodecoder_internal_buffer(a1, v14);
      v11 = *(_QWORD *)(a1 + 120);
      if (*(_DWORD *)(v11 + 28))
      {
        v12 = *((_QWORD *)&v16 + 1);
      }
      else
      {
        if (*(_DWORD *)(v11 + 20))
          v13 = (uint64_t *)&v15[7] + 1;
        else
          v13 = (uint64_t *)v15;
        v12 = *v13;
      }
      result = *(float *)(v12 + 4 * (*(_DWORD *)(a1 + 24) - 1));
      *a2 = result;
    }
    else
    {
      log_OutText(**(_QWORD **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron stop dense forward failed!", a6, a7, a8, *(uint64_t *)&v14[0]);
    }
  }
  return result;
}

uint64_t pack_tacodecoder_internal_buffer(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t step;
  int padded_len;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t result;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;

  v3 = *(_QWORD *)(a1 + 120);
  v4 = *(_QWORD *)(a1 + 240);
  v6 = *(_QWORD *)(v3 + 144);
  v5 = *(_QWORD *)(v3 + 152);
  v7 = *(_QWORD *)(v3 + 160);
  step = fi_shape_get_step((_DWORD *)(a1 + 20));
  *a2 = 0;
  a2[1] = v4;
  padded_len = get_padded_len(1, 8u);
  a2[2] = v4 + (4 * padded_len);
  v10 = get_padded_len((*(_DWORD *)v3 * *(_DWORD *)(v3 + 4)), 8u) + padded_len;
  a2[3] = v4 + (4 * v10);
  v11 = get_padded_len(*(unsigned int *)(v3 + 12), 8u) + v10;
  LODWORD(v12) = 4 * v11;
  if (!*(_DWORD *)(v3 + 28))
  {
    a2[4] = v4 + v12;
    v13 = get_padded_len(step, 8u) + v11;
    a2[5] = v4 + (4 * v13);
    v14 = get_padded_len(step, 8u) + v13;
    a2[6] = v4 + (4 * v14);
    LODWORD(v12) = 4 * (get_padded_len((2 * step), 8u) + v14);
  }
  a2[7] = v4 + v12;
  v15 = get_padded_len(*(unsigned int *)(v3 + 48), 8u);
  a2[8] = v4 + (v12 + 4 * v15);
  v16 = get_padded_len(*(unsigned int *)(v3 + 52), 8u) + v15;
  a2[9] = v4 + (v12 + 4 * v16);
  v17 = get_padded_len((*(_DWORD *)(v3 + 52) + *(_DWORD *)(v3 + 12)), 8u) + v16;
  a2[10] = v4 + (v12 + 4 * v17);
  v18 = get_padded_len(*(unsigned int *)(v3 + 56), 8u) + v17;
  v19 = *(unsigned int *)(v3 + 28);
  v20 = v4 + (v12 + 4 * v18);
  if ((_DWORD)v19)
  {
    a2[22] = v20;
    v21 = get_padded_len(v19, 8u) + v18;
    a2[23] = v4 + (v12 + 4 * v21);
    v22 = v12 + 4 * (get_padded_len((3 * *(_DWORD *)(v3 + 28)), 8u) + v21);
    a2[24] = v4 + v22;
    v12 = v22 + 12 * get_padded_len(*(unsigned int *)(v3 + 28), 8u);
    a2[25] = v4 + v12;
    v23 = get_padded_len(step, 8u);
  }
  else
  {
    a2[11] = v20;
    v23 = get_padded_len((*(_DWORD *)(v3 + 8) * step), 8u) + v18;
  }
  a2[12] = v4 + (v12 + 4 * v23);
  v24 = get_padded_len(*(unsigned int *)(v3 + 8), 8u);
  a2[13] = v4 + (v12 + 4 * (v23 + v24));
  v25 = get_padded_len((*(_DWORD *)(v3 + 12) + *(_DWORD *)(v3 + 56)), 8u) + v24;
  a2[16] = v4 + (v12 + 4 * (v23 + v25));
  v26 = get_padded_len(*(unsigned int *)(v3 + 64), 8u) + v25;
  a2[14] = v4 + (v12 + 4 * (v23 + v26));
  v27 = get_padded_len(*(unsigned int *)(v3 + 60), 8u) + v26;
  a2[15] = v4 + (v12 + 4 * (v23 + v27));
  v28 = get_padded_len(*(unsigned int *)(v3 + 60), 8u) + v27;
  a2[17] = v4 + (v12 + 4 * (v23 + v28));
  v29 = v12
      + 4
      * (v23
       + get_padded_len((*(_DWORD *)(v3 + 60) + *(_DWORD *)v3 * *(_DWORD *)(v3 + 4)), 8u)
       + v28);
  *(_QWORD *)(v6 + 240) = v4 + v29;
  v30 = v29 + get_padded_bytes(*(_DWORD *)(v6 + 248), 8u);
  *(_QWORD *)(v5 + 240) = v4 + v30;
  v31 = get_padded_bytes(*(_DWORD *)(v5 + 248), 8u) + v30;
  *(_QWORD *)(v7 + 240) = v4 + v31;
  result = get_padded_bytes(*(_DWORD *)(v7 + 248), 8u);
  if (!*(_DWORD *)(v3 + 28))
  {
    v33 = result + v31;
    if (*(_DWORD *)(v3 + 16))
    {
      a2[18] = v4 + v33;
      v34 = v33 + 4 * get_padded_len((*(_DWORD *)(v3 + 32) * step), 8u);
      v35 = *(_QWORD *)(v3 + 168);
      *(_QWORD *)(v35 + 240) = v4 + v34;
      v33 = get_padded_bytes(*(_DWORD *)(v35 + 248), 8u) + v34;
    }
    if (*(_DWORD *)(v3 + 20))
    {
      a2[19] = v4 + v33;
      v36 = get_padded_len(step, 8u);
      a2[20] = v4 + v33 + 4 * v36;
      v37 = get_padded_len((*(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 12)), 8u) + v36;
      a2[21] = v4 + v33 + 4 * v37;
      v33 += 4 * (get_padded_len(1, 8u) + v37);
    }
    a2[26] = v4 + v33;
    return get_padded_len((*(_DWORD *)(v3 + 8) * step), 8u);
  }
  return result;
}

uint64_t get_alignment(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  char *v10;
  _OWORD v11[2];
  _OWORD v12[10];
  __int128 v13;
  uint64_t v14;

  v14 = 0;
  v13 = 0u;
  memset(v12, 0, sizeof(v12));
  memset(v11, 0, sizeof(v11));
  if (result)
  {
    v8 = result;
    if (!*(_QWORD *)(result + 240))
      log_OutText(**(_QWORD **)result, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Decoder get buf failed!", a6, a7, a8, *(uint64_t *)&v11[0]);
    pack_tacodecoder_internal_buffer(v8, v11);
    v9 = *(_QWORD *)(v8 + 120);
    if (*(_DWORD *)(v9 + 28))
    {
      return *((_QWORD *)&v13 + 1);
    }
    else
    {
      if (*(_DWORD *)(v9 + 20))
        v10 = (char *)&v12[7] + 8;
      else
        v10 = (char *)v12;
      return *(_QWORD *)v10;
    }
  }
  return result;
}

uint64_t additive_attention(uint64_t *a1, _QWORD *a2, uint64_t a3, unsigned int *a4, uint64_t a5)
{
  float *v10;
  float *v11;
  float *v12;
  void *v13;
  const void *v14;
  unsigned int padded_len;
  void *v16;
  const void *v17;
  unsigned int v18;
  void *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  void *v29;
  unsigned int v30;
  uint64_t v31;
  void *v32;
  const void *v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  uint64_t v37;
  void *v38;
  const void *v39;
  unsigned int v40;
  uint64_t v41;
  float v42;
  uint64_t v43;
  float v44;
  uint64_t v45;
  float *v46;
  float v47;
  float v48;
  float v49;
  float v50;
  void *v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  unsigned int v58;
  void *v59;
  unsigned int v60;
  uint64_t v61;

  v10 = *(float **)(a5 + 152);
  v11 = *(float **)(a5 + 88);
  v12 = *(float **)(a5 + 32);
  v14 = *(const void **)(a5 + 64);
  v13 = *(void **)(a5 + 72);
  padded_len = get_padded_len(a4[13], 8u);
  cstdlib_memcpy(v13, v14, 4 * padded_len);
  v16 = (void *)(*(_QWORD *)(a5 + 72) + 4 * a4[13]);
  v17 = *(const void **)(a5 + 24);
  v18 = get_padded_len(a4[3], 8u);
  cstdlib_memcpy(v16, v17, 4 * v18);
  v19 = *(void **)(a5 + 80);
  v20 = get_padded_len(a4[14], 8u);
  cstdlib_memset(v19, 0, 4 * v20);
  v21 = (*(uint64_t (**)(_QWORD))(a2[7] + 128))(0);
  if ((_DWORD)v21)
  {
    v25 = v21;
    v26 = "Tacotron attention rnn forward failed!";
LABEL_5:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v22, v23, v24, v61);
    return v25;
  }
  cstdlib_memset(*(void **)(a5 + 96), 0, 4 * a4[2]);
  v27 = (*(uint64_t (**)(_QWORD))(a2[4] + 128))(0);
  if ((_DWORD)v27)
  {
    v25 = v27;
    v26 = "Tacotron decoder Key dense forward failed!";
    goto LABEL_5;
  }
  if (a4[4])
  {
    interleave(a3, *(int **)(a5 + 32), *(float **)(a5 + 40), *(_QWORD *)(a5 + 48));
    v29 = *(void **)(a5 + 144);
    v30 = get_padded_len(a4[8] * a3, 8u);
    cstdlib_memset(v29, 0, 4 * v30);
    v31 = (*(uint64_t (**)(_QWORD))(a2[10] + 128))(0);
    if ((_DWORD)v31)
    {
      v25 = v31;
      v26 = "Tacotron location layer conv forward failed!";
      goto LABEL_5;
    }
    v38 = *(void **)(a5 + 88);
    v39 = *(const void **)(a5 + 208);
    v40 = get_padded_len(a4[2] * a3, 8u);
    cstdlib_memcpy(v38, v39, 4 * v40);
    v41 = (*(uint64_t (**)(_QWORD))(a2[11] + 128))(0);
    if ((_DWORD)v41)
    {
      v25 = v41;
      v26 = "Tacotron location layer dense forward failed!";
      goto LABEL_5;
    }
  }
  else
  {
    v32 = *(void **)(a5 + 88);
    v33 = *(const void **)(a5 + 208);
    v34 = get_padded_len(a4[2] * a3, 8u);
    cstdlib_memcpy(v32, v33, 4 * v34);
  }
  if ((_DWORD)a3)
  {
    v35 = 0;
    do
      axpy(a4[2], *(float **)(a5 + 96), 1, (float *)(*(_QWORD *)(a5 + 88) + 4 * a4[2] * v35++), 1, 1.0);
    while ((_DWORD)a3 != v35);
  }
  fi_activate_array(v11, a4[2] * a3, 2);
  v36 = get_padded_len(a3, 8u);
  cstdlib_memset(v12, 0, 4 * v36);
  v37 = (*(uint64_t (**)(_QWORD))(a2[2] + 128))(0);
  if ((_DWORD)v37)
  {
    v25 = v37;
    v26 = "Tacotron attention vec_v dense forward failed!";
    goto LABEL_5;
  }
  fi_activate_array(v12, a3, 1);
  oneNorm((uint64_t)v12, a3, 1, (uint64_t)v12);
  axpy(a3, *(float **)(a5 + 32), 1, *(float **)(a5 + 40), 1, 1.0);
  if (a4[5])
  {
    if (!(_DWORD)a3)
      goto LABEL_23;
    v42 = **(float **)(a5 + 168);
    v43 = a3;
    v44 = 0.0;
    v45 = a3;
    v46 = v10;
    v47 = 0.0;
    do
    {
      v48 = *v46;
      v49 = *v12++;
      v50 = v49 * (float)((float)((float)(v42 * v47) + (float)(*v46 * (float)(1.0 - v42))) + 0.0000001);
      *v46++ = v50;
      v44 = v44 + v50;
      v47 = v48;
      --v45;
    }
    while (v45);
    if (v44 == 0.0)
    {
LABEL_23:
      v25 = 7;
      v26 = "Alpha sum equals zero!";
      goto LABEL_5;
    }
    do
    {
      *v10 = *v10 / v44;
      ++v10;
      --v43;
    }
    while (v43);
  }
  v51 = *(void **)(a5 + 24);
  v52 = get_padded_len(a4[3], 8u);
  cstdlib_memset(v51, 0, 4 * v52);
  v53 = a4[5];
  v54 = 152;
  if (!v53)
    v54 = 32;
  if ((_DWORD)a3)
  {
    v55 = 0;
    v56 = *(_QWORD *)(a5 + v54);
    do
    {
      axpy(a4[3], (float *)(*(_QWORD *)a5 + 4 * a4[3] * v55), 1, *(float **)(a5 + 24), 1, *(float *)(v56 + 4 * v55));
      ++v55;
    }
    while (a3 != v55);
    v53 = a4[5];
  }
  if (!v53)
    return 0;
  v57 = *(void **)(a5 + 160);
  v58 = get_padded_len(a4[14] + a4[3], 8u);
  cstdlib_memset(v57, 0, 4 * v58);
  cstdlib_memcpy(*(void **)(a5 + 160), *(const void **)(a5 + 24), 4 * a4[3]);
  cstdlib_memcpy((void *)(*(_QWORD *)(a5 + 160) + 4 * a4[3]), *(const void **)(a5 + 80), 4 * a4[14]);
  v59 = *(void **)(a5 + 168);
  v60 = get_padded_len(1, 8u);
  cstdlib_memset(v59, 0, 4 * v60);
  v25 = (*(uint64_t (**)(_QWORD))(a2[13] + 128))(0);
  if ((_DWORD)v25)
  {
    v26 = "Tacotron forward attention trans agent dense forward failed!";
    goto LABEL_5;
  }
  return v25;
}

uint64_t featex_bet7_component_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 3223330817;
  result = 0;
  *a2 = &IBet7FeatEx;
  return result;
}

uint64_t bet7_featex_ClassOpen(_WORD *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  if (!a3)
    return 3223330823;
  result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *a3 = a1;
    a3[1] = a2;
  }
  return result;
}

uint64_t bet7_featex_ClassClose()
{
  return 0;
}

uint64_t bet7_featex_ObjOpen(_WORD *a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t Object;
  int Allocator;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v21 = 0;
  v22 = 0;
  v5 = 3223330823;
  v20 = 0;
  if (a5)
  {
    inited = InitRsrcFunction(a1, a2, &v22);
    if ((inited & 0x80000000) != 0)
      return inited;
    *(_QWORD *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    inited = InitRsrcFunction(a3, a4, &v21);
    if ((inited & 0x80000000) != 0)
      return inited;
    v10 = heap_Calloc(*(_QWORD **)(v21 + 8), 1, 936);
    if (!v10)
    {
      log_OutPublic(*(_QWORD *)(v21 + 32), (uint64_t)"BET7_FEATEX", 78000, 0, v11, v12, v13, v14, v19);
      return 3223330826;
    }
    v15 = (_QWORD *)v10;
    Object = objc_GetObject(*(_QWORD *)(v21 + 48), (uint64_t)"SYNTHSTREAM", &v20);
    if ((Object & 0x80000000) != 0
      || (v15[3] = *(_QWORD *)(v20 + 8),
          Allocator = ooc_utils_createAllocator((uint64_t)(v15 + 111), a3, a4),
          Object = LH_ERROR_to_VERROR(Allocator),
          (Object & 0x80000000) != 0))
    {
      v5 = Object;
    }
    else
    {
      *v15 = a3;
      v15[1] = a4;
      v15[2] = v21;
      *(_QWORD *)a5 = v15;
      *(_DWORD *)(a5 + 8) = 2053;
      v5 = bet7_featex_ObjReopen((uint64_t)v15, *(_QWORD *)(a5 + 8));
      if ((v5 & 0x80000000) == 0)
        return v5;
    }
    if (v15[3])
    {
      objc_ReleaseObject(*(_QWORD *)(v21 + 48), (uint64_t)"SYNTHSTREAM");
      v15[3] = 0;
    }
  }
  return v5;
}

uint64_t bet7_featex_ObjClose(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v6 = safeh_HandleCheck((uint64_t)a1, a2, 2053, 936);
  result = 3223330824;
  if ((v6 & 0x80000000) == 0 && a1)
  {
    log_OutText(*(_QWORD *)(a1[2] + 32), (uint64_t)"BET7_FEATEX", 4, 0, (uint64_t)"Entering bet7_featex_ObjClose", v3, v4, v5, v11);
    if (a1[3])
    {
      objc_ReleaseObject(*(_QWORD *)(a1[2] + 48), (uint64_t)"SYNTHSTREAM");
      a1[3] = 0;
    }
    luavmldoutil_destroy_lua_vm((uint64_t)(a1 + 111), a1 + 116);
    OOCAllocator_Des();
    log_OutText(*(_QWORD *)(a1[2] + 32), (uint64_t)"BET7_FEATEX", 4, 0, (uint64_t)"Leaving bet7_featex_ObjClose", v8, v9, v10, v12);
    heap_Free(*(_QWORD **)(a1[2] + 8), (uint64_t)a1);
    return v6;
  }
  return result;
}

uint64_t bet7_featex_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t voice_specific_broker_string;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  size_t v13;
  char *v14;
  char v15;
  int ScriptFromBuffer;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v26;
  uint64_t v27;
  _OWORD v28[16];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v3 = 3223330824;
  if ((safeh_HandleCheck(a1, a2, 2053, 936) & 0x80000000) == 0 && a1)
  {
    memset(v28, 0, sizeof(v28));
    luavmldoutil_destroy_lua_vm(a1 + 888, (uint64_t *)(a1 + 928));
    *(_QWORD *)(a1 + 928) = 0;
    voice_specific_broker_string = bet7_generate_voice_specific_broker_string(*(_QWORD *)(a1 + 16), "bet7featex", (char *)v28);
    if ((voice_specific_broker_string & 0x80000000) != 0)
    {
      return voice_specific_broker_string;
    }
    else
    {
      v8 = luavmldoutil_initialize_lua_vm(*(_WORD **)a1, *(_QWORD *)(a1 + 8), a1 + 888, (uint64_t)"bet7_featex_dummy_voice_specific_function", (uint64_t)hlp_lua_log_callback_4, (uint64_t *)(a1 + 928), (char *)v28);
      if (v8 < 0 || !*(_QWORD *)(a1 + 928))
      {
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"BET7_FEATEX", 5, 0, (uint64_t)"BET7 featex Lua function [%s] is not available", v5, v6, v7, (uint64_t)"bet7_featex_dummy_voice_specific_function");
        if ((v8 & 0x1FFF) != 0x14 && v8 <= -1)
          return v8;
        else
          return 3223330841;
      }
      else
      {
        v9 = cstdlib_strlen(&gEncryptedScript);
        v10 = heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), v9 + 1);
        if (v10)
        {
          v11 = v10;
          if (v9)
          {
            v12 = (_BYTE *)v10;
            v13 = v9;
            v14 = &gEncryptedScript;
            do
            {
              v15 = *v14++;
              *v12++ = v15 ^ 0xBA;
              --v13;
            }
            while (v13);
          }
          *(_BYTE *)(v10 + v9) = 0;
          ScriptFromBuffer = LuaVMLDO_LoadScriptFromBuffer(*(_QWORD *)(a1 + 928), v10, v9);
          v3 = LH_ERROR_to_VERROR(ScriptFromBuffer);
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v11);
          if ((v3 & 0x80000000) == 0)
          {
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"BET7_FEATEX", 4, 0, (uint64_t)"Entering bet7_featex_loc_RunInitLuaFunction", v17, v18, v19, v26);
            v20 = LuaVMLDO_RunFunctionReturningString(*(_QWORD *)(a1 + 928), (uint64_t)"bet7_featex_init", (uint64_t)"embedded", 0xAu, (char *)v28);
            v3 = LH_ERROR_to_VERROR(v20);
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"BET7_FEATEX", 4, 0, (uint64_t)"Leaving bet7_featex_loc_RunInitLuaFunction", v21, v22, v23, v27);
          }
        }
        else
        {
          return 3223330826;
        }
      }
    }
  }
  return v3;
}

uint64_t bet7_featex_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  v7 = 3223330824;
  if ((safeh_HandleCheck(a1, a2, 2053, 936) & 0x80000000) == 0)
  {
    if (a1)
    {
      synstrmaux_InitStreamOpener(a1 + 32, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"BET7_FEATEX");
      synstrmaux_RegisterInStream((_WORD *)(a1 + 32), (uint64_t)"application/x-tnplus-words;version=1.0", 0, a1 + 872);
      synstrmaux_RegisterOutStream((_WORD *)(a1 + 32), (uint64_t)"application/x-json", a1 + 856);
      v7 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 32), *(_QWORD *)(a1 + 24), a3, a4);
      if ((v7 & 0x80000000) != 0)
        synstrmaux_CloseStreams((_WORD *)(a1 + 32), *(_QWORD *)(a1 + 24));
    }
  }
  return v7;
}

uint64_t bet7_featex_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  size_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  char *__s;
  uint64_t v31;
  uint64_t v32;

  v32 = 0;
  __s = 0;
  v31 = 0;
  v10 = 3223330824;
  if ((safeh_HandleCheck(a1, a2, 2053, 936) & 0x80000000) != 0 || !a1)
    return v10;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"BET7_FEATEX", 4, 0, (uint64_t)"Entering bet7_featex_Process", v7, v8, v9, v29);
  *a5 = 1;
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, char *, uint64_t *))(*(_QWORD *)(a1 + 24) + 144))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), (char *)&v32 + 4, &v32);
  if ((v10 & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"BET7_FEATEX", 59004, (uint64_t)"%s%x", v11, v12, v13, v14, "lhError");
  }
  else
  {
    if (!HIDWORD(v32))
    {
      if (!(_DWORD)v32)
      {
        *a5 = 0;
        goto LABEL_17;
      }
      v22 = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 32), *(_QWORD *)(a1 + 24));
      goto LABEL_14;
    }
    v15 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, char *))(*(_QWORD *)(a1 + 24) + 88))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), &v31, (char *)&v32 + 4);
    if ((v15 & 0x80000000) != 0)
    {
      v10 = v15;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"BET7_FEATEX", 59005, (uint64_t)"%s%s%s%x", v16, v17, v18, v19, "contentType");
      goto LABEL_17;
    }
    v20 = LuaVMLDO_RunFunctionWithTnplusWordsArgumentReturningPointerToString(*(_QWORD *)(a1 + 928), (uint64_t)"bet7_featex_process", HIDWORD(v32) / 0x98, v31, (uint64_t *)&__s);
    v10 = LH_ERROR_to_VERROR(v20);
    if ((v10 & 0x80000000) == 0 && __s)
    {
      v21 = cstdlib_strlen(__s);
      if (!v21
        || (v22 = (*(uint64_t (**)(_QWORD, _QWORD, char *, _QWORD))(*(_QWORD *)(a1 + 24) + 104))(*(_QWORD *)(a1 + 856), *(_QWORD *)(a1 + 864), __s, (v21 + 1)), (v22 & 0x80000000) == 0))
      {
        v23 = LuaVMLDO_ReleasePointerToString(*(_QWORD *)(a1 + 928));
        v22 = LH_ERROR_to_VERROR(v23);
      }
LABEL_14:
      v10 = v22;
    }
  }
LABEL_17:
  if (v31
    && ((*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 24) + 96))(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 880), HIDWORD(v32)) & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"BET7_FEATEX", 59006, (uint64_t)"%s%s%s%x", v24, v25, v26, v27, "contentType");
  }
  return v10;
}

uint64_t bet7_featex_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if ((safeh_HandleCheck(a1, a2, 2053, 936) & 0x80000000) != 0)
    return 3223330824;
  v6 = synstrmaux_CloseStreams((_WORD *)(a1 + 32), *(_QWORD *)(a1 + 24));
  if ((v6 & 0x80000000) != 0)
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"BET7_FEATEX", 3, 0, (uint64_t)"synstrmaux_CloseStreams error: %x", v3, v4, v5, v6);
  return v6;
}

uint64_t hlp_lua_log_callback_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"BET7_FEATEX", 4, 0, a2, a6, a7, a8, 0);
}

uint64_t neuralsynth_bet7_loc_CopyMarker(uint64_t a1, void *__dst, char **__src, int a4)
{
  uint64_t v4;
  uint64_t v9;
  int *v10;
  int v11;
  char *v12;
  void *v13;

  v4 = 3271565319;
  if (__dst && __src)
  {
    cstdlib_memcpy(__dst, __src, 0x20uLL);
    if (!a4)
      return 0;
    v9 = 0;
    v10 = &dword_24D29B080;
    while (1)
    {
      v11 = *v10;
      v10 += 4;
      if (v11 == *(_DWORD *)__src)
        break;
      if (++v9 == 8)
        return 0;
    }
    if (((0x9DuLL >> v9) & 1) == 0 && (v12 = __src[3]) != 0)
    {
      v13 = strhelper_Strdup(a1, v12);
      *((_QWORD *)__dst + 3) = v13;
      if (v13)
        return 0;
      else
        return 3271565322;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t neuralsynth_bet7_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 3271565313;
  result = 0;
  *a2 = &ITokenconverter_Bet7;
  return result;
}

uint64_t neuralsynth_bet7_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t inited;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  CustomAllocator *v10;
  uint64_t v12;
  uint64_t *v13;

  v3 = 3271565319;
  v13 = 0;
  if (a3)
  {
    *(_QWORD *)a3 = 0;
    *(_DWORD *)(a3 + 8) = 0;
    inited = InitRsrcFunction(a1, a2, &v13);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      v9 = neuralsynth_globalInit();
      v10 = (CustomAllocator *)v13;
      if ((v9 & 0x80000000) != 0)
      {
        log_OutText(v13[4], (uint64_t)"NEURALSYNTH_BET7", 1, 0, (uint64_t)"neuralsynth_bet7_ClassOpen : ONNX runtime was not loaded", v6, v7, v8, v12);
        return 3271565325;
      }
      else
      {
        *(_QWORD *)a3 = v13;
        *(_DWORD *)(a3 + 8) = 11995;
        if (SetCustomAllocatorResources(v10))
          return 3271565329;
        else
          return v9;
      }
    }
  }
  return v3;
}

uint64_t neuralsynth_bet7_ClassClose(CustomAllocator *a1)
{
  ClearCustomAllocatorResources(a1);
  return 0;
}

uint64_t neuralsynth_bet7_ObjOpen(uint64_t a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t Object;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;

  v29 = 0;
  v30 = 0;
  v5 = 3271565319;
  if (a5)
  {
    inited = InitRsrcFunction(a3, a4, &v30);
    if ((inited & 0x80000000) == 0)
    {
      inited = safeh_HandleCheck(a1, a2, 11995, 408);
      if ((inited & 0x80000000) == 0)
      {
        *(_QWORD *)a5 = 0;
        *(_DWORD *)(a5 + 8) = 0;
        log_OutText(*(_QWORD *)(v30 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Entering neuralsynth_bet7_ObjOpen", v12, v13, v14, v27);
        v15 = heap_Calloc(*(_QWORD **)(v30 + 8), 1, 1224);
        if (!v15)
        {
          log_OutPublic(*(_QWORD *)(v30 + 32), (uint64_t)"NEURALSYNTH_BET7", 59000, 0, v16, v17, v18, v19, v28);
          v5 = 3271565322;
          goto LABEL_12;
        }
        v20 = (_QWORD *)v15;
        Object = objc_GetObject(*(_QWORD *)(v30 + 48), (uint64_t)"SYNTHSTREAM", &v29);
        if ((Object & 0x80000000) != 0)
        {
          v5 = Object;
          log_OutPublic(*(_QWORD *)(v20[2] + 32), (uint64_t)"NEURALSYNTH_BET7", 59001, 0, v22, v23, v24, v25, v28);
        }
        else
        {
          v20[30] = *(_QWORD *)(v29 + 8);
          v20[3] = a1;
          v5 = neuralsynth_bet7_loc_ObjOpen(a3, a4, (uint64_t)v20);
          if ((v5 & 0x80000000) == 0)
          {
            *(_QWORD *)a5 = v20;
            *(_DWORD *)(a5 + 8) = 11994;
LABEL_12:
            log_OutText(*(_QWORD *)(v30 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Leaving neuralsynth_bet7_ObjOpen: %x", v12, v13, v14, v5);
            return v5;
          }
        }
        *(_QWORD *)a5 = v20;
        *(_DWORD *)(a5 + 8) = 11994;
        neuralsynth_bet7_ObjClose((uint64_t)v20, *(_QWORD *)(a5 + 8));
        *(_QWORD *)a5 = 0;
        *(_DWORD *)(a5 + 8) = 0;
        goto LABEL_12;
      }
    }
    v5 = inited;
    goto LABEL_12;
  }
  return v5;
}

uint64_t neuralsynth_bet7_ObjClose(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t NullHandle;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;

  v3 = safeh_HandleCheck(a1, a2, 11994, 1224);
  if ((v3 & 0x80000000) != 0)
    return 3271565320;
  v7 = v3;
  v8 = *(_QWORD *)(a1 + 16);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Entering neuralsynth_bet7_ObjClose", v4, v5, v6, v18);
  NullHandle = safeh_GetNullHandle();
  if (!safeh_HandlesEqual(*(_QWORD *)(a1 + 1072), *(_QWORD *)(a1 + 1080), NullHandle, v10))
  {
    v7 = neuralsynth_delete(*(uint64_t ***)(a1 + 1072), *(_QWORD *)(a1 + 1080));
    *(_QWORD *)(a1 + 1072) = 0;
    *(_DWORD *)(a1 + 1080) = 0;
    if ((v7 & 0x80000000) != 0)
      log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)"neuralsynth_delete: %x", v11, v12, v13, v7);
  }
  if (*(_QWORD *)(a1 + 240))
    v7 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
  neuralsynth_bet7_loc_FreeMarkers((_QWORD *)a1);
  heap_Free(*(_QWORD **)(v8 + 8), a1);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Leaving neuralsynth_bet7_ObjClose: %x", v14, v15, v16, v7);
  return v7;
}

uint64_t neuralsynth_bet7_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  if ((safeh_HandleCheck(a1, a2, 11994, 1224) & 0x80000000) != 0)
    return 3271565320;
  v6 = *(_QWORD *)(a1 + 16);
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Entering neuralsynth_bet7_ObjReopen", v3, v4, v5, v12);
  v7 = neuralsynth_bet7_loc_ObjOpen(*(_WORD **)a1, *(_QWORD *)(a1 + 8), a1);
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Leaving neuralsynth_bet7_ObjReopen: %x", v8, v9, v10, v7);
  return v7;
}

uint64_t neuralsynth_bet7_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;

  v8 = 3271565320;
  if ((safeh_HandleCheck(a1, a2, 11994, 1224) & 0x80000000) == 0)
  {
    v12 = *(_QWORD *)(a1 + 16);
    log_OutText(*(_QWORD *)(v12 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Entering neuralsynth_bet7_ProcessStart", v9, v10, v11, v17);
    *(_DWORD *)(a1 + 156) = 0;
    synstrmaux_InitStreamOpener(a1 + 248, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"NEURALSYNTH_BET7");
    if (synstrmaux_BuildAudioContentType("audio/L16;rate=", *(_DWORD *)(a1 + 1184), (char *)(a1 + 1136), 0x30uLL) <= 0x2F)
    {
      synstrmaux_RegisterInStream((_WORD *)(a1 + 248), (uint64_t)"application/x-json", 0, a1 + 1088);
      synstrmaux_RegisterOutStream((_WORD *)(a1 + 248), a1 + 1136, a1 + 1104);
      synstrmaux_RegisterOutStream((_WORD *)(a1 + 248), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
        a1 + 1120);
      v8 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 248), *(_QWORD *)(a1 + 240), a3, a4);
      if ((v8 & 0x80000000) == 0)
      {
        *(_QWORD *)(a1 + 168) = 0;
        neuralsynth_reset(*(_QWORD **)(a1 + 1072), *(_QWORD *)(a1 + 1080));
        neuralsynth_bet7_loc_CleanupMarkers((_QWORD *)a1);
        *(_QWORD *)(a1 + 1216) = 0;
LABEL_7:
        log_OutText(*(_QWORD *)(v12 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Leaving neuralsynth_bet7_ProcessStart: %x", v13, v14, v15, v8);
        return v8;
      }
    }
    else
    {
      v8 = 3271565321;
    }
    neuralsynth_bet7_ProcessEnd(a1, a2);
    goto LABEL_7;
  }
  return v8;
}

uint64_t neuralsynth_bet7_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *ArrayItem;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  _QWORD *ObjectItem;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  int ArraySize;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  const char *v66;
  uint64_t v67;
  const char *v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v85;
  _QWORD *v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  _QWORD *v93;
  int *v94;
  int *v95;
  const char *v96;
  int *v97;
  const char *v98;
  _QWORD *v99;
  _QWORD *v100;
  uint64_t StringValue;
  const char *v102;
  _QWORD *v103;
  uint64_t v104;
  char v105;
  char v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  _QWORD *v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  const char *v119;
  _BOOL4 IsString;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  char *v126;
  int *v127;
  uint64_t v128;
  uint64_t *v129;
  uint64_t v130;
  int v131;
  int v132;
  unsigned int v133;
  __int128 __src;
  __int128 v135;

  v7 = 3271565322;
  v131 = 0;
  v130 = 0;
  if ((safeh_HandleCheck(a1, a2, 11994, 1224) & 0x80000000) != 0)
    return 3271565320;
  v11 = *(_QWORD *)(a1 + 16);
  log_OutText(*(_QWORD *)(v11 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Entering neuralsynth_bet7_Process", v8, v9, v10, v124);
  if (!*(_DWORD *)(a1 + 156))
  {
    v12 = neuralsynth_bet7_loc_SetStyleVectors((_QWORD *)a1, (char *)(a1 + 48), "", a1 + 176, a1 + 192);
    if ((v12 & 0x80000000) != 0)
      goto LABEL_34;
    *(_DWORD *)(a1 + 156) = 1;
  }
  v132 = 0;
  v13 = LH_atou(*(const char **)(a1 + 136));
  v14 = (uint64_t *)(a1 + 160);
  if (*(_QWORD *)(a1 + 168))
  {
    v15 = 0;
    *(_DWORD *)(a1 + 228) = 0;
LABEL_7:
    v19 = neuralsynth_do_inference(*(_QWORD *)(a1 + 1072), *(_QWORD *)(a1 + 1080), (uint64_t)v14, a1 + 176, a1 + 192, (_QWORD *)(a1 + 1192), &v131, *(_DWORD *)(a1 + 232) == 0, v15);
    if ((v19 & 0x80000000) != 0)
    {
      log_OutText(*(_QWORD *)(v11 + 32), (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)"call to neuralsynth_do_inference failed: %x", v16, v17, v18, v19);
      goto LABEL_65;
    }
    v20 = *(_QWORD *)(a1 + 1200);
    if (v20)
    {
      v19 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 240) + 104))(*(_QWORD *)(a1 + 1104), *(_QWORD *)(a1 + 1112), *(_QWORD *)(a1 + 1192), (2 * v20));
      if ((v19 & 0x80000000) != 0)
      {
        v64 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
        goto LABEL_43;
      }
    }
    v25 = *(_QWORD *)(a1 + 1208);
    if (!v25)
      goto LABEL_55;
    v26 = *(_QWORD *)(v25 + 16);
    if (!v26)
      goto LABEL_55;
    v12 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, _QWORD))(*(_QWORD *)(a1 + 240) + 112))(*(_QWORD *)(a1 + 1120), *(_QWORD *)(a1 + 1128), &v130, (32 * v26));
    if ((v12 & 0x80000000) == 0)
    {
      v27 = *(uint64_t **)(a1 + 1208);
      if (v27[2])
      {
        v28 = 0;
        v29 = 0;
        while (1)
        {
          v30 = *v27;
          if (!v130 || v30 == 0)
            break;
          cstdlib_memcpy((void *)(v130 + v28), (const void *)(v30 + v28), 0x20uLL);
          ++v29;
          v27 = *(uint64_t **)(a1 + 1208);
          v32 = v27[2];
          v28 += 32;
          if (v29 >= v32)
          {
            v33 = (32 * v32);
            goto LABEL_53;
          }
        }
        v19 = 3271565319;
        goto LABEL_65;
      }
      v33 = 0;
LABEL_53:
      v19 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 240) + 120))(*(_QWORD *)(a1 + 1120), *(_QWORD *)(a1 + 1128), v33);
      if ((v19 & 0x80000000) == 0)
      {
        neuralsynth_bet7_loc_CleanupMarkers((_QWORD *)a1);
LABEL_55:
        *(_QWORD *)(a1 + 1216) += *(_QWORD *)(a1 + 1200);
        if (v131)
        {
          neuralsynth_bet7_loc_MoveToNextChunk((_QWORD *)a1);
          v19 = 0;
        }
        v69 = 2;
        goto LABEL_58;
      }
      v64 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_43:
      log_OutPublic(v64, (uint64_t)"NEURALSYNTH_BET7", 59007, (uint64_t)"%s%s%s%x", v21, v22, v23, v24, "contentType");
      goto LABEL_65;
    }
LABEL_34:
    v19 = v12;
    goto LABEL_65;
  }
  v34 = v13;
  v35 = *(_QWORD *)(a1 + 16);
  v36 = *(_QWORD *)(a1 + 208);
  if (v36)
  {
    v37 = *(_QWORD *)(a1 + 216);
    goto LABEL_24;
  }
  v133 = 0;
  *(_QWORD *)&__src = 0;
  if (((*(uint64_t (**)(_QWORD, _QWORD, unsigned int *, int *))(*(_QWORD *)(a1 + 240) + 144))(*(_QWORD *)(a1 + 1088), *(_QWORD *)(a1 + 1096), &v133, &v132) & 0x80000000) != 0)
  {
    v65 = *(_QWORD *)(v35 + 32);
    v66 = "Error reading segment stream";
LABEL_45:
    log_OutText(v65, (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)v66, v54, v55, v56, v125);
LABEL_62:
    *(_QWORD *)(a1 + 208) = 0;
    *(_DWORD *)(a1 + 224) = v133;
    v67 = *(_QWORD *)(v35 + 32);
    v68 = "Error reading data from the input stream";
    goto LABEL_63;
  }
  if (!v133)
  {
    *(_QWORD *)(a1 + 224) = 0x100000000;
    *(_QWORD *)(a1 + 208) = 0;
    *(_QWORD *)(a1 + 216) = 0;
    goto LABEL_48;
  }
  if (((*(uint64_t (**)(_QWORD, _QWORD, __int128 *, unsigned int *))(*(_QWORD *)(a1 + 240) + 88))(*(_QWORD *)(a1 + 1088), *(_QWORD *)(a1 + 1096), &__src, &v133) & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(v35 + 32), (uint64_t)"NEURALSYNTH_BET7", 59053, (uint64_t)"%s%s%s%x", v57, v58, v59, v60, "contentType");
    goto LABEL_62;
  }
  v61 = ttsJSON_Parse(*(_QWORD *)(v35 + 8), (char *)__src);
  if (!v61)
  {
    v65 = *(_QWORD *)(v35 + 32);
    v66 = "Input data stream is invalid. Expecting a JSON string";
    goto LABEL_45;
  }
  v36 = (uint64_t)v61;
  ArraySize = ttsJSON_GetArraySize((uint64_t)v61);
  v63 = v133;
  if (!ArraySize)
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 240) + 96))(*(_QWORD *)(a1 + 1088), *(_QWORD *)(a1 + 1096), v133);
    v63 = v133;
  }
  v37 = 0;
  *(_DWORD *)(a1 + 224) = v63;
  *(_DWORD *)(a1 + 228) = 1;
  *(_QWORD *)(a1 + 208) = v36;
  *(_QWORD *)(a1 + 216) = 0;
LABEL_24:
  if (v37 == (int)ttsJSON_GetArraySize(v36))
    goto LABEL_48;
  ArrayItem = ttsJSON_GetArrayItem(*(_QWORD *)(a1 + 208), *(_DWORD *)(a1 + 216));
  if (!ArrayItem)
  {
    v67 = *(_QWORD *)(v35 + 32);
    v68 = "Error reading features from the input stream";
LABEL_63:
    log_OutText(v67, (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)v68, v39, v40, v41, v125);
    v7 = 3271565578;
    goto LABEL_64;
  }
  v42 = ArrayItem;
  v43 = ttsJSON_GetArraySize((uint64_t)ArrayItem);
  if (!v43)
    goto LABEL_48;
  v44 = heap_Alloc(*(_QWORD *)(v35 + 8), 4 * v43);
  *v14 = v44;
  if (!v44)
  {
    log_OutPublic(*(_QWORD *)(v35 + 32), (uint64_t)"NEURALSYNTH_BET7", 59000, 0, v45, v46, v47, v48, v125);
    goto LABEL_64;
  }
  v128 = v35;
  v49 = ttsJSON_GetArrayItem(*(_QWORD *)(a1 + 208), *(_DWORD *)(a1 + 216));
  v50 = (uint64_t)v49;
  v129 = (uint64_t *)(a1 + 160);
  if (!v49)
    goto LABEL_74;
  if (!ttsJSON_GetArraySize((uint64_t)v49) || (v51 = ttsJSON_GetArrayItem(v50, 0)) == 0)
  {
    v85 = 0;
    v50 = 0;
    goto LABEL_75;
  }
  v52 = (uint64_t)v51;
  ObjectItem = ttsJSON_GetObjectItem((uint64_t)v51, "stylename");
  v50 = ObjectItem ? ObjectItem[4] : 0;
  v86 = ttsJSON_GetObjectItem(v52, "styleintensity");
  if (v86)
    v85 = (char *)v86[4];
  else
LABEL_74:
    v85 = 0;
LABEL_75:
  if (v50 | (unint64_t)v85)
  {
    if (!v50 || !cstdlib_strlen((const char *)v50))
      v50 = a1 + 48;
    if (v85)
      v87 = v85;
    else
      v87 = "";
    if ((neuralsynth_bet7_loc_SetStyleVectors((_QWORD *)a1, (char *)v50, v87, a1 + 176, a1 + 192) & 0x80000000) != 0)
      log_OutText(*(_QWORD *)(v128 + 32), (uint64_t)"NEURALSYNTH_BET7", 1, 0, (uint64_t)"Unable to set style templates at offset %d\n", v88, v89, v90, 0);
  }
  v91 = (_QWORD *)v42[2];
  v127 = a5;
  if (v91)
  {
    v15 = 0;
    v92 = 0;
    while (1)
    {
      v93 = ttsJSON_GetObjectItem((uint64_t)v91, "feat");
      if (v93)
        *(_DWORD *)(*v129 + 4 * v92++) = *((_DWORD *)v93 + 10);
      v94 = (int *)ttsJSON_GetObjectItem((uint64_t)v91, "type");
      if (!v94)
        goto LABEL_96;
      v95 = v94;
      v96 = (const char *)*((_QWORD *)v94 + 4);
      if (!v96 || cstdlib_strcmp(v96, "silence"))
        goto LABEL_93;
      v97 = (int *)ttsJSON_GetObjectItem((uint64_t)v91, "dur");
      if (v97)
        break;
LABEL_96:
      v91 = (_QWORD *)*v91;
      if (!v91)
        goto LABEL_99;
    }
    v95 = v97;
    v15 = vcvtad_u64_f64((double)v97[10] / (256000.0 / (double)v34));
LABEL_93:
    v98 = (const char *)*((_QWORD *)v95 + 4);
    if (v98 && !cstdlib_strcmp(v98, "phon"))
      *(_DWORD *)(a1 + 232) = 1;
    goto LABEL_96;
  }
  v92 = 0;
  v15 = 0;
LABEL_99:
  neuralsynth_bet7_loc_CleanupMarkers((_QWORD *)a1);
  v99 = (_QWORD *)v42[2];
  if (!v99)
  {
LABEL_129:
    *(_QWORD *)(a1 + 168) = v92;
    a5 = v127;
    v14 = (uint64_t *)(a1 + 160);
    if (v92)
      goto LABEL_7;
    heap_Free(*(_QWORD **)(v128 + 8), *v129);
    *v129 = 0;
    *(_QWORD *)(a1 + 168) = 0;
LABEL_48:
    if (!v132)
    {
      v70 = *(_QWORD *)(a1 + 16);
      v19 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 240) + 96))(*(_QWORD *)(a1 + 1088), *(_QWORD *)(a1 + 1096), *(unsigned int *)(a1 + 224));
      if ((v19 & 0x80000000) != 0)
      {
        log_OutPublic(*(_QWORD *)(v70 + 32), (uint64_t)"NEURALSYNTH_BET7", 59053, (uint64_t)"%s%s%s%x", v71, v72, v73, v74, "contentType");
        log_OutText(*(_QWORD *)(v11 + 32), (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)"call to neuralsynth_bet7_loc_EndOfInput failed: %x", v75, v76, v77, v19);
      }
      else
      {
        ttsJSON_Delete(*(_QWORD **)(a1 + 208));
        *(_QWORD *)(a1 + 208) = 0;
        *a5 = 0;
      }
      goto LABEL_65;
    }
    v19 = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 248), *(_QWORD *)(a1 + 240));
    v69 = 1;
LABEL_58:
    *a5 = v69;
    goto LABEL_65;
  }
  while (1)
  {
    v100 = ttsJSON_GetObjectItem((uint64_t)v99, "type");
    if (v100)
    {
      StringValue = ttsJSON_GetStringValue((uint64_t)v100);
      if (StringValue)
      {
        v102 = (const char *)StringValue;
        v103 = ttsJSON_GetObjectItem((uint64_t)v99, "attr");
        if (v103)
        {
          v126 = (char *)ttsJSON_GetStringValue((uint64_t)v103);
          if (v126)
          {
            v104 = 0;
            v105 = 1;
            while (1)
            {
              v106 = v105;
              if (!cstdlib_strcmp(v102, off_24D29B170[2 * v104]))
                break;
              v105 = 0;
              v104 = 1;
              if ((v106 & 1) == 0)
                goto LABEL_109;
            }
            if (!ttsJSON_AddStringToObject(v99, off_24D29B170[2 * v104 + 1], v126))
              goto LABEL_133;
          }
        }
      }
    }
LABEL_109:
    v110 = (_QWORD *)v99[2];
    if (v110)
      break;
LABEL_128:
    v99 = (_QWORD *)*v99;
    if (!v99)
      goto LABEL_129;
  }
  while (1)
  {
    __src = 0u;
    v135 = 0u;
    v111 = *(uint64_t **)(a1 + 1208);
    if (v111)
    {
      v112 = v111[2];
      if (v112 == v111[1])
      {
        v113 = heap_Realloc(*(uint64_t **)(*(_QWORD *)(a1 + 16) + 8), *v111, 32 * v112 + 4096);
        if (!v113)
          goto LABEL_132;
        v114 = *(uint64_t **)(a1 + 1208);
        v115 = v114[1] + 128;
        *v114 = v113;
        v114[1] = v115;
      }
    }
    else
    {
      v116 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), 1, 24);
      *(_QWORD *)(a1 + 1208) = v116;
      if (!v116)
        goto LABEL_132;
      v117 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), 128, 32);
      v118 = *(_QWORD *)(a1 + 1208);
      *(_QWORD *)v118 = v117;
      if (!v117)
        goto LABEL_132;
      *(_OWORD *)(v118 + 8) = xmmword_214FBE670;
    }
    v119 = (const char *)v110[7];
    if (v119)
      break;
LABEL_127:
    v110 = (_QWORD *)*v110;
    if (!v110)
      goto LABEL_128;
  }
  IsString = ttsJSON_IsString((_BOOL8)v110);
  *((_QWORD *)&v135 + 1) = 0;
  if (IsString)
    *((_QWORD *)&v135 + 1) = ttsJSON_GetStringValue((uint64_t)v110);
  else
    DWORD2(v135) = ttsJSON_GetNumberValue((uint64_t)v110);
  v121 = 0;
  while (cstdlib_strcmp(v119, (&gNeuralSynthTagMapping)[v121]))
  {
    v121 += 2;
    if (v121 == 16)
      goto LABEL_127;
  }
  *(_QWORD *)&__src = LODWORD((&gNeuralSynthTagMapping)[v121 + 1]);
  v122 = *(_QWORD *)(a1 + 1216);
  DWORD2(__src) = v121 == 14;
  HIDWORD(__src) = v122;
  LODWORD(v135) = 0;
  v123 = neuralsynth_bet7_loc_CopyMarker(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), (void *)(**(_QWORD **)(a1 + 1208) + 32 * *(_QWORD *)(*(_QWORD *)(a1 + 1208) + 16)), (char **)&__src, 1);
  if ((v123 & 0x80000000) == 0)
  {
    ++*(_QWORD *)(*(_QWORD *)(a1 + 1208) + 16);
    goto LABEL_127;
  }
  v7 = v123;
LABEL_132:
  neuralsynth_bet7_loc_FreeMarkers((_QWORD *)a1);
LABEL_133:
  log_OutText(*(_QWORD *)(v128 + 32), (uint64_t)"NEURALSYNTH_BET7", 1, 0, (uint64_t)"Unable to parse JSON input\n", v107, v108, v109, v125);
LABEL_64:
  log_OutText(*(_QWORD *)(v11 + 32), (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)"call to neuralsynth_bet7_loc_GetChunk failed: %x", v78, v79, v80, v7);
  v19 = v7;
LABEL_65:
  neuralsynth_free_vector_pcm_data((_QWORD *)(a1 + 1192));
  log_OutText(*(_QWORD *)(v11 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Leaving neuralsynth_bet7_Process: %x", v81, v82, v83, v19);
  return v19;
}

uint64_t neuralsynth_bet7_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;

  if ((safeh_HandleCheck(a1, a2, 11994, 1224) & 0x80000000) != 0)
    return 3271565320;
  v6 = *(_QWORD *)(a1 + 16);
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Entering neuralsynth_bet7_ProcessEnd", v3, v4, v5, v14);
  v7 = *(_QWORD **)(a1 + 208);
  if (v7)
  {
    ttsJSON_Delete(v7);
    *(_QWORD *)(a1 + 208) = 0;
  }
  if (*(_DWORD *)(a1 + 156) == 1)
  {
    neuralsynth_free_vector_style_template((_QWORD *)(a1 + 176));
    neuralsynth_free_vector_style_shape_template((_QWORD *)(a1 + 192));
    *(_DWORD *)(a1 + 156) = 0;
  }
  v8 = *(_QWORD *)(a1 + 160);
  if (v8)
  {
    heap_Free(*(_QWORD **)(v6 + 8), v8);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v12 = synstrmaux_CloseStreams((_WORD *)(a1 + 248), *(_QWORD *)(a1 + 240));
  if ((v12 & 0x80000000) != 0)
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)"synstrmaux_CloseStreams failed", v9, v10, v11, v15);
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Leaving neuralsynth_bet7_ProcessEnd: %x", v9, v10, v11, v12);
  return v12;
}

uint64_t neuralsynth_bet7_loc_ObjOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t inited;
  uint64_t v7;
  uint64_t UInt;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t Str;
  uint64_t NullHandle;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t voice_specific_broker_string;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *ObjectItem;
  _QWORD *v32;
  const char *StringValue;
  const char *v34;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _DWORD __n[3];
  uint64_t v41;
  uint64_t v42;
  char v43[256];
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  inited = InitRsrcFunction(a1, a2, &v39);
  if ((inited & 0x80000000) != 0)
    return inited;
  *(_QWORD *)a3 = a1;
  *(_QWORD *)(a3 + 8) = a2;
  v7 = v39;
  *(_QWORD *)(a3 + 16) = v39;
  *(_QWORD *)(a3 + 136) = "22050";
  UInt = paramc_ParamGetUInt(*(_QWORD *)(v7 + 40), (uint64_t)"frequencyhz", (unsigned int *)(a3 + 1184));
  v13 = *(_QWORD *)(a3 + 16);
  if ((UInt & 0x80000000) != 0
    || (UInt = paramc_ParamGetStr(*(_QWORD *)(v13 + 40), (uint64_t)"voice", (_QWORD *)(a3 + 32)),
        v13 = *(_QWORD *)(a3 + 16),
        (UInt & 0x80000000) != 0)
    || (UInt = paramc_ParamGetStr(*(_QWORD *)(v13 + 40), (uint64_t)"langcode", (_QWORD *)(a3 + 40)),
        v13 = *(_QWORD *)(a3 + 16),
        (UInt & 0x80000000) != 0))
  {
    v25 = UInt;
LABEL_24:
    log_OutPublic(*(_QWORD *)(v13 + 32), (uint64_t)"NEURALSYNTH_BET7", 59008, (uint64_t)"%s%s", v9, v10, v11, v12, "parameter");
    return v25;
  }
  Str = paramc_ParamGetStr(*(_QWORD *)(v13 + 40), (uint64_t)"voiceoperatingpoint", (_QWORD *)(a3 + 128));
  if ((Str & 0x80000000) != 0)
  {
    v25 = Str;
    v13 = *(_QWORD *)(a3 + 16);
    goto LABEL_24;
  }
  *(_QWORD *)(a3 + 144) = 0;
  paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a3 + 24) + 40), (uint64_t)"affinitylist", (_QWORD *)(a3 + 144));
  if ((paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a3 + 24) + 40), (uint64_t)"forceaffinity", (_DWORD *)(a3 + 152)) & 0x80000000) != 0)
    *(_DWORD *)(a3 + 152) = -1;
  NullHandle = safeh_GetNullHandle();
  if (!safeh_HandlesEqual(*(_QWORD *)(a3 + 1072), *(_QWORD *)(a3 + 1080), NullHandle, v16))
  {
    v17 = neuralsynth_delete(*(uint64_t ***)(a3 + 1072), *(_QWORD *)(a3 + 1080));
    *(_QWORD *)(a3 + 1072) = 0;
    *(_DWORD *)(a3 + 1080) = 0;
    if ((v17 & 0x80000000) != 0)
      log_OutText(*(_QWORD *)(v39 + 32), (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)"neuralsynth_delete: %x", v18, v19, v20, v17);
  }
  v41 = 0;
  v42 = 0;
  memset(__n, 0, sizeof(__n));
  voice_specific_broker_string = InitRsrcFunction(a1, a2, &v42);
  if ((voice_specific_broker_string & 0x80000000) != 0
    || (voice_specific_broker_string = bet7_generate_voice_specific_broker_string(v42, "config/json", v43),
        (voice_specific_broker_string & 0x80000000) != 0)
    || (voice_specific_broker_string = brk_DataOpen(*(_QWORD *)(v42 + 24)),
        (voice_specific_broker_string & 0x80000000) != 0)
    || (voice_specific_broker_string = brk_DataMapEx(*(_QWORD *)(v42 + 24), v41, 0, (uint64_t)__n, (uint64_t)&__n[1]),
        (voice_specific_broker_string & 0x80000000) != 0))
  {
    v25 = voice_specific_broker_string;
  }
  else
  {
    v25 = 3271565332;
    v26 = (char *)heap_Alloc(*(_QWORD *)(v42 + 8), (__n[0] + 1));
    if (v26)
    {
      v27 = v26;
      cstdlib_strncpy(v26, *(const char **)&__n[1], __n[0]);
      v27[__n[0]] = 0;
      v28 = v42;
      *(_BYTE *)(a3 + 48) = 0;
      v29 = ttsJSON_Parse(*(_QWORD *)(v28 + 8), v27);
      v30 = v29;
      if (v29)
      {
        ObjectItem = ttsJSON_GetObjectItem((uint64_t)v29, "Params");
        if (ObjectItem)
        {
          v32 = ttsJSON_GetObjectItem((uint64_t)ObjectItem, "default_style");
          if (v32)
          {
            StringValue = (const char *)ttsJSON_GetStringValue((uint64_t)v32);
            if (StringValue)
            {
              v34 = StringValue;
              if (cstdlib_strlen(StringValue) <= 0x4F)
              {
                cstdlib_strcpy((char *)(a3 + 48), v34);
                v25 = 0;
              }
            }
          }
        }
      }
      ttsJSON_Delete(v30);
      heap_Free(*(_QWORD **)(v42 + 8), (uint64_t)v27);
    }
    else
    {
      v25 = 3271565322;
    }
    if (*(_QWORD *)&__n[1])
    {
      brk_DataUnmap(*(_QWORD *)(v42 + 24), v41, *(uint64_t *)&__n[1]);
      if (*(_QWORD *)&__n[1])
        brk_DataClose(*(_QWORD *)(v42 + 24), v41);
    }
  }
  if ((v25 & 0x80000000) == 0 || (v25 & 0x1FFF) == 0x14)
  {
    v25 = neuralsynth_new(a1, a2, *(_QWORD *)(a3 + 40), *(_QWORD *)(a3 + 32), *(_QWORD *)(a3 + 128), *(_QWORD *)(a3 + 136), *(_QWORD *)(a3 + 144), *(_DWORD *)(a3 + 152), a3 + 1072);
    if ((v25 & 0x80000000) != 0)
      log_OutText(*(_QWORD *)(*(_QWORD *)(a3 + 16) + 32), (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)"neuralsynth_new: %x", v36, v37, v38, v25);
  }
  else
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a3 + 16) + 32), (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)"neuralsynth_bet7_getDefaultStyleFromJsonInfo: %x", v22, v23, v24, v25);
  }
  return v25;
}

_QWORD *neuralsynth_bet7_loc_FreeMarkers(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;

  if (result)
  {
    v1 = result;
    v2 = (_QWORD *)result[151];
    if (v2)
    {
      if (*v2)
      {
        neuralsynth_bet7_loc_CleanupMarkers(result);
        heap_Free(*(_QWORD **)(v1[2] + 8), *(_QWORD *)v1[151]);
        v2 = (_QWORD *)v1[151];
        *v2 = 0;
      }
      result = heap_Free(*(_QWORD **)(v1[2] + 8), (uint64_t)v2);
      v1[151] = 0;
    }
  }
  return result;
}

_QWORD *neuralsynth_bet7_loc_CleanupMarkers(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;

  if (result)
  {
    v1 = result;
    v2 = result[151];
    if (v2)
    {
      v3 = *(_QWORD *)(v2 + 16);
      if (v3)
      {
        do
        {
          v4 = 0;
          v5 = *(_QWORD *)v1[151];
          --v3;
          v6 = &dword_24D29B080;
          while (1)
          {
            v7 = *v6;
            v6 += 4;
            if (v7 == *(_DWORD *)(v5 + 32 * v3))
              break;
            if (++v4 == 8)
              goto LABEL_11;
          }
          if (((0x9DuLL >> v4) & 1) == 0)
          {
            v8 = *(_QWORD *)(v5 + 32 * v3 + 24);
            if (v8)
            {
              result = heap_Free(*(_QWORD **)(v1[2] + 8), v8);
              *(_QWORD *)(*(_QWORD *)v1[151] + 32 * v3 + 24) = 0;
            }
          }
LABEL_11:
          ;
        }
        while (v3);
        v2 = v1[151];
      }
      *(_QWORD *)(v2 + 16) = 0;
    }
  }
  return result;
}

uint64_t neuralsynth_bet7_loc_SetStyleVectors(_QWORD *a1, char *__s, char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t style_vectors;
  _OWORD v19[5];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  memset(v19, 0, sizeof(v19));
  if (cstdlib_strlen(__s)
    && neuralsynth_bet7_loc_GetStyleTemplateName(a1, __s, a3, (char *)v19, v10, v11, v12, v13)
    || neuralsynth_bet7_loc_GetStyleTemplateName(a1, "neutral", "", (char *)v19, v10, v11, v12, v13))
  {
    log_OutText(*(_QWORD *)(a1[2] + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Setting style template for [%s;%s]: [%s]",
      v11,
      v12,
      v13,
      (uint64_t)__s);
    style_vectors = neuralsynth_get_style_vectors(a1[134], a1[135], (char *)v19, a4, a5);
    if ((style_vectors & 0x80000000) != 0)
      log_OutText(*(_QWORD *)(a1[2] + 32), (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)"Unable to set style template: [%s]", v14, v15, v16, (uint64_t)v19);
  }
  else
  {
    log_OutText(*(_QWORD *)(a1[2] + 32), (uint64_t)"NEURALSYNTH_BET7", 0, 0, (uint64_t)"Style template for default style [%s] not available", v11, v12, v13, (uint64_t)"neutral");
    return 3271565312;
  }
  return style_vectors;
}

double neuralsynth_bet7_loc_MoveToNextChunk(_QWORD *a1)
{
  uint64_t v2;
  double result;

  v2 = a1[20];
  if (v2)
  {
    heap_Free(*(_QWORD **)(a1[2] + 8), v2);
    a1[20] = 0;
  }
  a1[21] = 0;
  ++a1[27];
  *(_QWORD *)&result = 1;
  *(_QWORD *)((char *)a1 + 228) = 1;
  return result;
}

uint64_t neuralsynth_bet7_loc_GetStyleTemplateName(_QWORD *a1, char *__s, char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v12;
  uint64_t is_style_supported;
  char __s2[16];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  char __src[16];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  *(_OWORD *)__src = 0u;
  v17 = 0u;
  v18 = 0u;
  *(_OWORD *)__s2 = 0u;
  v16 = 0u;
  if (!__s
    || !a3
    || !cstdlib_strlen(__s)
    || cstdlib_strlen(__s) - 80 < 0xFFFFFFFFFFFFFFAFLL
    || cstdlib_strlen(a3) - 80 < 0xFFFFFFFFFFFFFFAFLL)
  {
    goto LABEL_6;
  }
  neuralsynth_bet7_loc_NormalizeString(__s, __src);
  neuralsynth_bet7_loc_NormalizeString(a3, __s2);
  cstdlib_strcpy(a4, __src);
  if (__s2[0])
  {
    cstdlib_strcat(a4, "_");
    cstdlib_strcat(a4, __s2);
  }
  if ((is_style_supported = neuralsynth_is_style_supported(a1[134], a1[135], a4), (_DWORD)is_style_supported)
    || cstdlib_strcmp(__s2, "medium")
    && (cstdlib_strcpy(a4, __src),
        cstdlib_strcat(a4, "_medium"),
        is_style_supported = neuralsynth_is_style_supported(a1[134], a1[135], a4),
        (_DWORD)is_style_supported)
    || cstdlib_strlen(__s2)
    && (cstdlib_strcpy(a4, __src),
        is_style_supported = neuralsynth_is_style_supported(a1[134], a1[135], a4),
        (_DWORD)is_style_supported))
  {
    log_OutText(*(_QWORD *)(a1[2] + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Style template for [%s;%s]: [%s]",
      a6,
      a7,
      a8,
      (uint64_t)__s);
  }
  else
  {
LABEL_6:
    *a4 = 0;
    if (__s)
      v12 = __s;
    else
      v12 = "";
    log_OutText(*(_QWORD *)(a1[2] + 32), (uint64_t)"NEURALSYNTH_BET7", 4, 0, (uint64_t)"Style template for [%s;%s]: not found",
      a6,
      a7,
      a8,
      (uint64_t)v12);
    return 0;
  }
  return is_style_supported;
}

size_t neuralsynth_bet7_loc_NormalizeString(char *__s, _BYTE *a2)
{
  uint64_t v4;
  int v5;
  size_t result;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  _BYTE *v12;
  int v13;

  v4 = 0;
  do
    v5 = __s[v4++];
  while (v5 == 32);
  result = cstdlib_strlen(__s);
  v7 = v4 - 1;
  if (v4 - 1 >= result)
  {
    *a2 = 0;
  }
  else
  {
    v8 = 0;
    do
    {
      v9 = __s[v7];
      if ((_DWORD)v9 == 32)
      {
        a2[v8] = 95;
        do
        {
          v10 = v7 + 1;
          v11 = __s[++v7];
        }
        while (v11 == 32);
      }
      else
      {
        a2[v8] = cstdlib_tolower(v9);
        v10 = v7 + 1;
      }
      ++v8;
      result = cstdlib_strlen(__s);
      v7 = v10;
    }
    while (v10 < result);
    a2[v8] = 0;
    if (v8)
    {
      v12 = a2 - 1;
      do
      {
        v13 = v12[v8];
        if (v13 != 95 && v13 != 32)
          break;
        v12[v8--] = 0;
      }
      while (v8);
    }
  }
  return result;
}

uint64_t neuralsynth_new(_WORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, uint64_t a9)
{
  uint64_t inited;
  char *v12;
  char *v13;
  uint64_t *v14;
  uint64_t *v15;
  _QWORD *v16;
  _QWORD *ObjectItem;
  uint64_t v18;
  int v19;
  double *v20;
  int v21;
  double *v22;
  int v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  _DWORD __n[3];
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  char v32[256];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v29 = 0;
  v30 = 0;
  memset(__n, 0, sizeof(__n));
  if (!a9)
    return 3271565319;
  *(_QWORD *)a9 = 0;
  *(_DWORD *)(a9 + 8) = 0;
  inited = InitRsrcFunction(a1, a2, &v30);
  if ((inited & 0x80000000) == 0)
  {
    inited = bet7_generate_voice_specific_broker_string((uint64_t)v30, "config/json", v32);
    if ((inited & 0x80000000) == 0)
    {
      inited = brk_DataOpen(v30[3]);
      if ((inited & 0x80000000) == 0)
      {
        inited = brk_DataMapEx(v30[3], v29, 0, (uint64_t)__n, (uint64_t)&__n[1]);
        if ((inited & 0x80000000) == 0)
        {
          v12 = (char *)heap_Alloc(v30[1], (__n[0] + 1));
          v13 = v12;
          if (v12)
          {
            cstdlib_strncpy(v12, *(const char **)&__n[1], __n[0]);
            v13[__n[0]] = 0;
            v14 = v30;
            v31 = 0;
            v15 = v30 + 5;
            paramc_ParamGetUInt(v30[5], (uint64_t)"bet7_output_frames_first_cycle", (unsigned int *)&v31 + 1);
            paramc_ParamGetUInt(*v15, (uint64_t)"bet7_output_frames_per_cycle", (unsigned int *)&v31);
            if (v31)
            {
              v16 = ttsJSON_Parse(v14[1], v13);
              ObjectItem = ttsJSON_GetObjectItem((uint64_t)v16, "Params");
              v18 = (uint64_t)ObjectItem;
              if (!ObjectItem)
                goto LABEL_20;
              v19 = HIDWORD(v31);
              if (HIDWORD(v31))
              {
                v20 = (double *)ttsJSON_GetObjectItem((uint64_t)ObjectItem, "output_frames_first_cycle");
                if (v20)
                {
                  v20[6] = (double)v19;
                  *((_DWORD *)v20 + 10) = v19;
                }
              }
              v21 = v31;
              if ((_DWORD)v31)
              {
                v22 = (double *)ttsJSON_GetObjectItem(v18, "output_frames_per_cycle");
                if (v22)
                {
                  v22[6] = (double)v21;
                  *((_DWORD *)v22 + 10) = v21;
                }
              }
              v23 = cstdlib_strlen(v13);
              v24 = (char *)ttsJSON_PrintBuffered((uint64_t)v16, v23 + 16, 0);
              if (v24)
                heap_Free((_QWORD *)v14[1], (uint64_t)v13);
              else
LABEL_20:
                v24 = v13;
              ttsJSON_Delete(v16);
            }
            else
            {
              v24 = v13;
            }
            v26 = operator new(80);
            NEURALSYNTH_S::NEURALSYNTH_S(v26, (uint64_t)v30, v24, a7, a8);
            if (v26)
            {
              *(_QWORD *)a9 = v26;
              *(_DWORD *)(a9 + 8) = 11996;
              v25 = inited;
            }
            else
            {
              v25 = 3271565322;
            }
            heap_Free((_QWORD *)v30[1], (uint64_t)v24);
          }
          else
          {
            v25 = 3271565322;
          }
          if (*(_QWORD *)&__n[1])
          {
            brk_DataUnmap(v30[3], v29, *(uint64_t *)&__n[1]);
            if (*(_QWORD *)&__n[1])
              brk_DataClose(v30[3], v29);
          }
          return v25;
        }
      }
    }
  }
  return inited;
}

#error "214E763EC: call analysis failed (funcsize=43)"

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

uint64_t neuralsynth_delete(uint64_t **a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = safeh_HandleCheck((uint64_t)a1, a2, 11996, 80);
  if ((v3 & 0x80000000) != 0)
    return 3271565320;
  v4 = v3;
  if (a1)
  {
    NEURALSYNTH_S::~NEURALSYNTH_S(a1);
    operator delete(v5);
  }
  return v4;
}

uint64_t neuralsynth_do_inference(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, int *a7, int a8, uint64_t a9)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  size_t v24;
  _QWORD *v25;
  _WORD *v26;
  float *v27;
  BOOL v28;
  unint64_t v29;
  float v30;
  uint64_t v31;
  uint64_t *v33[4];
  uint64_t **v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38[4];
  uint64_t *v39[4];
  void *v40[4];
  void *__dst[4];
  uint64_t *v42[4];
  void *v43[4];
  uint64_t **v44;

  v16 = safeh_HandleCheck(a1, a2, 11996, 80);
  if ((v16 & 0x80000000) != 0)
    return 3271565320;
  v17 = v16;
  v18 = *(_QWORD *)(a3 + 8);
  std::vector<int,ENTTS::Allocator<int>>::vector((uint64_t *)v43, (int)v18);
  memcpy(v43[0], *(const void **)a3, 4 * *(_QWORD *)(a3 + 8));
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::vector((uint64_t *)v42, 2uLL);
  v19 = v42[0];
  *v42[0] = 1;
  v19[1] = v18;
  std::vector<float,ENTTS::Allocator<float>>::vector((uint64_t *)__dst, *(_QWORD *)(a4 + 8));
  memcpy(__dst[0], *(const void **)a4, 4 * *(_QWORD *)(a4 + 8));
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::vector((uint64_t *)v40, *(_QWORD *)(a5 + 8));
  memcpy(v40[0], *(const void **)a5, 8 * *(_QWORD *)(a5 + 8));
  memset(v39, 0, 24);
  v39[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(v38, 0, 24);
  v38[3] = (uint64_t *)CustomAllocator::mRsrc;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = CustomAllocator::mRsrc;
  memset(v33, 0, 24);
  v33[3] = (uint64_t *)CustomAllocator::mRsrc;
  v20 = (***(uint64_t (****)(_QWORD, void **, uint64_t **, void **, void **, uint64_t **, uint64_t **, uint64_t, BOOL))a1)(*(_QWORD *)a1, v43, v42, __dst, v40, v39, v38, a9, a8 != 0);
  *a7 = v20;
  VocoderStreamer::do_inference_chunk(*(uint64_t ***)(a1 + 32), v39, (uint64_t)v38, (uint64_t *)&v34, (uint64_t *)v33, v20);
  v22 = (uint64_t *)v34;
  v21 = v35;
  v23 = (char *)v35 - (char *)v34;
  v24 = ((char *)v35 - (char *)v34) >> 1;
  v25 = (_QWORD *)operator new(v24 + 8);
  *v25 = v23 >> 2;
  v26 = v25 + 1;
  if (v21 != v22)
    bzero(v25 + 1, v24);
  *a6 = v26;
  if (v26)
  {
    v27 = (float *)v34;
    v28 = v35 == (uint64_t *)v34;
    v29 = ((char *)v35 - (char *)v34) >> 2;
    a6[1] = v29;
    if (!v28)
    {
      if (v29 <= 1)
        v29 = 1;
      do
      {
        v30 = *v27++;
        *v26++ = (int)(float)(v30 * 32767.0);
        --v29;
      }
      while (v29);
    }
    v31 = v17;
  }
  else
  {
    v31 = 3271565322;
  }
  v44 = v33;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v44);
  v33[0] = (uint64_t *)&v34;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v33);
  v34 = v38;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v34);
  v38[0] = (uint64_t *)v39;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v38);
  v39[0] = (uint64_t *)v40;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](v39);
  v40[0] = __dst;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)v40);
  __dst[0] = v42;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)__dst);
  v42[0] = (uint64_t *)v43;
  std::vector<int,ENTTS::Allocator<int>>::__destroy_vector::operator()[abi:ne180100](v42);
  return v31;
}

uint64_t neuralsynth_reset(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = safeh_HandleCheck((uint64_t)a1, a2, 11996, 80);
  if ((v3 & 0x80000000) != 0)
    return 3271565320;
  v4 = v3;
  (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1);
  *(_BYTE *)(a1[4] + 344) = 1;
  return v4;
}

uint64_t neuralsynth_is_style_supported(uint64_t a1, int a2, char *a3)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  _BOOL8 v7;
  std::__shared_weak_count *v8;
  uint64_t v10[2];
  char v11;
  uint64_t v12;
  uint64_t *v13[4];
  float *v14;
  float *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20[2];
  char v21;
  uint64_t v22;
  _QWORD *v23[6];
  char v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t **v27;

  if ((safeh_HandleCheck(a1, a2, 11996, 80) & 0x80000000) != 0)
    return 3271565320;
  v5 = *(std::__shared_weak_count **)(a1 + 48);
  v18 = *(_QWORD *)(a1 + 40);
  v19 = v5;
  if (v5)
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  StyleTemplateManager::StyleTemplateManager(v20, &v18);
  v6 = v19;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = CustomAllocator::mRsrc;
  memset(v13, 0, 24);
  v13[3] = (uint64_t *)CustomAllocator::mRsrc;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v10, a3);
  StyleTemplateManager::get_style_template((uint64_t)v20, (uint64_t)v10, (uint64_t *)&v14, (uint64_t *)v13);
  if (v11 < 0)
    heap_Free(*(_QWORD **)(v12 + 8), v10[0]);
  v7 = v15 != v14 && *v14 != 0.0;
  v27 = v13;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v27);
  v13[0] = (uint64_t *)&v14;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v13);
  v8 = v26;
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v24 < 0)
    heap_Free(*(_QWORD **)(v25 + 8), (uint64_t)v23[4]);
  std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::destroy((uint64_t)v23, v23[1]);
  if (v21 < 0)
    heap_Free(*(_QWORD **)(v22 + 8), v20[0]);
  return v7;
}

void sub_214E76B38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  va_list va1;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va2;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  va_list va3;

  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v9 = va_arg(va2, uint64_t *);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v14 = va_arg(va3, _QWORD);
  v16 = va_arg(va3, _QWORD);
  v17 = va_arg(va3, _QWORD);
  v18 = va_arg(va3, _QWORD);
  v19 = va_arg(va3, _QWORD);
  v20 = va_arg(va3, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  *(_QWORD *)(v2 - 40) = va1;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v2 - 40));
  va_copy((va_list)v9, va2);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va1);
  StyleTemplateManager::~StyleTemplateManager((StyleTemplateManager *)va3);
  _Unwind_Resume(a1);
}

uint64_t std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), *(_QWORD *)a1);
  return a1;
}

void StyleTemplateManager::~StyleTemplateManager(StyleTemplateManager *this)
{
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 96);
  if (*((char *)this + 87) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 11) + 8), *((_QWORD *)this + 8));
  std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::destroy((uint64_t)this + 32, *((_QWORD **)this + 5));
  if (*((char *)this + 23) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 3) + 8), *(_QWORD *)this);
}

uint64_t neuralsynth_get_style_vectors(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  float *v14;
  float *v15;
  int64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t *v19;
  uint64_t *v20;
  int64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  uint64_t v26[2];
  char v27;
  uint64_t v28;
  float **v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  float *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  uint64_t v39[2];
  char v40;
  uint64_t v41;
  _QWORD *v42[6];
  char v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  uint64_t **v46;

  v9 = 3271565330;
  v10 = safeh_HandleCheck(a1, a2, 11996, 80);
  if ((v10 & 0x80000000) != 0)
    return 3271565320;
  v11 = v10;
  v12 = *(std::__shared_weak_count **)(a1 + 48);
  v37 = *(_QWORD *)(a1 + 40);
  v38 = v12;
  if (v12)
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  StyleTemplateManager::StyleTemplateManager(v39, &v37);
  v13 = v38;
  if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = CustomAllocator::mRsrc;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = CustomAllocator::mRsrc;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v26, a3);
  StyleTemplateManager::get_style_template((uint64_t)v39, (uint64_t)v26, (uint64_t *)&v33, (uint64_t *)&v29);
  if (v27 < 0)
    heap_Free(*(_QWORD **)(v28 + 8), v26[0]);
  if (v34 != v33 && *v33 != 0.0)
  {
    if (a4)
    {
      if (*(_QWORD *)a4)
        operator delete(*(_QWORD *)a4 - 8);
      *(_QWORD *)a4 = 0;
    }
    if (a5)
    {
      if (*(_QWORD *)a5)
        operator delete(*(_QWORD *)a5 - 8);
      *(_QWORD *)a5 = 0;
    }
    v15 = v33;
    v14 = v34;
    v16 = (char *)v34 - (char *)v33;
    v17 = (_QWORD *)operator new((char *)v34 - (char *)v33 + 8);
    *v17 = v16 >> 2;
    v18 = v17 + 1;
    if (v14 != v15)
      bzero(v17 + 1, v16);
    *(_QWORD *)a4 = v18;
    v20 = (uint64_t *)v29;
    v19 = v30;
    v21 = (char *)v30 - (char *)v29;
    v22 = (_QWORD *)operator new((char *)v30 - (char *)v29 + 8);
    *v22 = v21 >> 3;
    v23 = v22 + 1;
    if (v19 != v20)
      bzero(v22 + 1, v21);
    *(_QWORD *)a5 = v23;
    memcpy(*(void **)a4, v33, (char *)v34 - (char *)v33);
    *(_QWORD *)(a4 + 8) = v34 - v33;
    memcpy(*(void **)a5, v29, (char *)v30 - (char *)v29);
    *(_QWORD *)(a5 + 8) = ((char *)v30 - (char *)v29) >> 3;
    v9 = v11;
  }
  v46 = (uint64_t **)&v29;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v46);
  v29 = &v33;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v29);
  v24 = v45;
  if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  if (v43 < 0)
    heap_Free(*(_QWORD **)(v44 + 8), (uint64_t)v42[4]);
  std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::destroy((uint64_t)v42, v42[1]);
  if (v40 < 0)
    heap_Free(*(_QWORD **)(v41 + 8), v39[0]);
  return v9;
}

void sub_214E76EDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  va_list va1;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va2;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  va_list va3;

  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v9 = va_arg(va2, uint64_t *);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v14 = va_arg(va3, _QWORD);
  v16 = va_arg(va3, _QWORD);
  v17 = va_arg(va3, _QWORD);
  v18 = va_arg(va3, _QWORD);
  v19 = va_arg(va3, _QWORD);
  v20 = va_arg(va3, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  *(_QWORD *)(v2 - 72) = va1;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v2 - 72));
  va_copy((va_list)v9, va2);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va1);
  StyleTemplateManager::~StyleTemplateManager((StyleTemplateManager *)va3);
  _Unwind_Resume(a1);
}

_QWORD *neuralsynth_free_vector_style_template(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    v1 = result;
    if (*result)
      result = operator delete(*result - 8);
    *v1 = 0;
  }
  return result;
}

_QWORD *neuralsynth_free_vector_style_shape_template(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    v1 = result;
    if (*result)
      result = operator delete(*result - 8);
    *v1 = 0;
  }
  return result;
}

_QWORD *neuralsynth_free_vector_pcm_data(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    v1 = result;
    if (*result)
      result = operator delete(*result - 8);
    *v1 = 0;
  }
  return result;
}

uint64_t neuralsynth_globalInit()
{
  return 0;
}

uint64_t NEURALSYNTH_S::NEURALSYNTH_S(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, unsigned int a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  VOCODER_INPUT_S *v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  uint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  __int128 v39;
  unsigned int v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;

  v42 = a3;
  v43 = a2;
  v41 = a4;
  v40 = a5;
  *(_QWORD *)(a1 + 16) = 0;
  v6 = a1 + 16;
  *(_OWORD *)(a1 + 40) = 0u;
  v7 = a1 + 40;
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  v8 = a1 + 56;
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 32);
  ENTTS::make_shared<PipelineServices,RSRC_S const*&,char const*&,int &>(&v43, &v41, &v40, &v39);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>(v7, &v39);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
  if (*((_QWORD *)&v39 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v39 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  v38 = *(_QWORD *)(v43 + 8);
  ENTTS::make_shared<CJsonWrapper,void *,char const*&>(&v38, &v42, &v39);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>(v8, &v39);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
  if (*((_QWORD *)&v39 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v39 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  v11 = operator new(896);
  v12 = v11;
  v13 = *(std::__shared_weak_count **)(a1 + 48);
  v36 = *(_QWORD *)(a1 + 40);
  v37 = v13;
  if (v13)
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  v14 = *(std::__shared_weak_count **)(a1 + 64);
  v34 = *(_QWORD *)(a1 + 56);
  v35 = v14;
  if (v14)
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  TC2Engine::TC2Engine(v11, &v36, &v34);
  *(_QWORD *)a1 = v12;
  v15 = v35;
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  v16 = v37;
  if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  v17 = (VOCODER_INPUT_S *)operator new(16);
  VOCODER_INPUT_S::VOCODER_INPUT_S(v17);
  *(_QWORD *)(a1 + 8) = v17;
  v18 = *(std::__shared_weak_count **)(a1 + 48);
  v32 = *(_QWORD *)(a1 + 40);
  v33 = v18;
  if (v18)
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  v19 = *(std::__shared_weak_count **)(a1 + 64);
  v30 = *(_QWORD *)(a1 + 56);
  v31 = v19;
  if (v19)
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  create_vocoder_engine(&v32, &v30, (uint64_t)&v39);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>(v6, &v39);
  v20 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
  if (*((_QWORD *)&v39 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v39 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  v21 = v31;
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  v22 = v33;
  if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  v23 = operator new(352);
  v24 = v23;
  v25 = *(std::__shared_weak_count **)(a1 + 64);
  v28 = *(_QWORD *)(a1 + 56);
  v29 = v25;
  if (v25)
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  VocoderStreamer::VocoderStreamer(v23, v6, &v28);
  *(_QWORD *)(a1 + 32) = v24;
  v26 = v29;
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  return a1;
}

void sub_214E772F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  operator delete(v5);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v4);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

double ENTTS::make_shared<PipelineServices,RSRC_S const*&,char const*&,int &>@<D0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, unsigned int *a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v8;
  double result;
  __int128 v10;

  v8 = operator new(56);
  PipelineServices::PipelineServices(v8, *a1, *a2, *a3);
  std::shared_ptr<PipelineServices>::shared_ptr[abi:ne180100]<PipelineServices,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>,void>(&v10, v8);
  result = *(double *)&v10;
  *a4 = v10;
  return result;
}

void sub_214E773F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

double ENTTS::make_shared<CJsonWrapper,void *,char const*&>@<D0>(uint64_t *a1@<X0>, char **a2@<X1>, _OWORD *a3@<X8>)
{
  CJsonWrapper *v6;
  double result;
  __int128 v8;

  v6 = (CJsonWrapper *)operator new(32);
  CJsonWrapper::CJsonWrapper(v6, *a1, *a2);
  std::shared_ptr<CJsonWrapper>::shared_ptr[abi:ne180100]<CJsonWrapper,ENTTS::Deleter<CJsonWrapper>,ENTTS::Allocator<CJsonWrapper>,void>(&v8, (uint64_t)v6);
  result = *(double *)&v8;
  *a3 = v8;
  return result;
}

void sub_214E774D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<PipelineServices>::shared_ptr[abi:ne180100]<PipelineServices,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29B1E0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E77560(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  _QWORD *v13;

  __cxa_begin_catch(a1);
  ENTTS::Deleter<PipelineServices>::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_214E77578(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 40 * a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

_QWORD *ENTTS::Deleter<PipelineServices>::operator()(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;
  uint64_t *v4;

  if (a2)
  {
    *a2 = &unk_24D29B240;
    v4 = a2 + 1;
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v4);
    return operator delete((uint64_t)a2);
  }
  return result;
}

void entts_except::Exception::~Exception(std::exception *this)
{
  void *v1;

  std::exception::~exception(this);
  operator delete(v1);
}

void std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

_QWORD *std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>::__on_zero_shared(uint64_t a1)
{
  return ENTTS::Deleter<PipelineServices>::operator()(a1 + 24, *(_QWORD **)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

uint64_t **std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](uint64_t **result)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = *result;
  v2 = **result;
  if (v2)
  {
    v1[1] = v2;
    return (uint64_t **)heap_Free(*(_QWORD **)(v1[3] + 8), v2);
  }
  return result;
}

_QWORD *std::shared_ptr<CJsonWrapper>::shared_ptr[abi:ne180100]<CJsonWrapper,ENTTS::Deleter<CJsonWrapper>,ENTTS::Allocator<CJsonWrapper>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29B2E0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E777E0(void *a1)
{
  CJsonWrapper *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    CJsonWrapper::~CJsonWrapper(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E777FC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

CJsonWrapper *std::__shared_ptr_pointer<CJsonWrapper *,ENTTS::Deleter<CJsonWrapper>,ENTTS::Allocator<CJsonWrapper>>::__on_zero_shared(uint64_t a1)
{
  CJsonWrapper *result;
  uint64_t v2;

  result = *(CJsonWrapper **)(a1 + 24);
  if (result)
  {
    CJsonWrapper::~CJsonWrapper(result);
    return (CJsonWrapper *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<CJsonWrapper *,ENTTS::Deleter<CJsonWrapper>,ENTTS::Allocator<CJsonWrapper>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<CJsonWrapper *,ENTTS::Deleter<CJsonWrapper>,ENTTS::Allocator<CJsonWrapper>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

uint64_t std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void VOCODER_INPUT_S::VOCODER_INPUT_S(VOCODER_INPUT_S *this)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)operator new(32);
  v2[1] = 0;
  v2[2] = 0;
  *v2 = 0;
  v2[3] = CustomAllocator::mRsrc;
  *(_QWORD *)this = v2;
  v3 = (_QWORD *)operator new(32);
  v3[1] = 0;
  v3[2] = 0;
  *v3 = 0;
  v3[3] = CustomAllocator::mRsrc;
  *((_QWORD *)this + 1) = v3;
}

void std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const,std::vector<float,ENTTS::Allocator<float>>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t **std::__destroy_at[abi:ne180100]<std::pair<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const,std::vector<float,ENTTS::Allocator<float>>>,0>(uint64_t a1)
{
  uint64_t **result;
  uint64_t *v3;

  v3 = (uint64_t *)(a1 + 32);
  result = std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*(char *)(a1 + 23) < 0)
    return (uint64_t **)heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), *(_QWORD *)a1);
  return result;
}

_QWORD *std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  uint64_t v4;
  size_t v5;
  size_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  a1[3] = CustomAllocator::mRsrc;
  v4 = (uint64_t)(a1 + 3);
  v5 = strlen(__s);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]();
  v6 = v5;
  if (v5 >= 0x17)
  {
    v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v8 = v5 | 7;
    v9 = v8 + 1;
    v7 = (void *)ENTTS::Allocator<char>::allocate(v4, v8 + 1);
    a1[1] = v6;
    a1[2] = v9 | 0x8000000000000000;
    *a1 = v7;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v5;
    v7 = a1;
    if (!v5)
      goto LABEL_9;
  }
  memmove(v7, __s, v6);
LABEL_9:
  *((_BYTE *)v7 + v6) = 0;
  return a1;
}

void std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24D27C310, MEMORY[0x24BEDAAF0]);
}

void sub_214E77B00(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

uint64_t ENTTS::Allocator<char>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

void NEURALSYNTH_S::~NEURALSYNTH_S(uint64_t **this)
{
  VOCODER_INPUT_S *v2;
  uint64_t v3;
  uint64_t *v4;

  entts_delete<VocoderStreamer>(this[4]);
  v2 = (VOCODER_INPUT_S *)this[1];
  if (v2)
  {
    VOCODER_INPUT_S::~VOCODER_INPUT_S(v2);
    operator delete(v3);
  }
  v4 = *this;
  if (*this)
  {
    (*(void (**)(uint64_t *))(*v4 + 24))(*this);
    operator delete((uint64_t)v4);
  }
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)(this + 7));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)(this + 5));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)(this + 2));
}

uint64_t *entts_delete<VocoderStreamer>(uint64_t *result)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t *v3;

  if (result)
  {
    v1 = result;
    v3 = result + 39;
    std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v3 = v1 + 35;
    std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v3 = v1 + 31;
    std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v3 = v1 + 27;
    std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v3 = v1 + 18;
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v3 = v1 + 14;
    std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v3 = v1 + 10;
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v2 = std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)v1);
    return operator delete(v2);
  }
  return result;
}

uint64_t *std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](uint64_t **a1)
{
  uint64_t *result;

  result = *a1;
  if (*result)
  {
    std::vector<std::string,ENTTS::Allocator<std::string>>::__clear[abi:ne180100](result);
    return heap_Free(*(_QWORD **)((*a1)[3] + 8), **a1);
  }
  return result;
}

void std::vector<std::string,ENTTS::Allocator<std::string>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

void VOCODER_INPUT_S::~VOCODER_INPUT_S(VOCODER_INPUT_S *this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;

  v2 = *(uint64_t **)this;
  if (*(_QWORD *)this)
  {
    v4 = *(uint64_t **)this;
    std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
    operator delete((uint64_t)v2);
  }
  v3 = *((_QWORD *)this + 1);
  if (v3)
  {
    v4 = (uint64_t *)*((_QWORD *)this + 1);
    std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](&v4);
    operator delete(v3);
  }
}

uint64_t *std::vector<int,ENTTS::Allocator<int>>::vector(uint64_t *a1, unint64_t a2)
{
  void *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = CustomAllocator::mRsrc;
  if (a2)
  {
    std::vector<int,ENTTS::Allocator<int>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (void *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = (uint64_t)v4 + 4 * a2;
  }
  return a1;
}

void sub_214E77E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9)
{
  std::vector<int,ENTTS::Allocator<int>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<int,ENTTS::Allocator<int>>::__vallocate[abi:ne180100](uint64_t *a1, unint64_t a2)
{
  uint64_t result;

  if (a2 >> 62)
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  result = ENTTS::Allocator<int>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = result + 4 * a2;
  return result;
}

void std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

uint64_t ENTTS::Allocator<int>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

uint64_t **std::vector<int,ENTTS::Allocator<int>>::__destroy_vector::operator()[abi:ne180100](uint64_t **result)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = *result;
  v2 = **result;
  if (v2)
  {
    v1[1] = v2;
    return (uint64_t **)heap_Free(*(_QWORD **)(v1[3] + 8), v2);
  }
  return result;
}

uint64_t *std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::vector(uint64_t *a1, unint64_t a2)
{
  void *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = CustomAllocator::mRsrc;
  if (a2)
  {
    std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (void *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = (uint64_t)v4 + 8 * a2;
  }
  return a1;
}

void sub_214E77F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9)
{
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__vallocate[abi:ne180100](uint64_t *a1, unint64_t a2)
{
  uint64_t result;

  if (a2 >> 61)
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  result = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = result + 8 * a2;
  return result;
}

uint64_t ENTTS::Allocator<unsigned long>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 8 * a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

uint64_t **std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](uint64_t **result)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = *result;
  v2 = **result;
  if (v2)
  {
    v1[1] = v2;
    return (uint64_t **)heap_Free(*(_QWORD **)(v1[3] + 8), v2);
  }
  return result;
}

uint64_t *std::vector<float,ENTTS::Allocator<float>>::vector(uint64_t *a1, unint64_t a2)
{
  void *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = CustomAllocator::mRsrc;
  if (a2)
  {
    std::vector<int,ENTTS::Allocator<int>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (void *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = (uint64_t)v4 + 4 * a2;
  }
  return a1;
}

void sub_214E780D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9)
{
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t **std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](uint64_t **result)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = *result;
  v2 = **result;
  if (v2)
  {
    v1[1] = v2;
    return (uint64_t **)heap_Free(*(_QWORD **)(v1[3] + 8), v2);
  }
  return result;
}

uint64_t bet7_generate_voice_specific_broker_string(uint64_t a1, const char *a2, char *a3)
{
  uint64_t Str;
  size_t v7;
  size_t v8;
  size_t v9;
  int v10;
  uint64_t v11;
  char *v13;
  char *__s2;
  char __src[16];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  char __s1[16];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v13 = 0;
  __s2 = 0;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  *(_OWORD *)__s1 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  *(_OWORD *)__src = 0u;
  v16 = 0u;
  Str = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"langcode", &__s2);
  if ((Str & 0x80000000) != 0)
    return Str;
  Str = paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"voice", &v13);
  if ((Str & 0x80000000) != 0)
    return Str;
  cstdlib_strncat(__s1, a2, 0x100uLL);
  v7 = 256 - cstdlib_strlen(a2);
  cstdlib_strncat(__s1, "/", v7);
  v8 = v7 - cstdlib_strlen("/");
  cstdlib_strncat(__s1, __s2, v8);
  v9 = v8 - cstdlib_strlen(__s2);
  cstdlib_strncat(__s1, "/", v9);
  v10 = cstdlib_strlen("/");
  cstdlib_strncat(__s1, v13, (v9 - v10));
  v11 = brokeraux_ComposeBrokerString(a1, __s1, 0, 0, 0, 0, 0, __src, 0x100uLL);
  if ((v11 & 0x80000000) == 0)
    cstdlib_strcpy(a3, __src);
  return v11;
}

uint64_t enttsexcept2verror(entts_except::Exception *a1)
{
  unsigned int v1;

  v1 = *((_DWORD *)a1 + 2);
  if (v1 - 1 >= 0x1C)
    return 0;
  else
    return v1;
}

void entts_throw_verror(__int16 a1)
{
  _DWORD *exception;
  int v2;

  switch(a1 & 0x1FFF)
  {
    case 1:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 1;
      goto LABEL_31;
    case 2:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 2;
      goto LABEL_31;
    case 3:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 3;
      goto LABEL_31;
    case 4:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 4;
      goto LABEL_31;
    case 5:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 5;
      goto LABEL_31;
    case 6:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 6;
      goto LABEL_31;
    case 7:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 7;
      goto LABEL_31;
    case 8:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 8;
      goto LABEL_31;
    case 9:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 9;
      goto LABEL_31;
    case 0xA:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 10;
      goto LABEL_31;
    case 0xB:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 11;
      goto LABEL_31;
    case 0xC:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 12;
      goto LABEL_31;
    case 0xD:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 13;
      goto LABEL_31;
    case 0xE:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 14;
      goto LABEL_31;
    case 0xF:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 15;
      goto LABEL_31;
    case 0x10:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      exception[2] = 16;
      break;
    case 0x11:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 17;
      goto LABEL_31;
    case 0x12:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 18;
      goto LABEL_31;
    case 0x13:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 19;
      goto LABEL_31;
    case 0x14:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 20;
      goto LABEL_31;
    case 0x15:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 21;
      goto LABEL_31;
    case 0x16:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 22;
      goto LABEL_31;
    case 0x17:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 23;
      goto LABEL_31;
    case 0x18:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 24;
      goto LABEL_31;
    case 0x19:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 25;
      goto LABEL_31;
    case 0x1A:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 26;
      goto LABEL_31;
    case 0x1B:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 27;
      goto LABEL_31;
    case 0x1C:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      v2 = 28;
LABEL_31:
      exception[2] = v2;
      break;
    default:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      exception[2] = 0;
      break;
  }
}

uint64_t from_string_to_engine_type(const void **a1)
{
  uint64_t result;

  result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(a1, "\"onnx\"");
  if ((_DWORD)result)
  {
    result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(a1, "onnx");
    if ((_DWORD)result)
    {
      if (std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(a1, "\"NPU\"")
        && std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(a1, "NPU"))
      {
        if (std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(a1, "\"NEONFP16\"")&& std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(a1, "NEONFP16"))
        {
          if (std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(a1, "\"ort\""))return 4* (std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(a1, "ort") == 0);
          else
            return 4;
        }
        else
        {
          return 1;
        }
      }
      else
      {
        return 3;
      }
    }
  }
  return result;
}

uint64_t std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(const void **a1, char *__s)
{
  size_t v4;
  size_t v5;
  const void **v6;
  size_t v7;
  unsigned int v8;
  uint64_t result;

  v4 = strlen(__s);
  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    if (v4 != -1)
    {
      v5 = *((unsigned __int8 *)a1 + 23);
      goto LABEL_6;
    }
LABEL_15:
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_out_of_range[abi:ne180100]();
  }
  if (v4 == -1)
    goto LABEL_15;
  v6 = a1;
  a1 = (const void **)*a1;
  v5 = (size_t)v6[1];
LABEL_6:
  if (v5 >= v4)
    v7 = v4;
  else
    v7 = v5;
  if (v5 < v4)
    v8 = -1;
  else
    v8 = v5 > v4;
  LODWORD(result) = memcmp(a1, __s, v7);
  if ((_DWORD)result)
    return result;
  else
    return v8;
}

_QWORD *from_engine_type_to_string@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  const char *v2;
  char *v3;

  v2 = "onnx";
  if (a1 == 3)
    v2 = "NPU";
  if (a1 == 1)
    v3 = "NEONFP16";
  else
    v3 = (char *)v2;
  return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a2, v3);
}

_QWORD *print_not_compiled_error@<X0>(int a1@<W0>, void **a2@<X1>, uint64_t a3@<X8>)
{
  const char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void *v12;
  size_t v13;
  _QWORD *result;
  uint64_t v15;
  uint64_t v16[2];
  char v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;

  v5 = "onnx";
  if (a1 == 3)
    v5 = "NPU";
  if (a1 == 1)
    v6 = "NEONFP16";
  else
    v6 = (char *)v5;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v16, v6);
  v7 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::insert((uint64_t)v16, 0, "Engine ", 7uLL);
  v8 = *(_QWORD *)(v7 + 16);
  v19 = *(_OWORD *)v7;
  v20 = v8;
  v21 = CustomAllocator::mRsrc;
  *(_QWORD *)(v7 + 8) = 0;
  *(_QWORD *)(v7 + 16) = 0;
  *(_QWORD *)v7 = 0;
  v9 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)&v19, " not compiled for ", 0x12uLL);
  v10 = *(_QWORD *)(v9 + 16);
  v22 = *(_OWORD *)v9;
  v23 = v10;
  v24 = CustomAllocator::mRsrc;
  *(_QWORD *)(v9 + 8) = 0;
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)v9 = 0;
  v11 = *((char *)a2 + 23);
  if (v11 >= 0)
    v12 = a2;
  else
    v12 = *a2;
  if (v11 >= 0)
    v13 = *((unsigned __int8 *)a2 + 23);
  else
    v13 = (size_t)a2[1];
  result = (_QWORD *)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)&v22, v12, v13);
  *(_OWORD *)a3 = *(_OWORD *)result;
  v15 = CustomAllocator::mRsrc;
  *(_QWORD *)(a3 + 16) = result[2];
  *(_QWORD *)(a3 + 24) = v15;
  result[1] = 0;
  result[2] = 0;
  *result = 0;
  if (SHIBYTE(v23) < 0)
    result = heap_Free(*(_QWORD **)(v24 + 8), v22);
  if (SHIBYTE(v20) < 0)
    result = heap_Free(*(_QWORD **)(v21 + 8), v19);
  if (v17 < 0)
    return heap_Free(*(_QWORD **)(v18 + 8), v16[0]);
  return result;
}

void sub_214E789B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a17);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a13);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *print_not_supported_error@<X0>(int a1@<W0>, void **a2@<X1>, uint64_t a3@<X8>)
{
  const char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void *v12;
  size_t v13;
  _QWORD *result;
  uint64_t v15;
  uint64_t v16[2];
  char v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;

  v5 = "onnx";
  if (a1 == 3)
    v5 = "NPU";
  if (a1 == 1)
    v6 = "NEONFP16";
  else
    v6 = (char *)v5;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v16, v6);
  v7 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::insert((uint64_t)v16, 0, "Engine ", 7uLL);
  v8 = *(_QWORD *)(v7 + 16);
  v19 = *(_OWORD *)v7;
  v20 = v8;
  v21 = CustomAllocator::mRsrc;
  *(_QWORD *)(v7 + 8) = 0;
  *(_QWORD *)(v7 + 16) = 0;
  *(_QWORD *)v7 = 0;
  v9 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)&v19, " not supported ", 0xFuLL);
  v10 = *(_QWORD *)(v9 + 16);
  v22 = *(_OWORD *)v9;
  v23 = v10;
  v24 = CustomAllocator::mRsrc;
  *(_QWORD *)(v9 + 8) = 0;
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)v9 = 0;
  v11 = *((char *)a2 + 23);
  if (v11 >= 0)
    v12 = a2;
  else
    v12 = *a2;
  if (v11 >= 0)
    v13 = *((unsigned __int8 *)a2 + 23);
  else
    v13 = (size_t)a2[1];
  result = (_QWORD *)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)&v22, v12, v13);
  *(_OWORD *)a3 = *(_OWORD *)result;
  v15 = CustomAllocator::mRsrc;
  *(_QWORD *)(a3 + 16) = result[2];
  *(_QWORD *)(a3 + 24) = v15;
  result[1] = 0;
  result[2] = 0;
  *result = 0;
  if (SHIBYTE(v23) < 0)
    result = heap_Free(*(_QWORD **)(v24 + 8), v22);
  if (SHIBYTE(v20) < 0)
    result = heap_Free(*(_QWORD **)(v21 + 8), v19);
  if (v17 < 0)
    return heap_Free(*(_QWORD **)(v18 + 8), v16[0]);
  return result;
}

void sub_214E78B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a17);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a13);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("basic_string");
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24D27C318, MEMORY[0x24BEDAB00]);
}

void sub_214E78BC8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  return result;
}

uint64_t std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::insert(uint64_t a1, size_t a2, char *__src, size_t __len)
{
  char *v5;
  size_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  size_t v14;
  size_t v15;

  v5 = __src;
  v8 = *(unsigned __int8 *)(a1 + 23);
  if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    if (v8 >= a2)
    {
      v9 = 22;
      v10 = *(unsigned __int8 *)(a1 + 23);
      goto LABEL_6;
    }
LABEL_24:
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_out_of_range[abi:ne180100]();
  }
  v10 = *(_QWORD *)(a1 + 8);
  if (v10 < a2)
    goto LABEL_24;
  v9 = (*(_QWORD *)(a1 + 16) & 0x7FFFFFFFFFFFFFFFLL) - 1;
LABEL_6:
  if (v9 - v10 >= __len)
  {
    if (__len)
    {
      v11 = (char *)a1;
      if ((v8 & 0x80) != 0)
        v11 = *(char **)a1;
      if (v10 != a2)
      {
        v12 = &v11[a2];
        if (&v11[v10] <= __src || v12 > __src)
          v14 = 0;
        else
          v14 = __len;
        v5 = &__src[v14];
        memmove(&v12[__len], v12, v10 - a2);
      }
      memmove(&v11[a2], v5, __len);
      v15 = v10 + __len;
      if (*(char *)(a1 + 23) < 0)
        *(_QWORD *)(a1 + 8) = v15;
      else
        *(_BYTE *)(a1 + 23) = v15 & 0x7F;
      v11[v15] = 0;
    }
  }
  else
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__grow_by_and_replace((char **)a1, v9, v10 + __len - v9, v10, a2, 0, __len, __src);
  }
  return a1;
}

char *std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__grow_by_and_replace(char **a1, unint64_t a2, unint64_t a3, uint64_t a4, size_t a5, uint64_t a6, size_t a7, const void *a8)
{
  char *v13;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char **v18;
  char *result;
  char *v20;
  size_t v21;
  size_t v22;

  if (0x7FFFFFFFFFFFFFF6 - a2 < a3)
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]();
  v13 = (char *)a1;
  if (*((char *)a1 + 23) < 0)
    v13 = *a1;
  if (a2 > 0x3FFFFFFFFFFFFFF2)
  {
    v17 = 0x7FFFFFFFFFFFFFF7;
  }
  else
  {
    v15 = a3 + a2;
    if (a3 + a2 <= 2 * a2)
      v15 = 2 * a2;
    v16 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v16 = v15 | 7;
    if (v15 >= 0x17)
      v17 = v16 + 1;
    else
      v17 = 23;
  }
  v18 = a1 + 3;
  result = (char *)ENTTS::Allocator<char>::allocate((uint64_t)(a1 + 3), v17);
  v20 = result;
  if (a5)
    result = (char *)memmove(result, v13, a5);
  if (a7)
    result = (char *)memmove(&v20[a5], a8, a7);
  v21 = a4 - (a6 + a5);
  if (v21)
    result = (char *)memmove(&v20[a5 + a7], &v13[a5 + a6], v21);
  if (a2 != 22)
    result = (char *)heap_Free(*((_QWORD **)*v18 + 1), (uint64_t)v13);
  v22 = a7 + a5 + v21;
  *a1 = v20;
  a1[1] = (char *)v22;
  a1[2] = (char *)(v17 | 0x8000000000000000);
  v20[v22] = 0;
  return result;
}

uint64_t std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append(uint64_t a1, void *__src, size_t __len)
{
  unint64_t v6;
  size_t v7;
  char *v8;
  size_t v9;

  if (*(char *)(a1 + 23) < 0)
  {
    v7 = *(_QWORD *)(a1 + 8);
    v6 = (*(_QWORD *)(a1 + 16) & 0x7FFFFFFFFFFFFFFFLL) - 1;
  }
  else
  {
    v6 = 22;
    v7 = *(unsigned __int8 *)(a1 + 23);
  }
  if (v6 - v7 >= __len)
  {
    if (__len)
    {
      v8 = (char *)a1;
      if ((*(_BYTE *)(a1 + 23) & 0x80) != 0)
        v8 = *(char **)a1;
      memmove(&v8[v7], __src, __len);
      v9 = v7 + __len;
      if (*(char *)(a1 + 23) < 0)
        *(_QWORD *)(a1 + 8) = v9;
      else
        *(_BYTE *)(a1 + 23) = v9 & 0x7F;
      v8[v9] = 0;
    }
  }
  else
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__grow_by_and_replace((char **)a1, v6, __len - v6 + v7, v7, v7, 0, __len, __src);
  }
  return a1;
}

uint64_t *IDecoderEngine::common_initialization(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[3];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  std::vector<float,ENTTS::Allocator<float>>::resize(a6, ((a1[15] + (a1[10] >> 1)) * a1[13] * a1[14]));
  v9 = a1[14];
  v10 = (a1[13] * a1[15]);
  v12[0] = 1;
  v12[1] = v10;
  v12[2] = v9;
  return std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a7, (char *)v12, (uint64_t)&v13, 3uLL);
}

void std::vector<float,ENTTS::Allocator<float>>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (a1[1] - *a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      a1[1] = *a1 + 4 * a2;
  }
  else
  {
    std::vector<float,ENTTS::Allocator<float>>::__append(a1, a2 - v2);
  }
}

BOOL IDecoderEngine::do_inference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, char a8, unsigned __int8 a9)
{
  int v17;

  if (*(_BYTE *)(a1 + 29))
  {
    IDecoderEngine::common_initialization((_DWORD *)a1, a2, a3, a4, a5, a6, a7);
    (**(void (***)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *))a1)(a1, a2, a3, a4, a5, a6, a7);
  }
  IDecoderEngine::run_decoder(a1, (uint64_t)a6, (uint64_t)a7, a8, a9);
  *(_BYTE *)(a1 + 29) = 0;
  v17 = *(unsigned __int8 *)(a1 + 28);
  if (*(_BYTE *)(a1 + 28))
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  return v17 != 0;
}

uint64_t IDecoderEngine::run_decoder(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  int v7;
  uint64_t v8;
  uint64_t result;
  unsigned int v10;
  BOOL v11;

  if ((a4 & 1) != 0)
  {
    v7 = *(_DWORD *)(a1 + 68);
    if (*(_BYTE *)(a1 + 29))
    {
      if (!*(_DWORD *)(a1 + 84))
        v7 = *(_DWORD *)(a1 + 64);
      v8 = (*(_DWORD *)(a1 + 52)
          + *(_DWORD *)(a1 + 52) * (((*(_DWORD *)(a1 + 40) >> 1) + v7 - 1) / *(_DWORD *)(a1 + 52)))
         / *(_DWORD *)(a1 + 52);
    }
    else
    {
      v8 = (v7 - 1) / *(_DWORD *)(a1 + 52) + 1;
    }
  }
  else
  {
    v8 = *(unsigned int *)(a1 + 60);
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 16))(a1, a2, v8, a5);
  v10 = *(_DWORD *)(a1 + 32);
  if (*(_BYTE *)(a1 + 28))
    v11 = 1;
  else
    v11 = v10 >= *(_DWORD *)(a1 + 60);
  *(_BYTE *)(a1 + 28) = v11;
  *(_QWORD *)(*(_QWORD *)a3 + 8) = *(_DWORD *)(a1 + 52) * v10;
  return result;
}

void std::vector<float,ENTTS::Allocator<float>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _QWORD v20[5];

  v5 = a1[1];
  v4 = a1[2];
  if (a2 <= (v4 - v5) >> 2)
  {
    if (a2)
    {
      bzero((void *)a1[1], 4 * a2);
      v5 += 4 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    v6 = (uint64_t)(a1 + 3);
    v7 = *a1;
    v8 = v5 - *a1;
    v9 = a2 + (v8 >> 2);
    if (v9 >> 62)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    v11 = v4 - v7;
    if (v11 >> 1 > v9)
      v9 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v20[4] = a1 + 3;
    if (v12)
    {
      v13 = ENTTS::Allocator<int>::allocate(v6, v12);
      v7 = *a1;
      v5 = a1[1];
    }
    else
    {
      v13 = 0;
    }
    v14 = (char *)(v13 + 4 * v10);
    v15 = v13 + 4 * v12;
    bzero(v14, 4 * a2);
    v16 = &v14[4 * a2];
    if (v5 != v7)
    {
      v17 = v5;
      do
      {
        v18 = *(_DWORD *)(v17 - 4);
        v17 -= 4;
        *((_DWORD *)v14 - 1) = v18;
        v14 -= 4;
      }
      while (v17 != v7);
    }
    *a1 = (uint64_t)v14;
    a1[1] = (uint64_t)v16;
    v19 = a1[2];
    a1[2] = v15;
    v20[2] = v5;
    v20[3] = v19;
    v20[0] = v7;
    v20[1] = v7;
    std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)v20);
  }
}

uint64_t std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 3) & 0xFFFFFFFFFFFFFFFCLL);
  if (*(_QWORD *)a1)
    heap_Free(*(_QWORD **)(**(_QWORD **)(a1 + 32) + 8), *(_QWORD *)a1);
  return a1;
}

uint64_t *std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(uint64_t *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *result;
  if (a4 > (result[2] - *result) >> 3)
  {
    std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__vdeallocate(result);
    if (a4 >> 61)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v9 = v7[2] - *v7;
    v10 = v9 >> 2;
    if (v9 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = (uint64_t *)std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__vallocate[abi:ne180100](v7, v11);
    v13 = v7[1];
    v12 = v7 + 1;
    v8 = v13;
LABEL_14:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = (void *)v8;
      v19 = __src;
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  v12 = result + 1;
  v14 = result[1];
  v15 = (v14 - v8) >> 3;
  if (v15 >= a4)
    goto LABEL_14;
  v16 = &__src[8 * v15];
  if (v14 != v8)
  {
    result = (uint64_t *)memmove((void *)*result, __src, v14 - v8);
    v8 = *v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = (void *)v8;
    v19 = v16;
LABEL_16:
    result = (uint64_t *)memmove(v18, v19, v17);
  }
LABEL_17:
  *v12 = v8 + v17;
  return result;
}

uint64_t *std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__vdeallocate(uint64_t *result)
{
  uint64_t v1;
  uint64_t *v2;

  v1 = *result;
  if (*result)
  {
    v2 = result;
    result[1] = v1;
    result = heap_Free(*(_QWORD **)(result[3] + 8), v1);
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  return result;
}

uint64_t MelganEngine::MelganEngine(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  int v7;
  uint64_t i;
  uint64_t v9;
  int v10;
  uint64_t j;
  uint64_t v12;
  int v13;
  uint64_t k;
  uint64_t v15;
  int v16;
  uint64_t m;
  uint64_t v18;
  int v19;
  uint64_t n;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26[2];
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const void *v33[2];
  char v34;
  uint64_t v35;
  uint64_t v36[2];
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const void *v43[2];
  char v44;
  uint64_t v45;
  uint64_t v46[2];
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const void *v53[2];
  char v54;
  uint64_t v55;
  uint64_t v56[2];
  char v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const void *v63[2];
  char v64;
  uint64_t v65;
  uint64_t v66[2];
  char v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  const void *v73[2];
  char v74;
  uint64_t v75;
  uint64_t *v76;
  char v77;
  _QWORD v78[4];
  _QWORD v79[4];
  _QWORD v80[2];

  v80[0] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = &off_24D29B340;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  v6 = *a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v78, "Vocoder");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v79, "first_conv_engine");
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = CustomAllocator::mRsrc;
  v76 = &v69;
  v77 = 0;
  v69 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v72, 2);
  v70 = v69;
  v71 = v69 + 64;
  v70 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v72, (uint64_t)v78, (uint64_t)v80, v69);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v66, "\"onnx\"");
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v6 + 8))(v73, v6, &v69, v66);
  v7 = from_string_to_engine_type(v73);
  if (v74 < 0)
    heap_Free(*(_QWORD **)(v75 + 8), (uint64_t)v73[0]);
  if (v67 < 0)
    heap_Free(*(_QWORD **)(v68 + 8), v66[0]);
  v76 = &v69;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v76);
  for (i = 0; i != -8; i -= 4)
  {
    if (SHIBYTE(v79[i + 2]) < 0)
      heap_Free(*(_QWORD **)(v79[i + 3] + 8), v78[i + 4]);
  }
  v9 = *a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v78, "Vocoder");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v79, "first_block_engine");
  v59 = 0;
  v60 = 0;
  v61 = 0;
  v62 = CustomAllocator::mRsrc;
  v76 = &v59;
  v77 = 0;
  v59 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v62, 2);
  v60 = v59;
  v61 = v59 + 64;
  v60 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v62, (uint64_t)v78, (uint64_t)v80, v59);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v56, "\"onnx\"");
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v9 + 8))(v63, v9, &v59, v56);
  v10 = from_string_to_engine_type(v63);
  if (v64 < 0)
    heap_Free(*(_QWORD **)(v65 + 8), (uint64_t)v63[0]);
  if (v57 < 0)
    heap_Free(*(_QWORD **)(v58 + 8), v56[0]);
  v76 = &v59;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v76);
  for (j = 0; j != -8; j -= 4)
  {
    if (SHIBYTE(v79[j + 2]) < 0)
      heap_Free(*(_QWORD **)(v79[j + 3] + 8), v78[j + 4]);
  }
  v12 = *a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v78, "Vocoder");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v79, "second_block_engine");
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = CustomAllocator::mRsrc;
  v76 = &v49;
  v77 = 0;
  v49 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v52, 2);
  v50 = v49;
  v51 = v49 + 64;
  v50 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v52, (uint64_t)v78, (uint64_t)v80, v49);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v46, "\"onnx\"");
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v12 + 8))(v53, v12, &v49, v46);
  v13 = from_string_to_engine_type(v53);
  if (v54 < 0)
    heap_Free(*(_QWORD **)(v55 + 8), (uint64_t)v53[0]);
  if (v47 < 0)
    heap_Free(*(_QWORD **)(v48 + 8), v46[0]);
  v76 = &v49;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v76);
  for (k = 0; k != -8; k -= 4)
  {
    if (SHIBYTE(v79[k + 2]) < 0)
      heap_Free(*(_QWORD **)(v79[k + 3] + 8), v78[k + 4]);
  }
  v15 = *a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v78, "Vocoder");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v79, "third_block_engine");
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = CustomAllocator::mRsrc;
  v76 = &v39;
  v77 = 0;
  v39 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v42, 2);
  v40 = v39;
  v41 = v39 + 64;
  v40 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v42, (uint64_t)v78, (uint64_t)v80, v39);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v36, "\"onnx\"");
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v15 + 8))(v43, v15, &v39, v36);
  v16 = from_string_to_engine_type(v43);
  if (v44 < 0)
    heap_Free(*(_QWORD **)(v45 + 8), (uint64_t)v43[0]);
  if (v37 < 0)
    heap_Free(*(_QWORD **)(v38 + 8), v36[0]);
  v76 = &v39;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v76);
  for (m = 0; m != -8; m -= 4)
  {
    if (SHIBYTE(v79[m + 2]) < 0)
      heap_Free(*(_QWORD **)(v79[m + 3] + 8), v78[m + 4]);
  }
  v18 = *a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v78, "Vocoder");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v79, "pqmf_engine");
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = CustomAllocator::mRsrc;
  v76 = &v29;
  v77 = 0;
  v29 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v32, 2);
  v30 = v29;
  v31 = v29 + 64;
  v30 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v32, (uint64_t)v78, (uint64_t)v80, v29);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v26, "\"onnx\"");
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v18 + 8))(v33, v18, &v29, v26);
  v19 = from_string_to_engine_type(v33);
  if (v34 < 0)
    heap_Free(*(_QWORD **)(v35 + 8), (uint64_t)v33[0]);
  if (v27 < 0)
    heap_Free(*(_QWORD **)(v28 + 8), v26[0]);
  v76 = &v29;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v76);
  for (n = 0; n != -8; n -= 4)
  {
    if (SHIBYTE(v79[n + 2]) < 0)
      heap_Free(*(_QWORD **)(v79[n + 3] + 8), v78[n + 4]);
  }
  v21 = a2[1];
  v24 = *a2;
  v25 = (std::__shared_weak_count *)v21;
  if (v21)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
  MelganEngine::instantiate_engines((_QWORD *)a1, v7, v10, v13, v16, v19, &v24);
  v22 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  return a1;
}

void sub_214E79B44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t **MelganEngine::instantiate_engines(_QWORD *a1, int a2, int a3, int a4, int a5, int a6, uint64_t *a7)
{
  uint64_t *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  std::__shared_weak_count *v38;
  std::__shared_weak_count *v39;
  uint64_t v41;
  std::__shared_weak_count *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  __int128 v51;
  uint64_t v52[4];
  uint64_t v53;
  std::__shared_weak_count *v54;
  _QWORD v55[13];
  char v56;
  uint64_t v57;
  void *v58;
  _QWORD v59[13];
  char v60;
  uint64_t v61;
  void *v62;
  _QWORD v63[13];
  char v64;
  uint64_t v65;
  void *v66;
  _QWORD v67[13];
  char v68;
  uint64_t v69;
  void *v70;
  _QWORD v71[13];
  char v72;
  uint64_t v73;
  void *v74;
  _QWORD v75[13];
  char v76;
  uint64_t v77;
  void *v78;
  _QWORD v79[13];
  char v80;
  uint64_t v81;
  void *v82;
  uint64_t *__src[13];
  char v84;
  uint64_t v85;
  void *v86;
  _BYTE *v87;
  _BYTE *v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  uint64_t v92;

  v13 = a1 + 12;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 12, a7);
  v14 = (char *)(*(uint64_t (**)(_QWORD, const char *))(*(_QWORD *)a1[12] + 120))(a1[12], "CPU_RUN");
  if (v14)
  {
    v15 = *v13;
    affinity_parser(v14, (uint64_t *)&v91);
    if ((char **)(v15 + 8) != &v91)
      std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>((uint64_t *)(v15 + 8), v91, v92, (v92 - (uint64_t)v91) >> 2);
    __src[0] = (uint64_t *)&v91;
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](__src);
  }
  v16 = *v13;
  v87 = 0;
  v88 = 0;
  v89 = 0;
  v90 = CustomAllocator::mRsrc;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((uint64_t *)&v87, *(const void **)(v16 + 8), *(_QWORD *)(v16 + 16), (uint64_t)(*(_QWORD *)(v16 + 16) - *(_QWORD *)(v16 + 8)) >> 2);
  if (v88 == v87)
  {
    LODWORD(__src[0]) = 0;
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>((uint64_t *)&v87, (char *)__src, (uint64_t)__src + 4, 1uLL);
  }
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)__src);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v79);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v75);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v71);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v67);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v63);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v59);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v55);
  v17 = operator new(4096);
  v18 = (std::__shared_weak_count *)a1[13];
  v53 = a1[12];
  v54 = v18;
  if (v18)
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  memset(v52, 0, 24);
  v52[3] = CustomAllocator::mRsrc;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v52, v87, (uint64_t)v88, (v88 - v87) >> 2);
  NeonMELContainer::NeonMELContainer(v17, &v53, v52, (uint64_t)__src, (uint64_t)v79, (uint64_t)v75, (uint64_t)v71, (uint64_t)v67, (uint64_t)v63, (uint64_t)v59, (uint64_t)v55);
  a1[1] = v17;
  *(_QWORD *)&v51 = v52;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v51);
  v19 = v54;
  if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  v20 = a1[1];
  v21 = (std::__shared_weak_count *)a1[13];
  v49 = a1[12];
  v50 = v21;
  if (v21)
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  create_first_conv_engine(a2, v20, &v49, (uint64_t)&v51);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)(a1 + 2), &v51);
  v22 = (std::__shared_weak_count *)*((_QWORD *)&v51 + 1);
  if (*((_QWORD *)&v51 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v51 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  v23 = v50;
  if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  v24 = a1[1];
  v25 = (std::__shared_weak_count *)a1[13];
  v47 = a1[12];
  v48 = v25;
  if (v25)
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  create_first_block_engine(a3, v24, &v47, (uint64_t)&v51);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)(a1 + 4), &v51);
  v26 = (std::__shared_weak_count *)*((_QWORD *)&v51 + 1);
  if (*((_QWORD *)&v51 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v51 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  v27 = v48;
  if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  v28 = a1[1];
  v29 = (std::__shared_weak_count *)a1[13];
  v45 = a1[12];
  v46 = v29;
  if (v29)
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  create_second_block_engine(a4, v28, &v45, (uint64_t)&v51);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)(a1 + 6), &v51);
  v30 = (std::__shared_weak_count *)*((_QWORD *)&v51 + 1);
  if (*((_QWORD *)&v51 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v51 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  v31 = v46;
  if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  v32 = a1[1];
  v33 = (std::__shared_weak_count *)a1[13];
  v43 = a1[12];
  v44 = v33;
  if (v33)
    atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
  create_third_block_engine(a5, v32, &v43, (uint64_t)&v51);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)(a1 + 8), &v51);
  v34 = (std::__shared_weak_count *)*((_QWORD *)&v51 + 1);
  if (*((_QWORD *)&v51 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v51 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  v35 = v44;
  if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  v36 = a1[1];
  v37 = (std::__shared_weak_count *)a1[13];
  v41 = a1[12];
  v42 = v37;
  if (v37)
    atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
  create_pqmf_engine(a6, v36, &v41, (uint64_t)&v51);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)(a1 + 10), &v51);
  v38 = (std::__shared_weak_count *)*((_QWORD *)&v51 + 1);
  if (*((_QWORD *)&v51 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v51 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
  v39 = v42;
  if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
    std::__shared_weak_count::__release_weak(v39);
  }
  v55[0] = &unk_24D29B388;
  v55[2] = &unk_24D29B3B0;
  v58 = &unk_24D29B3D8;
  v55[3] = &unk_24D29B578;
  if (v56 < 0)
    heap_Free(*(_QWORD **)(v57 + 8), v55[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v58);
  v59[0] = &unk_24D29B388;
  v59[2] = &unk_24D29B3B0;
  v59[3] = &unk_24D29B578;
  v62 = &unk_24D29B3D8;
  if (v60 < 0)
    heap_Free(*(_QWORD **)(v61 + 8), v59[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v62);
  v63[0] = &unk_24D29B388;
  v63[2] = &unk_24D29B3B0;
  v66 = &unk_24D29B3D8;
  v63[3] = &unk_24D29B578;
  if (v64 < 0)
    heap_Free(*(_QWORD **)(v65 + 8), v63[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v66);
  v67[0] = &unk_24D29B388;
  v67[2] = &unk_24D29B3B0;
  v70 = &unk_24D29B3D8;
  v67[3] = &unk_24D29B578;
  if (v68 < 0)
    heap_Free(*(_QWORD **)(v69 + 8), v67[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v70);
  v71[0] = &unk_24D29B388;
  v71[2] = &unk_24D29B3B0;
  v74 = &unk_24D29B3D8;
  v71[3] = &unk_24D29B578;
  if (v72 < 0)
    heap_Free(*(_QWORD **)(v73 + 8), v71[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v74);
  v75[0] = &unk_24D29B388;
  v75[2] = &unk_24D29B3B0;
  v78 = &unk_24D29B3D8;
  v75[3] = &unk_24D29B578;
  if (v76 < 0)
    heap_Free(*(_QWORD **)(v77 + 8), v75[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v78);
  v79[0] = &unk_24D29B388;
  v79[2] = &unk_24D29B3B0;
  v82 = &unk_24D29B3D8;
  v79[3] = &unk_24D29B578;
  if (v80 < 0)
    heap_Free(*(_QWORD **)(v81 + 8), v79[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v82);
  __src[0] = (uint64_t *)&unk_24D29B388;
  __src[2] = (uint64_t *)&unk_24D29B3B0;
  v86 = &unk_24D29B3D8;
  __src[3] = (uint64_t *)&unk_24D29B578;
  if (v84 < 0)
    heap_Free(*(_QWORD **)(v85 + 8), (uint64_t)__src[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v86);
  __src[0] = (uint64_t *)&v87;
  return std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](__src);
}

void sub_214E7A624(_Unwind_Exception *a1)
{
  uint64_t v1;

  STACK[0x890] = v1 - 144;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&STACK[0x890]);
  _Unwind_Resume(a1);
}

void MelganEngine::~MelganEngine(MelganEngine *this)
{
  char *v2;
  NeonMELContainer *v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24D29B340;
  v2 = (char *)this + 16;
  std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100]((_QWORD *)this + 2);
  std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100]((_QWORD *)this + 4);
  std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100]((_QWORD *)this + 6);
  std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100]((_QWORD *)this + 8);
  std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100]((_QWORD *)this + 10);
  v3 = (NeonMELContainer *)*((_QWORD *)this + 1);
  if (v3)
  {
    NeonMELContainer::~NeonMELContainer(v3);
    operator delete(v4);
  }
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 96);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 80);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 64);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 48);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 32);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)v2);
}

void std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100](_QWORD *a1)
{
  std::__shared_weak_count *v1;

  v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

_QWORD *std::shared_ptr<IExternalServices>::operator=[abi:ne180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  v5 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1;
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)(a1 + 136) = &unk_24D29B4F0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = &unk_24D29B3B0;
  *(_QWORD *)a1 = &unk_24D29B4C8;
  std::ios_base::init((std::ios_base *)(a1 + 136), (void *)(a1 + 24));
  *(_QWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = -1;
  *(_QWORD *)a1 = &unk_24D29B388;
  *(_QWORD *)(a1 + 136) = &unk_24D29B3D8;
  *(_QWORD *)(a1 + 16) = &unk_24D29B3B0;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 24) = &unk_24D29B578;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  v2 = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = v2;
  *(_QWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 24;
  return a1;
}

void sub_214E7A97C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &unk_24D29B388;
  *(_QWORD *)(a1 + 136) = &unk_24D29B3D8;
  v2 = a1 + 136;
  *(_QWORD *)(a1 + 16) = &unk_24D29B3B0;
  *(_QWORD *)(a1 + 24) = &unk_24D29B578;
  if (*(char *)(a1 + 111) < 0)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 112) + 8), *(_QWORD *)(a1 + 88));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v2);
  return a1;
}

uint64_t **MelganEngine::do_inference(void (****a1)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v9[4];
  uint64_t *v10[4];
  uint64_t *v11[4];
  uint64_t *v12[4];
  uint64_t *v13[4];
  uint64_t *v14[4];
  uint64_t *v15[4];
  _QWORD v16[4];
  uint64_t **v17;

  memset(v16, 0, 24);
  v16[3] = CustomAllocator::mRsrc;
  memset(v15, 0, 24);
  v15[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(v14, 0, 24);
  v14[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(v13, 0, 24);
  v13[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(v12, 0, 24);
  v12[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(v11, 0, 24);
  v11[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(v10, 0, 24);
  v10[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(v9, 0, 24);
  v9[3] = (uint64_t *)CustomAllocator::mRsrc;
  (**a1[2])(a1[2], a2, a3, v15, v16);
  (**a1[4])(a1[4], v15, v16, v13, v14);
  (**a1[6])(a1[6], v13, v14, v11, v12);
  (**a1[8])(a1[8], v11, v12, v9, v10);
  (**a1[10])(a1[10], v9, v10, a4, a5);
  v17 = v9;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v17);
  v9[0] = (uint64_t *)v10;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](v9);
  v10[0] = (uint64_t *)v11;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v10);
  v11[0] = (uint64_t *)v12;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](v11);
  v12[0] = (uint64_t *)v13;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v12);
  v13[0] = (uint64_t *)v14;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](v13);
  v14[0] = (uint64_t *)v15;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v14);
  v15[0] = v16;
  return std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](v15);
}

void sub_214E7ABFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t ******a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t *****a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t ****a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t ***a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t **a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t *a30)
{
  uint64_t v30;
  uint64_t v31;

  *(_QWORD *)(v31 - 72) = &a10;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v31 - 72));
  a10 = &a14;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a10);
  a14 = &a18;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a14);
  a18 = &a22;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a18);
  a22 = &a26;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a22);
  a26 = &a30;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a26);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&a30);
  *(_QWORD *)(v31 - 136) = v30;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v31 - 136));
  _Unwind_Resume(a1);
}

uint64_t *std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(uint64_t *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *result;
  if (a4 > (result[2] - *result) >> 2)
  {
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__vdeallocate(result);
    if (a4 >> 62)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v9 = v7[2] - *v7;
    v10 = v9 >> 1;
    if (v9 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = (uint64_t *)std::vector<int,ENTTS::Allocator<int>>::__vallocate[abi:ne180100](v7, v11);
    v13 = v7[1];
    v12 = v7 + 1;
    v8 = v13;
LABEL_14:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = (void *)v8;
      v19 = __src;
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  v12 = result + 1;
  v14 = result[1];
  v15 = (v14 - v8) >> 2;
  if (v15 >= a4)
    goto LABEL_14;
  v16 = &__src[4 * v15];
  if (v14 != v8)
  {
    result = (uint64_t *)memmove((void *)*result, __src, v14 - v8);
    v8 = *v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = (void *)v8;
    v19 = v16;
LABEL_16:
    result = (uint64_t *)memmove(v18, v19, v17);
  }
LABEL_17:
  *v12 = v8 + v17;
  return result;
}

uint64_t *std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__vdeallocate(uint64_t *result)
{
  uint64_t v1;
  uint64_t *v2;

  v1 = *result;
  if (*result)
  {
    v2 = result;
    result[1] = v1;
    result = heap_Free(*(_QWORD **)(result[3] + 8), v1);
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  return result;
}

void `non-virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(uint64_t a1)
{
  *(_QWORD *)(a1 - 16) = &unk_24D29B388;
  *(_QWORD *)(a1 + 120) = &unk_24D29B3D8;
  *(_QWORD *)a1 = &unk_24D29B3B0;
  *(_QWORD *)(a1 + 8) = &unk_24D29B578;
  if (*(char *)(a1 + 95) < 0)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 96) + 8), *(_QWORD *)(a1 + 72));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  JUMPOUT(0x2199DA5E8);
}

{
  void *v1;
  uint64_t v2;

  *(_QWORD *)(a1 - 16) = &unk_24D29B388;
  v1 = (void *)(a1 - 16);
  *(_QWORD *)(a1 + 120) = &unk_24D29B3D8;
  v2 = a1 + 120;
  *(_QWORD *)a1 = &unk_24D29B3B0;
  *(_QWORD *)(a1 + 8) = &unk_24D29B578;
  if (*(char *)(a1 + 95) < 0)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 96) + 8), *(_QWORD *)(a1 + 72));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v2);
  operator delete(v1);
}

void `virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(_QWORD *a1)
{
  char *v1;

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  *(_QWORD *)v1 = &unk_24D29B388;
  *((_QWORD *)v1 + 17) = &unk_24D29B3D8;
  *((_QWORD *)v1 + 2) = &unk_24D29B3B0;
  *((_QWORD *)v1 + 3) = &unk_24D29B578;
  if (v1[111] < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)v1 + 14) + 8), *((_QWORD *)v1 + 11));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  JUMPOUT(0x2199DA5E8);
}

{
  _QWORD *v1;

  v1 = (_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  *v1 = &unk_24D29B388;
  v1[17] = &unk_24D29B3D8;
  v1[2] = &unk_24D29B3B0;
  v1[3] = &unk_24D29B578;
  if (*((char *)v1 + 111) < 0)
    heap_Free(*(_QWORD **)(v1[14] + 8), v1[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v1 + 17);
  operator delete(v1);
}

void std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(char *a1)
{
  char *v2;

  *(_QWORD *)a1 = &unk_24D29B388;
  *((_QWORD *)a1 + 17) = &unk_24D29B3D8;
  v2 = a1 + 136;
  *((_QWORD *)a1 + 2) = &unk_24D29B3B0;
  *((_QWORD *)a1 + 3) = &unk_24D29B578;
  if (a1[111] < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)a1 + 14) + 8), *((_QWORD *)a1 + 11));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v2);
  operator delete(a1);
}

uint64_t std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringbuf(uint64_t a1)
{
  *(_QWORD *)a1 = &unk_24D29B578;
  if (*(char *)(a1 + 87) < 0)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 88) + 8), *(_QWORD *)(a1 + 64));
  return std::streambuf::~streambuf();
}

void std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringbuf(uint64_t a1)
{
  void *v1;

  *(_QWORD *)a1 = &unk_24D29B578;
  if (*(char *)(a1 + 87) < 0)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 88) + 8), *(_QWORD *)(a1 + 64));
  v1 = (void *)std::streambuf::~streambuf();
  operator delete(v1);
}

double std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::seekoff@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double result;
  uint64_t v12;

  v5 = *(_QWORD *)(a1 + 96);
  v6 = *(_QWORD *)(a1 + 48);
  if (v5 < v6)
  {
    *(_QWORD *)(a1 + 96) = v6;
    v5 = v6;
  }
  if ((a4 & 0x18) == 0 || a3 == 1 && (a4 & 0x18) == 0x18)
    goto LABEL_14;
  if (v5)
  {
    v7 = (_QWORD *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0)
      v7 = (_QWORD *)*v7;
    v8 = v5 - (_QWORD)v7;
    if (a3)
      goto LABEL_10;
LABEL_17:
    v9 = a3;
    goto LABEL_20;
  }
  v8 = 0;
  if (!a3)
    goto LABEL_17;
LABEL_10:
  if (a3 != 2)
  {
    if (a3 == 1)
    {
      if ((a4 & 8) != 0)
        v9 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);
      else
        v9 = v6 - *(_QWORD *)(a1 + 40);
      goto LABEL_20;
    }
LABEL_14:
    v10 = -1;
    goto LABEL_15;
  }
  v9 = v8;
LABEL_20:
  v10 = -1;
  v12 = v9 + a2;
  if (v12 >= 0 && v8 >= v12 && (!v12 || ((a4 & 8) == 0 || *(_QWORD *)(a1 + 24)) && ((a4 & 0x10) == 0 || v6)))
  {
    if ((a4 & 8) != 0)
    {
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + v12;
      *(_QWORD *)(a1 + 32) = v5;
    }
    if ((a4 & 0x10) != 0)
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 40) + v12;
    v10 = v12;
  }
LABEL_15:
  result = 0.0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_QWORD *)(a5 + 128) = v10;
  return result;
}

uint64_t std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::seekpos(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a1 + 32))(a1, *(_QWORD *)(a2 + 128), 0, a3);
}

uint64_t std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::underflow(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unsigned __int8 *v4;

  v1 = *(_QWORD *)(a1 + 96);
  v2 = *(_QWORD *)(a1 + 48);
  if (v1 < v2)
  {
    *(_QWORD *)(a1 + 96) = v2;
    v1 = v2;
  }
  if ((*(_BYTE *)(a1 + 104) & 8) == 0)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 32);
  if (v3 < v1)
  {
    *(_QWORD *)(a1 + 32) = v1;
    v3 = v1;
  }
  v4 = *(unsigned __int8 **)(a1 + 24);
  if ((unint64_t)v4 < v3)
    return *v4;
  else
    return 0xFFFFFFFFLL;
}

uint64_t std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::pbackfail(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a1 + 96);
  v3 = *(_QWORD *)(a1 + 48);
  if (v2 < v3)
  {
    *(_QWORD *)(a1 + 96) = v3;
    v2 = v3;
  }
  v4 = *(_QWORD *)(a1 + 24);
  if (*(_QWORD *)(a1 + 16) >= v4)
    return 0xFFFFFFFFLL;
  if ((_DWORD)a2 == -1)
  {
    a2 = 0;
    *(_QWORD *)(a1 + 24) = v4 - 1;
    *(_QWORD *)(a1 + 32) = v2;
    return a2;
  }
  if ((*(_BYTE *)(a1 + 104) & 0x10) == 0 && *(unsigned __int8 *)(v4 - 1) != a2)
    return 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 24) = v4 - 1;
  *(_QWORD *)(a1 + 32) = v2;
  *(_BYTE *)(v4 - 1) = a2;
  return a2;
}

uint64_t std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::overflow(uint64_t a1, int a2)
{
  unsigned __int8 v2;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unsigned __int8 *v14;
  uint64_t v15;
  _QWORD *v16;

  if (a2 == -1)
    return 0;
  v2 = a2;
  v5 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  v7 = *(unsigned __int8 **)(a1 + 48);
  v6 = *(unsigned __int8 **)(a1 + 56);
  if (v7 == v6)
  {
    if ((*(_BYTE *)(a1 + 104) & 0x10) == 0)
      return 0xFFFFFFFFLL;
    v10 = *(_QWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 96);
    v12 = a1 + 64;
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::push_back((char *)(a1 + 64), 0);
    if (*(char *)(a1 + 87) < 0)
      v13 = (*(_QWORD *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1;
    else
      v13 = 22;
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::resize(a1 + 64, v13, 0);
    v14 = &v7[-v10];
    if (*(char *)(a1 + 87) < 0)
    {
      v12 = *(_QWORD *)(a1 + 64);
      v15 = *(_QWORD *)(a1 + 72);
    }
    else
    {
      v15 = *(unsigned __int8 *)(a1 + 87);
    }
    v6 = (unsigned __int8 *)(v12 + v15);
    v7 = &v14[v12];
    *(_QWORD *)(a1 + 40) = v12;
    *(_QWORD *)(a1 + 48) = &v14[v12];
    *(_QWORD *)(a1 + 56) = v6;
    v8 = v12 + v11 - v10;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 96);
  }
  if ((unint64_t)(v7 + 1) >= v8)
    v8 = (unint64_t)(v7 + 1);
  *(_QWORD *)(a1 + 96) = v8;
  if ((*(_BYTE *)(a1 + 104) & 8) != 0)
  {
    v16 = (_QWORD *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0)
      v16 = (_QWORD *)*v16;
    *(_QWORD *)(a1 + 16) = v16;
    *(_QWORD *)(a1 + 24) = (char *)v16 + v4 - v5;
    *(_QWORD *)(a1 + 32) = v8;
  }
  if (v7 == v6)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 104))(a1, v2);
  *(_QWORD *)(a1 + 48) = v7 + 1;
  *v7 = v2;
  return v2;
}

void sub_214E7B4A4(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x214E7B3A0);
}

char *std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::push_back(char *result, char a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  v3 = result;
  if ((result[23] & 0x80000000) == 0)
  {
    if (result[23] != 22)
    {
      v5 = result[23];
      result[23] = (result[23] + 1) & 0x7F;
      goto LABEL_8;
    }
    v4 = 22;
    goto LABEL_5;
  }
  v5 = *((_QWORD *)result + 1);
  v4 = (*((_QWORD *)result + 2) & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v5 == v4)
  {
LABEL_5:
    result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__grow_by((char **)result, v4, 1uLL, v4, v4, 0, 0);
    v5 = v4;
  }
  v3[1] = v5 + 1;
  v3 = (_QWORD *)*v3;
LABEL_8:
  v6 = (char *)v3 + v5;
  *v6 = a2;
  v6[1] = 0;
  return result;
}

char *std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__grow_by(char **a1, unint64_t a2, unint64_t a3, uint64_t a4, size_t a5, uint64_t a6, uint64_t a7)
{
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char **v18;
  char *result;
  char *v20;

  if (0x7FFFFFFFFFFFFFF7 - a2 < a3)
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]();
  v13 = (char *)a1;
  if (*((char *)a1 + 23) < 0)
    v13 = *a1;
  v14 = a3 + a2;
  if (a3 + a2 <= 2 * a2)
    v14 = 2 * a2;
  v15 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v14 | 7) != 0x17)
    v15 = v14 | 7;
  if (v14 >= 0x17)
    v16 = v15 + 1;
  else
    v16 = 23;
  if (a2 <= 0x3FFFFFFFFFFFFFF2)
    v17 = v16;
  else
    v17 = 0x7FFFFFFFFFFFFFF7;
  v18 = a1 + 3;
  result = (char *)ENTTS::Allocator<char>::allocate((uint64_t)(a1 + 3), v17);
  v20 = result;
  if (a5)
    result = (char *)memmove(result, v13, a5);
  if (a4 != a6 + a5)
    result = (char *)memmove(&v20[a5 + a7], &v13[a5 + a6], a4 - (a6 + a5));
  if (a2 != 22)
    result = (char *)heap_Free(*((_QWORD **)*v18 + 1), (uint64_t)v13);
  *a1 = v20;
  a1[2] = (char *)(v17 | 0x8000000000000000);
  return result;
}

uint64_t std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::resize(uint64_t result, unint64_t a2, int a3)
{
  unint64_t v3;

  if (*(char *)(result + 23) < 0)
  {
    v3 = *(_QWORD *)(result + 8);
    if (v3 >= a2)
    {
      *(_QWORD *)(result + 8) = a2;
      result = *(_QWORD *)result;
      goto LABEL_7;
    }
    return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append(result, a2 - v3, a3);
  }
  v3 = *(unsigned __int8 *)(result + 23);
  if (v3 < a2)
    return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append(result, a2 - v3, a3);
  *(_BYTE *)(result + 23) = a2 & 0x7F;
LABEL_7:
  *(_BYTE *)(result + a2) = 0;
  return result;
}

uint64_t std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append(uint64_t a1, size_t __len, int __c)
{
  unint64_t v6;
  size_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  size_t v11;

  if (__len)
  {
    LODWORD(v6) = *(char *)(a1 + 23);
    if ((v6 & 0x80000000) != 0)
    {
      v7 = *(_QWORD *)(a1 + 8);
      v9 = *(_QWORD *)(a1 + 16);
      v8 = (v9 & 0x7FFFFFFFFFFFFFFFLL) - 1;
      v6 = HIBYTE(v9);
    }
    else
    {
      v7 = *(unsigned __int8 *)(a1 + 23);
      v8 = 22;
    }
    if (v8 - v7 < __len)
    {
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__grow_by((char **)a1, v8, __len - v8 + v7, v7, v7, 0, 0);
      *(_QWORD *)(a1 + 8) = v7;
      LOBYTE(v6) = *(_BYTE *)(a1 + 23);
    }
    v10 = (char *)a1;
    if ((v6 & 0x80) != 0)
      v10 = *(char **)a1;
    memset(&v10[v7], __c, __len);
    v11 = v7 + __len;
    if (*(char *)(a1 + 23) < 0)
      *(_QWORD *)(a1 + 8) = v11;
    else
      *(_BYTE *)(a1 + 23) = v11 & 0x7F;
    v10[v11] = 0;
  }
  return a1;
}

uint64_t *std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(uint64_t *result, const void *a2, uint64_t a3, unint64_t a4)
{
  uint64_t *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = (uint64_t *)std::vector<int,ENTTS::Allocator<int>>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = (uint64_t *)memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_214E7B808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9)
{
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 32 * a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __int128 *v8;
  uint64_t v9;
  __int128 v10;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      v8 = (__int128 *)(a2 + v7);
      v9 = a4 + v7;
      *(_QWORD *)(a4 + v7 + 24) = CustomAllocator::mRsrc;
      if (*(char *)(a2 + v7 + 23) < 0)
      {
        std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external((_BYTE *)v9, *(void **)v8, *((_QWORD *)v8 + 1));
      }
      else
      {
        v10 = *v8;
        *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
        *(_OWORD *)v9 = v10;
      }
      v7 += 32;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_214E7B908(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 32;
    do
    {
      std::__destroy_at[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,0>((uint64_t *)(v4 + v2));
      v2 -= 32;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void *std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(_BYTE *__dst, void *__src, unint64_t a3)
{
  _QWORD *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8)
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]();
    v6 = __dst + 24;
    v7 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17)
      v7 = a3 | 7;
    v8 = v7 + 1;
    v9 = ENTTS::Allocator<char>::allocate((uint64_t)v6, v7 + 1);
    v5[1] = a3;
    v5[2] = v8 | 0x8000000000000000;
    *v5 = v9;
    v5 = (_QWORD *)v9;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, a3 + 1);
}

uint64_t *std::__destroy_at[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,0>(uint64_t *result)
{
  if (*((char *)result + 23) < 0)
    return heap_Free(*(_QWORD **)(result[3] + 8), *result);
  return result;
}

uint64_t **std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](uint64_t **result)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t **v6;

  v1 = *result;
  v2 = (uint64_t *)**result;
  if (v2)
  {
    v3 = (uint64_t *)v1[1];
    v4 = **result;
    v5 = *result;
    if (v3 != v2)
    {
      v6 = result;
      do
      {
        v3 -= 4;
        std::__destroy_at[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,0>(v3);
      }
      while (v3 != v2);
      v5 = *v6;
      v4 = **v6;
    }
    v1[1] = (uint64_t)v2;
    return (uint64_t **)heap_Free(*(_QWORD **)(v5[3] + 8), v4);
  }
  return result;
}

void create_first_conv_engine(int a1@<W0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v7;
  __int128 v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v11, "Melgan First Conv");
  if ((a1 & 0xFFFFFFFB) != 0 && a1 == 1)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v8, "vocoder");
    ENTTS::make_shared<MelganFirstConvNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(&v14, &v8, a3, &v7);
    *(_OWORD *)a4 = v7;
    if (v9 < 0)
      heap_Free(*(_QWORD **)(v10 + 8), v8);
  }
  else
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
  }
  if (v12 < 0)
    heap_Free(*(_QWORD **)(v13 + 8), v11);
}

void sub_214E7BB28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<MelganFirstConvNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _OWORD *a4@<X8>)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 __dst;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v8 = (_QWORD *)operator new(312);
  v9 = *a1;
  v16 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    __dst = *a2;
    v15 = *((_QWORD *)a2 + 2);
  }
  v10 = a3[1];
  v12 = *a3;
  v13 = (std::__shared_weak_count *)v10;
  if (v10)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  MelganFirstConvNeonFP16Engine::MelganFirstConvNeonFP16Engine(v8, v9, (char **)&__dst, &v12);
  std::shared_ptr<MelganFirstConvNeonFP16Engine>::shared_ptr[abi:ne180100]<MelganFirstConvNeonFP16Engine,ENTTS::Deleter<MelganFirstConvNeonFP16Engine>,ENTTS::Allocator<MelganFirstConvNeonFP16Engine>,void>(&v17, (uint64_t)v8);
  *a4 = v17;
  v17 = 0uLL;
  v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (SHIBYTE(v15) < 0)
    heap_Free(*(_QWORD **)(v16 + 8), __dst);
}

void sub_214E7BC74(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void create_first_block_engine(int a1@<W0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v7;
  __int128 v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v11, "Melgan First Block");
  if ((a1 & 0xFFFFFFFB) != 0 && a1 == 1)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v8, "vocoder");
    ENTTS::make_shared<MelganFirstBlockNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(&v14, &v8, a3, &v7);
    *(_OWORD *)a4 = v7;
    if (v9 < 0)
      heap_Free(*(_QWORD **)(v10 + 8), v8);
  }
  else
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
  }
  if (v12 < 0)
    heap_Free(*(_QWORD **)(v13 + 8), v11);
}

void sub_214E7BD78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<MelganFirstBlockNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _OWORD *a4@<X8>)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 __dst;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v8 = (_QWORD *)operator new(312);
  v9 = *a1;
  v16 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    __dst = *a2;
    v15 = *((_QWORD *)a2 + 2);
  }
  v10 = a3[1];
  v12 = *a3;
  v13 = (std::__shared_weak_count *)v10;
  if (v10)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  MelganFirstBlockNeonFP16Engine::MelganFirstBlockNeonFP16Engine(v8, v9, (char **)&__dst, &v12);
  std::shared_ptr<MelganFirstBlockNeonFP16Engine>::shared_ptr[abi:ne180100]<MelganFirstBlockNeonFP16Engine,ENTTS::Deleter<MelganFirstBlockNeonFP16Engine>,ENTTS::Allocator<MelganFirstBlockNeonFP16Engine>,void>(&v17, (uint64_t)v8);
  *a4 = v17;
  v17 = 0uLL;
  v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (SHIBYTE(v15) < 0)
    heap_Free(*(_QWORD **)(v16 + 8), __dst);
}

void sub_214E7BEC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void create_second_block_engine(int a1@<W0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v7;
  __int128 v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v11, "Melgan Second Block");
  if ((a1 & 0xFFFFFFFB) != 0 && a1 == 1)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v8, "vocoder");
    ENTTS::make_shared<MelganSecondBlockNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(&v14, &v8, a3, &v7);
    *(_OWORD *)a4 = v7;
    if (v9 < 0)
      heap_Free(*(_QWORD **)(v10 + 8), v8);
  }
  else
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
  }
  if (v12 < 0)
    heap_Free(*(_QWORD **)(v13 + 8), v11);
}

void sub_214E7BFC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<MelganSecondBlockNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _OWORD *a4@<X8>)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 __dst;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v8 = (_QWORD *)operator new(312);
  v9 = *a1;
  v16 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    __dst = *a2;
    v15 = *((_QWORD *)a2 + 2);
  }
  v10 = a3[1];
  v12 = *a3;
  v13 = (std::__shared_weak_count *)v10;
  if (v10)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  MelganSecondBlockNeonFP16Engine::MelganSecondBlockNeonFP16Engine(v8, v9, (char **)&__dst, &v12);
  std::shared_ptr<MelganSecondBlockNeonFP16Engine>::shared_ptr[abi:ne180100]<MelganSecondBlockNeonFP16Engine,ENTTS::Deleter<MelganSecondBlockNeonFP16Engine>,ENTTS::Allocator<MelganSecondBlockNeonFP16Engine>,void>(&v17, (uint64_t)v8);
  *a4 = v17;
  v17 = 0uLL;
  v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (SHIBYTE(v15) < 0)
    heap_Free(*(_QWORD **)(v16 + 8), __dst);
}

void sub_214E7C114(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void create_third_block_engine(int a1@<W0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v7;
  __int128 v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v11, "Melgan Third Block");
  if ((a1 & 0xFFFFFFFB) != 0 && a1 == 1)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v8, "vocoder");
    ENTTS::make_shared<MelganThirdBlockNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(&v14, &v8, a3, &v7);
    *(_OWORD *)a4 = v7;
    if (v9 < 0)
      heap_Free(*(_QWORD **)(v10 + 8), v8);
  }
  else
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
  }
  if (v12 < 0)
    heap_Free(*(_QWORD **)(v13 + 8), v11);
}

void sub_214E7C218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<MelganThirdBlockNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _OWORD *a4@<X8>)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 __dst;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v8 = (_QWORD *)operator new(312);
  v9 = *a1;
  v16 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    __dst = *a2;
    v15 = *((_QWORD *)a2 + 2);
  }
  v10 = a3[1];
  v12 = *a3;
  v13 = (std::__shared_weak_count *)v10;
  if (v10)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  MelganThirdBlockNeonFP16Engine::MelganThirdBlockNeonFP16Engine(v8, v9, (char **)&__dst, &v12);
  std::shared_ptr<MelganThirdBlockNeonFP16Engine>::shared_ptr[abi:ne180100]<MelganThirdBlockNeonFP16Engine,ENTTS::Deleter<MelganThirdBlockNeonFP16Engine>,ENTTS::Allocator<MelganThirdBlockNeonFP16Engine>,void>(&v17, (uint64_t)v8);
  *a4 = v17;
  v17 = 0uLL;
  v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (SHIBYTE(v15) < 0)
    heap_Free(*(_QWORD **)(v16 + 8), __dst);
}

void sub_214E7C364(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void create_pqmf_engine(int a1@<W0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v7;
  __int128 v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v11, "Melgan PQMF");
  if ((a1 & 0xFFFFFFFB) != 0 && a1 == 1)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v8, "vocoder");
    ENTTS::make_shared<PQMFNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(&v14, &v8, a3, &v7);
    *(_OWORD *)a4 = v7;
    if (v9 < 0)
      heap_Free(*(_QWORD **)(v10 + 8), v8);
  }
  else
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
  }
  if (v12 < 0)
    heap_Free(*(_QWORD **)(v13 + 8), v11);
}

void sub_214E7C464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<PQMFNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _OWORD *a4@<X8>)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 __dst;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v8 = (_QWORD *)operator new(312);
  v9 = *a1;
  v16 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    __dst = *a2;
    v15 = *((_QWORD *)a2 + 2);
  }
  v10 = a3[1];
  v12 = *a3;
  v13 = (std::__shared_weak_count *)v10;
  if (v10)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  PQMFNeonFP16Engine::PQMFNeonFP16Engine(v8, v9, (char **)&__dst, &v12);
  std::shared_ptr<PQMFNeonFP16Engine>::shared_ptr[abi:ne180100]<PQMFNeonFP16Engine,ENTTS::Deleter<PQMFNeonFP16Engine>,ENTTS::Allocator<PQMFNeonFP16Engine>,void>(&v17, (uint64_t)v8);
  *a4 = v17;
  v17 = 0uLL;
  v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (SHIBYTE(v15) < 0)
    heap_Free(*(_QWORD **)(v16 + 8), __dst);
}

void sub_214E7C5B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *MelganFirstConvNeonFP16Engine::MelganFirstConvNeonFP16Engine(_QWORD *a1, uint64_t a2, char **a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  __int128 v12;
  void *v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *a1 = &unk_24D29B610;
  a1[1] = 0;
  v8 = a1 + 1;
  a1[2] = 0;
  v9 = a1 + 3;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)(a1 + 3));
  v19 = a2;
  ENTTS::make_shared<NeonFirstConvMelManager,NeonMELContainer *,std::shared_ptr<IExternalServices> &>(&v19, a4, &v12);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)v8, &v12);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(*v8 + 152), a3);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v12, v9);
  *(_QWORD *)&v12 = &unk_24D29B388;
  v13 = &unk_24D29B3B0;
  v18 = &unk_24D29B3D8;
  v14 = &unk_24D29B578;
  if (v16 < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v18);
  NeonFirstConvMelManager::ModelNpy(*v8, (uint64_t)v9);
  return a1;
}

void sub_214E7C75C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<NeonFirstConvMelManager,NeonMELContainer *,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v6 = operator new(240);
  v7 = v6;
  v8 = *a1;
  v9 = (std::__shared_weak_count *)a2[1];
  v11 = *a2;
  v12 = v9;
  if (v9)
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  NeonFirstConvMelManager::NeonFirstConvMelManager(v6, v8, &v11);
  std::shared_ptr<NeonFirstConvMelManager>::shared_ptr[abi:ne180100]<NeonFirstConvMelManager,ENTTS::Deleter<NeonFirstConvMelManager>,ENTTS::Allocator<NeonFirstConvMelManager>,void>(&v13, v7);
  *a3 = v13;
  v13 = 0uLL;
  v10 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_214E7C85C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

char **std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=(char **result, char **a2)
{
  __int128 v2;
  size_t v3;
  size_t v4;

  if (result != a2)
  {
    if (*((char *)result + 23) < 0)
    {
      v3 = (size_t)a2[1];
      if (*((char *)a2 + 23) >= 0)
      {
        v4 = *((unsigned __int8 *)a2 + 23);
      }
      else
      {
        a2 = (char **)*a2;
        v4 = v3;
      }
      return (char **)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__assign_no_alias<false>((uint64_t)result, a2, v4);
    }
    else if ((*((_BYTE *)a2 + 23) & 0x80) != 0)
    {
      return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__assign_no_alias<true>(result, *a2, (size_t)a2[1]);
    }
    else
    {
      v2 = *(_OWORD *)a2;
      result[2] = a2[2];
      *(_OWORD *)result = v2;
    }
  }
  return result;
}

void std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  std::ios_base *v7;
  std::ios_base *v8;
  std::ios_base_vtbl *v9;

  v5 = *a1;
  v4 = a1[1];
  v6 = *a2;
  a1[1] = a2[1];
  a2[1] = v4;
  v7 = (std::ios_base *)((char *)a1 + *(_QWORD *)(v5 - 24));
  v8 = (std::ios_base *)((char *)a2 + *(_QWORD *)(v6 - 24));
  std::ios_base::swap(v7, v8);
  v9 = v7[1].__vftable;
  v7[1].__vftable = v8[1].__vftable;
  v8[1].__vftable = v9;
  LODWORD(v9) = v7[1].__fmtflags_;
  v7[1].__fmtflags_ = v8[1].__fmtflags_;
  v8[1].__fmtflags_ = v9;
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap((uint64_t)(a1 + 3), (uint64_t)(a2 + 3));
}

uint64_t **MelganFirstConvNeonFP16Engine::do_inference(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t i;
  unint64_t v11;
  unint64_t j;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v29;
  uint64_t v30[4];
  uint64_t v31[5];
  uint64_t *__src;
  unint64_t v33;
  uint64_t *v34;
  _QWORD v35[3];

  v35[2] = *MEMORY[0x24BDAC8D0];
  memset(v31, 0, 24);
  v31[3] = CustomAllocator::mRsrc;
  memset(v30, 0, 24);
  v30[3] = CustomAllocator::mRsrc;
  NeonFirstConvMelManager::do_inference(*(_QWORD *)(a1 + 8), a2, a3, v31, v30);
  v7 = *(uint64_t **)a4;
  *(_QWORD *)(a4 + 8) = *(_QWORD *)a4;
  v8 = v30[0];
  v9 = *(_QWORD *)(v30[0] + 8);
  if (v9 >= 3)
  {
    v29 = a5;
    for (i = 2; i < v9; ++i)
    {
      v11 = *(_QWORD *)(v8 + 16);
      if (v11)
      {
        for (j = 0; j < v11; ++j)
        {
          v13 = (int)j + (int)i * (int)v11;
          v14 = v31[0];
          v15 = *(_QWORD *)(a4 + 16);
          if ((unint64_t)v7 >= v15)
          {
            v16 = *(uint64_t **)a4;
            v17 = ((uint64_t)v7 - *(_QWORD *)a4) >> 2;
            v18 = v17 + 1;
            if ((unint64_t)(v17 + 1) >> 62)
              std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
            v19 = v15 - (_QWORD)v16;
            if (v19 >> 1 > v18)
              v18 = v19 >> 1;
            if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL)
              v20 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v20 = v18;
            v35[1] = a4 + 24;
            if (v20)
            {
              v21 = ENTTS::Allocator<int>::allocate(a4 + 24, v20);
              v16 = *(uint64_t **)a4;
              v7 = *(uint64_t **)(a4 + 8);
            }
            else
            {
              v21 = 0;
            }
            v22 = (_DWORD *)(v21 + 4 * v17);
            *v22 = *(_DWORD *)(v14 + 4 * v13);
            if (v7 == v16)
            {
              v24 = v21 + 4 * v17;
            }
            else
            {
              v23 = v7;
              v24 = v21 + 4 * v17;
              do
              {
                v25 = *((_DWORD *)v23 - 1);
                v23 = (uint64_t *)((char *)v23 - 4);
                *(_DWORD *)(v24 - 4) = v25;
                v24 -= 4;
              }
              while (v23 != v16);
            }
            v26 = (uint64_t *)(v22 + 1);
            *(_QWORD *)a4 = v24;
            *(_QWORD *)(a4 + 8) = v22 + 1;
            v27 = *(_QWORD *)(a4 + 16);
            *(_QWORD *)(a4 + 16) = v21 + 4 * v20;
            v34 = v7;
            v35[0] = v27;
            __src = v16;
            v33 = (unint64_t)v16;
            std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&__src);
            v8 = v30[0];
            v7 = v26;
          }
          else
          {
            *(_DWORD *)v7 = *(_DWORD *)(v31[0] + 4 * v13);
            v7 = (uint64_t *)((char *)v7 + 4);
          }
          *(_QWORD *)(a4 + 8) = v7;
          v11 = *(_QWORD *)(v8 + 16);
        }
      }
      v9 = *(_QWORD *)(v8 + 8);
    }
    a5 = v29;
  }
  __src = *(uint64_t **)v8;
  v33 = v9;
  v34 = *(uint64_t **)(v8 + 16);
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a5, (char *)&__src, (uint64_t)v35, 3uLL);
  __src = v30;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](&__src);
  __src = v31;
  return std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&__src);
}

void sub_214E7CB80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t **a18)
{
  a18 = (uint64_t **)&a10;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a18);
  a10 = &a14;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a10);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<NeonFirstConvMelManager>::shared_ptr[abi:ne180100]<NeonFirstConvMelManager,ENTTS::Deleter<NeonFirstConvMelManager>,ENTTS::Allocator<NeonFirstConvMelManager>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29B650;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E7CC30(void *a1)
{
  NeonFirstConvMelManager *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    NeonFirstConvMelManager::~NeonFirstConvMelManager(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E7CC4C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

NeonFirstConvMelManager *std::__shared_ptr_pointer<NeonFirstConvMelManager *,ENTTS::Deleter<NeonFirstConvMelManager>,ENTTS::Allocator<NeonFirstConvMelManager>>::__on_zero_shared(uint64_t a1)
{
  NeonFirstConvMelManager *result;
  uint64_t v2;

  result = *(NeonFirstConvMelManager **)(a1 + 24);
  if (result)
  {
    NeonFirstConvMelManager::~NeonFirstConvMelManager(result);
    return (NeonFirstConvMelManager *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NeonFirstConvMelManager *,ENTTS::Deleter<NeonFirstConvMelManager>,ENTTS::Allocator<NeonFirstConvMelManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<NeonFirstConvMelManager *,ENTTS::Deleter<NeonFirstConvMelManager>,ENTTS::Allocator<NeonFirstConvMelManager>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

char **std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__assign_no_alias<true>(char **__dst, void *__src, size_t __len)
{
  BOOL v5;
  unint64_t v6;

  v5 = __len > 0x16;
  v6 = __len - 22;
  if (v5)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__grow_by_and_replace(__dst, 0x16uLL, v6, *((_BYTE *)__dst + 23) & 0x7F, 0, *((_BYTE *)__dst + 23) & 0x7F, __len, __src);
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    if (__len)
      memmove(__dst, __src, __len);
    *((_BYTE *)__dst + __len) = 0;
  }
  return __dst;
}

uint64_t std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__assign_no_alias<false>(uint64_t a1, void *__src, size_t __len)
{
  unint64_t v5;
  char *v6;

  v5 = *(_QWORD *)(a1 + 16) & 0x7FFFFFFFFFFFFFFFLL;
  if (v5 <= __len)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__grow_by_and_replace((char **)a1, v5 - 1, __len - v5 + 1, *(_QWORD *)(a1 + 8), 0, *(_QWORD *)(a1 + 8), __len, __src);
  }
  else
  {
    v6 = *(char **)a1;
    *(_QWORD *)(a1 + 8) = __len;
    if (__len)
      memmove(v6, __src, __len);
    v6[__len] = 0;
  }
  return a1;
}

void std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  char *v32;
  char *v33;
  BOOL v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  std::locale v45;
  std::locale v46;
  std::locale v47;
  std::locale v48;

  v4 = a2 + 64;
  if (*(char *)(a2 + 87) >= 0)
    v5 = a2 + 64;
  else
    v5 = *(_QWORD *)(a2 + 64);
  v6 = *(_QWORD *)(a2 + 16);
  if (v6)
  {
    v7 = v6 - v5;
    v8 = *(_QWORD *)(a2 + 24) - v5;
    v9 = *(_QWORD *)(a2 + 32) - v5;
  }
  else
  {
    v8 = -1;
    v9 = -1;
    v7 = -1;
  }
  v10 = *(_QWORD *)(a2 + 40);
  if (v10)
  {
    v11 = v10 - v5;
    v12 = *(_QWORD *)(a2 + 48) - v5;
    v13 = *(_QWORD *)(a2 + 56) - v5;
  }
  else
  {
    v11 = -1;
    v12 = -1;
    v13 = -1;
  }
  v14 = *(_QWORD *)(a2 + 96);
  v15 = v14 - v5;
  if (!v14)
    v15 = -1;
  v16 = (_QWORD *)(a1 + 64);
  v17 = (_QWORD *)(a1 + 64);
  if (*(char *)(a1 + 87) < 0)
    v17 = (_QWORD *)*v16;
  v18 = *(_QWORD *)(a1 + 16);
  if (v18)
  {
    v19 = v18 - (_QWORD)v17;
    v20 = *(_QWORD *)(a1 + 24) - (_QWORD)v17;
    v21 = *(_QWORD *)(a1 + 32) - (_QWORD)v17;
  }
  else
  {
    v19 = -1;
    v20 = -1;
    v21 = -1;
  }
  v22 = *(_QWORD *)(a1 + 40);
  if (v22)
  {
    v23 = v22 - (_QWORD)v17;
    v24 = *(_QWORD *)(a1 + 48) - (_QWORD)v17;
    v25 = *(_QWORD *)(a1 + 56) - (_QWORD)v17;
  }
  else
  {
    v23 = -1;
    v24 = -1;
    v25 = -1;
  }
  v26 = *(_QWORD *)(a1 + 96);
  v27 = v26 - (_QWORD)v17;
  if (!v26)
    v27 = -1;
  v28 = *(_DWORD *)(a1 + 104);
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a2 + 104);
  *(_DWORD *)(a2 + 104) = v28;
  v29 = *(_QWORD *)(a1 + 80);
  v30 = *(_OWORD *)v16;
  v31 = *(_QWORD *)(v4 + 16);
  *(_OWORD *)v16 = *(_OWORD *)v4;
  *(_QWORD *)(a1 + 80) = v31;
  *(_OWORD *)v4 = v30;
  *(_QWORD *)(v4 + 16) = v29;
  if (*(char *)(a1 + 87) < 0)
    v16 = (_QWORD *)*v16;
  v32 = (char *)v16 + v8;
  v33 = (char *)v16 + v9;
  v34 = v7 == -1;
  if (v7 == -1)
    v35 = 0;
  else
    v35 = (char *)v16 + v7;
  if (v34)
  {
    v32 = 0;
    v33 = 0;
  }
  *(_QWORD *)(a1 + 16) = v35;
  *(_QWORD *)(a1 + 24) = v32;
  *(_QWORD *)(a1 + 32) = v33;
  if (v11 == -1)
  {
    v36 = 0;
    v37 = 0;
    *(_QWORD *)(a1 + 48) = 0;
  }
  else
  {
    v36 = (char *)v16 + v11;
    v37 = (char *)v16 + v13;
    *(_QWORD *)(a1 + 48) = (char *)v16 + v11 + v12;
  }
  *(_QWORD *)(a1 + 40) = v36;
  *(_QWORD *)(a1 + 56) = v37;
  v38 = (char *)v16 + v15;
  if (v15 == -1)
    v38 = 0;
  *(_QWORD *)(a1 + 96) = v38;
  if (*(char *)(a2 + 87) < 0)
    v4 = *(_QWORD *)(a2 + 64);
  v39 = v4 + v19;
  v40 = v4 + v20;
  v41 = v4 + v21;
  if (v19 == -1)
  {
    v39 = 0;
    v40 = 0;
    v41 = 0;
  }
  *(_QWORD *)(a2 + 16) = v39;
  *(_QWORD *)(a2 + 24) = v40;
  *(_QWORD *)(a2 + 32) = v41;
  if (v23 == -1)
  {
    v42 = 0;
    v43 = 0;
    *(_QWORD *)(a2 + 48) = 0;
  }
  else
  {
    v42 = v4 + v23;
    v43 = v4 + v25;
    *(_QWORD *)(a2 + 48) = v4 + v23 + v24;
  }
  *(_QWORD *)(a2 + 40) = v42;
  *(_QWORD *)(a2 + 56) = v43;
  v44 = v4 + v27;
  if (v27 == -1)
    v44 = 0;
  *(_QWORD *)(a2 + 96) = v44;
  std::locale::locale(&v48, (const std::locale *)(a2 + 8));
  std::locale::locale(&v46, (const std::locale *)(a1 + 8));
  (*(void (**)(uint64_t, std::locale *))(*(_QWORD *)a2 + 16))(a2, &v46);
  std::locale::locale(&v47, (const std::locale *)(a2 + 8));
  std::locale::operator=((std::locale *)(a2 + 8), &v46);
  std::locale::~locale(&v47);
  std::locale::~locale(&v46);
  (*(void (**)(uint64_t, std::locale *))(*(_QWORD *)a1 + 16))(a1, &v48);
  std::locale::locale(&v45, (const std::locale *)(a1 + 8));
  std::locale::operator=((std::locale *)(a1 + 8), &v48);
  std::locale::~locale(&v45);
  std::locale::~locale(&v48);
}

void sub_214E7D0A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, std::locale a12)
{
  std::locale::~locale(&a12);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<MelganFirstConvNeonFP16Engine>::shared_ptr[abi:ne180100]<MelganFirstConvNeonFP16Engine,ENTTS::Deleter<MelganFirstConvNeonFP16Engine>,ENTTS::Allocator<MelganFirstConvNeonFP16Engine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29B6B0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E7D144(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t v13;

  __cxa_begin_catch(a1);
  ENTTS::Deleter<MelganFirstConvNeonFP16Engine>::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_214E7D15C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *ENTTS::Deleter<MelganFirstConvNeonFP16Engine>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  if (a2)
  {
    *(_QWORD *)a2 = &unk_24D29B610;
    *(_QWORD *)(a2 + 24) = &unk_24D29B388;
    *(_QWORD *)(a2 + 160) = &unk_24D29B3D8;
    v3 = a2 + 160;
    *(_QWORD *)(a2 + 40) = &unk_24D29B3B0;
    *(_QWORD *)(a2 + 48) = &unk_24D29B578;
    if (*(char *)(a2 + 135) < 0)
      heap_Free(*(_QWORD **)(*(_QWORD *)(a2 + 136) + 8), *(_QWORD *)(a2 + 112));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v3);
    std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](a2 + 8);
    return operator delete(a2);
  }
  return result;
}

_QWORD *std::__shared_ptr_pointer<MelganFirstConvNeonFP16Engine *,ENTTS::Deleter<MelganFirstConvNeonFP16Engine>,ENTTS::Allocator<MelganFirstConvNeonFP16Engine>>::__on_zero_shared(uint64_t a1)
{
  return ENTTS::Deleter<MelganFirstConvNeonFP16Engine>::operator()(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<MelganFirstConvNeonFP16Engine *,ENTTS::Deleter<MelganFirstConvNeonFP16Engine>,ENTTS::Allocator<MelganFirstConvNeonFP16Engine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_QWORD *std::__shared_ptr_pointer<MelganFirstConvNeonFP16Engine *,ENTTS::Deleter<MelganFirstConvNeonFP16Engine>,ENTTS::Allocator<MelganFirstConvNeonFP16Engine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *MelganFirstBlockNeonFP16Engine::MelganFirstBlockNeonFP16Engine(_QWORD *a1, uint64_t a2, char **a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  __int128 v12;
  void *v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *a1 = &unk_24D29B710;
  a1[1] = 0;
  v8 = a1 + 1;
  a1[2] = 0;
  v9 = a1 + 3;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)(a1 + 3));
  v19 = a2;
  ENTTS::make_shared<NeonFirstBlockMelManager,NeonMELContainer *,std::shared_ptr<IExternalServices> &>(&v19, a4, &v12);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)v8, &v12);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(*v8 + 152), a3);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v12, v9);
  *(_QWORD *)&v12 = &unk_24D29B388;
  v13 = &unk_24D29B3B0;
  v18 = &unk_24D29B3D8;
  v14 = &unk_24D29B578;
  if (v16 < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v18);
  NeonFirstBlockMelManager::ModelNpy(*v8, (uint64_t)v9);
  return a1;
}

void sub_214E7D430(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<NeonFirstBlockMelManager,NeonMELContainer *,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v6 = operator new(240);
  v7 = v6;
  v8 = *a1;
  v9 = (std::__shared_weak_count *)a2[1];
  v11 = *a2;
  v12 = v9;
  if (v9)
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  NeonFirstBlockMelManager::NeonFirstBlockMelManager(v6, v8, &v11);
  std::shared_ptr<NeonFirstBlockMelManager>::shared_ptr[abi:ne180100]<NeonFirstBlockMelManager,ENTTS::Deleter<NeonFirstBlockMelManager>,ENTTS::Allocator<NeonFirstBlockMelManager>,void>(&v13, v7);
  *a3 = v13;
  v13 = 0uLL;
  v10 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_214E7D530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void MelganFirstBlockNeonFP16Engine::do_inference(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  NeonFirstBlockMelManager::do_inference(*(_QWORD *)(a1 + 8), a2, a3, a4, a5);
}

_QWORD *std::shared_ptr<NeonFirstBlockMelManager>::shared_ptr[abi:ne180100]<NeonFirstBlockMelManager,ENTTS::Deleter<NeonFirstBlockMelManager>,ENTTS::Allocator<NeonFirstBlockMelManager>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29B750;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E7D5DC(void *a1)
{
  NeonFirstBlockMelManager *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    NeonFirstBlockMelManager::~NeonFirstBlockMelManager(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E7D5F8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

NeonFirstBlockMelManager *std::__shared_ptr_pointer<NeonFirstBlockMelManager *,ENTTS::Deleter<NeonFirstBlockMelManager>,ENTTS::Allocator<NeonFirstBlockMelManager>>::__on_zero_shared(uint64_t a1)
{
  NeonFirstBlockMelManager *result;
  uint64_t v2;

  result = *(NeonFirstBlockMelManager **)(a1 + 24);
  if (result)
  {
    NeonFirstBlockMelManager::~NeonFirstBlockMelManager(result);
    return (NeonFirstBlockMelManager *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NeonFirstBlockMelManager *,ENTTS::Deleter<NeonFirstBlockMelManager>,ENTTS::Allocator<NeonFirstBlockMelManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<NeonFirstBlockMelManager *,ENTTS::Deleter<NeonFirstBlockMelManager>,ENTTS::Allocator<NeonFirstBlockMelManager>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *std::shared_ptr<MelganFirstBlockNeonFP16Engine>::shared_ptr[abi:ne180100]<MelganFirstBlockNeonFP16Engine,ENTTS::Deleter<MelganFirstBlockNeonFP16Engine>,ENTTS::Allocator<MelganFirstBlockNeonFP16Engine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29B7B0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E7D710(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t v13;

  __cxa_begin_catch(a1);
  ENTTS::Deleter<MelganFirstBlockNeonFP16Engine>::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_214E7D728(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *ENTTS::Deleter<MelganFirstBlockNeonFP16Engine>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  if (a2)
  {
    *(_QWORD *)a2 = &unk_24D29B710;
    *(_QWORD *)(a2 + 24) = &unk_24D29B388;
    *(_QWORD *)(a2 + 160) = &unk_24D29B3D8;
    v3 = a2 + 160;
    *(_QWORD *)(a2 + 40) = &unk_24D29B3B0;
    *(_QWORD *)(a2 + 48) = &unk_24D29B578;
    if (*(char *)(a2 + 135) < 0)
      heap_Free(*(_QWORD **)(*(_QWORD *)(a2 + 136) + 8), *(_QWORD *)(a2 + 112));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v3);
    std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](a2 + 8);
    return operator delete(a2);
  }
  return result;
}

_QWORD *std::__shared_ptr_pointer<MelganFirstBlockNeonFP16Engine *,ENTTS::Deleter<MelganFirstBlockNeonFP16Engine>,ENTTS::Allocator<MelganFirstBlockNeonFP16Engine>>::__on_zero_shared(uint64_t a1)
{
  return ENTTS::Deleter<MelganFirstBlockNeonFP16Engine>::operator()(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<MelganFirstBlockNeonFP16Engine *,ENTTS::Deleter<MelganFirstBlockNeonFP16Engine>,ENTTS::Allocator<MelganFirstBlockNeonFP16Engine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_QWORD *std::__shared_ptr_pointer<MelganFirstBlockNeonFP16Engine *,ENTTS::Deleter<MelganFirstBlockNeonFP16Engine>,ENTTS::Allocator<MelganFirstBlockNeonFP16Engine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *MelganSecondBlockNeonFP16Engine::MelganSecondBlockNeonFP16Engine(_QWORD *a1, uint64_t a2, char **a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  __int128 v12;
  void *v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *a1 = &unk_24D29B810;
  a1[1] = 0;
  v8 = a1 + 1;
  a1[2] = 0;
  v9 = a1 + 3;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)(a1 + 3));
  v19 = a2;
  ENTTS::make_shared<NeonSecondBlockMelManager,NeonMELContainer *,std::shared_ptr<IExternalServices> &>(&v19, a4, &v12);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)v8, &v12);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(*v8 + 152), a3);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v12, v9);
  *(_QWORD *)&v12 = &unk_24D29B388;
  v13 = &unk_24D29B3B0;
  v18 = &unk_24D29B3D8;
  v14 = &unk_24D29B578;
  if (v16 < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v18);
  NeonSecondBlockMelManager::ModelNpy(*v8, (uint64_t)v9);
  return a1;
}

void sub_214E7D9FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<NeonSecondBlockMelManager,NeonMELContainer *,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v6 = operator new(240);
  v7 = v6;
  v8 = *a1;
  v9 = (std::__shared_weak_count *)a2[1];
  v11 = *a2;
  v12 = v9;
  if (v9)
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  NeonSecondBlockMelManager::NeonSecondBlockMelManager(v6, v8, &v11);
  std::shared_ptr<NeonSecondBlockMelManager>::shared_ptr[abi:ne180100]<NeonSecondBlockMelManager,ENTTS::Deleter<NeonSecondBlockMelManager>,ENTTS::Allocator<NeonSecondBlockMelManager>,void>(&v13, v7);
  *a3 = v13;
  v13 = 0uLL;
  v10 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_214E7DAFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void MelganSecondBlockNeonFP16Engine::do_inference(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  NeonSecondBlockMelManager::do_inference(*(_QWORD *)(a1 + 8), a2, a3, a4, a5);
}

_QWORD *std::shared_ptr<NeonSecondBlockMelManager>::shared_ptr[abi:ne180100]<NeonSecondBlockMelManager,ENTTS::Deleter<NeonSecondBlockMelManager>,ENTTS::Allocator<NeonSecondBlockMelManager>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29B850;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E7DBA8(void *a1)
{
  NeonSecondBlockMelManager *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    NeonSecondBlockMelManager::~NeonSecondBlockMelManager(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E7DBC4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

NeonSecondBlockMelManager *std::__shared_ptr_pointer<NeonSecondBlockMelManager *,ENTTS::Deleter<NeonSecondBlockMelManager>,ENTTS::Allocator<NeonSecondBlockMelManager>>::__on_zero_shared(uint64_t a1)
{
  NeonSecondBlockMelManager *result;
  uint64_t v2;

  result = *(NeonSecondBlockMelManager **)(a1 + 24);
  if (result)
  {
    NeonSecondBlockMelManager::~NeonSecondBlockMelManager(result);
    return (NeonSecondBlockMelManager *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NeonSecondBlockMelManager *,ENTTS::Deleter<NeonSecondBlockMelManager>,ENTTS::Allocator<NeonSecondBlockMelManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<NeonSecondBlockMelManager *,ENTTS::Deleter<NeonSecondBlockMelManager>,ENTTS::Allocator<NeonSecondBlockMelManager>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *std::shared_ptr<MelganSecondBlockNeonFP16Engine>::shared_ptr[abi:ne180100]<MelganSecondBlockNeonFP16Engine,ENTTS::Deleter<MelganSecondBlockNeonFP16Engine>,ENTTS::Allocator<MelganSecondBlockNeonFP16Engine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29B8B0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E7DCDC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t v13;

  __cxa_begin_catch(a1);
  ENTTS::Deleter<MelganSecondBlockNeonFP16Engine>::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_214E7DCF4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *ENTTS::Deleter<MelganSecondBlockNeonFP16Engine>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  if (a2)
  {
    *(_QWORD *)a2 = &unk_24D29B810;
    *(_QWORD *)(a2 + 24) = &unk_24D29B388;
    *(_QWORD *)(a2 + 160) = &unk_24D29B3D8;
    v3 = a2 + 160;
    *(_QWORD *)(a2 + 40) = &unk_24D29B3B0;
    *(_QWORD *)(a2 + 48) = &unk_24D29B578;
    if (*(char *)(a2 + 135) < 0)
      heap_Free(*(_QWORD **)(*(_QWORD *)(a2 + 136) + 8), *(_QWORD *)(a2 + 112));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v3);
    std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](a2 + 8);
    return operator delete(a2);
  }
  return result;
}

_QWORD *std::__shared_ptr_pointer<MelganSecondBlockNeonFP16Engine *,ENTTS::Deleter<MelganSecondBlockNeonFP16Engine>,ENTTS::Allocator<MelganSecondBlockNeonFP16Engine>>::__on_zero_shared(uint64_t a1)
{
  return ENTTS::Deleter<MelganSecondBlockNeonFP16Engine>::operator()(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<MelganSecondBlockNeonFP16Engine *,ENTTS::Deleter<MelganSecondBlockNeonFP16Engine>,ENTTS::Allocator<MelganSecondBlockNeonFP16Engine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_QWORD *std::__shared_ptr_pointer<MelganSecondBlockNeonFP16Engine *,ENTTS::Deleter<MelganSecondBlockNeonFP16Engine>,ENTTS::Allocator<MelganSecondBlockNeonFP16Engine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *MelganThirdBlockNeonFP16Engine::MelganThirdBlockNeonFP16Engine(_QWORD *a1, uint64_t a2, char **a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  __int128 v12;
  void *v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *a1 = &unk_24D29B910;
  a1[1] = 0;
  v8 = a1 + 1;
  a1[2] = 0;
  v9 = a1 + 3;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)(a1 + 3));
  v19 = a2;
  ENTTS::make_shared<NeonThirdBlockMelManager,NeonMELContainer *,std::shared_ptr<IExternalServices> &>(&v19, a4, &v12);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)v8, &v12);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(*v8 + 152), a3);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v12, v9);
  *(_QWORD *)&v12 = &unk_24D29B388;
  v13 = &unk_24D29B3B0;
  v18 = &unk_24D29B3D8;
  v14 = &unk_24D29B578;
  if (v16 < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v18);
  NeonThirdBlockMelManager::ModelNpy(*v8, (uint64_t)v9);
  return a1;
}

void sub_214E7DFC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<NeonThirdBlockMelManager,NeonMELContainer *,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v6 = operator new(240);
  v7 = v6;
  v8 = *a1;
  v9 = (std::__shared_weak_count *)a2[1];
  v11 = *a2;
  v12 = v9;
  if (v9)
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  NeonThirdBlockMelManager::NeonThirdBlockMelManager(v6, v8, &v11);
  std::shared_ptr<NeonThirdBlockMelManager>::shared_ptr[abi:ne180100]<NeonThirdBlockMelManager,ENTTS::Deleter<NeonThirdBlockMelManager>,ENTTS::Allocator<NeonThirdBlockMelManager>,void>(&v13, v7);
  *a3 = v13;
  v13 = 0uLL;
  v10 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_214E7E0C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void MelganThirdBlockNeonFP16Engine::do_inference(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  NeonThirdBlockMelManager::do_inference(*(_QWORD *)(a1 + 8), a2, a3, a4, a5);
}

_QWORD *std::shared_ptr<NeonThirdBlockMelManager>::shared_ptr[abi:ne180100]<NeonThirdBlockMelManager,ENTTS::Deleter<NeonThirdBlockMelManager>,ENTTS::Allocator<NeonThirdBlockMelManager>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29B950;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E7E174(void *a1)
{
  NeonThirdBlockMelManager *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    NeonThirdBlockMelManager::~NeonThirdBlockMelManager(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E7E190(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

NeonThirdBlockMelManager *std::__shared_ptr_pointer<NeonThirdBlockMelManager *,ENTTS::Deleter<NeonThirdBlockMelManager>,ENTTS::Allocator<NeonThirdBlockMelManager>>::__on_zero_shared(uint64_t a1)
{
  NeonThirdBlockMelManager *result;
  uint64_t v2;

  result = *(NeonThirdBlockMelManager **)(a1 + 24);
  if (result)
  {
    NeonThirdBlockMelManager::~NeonThirdBlockMelManager(result);
    return (NeonThirdBlockMelManager *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NeonThirdBlockMelManager *,ENTTS::Deleter<NeonThirdBlockMelManager>,ENTTS::Allocator<NeonThirdBlockMelManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<NeonThirdBlockMelManager *,ENTTS::Deleter<NeonThirdBlockMelManager>,ENTTS::Allocator<NeonThirdBlockMelManager>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *std::shared_ptr<MelganThirdBlockNeonFP16Engine>::shared_ptr[abi:ne180100]<MelganThirdBlockNeonFP16Engine,ENTTS::Deleter<MelganThirdBlockNeonFP16Engine>,ENTTS::Allocator<MelganThirdBlockNeonFP16Engine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29B9B0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E7E2A8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t v13;

  __cxa_begin_catch(a1);
  ENTTS::Deleter<MelganThirdBlockNeonFP16Engine>::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_214E7E2C0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *ENTTS::Deleter<MelganThirdBlockNeonFP16Engine>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  if (a2)
  {
    *(_QWORD *)a2 = &unk_24D29B910;
    *(_QWORD *)(a2 + 24) = &unk_24D29B388;
    *(_QWORD *)(a2 + 160) = &unk_24D29B3D8;
    v3 = a2 + 160;
    *(_QWORD *)(a2 + 40) = &unk_24D29B3B0;
    *(_QWORD *)(a2 + 48) = &unk_24D29B578;
    if (*(char *)(a2 + 135) < 0)
      heap_Free(*(_QWORD **)(*(_QWORD *)(a2 + 136) + 8), *(_QWORD *)(a2 + 112));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v3);
    std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](a2 + 8);
    return operator delete(a2);
  }
  return result;
}

_QWORD *std::__shared_ptr_pointer<MelganThirdBlockNeonFP16Engine *,ENTTS::Deleter<MelganThirdBlockNeonFP16Engine>,ENTTS::Allocator<MelganThirdBlockNeonFP16Engine>>::__on_zero_shared(uint64_t a1)
{
  return ENTTS::Deleter<MelganThirdBlockNeonFP16Engine>::operator()(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<MelganThirdBlockNeonFP16Engine *,ENTTS::Deleter<MelganThirdBlockNeonFP16Engine>,ENTTS::Allocator<MelganThirdBlockNeonFP16Engine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_QWORD *std::__shared_ptr_pointer<MelganThirdBlockNeonFP16Engine *,ENTTS::Deleter<MelganThirdBlockNeonFP16Engine>,ENTTS::Allocator<MelganThirdBlockNeonFP16Engine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *PQMFNeonFP16Engine::PQMFNeonFP16Engine(_QWORD *a1, uint64_t a2, char **a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  __int128 v12;
  void *v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *a1 = &unk_24D29BA10;
  a1[1] = 0;
  v8 = a1 + 1;
  a1[2] = 0;
  v9 = a1 + 3;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)(a1 + 3));
  v19 = a2;
  ENTTS::make_shared<NeonPqmfBlockMelManager,NeonMELContainer *,std::shared_ptr<IExternalServices> &>(&v19, a4, &v12);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)v8, &v12);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(*v8 + 152), a3);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v12, v9);
  *(_QWORD *)&v12 = &unk_24D29B388;
  v13 = &unk_24D29B3B0;
  v18 = &unk_24D29B3D8;
  v14 = &unk_24D29B578;
  if (v16 < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v18);
  NeonPqmfBlockMelManager::ModelNpy(*v8, (uint64_t)v9);
  return a1;
}

void sub_214E7E594(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<NeonPqmfBlockMelManager,NeonMELContainer *,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v6 = operator new(240);
  v7 = v6;
  v8 = *a1;
  v9 = (std::__shared_weak_count *)a2[1];
  v11 = *a2;
  v12 = v9;
  if (v9)
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  NeonPqmfBlockMelManager::NeonPqmfBlockMelManager(v6, v8, &v11);
  std::shared_ptr<NeonPqmfBlockMelManager>::shared_ptr[abi:ne180100]<NeonPqmfBlockMelManager,ENTTS::Deleter<NeonPqmfBlockMelManager>,ENTTS::Allocator<NeonPqmfBlockMelManager>,void>(&v13, v7);
  *a3 = v13;
  v13 = 0uLL;
  v10 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_214E7E694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t **PQMFNeonFP16Engine::do_inference(uint64_t a1, uint64_t a2, _QWORD **a3, uint64_t *a4, uint64_t *a5)
{
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v13[4];
  void *__src;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18[4];
  void *__dst[4];
  __int128 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  memset(__dst, 0, 24);
  __dst[3] = (void *)CustomAllocator::mRsrc;
  memset(v18, 0, 24);
  v18[3] = (uint64_t *)CustomAllocator::mRsrc;
  __src = 0;
  v15 = 0;
  v16 = 0;
  v17 = CustomAllocator::mRsrc;
  memset(v13, 0, 24);
  v13[3] = (uint64_t *)CustomAllocator::mRsrc;
  std::vector<float,ENTTS::Allocator<float>>::resize((uint64_t *)__dst, ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2) + 20480);
  memcpy(__dst[0], *(const void **)a2, *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  v10 = *a3;
  v11 = (*a3)[1] + 256;
  *(_QWORD *)&v20 = **a3;
  *((_QWORD *)&v20 + 1) = v11;
  v21 = v10[2];
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>((uint64_t *)v18, (char *)&v20, (uint64_t)&v22, 3uLL);
  NeonPqmfBlockMelManager::do_inference(*(_QWORD *)(a1 + 8), (uint64_t)__dst, (uint64_t *)v18, (uint64_t *)&__src, (uint64_t *)v13);
  std::vector<float,ENTTS::Allocator<float>>::resize(a4, ((v15 - (uint64_t)__src) >> 2) - 1024);
  memcpy((void *)*a4, __src, a4[1] - *a4);
  v20 = *(_OWORD *)v13[0];
  v21 = v13[0][2] - 1024;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a5, (char *)&v20, (uint64_t)&v22, 3uLL);
  *(_QWORD *)&v20 = v13;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v20);
  v13[0] = (uint64_t *)&__src;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v13);
  __src = v18;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&__src);
  v18[0] = (uint64_t *)__dst;
  return std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v18);
}

void sub_214E7E864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t ***a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t **a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  uint64_t v21;

  *(_QWORD *)(v21 - 80) = &a9;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v21 - 80));
  a9 = &a13;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a9);
  a13 = (uint64_t **)&a17;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a13);
  a17 = &a21;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a17);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<NeonPqmfBlockMelManager>::shared_ptr[abi:ne180100]<NeonPqmfBlockMelManager,ENTTS::Deleter<NeonPqmfBlockMelManager>,ENTTS::Allocator<NeonPqmfBlockMelManager>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BA50;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E7E930(void *a1)
{
  NeonPqmfBlockMelManager *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    NeonPqmfBlockMelManager::~NeonPqmfBlockMelManager(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E7E94C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

NeonPqmfBlockMelManager *std::__shared_ptr_pointer<NeonPqmfBlockMelManager *,ENTTS::Deleter<NeonPqmfBlockMelManager>,ENTTS::Allocator<NeonPqmfBlockMelManager>>::__on_zero_shared(uint64_t a1)
{
  NeonPqmfBlockMelManager *result;
  uint64_t v2;

  result = *(NeonPqmfBlockMelManager **)(a1 + 24);
  if (result)
  {
    NeonPqmfBlockMelManager::~NeonPqmfBlockMelManager(result);
    return (NeonPqmfBlockMelManager *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NeonPqmfBlockMelManager *,ENTTS::Deleter<NeonPqmfBlockMelManager>,ENTTS::Allocator<NeonPqmfBlockMelManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<NeonPqmfBlockMelManager *,ENTTS::Deleter<NeonPqmfBlockMelManager>,ENTTS::Allocator<NeonPqmfBlockMelManager>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *std::shared_ptr<PQMFNeonFP16Engine>::shared_ptr[abi:ne180100]<PQMFNeonFP16Engine,ENTTS::Deleter<PQMFNeonFP16Engine>,ENTTS::Allocator<PQMFNeonFP16Engine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BAB0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E7EA64(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t v13;

  __cxa_begin_catch(a1);
  ENTTS::Deleter<PQMFNeonFP16Engine>::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_214E7EA7C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *ENTTS::Deleter<PQMFNeonFP16Engine>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  if (a2)
  {
    *(_QWORD *)a2 = &unk_24D29BA10;
    *(_QWORD *)(a2 + 24) = &unk_24D29B388;
    *(_QWORD *)(a2 + 160) = &unk_24D29B3D8;
    v3 = a2 + 160;
    *(_QWORD *)(a2 + 40) = &unk_24D29B3B0;
    *(_QWORD *)(a2 + 48) = &unk_24D29B578;
    if (*(char *)(a2 + 135) < 0)
      heap_Free(*(_QWORD **)(*(_QWORD *)(a2 + 136) + 8), *(_QWORD *)(a2 + 112));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v3);
    std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](a2 + 8);
    return operator delete(a2);
  }
  return result;
}

_QWORD *std::__shared_ptr_pointer<PQMFNeonFP16Engine *,ENTTS::Deleter<PQMFNeonFP16Engine>,ENTTS::Allocator<PQMFNeonFP16Engine>>::__on_zero_shared(uint64_t a1)
{
  return ENTTS::Deleter<PQMFNeonFP16Engine>::operator()(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<PQMFNeonFP16Engine *,ENTTS::Deleter<PQMFNeonFP16Engine>,ENTTS::Allocator<PQMFNeonFP16Engine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<PQMFNeonFP16Engine *,ENTTS::Deleter<PQMFNeonFP16Engine>,ENTTS::Allocator<PQMFNeonFP16Engine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

uint64_t ModelParameters::ModelParameters(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t j;
  uint64_t v9;
  uint64_t k;
  uint64_t v11;
  uint64_t m;
  uint64_t v13;
  uint64_t n;
  uint64_t v15;
  uint64_t ii;
  uint64_t v17;
  uint64_t jj;
  uint64_t v19;
  uint64_t kk;
  uint64_t v21;
  uint64_t mm;
  uint64_t v23;
  uint64_t nn;
  uint64_t v25;
  uint64_t i1;
  uint64_t v27;
  uint64_t i2;
  uint64_t v29;
  uint64_t i3;
  uint64_t v32[2];
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39[2];
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46[2];
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53[2];
  char v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60[2];
  char v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67[2];
  char v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74[2];
  char v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81[2];
  char v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88[2];
  char v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95[2];
  char v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102[2];
  char v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109[2];
  char v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116[2];
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123[2];
  char v124;
  uint64_t v125;
  uint64_t *v126;
  char v127;
  _QWORD v128[4];
  _QWORD v129[4];
  uint64_t v130;

  v130 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)a1 = xmmword_214FBEFA0;
  *(_OWORD *)(a1 + 16) = xmmword_214FBEFB0;
  *(_OWORD *)(a1 + 32) = xmmword_214FBEFC0;
  *(_QWORD *)(a1 + 48) = 500;
  *(_QWORD *)(a1 + 56) = 0x600000049;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  v4 = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 88) = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = v4;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = v4;
  *(_QWORD *)(a1 + 160) = 0;
  v5 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "postnet_vision_field");
  v119 = 0;
  v120 = 0;
  v121 = 0;
  v122 = CustomAllocator::mRsrc;
  v126 = &v119;
  v127 = 0;
  v119 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v122, 2);
  v120 = v119;
  v121 = v119 + 64;
  v120 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v122, (uint64_t)v128, (uint64_t)&v130, v119);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v116, "21");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v5 + 8))(v123, v5, &v119, v116);
  *(_DWORD *)a1 = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v117 < 0)
    heap_Free(*(_QWORD **)(v118 + 8), v116[0]);
  v126 = &v119;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (i = 0; i != -8; i -= 4)
  {
    if (SHIBYTE(v129[i + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[i + 3] + 8), v128[i + 4]);
  }
  v7 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "sampling_rate");
  v113 = 0;
  v112 = 0;
  v114 = 0;
  v115 = CustomAllocator::mRsrc;
  v126 = &v112;
  v127 = 0;
  v112 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v115, 2);
  v113 = v112;
  v114 = v112 + 64;
  v113 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v115, (uint64_t)v128, (uint64_t)&v130, v112);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v109, "22050");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v7 + 8))(v123, v7, &v112, v109);
  *(_DWORD *)(a1 + 4) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v110 < 0)
    heap_Free(*(_QWORD **)(v111 + 8), v109[0]);
  v126 = &v112;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (j = 0; j != -8; j -= 4)
  {
    if (SHIBYTE(v129[j + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[j + 3] + 8), v128[j + 4]);
  }
  v9 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "hop_length");
  v106 = 0;
  v105 = 0;
  v107 = 0;
  v108 = CustomAllocator::mRsrc;
  v126 = &v105;
  v127 = 0;
  v105 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v108, 2);
  v106 = v105;
  v107 = v105 + 64;
  v106 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v108, (uint64_t)v128, (uint64_t)&v130, v105);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v102, "256");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v9 + 8))(v123, v9, &v105, v102);
  *(_DWORD *)(a1 + 8) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v103 < 0)
    heap_Free(*(_QWORD **)(v104 + 8), v102[0]);
  v126 = &v105;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (k = 0; k != -8; k -= 4)
  {
    if (SHIBYTE(v129[k + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[k + 3] + 8), v128[k + 4]);
  }
  v11 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "frames_per_step");
  v99 = 0;
  v98 = 0;
  v100 = 0;
  v101 = CustomAllocator::mRsrc;
  v126 = &v98;
  v127 = 0;
  v98 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v101, 2);
  v99 = v98;
  v100 = v98 + 64;
  v99 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v101, (uint64_t)v128, (uint64_t)&v130, v98);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v95, "3");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v11 + 8))(v123, v11, &v98, v95);
  *(_DWORD *)(a1 + 12) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v96 < 0)
    heap_Free(*(_QWORD **)(v97 + 8), v95[0]);
  v126 = &v98;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (m = 0; m != -8; m -= 4)
  {
    if (SHIBYTE(v129[m + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[m + 3] + 8), v128[m + 4]);
  }
  v13 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "num_mels");
  v92 = 0;
  v91 = 0;
  v93 = 0;
  v94 = CustomAllocator::mRsrc;
  v126 = &v91;
  v127 = 0;
  v91 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v94, 2);
  v92 = v91;
  v93 = v91 + 64;
  v92 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v94, (uint64_t)v128, (uint64_t)&v130, v91);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v88, "80");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v13 + 8))(v123, v13, &v91, v88);
  *(_DWORD *)(a1 + 16) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v89 < 0)
    heap_Free(*(_QWORD **)(v90 + 8), v88[0]);
  v126 = &v91;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (n = 0; n != -8; n -= 4)
  {
    if (SHIBYTE(v129[n + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[n + 3] + 8), v128[n + 4]);
  }
  v15 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "tc2_max_iters");
  v84 = 0;
  v85 = 0;
  v86 = 0;
  v87 = CustomAllocator::mRsrc;
  v126 = &v84;
  v127 = 0;
  v84 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v87, 2);
  v85 = v84;
  v86 = v84 + 64;
  v85 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v87, (uint64_t)v128, (uint64_t)&v130, v84);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v81, "1000");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v15 + 8))(v123, v15, &v84, v81);
  *(_DWORD *)(a1 + 20) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v82 < 0)
    heap_Free(*(_QWORD **)(v83 + 8), v81[0]);
  v126 = &v84;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (ii = 0; ii != -8; ii -= 4)
  {
    if (SHIBYTE(v129[ii + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[ii + 3] + 8), v128[ii + 4]);
  }
  v17 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "output_frames_per_cycle");
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = CustomAllocator::mRsrc;
  v126 = &v77;
  v127 = 0;
  v77 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v80, 2);
  v78 = v77;
  v79 = v77 + 64;
  v78 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v80, (uint64_t)v128, (uint64_t)&v130, v77);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v74, "56");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v17 + 8))(v123, v17, &v77, v74);
  *(_DWORD *)(a1 + 28) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v75 < 0)
    heap_Free(*(_QWORD **)(v76 + 8), v74[0]);
  v126 = &v77;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (jj = 0; jj != -8; jj -= 4)
  {
    if (SHIBYTE(v129[jj + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[jj + 3] + 8), v128[jj + 4]);
  }
  v19 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "output_frames_first_cycle");
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = CustomAllocator::mRsrc;
  v126 = &v70;
  v127 = 0;
  v70 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v73, 2);
  v71 = v70;
  v72 = v70 + 64;
  v71 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v73, (uint64_t)v128, (uint64_t)&v130, v70);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v67, "41");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v19 + 8))(v123, v19, &v70, v67);
  *(_DWORD *)(a1 + 24) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v68 < 0)
    heap_Free(*(_QWORD **)(v69 + 8), v67[0]);
  v126 = &v70;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (kk = 0; kk != -8; kk -= 4)
  {
    if (SHIBYTE(v129[kk + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[kk + 3] + 8), v128[kk + 4]);
  }
  v21 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "max_input_length");
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v66 = CustomAllocator::mRsrc;
  v126 = &v63;
  v127 = 0;
  v63 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v66, 2);
  v64 = v63;
  v65 = v63 + 64;
  v64 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v66, (uint64_t)v128, (uint64_t)&v130, v63);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v60, "500");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v21 + 8))(v123, v21, &v63, v60);
  *(_DWORD *)(a1 + 48) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v61 < 0)
    heap_Free(*(_QWORD **)(v62 + 8), v60[0]);
  v126 = &v63;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (mm = 0; mm != -8; mm -= 4)
  {
    if (SHIBYTE(v129[mm + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[mm + 3] + 8), v128[mm + 4]);
  }
  v23 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "pad_to_same_length");
  v56 = 0;
  v57 = 0;
  v58 = 0;
  v59 = CustomAllocator::mRsrc;
  v126 = &v56;
  v127 = 0;
  v56 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v59, 2);
  v57 = v56;
  v58 = v56 + 64;
  v57 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v59, (uint64_t)v128, (uint64_t)&v130, v56);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v53, "0");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v23 + 8))(v123, v23, &v56, v53);
  *(_DWORD *)(a1 + 44) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v54 < 0)
    heap_Free(*(_QWORD **)(v55 + 8), v53[0]);
  v126 = &v56;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (nn = 0; nn != -8; nn -= 4)
  {
    if (SHIBYTE(v129[nn + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[nn + 3] + 8), v128[nn + 4]);
  }
  v25 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "overlap");
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = CustomAllocator::mRsrc;
  v126 = &v49;
  v127 = 0;
  v49 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v52, 2);
  v50 = v49;
  v51 = v49 + 64;
  v50 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v52, (uint64_t)v128, (uint64_t)&v130, v49);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v46, "10");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v25 + 8))(v123, v25, &v49, v46);
  *(_DWORD *)(a1 + 32) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v47 < 0)
    heap_Free(*(_QWORD **)(v48 + 8), v46[0]);
  v126 = &v49;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (i1 = 0; i1 != -8; i1 -= 4)
  {
    if (SHIBYTE(v129[i1 + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[i1 + 3] + 8), v128[i1 + 4]);
  }
  v27 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "extra");
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = CustomAllocator::mRsrc;
  v126 = &v42;
  v127 = 0;
  v42 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v45, 2);
  v43 = v42;
  v44 = v42 + 64;
  v43 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v45, (uint64_t)v128, (uint64_t)&v130, v42);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v39, "6");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v27 + 8))(v123, v27, &v42, v39);
  *(_DWORD *)(a1 + 36) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v40 < 0)
    heap_Free(*(_QWORD **)(v41 + 8), v39[0]);
  v126 = &v42;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (i2 = 0; i2 != -8; i2 -= 4)
  {
    if (SHIBYTE(v129[i2 + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[i2 + 3] + 8), v128[i2 + 4]);
  }
  v29 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v128, "Params");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v129, "silence_length");
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = CustomAllocator::mRsrc;
  v126 = &v35;
  v127 = 0;
  v35 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v38, 2);
  v36 = v35;
  v37 = v35 + 64;
  v36 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v38, (uint64_t)v128, (uint64_t)&v130, v35);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v32, "7");
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v29 + 8))(v123, v29, &v35, v32);
  *(_DWORD *)(a1 + 40) = ENTTS::stoi((uint64_t)v123, 0, 10);
  if (v124 < 0)
    heap_Free(*(_QWORD **)(v125 + 8), v123[0]);
  if (v33 < 0)
    heap_Free(*(_QWORD **)(v34 + 8), v32[0]);
  v126 = &v35;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v126);
  for (i3 = 0; i3 != -8; i3 -= 4)
  {
    if (SHIBYTE(v129[i3 + 2]) < 0)
      heap_Free(*(_QWORD **)(v129[i3 + 3] + 8), v128[i3 + 4]);
  }
  return a1;
}

void sub_214E7FC6C(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t ENTTS::stoi(uint64_t a1, _QWORD *a2, int a3)
{
  const char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  _DWORD *exception;
  int v13;
  char *__endptr;

  if (*(char *)(a1 + 23) >= 0)
    v5 = (const char *)a1;
  else
    v5 = *(const char **)a1;
  __endptr = 0;
  *__error() = 0;
  v6 = strtol(v5, &__endptr, a3);
  v7 = __endptr;
  if (v5 == __endptr)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    v13 = 7;
LABEL_17:
    exception[2] = v13;
  }
  v8 = v6;
  if (*__error() == 34 || v8 < (uint64_t)0xFFFFFFFF80000000 || v8 >= 0x80000000)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    v13 = 15;
    goto LABEL_17;
  }
  if (a2)
    *a2 = v7 - v5;
  return v8;
}

void create_convnet_engine(int a1@<W0>, uint64_t a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X8>)
{
  __int128 v7;
  __int128 v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v11, "TC2 Convnet");
  if ((a1 & 0xFFFFFFFB) != 0 && a1 == 1)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v8, "convnet");
    ENTTS::make_shared<ConvnetNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(&v14, &v8, a3, &v7);
    *(_OWORD *)a4 = v7;
    if (v9 < 0)
      heap_Free(*(_QWORD **)(v10 + 8), v8);
  }
  else
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
  }
  if (v12 < 0)
    heap_Free(*(_QWORD **)(v13 + 8), v11);
}

void sub_214E804B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<ConvnetNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _OWORD *a4@<X8>)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 __dst;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v8 = (_QWORD *)operator new(312);
  v9 = *a1;
  v16 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    __dst = *a2;
    v15 = *((_QWORD *)a2 + 2);
  }
  v10 = a3[1];
  v12 = *a3;
  v13 = (std::__shared_weak_count *)v10;
  if (v10)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  ConvnetNeonFP16Engine::ConvnetNeonFP16Engine(v8, v9, (char **)&__dst, &v12);
  std::shared_ptr<ConvnetNeonFP16Engine>::shared_ptr[abi:ne180100]<ConvnetNeonFP16Engine,ENTTS::Deleter<ConvnetNeonFP16Engine>,ENTTS::Allocator<ConvnetNeonFP16Engine>,void>(&v17, (uint64_t)v8);
  *a4 = v17;
  v17 = 0uLL;
  v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (SHIBYTE(v15) < 0)
    heap_Free(*(_QWORD **)(v16 + 8), __dst);
}

void sub_214E80604(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void create_lstm_engine(int a1@<W0>, uint64_t a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X8>)
{
  __int128 v7;
  __int128 v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v11, "TC2 LSTM");
  if ((a1 & 0xFFFFFFFB) != 0 && a1 == 1)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v8, "lstm");
    ENTTS::make_shared<LSTMNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(&v14, &v8, a3, &v7);
    *(_OWORD *)a4 = v7;
    if (v9 < 0)
      heap_Free(*(_QWORD **)(v10 + 8), v8);
  }
  else
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
  }
  if (v12 < 0)
    heap_Free(*(_QWORD **)(v13 + 8), v11);
}

void sub_214E80704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<LSTMNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _OWORD *a4@<X8>)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 __dst;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v8 = (_QWORD *)operator new(312);
  v9 = *a1;
  v16 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    __dst = *a2;
    v15 = *((_QWORD *)a2 + 2);
  }
  v10 = a3[1];
  v12 = *a3;
  v13 = (std::__shared_weak_count *)v10;
  if (v10)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  LSTMNeonFP16Engine::LSTMNeonFP16Engine(v8, v9, (char **)&__dst, &v12);
  std::shared_ptr<LSTMNeonFP16Engine>::shared_ptr[abi:ne180100]<LSTMNeonFP16Engine,ENTTS::Deleter<LSTMNeonFP16Engine>,ENTTS::Allocator<LSTMNeonFP16Engine>,void>(&v17, (uint64_t)v8);
  *a4 = v17;
  v17 = 0uLL;
  v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (SHIBYTE(v15) < 0)
    heap_Free(*(_QWORD **)(v16 + 8), __dst);
}

void sub_214E80850(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void create_memory_layer_engine(int a1@<W0>, uint64_t a2@<X2>, uint64_t *a3@<X3>, _QWORD *a4@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  char v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v14, "TC2 Memory");
  v13 = 0uLL;
  if ((a1 & 0xFFFFFFFB) != 0)
  {
    if (a1 == 1)
    {
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v10, "memory");
      ENTTS::make_shared<MemoryNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(&v17, &v10, a3, &v9);
      v7 = *((_QWORD *)&v9 + 1);
      v8 = v9;
      v13 = v9;
      if (v11 < 0)
        heap_Free(*(_QWORD **)(v12 + 8), v10);
    }
    else
    {
      v7 = 0;
      v8 = 0;
    }
    *a4 = v8;
    a4[1] = v7;
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
  }
  if (v15 < 0)
    heap_Free(*(_QWORD **)(v16 + 8), v14);
}

void sub_214E80964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;
  uint64_t v12;
  va_list va2;

  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v10 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<MemoryNeonFP16Engine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _OWORD *a4@<X8>)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 __dst;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v8 = (_QWORD *)operator new(312);
  v9 = *a1;
  v16 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    __dst = *a2;
    v15 = *((_QWORD *)a2 + 2);
  }
  v10 = a3[1];
  v12 = *a3;
  v13 = (std::__shared_weak_count *)v10;
  if (v10)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  MemoryNeonFP16Engine::MemoryNeonFP16Engine(v8, v9, (char **)&__dst, &v12);
  std::shared_ptr<MemoryNeonFP16Engine>::shared_ptr[abi:ne180100]<MemoryNeonFP16Engine,ENTTS::Deleter<MemoryNeonFP16Engine>,ENTTS::Allocator<MemoryNeonFP16Engine>,void>(&v17, (uint64_t)v8);
  *a4 = v17;
  v17 = 0uLL;
  v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (SHIBYTE(v15) < 0)
    heap_Free(*(_QWORD **)(v16 + 8), __dst);
}

void sub_214E80AB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *create_decoder_engine@<X0>(int a1@<W0>, ModelParameters *a2@<X1>, VisemeParameters *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t a6@<X8>)
{
  _QWORD *result;
  uint64_t *v12;
  uint64_t *v13;
  __int128 v14;
  __int128 v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;

  v21 = a4;
  result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v18, "TC2 Decoder");
  if ((a1 & 0xFFFFFFFB) != 0 && a1 == 1)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v15, "decoder");
    ENTTS::make_shared<DecoderNeonEngine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(&v21, &v15, a5, &v14);
    v12 = (uint64_t *)v14;
    *(_OWORD *)a6 = v14;
    v13 = v12;
    IDecoderEngine::set_model_parameters(v12, a2);
    result = IDecoderEngine::set_viseme_parameters(v13, a3);
    if (v16 < 0)
      result = heap_Free(*(_QWORD **)(v17 + 8), v15);
  }
  else
  {
    *(_QWORD *)a6 = 0;
    *(_QWORD *)(a6 + 8) = 0;
  }
  if (v19 < 0)
    return heap_Free(*(_QWORD **)(v20 + 8), v18);
  return result;
}

void sub_214E80BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<DecoderNeonEngine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 __dst;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v8 = operator new(656);
  v9 = *a1;
  v16 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    __dst = *a2;
    v15 = *((_QWORD *)a2 + 2);
  }
  v10 = a3[1];
  v12 = *a3;
  v13 = (std::__shared_weak_count *)v10;
  if (v10)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  DecoderNeonEngine::DecoderNeonEngine(v8, v9, (char **)&__dst, &v12);
  std::shared_ptr<DecoderNeonEngine>::shared_ptr[abi:ne180100]<DecoderNeonEngine,ENTTS::Deleter<DecoderNeonEngine>,ENTTS::Allocator<DecoderNeonEngine>,void>(&v17, v8);
  *a4 = v17;
  v17 = 0uLL;
  v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (SHIBYTE(v15) < 0)
    heap_Free(*(_QWORD **)(v16 + 8), __dst);
}

void sub_214E80D40(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *IDecoderEngine::set_model_parameters(uint64_t *this, ModelParameters *a2)
{
  uint64_t *v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v3 = this;
  v4 = *(_OWORD *)a2;
  v5 = *((_OWORD *)a2 + 1);
  v6 = *((_OWORD *)a2 + 2);
  *(_OWORD *)(this + 11) = *((_OWORD *)a2 + 3);
  *(_OWORD *)(this + 9) = v6;
  *(_OWORD *)(this + 7) = v5;
  *(_OWORD *)(this + 5) = v4;
  if (this + 5 != (uint64_t *)a2)
  {
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(this + 13, *((char **)a2 + 8), *((_QWORD *)a2 + 9), (uint64_t)(*((_QWORD *)a2 + 9) - *((_QWORD *)a2 + 8)) >> 2);
    std::vector<std::string,ENTTS::Allocator<std::string>>::__assign_with_size[abi:ne180100]<std::string*,std::string*>((uint64_t)(v3 + 17), *((std::string **)a2 + 12), *((__int128 **)a2 + 13), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)a2 + 13) - *((_QWORD *)a2 + 12)) >> 3));
    this = std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v3 + 21, *((char **)a2 + 16), *((_QWORD *)a2 + 17), (uint64_t)(*((_QWORD *)a2 + 17) - *((_QWORD *)a2 + 16)) >> 2);
  }
  v3[25] = *((_QWORD *)a2 + 20);
  return this;
}

uint64_t *IDecoderEngine::set_viseme_parameters(uint64_t *this, VisemeParameters *a2)
{
  uint64_t *v3;
  int v4;

  v3 = this;
  v4 = *((_DWORD *)a2 + 2);
  this[26] = *(_QWORD *)a2;
  *((_DWORD *)this + 54) = v4;
  if (this + 26 != (uint64_t *)a2)
  {
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(this + 28, *((char **)a2 + 2), *((_QWORD *)a2 + 3), (uint64_t)(*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 2);
    std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__assign_with_size[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>(v3 + 32, *((char ***)a2 + 6), *((_QWORD *)a2 + 7), (uint64_t)(*((_QWORD *)a2 + 7) - *((_QWORD *)a2 + 6)) >> 5);
    this = std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v3 + 36, *((char **)a2 + 10), *((_QWORD *)a2 + 11), (uint64_t)(*((_QWORD *)a2 + 11) - *((_QWORD *)a2 + 10)) >> 2);
  }
  v3[40] = *((_QWORD *)a2 + 14);
  return this;
}

void create_postnet_engine(int a1@<W0>, uint64_t a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X8>)
{
  __int128 v7;
  __int128 v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v11, "TC2 Postnet");
  if ((a1 & 0xFFFFFFFB) != 0 && a1 == 1)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v8, "postnet");
    ENTTS::make_shared<PostnetNeonEngine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(&v14, &v8, a3, &v7);
    *(_OWORD *)a4 = v7;
    if (v9 < 0)
      heap_Free(*(_QWORD **)(v10 + 8), v8);
  }
  else
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
  }
  if (v12 < 0)
    heap_Free(*(_QWORD **)(v13 + 8), v11);
}

void sub_214E80F58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<PostnetNeonEngine,void *&,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> &,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, __int128 *a2@<X1>, uint64_t *a3@<X2>, _OWORD *a4@<X8>)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  __int128 __dst;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v8 = (_QWORD *)operator new(312);
  v9 = *a1;
  v16 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    __dst = *a2;
    v15 = *((_QWORD *)a2 + 2);
  }
  v10 = a3[1];
  v12 = *a3;
  v13 = (std::__shared_weak_count *)v10;
  if (v10)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  PostnetNeonEngine::PostnetNeonEngine(v8, v9, (char **)&__dst, &v12);
  std::shared_ptr<PostnetNeonEngine>::shared_ptr[abi:ne180100]<PostnetNeonEngine,ENTTS::Deleter<PostnetNeonEngine>,ENTTS::Allocator<PostnetNeonEngine>,void>(&v17, (uint64_t)v8);
  *a4 = v17;
  v17 = 0uLL;
  v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (SHIBYTE(v15) < 0)
    heap_Free(*(_QWORD **)(v16 + 8), __dst);
}

void sub_214E810A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::vector<std::string,ENTTS::Allocator<std::string>>::__assign_with_size[abi:ne180100]<std::string*,std::string*>(uint64_t a1, std::string *__str, __int128 *a3, unint64_t a4)
{
  std::string *v8;
  unint64_t v9;
  unint64_t v10;
  std::string *v11;
  std::string *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v8 = *(std::string **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) < a4)
  {
    std::vector<std::string,ENTTS::Allocator<std::string>>::__vdeallocate((uint64_t *)a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v9 = 0x5555555555555556 * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3);
    if (v9 <= a4)
      v9 = a4;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) >= 0x555555555555555)
      v10 = 0xAAAAAAAAAAAAAAALL;
    else
      v10 = v9;
    std::vector<std::string,ENTTS::Allocator<std::string>>::__vallocate[abi:ne180100]((uint64_t *)a1, v10);
    v11 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::string>,std::string*,std::string*,std::string*>(a1 + 24, (__int128 *)__str, a3, *(std::string **)(a1 + 8));
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v8) >> 3) < a4)
  {
    v12 = (std::string *)((char *)__str + 8 * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v8) >> 3));
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::string *,std::string *,std::string *,0>(__str, v12, v8);
    v11 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::string>,std::string*,std::string*,std::string*>(a1 + 24, (__int128 *)v12, a3, *(std::string **)(a1 + 8));
LABEL_11:
    *(_QWORD *)(a1 + 8) = v11;
    return;
  }
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::string *,std::string *,std::string *,0>(__str, (std::string *)a3, v8);
  v14 = v13;
  v15 = *(_QWORD *)(a1 + 8);
  if (v15 != v13)
  {
    do
    {
      if (*(char *)(v15 - 1) < 0)
        operator delete(*(void **)(v15 - 24));
      v15 -= 24;
    }
    while (v15 != v14);
  }
  *(_QWORD *)(a1 + 8) = v14;
}

void sub_214E81244(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_214E8124C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t *std::vector<std::string,ENTTS::Allocator<std::string>>::__vdeallocate(uint64_t *result)
{
  uint64_t *v1;

  if (*result)
  {
    v1 = result;
    std::vector<std::string,ENTTS::Allocator<std::string>>::__clear[abi:ne180100](result);
    result = heap_Free(*(_QWORD **)(v1[3] + 8), *v1);
    *v1 = 0;
    v1[1] = 0;
    v1[2] = 0;
  }
  return result;
}

uint64_t std::vector<std::string,ENTTS::Allocator<std::string>>::__vallocate[abi:ne180100](uint64_t *a1, unint64_t a2)
{
  uint64_t result;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  result = ENTTS::Allocator<std::string>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = result + 24 * a2;
  return result;
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::string>,std::string*,std::string*,std::string*>(uint64_t a1, __int128 *a2, __int128 *a3, std::string *this)
{
  std::string *v4;
  __int128 *v6;
  __int128 v7;
  _QWORD v9[3];
  char v10;
  std::string *v11;
  std::string *v12;

  v4 = this;
  v11 = this;
  v12 = this;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
        v4 = v12;
      }
      else
      {
        v7 = *v6;
        v4->__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 2);
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      v6 = (__int128 *)((char *)v6 + 24);
      v12 = ++v4;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<ENTTS::Allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_214E81398(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<ENTTS::Allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<ENTTS::Allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<ENTTS::Allocator<std::string>,std::string*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<ENTTS::Allocator<std::string>,std::string*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 1) < 0)
      operator delete(*(void **)(v1 - 24));
    v1 -= 24;
  }
}

std::string *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::string *,std::string *,std::string *,0>(std::string *__str, std::string *a2, std::string *this)
{
  const std::string *v4;

  v4 = __str;
  if (__str != a2)
  {
    do
      std::string::operator=(this++, v4++);
    while (v4 != a2);
    return a2;
  }
  return (std::string *)v4;
}

uint64_t ENTTS::Allocator<std::string>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 24 * a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

uint64_t *std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__assign_with_size[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>(uint64_t *result, char **a2, uint64_t a3, unint64_t a4)
{
  char **v6;
  uint64_t *v7;
  char **v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v6 = a2;
  v7 = result;
  v8 = (char **)*result;
  if (a4 > (result[2] - *result) >> 5)
  {
    std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__vdeallocate(result);
    if (a4 >> 59)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v9 = v7[2] - *v7;
    v10 = v9 >> 4;
    if (v9 >> 4 <= a4)
      v10 = a4;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0)
      v11 = 0x7FFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__vallocate[abi:ne180100](v7, v11);
    result = (uint64_t *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)(v7 + 3), (uint64_t)v6, a3, v7[1]);
LABEL_15:
    v7[1] = (uint64_t)result;
    return result;
  }
  v12 = (uint64_t *)result[1];
  v13 = ((char *)v12 - (char *)v8) >> 5;
  if (v13 < a4)
  {
    v14 = (uint64_t)&a2[4 * v13];
    if (v12 != (uint64_t *)v8)
    {
      v15 = 32 * v13;
      do
      {
        std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=(v8, v6);
        v6 += 4;
        v8 += 4;
        v15 -= 32;
      }
      while (v15);
      v8 = (char **)v7[1];
    }
    result = (uint64_t *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)(v7 + 3), v14, a3, (uint64_t)v8);
    goto LABEL_15;
  }
  if (a2 == (char **)a3)
  {
    v16 = *result;
  }
  else
  {
    v16 = *result;
    do
    {
      result = (uint64_t *)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=(v8, v6);
      v6 += 4;
      v8 += 4;
      v16 += 32;
    }
    while (v6 != (char **)a3);
    v12 = (uint64_t *)v7[1];
  }
  while (v12 != (uint64_t *)v16)
  {
    v12 -= 4;
    result = std::__destroy_at[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,0>(v12);
  }
  v7[1] = v16;
  return result;
}

void sub_214E816CC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t *std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__vdeallocate(uint64_t *result)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;

  v1 = (uint64_t *)*result;
  if (*result)
  {
    v2 = result;
    v3 = (uint64_t *)result[1];
    v4 = *result;
    if (v3 != v1)
    {
      do
      {
        v3 -= 4;
        std::__destroy_at[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,0>(v3);
      }
      while (v3 != v1);
      v4 = *v2;
    }
    v2[1] = (uint64_t)v1;
    result = heap_Free(*(_QWORD **)(v2[3] + 8), v4);
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  return result;
}

uint64_t std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__vallocate[abi:ne180100](uint64_t *a1, unint64_t a2)
{
  uint64_t result;

  if (a2 >> 59)
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  result = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = result + 32 * a2;
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __int128 *v8;
  uint64_t v9;
  __int128 v10;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      v8 = (__int128 *)(a2 + v7);
      v9 = a4 + v7;
      *(_QWORD *)(a4 + v7 + 24) = CustomAllocator::mRsrc;
      if (*(char *)(a2 + v7 + 23) < 0)
      {
        std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external((_BYTE *)v9, *(void **)v8, *((_QWORD *)v8 + 1));
      }
      else
      {
        v10 = *v8;
        *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
        *(_OWORD *)v9 = v10;
      }
      v7 += 32;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_214E81824(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 32;
    do
    {
      std::__destroy_at[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,0>((uint64_t *)(v4 + v2));
      v2 -= 32;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *ConvnetNeonFP16Engine::ConvnetNeonFP16Engine(_QWORD *a1, uint64_t a2, char **a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  __int128 v12;
  void *v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *a1 = &unk_24D29C290;
  a1[1] = 0;
  v8 = a1 + 1;
  a1[2] = 0;
  v9 = a1 + 3;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)(a1 + 3));
  v19 = a2;
  ENTTS::make_shared<NeonConvNetManager,NeonTC2Container *,std::shared_ptr<IExternalServices> &>(&v19, a4, &v12);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)v8, &v12);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(*v8 + 32), a3);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v12, v9);
  *(_QWORD *)&v12 = &unk_24D29B388;
  v13 = &unk_24D29B3B0;
  v18 = &unk_24D29B3D8;
  v14 = &unk_24D29B578;
  if (v16 < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v18);
  NeonConvNetManager::ModelNpy(*v8, (uint64_t)v9);
  NeonConvNetManager::SetUp((_QWORD *)*v8);
  return a1;
}

void sub_214E819C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<NeonConvNetManager,NeonTC2Container *,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v6 = (_QWORD *)operator new(352);
  v7 = (uint64_t)v6;
  v8 = *a1;
  v9 = a2[1];
  v11 = *a2;
  v12 = (std::__shared_weak_count *)v9;
  if (v9)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  NeonConvNetManager::NeonConvNetManager(v6, v8, &v11);
  std::shared_ptr<NeonConvNetManager>::shared_ptr[abi:ne180100]<NeonConvNetManager,ENTTS::Deleter<NeonConvNetManager>,ENTTS::Allocator<NeonConvNetManager>,void>(&v13, v7);
  *a3 = v13;
  v13 = 0uLL;
  v10 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_214E81AC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<NeonConvNetManager>::shared_ptr[abi:ne180100]<NeonConvNetManager,ENTTS::Deleter<NeonConvNetManager>,ENTTS::Allocator<NeonConvNetManager>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BB10;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E81B64(void *a1)
{
  NeonConvNetManager *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    NeonConvNetManager::~NeonConvNetManager(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E81B80(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

NeonConvNetManager *std::__shared_ptr_pointer<NeonConvNetManager *,ENTTS::Deleter<NeonConvNetManager>,ENTTS::Allocator<NeonConvNetManager>>::__on_zero_shared(uint64_t a1)
{
  NeonConvNetManager *result;
  uint64_t v2;

  result = *(NeonConvNetManager **)(a1 + 24);
  if (result)
  {
    NeonConvNetManager::~NeonConvNetManager(result);
    return (NeonConvNetManager *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NeonConvNetManager *,ENTTS::Deleter<NeonConvNetManager>,ENTTS::Allocator<NeonConvNetManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<NeonConvNetManager *,ENTTS::Deleter<NeonConvNetManager>,ENTTS::Allocator<NeonConvNetManager>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *std::shared_ptr<ConvnetNeonFP16Engine>::shared_ptr[abi:ne180100]<ConvnetNeonFP16Engine,ENTTS::Deleter<ConvnetNeonFP16Engine>,ENTTS::Allocator<ConvnetNeonFP16Engine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BB70;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E81C98(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t v13;

  __cxa_begin_catch(a1);
  ENTTS::Deleter<ConvnetNeonFP16Engine>::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_214E81CB0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *ENTTS::Deleter<ConvnetNeonFP16Engine>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  if (a2)
  {
    *(_QWORD *)a2 = &unk_24D29C290;
    *(_QWORD *)(a2 + 24) = &unk_24D29B388;
    *(_QWORD *)(a2 + 160) = &unk_24D29B3D8;
    v3 = a2 + 160;
    *(_QWORD *)(a2 + 40) = &unk_24D29B3B0;
    *(_QWORD *)(a2 + 48) = &unk_24D29B578;
    if (*(char *)(a2 + 135) < 0)
      heap_Free(*(_QWORD **)(*(_QWORD *)(a2 + 136) + 8), *(_QWORD *)(a2 + 112));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v3);
    std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](a2 + 8);
    return operator delete(a2);
  }
  return result;
}

_QWORD *std::__shared_ptr_pointer<ConvnetNeonFP16Engine *,ENTTS::Deleter<ConvnetNeonFP16Engine>,ENTTS::Allocator<ConvnetNeonFP16Engine>>::__on_zero_shared(uint64_t a1)
{
  return ENTTS::Deleter<ConvnetNeonFP16Engine>::operator()(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<ConvnetNeonFP16Engine *,ENTTS::Deleter<ConvnetNeonFP16Engine>,ENTTS::Allocator<ConvnetNeonFP16Engine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<ConvnetNeonFP16Engine *,ENTTS::Deleter<ConvnetNeonFP16Engine>,ENTTS::Allocator<ConvnetNeonFP16Engine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *LSTMNeonFP16Engine::LSTMNeonFP16Engine(_QWORD *a1, uint64_t a2, char **a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  __int128 v12;
  void *v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *a1 = &unk_24D29BBD0;
  a1[1] = 0;
  v8 = a1 + 1;
  a1[2] = 0;
  v9 = a1 + 3;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)(a1 + 3));
  v19 = a2;
  ENTTS::make_shared<NeonLSTMManager,NeonTC2Container *,std::shared_ptr<IExternalServices> &>(&v19, a4, &v12);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)v8, &v12);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(*v8 + 32), a3);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v12, v9);
  *(_QWORD *)&v12 = &unk_24D29B388;
  v13 = &unk_24D29B3B0;
  v18 = &unk_24D29B3D8;
  v14 = &unk_24D29B578;
  if (v16 < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v18);
  NeonLSTMManager::ModelNpy(*v8, (uint64_t)v9);
  NeonLSTMManager::SetUp((_QWORD *)*v8);
  return a1;
}

void sub_214E81F90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<NeonLSTMManager,NeonTC2Container *,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v6 = (_QWORD *)operator new(296);
  v7 = (uint64_t)v6;
  v8 = *a1;
  v9 = a2[1];
  v11 = *a2;
  v12 = (std::__shared_weak_count *)v9;
  if (v9)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  NeonLSTMManager::NeonLSTMManager(v6, v8, &v11);
  std::shared_ptr<NeonLSTMManager>::shared_ptr[abi:ne180100]<NeonLSTMManager,ENTTS::Deleter<NeonLSTMManager>,ENTTS::Allocator<NeonLSTMManager>,void>(&v13, v7);
  *a3 = v13;
  v13 = 0uLL;
  v10 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_214E82090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void LSTMNeonFP16Engine::do_inference(uint64_t a1, int **a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  NeonLSTMManager::do_inference(*(_QWORD *)(a1 + 8), a2, a3, a4, a5);
}

_QWORD *std::shared_ptr<NeonLSTMManager>::shared_ptr[abi:ne180100]<NeonLSTMManager,ENTTS::Deleter<NeonLSTMManager>,ENTTS::Allocator<NeonLSTMManager>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BC10;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E8213C(void *a1)
{
  NeonLSTMManager *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    NeonLSTMManager::~NeonLSTMManager(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E82158(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

NeonLSTMManager *std::__shared_ptr_pointer<NeonLSTMManager *,ENTTS::Deleter<NeonLSTMManager>,ENTTS::Allocator<NeonLSTMManager>>::__on_zero_shared(uint64_t a1)
{
  NeonLSTMManager *result;
  uint64_t v2;

  result = *(NeonLSTMManager **)(a1 + 24);
  if (result)
  {
    NeonLSTMManager::~NeonLSTMManager(result);
    return (NeonLSTMManager *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NeonLSTMManager *,ENTTS::Deleter<NeonLSTMManager>,ENTTS::Allocator<NeonLSTMManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<NeonLSTMManager *,ENTTS::Deleter<NeonLSTMManager>,ENTTS::Allocator<NeonLSTMManager>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *std::shared_ptr<LSTMNeonFP16Engine>::shared_ptr[abi:ne180100]<LSTMNeonFP16Engine,ENTTS::Deleter<LSTMNeonFP16Engine>,ENTTS::Allocator<LSTMNeonFP16Engine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BC70;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E82270(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t v13;

  __cxa_begin_catch(a1);
  ENTTS::Deleter<LSTMNeonFP16Engine>::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_214E82288(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *ENTTS::Deleter<LSTMNeonFP16Engine>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  if (a2)
  {
    *(_QWORD *)a2 = &unk_24D29BBD0;
    *(_QWORD *)(a2 + 24) = &unk_24D29B388;
    *(_QWORD *)(a2 + 160) = &unk_24D29B3D8;
    v3 = a2 + 160;
    *(_QWORD *)(a2 + 40) = &unk_24D29B3B0;
    *(_QWORD *)(a2 + 48) = &unk_24D29B578;
    if (*(char *)(a2 + 135) < 0)
      heap_Free(*(_QWORD **)(*(_QWORD *)(a2 + 136) + 8), *(_QWORD *)(a2 + 112));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v3);
    std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](a2 + 8);
    return operator delete(a2);
  }
  return result;
}

_QWORD *std::__shared_ptr_pointer<LSTMNeonFP16Engine *,ENTTS::Deleter<LSTMNeonFP16Engine>,ENTTS::Allocator<LSTMNeonFP16Engine>>::__on_zero_shared(uint64_t a1)
{
  return ENTTS::Deleter<LSTMNeonFP16Engine>::operator()(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<LSTMNeonFP16Engine *,ENTTS::Deleter<LSTMNeonFP16Engine>,ENTTS::Allocator<LSTMNeonFP16Engine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<LSTMNeonFP16Engine *,ENTTS::Deleter<LSTMNeonFP16Engine>,ENTTS::Allocator<LSTMNeonFP16Engine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *MemoryNeonFP16Engine::MemoryNeonFP16Engine(_QWORD *a1, uint64_t a2, char **a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  __int128 v12;
  void *v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *a1 = &unk_24D29BCD0;
  a1[1] = 0;
  v8 = a1 + 1;
  a1[2] = 0;
  v9 = a1 + 3;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)(a1 + 3));
  v19 = a2;
  ENTTS::make_shared<NeonMemoryManager,NeonTC2Container *,std::shared_ptr<IExternalServices> &>(&v19, a4, &v12);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)v8, &v12);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(*v8 + 32), a3);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v12, v9);
  *(_QWORD *)&v12 = &unk_24D29B388;
  v13 = &unk_24D29B3B0;
  v18 = &unk_24D29B3D8;
  v14 = &unk_24D29B578;
  if (v16 < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v18);
  NeonMemoryManager::ModelNpy(*v8, (uint64_t)v9);
  NeonMemoryManager::SetUp((_QWORD *)*v8);
  return a1;
}

void sub_214E82568(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<NeonMemoryManager,NeonTC2Container *,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v6 = (_QWORD *)operator new(224);
  v7 = (uint64_t)v6;
  v8 = *a1;
  v9 = a2[1];
  v11 = *a2;
  v12 = (std::__shared_weak_count *)v9;
  if (v9)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  NeonMemoryManager::NeonMemoryManager(v6, v8, &v11);
  std::shared_ptr<NeonMemoryManager>::shared_ptr[abi:ne180100]<NeonMemoryManager,ENTTS::Deleter<NeonMemoryManager>,ENTTS::Allocator<NeonMemoryManager>,void>(&v13, v7);
  *a3 = v13;
  v13 = 0uLL;
  v10 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_214E82668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void MemoryNeonFP16Engine::do_inference(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  NeonMemoryManager::do_inference(*(_QWORD *)(a1 + 8), a2, a3, a4, a5);
}

_QWORD *std::shared_ptr<NeonMemoryManager>::shared_ptr[abi:ne180100]<NeonMemoryManager,ENTTS::Deleter<NeonMemoryManager>,ENTTS::Allocator<NeonMemoryManager>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BD10;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E82714(void *a1)
{
  NeonMemoryManager *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    NeonMemoryManager::~NeonMemoryManager(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E82730(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

NeonMemoryManager *std::__shared_ptr_pointer<NeonMemoryManager *,ENTTS::Deleter<NeonMemoryManager>,ENTTS::Allocator<NeonMemoryManager>>::__on_zero_shared(uint64_t a1)
{
  NeonMemoryManager *result;
  uint64_t v2;

  result = *(NeonMemoryManager **)(a1 + 24);
  if (result)
  {
    NeonMemoryManager::~NeonMemoryManager(result);
    return (NeonMemoryManager *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NeonMemoryManager *,ENTTS::Deleter<NeonMemoryManager>,ENTTS::Allocator<NeonMemoryManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<NeonMemoryManager *,ENTTS::Deleter<NeonMemoryManager>,ENTTS::Allocator<NeonMemoryManager>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *std::shared_ptr<MemoryNeonFP16Engine>::shared_ptr[abi:ne180100]<MemoryNeonFP16Engine,ENTTS::Deleter<MemoryNeonFP16Engine>,ENTTS::Allocator<MemoryNeonFP16Engine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BD70;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E82848(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t v13;

  __cxa_begin_catch(a1);
  ENTTS::Deleter<MemoryNeonFP16Engine>::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_214E82860(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *ENTTS::Deleter<MemoryNeonFP16Engine>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  if (a2)
  {
    *(_QWORD *)a2 = &unk_24D29BCD0;
    *(_QWORD *)(a2 + 24) = &unk_24D29B388;
    *(_QWORD *)(a2 + 160) = &unk_24D29B3D8;
    v3 = a2 + 160;
    *(_QWORD *)(a2 + 40) = &unk_24D29B3B0;
    *(_QWORD *)(a2 + 48) = &unk_24D29B578;
    if (*(char *)(a2 + 135) < 0)
      heap_Free(*(_QWORD **)(*(_QWORD *)(a2 + 136) + 8), *(_QWORD *)(a2 + 112));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v3);
    std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](a2 + 8);
    return operator delete(a2);
  }
  return result;
}

_QWORD *std::__shared_ptr_pointer<MemoryNeonFP16Engine *,ENTTS::Deleter<MemoryNeonFP16Engine>,ENTTS::Allocator<MemoryNeonFP16Engine>>::__on_zero_shared(uint64_t a1)
{
  return ENTTS::Deleter<MemoryNeonFP16Engine>::operator()(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<MemoryNeonFP16Engine *,ENTTS::Deleter<MemoryNeonFP16Engine>,ENTTS::Allocator<MemoryNeonFP16Engine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<MemoryNeonFP16Engine *,ENTTS::Deleter<MemoryNeonFP16Engine>,ENTTS::Allocator<MemoryNeonFP16Engine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

uint64_t DecoderNeonEngine::DecoderNeonEngine(uint64_t a1, uint64_t a2, char **a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  __int128 v12;
  void *v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *(_QWORD *)a1 = &unk_24D29BDD0;
  *(_DWORD *)(a1 + 8) = 512;
  *(_QWORD *)(a1 + 16) = 256;
  *(_DWORD *)(a1 + 24) = 1050253722;
  *(_WORD *)(a1 + 28) = 256;
  *(_DWORD *)(a1 + 32) = 0;
  ModelParameters::ModelParameters((ModelParameters *)(a1 + 40));
  *(_DWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 212) = 0x600000049;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  v8 = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = v8;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = v8;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 312) = v8;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)a1 = &unk_24D29C2D0;
  *(_DWORD *)(a1 + 328) = 0;
  v9 = (uint64_t *)(a1 + 336);
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100](a1 + 352);
  *(_OWORD *)(a1 + 640) = 0u;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]((_QWORD *)(a1 + 640), a4);
  v19 = a2;
  ENTTS::make_shared<NeonDecoderManager,NeonTC2Container *,std::shared_ptr<IExternalServices> &>(&v19, (uint64_t *)(a1 + 640), &v12);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>(a1 + 336, &v12);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(*v9 + 32), a3);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v12, (uint64_t *)(a1 + 352));
  *(_QWORD *)&v12 = &unk_24D29B388;
  v13 = &unk_24D29B3B0;
  v18 = &unk_24D29B3D8;
  v14 = &unk_24D29B578;
  if (v16 < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v18);
  NeonDecoderManager::ModelNpy(*v9, a1 + 352);
  NeonDecoderManager::SetUp((int *)*v9);
  return a1;
}

void sub_214E82BCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  IDecoderEngine *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v5);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v4);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v3);
  IDecoderEngine::~IDecoderEngine(v2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<NeonDecoderManager,NeonTC2Container *,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v6 = operator new(592);
  v7 = v6;
  v8 = *a1;
  v9 = a2[1];
  v11 = *a2;
  v12 = (std::__shared_weak_count *)v9;
  if (v9)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  NeonDecoderManager::NeonDecoderManager(v6, v8, &v11);
  std::shared_ptr<NeonDecoderManager>::shared_ptr[abi:ne180100]<NeonDecoderManager,ENTTS::Deleter<NeonDecoderManager>,ENTTS::Allocator<NeonDecoderManager>,void>(&v13, v7);
  *a3 = v13;
  v13 = 0uLL;
  v10 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_214E82CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void IDecoderEngine::~IDecoderEngine(IDecoderEngine *this)
{
  uint64_t *v2;
  uint64_t *v3;

  *(_QWORD *)this = &unk_24D29BDD0;
  v2 = (uint64_t *)((char *)this + 224);
  v3 = (uint64_t *)((char *)this + 288);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (uint64_t *)((char *)this + 256);
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = v2;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (uint64_t *)((char *)this + 168);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (uint64_t *)((char *)this + 136);
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (uint64_t *)((char *)this + 104);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void ModelParameters::ModelParameters(ModelParameters *this)
{
  uint64_t v1;

  *(_OWORD *)this = xmmword_214FBEFA0;
  *((_OWORD *)this + 1) = xmmword_214FBEFB0;
  *((_OWORD *)this + 2) = xmmword_214FBEFC0;
  *((_QWORD *)this + 6) = 500;
  *((_QWORD *)this + 7) = 0x600000049;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  v1 = CustomAllocator::mRsrc;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = v1;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = v1;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = v1;
  *((_QWORD *)this + 20) = 0;
}

_QWORD *std::shared_ptr<NeonDecoderManager>::shared_ptr[abi:ne180100]<NeonDecoderManager,ENTTS::Deleter<NeonDecoderManager>,ENTTS::Allocator<NeonDecoderManager>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BE10;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E82E78(void *a1)
{
  NeonDecoderManager *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    NeonDecoderManager::~NeonDecoderManager(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E82E94(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

NeonDecoderManager *std::__shared_ptr_pointer<NeonDecoderManager *,ENTTS::Deleter<NeonDecoderManager>,ENTTS::Allocator<NeonDecoderManager>>::__on_zero_shared(uint64_t a1)
{
  NeonDecoderManager *result;
  uint64_t v2;

  result = *(NeonDecoderManager **)(a1 + 24);
  if (result)
  {
    NeonDecoderManager::~NeonDecoderManager(result);
    return (NeonDecoderManager *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NeonDecoderManager *,ENTTS::Deleter<NeonDecoderManager>,ENTTS::Allocator<NeonDecoderManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<NeonDecoderManager *,ENTTS::Deleter<NeonDecoderManager>,ENTTS::Allocator<NeonDecoderManager>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *std::shared_ptr<DecoderNeonEngine>::shared_ptr[abi:ne180100]<DecoderNeonEngine,ENTTS::Deleter<DecoderNeonEngine>,ENTTS::Allocator<DecoderNeonEngine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BE70;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E82FAC(void *a1)
{
  DecoderNeonEngine *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    DecoderNeonEngine::~DecoderNeonEngine(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E82FC8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

DecoderNeonEngine *std::__shared_ptr_pointer<DecoderNeonEngine *,ENTTS::Deleter<DecoderNeonEngine>,ENTTS::Allocator<DecoderNeonEngine>>::__on_zero_shared(uint64_t a1)
{
  DecoderNeonEngine *result;
  uint64_t v2;

  result = *(DecoderNeonEngine **)(a1 + 24);
  if (result)
  {
    DecoderNeonEngine::~DecoderNeonEngine(result);
    return (DecoderNeonEngine *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<DecoderNeonEngine *,ENTTS::Deleter<DecoderNeonEngine>,ENTTS::Allocator<DecoderNeonEngine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<DecoderNeonEngine *,ENTTS::Deleter<DecoderNeonEngine>,ENTTS::Allocator<DecoderNeonEngine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

void DecoderNeonEngine::~DecoderNeonEngine(DecoderNeonEngine *this)
{
  uint64_t *v2;

  *(_QWORD *)this = &unk_24D29C2D0;
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 640);
  *((_QWORD *)this + 44) = &unk_24D29B388;
  *((_QWORD *)this + 61) = &unk_24D29B3D8;
  *((_QWORD *)this + 46) = &unk_24D29B3B0;
  *((_QWORD *)this + 47) = &unk_24D29B578;
  if (*((char *)this + 463) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 58) + 8), *((_QWORD *)this + 55));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8]((char *)this + 488);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 336);
  *(_QWORD *)this = &unk_24D29BDD0;
  v2 = (uint64_t *)((char *)this + 288);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (uint64_t *)((char *)this + 256);
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (uint64_t *)((char *)this + 224);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (uint64_t *)((char *)this + 168);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (uint64_t *)((char *)this + 136);
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (uint64_t *)((char *)this + 104);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

_QWORD *PostnetNeonEngine::PostnetNeonEngine(_QWORD *a1, uint64_t a2, char **a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  __int128 v12;
  void *v13;
  void *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *a1 = &unk_24D29BED0;
  a1[1] = 0;
  v8 = a1 + 1;
  a1[2] = 0;
  v9 = a1 + 3;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)(a1 + 3));
  v19 = a2;
  ENTTS::make_shared<NeonPostNetManager,NeonTC2Container *,std::shared_ptr<IExternalServices> &>(&v19, a4, &v12);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)v8, &v12);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(*v8 + 32), a3);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v12, v9);
  *(_QWORD *)&v12 = &unk_24D29B388;
  v13 = &unk_24D29B3B0;
  v18 = &unk_24D29B3D8;
  v14 = &unk_24D29B578;
  if (v16 < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v18);
  NeonPostNetManager::ModelNpy(*v8, (uint64_t)v9);
  NeonPostNetManager::SetUp(*v8);
  return a1;
}

void sub_214E83314(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void ENTTS::make_shared<NeonPostNetManager,NeonTC2Container *,std::shared_ptr<IExternalServices> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  __int128 v13;

  v6 = operator new(480);
  v7 = v6;
  v8 = *a1;
  v9 = a2[1];
  v11 = *a2;
  v12 = (std::__shared_weak_count *)v9;
  if (v9)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  NeonPostNetManager::NeonPostNetManager(v6, v8, &v11);
  std::shared_ptr<NeonPostNetManager>::shared_ptr[abi:ne180100]<NeonPostNetManager,ENTTS::Deleter<NeonPostNetManager>,ENTTS::Allocator<NeonPostNetManager>,void>(&v13, v7);
  *a3 = v13;
  v13 = 0uLL;
  v10 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_214E83414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void PostnetNeonEngine::do_inference(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  NeonPostNetManager::do_inference(*(_QWORD *)(a1 + 8), a2, a3, a4, a5);
}

_QWORD *std::shared_ptr<NeonPostNetManager>::shared_ptr[abi:ne180100]<NeonPostNetManager,ENTTS::Deleter<NeonPostNetManager>,ENTTS::Allocator<NeonPostNetManager>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BF10;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E834C0(void *a1)
{
  NeonPostNetManager *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    NeonPostNetManager::~NeonPostNetManager(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E834DC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

NeonPostNetManager *std::__shared_ptr_pointer<NeonPostNetManager *,ENTTS::Deleter<NeonPostNetManager>,ENTTS::Allocator<NeonPostNetManager>>::__on_zero_shared(uint64_t a1)
{
  NeonPostNetManager *result;
  uint64_t v2;

  result = *(NeonPostNetManager **)(a1 + 24);
  if (result)
  {
    NeonPostNetManager::~NeonPostNetManager(result);
    return (NeonPostNetManager *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NeonPostNetManager *,ENTTS::Deleter<NeonPostNetManager>,ENTTS::Allocator<NeonPostNetManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<NeonPostNetManager *,ENTTS::Deleter<NeonPostNetManager>,ENTTS::Allocator<NeonPostNetManager>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *std::shared_ptr<PostnetNeonEngine>::shared_ptr[abi:ne180100]<PostnetNeonEngine,ENTTS::Deleter<PostnetNeonEngine>,ENTTS::Allocator<PostnetNeonEngine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29BF70;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E835F4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  uint64_t v13;

  __cxa_begin_catch(a1);
  ENTTS::Deleter<PostnetNeonEngine>::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_214E8360C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *ENTTS::Deleter<PostnetNeonEngine>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  if (a2)
  {
    *(_QWORD *)a2 = &unk_24D29BED0;
    *(_QWORD *)(a2 + 24) = &unk_24D29B388;
    *(_QWORD *)(a2 + 160) = &unk_24D29B3D8;
    v3 = a2 + 160;
    *(_QWORD *)(a2 + 40) = &unk_24D29B3B0;
    *(_QWORD *)(a2 + 48) = &unk_24D29B578;
    if (*(char *)(a2 + 135) < 0)
      heap_Free(*(_QWORD **)(*(_QWORD *)(a2 + 136) + 8), *(_QWORD *)(a2 + 112));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v3);
    std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](a2 + 8);
    return operator delete(a2);
  }
  return result;
}

_QWORD *std::__shared_ptr_pointer<PostnetNeonEngine *,ENTTS::Deleter<PostnetNeonEngine>,ENTTS::Allocator<PostnetNeonEngine>>::__on_zero_shared(uint64_t a1)
{
  return ENTTS::Deleter<PostnetNeonEngine>::operator()(a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<PostnetNeonEngine *,ENTTS::Deleter<PostnetNeonEngine>,ENTTS::Allocator<PostnetNeonEngine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<PostnetNeonEngine *,ENTTS::Deleter<PostnetNeonEngine>,ENTTS::Allocator<PostnetNeonEngine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

uint64_t TC2Engine::TC2Engine(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  uint64_t (***v13)(_QWORD, uint64_t *);
  int v14;
  uint64_t i;
  uint64_t (***v16)(_QWORD, uint64_t *);
  int v17;
  uint64_t j;
  uint64_t (***v19)(_QWORD, uint64_t *);
  int v20;
  uint64_t k;
  uint64_t (***v22)(_QWORD, uint64_t *);
  int v23;
  uint64_t m;
  uint64_t (***v25)(_QWORD, uint64_t *);
  int v26;
  uint64_t n;
  uint64_t (***v28)(_QWORD, uint64_t *);
  int v29;
  uint64_t (***v30)(_QWORD, uint64_t *);
  uint64_t ii;
  uint64_t (***v32)(_QWORD, uint64_t *);
  uint64_t jj;
  uint64_t (***v34)(_QWORD, uint64_t *);
  uint64_t kk;
  uint64_t (***v36)(_QWORD, uint64_t *);
  uint64_t mm;
  uint64_t (***v38)(_QWORD, uint64_t *);
  uint64_t nn;
  uint64_t v40;
  std::__shared_weak_count *v41;
  uint64_t v44;
  std::__shared_weak_count *v45;
  uint64_t v46[2];
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const void *v53[2];
  char v54;
  uint64_t v55;
  uint64_t v56[2];
  char v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const void *v63[2];
  char v64;
  uint64_t v65;
  uint64_t v66[2];
  char v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  const void *v73[2];
  char v74;
  uint64_t v75;
  uint64_t v76[2];
  char v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  const void *v83[2];
  char v84;
  uint64_t v85;
  uint64_t v86[2];
  char v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  const void *v93[2];
  char v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100[2];
  char v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  const void *v107[2];
  char v108;
  uint64_t v109;
  uint64_t v110[2];
  char v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  const void *v117[2];
  char v118;
  uint64_t v119;
  uint64_t v120[2];
  char v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  const void *v127[2];
  char v128;
  uint64_t v129;
  uint64_t v130[2];
  char v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  const void *v137[2];
  char v138;
  uint64_t v139;
  uint64_t v140[2];
  char v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  const void *v147[2];
  char v148;
  uint64_t v149;
  uint64_t (***v150)(_QWORD, uint64_t *);
  std::__shared_weak_count *v151;
  uint64_t (***v152)(_QWORD, uint64_t *);
  std::__shared_weak_count *v153;
  uint64_t *v154;
  char v155;
  uint64_t v156;
  int v157;
  __int128 v158;
  _QWORD v159[2];
  __int128 v160;
  _QWORD v161[2];
  __int128 v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;

  v165 = *MEMORY[0x24BDAC8D0];
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_24D29BFD0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 96) = 0;
  v5 = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 192) = v5;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_QWORD *)(a1 + 224) = v5;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = v5;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = v5;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 320) = v5;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_QWORD *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 352) = v5;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_QWORD *)(a1 + 376) = 0;
  *(_QWORD *)(a1 + 384) = v5;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 416) = v5;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 448) = v5;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_QWORD *)(a1 + 472) = 0;
  *(_QWORD *)(a1 + 480) = v5;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_QWORD *)(a1 + 504) = 0;
  *(_QWORD *)(a1 + 512) = v5;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_QWORD *)(a1 + 536) = 0;
  *(_QWORD *)(a1 + 544) = v5;
  *(_WORD *)(a1 + 552) = 1;
  *(_BYTE *)(a1 + 554) = 1;
  v6 = a1 + 592;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  v7 = (std::__shared_weak_count *)a3[1];
  v152 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
  v153 = v7;
  if (v7)
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  ModelParameters::ModelParameters(v6, &v152);
  v8 = (_QWORD *)(a1 + 776);
  v9 = v153;
  if (v153 && !atomic_fetch_add(&v153->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  *(_QWORD *)(a1 + 760) = 0x4900000000;
  *(_DWORD *)(a1 + 768) = 6;
  *(_QWORD *)(a1 + 784) = 0;
  *(_QWORD *)(a1 + 792) = 0;
  *v8 = 0;
  v10 = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 800) = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 808) = 0;
  *(_QWORD *)(a1 + 816) = 0;
  *(_QWORD *)(a1 + 824) = 0;
  *(_QWORD *)(a1 + 832) = v10;
  *(_QWORD *)(a1 + 840) = 0;
  *(_QWORD *)(a1 + 848) = 0;
  *(_QWORD *)(a1 + 856) = 0;
  *(_QWORD *)(a1 + 864) = v10;
  *(_QWORD *)(a1 + 880) = 0;
  *(_QWORD *)(a1 + 872) = 0;
  *(_QWORD *)(a1 + 888) = 0;
  *(_BYTE *)(a1 + 8) = 1;
  v11 = (std::__shared_weak_count *)a3[1];
  v150 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
  v151 = v11;
  if (v11)
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  VisemeParameters::VisemeParameters((uint64_t)&v156);
  *(_QWORD *)(a1 + 760) = v156;
  *(_DWORD *)(a1 + 768) = v157;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__vdeallocate((uint64_t *)(a1 + 776));
  *(_OWORD *)v8 = v158;
  *(_QWORD *)(a1 + 792) = v159[0];
  v159[0] = 0;
  v158 = 0uLL;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__vdeallocate((uint64_t *)(a1 + 808));
  *(_OWORD *)(a1 + 808) = v160;
  *(_QWORD *)(a1 + 824) = v161[0];
  v161[0] = 0;
  v160 = 0uLL;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__vdeallocate((uint64_t *)(a1 + 840));
  *(_OWORD *)(a1 + 840) = v162;
  v12 = v164;
  *(_QWORD *)(a1 + 856) = v163;
  v163 = 0;
  v162 = 0uLL;
  *(_QWORD *)(a1 + 872) = v12;
  v154 = (uint64_t *)&v162;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v154);
  v154 = (uint64_t *)&v160;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
  v154 = (uint64_t *)&v158;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v154);
  if (v151 && !atomic_fetch_add(&v151->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v151->__on_zero_shared)(v151);
    std::__shared_weak_count::__release_weak(v151);
  }
  v13 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "TC2");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v159, "convnet_engine");
  v144 = 0;
  v143 = 0;
  v145 = 0;
  v146 = CustomAllocator::mRsrc;
  v154 = &v143;
  v155 = 0;
  v143 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v146, 2);
  v144 = v143;
  v145 = v143 + 64;
  v144 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v146, (uint64_t)&v156, (uint64_t)v161, v143);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v140, "\"onnx\"");
  ((void (*)(const void **__return_ptr, uint64_t (***)(_QWORD, uint64_t *), uint64_t *, uint64_t *))(*v13)[1])(v147, v13, &v143, v140);
  v14 = from_string_to_engine_type(v147);
  if (v148 < 0)
    heap_Free(*(_QWORD **)(v149 + 8), (uint64_t)v147[0]);
  if (v141 < 0)
    heap_Free(*(_QWORD **)(v142 + 8), v140[0]);
  v154 = &v143;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
  for (i = 0; i != -8; i -= 4)
  {
    if (*((char *)&v160 + i * 8 + 7) < 0)
      heap_Free(*(_QWORD **)(v161[i - 1] + 8), v159[i]);
  }
  v16 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "TC2");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v159, "lstm_engine");
  v134 = 0;
  v133 = 0;
  v135 = 0;
  v136 = CustomAllocator::mRsrc;
  v154 = &v133;
  v155 = 0;
  v133 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v136, 2);
  v134 = v133;
  v135 = v133 + 64;
  v134 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v136, (uint64_t)&v156, (uint64_t)v161, v133);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v130, "\"onnx\"");
  ((void (*)(const void **__return_ptr, uint64_t (***)(_QWORD, uint64_t *), uint64_t *, uint64_t *))(*v16)[1])(v137, v16, &v133, v130);
  v17 = from_string_to_engine_type(v137);
  if (v138 < 0)
    heap_Free(*(_QWORD **)(v139 + 8), (uint64_t)v137[0]);
  if (v131 < 0)
    heap_Free(*(_QWORD **)(v132 + 8), v130[0]);
  v154 = &v133;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
  for (j = 0; j != -8; j -= 4)
  {
    if (*((char *)&v160 + j * 8 + 7) < 0)
      heap_Free(*(_QWORD **)(v161[j - 1] + 8), v159[j]);
  }
  v19 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "TC2");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v159, "memory_engine");
  v124 = 0;
  v123 = 0;
  v125 = 0;
  v126 = CustomAllocator::mRsrc;
  v154 = &v123;
  v155 = 0;
  v123 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v126, 2);
  v124 = v123;
  v125 = v123 + 64;
  v124 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v126, (uint64_t)&v156, (uint64_t)v161, v123);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v120, "\"onnx\"");
  ((void (*)(const void **__return_ptr, uint64_t (***)(_QWORD, uint64_t *), uint64_t *, uint64_t *))(*v19)[1])(v127, v19, &v123, v120);
  v20 = from_string_to_engine_type(v127);
  if (v128 < 0)
    heap_Free(*(_QWORD **)(v129 + 8), (uint64_t)v127[0]);
  if (v121 < 0)
    heap_Free(*(_QWORD **)(v122 + 8), v120[0]);
  v154 = &v123;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
  for (k = 0; k != -8; k -= 4)
  {
    if (*((char *)&v160 + k * 8 + 7) < 0)
      heap_Free(*(_QWORD **)(v161[k - 1] + 8), v159[k]);
  }
  v22 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "TC2");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v159, "decoder_engine");
  v114 = 0;
  v113 = 0;
  v115 = 0;
  v116 = CustomAllocator::mRsrc;
  v154 = &v113;
  v155 = 0;
  v113 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v116, 2);
  v114 = v113;
  v115 = v113 + 64;
  v114 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v116, (uint64_t)&v156, (uint64_t)v161, v113);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v110, "\"onnx\"");
  ((void (*)(const void **__return_ptr, uint64_t (***)(_QWORD, uint64_t *), uint64_t *, uint64_t *))(*v22)[1])(v117, v22, &v113, v110);
  v23 = from_string_to_engine_type(v117);
  if (v118 < 0)
    heap_Free(*(_QWORD **)(v119 + 8), (uint64_t)v117[0]);
  if (v111 < 0)
    heap_Free(*(_QWORD **)(v112 + 8), v110[0]);
  v154 = &v113;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
  for (m = 0; m != -8; m -= 4)
  {
    if (*((char *)&v160 + m * 8 + 7) < 0)
      heap_Free(*(_QWORD **)(v161[m - 1] + 8), v159[m]);
  }
  v25 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "TC2");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v159, "postnet_engine");
  v104 = 0;
  v103 = 0;
  v105 = 0;
  v106 = CustomAllocator::mRsrc;
  v154 = &v103;
  v155 = 0;
  v103 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v106, 2);
  v104 = v103;
  v105 = v103 + 64;
  v104 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v106, (uint64_t)&v156, (uint64_t)v161, v103);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v100, "\"onnx\"");
  ((void (*)(const void **__return_ptr, uint64_t (***)(_QWORD, uint64_t *), uint64_t *, uint64_t *))(*v25)[1])(v107, v25, &v103, v100);
  v26 = from_string_to_engine_type(v107);
  if (v108 < 0)
    heap_Free(*(_QWORD **)(v109 + 8), (uint64_t)v107[0]);
  if (v101 < 0)
    heap_Free(*(_QWORD **)(v102 + 8), v100[0]);
  v154 = &v103;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
  for (n = 0; n != -8; n -= 4)
  {
    if (*((char *)&v160 + n * 8 + 7) < 0)
      heap_Free(*(_QWORD **)(v161[n - 1] + 8), v159[n]);
  }
  v28 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "Token_converter");
  v97 = 0;
  v96 = 0;
  v98 = 0;
  v99 = CustomAllocator::mRsrc;
  v154 = &v96;
  v155 = 0;
  v96 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v99, 1);
  v97 = v96;
  v98 = v96 + 32;
  v97 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v99, (uint64_t)&v156, (uint64_t)v159, v96);
  v29 = (**v28)(v28, &v96);
  v154 = &v96;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
  if (SBYTE7(v158) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)&v158 + 1) + 8), v156);
  if (v29)
  {
    v30 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "Token_converter");
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v159, "convnet_engine");
    v90 = 0;
    v89 = 0;
    v91 = 0;
    v92 = CustomAllocator::mRsrc;
    v154 = &v89;
    v155 = 0;
    v89 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v92, 2);
    v90 = v89;
    v91 = v89 + 64;
    v90 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v92, (uint64_t)&v156, (uint64_t)v161, v89);
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v86, "\"onnx\"");
    ((void (*)(const void **__return_ptr, uint64_t (***)(_QWORD, uint64_t *), uint64_t *, uint64_t *))(*v30)[1])(v93, v30, &v89, v86);
    v14 = from_string_to_engine_type(v93);
    if (v94 < 0)
      heap_Free(*(_QWORD **)(v95 + 8), (uint64_t)v93[0]);
    if (v87 < 0)
      heap_Free(*(_QWORD **)(v88 + 8), v86[0]);
    v154 = &v89;
    std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
    for (ii = 0; ii != -8; ii -= 4)
    {
      if (*((char *)&v160 + ii * 8 + 7) < 0)
        heap_Free(*(_QWORD **)(v161[ii - 1] + 8), v159[ii]);
    }
    v32 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "Token_converter");
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v159, "lstm_engine");
    v79 = 0;
    v80 = 0;
    v81 = 0;
    v82 = CustomAllocator::mRsrc;
    v154 = &v79;
    v155 = 0;
    v79 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v82, 2);
    v80 = v79;
    v81 = v79 + 64;
    v80 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v82, (uint64_t)&v156, (uint64_t)v161, v79);
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v76, "\"onnx\"");
    ((void (*)(const void **__return_ptr, uint64_t (***)(_QWORD, uint64_t *), uint64_t *, uint64_t *))(*v32)[1])(v83, v32, &v79, v76);
    v17 = from_string_to_engine_type(v83);
    if (v84 < 0)
      heap_Free(*(_QWORD **)(v85 + 8), (uint64_t)v83[0]);
    if (v77 < 0)
      heap_Free(*(_QWORD **)(v78 + 8), v76[0]);
    v154 = &v79;
    std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
    for (jj = 0; jj != -8; jj -= 4)
    {
      if (*((char *)&v160 + jj * 8 + 7) < 0)
        heap_Free(*(_QWORD **)(v161[jj - 1] + 8), v159[jj]);
    }
    v34 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "Token_converter");
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v159, "memory_engine");
    v69 = 0;
    v70 = 0;
    v71 = 0;
    v72 = CustomAllocator::mRsrc;
    v154 = &v69;
    v155 = 0;
    v69 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v72, 2);
    v70 = v69;
    v71 = v69 + 64;
    v70 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v72, (uint64_t)&v156, (uint64_t)v161, v69);
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v66, "\"onnx\"");
    ((void (*)(const void **__return_ptr, uint64_t (***)(_QWORD, uint64_t *), uint64_t *, uint64_t *))(*v34)[1])(v73, v34, &v69, v66);
    v20 = from_string_to_engine_type(v73);
    if (v74 < 0)
      heap_Free(*(_QWORD **)(v75 + 8), (uint64_t)v73[0]);
    if (v67 < 0)
      heap_Free(*(_QWORD **)(v68 + 8), v66[0]);
    v154 = &v69;
    std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
    for (kk = 0; kk != -8; kk -= 4)
    {
      if (*((char *)&v160 + kk * 8 + 7) < 0)
        heap_Free(*(_QWORD **)(v161[kk - 1] + 8), v159[kk]);
    }
    v36 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "Token_converter");
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v159, "decoder_engine");
    v59 = 0;
    v60 = 0;
    v61 = 0;
    v62 = CustomAllocator::mRsrc;
    v154 = &v59;
    v155 = 0;
    v59 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v62, 2);
    v60 = v59;
    v61 = v59 + 64;
    v60 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v62, (uint64_t)&v156, (uint64_t)v161, v59);
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v56, "\"onnx\"");
    ((void (*)(const void **__return_ptr, uint64_t (***)(_QWORD, uint64_t *), uint64_t *, uint64_t *))(*v36)[1])(v63, v36, &v59, v56);
    v23 = from_string_to_engine_type(v63);
    if (v64 < 0)
      heap_Free(*(_QWORD **)(v65 + 8), (uint64_t)v63[0]);
    if (v57 < 0)
      heap_Free(*(_QWORD **)(v58 + 8), v56[0]);
    v154 = &v59;
    std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
    for (mm = 0; mm != -8; mm -= 4)
    {
      if (*((char *)&v160 + mm * 8 + 7) < 0)
        heap_Free(*(_QWORD **)(v161[mm - 1] + 8), v159[mm]);
    }
    v38 = (uint64_t (***)(_QWORD, uint64_t *))*a3;
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v156, "Token_converter");
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v159, "postnet_engine");
    v49 = 0;
    v50 = 0;
    v51 = 0;
    v52 = CustomAllocator::mRsrc;
    v154 = &v49;
    v155 = 0;
    v49 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v52, 2);
    v50 = v49;
    v51 = v49 + 64;
    v50 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v52, (uint64_t)&v156, (uint64_t)v161, v49);
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v46, "\"onnx\"");
    ((void (*)(const void **__return_ptr, uint64_t (***)(_QWORD, uint64_t *), uint64_t *, uint64_t *))(*v38)[1])(v53, v38, &v49, v46);
    v26 = from_string_to_engine_type(v53);
    if (v54 < 0)
      heap_Free(*(_QWORD **)(v55 + 8), (uint64_t)v53[0]);
    if (v47 < 0)
      heap_Free(*(_QWORD **)(v48 + 8), v46[0]);
    v154 = &v49;
    std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v154);
    for (nn = 0; nn != -8; nn -= 4)
    {
      if (*((char *)&v160 + nn * 8 + 7) < 0)
        heap_Free(*(_QWORD **)(v161[nn - 1] + 8), v159[nn]);
    }
  }
  v40 = a2[1];
  v44 = *a2;
  v45 = (std::__shared_weak_count *)v40;
  if (v40)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v40 + 8), 1uLL, memory_order_relaxed);
  TC2Engine::instantiate_engines((uint64_t *)a1, v14, v17, v20, v23, v26, &v44);
  v41 = v45;
  if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
  }
  return a1;
}

void sub_214E847CC(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void VisemeParameters::~VisemeParameters(VisemeParameters *this)
{
  uint64_t *v2;

  v2 = (uint64_t *)((char *)this + 80);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (uint64_t *)((char *)this + 48);
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (uint64_t *)((char *)this + 16);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

uint64_t **TC2Engine::instantiate_engines(uint64_t *a1, int a2, int a3, int a4, int a5, int a6, uint64_t *a7)
{
  uint64_t *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  std::__shared_weak_count *v38;
  std::__shared_weak_count *v39;
  uint64_t v41;
  std::__shared_weak_count *v42;
  char v43[64];
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  _BYTE v49[16];
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _BYTE v53[64];
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  std::__shared_weak_count *v58;
  char v59[64];
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  char v65[64];
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  std::__shared_weak_count *v70;
  char v71[64];
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  __int128 v75;
  uint64_t v76[4];
  uint64_t v77;
  std::__shared_weak_count *v78;
  _QWORD v79[13];
  char v80;
  uint64_t v81;
  void *v82;
  _QWORD v83[13];
  char v84;
  uint64_t v85;
  void *v86;
  _QWORD v87[13];
  char v88;
  uint64_t v89;
  void *v90;
  _QWORD v91[13];
  char v92;
  uint64_t v93;
  void *v94;
  _QWORD v95[13];
  char v96;
  uint64_t v97;
  void *v98;
  _QWORD v99[13];
  char v100;
  uint64_t v101;
  void *v102;
  _QWORD v103[13];
  char v104;
  uint64_t v105;
  void *v106;
  uint64_t *__src[13];
  char v108;
  uint64_t v109;
  void *v110;
  _BYTE *v111;
  _BYTE *v112;
  uint64_t v113;
  uint64_t v114;
  char *v115;
  uint64_t v116;
  uint64_t *v117;

  v13 = a1 + 110;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 110, a7);
  v14 = (char *)(*(uint64_t (**)(uint64_t, const char *))(*(_QWORD *)a1[110] + 120))(a1[110], "CPU_RUN");
  if (v14)
  {
    v15 = *v13;
    affinity_parser(v14, (uint64_t *)&v115);
    if ((char **)(v15 + 8) != &v115)
      std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>((uint64_t *)(v15 + 8), v115, v116, (v116 - (uint64_t)v115) >> 2);
    __src[0] = (uint64_t *)&v115;
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](__src);
  }
  v16 = *v13;
  v111 = 0;
  v112 = 0;
  v113 = 0;
  v114 = CustomAllocator::mRsrc;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((uint64_t *)&v111, *(const void **)(v16 + 8), *(_QWORD *)(v16 + 16), (uint64_t)(*(_QWORD *)(v16 + 16) - *(_QWORD *)(v16 + 8)) >> 2);
  if (v112 == v111)
  {
    LODWORD(__src[0]) = 0;
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>((uint64_t *)&v111, (char *)__src, (uint64_t)__src + 4, 1uLL);
  }
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)__src);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v103);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v99);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v95);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v91);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v87);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v83);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v79);
  v17 = operator new(3400);
  v18 = (std::__shared_weak_count *)a1[111];
  v77 = a1[110];
  v78 = v18;
  if (v18)
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  memset(v76, 0, 24);
  v76[3] = CustomAllocator::mRsrc;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v76, v111, (uint64_t)v112, (v112 - v111) >> 2);
  NeonTC2Container::NeonTC2Container(v17, &v77, v76, (uint64_t)__src, (uint64_t)v103, (uint64_t)v99, (uint64_t)v95, (uint64_t)v91, (uint64_t)v87, (uint64_t)v83, (uint64_t)v79);
  a1[2] = v17;
  *(_QWORD *)&v75 = v76;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v75);
  v19 = v78;
  if (v78 && !atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  ModelParameters::ModelParameters((ModelParameters *)v71, (const ModelParameters *)(a1 + 74));
  v20 = a1[2];
  v21 = (std::__shared_weak_count *)a1[111];
  v69 = a1[110];
  v70 = v21;
  if (v21)
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  create_convnet_engine(a2, v20, &v69, (uint64_t)&v75);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)(a1 + 5), &v75);
  v22 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
  if (*((_QWORD *)&v75 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v75 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  v23 = v70;
  if (v70 && !atomic_fetch_add(&v70->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  v117 = &v74;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v73;
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v72;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  ModelParameters::ModelParameters((ModelParameters *)v65, (const ModelParameters *)(a1 + 74));
  v24 = a1[2];
  v25 = (std::__shared_weak_count *)a1[111];
  v63 = a1[110];
  v64 = v25;
  if (v25)
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  create_lstm_engine(a3, v24, &v63, (uint64_t)&v75);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)(a1 + 7), &v75);
  v26 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
  if (*((_QWORD *)&v75 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v75 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  v27 = v64;
  if (v64 && !atomic_fetch_add(&v64->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  v117 = &v68;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v67;
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v66;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  ModelParameters::ModelParameters((ModelParameters *)v59, (const ModelParameters *)(a1 + 74));
  v28 = a1[2];
  v29 = (std::__shared_weak_count *)a1[111];
  v57 = a1[110];
  v58 = v29;
  if (v29)
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  create_memory_layer_engine(a4, v28, &v57, &v75);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)(a1 + 9), &v75);
  v30 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
  if (*((_QWORD *)&v75 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v75 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  v31 = v58;
  if (v58 && !atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  v117 = &v62;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v61;
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v60;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  ModelParameters::ModelParameters((ModelParameters *)v53, (const ModelParameters *)(a1 + 74));
  VisemeParameters::VisemeParameters((VisemeParameters *)v49, (const VisemeParameters *)(a1 + 95));
  v32 = a1[2];
  v33 = (std::__shared_weak_count *)a1[111];
  v47 = a1[110];
  v48 = v33;
  if (v33)
    atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
  create_decoder_engine(a5, (ModelParameters *)v53, (VisemeParameters *)v49, v32, &v47, (uint64_t)&v75);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)(a1 + 3), &v75);
  v34 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
  if (*((_QWORD *)&v75 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v75 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  v35 = v48;
  if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  v117 = &v52;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v51;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v50;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v56;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v55;
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v54;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  ModelParameters::ModelParameters((ModelParameters *)v43, (const ModelParameters *)(a1 + 74));
  v36 = a1[2];
  v37 = (std::__shared_weak_count *)a1[111];
  v41 = a1[110];
  v42 = v37;
  if (v37)
    atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
  create_postnet_engine(a6, v36, &v41, (uint64_t)&v75);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)(a1 + 11), &v75);
  v38 = (std::__shared_weak_count *)*((_QWORD *)&v75 + 1);
  if (*((_QWORD *)&v75 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v75 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
  v39 = v42;
  if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
    std::__shared_weak_count::__release_weak(v39);
  }
  v117 = &v46;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v45;
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v117 = &v44;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v117);
  v79[0] = &unk_24D29B388;
  v79[2] = &unk_24D29B3B0;
  v82 = &unk_24D29B3D8;
  v79[3] = &unk_24D29B578;
  if (v80 < 0)
    heap_Free(*(_QWORD **)(v81 + 8), v79[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v82);
  v83[0] = &unk_24D29B388;
  v83[2] = &unk_24D29B3B0;
  v86 = &unk_24D29B3D8;
  v83[3] = &unk_24D29B578;
  if (v84 < 0)
    heap_Free(*(_QWORD **)(v85 + 8), v83[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v86);
  v87[0] = &unk_24D29B388;
  v87[2] = &unk_24D29B3B0;
  v90 = &unk_24D29B3D8;
  v87[3] = &unk_24D29B578;
  if (v88 < 0)
    heap_Free(*(_QWORD **)(v89 + 8), v87[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v90);
  v91[0] = &unk_24D29B388;
  v91[2] = &unk_24D29B3B0;
  v94 = &unk_24D29B3D8;
  v91[3] = &unk_24D29B578;
  if (v92 < 0)
    heap_Free(*(_QWORD **)(v93 + 8), v91[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v94);
  v95[0] = &unk_24D29B388;
  v95[2] = &unk_24D29B3B0;
  v98 = &unk_24D29B3D8;
  v95[3] = &unk_24D29B578;
  if (v96 < 0)
    heap_Free(*(_QWORD **)(v97 + 8), v95[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v98);
  v99[0] = &unk_24D29B388;
  v99[2] = &unk_24D29B3B0;
  v102 = &unk_24D29B3D8;
  v99[3] = &unk_24D29B578;
  if (v100 < 0)
    heap_Free(*(_QWORD **)(v101 + 8), v99[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v102);
  v103[0] = &unk_24D29B388;
  v103[2] = &unk_24D29B3B0;
  v106 = &unk_24D29B3D8;
  v103[3] = &unk_24D29B578;
  if (v104 < 0)
    heap_Free(*(_QWORD **)(v105 + 8), v103[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v106);
  __src[0] = (uint64_t *)&unk_24D29B388;
  __src[2] = (uint64_t *)&unk_24D29B3B0;
  v110 = &unk_24D29B3D8;
  __src[3] = (uint64_t *)&unk_24D29B578;
  if (v108 < 0)
    heap_Free(*(_QWORD **)(v109 + 8), (uint64_t)__src[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v110);
  __src[0] = (uint64_t *)&v111;
  return std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](__src);
}

void sub_214E85860(_Unwind_Exception *a1)
{
  uint64_t v1;

  STACK[0xC48] = v1 - 152;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&STACK[0xC48]);
  _Unwind_Resume(a1);
}

void ModelParameters::~ModelParameters(ModelParameters *this)
{
  uint64_t *v2;

  v2 = (uint64_t *)((char *)this + 128);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (uint64_t *)((char *)this + 96);
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (uint64_t *)((char *)this + 64);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void *TC2Engine::prepare_input_for_vocoder(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[3];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v12 = *(_QWORD *)(*(_QWORD *)a3 + 16);
  v13 = v12 * a7;
  std::vector<float,ENTTS::Allocator<float>>::resize(a4, v12 * a7);
  v15[0] = 1;
  v15[1] = a7;
  v15[2] = v12;
  std::vector<unsigned long long,ENTTS::Allocator<unsigned long long>>::__assign_with_size[abi:ne180100]<unsigned long long const*,unsigned long long const*>(a5, (char *)v15, (uint64_t)&v16, 3uLL);
  return memcpy((void *)*a4, (const void *)(*a2 + 4 * v12 * (a6 - a7)), 4 * v13);
}

void TC2Engine::~TC2Engine(TC2Engine *this)
{
  char *v2;
  NeonTC2Container *v3;
  uint64_t v4;
  uint64_t *v5;

  *(_QWORD *)this = &off_24D29BFD0;
  v2 = (char *)this + 40;
  std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100]((_QWORD *)this + 5);
  std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100]((_QWORD *)this + 7);
  std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100]((_QWORD *)this + 9);
  std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100]((_QWORD *)this + 3);
  std::shared_ptr<IMelganFirstConvEngine>::reset[abi:ne180100]((_QWORD *)this + 11);
  v3 = (NeonTC2Container *)*((_QWORD *)this + 2);
  if (v3)
  {
    NeonTC2Container::~NeonTC2Container(v3);
    operator delete(v4);
  }
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 880);
  v5 = (uint64_t *)((char *)this + 840);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 808);
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 776);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 720);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 688);
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 656);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 520);
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 488);
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 456);
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 424);
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 392);
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 360);
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 328);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 296);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 264);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 232);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 200);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (uint64_t *)((char *)this + 168);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 88);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 72);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 56);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 24);
}

{
  void *v1;

  TC2Engine::~TC2Engine(this);
  operator delete(v1);
}

uint64_t TC2Engine::reset(TC2Engine *this)
{
  uint64_t result;

  *((_WORD *)this + 276) = 1;
  *((_BYTE *)this + 554) = 1;
  *((_OWORD *)this + 35) = 0u;
  result = *((_QWORD *)this + 3);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void TC2Engine::concat_lstm_and_style(int a1, _QWORD *a2, uint64_t a3, const void **a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *v6;
  const void **v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  uint64_t v13;
  size_t v14;
  const void **v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v20;
  _QWORD __src[3];
  uint64_t v22;

  v6 = a6;
  v8 = a4;
  v22 = *MEMORY[0x24BDAC8D0];
  v9 = *(unsigned int *)(*(_QWORD *)a3 + 8);
  v10 = *(_QWORD *)(*(_QWORD *)a3 + 16);
  v11 = (_BYTE *)a4[1] - (_BYTE *)*a4;
  __src[0] = 1;
  __src[1] = v9;
  v20 = v10;
  __src[2] = (v11 >> 2) + v10;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a6, (char *)__src, (uint64_t)&v22, 3uLL);
  std::vector<float,ENTTS::Allocator<float>>::resize(a5, *(_QWORD *)(*v6 + 16) * *(_QWORD *)(*v6 + 8));
  if (v9)
  {
    v12 = 0;
    v13 = 0;
    v14 = v11 & 0x3FFFFFFFCLL;
    do
    {
      v15 = v8;
      v16 = v6;
      v17 = *(_QWORD *)(*v6 + 16) * v13;
      memcpy((void *)(*a5 + 4 * v17), (const void *)(*a2 + 4 * v12), 4 * v20);
      v18 = v17 + v20;
      v6 = v16;
      v8 = v15;
      memcpy((void *)(*a5 + 4 * v18), *v15, v14);
      ++v13;
      v12 += v20;
    }
    while (v9 != v13);
  }
}

uint64_t *TC2Engine::get_intermediate_results(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13)
{
  uint64_t *result;

  if ((uint64_t *)(a1 + 168) != a2)
    std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a2, *(char **)(a1 + 168), *(_QWORD *)(a1 + 176), (uint64_t)(*(_QWORD *)(a1 + 176) - *(_QWORD *)(a1 + 168)) >> 2);
  if ((uint64_t *)(a1 + 200) != a4)
    std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a4, *(char **)(a1 + 200), *(_QWORD *)(a1 + 208), (uint64_t)(*(_QWORD *)(a1 + 208) - *(_QWORD *)(a1 + 200)) >> 2);
  if ((uint64_t *)(a1 + 232) != a6)
    std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a6, *(char **)(a1 + 232), *(_QWORD *)(a1 + 240), (uint64_t)(*(_QWORD *)(a1 + 240) - *(_QWORD *)(a1 + 232)) >> 2);
  if ((uint64_t *)(a1 + 264) != a8)
    std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a8, *(char **)(a1 + 264), *(_QWORD *)(a1 + 272), (uint64_t)(*(_QWORD *)(a1 + 272) - *(_QWORD *)(a1 + 264)) >> 2);
  if ((uint64_t *)(a1 + 296) != a10)
    std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a10, *(char **)(a1 + 296), *(_QWORD *)(a1 + 304), (uint64_t)(*(_QWORD *)(a1 + 304) - *(_QWORD *)(a1 + 296)) >> 2);
  if ((uint64_t *)(a1 + 328) != a12)
    std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a12, *(char **)(a1 + 328), *(_QWORD *)(a1 + 336), (uint64_t)(*(_QWORD *)(a1 + 336) - *(_QWORD *)(a1 + 328)) >> 2);
  if ((uint64_t *)(a1 + 360) != a3)
    std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a3, *(char **)(a1 + 360), *(_QWORD *)(a1 + 368), (uint64_t)(*(_QWORD *)(a1 + 368) - *(_QWORD *)(a1 + 360)) >> 3);
  if ((uint64_t *)(a1 + 392) != a5)
    std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a5, *(char **)(a1 + 392), *(_QWORD *)(a1 + 400), (uint64_t)(*(_QWORD *)(a1 + 400) - *(_QWORD *)(a1 + 392)) >> 3);
  result = a7;
  if ((uint64_t *)(a1 + 424) != a7)
    result = std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a7, *(char **)(a1 + 424), *(_QWORD *)(a1 + 432), (uint64_t)(*(_QWORD *)(a1 + 432) - *(_QWORD *)(a1 + 424)) >> 3);
  if ((uint64_t *)(a1 + 456) != a9)
    result = std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a9, *(char **)(a1 + 456), *(_QWORD *)(a1 + 464), (uint64_t)(*(_QWORD *)(a1 + 464) - *(_QWORD *)(a1 + 456)) >> 3);
  if ((uint64_t *)(a1 + 488) != a11)
    result = std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a11, *(char **)(a1 + 488), *(_QWORD *)(a1 + 496), (uint64_t)(*(_QWORD *)(a1 + 496) - *(_QWORD *)(a1 + 488)) >> 3);
  if ((uint64_t *)(a1 + 520) != a13)
    return std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a13, *(char **)(a1 + 520), *(_QWORD *)(a1 + 528), (uint64_t)(*(_QWORD *)(a1 + 528) - *(_QWORD *)(a1 + 520)) >> 3);
  return result;
}

uint64_t TC2Engine::do_inference(uint64_t a1, uint64_t a2, uint64_t a3, const void **a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t a8, unsigned __int8 a9)
{
  std::chrono::steady_clock::time_point v14;
  std::chrono::steady_clock::time_point v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t **v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t *v25;
  unint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t *v34;
  uint64_t v35;
  int v36;
  uint64_t *v37;
  uint64_t v38;
  std::chrono::steady_clock::time_point v39;
  std::chrono::steady_clock::time_point v40;
  std::chrono::steady_clock::time_point v41;
  std::chrono::steady_clock::time_point v42;
  double v43;
  _BOOL8 v44;
  int v45;
  int v46;
  std::chrono::steady_clock::time_point v47;
  int v48;
  uint64_t **v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t *v53;
  unint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _DWORD *v61;
  uint64_t *v62;
  uint64_t v63;
  int v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t *v67;
  std::chrono::steady_clock::time_point v68;
  std::chrono::steady_clock::time_point v69;
  unsigned int v70;
  char v71;
  unsigned int v72;
  int v73;
  unsigned int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  std::chrono::steady_clock::time_point v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  std::chrono::steady_clock::time_point v83;
  std::chrono::steady_clock::time_point v85;
  unsigned int v86;
  _QWORD v89[4];
  _QWORD v90[4];
  uint64_t v91[4];
  void *__dst[5];
  uint64_t __src;
  uint64_t *v94;
  uint64_t *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;

  v98 = *MEMORY[0x24BDAC8D0];
  v14.__d_.__rep_ = get_timestamp().__d_.__rep_;
  v15.__d_.__rep_ = get_timestamp().__d_.__rep_;
  if (*(_BYTE *)(a1 + 554))
  {
    *(_QWORD *)(a1 + 576) = a8;
    *(_QWORD *)(a1 + 176) = *(_QWORD *)(a1 + 168);
    *(_QWORD *)(a1 + 208) = *(_QWORD *)(a1 + 200);
    *(_QWORD *)(a1 + 240) = *(_QWORD *)(a1 + 232);
    *(_QWORD *)(a1 + 272) = *(_QWORD *)(a1 + 264);
    *(_QWORD *)(a1 + 304) = *(_QWORD *)(a1 + 296);
    *(_QWORD *)(a1 + 336) = *(_QWORD *)(a1 + 328);
    *(_QWORD *)(a1 + 368) = *(_QWORD *)(a1 + 360);
    *(_QWORD *)(a1 + 400) = *(_QWORD *)(a1 + 392);
    *(_QWORD *)(a1 + 432) = *(_QWORD *)(a1 + 424);
    *(_QWORD *)(a1 + 464) = *(_QWORD *)(a1 + 456);
    *(_QWORD *)(a1 + 496) = *(_QWORD *)(a1 + 488);
    *(_QWORD *)(a1 + 528) = *(_QWORD *)(a1 + 520);
    TC2Engine::do_inference_encoding(a1, a2, a3, a4);
  }
  if (*(_BYTE *)(a1 + 8))
  {
    v16 = *(_DWORD *)(a1 + 592);
    v17 = v16 >> 1;
    memset(__dst, 0, 24);
    __dst[3] = (void *)CustomAllocator::mRsrc;
    memset(v91, 0, 24);
    v91[3] = CustomAllocator::mRsrc;
    memset(v90, 0, 24);
    v90[3] = CustomAllocator::mRsrc;
    memset(v89, 0, 24);
    v89[3] = CustomAllocator::mRsrc;
    v18 = a7;
    if (*(_BYTE *)(a1 + 554))
    {
      *(_WORD *)(a1 + 553) = 0;
      *(_DWORD *)(a1 + 588) = 0;
      *(_QWORD *)(a1 + 136) = 0;
      *(_QWORD *)(a1 + 144) = 0;
      if (*(_DWORD *)(a1 + 636))
      {
        v17 = 0;
        v19 = 0;
        v20 = *(_DWORD *)(a1 + 620) + (v16 & 0xFFFFFFFE);
      }
      else
      {
        v19 = 0;
        v20 = *(_DWORD *)(a1 + 616) + v17;
        v17 = 0;
      }
    }
    else
    {
      v45 = *(_DWORD *)(a1 + 620);
      if (*(_DWORD *)(a1 + 636))
        v46 = v45 * *(_DWORD *)(a1 + 588);
      else
        v46 = *(_DWORD *)(a1 + 616) + (*(_DWORD *)(a1 + 588) - 1) * v45;
      v19 = v46 - v17;
      v20 = v45 + (v16 & 0xFFFFFFFE) + v46 - v17;
    }
    v47.__d_.__rep_ = get_timestamp().__d_.__rep_;
    v86 = v17;
    if (*(_BYTE *)(a1 + 553))
    {
      v48 = 1;
    }
    else
    {
      v49 = (uint64_t **)(a1 + 296);
      if (IDecoderEngine::do_inference(*(_QWORD *)(a1 + 24), a1 + 232, a1 + 424, a1 + 264, a1 + 456, (uint64_t *)(a1 + 296), (uint64_t *)(a1 + 488), 1, a9))
      {
        v50 = *(_QWORD *)(a1 + 576);
        v51 = *(unsigned int *)(a1 + 608);
        if (v50 * v51)
        {
          LODWORD(v52) = 0;
          v53 = *(uint64_t **)(a1 + 304);
          do
          {
            v54 = *(_QWORD *)(a1 + 312);
            if ((unint64_t)v53 >= v54)
            {
              v55 = *v49;
              v56 = ((char *)v53 - (char *)*v49) >> 2;
              v57 = v56 + 1;
              if ((unint64_t)(v56 + 1) >> 62)
                std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
              v58 = v54 - (_QWORD)v55;
              if (v58 >> 1 > v57)
                v57 = v58 >> 1;
              if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFFCLL)
                v59 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v59 = v57;
              v97 = a1 + 320;
              if (v59)
              {
                v60 = ENTTS::Allocator<int>::allocate(a1 + 320, v59);
                v55 = *(uint64_t **)(a1 + 296);
                v53 = *(uint64_t **)(a1 + 304);
              }
              else
              {
                v60 = 0;
              }
              v61 = (_DWORD *)(v60 + 4 * v56);
              *v61 = *(_DWORD *)(a1 + 584);
              if (v53 == v55)
              {
                v63 = v60 + 4 * v56;
              }
              else
              {
                v62 = v53;
                v63 = v60 + 4 * v56;
                do
                {
                  v64 = *((_DWORD *)v62 - 1);
                  v62 = (uint64_t *)((char *)v62 - 4);
                  *(_DWORD *)(v63 - 4) = v64;
                  v63 -= 4;
                }
                while (v62 != v55);
              }
              v65 = (uint64_t *)(v61 + 1);
              *(_QWORD *)(a1 + 296) = v63;
              *(_QWORD *)(a1 + 304) = v61 + 1;
              v66 = *(_QWORD *)(a1 + 312);
              *(_QWORD *)(a1 + 312) = v60 + 4 * v59;
              v95 = v53;
              v96 = v66;
              __src = (uint64_t)v55;
              v94 = v55;
              std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&__src);
              v50 = *(_QWORD *)(a1 + 576);
              v51 = *(unsigned int *)(a1 + 608);
              v53 = v65;
            }
            else
            {
              *(_DWORD *)v53 = *(_DWORD *)(a1 + 584);
              v53 = (uint64_t *)((char *)v53 + 4);
            }
            *(_QWORD *)(a1 + 304) = v53;
            v52 = (v52 + 1);
          }
          while (v50 * v51 > v52);
        }
        *(_QWORD *)(*(_QWORD *)(a1 + 488) + 8) += v50;
        v48 = 1;
        v18 = a7;
      }
      else
      {
        v48 = 0;
      }
    }
    v67 = (uint64_t *)(v20 - v19);
    std::vector<float,ENTTS::Allocator<float>>::resize((uint64_t *)__dst, (*(_DWORD *)(a1 + 608) * (_DWORD)v67));
    __src = 1;
    v94 = v67;
    v95 = (uint64_t *)*(unsigned int *)(a1 + 608);
    std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(v91, (char *)&__src, (uint64_t)&v96, 3uLL);
    memcpy(__dst[0], (const void *)(*(_QWORD *)(a1 + 296) + 4 * *(_DWORD *)(a1 + 608) * v19), 4 * (*(_DWORD *)(a1 + 608) * (_DWORD)v67));
    v68.__d_.__rep_ = get_timestamp().__d_.__rep_;
    *(double *)(a1 + 136) = time_elapsed(v47.__d_.__rep_, v68.__d_.__rep_) + *(double *)(a1 + 136);
    v69.__d_.__rep_ = get_timestamp().__d_.__rep_;
    (***(void (****)(_QWORD, void **, uint64_t *, _QWORD *, _QWORD *))(a1 + 88))(*(_QWORD *)(a1 + 88), __dst, v91, v90, v89);
    if (*(_DWORD *)(a1 + 636))
      v70 = *(_DWORD *)(a1 + 620) + *(_DWORD *)(a1 + 620) * *(_DWORD *)(a1 + 588);
    else
      v70 = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 620) * *(_DWORD *)(a1 + 588);
    if (v70 < *(_DWORD *)(*(_QWORD *)(a1 + 488) + 8))
      v71 = v48;
    else
      v71 = 0;
    *(_BYTE *)(a1 + 553) = v71;
    std::vector<float,ENTTS::Allocator<float>>::resize((uint64_t *)(a1 + 328), *(_DWORD *)(a1 + 608) * v70);
    __src = 1;
    v94 = (uint64_t *)v70;
    v95 = (uint64_t *)*(unsigned int *)(a1 + 608);
    std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>((uint64_t *)(a1 + 520), (char *)&__src, (uint64_t)&v96, 3uLL);
    v72 = *(_DWORD *)(a1 + 588);
    if (*(_DWORD *)(a1 + 636))
    {
      v73 = *(_DWORD *)(a1 + 608);
      v74 = v73 * *(_DWORD *)(a1 + 620);
      v72 *= v74;
    }
    else
    {
      v75 = *(_DWORD *)(a1 + 616);
      if (v72)
      {
        v76 = *(_DWORD *)(a1 + 620);
        v73 = *(_DWORD *)(a1 + 608);
        v72 = (v75 + v76 * (v72 - 1)) * v73;
        v74 = v73 * v76;
      }
      else
      {
        v73 = *(_DWORD *)(a1 + 608);
        v74 = v73 * v75;
      }
    }
    memcpy((void *)(*(_QWORD *)(a1 + 328) + 4 * v72), (const void *)(v90[0] + 4 * v73 * v86), 4 * v74);
    if (v48)
      v77 = *(_BYTE *)(a1 + 553) != 0;
    else
      v77 = 1;
    *(_BYTE *)(a1 + 552) = v77;
    v78 = *(_DWORD *)(a1 + 588);
    if (!v78)
    {
      v79.__d_.__rep_ = get_timestamp().__d_.__rep_;
      *(double *)(a1 + 160) = time_elapsed(v15.__d_.__rep_, v79.__d_.__rep_);
      v77 = *(unsigned __int8 *)(a1 + 552);
      v78 = *(_DWORD *)(a1 + 588);
    }
    *(_DWORD *)(a1 + 588) = v78 + 1;
    v44 = v77 == 0;
    v80 = *(_QWORD *)(a1 + 568);
    v81 = *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8) - v80;
    *(_QWORD *)(a1 + 560) = v81;
    if (!v77)
    {
      v81 = *(_QWORD *)(*(_QWORD *)(a1 + 488) + 8) - v80;
      *(_QWORD *)(a1 + 560) = v81;
    }
    std::vector<float,ENTTS::Allocator<float>>::resize(a6, v81 * *(unsigned int *)(a1 + 608));
    v82 = *(uint64_t **)(a1 + 560);
    __src = 1;
    v94 = v82;
    v95 = (uint64_t *)*(unsigned int *)(a1 + 608);
    std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(v18, (char *)&__src, (uint64_t)&v96, 3uLL);
    memcpy((void *)*a6, (const void *)(*(_QWORD *)(a1 + 328) + 4 * *(_QWORD *)(a1 + 568) * *(unsigned int *)(a1 + 608)), 4 * *(unsigned int *)(a1 + 608) * *(_QWORD *)(a1 + 560));
    *(_QWORD *)(a1 + 568) += *(_QWORD *)(a1 + 560);
    v83.__d_.__rep_ = get_timestamp().__d_.__rep_;
    *(double *)(a1 + 144) = time_elapsed(v69.__d_.__rep_, v83.__d_.__rep_) + *(double *)(a1 + 144);
    if (!v77)
    {
      *(_BYTE *)(a1 + 554) = 1;
      *(_QWORD *)(a1 + 560) = 0;
      *(_QWORD *)(a1 + 568) = 0;
    }
    __src = (uint64_t)v89;
    std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&__src);
    __src = (uint64_t)v90;
    std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&__src);
    __src = (uint64_t)v91;
    std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&__src);
    __src = (uint64_t)__dst;
    std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&__src);
  }
  else
  {
    v85.__d_.__rep_ = get_timestamp().__d_.__rep_;
    v21 = (uint64_t **)(a1 + 296);
    IDecoderEngine::do_inference(*(_QWORD *)(a1 + 24), a1 + 232, a1 + 424, a1 + 264, a1 + 456, (uint64_t *)(a1 + 296), (uint64_t *)(a1 + 488), 0, a9);
    v22 = *(_QWORD *)(a1 + 576);
    v23 = *(unsigned int *)(a1 + 608);
    if (v22 * v23)
    {
      v24 = 0;
      v25 = *(uint64_t **)(a1 + 304);
      do
      {
        v26 = *(_QWORD *)(a1 + 312);
        if ((unint64_t)v25 >= v26)
        {
          v27 = *v21;
          v28 = ((char *)v25 - (char *)*v21) >> 2;
          v29 = v28 + 1;
          if ((unint64_t)(v28 + 1) >> 62)
            std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
          v30 = v26 - (_QWORD)v27;
          if (v30 >> 1 > v29)
            v29 = v30 >> 1;
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFFCLL)
            v31 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v31 = v29;
          v97 = a1 + 320;
          if (v31)
          {
            v32 = ENTTS::Allocator<int>::allocate(a1 + 320, v31);
            v27 = *(uint64_t **)(a1 + 296);
            v25 = *(uint64_t **)(a1 + 304);
          }
          else
          {
            v32 = 0;
          }
          v33 = (_DWORD *)(v32 + 4 * v28);
          *v33 = *(_DWORD *)(a1 + 584);
          if (v25 == v27)
          {
            v35 = v32 + 4 * v28;
          }
          else
          {
            v34 = v25;
            v35 = v32 + 4 * v28;
            do
            {
              v36 = *((_DWORD *)v34 - 1);
              v34 = (uint64_t *)((char *)v34 - 4);
              *(_DWORD *)(v35 - 4) = v36;
              v35 -= 4;
            }
            while (v34 != v27);
          }
          v37 = (uint64_t *)(v33 + 1);
          *(_QWORD *)(a1 + 296) = v35;
          *(_QWORD *)(a1 + 304) = v33 + 1;
          v38 = *(_QWORD *)(a1 + 312);
          *(_QWORD *)(a1 + 312) = v32 + 4 * v31;
          v95 = v25;
          v96 = v38;
          __src = (uint64_t)v27;
          v94 = v27;
          std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&__src);
          v22 = *(_QWORD *)(a1 + 576);
          v23 = *(unsigned int *)(a1 + 608);
          v25 = v37;
        }
        else
        {
          *(_DWORD *)v25 = *(_DWORD *)(a1 + 584);
          v25 = (uint64_t *)((char *)v25 + 4);
        }
        *(_QWORD *)(a1 + 304) = v25;
        ++v24;
      }
      while (v24 < v22 * v23);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 488) + 8) += v22;
    v39.__d_.__rep_ = get_timestamp().__d_.__rep_;
    *(double *)(a1 + 136) = time_elapsed(v85.__d_.__rep_, v39.__d_.__rep_);
    v40.__d_.__rep_ = get_timestamp().__d_.__rep_;
    (***(void (****)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88))(*(_QWORD *)(a1 + 88), a1 + 296, a1 + 488, a1 + 328, a1 + 520);
    if ((uint64_t *)(a1 + 328) != a6)
      std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a6, *(char **)(a1 + 328), *(_QWORD *)(a1 + 336), (uint64_t)(*(_QWORD *)(a1 + 336) - *(_QWORD *)(a1 + 328)) >> 2);
    if ((uint64_t *)(a1 + 520) != a7)
      std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a7, *(char **)(a1 + 520), *(_QWORD *)(a1 + 528), (uint64_t)(*(_QWORD *)(a1 + 528) - *(_QWORD *)(a1 + 520)) >> 3);
    v41.__d_.__rep_ = get_timestamp().__d_.__rep_;
    *(double *)(a1 + 144) = time_elapsed(v40.__d_.__rep_, v41.__d_.__rep_);
    v42.__d_.__rep_ = get_timestamp().__d_.__rep_;
    v43 = time_elapsed(v14.__d_.__rep_, v42.__d_.__rep_);
    *(double *)(a1 + 152) = v43;
    *(double *)(a1 + 160) = v43;
    return 1;
  }
  return v44;
}

void sub_214E868D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t ***a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t **a19, uint64_t a20,uint64_t a21,uint64_t a22,char *a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  *(_QWORD *)(v27 - 144) = &a15;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v27 - 144));
  a15 = &a19;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a15);
  a19 = (uint64_t **)&a23;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a19);
  a23 = &a27;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a23);
  _Unwind_Resume(a1);
}

void TC2Engine::do_inference_encoding(uint64_t a1, uint64_t a2, uint64_t a3, const void **a4)
{
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep;
  std::chrono::steady_clock::time_point v9;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v10;
  std::chrono::steady_clock::time_point v11;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12;
  std::chrono::steady_clock::time_point v13;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v14;
  std::chrono::steady_clock::time_point v15;
  _DWORD *exception;

  if (!*(_QWORD *)(a1 + 40) || !*(_QWORD *)(a1 + 56) || !*(_QWORD *)(a1 + 72))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 6;
  }
  rep = get_timestamp().__d_.__rep_;
  (***(void (****)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(*(_QWORD *)(a1 + 40), a2, a3, a1 + 168, a1 + 360);
  v9.__d_.__rep_ = get_timestamp().__d_.__rep_;
  *(double *)(a1 + 104) = time_elapsed(rep, v9.__d_.__rep_);
  v10 = get_timestamp().__d_.__rep_;
  (***(void (****)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 56))(*(_QWORD *)(a1 + 56), a1 + 168, a1 + 360, a1 + 200, a1 + 392);
  v11.__d_.__rep_ = get_timestamp().__d_.__rep_;
  *(double *)(a1 + 112) = time_elapsed(v10, v11.__d_.__rep_);
  v12 = get_timestamp().__d_.__rep_;
  TC2Engine::concat_lstm_and_style(v12, (_QWORD *)(a1 + 200), a1 + 392, a4, (uint64_t *)(a1 + 232), (uint64_t *)(a1 + 424));
  v13.__d_.__rep_ = get_timestamp().__d_.__rep_;
  *(double *)(a1 + 120) = time_elapsed(v12, v13.__d_.__rep_);
  v14 = get_timestamp().__d_.__rep_;
  (***(void (****)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 72))(*(_QWORD *)(a1 + 72), a1 + 232, a1 + 424, a1 + 264, a1 + 456);
  v15.__d_.__rep_ = get_timestamp().__d_.__rep_;
  *(double *)(a1 + 128) = time_elapsed(v14, v15.__d_.__rep_);
}

void ModelParameters::ModelParameters(ModelParameters *this, const ModelParameters *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *(_OWORD *)a2;
  v5 = *((_OWORD *)a2 + 1);
  v6 = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 3) = v6;
  *(_OWORD *)this = v4;
  *((_OWORD *)this + 1) = v5;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = CustomAllocator::mRsrc;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((uint64_t *)this + 8, *((const void **)a2 + 8), *((_QWORD *)a2 + 9), (uint64_t)(*((_QWORD *)a2 + 9) - *((_QWORD *)a2 + 8)) >> 2);
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  v7 = CustomAllocator::mRsrc;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = v7;
  std::vector<std::string,ENTTS::Allocator<std::string>>::__init_with_size[abi:ne180100]<std::string*,std::string*>((std::string *)this + 4, *((__int128 **)a2 + 12), *((__int128 **)a2 + 13), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)a2 + 13) - *((_QWORD *)a2 + 12)) >> 3));
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  v8 = CustomAllocator::mRsrc;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = v8;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((uint64_t *)this + 16, *((const void **)a2 + 16), *((_QWORD *)a2 + 17), (uint64_t)(*((_QWORD *)a2 + 17) - *((_QWORD *)a2 + 16)) >> 2);
  *((_QWORD *)this + 20) = *((_QWORD *)a2 + 20);
}

void sub_214E86BC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  _Unwind_Resume(a1);
}

std::string *std::vector<std::string,ENTTS::Allocator<std::string>>::__init_with_size[abi:ne180100]<std::string*,std::string*>(std::string *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  std::string *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::string,ENTTS::Allocator<std::string>>::__vallocate[abi:ne180100]((uint64_t *)result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::string>,std::string*,std::string*,std::string*>((uint64_t)&v6[1], a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

void sub_214E86C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::string,ENTTS::Allocator<std::string>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void VisemeParameters::VisemeParameters(VisemeParameters *this, const VisemeParameters *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(_QWORD *)a2;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *(_QWORD *)this = v4;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = CustomAllocator::mRsrc;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((uint64_t *)this + 2, *((const void **)a2 + 2), *((_QWORD *)a2 + 3), (uint64_t)(*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 2);
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  v5 = CustomAllocator::mRsrc;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = v5;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__init_with_size[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t *)this + 6, *((_QWORD *)a2 + 6), *((_QWORD *)a2 + 7), (uint64_t)(*((_QWORD *)a2 + 7) - *((_QWORD *)a2 + 6)) >> 5);
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  v6 = CustomAllocator::mRsrc;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = v6;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((uint64_t *)this + 10, *((const void **)a2 + 10), *((_QWORD *)a2 + 11), (uint64_t)(*((_QWORD *)a2 + 11) - *((_QWORD *)a2 + 10)) >> 2);
  *((_QWORD *)this + 14) = *((_QWORD *)a2 + 14);
}

void sub_214E86D44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__init_with_size[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>(uint64_t *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__vallocate[abi:ne180100](result, a4);
    result = (uint64_t *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)(v6 + 3), a2, a3, v6[1]);
    v6[1] = (uint64_t)result;
  }
  return result;
}

void sub_214E86DD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<unsigned long long,ENTTS::Allocator<unsigned long long>>::__assign_with_size[abi:ne180100]<unsigned long long const*,unsigned long long const*>(uint64_t *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *result;
  if (a4 > (result[2] - *result) >> 3)
  {
    std::vector<unsigned long long,ENTTS::Allocator<unsigned long long>>::__vdeallocate(result);
    if (a4 >> 61)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v9 = v7[2] - *v7;
    v10 = v9 >> 2;
    if (v9 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = (uint64_t *)std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__vallocate[abi:ne180100](v7, v11);
    v13 = v7[1];
    v12 = v7 + 1;
    v8 = v13;
LABEL_14:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = (void *)v8;
      v19 = __src;
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  v12 = result + 1;
  v14 = result[1];
  v15 = (v14 - v8) >> 3;
  if (v15 >= a4)
    goto LABEL_14;
  v16 = &__src[8 * v15];
  if (v14 != v8)
  {
    result = (uint64_t *)memmove((void *)*result, __src, v14 - v8);
    v8 = *v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = (void *)v8;
    v19 = v16;
LABEL_16:
    result = (uint64_t *)memmove(v18, v19, v17);
  }
LABEL_17:
  *v12 = v8 + v17;
  return result;
}

uint64_t *std::vector<unsigned long long,ENTTS::Allocator<unsigned long long>>::__vdeallocate(uint64_t *result)
{
  uint64_t v1;
  uint64_t *v2;

  v1 = *result;
  if (*result)
  {
    v2 = result;
    result[1] = v1;
    result = heap_Free(*(_QWORD **)(result[3] + 8), v1);
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  return result;
}

uint64_t *std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(uint64_t *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *result;
  if (a4 > (result[2] - *result) >> 2)
  {
    std::vector<float,ENTTS::Allocator<float>>::__vdeallocate(result);
    if (a4 >> 62)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v9 = v7[2] - *v7;
    v10 = v9 >> 1;
    if (v9 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = (uint64_t *)std::vector<int,ENTTS::Allocator<int>>::__vallocate[abi:ne180100](v7, v11);
    v13 = v7[1];
    v12 = v7 + 1;
    v8 = v13;
LABEL_14:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = (void *)v8;
      v19 = __src;
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  v12 = result + 1;
  v14 = result[1];
  v15 = (v14 - v8) >> 2;
  if (v15 >= a4)
    goto LABEL_14;
  v16 = &__src[4 * v15];
  if (v14 != v8)
  {
    result = (uint64_t *)memmove((void *)*result, __src, v14 - v8);
    v8 = *v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = (void *)v8;
    v19 = v16;
LABEL_16:
    result = (uint64_t *)memmove(v18, v19, v17);
  }
LABEL_17:
  *v12 = v8 + v17;
  return result;
}

uint64_t *std::vector<float,ENTTS::Allocator<float>>::__vdeallocate(uint64_t *result)
{
  uint64_t v1;
  uint64_t *v2;

  v1 = *result;
  if (*result)
  {
    v2 = result;
    result[1] = v1;
    result = heap_Free(*(_QWORD **)(result[3] + 8), v1);
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  return result;
}

double create_melgan_vocoder_engine@<D0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  double result;
  __int128 v5;

  ENTTS::make_shared<MelganEngine,std::shared_ptr<IExternalServices> &,std::shared_ptr<IJsonWrapper> &>(a1, a2, &v5);
  result = *(double *)&v5;
  *a3 = v5;
  return result;
}

void ENTTS::make_shared<MelganEngine,std::shared_ptr<IExternalServices> &,std::shared_ptr<IJsonWrapper> &>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  __int128 v16;

  v6 = operator new(112);
  v7 = v6;
  v8 = (std::__shared_weak_count *)a1[1];
  v14 = *a1;
  v15 = v8;
  if (v8)
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  v9 = (std::__shared_weak_count *)a2[1];
  v12 = *a2;
  v13 = v9;
  if (v9)
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  MelganEngine::MelganEngine(v6, &v14, &v12);
  std::shared_ptr<MelganEngine>::shared_ptr[abi:ne180100]<MelganEngine,ENTTS::Deleter<MelganEngine>,ENTTS::Allocator<MelganEngine>,void>(&v16, v7);
  *a3 = v16;
  v16 = 0uLL;
  v10 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  v11 = v15;
  if (v15)
  {
    if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_214E871B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void create_vocoder_engine(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  unint64_t i;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16[2];
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23[2];
  char v24;
  uint64_t v25;
  uint64_t *v26;
  char v27;
  _OWORD v28[2];
  _QWORD v29[4];
  _QWORD v30[2];

  v30[1] = *MEMORY[0x24BDAC8D0];
  v6 = *a2;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v28, "Vocoder");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v29, "engine_type");
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = CustomAllocator::mRsrc;
  v26 = &v19;
  v27 = 0;
  v19 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v22, 2);
  v20 = v19;
  v21 = v19 + 64;
  v20 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v22, (uint64_t)v28, (uint64_t)v30, v19);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v16, "");
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v6 + 8))(v23, v6, &v19, v16);
  if (v17 < 0)
    heap_Free(*(_QWORD **)(v18 + 8), v16[0]);
  v26 = &v19;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](&v26);
  for (i = 0; i != -64; i -= 32)
  {
    if (SHIBYTE(v29[i / 8 + 2]) < 0)
      heap_Free(*(_QWORD **)(v29[i / 8 + 3] + 8), *(_QWORD *)&v28[i / 0x10 + 2]);
  }
  if (std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(v23, "\"onnx\"")
    && std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(v23, "\"CoreML\"")
    && !std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(v23, "\"melgan\""))
  {
    v8 = a1[1];
    v14 = *a1;
    v15 = (std::__shared_weak_count *)v8;
    if (v8)
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    v9 = a2[1];
    v12 = *a2;
    v13 = (std::__shared_weak_count *)v9;
    if (v9)
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    ENTTS::make_shared<MelganEngine,std::shared_ptr<IExternalServices> &,std::shared_ptr<IJsonWrapper> &>(&v14, &v12, v28);
    *(_OWORD *)a3 = v28[0];
    v10 = v13;
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    v11 = v15;
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
  if (v24 < 0)
    heap_Free(*(_QWORD **)(v25 + 8), (uint64_t)v23[0]);
}

void sub_214E8746C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a21);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<MelganEngine>::shared_ptr[abi:ne180100]<MelganEngine,ENTTS::Deleter<MelganEngine>,ENTTS::Allocator<MelganEngine>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29C030;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214E87590(void *a1)
{
  MelganEngine *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  if (v1)
  {
    MelganEngine::~MelganEngine(v1);
    operator delete(v2);
  }
  __cxa_rethrow();
}

void sub_214E875AC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

MelganEngine *std::__shared_ptr_pointer<MelganEngine *,ENTTS::Deleter<MelganEngine>,ENTTS::Allocator<MelganEngine>>::__on_zero_shared(uint64_t a1)
{
  MelganEngine *result;
  uint64_t v2;

  result = *(MelganEngine **)(a1 + 24);
  if (result)
  {
    MelganEngine::~MelganEngine(result);
    return (MelganEngine *)operator delete(v2);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MelganEngine *,ENTTS::Deleter<MelganEngine>,ENTTS::Allocator<MelganEngine>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<MelganEngine *,ENTTS::Deleter<MelganEngine>,ENTTS::Allocator<MelganEngine>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

void VocoderStreamer::init_engine(uint64_t a1, uint64_t *a2)
{
  int v3;
  int v4;
  int v5;
  int v6;
  unint64_t v7;
  unsigned int v8;
  void **v9;
  uint64_t *v10;
  uint64_t v11;
  unsigned int v12;
  double v13;
  float *v14;
  uint64_t v15;
  float v16;
  uint64_t v17;
  float v18;

  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]((_QWORD *)a1, a2);
  v3 = *(_DWORD *)(a1 + 24);
  v5 = *(_DWORD *)(a1 + 44);
  v4 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 184) = v3;
  *(_DWORD *)(a1 + 188) = v4;
  v6 = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 192) = v6;
  *(_DWORD *)(a1 + 196) = v4 - 3;
  *(_DWORD *)(a1 + 200) = v5;
  *(_DWORD *)(a1 + 204) = v6 + v4 + v5;
  v7 = (v4 * v3);
  *(_DWORD *)(a1 + 208) = v7;
  *(_DWORD *)(a1 + 212) = v6 * v3;
  v8 = (v4 - 3) * v3;
  v9 = (void **)(a1 + 216);
  std::vector<float,ENTTS::Allocator<float>>::resize((uint64_t *)(a1 + 216), v7);
  v10 = (uint64_t *)(a1 + 248);
  std::vector<float,ENTTS::Allocator<float>>::resize(v10, v7);
  if (v8)
    bzero(*v9, 4 * v8);
  if (v3)
  {
    v11 = 0;
    v12 = 3 * v3 - 1;
    v13 = 1.0 / (double)v12;
    v14 = (float *)*v9;
    if ((3 * v3) <= 1)
      v15 = 1;
    else
      v15 = (3 * v3);
    do
    {
      v16 = v13 * (double)v11;
      v14[v8 + v11++] = v16;
    }
    while (v15 != v11);
    if (v8)
      memset_pattern16((void *)*v10, &unk_214FBF630, 4 * v8);
    v17 = *v10;
    do
    {
      v18 = v13 * (double)v12;
      *(float *)(v17 + 4 * v8++) = v18;
      --v12;
      --v15;
    }
    while (v15);
  }
}

uint64_t VocoderStreamer::VocoderStreamer(uint64_t a1, uint64_t *a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  ModelParameters::ModelParameters((ModelParameters *)(a1 + 16));
  v4 = *(_DWORD *)(a1 + 24);
  v6 = *(_DWORD *)(a1 + 44);
  v5 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 184) = v4;
  *(_DWORD *)(a1 + 188) = v5;
  v7 = *(_QWORD *)(a1 + 52);
  *(_QWORD *)(a1 + 192) = v7;
  *(_DWORD *)(a1 + 200) = v6;
  *(_DWORD *)(a1 + 204) = v7 + v5 + v6;
  *(_DWORD *)(a1 + 208) = v5 * v4;
  *(_DWORD *)(a1 + 212) = v7 * v4;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  v8 = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 240) = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = v8;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = v8;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 336) = v8;
  *(_BYTE *)(a1 + 344) = 1;
  VocoderStreamer::init_engine(a1, a2);
  return a1;
}

void sub_214E87844(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  ModelParameters *v3;
  va_list va;

  va_start(va, a2);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  ModelParameters::~ModelParameters(v3);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

uint64_t VocoderStreamer::VocoderStreamer(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v5 = (std::__shared_weak_count *)a3[1];
  v13 = *a3;
  v14 = v5;
  if (v5)
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  ModelParameters::ModelParameters(a1 + 16, &v13);
  v6 = v14;
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  v7 = *(_DWORD *)(a1 + 24);
  v9 = *(_DWORD *)(a1 + 44);
  v8 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 184) = v7;
  *(_DWORD *)(a1 + 188) = v8;
  v10 = *(_QWORD *)(a1 + 52);
  *(_QWORD *)(a1 + 192) = v10;
  *(_DWORD *)(a1 + 200) = v9;
  *(_DWORD *)(a1 + 204) = v10 + v8 + v9;
  *(_DWORD *)(a1 + 208) = v8 * v7;
  *(_DWORD *)(a1 + 212) = v10 * v7;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  v11 = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 240) = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = v11;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = v11;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 336) = v11;
  *(_BYTE *)(a1 + 344) = 1;
  VocoderStreamer::init_engine(a1, a2);
  return a1;
}

void sub_214E879BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  ModelParameters *v5;
  va_list va;

  va_start(va, a4);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  ModelParameters::~ModelParameters(v5);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v4);
  _Unwind_Resume(a1);
}

uint64_t *VocoderStreamer::pad_input(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, unsigned int a6)
{
  uint64_t *v11;
  uint64_t v12;
  _QWORD v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (a6)
  {
    v11 = result;
    std::vector<float,ENTTS::Allocator<float>>::resize(a4, (*(_DWORD *)(*(_QWORD *)a3 + 8) + a6) * *((_DWORD *)result + 8));
    memcpy((void *)*a4, *(const void **)a2, *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
    v12 = *(_QWORD *)(*(_QWORD *)a3 + 8) + a6;
    v13[0] = 1;
    v13[1] = v12;
    v13[2] = *((unsigned int *)v11 + 8);
    return std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a5, (char *)v13, (uint64_t)&v14, 3uLL);
  }
  else
  {
    if (a4 != (uint64_t *)a2)
      result = std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a4, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
    if (a5 != (uint64_t *)a3)
      return std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a5, *(char **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3);
  }
  return result;
}

uint64_t **VocoderStreamer::do_inference_chunk(uint64_t **result, _QWORD *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, int a6)
{
  char v6;
  uint64_t **v8;
  int v9;
  char v10;
  BOOL v11;
  _BOOL4 v12;
  float *v13;
  uint64_t v14;
  unint64_t v15;
  float v16;

  v6 = a6;
  v8 = result;
  v9 = *((unsigned __int8 *)result + 344);
  v10 = a6 ^ 1;
  if (!*((_BYTE *)result + 344) || ((a6 ^ 1) & 1) != 0)
  {
    if (!*((_BYTE *)result + 344) || (a6 & 1) != 0)
    {
      v11 = v9 == 0;
      v12 = v9 != 0;
      if (!v11)
        v10 = 1;
      if ((v10 & 1) != 0)
      {
        if (((v12 | a6) & 1) == 0)
          result = VocoderStreamer::middle_segment_inference((uint64_t)result, (uint64_t)a2, a3, a4, a5);
      }
      else
      {
        result = VocoderStreamer::end_segment_inference((uint64_t)result, (uint64_t)a2, a3, a4, a5);
      }
    }
    else
    {
      result = VocoderStreamer::start_segment_inference(result, a2, a3, a4, a5);
    }
  }
  else
  {
    result = VocoderStreamer::compute_full_chuck(result, (uint64_t)a2, a3, a4, a5);
  }
  v13 = (float *)*a4;
  v14 = a4[1] - *a4;
  if (v14)
  {
    v15 = v14 >> 2;
    if (v15 <= 1)
      v15 = 1;
    do
    {
      v16 = 1.0;
      if (*v13 > 1.0 || (v16 = -1.0, *v13 < -1.0))
        *v13 = v16;
      ++v13;
      --v15;
    }
    while (v15);
  }
  *((_BYTE *)v8 + 344) = v6;
  return result;
}

uint64_t **VocoderStreamer::compute_full_chuck(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  int v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t **v12;
  uint64_t *v14[4];
  void *__src[4];
  uint64_t *v16[4];
  uint64_t v17[4];
  int64x2_t v18;
  unint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v17[3] = CustomAllocator::mRsrc;
  memset(v16, 0, 24);
  v16[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(__src, 0, 24);
  __src[3] = (void *)CustomAllocator::mRsrc;
  memset(v14, 0, 24);
  v14[3] = (uint64_t *)CustomAllocator::mRsrc;
  v8 = *(_DWORD *)(*(_QWORD *)a3 + 8);
  if (*((_DWORD *)a1 + 15))
    v9 = *((_DWORD *)a1 + 51) - v8;
  else
    v9 = 0;
  VocoderStreamer::pad_input(a1, a2, a3, v17, (uint64_t *)v16, v9);
  (**(void (***)(_QWORD, uint64_t *, uint64_t **, void **, uint64_t **))*a1)(*a1, v17, v16, __src, v14);
  v10 = (*((_DWORD *)a1 + 46) * v8);
  std::vector<float,ENTTS::Allocator<float>>::resize(a4, v10);
  memcpy((void *)*a4, __src[0], 4 * v10);
  v18 = vdupq_n_s64(1uLL);
  v19 = v10;
  v11 = std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a5, v18.i8, (uint64_t)&v20, 3uLL);
  v12 = VocoderStreamer::initial_fade_in((uint64_t)v11, a4);
  VocoderStreamer::final_fade_out((uint64_t)v12, a4);
  v18.i64[0] = (uint64_t)v14;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v18);
  v14[0] = (uint64_t *)__src;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v14);
  __src[0] = v16;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)__src);
  v16[0] = v17;
  return std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v16);
}

void sub_214E87DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t ***a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t **a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  uint64_t v21;

  *(_QWORD *)(v21 - 64) = &a9;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v21 - 64));
  a9 = &a13;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a9);
  a13 = (uint64_t **)&a17;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a13);
  a17 = &a21;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a17);
  _Unwind_Resume(a1);
}

uint64_t **VocoderStreamer::start_segment_inference(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  int v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t *v12;
  int v13;
  int v14;
  int v15;
  uint64_t *v16;
  uint64_t *v18[4];
  void *__src[4];
  uint64_t *v20[4];
  uint64_t v21[4];
  int64x2_t v22;
  unint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  memset(v21, 0, 24);
  v21[3] = CustomAllocator::mRsrc;
  memset(v20, 0, 24);
  v20[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(__src, 0, 24);
  __src[3] = (void *)CustomAllocator::mRsrc;
  memset(v18, 0, 24);
  v18[3] = (uint64_t *)CustomAllocator::mRsrc;
  v9 = *(_DWORD *)(*(_QWORD *)a3 + 8);
  if (*((_DWORD *)a1 + 15))
    v10 = *((_DWORD *)a1 + 51) - v9;
  else
    v10 = 0;
  VocoderStreamer::pad_input(a1, (uint64_t)a2, a3, v21, (uint64_t *)v20, v10);
  (**(void (***)(_QWORD, uint64_t *, uint64_t **, void **, uint64_t **))*a1)(*a1, v21, v20, __src, v18);
  v11 = ((v9 - (*((_DWORD *)a1 + 47) + *((_DWORD *)a1 + 48))) * *((_DWORD *)a1 + 46));
  std::vector<float,ENTTS::Allocator<float>>::resize(a4, v11);
  memcpy((void *)*a4, __src[0], 4 * v11);
  v22 = vdupq_n_s64(1uLL);
  v23 = v11;
  v12 = std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a5, v22.i8, (uint64_t)&v24, 3uLL);
  VocoderStreamer::initial_fade_in((uint64_t)v12, a4);
  v13 = *((_DWORD *)a1 + 48) + *((_DWORD *)a1 + 47);
  std::vector<float,ENTTS::Allocator<float>>::resize(a1 + 39, (v13 * *((_DWORD *)a1 + 8)));
  memcpy((void *)a1[39], (const void *)(*a2 + 4 * (*((_DWORD *)a1 + 8) * (v9 - v13))), 4 * (*((_DWORD *)a1 + 8) * v13));
  LODWORD(v11) = *((_DWORD *)a1 + 47);
  v14 = *((_DWORD *)a1 + 48);
  v15 = *((_DWORD *)a1 + 46);
  v16 = a1 + 35;
  std::vector<float,ENTTS::Allocator<float>>::resize(v16, (v15 * v11));
  memcpy((void *)*v16, (char *)__src[0] + 4 * ((v9 - (v11 + v14)) * v15), 4 * (v15 * v11));
  v22.i64[0] = (uint64_t)v18;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v22);
  v18[0] = (uint64_t *)__src;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v18);
  __src[0] = v20;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)__src);
  v20[0] = v21;
  return std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v20);
}

void sub_214E88008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t ***a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t **a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  uint64_t v21;

  *(_QWORD *)(v21 - 80) = &a9;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v21 - 80));
  a9 = &a13;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a9);
  a13 = (uint64_t **)&a17;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a13);
  a17 = &a21;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a17);
  _Unwind_Resume(a1);
}

uint64_t **VocoderStreamer::end_segment_inference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  float *v16;
  unint64_t v17;
  float *v18;
  float *v19;
  float *v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  uint64_t *v27[4];
  void *__src[4];
  uint64_t *v29[4];
  void *__dst[4];
  int64x2_t v31;
  unint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  memset(__dst, 0, 24);
  __dst[3] = (void *)CustomAllocator::mRsrc;
  memset(v29, 0, 24);
  v29[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(__src, 0, 24);
  __src[3] = (void *)CustomAllocator::mRsrc;
  memset(v27, 0, 24);
  v27[3] = (uint64_t *)CustomAllocator::mRsrc;
  v9 = *(_DWORD *)(*(_QWORD *)a3 + 8);
  v10 = *(_DWORD *)(a1 + 188) + *(_DWORD *)(a1 + 192) + v9;
  v11 = *(_DWORD *)(a1 + 60);
  if (v11)
    v11 = *(_DWORD *)(a1 + 204) - v10;
  v12 = (v11 + v10);
  std::vector<float,ENTTS::Allocator<float>>::resize((uint64_t *)__dst, (*(_DWORD *)(a1 + 32) * v12));
  memcpy(__dst[0], *(const void **)(a1 + 312), 4 * ((*(_DWORD *)(a1 + 192) + *(_DWORD *)(a1 + 188)) * *(_DWORD *)(a1 + 32)));
  memcpy((char *)__dst[0] + 4 * ((*(_DWORD *)(a1 + 192) + *(_DWORD *)(a1 + 188)) * *(_DWORD *)(a1 + 32)), *(const void **)a2, *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  v31.i64[0] = 1;
  v31.i64[1] = v12;
  v32 = *(unsigned int *)(a1 + 32);
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>((uint64_t *)v29, v31.i8, (uint64_t)&v33, 3uLL);
  (***(void (****)(_QWORD, void **, uint64_t **, void **, uint64_t **))a1)(*(_QWORD *)a1, __dst, v29, __src, v27);
  v13 = ((*(_DWORD *)(a1 + 188) + v9) * *(_DWORD *)(a1 + 184));
  std::vector<float,ENTTS::Allocator<float>>::resize(a4, v13);
  memcpy((void *)*a4, __src[0], 4 * v13);
  v31 = vdupq_n_s64(1uLL);
  v32 = v13;
  v14 = std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a5, v31.i8, (uint64_t)&v33, 3uLL);
  LODWORD(v15) = *(_DWORD *)(a1 + 184) * *(_DWORD *)(a1 + 188);
  v16 = (float *)*a4;
  v17 = (unint64_t)(a4[1] - *a4) >> 2;
  if (v15 >= v17)
    v15 = v17;
  else
    v15 = v15;
  if ((_DWORD)v15)
  {
    v18 = *(float **)(a1 + 216);
    v19 = *(float **)(a1 + 280);
    v20 = *(float **)(a1 + 248);
    do
    {
      v21 = *v18++;
      v22 = v21;
      v23 = *v19++;
      v24 = v23;
      v25 = *v20++;
      *v16 = (float)(v24 * v25) + (float)(*v16 * v22);
      ++v16;
      --v15;
    }
    while (v15);
  }
  VocoderStreamer::final_fade_out((uint64_t)v14, a4);
  v31.i64[0] = (uint64_t)v27;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v31);
  v27[0] = (uint64_t *)__src;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v27);
  __src[0] = v29;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)__src);
  v29[0] = (uint64_t *)__dst;
  return std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v29);
}

void sub_214E882A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t ***a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t **a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  uint64_t v21;

  *(_QWORD *)(v21 - 80) = &a9;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v21 - 80));
  a9 = &a13;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a9);
  a13 = (uint64_t **)&a17;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a13);
  a17 = &a21;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a17);
  _Unwind_Resume(a1);
}

uint64_t **VocoderStreamer::middle_segment_inference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  float *v14;
  float *v15;
  float *v16;
  float *v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unint64_t v27;
  uint64_t *v28;
  uint64_t *v30[4];
  void *__src[4];
  uint64_t *v32[4];
  void *__dst[4];
  int64x2_t v34;
  unint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  memset(__dst, 0, 24);
  v9 = (*(_DWORD *)(a1 + 204) * *(_DWORD *)(a1 + 32));
  __dst[3] = (void *)CustomAllocator::mRsrc;
  memset(v32, 0, 24);
  v32[3] = (uint64_t *)CustomAllocator::mRsrc;
  memset(__src, 0, 24);
  __src[3] = (void *)CustomAllocator::mRsrc;
  memset(v30, 0, 24);
  v30[3] = (uint64_t *)CustomAllocator::mRsrc;
  std::vector<float,ENTTS::Allocator<float>>::resize((uint64_t *)__dst, v9);
  memcpy(__dst[0], *(const void **)(a1 + 312), 4 * ((*(_DWORD *)(a1 + 192) + *(_DWORD *)(a1 + 188)) * *(_DWORD *)(a1 + 32)));
  memcpy((char *)__dst[0] + 4 * ((*(_DWORD *)(a1 + 192) + *(_DWORD *)(a1 + 188)) * *(_DWORD *)(a1 + 32)), *(const void **)a2, *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  v10 = *(unsigned int *)(a1 + 204);
  v34.i64[0] = 1;
  v34.i64[1] = v10;
  v35 = *(unsigned int *)(a1 + 32);
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>((uint64_t *)v32, v34.i8, (uint64_t)&v36, 3uLL);
  (***(void (****)(_QWORD, void **, uint64_t **, void **, uint64_t **))a1)(*(_QWORD *)a1, __dst, v32, __src, v30);
  v11 = (*(_DWORD *)(a1 + 184) * *(_DWORD *)(a1 + 200));
  std::vector<float,ENTTS::Allocator<float>>::resize(a4, v11);
  memcpy((void *)*a4, __src[0], 4 * v11);
  v34 = vdupq_n_s64(1uLL);
  v35 = v11;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a5, v34.i8, (uint64_t)&v36, 3uLL);
  v12 = *(_DWORD *)(a1 + 188);
  v13 = (*(_DWORD *)(a1 + 184) * v12);
  if ((_DWORD)v13)
  {
    v14 = (float *)*a4;
    v15 = *(float **)(a1 + 216);
    v16 = *(float **)(a1 + 280);
    v17 = *(float **)(a1 + 248);
    do
    {
      v18 = *v15++;
      v19 = v18;
      v20 = *v16++;
      v21 = v20;
      v22 = *v17++;
      *v14 = (float)(v21 * v22) + (float)(*v14 * v19);
      ++v14;
      --v13;
    }
    while (v13);
  }
  v23 = *(_DWORD *)(a1 + 200);
  v24 = *(_DWORD *)(a1 + 192) + v12;
  std::vector<float,ENTTS::Allocator<float>>::resize((uint64_t *)(a1 + 312), (v24 * *(_DWORD *)(a1 + 32)));
  memcpy(*(void **)(a1 + 312), (const void *)(*(_QWORD *)a2 + 4 * (*(_DWORD *)(a1 + 32) * (v23 - v24))), 4 * (*(_DWORD *)(a1 + 32) * v24));
  v25 = *(_DWORD *)(a1 + 184);
  v26 = *(_DWORD *)(a1 + 200);
  v27 = ((*(_DWORD *)(a1 + 204) - (v26 + *(_DWORD *)(a1 + 192))) * v25);
  v28 = (uint64_t *)(a1 + 280);
  std::vector<float,ENTTS::Allocator<float>>::resize(v28, v27);
  memcpy((void *)*v28, (char *)__src[0] + 4 * (v25 * v26), 4 * v27);
  v34.i64[0] = (uint64_t)v30;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v34);
  v30[0] = (uint64_t *)__src;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v30);
  __src[0] = v32;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)__src);
  v32[0] = (uint64_t *)__dst;
  return std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](v32);
}

void sub_214E88590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t ***a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t **a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  uint64_t v21;

  *(_QWORD *)(v21 - 80) = &a9;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v21 - 80));
  a9 = &a13;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a9);
  a13 = (uint64_t **)&a17;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a13);
  a17 = &a21;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a17);
  _Unwind_Resume(a1);
}

void VocoderStreamer::clip_pcm(uint64_t a1, uint64_t a2)
{
  float *v2;
  uint64_t v3;
  unint64_t v4;
  float v5;

  v2 = *(float **)a2;
  v3 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  if (v3)
  {
    v4 = v3 >> 2;
    if (v4 <= 1)
      v4 = 1;
    do
    {
      v5 = 1.0;
      if (*v2 > 1.0 || (v5 = -1.0, *v2 < -1.0))
        *v2 = v5;
      ++v2;
      --v4;
    }
    while (v4);
  }
}

uint64_t **VocoderStreamer::initial_fade_in(uint64_t a1, uint64_t *a2)
{
  float *v3;
  uint64_t v4;
  int64x2_t v5;
  uint64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  int64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t **result;
  void *__b[4];
  void **v18;

  if ((unint64_t)(a2[1] - *a2) >= 0x100)
  {
    std::vector<float,ENTTS::Allocator<float>>::vector((uint64_t *)__b, 0x40uLL);
    v3 = (float *)__b[0];
    memset_pattern16(__b[0], &unk_214FBF640, 0x40uLL);
    memset_pattern16(v3 + 16, &unk_214FBF640, 0x78uLL);
    v4 = 0;
    v5 = (int64x2_t)xmmword_214F962F0;
    v6 = (uint64x2_t)vdupq_n_s64(0x12uLL);
    v7 = (float64x2_t)vdupq_n_s64(0x3FAD83EA50F0F0F1uLL);
    v8 = (float64x2_t)vdupq_n_s64(0x3F947AE140000000uLL);
    v9 = vdupq_n_s64(2uLL);
    do
    {
      v10.f64[0] = (double)(int)v4;
      v10.f64[1] = (double)((int)v4 + 1);
      v11 = vmlaq_f64(v8, v7, v10);
      if ((vmovn_s64((int64x2_t)vcgtq_u64(v6, (uint64x2_t)v5)).u8[0] & 1) != 0)
      {
        v12 = v11.f64[0];
        v3[v4 + 46] = v12;
      }
      if ((vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x12uLL), *(uint64x2_t *)&v5)).i32[1] & 1) != 0)
      {
        v13 = v11.f64[1];
        v3[v4 + 47] = v13;
      }
      v4 += 2;
      v5 = vaddq_s64(v5, v9);
    }
    while (v4 != 18);
    v14 = 0;
    v15 = *a2;
    do
    {
      *(float *)(v15 + v14 * 4) = *(float *)(v15 + v14 * 4) * v3[v14];
      ++v14;
    }
    while (v14 != 64);
    v18 = __b;
    return std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v18);
  }
  return result;
}

uint64_t **VocoderStreamer::final_fade_out(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  int64x2_t v4;
  uint64_t v5;
  int64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  int64x2_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t **result;
  uint64_t v14[4];
  uint64_t *v15;

  if ((unint64_t)(a2[1] - *a2) >= 0x180)
  {
    std::vector<float,ENTTS::Allocator<float>>::vector(v14, 0x60uLL);
    v3 = 0;
    v4 = (int64x2_t)xmmword_214F962F0;
    v5 = v14[0];
    v6 = vdupq_n_s64(0x1FuLL);
    v7 = (float64x2_t)vdupq_n_s64(0x3FA06EFD06F7BDEFuLL);
    v8 = (float64x2_t)vdupq_n_s64(0x3F747AE140000000uLL);
    v9 = vdupq_n_s64(2uLL);
    do
    {
      *(float32x2_t *)(v5 + v3) = vcvt_f32_f64(vmlaq_f64(v8, v7, vcvtq_f64_u64((uint64x2_t)vsubq_s64(v6, v4))));
      v4 = vaddq_s64(v4, v9);
      v3 += 8;
    }
    while (v3 != 128);
    memset_pattern16((void *)(v5 + 128), &unk_214FBF650, 0xC0uLL);
    memset_pattern16((void *)(v5 + 320), &unk_214FBF650, 0x40uLL);
    v10 = 0;
    v11 = *a2;
    v12 = ((unint64_t)(a2[1] - *a2) >> 2) + 4294967199u;
    do
    {
      *(float *)(v11 + 4 * (v12 + v10)) = *(float *)(v11 + 4 * (v12 + v10))
                                                        * *(float *)(v5 + 4 * v10);
      ++v10;
    }
    while (v10 != 96);
    v15 = v14;
    return std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100](&v15);
  }
  return result;
}

uint64_t from_string_to_vocoder_type(const void **a1)
{
  uint64_t result;

  result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(a1, "\"onnx\"");
  if ((_DWORD)result)
    return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::compare(a1, "\"melgan\"") == 0;
  return result;
}

_QWORD *from_vocoder_type_to_string@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  char *v2;

  if (a1 == 1)
    v2 = "melgan";
  else
    v2 = "onnx";
  return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a2, v2);
}

uint64_t *transpose_3Dtensor(int **a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t *result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  uint64_t v15;
  int *v16;
  _DWORD *v17;
  uint64_t i;
  int v19;
  _QWORD v20[3];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  a3[1] = *a3;
  std::vector<float,ENTTS::Allocator<float>>::resize(a3, *(_QWORD *)(*a2 + 16) * *(_QWORD *)(*a2 + 8));
  v8 = *a2;
  v9 = *(_QWORD *)(*a2 + 16);
  v20[0] = 1;
  v20[1] = v9;
  v20[2] = *(_QWORD *)(v8 + 8);
  result = std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a4, (char *)v20, (uint64_t)&v21, 3uLL);
  v11 = *(_QWORD *)(*a2 + 8);
  if (v11)
  {
    v12 = 0;
    v13 = *(_QWORD *)(*a2 + 16);
    v14 = *a1;
    v15 = *a3;
    do
    {
      v16 = v14;
      v17 = (_DWORD *)v15;
      for (i = v13; i; --i)
      {
        v19 = *v16++;
        *v17 = v19;
        v17 += v11;
      }
      ++v12;
      v15 += 4;
      v14 += v13;
    }
    while (v12 != v11);
  }
  return result;
}

uint64_t print_shape<unsigned long long>@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  size_t v10;
  uint64_t v11[2];
  char v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  char __str[32];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  result = (uint64_t)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a2, "");
  v5 = *a1;
  if (a1[1] != *a1)
  {
    v6 = 0;
    do
    {
      snprintf(__str, 0x20uLL, "%llu", *(_QWORD *)(v5 + 8 * v6));
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v11, __str);
      v7 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)v11, " ", 1uLL);
      v8 = *(_QWORD *)(v7 + 16);
      v14 = *(_OWORD *)v7;
      v15 = v8;
      v16 = CustomAllocator::mRsrc;
      *(_QWORD *)(v7 + 8) = 0;
      *(_QWORD *)(v7 + 16) = 0;
      *(_QWORD *)v7 = 0;
      if (v15 >= 0)
        v9 = &v14;
      else
        v9 = (__int128 *)v14;
      if (v15 >= 0)
        v10 = HIBYTE(v15);
      else
        v10 = *((_QWORD *)&v14 + 1);
      result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)a2, v9, v10);
      if (SHIBYTE(v15) < 0)
        result = (uint64_t)heap_Free(*(_QWORD **)(v16 + 8), v14);
      if (v12 < 0)
        result = (uint64_t)heap_Free(*(_QWORD **)(v13 + 8), v11[0]);
      ++v6;
      v5 = *a1;
    }
    while (v6 < (a1[1] - *a1) >> 3);
  }
  return result;
}

void sub_214E88B78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void zero_upsampling(int **a1, _QWORD *a2, uint64_t *a3, unsigned int a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  int *v13;
  _DWORD *v14;
  uint64_t i;
  int v16;

  v7 = a4 + 1;
  std::vector<float,ENTTS::Allocator<float>>::resize(a3, a2[1] * *a2 * a2[3] * (a2[2] * v7 - a4));
  v8 = a2[2];
  if (v8)
  {
    v9 = 0;
    v10 = a2[3];
    v11 = *a1;
    v12 = *a3;
    do
    {
      v13 = v11;
      v14 = (_DWORD *)v12;
      for (i = v10; i; --i)
      {
        v16 = *v13++;
        *v14++ = v16;
      }
      ++v9;
      v12 += 4 * v10 * v7;
      v11 += v10;
    }
    while (v9 != v8);
  }
}

uint64_t cpu_affinity_isset()
{
  return 0;
}

uint64_t affinity_parser@<X0>(char *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result;
  uint64_t *v5;
  uint64_t *v6;
  int64_t v7;
  uint64_t v8;
  char *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  int v16;
  int v17;
  _DWORD *v18;
  unint64_t v19;
  _DWORD *v20;
  _DWORD *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _DWORD *v27;
  _DWORD *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  _DWORD *v34;
  unint64_t v35;
  _DWORD *v36;
  _DWORD *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _DWORD *v43;
  _DWORD *v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48[2];
  unsigned __int8 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  unsigned __int8 v57;
  uint64_t v58;
  uint64_t v59;
  __int128 __dst;
  _DWORD *v61;
  uint64_t v62;
  _QWORD *v63;

  a2[3] = CustomAllocator::mRsrc;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v55, ",");
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = CustomAllocator::mRsrc;
  for (result = (uint64_t)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v48, a1);
        ;
        result = (uint64_t)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::erase(v48, 0, v32 + v14))
  {
    v5 = (v49 & 0x80u) == 0 ? v48 : (uint64_t *)v48[0];
    v6 = (v57 & 0x80u) == 0 ? (uint64_t *)&v55 : v55;
    v7 = (v57 & 0x80u) == 0 ? v57 : v56;
    if (v7)
      break;
    v14 = 0;
LABEL_25:
    v59 = CustomAllocator::mRsrc;
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string(&__dst, v48, 0, v14);
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)&v51, &__dst);
    if (SHIBYTE(v61) < 0)
      heap_Free(*(_QWORD **)(v62 + 8), __dst);
    v15 = HIBYTE(v53);
    if (v53 < 0)
      v15 = v52;
    if (v15)
    {
      v16 = ENTTS::stoi((uint64_t)&v51, 0, 10);
      v17 = v16;
      v18 = (_DWORD *)a2[1];
      v19 = a2[2];
      if ((unint64_t)v18 >= v19)
      {
        v21 = (_DWORD *)*a2;
        v22 = ((uint64_t)v18 - *a2) >> 2;
        v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 62)
          std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
        v24 = v19 - (_QWORD)v21;
        if (v24 >> 1 > v23)
          v23 = v24 >> 1;
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
          v25 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v25 = v23;
        v63 = a2 + 3;
        if (v25)
        {
          v26 = ENTTS::Allocator<int>::allocate((uint64_t)(a2 + 3), v25);
          v21 = (_DWORD *)*a2;
          v18 = (_DWORD *)a2[1];
        }
        else
        {
          v26 = 0;
        }
        v27 = (_DWORD *)(v26 + 4 * v22);
        *v27 = v17;
        if (v18 == v21)
        {
          v29 = v26 + 4 * v22;
        }
        else
        {
          v28 = v18;
          v29 = v26 + 4 * v22;
          do
          {
            v30 = *--v28;
            *(_DWORD *)(v29 - 4) = v30;
            v29 -= 4;
          }
          while (v28 != v21);
        }
        v20 = v27 + 1;
        *a2 = v29;
        a2[1] = (uint64_t)(v27 + 1);
        v31 = a2[2];
        a2[2] = v26 + 4 * v25;
        v61 = v18;
        v62 = v31;
        *(_QWORD *)&__dst = v21;
        *((_QWORD *)&__dst + 1) = v21;
        std::__split_buffer<unsigned int,ENTTS::Allocator<unsigned int> &>::~__split_buffer((uint64_t)&__dst);
      }
      else
      {
        *v18 = v16;
        v20 = v18 + 1;
      }
      a2[1] = (uint64_t)v20;
    }
    v32 = v57;
    if ((v57 & 0x80u) != 0)
      v32 = v56;
  }
  if ((v49 & 0x80u) == 0)
    v8 = v49;
  else
    v8 = v48[1];
  if (v8 >= v7)
  {
    v9 = (char *)v5 + v8;
    v10 = *(char *)v6;
    v11 = v8;
    result = (uint64_t)v5;
    do
    {
      v12 = v11 - v7;
      if (v12 == -1)
        break;
      result = (uint64_t)memchr((void *)result, v10, v12 + 1);
      if (!result)
        break;
      v13 = result;
      result = memcmp((const void *)result, v6, v7);
      if (!(_DWORD)result)
      {
        if ((char *)v13 == v9)
          break;
        v14 = v13 - (_QWORD)v5;
        if (v13 - (_QWORD)v5 == -1)
          break;
        goto LABEL_25;
      }
      result = v13 + 1;
      v11 = (uint64_t)&v9[-v13 - 1];
    }
    while (v11 >= v7);
  }
  if (v8)
  {
    result = ENTTS::stoi((uint64_t)v48, 0, 10);
    v33 = result;
    v34 = (_DWORD *)a2[1];
    v35 = a2[2];
    if ((unint64_t)v34 >= v35)
    {
      v37 = (_DWORD *)*a2;
      v38 = ((uint64_t)v34 - *a2) >> 2;
      v39 = v38 + 1;
      if ((unint64_t)(v38 + 1) >> 62)
        std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
      v40 = v35 - (_QWORD)v37;
      if (v40 >> 1 > v39)
        v39 = v40 >> 1;
      if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFFCLL)
        v41 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v41 = v39;
      v63 = a2 + 3;
      if (v41)
      {
        v42 = ENTTS::Allocator<int>::allocate((uint64_t)(a2 + 3), v41);
        v37 = (_DWORD *)*a2;
        v34 = (_DWORD *)a2[1];
      }
      else
      {
        v42 = 0;
      }
      v43 = (_DWORD *)(v42 + 4 * v38);
      *v43 = v33;
      if (v34 == v37)
      {
        v45 = v42 + 4 * v38;
      }
      else
      {
        v44 = v34;
        v45 = v42 + 4 * v38;
        do
        {
          v46 = *--v44;
          *(_DWORD *)(v45 - 4) = v46;
          v45 -= 4;
        }
        while (v44 != v37);
      }
      v36 = v43 + 1;
      *a2 = v45;
      a2[1] = (uint64_t)(v43 + 1);
      v47 = a2[2];
      a2[2] = v42 + 4 * v41;
      v61 = v34;
      v62 = v47;
      *(_QWORD *)&__dst = v37;
      *((_QWORD *)&__dst + 1) = v37;
      result = std::__split_buffer<unsigned int,ENTTS::Allocator<unsigned int> &>::~__split_buffer((uint64_t)&__dst);
    }
    else
    {
      *v34 = result;
      v36 = v34 + 1;
    }
    a2[1] = (uint64_t)v36;
  }
  if ((char)v49 < 0)
    result = (uint64_t)heap_Free(*(_QWORD **)(v50 + 8), v48[0]);
  if (SHIBYTE(v53) < 0)
    result = (uint64_t)heap_Free(*(_QWORD **)(v54 + 8), v51);
  if ((char)v57 < 0)
    return (uint64_t)heap_Free(*(_QWORD **)(v58 + 8), (uint64_t)v55);
  return result;
}

void sub_214E89080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int __src, std::exception a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t *v26;

  if (a2 == 1)
  {
    __cxa_get_exception_ptr(a1);
    a12.__vftable = (std::exception_vtbl *)(MEMORY[0x24BEDB8F0] + 16);
    __cxa_begin_catch(a1);
    __src = 0;
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v26, (char *)&__src, (uint64_t)&a12, 1uLL);
    std::exception::~exception(&a12);
    __cxa_end_catch();
    JUMPOUT(0x214E89000);
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a13);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a17);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a21);
  a21 = v26;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

uint64_t std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v4;

  if (*(char *)(a1 + 23) < 0)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 24) + 8), *(_QWORD *)a1);
    *(_BYTE *)(a1 + 23) = 0;
    *(_BYTE *)a1 = 0;
  }
  v4 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((_BYTE *)a2 + 23) = 0;
  *(_BYTE *)a2 = 0;
  return a1;
}

uint64_t *std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::erase(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4;
  uint64_t *v5;

  if (*((char *)a1 + 23) < 0)
    v4 = a1[1];
  else
    v4 = *((unsigned __int8 *)a1 + 23);
  if (v4 < a2)
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_out_of_range[abi:ne180100]();
  if (a3 == -1)
  {
    if ((*((_BYTE *)a1 + 23) & 0x80) != 0)
    {
      v5 = (uint64_t *)*a1;
      a1[1] = a2;
    }
    else
    {
      *((_BYTE *)a1 + 23) = a2 & 0x7F;
      v5 = a1;
    }
    *((_BYTE *)v5 + a2) = 0;
  }
  else
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__erase_external_with_move(a1, a2, a3);
  }
  return a1;
}

uint64_t affinity_safeguard24(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v3 = *a1;
  v2 = a1[1];
  v4 = v2 - *a1;
  if (v4 < 0x11)
  {
    if (v4 == 12)
    {
      v2 -= 4;
      a1[1] = v2;
    }
  }
  else
  {
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::resize(a1, 4uLL);
    v3 = *a1;
    v2 = a1[1];
  }
  return (v2 - v3) >> 2;
}

void std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (a1[1] - *a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      a1[1] = *a1 + 4 * a2;
  }
  else
  {
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__append(a1, a2 - v2);
  }
}

_QWORD *BOOL_to_string@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  char *v2;

  if (a1)
    v2 = "true";
  else
    v2 = "false";
  return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a2, v2);
}

uint64_t print_shape<unsigned int>@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  size_t v10;
  uint64_t v11[2];
  char v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  char __str[32];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  result = (uint64_t)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a2, "");
  v5 = *a1;
  if (a1[1] != *a1)
  {
    v6 = 0;
    do
    {
      snprintf(__str, 0x20uLL, "%u", *(_DWORD *)(v5 + 4 * v6));
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v11, __str);
      v7 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)v11, " ", 1uLL);
      v8 = *(_QWORD *)(v7 + 16);
      v14 = *(_OWORD *)v7;
      v15 = v8;
      v16 = CustomAllocator::mRsrc;
      *(_QWORD *)(v7 + 8) = 0;
      *(_QWORD *)(v7 + 16) = 0;
      *(_QWORD *)v7 = 0;
      if (v15 >= 0)
        v9 = &v14;
      else
        v9 = (__int128 *)v14;
      if (v15 >= 0)
        v10 = HIBYTE(v15);
      else
        v10 = *((_QWORD *)&v14 + 1);
      result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)a2, v9, v10);
      if (SHIBYTE(v15) < 0)
        result = (uint64_t)heap_Free(*(_QWORD **)(v16 + 8), v14);
      if (v12 < 0)
        result = (uint64_t)heap_Free(*(_QWORD **)(v13 + 8), v11[0]);
      ++v6;
      v5 = *a1;
    }
    while (v6 < (a1[1] - *a1) >> 2);
  }
  return result;
}

void sub_214E89448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t print_shape<unsigned long>@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  size_t v10;
  uint64_t v11[2];
  char v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  char __str[32];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  result = (uint64_t)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a2, "");
  v5 = *a1;
  if (a1[1] != *a1)
  {
    v6 = 0;
    do
    {
      snprintf(__str, 0x20uLL, "%lu", *(_QWORD *)(v5 + 8 * v6));
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v11, __str);
      v7 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)v11, " ", 1uLL);
      v8 = *(_QWORD *)(v7 + 16);
      v14 = *(_OWORD *)v7;
      v15 = v8;
      v16 = CustomAllocator::mRsrc;
      *(_QWORD *)(v7 + 8) = 0;
      *(_QWORD *)(v7 + 16) = 0;
      *(_QWORD *)v7 = 0;
      if (v15 >= 0)
        v9 = &v14;
      else
        v9 = (__int128 *)v14;
      if (v15 >= 0)
        v10 = HIBYTE(v15);
      else
        v10 = *((_QWORD *)&v14 + 1);
      result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)a2, v9, v10);
      if (SHIBYTE(v15) < 0)
        result = (uint64_t)heap_Free(*(_QWORD **)(v16 + 8), v14);
      if (v12 < 0)
        result = (uint64_t)heap_Free(*(_QWORD **)(v13 + 8), v11[0]);
      ++v6;
      v5 = *a1;
    }
    while (v6 < (a1[1] - *a1) >> 3);
  }
  return result;
}

void sub_214E895EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

double get_vector_sum<double>(double **a1)
{
  double *v1;
  double result;
  double v3;

  v1 = *a1;
  result = 0.0;
  while (v1 != a1[1])
  {
    v3 = *v1++;
    result = result + v3;
  }
  return result;
}

double get_vector_average<double>(double **a1)
{
  double *v1;
  double v2;
  double *v3;
  double v4;

  v1 = a1[1];
  v2 = 0.0;
  if (*a1 != v1)
  {
    v3 = *a1;
    do
    {
      v4 = *v3++;
      v2 = v2 + v4;
    }
    while (v3 != v1);
  }
  return v2 / (double)(int)((unint64_t)((char *)v1 - (char *)*a1) >> 3);
}

uint64_t **vector_percentiles<double>(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  uint64_t v13[4];
  uint64_t *v14;

  v7 = *(const void **)a1;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = v8 - *(_QWORD *)a1;
  memset(v13, 0, 24);
  v13[3] = CustomAllocator::mRsrc;
  std::vector<double,ENTTS::Allocator<double>>::__init_with_size[abi:ne180100]<double *,double *>(v13, v7, v8, v9 >> 3);
  std::__sort<std::__less<double,double> &,double *>();
  v10 = (double)(int)((unint64_t)v9 >> 3);
  v11 = v13[0];
  *a2 = *(_QWORD *)(v13[0] + 8 * (unint64_t)(v10 * 0.5 + -1.0));
  *a3 = *(_QWORD *)(v11 + 8 * (unint64_t)(v10 * 0.9 + -1.0));
  *a4 = *(_QWORD *)(v11 + 8 * (unint64_t)(v10 * 0.99 + -1.0));
  v14 = v13;
  return std::vector<double,ENTTS::Allocator<double>>::__destroy_vector::operator()[abi:ne180100](&v14);
}

void sub_214E89760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::vector<double,ENTTS::Allocator<double>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  _Unwind_Resume(a1);
}

double time_elapsed(uint64_t a1, uint64_t a2)
{
  return (double)(a2 - a1) / 1000.0 / 1000.0 / 1000.0;
}

_QWORD *std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string(_QWORD *__dst, uint64_t *a2, unint64_t a3, size_t a4)
{
  uint64_t *v5;
  char *v7;
  unint64_t v8;
  size_t v9;
  size_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;

  v5 = a2;
  __dst[3] = CustomAllocator::mRsrc;
  v7 = (char *)(__dst + 3);
  if (*((char *)a2 + 23) < 0)
  {
    v8 = a2[1];
    if (v8 < a3)
      goto LABEL_18;
    v5 = (uint64_t *)*a2;
  }
  else
  {
    v8 = *((unsigned __int8 *)a2 + 23);
    if (v8 < a3)
LABEL_18:
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_out_of_range[abi:ne180100]();
  }
  v9 = v8 - a3;
  if (v9 >= a4)
    v10 = a4;
  else
    v10 = v9;
  if (v10 >= 0x7FFFFFFFFFFFFFF8)
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]();
  if (v10 >= 0x17)
  {
    v12 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v12 = v10 | 7;
    v13 = v12 + 1;
    v11 = (void *)ENTTS::Allocator<char>::allocate((uint64_t)v7, v12 + 1);
    __dst[1] = v10;
    __dst[2] = v13 | 0x8000000000000000;
    *__dst = v11;
  }
  else
  {
    *((_BYTE *)__dst + 23) = v10;
    v11 = __dst;
    if (!v10)
      goto LABEL_17;
  }
  memmove(v11, (char *)v5 + a3, v10);
LABEL_17:
  *((_BYTE *)v11 + v10) = 0;
  return __dst;
}

uint64_t std::__split_buffer<unsigned int,ENTTS::Allocator<unsigned int> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 3) & 0xFFFFFFFFFFFFFFFCLL);
  if (*(_QWORD *)a1)
    heap_Free(*(_QWORD **)(**(_QWORD **)(a1 + 32) + 8), *(_QWORD *)a1);
  return a1;
}

_QWORD *std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__erase_external_with_move(_QWORD *result, uint64_t a2, unint64_t a3)
{
  _QWORD *v3;
  int v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;

  if (a3)
  {
    v3 = result;
    v4 = *((char *)result + 23);
    if (v4 < 0)
    {
      v6 = (_QWORD *)*result;
      v5 = result[1];
    }
    else
    {
      v5 = *((unsigned __int8 *)result + 23);
      v6 = result;
    }
    if (v5 - a2 >= a3)
      v7 = a3;
    else
      v7 = v5 - a2;
    if (v5 - a2 > a3)
    {
      result = memmove((char *)v6 + a2, (char *)v6 + a2 + v7, v5 - a2 - v7);
      LOBYTE(v4) = *((_BYTE *)v3 + 23);
    }
    v8 = v5 - v7;
    if ((v4 & 0x80) != 0)
      v3[1] = v8;
    else
      *((_BYTE *)v3 + 23) = v8 & 0x7F;
    *((_BYTE *)v6 + v8) = 0;
  }
  return result;
}

void std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _QWORD v20[5];

  v5 = a1[1];
  v4 = a1[2];
  if (a2 <= (v4 - v5) >> 2)
  {
    if (a2)
    {
      bzero((void *)a1[1], 4 * a2);
      v5 += 4 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    v6 = (uint64_t)(a1 + 3);
    v7 = *a1;
    v8 = v5 - *a1;
    v9 = a2 + (v8 >> 2);
    if (v9 >> 62)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    v11 = v4 - v7;
    if (v11 >> 1 > v9)
      v9 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v20[4] = a1 + 3;
    if (v12)
    {
      v13 = ENTTS::Allocator<int>::allocate(v6, v12);
      v7 = *a1;
      v5 = a1[1];
    }
    else
    {
      v13 = 0;
    }
    v14 = (char *)(v13 + 4 * v10);
    v15 = v13 + 4 * v12;
    bzero(v14, 4 * a2);
    v16 = &v14[4 * a2];
    if (v5 != v7)
    {
      v17 = v5;
      do
      {
        v18 = *(_DWORD *)(v17 - 4);
        v17 -= 4;
        *((_DWORD *)v14 - 1) = v18;
        v14 -= 4;
      }
      while (v17 != v7);
    }
    *a1 = (uint64_t)v14;
    a1[1] = (uint64_t)v16;
    v19 = a1[2];
    a1[2] = v15;
    v20[2] = v5;
    v20[3] = v19;
    v20[0] = v7;
    v20[1] = v7;
    std::__split_buffer<unsigned int,ENTTS::Allocator<unsigned int> &>::~__split_buffer((uint64_t)v20);
  }
}

uint64_t *std::vector<double,ENTTS::Allocator<double>>::__init_with_size[abi:ne180100]<double *,double *>(uint64_t *result, const void *a2, uint64_t a3, unint64_t a4)
{
  uint64_t *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = (uint64_t *)std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = (uint64_t *)memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_214E89AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9)
{
  std::vector<double,ENTTS::Allocator<double>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t **std::vector<double,ENTTS::Allocator<double>>::__destroy_vector::operator()[abi:ne180100](uint64_t **result)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = *result;
  v2 = **result;
  if (v2)
  {
    v1[1] = v2;
    return (uint64_t **)heap_Free(*(_QWORD **)(v1[3] + 8), v2);
  }
  return result;
}

_QWORD *StyleTemplateManager::StyleTemplateManager(_QWORD *a1, char **a2)
{
  _QWORD *v4;

  v4 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a1, "news");
  v4[5] = 0;
  v4[6] = 0;
  v4[4] = v4 + 5;
  v4[9] = 0;
  v4[10] = 0;
  v4[11] = CustomAllocator::mRsrc;
  v4[13] = 0;
  *((_BYTE *)v4 + 56) = 0;
  v4[8] = 0;
  v4[12] = 0;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)v4 + 8, a2);
  return a1;
}

void sub_214E89BC0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v3);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v4);
  std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::destroy(v2, *(_QWORD **)(v1 + 40));
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v1);
  _Unwind_Resume(a1);
}

uint64_t StyleTemplateManager::StyleTemplateManager(uint64_t a1, uint64_t *a2)
{
  _QWORD *v4;
  uint64_t v5;

  v4 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>((_QWORD *)a1, "news");
  v4[6] = 0;
  v4[5] = 0;
  v4[4] = v4 + 5;
  v4[8] = 0;
  v4[9] = 0;
  v5 = CustomAllocator::mRsrc;
  v4[10] = 0;
  v4[11] = v5;
  v4[13] = 0;
  v4[12] = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](v4 + 12, a2);
  return a1;
}

uint64_t *StyleTemplateManager::set_style_template(uint64_t a1, __int128 *a2, uint64_t a3)
{
  uint64_t *result;
  __int128 *v5;

  v5 = a2;
  result = std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>,std::tuple<>>((uint64_t **)(a1 + 32), (const void **)a2, (uint64_t)&std::piecewise_construct, &v5)+ 8;
  if (result != (uint64_t *)a3)
    return std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(result, *(char **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
  return result;
}

uint64_t *StyleTemplateManager::get_style_template(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t v9;
  __int128 *p_dst;
  _QWORD *v11;
  __int128 *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18[2];
  char v19;
  uint64_t v20;
  __int128 __dst;
  void *v22;
  _QWORD **v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  void *v27;
  __int128 *__src[2];
  void *v29;
  _QWORD v30[10];
  char v31;
  uint64_t v32;
  _QWORD v33[20];

  v33[19] = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 56))
  {
    if (std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__count_unique<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>(a1 + 32, (const void **)a2))
    {
      __src[0] = (__int128 *)a2;
      v8 = std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>,std::tuple<>>((uint64_t **)(a1 + 32), (const void **)a2, (uint64_t)&std::piecewise_construct, __src);
      if (v8 + 8 != a3)
LABEL_4:
        std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a3, (char *)v8[8], v8[9], (v8[9] - v8[8]) >> 2);
    }
    else
    {
      if (!std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__count_unique<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>(a1 + 32, (const void **)a1))
      {
        LODWORD(__src[0]) = 0;
        std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a3, (char *)__src, (uint64_t)__src + 4, 1uLL);
        goto LABEL_33;
      }
      __src[0] = (__int128 *)a1;
      v8 = std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>,std::tuple<>>((uint64_t **)(a1 + 32), (const void **)a1, (uint64_t)&std::piecewise_construct, __src);
      if (v8 + 8 != a3)
        goto LABEL_4;
    }
LABEL_33:
    v17 = (a3[1] - *a3) >> 2;
    __src[0] = (__int128 *)1;
    __src[1] = (__int128 *)v17;
    return std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__assign_with_size[abi:ne180100]<unsigned long const*,unsigned long const*>(a4, (char *)__src, (uint64_t)&v29, 2uLL);
  }
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)__src);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&__dst);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&__dst, (uint64_t *)__src);
  v27 = &unk_24D29B3D8;
  *(_QWORD *)&__dst = &unk_24D29B388;
  v22 = &unk_24D29B3B0;
  v23 = (_QWORD **)&unk_24D29B578;
  if (v25 < 0)
    heap_Free(*(_QWORD **)(v26 + 8), v24);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v27);
  v23 = (_QWORD **)CustomAllocator::mRsrc;
  if (*(char *)(a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    __dst = *(_OWORD *)a2;
    v22 = *(void **)(a2 + 16);
  }
  v9 = HIBYTE(v22);
  p_dst = &__dst;
  if (SHIBYTE(v22) < 0)
  {
    v9 = *((_QWORD *)&__dst + 1);
    p_dst = (__int128 *)__dst;
  }
  for (; v9; --v9)
  {
    if (*(_BYTE *)p_dst == 95)
      *(_BYTE *)p_dst = 47;
    p_dst = (__int128 *)((char *)p_dst + 1);
  }
  v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v29, (uint64_t)"style/template/", 15);
  if (SHIBYTE(v22) >= 0)
    v12 = &__dst;
  else
    v12 = (__int128 *)__dst;
  if (SHIBYTE(v22) >= 0)
    v13 = HIBYTE(v22);
  else
    v13 = *((_QWORD *)&__dst + 1);
  v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)v12, v13);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"/npy", 4);
  v15 = *(_QWORD *)(a1 + 96);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v30, v18);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, _QWORD))(*(_QWORD *)v15 + 16))(v15, v18, a4, a3, 0);
  if (v19 < 0)
    heap_Free(*(_QWORD **)(v20 + 8), v18[0]);
  if (SHIBYTE(v22) < 0)
    heap_Free(v23[1], __dst);
  __src[0] = (__int128 *)&unk_24D29B388;
  v33[0] = &unk_24D29B3D8;
  v29 = &unk_24D29B3B0;
  v30[0] = &unk_24D29B578;
  if (v31 < 0)
    heap_Free(*(_QWORD **)(v32 + 8), v30[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return (uint64_t *)MEMORY[0x2199DA5E8](v33);
}

void sub_214E8A050(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int __src, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__find_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)v10);
    std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__insert_node_at(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__find_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32)))break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::operator()[abi:ne180100](v7, v9, a3))break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

_QWORD *std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *result;

  v5 = a1 + 8;
  v6 = operator new(0x60uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = std::pair<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const,std::vector<float,ENTTS::Allocator<float>>>::pair[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>(v6 + 4, *a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_214E8A2A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

BOOL std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::operator()[abi:ne180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

_QWORD *std::pair<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const,std::vector<float,ENTTS::Allocator<float>>>::pair[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>(_QWORD *__dst, __int128 *a2)
{
  __int128 v3;
  uint64_t v4;

  __dst[3] = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v3 = *a2;
    __dst[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)__dst = v3;
  }
  __dst[4] = 0;
  __dst[5] = 0;
  v4 = CustomAllocator::mRsrc;
  __dst[6] = 0;
  __dst[7] = v4;
  return __dst;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const,std::vector<float,ENTTS::Allocator<float>>>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

uint64_t std::__tree<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::__map_value_compare<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>,std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::allocator<std::__value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::vector<float,ENTTS::Allocator<float>>>>>::__count_unique<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>(uint64_t a1, const void **a2)
{
  const void **v2;
  uint64_t v4;
  uint64_t v5;

  v2 = *(const void ***)(a1 + 8);
  if (v2)
  {
    v4 = a1 + 16;
    v5 = 1;
    do
    {
      if (!std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::operator()[abi:ne180100](v4, a2, v2 + 4))
      {
        if (!std::less<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::operator()[abi:ne180100](v4, v2 + 4, a2))return v5;
        ++v2;
      }
      v2 = (const void **)*v2;
    }
    while (v2);
  }
  return 0;
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x2199DA4BC](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x24BEDB350]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x2199DA4C8](v13);
  return a1;
}

void sub_214E8A740(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  MEMORY[0x2199DA4C8](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x214E8A720);
}

void sub_214E8A788(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_214E8A8BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

uint64_t std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  int v2;
  uint64_t v3;
  char *v4;
  char *v5;
  char *v6;

  v2 = *(_DWORD *)(result + 104);
  if ((v2 & 0x10) != 0)
  {
    v4 = *(char **)(result + 96);
    v5 = *(char **)(result + 48);
    if (v4 < v5)
    {
      *(_QWORD *)(result + 96) = v5;
      v4 = v5;
    }
    v6 = *(char **)(result + 40);
  }
  else
  {
    if ((v2 & 8) == 0)
    {
      *a2 = 0;
      a2[1] = 0;
      v3 = CustomAllocator::mRsrc;
      a2[2] = 0;
      a2[3] = v3;
      return result;
    }
    v6 = *(char **)(result + 16);
    v4 = *(char **)(result + 32);
  }
  a2[3] = CustomAllocator::mRsrc;
  return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_with_size[abi:ne180100]<char *,char *>((uint64_t)a2, v6, v4, v4 - v6);
}

uint64_t std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_with_size[abi:ne180100]<char *,char *>(uint64_t result, char *a2, char *a3, unint64_t a4)
{
  _QWORD *v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;

  v4 = (_QWORD *)result;
  if (a4 >= 0x7FFFFFFFFFFFFFF8)
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]();
  if (a4 > 0x16)
  {
    v8 = result + 24;
    v9 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17)
      v9 = a4 | 7;
    v10 = v9 + 1;
    result = ENTTS::Allocator<char>::allocate(v8, v9 + 1);
    v4[1] = a4;
    v4[2] = v10 | 0x8000000000000000;
    *v4 = result;
    v4 = (_QWORD *)result;
  }
  else
  {
    *(_BYTE *)(result + 23) = a4;
  }
  while (a2 != a3)
  {
    v11 = *a2++;
    *(_BYTE *)v4 = v11;
    v4 = (_QWORD *)((char *)v4 + 1);
  }
  *(_BYTE *)v4 = 0;
  return result;
}

double VisemeParameters::VisemeParameters(uint64_t a1)
{
  double result;
  uint64_t v2;

  *(_DWORD *)a1 = 0;
  *(_QWORD *)&result = 0x600000049;
  *(_QWORD *)(a1 + 4) = 0x600000049;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v2 = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = v2;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = v2;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = v2;
  *(_QWORD *)(a1 + 112) = 0;
  return result;
}

{
  double result;
  uint64_t v2;

  *(_DWORD *)a1 = 0;
  *(_QWORD *)&result = 0x600000049;
  *(_QWORD *)(a1 + 4) = 0x600000049;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v2 = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = v2;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = v2;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = v2;
  *(_QWORD *)(a1 + 112) = 0;
  return result;
}

uint64_t PipelineServices::PipelineServices(uint64_t a1, uint64_t a2, char *a3, int a4)
{
  uint64_t *v6;
  char *v8;
  uint64_t v9;
  char **v10;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = (uint64_t *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = CustomAllocator::mRsrc;
  *(_BYTE *)(a1 + 40) = 1;
  *(_QWORD *)a1 = &off_24D29C090;
  *(_QWORD *)(a1 + 48) = a2;
  if (a3)
  {
    affinity_parser(a3, (uint64_t *)&v8);
    if (v6 != (uint64_t *)&v8)
      std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v6, v8, v9, (v9 - (uint64_t)v8) >> 2);
    v10 = &v8;
    std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v10);
  }
  if ((a4 & 0x80000000) == 0)
    *(_BYTE *)(a1 + 40) = a4 != 0;
  return a1;
}

void sub_214E8ABC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char *a14)
{
  _QWORD *v14;

  a14 = &a10;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a14);
  *v14 = &unk_24D29B240;
  std::vector<unsigned int,ENTTS::Allocator<unsigned int>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&a14);
  _Unwind_Resume(a1);
}

uint64_t PipelineServices::data_read_all(uint64_t a1, const char *a2, _QWORD *a3, uint64_t a4, _QWORD *a5, int a6)
{
  uint64_t v11;
  int voice_specific_broker_string;
  uint64_t result;
  __int16 v14;
  unsigned int v15;
  uint64_t v16;
  char v17[256];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v15 = 0;
  v11 = *(_QWORD *)(a1 + 48);
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  v16 = 0;
  voice_specific_broker_string = bet7_generate_voice_specific_broker_string(v11, a2, v17);
  if (voice_specific_broker_string < 0
    || (voice_specific_broker_string = brk_DataOpenEx(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24), (uint64_t)v17, a6 ^ 1u, (uint64_t)&v16), voice_specific_broker_string < 0))
  {
    v14 = voice_specific_broker_string;
    goto LABEL_8;
  }
  result = brk_DataMapEx(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24), v16, 0, (uint64_t)&v15, a4);
  if ((result & 0x80000000) != 0)
  {
    v14 = result;
    brk_DataClose(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24), v16);
LABEL_8:
    entts_throw_verror(v14);
  }
  *a3 = v16;
  *a5 = v15;
  return result;
}

uint64_t PipelineServices::data_release_and_close(uint64_t this, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = this;
  if (a3)
    this = brk_DataUnmap(*(_QWORD *)(*(_QWORD *)(this + 48) + 24), a2, a3);
  if (a2)
    return brk_DataClose(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 24), a2);
  return this;
}

uint64_t PipelineServices::read_numpy(uint64_t a1, __int128 *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  void *v14;
  uint64_t v15;

  v15 = 0;
  v13 = 0;
  v14 = 0;
  v12 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&v10, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v10 = *a2;
    v11 = *((_QWORD *)a2 + 2);
  }
  (**(void (***)(uint64_t, __int128 *, uint64_t *, void **, size_t *, uint64_t))a1)(a1, &v10, &v15, &v14, &v13, a5);
  if (SHIBYTE(v11) < 0)
    heap_Free(*(_QWORD **)(v12 + 8), v10);
  npy::LoadArrayFromNumpy(v14, v13, a3, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(_QWORD *)a1 + 8))(a1, v15, v14);
}

void sub_214E8AE4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *npy::LoadArrayFromNumpy(void *__src, size_t __len, uint64_t *a3, uint64_t *a4)
{
  _QWORD *result;
  _QWORD v7[12];
  char v8;
  uint64_t v9;
  void *v10;
  char *__dst[2];
  char v12;
  uint64_t v13;

  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100](__dst, __src, __len);
  std::basic_istringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_istringstream[abi:ne180100]((uint64_t)v7, __dst, 8);
  npy::LoadArrayFromNumpy<float>(v7, a3, a4);
  v10 = &unk_24D29C168;
  v7[0] = &unk_24D29C140;
  v7[2] = &unk_24D29B578;
  if (v8 < 0)
    heap_Free(*(_QWORD **)(v9 + 8), v7[10]);
  std::streambuf::~streambuf();
  std::istream::~istream();
  result = (_QWORD *)MEMORY[0x2199DA5E8](&v10);
  if (v12 < 0)
    return heap_Free(*(_QWORD **)(v13 + 8), (uint64_t)__dst[0]);
  return result;
}

{
  _QWORD *result;
  _QWORD v7[12];
  char v8;
  uint64_t v9;
  void *v10;
  char *__dst[2];
  char v12;
  uint64_t v13;

  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100](__dst, __src, __len);
  std::basic_istringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_istringstream[abi:ne180100]((uint64_t)v7, __dst, 8);
  npy::LoadArrayFromNumpy_16_or_32(v7, a3, a4);
  v10 = &unk_24D29C168;
  v7[0] = &unk_24D29C140;
  v7[2] = &unk_24D29B578;
  if (v8 < 0)
    heap_Free(*(_QWORD **)(v9 + 8), v7[10]);
  std::streambuf::~streambuf();
  std::istream::~istream();
  result = (_QWORD *)MEMORY[0x2199DA5E8](&v10);
  if (v12 < 0)
    return heap_Free(*(_QWORD **)(v13 + 8), (uint64_t)__dst[0]);
  return result;
}

void sub_214E8AF4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::basic_istringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_istringstream((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v2 - 64);
  _Unwind_Resume(a1);
}

uint64_t PipelineServices::read_numpy_and_cast_16(uint64_t a1, __int128 *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  void *v14;
  uint64_t v15;

  v15 = 0;
  v13 = 0;
  v14 = 0;
  v12 = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&v10, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v10 = *a2;
    v11 = *((_QWORD *)a2 + 2);
  }
  (**(void (***)(uint64_t, __int128 *, uint64_t *, void **, size_t *, uint64_t))a1)(a1, &v10, &v15, &v14, &v13, a5);
  if (SHIBYTE(v11) < 0)
    heap_Free(*(_QWORD **)(v12 + 8), v10);
  npy::LoadArrayFromNumpy(v14, v13, a3, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(_QWORD *)a1 + 8))(a1, v15, v14);
}

void sub_214E8B054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_214E8B154(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::basic_istringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_istringstream((uint64_t)va);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v2 - 64);
  _Unwind_Resume(a1);
}

uint64_t PipelineServices::entts_Malloc(PipelineServices *this, unsigned int a2)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Alloc(*(_QWORD *)(*((_QWORD *)this + 6) + 8), a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

uint64_t PipelineServices::entts_Calloc(PipelineServices *this, unsigned int a2, unsigned int a3)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Calloc(*(_QWORD **)(*((_QWORD *)this + 6) + 8), a2, a3);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

uint64_t PipelineServices::entts_Realloc(PipelineServices *this, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Realloc(*(uint64_t **)(*((_QWORD *)this + 6) + 8), a2, a3);
  if (!result)
  {
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 6) + 8), a2);
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

_QWORD *PipelineServices::entts_Free(PipelineServices *this, uint64_t a2)
{
  return heap_Free(*(_QWORD **)(*((_QWORD *)this + 6) + 8), a2);
}

BOOL PipelineServices::is_threading_available(PipelineServices *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 6) + 400) != 0;
}

uint64_t PipelineServices::create_thread(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  LODWORD(result) = thread_ObjOpen(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 400), *(_QWORD **)(*(_QWORD *)(a1 + 48) + 8), a2);
  if ((result & 0x80000000) != 0 || (result = thread_Start((_QWORD *)*a2), (result & 0x80000000) != 0))
    entts_throw_verror(result);
  return result;
}

uint64_t PipelineServices::join_thread(uint64_t a1, _QWORD **a2)
{
  uint64_t result;

  result = thread_Join(*a2);
  if ((result & 0x80000000) != 0)
    entts_throw_verror(result);
  return result;
}

uint64_t PipelineServices::destroy_thread(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = thread_ObjClose(*a2);
  if ((result & 0x80000000) != 0)
    entts_throw_verror(result);
  return result;
}

void PipelineServices::throw_error(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  _DWORD *exception;

  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 32);
  if (*(char *)(a3 + 23) < 0)
    a3 = *(_QWORD *)a3;
  log_OutText(v9, (uint64_t)"NEURALSYNTH_BET7_SERVICES", 0, 0, (uint64_t)"SEVERE: exception: %s", a6, a7, a8, a3);
  exception = __cxa_allocate_exception(0x10uLL);
  *(_QWORD *)exception = &unk_24D29B1B8;
  exception[2] = a2;
}

char *PipelineServices::getenv(PipelineServices *this, const char *a2)
{
  return getenv(a2);
}

uint64_t std::basic_istringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_istringstream[abi:ne180100](uint64_t a1, char **a2, int a3)
{
  uint64_t v6;

  *(_QWORD *)(a1 + 128) = &unk_24D29C1D8;
  v6 = a1 + 16;
  *(_QWORD *)a1 = &unk_24D29C1B0;
  *(_QWORD *)(a1 + 8) = 0;
  std::ios_base::init((std::ios_base *)(a1 + 128), (void *)(a1 + 16));
  *(_QWORD *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 272) = -1;
  *(_QWORD *)a1 = &unk_24D29C140;
  *(_QWORD *)(a1 + 128) = &unk_24D29C168;
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringbuf[abi:ne180100](v6, a2, a3 | 8);
  return a1;
}

void sub_214E8B49C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::istream::~istream();
  MEMORY[0x2199DA5E8](v1);
  _Unwind_Resume(a1);
}

_QWORD *npy::LoadArrayFromNumpy<float>(_QWORD *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *result;
  uint64_t v10;
  char v11;
  uint64_t v12;
  __int128 __dst;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16[2];
  uint64_t v17;
  uint64_t v18;
  char v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  char __s[16];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  npy::read_header(a1, &v20);
  v19 = 0;
  v16[0] = 0;
  v16[1] = 0;
  v17 = 0;
  v18 = CustomAllocator::mRsrc;
  v15 = CustomAllocator::mRsrc;
  if (SHIBYTE(v21) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, (void *)v20, *((unint64_t *)&v20 + 1));
  }
  else
  {
    __dst = v20;
    v14 = v21;
  }
  npy::parse_header(&__dst, (uint64_t)v16, &v19, a2);
  if (SHIBYTE(v14) < 0)
    heap_Free(*(_QWORD **)(v15 + 8), __dst);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v10, __s);
  v5 = (uint64_t *)*a2;
  v6 = (uint64_t *)a2[1];
  v7 = 1;
  while (v5 != v6)
  {
    v8 = *v5++;
    v7 *= v8;
  }
  std::vector<float,ENTTS::Allocator<float>>::resize(a3, v7);
  result = (_QWORD *)std::istream::read();
  if (v11 < 0)
    result = heap_Free(*(_QWORD **)(v12 + 8), v10);
  if (SHIBYTE(v17) < 0)
    result = heap_Free(*(_QWORD **)(v18 + 8), v16[0]);
  if (SHIBYTE(v21) < 0)
    return heap_Free(*(_QWORD **)(v22 + 8), v20);
  return result;
}

void sub_214E8B630(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_istringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_istringstream(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)(a1 + 128) = &unk_24D29C168;
  v2 = a1 + 128;
  *(_QWORD *)a1 = &unk_24D29C140;
  *(_QWORD *)(a1 + 16) = &unk_24D29B578;
  if (*(char *)(a1 + 103) < 0)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 104) + 8), *(_QWORD *)(a1 + 80));
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x2199DA5E8](v2);
  return a1;
}

_QWORD *std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100](_QWORD *__dst, void *__src, size_t __len)
{
  char *v4;
  void *v7;
  size_t v8;
  size_t v9;

  __dst[3] = CustomAllocator::mRsrc;
  v4 = (char *)(__dst + 3);
  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v8 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v8 = __len | 7;
    v9 = v8 + 1;
    v7 = (void *)ENTTS::Allocator<char>::allocate((uint64_t)v4, v8 + 1);
    __dst[1] = __len;
    __dst[2] = v9 | 0x8000000000000000;
    *__dst = v7;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v7 = __dst;
    if (!__len)
      goto LABEL_9;
  }
  memmove(v7, __src, __len);
LABEL_9:
  *((_BYTE *)v7 + __len) = 0;
  return __dst;
}

void std::basic_istringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_istringstream(char *a1)
{
  char *v2;

  *((_QWORD *)a1 + 16) = &unk_24D29C168;
  v2 = a1 + 128;
  *(_QWORD *)a1 = &unk_24D29C140;
  *((_QWORD *)a1 + 2) = &unk_24D29B578;
  if (a1[103] < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)a1 + 13) + 8), *((_QWORD *)a1 + 10));
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x2199DA5E8](v2);
  operator delete(a1);
}

void `virtual thunk to'std::basic_istringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_istringstream(_QWORD *a1)
{
  char *v1;

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  *((_QWORD *)v1 + 16) = &unk_24D29C168;
  *(_QWORD *)v1 = &unk_24D29C140;
  *((_QWORD *)v1 + 2) = &unk_24D29B578;
  if (v1[103] < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)v1 + 13) + 8), *((_QWORD *)v1 + 10));
  std::streambuf::~streambuf();
  std::istream::~istream();
  JUMPOUT(0x2199DA5E8);
}

{
  char *v1;

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  *((_QWORD *)v1 + 16) = &unk_24D29C168;
  *(_QWORD *)v1 = &unk_24D29C140;
  *((_QWORD *)v1 + 2) = &unk_24D29B578;
  if (v1[103] < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)v1 + 13) + 8), *((_QWORD *)v1 + 10));
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x2199DA5E8](v1 + 128);
  operator delete(v1);
}

uint64_t std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringbuf[abi:ne180100](uint64_t a1, char **a2, int a3)
{
  uint64_t v6;

  v6 = std::streambuf::basic_streambuf();
  *(_QWORD *)v6 = &unk_24D29B578;
  *(_QWORD *)(v6 + 64) = 0;
  *(_QWORD *)(v6 + 72) = 0;
  *(_QWORD *)(v6 + 80) = 0;
  *(_QWORD *)(v6 + 88) = CustomAllocator::mRsrc;
  *(_QWORD *)(v6 + 96) = 0;
  *(_DWORD *)(v6 + 104) = a3;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=((char **)(v6 + 64), a2);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_buf_ptrs[abi:ne180100](a1);
  return a1;
}

void sub_214E8BA2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v1);
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_buf_ptrs[abi:ne180100](uint64_t a1)
{
  uint64_t result;
  char v3;
  uint64_t v4;
  unint64_t v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  *(_QWORD *)(a1 + 96) = 0;
  result = a1 + 64;
  v3 = *(_BYTE *)(a1 + 87);
  if (v3 < 0)
  {
    v4 = *(_QWORD *)(a1 + 64);
    v5 = *(_QWORD *)(a1 + 72);
  }
  else
  {
    v4 = result;
    v5 = *(unsigned __int8 *)(a1 + 87);
  }
  v6 = *(_DWORD *)(a1 + 104);
  if ((v6 & 8) != 0)
  {
    *(_QWORD *)(a1 + 96) = v4 + v5;
    *(_QWORD *)(a1 + 16) = v4;
    *(_QWORD *)(a1 + 24) = v4;
    *(_QWORD *)(a1 + 32) = v4 + v5;
  }
  if ((v6 & 0x10) != 0)
  {
    *(_QWORD *)(a1 + 96) = v4 + v5;
    v7 = v3 < 0 ? (*(_QWORD *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::resize(result, v7, 0);
    v8 = *(char *)(a1 + 87) < 0 ? *(_QWORD *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(_QWORD *)(a1 + 40) = v4;
    *(_QWORD *)(a1 + 48) = v4;
    *(_QWORD *)(a1 + 56) = v4 + v8;
    if ((*(_BYTE *)(a1 + 104) & 3) != 0)
    {
      if (v5 >> 31)
      {
        v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
        v4 += v10 + 0x7FFFFFFF;
        v5 = v5 - v10 - 0x7FFFFFFF;
        *(_QWORD *)(a1 + 48) = v4;
      }
      if (v5)
        *(_QWORD *)(a1 + 48) = v4 + v5;
    }
  }
  return result;
}

uint64_t **npy::read_header@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  unsigned int v5;
  size_t v6;
  _DWORD *exception;
  _DWORD *v9;
  _DWORD *v10;
  int64x2_t *p_src;
  int64x2_t __src;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  std::istream::read();
  if ((*((_BYTE *)a1 + *(_QWORD *)(*a1 - 24) + 32) & 5) != 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 4;
  }
  if (__src.i32[0] != 1297436307 || __src.u16[2] != 22864)
  {
    v9 = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)v9 = &unk_24D29B1B8;
    v9[2] = 4;
  }
  if (__src.u8[6] != 1 || __src.i8[7])
  {
    if (__src.u8[6] != 2 || __src.i8[7])
    {
      v10 = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)v10 = &unk_24D29B1B8;
      v10[2] = 4;
    }
    std::istream::read();
    v5 = __src.i8[0] | (__src.i8[1] << 8) | (__src.i8[2] << 16) | (__src.i8[3] << 24);
  }
  else
  {
    std::istream::read();
    v5 = __src.i8[0] | (__src.i8[1] << 8);
  }
  __src = 0uLL;
  v13 = 0;
  v14 = CustomAllocator::mRsrc;
  v6 = v5;
  std::vector<char,ENTTS::Allocator<char>>::reserve(&__src, v5);
  std::istream::read();
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100](a2, (void *)__src.i64[0], v6);
  p_src = &__src;
  return std::vector<char,ENTTS::Allocator<char>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&p_src);
}

void sub_214E8BD68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9)
{
  std::vector<char,ENTTS::Allocator<char>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t **npy::parse_header(__int128 *a1, uint64_t a2, char *a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 *v17;
  __int128 *v18;
  int v19;
  int v20;
  char v22;
  int v23;
  __int128 *v24;
  __int128 *i;
  __int128 v26;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t **v43;
  _DWORD *v45;
  _DWORD *v46;
  _DWORD *exception;
  _DWORD *v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  __int128 *v55;
  __int128 *v56;
  __int128 v57;
  uint64_t v58;
  uint64_t v59;
  __int128 v60;
  uint64_t v61;
  uint64_t v62;
  __int128 v63;
  uint64_t v64;
  uint64_t v65;
  __int128 v66;
  uint64_t v67;
  uint64_t v68;
  __int128 __dst;
  uint64_t v70;
  uint64_t v71;
  __int128 *v72;
  __int128 *v73;
  __int128 *v74;
  uint64_t v75;
  __int128 v76;
  _QWORD *v77;
  uint64_t v78;
  _QWORD *v79;
  _QWORD v80[4];
  _QWORD v81[4];
  _QWORD v82[4];
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  if (*((char *)a1 + 23) < 0)
  {
    v10 = *(_BYTE **)a1;
    v11 = *((_QWORD *)a1 + 1);
    if (*(_BYTE *)(*(_QWORD *)a1 + v11 - 1) == 10)
    {
      v9 = v11 - 1;
      *((_QWORD *)a1 + 1) = v9;
      goto LABEL_6;
    }
LABEL_100:
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 4;
  }
  v8 = *((unsigned __int8 *)a1 + 23);
  if (*((_BYTE *)a1 + v8 - 1) != 10)
    goto LABEL_100;
  v9 = v8 - 1;
  *((_BYTE *)a1 + 23) = (v8 - 1) & 0x7F;
  v10 = a1;
LABEL_6:
  v10[v9] = 0;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v80, "descr");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v81, "fortran_order");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v82, "shape");
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = CustomAllocator::mRsrc;
  *(_QWORD *)&v76 = &v72;
  BYTE8(v76) = 0;
  v72 = (__int128 *)ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate((uint64_t)&v75, 3);
  v73 = v72;
  v74 = v72 + 6;
  v12 = 0;
  v73 = (__int128 *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>((uint64_t)&v75, (uint64_t)v80, (uint64_t)&v83, (uint64_t)v72);
  do
  {
    if (SHIBYTE(v82[v12 + 2]) < 0)
      heap_Free(*(_QWORD **)(v82[v12 + 3] + 8), v82[v12]);
    v12 -= 4;
  }
  while (v12 != -12);
  v71 = CustomAllocator::mRsrc;
  if (*((char *)a1 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *(void **)a1, *((_QWORD *)a1 + 1));
  }
  else
  {
    __dst = *a1;
    v70 = *((_QWORD *)a1 + 2);
  }
  npy::pyparse::parse_dict((uint64_t **)&__dst, &v72, v80);
  if (SHIBYTE(v70) < 0)
    heap_Free(*(_QWORD **)(v71 + 8), __dst);
  if (!v81[1])
  {
    v48 = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)v48 = &unk_24D29B1B8;
    v48[2] = 4;
  }
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v76, "descr");
  *(_QWORD *)&v63 = &v76;
  v13 = std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>&&>,std::tuple<>>((uint64_t)v80, (unsigned __int8 *)&v76, (uint64_t)&std::piecewise_construct, (_OWORD **)&v63);
  v68 = CustomAllocator::mRsrc;
  if (*(char *)(v13 + 71) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&v66, *(void **)(v13 + 48), *(_QWORD *)(v13 + 56));
  }
  else
  {
    v66 = *(_OWORD *)(v13 + 48);
    v67 = *(_QWORD *)(v13 + 64);
  }
  if (SHIBYTE(v77) < 0)
    heap_Free(*(_QWORD **)(v78 + 8), v76);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v76, "fortran_order");
  *(_QWORD *)&v60 = &v76;
  v14 = std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>&&>,std::tuple<>>((uint64_t)v80, (unsigned __int8 *)&v76, (uint64_t)&std::piecewise_construct, (_OWORD **)&v60);
  v65 = CustomAllocator::mRsrc;
  if (*(char *)(v14 + 71) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&v63, *(void **)(v14 + 48), *(_QWORD *)(v14 + 56));
  }
  else
  {
    v63 = *(_OWORD *)(v14 + 48);
    v64 = *(_QWORD *)(v14 + 64);
  }
  if (SHIBYTE(v77) < 0)
    heap_Free(*(_QWORD **)(v78 + 8), v76);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v76, "shape");
  v55 = &v76;
  v15 = std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>&&>,std::tuple<>>((uint64_t)v80, (unsigned __int8 *)&v76, (uint64_t)&std::piecewise_construct, &v55);
  v62 = CustomAllocator::mRsrc;
  if (*(char *)(v15 + 71) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&v60, *(void **)(v15 + 48), *(_QWORD *)(v15 + 56));
  }
  else
  {
    v60 = *(_OWORD *)(v15 + 48);
    v61 = *(_QWORD *)(v15 + 64);
  }
  if (SHIBYTE(v77) < 0)
    heap_Free(*(_QWORD **)(v78 + 8), v76);
  v59 = CustomAllocator::mRsrc;
  if (SHIBYTE(v67) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&v57, (void *)v66, *((unint64_t *)&v66 + 1));
  }
  else
  {
    v57 = v66;
    v58 = v67;
  }
  npy::parse_typestring(&v57);
  if (SHIBYTE(v58) < 0)
    heap_Free(*(_QWORD **)(v59 + 8), v57);
  if (SHIBYTE(v67) < 0)
  {
    v17 = (__int128 *)v66;
    if (*(_BYTE *)v66 != 39)
      goto LABEL_98;
    v16 = *((_QWORD *)&v66 + 1);
  }
  else
  {
    if (v66 != 39)
      goto LABEL_98;
    v16 = HIBYTE(v67);
    v17 = &v66;
  }
  if (*((_BYTE *)v17 + v16 - 1) != 39)
  {
LABEL_98:
    v45 = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)v45 = &unk_24D29B1B8;
    v45[2] = 7;
  }
  v55 = (__int128 *)CustomAllocator::mRsrc;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string(&v76, (uint64_t *)&v66, 1uLL, v16 - 2);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](a2, &v76);
  if (SHIBYTE(v77) < 0)
    heap_Free(*(_QWORD **)(v78 + 8), v76);
  if (v64 < 0)
  {
    if (*((_QWORD *)&v63 + 1) != 4)
    {
      if (*((_QWORD *)&v63 + 1) != 5)
        goto LABEL_99;
      v18 = (__int128 *)v63;
      goto LABEL_51;
    }
    v23 = *(_DWORD *)v63;
LABEL_59:
    if (v23 != 1702195796)
      goto LABEL_99;
    v22 = 1;
    goto LABEL_61;
  }
  if (HIBYTE(v64) == 4)
  {
    v23 = v63;
    goto LABEL_59;
  }
  if (HIBYTE(v64) != 5)
    goto LABEL_99;
  v18 = &v63;
LABEL_51:
  v19 = *(_DWORD *)v18;
  v20 = *((unsigned __int8 *)v18 + 4);
  if (v19 != 1936482630 || v20 != 101)
  {
LABEL_99:
    v46 = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)v46 = &unk_24D29B1B8;
    v46[2] = 7;
  }
  v22 = 0;
LABEL_61:
  *a3 = v22;
  v54 = CustomAllocator::mRsrc;
  if (SHIBYTE(v61) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&v52, (void *)v60, *((unint64_t *)&v60 + 1));
  }
  else
  {
    v52 = v60;
    v53 = v61;
  }
  npy::pyparse::parse_tuple((uint64_t)&v52, (uint64_t *)&v55);
  if (SHIBYTE(v53) < 0)
    heap_Free(*(_QWORD **)(v54 + 8), v52);
  v24 = v55;
  for (i = v56; v24 != i; v24 += 2)
  {
    v51 = CustomAllocator::mRsrc;
    if (*((char *)v24 + 23) < 0)
    {
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&v49, *(void **)v24, *((_QWORD *)v24 + 1));
    }
    else
    {
      v26 = *v24;
      v50 = *((_QWORD *)v24 + 2);
      v49 = v26;
    }
    v27 = ENTTS::stoul((uint64_t)&v49, 0, 10);
    v28 = v27;
    v29 = (_QWORD *)a4[1];
    v30 = a4[2];
    if ((unint64_t)v29 >= v30)
    {
      v32 = (_QWORD *)*a4;
      v33 = ((uint64_t)v29 - *a4) >> 3;
      v34 = v33 + 1;
      if ((unint64_t)(v33 + 1) >> 61)
        std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
      v35 = v30 - (_QWORD)v32;
      if (v35 >> 2 > v34)
        v34 = v35 >> 2;
      if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
        v36 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v36 = v34;
      v79 = a4 + 3;
      if (v36)
      {
        v37 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a4 + 3), v36);
        v32 = (_QWORD *)*a4;
        v29 = (_QWORD *)a4[1];
      }
      else
      {
        v37 = 0;
      }
      v38 = (_QWORD *)(v37 + 8 * v33);
      *v38 = v28;
      if (v29 == v32)
      {
        v40 = v37 + 8 * v33;
      }
      else
      {
        v39 = v29;
        v40 = v37 + 8 * v33;
        do
        {
          v41 = *--v39;
          *(_QWORD *)(v40 - 8) = v41;
          v40 -= 8;
        }
        while (v39 != v32);
      }
      v31 = v38 + 1;
      *a4 = v40;
      a4[1] = (uint64_t)(v38 + 1);
      v42 = a4[2];
      a4[2] = v37 + 8 * v36;
      v77 = v29;
      v78 = v42;
      *(_QWORD *)&v76 = v32;
      *((_QWORD *)&v76 + 1) = v32;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v76);
    }
    else
    {
      *v29 = v27;
      v31 = v29 + 1;
    }
    a4[1] = (uint64_t)v31;
    if (SHIBYTE(v50) < 0)
      heap_Free(*(_QWORD **)(v51 + 8), v49);
  }
  *(_QWORD *)&v76 = &v55;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v76);
  if (SHIBYTE(v61) < 0)
    heap_Free(*(_QWORD **)(v62 + 8), v60);
  if (SHIBYTE(v64) < 0)
    heap_Free(*(_QWORD **)(v65 + 8), v63);
  if (SHIBYTE(v67) < 0)
    heap_Free(*(_QWORD **)(v68 + 8), v66);
  v43 = (uint64_t **)std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::~__hash_table((uint64_t)v80);
  v80[0] = &v72;
  return std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100](v43);
}

void sub_214E8C544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

int64x2_t *std::vector<char,ENTTS::Allocator<char>>::reserve(int64x2_t *result, unint64_t a2)
{
  int64x2_t *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  int64x2_t v10;
  uint64_t v11;
  uint64_t v12;
  int64x2_t v13;
  uint64_t v14;
  uint64_t *v15;

  if (result[1].i64[0] - result->i64[0] < a2)
  {
    v3 = result;
    if ((a2 & 0x8000000000000000) != 0)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v4 = result->i64[1] - result->i64[0];
    v15 = &result[1].i64[1];
    v5 = ENTTS::Allocator<char>::allocate((uint64_t)&result[1].i64[1], a2);
    v7 = v3->i64[0];
    v6 = v3->u64[1];
    if (v6 == v3->i64[0])
    {
      v10 = vdupq_n_s64(v6);
      v8 = v5 + v4;
    }
    else
    {
      v8 = v5 + v4;
      do
      {
        v9 = *(_BYTE *)--v6;
        *(_BYTE *)--v8 = v9;
      }
      while (v6 != v7);
      v10 = *v3;
    }
    v3->i64[0] = v8;
    v3->i64[1] = v5 + v4;
    v13 = v10;
    v11 = v3[1].i64[0];
    v3[1].i64[0] = v5 + a2;
    v14 = v11;
    v12 = v10.i64[0];
    return (int64x2_t *)std::__split_buffer<char,ENTTS::Allocator<char> &>::~__split_buffer((uint64_t)&v12);
  }
  return result;
}

uint64_t std::__split_buffer<char,ENTTS::Allocator<char> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)(a1 + 16) != v2)
    *(_QWORD *)(a1 + 16) = v2;
  if (*(_QWORD *)a1)
    heap_Free(*(_QWORD **)(**(_QWORD **)(a1 + 32) + 8), *(_QWORD *)a1);
  return a1;
}

uint64_t **std::vector<char,ENTTS::Allocator<char>>::__destroy_vector::operator()[abi:ne180100](uint64_t **result)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = *result;
  v2 = **result;
  if (v2)
  {
    v1[1] = v2;
    return (uint64_t **)heap_Free(*(_QWORD **)(v1[3] + 8), v2);
  }
  return result;
}

uint64_t **npy::pyparse::parse_dict@<X0>(uint64_t **result@<X0>, __int128 **a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  uint64_t v11;
  int64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  char *v16;
  int64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  int v21;
  void *v22;
  uint64_t v23;
  char *v24;
  __int128 v25;
  char *v26;
  _BYTE *v27;
  __int128 v28;
  uint64_t v29;
  uint64_t *v30;
  char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  void **v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  _BYTE *v43;
  unsigned __int8 *v44;
  _DWORD *v45;
  _DWORD *exception;
  uint64_t v47;
  uint64_t v48;
  __int128 *v49;
  __int128 v50;
  char v51;
  uint64_t v52;
  _BYTE v53[24];
  uint64_t v54;
  uint64_t v55;
  __int128 __dst;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  char *v60;
  unint64_t v61;
  uint64_t v62;
  __int128 *p_dst;

  v3 = (uint64_t)a3;
  *a3 = 0;
  a3[1] = 0;
  v4 = CustomAllocator::mRsrc;
  *(_QWORD *)(v3 + 16) = CustomAllocator::mRsrc;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = v4;
  *(_QWORD *)(v3 + 40) = 0;
  *(_DWORD *)(v3 + 48) = 1065353216;
  if (a2[1] == *a2)
    return result;
  v6 = (uint64_t)result;
  npy::pyparse::trim((uint64_t)result, v53);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](v6, (__int128 *)v53);
  if ((v53[23] & 0x80000000) != 0)
    heap_Free(*(_QWORD **)(v54 + 8), *(uint64_t *)v53);
  v47 = v3;
  if (*(char *)(v6 + 23) < 0)
  {
    if (**(_BYTE **)v6 != 123)
      goto LABEL_88;
    v7 = *(_QWORD *)(v6 + 8);
    v8 = *(_QWORD *)v6 + v7;
  }
  else
  {
    if (*(_BYTE *)v6 != 123)
      goto LABEL_88;
    v7 = *(unsigned __int8 *)(v6 + 23);
    v8 = v6 + v7;
  }
  if (*(_BYTE *)(v8 - 1) != 125)
  {
LABEL_88:
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 7;
  }
  v59 = (uint64_t *)CustomAllocator::mRsrc;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string(v53, (uint64_t *)v6, 1uLL, v7 - 2);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](v6, (__int128 *)v53);
  if ((v53[23] & 0x80000000) != 0)
    heap_Free(*(_QWORD **)(v54 + 8), *(uint64_t *)v53);
  v59 = 0;
  v60 = 0;
  v61 = 0;
  v62 = CustomAllocator::mRsrc;
  v9 = *a2;
  v49 = a2[1];
  if (*a2 != v49)
  {
    v48 = v6;
    while (1)
    {
      std::operator+<char,std::char_traits<char>,ENTTS::Allocator<char>>("'", (const void **)v9, (void **)&__dst);
      v10 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)&__dst, "'", 1uLL);
      *(_OWORD *)v53 = *(_OWORD *)v10;
      v11 = CustomAllocator::mRsrc;
      *(_QWORD *)&v53[16] = *(_QWORD *)(v10 + 16);
      v54 = CustomAllocator::mRsrc;
      *(_QWORD *)(v10 + 8) = 0;
      *(_QWORD *)(v10 + 16) = 0;
      *(_QWORD *)v10 = 0;
      if (*(char *)(v6 + 23) < 0)
      {
        v13 = *(_QWORD *)v6;
        v12 = *(_QWORD *)(v6 + 8);
      }
      else
      {
        v12 = *(unsigned __int8 *)(v6 + 23);
        v13 = v6;
      }
      v14 = v53[23];
      v15 = *(_QWORD *)v53;
      v16 = v53[23] >= 0 ? v53 : *(char **)v53;
      v17 = v53[23] >= 0 ? v53[23] : *(_QWORD *)&v53[8];
      if (v17)
        break;
      v20 = 0;
      if ((v53[23] & 0x80000000) != 0)
        goto LABEL_39;
LABEL_40:
      if (SHIBYTE(v57) < 0)
        heap_Free(*(_QWORD **)(v58 + 8), __dst);
      if (v20 == -1)
      {
        v45 = __cxa_allocate_exception(0x10uLL);
        *(_QWORD *)v45 = &unk_24D29B1B8;
        v45[2] = 7;
      }
      *(_QWORD *)v53 = v20;
      v55 = CustomAllocator::mRsrc;
      if (*((char *)v9 + 23) < 0)
      {
        std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&v53[8], *(void **)v9, *((_QWORD *)v9 + 1));
      }
      else
      {
        v25 = *v9;
        v54 = *((_QWORD *)v9 + 2);
        *(_OWORD *)&v53[8] = v25;
      }
      v26 = v60;
      if ((unint64_t)v60 >= v61)
      {
        v29 = std::vector<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,ENTTS::Allocator<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__push_back_slow_path<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> const&>((uint64_t *)&v59, (uint64_t)v53);
      }
      else
      {
        *(_QWORD *)v60 = *(_QWORD *)v53;
        v27 = v26 + 8;
        *((_QWORD *)v26 + 4) = CustomAllocator::mRsrc;
        if (SHIBYTE(v54) < 0)
        {
          std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(v27, *(void **)&v53[8], *(unint64_t *)&v53[16]);
        }
        else
        {
          v28 = *(_OWORD *)&v53[8];
          *((_QWORD *)v26 + 3) = v54;
          *(_OWORD *)v27 = v28;
        }
        v29 = (uint64_t)(v26 + 40);
      }
      v60 = (char *)v29;
      if (SHIBYTE(v54) < 0)
        heap_Free(*(_QWORD **)(v55 + 8), *(uint64_t *)&v53[8]);
      v9 += 2;
      if (v9 == v49)
      {
        v30 = v59;
        v31 = v60;
        goto LABEL_57;
      }
    }
    v18 = (char *)(v13 + v12);
    if (v12 >= v17)
    {
      v21 = *v16;
      v22 = (void *)v13;
      do
      {
        v23 = v12 - v17;
        if (v23 == -1)
          break;
        v24 = (char *)memchr(v22, v21, v23 + 1);
        if (!v24)
          break;
        v19 = v24;
        if (!memcmp(v24, v16, v17))
          goto LABEL_34;
        v22 = v19 + 1;
        v12 = v18 - (v19 + 1);
      }
      while (v12 >= v17);
      v19 = v18;
LABEL_34:
      v3 = v47;
    }
    else
    {
      v19 = (char *)(v13 + v12);
    }
    if (v19 == v18)
      v20 = -1;
    else
      v20 = (uint64_t)&v19[-v13];
    v6 = v48;
    if ((v14 & 0x80000000) == 0)
      goto LABEL_40;
LABEL_39:
    heap_Free(*(_QWORD **)(v11 + 8), v15);
    goto LABEL_40;
  }
  v31 = 0;
  v30 = 0;
LABEL_57:
  v32 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((v31 - (char *)v30) >> 3));
  if (v31 == (char *)v30)
    v33 = 0;
  else
    v33 = v32;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *,false>(v30, v31, (uint64_t)&__dst, v33, 1);
  v34 = (uint64_t)v59;
  v35 = v60;
  if (v60 != (char *)v59)
  {
    v36 = 0;
    v37 = 0;
    do
    {
      memset(v53, 0, sizeof(v53));
      v54 = CustomAllocator::mRsrc;
      v38 = *(_QWORD *)(v34 + v36);
      v39 = (void **)(v34 + v36 + 8);
      v58 = CustomAllocator::mRsrc;
      if (*(char *)(v34 + v36 + 31) < 0)
      {
        std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, *v39, *(_QWORD *)(v34 + v36 + 16));
        v34 = (uint64_t)v59;
        v35 = v60;
      }
      else
      {
        v40 = *(_OWORD *)v39;
        v57 = *(_QWORD *)(v34 + v36 + 24);
        __dst = v40;
      }
      if (++v37 >= 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v35[-v34] >> 3))
        v41 = -1;
      else
        v41 = *(_QWORD *)(v34 + v36 + 40);
      p_dst = (__int128 *)CustomAllocator::mRsrc;
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string(&v50, (uint64_t *)v6, v38, v41 - v38);
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)v53, &v50);
      if (v51 < 0)
        heap_Free(*(_QWORD **)(v52 + 8), v50);
      npy::pyparse::trim((uint64_t)v53, &v50);
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)v53, &v50);
      if (v51 < 0)
        heap_Free(*(_QWORD **)(v52 + 8), v50);
      if ((v53[23] & 0x80000000) != 0)
      {
        v43 = *(_BYTE **)v53;
        if (*(_BYTE *)(*(_QWORD *)v53 + *(_QWORD *)&v53[8] - 1) == 44)
        {
          v42 = --*(_QWORD *)&v53[8];
          goto LABEL_77;
        }
      }
      else if (v53[v53[23] - 1] == 44)
      {
        v42 = v53[23] - 1;
        v53[23] = (v53[23] - 1) & 0x7F;
        v43 = v53;
LABEL_77:
        v43[v42] = 0;
      }
      npy::pyparse::get_value_from_map((uint64_t)v53, &v50);
      p_dst = &__dst;
      v44 = std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>,std::tuple<>>(v3, (unsigned __int8 *)&__dst, (uint64_t)&std::piecewise_construct, &p_dst);
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)(v44 + 48), &v50);
      if (v51 < 0)
        heap_Free(*(_QWORD **)(v52 + 8), v50);
      if (SHIBYTE(v57) < 0)
        heap_Free(*(_QWORD **)(v58 + 8), __dst);
      if ((v53[23] & 0x80000000) != 0)
        heap_Free(*(_QWORD **)(v54 + 8), *(uint64_t *)v53);
      v34 = (uint64_t)v59;
      v35 = v60;
      v36 += 40;
    }
    while (v37 < 0xCCCCCCCCCCCCCCCDLL * ((v60 - (char *)v59) >> 3));
  }
  *(_QWORD *)v53 = &v59;
  return std::vector<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,ENTTS::Allocator<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)v53);
}

void sub_214E8CE50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t *a17)
{
  uint64_t v17;
  uint64_t v18;

  a17 = (uint64_t *)(v18 - 136);
  std::vector<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,ENTTS::Allocator<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__destroy_vector::operator()[abi:ne180100](&a17);
  std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::~__hash_table(v17);
  _Unwind_Resume(a1);
}

_BYTE *npy::parse_typestring(_BYTE *result)
{
  int v1;
  unsigned int v2;
  BOOL v3;
  int v4;
  int v6;
  _BYTE *v7;
  int v8;
  unsigned int v9;
  unint64_t i;
  unint64_t v11;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t v14;
  _DWORD *exception;

  if ((char)result[23] < 0)
  {
    v7 = *(_BYTE **)result;
    if (**(_BYTE **)result != 39)
      return result;
    v8 = v7[1];
    if (v8 != 60)
    {
      if (v8 != 124 && v8 != 62)
        return result;
      v7 = *(_BYTE **)result;
    }
    v9 = v7[2];
    if (v9 > 0x68)
    {
      if (v9 != 105 && v9 != 117)
        return result;
    }
    else
    {
      if (v9 != 99 && v9 != 102)
        return result;
      v7 = *(_BYTE **)result;
    }
    v6 = (char)v7[3];
    if (v6 < 48)
      return result;
  }
  else
  {
    if (*result != 39)
      return result;
    v1 = result[1];
    if (v1 != 60 && v1 != 62 && v1 != 124)
      return result;
    v2 = result[2] - 99;
    v3 = v2 > 0x12;
    v4 = (1 << v2) & 0x40049;
    if (v3 || v4 == 0)
      return result;
    v6 = (char)result[3];
    if (v6 <= 47)
      return result;
  }
  if (v6 <= 0x39u)
  {
    for (i = 4; ; ++i)
    {
      v11 = result[23];
      if ((result[23] & 0x80) != 0)
        v11 = *((_QWORD *)result + 1);
      if (i >= v11)
        break;
      v12 = result;
      if ((result[23] & 0x80) != 0)
        v12 = *(_BYTE **)result;
      if ((char)v12[i] < 48)
        break;
      v13 = result;
      if ((result[23] & 0x80) != 0)
        v13 = *(_BYTE **)result;
      if ((char)v13[i] > 57)
        break;
    }
    v14 = result[23];
    if ((result[23] & 0x80) != 0)
      v14 = *((_QWORD *)result + 1);
    if (v14 == i)
      goto LABEL_43;
    if ((result[23] & 0x80) != 0)
      result = *(_BYTE **)result;
    if (result[i] != 39)
    {
LABEL_43:
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &unk_24D29B1B8;
      exception[2] = 4;
    }
  }
  return result;
}

uint64_t npy::pyparse::parse_tuple@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  _DWORD *exception;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 __dst;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  void *v21;

  *a2 = 0;
  a2[1] = 0;
  v4 = CustomAllocator::mRsrc;
  a2[2] = 0;
  a2[3] = v4;
  npy::pyparse::trim(a1, &__dst);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](a1, &__dst);
  if (SHIBYTE(v16) < 0)
    heap_Free(*(_QWORD **)(v17 + 8), __dst);
  if (*(char *)(a1 + 23) < 0)
  {
    if (**(_BYTE **)a1 != 40)
      goto LABEL_22;
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(_QWORD *)a1 + v5;
  }
  else
  {
    if (*(_BYTE *)a1 != 40)
      goto LABEL_22;
    v5 = *(unsigned __int8 *)(a1 + 23);
    v6 = a1 + v5;
  }
  if (*(_BYTE *)(v6 - 1) != 41)
  {
LABEL_22:
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 7;
  }
  *(_QWORD *)&v12 = CustomAllocator::mRsrc;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string(&__dst, (uint64_t *)a1, 1uLL, v5 - 2);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](a1, &__dst);
  if (SHIBYTE(v16) < 0)
    heap_Free(*(_QWORD **)(v17 + 8), __dst);
  std::basic_istringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_istringstream[abi:ne180100]((uint64_t)&__dst, (char **)a1, 8);
  v12 = 0uLL;
  v13 = 0;
  v14 = CustomAllocator::mRsrc;
  while (1)
  {
    v7 = std::getline[abi:ne180100]<char,std::char_traits<char>,ENTTS::Allocator<char>>(&__dst, (uint64_t)&v12, 0x2Cu);
    if ((*((_BYTE *)v7 + *(_QWORD *)(*v7 - 24) + 32) & 5) != 0)
      break;
    v8 = a2[1];
    if (v8 >= a2[2])
    {
      v9 = std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__push_back_slow_path<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>(a2, &v12);
    }
    else
    {
      std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__construct_one_at_end[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>(a2, &v12);
      v9 = v8 + 32;
    }
    a2[1] = v9;
  }
  if (SHIBYTE(v13) < 0)
    heap_Free(*(_QWORD **)(v14 + 8), v12);
  v21 = &unk_24D29C168;
  *(_QWORD *)&__dst = &unk_24D29C140;
  v16 = &unk_24D29B578;
  if (v19 < 0)
    heap_Free(*(_QWORD **)(v20 + 8), v18);
  std::streambuf::~streambuf();
  std::istream::~istream();
  return MEMORY[0x2199DA5E8](&v21);
}

void sub_214E8D324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t ENTTS::stoul(uint64_t a1, _QWORD *a2, int a3)
{
  const char *v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  BOOL v9;
  BOOL v10;
  _DWORD *exception;
  char *__endptr;

  if (*(char *)(a1 + 23) >= 0)
    v5 = (const char *)a1;
  else
    v5 = *(const char **)a1;
  __endptr = 0;
  *__error() = 0;
  v6 = strtoul(v5, &__endptr, a3);
  v7 = __endptr;
  if (v5 == __endptr
    || ((v8 = v6, *__error() != 34) ? (v9 = v8 < (uint64_t)0xFFFFFFFF80000000) : (v9 = 1),
        !v9 ? (v10 = v8 < 0x80000000) : (v10 = 0),
        !v10))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 15;
  }
  if (a2)
    *a2 = v7 - v5;
  return v8;
}

_QWORD *npy::pyparse::trim@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  _QWORD *result;
  uint64_t v16[2];
  unsigned __int8 v17;
  uint64_t v18;
  uint64_t v19;

  v4 = v16;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v16, " \t");
  v5 = *(char *)(a1 + 23);
  if (v5 >= 0)
    v6 = a1;
  else
    v6 = *(_QWORD *)a1;
  if (v5 >= 0)
    v7 = *(unsigned __int8 *)(a1 + 23);
  else
    v7 = *(_QWORD *)(a1 + 8);
  if ((v17 & 0x80u) == 0)
  {
    v8 = v17;
  }
  else
  {
    v4 = (uint64_t *)v16[0];
    v8 = v16[1];
  }
  if (!v7)
    goto LABEL_22;
  v9 = (char *)v6;
  if (v8)
  {
    v10 = v7;
    v9 = (char *)v6;
    while (memchr(v4, *v9, v8))
    {
      ++v9;
      if (!--v10)
        goto LABEL_22;
    }
  }
  v11 = (unint64_t)&v9[-v6];
  if (v11 == -1)
  {
LABEL_22:
    result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a2, "");
  }
  else
  {
    v12 = v7 - 1;
    do
    {
      v13 = v12;
      if (v12 == -1)
        break;
      if (!v8)
        break;
      v14 = memchr(v4, *(char *)(v6 + v12), v8);
      v12 = v13 - 1;
    }
    while (v14);
    v19 = CustomAllocator::mRsrc;
    result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string(a2, (uint64_t *)a1, v11, v13 - v11 + 1);
  }
  if ((char)v17 < 0)
    return heap_Free(*(_QWORD **)(v18 + 8), v16[0]);
  return result;
}

void sub_214E8D590(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::operator+<char,std::char_traits<char>,ENTTS::Allocator<char>>@<X0>(const char *a1@<X0>, const void **a2@<X1>, void **a3@<X8>)
{
  size_t v6;
  size_t v7;
  size_t v8;
  uint64_t result;
  const void *v10;

  v6 = strlen(a1);
  v7 = v6;
  if (*((char *)a2 + 23) >= 0)
    v8 = *((unsigned __int8 *)a2 + 23);
  else
    v8 = (size_t)a2[1];
  result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]((uint64_t)a3, v8 + v6);
  if (*((char *)a3 + 23) < 0)
    a3 = (void **)*a3;
  if (v7)
    result = (uint64_t)memmove(a3, a1, v7);
  if (v8)
  {
    if (*((char *)a2 + 23) >= 0)
      v10 = a2;
    else
      v10 = *a2;
    result = (uint64_t)memmove((char *)a3 + v7, v10, v8);
  }
  *((_BYTE *)a3 + v7 + v8) = 0;
  return result;
}

uint64_t std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), *(_QWORD *)(a1 + 8));
  return a1;
}

_QWORD *npy::pyparse::get_value_from_map@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *result;
  uint64_t __dst[2];
  char v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *(_QWORD *)a1;
  if (*(char *)(a1 + 23) < 0)
  {
    v4 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    v3 = a1;
    v4 = *(unsigned __int8 *)(a1 + 23);
  }
  if (!v4)
    return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a2, "");
  v5 = 0;
  while (*(_BYTE *)(v3 + v5) != 58)
  {
    if (v4 == ++v5)
      return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a2, "");
  }
  if (v4 == v5 || v5 == -1)
    return std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(a2, "");
  v10 = CustomAllocator::mRsrc;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string(__dst, (uint64_t *)a1, v5 + 1, 0xFFFFFFFFFFFFFFFFLL);
  result = npy::pyparse::trim((uint64_t)__dst, a2);
  if (v8 < 0)
    return heap_Free(*(_QWORD **)(v9 + 8), __dst[0]);
  return result;
}

void sub_214E8D788(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)(a1 + 24) = CustomAllocator::mRsrc;
  v3 = a1 + 24;
  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__throw_length_error[abi:ne180100]();
  if (a2 > 0x16)
  {
    v5 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v5 = a2 | 7;
    v6 = v5 + 1;
    v7 = ENTTS::Allocator<char>::allocate(v3, v5 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v6 | 0x8000000000000000;
    *(_QWORD *)a1 = v7;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

uint64_t std::vector<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,ENTTS::Allocator<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__push_back_slow_path<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666)
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 3);
  v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x333333333333333)
    v9 = 0x666666666666666;
  else
    v9 = v5;
  v17 = a1 + 3;
  if (v9)
    v10 = ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (_QWORD *)(v10 + 40 * v4);
  v16 = v10 + 40 * v9;
  std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::pair[abi:ne180100](v14, a2);
  v15 = v14 + 5;
  std::vector<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,ENTTS::Allocator<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,ENTTS::Allocator<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>> &>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_214E8D92C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,ENTTS::Allocator<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>> &>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::pair[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  __int128 v4;

  *a1 = *(_QWORD *)a2;
  v3 = a1 + 1;
  a1[4] = CustomAllocator::mRsrc;
  if (*(char *)(a2 + 31) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(v3, *(void **)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  else
  {
    v4 = *(_OWORD *)(a2 + 8);
    v3[2] = *(_QWORD *)(a2 + 24);
    *(_OWORD *)v3 = v4;
  }
  return a1;
}

uint64_t *std::vector<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,ENTTS::Allocator<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  if (v2 != *result)
  {
    do
    {
      v5 = *(_QWORD *)(v2 - 40);
      v2 -= 40;
      *(_QWORD *)(v4 - 40) = v5;
      v4 -= 40;
      v6 = *(_OWORD *)(v2 + 8);
      *(_QWORD *)(v4 + 24) = *(_QWORD *)(v2 + 24);
      *(_OWORD *)(v4 + 8) = v6;
      *(_QWORD *)(v4 + 32) = CustomAllocator::mRsrc;
      *(_QWORD *)(v2 + 8) = 0;
      *(_QWORD *)(v2 + 16) = 0;
      *(_QWORD *)(v2 + 24) = 0;
    }
    while (v2 != v3);
  }
  a2[1] = v4;
  v7 = *result;
  *result = v4;
  a2[1] = v7;
  v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

_QWORD *std::__destroy_at[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,0>(_QWORD *result)
{
  if (*((char *)result + 31) < 0)
    return heap_Free(*(_QWORD **)(result[4] + 8), result[1]);
  return result;
}

uint64_t std::__split_buffer<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,ENTTS::Allocator<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>> &>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 40;
    std::__destroy_at[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,0>((_QWORD *)(i - 40));
  }
  if (*(_QWORD *)a1)
    heap_Free(*(_QWORD **)(**(_QWORD **)(a1 + 32) + 8), *(_QWORD *)a1);
  return a1;
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *,false>(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  __int128 v19;
  unint64_t v20;
  char v21;
  BOOL v22;
  uint64_t v23;
  __int128 v24;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;

uint64_t std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  const void *v5;
  const void *v6;
  int v7;
  _QWORD *v8;
  const void *v9;
  const void *v10;
  int v11;
  size_t v12;
  const void *v13;
  size_t v14;
  const void *v15;
  size_t v16;
  int v17;

  if (*a2 < *a3)
    return 1;
  if (*a3 < *a2)
    return 0;
  v6 = (const void *)a3[1];
  v4 = a3 + 1;
  v5 = v6;
  v7 = *((char *)v4 + 23);
  v10 = (const void *)a2[1];
  v8 = a2 + 1;
  v9 = v10;
  v11 = *((char *)v8 + 23);
  if (v11 >= 0)
    v12 = *((unsigned __int8 *)v8 + 23);
  else
    v12 = v8[1];
  if (v11 >= 0)
    v13 = v8;
  else
    v13 = v9;
  if (v7 >= 0)
    v14 = *((unsigned __int8 *)v4 + 23);
  else
    v14 = v4[1];
  if (v7 >= 0)
    v15 = v4;
  else
    v15 = v5;
  if (v14 >= v12)
    v16 = v12;
  else
    v16 = v14;
  v17 = memcmp(v13, v15, v16);
  if (v17)
    return v17 < 0;
  else
    return v12 < v14;
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(uint64_t result, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char v14;
  _QWORD *v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;

  if ((_QWORD *)result != a2)
  {
    v4 = (_QWORD *)result;
    v5 = (_QWORD *)(result + 40);
    if ((_QWORD *)(result + 40) != a2)
    {
      v7 = 0;
      v8 = (_QWORD *)result;
      do
      {
        v9 = v5;
        result = std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, v5, v8);
        if ((_DWORD)result)
        {
          v10 = *v9;
          v17 = *((_OWORD *)v8 + 3);
          v18 = v8[8];
          v16 = v10;
          v19 = CustomAllocator::mRsrc;
          v8[6] = 0;
          v8[7] = 0;
          v11 = v7;
          v8[8] = 0;
          while (1)
          {
            v12 = v11;
            v13 = (char *)v4 + v11;
            *((_QWORD *)v13 + 5) = *(_QWORD *)v13;
            std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)(v13 + 48), (__int128 *)(v13 + 8));
            if (!v12)
              break;
            v14 = std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, &v16, (_QWORD *)((char *)v4 + v12 - 40));
            v11 = v12 - 40;
            if ((v14 & 1) == 0)
            {
              v15 = (_QWORD *)((char *)v4 + v12);
              goto LABEL_10;
            }
          }
          v15 = v4;
LABEL_10:
          *v15 = v16;
          result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)v4 + v12 + 8, &v17);
          if (SHIBYTE(v18) < 0)
            result = (uint64_t)heap_Free(*(_QWORD **)(v19 + 8), v17);
        }
        v5 = v9 + 5;
        v7 += 40;
        v8 = v9;
      }
      while (v9 + 5 != a2);
    }
  }
  return result;
}

void sub_214E8E078(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(uint64_t result, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;

  if ((_QWORD *)result != a2)
  {
    v4 = (_QWORD *)result;
    v5 = (_QWORD *)(result + 40);
    if ((_QWORD *)(result + 40) != a2)
    {
      v7 = result + 48;
      do
      {
        v8 = v5;
        result = std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, v5, v4);
        if ((_DWORD)result)
        {
          v9 = *v8;
          v14 = *((_OWORD *)v4 + 3);
          v15 = v4[8];
          v13 = v9;
          v16 = CustomAllocator::mRsrc;
          v4[6] = 0;
          v4[7] = 0;
          v10 = v7;
          v4[8] = 0;
          do
          {
            *(_QWORD *)(v10 - 8) = *(_QWORD *)(v10 - 48);
            v11 = v10 - 40;
            std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](v10, (__int128 *)(v10 - 40));
            v12 = std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, &v13, (_QWORD *)(v10 - 88));
            v10 -= 40;
          }
          while ((v12 & 1) != 0);
          *(_QWORD *)(v11 - 8) = v13;
          result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](v11, &v14);
          if (SHIBYTE(v15) < 0)
            result = (uint64_t)heap_Free(*(_QWORD **)(v16 + 8), v14);
        }
        v5 = v8 + 5;
        v7 += 40;
        v4 = v8;
      }
      while (v8 + 5 != a2);
    }
  }
  return result;
}

void sub_214E8E1B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  char v8;
  uint64_t result;
  __int128 *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;

  v8 = std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a4, a2, a1);
  result = std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a4, a3, a2);
  if ((v8 & 1) == 0)
  {
    if (!(_DWORD)result)
      return result;
    v15 = *a2;
    *a2 = *a3;
    *a3 = v15;
    v16 = a2[3];
    v17 = *(_OWORD *)(a2 + 1);
    v18 = a3[3];
    *(_OWORD *)(a2 + 1) = *(_OWORD *)(a3 + 1);
    a2[3] = v18;
    *(_OWORD *)(a3 + 1) = v17;
    a3[3] = v16;
    if (!std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a4, a2, a1))return 1;
    v19 = *a1;
    *a1 = *a2;
    *a2 = v19;
    v20 = a1[3];
    v21 = *(_OWORD *)(a1 + 1);
    v22 = a2[3];
    *(_OWORD *)(a1 + 1) = *(_OWORD *)(a2 + 1);
    a1[3] = v22;
    *(_OWORD *)(a2 + 1) = v21;
    a2[3] = v20;
    return 2;
  }
  v10 = (__int128 *)(a1 + 1);
  v11 = *a1;
  if (!(_DWORD)result)
  {
    *a1 = *a2;
    *a2 = v11;
    v23 = a1[3];
    v24 = *v10;
    v25 = a2[3];
    *v10 = *(_OWORD *)(a2 + 1);
    a1[3] = v25;
    *(_OWORD *)(a2 + 1) = v24;
    a2[3] = v23;
    if (!std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a4, a3, a2))return 1;
    v26 = *a2;
    *a2 = *a3;
    *a3 = v26;
    v27 = a2[3];
    v28 = *(_OWORD *)(a2 + 1);
    v29 = a3[3];
    *(_OWORD *)(a2 + 1) = *(_OWORD *)(a3 + 1);
    a2[3] = v29;
    *(_OWORD *)(a3 + 1) = v28;
    a3[3] = v27;
    return 2;
  }
  *a1 = *a3;
  *a3 = v11;
  v12 = a1[3];
  v13 = *v10;
  v14 = a3[3];
  *v10 = *(_OWORD *)(a3 + 1);
  a1[3] = v14;
  *(_OWORD *)(a3 + 1) = v13;
  a3[3] = v12;
  return 1;
}

_QWORD *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *,std::__less<void,void> &>(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  _QWORD *v6;
  _QWORD *v7;
  int v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;

  v4 = a2;
  v14 = *a1;
  v15 = *(_OWORD *)(a1 + 1);
  v16 = a1[3];
  v17 = CustomAllocator::mRsrc;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  if ((std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, &v14, (_QWORD *)(a2 - 40)) & 1) != 0)
  {
    v6 = a1;
    do
      v6 += 5;
    while ((std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, &v14, v6) & 1) == 0);
  }
  else
  {
    v7 = a1 + 5;
    do
    {
      v6 = v7;
      if ((unint64_t)v7 >= v4)
        break;
      v8 = std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, &v14, v7);
      v7 = v6 + 5;
    }
    while (!v8);
  }
  if ((unint64_t)v6 < v4)
  {
    do
      v4 -= 40;
    while ((std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, &v14, (_QWORD *)v4) & 1) != 0);
  }
  while ((unint64_t)v6 < v4)
  {
    v9 = *v6;
    *v6 = *(_QWORD *)v4;
    *(_QWORD *)v4 = v9;
    v10 = *(_OWORD *)(v6 + 1);
    v19 = v6[3];
    v18 = v10;
    v11 = *(_OWORD *)(v4 + 8);
    v6[3] = *(_QWORD *)(v4 + 24);
    *(_OWORD *)(v6 + 1) = v11;
    v12 = v18;
    *(_QWORD *)(v4 + 24) = v19;
    *(_OWORD *)(v4 + 8) = v12;
    do
      v6 += 5;
    while (!std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, &v14, v6));
    do
      v4 -= 40;
    while ((std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, &v14, (_QWORD *)v4) & 1) != 0);
  }
  if (v6 - 5 != a1)
  {
    *a1 = *(v6 - 5);
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)(a1 + 1), (__int128 *)v6 - 2);
  }
  *(v6 - 5) = v14;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)(v6 - 4), &v15);
  if (SHIBYTE(v16) < 0)
    heap_Free(*(_QWORD **)(v17 + 8), v15);
  return v6;
}

void sub_214E8E524(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *,std::__less<void,void> &>(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;

  v6 = 0;
  v17 = *a1;
  v19 = a1[3];
  v20 = CustomAllocator::mRsrc;
  v7 = (uint64_t)(a1 + 1);
  v18 = *(_OWORD *)(a1 + 1);
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  do
  {
    v8 = std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, &a1[v6 + 5], &v17);
    v6 += 5;
  }
  while ((v8 & 1) != 0);
  v9 = (unint64_t)&a1[v6];
  if (v6 == 5)
  {
    do
    {
      if (v9 >= (unint64_t)a2)
        break;
      a2 -= 5;
    }
    while ((std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, a2, &v17) & 1) == 0);
  }
  else
  {
    do
      a2 -= 5;
    while (!std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, a2, &v17));
  }
  v10 = (unint64_t)&a1[v6];
  if (v9 < (unint64_t)a2)
  {
    v11 = a2;
    do
    {
      v12 = *(_QWORD *)v10;
      *(_QWORD *)v10 = *v11;
      *v11 = v12;
      v13 = *(_OWORD *)(v10 + 8);
      v22 = *(_QWORD *)(v10 + 24);
      v21 = v13;
      v14 = *(_OWORD *)(v11 + 1);
      *(_QWORD *)(v10 + 24) = v11[3];
      *(_OWORD *)(v10 + 8) = v14;
      v15 = v21;
      v11[3] = v22;
      *(_OWORD *)(v11 + 1) = v15;
      do
        v10 += 40;
      while ((std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, (_QWORD *)v10, &v17) & 1) != 0);
      do
        v11 -= 5;
      while (!std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, v11, &v17));
    }
    while (v10 < (unint64_t)v11);
  }
  if ((uint64_t *)(v10 - 40) != a1)
  {
    *a1 = *(_QWORD *)(v10 - 40);
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](v7, (__int128 *)(v10 - 32));
  }
  *(_QWORD *)(v10 - 40) = v17;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](v10 - 32, &v18);
  if (SHIBYTE(v19) < 0)
    heap_Free(*(_QWORD **)(v20 + 8), v18);
  return v10 - 40;
}

void sub_214E8E718(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  _QWORD *v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;

  v6 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, (_QWORD *)(a2 - 40), (_QWORD *)a1))
      {
        v8 = *(_QWORD *)a1;
        *(_QWORD *)a1 = *(_QWORD *)(a2 - 40);
        *(_QWORD *)(a2 - 40) = v8;
        v9 = *(_QWORD *)(a1 + 24);
        v10 = *(_OWORD *)(a1 + 8);
        v11 = *(_QWORD *)(a2 - 16);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 - 32);
        *(_QWORD *)(a1 + 24) = v11;
        *(_OWORD *)(a2 - 32) = v10;
        *(_QWORD *)(a2 - 16) = v9;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>((uint64_t *)a1, (uint64_t *)(a1 + 40), (uint64_t *)(a2 - 40), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(a1, a1 + 40, a1 + 80, a2 - 40, a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(a1, a1 + 40, a1 + 80, a1 + 120, a2 - 40, a3);
      return 1;
    default:
      v12 = (_QWORD *)(a1 + 80);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>((uint64_t *)a1, (uint64_t *)(a1 + 40), (uint64_t *)(a1 + 80), a3);
      v13 = a1 + 120;
      if (a1 + 120 == a2)
        return 1;
      v14 = 0;
      v15 = 0;
      break;
  }
  while (1)
  {
    if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, (_QWORD *)v13, v12))
    {
      v16 = *(_QWORD *)v13;
      v23 = *(_OWORD *)(v13 + 8);
      v24 = *(_QWORD *)(v13 + 24);
      v22 = v16;
      v25 = CustomAllocator::mRsrc;
      *(_QWORD *)(v13 + 8) = 0;
      *(_QWORD *)(v13 + 16) = 0;
      v17 = v14;
      *(_QWORD *)(v13 + 24) = 0;
      while (1)
      {
        v18 = v17;
        v19 = a1 + v17;
        *(_QWORD *)(v19 + 120) = *(_QWORD *)(v19 + 80);
        std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](v19 + 128, (__int128 *)(v19 + 88));
        if (v18 == -80)
          break;
        v20 = std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, &v22, (_QWORD *)(a1 + v18 + 40));
        v17 = v18 - 40;
        if ((v20 & 1) == 0)
        {
          v21 = (_QWORD *)(a1 + v17 + 120);
          goto LABEL_12;
        }
      }
      v21 = (_QWORD *)a1;
LABEL_12:
      *v21 = v22;
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](a1 + v18 + 88, &v23);
      if (SHIBYTE(v24) < 0)
        heap_Free(*(_QWORD **)(v25 + 8), v23);
      if (++v15 == 8)
        return v13 + 40 == a2;
    }
    v12 = (_QWORD *)v13;
    v14 += 40;
    v13 += 40;
    if (v13 == a2)
      return 1;
  }
}

void sub_214E8E998(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __n128 result;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>((uint64_t *)a1, (uint64_t *)a2, (uint64_t *)a3, a5);
  if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a5, (_QWORD *)a4, (_QWORD *)a3))
  {
    v11 = *(_QWORD *)a3;
    *(_QWORD *)a3 = *(_QWORD *)a4;
    *(_QWORD *)a4 = v11;
    v12 = *(_QWORD *)(a3 + 24);
    v13 = *(_OWORD *)(a3 + 8);
    v14 = *(_QWORD *)(a4 + 24);
    *(_OWORD *)(a3 + 8) = *(_OWORD *)(a4 + 8);
    *(_QWORD *)(a3 + 24) = v14;
    *(_OWORD *)(a4 + 8) = v13;
    *(_QWORD *)(a4 + 24) = v12;
    if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a5, (_QWORD *)a3, (_QWORD *)a2))
    {
      v15 = *(_QWORD *)a2;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v15;
      v16 = *(_QWORD *)(a2 + 24);
      v17 = *(_OWORD *)(a2 + 8);
      v18 = *(_QWORD *)(a3 + 24);
      *(_OWORD *)(a2 + 8) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(a2 + 24) = v18;
      *(_OWORD *)(a3 + 8) = v17;
      *(_QWORD *)(a3 + 24) = v16;
      if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a5, (_QWORD *)a2, (_QWORD *)a1))
      {
        v19 = *(_QWORD *)a1;
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_QWORD *)a2 = v19;
        v20 = *(_QWORD *)(a1 + 24);
        result = *(__n128 *)(a1 + 8);
        v21 = *(_QWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
        *(_QWORD *)(a1 + 24) = v21;
        *(__n128 *)(a2 + 8) = result;
        *(_QWORD *)(a2 + 24) = v20;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __n128 result;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(a1, a2, a3, a4, a6);
  if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a6, (_QWORD *)a5, (_QWORD *)a4))
  {
    v13 = *(_QWORD *)a4;
    *(_QWORD *)a4 = *(_QWORD *)a5;
    *(_QWORD *)a5 = v13;
    v14 = *(_QWORD *)(a4 + 24);
    v15 = *(_OWORD *)(a4 + 8);
    v16 = *(_QWORD *)(a5 + 24);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(a5 + 8);
    *(_QWORD *)(a4 + 24) = v16;
    *(_OWORD *)(a5 + 8) = v15;
    *(_QWORD *)(a5 + 24) = v14;
    if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a6, (_QWORD *)a4, (_QWORD *)a3))
    {
      v17 = *(_QWORD *)a3;
      *(_QWORD *)a3 = *(_QWORD *)a4;
      *(_QWORD *)a4 = v17;
      v18 = *(_QWORD *)(a3 + 24);
      v19 = *(_OWORD *)(a3 + 8);
      v20 = *(_QWORD *)(a4 + 24);
      *(_OWORD *)(a3 + 8) = *(_OWORD *)(a4 + 8);
      *(_QWORD *)(a3 + 24) = v20;
      *(_OWORD *)(a4 + 8) = v19;
      *(_QWORD *)(a4 + 24) = v18;
      if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a6, (_QWORD *)a3, (_QWORD *)a2))
      {
        v21 = *(_QWORD *)a2;
        *(_QWORD *)a2 = *(_QWORD *)a3;
        *(_QWORD *)a3 = v21;
        v22 = *(_QWORD *)(a2 + 24);
        v23 = *(_OWORD *)(a2 + 8);
        v24 = *(_QWORD *)(a3 + 24);
        *(_OWORD *)(a2 + 8) = *(_OWORD *)(a3 + 8);
        *(_QWORD *)(a2 + 24) = v24;
        *(_OWORD *)(a3 + 8) = v23;
        *(_QWORD *)(a3 + 24) = v22;
        if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a6, (_QWORD *)a2, (_QWORD *)a1))
        {
          v25 = *(_QWORD *)a1;
          *(_QWORD *)a1 = *(_QWORD *)a2;
          *(_QWORD *)a2 = v25;
          v26 = *(_QWORD *)(a1 + 24);
          result = *(__n128 *)(a1 + 8);
          v27 = *(_QWORD *)(a2 + 24);
          *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
          *(_QWORD *)(a1 + 24) = v27;
          *(__n128 *)(a2 + 8) = result;
          *(_QWORD *)(a2 + 24) = v26;
        }
      }
    }
  }
  return result;
}

uint64_t std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(char *a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  _OWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  unint64_t v20;

  if (a1 != a2)
  {
    v6 = (uint64_t)a2;
    v8 = a2 - a1;
    v9 = (a2 - a1) / 40;
    if (a2 - a1 >= 41)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[40 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>((uint64_t)a1, a4, v9, v12);
        v12 -= 40;
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = a1 + 8;
      v15 = v6;
      do
      {
        if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a4, (_QWORD *)v15, a1))
        {
          v16 = *(_QWORD *)v15;
          *(_QWORD *)v15 = *(_QWORD *)a1;
          *(_QWORD *)a1 = v16;
          v17 = *(_QWORD *)(v15 + 24);
          v18 = *(_OWORD *)(v15 + 8);
          v19 = *((_QWORD *)a1 + 3);
          *(_OWORD *)(v15 + 8) = *v14;
          *(_QWORD *)(v15 + 24) = v19;
          *v14 = v18;
          *((_QWORD *)a1 + 3) = v17;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>((uint64_t)a1, a4, v9, a1);
        }
        v15 += 40;
      }
      while (v15 != a3);
      v13 = a3;
    }
    if (v8 >= 41)
    {
      v20 = v8 / 0x28uLL;
      do
      {
        std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(a1, v6, a4, v20);
        v6 -= 40;
      }
      while (v20-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(uint64_t result, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  int64_t v7;
  int64_t v10;
  uint64_t v11;
  int64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;

  v4 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = a4;
    v6 = result;
    v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)a4 - result) >> 3)))
    {
      v10 = (0x999999999999999ALL * (((uint64_t)a4 - result) >> 3)) | 1;
      v11 = result + 40 * v10;
      v12 = 0x999999999999999ALL * (((uint64_t)a4 - result) >> 3) + 2;
      if (v12 < a3
        && std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a2, (_QWORD *)(result + 40 * v10), (_QWORD *)(v11 + 40)))
      {
        v11 += 40;
        v10 = v12;
      }
      result = std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a2, (_QWORD *)v11, v5);
      if ((result & 1) == 0)
      {
        v16 = *v5;
        v17 = *(_OWORD *)(v5 + 1);
        v18 = v5[3];
        v19 = CustomAllocator::mRsrc;
        v5[1] = 0;
        v5[2] = 0;
        v5[3] = 0;
        do
        {
          v13 = (_QWORD *)v11;
          v14 = v11 + 8;
          *v5 = *(_QWORD *)v11;
          std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)(v5 + 1), (__int128 *)(v11 + 8));
          if (v7 < v10)
            break;
          v15 = (2 * v10) | 1;
          v11 = v6 + 40 * v15;
          v10 = 2 * v10 + 2;
          if (v10 >= a3)
          {
            v10 = v15;
          }
          else if (std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a2, (_QWORD *)(v6 + 40 * v15), (_QWORD *)(v11 + 40)))
          {
            v11 += 40;
          }
          else
          {
            v10 = v15;
          }
          v5 = v13;
        }
        while (!std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a2, (_QWORD *)v11, &v16));
        *v13 = v16;
        result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](v14, &v17);
        if (SHIBYTE(v18) < 0)
          return (uint64_t)heap_Free(*(_QWORD **)(v19 + 8), v17);
      }
    }
  }
  return result;
}

void sub_214E8EF54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  __int128 *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;

  if (a4 >= 2)
  {
    v6 = result;
    v11 = *result;
    v12 = *(_OWORD *)(result + 1);
    v13 = result[3];
    v14 = CustomAllocator::mRsrc;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    v7 = (_QWORD *)std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(result, a3, a4);
    v8 = v7;
    v9 = (_QWORD *)(a2 - 40);
    if (v7 == (_QWORD *)(a2 - 40))
    {
      *v7 = v11;
      result = (_QWORD *)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)(v7 + 1), &v12);
    }
    else
    {
      *v7 = *(_QWORD *)(a2 - 40);
      v10 = (__int128 *)(a2 - 32);
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)(v7 + 1), v10);
      *v9 = v11;
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)v10, &v12);
      result = std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(v6, (uint64_t)(v8 + 5), a3, 0xCCCCCCCCCCCCCCCDLL * (v8 + 5 - v6));
    }
    if (SHIBYTE(v13) < 0)
      return heap_Free(*(_QWORD **)(v14 + 8), v12);
  }
  return result;
}

void sub_214E8F084(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = 0;
  v7 = a3 - 2;
  if (a3 < 2)
    v7 = a3 - 1;
  v8 = v7 >> 1;
  do
  {
    v9 = (uint64_t)&a1[5 * v6 + 5];
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3
      && std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a2, &a1[5 * v6 + 5], &a1[5 * v6 + 10]))
    {
      v9 += 40;
      v10 = v11;
    }
    *a1 = *(_QWORD *)v9;
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)(a1 + 1), (__int128 *)(v9 + 8));
    a1 = (_QWORD *)v9;
    v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

_QWORD *std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> *>(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;

  if (a4 >= 2)
  {
    v6 = result;
    v7 = (unint64_t)(a4 - 2) >> 1;
    v8 = &result[5 * v7];
    v9 = (_QWORD *)(a2 - 40);
    result = (_QWORD *)std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, v8, (_QWORD *)(a2 - 40));
    if ((_DWORD)result)
    {
      v12 = *(_QWORD *)(a2 - 40);
      v13 = *(_OWORD *)(a2 - 32);
      v14 = *(_QWORD *)(a2 - 16);
      v15 = CustomAllocator::mRsrc;
      *(_QWORD *)(a2 - 32) = 0;
      *(_QWORD *)(a2 - 24) = 0;
      *(_QWORD *)(a2 - 16) = 0;
      do
      {
        v10 = v8;
        v11 = (uint64_t)(v8 + 1);
        *v9 = *v8;
        std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)(v9 + 1), (__int128 *)(v8 + 1));
        if (!v7)
          break;
        v7 = (v7 - 1) >> 1;
        v8 = &v6[5 * v7];
        v9 = v10;
      }
      while ((std::__less<void,void>::operator()[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>(a3, v8, &v12) & 1) != 0);
      *v10 = v12;
      result = (_QWORD *)std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100](v11, &v13);
      if (SHIBYTE(v14) < 0)
        return heap_Free(*(_QWORD **)(v15 + 8), v13);
    }
  }
  return result;
}

void sub_214E8F280(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  unint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned int v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *v15;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  __int128 **v26;
  _QWORD v27[3];

  v7 = 0xCBF29CE484222325;
  v8 = a2[23];
  if ((v8 & 0x80u) == 0)
    v9 = a2;
  else
    v9 = *(unsigned __int8 **)a2;
  if ((v8 & 0x80u) != 0)
    v8 = *((_QWORD *)a2 + 1);
  for (; v8; --v8)
  {
    v10 = *v9++;
    v7 = 0x100000001B3 * (v7 ^ v10);
  }
  v11 = *(_QWORD *)(a1 + 8);
  if (!v11)
    goto LABEL_27;
  v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
  v12.i16[0] = vaddlv_u8(v12);
  v13 = v12.u32[0];
  if (v12.u32[0] > 1uLL)
  {
    v4 = v7;
    if (v7 >= v11)
      v4 = v7 % v11;
  }
  else
  {
    v4 = (v11 - 1) & v7;
  }
  v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
  if (!v14)
    goto LABEL_27;
  v15 = *v14;
  if (!*v14)
    goto LABEL_27;
  v26 = a4;
  do
  {
    v16 = *((_QWORD *)v15 + 1);
    if (v16 == v7)
    {
      if ((std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::operator()[abi:ne180100](a1 + 48, v15 + 16, a2) & 1) != 0)return v15;
      goto LABEL_25;
    }
    if (v13 > 1)
    {
      if (v16 >= v11)
        v16 %= v11;
    }
    else
    {
      v16 &= v11 - 1;
    }
    if (v16 != v4)
      break;
LABEL_25:
    v15 = *(unsigned __int8 **)v15;
  }
  while (v15);
  a4 = v26;
LABEL_27:
  std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>,std::tuple<>>(a1, v7, a4, (uint64_t)v27);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 40) + 1);
  v18 = *(float *)(a1 + 48);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__rehash<true>((uint64_t *)a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v7 >= v11)
        v4 = v7 % v11;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v11 - 1) & v7;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v27[0] = *v23;
    *v23 = v27[0];
  }
  else
  {
    *(_QWORD *)v27[0] = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v27[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 24;
    if (*(_QWORD *)v27[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v27[0];
    }
  }
  v15 = (unsigned __int8 *)v27[0];
  ++*(_QWORD *)(a1 + 40);
  return v15;
}

void sub_214E8F528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a12)
    std::__hash_node_destructor<ENTTS::Allocator<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *>>>::operator()[abi:ne180100](&a13, a12);
  _Unwind_Resume(exception_object);
}

_QWORD *std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v7 = a1 + 32;
  v8 = (_QWORD *)ENTTS::Allocator<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *>>::allocate(a1 + 32, 1);
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  result = std::pair<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const,std::vector<float,ENTTS::Allocator<float>>>::pair[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>(v8 + 2, *a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_214E8F5C4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;

  *v1 = 0;
  std::__hash_node_destructor<ENTTS::Allocator<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::operator()[abi:ne180100](uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v14;
  uint64_t result;

  v3 = a3;
  v4 = a2[23];
  if ((v4 & 0x80u) == 0)
    v5 = a2[23];
  else
    v5 = *((_QWORD *)a2 + 1);
  v6 = a3[23];
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *((_QWORD *)a3 + 1);
  if (v5 != v6)
    return 0;
  if (v7 < 0)
    v3 = *(unsigned __int8 **)a3;
  if ((v4 & 0x80) != 0)
    return memcmp(*(const void **)a2, v3, *((_QWORD *)a2 + 1)) == 0;
  if (!a2[23])
    return 1;
  v8 = v4 - 1;
  do
  {
    v10 = *a2++;
    v9 = v10;
    v12 = *v3++;
    v11 = v12;
    v14 = v8-- != 0;
    result = v9 == v11;
  }
  while (v9 == v11 && v14);
  return result;
}

uint64_t ENTTS::Allocator<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *>>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 80 * a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__rehash<true>(uint64_t *result, size_t __n)
{
  uint64_t *v2;
  unint64_t v3;
  int8x8_t v4;
  uint8x8_t v5;
  uint64_t *v6;

  v2 = result;
  if (__n == 1)
  {
    v3 = 2;
  }
  else
  {
    v3 = __n;
    if ((__n & (__n - 1)) != 0)
    {
      result = (uint64_t *)std::__next_prime(__n);
      v3 = (unint64_t)result;
    }
  }
  v4 = (int8x8_t)v2[1];
  if (v3 > *(_QWORD *)&v4)
    return std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__do_rehash<true>(v2, v3);
  if (v3 < *(_QWORD *)&v4)
  {
    result = (uint64_t *)vcvtps_u32_f32((float)(unint64_t)v2[5] / *((float *)v2 + 12));
    if (*(_QWORD *)&v4 < 3uLL || (v5 = (uint8x8_t)vcnt_s8(v4), v5.i16[0] = vaddlv_u8(v5), v5.u32[0] > 1uLL))
    {
      result = (uint64_t *)std::__next_prime((size_t)result);
    }
    else
    {
      v6 = (uint64_t *)(1 << -(char)__clz((unint64_t)result - 1));
      if ((unint64_t)result >= 2)
        result = v6;
    }
    if (v3 <= (unint64_t)result)
      v3 = (unint64_t)result;
    if (v3 < *(_QWORD *)&v4)
      return std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__do_rehash<true>(v2, v3);
  }
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__do_rehash<true>(uint64_t *result, unint64_t a2)
{
  uint64_t *v2;
  unint64_t *v3;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;

  v2 = result;
  v3 = (unint64_t *)(result + 1);
  if (a2)
  {
    result = (uint64_t *)ENTTS::Allocator<unsigned long>::allocate((uint64_t)(result + 2), a2);
    v5 = *v2;
    *v2 = (uint64_t)result;
    if (v5)
      result = std::__bucket_list_deallocator<ENTTS::Allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *> *> *>>::operator()[abi:ne180100]((uint64_t)v3, v5);
    v6 = 0;
    *v3 = a2;
    do
      *(_QWORD *)(*v2 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = (_QWORD *)v2[3];
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*v2 + 8 * v8) = v2 + 3;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*v2 + 8 * v12))
            {
              *(_QWORD *)(*v2 + 8 * v12) = v7;
              goto LABEL_23;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*v2 + 8 * v12);
            **(_QWORD **)(*v2 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_23:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *result;
    *result = 0;
    if (v10)
      result = std::__bucket_list_deallocator<ENTTS::Allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *> *> *>>::operator()[abi:ne180100]((uint64_t)(result + 1), v10);
    *v3 = 0;
  }
  return result;
}

_QWORD *std::__bucket_list_deallocator<ENTTS::Allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *> *> *>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  return heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 8), a2);
}

uint64_t *std::__hash_node_destructor<ENTTS::Allocator<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *>>>::operator()[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t *v3;

  v3 = result;
  if (*((_BYTE *)result + 8))
    result = std::__destroy_at[abi:ne180100]<std::pair<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,0>((uint64_t *)(a2 + 16));
  if (a2)
    return heap_Free(*(_QWORD **)(*(_QWORD *)*v3 + 8), a2);
  return result;
}

uint64_t *std::__destroy_at[abi:ne180100]<std::pair<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,0>(uint64_t *result)
{
  uint64_t *v1;

  v1 = result;
  if (*((char *)result + 55) < 0)
    result = heap_Free(*(_QWORD **)(result[7] + 8), result[4]);
  if (*((char *)v1 + 23) < 0)
    return heap_Free(*(_QWORD **)(v1[3] + 8), *v1);
  return result;
}

uint64_t **std::vector<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,ENTTS::Allocator<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__destroy_vector::operator()[abi:ne180100](uint64_t **result)
{
  uint64_t *v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t **v6;

  v1 = *result;
  v2 = (_QWORD *)**result;
  if (v2)
  {
    v3 = (_QWORD *)v1[1];
    v4 = **result;
    v5 = *result;
    if (v3 != v2)
    {
      v6 = result;
      do
      {
        v3 -= 5;
        std::__destroy_at[abi:ne180100]<std::pair<unsigned long,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,0>(v3);
      }
      while (v3 != v2);
      v5 = *v6;
      v4 = **v6;
    }
    v1[1] = (uint64_t)v2;
    return (uint64_t **)heap_Free(*(_QWORD **)(v5[3] + 8), v4);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>&&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unsigned int v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t i;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  float v23;
  _BOOL8 v24;
  unint64_t v25;
  unint64_t v26;
  size_t v27;
  uint64_t *v28;
  unint64_t v29;

  v8 = 0xCBF29CE484222325;
  v9 = a2[23];
  if ((v9 & 0x80u) == 0)
    v10 = a2;
  else
    v10 = *(unsigned __int8 **)a2;
  if ((v9 & 0x80u) != 0)
    v9 = *((_QWORD *)a2 + 1);
  for (; v9; --v9)
  {
    v11 = *v10++;
    v8 = 0x100000001B3 * (v8 ^ v11);
  }
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v12)
        v4 = v8 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v8;
    }
    v15 = *(uint64_t **)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      for (i = *v15; i; i = *(_QWORD *)i)
      {
        v17 = *(_QWORD *)(i + 8);
        if (v17 == v8)
        {
          if ((std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::operator()[abi:ne180100](a1 + 48, (unsigned __int8 *)(i + 16), a2) & 1) != 0)return i;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4)
            break;
        }
      }
    }
  }
  i = ENTTS::Allocator<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *>>::allocate(a1 + 32, 1);
  *(_QWORD *)i = 0;
  *(_QWORD *)(i + 8) = v8;
  v18 = *a4;
  v19 = *((_QWORD *)*a4 + 2);
  *(_OWORD *)(i + 16) = **a4;
  v20 = CustomAllocator::mRsrc;
  *(_QWORD *)(i + 32) = v19;
  *(_QWORD *)(i + 40) = v20;
  v18[1] = 0;
  v18[2] = 0;
  *v18 = 0;
  *(_QWORD *)(i + 48) = 0;
  *(_QWORD *)(i + 56) = 0;
  v21 = CustomAllocator::mRsrc;
  *(_QWORD *)(i + 64) = 0;
  *(_QWORD *)(i + 72) = v21;
  v22 = (float)(unint64_t)(*(_QWORD *)(a1 + 40) + 1);
  v23 = *(float *)(a1 + 48);
  if (!v12 || (float)(v23 * (float)v12) < v22)
  {
    v24 = 1;
    if (v12 >= 3)
      v24 = (v12 & (v12 - 1)) != 0;
    v25 = v24 | (2 * v12);
    v26 = vcvtps_u32_f32(v22 / v23);
    if (v25 <= v26)
      v27 = v26;
    else
      v27 = v25;
    std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__rehash<true>((uint64_t *)a1, v27);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v8 >= v12)
        v4 = v8 % v12;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v12 - 1) & v8;
    }
  }
  v28 = *(uint64_t **)(*(_QWORD *)a1 + 8 * v4);
  if (v28)
  {
    *(_QWORD *)i = *v28;
LABEL_45:
    *v28 = i;
    goto LABEL_46;
  }
  *(_QWORD *)i = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = i;
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 24;
  if (*(_QWORD *)i)
  {
    v29 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v29 >= v12)
        v29 %= v12;
    }
    else
    {
      v29 &= v12 - 1;
    }
    v28 = (uint64_t *)(*(_QWORD *)a1 + 8 * v29);
    goto LABEL_45;
  }
LABEL_46:
  ++*(_QWORD *)(a1 + 40);
  return i;
}

void sub_214E8FD10(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t *v2;

  std::__hash_node_destructor<ENTTS::Allocator<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

_QWORD *std::getline[abi:ne180100]<char,std::char_traits<char>,ENTTS::Allocator<char>>(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v6;
  _QWORD *v7;
  _BYTE *v8;
  int v9;
  char v11;

  MEMORY[0x2199DA480](&v11, a1, 1);
  if (!v11)
    return a1;
  if (*(char *)(a2 + 23) < 0)
  {
    **(_BYTE **)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 23) = 0;
  }
  v6 = 0;
  while (1)
  {
    v7 = *(_QWORD **)((char *)a1 + *(_QWORD *)(*a1 - 24) + 40);
    v8 = (_BYTE *)v7[3];
    if (v8 != (_BYTE *)v7[4])
    {
      v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }
    LODWORD(v7) = (*(uint64_t (**)(_QWORD *))(*v7 + 80))(v7);
    if ((_DWORD)v7 == -1)
      break;
LABEL_9:
    if (v7 == a3)
    {
      v9 = 0;
      goto LABEL_17;
    }
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::push_back((char *)a2, (char)v7);
    --v6;
    if (*(char *)(a2 + 23) < 0 && *(_QWORD *)(a2 + 8) == 0x7FFFFFFFFFFFFFF7)
    {
      v9 = 4;
      goto LABEL_17;
    }
  }
  if (v6)
    v9 = 2;
  else
    v9 = 6;
LABEL_17:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | v9);
  return a1;
}

void sub_214E8FE58(void *a1)
{
  _QWORD *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  v2 = *v1;
  *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24) + 32) |= 1u;
  if ((*((_BYTE *)v1 + *(_QWORD *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x214E8FE24);
  }
  __cxa_rethrow();
}

void sub_214E8FE9C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__construct_one_at_end[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>(_QWORD *result, __int128 *a2)
{
  _QWORD *v2;
  uint64_t v3;
  __int128 v4;

  v2 = result;
  v3 = result[1];
  *(_QWORD *)(v3 + 24) = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    result = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external((_BYTE *)v3, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    *(_QWORD *)(v3 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v3 = v4;
  }
  v2[1] = v3 + 32;
  return result;
}

void sub_214E8FF14(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__push_back_slow_path<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const&>(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  __int128 v17;
  int64x2_t v18;
  uint64_t v19;
  uint64_t v21;
  int64x2_t v22;
  uint64_t v23;
  _QWORD *v24;

  v3 = *a1;
  v4 = (a1[1] - *a1) >> 5;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59)
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 3);
  v8 = a1[2] - v3;
  if (v8 >> 4 > v5)
    v5 = v8 >> 4;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0)
    v9 = 0x7FFFFFFFFFFFFFFLL;
  else
    v9 = v5;
  v24 = a1 + 3;
  if (v9)
    v10 = ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>::allocate(v7, v9);
  else
    v10 = 0;
  v11 = v10 + 32 * v4;
  v21 = v10;
  v22.i64[0] = v11;
  v22.i64[1] = v11;
  v23 = v10 + 32 * v9;
  *(_QWORD *)(v11 + 24) = CustomAllocator::mRsrc;
  if (*((char *)a2 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external((_BYTE *)v11, *(void **)a2, *((_QWORD *)a2 + 1));
    v13 = v22.i64[1];
    v11 = v22.i64[0];
  }
  else
  {
    v12 = *a2;
    *(_QWORD *)(v11 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v11 = v12;
    v13 = v10 + 32 * v4;
  }
  v14 = v13 + 32;
  v22.i64[1] = v13 + 32;
  v16 = *a1;
  v15 = a1[1];
  if (v15 == *a1)
  {
    v18 = vdupq_n_s64(v15);
  }
  else
  {
    do
    {
      v17 = *(_OWORD *)(v15 - 32);
      *(_QWORD *)(v11 - 16) = *(_QWORD *)(v15 - 16);
      *(_OWORD *)(v11 - 32) = v17;
      *(_QWORD *)(v11 - 8) = CustomAllocator::mRsrc;
      v11 -= 32;
      *(_QWORD *)(v15 - 32) = 0;
      *(_QWORD *)(v15 - 24) = 0;
      *(_QWORD *)(v15 - 16) = 0;
      v15 -= 32;
    }
    while (v15 != v16);
    v18 = *(int64x2_t *)a1;
    v14 = v22.i64[1];
  }
  *a1 = v11;
  a1[1] = v14;
  v22 = v18;
  v19 = a1[2];
  a1[2] = v23;
  v23 = v19;
  v21 = v18.i64[0];
  std::__split_buffer<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> &>::~__split_buffer((uint64_t)&v21);
  return v14;
}

void sub_214E90080(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> &>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>> &>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    std::__destroy_at[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,0>((uint64_t *)(i - 32));
  }
  if (*(_QWORD *)a1)
    heap_Free(*(_QWORD **)(**(_QWORD **)(a1 + 32) + 8), *(_QWORD *)a1);
  return a1;
}

uint64_t std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  if (*(_QWORD *)a1)
    heap_Free(*(_QWORD **)(**(_QWORD **)(a1 + 32) + 8), *(_QWORD *)a1);
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2;

  std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__deallocate_node((_QWORD *)a1, *(_QWORD **)(a1 + 24));
  v2 = *(_QWORD *)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    std::__bucket_list_deallocator<ENTTS::Allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,void *> *> *>>::operator()[abi:ne180100](a1 + 8, v2);
  return a1;
}

_QWORD *std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,std::hash<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,true>,ENTTS::Allocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>>::__deallocate_node(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;

  v3 = result;
  while (a2)
  {
    v4 = (_QWORD *)*a2;
    std::__destroy_at[abi:ne180100]<std::pair<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>> const,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>,0>(a2 + 2);
    result = heap_Free(*(_QWORD **)(v3[4] + 8), (uint64_t)a2);
    a2 = v4;
  }
  return result;
}

uint64_t **npy::LoadArrayFromNumpy_16_or_32(_QWORD *a1, uint64_t *a2, uint64_t *a3)
{
  size_t v5;
  char v6;
  size_t v7;
  uint64_t v8;
  size_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t *v12;
  size_t v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _WORD *v20;
  unint64_t v26;
  _WORD *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _WORD *v34;
  _WORD *v35;
  uint64_t v36;
  __int16 v37;
  _WORD *v38;
  uint64_t v39;
  unsigned __int8 v40;
  uint64_t *v41;
  unint64_t v42;
  uint64_t *v43;
  size_t v44;
  uint64_t *v46;
  uint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  _WORD *v53;
  unint64_t v54;
  _WORD *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _WORD *v62;
  _WORD *v63;
  uint64_t v64;
  __int16 v65;
  _WORD *v66;
  uint64_t v67;
  uint64_t v69[2];
  char v70;
  uint64_t v71;
  __int128 __dst;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75[2];
  unsigned __int8 v76;
  uint64_t v77;
  uint64_t v78[2];
  unsigned __int8 v79;
  uint64_t v80;
  uint64_t *v81;
  size_t v82;
  uint64_t v83;
  uint64_t v84;
  char v85;
  __int128 v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  char __s[8];
  _WORD *v98;
  _WORD *v99;
  uint64_t v100;
  _QWORD *v101;
  uint64_t v102;

  v102 = *MEMORY[0x24BDAC8D0];
  v93 = 0;
  v94 = 0;
  v95 = 0;
  v96 = CustomAllocator::mRsrc;
  v89 = 0;
  v90 = 0;
  v91 = 0;
  v92 = CustomAllocator::mRsrc;
  npy::read_header(a1, &v86);
  v85 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v84 = CustomAllocator::mRsrc;
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v78, "<f4");
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v75, "<f2");
  v74 = CustomAllocator::mRsrc;
  if (SHIBYTE(v87) < 0)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&__dst, (void *)v86, *((unint64_t *)&v86 + 1));
  }
  else
  {
    __dst = v86;
    v73 = v87;
  }
  npy::parse_header(&__dst, (uint64_t)&v81, &v85, a2);
  if (SHIBYTE(v73) < 0)
    heap_Free(*(_QWORD **)(v74 + 8), __dst);
  v5 = HIBYTE(v83);
  v6 = HIBYTE(v83);
  v8 = (uint64_t)v81;
  v7 = v82;
  if (v83 >= 0)
    v9 = HIBYTE(v83);
  else
    v9 = v82;
  if (v83 >= 0)
    v10 = (uint64_t *)&v81;
  else
    v10 = v81;
  if ((v79 & 0x80u) == 0)
    v11 = v79;
  else
    v11 = v78[1];
  if ((v79 & 0x80u) == 0)
    v12 = v78;
  else
    v12 = (uint64_t *)v78[0];
  if (v11 >= v9)
    v13 = v9;
  else
    v13 = v11;
  if (!memcmp(v10, v12, v13) && v11 == v9)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v69, __s);
    v14 = (uint64_t *)*a2;
    v15 = 1;
    while (v14 != (uint64_t *)a2[1])
    {
      v16 = *v14++;
      v15 *= v16;
    }
    std::vector<float,ENTTS::Allocator<float>>::resize(&v93, v15);
    std::istream::read();
    v18 = v93;
    v17 = v94;
    if (v94 != v93)
    {
      v19 = 0;
      v20 = (_WORD *)a3[1];
      do
      {
        _S0 = *(_DWORD *)(v18 + 4 * v19);
        __asm { FCVT            H8, S0 }
        v26 = a3[2];
        if ((unint64_t)v20 >= v26)
        {
          v27 = (_WORD *)*a3;
          v28 = (uint64_t)v20 - *a3;
          if (v28 <= -3)
            std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
          v29 = v28 >> 1;
          v30 = v26 - (_QWORD)v27;
          if (v30 <= (v28 >> 1) + 1)
            v31 = v29 + 1;
          else
            v31 = v30;
          if (v30 >= 0x7FFFFFFFFFFFFFFELL)
            v32 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v32 = v31;
          v101 = a3 + 3;
          if (v32)
          {
            v33 = ENTTS::Allocator<half>::allocate((uint64_t)(a3 + 3), v32);
            v27 = (_WORD *)*a3;
            v20 = (_WORD *)a3[1];
          }
          else
          {
            v33 = 0;
          }
          v34 = (_WORD *)(v33 + 2 * v29);
          *v34 = _H8;
          if (v20 == v27)
          {
            v36 = v33 + 2 * v29;
          }
          else
          {
            v35 = v20;
            v36 = v33 + 2 * v29;
            do
            {
              v37 = *--v35;
              *(_WORD *)(v36 - 2) = v37;
              v36 -= 2;
            }
            while (v35 != v27);
          }
          v38 = v34 + 1;
          *a3 = v36;
          a3[1] = (uint64_t)(v34 + 1);
          v39 = a3[2];
          a3[2] = v33 + 2 * v32;
          v99 = v20;
          v100 = v39;
          *(_QWORD *)__s = v27;
          v98 = v27;
          std::__split_buffer<half,ENTTS::Allocator<half> &>::~__split_buffer((uint64_t)__s);
          v18 = v93;
          v17 = v94;
          v20 = v38;
        }
        else
        {
          *v20++ = _H8;
        }
        a3[1] = (uint64_t)v20;
        ++v19;
      }
      while (v19 < (v17 - v18) >> 2);
    }
    if (v70 < 0)
      heap_Free(*(_QWORD **)(v71 + 8), v69[0]);
    v5 = HIBYTE(v83);
    v8 = (uint64_t)v81;
    v7 = v82;
    v6 = HIBYTE(v83);
  }
  v40 = v76;
  if (v6 >= 0)
  {
    v41 = (uint64_t *)&v81;
  }
  else
  {
    v5 = v7;
    v41 = (uint64_t *)v8;
  }
  if ((v76 & 0x80u) == 0)
    v42 = v76;
  else
    v42 = v75[1];
  if ((v76 & 0x80u) == 0)
    v43 = v75;
  else
    v43 = (uint64_t *)v75[0];
  if (v42 >= v5)
    v44 = v5;
  else
    v44 = v42;
  if (!memcmp(v41, v43, v44) && v42 == v5)
  {
    std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v69, __s);
    v46 = (uint64_t *)*a2;
    v47 = (uint64_t *)a2[1];
    v48 = 1;
    while (v46 != v47)
    {
      v49 = *v46++;
      v48 *= v49;
    }
    std::vector<half,ENTTS::Allocator<half>>::resize(&v89, v48);
    std::istream::read();
    v51 = v89;
    v50 = v90;
    if (v90 != v89)
    {
      v52 = 0;
      v53 = (_WORD *)a3[1];
      do
      {
        v54 = a3[2];
        if ((unint64_t)v53 >= v54)
        {
          v55 = (_WORD *)*a3;
          v56 = (uint64_t)v53 - *a3;
          if (v56 <= -3)
            std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
          v57 = v56 >> 1;
          v58 = v54 - (_QWORD)v55;
          if (v58 <= (v56 >> 1) + 1)
            v59 = v57 + 1;
          else
            v59 = v58;
          if (v58 >= 0x7FFFFFFFFFFFFFFELL)
            v60 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v60 = v59;
          v101 = a3 + 3;
          if (v60)
          {
            v61 = ENTTS::Allocator<half>::allocate((uint64_t)(a3 + 3), v60);
            v55 = (_WORD *)*a3;
            v53 = (_WORD *)a3[1];
          }
          else
          {
            v61 = 0;
          }
          v62 = (_WORD *)(v61 + 2 * v57);
          *v62 = *(_WORD *)(v51 + 2 * v52);
          if (v53 == v55)
          {
            v64 = v61 + 2 * v57;
          }
          else
          {
            v63 = v53;
            v64 = v61 + 2 * v57;
            do
            {
              v65 = *--v63;
              *(_WORD *)(v64 - 2) = v65;
              v64 -= 2;
            }
            while (v63 != v55);
          }
          v66 = v62 + 1;
          *a3 = v64;
          a3[1] = (uint64_t)(v62 + 1);
          v67 = a3[2];
          a3[2] = v61 + 2 * v60;
          v99 = v53;
          v100 = v67;
          *(_QWORD *)__s = v55;
          v98 = v55;
          std::__split_buffer<half,ENTTS::Allocator<half> &>::~__split_buffer((uint64_t)__s);
          v51 = v89;
          v50 = v90;
          v53 = v66;
        }
        else
        {
          *v53++ = *(_WORD *)(v51 + 2 * v52);
        }
        a3[1] = (uint64_t)v53;
        ++v52;
      }
      while (v52 < (v50 - v51) >> 1);
    }
    if (v70 < 0)
      heap_Free(*(_QWORD **)(v71 + 8), v69[0]);
    v40 = v76;
  }
  if ((v40 & 0x80) != 0)
    heap_Free(*(_QWORD **)(v77 + 8), v75[0]);
  if ((char)v79 < 0)
    heap_Free(*(_QWORD **)(v80 + 8), v78[0]);
  if (SHIBYTE(v83) < 0)
    heap_Free(*(_QWORD **)(v84 + 8), (uint64_t)v81);
  if (SHIBYTE(v87) < 0)
    heap_Free(*(_QWORD **)(v88 + 8), v86);
  *(_QWORD *)__s = &v89;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)__s);
  *(_QWORD *)__s = &v93;
  return std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)__s);
}

void sub_214E906F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void std::vector<half,ENTTS::Allocator<half>>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (a1[1] - *a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2)
      a1[1] = *a1 + 2 * a2;
  }
  else
  {
    std::vector<half,ENTTS::Allocator<half>>::__append(a1, a2 - v2);
  }
}

uint64_t ENTTS::Allocator<half>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 2 * a2);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

uint64_t std::__split_buffer<half,ENTTS::Allocator<half> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 1) & 0xFFFFFFFFFFFFFFFELL);
  if (*(_QWORD *)a1)
    heap_Free(*(_QWORD **)(**(_QWORD **)(a1 + 32) + 8), *(_QWORD *)a1);
  return a1;
}

void std::vector<half,ENTTS::Allocator<half>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  _QWORD v20[5];

  v5 = a1[1];
  v4 = a1[2];
  if (a2 <= (v4 - v5) >> 1)
  {
    if (a2)
    {
      bzero((void *)a1[1], 2 * a2);
      v5 += 2 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    v6 = (uint64_t)(a1 + 3);
    v7 = *a1;
    v8 = v5 - *a1;
    v9 = a2 + (v8 >> 1);
    if (v9 < 0)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 1;
    v11 = v4 - v7;
    if (v11 > v9)
      v9 = v11;
    if (v11 >= 0x7FFFFFFFFFFFFFFELL)
      v12 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v20[4] = a1 + 3;
    if (v12)
    {
      v13 = ENTTS::Allocator<half>::allocate(v6, v12);
      v7 = *a1;
      v5 = a1[1];
    }
    else
    {
      v13 = 0;
    }
    v14 = (char *)(v13 + 2 * v10);
    v15 = v13 + 2 * v12;
    bzero(v14, 2 * a2);
    v16 = &v14[2 * a2];
    if (v5 != v7)
    {
      v17 = v5;
      do
      {
        v18 = *(_WORD *)(v17 - 2);
        v17 -= 2;
        *((_WORD *)v14 - 1) = v18;
        v14 -= 2;
      }
      while (v17 != v7);
    }
    *a1 = (uint64_t)v14;
    a1[1] = (uint64_t)v16;
    v19 = a1[2];
    a1[2] = v15;
    v20[2] = v5;
    v20[3] = v19;
    v20[0] = v7;
    v20[1] = v7;
    std::__split_buffer<half,ENTTS::Allocator<half> &>::~__split_buffer((uint64_t)v20);
  }
}

uint64_t **std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100](uint64_t **result)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = *result;
  v2 = **result;
  if (v2)
  {
    v1[1] = v2;
    return (uint64_t **)heap_Free(*(_QWORD **)(v1[3] + 8), v2);
  }
  return result;
}

void CJsonWrapper::CJsonWrapper(CJsonWrapper *this, uint64_t a2, char *a3)
{
  *(_QWORD *)this = off_24D29C210;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 3) = ttsJSON_Parse(a2, a3);
}

{
  *(_QWORD *)this = off_24D29C210;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 3) = ttsJSON_Parse(a2, a3);
}

void CJsonWrapper::~CJsonWrapper(CJsonWrapper *this)
{
  *(_QWORD *)this = off_24D29C210;
  ttsJSON_Delete(*((_QWORD **)this + 3));
}

BOOL CJsonWrapper::parameter_exists(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *ObjectItem;
  uint64_t v4;
  __int128 v5;
  char *v6;
  _BOOL8 v7;
  BOOL v8;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;

  v2 = a2[1];
  if (v2 == *a2)
    return 0;
  ObjectItem = *(_QWORD **)(a1 + 24);
  v4 = *a2 + 32;
  do
  {
    v12 = CustomAllocator::mRsrc;
    if (*(char *)(v4 - 9) < 0)
    {
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(&v10, *(void **)(v4 - 32), *(_QWORD *)(v4 - 24));
    }
    else
    {
      v5 = *(_OWORD *)(v4 - 32);
      v11 = *(_QWORD *)(v4 - 16);
      v10 = v5;
    }
    if (v11 >= 0)
      v6 = (char *)&v10;
    else
      v6 = (char *)v10;
    ObjectItem = ttsJSON_GetObjectItem((uint64_t)ObjectItem, v6);
    v7 = ObjectItem != 0;
    if (SHIBYTE(v11) < 0)
      heap_Free(*(_QWORD **)(v12 + 8), v10);
    if (ObjectItem)
      v8 = v4 == v2;
    else
      v8 = 1;
    v4 += 32;
  }
  while (!v8);
  return v7;
}

void sub_214E90B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)&a9);
  _Unwind_Resume(a1);
}

__n128 CJsonWrapper::get_parameter@<Q0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, __n128 *a3@<X2>, __n128 *a4@<X8>)
{
  char v8;
  __n128 result;
  _QWORD *ObjectItem;
  uint64_t i;
  uint64_t v12;
  __int128 v13;
  char *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22[2];
  char v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28[4];
  char __str[16];
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  memset(v28, 0, 24);
  v28[3] = CustomAllocator::mRsrc;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__init_with_size[abi:ne180100]<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*,std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>*>(v28, *a2, a2[1], (a2[1] - *a2) >> 5);
  v8 = (**(uint64_t (***)(uint64_t, uint64_t *))a1)(a1, v28);
  *(_QWORD *)__str = v28;
  std::vector<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>,ENTTS::Allocator<std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)__str);
  if ((v8 & 1) != 0)
  {
    ObjectItem = *(_QWORD **)(a1 + 24);
    v12 = *a2;
    for (i = a2[1]; v12 != i; v12 += 32)
    {
      v31 = CustomAllocator::mRsrc;
      if (*(char *)(v12 + 23) < 0)
      {
        std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::__init_copy_ctor_external(__str, *(void **)v12, *(_QWORD *)(v12 + 8));
      }
      else
      {
        v13 = *(_OWORD *)v12;
        v30 = *(_QWORD *)(v12 + 16);
        *(_OWORD *)__str = v13;
      }
      if (v30 >= 0)
        v14 = __str;
      else
        v14 = *(char **)__str;
      ObjectItem = ttsJSON_GetObjectItem((uint64_t)ObjectItem, v14);
      if (SHIBYTE(v30) < 0)
        heap_Free(*(_QWORD **)(v31 + 8), *(uint64_t *)__str);
    }
    a4->n128_u64[0] = 0;
    a4->n128_u64[1] = 0;
    v15 = CustomAllocator::mRsrc;
    a4[1].n128_u64[0] = 0;
    a4[1].n128_u64[1] = v15;
    v16 = *((_DWORD *)ObjectItem + 6);
    if (v16 == 16)
    {
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(v22, (char *)ObjectItem[4]);
      v17 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::insert((uint64_t)v22, 0, "\"", 1uLL);
      v18 = *(_QWORD *)(v17 + 16);
      v25 = *(_OWORD *)v17;
      v26 = v18;
      v27 = CustomAllocator::mRsrc;
      *(_QWORD *)(v17 + 8) = 0;
      *(_QWORD *)(v17 + 16) = 0;
      *(_QWORD *)v17 = 0;
      v19 = std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::append((uint64_t)&v25, "\"", 1uLL);
      v20 = *(_QWORD *)(v19 + 16);
      *(_OWORD *)__str = *(_OWORD *)v19;
      v30 = v20;
      v31 = CustomAllocator::mRsrc;
      *(_QWORD *)(v19 + 8) = 0;
      *(_QWORD *)(v19 + 16) = 0;
      *(_QWORD *)v19 = 0;
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)a4, (__int128 *)__str);
      if (SHIBYTE(v30) < 0)
        heap_Free(*(_QWORD **)(v31 + 8), *(uint64_t *)__str);
      if (SHIBYTE(v26) < 0)
        heap_Free(*(_QWORD **)(v27 + 8), v25);
      if (v23 < 0)
        heap_Free(*(_QWORD **)(v24 + 8), v22[0]);
      v16 = *((_DWORD *)ObjectItem + 6);
    }
    if (v16 == 8)
    {
      snprintf(__str, 0x20uLL, "%f", *((double *)ObjectItem + 6));
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_string[abi:ne180100]<0>(&v25, __str);
      std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=[abi:ne180100]((uint64_t)a4, &v25);
      if (SHIBYTE(v26) < 0)
        heap_Free(*(_QWORD **)(v27 + 8), v25);
    }
  }
  else
  {
    result = *a3;
    *a4 = *a3;
    v21 = CustomAllocator::mRsrc;
    a4[1].n128_u64[0] = a3[1].n128_u64[0];
    a4[1].n128_u64[1] = v21;
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    a3->n128_u64[0] = 0;
  }
  return result;
}

void sub_214E90E30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t operator new(uint64_t a1)
{
  uint64_t result;
  _DWORD *exception;

  result = heap_Alloc(*(_QWORD *)(CustomAllocator::mRsrc + 8), a1);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &unk_24D29B1B8;
    exception[2] = 10;
  }
  return result;
}

{
  return heap_Alloc(*(_QWORD *)(CustomAllocator::mRsrc + 8), a1);
}

_QWORD *operator delete(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

void operator new[]()
{
  std::nested_exception *exception;
  std::nested_exception *v1;

  exception = (std::nested_exception *)__cxa_allocate_exception(0x10uLL);
  exception->__vftable = 0;
  exception->__ptr_.__ptr_ = 0;
  v1 = ENTTS::ArrayNewCalledException::ArrayNewCalledException(exception);
}

{
  std::nested_exception *exception;
  std::nested_exception *v1;

  exception = (std::nested_exception *)__cxa_allocate_exception(0x10uLL);
  exception->__vftable = 0;
  exception->__ptr_.__ptr_ = 0;
  v1 = ENTTS::ArrayNewCalledException::ArrayNewCalledException(exception);
}

std::nested_exception *ENTTS::ArrayNewCalledException::ArrayNewCalledException(std::nested_exception *this)
{
  std::nested_exception *result;

  result = std::nested_exception::nested_exception(this);
  result->__vftable = (std::nested_exception_vtbl *)&unk_24D29C270;
  return result;
}

void ENTTS::ArrayNewCalledException::~ArrayNewCalledException(std::nested_exception *this)
{
  void *v1;

  std::nested_exception::~nested_exception(this);
  operator delete(v1);
}

int *CustomAllocator::GetInstance(CustomAllocator *this)
{
  unsigned __int8 v1;

  {
    CustomAllocator::GetInstance(void)::instance = 0;
  }
  return &CustomAllocator::GetInstance(void)::instance;
}

uint64_t CustomAllocator::SetInstanceResources(_DWORD *a1, uint64_t a2)
{
  uint64_t result;
  int v3;

  if (CustomAllocator::mRsrc)
  {
    if (CustomAllocator::mRsrc != a2)
      return 0xFFFFFFFFLL;
    v3 = CustomAllocator::mCount + 1;
  }
  else
  {
    CustomAllocator::mRsrc = a2;
    v3 = 1;
    *a1 = 1;
  }
  result = 0;
  CustomAllocator::mCount = v3;
  return result;
}

_DWORD *CustomAllocator::ClearInstanceResources(_DWORD *this)
{
  int v1;
  int v2;

  v1 = CustomAllocator::mCount;
  v2 = CustomAllocator::mCount - 1;
  if (CustomAllocator::mCount >= 1)
  {
    --CustomAllocator::mCount;
    v1 = v2;
  }
  if (!v1)
  {
    CustomAllocator::mRsrc = 0;
    *this = 0;
  }
  return this;
}

uint64_t CustomAllocator::GetAllocatorStatus(CustomAllocator *this)
{
  return *(unsigned int *)this;
}

uint64_t SetCustomAllocatorResources(CustomAllocator *a1)
{
  int *Instance;

  Instance = CustomAllocator::GetInstance(a1);
  return CustomAllocator::SetInstanceResources(Instance, (uint64_t)a1);
}

_DWORD *ClearCustomAllocatorResources(CustomAllocator *a1)
{
  int *Instance;

  Instance = CustomAllocator::GetInstance(a1);
  return CustomAllocator::ClearInstanceResources(Instance);
}

void ConvnetNeonFP16Engine::do_inference(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  NeonConvNetManager::do_inference(*(_QWORD **)(a1 + 8), a2, a3, a4, a5);
}

void DecoderNeonEngine::custom_init(uint64_t a1, int **a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int *v32;
  int *v33;
  _DWORD *v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  uint64_t i;

  v4 = *(_QWORD *)(a1 + 336);
  *(_DWORD *)(v4 + 572) = 0;
  bzero(*(void **)(v4 + 520), 2 * *(int *)(v4 + 64));
  bzero(*(void **)(*(_QWORD *)(a1 + 336) + 488), 2 * *(unsigned int *)(a1 + 8));
  bzero(*(void **)(*(_QWORD *)(a1 + 336) + 496), 2 * *(unsigned int *)(a1 + 8));
  bzero(*(void **)(*(_QWORD *)(a1 + 336) + 504), 2 * *(unsigned int *)(a1 + 8));
  bzero(*(void **)(*(_QWORD *)(a1 + 336) + 512), 2 * *(unsigned int *)(a1 + 8));
  bzero(*(void **)(*(_QWORD *)(a1 + 336) + 536), 2 * *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 336) + 24) + 3384));
  bzero(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 336) + 24) + 3344), 12000 * *(_DWORD *)(*(_QWORD *)(a1 + 336) + 64));
  v5 = *(_QWORD *)(a1 + 336);
  v6 = *(int *)(*(_QWORD *)(v5 + 24) + 3396);
  if ((v6 & 7) != 0)
  {
    if ((int)v6 <= 0)
      v7 = -(-(int)v6 & 7);
    else
      v7 = *(_DWORD *)(*(_QWORD *)(v5 + 24) + 3396) & 7;
    v8 = 8 - v7;
    *(_DWORD *)(v5 + 544) = v8;
    v9 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 640) + 32))(*(_QWORD *)(a1 + 640), 2 * ((v8 + (int)v6) << 7));
    v10 = *(_QWORD *)(a1 + 336);
    *(_QWORD *)(v10 + 200) = v9;
    v11 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 640) + 32))(*(_QWORD *)(a1 + 640), 2 * (*(_DWORD *)(*(_QWORD *)(v10 + 24) + 3396) + *(_DWORD *)(v10 + 544) + 31));
    v12 = *(_QWORD *)(a1 + 336);
    *(_QWORD *)(v12 + 528) = v11;
    bzero(v11, 2 * (*(_DWORD *)(*(_QWORD *)(v12 + 24) + 3396) + *(_DWORD *)(v12 + 544) + 31));
    v13 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 640) + 32))(*(_QWORD *)(a1 + 640), 64* (*(_DWORD *)(*(_QWORD *)(a1 + 336) + 544) + *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 336) + 24) + 3396)));
    v14 = *(_QWORD *)(a1 + 336);
    *(_QWORD *)(v14 + 216) = v13;
    v15 = *(_DWORD *)(v14 + 544) + *(_DWORD *)(*(_QWORD *)(v14 + 24) + 3396);
  }
  else
  {
    *(_DWORD *)(v5 + 544) = 0;
    v16 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 640) + 32))(*(_QWORD *)(a1 + 640), v6 << 8);
    v17 = *(_QWORD *)(a1 + 336);
    *(_QWORD *)(v17 + 200) = v16;
    v18 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 640) + 32))(*(_QWORD *)(a1 + 640), 2 * *(int *)(*(_QWORD *)(v17 + 24) + 3396) + 62);
    v19 = *(_QWORD *)(a1 + 336);
    *(_QWORD *)(v19 + 528) = v18;
    bzero(v18, 2 * *(int *)(*(_QWORD *)(v19 + 24) + 3396) + 62);
    v20 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 640) + 32))(*(_QWORD *)(a1 + 640), (uint64_t)*(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 336) + 24) + 3396) << 6);
    v21 = *(_QWORD *)(a1 + 336);
    *(_QWORD *)(v21 + 216) = v20;
    v15 = *(_DWORD *)(*(_QWORD *)(v21 + 24) + 3396);
  }
  v22 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 640) + 32))(*(_QWORD *)(a1 + 640), 2 * (v15 << 7));
  v23 = *(_QWORD *)(a1 + 336);
  *(_QWORD *)(v23 + 224) = v22;
  v24 = *(_QWORD *)(v23 + 24);
  v25 = *(_DWORD *)(v24 + 3396);
  if (v25 <= 0)
    v26 = -(-v25 & 7);
  else
    v26 = *(_DWORD *)(v24 + 3396) & 7;
  v27 = v25 - v26 + 8;
  *(_DWORD *)(v23 + 400) = v27;
  v28 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 640) + 32))(*(_QWORD *)(a1 + 640), 2 * v27 * *(_DWORD *)(v24 + 3384));
  v29 = *(_QWORD *)(a1 + 336);
  *(_QWORD *)(v29 + 408) = v28;
  v30 = *(_QWORD *)(v29 + 24);
  v31 = *(_QWORD *)(v30 + 3328);
  if (!v31)
  {
    v31 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 640) + 32))(*(_QWORD *)(a1 + 640), 4 * *(_DWORD *)(v30 + 3380) * *(_DWORD *)(v30 + 3396));
    v29 = *(_QWORD *)(a1 + 336);
    v30 = *(_QWORD *)(v29 + 24);
    *(_QWORD *)(v30 + 3328) = v31;
  }
  v32 = *a2;
  v33 = a2[1];
  if (*a2 != v33)
  {
    v34 = (_DWORD *)v31;
    do
    {
      v35 = *v32++;
      *v34++ = v35;
    }
    while (v32 != v33);
  }
  v36 = *(_DWORD *)(v30 + 3384);
  if (v36 >= 0)
    v37 = *(_DWORD *)(v30 + 3384);
  else
    v37 = v36 + 7;
  v38 = *(int *)(v29 + 400);
  if (v36 >= 8)
  {
    v39 = 0;
    v40 = 0;
    v41 = 0;
    v42 = v37 >> 3;
    do
    {
      if ((int)v38 >= 8)
      {
        v43 = 0;
        v44 = *(_DWORD *)(v30 + 3396);
        v45 = v39;
        do
        {
          v46 = 0;
          v47 = v45;
          do
          {
            if (v46 + 8 * v43 >= v44)
            {
              v55 = (_QWORD *)(*(_QWORD *)(v29 + 408) + 2 * v41);
              *v55 = 0;
              v55[1] = 0;
              v41 += 8;
            }
            else
            {
              v48 = 0;
              v49 = *(_QWORD *)(v29 + 408) + 2 * v41;
              do
              {
                _S0 = *(_DWORD *)(v31 + 4 * (v47 + (int)v48));
                __asm { FCVT            H0, S0 }
                *(_WORD *)(v49 + 2 * v48++) = _S0;
              }
              while (v48 != 8);
              v41 += 8;
            }
            ++v46;
            v47 += v36;
          }
          while (v46 != 8);
          ++v43;
          v45 += 8 * v36;
        }
        while (v43 != (int)v38 / 8);
      }
      ++v40;
      v39 += 8;
    }
    while (v40 != v42);
  }
  v56 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 640) + 32))(*(_QWORD *)(a1 + 640), 2 * v38);
  v57 = *(_QWORD *)(a1 + 336);
  *(_QWORD *)(v57 + 232) = v56;
  bzero(v56, 2 * *(int *)(v57 + 400));
  v58 = *(_QWORD *)(a1 + 336);
  v59 = *(_QWORD *)(v58 + 24);
  if (!*(_BYTE *)(v59 + 2722))
  {
    v60 = *(int *)(v59 + 3396);
    v61 = *(_DWORD *)(v58 + 544) + v60;
    if (v61 >= 4)
    {
      v62 = 0;
      v63 = 0;
      v64 = v61 >> 2;
      v65 = *(_QWORD *)(v59 + 3368);
      do
      {
        v66 = 0;
        v67 = v62 >> 3;
        v68 = v62 >> 3;
        do
        {
          v69 = 0;
          v70 = v67;
          v71 = v68;
          do
          {
            for (i = 0; i != 8; ++i)
            {
              _H0 = 0;
              if (v69 + 4 * v63 < v60)
              {
                _S0 = *(_DWORD *)(*(_QWORD *)(v59 + 3336) + 32 * (v70 & 0x1FFFFFFF) + 4 * i);
                __asm { FCVT            H0, S0 }
              }
              *(_WORD *)(v65 + 16 * (v71 & 0x1FFFFFFF) + 2 * i) = _H0;
            }
            ++v69;
            ++v71;
            v70 += 16;
          }
          while (v69 != 4);
          ++v66;
          LODWORD(v68) = v68 + 4;
          LODWORD(v67) = v67 + 1;
        }
        while (v66 != 16);
        ++v63;
        v62 += 512;
      }
      while (v63 != v64);
    }
  }
}

NeonDecoderManager *DecoderNeonEngine::do_inference_loop(uint64_t a1, uint64_t *a2, unsigned int a3, int a4)
{
  NeonDecoderManager *result;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t i;
  int v16;
  unsigned int v17;
  unsigned int v19;
  int v20;
  int v21;

  result = *(NeonDecoderManager **)(a1 + 336);
  if (*(_BYTE *)(*((_QWORD *)result + 3) + 2304))
  {
    result = (NeonDecoderManager *)NeonDecoderManager::do_loop_inference(result, *(_DWORD *)(a1 + 32), a3, *(_DWORD *)(a1 + 60));
    if ((int)result >= 1)
    {
      v8 = 0;
      v9 = *(_DWORD *)(a1 + 32);
      v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 336) + 24) + 3344);
      v11 = *a2;
      v12 = 240 * v9;
      v13 = *(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 52);
      v14 = v13 * v9;
      do
      {
        for (i = 0; i != 240; ++i)
          *(_DWORD *)(v11 + 4 * (v14 + i)) = *(_DWORD *)(v10 + 4 * (v12 + i));
        ++v8;
        v12 += 240;
        v14 += v13;
      }
      while (v8 != (_DWORD)result);
    }
    if ((_DWORD)result != a3)
      *(_BYTE *)(a1 + 28) = 1;
    v16 = *(_DWORD *)(a1 + 32) + (_DWORD)result;
LABEL_10:
    *(_DWORD *)(a1 + 32) = v16;
  }
  else
  {
    *(_DWORD *)(a1 + 328) = 0;
    v17 = *(unsigned __int8 *)(a1 + 28);
    if (!*(_BYTE *)(a1 + 28))
    {
      do
      {
        if (v17 >= a3)
          break;
        v19 = *(_DWORD *)(a1 + 32);
        if (v19 >= *(_DWORD *)(a1 + 60))
          break;
        if (a4)
        {
          *(_BYTE *)(a1 + 28) = 1;
          *(_DWORD *)(a1 + 328) = v17 + 1;
          v16 = v19 + 1;
          goto LABEL_10;
        }
        result = (NeonDecoderManager *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 8))(a1, a2);
        v20 = *(_DWORD *)(a1 + 32);
        v21 = *(unsigned __int8 *)(a1 + 28);
        v17 = *(_DWORD *)(a1 + 328) + 1;
        *(_DWORD *)(a1 + 328) = v17;
        *(_DWORD *)(a1 + 32) = v20 + 1;
      }
      while (!v21);
    }
  }
  return result;
}

float DecoderNeonEngine::do_inference_step(uint64_t a1, uint64_t *a2, __n128 a3)
{
  char v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  float result;

  v5 = NeonDecoderManager::do_step_inference(*(NeonDecoderManager **)(a1 + 336), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 336) + 24) + 3396), a3);
  v6 = 0;
  *(_BYTE *)(a1 + 28) = v5;
  v7 = *(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 52);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 336) + 256);
  v9 = *a2;
  do
  {
    _H0 = *(_WORD *)(v8 + 2 * v6);
    __asm { FCVT            S0, H0 }
    *(float *)(v9 + 4 * (v7 + v6++)) = result;
  }
  while (v6 != 240);
  return result;
}

uint64_t DecoderNeonEngine::stop_decoder(uint64_t this)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = this;
  *(_DWORD *)(this + 32) = 0;
  *(_WORD *)(this + 28) = 256;
  v2 = *(_QWORD **)(this + 336);
  if (v2[25])
  {
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 640) + 56))(*(_QWORD *)(this + 640));
    v2 = *(_QWORD **)(v1 + 336);
    v2[25] = 0;
  }
  if (v2[66])
  {
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 640) + 56))(*(_QWORD *)(v1 + 640));
    v2 = *(_QWORD **)(v1 + 336);
    v2[66] = 0;
  }
  if (v2[27])
  {
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 640) + 56))(*(_QWORD *)(v1 + 640));
    v2 = *(_QWORD **)(v1 + 336);
    v2[27] = 0;
  }
  if (v2[28])
  {
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 640) + 56))(*(_QWORD *)(v1 + 640));
    v2 = *(_QWORD **)(v1 + 336);
    v2[28] = 0;
  }
  if (v2[51])
  {
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 640) + 56))(*(_QWORD *)(v1 + 640));
    v2 = *(_QWORD **)(v1 + 336);
    v2[51] = 0;
  }
  if (v2[29])
  {
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 640) + 56))(*(_QWORD *)(v1 + 640));
    *(_QWORD *)(*(_QWORD *)(v1 + 336) + 232) = 0;
  }
  return this;
}

BOOL VirtualManager::WriteWaveFile(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unsigned __int8 *base;
  void (__cdecl **v7)(std::ofstream *__hidden);
  FILE v8[2];
  std::ios_base v9;
  uint64_t v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v9.__vftable = (std::ios_base_vtbl *)&unk_24D29C3B8;
  std::ios_base::init(&v9, v8);
  v10 = 0;
  v11 = -1;
  std::filebuf::basic_filebuf((uint64_t)v8);
  std::ofstream::open(&v7, a4, 52);
  base = v8[0]._lb._base;
  if (v8[0]._lb._base)
  {
    std::ostream::write();
    std::ostream::write();
    if (!std::filebuf::close(v8))
      std::ios_base::clear((std::ios_base *)((char *)&v7 + (_QWORD)*(v7 - 3)), *(_DWORD *)((char *)&v8[0]._bf._base + (_QWORD)*(v7 - 3)) | 4);
  }
  std::filebuf::~filebuf((uint64_t)v8);
  std::ostream::~ostream();
  MEMORY[0x2199DA5E8](&v9);
  return base != 0;
}

void sub_214E91AA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x2199DA5E8](v1);
  _Unwind_Resume(a1);
}

void std::ofstream::open(_QWORD *a1, char *a2, int a3)
{
  uint64_t v4;
  int v5;
  FILE *v6;
  std::ios_base *v7;
  std::ios_base::iostate v8;

  v4 = (uint64_t)(a1 + 1);
  v5 = a3 | 0x10;
  if (a2[23] < 0)
    a2 = *(char **)a2;
  v6 = std::filebuf::open(v4, a2, v5);
  v7 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  if (v6)
    v8 = 0;
  else
    v8 = v7->__rdstate_ | 4;
  std::ios_base::clear(v7, v8);
}

void (__cdecl ***std::ofstream::~ofstream(void (__cdecl ***a1)(std::ofstream *__hidden this)))(std::ofstream *__hidden this)
{
  _QWORD *v2;

  v2 = a1 + 52;
  std::filebuf::~filebuf((uint64_t)(a1 + 1));
  std::ostream::~ostream();
  MEMORY[0x2199DA5E8](v2);
  return a1;
}

uint64_t Show::tensor_padding_column_ordered(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  const std::locale::facet *v10;
  int v11;
  int v12;
  char v13;
  int v14;
  int v15;
  int v16;
  int v17;
  char v18;
  uint64_t v19;
  char v20;
  int v21;
  int v28;
  int v29;
  uint64_t i;
  const std::locale::facet *v33;
  _QWORD *v34;
  _QWORD *v35;
  const std::locale::facet *v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  char v44;
  uint64_t v45;
  char v46;
  int v47;
  int v50;
  int v51;
  uint64_t j;
  const std::locale::facet *v55;
  const std::locale::facet *v56;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  char v63;
  int v64;
  std::locale v65;

  v6 = (_QWORD *)MEMORY[0x24BEDB318];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v7 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)", ", 2);
  v8 = (_QWORD *)std::ostream::operator<<();
  v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"]", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
  v10 = std::locale::use_facet(&v65, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
  std::locale::~locale(&v65);
  std::ostream::put();
  std::ostream::flush();
  v11 = 0;
  v12 = 16 * (a4 / 4);
  v58 = a4 / 4;
  v59 = a4;
  v61 = 32 * (a4 / 4);
  v13 = 1;
  do
  {
    v14 = 0;
    v63 = v13;
    v15 = 16 * v11;
    v16 = v61 + 16 * v11;
    do
    {
      v17 = 0;
      v18 = 1;
      do
      {
        v19 = 0;
        v20 = v18;
        v21 = v15 + v12 * v17;
        do
        {
          _H0 = *(_WORD *)(a2 + 2 * (v21 + (int)v19));
          __asm { FCVT            D0, H0 }
          printf("%2.7f ", _D0);
          v19 += 4;
        }
        while (v19 != 16);
        v18 = 0;
        v17 = 1;
      }
      while ((v20 & 1) != 0);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"... ", 4);
      v28 = 2;
      v29 = v16;
      do
      {
        for (i = 0; i != 16; i += 4)
        {
          _H0 = *(_WORD *)(a2 + 2 * (v29 + (int)i));
          __asm { FCVT            D0, H0 }
          printf("%2.7f ", _D0);
        }
        ++v28;
        v29 += v12;
      }
      while (v28 != 4);
      std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(_QWORD *)(*v6 - 24)));
      v33 = std::locale::use_facet(&v65, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v33->__vftable[2].~facet_0)(v33, 10);
      std::locale::~locale(&v65);
      std::ostream::put();
      std::ostream::flush();
      ++v14;
      ++v15;
      ++v16;
    }
    while (v14 != 4);
    v13 = 0;
    v11 = 1;
  }
  while ((v63 & 1) != 0);
  v34 = (_QWORD *)MEMORY[0x24BEDB318];
  v35 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" ...", 4);
  std::ios_base::getloc((const std::ios_base *)((char *)v35 + *(_QWORD *)(*v35 - 24)));
  v36 = std::locale::use_facet(&v65, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v36->__vftable[2].~facet_0)(v36, 10);
  std::locale::~locale(&v65);
  std::ostream::put();
  std::ostream::flush();
  v37 = v59 - 8;
  if (v59 < 8)
    v37 = v59 - 5;
  v38 = v37 >> 2;
  if (v37 >> 2 < v58)
  {
    v39 = 16 * v38;
    v40 = v61 + 16 * v38;
    do
    {
      v62 = v39;
      v64 = v38;
      v41 = 0;
      v42 = v40;
      v60 = v40;
      do
      {
        v43 = 0;
        v44 = 1;
        do
        {
          v45 = 0;
          v46 = v44;
          v47 = v39 + v12 * v43;
          do
          {
            _H0 = *(_WORD *)(a2 + 2 * (v47 + (int)v45));
            __asm { FCVT            D0, H0 }
            printf("%2.7f ", _D0);
            v45 += 4;
          }
          while (v45 != 16);
          v44 = 0;
          v43 = 1;
        }
        while ((v46 & 1) != 0);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)"... ", 4);
        v50 = 2;
        v51 = v42;
        do
        {
          for (j = 0; j != 16; j += 4)
          {
            _H0 = *(_WORD *)(a2 + 2 * (v51 + (int)j));
            __asm { FCVT            D0, H0 }
            printf("%2.7f ", _D0);
          }
          ++v50;
          v51 += v12;
        }
        while (v50 != 4);
        std::ios_base::getloc((const std::ios_base *)((char *)v34 + *(_QWORD *)(*v34 - 24)));
        v55 = std::locale::use_facet(&v65, MEMORY[0x24BEDB350]);
        ((void (*)(const std::locale::facet *, uint64_t))v55->__vftable[2].~facet_0)(v55, 10);
        std::locale::~locale(&v65);
        std::ostream::put();
        std::ostream::flush();
        ++v41;
        ++v39;
        ++v42;
      }
      while (v41 != 4);
      v38 = v64 + 1;
      v39 = v62 + 16;
      v40 = v60 + 16;
    }
    while (v64 + 1 != v58);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v34 + *(_QWORD *)(*v34 - 24)));
  v56 = std::locale::use_facet(&v65, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v56->__vftable[2].~facet_0)(v56, 10);
  std::locale::~locale(&v65);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_214E92014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14)
{
  std::locale::~locale(&a14);
  _Unwind_Resume(a1);
}

uint64_t Show::tensor_column_ordered(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  const std::locale::facet *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  char v18;
  int v19;
  int v20;
  int v21;
  int v22;
  char v23;
  uint64_t v24;
  char v25;
  int v26;
  int v33;
  int v34;
  uint64_t i;
  const std::locale::facet *v38;
  _QWORD *v39;
  const std::locale::facet *v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  char v48;
  uint64_t v49;
  char v50;
  int v51;
  int v54;
  int v55;
  uint64_t j;
  const std::locale::facet *v59;
  const std::locale::facet *v60;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  char v67;
  int v68;
  int v69;
  std::locale v70;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v9 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
  v10 = (_QWORD *)std::ostream::operator<<();
  v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"]", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v11 + *(_QWORD *)(*v11 - 24)));
  v12 = std::locale::use_facet(&v70, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 10);
  std::locale::~locale(&v70);
  std::ostream::put();
  std::ostream::flush();
  v13 = 0;
  v14 = a4 / 4;
  v15 = a3 - a5;
  if (a3 < a5)
    v15 = a3 - a5 + 3;
  v16 = a3 / 4;
  v17 = 16 * v14;
  v62 = a4 / 4;
  v63 = a4;
  v69 = v15 >> 2;
  v65 = 16 * (v15 >> 2) * v14;
  v18 = 1;
  do
  {
    v19 = 0;
    v67 = v18;
    v20 = 16 * v13;
    v21 = v65 + 16 * v13;
    do
    {
      v22 = 0;
      v23 = 1;
      do
      {
        v24 = 0;
        v25 = v23;
        v26 = v20 + v17 * v22;
        do
        {
          _H0 = *(_WORD *)(a2 + 2 * (v26 + (int)v24));
          __asm { FCVT            D0, H0 }
          printf("%2.7f ", _D0);
          v24 += 4;
        }
        while (v24 != 16);
        v23 = 0;
        v22 = 1;
      }
      while ((v25 & 1) != 0);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
      if (v69 < v16)
      {
        v33 = v21;
        v34 = v69;
        do
        {
          for (i = 0; i != 16; i += 4)
          {
            _H0 = *(_WORD *)(a2 + 2 * (v33 + (int)i));
            __asm { FCVT            D0, H0 }
            printf("%2.7f ", _D0);
          }
          ++v34;
          v33 += v17;
        }
        while (v34 != v16);
      }
      std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
      v38 = std::locale::use_facet(&v70, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
      std::locale::~locale(&v70);
      std::ostream::put();
      std::ostream::flush();
      ++v19;
      ++v20;
      ++v21;
    }
    while (v19 != 4);
    v18 = 0;
    v13 = 1;
  }
  while ((v67 & 1) != 0);
  v39 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" ...", 4);
  std::ios_base::getloc((const std::ios_base *)((char *)v39 + *(_QWORD *)(*v39 - 24)));
  v40 = std::locale::use_facet(&v70, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v40->__vftable[2].~facet_0)(v40, 10);
  std::locale::~locale(&v70);
  std::ostream::put();
  std::ostream::flush();
  v41 = v63 - 8;
  if (v63 < 8)
    v41 = v63 - 5;
  v42 = v41 >> 2;
  if (v41 >> 2 < v62)
  {
    v43 = 16 * v42;
    v44 = v65 + 16 * v42;
    do
    {
      v66 = v43;
      v68 = v42;
      v45 = 0;
      v46 = v44;
      v64 = v44;
      do
      {
        v47 = 0;
        v48 = 1;
        do
        {
          v49 = 0;
          v50 = v48;
          v51 = v43 + v17 * v47;
          do
          {
            _H0 = *(_WORD *)(a2 + 2 * (v51 + (int)v49));
            __asm { FCVT            D0, H0 }
            printf("%2.7f ", _D0);
            v49 += 4;
          }
          while (v49 != 16);
          v48 = 0;
          v47 = 1;
        }
        while ((v50 & 1) != 0);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
        if (v69 < v16)
        {
          v54 = v46;
          v55 = v69;
          do
          {
            for (j = 0; j != 16; j += 4)
            {
              _H0 = *(_WORD *)(a2 + 2 * (v54 + (int)j));
              __asm { FCVT            D0, H0 }
              printf("%2.7f ", _D0);
            }
            ++v55;
            v54 += v17;
          }
          while (v55 != v16);
        }
        std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
        v59 = std::locale::use_facet(&v70, MEMORY[0x24BEDB350]);
        ((void (*)(const std::locale::facet *, uint64_t))v59->__vftable[2].~facet_0)(v59, 10);
        std::locale::~locale(&v70);
        std::ostream::put();
        std::ostream::flush();
        ++v45;
        ++v43;
        ++v46;
      }
      while (v45 != 4);
      v42 = v68 + 1;
      v43 = v66 + 16;
      v44 = v64 + 16;
    }
    while (v68 + 1 != v62);
  }
  std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
  v60 = std::locale::use_facet(&v70, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v60->__vftable[2].~facet_0)(v60, 10);
  std::locale::~locale(&v70);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_214E9251C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14)
{
  std::locale::~locale(&a14);
  _Unwind_Resume(a1);
}

uint64_t Show::qtensor_padding_column_ordered(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  int v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  const std::locale::facet *v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  int v32;
  int v33;
  uint64_t i;
  const std::locale::facet *v37;
  _QWORD *v38;
  const std::locale::facet *v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  char v47;
  uint64_t v48;
  char v49;
  int v50;
  int v53;
  int v54;
  uint64_t j;
  const std::locale::facet *v58;
  const std::locale::facet *v59;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  uint64_t v66;
  int v67;
  int v68;
  std::locale v69;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v9 = 4 * a3;
  v10 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)", ", 2);
  v11 = (_QWORD *)std::ostream::operator<<();
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"]", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  v13 = std::locale::use_facet(&v69, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  std::ostream::flush();
  v14 = 0;
  v15 = a4 + 7;
  v64 = a4;
  if (a4 >= 0)
    v15 = a4;
  v16 = v15 >> 3;
  v17 = 32 * (v15 >> 3);
  v18 = v9 - a5;
  if (v9 < a5)
    v18 = v9 - a5 + 3;
  v61 = v16;
  v68 = v18 >> 2;
  v19 = 32 * (v18 >> 2) * v16;
  v62 = v19;
  v20 = a2;
  do
  {
    v66 = v14;
    v21 = 0;
    v22 = 1;
    do
    {
      v23 = 0;
      v24 = v22;
      v25 = v20 + 2 * v17 * v21;
      do
      {
        _H0 = *(_WORD *)(v25 + v23);
        __asm { FCVT            D0, H0 }
        printf("%2.4f ", _D0);
        v23 += 16;
      }
      while (v23 != 64);
      v22 = 0;
      v21 = 1;
    }
    while ((v24 & 1) != 0);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
    if (v68 < a3)
    {
      v32 = v19;
      v33 = v68;
      do
      {
        for (i = 0; i != 32; i += 8)
        {
          _H0 = *(_WORD *)(a2 + 2 * (v32 + (int)i));
          __asm { FCVT            D0, H0 }
          printf("%2.4f ", _D0);
        }
        ++v33;
        v32 += v17;
      }
      while (v33 != a3);
    }
    std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
    v37 = std::locale::use_facet(&v69, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v37->__vftable[2].~facet_0)(v37, 10);
    std::locale::~locale(&v69);
    std::ostream::put();
    std::ostream::flush();
    v14 = v66 + 1;
    v20 += 2;
    ++v19;
  }
  while (v66 != 7);
  v38 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" ...", 4);
  std::ios_base::getloc((const std::ios_base *)((char *)v38 + *(_QWORD *)(*v38 - 24)));
  v39 = std::locale::use_facet(&v69, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v39->__vftable[2].~facet_0)(v39, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  std::ostream::flush();
  v40 = v64 - 8;
  if (v64 < 8)
    v40 = v64 - 1;
  v41 = v40 >> 3;
  if (v40 >> 3 < v61)
  {
    v42 = 32 * v41;
    v43 = v62 + 32 * v41;
    do
    {
      v65 = v42;
      v67 = v41;
      v44 = 0;
      v45 = v43;
      v63 = v43;
      do
      {
        v46 = 0;
        v47 = 1;
        do
        {
          v48 = 0;
          v49 = v47;
          v50 = v42 + v17 * v46;
          do
          {
            _H0 = *(_WORD *)(a2 + 2 * (v50 + (int)v48));
            __asm { FCVT            D0, H0 }
            printf("%2.4f ", _D0);
            v48 += 8;
          }
          while (v48 != 32);
          v47 = 0;
          v46 = 1;
        }
        while ((v49 & 1) != 0);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
        if (v68 < a3)
        {
          v53 = v45;
          v54 = v68;
          do
          {
            for (j = 0; j != 32; j += 8)
            {
              _H0 = *(_WORD *)(a2 + 2 * (v53 + (int)j));
              __asm { FCVT            D0, H0 }
              printf("%2.4f ", _D0);
            }
            ++v54;
            v53 += v17;
          }
          while (v54 != a3);
        }
        std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
        v58 = std::locale::use_facet(&v69, MEMORY[0x24BEDB350]);
        ((void (*)(const std::locale::facet *, uint64_t))v58->__vftable[2].~facet_0)(v58, 10);
        std::locale::~locale(&v69);
        std::ostream::put();
        std::ostream::flush();
        ++v44;
        ++v42;
        ++v45;
      }
      while (v44 != 8);
      v41 = v67 + 1;
      v42 = v65 + 32;
      v43 = v63 + 32;
    }
    while (v67 + 1 != v61);
  }
  std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
  v59 = std::locale::use_facet(&v69, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v59->__vftable[2].~facet_0)(v59, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_214E92A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::locale a16)
{
  std::locale::~locale(&a16);
  _Unwind_Resume(a1);
}

uint64_t Show::qtensor_row_ordered(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  const std::locale::facet *v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  int v30;
  int v31;
  uint64_t i;
  const std::locale::facet *v35;
  _QWORD *v36;
  _QWORD *v37;
  const std::locale::facet *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  char v47;
  uint64_t v48;
  char v49;
  int v50;
  int v53;
  int v54;
  uint64_t j;
  const std::locale::facet *v58;
  const std::locale::facet *v59;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  std::locale v69;

  v9 = (_QWORD *)MEMORY[0x24BEDB318];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v10 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)", ", 2);
  v66 = a4;
  v11 = (_QWORD *)std::ostream::operator<<();
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"]", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  v13 = std::locale::use_facet(&v69, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  std::ostream::flush();
  v14 = 0;
  v64 = a5;
  v15 = a3 - a5;
  if (a3 < a5)
    v15 = a3 - a5 + 3;
  v16 = a3 / 4;
  v68 = v15 >> 2;
  v17 = 32 * (v15 >> 2);
  v18 = a2;
  do
  {
    v19 = 0;
    v20 = 1;
    do
    {
      v21 = 0;
      v22 = v20;
      v23 = v18 + 2 * v19;
      do
      {
        _H0 = *(_WORD *)(v23 + v21);
        __asm { FCVT            D0, H0 }
        printf("%2.4f ", _D0);
        v21 += 16;
      }
      while (v21 != 64);
      v20 = 0;
      v19 = 32;
    }
    while ((v22 & 1) != 0);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"... ", 4);
    if (v68 < v16)
    {
      v30 = v17;
      v31 = v68;
      do
      {
        for (i = 0; i != 32; i += 8)
        {
          _H0 = *(_WORD *)(a2 + 2 * (v30 + (int)i));
          __asm { FCVT            D0, H0 }
          printf("%2.4f ", _D0);
        }
        ++v31;
        v30 += 32;
      }
      while (v31 != v16);
    }
    std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
    v35 = std::locale::use_facet(&v69, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 10);
    std::locale::~locale(&v69);
    std::ostream::put();
    std::ostream::flush();
    ++v14;
    v18 += 2;
    ++v17;
  }
  while (v14 != 8);
  v36 = (_QWORD *)MEMORY[0x24BEDB318];
  v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" ...", 4);
  std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(_QWORD *)(*v37 - 24)));
  v38 = std::locale::use_facet(&v69, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  std::ostream::flush();
  v39 = v66 - v64;
  if (v66 < v64)
    v39 = v66 - v64 + 7;
  v40 = v39 >> 3;
  v41 = v66 + 7;
  if (v66 >= 0)
    v41 = v66;
  if (v40 < v41 >> 3)
  {
    v42 = 32 * v40 * v16;
    v61 = 32 * v16;
    v62 = v41 >> 3;
    v43 = v42 + 32 * v68;
    do
    {
      v65 = v42;
      v67 = v40;
      v44 = 0;
      v45 = v43;
      v63 = v43;
      do
      {
        v46 = 0;
        v47 = 1;
        do
        {
          v48 = 0;
          v49 = v47;
          v50 = v42 + 32 * v46;
          do
          {
            _H0 = *(_WORD *)(a2 + 2 * (v50 + (int)v48));
            __asm { FCVT            D0, H0 }
            printf("%2.4f ", _D0);
            v48 += 8;
          }
          while (v48 != 32);
          v47 = 0;
          v46 = 1;
        }
        while ((v49 & 1) != 0);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)"... ", 4);
        if (v68 < v16)
        {
          v53 = v45;
          v54 = v68;
          do
          {
            for (j = 0; j != 32; j += 8)
            {
              _H0 = *(_WORD *)(a2 + 2 * (v53 + (int)j));
              __asm { FCVT            D0, H0 }
              printf("%2.4f ", _D0);
            }
            ++v54;
            v53 += 32;
          }
          while (v54 != v16);
        }
        std::ios_base::getloc((const std::ios_base *)((char *)v36 + *(_QWORD *)(*v36 - 24)));
        v58 = std::locale::use_facet(&v69, MEMORY[0x24BEDB350]);
        ((void (*)(const std::locale::facet *, uint64_t))v58->__vftable[2].~facet_0)(v58, 10);
        std::locale::~locale(&v69);
        std::ostream::put();
        std::ostream::flush();
        ++v44;
        ++v42;
        ++v45;
      }
      while (v44 != 8);
      v40 = v67 + 1;
      v42 = v65 + v61;
      v43 = v63 + v61;
    }
    while (v67 + 1 != v62);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v36 + *(_QWORD *)(*v36 - 24)));
  v59 = std::locale::use_facet(&v69, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v59->__vftable[2].~facet_0)(v59, 10);
  std::locale::~locale(&v69);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_214E92EBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14)
{
  std::locale::~locale(&a14);
  _Unwind_Resume(a1);
}

uint64_t Show::qtensor_column_ordered(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  const std::locale::facet *v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  int v30;
  int v31;
  uint64_t i;
  const std::locale::facet *v35;
  _QWORD *v36;
  const std::locale::facet *v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  char v45;
  uint64_t v46;
  char v47;
  int v48;
  int v51;
  int v52;
  uint64_t j;
  const std::locale::facet *v56;
  const std::locale::facet *v57;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  int v66;
  int v67;
  std::locale v68;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v9 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
  v10 = (_QWORD *)std::ostream::operator<<();
  v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"]", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v11 + *(_QWORD *)(*v11 - 24)));
  v12 = std::locale::use_facet(&v68, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 10);
  std::locale::~locale(&v68);
  std::ostream::put();
  std::ostream::flush();
  v13 = 0;
  v14 = 32 * (a4 / 8);
  v63 = a5;
  v15 = a3 - a5;
  if (a3 < a5)
    v15 = a3 - a5 + 3;
  v16 = a3 / 4;
  v60 = a4 / 8;
  v61 = a4;
  v67 = v15 >> 2;
  v17 = 32 * (v15 >> 2) * (a4 / 8);
  v59 = v17;
  v18 = a2;
  do
  {
    v65 = v13;
    v19 = 0;
    v20 = 1;
    do
    {
      v21 = 0;
      v22 = v20;
      v23 = v18 + 2 * v14 * v19;
      do
      {
        _H0 = *(_WORD *)(v23 + v21);
        __asm { FCVT            D0, H0 }
        printf("%2.4f ", _D0);
        v21 += 16;
      }
      while (v21 != 64);
      v20 = 0;
      v19 = 1;
    }
    while ((v22 & 1) != 0);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
    if (v67 < v16)
    {
      v30 = v17;
      v31 = v67;
      do
      {
        for (i = 0; i != 32; i += 8)
        {
          _H0 = *(_WORD *)(a2 + 2 * (v30 + (int)i));
          __asm { FCVT            D0, H0 }
          printf("%2.4f ", _D0);
        }
        ++v31;
        v30 += v14;
      }
      while (v31 != v16);
    }
    std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
    v35 = std::locale::use_facet(&v68, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 10);
    std::locale::~locale(&v68);
    std::ostream::put();
    std::ostream::flush();
    v13 = v65 + 1;
    v18 += 2;
    ++v17;
  }
  while (v65 != 7);
  v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" ...", 4);
  std::ios_base::getloc((const std::ios_base *)((char *)v36 + *(_QWORD *)(*v36 - 24)));
  v37 = std::locale::use_facet(&v68, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v37->__vftable[2].~facet_0)(v37, 10);
  std::locale::~locale(&v68);
  std::ostream::put();
  std::ostream::flush();
  v38 = v61 - v63;
  if (v61 < v63)
    v38 = v61 - v63 + 7;
  v39 = v38 >> 3;
  if (v38 >> 3 < v60)
  {
    v40 = 32 * v39;
    v41 = v59 + 32 * v39;
    do
    {
      v64 = v40;
      v66 = v39;
      v42 = 0;
      v43 = v41;
      v62 = v41;
      do
      {
        v44 = 0;
        v45 = 1;
        do
        {
          v46 = 0;
          v47 = v45;
          v48 = v40 + v14 * v44;
          do
          {
            _H0 = *(_WORD *)(a2 + 2 * (v48 + (int)v46));
            __asm { FCVT            D0, H0 }
            printf("%2.4f ", _D0);
            v46 += 8;
          }
          while (v46 != 32);
          v45 = 0;
          v44 = 1;
        }
        while ((v47 & 1) != 0);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
        if (v67 < v16)
        {
          v51 = v43;
          v52 = v67;
          do
          {
            for (j = 0; j != 32; j += 8)
            {
              _H0 = *(_WORD *)(a2 + 2 * (v51 + (int)j));
              __asm { FCVT            D0, H0 }
              printf("%2.4f ", _D0);
            }
            ++v52;
            v51 += v14;
          }
          while (v52 != v16);
        }
        std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
        v56 = std::locale::use_facet(&v68, MEMORY[0x24BEDB350]);
        ((void (*)(const std::locale::facet *, uint64_t))v56->__vftable[2].~facet_0)(v56, 10);
        std::locale::~locale(&v68);
        std::ostream::put();
        std::ostream::flush();
        ++v42;
        ++v40;
        ++v43;
      }
      while (v42 != 8);
      v39 = v66 + 1;
      v40 = v64 + 32;
      v41 = v62 + 32;
    }
    while (v66 + 1 != v60);
  }
  std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
  v57 = std::locale::use_facet(&v68, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v57->__vftable[2].~facet_0)(v57, 10);
  std::locale::~locale(&v68);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_214E933B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::locale a16)
{
  std::locale::~locale(&a16);
  _Unwind_Resume(a1);
}

uint64_t Show::line_column_ordered(uint64_t a1, _WORD *a2, int a3, int a4, int a5)
{
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  const std::locale::facet *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int16 *v19;
  uint64_t v20;
  __int16 *v21;
  uint64_t v28;
  uint64_t v29;
  const std::locale::facet *v32;
  _QWORD *v33;
  _QWORD *v34;
  const std::locale::facet *v35;
  uint64_t v36;
  __int16 *v37;
  uint64_t v38;
  __int16 *v39;
  std::locale::id *v40;
  uint64_t v41;
  __int16 *v42;
  __int16 *v45;
  uint64_t v46;
  const std::locale::facet *v49;
  const std::locale::facet *v50;
  int v52;
  _WORD *v53;
  uint64_t v54;
  uint64_t v55;
  std::locale v56;

  v9 = (_QWORD *)MEMORY[0x24BEDB318];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v10 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)", ", 2);
  v11 = (_QWORD *)std::ostream::operator<<();
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"]", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  v13 = std::locale::use_facet(&v56, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v56);
  std::ostream::put();
  std::ostream::flush();
  v14 = 0;
  v15 = a5;
  v54 = a4;
  v55 = a3 - a5;
  v16 = a3;
  v17 = 2 * a4;
  v52 = a4;
  v53 = a2;
  v18 = 2 * a4 * v55;
  v19 = a2;
  do
  {
    v20 = 8;
    v21 = v19;
    do
    {
      _H0 = *v21;
      __asm { FCVT            D0, H0 }
      printf("%2.4f ", _D0);
      v21 = (__int16 *)((char *)v21 + v17);
      --v20;
    }
    while (v20);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"... ", 4);
    if (v15 >= 1)
    {
      v28 = v18;
      v29 = v55;
      do
      {
        _H0 = *(__int16 *)((char *)v19 + v28);
        __asm { FCVT            D0, H0 }
        printf("%2.4f ", _D0);
        ++v29;
        v28 += v17;
      }
      while (v29 < a3);
    }
    std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
    v32 = std::locale::use_facet(&v56, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v32->__vftable[2].~facet_0)(v32, 10);
    std::locale::~locale(&v56);
    std::ostream::put();
    std::ostream::flush();
    ++v14;
    ++v19;
  }
  while (v14 != 8);
  v33 = (_QWORD *)MEMORY[0x24BEDB318];
  v34 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" ...", 4);
  std::ios_base::getloc((const std::ios_base *)((char *)v34 + *(_QWORD *)(*v34 - 24)));
  v35 = std::locale::use_facet(&v56, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 10);
  std::locale::~locale(&v56);
  std::ostream::put();
  std::ostream::flush();
  if (v15 >= 1)
  {
    v36 = v52 - v15;
    v37 = &v53[v36];
    v38 = 2 * v54;
    v39 = &v53[(int)v54 * (uint64_t)(int)v55 + v36];
    v40 = (std::locale::id *)MEMORY[0x24BEDB350];
    do
    {
      v41 = 8;
      v42 = v37;
      do
      {
        _H0 = *v42;
        __asm { FCVT            D0, H0 }
        printf("%2.4f ", _D0);
        v42 = (__int16 *)((char *)v42 + v38);
        --v41;
      }
      while (v41);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)"... ", 4);
      v45 = v39;
      v46 = v55;
      do
      {
        _H0 = *v45;
        __asm { FCVT            D0, H0 }
        printf("%2.4f ", _D0);
        ++v46;
        v45 = (__int16 *)((char *)v45 + v38);
      }
      while (v46 < v16);
      std::ios_base::getloc((const std::ios_base *)((char *)v33 + *(_QWORD *)(*v33 - 24)));
      v49 = std::locale::use_facet(&v56, v40);
      ((void (*)(const std::locale::facet *, uint64_t))v49->__vftable[2].~facet_0)(v49, 10);
      std::locale::~locale(&v56);
      std::ostream::put();
      std::ostream::flush();
      ++v36;
      ++v37;
      ++v39;
    }
    while (v36 < v54);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v33 + *(_QWORD *)(*v33 - 24)));
  v50 = std::locale::use_facet(&v56, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v50->__vftable[2].~facet_0)(v50, 10);
  std::locale::~locale(&v56);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_214E937B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14)
{
  std::locale::~locale(&a14);
  _Unwind_Resume(a1);
}

uint64_t Show::vector(uint64_t a1, __int16 *a2, int a3, int a4)
{
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  const std::locale::facet *v10;
  uint64_t v11;
  __int16 *v12;
  __int16 v13;
  uint64_t v20;
  const std::locale::facet *v23;
  std::locale v25;

  v7 = (_QWORD *)MEMORY[0x24BEDB318];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v8 = (_QWORD *)std::ostream::operator<<();
  v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"] ", 2);
  std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
  v10 = std::locale::use_facet(&v25, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  std::ostream::flush();
  if (a4 <= 0)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
  }
  else
  {
    v11 = a4;
    v12 = a2;
    do
    {
      v13 = *v12++;
      _H0 = v13;
      __asm { FCVT            D0, H0 }
      printf("%2.4f ", _D0);
      --v11;
    }
    while (v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
    v20 = a3 - a4;
    do
    {
      _H0 = a2[v20];
      __asm { FCVT            D0, H0 }
      printf("%2.4f ", _D0);
      ++v20;
    }
    while (v20 < a3);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
  v23 = std::locale::use_facet(&v25, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10);
  std::locale::~locale(&v25);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_214E9399C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

uint64_t Show::transposed(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  const std::locale::facet *v10;
  uint64_t result;
  int v12;
  uint64_t v13;
  std::locale::id *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t i;
  const std::locale::facet *v26;
  uint64_t v28;
  int v29;
  std::locale v30;

  v6 = (_QWORD *)MEMORY[0x24BEDB318];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v7 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)", ", 2);
  v8 = (_QWORD *)std::ostream::operator<<();
  v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"]", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
  v10 = std::locale::use_facet(&v30, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
  std::locale::~locale(&v30);
  std::ostream::put();
  result = std::ostream::flush();
  if (a4 >= 1)
  {
    v12 = 0;
    v13 = 0;
    v14 = (std::locale::id *)MEMORY[0x24BEDB350];
    do
    {
      v15 = 0;
      v28 = v13;
      v29 = v12;
      v16 = v12 + 32 * a3 / 4 * a4 * ((int)v13 / a4);
      do
      {
        v17 = 0;
        v18 = v16;
        do
        {
          for (i = 0; i != 32; i += 8)
          {
            _H0 = *(_WORD *)(a2 + 2 * (v18 + (int)i));
            __asm { FCVT            D0, H0 }
            printf("%2.7f ", _D0);
          }
          ++v17;
          v18 += 32 * a4;
        }
        while (v17 != 4);
        std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(_QWORD *)(*v6 - 24)));
        v26 = std::locale::use_facet(&v30, v14);
        ((void (*)(const std::locale::facet *, uint64_t))v26->__vftable[2].~facet_0)(v26, 10);
        std::locale::~locale(&v30);
        std::ostream::put();
        result = std::ostream::flush();
        ++v15;
        ++v16;
      }
      while (v15 != 8);
      v13 = v28 + 1;
      v12 = v29 + 32;
    }
    while (v28 + 1 != a4);
  }
  return result;
}

void sub_214E93BC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14)
{
  std::locale::~locale(&a14);
  _Unwind_Resume(a1);
}

uint64_t Show::tensor_column_ordered(Show *this, float *a2, int a3, int a4)
{
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  const std::locale::facet *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  char v22;
  uint64_t v23;
  char v24;
  int v25;
  int v26;
  int v27;
  uint64_t i;
  const std::locale::facet *v29;
  const std::locale::facet *v30;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  std::locale v37;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v7 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)", ", 2);
  v8 = (_QWORD *)std::ostream::operator<<();
  v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"]", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
  v10 = std::locale::use_facet(&v37, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
  std::locale::~locale(&v37);
  std::ostream::put();
  std::ostream::flush();
  v11 = a4 + 3;
  if (a4 >= 0)
    v11 = a4;
  if (a4 >= 4)
  {
    v12 = 0;
    v13 = 0;
    v14 = v11 >> 2;
    v15 = a3 - 8;
    if (a3 < 8)
      v15 = a3 - 5;
    v16 = a3 / 4;
    v17 = 16 * v14;
    v32 = v14;
    v36 = v15 >> 2;
    v18 = 16 * (v15 >> 2) * v14;
    do
    {
      v34 = v13;
      v35 = v12;
      v19 = 0;
      v20 = v18;
      v33 = v18;
      do
      {
        v21 = 0;
        v22 = 1;
        do
        {
          v23 = 0;
          v24 = v22;
          v25 = v12 + v17 * v21;
          do
          {
            printf("%2.7f ", a2[v25 + (int)v23]);
            v23 += 4;
          }
          while (v23 != 16);
          v22 = 0;
          v21 = 1;
        }
        while ((v24 & 1) != 0);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
        if (v36 < v16)
        {
          v26 = v20;
          v27 = v36;
          do
          {
            for (i = 0; i != 16; i += 4)
              printf("%2.7f ", a2[v26 + (int)i]);
            ++v27;
            v26 += v17;
          }
          while (v27 != v16);
        }
        std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
        v29 = std::locale::use_facet(&v37, MEMORY[0x24BEDB350]);
        ((void (*)(const std::locale::facet *, uint64_t))v29->__vftable[2].~facet_0)(v29, 10);
        std::locale::~locale(&v37);
        std::ostream::put();
        std::ostream::flush();
        ++v19;
        ++v12;
        ++v20;
      }
      while (v19 != 4);
      v13 = v34 + 1;
      v12 = v35 + 16;
      v18 = v33 + 16;
    }
    while (v34 + 1 != v32);
  }
  std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
  v30 = std::locale::use_facet(&v37, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v30->__vftable[2].~facet_0)(v30, 10);
  std::locale::~locale(&v37);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_214E93EDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14)
{
  std::locale::~locale(&a14);
  _Unwind_Resume(a1);
}

uint64_t Show::qtensor_column_ordered(Show *this, float *a2, int a3, int a4, int a5)
{
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  const std::locale::facet *v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  float *v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  char v22;
  char *v23;
  int v24;
  int v25;
  uint64_t i;
  const std::locale::facet *v27;
  _QWORD *v28;
  const std::locale::facet *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  char v37;
  uint64_t v38;
  char v39;
  int v40;
  int v41;
  int v42;
  uint64_t j;
  const std::locale::facet *v44;
  const std::locale::facet *v45;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  std::locale v56;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v9 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
  v10 = (_QWORD *)std::ostream::operator<<();
  v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"]", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v11 + *(_QWORD *)(*v11 - 24)));
  v12 = std::locale::use_facet(&v56, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 10);
  std::locale::~locale(&v56);
  std::ostream::put();
  std::ostream::flush();
  v13 = 0;
  v14 = 32 * (a4 / 8);
  v51 = a5;
  v15 = a3 - a5;
  if (a3 < a5)
    v15 = a3 - a5 + 3;
  v16 = a3 / 4;
  v48 = a4 / 8;
  v49 = a4;
  v55 = v15 >> 2;
  v17 = 32 * (v15 >> 2) * (a4 / 8);
  v47 = v17;
  v18 = a2;
  do
  {
    v53 = v13;
    v19 = 0;
    v20 = 1;
    do
    {
      v21 = 0;
      v22 = v20;
      v23 = (char *)v18 + 4 * v14 * v19;
      do
      {
        printf("%2.4f ", *(float *)&v23[v21]);
        v21 += 32;
      }
      while (v21 != 128);
      v20 = 0;
      v19 = 1;
    }
    while ((v22 & 1) != 0);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
    if (v55 < v16)
    {
      v24 = v17;
      v25 = v55;
      do
      {
        for (i = 0; i != 32; i += 8)
          printf("%2.4f ", a2[v24 + (int)i]);
        ++v25;
        v24 += v14;
      }
      while (v25 != v16);
    }
    std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
    v27 = std::locale::use_facet(&v56, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v27->__vftable[2].~facet_0)(v27, 10);
    std::locale::~locale(&v56);
    std::ostream::put();
    std::ostream::flush();
    v13 = v53 + 1;
    ++v18;
    ++v17;
  }
  while (v53 != 7);
  v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" ...", 4);
  std::ios_base::getloc((const std::ios_base *)((char *)v28 + *(_QWORD *)(*v28 - 24)));
  v29 = std::locale::use_facet(&v56, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v29->__vftable[2].~facet_0)(v29, 10);
  std::locale::~locale(&v56);
  std::ostream::put();
  std::ostream::flush();
  v30 = v49 - v51;
  if (v49 < v51)
    v30 = v49 - v51 + 7;
  v31 = v30 >> 3;
  if (v30 >> 3 < v48)
  {
    v32 = 32 * v31;
    v33 = v47 + 32 * v31;
    do
    {
      v52 = v32;
      v54 = v31;
      v34 = 0;
      v35 = v33;
      v50 = v33;
      do
      {
        v36 = 0;
        v37 = 1;
        do
        {
          v38 = 0;
          v39 = v37;
          v40 = v32 + v14 * v36;
          do
          {
            printf("%2.4f ", a2[v40 + (int)v38]);
            v38 += 8;
          }
          while (v38 != 32);
          v37 = 0;
          v36 = 1;
        }
        while ((v39 & 1) != 0);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"... ", 4);
        if (v55 < v16)
        {
          v41 = v35;
          v42 = v55;
          do
          {
            for (j = 0; j != 32; j += 8)
              printf("%2.4f ", a2[v41 + (int)j]);
            ++v42;
            v41 += v14;
          }
          while (v42 != v16);
        }
        std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
        v44 = std::locale::use_facet(&v56, MEMORY[0x24BEDB350]);
        ((void (*)(const std::locale::facet *, uint64_t))v44->__vftable[2].~facet_0)(v44, 10);
        std::locale::~locale(&v56);
        std::ostream::put();
        std::ostream::flush();
        ++v34;
        ++v32;
        ++v35;
      }
      while (v34 != 8);
      v31 = v54 + 1;
      v32 = v52 + 32;
      v33 = v50 + 32;
    }
    while (v54 + 1 != v48);
  }
  std::ios_base::getloc((const std::ios_base *)(MEMORY[0x24BEDB318] + *(_QWORD *)(*MEMORY[0x24BEDB318] - 24)));
  v45 = std::locale::use_facet(&v56, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v45->__vftable[2].~facet_0)(v45, 10);
  std::locale::~locale(&v56);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_214E943C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::locale a16)
{
  std::locale::~locale(&a16);
  _Unwind_Resume(a1);
}

uint64_t Show::line_column_ordered(Show *this, float *a2, int a3, int a4, int a5)
{
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  const std::locale::facet *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  float *v21;
  uint64_t v22;
  uint64_t v23;
  const std::locale::facet *v24;
  _QWORD *v25;
  _QWORD *v26;
  const std::locale::facet *v27;
  uint64_t v28;
  float *v29;
  uint64_t v30;
  float *v31;
  std::locale::id *v32;
  uint64_t v33;
  float *v34;
  float *v35;
  uint64_t v36;
  const std::locale::facet *v37;
  const std::locale::facet *v38;
  int v40;
  float *v41;
  uint64_t v42;
  uint64_t v43;
  std::locale v44;

  v9 = (_QWORD *)MEMORY[0x24BEDB318];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" [", 2);
  v10 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)", ", 2);
  v11 = (_QWORD *)std::ostream::operator<<();
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"]", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  v13 = std::locale::use_facet(&v44, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v44);
  std::ostream::put();
  std::ostream::flush();
  v14 = 0;
  v15 = a5;
  v42 = a4;
  v43 = a3 - a5;
  v16 = a3;
  v17 = 4 * a4;
  v40 = a4;
  v41 = a2;
  v18 = 4 * a4 * v43;
  v19 = a2;
  do
  {
    v20 = 8;
    v21 = v19;
    do
    {
      printf("%2.4f ", *v21);
      v21 = (float *)((char *)v21 + v17);
      --v20;
    }
    while (v20);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"... ", 4);
    if (v15 >= 1)
    {
      v22 = v18;
      v23 = v43;
      do
      {
        printf("%2.4f ", *(float *)((char *)v19 + v22));
        ++v23;
        v22 += v17;
      }
      while (v23 < a3);
    }
    std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
    v24 = std::locale::use_facet(&v44, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v24->__vftable[2].~facet_0)(v24, 10);
    std::locale::~locale(&v44);
    std::ostream::put();
    std::ostream::flush();
    ++v14;
    ++v19;
  }
  while (v14 != 8);
  v25 = (_QWORD *)MEMORY[0x24BEDB318];
  v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)" ...", 4);
  std::ios_base::getloc((const std::ios_base *)((char *)v26 + *(_QWORD *)(*v26 - 24)));
  v27 = std::locale::use_facet(&v44, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v27->__vftable[2].~facet_0)(v27, 10);
  std::locale::~locale(&v44);
  std::ostream::put();
  std::ostream::flush();
  if (v15 >= 1)
  {
    v28 = v40 - v15;
    v29 = &v41[v28];
    v30 = 4 * v42;
    v31 = &v41[(int)v42 * (uint64_t)(int)v43 + v28];
    v32 = (std::locale::id *)MEMORY[0x24BEDB350];
    do
    {
      v33 = 8;
      v34 = v29;
      do
      {
        printf("%2.4f ", *v34);
        v34 = (float *)((char *)v34 + v30);
        --v33;
      }
      while (v33);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"... ", 4);
      v35 = v31;
      v36 = v43;
      do
      {
        printf("%2.4f ", *v35);
        ++v36;
        v35 = (float *)((char *)v35 + v30);
      }
      while (v36 < v16);
      std::ios_base::getloc((const std::ios_base *)((char *)v25 + *(_QWORD *)(*v25 - 24)));
      v37 = std::locale::use_facet(&v44, v32);
      ((void (*)(const std::locale::facet *, uint64_t))v37->__vftable[2].~facet_0)(v37, 10);
      std::locale::~locale(&v44);
      std::ostream::put();
      std::ostream::flush();
      ++v28;
      ++v29;
      ++v31;
    }
    while (v28 < v42);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v25 + *(_QWORD *)(*v25 - 24)));
  v38 = std::locale::use_facet(&v44, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
  std::locale::~locale(&v44);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_214E947C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14)
{
  std::locale::~locale(&a14);
  _Unwind_Resume(a1);
}

void `virtual thunk to'std::ofstream::~ofstream(_QWORD *a1)
{
  void (__cdecl ***v1)(std::ofstream *__hidden);

  v1 = (void (__cdecl ***)(std::ofstream *__hidden))((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::filebuf::~filebuf((uint64_t)(v1 + 1));
  std::ostream::~ostream();
  JUMPOUT(0x2199DA5E8);
}

{
  void (__cdecl ***v1)(std::ofstream *__hidden);

  v1 = (void (__cdecl ***)(std::ofstream *__hidden))((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::filebuf::~filebuf((uint64_t)(v1 + 1));
  std::ostream::~ostream();
  MEMORY[0x2199DA5E8](v1 + 52);
  operator delete(v1);
}

void std::ofstream::~ofstream(void (__cdecl ***a1)(std::ofstream *__hidden this))
{
  _QWORD *v2;

  v2 = a1 + 52;
  std::filebuf::~filebuf((uint64_t)(a1 + 1));
  std::ostream::~ostream();
  MEMORY[0x2199DA5E8](v2);
  operator delete(a1);
}

uint64_t std::filebuf::~filebuf(uint64_t a1)
{
  void *v2;
  void *v3;

  std::filebuf::close((FILE *)a1);
  if (*(_BYTE *)(a1 + 400))
  {
    v2 = *(void **)(a1 + 64);
    if (v2)
      operator delete[](v2);
  }
  if (*(_BYTE *)(a1 + 401))
  {
    v3 = *(void **)(a1 + 104);
    if (v3)
      operator delete[](v3);
  }
  return std::streambuf::~streambuf();
}

void sub_214E94974(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x214E9493CLL);
}

FILE *std::filebuf::close(FILE *a1)
{
  FILE *base;
  int v3;

  base = (FILE *)a1->_lb._base;
  if (base)
  {
    v3 = (*((uint64_t (**)(FILE *))a1->_p + 6))(a1);
    if (fclose(base) | v3)
      base = 0;
    else
      base = a1;
    a1->_lb._base = 0;
    (*((void (**)(FILE *, _QWORD, _QWORD))a1->_p + 3))(a1, 0, 0);
  }
  return base;
}

void sub_214E949F4(_Unwind_Exception *a1)
{
  FILE *v1;

  fclose(v1);
  _Unwind_Resume(a1);
}

void std::filebuf::~filebuf(uint64_t a1)
{
  void *v1;

  v1 = (void *)std::filebuf::~filebuf(a1);
  operator delete(v1);
}

void std::filebuf::imbue(uint64_t a1, const std::locale *a2)
{
  const std::locale::facet *v4;
  int v5;
  void *v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  size_t v10;

  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  v4 = std::locale::use_facet(a2, MEMORY[0x24BEDB488]);
  *(_QWORD *)(a1 + 128) = v4;
  LODWORD(a2) = *(unsigned __int8 *)(a1 + 402);
  v5 = ((uint64_t (*)(const std::locale::facet *))v4->__vftable[2].~facet_0)(v4);
  *(_BYTE *)(a1 + 402) = v5;
  if ((_DWORD)a2 != v5)
  {
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    if (v5)
    {
      if (*(_BYTE *)(a1 + 400))
      {
        v6 = *(void **)(a1 + 64);
        if (v6)
          operator delete[](v6);
      }
      *(_BYTE *)(a1 + 400) = *(_BYTE *)(a1 + 401);
      v7 = *(_QWORD *)(a1 + 112);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 104);
      *(_BYTE *)(a1 + 401) = 0;
      *(_QWORD *)(a1 + 104) = 0;
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 96) = v7;
    }
    else if (*(_BYTE *)(a1 + 400) || (v9 = *(_QWORD *)(a1 + 64), v9 == a1 + 88))
    {
      v8 = *(_QWORD *)(a1 + 96);
      *(_QWORD *)(a1 + 112) = v8;
      *(_QWORD *)(a1 + 104) = operator new[](v8);
      *(_BYTE *)(a1 + 401) = 1;
    }
    else
    {
      v10 = *(_QWORD *)(a1 + 96);
      *(_QWORD *)(a1 + 104) = v9;
      *(_QWORD *)(a1 + 112) = v10;
      *(_BYTE *)(a1 + 401) = 0;
      *(_QWORD *)(a1 + 64) = operator new[](v10);
      *(_BYTE *)(a1 + 400) = 1;
    }
  }
}

uint64_t std::filebuf::setbuf(uint64_t a1, uint64_t a2, int64_t __sz)
{
  void *v6;
  void *v7;
  int v8;
  size_t v10;

  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (*(_BYTE *)(a1 + 400))
  {
    v6 = *(void **)(a1 + 64);
    if (v6)
      operator delete[](v6);
  }
  if (*(_BYTE *)(a1 + 401))
  {
    v7 = *(void **)(a1 + 104);
    if (v7)
      operator delete[](v7);
  }
  *(_QWORD *)(a1 + 96) = __sz;
  if ((unint64_t)__sz < 9)
  {
    *(_QWORD *)(a1 + 64) = a1 + 88;
    *(_QWORD *)(a1 + 96) = 8;
    *(_BYTE *)(a1 + 400) = 0;
    if (*(_BYTE *)(a1 + 402))
      goto LABEL_12;
  }
  else
  {
    v8 = *(unsigned __int8 *)(a1 + 402);
    if (a2 && *(_BYTE *)(a1 + 402))
    {
      *(_QWORD *)(a1 + 64) = a2;
      *(_BYTE *)(a1 + 400) = 0;
LABEL_12:
      *(_BYTE *)(a1 + 401) = 0;
      *(_QWORD *)(a1 + 104) = 0;
      *(_QWORD *)(a1 + 112) = 0;
      return a1;
    }
    *(_QWORD *)(a1 + 64) = operator new[](__sz);
    *(_BYTE *)(a1 + 400) = 1;
    if (v8)
      goto LABEL_12;
  }
  if (__sz <= 8)
    v10 = 8;
  else
    v10 = __sz;
  *(_QWORD *)(a1 + 112) = v10;
  if (a2 && v10 >= 9)
  {
    *(_QWORD *)(a1 + 104) = a2;
    *(_BYTE *)(a1 + 401) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 104) = operator new[](v10);
    *(_BYTE *)(a1 + 401) = 1;
  }
  return a1;
}

__n128 std::filebuf::seekoff@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  int v9;
  __n128 result;
  int v11;
  off_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  v5 = *(_QWORD *)(a1 + 128);
  if (!v5)
    std::__throw_bad_cast[abi:ne180100]();
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
  if (!*(_QWORD *)(a1 + 120)
    || (v11 = v9, a2) && v9 < 1
    || (*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1)
    || a3 >= 3
    || (v11 <= 0 ? (v12 = 0) : (v12 = v11 * a2), fseeko(*(FILE **)(a1 + 120), v12, a3)))
  {
    result.n128_u64[0] = 0;
    *(_OWORD *)(a4 + 96) = 0u;
    *(_OWORD *)(a4 + 112) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 80) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_QWORD *)(a4 + 128) = -1;
  }
  else
  {
    *(_QWORD *)(a4 + 128) = ftello(*(FILE **)(a1 + 120));
    v13 = *(_OWORD *)(a1 + 216);
    *(_OWORD *)(a4 + 64) = *(_OWORD *)(a1 + 200);
    *(_OWORD *)(a4 + 80) = v13;
    v14 = *(_OWORD *)(a1 + 248);
    *(_OWORD *)(a4 + 96) = *(_OWORD *)(a1 + 232);
    *(_OWORD *)(a4 + 112) = v14;
    v15 = *(_OWORD *)(a1 + 152);
    *(_OWORD *)a4 = *(_OWORD *)(a1 + 136);
    *(_OWORD *)(a4 + 16) = v15;
    result = *(__n128 *)(a1 + 168);
    v16 = *(_OWORD *)(a1 + 184);
    *(__n128 *)(a4 + 32) = result;
    *(_OWORD *)(a4 + 48) = v16;
  }
  return result;
}

__n128 std::filebuf::seekpos@<Q0>(FILE **a1@<X0>, __n128 *a2@<X1>, uint64_t a3@<X8>)
{
  __n128 result;
  __n128 v7;
  __n128 v8;
  __n128 v9;

  if (!a1[15] || ((unsigned int (*)(FILE **))(*a1)->_cookie)(a1) || fseeko(a1[15], a2[8].n128_i64[0], 0))
  {
    result.n128_u64[0] = 0;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_QWORD *)(a3 + 128) = -1;
  }
  else
  {
    memmove(a1 + 17, a2, 0x80uLL);
    v7 = a2[7];
    *(__n128 *)(a3 + 96) = a2[6];
    *(__n128 *)(a3 + 112) = v7;
    *(_QWORD *)(a3 + 128) = a2[8].n128_u64[0];
    v8 = a2[3];
    *(__n128 *)(a3 + 32) = a2[2];
    *(__n128 *)(a3 + 48) = v8;
    v9 = a2[5];
    *(__n128 *)(a3 + 64) = a2[4];
    *(__n128 *)(a3 + 80) = v9;
    result = a2[1];
    *(__n128 *)a3 = *a2;
    *(__n128 *)(a3 + 16) = result;
  }
  return result;
}

uint64_t std::filebuf::sync(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  const void *v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  int v12;
  uint64_t v13;
  int v14;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a1 + 120))
    return 0;
  v2 = *(_QWORD *)(a1 + 128);
  if (!v2)
    std::__throw_bad_cast[abi:ne180100]();
  v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x10) != 0)
  {
    if (*(_QWORD *)(a1 + 48) == *(_QWORD *)(a1 + 40)
      || (v4 = 0xFFFFFFFFLL,
          (*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 104))(a1, 0xFFFFFFFFLL) != -1))
    {
      while (1)
      {
        v5 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD, __int128 *))(**(_QWORD **)(a1 + 128) + 40))(*(_QWORD *)(a1 + 128), a1 + 136, *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 64) + *(_QWORD *)(a1 + 96), &v21);
        v6 = *(const void **)(a1 + 64);
        v7 = v21 - (_QWORD)v6;
        if (fwrite(v6, 1uLL, v21 - (_QWORD)v6, *(FILE **)(a1 + 120)) != v7)
          break;
        if (v5 != 1)
        {
          if (v5 == 2 || fflush(*(FILE **)(a1 + 120)))
            return 0xFFFFFFFFLL;
          return 0;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if ((v3 & 8) == 0)
      return 0;
    v8 = *(_OWORD *)(a1 + 344);
    v25 = *(_OWORD *)(a1 + 328);
    v26 = v8;
    v9 = *(_OWORD *)(a1 + 376);
    v27 = *(_OWORD *)(a1 + 360);
    v28 = v9;
    v10 = *(_OWORD *)(a1 + 280);
    v21 = *(_OWORD *)(a1 + 264);
    v22 = v10;
    v11 = *(_OWORD *)(a1 + 312);
    v23 = *(_OWORD *)(a1 + 296);
    v24 = v11;
    if (*(_BYTE *)(a1 + 402))
    {
      v12 = 0;
      v13 = *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24);
    }
    else
    {
      v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
      v13 = *(_QWORD *)(a1 + 80) - *(_QWORD *)(a1 + 72);
      if (v14 < 1)
      {
        if (*(_QWORD *)(a1 + 24) == *(_QWORD *)(a1 + 32))
        {
          v12 = 0;
        }
        else
        {
          v13 = v13
              + *(_QWORD *)(a1 + 72)
              - (*(_QWORD *)(a1 + 64)
               + (*(int (**)(_QWORD, __int128 *, _QWORD))(**(_QWORD **)(a1 + 128) + 64))(*(_QWORD *)(a1 + 128), &v21, *(_QWORD *)(a1 + 64)));
          v12 = 1;
        }
      }
      else
      {
        v12 = 0;
        v13 += (*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) * v14;
      }
    }
    if (fseeko(*(FILE **)(a1 + 120), -v13, 1))
      return 0xFFFFFFFFLL;
    if (v12)
    {
      v16 = v26;
      *(_OWORD *)(a1 + 200) = v25;
      *(_OWORD *)(a1 + 216) = v16;
      v17 = v28;
      *(_OWORD *)(a1 + 232) = v27;
      *(_OWORD *)(a1 + 248) = v17;
      v18 = v22;
      *(_OWORD *)(a1 + 136) = v21;
      *(_OWORD *)(a1 + 152) = v18;
      v19 = v24;
      *(_OWORD *)(a1 + 168) = v23;
      *(_OWORD *)(a1 + 184) = v19;
    }
    v4 = 0;
    v20 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(a1 + 72) = v20;
    *(_QWORD *)(a1 + 80) = v20;
    *(_DWORD *)(a1 + 396) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  return v4;
}

uint64_t std::filebuf::underflow(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  uint64_t result;
  unsigned __int8 *v8;
  size_t v9;
  size_t v10;
  unsigned __int8 *v11;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  FILE *v19;
  size_t v20;
  size_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  size_t v26;
  size_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  char *v31;
  unsigned __int8 *v32;
  char v33;
  uint64_t v34;

  if (!*(_QWORD *)(a1 + 120))
    return 0xFFFFFFFFLL;
  v2 = *(_DWORD *)(a1 + 396);
  if ((v2 & 8) != 0)
  {
    v6 = *(unsigned __int8 **)(a1 + 24);
    if (v6)
      goto LABEL_12;
    goto LABEL_11;
  }
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  v3 = 96;
  if (!*(_BYTE *)(a1 + 402))
    v3 = 112;
  v4 = 64;
  if (!*(_BYTE *)(a1 + 402))
    v4 = 104;
  v5 = *(_QWORD *)(a1 + v4);
  v6 = (unsigned __int8 *)(v5 + *(_QWORD *)(a1 + v3));
  *(_QWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 24) = v6;
  *(_QWORD *)(a1 + 32) = v6;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 396) = 8;
  if (!v6)
  {
LABEL_11:
    v6 = (unsigned __int8 *)&v34;
    *(_QWORD *)(a1 + 16) = &v33;
    *(_QWORD *)(a1 + 24) = &v34;
    *(_QWORD *)(a1 + 32) = &v34;
  }
LABEL_12:
  v8 = *(unsigned __int8 **)(a1 + 32);
  if ((v2 & 8) != 0)
  {
    if ((unint64_t)((uint64_t)&v8[-*(_QWORD *)(a1 + 16)] / 2) >= 4)
      v9 = 4;
    else
      v9 = (uint64_t)&v8[-*(_QWORD *)(a1 + 16)] / 2;
  }
  else
  {
    v9 = 0;
  }
  if (v6 != v8)
    goto LABEL_36;
  memmove(*(void **)(a1 + 16), &v6[-v9], v9);
  if (*(_BYTE *)(a1 + 402))
  {
    v10 = fread((void *)(v9 + *(_QWORD *)(a1 + 16)), 1uLL, *(_QWORD *)(a1 + 32) - (v9 + *(_QWORD *)(a1 + 16)), *(FILE **)(a1 + 120));
    if (v10)
    {
      v6 = (unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v9);
      v11 = &v6[v10];
LABEL_35:
      *(_QWORD *)(a1 + 24) = v6;
      *(_QWORD *)(a1 + 32) = v11;
LABEL_36:
      result = *v6;
      goto LABEL_37;
    }
  }
  else
  {
    v12 = *(_BYTE **)(a1 + 72);
    v13 = *(_BYTE **)(a1 + 80);
    if (v13 == v12)
    {
      v14 = *(_QWORD *)(a1 + 80);
    }
    else
    {
      memmove(*(void **)(a1 + 64), v12, v13 - v12);
      v13 = *(_BYTE **)(a1 + 72);
      v14 = *(_QWORD *)(a1 + 80);
    }
    v15 = *(_QWORD *)(a1 + 64);
    v16 = (void *)(v15 + v14 - (_QWORD)v13);
    *(_QWORD *)(a1 + 72) = v16;
    if (v15 == a1 + 88)
      v17 = 8;
    else
      v17 = *(_QWORD *)(a1 + 96);
    v18 = v15 + v17;
    *(_QWORD *)(a1 + 80) = v18;
    v19 = *(FILE **)(a1 + 120);
    v20 = v18 - (_QWORD)v16;
    if (v20 >= *(_QWORD *)(a1 + 112) - v9)
      v21 = *(_QWORD *)(a1 + 112) - v9;
    else
      v21 = v20;
    v22 = *(_OWORD *)(a1 + 216);
    *(_OWORD *)(a1 + 328) = *(_OWORD *)(a1 + 200);
    *(_OWORD *)(a1 + 344) = v22;
    v23 = *(_OWORD *)(a1 + 248);
    *(_OWORD *)(a1 + 360) = *(_OWORD *)(a1 + 232);
    *(_OWORD *)(a1 + 376) = v23;
    v24 = *(_OWORD *)(a1 + 152);
    *(_OWORD *)(a1 + 264) = *(_OWORD *)(a1 + 136);
    *(_OWORD *)(a1 + 280) = v24;
    v25 = *(_OWORD *)(a1 + 184);
    *(_OWORD *)(a1 + 296) = *(_OWORD *)(a1 + 168);
    *(_OWORD *)(a1 + 312) = v25;
    v26 = fread(v16, 1uLL, v21, v19);
    if (v26)
    {
      v27 = v26;
      v28 = *(_QWORD *)(a1 + 128);
      if (!v28)
        std::__throw_bad_cast[abi:ne180100]();
      v29 = *(_QWORD *)(a1 + 64);
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a1 + 72) + v27;
      if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v28 + 32))(v28, a1 + 136, v29) == 3)
      {
        v6 = *(unsigned __int8 **)(a1 + 64);
        v11 = *(unsigned __int8 **)(a1 + 80);
        *(_QWORD *)(a1 + 16) = v6;
        goto LABEL_35;
      }
      v11 = v32;
      v6 = (unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v9);
      if (v32 != v6)
        goto LABEL_35;
    }
  }
  result = 0xFFFFFFFFLL;
LABEL_37:
  v31 = *(char **)(a1 + 16);
  v30 = (_QWORD *)(a1 + 16);
  if (v31 == &v33)
  {
    *v30 = 0;
    v30[1] = 0;
    v30[2] = 0;
  }
  return result;
}

uint64_t std::filebuf::pbackfail(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  if (!*(_QWORD *)(a1 + 120))
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 24);
  if (*(_QWORD *)(a1 + 16) >= v2)
    return 0xFFFFFFFFLL;
  if ((_DWORD)a2 == -1)
  {
    a2 = 0;
    *(_QWORD *)(a1 + 24) = v2 - 1;
    return a2;
  }
  if ((*(_BYTE *)(a1 + 392) & 0x10) == 0 && *(unsigned __int8 *)(v2 - 1) != a2)
    return 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 24) = v2 - 1;
  *(_BYTE *)(v2 - 1) = a2;
  return a2;
}

uint64_t std::filebuf::overflow(uint64_t a1, unsigned int a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  size_t v8;
  FILE *v9;
  const void *v10;
  uint64_t v12;
  unsigned int v13;
  const void *v14;
  uint64_t v15;
  const void *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;

  if (!*(_QWORD *)(a1 + 120))
    return 0xFFFFFFFFLL;
  std::filebuf::__write_mode(a1);
  v4 = *(char **)(a1 + 48);
  v5 = *(_QWORD *)(a1 + 56);
  v6 = *(_QWORD *)(a1 + 40);
  if (a2 == -1)
  {
    v7 = *(_BYTE **)(a1 + 40);
  }
  else
  {
    if (!v4)
    {
      v4 = &v18;
      *(_QWORD *)(a1 + 40) = &v18;
      *(_QWORD *)(a1 + 48) = &v18;
      *(_QWORD *)(a1 + 56) = &v19;
    }
    *v4 = a2;
    v7 = *(_BYTE **)(a1 + 40);
    v4 = (char *)(*(_QWORD *)(a1 + 48) + 1);
    *(_QWORD *)(a1 + 48) = v4;
  }
  v8 = v4 - v7;
  if (v4 == v7)
    goto LABEL_12;
  if (!*(_BYTE *)(a1 + 402))
  {
    v17 = *(_QWORD *)(a1 + 64);
    v12 = *(_QWORD *)(a1 + 128);
    if (!v12)
LABEL_22:
      std::__throw_bad_cast[abi:ne180100]();
    while (1)
    {
      v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v12 + 24))(v12, a1 + 136);
      v10 = *(const void **)(a1 + 40);
      if (v16 == v10)
        return 0xFFFFFFFFLL;
      if (v13 == 3)
      {
        v8 = *(_QWORD *)(a1 + 48) - (_QWORD)v10;
        v9 = *(FILE **)(a1 + 120);
        goto LABEL_10;
      }
      if (v13 > 1)
        return 0xFFFFFFFFLL;
      v14 = *(const void **)(a1 + 64);
      if (fwrite(v14, 1uLL, v17 - (_QWORD)v14, *(FILE **)(a1 + 120)) != v17 - (_QWORD)v14)
        return 0xFFFFFFFFLL;
      if (v13 != 1)
        goto LABEL_11;
      v15 = *(_QWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 40) = v16;
      *(_QWORD *)(a1 + 56) = v15;
      v12 = *(_QWORD *)(a1 + 128);
      if (!v12)
        goto LABEL_22;
    }
  }
  v9 = *(FILE **)(a1 + 120);
  v10 = v7;
LABEL_10:
  if (fwrite(v10, 1uLL, v8, v9) != v8)
    return 0xFFFFFFFFLL;
LABEL_11:
  *(_QWORD *)(a1 + 40) = v6;
  *(_QWORD *)(a1 + 48) = v6;
  *(_QWORD *)(a1 + 56) = v5;
LABEL_12:
  if (a2 == -1)
    return 0;
  else
    return a2;
}

void std::__throw_bad_cast[abi:ne180100]()
{
  std::bad_cast *exception;
  std::bad_cast *v1;

  exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_cast::bad_cast(exception);
  __cxa_throw(v1, MEMORY[0x24BEDB750], MEMORY[0x24BEDB650]);
}

uint64_t std::filebuf::__write_mode(uint64_t result)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if ((*(_BYTE *)(result + 396) & 0x10) == 0)
  {
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)(result + 32) = 0;
    v1 = *(_QWORD *)(result + 96);
    if (v1 < 9)
    {
      *(_QWORD *)(result + 40) = 0;
      *(_QWORD *)(result + 48) = 0;
      *(_QWORD *)(result + 56) = 0;
    }
    else if (*(_BYTE *)(result + 402))
    {
      v2 = *(_QWORD *)(result + 64);
      *(_QWORD *)(result + 40) = v2;
      *(_QWORD *)(result + 48) = v2;
      *(_QWORD *)(result + 56) = v1 + v2 - 1;
    }
    else
    {
      v3 = *(_QWORD *)(result + 104);
      v4 = *(_QWORD *)(result + 112) + v3 - 1;
      *(_QWORD *)(result + 40) = v3;
      *(_QWORD *)(result + 48) = v3;
      *(_QWORD *)(result + 56) = v4;
    }
    *(_DWORD *)(result + 396) = 16;
  }
  return result;
}

uint64_t std::filebuf::basic_filebuf(uint64_t a1)
{
  uint64_t v2;
  const std::locale *v3;
  _BOOL4 has_facet;
  std::locale v6;

  v2 = std::streambuf::basic_streambuf();
  *(_QWORD *)(v2 + 72) = 0;
  *(_QWORD *)(v2 + 80) = 0;
  *(_QWORD *)(v2 + 64) = 0;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_OWORD *)(v2 + 144) = 0u;
  *(_OWORD *)(v2 + 160) = 0u;
  *(_OWORD *)(v2 + 176) = 0u;
  *(_OWORD *)(v2 + 192) = 0u;
  *(_OWORD *)(v2 + 208) = 0u;
  *(_OWORD *)(v2 + 224) = 0u;
  *(_OWORD *)(v2 + 240) = 0u;
  *(_OWORD *)(v2 + 256) = 0u;
  *(_OWORD *)(v2 + 272) = 0u;
  *(_OWORD *)(v2 + 288) = 0u;
  *(_OWORD *)(v2 + 304) = 0u;
  *(_OWORD *)(v2 + 320) = 0u;
  *(_OWORD *)(v2 + 336) = 0u;
  *(_OWORD *)(v2 + 368) = 0u;
  *(_OWORD *)(v2 + 384) = 0u;
  *(_DWORD *)(v2 + 399) = 0;
  v3 = (const std::locale *)(v2 + 8);
  *(_OWORD *)(v2 + 352) = 0u;
  std::locale::locale(&v6, (const std::locale *)(v2 + 8));
  has_facet = std::locale::has_facet(&v6, MEMORY[0x24BEDB488]);
  std::locale::~locale(&v6);
  if (has_facet)
  {
    std::locale::locale(&v6, v3);
    *(_QWORD *)(a1 + 128) = std::locale::use_facet(&v6, MEMORY[0x24BEDB488]);
    std::locale::~locale(&v6);
    *(_BYTE *)(a1 + 402) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 128) + 56))(*(_QWORD *)(a1 + 128));
  }
  (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 24))(a1, 0, 4096);
  return a1;
}

void sub_214E955CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

FILE *std::filebuf::open(uint64_t a1, char *__filename, int a3)
{
  FILE *result;
  signed int v6;
  const char *v7;

  if (*(_QWORD *)(a1 + 120))
    return 0;
  result = 0;
  v6 = a3 & 0xFFFFFFFD;
  v7 = "w";
  if ((int)(a3 & 0xFFFFFFFD) > 47)
  {
    if (v6 > 55)
    {
      if (v6 == 56)
      {
        v7 = "w+";
      }
      else
      {
        if (v6 != 60)
          return result;
        v7 = "w+b";
      }
    }
    else if (v6 != 48)
    {
      if (v6 != 52)
        return result;
LABEL_10:
      v7 = "wb";
    }
LABEL_22:
    result = fopen(__filename, v7);
    *(_QWORD *)(a1 + 120) = result;
    if (result)
    {
      *(_DWORD *)(a1 + 392) = a3;
      if ((a3 & 2) != 0 && fseek(result, 0, 2))
      {
        fclose(*(FILE **)(a1 + 120));
        result = 0;
        *(_QWORD *)(a1 + 120) = 0;
      }
      else
      {
        return (FILE *)a1;
      }
    }
  }
  else
  {
    switch(v6)
    {
      case 1:
      case 17:
        v7 = "a";
        goto LABEL_22;
      case 5:
      case 21:
        v7 = "ab";
        goto LABEL_22;
      case 8:
        v7 = "r";
        goto LABEL_22;
      case 9:
      case 25:
        v7 = "a+";
        goto LABEL_22;
      case 12:
        v7 = "rb";
        goto LABEL_22;
      case 13:
      case 29:
        v7 = "a+b";
        goto LABEL_22;
      case 16:
        goto LABEL_22;
      case 20:
        goto LABEL_10;
      case 24:
        v7 = "r+";
        goto LABEL_22;
      case 28:
        v7 = "r+b";
        goto LABEL_22;
      default:
        return result;
    }
  }
  return result;
}

_QWORD *NeonConvNetManager::NeonConvNetManager(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = CustomAllocator::mRsrc;
  a1[42] = 0;
  a1[43] = 0;
  a1[3] = a2;
  a1[4] = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 42, a3);
  *(_BYTE *)(a1[3] + 2720) = 0;
  return a1;
}

{
  a1[1] = 0;
  a1[2] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = CustomAllocator::mRsrc;
  a1[42] = 0;
  a1[43] = 0;
  a1[3] = a2;
  a1[4] = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 42, a3);
  *(_BYTE *)(a1[3] + 2720) = 0;
  return a1;
}

void NeonConvNetManager::~NeonConvNetManager(NeonConvNetManager *this)
{
  uint64_t v2;
  uint64_t v3;

  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *((_QWORD *)this + 17));
  v2 = 152;
  v3 = 216;
  do
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *(_QWORD *)((char *)this + v2 - 8));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *(_QWORD *)((char *)this + v2));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *(_QWORD *)((char *)this + v3 - 24));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *(_QWORD *)((char *)this + v3 - 16));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *(_QWORD *)((char *)this + v3 - 8));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *(_QWORD *)((char *)this + v3));
    v2 += 16;
    v3 += 32;
  }
  while (v2 != 200);
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *((_QWORD *)this + 36));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *((_QWORD *)this + 37));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *(_QWORD *)(*((_QWORD *)this + 3) + 3360));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 42) + 56))(*((_QWORD *)this + 42), *(_QWORD *)(*((_QWORD *)this + 3) + 3312));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 336);
  if (*((char *)this + 55) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 7) + 8), *((_QWORD *)this + 4));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

uint64_t NeonConvNetManager::ModelNpy(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  const std::locale::facet *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  const std::locale::facet *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  _QWORD *v56;
  const std::locale::facet *v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  const std::locale::facet *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  const std::locale::facet *v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  _QWORD *v92;
  const std::locale::facet *v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  _QWORD *v104;
  const std::locale::facet *v105;
  int v106;
  uint64_t v107;
  uint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  _QWORD *v121;
  const std::locale::facet *v122;
  _QWORD *v124;
  uint64_t v125[2];
  char v126;
  uint64_t v127;
  uint64_t v128[2];
  char v129;
  uint64_t v130;
  uint64_t v131[2];
  char v132;
  uint64_t v133;
  uint64_t v134[2];
  char v135;
  uint64_t v136;
  uint64_t v137[2];
  char v138;
  uint64_t v139;
  uint64_t v140[2];
  char v141;
  uint64_t v142;
  uint64_t v143[2];
  char v144;
  uint64_t v145;
  std::locale v146;
  void *v147;
  void *v148;
  uint64_t v149;
  char v150;
  uint64_t v151;
  _QWORD v152[19];
  std::locale v153;
  void *v154;
  _QWORD v155[10];
  char v156;
  uint64_t v157;
  void *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;

  v167 = 0;
  v168 = 0;
  v169 = 0;
  v170 = CustomAllocator::mRsrc;
  v163 = 0;
  v164 = 0;
  v165 = 0;
  v166 = CustomAllocator::mRsrc;
  v159 = 0;
  v160 = 0;
  v161 = 0;
  v162 = CustomAllocator::mRsrc;
  v124 = (_QWORD *)(a2 + 16);
  v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a2 + 16), (uint64_t)"path: ", 6);
  v4 = a1 + 32;
  v5 = *(char *)(a1 + 55);
  if (v5 >= 0)
    v6 = a1 + 32;
  else
    v6 = *(_QWORD *)(a1 + 32);
  if (v5 >= 0)
    v7 = *(unsigned __int8 *)(a1 + 55);
  else
    v7 = *(_QWORD *)(a1 + 40);
  v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, v6, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24)));
  v9 = std::locale::use_facet(&v153, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v153);
  std::ostream::put();
  std::ostream::flush();
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v153);
  v168 = v167;
  v160 = v159;
  v164 = v163;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v146);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v146, (uint64_t *)&v153);
  v146.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v147 = &unk_24D29B3B0;
  v152[0] = &unk_24D29B3D8;
  v148 = &unk_24D29B578;
  if (v150 < 0)
    heap_Free(*(_QWORD **)(v151 + 8), v149);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v152);
  v10 = *(char *)(a1 + 55);
  if (v10 >= 0)
    v11 = a1 + 32;
  else
    v11 = *(_QWORD *)(a1 + 32);
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a1 + 55);
  else
    v12 = *(_QWORD *)(a1 + 40);
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v154, v11, v12);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"/w/npy", 6);
  v14 = *(_QWORD *)(a1 + 336);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v155, v143);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v14 + 24))(v14, v143, &v167, &v159, 1);
  if (v144 < 0)
    heap_Free(*(_QWORD **)(v145 + 8), v143[0]);
  if (v160 == v159)
  {
    v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v124, (uint64_t)"error: gathet layer", 19);
    std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(_QWORD *)(*v24 - 24)));
    v25 = std::locale::use_facet(&v146, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
    std::locale::~locale(&v146);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v15 = *(_DWORD *)(v167 + 16);
    *(_DWORD *)(a1 + 64) = v15;
    v16 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 336) + 32))(*(_QWORD *)(a1 + 336), 2 * (v15 << 9));
    *(_QWORD *)(a1 + 136) = v16;
    v17 = *(unsigned int *)(a1 + 64);
    if ((int)v17 >= 1)
    {
      v18 = 0;
      v19 = 0;
      v20 = v159;
      v21 = (v160 - v159) >> 1;
      do
      {
        v22 = 0;
        v23 = v19;
        do
        {
          if (v21 <= v23)
            goto LABEL_142;
          *(_WORD *)(v16 + 2 * v18 + v22) = *(_WORD *)(v20 + 2 * v23);
          v22 += 2;
          v23 += v17;
        }
        while (v22 != 1024);
        ++v19;
        v18 += 512;
      }
      while (v19 != v17);
    }
  }
  v26 = 0;
  do
  {
    v168 = v167;
    v160 = v159;
    v164 = v163;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v146);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v146, (uint64_t *)&v153);
    v146.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v152[0] = &unk_24D29B3D8;
    v147 = &unk_24D29B3B0;
    v148 = &unk_24D29B578;
    if (v150 < 0)
      heap_Free(*(_QWORD **)(v151 + 8), v149);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v152);
    v27 = *(char *)(a1 + 55);
    if (v27 >= 0)
      v28 = v4;
    else
      v28 = *(_QWORD *)(a1 + 32);
    if (v27 >= 0)
      v29 = *(unsigned __int8 *)(a1 + 55);
    else
      v29 = *(_QWORD *)(a1 + 40);
    v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v154, v28, v29);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)"/w", 2);
    v31 = v26 + 1;
    v32 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"/npy", 4);
    v33 = *(_QWORD *)(a1 + 336);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v155, v140);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v33 + 24))(v33, v140, &v167, &v159, 1);
    if (v141 < 0)
      heap_Free(*(_QWORD **)(v142 + 8), v140[0]);
    if (v160 == v159)
    {
      v56 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v124, (uint64_t)"error: conv_weight", 18);
      std::ios_base::getloc((const std::ios_base *)((char *)v56 + *(_QWORD *)(*v56 - 24)));
      v57 = std::locale::use_facet(&v146, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v57->__vftable[2].~facet_0)(v57, 10);
      std::locale::~locale(&v146);
      std::ostream::put();
      v4 = a1 + 32;
      std::ostream::flush();
    }
    else
    {
      v34 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 336) + 32))(*(_QWORD *)(a1 + 336), 2621440);
      v35 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 336) + 32))(*(_QWORD *)(a1 + 336), 2621440);
      v36 = 0;
      *(_QWORD *)(a1 + 16 * v26 + 144) = v35;
      v37 = v159;
      v38 = (v160 - v159) >> 1;
      v39 = v34;
      do
      {
        v40 = 0;
        v41 = v36;
        v42 = v39;
        do
        {
          v43 = 0;
          v44 = v41;
          do
          {
            if (v38 <= v44)
              std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
            *(_WORD *)(v42 + v43) = *(_WORD *)(v37 + 2 * v44);
            v43 += 2;
            v44 += 2560;
          }
          while (v43 != 1024);
          ++v40;
          v42 += 1024;
          v41 += 5;
        }
        while (v40 != 512);
        ++v36;
        v39 += 0x80000;
      }
      while (v36 != 5);
      v45 = 0;
      v46 = 0;
      v47 = v34;
      do
      {
        v48 = 0;
        v49 = v47;
        do
        {
          v50 = 0;
          v51 = v49;
          do
          {
            v52 = 0;
            v53 = v51;
            do
            {
              v54 = 0;
              v55 = v46;
              do
              {
                *(_WORD *)(v35 + 2 * v46 + 2 * v54) = *(_WORD *)(v53 + 2 * v54);
                ++v54;
              }
              while (v54 != 8);
              ++v52;
              v53 += 1024;
              v46 += 8;
            }
            while (v52 != 4);
            ++v50;
            v51 += 4096;
            v46 = v55 + 8;
          }
          while (v50 != 128);
          ++v48;
          v49 += 0x80000;
          v46 = v55 + 8;
        }
        while (v48 != 5);
        ++v45;
        v47 += 16;
        v46 = v55 + 8;
      }
      while (v45 != 64);
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 336) + 56))(*(_QWORD *)(a1 + 336), v34);
    }
    v168 = v167;
    v160 = v159;
    v164 = v163;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v146);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v146, (uint64_t *)&v153);
    v146.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v147 = &unk_24D29B3B0;
    v152[0] = &unk_24D29B3D8;
    v148 = &unk_24D29B578;
    if (v150 < 0)
      heap_Free(*(_QWORD **)(v151 + 8), v149);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v152);
    v58 = *(char *)(a1 + 55);
    if (v58 >= 0)
      v59 = v4;
    else
      v59 = *(_QWORD *)(a1 + 32);
    if (v58 >= 0)
      v60 = *(unsigned __int8 *)(a1 + 55);
    else
      v60 = *(_QWORD *)(a1 + 40);
    v61 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v154, v59, v60);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v61, (uint64_t)"/b", 2);
    v62 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v62, (uint64_t)"/npy", 4);
    v63 = *(_QWORD *)(a1 + 336);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v155, v137);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v63 + 24))(v63, v137, &v167, &v159, 1);
    if (v138 < 0)
      heap_Free(*(_QWORD **)(v139 + 8), v137[0]);
    if (v160 != v159)
    {
      v64 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 336) + 32))(*(_QWORD *)(a1 + 336), 1024);
      v65 = 0;
      *(_QWORD *)(a1 + 16 * v26 + 152) = v64;
      v66 = v159;
      v67 = (v160 - v159) >> 1;
      while (v67 != v65)
      {
        *(_WORD *)(v64 + 2 * v65) = *(_WORD *)(v66 + 2 * v65);
        if (++v65 == 512)
          goto LABEL_73;
      }
LABEL_142:
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    }
    v68 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v124, (uint64_t)"error: conv_bias", 16);
    std::ios_base::getloc((const std::ios_base *)((char *)v68 + *(_QWORD *)(*v68 - 24)));
    v69 = std::locale::use_facet(&v146, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 10);
    std::locale::~locale(&v146);
    std::ostream::put();
    v4 = a1 + 32;
    std::ostream::flush();
    v66 = v159;
LABEL_73:
    v168 = v167;
    v160 = v66;
    v164 = v163;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v146);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v146, (uint64_t *)&v153);
    v146.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v147 = &unk_24D29B3B0;
    v152[0] = &unk_24D29B3D8;
    v148 = &unk_24D29B578;
    if (v150 < 0)
      heap_Free(*(_QWORD **)(v151 + 8), v149);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v152);
    v70 = *(char *)(a1 + 55);
    if (v70 >= 0)
      v71 = v4;
    else
      v71 = *(_QWORD *)(a1 + 32);
    if (v70 >= 0)
      v72 = *(unsigned __int8 *)(a1 + 55);
    else
      v72 = *(_QWORD *)(a1 + 40);
    v73 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v154, v71, v72);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)"/gamma", 6);
    v74 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v74, (uint64_t)"/npy", 4);
    v75 = *(_QWORD *)(a1 + 336);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v155, v134);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v75 + 24))(v75, v134, &v167, &v159, 1);
    if (v135 < 0)
      heap_Free(*(_QWORD **)(v136 + 8), v134[0]);
    if (v160 != v159)
    {
      v76 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 336) + 32))(*(_QWORD *)(a1 + 336), 1024);
      v77 = 0;
      *(_QWORD *)(a1 + 32 * v26 + 192) = v76;
      v78 = v159;
      v79 = (v160 - v159) >> 1;
      while (v79 != v77)
      {
        *(_WORD *)(v76 + 2 * v77) = *(_WORD *)(v78 + 2 * v77);
        if (++v77 == 512)
          goto LABEL_89;
      }
      goto LABEL_142;
    }
    v80 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v124, (uint64_t)"error: batch norm gamma", 23);
    std::ios_base::getloc((const std::ios_base *)((char *)v80 + *(_QWORD *)(*v80 - 24)));
    v81 = std::locale::use_facet(&v146, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v81->__vftable[2].~facet_0)(v81, 10);
    std::locale::~locale(&v146);
    std::ostream::put();
    v4 = a1 + 32;
    std::ostream::flush();
    v78 = v159;
LABEL_89:
    v168 = v167;
    v160 = v78;
    v164 = v163;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v146);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v146, (uint64_t *)&v153);
    v146.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v147 = &unk_24D29B3B0;
    v152[0] = &unk_24D29B3D8;
    v148 = &unk_24D29B578;
    if (v150 < 0)
      heap_Free(*(_QWORD **)(v151 + 8), v149);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v152);
    v82 = *(char *)(a1 + 55);
    if (v82 >= 0)
      v83 = v4;
    else
      v83 = *(_QWORD *)(a1 + 32);
    if (v82 >= 0)
      v84 = *(unsigned __int8 *)(a1 + 55);
    else
      v84 = *(_QWORD *)(a1 + 40);
    v85 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v154, v83, v84);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v85, (uint64_t)"/beta", 5);
    v86 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v86, (uint64_t)"/npy", 4);
    v87 = *(_QWORD *)(a1 + 336);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v155, v131);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v87 + 24))(v87, v131, &v167, &v159, 1);
    if (v132 < 0)
      heap_Free(*(_QWORD **)(v133 + 8), v131[0]);
    if (v160 != v159)
    {
      v88 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 336) + 32))(*(_QWORD *)(a1 + 336), 1024);
      v89 = 0;
      *(_QWORD *)(a1 + 32 * v26 + 200) = v88;
      v90 = v159;
      v91 = (v160 - v159) >> 1;
      while (v91 != v89)
      {
        *(_WORD *)(v88 + 2 * v89) = *(_WORD *)(v90 + 2 * v89);
        if (++v89 == 512)
          goto LABEL_105;
      }
      goto LABEL_142;
    }
    v92 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v124, (uint64_t)"error: batch norm beta", 22);
    std::ios_base::getloc((const std::ios_base *)((char *)v92 + *(_QWORD *)(*v92 - 24)));
    v93 = std::locale::use_facet(&v146, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v93->__vftable[2].~facet_0)(v93, 10);
    std::locale::~locale(&v146);
    std::ostream::put();
    v4 = a1 + 32;
    std::ostream::flush();
    v90 = v159;
LABEL_105:
    v168 = v167;
    v160 = v90;
    v164 = v163;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v146);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v146, (uint64_t *)&v153);
    v146.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v147 = &unk_24D29B3B0;
    v152[0] = &unk_24D29B3D8;
    v148 = &unk_24D29B578;
    if (v150 < 0)
      heap_Free(*(_QWORD **)(v151 + 8), v149);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v152);
    v94 = *(char *)(a1 + 55);
    if (v94 >= 0)
      v95 = v4;
    else
      v95 = *(_QWORD *)(a1 + 32);
    if (v94 >= 0)
      v96 = *(unsigned __int8 *)(a1 + 55);
    else
      v96 = *(_QWORD *)(a1 + 40);
    v97 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v154, v95, v96);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v97, (uint64_t)"/mu", 3);
    v98 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v98, (uint64_t)"/npy", 4);
    v99 = *(_QWORD *)(a1 + 336);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v155, v128);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v99 + 24))(v99, v128, &v167, &v159, 1);
    if (v129 < 0)
      heap_Free(*(_QWORD **)(v130 + 8), v128[0]);
    if (v160 != v159)
    {
      v100 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 336) + 32))(*(_QWORD *)(a1 + 336), 1024);
      v101 = 0;
      *(_QWORD *)(a1 + 32 * v26 + 208) = v100;
      v102 = v159;
      v103 = (v160 - v159) >> 1;
      while (v103 != v101)
      {
        *(_WORD *)(v100 + 2 * v101) = *(_WORD *)(v102 + 2 * v101);
        if (++v101 == 512)
          goto LABEL_121;
      }
      goto LABEL_142;
    }
    v104 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v124, (uint64_t)"error: batch norm mu", 20);
    std::ios_base::getloc((const std::ios_base *)((char *)v104 + *(_QWORD *)(*v104 - 24)));
    v105 = std::locale::use_facet(&v146, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v105->__vftable[2].~facet_0)(v105, 10);
    std::locale::~locale(&v146);
    std::ostream::put();
    v4 = a1 + 32;
    std::ostream::flush();
    v102 = v159;
LABEL_121:
    v168 = v167;
    v160 = v102;
    v164 = v163;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v146);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v146, (uint64_t *)&v153);
    v146.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v147 = &unk_24D29B3B0;
    v152[0] = &unk_24D29B3D8;
    v148 = &unk_24D29B578;
    if (v150 < 0)
      heap_Free(*(_QWORD **)(v151 + 8), v149);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v152);
    v106 = *(char *)(a1 + 55);
    if (v106 >= 0)
      v107 = v4;
    else
      v107 = *(_QWORD *)(a1 + 32);
    if (v106 >= 0)
      v108 = *(unsigned __int8 *)(a1 + 55);
    else
      v108 = *(_QWORD *)(a1 + 40);
    v109 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v154, v107, v108);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v109, (uint64_t)"/sigma", 6);
    v110 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v110, (uint64_t)"/npy", 4);
    v111 = *(_QWORD *)(a1 + 336);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v155, v125);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v111 + 16))(v111, v125, &v167, &v163, 1);
    if (v126 < 0)
      heap_Free(*(_QWORD **)(v127 + 8), v125[0]);
    if (v164 == v163)
    {
      v121 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v124, (uint64_t)"error: batch norm sigma [sqrt]", 30);
      std::ios_base::getloc((const std::ios_base *)((char *)v121 + *(_QWORD *)(*v121 - 24)));
      v122 = std::locale::use_facet(&v146, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v122->__vftable[2].~facet_0)(v122, 10);
      std::locale::~locale(&v146);
      std::ostream::put();
      v4 = a1 + 32;
      std::ostream::flush();
    }
    else
    {
      v112 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 336) + 32))(*(_QWORD *)(a1 + 336), 1024);
      v113 = 0;
      *(_QWORD *)(a1 + 32 * v26 + 216) = v112;
      v114 = v163;
      v115 = (v164 - v163) >> 2;
      do
      {
        if (v115 == v113)
          std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
        _S0 = sqrtf(*(float *)(v114 + 4 * v113) + 0.001);
        __asm { FCVT            H0, S0 }
        *(_WORD *)(v112 + 2 * v113++) = LOWORD(_S0);
      }
      while (v113 != 512);
    }
    ++v26;
  }
  while (v31 != 3);
  v153.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v154 = &unk_24D29B3B0;
  v158 = &unk_24D29B3D8;
  v155[0] = &unk_24D29B578;
  if (v156 < 0)
    heap_Free(*(_QWORD **)(v157 + 8), v155[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v158);
  v153.__locale_ = (std::locale::__imp *)&v159;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v153);
  v153.__locale_ = (std::locale::__imp *)&v163;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v153);
  v153.__locale_ = (std::locale::__imp *)&v167;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v153);
  return 1;
}

void sub_214E96A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,std::locale a41)
{
  uint64_t v41;

  std::locale::~locale(&a41);
  STACK[0x220] = (unint64_t)&unk_24D29B388;
  STACK[0x230] = (unint64_t)&unk_24D29B3B0;
  STACK[0x2A8] = (unint64_t)&unk_24D29B3D8;
  STACK[0x238] = (unint64_t)&unk_24D29B578;
  if (SLOBYTE(STACK[0x28F]) < 0)
    heap_Free(*(_QWORD **)(STACK[0x290] + 8), STACK[0x278]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&STACK[0x2A8]);
  *(_QWORD *)(v41 - 112) = v41 - 208;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v41 - 112));
  *(_QWORD *)(v41 - 208) = v41 - 176;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v41 - 208));
  *(_QWORD *)(v41 - 176) = v41 - 144;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v41 - 176));
  _Unwind_Resume(a1);
}

uint64_t NeonConvNetManager::neon_gather_phoneme_add_offset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, unsigned int a7, int a8, unsigned int a9)
{
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t result;
  int v16;
  uint64_t v17;
  __int128 *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _OWORD *v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  _OWORD *v30;

  v9 = a5 >> 5;
  if (a6)
  {
    v10 = 0;
    v11 = a7 + a6;
    v12 = (a7 + a6) >> 2 << 7;
    v13 = v9 / a9 * a8;
    v14 = v13 + v9 / a9;
    result = 192 * ((a7 + a6) >> 2);
    do
    {
      if (v13 < v14)
      {
        v16 = *(_DWORD *)(a3 + 4 * v10) * a5;
        v17 = v9 / a9 * a8;
        do
        {
          v18 = (__int128 *)(a2 + 2 * (v16 + 32 * (int)v17));
          v19 = *v18;
          v20 = v18[1];
          v21 = v18[2];
          v22 = v18[3];
          v23 = (_OWORD *)(a4 + 2 * (int)(8 * v10 + v12 * v17));
          *v23 = v19;
          v23[4 * (v11 >> 2)] = v20;
          v23[8 * (v11 >> 2)] = v21;
          v23[12 * (v11 >> 2)] = v22;
          ++v17;
        }
        while (v14 > v17);
      }
      ++v10;
    }
    while (v10 != a6);
  }
  else
  {
    v11 = a7;
  }
  if (v11 > a6)
  {
    v24 = v9 / a9;
    v25 = v9 / a9 * a8;
    v26 = v24 * a8 + v24;
    do
    {
      if (v25 < v26)
      {
        v27 = a6 + 3;
        if (a6 >= 0)
          v27 = a6;
        v28 = ((8 * v27) & 0xFFFFFFE0) + 8 * (a6 - (v27 & 0x1FFFFFFC));
        v29 = (v24 * a8);
        do
        {
          v30 = (_OWORD *)(a4 + 2 * (int)(v28 + (v11 >> 2 << 7) * v29));
          *v30 = 0uLL;
          v30[4 * (v11 >> 2)] = 0uLL;
          v30[8 * (v11 >> 2)] = 0uLL;
          v30[12 * (v11 >> 2)] = 0uLL;
          ++v29;
        }
        while (v26 > v29);
      }
      ++a6;
    }
    while (a6 != v11);
  }
  return result;
}

void NeonConvNetManager::neon_encoder_conv_input_shift_by_coloums(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6, unsigned int a7)
{
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 *v24;
  __int128 v25;
  _OWORD *v26;
  _OWORD *v27;
  _OWORD *v28;
  _OWORD *v29;
  _OWORD *v30;
  _OWORD *v31;
  _OWORD *v32;
  _OWORD *v33;
  _OWORD *v34;
  _OWORD *v35;

  v7 = a4 >> 3;
  v8 = (a4 >> 3) / a7 * a6;
  v9 = v8 + (a4 >> 3) / a7;
  if (v8 < v9)
  {
    v10 = 4 * v7;
    v11 = (a5 / 4);
    v12 = v7 << 8;
    v13 = (int)(v7 << 6);
    v14 = (int)(v7 << 7);
    v15 = 24 * v7;
    do
    {
      if (a5 <= 3)
      {
        v17 = 32 * v8;
        v20 = 0uLL;
        v19 = 0uLL;
        v18 = 0uLL;
      }
      else
      {
        v16 = 0;
        v17 = 32 * v8;
        v18 = 0uLL;
        v19 = 0uLL;
        v20 = 0uLL;
        do
        {
          v21 = v20;
          v22 = v19;
          v23 = v18;
          v24 = (__int128 *)(a2 + 2 * (int)(32 * (v11 * v8 + v16)));
          v25 = *v24;
          v18 = v24[1];
          v19 = v24[2];
          v20 = v24[3];
          v26 = (_OWORD *)(a3
                         + 2 * (int)(v17 + v12 * (v16 >> 1))
                         + 2 * (((int)((_DWORD)v16 << 31) >> 31) & (v10 * 8)));
          *v26 = v23;
          v26[1] = v22;
          v26[2] = v21;
          v26[3] = v25;
          v27 = (_OWORD *)((char *)v26 + 2 * v13);
          *v27 = v22;
          v27[1] = v21;
          v27[2] = v25;
          v27[3] = v18;
          v28 = (_OWORD *)((char *)v26 + 2 * v14);
          *v28 = v21;
          v28[1] = v25;
          v28[2] = v18;
          v28[3] = v19;
          v29 = &v26[v15];
          *v29 = v25;
          v29[1] = v18;
          v29[2] = v19;
          v29[3] = v20;
          ++v16;
        }
        while (v11 != v16);
      }
      v30 = (_OWORD *)(a3 + 2 * (v17 + v12 * (a5 / 8)));
      *v30 = v18;
      v30[1] = v19;
      v30[2] = v20;
      v30[3] = 0uLL;
      v31 = &v30[v10];
      v31[2] = 0uLL;
      v31[3] = 0uLL;
      v32 = (_OWORD *)((char *)v30 + 2 * v13);
      *v31 = 0uLL;
      v31[1] = 0uLL;
      *v32 = v19;
      v32[1] = v20;
      v33 = &v32[v10];
      v32[2] = 0uLL;
      v32[3] = 0uLL;
      v34 = (_OWORD *)((char *)v30 + 2 * v14);
      v33[2] = 0uLL;
      v33[3] = 0uLL;
      *v33 = 0uLL;
      v33[1] = 0uLL;
      v35 = &v34[v10];
      *v34 = v20;
      v34[1] = 0uLL;
      v34[2] = 0uLL;
      v34[3] = 0uLL;
      ++v8;
      v35[2] = 0uLL;
      v35[3] = 0uLL;
      *v35 = 0uLL;
      v35[1] = 0uLL;
    }
    while (v9 > v8);
  }
}

void NeonConvNetManager::neon_encoder_conv_rows_relu(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, unsigned int a8, int a9, unsigned int a10)
{
  uint64_t v10;
  unsigned int v11;
  int v12;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  signed int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  unsigned int v23;
  float16x8_t v24;
  unint64_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  signed int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t *v63;

  if (a8 >= 8)
  {
    v10 = 0;
    v11 = a7 >> 3;
    v12 = 32 * (a7 >> 3);
    v13 = (a6 - 1) >> 1;
    v14 = 3 - ((a6 - 1) >> 1);
    if ((a6 - 1) > 7)
      v14 = 0;
    v15 = v11 << 6;
    v16 = (v11 << 6) * v14;
    v17 = v11 << 8;
    v18 = v11 / a10 * a9;
    v19 = v18 + v11 / a10;
    v20 = a4 + 2 * v16;
    if (v11 <= 1)
      v21 = 1;
    else
      v21 = a7 >> 3;
    v22 = (unint64_t)v21 << 6;
    do
    {
      if (v18 < v19)
      {
        v23 = v18;
        do
        {
          v24 = *(float16x8_t *)(a3 + 2 * (int)(8 * v23));
          if (a6)
          {
            v25 = 0;
            v26 = *(float16x8_t *)(a3 + 2 * (int)(8 * v23));
            v27 = v26;
            v28 = v26;
            v29 = v26;
            v30 = v26;
            v31 = v26;
            v32 = v26;
            do
            {
              if (v25 <= v13)
              {
                v33 = v15 * v25;
                v34 = v15 * v25 + v12;
              }
              else
              {
                v33 = v12 * (a6 - 6) + v25 % ((int)v13 + 1) * v15;
                v34 = v15 * v25;
              }
              if (a7 >= 8)
              {
                v35 = 0;
                v36 = 0;
                v37 = v20 + 2 * v33;
                v38 = v20 + 2 * v34;
                do
                {
                  v39 = a2
                      + 2 * (int)(((8 * a7) & 0xFFFFFFE0) * a6 * v23)
                      + 2 * v25 * (int)((8 * a7) & 0xFFFFFFE0)
                      + (v36 << 7);
                  v40 = *(float16x8_t *)(v39 + 16);
                  v42 = *(float16x8_t *)(v37 + v35);
                  v41 = *(float16x8_t *)(v37 + v35 + 16);
                  v44 = *(float16x8_t *)(v37 + v35 + 32);
                  v43 = *(float16x8_t *)(v37 + v35 + 48);
                  v45 = *(float16x8_t *)(v39 + 32);
                  v46 = *(float16x8_t *)(v39 + 48);
                  v48 = *(float16x8_t *)(v38 + v35);
                  v47 = *(float16x8_t *)(v38 + v35 + 16);
                  v49 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v24, *(float16x8_t *)v39, *(short float *)v42.i16), v40, *(float16x4_t *)v42.i8, 1), v45, *(float16x4_t *)v42.i8, 2), v46, *(float16x4_t *)v42.i8, 3);
                  v50 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v26, *(float16x8_t *)v39, *(short float *)v41.i16), v40, *(float16x4_t *)v41.i8, 1), v45, *(float16x4_t *)v41.i8, 2), v46, *(float16x4_t *)v41.i8, 3);
                  v51 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v27, *(float16x8_t *)v39, *(short float *)v44.i16), v40, *(float16x4_t *)v44.i8, 1), v45, *(float16x4_t *)v44.i8, 2), v46, *(float16x4_t *)v44.i8, 3);
                  v52 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v28, *(float16x8_t *)v39, *(short float *)v43.i16), v40, *(float16x4_t *)v43.i8, 1), v45, *(float16x4_t *)v43.i8, 2), v46, *(float16x4_t *)v43.i8, 3);
                  v54 = *(float16x8_t *)(v38 + v35 + 32);
                  v53 = *(float16x8_t *)(v38 + v35 + 48);
                  v55 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v29, *(float16x8_t *)v39, *(short float *)v48.i16), v40, *(float16x4_t *)v48.i8, 1), v45, *(float16x4_t *)v48.i8, 2), v46, *(float16x4_t *)v48.i8, 3);
                  v56 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v30, *(float16x8_t *)v39, *(short float *)v47.i16), v40, *(float16x4_t *)v47.i8, 1), v45, *(float16x4_t *)v47.i8, 2), v46, *(float16x4_t *)v47.i8, 3);
                  v57 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v31, *(float16x8_t *)v39, *(short float *)v54.i16), v40, *(float16x4_t *)v54.i8, 1), v45, *(float16x4_t *)v54.i8, 2), v46, *(float16x4_t *)v54.i8, 3);
                  v58 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v32, *(float16x8_t *)v39, *(short float *)v53.i16), v40, *(float16x4_t *)v53.i8, 1), v45, *(float16x4_t *)v53.i8, 2), v46, *(float16x4_t *)v53.i8, 3);
                  v59 = *(float16x8_t *)(v39 + 64);
                  v60 = *(float16x8_t *)(v39 + 80);
                  v62 = *(float16x8_t *)(v39 + 96);
                  v61 = *(float16x8_t *)(v39 + 112);
                  v24 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v49, v59, v42, 4), v60, v42, 5), v62, v42, 6), v61, v42, 7);
                  v26 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v50, v59, v41, 4), v60, v41, 5), v62, v41, 6), v61, v41, 7);
                  v27 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v51, v59, v44, 4), v60, v44, 5), v62, v44, 6), v61, v44, 7);
                  v28 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v52, v59, v43, 4), v60, v43, 5), v62, v43, 6), v61, v43, 7);
                  v29 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v55, v59, v48, 4), v60, v48, 5), v62, v48, 6), v61, v48, 7);
                  v30 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v56, v59, v47, 4), v60, v47, 5), v62, v47, 6), v61, v47, 7);
                  v31 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v57, v59, v54, 4), v60, v54, 5), v62, v54, 6), v61, v54, 7);
                  ++v36;
                  v35 += 64;
                  v32 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v58, v59, v53, 4), v60, v53, 5), v62, v53, 6), v61, v53, 7);
                }
                while (v22 != v35);
              }
              ++v25;
            }
            while (v25 != a6);
          }
          else
          {
            v32 = *(float16x8_t *)(a3 + 2 * (int)(8 * v23));
            v31 = v32;
            v30 = v32;
            v29 = v32;
            v28 = v32;
            v27 = v32;
            v26 = v32;
          }
          v63 = (float16x8_t *)(a5 + 2 * ((_DWORD)v10 << 6) + 2 * (int)(((8 * a8) & 0xFFFFFFE0) * v23));
          *v63 = vmaxq_f16(v24, (float16x8_t)0);
          v63[1] = vmaxq_f16(v26, (float16x8_t)0);
          v63[2] = vmaxq_f16(v27, (float16x8_t)0);
          v63[3] = vmaxq_f16(v28, (float16x8_t)0);
          v63[4] = vmaxq_f16(v29, (float16x8_t)0);
          v63[5] = vmaxq_f16(v30, (float16x8_t)0);
          v63[6] = vmaxq_f16(v31, (float16x8_t)0);
          v63[7] = vmaxq_f16(v32, (float16x8_t)0);
          ++v23;
        }
        while (v19 > v23);
      }
      ++v10;
      v20 += 2 * v17;
    }
    while (v10 != a8 >> 3);
  }
}

void NeonConvNetManager::neon_encoder_conv_rows(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, unsigned int a8, int a9, unsigned int a10)
{
  uint64_t v10;
  unsigned int v11;
  int v12;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  signed int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  unsigned int v23;
  float16x8_t v24;
  unint64_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  signed int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t *v63;

  if (a8 >= 8)
  {
    v10 = 0;
    v11 = a7 >> 3;
    v12 = 32 * (a7 >> 3);
    v13 = (a6 - 1) >> 1;
    v14 = 3 - ((a6 - 1) >> 1);
    if ((a6 - 1) > 7)
      v14 = 0;
    v15 = v11 << 6;
    v16 = (v11 << 6) * v14;
    v17 = v11 << 8;
    v18 = v11 / a10 * a9;
    v19 = v18 + v11 / a10;
    v20 = a4 + 2 * v16;
    if (v11 <= 1)
      v21 = 1;
    else
      v21 = a7 >> 3;
    v22 = (unint64_t)v21 << 6;
    do
    {
      if (v18 < v19)
      {
        v23 = v18;
        do
        {
          v24 = *(float16x8_t *)(a3 + 2 * (int)(8 * v23));
          if (a6)
          {
            v25 = 0;
            v26 = *(float16x8_t *)(a3 + 2 * (int)(8 * v23));
            v27 = v26;
            v28 = v26;
            v29 = v26;
            v30 = v26;
            v31 = v26;
            v32 = v26;
            do
            {
              if (v25 <= v13)
              {
                v33 = v15 * v25;
                v34 = v15 * v25 + v12;
              }
              else
              {
                v33 = v12 * (a6 - 6) + v25 % ((int)v13 + 1) * v15;
                v34 = v15 * v25;
              }
              if (a7 >= 8)
              {
                v35 = 0;
                v36 = 0;
                v37 = v20 + 2 * v33;
                v38 = v20 + 2 * v34;
                do
                {
                  v39 = a2
                      + 2 * (int)(((8 * a7) & 0xFFFFFFE0) * a6 * v23)
                      + 2 * v25 * (int)((8 * a7) & 0xFFFFFFE0)
                      + (v36 << 7);
                  v40 = *(float16x8_t *)(v39 + 16);
                  v42 = *(float16x8_t *)(v37 + v35);
                  v41 = *(float16x8_t *)(v37 + v35 + 16);
                  v44 = *(float16x8_t *)(v37 + v35 + 32);
                  v43 = *(float16x8_t *)(v37 + v35 + 48);
                  v45 = *(float16x8_t *)(v39 + 32);
                  v46 = *(float16x8_t *)(v39 + 48);
                  v48 = *(float16x8_t *)(v38 + v35);
                  v47 = *(float16x8_t *)(v38 + v35 + 16);
                  v49 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v24, *(float16x8_t *)v39, *(short float *)v42.i16), v40, *(float16x4_t *)v42.i8, 1), v45, *(float16x4_t *)v42.i8, 2), v46, *(float16x4_t *)v42.i8, 3);
                  v50 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v26, *(float16x8_t *)v39, *(short float *)v41.i16), v40, *(float16x4_t *)v41.i8, 1), v45, *(float16x4_t *)v41.i8, 2), v46, *(float16x4_t *)v41.i8, 3);
                  v51 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v27, *(float16x8_t *)v39, *(short float *)v44.i16), v40, *(float16x4_t *)v44.i8, 1), v45, *(float16x4_t *)v44.i8, 2), v46, *(float16x4_t *)v44.i8, 3);
                  v52 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v28, *(float16x8_t *)v39, *(short float *)v43.i16), v40, *(float16x4_t *)v43.i8, 1), v45, *(float16x4_t *)v43.i8, 2), v46, *(float16x4_t *)v43.i8, 3);
                  v54 = *(float16x8_t *)(v38 + v35 + 32);
                  v53 = *(float16x8_t *)(v38 + v35 + 48);
                  v55 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v29, *(float16x8_t *)v39, *(short float *)v48.i16), v40, *(float16x4_t *)v48.i8, 1), v45, *(float16x4_t *)v48.i8, 2), v46, *(float16x4_t *)v48.i8, 3);
                  v56 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v30, *(float16x8_t *)v39, *(short float *)v47.i16), v40, *(float16x4_t *)v47.i8, 1), v45, *(float16x4_t *)v47.i8, 2), v46, *(float16x4_t *)v47.i8, 3);
                  v57 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v31, *(float16x8_t *)v39, *(short float *)v54.i16), v40, *(float16x4_t *)v54.i8, 1), v45, *(float16x4_t *)v54.i8, 2), v46, *(float16x4_t *)v54.i8, 3);
                  v58 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v32, *(float16x8_t *)v39, *(short float *)v53.i16), v40, *(float16x4_t *)v53.i8, 1), v45, *(float16x4_t *)v53.i8, 2), v46, *(float16x4_t *)v53.i8, 3);
                  v59 = *(float16x8_t *)(v39 + 64);
                  v60 = *(float16x8_t *)(v39 + 80);
                  v62 = *(float16x8_t *)(v39 + 96);
                  v61 = *(float16x8_t *)(v39 + 112);
                  v24 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v49, v59, v42, 4), v60, v42, 5), v62, v42, 6), v61, v42, 7);
                  v26 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v50, v59, v41, 4), v60, v41, 5), v62, v41, 6), v61, v41, 7);
                  v27 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v51, v59, v44, 4), v60, v44, 5), v62, v44, 6), v61, v44, 7);
                  v28 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v52, v59, v43, 4), v60, v43, 5), v62, v43, 6), v61, v43, 7);
                  v29 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v55, v59, v48, 4), v60, v48, 5), v62, v48, 6), v61, v48, 7);
                  v30 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v56, v59, v47, 4), v60, v47, 5), v62, v47, 6), v61, v47, 7);
                  v31 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v57, v59, v54, 4), v60, v54, 5), v62, v54, 6), v61, v54, 7);
                  ++v36;
                  v35 += 64;
                  v32 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v58, v59, v53, 4), v60, v53, 5), v62, v53, 6), v61, v53, 7);
                }
                while (v22 != v35);
              }
              ++v25;
            }
            while (v25 != a6);
          }
          else
          {
            v32 = *(float16x8_t *)(a3 + 2 * (int)(8 * v23));
            v31 = v32;
            v30 = v32;
            v29 = v32;
            v28 = v32;
            v27 = v32;
            v26 = v32;
          }
          v63 = (float16x8_t *)(a5 + 2 * ((_DWORD)v10 << 6) + 2 * (int)(((8 * a8) & 0xFFFFFFE0) * v23));
          *v63 = v24;
          v63[1] = v26;
          v63[2] = v27;
          v63[3] = v28;
          v63[4] = v29;
          v63[5] = v30;
          v63[6] = v31;
          v63[7] = v32;
          ++v23;
        }
        while (v19 > v23);
      }
      ++v10;
      v20 += 2 * v17;
    }
    while (v10 != a8 >> 3);
  }
}

void NeonConvNetManager::neon_batch_norm(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, int a9, int a10, int a11, unsigned int a12)
{
  int v12;
  uint64_t v13;
  unsigned int v14;
  float16x8_t *v15;
  float16x8_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  uint64_t v24;
  uint64_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;

  v12 = (a8 >> 3) / a12;
  LODWORD(v13) = v12 * a11;
  v14 = v12 * a11 + v12;
  if (v12 * a11 < v14)
  {
    v15 = 0;
    v16 = 0;
    LODWORD(v17) = (a10 + a9) >> 3;
    if (v17 <= 1)
      v17 = 1;
    else
      v17 = v17;
    v13 = (int)v13;
    do
    {
      if ((a10 + a9) >= 8)
      {
        v18 = 0;
        v19 = 16 * (_DWORD)v13;
        v20 = *(float16x8_t *)(a2 + v19);
        v21 = *(float16x8_t *)(a3 + v19);
        v22 = *(float16x8_t *)(a4 + v19);
        v23 = *(float16x8_t *)(a5 + v19);
        v24 = a6 + 2 * v13 * (int)((8 * a9) & 0xFFFFFFE0);
        v25 = v17;
        do
        {
          v15 = (float16x8_t *)(v24 + (v18 << 7));
          v16 = (float16x8_t *)(v24 + 64 + (v18 << 7));
          v26 = vmlaq_f16(v23, vdivq_f16(vsubq_f16(v15[1], v21), v22), v20);
          v27 = vmlaq_f16(v23, vdivq_f16(vsubq_f16(v15[2], v21), v22), v20);
          v28 = vmlaq_f16(v23, vdivq_f16(vsubq_f16(v15[3], v21), v22), v20);
          v29 = vmlaq_f16(v23, vdivq_f16(vsubq_f16(*v16, v21), v22), v20);
          v30 = vmlaq_f16(v23, vdivq_f16(vsubq_f16(v16[1], v21), v22), v20);
          v31 = vmlaq_f16(v23, vdivq_f16(vsubq_f16(v16[2], v21), v22), v20);
          v32 = vdivq_f16(vsubq_f16(v16[3], v21), v22);
          *v15 = vmlaq_f16(v23, vdivq_f16(vsubq_f16(*v15, v21), v22), v20);
          v15[1] = v26;
          v15[2] = v27;
          v15[3] = v28;
          *v16 = v29;
          v16[1] = v30;
          v16[2] = v31;
          v16[3] = vmlaq_f16(v23, v32, v20);
          ++v18;
          --v25;
        }
        while (v25);
      }
      switch(a10)
      {
        case 1:
          v16[3] = 0uLL;
          break;
        case 2:
          v16[2] = 0uLL;
          v16[3] = 0uLL;
          break;
        case 3:
          v16[2] = 0uLL;
          v16[3] = 0uLL;
          v16[1] = 0uLL;
          break;
        case 4:
          goto LABEL_16;
        case 5:
          v15[3] = 0uLL;
          goto LABEL_16;
        case 6:
          v15[2] = 0uLL;
          v15[3] = 0uLL;
          goto LABEL_16;
        case 7:
          v15[2] = 0uLL;
          v15[3] = 0uLL;
          v15[1] = 0uLL;
LABEL_16:
          v16[2] = 0uLL;
          v16[3] = 0uLL;
          *v16 = 0uLL;
          v16[1] = 0uLL;
          break;
        default:
          break;
      }
      ++v13;
    }
    while (v14 > v13);
  }
}

void NeonConvNetManager::neon_batch_norm_out(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned int a9, int a10, int a11, unsigned int a12)
{
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  uint64_t v23;
  float16x8_t *v24;
  float16x8_t *v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;

  v12 = (a8 >> 3) / a12;
  LODWORD(v13) = v12 * a11;
  v14 = v12 * a11 + v12;
  if (v12 * a11 < v14)
  {
    LODWORD(v15) = a9 >> 2;
    if (a9 >> 2 <= 1)
      v15 = 1;
    else
      v15 = v15;
    v13 = (int)v13;
    do
    {
      if (a9 >= 4)
      {
        v16 = 0;
        v17 = 0;
        v18 = 16 * (_DWORD)v13;
        v19 = *(float16x8_t *)(a2 + v18);
        v20 = *(float16x8_t *)(a3 + v18);
        v21 = *(float16x8_t *)(a4 + v18);
        v22 = *(float16x8_t *)(a5 + v18);
        v23 = v15;
        do
        {
          v24 = (float16x8_t *)(a6 + 2 * v13 * (int)(32 * (a9 >> 2)) + (v17 << 6));
          v25 = (float16x8_t *)(a7 + v18 + 2 * v16);
          v26 = vmlaq_f16(v22, vdivq_f16(vsubq_f16(v24[1], v20), v21), v19);
          v27 = vmlaq_f16(v22, vdivq_f16(vsubq_f16(v24[2], v20), v21), v19);
          v28 = vdivq_f16(vsubq_f16(v24[3], v20), v21);
          *v25 = vmlaq_f16(v22, vdivq_f16(vsubq_f16(*v24, v20), v21), v19);
          *(float16x8_t *)((char *)v25 + 2 * a8) = v26;
          *(float16x8_t *)((char *)v25 + 4 * a8) = v27;
          *(float16x8_t *)((char *)v25 + 6 * a8) = vmlaq_f16(v22, v28, v19);
          ++v17;
          v16 += 4 * a8;
          --v23;
        }
        while (v23);
      }
      ++v13;
    }
    while (v14 > v13);
  }
}

uint64_t NeonConvNetManager::SetUp(_QWORD *a1)
{
  NeonTC2Container *v2;
  int v3;
  uint64_t result;

  v2 = (NeonTC2Container *)a1[3];
  if (!*((_BYTE *)v2 + 2304)
    || (v3 = NeonTC2Container::EngineMCSetUp(v2, a1, 0, (void (*)(void *, int))mc_ConvNet_do_inference),
        result = 0,
        v3))
  {
    a1[36] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[42] + 32))(a1[42], 0x200000);
    a1[37] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[42] + 32))(a1[42], 0x800000);
    *(_QWORD *)(a1[3] + 3360) = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[42] + 32))(a1[42], 0x200000);
    *(_QWORD *)(a1[3] + 3312) = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[42] + 32))(a1[42], 0x400000);
    return 1;
  }
  return result;
}

uint64_t *mc_ConvNet_do_inference(uint64_t a1, int a2)
{
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t *result;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __int16 *v17;
  _DWORD *v18;
  __int16 v19;
  uint64_t v26;
  uint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t *v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  unint64_t v45;
  uint64_t *v46;
  _QWORD *v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  unint64_t v60;
  _QWORD *v61;
  _QWORD *v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  _QWORD *v74;
  _QWORD *v75;
  _QWORD *v76;
  uint64_t v77;
  _QWORD *v78;

  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(_DWORD *)(v4 + 3396);
  if (v5 <= 0)
    v6 = -(-v5 & 7);
  else
    v6 = *(_DWORD *)(v4 + 3396) & 7;
  if (v6)
    v7 = 8 - v6;
  else
    v7 = 0;
  NeonConvNetManager::neon_gather_phoneme_add_offset(a1, *(_QWORD *)(a1 + 136), **(_QWORD **)(a1 + 304), *(_QWORD *)(a1 + 288), 0x200u, v5, v7, a2, *(_DWORD *)(v4 + 2308));
  (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 24) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 24)
                                                                                                  + 2656));
  v8 = *(_QWORD *)(a1 + 24);
  if (!a2)
    *(_DWORD *)(v8 + 3396) += v7;
  result = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v8 + 2656) + 8))(*(_QWORD *)(v8 + 2656));
  for (i = 0; i != 3; ++i)
  {
    NeonConvNetManager::neon_encoder_conv_input_shift_by_coloums((uint64_t)result, *(_QWORD *)(a1 + 288), *(_QWORD *)(a1 + 296), 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396), a2, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 24) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2656));
    if (i == 2)
      NeonConvNetManager::neon_encoder_conv_rows(v11, *(_QWORD *)(a1 + 176), *(_QWORD *)(a1 + 184), *(_QWORD *)(a1 + 296), *(_QWORD *)(a1 + 288), 5, 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396), a2, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    else
      NeonConvNetManager::neon_encoder_conv_rows_relu(v11, *(_QWORD *)(a1 + 16 * i + 144), *(_QWORD *)(a1 + 16 * i + 152), *(_QWORD *)(a1 + 296), *(_QWORD *)(a1 + 288), 5, 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396), a2, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    v12 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 24) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2656));
    if (i == 2)
    {
      NeonConvNetManager::neon_batch_norm_out(v12, *(_QWORD *)(a1 + 256), *(_QWORD *)(a1 + 272), *(_QWORD *)(a1 + 280), *(_QWORD *)(a1 + 264), *(_QWORD *)(a1 + 288), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 3360), 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396), v73, a2, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
      (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 24) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2656));
      v14 = *(_QWORD *)(a1 + 24);
      if (!a2)
      {
        v15 = *(_DWORD *)(v14 + 3396) - v7;
        *(_DWORD *)(v14 + 3396) = v15;
        if (!*(_BYTE *)(v14 + 2721) && v15 >= 1)
        {
          LODWORD(v16) = v15 << 9;
          v17 = *(__int16 **)(v14 + 3360);
          v18 = *(_DWORD **)(v14 + 3312);
          if ((int)v16 <= 1)
            v16 = 1;
          else
            v16 = v16;
          do
          {
            v19 = *v17++;
            _H0 = v19;
            __asm { FCVT            S0, H0 }
            *v18++ = _S0;
            --v16;
          }
          while (v16);
        }
      }
    }
    else
    {
      NeonConvNetManager::neon_batch_norm(v12, *(_QWORD *)(a1 + 32 * i + 192), *(_QWORD *)(a1 + 32 * i + 208), *(_QWORD *)(a1 + 32 * i + 216), *(_QWORD *)(a1 + 32 * i + 200), *(_QWORD *)(a1 + 288), v13, 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396), v7, a2, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
      v14 = *(_QWORD *)(a1 + 24);
    }
    result = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v14 + 2656) + 8))(*(_QWORD *)(v14 + 2656));
  }
  if (!a2)
  {
    v26 = *(_QWORD *)(a1 + 24);
    if (!*(_BYTE *)(v26 + 2721))
    {
      v27 = *(uint64_t **)(a1 + 328);
      v28 = (_QWORD *)v27[1];
      v29 = v27[2];
      if ((unint64_t)v28 >= v29)
      {
        v32 = (_QWORD *)*v27;
        v33 = ((uint64_t)v28 - *v27) >> 3;
        v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 61)
          goto LABEL_79;
        v35 = v29 - (_QWORD)v32;
        if (v35 >> 2 > v34)
          v34 = v35 >> 2;
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
          v36 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v36 = v34;
        v78 = v27 + 3;
        if (v36)
        {
          v37 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v27 + 3), v36);
          v32 = (_QWORD *)*v27;
          v28 = (_QWORD *)v27[1];
        }
        else
        {
          v37 = 0;
        }
        v38 = (_QWORD *)(v37 + 8 * v33);
        *v38 = 1;
        if (v28 == v32)
        {
          v40 = v37 + 8 * v33;
        }
        else
        {
          v39 = v28;
          v40 = v37 + 8 * v33;
          do
          {
            v41 = *--v39;
            *(_QWORD *)(v40 - 8) = v41;
            v40 -= 8;
          }
          while (v39 != v32);
        }
        v31 = v38 + 1;
        *v27 = v40;
        v74 = v32;
        v75 = v32;
        v27[1] = (uint64_t)(v38 + 1);
        v76 = v28;
        v42 = v27[2];
        v27[2] = v37 + 8 * v36;
        v77 = v42;
        std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v74);
        v30 = *(uint64_t **)(a1 + 328);
        v26 = *(_QWORD *)(a1 + 24);
      }
      else
      {
        *v28 = 1;
        v30 = v27;
        v31 = v28 + 1;
      }
      v27[1] = (uint64_t)v31;
      v43 = *(int *)(v26 + 3396);
      v44 = (_QWORD *)v30[1];
      v45 = v30[2];
      if ((unint64_t)v44 >= v45)
      {
        v48 = (_QWORD *)*v30;
        v49 = ((uint64_t)v44 - *v30) >> 3;
        v50 = v49 + 1;
        if ((unint64_t)(v49 + 1) >> 61)
          std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
        v51 = v45 - (_QWORD)v48;
        if (v51 >> 2 > v50)
          v50 = v51 >> 2;
        if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8)
          v52 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v52 = v50;
        v78 = v30 + 3;
        if (v52)
        {
          v53 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v30 + 3), v52);
          v48 = (_QWORD *)*v30;
          v44 = (_QWORD *)v30[1];
        }
        else
        {
          v53 = 0;
        }
        v54 = (_QWORD *)(v53 + 8 * v49);
        *v54 = v43;
        if (v44 == v48)
        {
          v56 = v53 + 8 * v49;
        }
        else
        {
          v55 = v44;
          v56 = v53 + 8 * v49;
          do
          {
            v57 = *--v55;
            *(_QWORD *)(v56 - 8) = v57;
            v56 -= 8;
          }
          while (v55 != v48);
        }
        v47 = v54 + 1;
        *v30 = v56;
        v74 = v48;
        v75 = v48;
        v30[1] = (uint64_t)(v54 + 1);
        v76 = v44;
        v58 = v30[2];
        v30[2] = v53 + 8 * v52;
        v77 = v58;
        std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v74);
        v46 = *(uint64_t **)(a1 + 328);
      }
      else
      {
        *v44 = v43;
        v46 = v30;
        v47 = v44 + 1;
      }
      v30[1] = (uint64_t)v47;
      v59 = (_QWORD *)v46[1];
      v60 = v46[2];
      if ((unint64_t)v59 < v60)
      {
        *v59 = 512;
        v61 = v59 + 1;
LABEL_77:
        v46[1] = (uint64_t)v61;
        return std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(*(uint64_t **)(a1 + 320), *(char **)(*(_QWORD *)(a1 + 24) + 3312), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 3312) + ((uint64_t)*(int *)(*(_QWORD *)(a1 + 24) + 3396) << 11), (uint64_t)*(int *)(*(_QWORD *)(a1 + 24) + 3396) << 9);
      }
      v62 = (_QWORD *)*v46;
      v63 = ((uint64_t)v59 - *v46) >> 3;
      v64 = v63 + 1;
      if (!((unint64_t)(v63 + 1) >> 61))
      {
        v65 = v60 - (_QWORD)v62;
        if (v65 >> 2 > v64)
          v64 = v65 >> 2;
        if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8)
          v66 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v66 = v64;
        v78 = v46 + 3;
        if (v66)
        {
          v67 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v46 + 3), v66);
          v62 = (_QWORD *)*v46;
          v59 = (_QWORD *)v46[1];
        }
        else
        {
          v67 = 0;
        }
        v68 = (_QWORD *)(v67 + 8 * v63);
        *v68 = 512;
        if (v59 == v62)
        {
          v70 = v67 + 8 * v63;
        }
        else
        {
          v69 = v59;
          v70 = v67 + 8 * v63;
          do
          {
            v71 = *--v69;
            *(_QWORD *)(v70 - 8) = v71;
            v70 -= 8;
          }
          while (v69 != v62);
        }
        v61 = v68 + 1;
        *v46 = v70;
        v74 = v62;
        v75 = v62;
        v46[1] = (uint64_t)(v68 + 1);
        v76 = v59;
        v72 = v46[2];
        v46[2] = v67 + 8 * v66;
        v77 = v72;
        std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v74);
        goto LABEL_77;
      }
LABEL_79:
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    }
  }
  return result;
}

void NeonConvNetManager::do_inference(_QWORD *a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v8;
  int v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __int16 *v19;
  _DWORD *v20;
  __int16 v21;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD *v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _QWORD *v75;

  v8 = a1[3];
  if (*(_BYTE *)(v8 + 2304))
  {
    a1[38] = a2;
    a1[39] = a3;
    a1[40] = a4;
    a1[41] = a5;
    if (a3[1] - *a3 > 8uLL)
    {
      *(_DWORD *)(v8 + 3396) = *(_QWORD *)(*a3 + 8);
      SynchroManager::cond_broadcast_on_entry((SynchroManager *)(v8 + 2312), *(_DWORD *)(v8 + 2308), 1);
      SynchroManager::cond_wait_less_on_exit((SynchroManager *)(a1[3] + 2312), *(_DWORD *)(a1[3] + 2308));
      return;
    }
LABEL_76:
    std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
  }
  if (a3[1] - *a3 <= 8uLL)
    goto LABEL_76;
  v9 = *(_DWORD *)(*a3 + 8);
  *(_DWORD *)(v8 + 3396) = v9;
  if (v9 <= 0)
    v10 = -(-v9 & 7);
  else
    v10 = v9 & 7;
  if (v10)
    v11 = 8 - v10;
  else
    v11 = 0;
  v12 = NeonConvNetManager::neon_gather_phoneme_add_offset((uint64_t)a1, a1[17], *a2, a1[36], 0x200u, v9, v11, 0, *(_DWORD *)(v8 + 2308));
  v13 = 0;
  *(_DWORD *)(a1[3] + 3396) += v11;
  while (1)
  {
    NeonConvNetManager::neon_encoder_conv_input_shift_by_coloums(v12, a1[36], a1[37], 0x200u, *(_DWORD *)(a1[3] + 3396), 0, *(_DWORD *)(a1[3] + 2308));
    if (v13 == 2)
      break;
    NeonConvNetManager::neon_encoder_conv_rows_relu(v14, a1[2 * v13 + 18], a1[2 * v13 + 19], a1[37], a1[36], 5, 0x200u, *(_DWORD *)(a1[3] + 3396), 0, *(_DWORD *)(a1[3] + 2308));
    NeonConvNetManager::neon_batch_norm(v28, a1[4 * v13 + 24], a1[4 * v13 + 26], a1[4 * v13 + 27], a1[4 * v13 + 25], a1[36], v29, 0x200u, *(_DWORD *)(a1[3] + 3396), v11, 0, *(_DWORD *)(a1[3] + 2308));
LABEL_21:
    if (++v13 == 3)
      goto LABEL_22;
  }
  NeonConvNetManager::neon_encoder_conv_rows(v14, a1[22], a1[23], a1[37], a1[36], 5, 0x200u, *(_DWORD *)(a1[3] + 3396), 0, *(_DWORD *)(a1[3] + 2308));
  NeonConvNetManager::neon_batch_norm_out(v15, a1[32], a1[34], a1[35], a1[33], a1[36], *(_QWORD *)(a1[3] + 3360), 0x200u, *(_DWORD *)(a1[3] + 3396), v70, 0, *(_DWORD *)(a1[3] + 2308));
  v16 = a1[3];
  v17 = *(_DWORD *)(v16 + 3396) - v11;
  *(_DWORD *)(v16 + 3396) = v17;
  if (!*(_BYTE *)(v16 + 2721) && v17 >= 1)
  {
    LODWORD(v18) = v17 << 9;
    v19 = *(__int16 **)(v16 + 3360);
    v20 = *(_DWORD **)(v16 + 3312);
    if ((int)v18 <= 1)
      v18 = 1;
    else
      v18 = v18;
    do
    {
      v21 = *v19++;
      _H0 = v21;
      __asm { FCVT            S0, H0 }
      *v20++ = _S0;
      --v18;
    }
    while (v18);
    goto LABEL_21;
  }
LABEL_22:
  v30 = a1[3];
  if (!*(_BYTE *)(v30 + 2721))
  {
    v31 = (_QWORD *)a5[1];
    v32 = a5[2];
    if ((unint64_t)v31 < v32)
    {
      *v31 = 1;
      v33 = v31 + 1;
      goto LABEL_40;
    }
    v34 = (_QWORD *)*a5;
    v35 = ((uint64_t)v31 - *a5) >> 3;
    v36 = v35 + 1;
    if ((unint64_t)(v35 + 1) >> 61)
      goto LABEL_77;
    v37 = v32 - (_QWORD)v34;
    if (v37 >> 2 > v36)
      v36 = v37 >> 2;
    if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
      v38 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v38 = v36;
    v75 = a5 + 3;
    if (v38)
    {
      v39 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v38);
      v34 = (_QWORD *)*a5;
      v31 = (_QWORD *)a5[1];
    }
    else
    {
      v39 = 0;
    }
    v40 = (_QWORD *)(v39 + 8 * v35);
    *v40 = 1;
    if (v31 == v34)
    {
      v42 = v39 + 8 * v35;
    }
    else
    {
      v41 = v31;
      v42 = v39 + 8 * v35;
      do
      {
        v43 = *--v41;
        *(_QWORD *)(v42 - 8) = v43;
        v42 -= 8;
      }
      while (v41 != v34);
    }
    v33 = v40 + 1;
    *a5 = v42;
    a5[1] = (uint64_t)(v40 + 1);
    v44 = a5[2];
    a5[2] = v39 + 8 * v38;
    v73 = v31;
    v74 = v44;
    v71 = v34;
    v72 = v34;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v71);
    v30 = a1[3];
    v32 = a5[2];
LABEL_40:
    a5[1] = (uint64_t)v33;
    v45 = *(int *)(v30 + 3396);
    if ((unint64_t)v33 < v32)
    {
      *v33 = v45;
      v46 = v33 + 1;
      goto LABEL_57;
    }
    v47 = (_QWORD *)*a5;
    v48 = ((uint64_t)v33 - *a5) >> 3;
    v49 = v48 + 1;
    if ((unint64_t)(v48 + 1) >> 61)
      goto LABEL_77;
    v50 = v32 - (_QWORD)v47;
    if (v50 >> 2 > v49)
      v49 = v50 >> 2;
    if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8)
      v51 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v51 = v49;
    v75 = a5 + 3;
    if (v51)
    {
      v52 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v51);
      v47 = (_QWORD *)*a5;
      v33 = (_QWORD *)a5[1];
    }
    else
    {
      v52 = 0;
    }
    v53 = (_QWORD *)(v52 + 8 * v48);
    *v53 = v45;
    if (v33 == v47)
    {
      v55 = v52 + 8 * v48;
    }
    else
    {
      v54 = v33;
      v55 = v52 + 8 * v48;
      do
      {
        v56 = *--v54;
        *(_QWORD *)(v55 - 8) = v56;
        v55 -= 8;
      }
      while (v54 != v47);
    }
    v46 = v53 + 1;
    *a5 = v55;
    a5[1] = (uint64_t)(v53 + 1);
    v57 = a5[2];
    a5[2] = v52 + 8 * v51;
    v73 = v33;
    v74 = v57;
    v71 = v47;
    v72 = v47;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v71);
    v32 = a5[2];
LABEL_57:
    a5[1] = (uint64_t)v46;
    if ((unint64_t)v46 < v32)
    {
      *v46 = 512;
      v58 = v46 + 1;
      goto LABEL_74;
    }
    v59 = (_QWORD *)*a5;
    v60 = ((uint64_t)v46 - *a5) >> 3;
    v61 = v60 + 1;
    if ((unint64_t)(v60 + 1) >> 61)
LABEL_77:
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v62 = v32 - (_QWORD)v59;
    if (v62 >> 2 > v61)
      v61 = v62 >> 2;
    if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8)
      v63 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v63 = v61;
    v75 = a5 + 3;
    if (v63)
    {
      v64 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v63);
      v59 = (_QWORD *)*a5;
      v46 = (_QWORD *)a5[1];
    }
    else
    {
      v64 = 0;
    }
    v65 = (_QWORD *)(v64 + 8 * v60);
    *v65 = 512;
    if (v46 == v59)
    {
      v67 = v64 + 8 * v60;
    }
    else
    {
      v66 = v46;
      v67 = v64 + 8 * v60;
      do
      {
        v68 = *--v66;
        *(_QWORD *)(v67 - 8) = v68;
        v67 -= 8;
      }
      while (v66 != v59);
    }
    v58 = v65 + 1;
    *a5 = v67;
    a5[1] = (uint64_t)(v65 + 1);
    v69 = a5[2];
    a5[2] = v64 + 8 * v63;
    v73 = v46;
    v74 = v69;
    v71 = v59;
    v72 = v59;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v71);
LABEL_74:
    a5[1] = (uint64_t)v58;
    std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a4, *(char **)(a1[3] + 3312), *(_QWORD *)(a1[3] + 3312) + ((uint64_t)*(int *)(a1[3] + 3396) << 11), (uint64_t)*(int *)(a1[3] + 3396) << 9);
  }
}

void std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("vector");
}

_QWORD *NeonLSTMManager::NeonLSTMManager(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = CustomAllocator::mRsrc;
  a1[35] = 0;
  a1[36] = 0;
  a1[3] = a2;
  a1[4] = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 35, a3);
  *(_BYTE *)(a1[3] + 2721) = 0;
  return a1;
}

{
  a1[1] = 0;
  a1[2] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = CustomAllocator::mRsrc;
  a1[35] = 0;
  a1[36] = 0;
  a1[3] = a2;
  a1[4] = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 35, a3);
  *(_BYTE *)(a1[3] + 2721) = 0;
  return a1;
}

void NeonLSTMManager::~NeonLSTMManager(NeonLSTMManager *this)
{
  uint64_t v2;

  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 15));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 16));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 17));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 18));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 23));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 24));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 25));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 26));
  v2 = *((_QWORD *)this + 3);
  if (*(_BYTE *)(v2 + 2304))
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 27));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 28));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 29));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 30));
    v2 = *((_QWORD *)this + 3);
  }
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *(_QWORD *)(v2 + 3320));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 19));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 20));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 21));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 35) + 56))(*((_QWORD *)this + 35), *((_QWORD *)this + 22));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 280);
  if (*((char *)this + 55) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 7) + 8), *((_QWORD *)this + 4));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

uint64_t NeonLSTMManager::ModelNpy(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  const std::locale::facet *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  _QWORD *v33;
  const std::locale::facet *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  const std::locale::facet *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  _QWORD *v70;
  const std::locale::facet *v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  _QWORD *v75;
  _QWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  const std::locale::facet *v83;
  uint64_t v85[2];
  char v86;
  uint64_t v87;
  uint64_t v88[2];
  char v89;
  uint64_t v90;
  uint64_t v91[2];
  char v92;
  uint64_t v93;
  uint64_t v94[2];
  char v95;
  uint64_t v96;
  std::locale v97;
  void *v98;
  void *v99;
  uint64_t v100;
  char v101;
  uint64_t v102;
  _QWORD v103[19];
  std::locale v104;
  void *v105;
  _QWORD v106[10];
  char v107;
  uint64_t v108;
  void *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;

  v118 = 0;
  v119 = 0;
  v120 = 0;
  v121 = CustomAllocator::mRsrc;
  v114 = 0;
  v115 = 0;
  v116 = 0;
  v117 = CustomAllocator::mRsrc;
  v110 = 0;
  v111 = 0;
  v112 = 0;
  v113 = CustomAllocator::mRsrc;
  v3 = (_QWORD *)(a2 + 16);
  v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a2 + 16), (uint64_t)"path: ", 6);
  v5 = *(char *)(a1 + 55);
  if (v5 >= 0)
    v6 = a1 + 32;
  else
    v6 = *(_QWORD *)(a1 + 32);
  if (v5 >= 0)
    v7 = *(unsigned __int8 *)(a1 + 55);
  else
    v7 = *(_QWORD *)(a1 + 40);
  v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, v6, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24)));
  v9 = std::locale::use_facet(&v104, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v104);
  std::ostream::put();
  std::ostream::flush();
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v104);
  v119 = v118;
  v111 = v110;
  v115 = v114;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v97);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v97, (uint64_t *)&v104);
  v97.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v98 = &unk_24D29B3B0;
  v103[0] = &unk_24D29B3D8;
  v99 = &unk_24D29B578;
  if (v101 < 0)
    heap_Free(*(_QWORD **)(v102 + 8), v100);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v103);
  v10 = *(char *)(a1 + 55);
  if (v10 >= 0)
    v11 = a1 + 32;
  else
    v11 = *(_QWORD *)(a1 + 32);
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a1 + 55);
  else
    v12 = *(_QWORD *)(a1 + 40);
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, v11, v12);
  v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"/fw/lstm/cell/kernel", 20);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"/npy", 4);
  v15 = *(_QWORD *)(a1 + 280);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v106, v94);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v15 + 24))(v15, v94, &v118, &v110, 1);
  if (v95 < 0)
    heap_Free(*(_QWORD **)(v96 + 8), v94[0]);
  if (v111 == v110)
  {
    v33 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"error: forwards matmul layer weight", 35);
    std::ios_base::getloc((const std::ios_base *)((char *)v33 + *(_QWORD *)(*v33 - 24)));
    v34 = std::locale::use_facet(&v97, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v34->__vftable[2].~facet_0)(v34, 10);
    std::locale::~locale(&v97);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v16 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 280) + 32))(*(_QWORD *)(a1 + 280), 1572864);
    v17 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 280) + 32))(*(_QWORD *)(a1 + 280), 1572864);
    v18 = 0;
    v19 = 0;
    *(_QWORD *)(a1 + 120) = v17;
    v20 = v110;
    v21 = (v111 - v110) >> 1;
    do
    {
      v22 = 1024;
      v23 = v18;
      do
      {
        if (v21 <= v23)
          std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
        *(_WORD *)(v16 + 2 * v23) = *(_WORD *)(v20 + 2 * v23);
        ++v23;
        --v22;
      }
      while (v22);
      ++v19;
      v18 += 1024;
    }
    while (v19 != 768);
    v24 = 0;
    v25 = 0;
    v26 = v16;
    do
    {
      v27 = 0;
      v28 = v26;
      do
      {
        v29 = 0;
        v30 = v28;
        do
        {
          v31 = 0;
          v32 = v25;
          do
          {
            *(_WORD *)(v17 + 2 * v25 + 2 * v31) = *(_WORD *)(v30 + 2 * v31);
            ++v31;
          }
          while (v31 != 8);
          ++v29;
          v30 += 2048;
          v25 += 8;
        }
        while (v29 != 4);
        ++v27;
        v28 += 0x2000;
        v25 = v32 + 8;
      }
      while (v27 != 192);
      ++v24;
      v26 += 16;
      v25 = v32 + 8;
    }
    while (v24 != 128);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 280) + 56))(*(_QWORD *)(a1 + 280), v16);
  }
  v119 = v118;
  v111 = v110;
  v115 = v114;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v97);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v97, (uint64_t *)&v104);
  v97.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v103[0] = &unk_24D29B3D8;
  v98 = &unk_24D29B3B0;
  v99 = &unk_24D29B578;
  if (v101 < 0)
    heap_Free(*(_QWORD **)(v102 + 8), v100);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v103);
  v35 = *(char *)(a1 + 55);
  if (v35 >= 0)
    v36 = a1 + 32;
  else
    v36 = *(_QWORD *)(a1 + 32);
  if (v35 >= 0)
    v37 = *(unsigned __int8 *)(a1 + 55);
  else
    v37 = *(_QWORD *)(a1 + 40);
  v38 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, v36, v37);
  v39 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)"/fw/lstm/cell/bias", 18);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)"/npy", 4);
  v40 = *(_QWORD *)(a1 + 280);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v106, v91);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v40 + 24))(v40, v91, &v118, &v110, 1);
  if (v92 < 0)
    heap_Free(*(_QWORD **)(v93 + 8), v91[0]);
  if (v111 != v110)
  {
    v41 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 280) + 32))(*(_QWORD *)(a1 + 280), 2048);
    v42 = 0;
    *(_QWORD *)(a1 + 128) = v41;
    v43 = v110;
    v44 = (v111 - v110) >> 1;
    while (v44 != v42)
    {
      *(_WORD *)(v41 + 2 * v42) = *(_WORD *)(v43 + 2 * v42);
      if (++v42 == 1024)
        goto LABEL_49;
    }
LABEL_96:
    std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
  }
  v45 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"error: forwards matmul layer bias", 33);
  std::ios_base::getloc((const std::ios_base *)((char *)v45 + *(_QWORD *)(*v45 - 24)));
  v46 = std::locale::use_facet(&v97, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v46->__vftable[2].~facet_0)(v46, 10);
  std::locale::~locale(&v97);
  std::ostream::put();
  std::ostream::flush();
  v43 = v110;
LABEL_49:
  v119 = v118;
  v111 = v43;
  v115 = v114;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v97);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v97, (uint64_t *)&v104);
  v97.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v103[0] = &unk_24D29B3D8;
  v98 = &unk_24D29B3B0;
  v99 = &unk_24D29B578;
  if (v101 < 0)
    heap_Free(*(_QWORD **)(v102 + 8), v100);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v103);
  v47 = *(char *)(a1 + 55);
  if (v47 >= 0)
    v48 = a1 + 32;
  else
    v48 = *(_QWORD *)(a1 + 32);
  if (v47 >= 0)
    v49 = *(unsigned __int8 *)(a1 + 55);
  else
    v49 = *(_QWORD *)(a1 + 40);
  v50 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, v48, v49);
  v51 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v50, (uint64_t)"/bw/lstm/cell/kernel", 20);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v51, (uint64_t)"/npy", 4);
  v52 = *(_QWORD *)(a1 + 280);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v106, v88);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v52 + 24))(v52, v88, &v118, &v110, 1);
  if (v89 < 0)
    heap_Free(*(_QWORD **)(v90 + 8), v88[0]);
  if (v111 == v110)
  {
    v70 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"error: backwards matmul layer weight", 36);
    std::ios_base::getloc((const std::ios_base *)((char *)v70 + *(_QWORD *)(*v70 - 24)));
    v71 = std::locale::use_facet(&v97, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v71->__vftable[2].~facet_0)(v71, 10);
    std::locale::~locale(&v97);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v53 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 280) + 32))(*(_QWORD *)(a1 + 280), 1572864);
    v54 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 280) + 32))(*(_QWORD *)(a1 + 280), 1572864);
    v55 = 0;
    v56 = 0;
    *(_QWORD *)(a1 + 136) = v54;
    v57 = v110;
    v58 = (v111 - v110) >> 1;
    do
    {
      v59 = 1024;
      v60 = v55;
      do
      {
        if (v58 <= v60)
          std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
        *(_WORD *)(v53 + 2 * v60) = *(_WORD *)(v57 + 2 * v60);
        ++v60;
        --v59;
      }
      while (v59);
      ++v56;
      v55 += 1024;
    }
    while (v56 != 768);
    v61 = 0;
    v62 = 0;
    v63 = v53;
    do
    {
      v64 = 0;
      v65 = v63;
      do
      {
        v66 = 0;
        v67 = v65;
        do
        {
          v68 = 0;
          v69 = v62;
          do
          {
            *(_WORD *)(v54 + 2 * v62 + 2 * v68) = *(_WORD *)(v67 + 2 * v68);
            ++v68;
          }
          while (v68 != 8);
          ++v66;
          v67 += 2048;
          v62 += 8;
        }
        while (v66 != 4);
        ++v64;
        v65 += 0x2000;
        v62 = v69 + 8;
      }
      while (v64 != 192);
      ++v61;
      v63 += 16;
      v62 = v69 + 8;
    }
    while (v61 != 128);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 280) + 56))(*(_QWORD *)(a1 + 280), v53);
  }
  v119 = v118;
  v111 = v110;
  v115 = v114;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v97);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v97, (uint64_t *)&v104);
  v97.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v103[0] = &unk_24D29B3D8;
  v98 = &unk_24D29B3B0;
  v99 = &unk_24D29B578;
  if (v101 < 0)
    heap_Free(*(_QWORD **)(v102 + 8), v100);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v103);
  v72 = *(char *)(a1 + 55);
  if (v72 >= 0)
    v73 = a1 + 32;
  else
    v73 = *(_QWORD *)(a1 + 32);
  if (v72 >= 0)
    v74 = *(unsigned __int8 *)(a1 + 55);
  else
    v74 = *(_QWORD *)(a1 + 40);
  v75 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v105, v73, v74);
  v76 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v75, (uint64_t)"/bw/lstm/cell/bias", 18);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v76, (uint64_t)"/npy", 4);
  v77 = *(_QWORD *)(a1 + 280);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v106, v85);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v77 + 24))(v77, v85, &v118, &v110, 1);
  if (v86 < 0)
    heap_Free(*(_QWORD **)(v87 + 8), v85[0]);
  if (v111 != v110)
  {
    v78 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 280) + 32))(*(_QWORD *)(a1 + 280), 2048);
    v79 = 0;
    *(_QWORD *)(a1 + 144) = v78;
    v80 = v110;
    v81 = (v111 - v110) >> 1;
    while (v81 != v79)
    {
      *(_WORD *)(v78 + 2 * v79) = *(_WORD *)(v80 + 2 * v79);
      if (++v79 == 1024)
        goto LABEL_91;
    }
    goto LABEL_96;
  }
  v82 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"error: backwards matmul layer bias", 34);
  std::ios_base::getloc((const std::ios_base *)((char *)v82 + *(_QWORD *)(*v82 - 24)));
  v83 = std::locale::use_facet(&v97, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v83->__vftable[2].~facet_0)(v83, 10);
  std::locale::~locale(&v97);
  std::ostream::put();
  std::ostream::flush();
LABEL_91:
  v104.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v109 = &unk_24D29B3D8;
  v105 = &unk_24D29B3B0;
  v106[0] = &unk_24D29B578;
  if (v107 < 0)
    heap_Free(*(_QWORD **)(v108 + 8), v106[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v109);
  v104.__locale_ = (std::locale::__imp *)&v110;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v104);
  v104.__locale_ = (std::locale::__imp *)&v114;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v104);
  v104.__locale_ = (std::locale::__imp *)&v118;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v104);
  return 1;
}

void sub_214E98FEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,std::locale a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,std::locale a61)
{
  uint64_t v61;

  std::locale::~locale(&a25);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)&a61);
  *(_QWORD *)(v61 - 96) = v61 - 192;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v61 - 96));
  *(_QWORD *)(v61 - 192) = v61 - 160;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v61 - 192));
  *(_QWORD *)(v61 - 160) = v61 - 128;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v61 - 160));
  _Unwind_Resume(a1);
}

__n128 NeonLSTMManager::neon_concat(uint64_t a1, uint64_t a2, __n128 *a3, __n128 *a4, unsigned int a5, unsigned int a6, int a7)
{
  uint64_t v7;
  __n128 *v8;
  __n128 *v9;
  __n128 result;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  uint64_t v14;
  __n128 *v15;
  __n128 *v16;
  __n128 v17;
  __n128 v18;
  __n128 v19;

  if (a5 >= 0x20)
  {
    v7 = a5 >> 5;
    v8 = (__n128 *)(a2 + 2 * a7 * a5 + 32);
    v9 = a4 + 2;
    do
    {
      result = v8[-2];
      v11 = v8[-1];
      v12 = *v8;
      v13 = v8[1];
      v8 += 4;
      v9[-2] = result;
      v9[-1] = v11;
      *v9 = v12;
      v9[1] = v13;
      v9 += 4;
      --v7;
    }
    while (v7);
  }
  if (a6 >= 0x20)
  {
    LODWORD(v14) = a6 >> 5;
    if (a6 >> 5 <= 1)
      v14 = 1;
    else
      v14 = v14;
    v15 = a3 + 2;
    v16 = (__n128 *)((char *)a4 + 2 * a5 + 32);
    do
    {
      result = v15[-2];
      v17 = v15[-1];
      v18 = *v15;
      v19 = v15[1];
      v15 += 4;
      v16[-2] = result;
      v16[-1] = v17;
      *v16 = v18;
      v16[1] = v19;
      v16 += 4;
      --v14;
    }
    while (v14);
  }
  return result;
}

float16x8_t NeonLSTMManager::neon_matmul_conv(float16x8_t result, uint64_t a2, float16x8_t *a3, uint64_t a4, float16x8_t *a5, uint64_t a6, unsigned int a7, unsigned int a8)
{
  uint64_t v8;
  uint64_t v9;
  float16x8_t *v10;
  float16x8_t v11;
  float16x8_t v12;
  float16x8_t v13;
  float16x8_t v14;
  float16x8_t *v15;
  uint64_t v16;
  float16x8_t *v17;
  float16x8_t v18;

  if (a8 >= 8)
  {
    v8 = 0;
    LODWORD(v9) = a7 >> 3;
    if (a7 >> 3 <= 1)
      v9 = 1;
    else
      v9 = v9;
    v10 = a3 + 4;
    do
    {
      v11 = *(float16x8_t *)(a4 + 16 * v8);
      v12 = 0uLL;
      if (a7 >= 8)
      {
        v14 = 0uLL;
        v15 = v10;
        v16 = v9;
        v17 = a5;
        v13 = 0uLL;
        do
        {
          v18 = *v17++;
          v11 = vmlaq_laneq_f16(vmlaq_n_f16(v11, v15[-4], *(short float *)v18.i16), *v15, v18, 4);
          v14 = vmlaq_laneq_f16(vmlaq_lane_f16(v14, v15[-3], *(float16x4_t *)v18.i8, 1), v15[1], v18, 5);
          v13 = vmlaq_laneq_f16(vmlaq_lane_f16(v13, v15[-2], *(float16x4_t *)v18.i8, 2), v15[2], v18, 6);
          v12 = vmlaq_laneq_f16(vmlaq_lane_f16(v12, v15[-1], *(float16x4_t *)v18.i8, 3), v15[3], v18, 7);
          v15 += 8;
          --v16;
        }
        while (v16);
      }
      else
      {
        v13 = 0uLL;
        v14 = 0uLL;
      }
      result = vaddq_f16(v12, vaddq_f16(v13, vaddq_f16(v14, v11)));
      *(float16x8_t *)(a6 + 16 * v8++) = result;
      v10 = (float16x8_t *)((char *)v10 + 2 * (int)((8 * a7) & 0xFFFFFFE0));
    }
    while (v8 != a8 >> 3);
  }
  return result;
}

uint64_t NeonLSTMManager::SetUp(_QWORD *a1)
{
  NeonTC2Container *v2;
  uint64_t result;

  v2 = (NeonTC2Container *)a1[3];
  if (!*((_BYTE *)v2 + 2304)
    || (result = NeonTC2Container::EngineMCSetUp(v2, a1, 1, (void (*)(void *, int))mc_LSTM_do_inference),
        (_DWORD)result))
  {
    a1[23] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 0x200000);
    a1[24] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 0x200000);
    a1[25] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 1536);
    a1[26] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 2048);
    if (*(_BYTE *)(a1[3] + 2304))
    {
      a1[27] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 1536);
      a1[28] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 2048);
      a1[29] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 1536);
      a1[30] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 2048);
    }
    *(_QWORD *)(a1[3] + 3320) = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 0x400000);
    a1[19] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 512);
    a1[20] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 512);
    a1[21] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 512);
    a1[22] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[35] + 32))(a1[35], 512);
    return 1;
  }
  return result;
}

uint64_t *mc_LSTM_do_inference(void *a1, int a2)
{
  int v2;
  uint64_t v4;
  _OWORD *v5;
  _OWORD *v6;
  _OWORD *v7;
  _OWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  int v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _OWORD *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float16x8_t *v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _OWORD *v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float16x8_t *v62;
  float16x8_t v63;
  float16x8_t v64;
  float16x8_t v65;
  float16x8_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _OWORD *v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  float16x8_t *v78;
  float16x8_t v79;
  float16x8_t v80;
  float16x8_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float v89;
  float32x4_t v90;
  float v91;
  float32x4_t v92;
  float32x4_t v93;
  float v94;
  float32x4_t v95;
  float v96;
  float32x4_t v97;
  unint64_t v98;
  float16x8_t v99;
  float16x8_t v100;
  float16x8_t v101;
  float16x8_t v102;
  float16x8_t *v103;
  float16x8_t v104;
  float16x8_t v105;
  float16x8_t v106;
  float16x8_t v107;
  float16x8_t v108;
  _OWORD *v109;
  float16x8_t v110;
  float16x8_t v111;
  float16x8_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  float v118;
  float v119;
  uint64_t v122;
  float16x8_t *v123;
  float16x8_t v124;
  float16x8_t v125;
  float16x8_t v126;
  float16x8_t v127;
  float16x8_t *v128;
  float16x8_t v129;
  float16x8_t v130;
  float16x8_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  _OWORD *v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  float16x8_t *v143;
  float16x8_t v144;
  float16x8_t v145;
  float16x8_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float v154;
  float32x4_t v155;
  float v156;
  float32x4_t v157;
  float32x4_t v158;
  float v159;
  float32x4_t v160;
  float v161;
  float32x4_t v162;
  uint64_t v163;
  float16x8_t v164;
  float16x8_t v165;
  float16x8_t v166;
  float16x8_t v167;
  float16x8_t *v168;
  float16x8_t v169;
  float16x8_t v170;
  float16x8_t v171;
  float16x8_t v172;
  float16x8_t v173;
  _OWORD *v174;
  float16x8_t v175;
  float16x8_t v176;
  float16x8_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  float v183;
  float v184;
  uint64_t v187;
  float16x8_t *v188;
  float16x8_t v189;
  float16x8_t v190;
  float16x8_t v191;
  float16x8_t v192;
  float16x8_t *v193;
  float16x8_t v194;
  float16x8_t v195;
  float16x8_t v196;
  uint64_t *result;
  uint64_t v198;
  int v199;
  uint64_t v200;
  __int16 *v201;
  _DWORD *v202;
  __int16 v203;
  uint64_t *v206;
  _QWORD *v207;
  unint64_t v208;
  uint64_t *v209;
  _QWORD *v210;
  _QWORD *v211;
  uint64_t v212;
  unint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  _QWORD *v217;
  _QWORD *v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  _QWORD *v223;
  unint64_t v224;
  uint64_t *v225;
  _QWORD *v226;
  _QWORD *v227;
  uint64_t v228;
  unint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  _QWORD *v233;
  _QWORD *v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  _QWORD *v238;
  unint64_t v239;
  _QWORD *v240;
  _QWORD *v241;
  uint64_t v242;
  unint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  _QWORD *v247;
  _QWORD *v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  int v252;
  uint64_t v253;
  uint64_t v254;
  unsigned int v255;
  unsigned int v256;
  float16x8_t v257;
  float16x8_t v258;
  float32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float32x4_t v265;
  float32x4_t v266;
  float32x4_t v267;
  float v268;
  float32x4_t v269;
  float32x4_t v270;
  float32x4_t v271;
  float32x4_t v272;
  float v273;
  float32x4_t v274;
  float32x4_t v275;
  float32x4_t v276;
  float32x4_t v277;
  float32x4_t v278;
  float32x4_t v279;
  float32x4_t v280;
  float32x4_t v281;
  float32x4_t v282;
  _QWORD *v283;
  _QWORD *v284;
  _QWORD *v285;
  uint64_t v286;
  _QWORD *v287;
  _BYTE v288[3072];
  uint64_t v289;
  _QWORD v290[5];

  v2 = a2;
  v289 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v4 = *((_QWORD *)a1 + 3);
  }
  else
  {
    bzero(*((void **)a1 + 27), 0x600uLL);
    bzero(*((void **)a1 + 29), 0x600uLL);
    v5 = (_OWORD *)*((_QWORD *)a1 + 19);
    v5[30] = 0u;
    v5[31] = 0u;
    v5[28] = 0u;
    v5[29] = 0u;
    v5[26] = 0u;
    v5[27] = 0u;
    v5[24] = 0u;
    v5[25] = 0u;
    v5[22] = 0u;
    v5[23] = 0u;
    v5[20] = 0u;
    v5[21] = 0u;
    v5[18] = 0u;
    v5[19] = 0u;
    v5[16] = 0u;
    v5[17] = 0u;
    v5[14] = 0u;
    v5[15] = 0u;
    v5[12] = 0u;
    v5[13] = 0u;
    v5[10] = 0u;
    v5[11] = 0u;
    v5[8] = 0u;
    v5[9] = 0u;
    v5[6] = 0u;
    v5[7] = 0u;
    v5[4] = 0u;
    v5[5] = 0u;
    v5[2] = 0u;
    v5[3] = 0u;
    *v5 = 0u;
    v5[1] = 0u;
    v6 = (_OWORD *)*((_QWORD *)a1 + 20);
    v6[30] = 0u;
    v6[31] = 0u;
    v6[28] = 0u;
    v6[29] = 0u;
    v6[26] = 0u;
    v6[27] = 0u;
    v6[24] = 0u;
    v6[25] = 0u;
    v6[22] = 0u;
    v6[23] = 0u;
    v6[20] = 0u;
    v6[21] = 0u;
    v6[18] = 0u;
    v6[19] = 0u;
    v6[16] = 0u;
    v6[17] = 0u;
    v6[14] = 0u;
    v6[15] = 0u;
    v6[12] = 0u;
    v6[13] = 0u;
    v6[10] = 0u;
    v6[11] = 0u;
    v6[8] = 0u;
    v6[9] = 0u;
    v6[6] = 0u;
    v6[7] = 0u;
    v6[4] = 0u;
    v6[5] = 0u;
    v6[2] = 0u;
    v6[3] = 0u;
    *v6 = 0u;
    v6[1] = 0u;
    v7 = (_OWORD *)*((_QWORD *)a1 + 21);
    v7[30] = 0u;
    v7[31] = 0u;
    v7[28] = 0u;
    v7[29] = 0u;
    v7[26] = 0u;
    v7[27] = 0u;
    v7[24] = 0u;
    v7[25] = 0u;
    v7[22] = 0u;
    v7[23] = 0u;
    v7[20] = 0u;
    v7[21] = 0u;
    v7[18] = 0u;
    v7[19] = 0u;
    v7[16] = 0u;
    v7[17] = 0u;
    v7[14] = 0u;
    v7[15] = 0u;
    v7[12] = 0u;
    v7[13] = 0u;
    v7[10] = 0u;
    v7[11] = 0u;
    v7[8] = 0u;
    v7[9] = 0u;
    v7[6] = 0u;
    v7[7] = 0u;
    v7[4] = 0u;
    v7[5] = 0u;
    v7[2] = 0u;
    v7[3] = 0u;
    *v7 = 0u;
    v7[1] = 0u;
    v8 = (_OWORD *)*((_QWORD *)a1 + 22);
    v8[30] = 0u;
    v8[31] = 0u;
    v8[28] = 0u;
    v8[29] = 0u;
    v8[26] = 0u;
    v8[27] = 0u;
    v8[24] = 0u;
    v8[25] = 0u;
    v8[22] = 0u;
    v8[23] = 0u;
    v8[20] = 0u;
    v8[21] = 0u;
    v8[18] = 0u;
    v8[19] = 0u;
    v8[16] = 0u;
    v8[17] = 0u;
    v8[14] = 0u;
    v8[15] = 0u;
    v8[12] = 0u;
    v8[13] = 0u;
    v8[10] = 0u;
    v8[11] = 0u;
    v8[8] = 0u;
    v8[9] = 0u;
    v8[6] = 0u;
    v8[7] = 0u;
    v8[4] = 0u;
    v8[5] = 0u;
    v8[2] = 0u;
    v8[3] = 0u;
    *v8 = 0u;
    v8[1] = 0u;
    v4 = *((_QWORD *)a1 + 3);
    if (!*(_BYTE *)(v4 + 2720))
    {
      v9 = (_QWORD *)*((_QWORD *)a1 + 32);
      if (v9[1] - *v9 <= 8uLL)
        std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
      *(_DWORD *)(v4 + 3396) = *(_QWORD *)(*v9 + 8);
    }
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(v4 + 2656) + 8))(*(_QWORD *)(v4 + 2656));
  v10 = *((_QWORD *)a1 + 3);
  if (!*(_BYTE *)(v10 + 2720))
  {
    v11 = 512 / *(_DWORD *)(v10 + 2308);
    LODWORD(v12) = v11 * v2;
    v13 = v11 + v11 * v2;
    if ((int)v12 < v13)
    {
      v14 = *(unsigned int *)(v10 + 3396);
      v12 = (int)v12;
      do
      {
        if ((int)v14 >= 1)
        {
          v15 = (uint64_t *)*((_QWORD *)a1 + 31);
          v16 = *v15;
          v17 = (v15[1] - *v15) >> 2;
          v18 = v14;
          v19 = v12;
          do
          {
            if (v17 <= v19)
              std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
            _S0 = *(_DWORD *)(v16 + 4 * v19);
            __asm { FCVT            H0, S0 }
            *(_WORD *)(*((_QWORD *)a1 + 23) + 2 * v19) = _S0;
            v19 += 512;
            --v18;
          }
          while (v18);
        }
        ++v12;
      }
      while (v13 != (_DWORD)v12);
    }
  }
  v25 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v10 + 2656) + 8))(*(_QWORD *)(v10 + 2656));
  v26 = *((_QWORD *)a1 + 3);
  LODWORD(v27) = *(_DWORD *)(v26 + 3396);
  if ((int)v27 >= 1)
  {
    v28 = 0;
    v29 = 0;
    v266 = (float32x4_t)vdupq_n_s32(0x3F523BE9u);
    v267 = (float32x4_t)vdupq_n_s32(0x401D2709u);
    v264 = (float32x4_t)vdupq_n_s32(0x401C7BF8u);
    v265 = (float32x4_t)vdupq_n_s32(0x3F64AAB6u);
    v30 = -1;
    v263 = (float32x4_t)vdupq_n_s32(0x3F508C6Du);
    __asm { FMOV            V0.4S, #1.0 }
    v282 = _Q0;
    v257 = (float16x8_t)vdupq_n_s16(0x2E66u);
    v258 = (float16x8_t)vdupq_n_s16(0x3B33u);
    v252 = v2;
    do
    {
      if (v2)
      {
        if (v2 == 1)
        {
          v253 = v29;
          v255 = v28;
          if (*(_BYTE *)(v26 + 2720))
          {
            v32 = 0;
            v33 = *(_QWORD *)(v26 + 3360);
            v34 = *((_QWORD *)a1 + 22);
            v35 = *((_QWORD *)a1 + 29);
            v36 = v33 + 2 * (((_DWORD)v27 + v30) << 9) + 48;
            do
            {
              v37 = (_OWORD *)(v35 + v32);
              v38 = *(_OWORD *)(v36 + v32 - 32);
              v39 = *(_OWORD *)(v36 + v32 - 16);
              v40 = *(_OWORD *)(v36 + v32);
              *v37 = *(_OWORD *)(v36 + v32 - 48);
              v37[1] = v38;
              v37[2] = v39;
              v37[3] = v40;
              v32 += 64;
            }
            while (v32 != 1024);
            v41 = 0;
            v42 = v35 + 1024;
            v43 = v34 + 48;
            do
            {
              v44 = (float16x8_t *)(v42 + v41);
              v45 = *(float16x8_t *)(v43 + v41 - 48);
              v46 = *(float16x8_t *)(v43 + v41 - 32);
              v47 = *(float16x8_t *)(v43 + v41 - 16);
              v48 = *(float16x8_t *)(v43 + v41);
              *v44 = v45;
              v44[1] = v46;
              v44[2] = v47;
              v44[3] = v48;
              v41 += 64;
            }
            while (v41 != 512);
          }
          else
          {
            v132 = 0;
            v133 = *((_QWORD *)a1 + 22);
            v134 = *((_QWORD *)a1 + 29);
            v135 = *((_QWORD *)a1 + 23) + 2 * (((_DWORD)v27 + v30) << 9) + 48;
            do
            {
              v136 = (_OWORD *)(v134 + v132);
              v137 = *(_OWORD *)(v135 + v132 - 32);
              v138 = *(_OWORD *)(v135 + v132 - 16);
              v139 = *(_OWORD *)(v135 + v132);
              *v136 = *(_OWORD *)(v135 + v132 - 48);
              v136[1] = v137;
              v136[2] = v138;
              v136[3] = v139;
              v132 += 64;
            }
            while (v132 != 1024);
            v140 = 0;
            v141 = v134 + 1024;
            v142 = v133 + 48;
            do
            {
              v143 = (float16x8_t *)(v141 + v140);
              v45 = *(float16x8_t *)(v142 + v140 - 48);
              v144 = *(float16x8_t *)(v142 + v140 - 32);
              v145 = *(float16x8_t *)(v142 + v140 - 16);
              v146 = *(float16x8_t *)(v142 + v140);
              *v143 = v45;
              v143[1] = v144;
              v143[2] = v145;
              v143[3] = v146;
              v140 += 64;
            }
            while (v140 != 512);
          }
          NeonLSTMManager::neon_matmul_conv(v45, v25, *((float16x8_t **)a1 + 17), *((_QWORD *)a1 + 18), *((float16x8_t **)a1 + 29), *((_QWORD *)a1 + 30), 0x300u, 0x400u);
          v147 = 0;
          v148 = *((_QWORD *)a1 + 30);
          v149 = *((_QWORD *)a1 + 21);
          do
          {
            v150 = vcvtq_f32_f16(*(float16x4_t *)(v148 + v147 + 512));
            v151 = vabsq_f32(v150);
            v152 = vmulq_f32(v150, v150);
            v261 = vdivq_f32(vmulq_f32(vmlaq_f32(vmlaq_f32(v267, v267, v151), v152, vmlaq_f32(v265, v266, v151)), v150), vmlaq_f32(v264, vabsq_f32(vmlaq_f32(v150, v151, vmulq_f32(v150, v263))), vaddq_f32(v152, v264)));
            v280 = vnegq_f32(vcvtq_f32_f16(*(float16x4_t *)(v148 + v147)));
            v273 = expf(v280.f32[1]);
            v153.f32[0] = expf(v280.f32[0]);
            v153.f32[1] = v273;
            v274 = v153;
            v154 = expf(v280.f32[2]);
            v155 = v274;
            v155.f32[2] = v154;
            v275 = v155;
            v156 = expf(v280.f32[3]);
            v157 = v275;
            v157.f32[3] = v156;
            *(float16x4_t *)&v288[v147 + 1024] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v282, vaddq_f32(v157, v282)), v261));
            v262 = vcvtq_f32_f16(*(float16x4_t *)(v149 + v147));
            v281 = vnegq_f32(vaddq_f32(vcvtq_f32_f16(*(float16x4_t *)(v148 + v147 + 1024)), v282));
            v275.i32[0] = expf(v281.f32[1]);
            v158.f32[0] = expf(v281.f32[0]);
            v158.i32[1] = v275.i32[0];
            v276 = v158;
            v159 = expf(v281.f32[2]);
            v160 = v276;
            v160.f32[2] = v159;
            v277 = v160;
            v161 = expf(v281.f32[3]);
            v162 = v277;
            v162.f32[3] = v161;
            *(float16x4_t *)&v288[v147 + 512] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v282, vaddq_f32(v162, v282)), v262));
            v147 += 8;
          }
          while (v147 != 512);
          v163 = -512;
          do
          {
            v164 = *(float16x8_t *)&v288[v163 + 1568];
            v165 = *(float16x8_t *)&v288[v163 + 1584];
            v166 = *(float16x8_t *)&v288[v163 + 1056];
            v167 = *(float16x8_t *)&v288[v163 + 1072];
            v168 = (float16x8_t *)(*((_QWORD *)a1 + 21) + v163);
            v169 = v168[32];
            v170 = v168[33];
            v171 = v168[34];
            v172 = v168[35];
            v173 = vaddq_f16(*(float16x8_t *)&v288[v163 + 1536], *(float16x8_t *)&v288[v163 + 1024]);
            v174 = &v288[v163];
            v175 = vaddq_f16(*(float16x8_t *)&v288[v163 + 1552], *(float16x8_t *)&v288[v163 + 1040]);
            v174[32] = v173;
            v174[33] = v175;
            v176 = vaddq_f16(v164, v166);
            v177 = vaddq_f16(v165, v167);
            v174[34] = v176;
            v174[35] = v177;
            v168[32] = vaddq_f16(vmulq_f16(v173, v258), vmulq_f16(v169, v257));
            *(float16x8_t *)(*((_QWORD *)a1 + 21) + v163 + 528) = vaddq_f16(vmulq_f16(v175, v258), vmulq_f16(v170, v257));
            *(float16x8_t *)(*((_QWORD *)a1 + 21) + v163 + 544) = vaddq_f16(vmulq_f16(v176, v258), vmulq_f16(v171, v257));
            *(float16x8_t *)(*((_QWORD *)a1 + 21) + v163 + 560) = vaddq_f16(vmulq_f16(v177, v258), vmulq_f16(v172, v257));
            v163 += 64;
          }
          while (v163);
          v178 = 0;
          v179 = *((_QWORD *)a1 + 30) + 1536;
          v180 = *((_QWORD *)a1 + 24) + 2 * (((int)v27 + v30) << 9) + 512;
          do
          {
            _H0 = *(_WORD *)&v288[v178];
            __asm { FCVT            S0, H0 }
            v183 = fabsf(_S0);
            v184 = (float)((float)((float)((float)(v183 * 2.4555) + 2.4555)
                                 + (float)((float)((float)(v183 * 0.82123) + 0.89323) * (float)(_S0 * _S0)))
                         * _S0)
                 / (float)((float)((float)((float)(_S0 * _S0) + 2.4451)
                                 * fabsf(_S0 + (float)((float)(_S0 * 0.81464) * v183)))
                         + 2.4451);
            LOWORD(_S0) = *(_WORD *)(v179 + v178);
            __asm { FCVT            S0, H0 }
            _S0 = v184 * (float)(1.0 / (float)(expf(-_S0) + 1.0));
            __asm { FCVT            H0, S0 }
            *(_WORD *)(v180 + v178) = LOWORD(_S0);
            v178 += 2;
          }
          while (v178 != 512);
          v187 = -512;
          v2 = v252;
          v29 = v253;
          v28 = v255;
          do
          {
            v188 = (float16x8_t *)(*((_QWORD *)a1 + 24) + 2 * (((int)v27 + v30) << 9) + v187);
            v189 = v188[64];
            v190 = v188[65];
            v191 = v188[66];
            v192 = v188[67];
            v193 = (float16x8_t *)(*((_QWORD *)a1 + 22) + v187);
            v194 = v193[33];
            v195 = v193[34];
            v196 = v193[35];
            v193[32] = vaddq_f16(vmulq_f16(v189, v258), vmulq_f16(v193[32], v257));
            *(float16x8_t *)(*((_QWORD *)a1 + 22) + v187 + 528) = vaddq_f16(vmulq_f16(v190, v258), vmulq_f16(v194, v257));
            *(float16x8_t *)(*((_QWORD *)a1 + 22) + v187 + 544) = vaddq_f16(vmulq_f16(v191, v258), vmulq_f16(v195, v257));
            *(float16x8_t *)(*((_QWORD *)a1 + 22) + v187 + 560) = vaddq_f16(vmulq_f16(v192, v258), vmulq_f16(v196, v257));
            v187 += 64;
          }
          while (v187);
        }
      }
      else
      {
        v254 = v29;
        v256 = v28;
        v49 = 2 * v28;
        if (*(_BYTE *)(v26 + 2720))
        {
          v50 = 0;
          v51 = *(_QWORD *)(v26 + 3360);
          v52 = *((_QWORD *)a1 + 20);
          v53 = *((_QWORD *)a1 + 27);
          v54 = v51 + v49 + 48;
          do
          {
            v55 = (_OWORD *)(v53 + v50);
            v56 = *(_OWORD *)(v54 + v50 - 32);
            v57 = *(_OWORD *)(v54 + v50 - 16);
            v58 = *(_OWORD *)(v54 + v50);
            *v55 = *(_OWORD *)(v54 + v50 - 48);
            v55[1] = v56;
            v55[2] = v57;
            v55[3] = v58;
            v50 += 64;
          }
          while (v50 != 1024);
          v59 = 0;
          v60 = v53 + 1024;
          v61 = v52 + 48;
          do
          {
            v62 = (float16x8_t *)(v60 + v59);
            v63 = *(float16x8_t *)(v61 + v59 - 48);
            v64 = *(float16x8_t *)(v61 + v59 - 32);
            v65 = *(float16x8_t *)(v61 + v59 - 16);
            v66 = *(float16x8_t *)(v61 + v59);
            *v62 = v63;
            v62[1] = v64;
            v62[2] = v65;
            v62[3] = v66;
            v59 += 64;
          }
          while (v59 != 512);
        }
        else
        {
          v67 = 0;
          v68 = *((_QWORD *)a1 + 20);
          v69 = *((_QWORD *)a1 + 27);
          v70 = *((_QWORD *)a1 + 23) + v49 + 48;
          do
          {
            v71 = (_OWORD *)(v69 + v67);
            v72 = *(_OWORD *)(v70 + v67 - 32);
            v73 = *(_OWORD *)(v70 + v67 - 16);
            v74 = *(_OWORD *)(v70 + v67);
            *v71 = *(_OWORD *)(v70 + v67 - 48);
            v71[1] = v72;
            v71[2] = v73;
            v71[3] = v74;
            v67 += 64;
          }
          while (v67 != 1024);
          v75 = 0;
          v76 = v69 + 1024;
          v77 = v68 + 48;
          do
          {
            v78 = (float16x8_t *)(v76 + v75);
            v63 = *(float16x8_t *)(v77 + v75 - 48);
            v79 = *(float16x8_t *)(v77 + v75 - 32);
            v80 = *(float16x8_t *)(v77 + v75 - 16);
            v81 = *(float16x8_t *)(v77 + v75);
            *v78 = v63;
            v78[1] = v79;
            v78[2] = v80;
            v78[3] = v81;
            v75 += 64;
          }
          while (v75 != 512);
        }
        NeonLSTMManager::neon_matmul_conv(v63, v25, *((float16x8_t **)a1 + 15), *((_QWORD *)a1 + 16), *((float16x8_t **)a1 + 27), *((_QWORD *)a1 + 28), 0x300u, 0x400u);
        v82 = 0;
        v83 = *((_QWORD *)a1 + 28);
        v84 = *((_QWORD *)a1 + 19);
        do
        {
          v85 = vcvtq_f32_f16(*(float16x4_t *)(v83 + v82 + 512));
          v86 = vabsq_f32(v85);
          v87 = vmulq_f32(v85, v85);
          v259 = vdivq_f32(vmulq_f32(vmlaq_f32(vmlaq_f32(v267, v267, v86), v87, vmlaq_f32(v265, v266, v86)), v85), vmlaq_f32(v264, vabsq_f32(vmlaq_f32(v85, v86, vmulq_f32(v85, v263))), vaddq_f32(v87, v264)));
          v278 = vnegq_f32(vcvtq_f32_f16(*(float16x4_t *)(v83 + v82)));
          v268 = expf(v278.f32[1]);
          v88.f32[0] = expf(v278.f32[0]);
          v88.f32[1] = v268;
          v269 = v88;
          v89 = expf(v278.f32[2]);
          v90 = v269;
          v90.f32[2] = v89;
          v270 = v90;
          v91 = expf(v278.f32[3]);
          v92 = v270;
          v92.f32[3] = v91;
          *(float16x4_t *)&v288[v82 + 2560] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v282, vaddq_f32(v92, v282)), v259));
          v260 = vcvtq_f32_f16(*(float16x4_t *)(v84 + v82));
          v279 = vnegq_f32(vaddq_f32(vcvtq_f32_f16(*(float16x4_t *)(v83 + v82 + 1024)), v282));
          v270.i32[0] = expf(v279.f32[1]);
          v93.f32[0] = expf(v279.f32[0]);
          v93.i32[1] = v270.i32[0];
          v271 = v93;
          v94 = expf(v279.f32[2]);
          v95 = v271;
          v95.f32[2] = v94;
          v272 = v95;
          v96 = expf(v279.f32[3]);
          v97 = v272;
          v97.f32[3] = v96;
          *(float16x4_t *)&v288[v82 + 2048] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v282, vaddq_f32(v97, v282)), v260));
          v82 += 8;
        }
        while (v82 != 512);
        v98 = -512;
        do
        {
          v99 = *(float16x8_t *)&v290[v98 / 8 + 2];
          v100 = *(float16x8_t *)&v290[v98 / 8 + 4];
          v101 = *(float16x8_t *)&v288[v98 + 2592];
          v102 = *(float16x8_t *)&v288[v98 + 2608];
          v103 = (float16x8_t *)(*((_QWORD *)a1 + 19) + v98);
          v104 = v103[32];
          v105 = v103[33];
          v106 = v103[34];
          v107 = v103[35];
          v108 = vaddq_f16(*(float16x8_t *)&v288[v98 + 3072], *(float16x8_t *)&v288[v98 + 2560]);
          v109 = &v288[v98 + 1536];
          v110 = vaddq_f16(*(float16x8_t *)&v290[v98 / 8], *(float16x8_t *)&v288[v98 + 2576]);
          v109[32] = v108;
          v109[33] = v110;
          v111 = vaddq_f16(v99, v101);
          v112 = vaddq_f16(v100, v102);
          v109[34] = v111;
          v109[35] = v112;
          v103[32] = vaddq_f16(vmulq_f16(v108, v258), vmulq_f16(v104, v257));
          *(float16x8_t *)(*((_QWORD *)a1 + 19) + v98 + 528) = vaddq_f16(vmulq_f16(v110, v258), vmulq_f16(v105, v257));
          *(float16x8_t *)(*((_QWORD *)a1 + 19) + v98 + 544) = vaddq_f16(vmulq_f16(v111, v258), vmulq_f16(v106, v257));
          *(float16x8_t *)(*((_QWORD *)a1 + 19) + v98 + 560) = vaddq_f16(vmulq_f16(v112, v258), vmulq_f16(v107, v257));
          v98 += 64;
        }
        while (v98);
        v113 = 0;
        v114 = *((_QWORD *)a1 + 24) + v49;
        v115 = *((_QWORD *)a1 + 28) + 1536;
        do
        {
          _H0 = *(_WORD *)&v288[v113 + 1536];
          __asm { FCVT            S0, H0 }
          v118 = fabsf(_S0);
          v119 = (float)((float)((float)((float)(v118 * 2.4555) + 2.4555)
                               + (float)((float)((float)(v118 * 0.82123) + 0.89323) * (float)(_S0 * _S0)))
                       * _S0)
               / (float)((float)((float)((float)(_S0 * _S0) + 2.4451)
                               * fabsf(_S0 + (float)((float)(_S0 * 0.81464) * v118)))
                       + 2.4451);
          LOWORD(_S0) = *(_WORD *)(v115 + v113);
          __asm { FCVT            S0, H0 }
          _S0 = v119 * (float)(1.0 / (float)(expf(-_S0) + 1.0));
          __asm { FCVT            H0, S0 }
          *(_WORD *)(v114 + v113) = LOWORD(_S0);
          v113 += 2;
        }
        while (v113 != 512);
        v122 = -512;
        v2 = v252;
        v29 = v254;
        v28 = v256;
        do
        {
          v123 = (float16x8_t *)(*((_QWORD *)a1 + 24) + v49 + v122);
          v124 = v123[32];
          v125 = v123[33];
          v126 = v123[34];
          v127 = v123[35];
          v128 = (float16x8_t *)(*((_QWORD *)a1 + 20) + v122);
          v129 = v128[33];
          v130 = v128[34];
          v131 = v128[35];
          v128[32] = vaddq_f16(vmulq_f16(v124, v258), vmulq_f16(v128[32], v257));
          *(float16x8_t *)(*((_QWORD *)a1 + 20) + v122 + 528) = vaddq_f16(vmulq_f16(v125, v258), vmulq_f16(v129, v257));
          *(float16x8_t *)(*((_QWORD *)a1 + 20) + v122 + 544) = vaddq_f16(vmulq_f16(v126, v258), vmulq_f16(v130, v257));
          *(float16x8_t *)(*((_QWORD *)a1 + 20) + v122 + 560) = vaddq_f16(vmulq_f16(v127, v258), vmulq_f16(v131, v257));
          v122 += 64;
        }
        while (v122);
      }
      ++v29;
      v26 = *((_QWORD *)a1 + 3);
      v27 = *(int *)(v26 + 3396);
      --v30;
      v28 += 512;
    }
    while (v29 < v27);
  }
  result = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v26 + 2656) + 8))(*(_QWORD *)(v26 + 2656));
  if (!v2)
  {
    v198 = *((_QWORD *)a1 + 3);
    v199 = *(_DWORD *)(v198 + 3396);
    if (v199 >= 1)
    {
      LODWORD(v200) = v199 << 9;
      v201 = (__int16 *)*((_QWORD *)a1 + 24);
      v202 = *(_DWORD **)(v198 + 3320);
      if (v199 << 9 <= 1)
        v200 = 1;
      else
        v200 = v200;
      do
      {
        v203 = *v201++;
        _H0 = v203;
        __asm { FCVT            S0, H0 }
        *v202++ = _S0;
        --v200;
      }
      while (v200);
    }
    v206 = (uint64_t *)*((_QWORD *)a1 + 34);
    v207 = (_QWORD *)v206[1];
    v208 = v206[2];
    if ((unint64_t)v207 >= v208)
    {
      v211 = (_QWORD *)*v206;
      v212 = ((uint64_t)v207 - *v206) >> 3;
      v213 = v212 + 1;
      if ((unint64_t)(v212 + 1) >> 61)
        std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
      v214 = v208 - (_QWORD)v211;
      if (v214 >> 2 > v213)
        v213 = v214 >> 2;
      if ((unint64_t)v214 >= 0x7FFFFFFFFFFFFFF8)
        v215 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v215 = v213;
      v287 = v206 + 3;
      if (v215)
      {
        v216 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v206 + 3), v215);
        v211 = (_QWORD *)*v206;
        v207 = (_QWORD *)v206[1];
      }
      else
      {
        v216 = 0;
      }
      v217 = (_QWORD *)(v216 + 8 * v212);
      *v217 = 1;
      if (v207 == v211)
      {
        v219 = v216 + 8 * v212;
      }
      else
      {
        v218 = v207;
        v219 = v216 + 8 * v212;
        do
        {
          v220 = *--v218;
          *(_QWORD *)(v219 - 8) = v220;
          v219 -= 8;
        }
        while (v218 != v211);
      }
      v210 = v217 + 1;
      *v206 = v219;
      v283 = v211;
      v284 = v211;
      v206[1] = (uint64_t)(v217 + 1);
      v285 = v207;
      v221 = v206[2];
      v206[2] = v216 + 8 * v215;
      v286 = v221;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v283);
      v209 = (uint64_t *)*((_QWORD *)a1 + 34);
      v199 = *(_DWORD *)(*((_QWORD *)a1 + 3) + 3396);
    }
    else
    {
      *v207 = 1;
      v209 = v206;
      v210 = v207 + 1;
    }
    v206[1] = (uint64_t)v210;
    v222 = v199;
    v223 = (_QWORD *)v209[1];
    v224 = v209[2];
    if ((unint64_t)v223 >= v224)
    {
      v227 = (_QWORD *)*v209;
      v228 = ((uint64_t)v223 - *v209) >> 3;
      v229 = v228 + 1;
      if ((unint64_t)(v228 + 1) >> 61)
        std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
      v230 = v224 - (_QWORD)v227;
      if (v230 >> 2 > v229)
        v229 = v230 >> 2;
      if ((unint64_t)v230 >= 0x7FFFFFFFFFFFFFF8)
        v231 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v231 = v229;
      v287 = v209 + 3;
      if (v231)
      {
        v232 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v209 + 3), v231);
        v227 = (_QWORD *)*v209;
        v223 = (_QWORD *)v209[1];
      }
      else
      {
        v232 = 0;
      }
      v233 = (_QWORD *)(v232 + 8 * v228);
      *v233 = v222;
      if (v223 == v227)
      {
        v235 = v232 + 8 * v228;
      }
      else
      {
        v234 = v223;
        v235 = v232 + 8 * v228;
        do
        {
          v236 = *--v234;
          *(_QWORD *)(v235 - 8) = v236;
          v235 -= 8;
        }
        while (v234 != v227);
      }
      v226 = v233 + 1;
      *v209 = v235;
      v283 = v227;
      v284 = v227;
      v209[1] = (uint64_t)(v233 + 1);
      v285 = v223;
      v237 = v209[2];
      v209[2] = v232 + 8 * v231;
      v286 = v237;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v283);
      v225 = (uint64_t *)*((_QWORD *)a1 + 34);
    }
    else
    {
      *v223 = v199;
      v225 = v209;
      v226 = v223 + 1;
    }
    v209[1] = (uint64_t)v226;
    v238 = (_QWORD *)v225[1];
    v239 = v225[2];
    if ((unint64_t)v238 >= v239)
    {
      v241 = (_QWORD *)*v225;
      v242 = ((uint64_t)v238 - *v225) >> 3;
      v243 = v242 + 1;
      if ((unint64_t)(v242 + 1) >> 61)
        std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
      v244 = v239 - (_QWORD)v241;
      if (v244 >> 2 > v243)
        v243 = v244 >> 2;
      if ((unint64_t)v244 >= 0x7FFFFFFFFFFFFFF8)
        v245 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v245 = v243;
      v287 = v225 + 3;
      if (v245)
      {
        v246 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v225 + 3), v245);
        v241 = (_QWORD *)*v225;
        v238 = (_QWORD *)v225[1];
      }
      else
      {
        v246 = 0;
      }
      v247 = (_QWORD *)(v246 + 8 * v242);
      *v247 = 512;
      if (v238 == v241)
      {
        v249 = v246 + 8 * v242;
      }
      else
      {
        v248 = v238;
        v249 = v246 + 8 * v242;
        do
        {
          v250 = *--v248;
          *(_QWORD *)(v249 - 8) = v250;
          v249 -= 8;
        }
        while (v248 != v241);
      }
      v240 = v247 + 1;
      *v225 = v249;
      v283 = v241;
      v284 = v241;
      v225[1] = (uint64_t)(v247 + 1);
      v285 = v238;
      v251 = v225[2];
      v225[2] = v246 + 8 * v245;
      v286 = v251;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v283);
    }
    else
    {
      *v238 = 512;
      v240 = v238 + 1;
    }
    v225[1] = (uint64_t)v240;
    return std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(*((uint64_t **)a1 + 33), *(char **)(*((_QWORD *)a1 + 3) + 3320), *(_QWORD *)(*((_QWORD *)a1 + 3) + 3320) + ((uint64_t)*(int *)(*((_QWORD *)a1 + 3) + 3396) << 11), (uint64_t)*(int *)(*((_QWORD *)a1 + 3) + 3396) << 9);
  }
  return result;
}

void NeonLSTMManager::do_inference(uint64_t a1, int **a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *v6;
  uint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  _OWORD *v13;
  _OWORD *v14;
  _OWORD *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int *v19;
  _WORD *v20;
  int v21;
  unsigned int v27;
  uint64_t v28;
  int v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _OWORD *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float16x8_t *v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _OWORD *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  float16x8_t *v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float v71;
  float32x4_t v72;
  float v73;
  float32x4_t v74;
  float32x4_t v75;
  float v76;
  float32x4_t v77;
  float v78;
  float32x4_t v79;
  unint64_t v80;
  float16x8_t v81;
  float16x8_t v82;
  float16x8_t v83;
  float16x8_t v84;
  float16x8_t *v85;
  float16x8_t v86;
  float16x8_t v87;
  float16x8_t v88;
  float16x8_t v89;
  float16x8_t v90;
  _OWORD *v91;
  float16x8_t v92;
  float16x8_t v93;
  float16x8_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  float v100;
  float v101;
  uint64_t v103;
  uint64_t v105;
  float16x8_t *v106;
  float16x8_t v107;
  float16x8_t v108;
  float16x8_t v109;
  float16x8_t v110;
  float16x8_t *v111;
  float16x8_t v112;
  float16x8_t v113;
  float16x8_t v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  _OWORD *v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  float16x8_t *v129;
  float16x8_t v130;
  float16x8_t v131;
  float16x8_t v132;
  float16x8_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  _OWORD *v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  float16x8_t *v145;
  float16x8_t v146;
  float16x8_t v147;
  float16x8_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float v156;
  float32x4_t v157;
  float v158;
  float32x4_t v159;
  float32x4_t v160;
  float v161;
  float32x4_t v162;
  float v163;
  float32x4_t v164;
  uint64_t v165;
  float16x8_t v166;
  float16x8_t v167;
  float16x8_t v168;
  float16x8_t v169;
  float16x8_t *v170;
  float16x8_t v171;
  float16x8_t v172;
  float16x8_t v173;
  float16x8_t v174;
  float16x8_t v175;
  _OWORD *v176;
  float16x8_t v177;
  float16x8_t v178;
  float16x8_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  float v185;
  float v186;
  uint64_t v189;
  float16x8_t *v190;
  float16x8_t v191;
  float16x8_t v192;
  float16x8_t v193;
  float16x8_t v194;
  float16x8_t *v195;
  float16x8_t v196;
  float16x8_t v197;
  float16x8_t v198;
  uint64_t v199;
  uint64_t v200;
  __int16 *v201;
  _DWORD *v202;
  __int16 v203;
  _QWORD *v206;
  unint64_t v207;
  _QWORD *v208;
  _QWORD *v209;
  uint64_t v210;
  unint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  _QWORD *v215;
  _QWORD *v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  _QWORD *v221;
  _QWORD *v222;
  uint64_t v223;
  unint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  _QWORD *v228;
  _QWORD *v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  _QWORD *v233;
  _QWORD *v234;
  uint64_t v235;
  unint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  _QWORD *v240;
  _QWORD *v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t *v245;
  uint64_t v246;
  unsigned int v247;
  float16x8_t v248;
  float16x8_t v249;
  float32x4_t v250;
  float32x4_t v251;
  float32x4_t v252;
  float32x4_t v253;
  float32x4_t v254;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v258;
  float v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float v264;
  float32x4_t v265;
  float32x4_t v266;
  float32x4_t v267;
  float32x4_t v268;
  float32x4_t v269;
  float32x4_t v270;
  float32x4_t v271;
  float32x4_t v272;
  float32x4_t v273;
  _QWORD *v274;
  _QWORD *v275;
  _QWORD *v276;
  uint64_t v277;
  _QWORD *v278;
  _BYTE v279[3072];
  uint64_t v280;
  _QWORD v281[5];

  v6 = a4;
  v280 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(v10 + 2304))
  {
    *(_QWORD *)(a1 + 248) = a2;
    *(_QWORD *)(a1 + 256) = a3;
    *(_QWORD *)(a1 + 264) = a4;
    *(_QWORD *)(a1 + 272) = a5;
    SynchroManager::cond_broadcast_on_entry((SynchroManager *)(v10 + 2312), *(_DWORD *)(v10 + 2308), 2);
    SynchroManager::cond_wait_less_on_exit((SynchroManager *)(*(_QWORD *)(a1 + 24) + 2312), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    return;
  }
  bzero(*(void **)(a1 + 200), 0x600uLL);
  v12 = *(_OWORD **)(a1 + 152);
  v12[30] = 0u;
  v12[31] = 0u;
  v12[28] = 0u;
  v12[29] = 0u;
  v12[26] = 0u;
  v12[27] = 0u;
  v12[24] = 0u;
  v12[25] = 0u;
  v12[22] = 0u;
  v12[23] = 0u;
  v12[20] = 0u;
  v12[21] = 0u;
  v12[18] = 0u;
  v12[19] = 0u;
  v12[16] = 0u;
  v12[17] = 0u;
  v12[14] = 0u;
  v12[15] = 0u;
  v12[12] = 0u;
  v12[13] = 0u;
  v12[10] = 0u;
  v12[11] = 0u;
  v12[8] = 0u;
  v12[9] = 0u;
  v12[6] = 0u;
  v12[7] = 0u;
  v12[4] = 0u;
  v12[5] = 0u;
  v12[2] = 0u;
  v12[3] = 0u;
  *v12 = 0u;
  v12[1] = 0u;
  v13 = *(_OWORD **)(a1 + 160);
  v13[30] = 0u;
  v13[31] = 0u;
  v13[28] = 0u;
  v13[29] = 0u;
  v13[26] = 0u;
  v13[27] = 0u;
  v13[24] = 0u;
  v13[25] = 0u;
  v13[22] = 0u;
  v13[23] = 0u;
  v13[20] = 0u;
  v13[21] = 0u;
  v13[18] = 0u;
  v13[19] = 0u;
  v13[16] = 0u;
  v13[17] = 0u;
  v13[14] = 0u;
  v13[15] = 0u;
  v13[12] = 0u;
  v13[13] = 0u;
  v13[10] = 0u;
  v13[11] = 0u;
  v13[8] = 0u;
  v13[9] = 0u;
  v13[6] = 0u;
  v13[7] = 0u;
  v13[4] = 0u;
  v13[5] = 0u;
  v13[2] = 0u;
  v13[3] = 0u;
  *v13 = 0u;
  v13[1] = 0u;
  v14 = *(_OWORD **)(a1 + 168);
  v14[30] = 0u;
  v14[31] = 0u;
  v14[28] = 0u;
  v14[29] = 0u;
  v14[26] = 0u;
  v14[27] = 0u;
  v14[24] = 0u;
  v14[25] = 0u;
  v14[22] = 0u;
  v14[23] = 0u;
  v14[20] = 0u;
  v14[21] = 0u;
  v14[18] = 0u;
  v14[19] = 0u;
  v14[16] = 0u;
  v14[17] = 0u;
  v14[14] = 0u;
  v14[15] = 0u;
  v14[12] = 0u;
  v14[13] = 0u;
  v14[10] = 0u;
  v14[11] = 0u;
  v14[8] = 0u;
  v14[9] = 0u;
  v14[6] = 0u;
  v14[7] = 0u;
  v14[4] = 0u;
  v14[5] = 0u;
  v14[2] = 0u;
  v14[3] = 0u;
  *v14 = 0u;
  v14[1] = 0u;
  v15 = *(_OWORD **)(a1 + 176);
  v15[30] = 0u;
  v15[31] = 0u;
  v15[28] = 0u;
  v15[29] = 0u;
  v15[26] = 0u;
  v15[27] = 0u;
  v15[24] = 0u;
  v15[25] = 0u;
  v15[22] = 0u;
  v15[23] = 0u;
  v15[20] = 0u;
  v15[21] = 0u;
  v15[18] = 0u;
  v15[19] = 0u;
  v15[16] = 0u;
  v15[17] = 0u;
  v15[14] = 0u;
  v15[15] = 0u;
  v15[12] = 0u;
  v15[13] = 0u;
  v15[10] = 0u;
  v15[11] = 0u;
  v15[8] = 0u;
  v15[9] = 0u;
  v15[6] = 0u;
  v15[7] = 0u;
  v15[4] = 0u;
  v15[5] = 0u;
  v15[2] = 0u;
  v15[3] = 0u;
  *v15 = 0u;
  v15[1] = 0u;
  v16 = *(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(v16 + 2720))
  {
    v17 = *(_DWORD *)(v16 + 3396);
  }
  else
  {
    if (a3[1] - *a3 <= 8uLL)
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    v17 = *(_DWORD *)(*a3 + 8);
    *(_DWORD *)(v16 + 3396) = v17;
    if (v17 < 1)
      goto LABEL_58;
    LODWORD(v18) = v17 << 9;
    v19 = *a2;
    v20 = *(_WORD **)(a1 + 184);
    if (v17 << 9 <= 1)
      v18 = 1;
    else
      v18 = v18;
    do
    {
      v21 = *v19++;
      _S0 = v21;
      __asm { FCVT            H0, S0 }
      *v20++ = _S0;
      --v18;
    }
    while (v18);
  }
  if (v17 >= 1)
  {
    v245 = v6;
    v27 = 0;
    v28 = 0;
    v257 = (float32x4_t)vdupq_n_s32(0x3F523BE9u);
    v258 = (float32x4_t)vdupq_n_s32(0x401D2709u);
    v255 = (float32x4_t)vdupq_n_s32(0x401C7BF8u);
    v256 = (float32x4_t)vdupq_n_s32(0x3F64AAB6u);
    v29 = -1;
    v254 = (float32x4_t)vdupq_n_s32(0x3F508C6Du);
    __asm { FMOV            V0.4S, #1.0 }
    v273 = _Q0;
    v248 = (float16x8_t)vdupq_n_s16(0x2E66u);
    v249 = (float16x8_t)vdupq_n_s16(0x3B33u);
    do
    {
      v31 = 2 * v27;
      v246 = v28;
      v247 = v27;
      if (*(_BYTE *)(v16 + 2720))
      {
        v32 = 0;
        v33 = *(_QWORD *)(v16 + 3360);
        v34 = *(_QWORD *)(a1 + 160);
        v35 = *(_QWORD *)(a1 + 200);
        v36 = v33 + v31 + 48;
        do
        {
          v37 = (_OWORD *)(v35 + v32);
          v38 = *(_OWORD *)(v36 + v32 - 32);
          v39 = *(_OWORD *)(v36 + v32 - 16);
          v40 = *(_OWORD *)(v36 + v32);
          *v37 = *(_OWORD *)(v36 + v32 - 48);
          v37[1] = v38;
          v37[2] = v39;
          v37[3] = v40;
          v32 += 64;
        }
        while (v32 != 1024);
        v41 = 0;
        v42 = v35 + 1024;
        v43 = v34 + 48;
        do
        {
          v44 = (float16x8_t *)(v42 + v41);
          v45 = *(float16x8_t *)(v43 + v41 - 48);
          v46 = *(float16x8_t *)(v43 + v41 - 32);
          v47 = *(float16x8_t *)(v43 + v41 - 16);
          v48 = *(float16x8_t *)(v43 + v41);
          *v44 = v45;
          v44[1] = v46;
          v44[2] = v47;
          v44[3] = v48;
          v41 += 64;
        }
        while (v41 != 512);
      }
      else
      {
        v49 = 0;
        v50 = *(_QWORD *)(a1 + 160);
        v51 = *(_QWORD *)(a1 + 200);
        v52 = *(_QWORD *)(a1 + 184) + v31 + 48;
        do
        {
          v53 = (_OWORD *)(v51 + v49);
          v54 = *(_OWORD *)(v52 + v49 - 32);
          v55 = *(_OWORD *)(v52 + v49 - 16);
          v56 = *(_OWORD *)(v52 + v49);
          *v53 = *(_OWORD *)(v52 + v49 - 48);
          v53[1] = v54;
          v53[2] = v55;
          v53[3] = v56;
          v49 += 64;
        }
        while (v49 != 1024);
        v57 = 0;
        v58 = v51 + 1024;
        v59 = v50 + 48;
        do
        {
          v60 = (float16x8_t *)(v58 + v57);
          v45 = *(float16x8_t *)(v59 + v57 - 48);
          v61 = *(float16x8_t *)(v59 + v57 - 32);
          v62 = *(float16x8_t *)(v59 + v57 - 16);
          v63 = *(float16x8_t *)(v59 + v57);
          *v60 = v45;
          v60[1] = v61;
          v60[2] = v62;
          v60[3] = v63;
          v57 += 64;
        }
        while (v57 != 512);
      }
      NeonLSTMManager::neon_matmul_conv(v45, v11, *(float16x8_t **)(a1 + 120), *(_QWORD *)(a1 + 128), *(float16x8_t **)(a1 + 200), *(_QWORD *)(a1 + 208), 0x300u, 0x400u);
      v64 = 0;
      v65 = *(_QWORD *)(a1 + 208);
      v66 = *(_QWORD *)(a1 + 152);
      do
      {
        v67 = vcvtq_f32_f16(*(float16x4_t *)(v65 + v64 + 512));
        v68 = vabsq_f32(v67);
        v69 = vmulq_f32(v67, v67);
        v250 = vdivq_f32(vmulq_f32(vmlaq_f32(vmlaq_f32(v258, v258, v68), v69, vmlaq_f32(v256, v257, v68)), v67), vmlaq_f32(v255, vabsq_f32(vmlaq_f32(v67, v68, vmulq_f32(v67, v254))), vaddq_f32(v69, v255)));
        v269 = vnegq_f32(vcvtq_f32_f16(*(float16x4_t *)(v65 + v64)));
        v259 = expf(v269.f32[1]);
        v70.f32[0] = expf(v269.f32[0]);
        v70.f32[1] = v259;
        v260 = v70;
        v71 = expf(v269.f32[2]);
        v72 = v260;
        v72.f32[2] = v71;
        v261 = v72;
        v73 = expf(v269.f32[3]);
        v74 = v261;
        v74.f32[3] = v73;
        *(float16x4_t *)&v279[v64 + 2560] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v273, vaddq_f32(v74, v273)), v250));
        v251 = vcvtq_f32_f16(*(float16x4_t *)(v66 + v64));
        v270 = vnegq_f32(vaddq_f32(vcvtq_f32_f16(*(float16x4_t *)(v65 + v64 + 1024)), v273));
        v261.i32[0] = expf(v270.f32[1]);
        v75.f32[0] = expf(v270.f32[0]);
        v75.i32[1] = v261.i32[0];
        v262 = v75;
        v76 = expf(v270.f32[2]);
        v77 = v262;
        v77.f32[2] = v76;
        v263 = v77;
        v78 = expf(v270.f32[3]);
        v79 = v263;
        v79.f32[3] = v78;
        *(float16x4_t *)&v279[v64 + 2048] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v273, vaddq_f32(v79, v273)), v251));
        v64 += 8;
      }
      while (v64 != 512);
      v80 = -512;
      do
      {
        v81 = *(float16x8_t *)&v281[v80 / 8 + 2];
        v82 = *(float16x8_t *)&v281[v80 / 8 + 4];
        v83 = *(float16x8_t *)&v279[v80 + 2592];
        v84 = *(float16x8_t *)&v279[v80 + 2608];
        v85 = (float16x8_t *)(*(_QWORD *)(a1 + 152) + v80);
        v86 = v85[32];
        v87 = v85[33];
        v88 = v85[34];
        v89 = v85[35];
        v90 = vaddq_f16(*(float16x8_t *)&v279[v80 + 3072], *(float16x8_t *)&v279[v80 + 2560]);
        v91 = &v279[v80 + 1536];
        v92 = vaddq_f16(*(float16x8_t *)&v281[v80 / 8], *(float16x8_t *)&v279[v80 + 2576]);
        v91[32] = v90;
        v91[33] = v92;
        v93 = vaddq_f16(v81, v83);
        v94 = vaddq_f16(v82, v84);
        v91[34] = v93;
        v91[35] = v94;
        v85[32] = vaddq_f16(vmulq_f16(v90, v249), vmulq_f16(v86, v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 152) + v80 + 528) = vaddq_f16(vmulq_f16(v92, v249), vmulq_f16(v87, v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 152) + v80 + 544) = vaddq_f16(vmulq_f16(v93, v249), vmulq_f16(v88, v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 152) + v80 + 560) = vaddq_f16(vmulq_f16(v94, v249), vmulq_f16(v89, v248));
        v80 += 64;
      }
      while (v80);
      v95 = 0;
      v96 = *(_QWORD *)(a1 + 192) + v31;
      v97 = *(_QWORD *)(a1 + 208) + 1536;
      do
      {
        _H0 = *(_WORD *)&v279[v95 + 1536];
        __asm { FCVT            S0, H0 }
        v100 = fabsf(_S0);
        v101 = (float)((float)((float)((float)(v100 * 2.4555) + 2.4555)
                             + (float)((float)((float)(v100 * 0.82123) + 0.89323) * (float)(_S0 * _S0)))
                     * _S0)
             / (float)((float)((float)((float)(_S0 * _S0) + 2.4451) * fabsf(_S0 + (float)((float)(_S0 * 0.81464) * v100)))
                     + 2.4451);
        LOWORD(_S0) = *(_WORD *)(v97 + v95);
        __asm { FCVT            S0, H0 }
        _S0 = v101 * (float)(1.0 / (float)(expf(-_S0) + 1.0));
        __asm { FCVT            H0, S0 }
        *(_WORD *)(v96 + v95) = LOWORD(_S0);
        v95 += 2;
      }
      while (v95 != 512);
      v105 = -512;
      do
      {
        v106 = (float16x8_t *)(*(_QWORD *)(a1 + 192) + v31 + v105);
        v107 = v106[32];
        v108 = v106[33];
        v109 = v106[34];
        v110 = v106[35];
        v111 = (float16x8_t *)(*(_QWORD *)(a1 + 160) + v105);
        v112 = v111[33];
        v113 = v111[34];
        v114 = v111[35];
        v111[32] = vaddq_f16(vmulq_f16(v107, v249), vmulq_f16(v111[32], v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 160) + v105 + 528) = vaddq_f16(vmulq_f16(v108, v249), vmulq_f16(v112, v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 160) + v105 + 544) = vaddq_f16(vmulq_f16(v109, v249), vmulq_f16(v113, v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 160) + v105 + 560) = vaddq_f16(vmulq_f16(v110, v249), vmulq_f16(v114, v248));
        v105 += 64;
      }
      while (v105);
      v115 = *(_QWORD *)(a1 + 24);
      v116 = *(_DWORD *)(v115 + 3396);
      if (*(_BYTE *)(v115 + 2720))
      {
        v117 = 0;
        v118 = *(_QWORD *)(v115 + 3360);
        v119 = *(_QWORD *)(a1 + 176);
        v120 = *(_QWORD *)(a1 + 200);
        v121 = v118 + 2 * ((v116 + v29) << 9) + 48;
        do
        {
          v122 = (_OWORD *)(v120 + v117);
          v123 = *(_OWORD *)(v121 + v117 - 32);
          v124 = *(_OWORD *)(v121 + v117 - 16);
          v125 = *(_OWORD *)(v121 + v117);
          *v122 = *(_OWORD *)(v121 + v117 - 48);
          v122[1] = v123;
          v122[2] = v124;
          v122[3] = v125;
          v117 += 64;
        }
        while (v117 != 1024);
        v126 = 0;
        v127 = v120 + 1024;
        v128 = v119 + 48;
        do
        {
          v129 = (float16x8_t *)(v127 + v126);
          v130 = *(float16x8_t *)(v128 + v126 - 48);
          v131 = *(float16x8_t *)(v128 + v126 - 32);
          v132 = *(float16x8_t *)(v128 + v126 - 16);
          v133 = *(float16x8_t *)(v128 + v126);
          *v129 = v130;
          v129[1] = v131;
          v129[2] = v132;
          v129[3] = v133;
          v126 += 64;
        }
        while (v126 != 512);
      }
      else
      {
        v134 = 0;
        v135 = *(_QWORD *)(a1 + 176);
        v136 = *(_QWORD *)(a1 + 200);
        v137 = *(_QWORD *)(a1 + 184) + 2 * ((v116 + v29) << 9) + 48;
        do
        {
          v138 = (_OWORD *)(v136 + v134);
          v139 = *(_OWORD *)(v137 + v134 - 32);
          v140 = *(_OWORD *)(v137 + v134 - 16);
          v141 = *(_OWORD *)(v137 + v134);
          *v138 = *(_OWORD *)(v137 + v134 - 48);
          v138[1] = v139;
          v138[2] = v140;
          v138[3] = v141;
          v134 += 64;
        }
        while (v134 != 1024);
        v142 = 0;
        v143 = v136 + 1024;
        v144 = v135 + 48;
        do
        {
          v145 = (float16x8_t *)(v143 + v142);
          v130 = *(float16x8_t *)(v144 + v142 - 48);
          v146 = *(float16x8_t *)(v144 + v142 - 32);
          v147 = *(float16x8_t *)(v144 + v142 - 16);
          v148 = *(float16x8_t *)(v144 + v142);
          *v145 = v130;
          v145[1] = v146;
          v145[2] = v147;
          v145[3] = v148;
          v142 += 64;
        }
        while (v142 != 512);
      }
      NeonLSTMManager::neon_matmul_conv(v130, v103, *(float16x8_t **)(a1 + 136), *(_QWORD *)(a1 + 144), *(float16x8_t **)(a1 + 200), *(_QWORD *)(a1 + 208), 0x300u, 0x400u);
      v149 = 0;
      v150 = *(_QWORD *)(a1 + 208);
      v151 = *(_QWORD *)(a1 + 168);
      do
      {
        v152 = vcvtq_f32_f16(*(float16x4_t *)(v150 + v149 + 512));
        v153 = vabsq_f32(v152);
        v154 = vmulq_f32(v152, v152);
        v252 = vdivq_f32(vmulq_f32(vmlaq_f32(vmlaq_f32(v258, v258, v153), v154, vmlaq_f32(v256, v257, v153)), v152), vmlaq_f32(v255, vabsq_f32(vmlaq_f32(v152, v153, vmulq_f32(v152, v254))), vaddq_f32(v154, v255)));
        v271 = vnegq_f32(vcvtq_f32_f16(*(float16x4_t *)(v150 + v149)));
        v264 = expf(v271.f32[1]);
        v155.f32[0] = expf(v271.f32[0]);
        v155.f32[1] = v264;
        v265 = v155;
        v156 = expf(v271.f32[2]);
        v157 = v265;
        v157.f32[2] = v156;
        v266 = v157;
        v158 = expf(v271.f32[3]);
        v159 = v266;
        v159.f32[3] = v158;
        *(float16x4_t *)&v279[v149 + 1024] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v273, vaddq_f32(v159, v273)), v252));
        v253 = vcvtq_f32_f16(*(float16x4_t *)(v151 + v149));
        v272 = vnegq_f32(vaddq_f32(vcvtq_f32_f16(*(float16x4_t *)(v150 + v149 + 1024)), v273));
        v266.i32[0] = expf(v272.f32[1]);
        v160.f32[0] = expf(v272.f32[0]);
        v160.i32[1] = v266.i32[0];
        v267 = v160;
        v161 = expf(v272.f32[2]);
        v162 = v267;
        v162.f32[2] = v161;
        v268 = v162;
        v163 = expf(v272.f32[3]);
        v164 = v268;
        v164.f32[3] = v163;
        *(float16x4_t *)&v279[v149 + 512] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v273, vaddq_f32(v164, v273)), v253));
        v149 += 8;
      }
      while (v149 != 512);
      v165 = -512;
      do
      {
        v166 = *(float16x8_t *)&v279[v165 + 1568];
        v167 = *(float16x8_t *)&v279[v165 + 1584];
        v168 = *(float16x8_t *)&v279[v165 + 1056];
        v169 = *(float16x8_t *)&v279[v165 + 1072];
        v170 = (float16x8_t *)(*(_QWORD *)(a1 + 168) + v165);
        v171 = v170[32];
        v172 = v170[33];
        v173 = v170[34];
        v174 = v170[35];
        v175 = vaddq_f16(*(float16x8_t *)&v279[v165 + 1536], *(float16x8_t *)&v279[v165 + 1024]);
        v176 = &v279[v165];
        v177 = vaddq_f16(*(float16x8_t *)&v279[v165 + 1552], *(float16x8_t *)&v279[v165 + 1040]);
        v176[32] = v175;
        v176[33] = v177;
        v178 = vaddq_f16(v166, v168);
        v179 = vaddq_f16(v167, v169);
        v176[34] = v178;
        v176[35] = v179;
        v170[32] = vaddq_f16(vmulq_f16(v175, v249), vmulq_f16(v171, v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 168) + v165 + 528) = vaddq_f16(vmulq_f16(v177, v249), vmulq_f16(v172, v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 168) + v165 + 544) = vaddq_f16(vmulq_f16(v178, v249), vmulq_f16(v173, v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 168) + v165 + 560) = vaddq_f16(vmulq_f16(v179, v249), vmulq_f16(v174, v248));
        v165 += 64;
      }
      while (v165);
      v180 = 0;
      v181 = *(_QWORD *)(a1 + 208) + 1536;
      v182 = *(_QWORD *)(a1 + 192) + 2 * ((v116 + v29) << 9) + 512;
      do
      {
        _H0 = *(_WORD *)&v279[v180];
        __asm { FCVT            S0, H0 }
        v185 = fabsf(_S0);
        v186 = (float)((float)((float)((float)(v185 * 2.4555) + 2.4555)
                             + (float)((float)((float)(v185 * 0.82123) + 0.89323) * (float)(_S0 * _S0)))
                     * _S0)
             / (float)((float)((float)((float)(_S0 * _S0) + 2.4451) * fabsf(_S0 + (float)((float)(_S0 * 0.81464) * v185)))
                     + 2.4451);
        LOWORD(_S0) = *(_WORD *)(v181 + v180);
        __asm { FCVT            S0, H0 }
        _S0 = v186 * (float)(1.0 / (float)(expf(-_S0) + 1.0));
        __asm { FCVT            H0, S0 }
        *(_WORD *)(v182 + v180) = LOWORD(_S0);
        v180 += 2;
      }
      while (v180 != 512);
      v189 = -512;
      do
      {
        v190 = (float16x8_t *)(*(_QWORD *)(a1 + 192) + 2 * ((v116 + v29) << 9) + v189);
        v191 = v190[64];
        v192 = v190[65];
        v193 = v190[66];
        v194 = v190[67];
        v195 = (float16x8_t *)(*(_QWORD *)(a1 + 176) + v189);
        v196 = v195[33];
        v197 = v195[34];
        v198 = v195[35];
        v195[32] = vaddq_f16(vmulq_f16(v191, v249), vmulq_f16(v195[32], v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 176) + v189 + 528) = vaddq_f16(vmulq_f16(v192, v249), vmulq_f16(v196, v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 176) + v189 + 544) = vaddq_f16(vmulq_f16(v193, v249), vmulq_f16(v197, v248));
        *(float16x8_t *)(*(_QWORD *)(a1 + 176) + v189 + 560) = vaddq_f16(vmulq_f16(v194, v249), vmulq_f16(v198, v248));
        v189 += 64;
      }
      while (v189);
      v28 = v246 + 1;
      v16 = *(_QWORD *)(a1 + 24);
      v199 = *(int *)(v16 + 3396);
      v27 = v247 + 512;
      --v29;
    }
    while (v246 + 1 < v199);
    if ((int)v199 < 1)
    {
      v6 = v245;
    }
    else
    {
      LODWORD(v200) = (_DWORD)v199 << 9;
      v201 = *(__int16 **)(a1 + 192);
      v202 = *(_DWORD **)(v16 + 3320);
      if ((int)v200 <= 1)
        v200 = 1;
      else
        v200 = v200;
      v6 = v245;
      do
      {
        v203 = *v201++;
        _H0 = v203;
        __asm { FCVT            S0, H0 }
        *v202++ = _S0;
        --v200;
      }
      while (v200);
    }
  }
LABEL_58:
  v206 = (_QWORD *)a5[1];
  v207 = a5[2];
  if ((unint64_t)v206 >= v207)
  {
    v209 = (_QWORD *)*a5;
    v210 = ((uint64_t)v206 - *a5) >> 3;
    v211 = v210 + 1;
    if ((unint64_t)(v210 + 1) >> 61)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v212 = v207 - (_QWORD)v209;
    if (v212 >> 2 > v211)
      v211 = v212 >> 2;
    if ((unint64_t)v212 >= 0x7FFFFFFFFFFFFFF8)
      v213 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v213 = v211;
    v278 = a5 + 3;
    if (v213)
    {
      v214 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v213);
      v209 = (_QWORD *)*a5;
      v206 = (_QWORD *)a5[1];
    }
    else
    {
      v214 = 0;
    }
    v215 = (_QWORD *)(v214 + 8 * v210);
    *v215 = 1;
    if (v206 == v209)
    {
      v217 = v214 + 8 * v210;
    }
    else
    {
      v216 = v206;
      v217 = v214 + 8 * v210;
      do
      {
        v218 = *--v216;
        *(_QWORD *)(v217 - 8) = v218;
        v217 -= 8;
      }
      while (v216 != v209);
    }
    v208 = v215 + 1;
    *a5 = v217;
    a5[1] = (uint64_t)(v215 + 1);
    v219 = a5[2];
    a5[2] = v214 + 8 * v213;
    v276 = v206;
    v277 = v219;
    v274 = v209;
    v275 = v209;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v274);
    v16 = *(_QWORD *)(a1 + 24);
    v207 = a5[2];
  }
  else
  {
    *v206 = 1;
    v208 = v206 + 1;
  }
  a5[1] = (uint64_t)v208;
  v220 = *(int *)(v16 + 3396);
  if ((unint64_t)v208 >= v207)
  {
    v222 = (_QWORD *)*a5;
    v223 = ((uint64_t)v208 - *a5) >> 3;
    v224 = v223 + 1;
    if ((unint64_t)(v223 + 1) >> 61)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v225 = v207 - (_QWORD)v222;
    if (v225 >> 2 > v224)
      v224 = v225 >> 2;
    if ((unint64_t)v225 >= 0x7FFFFFFFFFFFFFF8)
      v226 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v226 = v224;
    v278 = a5 + 3;
    if (v226)
    {
      v227 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v226);
      v222 = (_QWORD *)*a5;
      v208 = (_QWORD *)a5[1];
    }
    else
    {
      v227 = 0;
    }
    v228 = (_QWORD *)(v227 + 8 * v223);
    *v228 = v220;
    if (v208 == v222)
    {
      v230 = v227 + 8 * v223;
    }
    else
    {
      v229 = v208;
      v230 = v227 + 8 * v223;
      do
      {
        v231 = *--v229;
        *(_QWORD *)(v230 - 8) = v231;
        v230 -= 8;
      }
      while (v229 != v222);
    }
    v221 = v228 + 1;
    *a5 = v230;
    a5[1] = (uint64_t)(v228 + 1);
    v232 = a5[2];
    a5[2] = v227 + 8 * v226;
    v276 = v208;
    v277 = v232;
    v274 = v222;
    v275 = v222;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v274);
    v207 = a5[2];
  }
  else
  {
    *v208 = v220;
    v221 = v208 + 1;
  }
  a5[1] = (uint64_t)v221;
  if ((unint64_t)v221 >= v207)
  {
    v234 = (_QWORD *)*a5;
    v235 = ((uint64_t)v221 - *a5) >> 3;
    v236 = v235 + 1;
    if ((unint64_t)(v235 + 1) >> 61)
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v237 = v207 - (_QWORD)v234;
    if (v237 >> 2 > v236)
      v236 = v237 >> 2;
    if ((unint64_t)v237 >= 0x7FFFFFFFFFFFFFF8)
      v238 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v238 = v236;
    v278 = a5 + 3;
    if (v238)
    {
      v239 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v238);
      v234 = (_QWORD *)*a5;
      v221 = (_QWORD *)a5[1];
    }
    else
    {
      v239 = 0;
    }
    v240 = (_QWORD *)(v239 + 8 * v235);
    *v240 = 512;
    if (v221 == v234)
    {
      v242 = v239 + 8 * v235;
    }
    else
    {
      v241 = v221;
      v242 = v239 + 8 * v235;
      do
      {
        v243 = *--v241;
        *(_QWORD *)(v242 - 8) = v243;
        v242 -= 8;
      }
      while (v241 != v234);
    }
    v233 = v240 + 1;
    *a5 = v242;
    a5[1] = (uint64_t)(v240 + 1);
    v244 = a5[2];
    a5[2] = v239 + 8 * v238;
    v276 = v221;
    v277 = v244;
    v274 = v234;
    v275 = v234;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v274);
  }
  else
  {
    *v221 = 512;
    v233 = v221 + 1;
  }
  a5[1] = (uint64_t)v233;
  std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(v6, *(char **)(*(_QWORD *)(a1 + 24) + 3320), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 3320) + ((uint64_t)*(int *)(*(_QWORD *)(a1 + 24) + 3396) << 11), (uint64_t)*(int *)(*(_QWORD *)(a1 + 24) + 3396) << 9);
}

_QWORD *NeonMemoryManager::NeonMemoryManager(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = CustomAllocator::mRsrc;
  a1[27] = 0;
  a1[26] = 0;
  a1[3] = a2;
  a1[4] = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 26, a3);
  *(_BYTE *)(a1[3] + 2722) = 0;
  return a1;
}

{
  a1[1] = 0;
  a1[2] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = CustomAllocator::mRsrc;
  a1[27] = 0;
  a1[26] = 0;
  a1[3] = a2;
  a1[4] = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 26, a3);
  *(_BYTE *)(a1[3] + 2722) = 0;
  return a1;
}

void NeonMemoryManager::~NeonMemoryManager(NeonMemoryManager *this)
{
  char *v2;

  v2 = (char *)this + 208;
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 26) + 56))(*((_QWORD *)this + 26), *((_QWORD *)this + 19));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 26) + 56))(*((_QWORD *)this + 26), *(_QWORD *)(*((_QWORD *)this + 3) + 3328));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 26) + 56))(*((_QWORD *)this + 26), *(_QWORD *)(*((_QWORD *)this + 3) + 3336));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 26) + 56))(*((_QWORD *)this + 26), *((_QWORD *)this + 20));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 26) + 56))(*((_QWORD *)this + 26), *(_QWORD *)(*((_QWORD *)this + 3) + 3368));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  if (*((char *)this + 55) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 7) + 8), *((_QWORD *)this + 4));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

uint64_t NeonMemoryManager::ModelNpy(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  const std::locale::facet *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  int v16;
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t i;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  _QWORD *v37;
  const std::locale::facet *v38;
  uint64_t v40[2];
  char v41;
  uint64_t v42;
  std::locale v43;
  void *v44;
  void *v45;
  uint64_t v46;
  char v47;
  uint64_t v48;
  void *v49;
  std::locale v50;
  void *v51;
  _QWORD v52[10];
  char v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _DWORD *v64;
  _DWORD *v65;
  uint64_t v66;
  uint64_t v67;

  v64 = 0;
  v65 = 0;
  v66 = 0;
  v67 = CustomAllocator::mRsrc;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v63 = CustomAllocator::mRsrc;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  v59 = CustomAllocator::mRsrc;
  v3 = (_QWORD *)(a2 + 16);
  v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a2 + 16), (uint64_t)"path: ", 6);
  v5 = *(char *)(a1 + 55);
  if (v5 >= 0)
    v6 = a1 + 32;
  else
    v6 = *(_QWORD *)(a1 + 32);
  if (v5 >= 0)
    v7 = *(unsigned __int8 *)(a1 + 55);
  else
    v7 = *(_QWORD *)(a1 + 40);
  v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, v6, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24)));
  v9 = std::locale::use_facet(&v50, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v50);
  std::ostream::put();
  std::ostream::flush();
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v50);
  v65 = v64;
  v57 = v56;
  v61 = v60;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v43);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v43, (uint64_t *)&v50);
  v43.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v44 = &unk_24D29B3B0;
  v49 = &unk_24D29B3D8;
  v45 = &unk_24D29B578;
  if (v47 < 0)
    heap_Free(*(_QWORD **)(v48 + 8), v46);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v49);
  v10 = *(char *)(a1 + 55);
  if (v10 >= 0)
    v11 = a1 + 32;
  else
    v11 = *(_QWORD *)(a1 + 32);
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a1 + 55);
  else
    v12 = *(_QWORD *)(a1 + 40);
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v51, v11, v12);
  v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"/fc/w", 5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"/npy", 4);
  v15 = *(_QWORD *)(a1 + 208);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v52, v40);
  (*(void (**)(uint64_t, uint64_t *, _DWORD **, uint64_t *, uint64_t))(*(_QWORD *)v15 + 24))(v15, v40, &v64, &v56, 1);
  if (v41 < 0)
    heap_Free(*(_QWORD **)(v42 + 8), v40[0]);
  v16 = *v64;
  v17 = *(_DWORD **)(a1 + 24);
  v17[845] = *v64;
  v17[844] = v16 - 512;
  v17[846] = v16;
  v17[847] = v16 + 768;
  v17[848] = v16 + 512;
  if (v57 == v56)
  {
    v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"error: memory layer", 19);
    std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(_QWORD *)(*v37 - 24)));
    v38 = std::locale::use_facet(&v43, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
    std::locale::~locale(&v43);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v18 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 208) + 32))(*(_QWORD *)(a1 + 208), 2 * (v16 << 7));
    v19 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 208) + 32))(*(_QWORD *)(a1 + 208), (uint64_t)*(int *)(*(_QWORD *)(a1 + 24) + 3380) << 8);
    *(_QWORD *)(a1 + 152) = v19;
    v20 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 3380);
    if ((int)v20 >= 1)
    {
      v21 = 0;
      v22 = 0;
      v23 = v56;
      v24 = (v57 - v56) >> 1;
      v25 = v18;
      do
      {
        for (i = 0; i != 128; ++i)
        {
          if (v24 <= v21 + i)
            std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
          *(_WORD *)(v25 + 2 * i) = *(_WORD *)(v23 + 2 * i);
        }
        ++v22;
        v25 += 256;
        v21 += 128;
        v23 += 256;
      }
      while (v22 != v20);
    }
    v27 = 0;
    v28 = 0;
    v29 = v18;
    do
    {
      if ((int)v20 >= 4)
      {
        v30 = 0;
        v31 = v29;
        do
        {
          v32 = 0;
          v33 = v31;
          do
          {
            v34 = 0;
            v35 = v28;
            v36 = v19 + 2 * v28;
            do
            {
              *(_WORD *)(v36 + 2 * v34) = *(_WORD *)(v33 + 2 * v34);
              ++v34;
            }
            while (v34 != 8);
            v28 = v35 + 8;
            ++v32;
            v33 += 256;
          }
          while (v32 != 4);
          ++v30;
          v31 += 1024;
          v28 = v35 + 8;
        }
        while (v30 != (int)v20 / 4);
        v28 = v35 + 8;
      }
      ++v27;
      v29 += 16;
    }
    while (v27 != 16);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 208) + 56))(*(_QWORD *)(a1 + 208), v18);
  }
  v50.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v55 = &unk_24D29B3D8;
  v51 = &unk_24D29B3B0;
  v52[0] = &unk_24D29B578;
  if (v53 < 0)
    heap_Free(*(_QWORD **)(v54 + 8), v52[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v55);
  v50.__locale_ = (std::locale::__imp *)&v56;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v50);
  v50.__locale_ = (std::locale::__imp *)&v60;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v50);
  v50.__locale_ = (std::locale::__imp *)&v64;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v50);
  return 1;
}

void sub_214E9B858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,std::locale a50)
{
  uint64_t v50;

  std::locale::~locale(&a14);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)&a50);
  *(_QWORD *)(v50 - 88) = v50 - 184;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v50 - 88));
  *(_QWORD *)(v50 - 184) = v50 - 152;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v50 - 184));
  *(_QWORD *)(v50 - 152) = v50 - 120;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v50 - 152));
  _Unwind_Resume(a1);
}

void NeonMemoryManager::neon_convert_f2h_column(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, int a6, int a7, unsigned int a8)
{
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  float32x4_t *v28;
  float32x4_t *v29;
  uint64_t v30;
  uint64_t v31;
  float32x4_t *v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t *v35;
  float32x4_t v36;
  float32x4_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float32x4_t *v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t *v43;
  float32x4_t v44;
  float32x4_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float32x4_t *v48;
  float32x4_t *v49;
  float16x8_t *v50;
  uint64_t v51;
  float32x4_t *v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t *v55;
  float32x4_t v56;
  float32x4_t v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t v60;
  float16x8_t v61;
  float32x4_t *v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t *v65;
  float32x4_t v66;
  float32x4_t v67;
  float16x8_t v68;
  float16x8_t v69;
  float32x4_t *v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t *v73;
  float32x4_t v74;
  float32x4_t v75;
  float16x8_t v76;
  float16x8_t v77;
  float16x8_t v78;
  float16x8_t v79;
  float32x4_t *v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t *v83;
  float32x4_t v84;
  float32x4_t v85;
  float16x8_t v86;
  float16x8_t v87;
  float16x8_t v88;
  float16x8_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;

  v8 = a4 >> 3;
  v9 = (a4 >> 3) / a8 * a7;
  v10 = v9 + (a4 >> 3) / a8;
  if (v9 < v10)
  {
    v11 = 8 * a4;
    v12 = v8 << 6;
    v13 = a3 + 2 * (int)(32 * v8);
    v14 = a4;
    v15 = 3 * a4;
    v16 = a2 + 4 * 8 * a4 * (a5 >> 3);
    v91 = v13;
    v92 = a2 + 16 * a4;
    v17 = v92 + 4 * 8 * a4 * (a5 >> 3);
    v18 = v12 * (a5 >> 3);
    v19 = 2 * a4;
    if (a5 >> 3 <= 1)
      v20 = 1;
    else
      v20 = a5 >> 3;
    v90 = v20;
    v21 = a3 + 2 * v18;
    v22 = a6 - 1;
    v23 = v13 + 2 * v18;
    do
    {
      if (a5 > 7)
      {
        v25 = 0;
        v26 = 0;
        v24 = 32 * v9;
        v27 = v90;
        do
        {
          v28 = (float32x4_t *)(a2 + 32 * v9 + 4 * v25);
          v29 = (float32x4_t *)(v92 + 32 * v9 + 4 * v25);
          v30 = a3 + ((uint64_t)v9 << 6) + 2 * v26 * v12;
          v31 = v91 + ((uint64_t)v9 << 6) + 2 * v26 * v12;
          v32 = (float32x4_t *)((char *)v28 + 4 * v14);
          v33 = *v32;
          v34 = v32[1];
          v35 = (float32x4_t *)((char *)v28 + 4 * v19);
          v36 = *v35;
          v37 = v35[1];
          v38 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v33), v34);
          v39 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v28 + 4 * v15)), *(float32x4_t *)((char *)v28 + 4 * v15 + 16));
          *(float16x8_t *)v30 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v28), v28[1]);
          *(float16x8_t *)(v30 + 16) = v38;
          *(float16x8_t *)(v30 + 32) = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v36), v37);
          *(float16x8_t *)(v30 + 48) = v39;
          v40 = (float32x4_t *)((char *)v29 + 4 * v14);
          v41 = *v40;
          v42 = v40[1];
          v43 = (float32x4_t *)((char *)v29 + 4 * v19);
          v44 = *v43;
          v45 = v43[1];
          v46 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v41), v42);
          v47 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v29 + 4 * v15)), *(float32x4_t *)((char *)v29 + 4 * v15 + 16));
          *(float16x8_t *)v31 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v29), v29[1]);
          *(float16x8_t *)(v31 + 16) = v46;
          *(float16x8_t *)(v31 + 32) = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v44), v45);
          *(float16x8_t *)(v31 + 48) = v47;
          ++v26;
          v25 += v11;
          --v27;
        }
        while (v27);
      }
      else
      {
        v24 = 32 * v9;
      }
      v48 = (float32x4_t *)(v16 + 32 * v9);
      v49 = (float32x4_t *)(v17 + 32 * v9);
      v50 = (float16x8_t *)(v21 + 2 * v24);
      v51 = v23 + 2 * v24;
      switch(v22)
      {
        case 0:
          v52 = (float32x4_t *)((char *)v48 + 4 * v14);
          v53 = *v52;
          v54 = v52[1];
          v55 = (float32x4_t *)((char *)v48 + 4 * v19);
          v56 = *v55;
          v57 = v55[1];
          v58 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v53), v54);
          v59 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v48 + 4 * v15)), *(float32x4_t *)((char *)v48 + 4 * v15 + 16));
          *v50 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v48), v48[1]);
          v50[1] = v58;
          v50[2] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v56), v57);
          v50[3] = v59;
          v60 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v49 + 4 * v14)), *(float32x4_t *)((char *)v49 + 4 * v14 + 16));
          v61 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v49 + 4 * v19)), *(float32x4_t *)((char *)v49 + 4 * v19 + 16));
          *(float16x8_t *)v51 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v49), v49[1]);
          *(float16x8_t *)(v51 + 16) = v60;
          *(float16x8_t *)(v51 + 32) = v61;
          *(_OWORD *)(v51 + 48) = 0uLL;
          break;
        case 1:
          v80 = (float32x4_t *)((char *)v48 + 4 * v14);
          v81 = *v80;
          v82 = v80[1];
          v83 = (float32x4_t *)((char *)v48 + 4 * v19);
          v84 = *v83;
          v85 = v83[1];
          v86 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v81), v82);
          v87 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v48 + 4 * v15)), *(float32x4_t *)((char *)v48 + 4 * v15 + 16));
          *v50 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v48), v48[1]);
          v50[1] = v86;
          v50[2] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v84), v85);
          v50[3] = v87;
          v88 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v49 + 4 * v14)), *(float32x4_t *)((char *)v49 + 4 * v14 + 16));
          *(float16x8_t *)v51 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v49), v49[1]);
          *(float16x8_t *)(v51 + 16) = v88;
          goto LABEL_16;
        case 2:
          v62 = (float32x4_t *)((char *)v48 + 4 * v14);
          v63 = *v62;
          v64 = v62[1];
          v65 = (float32x4_t *)((char *)v48 + 4 * v19);
          v66 = *v65;
          v67 = v65[1];
          v68 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v63), v64);
          v69 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v48 + 4 * v15)), *(float32x4_t *)((char *)v48 + 4 * v15 + 16));
          *v50 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v48), v48[1]);
          v50[1] = v68;
          v50[2] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v66), v67);
          v50[3] = v69;
          *(float16x8_t *)v51 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v49), v49[1]);
          *(_OWORD *)(v51 + 16) = 0uLL;
LABEL_16:
          *(_OWORD *)(v51 + 32) = 0uLL;
          *(_OWORD *)(v51 + 48) = 0uLL;
          break;
        case 3:
          v70 = (float32x4_t *)((char *)v48 + 4 * v14);
          v71 = *v70;
          v72 = v70[1];
          v73 = (float32x4_t *)((char *)v48 + 4 * v19);
          v74 = *v73;
          v75 = v73[1];
          v76 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v71), v72);
          v77 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v48 + 4 * v15)), *(float32x4_t *)((char *)v48 + 4 * v15 + 16));
          *v50 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v48), v48[1]);
          v50[1] = v76;
          v50[2] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v74), v75);
          v50[3] = v77;
          goto LABEL_21;
        case 4:
          v78 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v48 + 4 * v14)), *(float32x4_t *)((char *)v48 + 4 * v14 + 16));
          v79 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v48 + 4 * v19)), *(float32x4_t *)((char *)v48 + 4 * v19 + 16));
          *v50 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v48), v48[1]);
          v50[1] = v78;
          v50[2] = v79;
          goto LABEL_20;
        case 5:
          v89 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v48 + 4 * v14)), *(float32x4_t *)((char *)v48 + 4 * v14 + 16));
          *v50 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v48), v48[1]);
          v50[1] = v89;
          goto LABEL_19;
        case 6:
          *v50 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v48), v48[1]);
          v50[1] = 0uLL;
LABEL_19:
          v50[2] = 0uLL;
LABEL_20:
          v50[3] = 0uLL;
LABEL_21:
          *(_OWORD *)(v51 + 32) = 0uLL;
          *(_OWORD *)(v51 + 48) = 0uLL;
          *(_OWORD *)v51 = 0uLL;
          *(_OWORD *)(v51 + 16) = 0uLL;
          break;
        default:
          break;
      }
      ++v9;
    }
    while (v10 > v9);
  }
}

void NeonMemoryManager::neon_matmul_layer(uint64_t a1, uint64_t a2, float16x4_t *a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, int a8, int a9, unsigned int a10)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  uint64_t v26;
  float16x4_t *v27;
  uint64_t v28;
  float16x8_t *v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t *v52;
  float16x8_t *v53;

  if ((a8 + a7) >= 8)
  {
    v10 = 0;
    v11 = (a8 + a7) >> 3;
    LODWORD(v12) = a5 >> 3;
    v13 = (a6 >> 3) / a10;
    v14 = v13 * a9 + v13;
    v15 = (int)(a6 >> 3 << 6);
    if (a5 >> 3 <= 1)
      v12 = 1;
    else
      v12 = v12;
    v16 = 2 * (int)(32 * (a5 >> 3));
    do
    {
      if (v13 * a9 < v14)
      {
        v17 = v13 * a9;
        do
        {
          v18 = 0uLL;
          v19 = 0uLL;
          v20 = 0uLL;
          v21 = 0uLL;
          v22 = 0uLL;
          v23 = 0uLL;
          v24 = 0uLL;
          v25 = 0uLL;
          if (a5 >= 8)
          {
            v26 = 0;
            v27 = a3;
            v28 = v12;
            do
            {
              v29 = (float16x8_t *)(a2 + 2 * v17 * (int)((8 * a5) & 0xFFFFFFE0) + (v26 << 7));
              v30 = v29[1];
              v31 = *(float16x8_t *)v27[2].i8;
              v33 = *(float16x8_t *)v27[4].i8;
              v32 = *(float16x8_t *)v27[6].i8;
              v34 = v29[2];
              v35 = v29[3];
              v37 = *(float16x8_t *)&v27->i8[64 * (a5 >> 3)];
              v36 = *(float16x8_t *)&v27[2].i8[v16];
              v38 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v25, *v29, COERCE_SHORT_FLOAT(*(_OWORD *)v27->i8)), v30, *v27, 1), v34, *v27, 2), v35, *v27, 3);
              v39 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v24, *v29, *(short float *)v31.i16), v30, *(float16x4_t *)v31.i8, 1), v34, *(float16x4_t *)v31.i8, 2), v35, *(float16x4_t *)v31.i8, 3);
              v40 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v23, *v29, *(short float *)v33.i16), v30, *(float16x4_t *)v33.i8, 1), v34, *(float16x4_t *)v33.i8, 2), v35, *(float16x4_t *)v33.i8, 3);
              v41 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v22, *v29, *(short float *)v32.i16), v30, *(float16x4_t *)v32.i8, 1), v34, *(float16x4_t *)v32.i8, 2), v35, *(float16x4_t *)v32.i8, 3);
              v43 = *(float16x8_t *)&v27[4].i8[v16];
              v42 = *(float16x8_t *)&v27[6].i8[v16];
              v44 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v21, *v29, *(short float *)v37.i16), v30, *(float16x4_t *)v37.i8, 1), v34, *(float16x4_t *)v37.i8, 2), v35, *(float16x4_t *)v37.i8, 3);
              v45 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v20, *v29, *(short float *)v36.i16), v30, *(float16x4_t *)v36.i8, 1), v34, *(float16x4_t *)v36.i8, 2), v35, *(float16x4_t *)v36.i8, 3);
              v46 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v19, *v29, *(short float *)v43.i16), v30, *(float16x4_t *)v43.i8, 1), v34, *(float16x4_t *)v43.i8, 2), v35, *(float16x4_t *)v43.i8, 3);
              v47 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v18, *v29, *(short float *)v42.i16), v30, *(float16x4_t *)v42.i8, 1), v34, *(float16x4_t *)v42.i8, 2), v35, *(float16x4_t *)v42.i8, 3);
              v48 = v29[4];
              v49 = v29[5];
              v51 = v29[6];
              v50 = v29[7];
              v25 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v38, v48, *(float16x8_t *)v27->i8, 4), v49, *(float16x8_t *)v27->i8, 5), v51, *(float16x8_t *)v27->i8, 6), v50, *(float16x8_t *)v27->i8, 7);
              v24 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v39, v48, v31, 4), v49, v31, 5), v51, v31, 6), v50, v31, 7);
              v23 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v40, v48, v33, 4), v49, v33, 5), v51, v33, 6), v50, v33, 7);
              v22 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v41, v48, v32, 4), v49, v32, 5), v51, v32, 6), v50, v32, 7);
              v21 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v44, v48, v37, 4), v49, v37, 5), v51, v37, 6), v50, v37, 7);
              v20 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v45, v48, v36, 4), v49, v36, 5), v51, v36, 6), v50, v36, 7);
              v19 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v46, v48, v43, 4), v49, v43, 5), v51, v43, 6), v50, v43, 7);
              ++v26;
              v27 += 8;
              v18 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v47, v48, v42, 4), v49, v42, 5), v51, v42, 6), v50, v42, 7);
              --v28;
            }
            while (v28);
          }
          v52 = (float16x8_t *)(a4 + 2 * v10 * v15 + 64 * (_DWORD)v17);
          *v52 = v25;
          v52[1] = v24;
          v52[2] = v23;
          v52[3] = v22;
          v53 = (float16x8_t *)(a4 + 2 * (int)(32 * (a6 >> 3)) + 2 * v10 * v15 + 64 * (_DWORD)v17);
          *v53 = v21;
          v53[1] = v20;
          v53[2] = v19;
          v53[3] = v18;
          ++v17;
        }
        while (v14 > v17);
      }
      ++v10;
      a3 = (float16x4_t *)((char *)a3 + 2 * (int)(a5 >> 3 << 6));
    }
    while (v10 != v11);
  }
}

uint64_t NeonMemoryManager::SetUp(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  v2 = a1[3];
  if (*(_BYTE *)(v2 + 2304))
  {
    result = NeonTC2Container::EngineMCSetUp((NeonTC2Container *)v2, a1, 2, (void (*)(void *, int))mc_memory_do_inference);
    if (!(_DWORD)result)
      return result;
    v2 = a1[3];
  }
  *(_QWORD *)(a1[3] + 3328) = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[26] + 32))(a1[26], (uint64_t)*(int *)(v2 + 3380) << 13);
  v4 = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[26] + 32))(a1[26], 0x100000);
  v5 = a1[3];
  *(_QWORD *)(v5 + 3336) = v4;
  a1[20] = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[26] + 32))(a1[26], (uint64_t)*(int *)(v5 + 3380) << 12);
  *(_QWORD *)(a1[3] + 3368) = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[26] + 32))(a1[26], 0x80000);
  return 1;
}

uint64_t *mc_memory_do_inference(void *a1, int a2)
{
  uint64_t v4;
  _QWORD *v5;
  int v6;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *result;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t i;
  uint64_t *v36;
  _QWORD *v37;
  unint64_t v38;
  uint64_t *v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t *v55;
  _QWORD *v56;
  _QWORD *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  _QWORD *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  unint64_t v69;
  _QWORD *v70;
  _QWORD *v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _QWORD *v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  _QWORD *v83;
  _QWORD *v84;
  uint64_t v85;
  _QWORD *v86;

  if (a2)
  {
    v4 = *((_QWORD *)a1 + 3);
  }
  else
  {
    v5 = (_QWORD *)*((_QWORD *)a1 + 23);
    if (v5[1] - *v5 <= 8uLL)
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    v6 = *(_DWORD *)(*v5 + 8);
    v4 = *((_QWORD *)a1 + 3);
    *(_DWORD *)(v4 + 3396) = v6;
    _NF = -v6 < 0;
    v8 = -v6 & 7;
    v9 = v6 & 7;
    if (!_NF)
      v9 = -v8;
    if (v9)
      *((_DWORD *)a1 + 42) = 8 - v9;
    else
      *((_DWORD *)a1 + 42) = 0;
  }
  v10 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 2656) + 8))(*(_QWORD *)(v4 + 2656));
  NeonMemoryManager::neon_convert_f2h_column(v10, **((_QWORD **)a1 + 22), *((_QWORD *)a1 + 20), *(_DWORD *)(*((_QWORD *)a1 + 3) + 3380), *(_DWORD *)(*((_QWORD *)a1 + 3) + 3396), *((_DWORD *)a1 + 42), a2, *(_DWORD *)(*((_QWORD *)a1 + 3) + 2308));
  v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 3) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 3) + 2656));
  NeonMemoryManager::neon_matmul_layer(v11, *((_QWORD *)a1 + 19), *((float16x4_t **)a1 + 20), *(_QWORD *)(*((_QWORD *)a1 + 3) + 3368), *(_DWORD *)(*((_QWORD *)a1 + 3) + 3380), 0x80u, *(_DWORD *)(*((_QWORD *)a1 + 3) + 3396), *((_DWORD *)a1 + 42), a2, *(_DWORD *)(*((_QWORD *)a1 + 3) + 2308));
  result = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 3) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 3) + 2656));
  v13 = *((_QWORD *)a1 + 3);
  if (!*(_BYTE *)(v13 + 2723))
  {
    v14 = *(int *)(v13 + 3396);
    v15 = *((_DWORD *)a1 + 42) + v14;
    if (v15 >= 4)
    {
      v16 = 0;
      v17 = v15 >> 2;
      v18 = 16 / *(_DWORD *)(v13 + 2308);
      v19 = v18 * a2;
      v20 = v18 * a2;
      v21 = v18 + v18 * a2;
      v22 = 8 * v19;
      v23 = 32 * v19;
      do
      {
        if ((int)v20 < (int)v21)
        {
          v24 = v23;
          v25 = v22;
          v26 = v20;
          do
          {
            v27 = 0;
            v28 = 2 * v24;
            v29 = v25;
            do
            {
              for (i = 0; i != 8; ++i)
              {
                if (v27 + 4 * v16 < v14)
                {
                  _H0 = *(_WORD *)(*(_QWORD *)(v13 + 3368) + v28 + 2 * i);
                  __asm { FCVT            S0, H0 }
                  *(_DWORD *)(*(_QWORD *)(v13 + 3336) + 4 * v29 + 4 * i) = _S0;
                }
              }
              ++v27;
              v29 += 128;
              v28 += 16;
            }
            while (v27 != 4);
            ++v26;
            v25 += 8;
            v24 += 32;
          }
          while (v26 != v21);
        }
        ++v16;
        v22 += 512;
        v23 += 512;
      }
      while (v16 != v17);
    }
    result = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v13 + 2656) + 8))(*(_QWORD *)(v13 + 2656));
    if (!a2)
    {
      v36 = (uint64_t *)*((_QWORD *)a1 + 25);
      v37 = (_QWORD *)v36[1];
      v38 = v36[2];
      if ((unint64_t)v37 >= v38)
      {
        v41 = (_QWORD *)*v36;
        v42 = ((uint64_t)v37 - *v36) >> 3;
        v43 = v42 + 1;
        if ((unint64_t)(v42 + 1) >> 61)
          goto LABEL_77;
        v44 = v38 - (_QWORD)v41;
        if (v44 >> 2 > v43)
          v43 = v44 >> 2;
        if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8)
          v45 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v45 = v43;
        v86 = v36 + 3;
        if (v45)
        {
          v46 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v36 + 3), v45);
          v41 = (_QWORD *)*v36;
          v37 = (_QWORD *)v36[1];
        }
        else
        {
          v46 = 0;
        }
        v47 = (_QWORD *)(v46 + 8 * v42);
        *v47 = 1;
        if (v37 == v41)
        {
          v49 = v46 + 8 * v42;
        }
        else
        {
          v48 = v37;
          v49 = v46 + 8 * v42;
          do
          {
            v50 = *--v48;
            *(_QWORD *)(v49 - 8) = v50;
            v49 -= 8;
          }
          while (v48 != v41);
        }
        v40 = v47 + 1;
        *v36 = v49;
        v82 = v41;
        v83 = v41;
        v36[1] = (uint64_t)(v47 + 1);
        v84 = v37;
        v51 = v36[2];
        v36[2] = v46 + 8 * v45;
        v85 = v51;
        std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v82);
        v39 = (uint64_t *)*((_QWORD *)a1 + 25);
      }
      else
      {
        *v37 = 1;
        v39 = v36;
        v40 = v37 + 1;
      }
      v36[1] = (uint64_t)v40;
      v52 = *(int *)(*((_QWORD *)a1 + 3) + 3396);
      v53 = (_QWORD *)v39[1];
      v54 = v39[2];
      if ((unint64_t)v53 >= v54)
      {
        v57 = (_QWORD *)*v39;
        v58 = ((uint64_t)v53 - *v39) >> 3;
        v59 = v58 + 1;
        if ((unint64_t)(v58 + 1) >> 61)
          std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
        v60 = v54 - (_QWORD)v57;
        if (v60 >> 2 > v59)
          v59 = v60 >> 2;
        if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8)
          v61 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v61 = v59;
        v86 = v39 + 3;
        if (v61)
        {
          v62 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v39 + 3), v61);
          v57 = (_QWORD *)*v39;
          v53 = (_QWORD *)v39[1];
        }
        else
        {
          v62 = 0;
        }
        v63 = (_QWORD *)(v62 + 8 * v58);
        *v63 = v52;
        if (v53 == v57)
        {
          v65 = v62 + 8 * v58;
        }
        else
        {
          v64 = v53;
          v65 = v62 + 8 * v58;
          do
          {
            v66 = *--v64;
            *(_QWORD *)(v65 - 8) = v66;
            v65 -= 8;
          }
          while (v64 != v57);
        }
        v56 = v63 + 1;
        *v39 = v65;
        v82 = v57;
        v83 = v57;
        v39[1] = (uint64_t)(v63 + 1);
        v84 = v53;
        v67 = v39[2];
        v39[2] = v62 + 8 * v61;
        v85 = v67;
        std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v82);
        v55 = (uint64_t *)*((_QWORD *)a1 + 25);
      }
      else
      {
        *v53 = v52;
        v55 = v39;
        v56 = v53 + 1;
      }
      v39[1] = (uint64_t)v56;
      v68 = (_QWORD *)v55[1];
      v69 = v55[2];
      if ((unint64_t)v68 < v69)
      {
        *v68 = 128;
        v70 = v68 + 1;
LABEL_74:
        v55[1] = (uint64_t)v70;
        return std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(*((uint64_t **)a1 + 24), *(char **)(*((_QWORD *)a1 + 3) + 3336), *(_QWORD *)(*((_QWORD *)a1 + 3) + 3336) + ((uint64_t)*(int *)(*((_QWORD *)a1 + 3) + 3396) << 9), (uint64_t)*(int *)(*((_QWORD *)a1 + 3) + 3396) << 7);
      }
      v71 = (_QWORD *)*v55;
      v72 = ((uint64_t)v68 - *v55) >> 3;
      v73 = v72 + 1;
      if (!((unint64_t)(v72 + 1) >> 61))
      {
        v74 = v69 - (_QWORD)v71;
        if (v74 >> 2 > v73)
          v73 = v74 >> 2;
        if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFF8)
          v75 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v75 = v73;
        v86 = v55 + 3;
        if (v75)
        {
          v76 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v55 + 3), v75);
          v71 = (_QWORD *)*v55;
          v68 = (_QWORD *)v55[1];
        }
        else
        {
          v76 = 0;
        }
        v77 = (_QWORD *)(v76 + 8 * v72);
        *v77 = 128;
        if (v68 == v71)
        {
          v79 = v76 + 8 * v72;
        }
        else
        {
          v78 = v68;
          v79 = v76 + 8 * v72;
          do
          {
            v80 = *--v78;
            *(_QWORD *)(v79 - 8) = v80;
            v79 -= 8;
          }
          while (v78 != v71);
        }
        v70 = v77 + 1;
        *v55 = v79;
        v82 = v71;
        v83 = v71;
        v55[1] = (uint64_t)(v77 + 1);
        v84 = v68;
        v81 = v55[2];
        v55[2] = v76 + 8 * v75;
        v85 = v81;
        std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v82);
        goto LABEL_74;
      }
LABEL_77:
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    }
  }
  return result;
}

void NeonMemoryManager::do_inference(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v8;
  signed int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t i;
  _QWORD *v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  _QWORD *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _QWORD *v75;

  v8 = *(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(v8 + 2304))
  {
    *(_QWORD *)(a1 + 176) = a2;
    *(_QWORD *)(a1 + 184) = a3;
    *(_QWORD *)(a1 + 192) = a4;
    *(_QWORD *)(a1 + 200) = a5;
    SynchroManager::cond_broadcast_on_entry((SynchroManager *)(v8 + 2312), *(_DWORD *)(v8 + 2308), 3);
    SynchroManager::cond_wait_less_on_exit((SynchroManager *)(*(_QWORD *)(a1 + 24) + 2312), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    return;
  }
  if (a3[1] - *a3 <= 8uLL)
    std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
  v9 = *(_DWORD *)(*a3 + 8);
  *(_DWORD *)(v8 + 3396) = v9;
  if (v9 <= 0)
    v10 = -(-v9 & 7);
  else
    v10 = v9 & 7;
  if (v10)
    v11 = 8 - v10;
  else
    v11 = 0;
  *(_DWORD *)(a1 + 168) = v11;
  NeonMemoryManager::neon_convert_f2h_column(a1, *a2, *(_QWORD *)(a1 + 160), *(_DWORD *)(v8 + 3380), v9, v11, 0, *(_DWORD *)(v8 + 2308));
  NeonMemoryManager::neon_matmul_layer(v12, *(_QWORD *)(a1 + 152), *(float16x4_t **)(a1 + 160), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 3368), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3380), 0x80u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396), *(_DWORD *)(a1 + 168), 0, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
  v13 = *(_QWORD *)(a1 + 24);
  if (!*(_BYTE *)(v13 + 2723))
  {
    v14 = *(_DWORD *)(v13 + 3396);
    v15 = *(_DWORD *)(a1 + 168) + v14;
    if (v15 >= 4)
    {
      v16 = 0;
      v17 = 0;
      v18 = v15 >> 2;
      do
      {
        v19 = 0;
        v20 = v16 >> 3;
        v21 = v16 >> 3;
        do
        {
          v22 = 0;
          v23 = v20;
          v24 = v21;
          do
          {
            for (i = 0; i != 8; ++i)
            {
              if (v22 + 4 * v17 < v14)
              {
                _H0 = *(_WORD *)(*(_QWORD *)(v13 + 3368) + 16 * (v23 & 0x1FFFFFFF) + 2 * i);
                __asm { FCVT            S0, H0 }
                *(_DWORD *)(*(_QWORD *)(v13 + 3336) + 32 * (v24 & 0x1FFFFFFF) + 4 * i) = _S0;
              }
            }
            ++v22;
            v24 += 16;
            ++v23;
          }
          while (v22 != 4);
          ++v19;
          LODWORD(v21) = v21 + 1;
          LODWORD(v20) = v20 + 4;
        }
        while (v19 != 16);
        ++v17;
        v16 += 512;
      }
      while (v17 != v18);
    }
    v32 = (_QWORD *)a5[1];
    v33 = a5[2];
    if ((unint64_t)v32 >= v33)
    {
      v35 = (_QWORD *)*a5;
      v36 = ((uint64_t)v32 - *a5) >> 3;
      v37 = v36 + 1;
      if ((unint64_t)(v36 + 1) >> 61)
        goto LABEL_76;
      v38 = v33 - (_QWORD)v35;
      if (v38 >> 2 > v37)
        v37 = v38 >> 2;
      if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8)
        v39 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v39 = v37;
      v75 = a5 + 3;
      if (v39)
      {
        v40 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v39);
        v35 = (_QWORD *)*a5;
        v32 = (_QWORD *)a5[1];
      }
      else
      {
        v40 = 0;
      }
      v41 = (_QWORD *)(v40 + 8 * v36);
      *v41 = 1;
      if (v32 == v35)
      {
        v43 = v40 + 8 * v36;
      }
      else
      {
        v42 = v32;
        v43 = v40 + 8 * v36;
        do
        {
          v44 = *--v42;
          *(_QWORD *)(v43 - 8) = v44;
          v43 -= 8;
        }
        while (v42 != v35);
      }
      v34 = v41 + 1;
      *a5 = v43;
      a5[1] = (uint64_t)(v41 + 1);
      v45 = a5[2];
      a5[2] = v40 + 8 * v39;
      v73 = v32;
      v74 = v45;
      v71 = v35;
      v72 = v35;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v71);
      v14 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396);
      v33 = a5[2];
    }
    else
    {
      *v32 = 1;
      v34 = v32 + 1;
    }
    a5[1] = (uint64_t)v34;
    v46 = v14;
    if ((unint64_t)v34 >= v33)
    {
      v48 = (_QWORD *)*a5;
      v49 = ((uint64_t)v34 - *a5) >> 3;
      v50 = v49 + 1;
      if ((unint64_t)(v49 + 1) >> 61)
        goto LABEL_76;
      v51 = v33 - (_QWORD)v48;
      if (v51 >> 2 > v50)
        v50 = v51 >> 2;
      if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8)
        v52 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v52 = v50;
      v75 = a5 + 3;
      if (v52)
      {
        v53 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v52);
        v48 = (_QWORD *)*a5;
        v34 = (_QWORD *)a5[1];
      }
      else
      {
        v53 = 0;
      }
      v54 = (_QWORD *)(v53 + 8 * v49);
      *v54 = v46;
      if (v34 == v48)
      {
        v56 = v53 + 8 * v49;
      }
      else
      {
        v55 = v34;
        v56 = v53 + 8 * v49;
        do
        {
          v57 = *--v55;
          *(_QWORD *)(v56 - 8) = v57;
          v56 -= 8;
        }
        while (v55 != v48);
      }
      v47 = v54 + 1;
      *a5 = v56;
      a5[1] = (uint64_t)(v54 + 1);
      v58 = a5[2];
      a5[2] = v53 + 8 * v52;
      v73 = v34;
      v74 = v58;
      v71 = v48;
      v72 = v48;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v71);
      v33 = a5[2];
    }
    else
    {
      *v34 = v14;
      v47 = v34 + 1;
    }
    a5[1] = (uint64_t)v47;
    if ((unint64_t)v47 < v33)
    {
      *v47 = 128;
      v59 = v47 + 1;
LABEL_73:
      a5[1] = (uint64_t)v59;
      std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a4, *(char **)(*(_QWORD *)(a1 + 24) + 3336), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 3336) + ((uint64_t)*(int *)(*(_QWORD *)(a1 + 24) + 3396) << 9), (uint64_t)*(int *)(*(_QWORD *)(a1 + 24) + 3396) << 7);
      return;
    }
    v60 = (_QWORD *)*a5;
    v61 = ((uint64_t)v47 - *a5) >> 3;
    v62 = v61 + 1;
    if (!((unint64_t)(v61 + 1) >> 61))
    {
      v63 = v33 - (_QWORD)v60;
      if (v63 >> 2 > v62)
        v62 = v63 >> 2;
      if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF8)
        v64 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v64 = v62;
      v75 = a5 + 3;
      if (v64)
      {
        v65 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v64);
        v60 = (_QWORD *)*a5;
        v47 = (_QWORD *)a5[1];
      }
      else
      {
        v65 = 0;
      }
      v66 = (_QWORD *)(v65 + 8 * v61);
      *v66 = 128;
      if (v47 == v60)
      {
        v68 = v65 + 8 * v61;
      }
      else
      {
        v67 = v47;
        v68 = v65 + 8 * v61;
        do
        {
          v69 = *--v67;
          *(_QWORD *)(v68 - 8) = v69;
          v68 -= 8;
        }
        while (v67 != v60);
      }
      v59 = v66 + 1;
      *a5 = v68;
      a5[1] = (uint64_t)(v66 + 1);
      v70 = a5[2];
      a5[2] = v65 + 8 * v64;
      v73 = v47;
      v74 = v70;
      v71 = v60;
      v72 = v60;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v71);
      goto LABEL_73;
    }
LABEL_76:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  }
}

uint64_t NeonDecoderManager::NeonDecoderManager(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 56) = CustomAllocator::mRsrc;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]((_QWORD *)(a1 + 576), a3);
  *(_DWORD *)(a1 + 64) = 80;
  *(_BYTE *)(*(_QWORD *)(a1 + 24) + 2723) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_QWORD *)(a1 + 536) = 0;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  return a1;
}

{
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 56) = CustomAllocator::mRsrc;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]((_QWORD *)(a1 + 576), a3);
  *(_DWORD *)(a1 + 64) = 80;
  *(_BYTE *)(*(_QWORD *)(a1 + 24) + 2723) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_QWORD *)(a1 + 536) = 0;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  return a1;
}

void NeonDecoderManager::~NeonDecoderManager(NeonDecoderManager *this)
{
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 33));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 34));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 38));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 35));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 36));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 39));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 40));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 41));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 42));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 43));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 44));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 45));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 47));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 48));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 49));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 52));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 53));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 54));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 55));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 61));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 62));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 63));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 64));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 65));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 67));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *(_QWORD *)(*((_QWORD *)this + 3) + 3344));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 19));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 20));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 21));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 22));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 32));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 31));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 23));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 72) + 56))(*((_QWORD *)this + 72), *((_QWORD *)this + 24));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 576);
  if (*((char *)this + 55) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 7) + 8), *((_QWORD *)this + 4));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

uint64_t NeonDecoderManager::ModelNpy(uint64_t a1, uint64_t a2)
{
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3;
  uint64_t i;
  _QWORD *v5;
  _QWORD *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t j;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  _QWORD *v37;
  const std::locale::facet *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  const std::locale::facet *v50;
  uint64_t v51;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v52;
  float v53;
  short float v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  _QWORD *v78;
  const std::locale::facet *v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  _QWORD *v90;
  const std::locale::facet *v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  _QWORD *v95;
  _QWORD *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t k;
  uint64_t v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  uint64_t v116;
  _QWORD *v117;
  const std::locale::facet *v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  _QWORD *v122;
  _QWORD *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  _QWORD *v129;
  const std::locale::facet *v130;
  int v131;
  uint64_t v132;
  uint64_t v133;
  _QWORD *v134;
  _QWORD *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  int v153;
  _QWORD *v154;
  const std::locale::facet *v155;
  int v156;
  uint64_t v157;
  uint64_t v158;
  _QWORD *v159;
  _QWORD *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  _QWORD *v166;
  const std::locale::facet *v167;
  int v168;
  uint64_t v169;
  uint64_t v170;
  _QWORD *v171;
  _QWORD *v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  unint64_t v176;
  uint64_t v177;
  uint64_t v178;
  unint64_t v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  int v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int v190;
  _QWORD *v191;
  const std::locale::facet *v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  _QWORD *v196;
  _QWORD *v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  unint64_t v203;
  _WORD *v204;
  uint64_t v205;
  _WORD *v206;
  unsigned int v207;
  int v208;
  int v209;
  int v210;
  uint64_t v211;
  unsigned int v212;
  uint64_t v213;
  unsigned int v214;
  uint64_t m;
  _QWORD *v216;
  _QWORD *v217;
  const std::locale::facet *v218;
  int v219;
  uint64_t v220;
  uint64_t v221;
  _QWORD *v222;
  _QWORD *v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  _QWORD *v229;
  const std::locale::facet *v230;
  int v231;
  uint64_t v232;
  uint64_t v233;
  _QWORD *v234;
  _QWORD *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  unint64_t v239;
  uint64_t v240;
  uint64_t v241;
  unint64_t v242;
  uint64_t v243;
  unint64_t v244;
  uint64_t v245;
  int v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  int v253;
  _QWORD *v254;
  const std::locale::facet *v255;
  int v256;
  uint64_t v257;
  uint64_t v258;
  _QWORD *v259;
  _QWORD *v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  _QWORD *v266;
  const std::locale::facet *v267;
  int v268;
  uint64_t v269;
  uint64_t v270;
  _QWORD *v271;
  _QWORD *v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  _QWORD *v278;
  const std::locale::facet *v279;
  int v280;
  uint64_t v281;
  uint64_t v282;
  _QWORD *v283;
  _QWORD *v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  unint64_t v292;
  uint64_t v293;
  uint64_t n;
  uint64_t v295;
  int v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  int v303;
  uint64_t v304;
  _QWORD *v305;
  const std::locale::facet *v306;
  int v307;
  uint64_t v308;
  uint64_t v309;
  _QWORD *v310;
  _QWORD *v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  _QWORD *v317;
  const std::locale::facet *v318;
  int v319;
  uint64_t v320;
  uint64_t v321;
  _QWORD *v322;
  _QWORD *v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  unint64_t v331;
  uint64_t v332;
  uint64_t ii;
  unint64_t v334;
  uint64_t v335;
  uint64_t v336;
  int v337;
  unint64_t v338;
  uint64_t v339;
  unsigned int v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  int v344;
  uint64_t v345;
  __int16 v346;
  _QWORD *v347;
  const std::locale::facet *v348;
  int v349;
  uint64_t v350;
  uint64_t v351;
  _QWORD *v352;
  _QWORD *v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  unint64_t v357;
  uint64_t v358;
  unint64_t v359;
  __int16 v360;
  _QWORD *v361;
  const std::locale::facet *v362;
  uint64_t v364[2];
  char v365;
  uint64_t v366;
  uint64_t v367[2];
  char v368;
  uint64_t v369;
  uint64_t v370[2];
  char v371;
  uint64_t v372;
  uint64_t v373[2];
  char v374;
  uint64_t v375;
  uint64_t v376[2];
  char v377;
  uint64_t v378;
  uint64_t v379[2];
  char v380;
  uint64_t v381;
  uint64_t v382[2];
  char v383;
  uint64_t v384;
  uint64_t v385[2];
  char v386;
  uint64_t v387;
  uint64_t v388[2];
  char v389;
  uint64_t v390;
  uint64_t v391[2];
  char v392;
  uint64_t v393;
  uint64_t v394[2];
  char v395;
  uint64_t v396;
  uint64_t v397[2];
  char v398;
  uint64_t v399;
  uint64_t v400[2];
  char v401;
  uint64_t v402;
  uint64_t v403[2];
  char v404;
  uint64_t v405;
  uint64_t v406[2];
  char v407;
  uint64_t v408;
  uint64_t v409[2];
  char v410;
  uint64_t v411;
  uint64_t v412[2];
  char v413;
  uint64_t v414;
  uint64_t v415[2];
  char v416;
  uint64_t v417;
  std::locale v418;
  void *v419;
  void *v420;
  uint64_t v421;
  char v422;
  uint64_t v423;
  _QWORD v424[19];
  std::locale v425;
  void *v426;
  _QWORD v427[10];
  char v428;
  uint64_t v429;
  void *v430;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;

  v440 = 0;
  v441 = 0;
  v442 = 0;
  v443 = CustomAllocator::mRsrc;
  v436 = 0;
  v437 = 0;
  v438 = 0;
  v439 = CustomAllocator::mRsrc;
  v432 = 0;
  v433 = 0;
  v434 = 0;
  v435 = CustomAllocator::mRsrc;
  v3 = 1234;
  v431.__x_[0] = 1234;
  for (i = 1; i != 624; ++i)
  {
    v3 = i + 1812433253 * (v3 ^ (v3 >> 30));
    v431.__x_[i] = v3;
  }
  v431.__i_ = 0;
  v5 = (_QWORD *)(a2 + 16);
  v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a2 + 16), (uint64_t)"path: ", 6);
  v7 = *(char *)(a1 + 55);
  if (v7 >= 0)
    v8 = a1 + 32;
  else
    v8 = *(_QWORD *)(a1 + 32);
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a1 + 55);
  else
    v9 = *(_QWORD *)(a1 + 40);
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, v8, v9);
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
  v11 = std::locale::use_facet(&v425, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v425);
  std::ostream::put();
  std::ostream::flush();
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v425);
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v12 = *(char *)(a1 + 55);
  if (v12 >= 0)
    v13 = a1 + 32;
  else
    v13 = *(_QWORD *)(a1 + 32);
  if (v12 >= 0)
    v14 = *(unsigned __int8 *)(a1 + 55);
  else
    v14 = *(_QWORD *)(a1 + 40);
  v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v13, v14);
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"/customdecoderstep/decoder/prenet/dense/1/mat", 45);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"/npy", 4);
  v17 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v415);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v17 + 24))(v17, v415, &v440, &v432, 1);
  if (v416 < 0)
    heap_Free(*(_QWORD **)(v417 + 8), v415[0]);
  if (v433 == v432)
  {
    v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: prenet first layer weight", 32);
    std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(_QWORD *)(*v37 - 24)));
    v38 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
    std::locale::~locale(&v418);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v18 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), (uint64_t)*(int *)(a1 + 64) << 9);
    v19 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), (uint64_t)*(int *)(a1 + 64) << 9);
    *(_QWORD *)(a1 + 264) = v19;
    v20 = *(unsigned int *)(a1 + 64);
    if ((int)v20 >= 1)
    {
      v21 = 0;
      v22 = 0;
      v23 = v432;
      v24 = (v433 - v432) >> 1;
      v25 = v18;
      do
      {
        for (j = 0; j != 256; ++j)
        {
          if (v24 <= v21 + j)
            std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
          *(_WORD *)(v25 + 2 * j) = *(_WORD *)(v23 + 2 * j);
        }
        ++v22;
        v25 += 512;
        v21 += 256;
        v23 += 512;
      }
      while (v22 != v20);
    }
    v27 = 0;
    v28 = 0;
    v29 = v18;
    do
    {
      if ((int)v20 >= 4)
      {
        v30 = 0;
        v31 = v29;
        do
        {
          v32 = 0;
          v33 = v31;
          do
          {
            v34 = 0;
            v35 = v28;
            v36 = v19 + 2 * v28;
            do
            {
              *(_WORD *)(v36 + 2 * v34) = *(_WORD *)(v33 + 2 * v34);
              ++v34;
            }
            while (v34 != 8);
            v28 = v35 + 8;
            ++v32;
            v33 += 512;
          }
          while (v32 != 4);
          ++v30;
          v31 += 2048;
          v28 = v35 + 8;
        }
        while (v30 != (int)v20 / 4);
        v28 = v35 + 8;
      }
      ++v27;
      v29 += 16;
    }
    while (v27 != 32);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), v18);
  }
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v39 = *(char *)(a1 + 55);
  if (v39 >= 0)
    v40 = a1 + 32;
  else
    v40 = *(_QWORD *)(a1 + 32);
  if (v39 >= 0)
    v41 = *(unsigned __int8 *)(a1 + 55);
  else
    v41 = *(_QWORD *)(a1 + 40);
  v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v40, v41);
  v43 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)"/decoder/prenet/dense/1/bias", 28);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, (uint64_t)"/npy", 4);
  v44 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v412);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v44 + 24))(v44, v412, &v440, &v432, 1);
  if (v413 < 0)
    heap_Free(*(_QWORD **)(v414 + 8), v412[0]);
  if (v433 != v432)
  {
    v45 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 512);
    v46 = 0;
    *(_QWORD *)(a1 + 272) = v45;
    v47 = v432;
    v48 = (v433 - v432) >> 1;
    while (v48 != v46)
    {
      *(_WORD *)(v45 + 2 * v46) = *(_WORD *)(v47 + 2 * v46);
      if (++v46 == 256)
        goto LABEL_54;
    }
LABEL_426:
    std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
  }
  v49 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: prenet first layer bias", 30);
  std::ios_base::getloc((const std::ios_base *)((char *)v49 + *(_QWORD *)(*v49 - 24)));
  v50 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v50->__vftable[2].~facet_0)(v50, 10);
  std::locale::~locale(&v418);
  std::ostream::put();
  std::ostream::flush();
LABEL_54:
  *(_WORD *)(a1 + 296) = 15799;
  v51 = 0;
  *(_QWORD *)(a1 + 304) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 1024000);
  do
  {
    v52 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v431);
    v53 = ((double)v52
         + (double)std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v431)
         * 4294967300.0)
        * 5.42101086e-20
        + 0.0;
    if (v53 >= 0.3)
      LOWORD(v54) = COERCE_UNSIGNED_INT(1.0);
    else
      v54 = COERCE_SHORT_FLOAT(0);
    *(short float *)(*(_QWORD *)(a1 + 304) + v51) = v54;
    v51 += 2;
  }
  while (v51 != 1024000);
  *(_DWORD *)(a1 + 296) = 1035419063;
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v55 = *(char *)(a1 + 55);
  if (v55 >= 0)
    v56 = a1 + 32;
  else
    v56 = *(_QWORD *)(a1 + 32);
  if (v55 >= 0)
    v57 = *(unsigned __int8 *)(a1 + 55);
  else
    v57 = *(_QWORD *)(a1 + 40);
  v58 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v56, v57);
  v59 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v58, (uint64_t)"/customdecoderstep/decoder/prenet/dense/2/mat", 45);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"/npy", 4);
  v60 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v409);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v60 + 24))(v60, v409, &v440, &v432, 1);
  if (v410 < 0)
    heap_Free(*(_QWORD **)(v411 + 8), v409[0]);
  if (v433 == v432)
  {
    v78 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: prenet second layer weight", 33);
    std::ios_base::getloc((const std::ios_base *)((char *)v78 + *(_QWORD *)(*v78 - 24)));
    v79 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v79->__vftable[2].~facet_0)(v79, 10);
    std::locale::~locale(&v418);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v61 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 0x20000);
    v62 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 0x20000);
    v63 = 0;
    v64 = 0;
    *(_QWORD *)(a1 + 280) = v62;
    v65 = v432;
    v66 = (v433 - v432) >> 1;
    do
    {
      v67 = 256;
      v68 = v63;
      do
      {
        if (v66 <= v68)
          std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
        *(_WORD *)(v61 + 2 * v68) = *(_WORD *)(v65 + 2 * v68);
        ++v68;
        --v67;
      }
      while (v67);
      ++v64;
      v63 += 256;
    }
    while (v64 != 256);
    v69 = 0;
    v70 = 0;
    v71 = v61;
    do
    {
      v72 = 0;
      v73 = v71;
      do
      {
        v74 = 0;
        v75 = v73;
        do
        {
          v76 = 0;
          v77 = v70;
          do
          {
            *(_WORD *)(v62 + 2 * v70 + 2 * v76) = *(_WORD *)(v75 + 2 * v76);
            ++v76;
          }
          while (v76 != 8);
          ++v74;
          v75 += 512;
          v70 += 8;
        }
        while (v74 != 4);
        ++v72;
        v73 += 2048;
        v70 = v77 + 8;
      }
      while (v72 != 64);
      ++v69;
      v71 += 16;
      v70 = v77 + 8;
    }
    while (v69 != 32);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), v61);
  }
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v80 = *(char *)(a1 + 55);
  if (v80 >= 0)
    v81 = a1 + 32;
  else
    v81 = *(_QWORD *)(a1 + 32);
  if (v80 >= 0)
    v82 = *(unsigned __int8 *)(a1 + 55);
  else
    v82 = *(_QWORD *)(a1 + 40);
  v83 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v81, v82);
  v84 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v83, (uint64_t)"/decoder/prenet/dense/2/bias", 28);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v84, (uint64_t)"/npy", 4);
  v85 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v406);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v85 + 24))(v85, v406, &v440, &v432, 1);
  if (v407 < 0)
    heap_Free(*(_QWORD **)(v408 + 8), v406[0]);
  if (v433 != v432)
  {
    v86 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 512);
    v87 = 0;
    *(_QWORD *)(a1 + 288) = v86;
    v88 = v432;
    v89 = (v433 - v432) >> 1;
    while (v89 != v87)
    {
      *(_WORD *)(v86 + 2 * v87) = *(_WORD *)(v88 + 2 * v87);
      if (++v87 == 256)
        goto LABEL_101;
    }
    goto LABEL_426;
  }
  v90 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: prenet second layer bias", 31);
  std::ios_base::getloc((const std::ios_base *)((char *)v90 + *(_QWORD *)(*v90 - 24)));
  v91 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v91->__vftable[2].~facet_0)(v91, 10);
  std::locale::~locale(&v418);
  std::ostream::put();
  std::ostream::flush();
  v88 = v432;
LABEL_101:
  v441 = v440;
  v433 = v88;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v92 = *(char *)(a1 + 55);
  if (v92 >= 0)
    v93 = a1 + 32;
  else
    v93 = *(_QWORD *)(a1 + 32);
  if (v92 >= 0)
    v94 = *(unsigned __int8 *)(a1 + 55);
  else
    v94 = *(_QWORD *)(a1 + 40);
  v95 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v93, v94);
  v96 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v95, (uint64_t)"/multi/lstm/cell/0/kernel", 25);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v96, (uint64_t)"/npy", 4);
  v97 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v403);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v97 + 24))(v97, v403, &v440, &v432, 1);
  if (v404 < 0)
    heap_Free(*(_QWORD **)(v405 + 8), v403[0]);
  if (v433 == v432)
  {
    v117 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: first lstm matmul layer weight", 37);
    std::ios_base::getloc((const std::ios_base *)((char *)v117 + *(_QWORD *)(*v117 - 24)));
    v118 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v118->__vftable[2].~facet_0)(v118, 10);
    std::locale::~locale(&v418);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v98 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), (uint64_t)*(int *)(*(_QWORD *)(a1 + 24) + 3388) << 12);
    v99 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), (uint64_t)*(int *)(*(_QWORD *)(a1 + 24) + 3388) << 12);
    *(_QWORD *)(a1 + 312) = v99;
    v100 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 3388);
    if ((int)v100 >= 1)
    {
      v101 = 0;
      v102 = 0;
      v103 = v432;
      v104 = (v433 - v432) >> 1;
      v105 = v98;
      do
      {
        for (k = 0; k != 2048; ++k)
        {
          if (v104 <= v101 + k)
            std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
          *(_WORD *)(v105 + 2 * k) = *(_WORD *)(v103 + 2 * k);
        }
        ++v102;
        v105 += 4096;
        v101 += 2048;
        v103 += 4096;
      }
      while (v102 != v100);
    }
    v107 = 0;
    v108 = 0;
    v109 = v98;
    do
    {
      if ((int)v100 >= 4)
      {
        v110 = 0;
        v111 = v109;
        do
        {
          v112 = 0;
          v113 = v111;
          do
          {
            v114 = 0;
            v115 = v108;
            v116 = v99 + 2 * v108;
            do
            {
              *(_WORD *)(v116 + 2 * v114) = *(_WORD *)(v113 + 2 * v114);
              ++v114;
            }
            while (v114 != 8);
            v108 = v115 + 8;
            ++v112;
            v113 += 4096;
          }
          while (v112 != 4);
          ++v110;
          v111 += 0x4000;
          v108 = v115 + 8;
        }
        while (v110 != (int)v100 / 4);
        v108 = v115 + 8;
      }
      ++v107;
      v109 += 16;
    }
    while (v107 != 256);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), v98);
  }
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v119 = *(char *)(a1 + 55);
  if (v119 >= 0)
    v120 = a1 + 32;
  else
    v120 = *(_QWORD *)(a1 + 32);
  if (v119 >= 0)
    v121 = *(unsigned __int8 *)(a1 + 55);
  else
    v121 = *(_QWORD *)(a1 + 40);
  v122 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v120, v121);
  v123 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v122, (uint64_t)"/multi/lstm/cell/0/bias", 23);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v123, (uint64_t)"/npy", 4);
  v124 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v400);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v124 + 24))(v124, v400, &v440, &v432, 1);
  if (v401 < 0)
    heap_Free(*(_QWORD **)(v402 + 8), v400[0]);
  if (v433 != v432)
  {
    v125 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 4096);
    v126 = 0;
    *(_QWORD *)(a1 + 320) = v125;
    v127 = v432;
    v128 = (v433 - v432) >> 1;
    while (v128 != v126)
    {
      *(_WORD *)(v125 + 2 * v126) = *(_WORD *)(v127 + 2 * v126);
      if (++v126 == 2048)
        goto LABEL_146;
    }
    goto LABEL_426;
  }
  v129 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: first lstm matmul layer bias", 35);
  std::ios_base::getloc((const std::ios_base *)((char *)v129 + *(_QWORD *)(*v129 - 24)));
  v130 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v130->__vftable[2].~facet_0)(v130, 10);
  std::locale::~locale(&v418);
  std::ostream::put();
  std::ostream::flush();
  v127 = v432;
LABEL_146:
  v441 = v440;
  v433 = v127;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v131 = *(char *)(a1 + 55);
  if (v131 >= 0)
    v132 = a1 + 32;
  else
    v132 = *(_QWORD *)(a1 + 32);
  if (v131 >= 0)
    v133 = *(unsigned __int8 *)(a1 + 55);
  else
    v133 = *(_QWORD *)(a1 + 40);
  v134 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v132, v133);
  v135 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v134, (uint64_t)"/multi/lstm/cell/1/kernel", 25);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v135, (uint64_t)"/npy", 4);
  v136 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v397);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v136 + 24))(v136, v397, &v440, &v432, 1);
  if (v398 < 0)
    heap_Free(*(_QWORD **)(v399 + 8), v397[0]);
  if (v433 == v432)
  {
    v154 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: second lstm matmul layer weight", 38);
    std::ios_base::getloc((const std::ios_base *)((char *)v154 + *(_QWORD *)(*v154 - 24)));
    v155 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v155->__vftable[2].~facet_0)(v155, 10);
    std::locale::~locale(&v418);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v137 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 0x400000);
    v138 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 0x400000);
    v139 = 0;
    v140 = 0;
    *(_QWORD *)(a1 + 328) = v138;
    v141 = v432;
    v142 = (v433 - v432) >> 1;
    do
    {
      v143 = 2048;
      v144 = v139;
      do
      {
        if (v142 <= v144)
          std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
        *(_WORD *)(v137 + 2 * v144) = *(_WORD *)(v141 + 2 * v144);
        ++v144;
        --v143;
      }
      while (v143);
      ++v140;
      v139 += 2048;
    }
    while (v140 != 1024);
    v145 = 0;
    v146 = 0;
    v147 = v137;
    do
    {
      v148 = 0;
      v149 = v147;
      do
      {
        v150 = 0;
        v151 = v149;
        do
        {
          v152 = 0;
          v153 = v146;
          do
          {
            *(_WORD *)(v138 + 2 * v146 + 2 * v152) = *(_WORD *)(v151 + 2 * v152);
            ++v152;
          }
          while (v152 != 8);
          ++v150;
          v151 += 4096;
          v146 += 8;
        }
        while (v150 != 4);
        ++v148;
        v149 += 0x4000;
        v146 = v153 + 8;
      }
      while (v148 != 256);
      ++v145;
      v147 += 16;
      v146 = v153 + 8;
    }
    while (v145 != 256);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), v137);
  }
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v156 = *(char *)(a1 + 55);
  if (v156 >= 0)
    v157 = a1 + 32;
  else
    v157 = *(_QWORD *)(a1 + 32);
  if (v156 >= 0)
    v158 = *(unsigned __int8 *)(a1 + 55);
  else
    v158 = *(_QWORD *)(a1 + 40);
  v159 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v157, v158);
  v160 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v159, (uint64_t)"/multi/lstm/cell/1/bias", 23);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v160, (uint64_t)"/npy", 4);
  v161 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v394);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v161 + 24))(v161, v394, &v440, &v432, 1);
  if (v395 < 0)
    heap_Free(*(_QWORD **)(v396 + 8), v394[0]);
  if (v433 != v432)
  {
    v162 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 4096);
    v163 = 0;
    *(_QWORD *)(a1 + 336) = v162;
    v164 = v432;
    v165 = (v433 - v432) >> 1;
    while (v165 != v163)
    {
      *(_WORD *)(v162 + 2 * v163) = *(_WORD *)(v164 + 2 * v163);
      if (++v163 == 2048)
        goto LABEL_188;
    }
    goto LABEL_426;
  }
  v166 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: second lstm matmul layer bias", 36);
  std::ios_base::getloc((const std::ios_base *)((char *)v166 + *(_QWORD *)(*v166 - 24)));
  v167 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v167->__vftable[2].~facet_0)(v167, 10);
  std::locale::~locale(&v418);
  std::ostream::put();
  std::ostream::flush();
  v164 = v432;
LABEL_188:
  v441 = v440;
  v433 = v164;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v168 = *(char *)(a1 + 55);
  if (v168 >= 0)
    v169 = a1 + 32;
  else
    v169 = *(_QWORD *)(a1 + 32);
  if (v168 >= 0)
    v170 = *(unsigned __int8 *)(a1 + 55);
  else
    v170 = *(_QWORD *)(a1 + 40);
  v171 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v169, v170);
  v172 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v171, (uint64_t)"/location/sensitive/attention/query/layer/kernel", 48);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v172, (uint64_t)"/npy", 4);
  v173 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v391);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v173 + 24))(v173, v391, &v440, &v432, 1);
  if (v392 < 0)
    heap_Free(*(_QWORD **)(v393 + 8), v391[0]);
  if (v433 == v432)
  {
    v191 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: attention query matmul layer weight", 42);
    std::ios_base::getloc((const std::ios_base *)((char *)v191 + *(_QWORD *)(*v191 - 24)));
    v192 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v192->__vftable[2].~facet_0)(v192, 10);
    std::locale::~locale(&v418);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v174 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 0x20000);
    v175 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 0x20000);
    v176 = 0;
    v177 = 0;
    *(_QWORD *)(a1 + 344) = v175;
    v178 = v432;
    v179 = (v433 - v432) >> 1;
    do
    {
      v180 = 128;
      v181 = v176;
      do
      {
        if (v179 <= v181)
          std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
        *(_WORD *)(v174 + 2 * v181) = *(_WORD *)(v178 + 2 * v181);
        ++v181;
        --v180;
      }
      while (v180);
      ++v177;
      v176 += 128;
    }
    while (v177 != 512);
    v182 = 0;
    v183 = 0;
    v184 = v174;
    do
    {
      v185 = 0;
      v186 = v184;
      do
      {
        v187 = 0;
        v188 = v186;
        do
        {
          v189 = 0;
          v190 = v183;
          do
          {
            *(_WORD *)(v175 + 2 * v183 + 2 * v189) = *(_WORD *)(v188 + 2 * v189);
            ++v189;
          }
          while (v189 != 8);
          ++v187;
          v188 += 256;
          v183 += 8;
        }
        while (v187 != 4);
        ++v185;
        v186 += 1024;
        v183 = v190 + 8;
      }
      while (v185 != 128);
      ++v182;
      v184 += 16;
      v183 = v190 + 8;
    }
    while (v182 != 16);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), v174);
  }
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v193 = *(char *)(a1 + 55);
  if (v193 >= 0)
    v194 = a1 + 32;
  else
    v194 = *(_QWORD *)(a1 + 32);
  if (v193 >= 0)
    v195 = *(unsigned __int8 *)(a1 + 55);
  else
    v195 = *(_QWORD *)(a1 + 40);
  v196 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v194, v195);
  v197 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v196, (uint64_t)"/location/sensitive/attention/conv1d/kernel", 43);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v197, (uint64_t)"/npy", 4);
  v198 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v388);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v198 + 24))(v198, v388, &v440, &v432, 1);
  if (v389 < 0)
    heap_Free(*(_QWORD **)(v390 + 8), v388[0]);
  if (v433 == v432)
  {
    v217 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: attention location features layer weight", 47);
    std::ios_base::getloc((const std::ios_base *)((char *)v217 + *(_QWORD *)(*v217 - 24)));
    v218 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v218->__vftable[2].~facet_0)(v218, 10);
    std::locale::~locale(&v418);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v199 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 1984);
    *(_DWORD *)(a1 + 368) = 32;
    v200 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 2048);
    v201 = 0;
    *(_QWORD *)(a1 + 352) = v200;
    v202 = v432;
    v203 = (v433 - v432) >> 1;
    v204 = (_WORD *)v199;
    do
    {
      v205 = 0;
      v206 = v204;
      do
      {
        if (v203 <= v201 + v205)
          std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
        *v206++ = *(_WORD *)(v202 + 2 * v205);
        v205 += 31;
      }
      while (v205 != 992);
      ++v201;
      v204 += 32;
      v202 += 2;
    }
    while (v201 != 31);
    v207 = 0;
    v208 = 0;
    v209 = 0;
    v210 = *(_DWORD *)(a1 + 368);
    do
    {
      if (v210 >= 8)
      {
        v211 = 0;
        v212 = v207;
        do
        {
          v213 = 0;
          v214 = v212;
          do
          {
            if ((unint64_t)(v213 + 8 * v211) >= 0x1F)
            {
              v216 = (_QWORD *)(v200 + 2 * v208);
              *v216 = 0;
              v216[1] = 0;
              v208 += 8;
            }
            else
            {
              for (m = 0; m != 8; ++m)
                *(_WORD *)(v200 + 2 * v208 + 2 * m) = *(_WORD *)(v199 + 2 * v214 + 2 * m);
              v208 += 8;
            }
            ++v213;
            v214 += 32;
          }
          while (v213 != 8);
          ++v211;
          v212 += 256;
        }
        while (v211 != v210 / 8);
      }
      ++v209;
      v207 += 8;
    }
    while (v209 != 4);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), v199);
  }
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v219 = *(char *)(a1 + 55);
  if (v219 >= 0)
    v220 = a1 + 32;
  else
    v220 = *(_QWORD *)(a1 + 32);
  if (v219 >= 0)
    v221 = *(unsigned __int8 *)(a1 + 55);
  else
    v221 = *(_QWORD *)(a1 + 40);
  v222 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v220, v221);
  v223 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v222, (uint64_t)"/location/sensitive/attention/convolution/bias", 46);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v223, (uint64_t)"/npy", 4);
  v224 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v385);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v224 + 24))(v224, v385, &v440, &v432, 1);
  if (v386 < 0)
    heap_Free(*(_QWORD **)(v387 + 8), v385[0]);
  if (v433 != v432)
  {
    v225 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 64);
    v226 = 0;
    *(_QWORD *)(a1 + 360) = v225;
    v227 = v432;
    v228 = (v433 - v432) >> 1;
    while (v228 != v226)
    {
      *(_WORD *)(v225 + 2 * v226) = *(_WORD *)(v227 + 2 * v226);
      if (++v226 == 32)
        goto LABEL_260;
    }
    goto LABEL_426;
  }
  v229 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: attention location features layer bias", 45);
  std::ios_base::getloc((const std::ios_base *)((char *)v229 + *(_QWORD *)(*v229 - 24)));
  v230 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v230->__vftable[2].~facet_0)(v230, 10);
  std::locale::~locale(&v418);
  std::ostream::put();
  std::ostream::flush();
  v227 = v432;
LABEL_260:
  v441 = v440;
  v433 = v227;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v231 = *(char *)(a1 + 55);
  if (v231 >= 0)
    v232 = a1 + 32;
  else
    v232 = *(_QWORD *)(a1 + 32);
  if (v231 >= 0)
    v233 = *(unsigned __int8 *)(a1 + 55);
  else
    v233 = *(_QWORD *)(a1 + 40);
  v234 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v232, v233);
  v235 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v234, (uint64_t)"/location/sensitive/attention/location/features/layer/tensordot", 63);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v235, (uint64_t)"/npy", 4);
  v236 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v382);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v236 + 24))(v236, v382, &v440, &v432, 1);
  if (v383 < 0)
    heap_Free(*(_QWORD **)(v384 + 8), v382[0]);
  if (v433 == v432)
  {
    v254 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: attention location matmul layer weight", 45);
    std::ios_base::getloc((const std::ios_base *)((char *)v254 + *(_QWORD *)(*v254 - 24)));
    v255 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v255->__vftable[2].~facet_0)(v255, 10);
    std::locale::~locale(&v418);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v237 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 0x2000);
    v238 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 0x2000);
    v239 = 0;
    v240 = 0;
    *(_QWORD *)(a1 + 376) = v238;
    v241 = v432;
    v242 = (v433 - v432) >> 1;
    do
    {
      v243 = 128;
      v244 = v239;
      do
      {
        if (v242 <= v244)
          std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
        *(_WORD *)(v237 + 2 * v244) = *(_WORD *)(v241 + 2 * v244);
        ++v244;
        --v243;
      }
      while (v243);
      ++v240;
      v239 += 128;
    }
    while (v240 != 32);
    v245 = 0;
    v246 = 0;
    v247 = v237;
    do
    {
      v248 = 0;
      v249 = v247;
      do
      {
        v250 = 0;
        v251 = v249;
        do
        {
          v252 = 0;
          v253 = v246;
          do
          {
            *(_WORD *)(v238 + 2 * v246 + 2 * v252) = *(_WORD *)(v251 + 2 * v252);
            ++v252;
          }
          while (v252 != 8);
          ++v250;
          v251 += 256;
          v246 += 8;
        }
        while (v250 != 4);
        ++v248;
        v249 += 1024;
        v246 = v253 + 8;
      }
      while (v248 != 8);
      ++v245;
      v247 += 16;
      v246 = v253 + 8;
    }
    while (v245 != 16);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), v237);
  }
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v256 = *(char *)(a1 + 55);
  if (v256 >= 0)
    v257 = a1 + 32;
  else
    v257 = *(_QWORD *)(a1 + 32);
  if (v256 >= 0)
    v258 = *(unsigned __int8 *)(a1 + 55);
  else
    v258 = *(_QWORD *)(a1 + 40);
  v259 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v257, v258);
  v260 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v259, (uint64_t)"/location/sensitive/attention/attention/bias", 44);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v260, (uint64_t)"/npy", 4);
  v261 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v379);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v261 + 24))(v261, v379, &v440, &v432, 1);
  if (v380 < 0)
    heap_Free(*(_QWORD **)(v381 + 8), v379[0]);
  if (v433 != v432)
  {
    v262 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 256);
    v263 = 0;
    *(_QWORD *)(a1 + 384) = v262;
    v264 = v432;
    v265 = (v433 - v432) >> 1;
    while (v265 != v263)
    {
      *(_WORD *)(v262 + 2 * v263) = *(_WORD *)(v264 + 2 * v263);
      if (++v263 == 128)
        goto LABEL_302;
    }
    goto LABEL_426;
  }
  v266 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: attention location matmul layer bias", 43);
  std::ios_base::getloc((const std::ios_base *)((char *)v266 + *(_QWORD *)(*v266 - 24)));
  v267 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v267->__vftable[2].~facet_0)(v267, 10);
  std::locale::~locale(&v418);
  std::ostream::put();
  std::ostream::flush();
  v264 = v432;
LABEL_302:
  v441 = v440;
  v433 = v264;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v268 = *(char *)(a1 + 55);
  if (v268 >= 0)
    v269 = a1 + 32;
  else
    v269 = *(_QWORD *)(a1 + 32);
  if (v268 >= 0)
    v270 = *(unsigned __int8 *)(a1 + 55);
  else
    v270 = *(_QWORD *)(a1 + 40);
  v271 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v269, v270);
  v272 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v271, (uint64_t)"/location/sensitive/attention/attention/variable", 48);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v272, (uint64_t)"/npy", 4);
  v273 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v376);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v273 + 24))(v273, v376, &v440, &v432, 1);
  if (v377 < 0)
    heap_Free(*(_QWORD **)(v378 + 8), v376[0]);
  if (v433 != v432)
  {
    v274 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 256);
    v275 = 0;
    *(_QWORD *)(a1 + 392) = v274;
    v276 = v432;
    v277 = (v433 - v432) >> 1;
    while (v277 != v275)
    {
      *(_WORD *)(v274 + 2 * v275) = *(_WORD *)(v276 + 2 * v275);
      if (++v275 == 128)
        goto LABEL_318;
    }
    goto LABEL_426;
  }
  v278 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: location attention matmul weight", 39);
  std::ios_base::getloc((const std::ios_base *)((char *)v278 + *(_QWORD *)(*v278 - 24)));
  v279 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v279->__vftable[2].~facet_0)(v279, 10);
  std::locale::~locale(&v418);
  std::ostream::put();
  std::ostream::flush();
  v276 = v432;
LABEL_318:
  v441 = v440;
  v433 = v276;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v280 = *(char *)(a1 + 55);
  if (v280 >= 0)
    v281 = a1 + 32;
  else
    v281 = *(_QWORD *)(a1 + 32);
  if (v280 >= 0)
    v282 = *(unsigned __int8 *)(a1 + 55);
  else
    v282 = *(_QWORD *)(a1 + 40);
  v283 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v281, v282);
  v284 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v283, (uint64_t)"/projection/linear/projection/kernel", 36);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v284, (uint64_t)"/npy", 4);
  v285 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v373);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v285 + 24))(v285, v373, &v440, &v432, 1);
  if (v374 < 0)
    heap_Free(*(_QWORD **)(v375 + 8), v373[0]);
  if (v433 == v432)
  {
    v305 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: stop token linear projection matmul layer weight", 55);
    std::ios_base::getloc((const std::ios_base *)((char *)v305 + *(_QWORD *)(*v305 - 24)));
    v306 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v306->__vftable[2].~facet_0)(v306, 10);
    std::locale::~locale(&v418);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v286 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 480 * *(int *)(*(_QWORD *)(a1 + 24) + 3392));
    v287 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 480 * *(int *)(*(_QWORD *)(a1 + 24) + 3392));
    *(_QWORD *)(a1 + 416) = v287;
    v288 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 3392);
    if ((int)v288 >= 1)
    {
      v289 = 0;
      v290 = 0;
      v291 = v432;
      v292 = (v433 - v432) >> 1;
      v293 = v286;
      do
      {
        for (n = 0; n != 240; ++n)
        {
          if (v292 <= v289 + n)
            std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
          *(_WORD *)(v293 + 2 * n) = *(_WORD *)(v291 + 2 * n);
        }
        ++v290;
        v293 += 480;
        v289 += 240;
        v291 += 480;
      }
      while (v290 != v288);
    }
    v295 = 0;
    v296 = 0;
    v297 = v286;
    do
    {
      if ((int)v288 >= 4)
      {
        v298 = 0;
        v299 = v297;
        do
        {
          v300 = 0;
          v301 = v299;
          do
          {
            v302 = 0;
            v303 = v296;
            v304 = v287 + 2 * v296;
            do
            {
              *(_WORD *)(v304 + 2 * v302) = *(_WORD *)(v301 + 2 * v302);
              ++v302;
            }
            while (v302 != 8);
            v296 = v303 + 8;
            ++v300;
            v301 += 480;
          }
          while (v300 != 4);
          ++v298;
          v299 += 1920;
          v296 = v303 + 8;
        }
        while (v298 != (int)v288 / 4);
        v296 = v303 + 8;
      }
      ++v295;
      v297 += 16;
    }
    while (v295 != 30);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), v286);
  }
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v307 = *(char *)(a1 + 55);
  if (v307 >= 0)
    v308 = a1 + 32;
  else
    v308 = *(_QWORD *)(a1 + 32);
  if (v307 >= 0)
    v309 = *(unsigned __int8 *)(a1 + 55);
  else
    v309 = *(_QWORD *)(a1 + 40);
  v310 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v308, v309);
  v311 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v310, (uint64_t)"/projection/linear/projection/bias", 34);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v311, (uint64_t)"/npy", 4);
  v312 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v370);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v312 + 24))(v312, v370, &v440, &v432, 1);
  if (v371 < 0)
    heap_Free(*(_QWORD **)(v372 + 8), v370[0]);
  if (v433 != v432)
  {
    v313 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 480);
    v314 = 0;
    *(_QWORD *)(a1 + 424) = v313;
    v315 = v432;
    v316 = (v433 - v432) >> 1;
    while (v316 != v314)
    {
      *(_WORD *)(v313 + 2 * v314) = *(_WORD *)(v315 + 2 * v314);
      if (++v314 == 240)
        goto LABEL_363;
    }
    goto LABEL_426;
  }
  v317 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: stop token linear projection matmul layer bias", 53);
  std::ios_base::getloc((const std::ios_base *)((char *)v317 + *(_QWORD *)(*v317 - 24)));
  v318 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v318->__vftable[2].~facet_0)(v318, 10);
  std::locale::~locale(&v418);
  std::ostream::put();
  std::ostream::flush();
  v315 = v432;
LABEL_363:
  v441 = v440;
  v433 = v315;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v319 = *(char *)(a1 + 55);
  if (v319 >= 0)
    v320 = a1 + 32;
  else
    v320 = *(_QWORD *)(a1 + 32);
  if (v319 >= 0)
    v321 = *(unsigned __int8 *)(a1 + 55);
  else
    v321 = *(_QWORD *)(a1 + 40);
  v322 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v320, v321);
  v323 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v322, (uint64_t)"/projection/stop/token/projection/kernel", 40);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v323, (uint64_t)"/npy", 4);
  v324 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v367);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v324 + 24))(v324, v367, &v440, &v432, 1);
  if (v368 < 0)
    heap_Free(*(_QWORD **)(v369 + 8), v367[0]);
  if (v433 == v432)
  {
    v347 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: stop token stop projection matmul layer weight", 53);
    std::ios_base::getloc((const std::ios_base *)((char *)v347 + *(_QWORD *)(*v347 - 24)));
    v348 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v348->__vftable[2].~facet_0)(v348, 10);
    std::locale::~locale(&v418);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v325 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 6 * *(int *)(*(_QWORD *)(a1 + 24) + 3392));
    *(_DWORD *)(a1 + 448) = 8;
    v326 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 16 * *(int *)(*(_QWORD *)(a1 + 24) + 3392));
    *(_QWORD *)(a1 + 432) = v326;
    v327 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 3392);
    if ((int)v327 >= 1)
    {
      v328 = 0;
      v329 = 0;
      v330 = v432;
      v331 = (v433 - v432) >> 1;
      v332 = v325;
      do
      {
        for (ii = 0; ii != 3; ++ii)
        {
          if (v331 <= v328 + ii)
            std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
          *(_WORD *)(v332 + 2 * ii) = *(_WORD *)(v330 + 2 * ii);
        }
        ++v329;
        v332 += 6;
        v328 += 3;
        v330 += 6;
      }
      while (v329 != v327);
    }
    v334 = *(unsigned int *)(a1 + 448);
    if ((int)v334 >= 8)
    {
      v335 = 0;
      v336 = 0;
      v337 = 0;
      v338 = v334 >> 3;
      do
      {
        if ((int)v327 >= 4)
        {
          v339 = 0;
          v340 = v335;
          do
          {
            v341 = 0;
            v342 = v325 + 8 * (v340 >> 2);
            do
            {
              v343 = 0;
              v344 = v337;
              v345 = v326 + 2 * v337;
              do
              {
                v346 = 0;
                if ((unint64_t)(v335 + v343) <= 2)
                  v346 = *(_WORD *)(v342 + 2 * v343);
                *(_WORD *)(v345 + 2 * v343++) = v346;
              }
              while (v343 != 8);
              v337 = v344 + 8;
              ++v341;
              v342 += 6;
            }
            while (v341 != 4);
            ++v339;
            v340 += 12;
            v337 = v344 + 8;
          }
          while (v339 != (int)v327 / 4);
          v337 = v344 + 8;
        }
        ++v336;
        v335 += 8;
      }
      while (v336 != v338);
    }
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), v325);
  }
  v441 = v440;
  v433 = v432;
  v437 = v436;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v418);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v418, (uint64_t *)&v425);
  v418.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v419 = &unk_24D29B3B0;
  v424[0] = &unk_24D29B3D8;
  v420 = &unk_24D29B578;
  if (v422 < 0)
    heap_Free(*(_QWORD **)(v423 + 8), v421);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v424);
  v349 = *(char *)(a1 + 55);
  if (v349 >= 0)
    v350 = a1 + 32;
  else
    v350 = *(_QWORD *)(a1 + 32);
  if (v349 >= 0)
    v351 = *(unsigned __int8 *)(a1 + 55);
  else
    v351 = *(_QWORD *)(a1 + 40);
  v352 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v426, v350, v351);
  v353 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v352, (uint64_t)"/projection/stop/token/projection/bias", 38);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v353, (uint64_t)"/npy", 4);
  v354 = *(_QWORD *)(a1 + 576);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v427, v364);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v354 + 24))(v354, v364, &v440, &v432, 1);
  if (v365 < 0)
    heap_Free(*(_QWORD **)(v366 + 8), v364[0]);
  if (v433 == v432)
  {
    v361 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"error: stop token stop projection matmul layer bias", 51);
    std::ios_base::getloc((const std::ios_base *)((char *)v361 + *(_QWORD *)(*v361 - 24)));
    v362 = std::locale::use_facet(&v418, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v362->__vftable[2].~facet_0)(v362, 10);
    std::locale::~locale(&v418);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v355 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 2 * *(int *)(a1 + 448));
    *(_QWORD *)(a1 + 440) = v355;
    v356 = *(unsigned int *)(a1 + 448);
    if ((int)v356 >= 1)
    {
      v357 = 0;
      v358 = v432;
      v359 = (v433 - v432) >> 1;
      do
      {
        v360 = 0;
        if (v357 <= 2)
        {
          if (v359 <= v357)
            goto LABEL_426;
          v360 = *(_WORD *)(v358 + 2 * v357);
        }
        *(_WORD *)(v355 + 2 * v357++) = v360;
      }
      while (v356 != v357);
    }
  }
  v425.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v426 = &unk_24D29B3B0;
  v430 = &unk_24D29B3D8;
  v427[0] = &unk_24D29B578;
  if (v428 < 0)
    heap_Free(*(_QWORD **)(v429 + 8), v427[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v430);
  *(_QWORD *)v431.__x_ = &v432;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v431);
  *(_QWORD *)v431.__x_ = &v436;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v431);
  *(_QWORD *)v431.__x_ = &v440;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v431);
  return 1;
}

void sub_214E9FB8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::locale::~locale((std::locale *)&STACK[0x240]);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)&STACK[0x360]);
  STACK[0x480] = v1 - 216;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&STACK[0x480]);
  STACK[0x480] = v1 - 184;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&STACK[0x480]);
  STACK[0x480] = v1 - 152;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&STACK[0x480]);
  _Unwind_Resume(a1);
}

void NeonDecoderManager::prenet_matmul(__n128 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float16x8_t *a7, uint64_t a8, unsigned int a9, unsigned int a10, int a11, int a12, unsigned int a13)
{
  int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  uint64_t v22;
  uint64_t v23;
  float16x8_t *v24;
  float16x8_t *v25;
  float16x8_t v26;

  v13 = (a10 >> 3) / a13;
  LODWORD(v14) = v13 * a12;
  v15 = v13 * a12 + v13;
  if (v13 * a12 < v15)
  {
    LODWORD(v16) = a9 >> 3;
    v17 = a5 + 2 * a6;
    if (a9 >> 3 <= 1)
      v16 = 1;
    else
      v16 = v16;
    v14 = (int)v14;
    do
    {
      v18 = *(float16x8_t *)(a4 + 16 * (_DWORD)v14);
      if (a9 >= 8)
      {
        v22 = 0;
        v21 = 0uLL;
        v23 = v16;
        v24 = a7;
        v20 = 0uLL;
        v19 = 0uLL;
        do
        {
          v25 = (float16x8_t *)(a3 + 2 * v14 * (int)((8 * a9) & 0xFFFFFFE0) + (v22 << 7));
          v26 = *v24++;
          v18 = vmlaq_laneq_f16(vmlaq_n_f16(v18, *v25, *(short float *)v26.i16), v25[4], v26, 4);
          v21 = vmlaq_laneq_f16(vmlaq_lane_f16(v21, v25[1], *(float16x4_t *)v26.i8, 1), v25[5], v26, 5);
          v20 = vmlaq_laneq_f16(vmlaq_lane_f16(v20, v25[2], *(float16x4_t *)v26.i8, 2), v25[6], v26, 6);
          v19 = vmlaq_laneq_f16(vmlaq_lane_f16(v19, v25[3], *(float16x4_t *)v26.i8, 3), v25[7], v26, 7);
          ++v22;
          --v23;
        }
        while (v23);
      }
      else
      {
        v19 = 0uLL;
        v20 = 0uLL;
        v21 = 0uLL;
      }
      *(float16x8_t *)(a8 + 16 * (_DWORD)v14) = vmulq_f16(*(float16x8_t *)(v17 + 16 * (_DWORD)v14), vmulq_n_f16(vmaxq_f16(vaddq_f16(v19, vaddq_f16(v20, vaddq_f16(v21, v18))), (float16x8_t)0), *(short float *)a1.n128_u16));
      ++v14;
    }
    while (v15 > v14);
  }
}

float16x8_t NeonDecoderManager::lstm_first_matmul(float16x8_t result, uint64_t a2, uint64_t a3, uint64_t a4, float16x8_t *a5, float16x8_t *a6, float16x8_t *a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11, unsigned int a12, int a13, unsigned int a14)
{
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  uint64_t v23;
  uint64_t v24;
  float16x8_t *v25;
  float16x8_t *v26;
  float16x8_t v27;
  float16x8_t *v28;
  unint64_t v29;
  unsigned int v30;
  float16x8_t *v31;
  float16x8_t v32;
  float16x8_t *v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  float16x8_t *v37;
  float16x8_t v38;

  LODWORD(v14) = (a12 >> 3) / a14 * a13;
  v15 = v14 + (a12 >> 3) / a14;
  if (v14 < v15)
  {
    v16 = (a9 >> 3) + (a10 >> 3);
    if (a9 >> 3 <= 1)
      v17 = 1;
    else
      v17 = a9 >> 3;
    v14 = (int)v14;
    do
    {
      v18 = v14 * (int)((8 * (a10 + a9 + a11)) & 0xFFFFFFE0);
      v19 = *(float16x8_t *)(a4 + 16 * (_DWORD)v14);
      v20 = 0uLL;
      if (a9 >= 8)
      {
        v23 = 0;
        v22 = 0uLL;
        v24 = v17;
        v25 = a5;
        v21 = 0uLL;
        do
        {
          v26 = (float16x8_t *)(a3 + 2 * v18 + (v23 << 7));
          v27 = *v25++;
          v19 = vmlaq_laneq_f16(vmlaq_n_f16(v19, *v26, *(short float *)v27.i16), v26[4], v27, 4);
          v22 = vmlaq_laneq_f16(vmlaq_lane_f16(v22, v26[1], *(float16x4_t *)v27.i8, 1), v26[5], v27, 5);
          v21 = vmlaq_laneq_f16(vmlaq_lane_f16(v21, v26[2], *(float16x4_t *)v27.i8, 2), v26[6], v27, 6);
          v20 = vmlaq_laneq_f16(vmlaq_lane_f16(v20, v26[3], *(float16x4_t *)v27.i8, 3), v26[7], v27, 7);
          ++v23;
          --v24;
        }
        while (v24);
      }
      else
      {
        v21 = 0uLL;
        v22 = 0uLL;
      }
      if (a10 >= 8)
      {
        v28 = a6;
        v29 = a9 >> 3;
        v30 = a9 >> 3;
        do
        {
          v31 = (float16x8_t *)(a3 + 2 * v18 + 2 * (v30 << 6));
          v32 = *v28++;
          v19 = vmlaq_laneq_f16(vmlaq_n_f16(v19, *v31, *(short float *)v32.i16), v31[4], v32, 4);
          v22 = vmlaq_laneq_f16(vmlaq_lane_f16(v22, v31[1], *(float16x4_t *)v32.i8, 1), v31[5], v32, 5);
          v21 = vmlaq_laneq_f16(vmlaq_lane_f16(v21, v31[2], *(float16x4_t *)v32.i8, 2), v31[6], v32, 6);
          v20 = vmlaq_laneq_f16(vmlaq_lane_f16(v20, v31[3], *(float16x4_t *)v32.i8, 3), v31[7], v32, 7);
          ++v29;
          ++v30;
        }
        while (v29 < v16);
      }
      if (a11 >= 8)
      {
        v33 = a7;
        v34 = (unint64_t)((a9 >> 3) + (a10 >> 3)) << 6;
        v35 = (a9 >> 3) + (a10 >> 3);
        v36 = a3 + 2 * v18;
        do
        {
          v37 = (float16x8_t *)(v36 + 2 * (v34 & 0xFFFFFFC0));
          v38 = *v33++;
          v19 = vmlaq_laneq_f16(vmlaq_n_f16(v19, *v37, *(short float *)v38.i16), v37[4], v38, 4);
          v22 = vmlaq_laneq_f16(vmlaq_lane_f16(v22, v37[1], *(float16x4_t *)v38.i8, 1), v37[5], v38, 5);
          v21 = vmlaq_laneq_f16(vmlaq_lane_f16(v21, v37[2], *(float16x4_t *)v38.i8, 2), v37[6], v38, 6);
          v20 = vmlaq_laneq_f16(vmlaq_lane_f16(v20, v37[3], *(float16x4_t *)v38.i8, 3), v37[7], v38, 7);
          ++v35;
          v34 += 64;
        }
        while (v35 < v16 + (a11 >> 3));
      }
      result = vaddq_f16(v20, vaddq_f16(v21, vaddq_f16(v22, v19)));
      *(float16x8_t *)(a8 + 16 * (_DWORD)v14++) = result;
    }
    while (v15 > v14);
  }
  return result;
}

float16x8_t NeonDecoderManager::lstm_second_matmul(float16x8_t result, uint64_t a2, uint64_t a3, uint64_t a4, float16x8_t *a5, float16x8_t *a6, uint64_t a7, unsigned int a8, unsigned int a9, unsigned int a10, int a11, unsigned int a12)
{
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  float16x8_t v16;
  float16x8_t v17;
  float16x8_t v18;
  float16x8_t v19;
  uint64_t v20;
  uint64_t v21;
  float16x8_t *v22;
  float16x8_t *v23;
  float16x8_t v24;
  float16x8_t *v25;
  unint64_t v26;
  unsigned int v27;
  uint64_t v28;
  float16x8_t *v29;
  float16x8_t v30;

  LODWORD(v12) = (a10 >> 3) / a12 * a11;
  v13 = v12 + (a10 >> 3) / a12;
  if (v12 < v13)
  {
    if (a8 >> 3 <= 1)
      v14 = 1;
    else
      v14 = a8 >> 3;
    v12 = (int)v12;
    do
    {
      v15 = v12 * (int)((8 * (a9 + a8)) & 0xFFFFFFE0);
      v16 = *(float16x8_t *)(a4 + 16 * (_DWORD)v12);
      v17 = 0uLL;
      if (a8 >= 8)
      {
        v20 = 0;
        v19 = 0uLL;
        v21 = v14;
        v22 = a5;
        v18 = 0uLL;
        do
        {
          v23 = (float16x8_t *)(a3 + 2 * v15 + (v20 << 7));
          v24 = *v22++;
          v16 = vmlaq_laneq_f16(vmlaq_n_f16(v16, *v23, *(short float *)v24.i16), v23[4], v24, 4);
          v19 = vmlaq_laneq_f16(vmlaq_lane_f16(v19, v23[1], *(float16x4_t *)v24.i8, 1), v23[5], v24, 5);
          v18 = vmlaq_laneq_f16(vmlaq_lane_f16(v18, v23[2], *(float16x4_t *)v24.i8, 2), v23[6], v24, 6);
          v17 = vmlaq_laneq_f16(vmlaq_lane_f16(v17, v23[3], *(float16x4_t *)v24.i8, 3), v23[7], v24, 7);
          ++v20;
          --v21;
        }
        while (v21);
      }
      else
      {
        v18 = 0uLL;
        v19 = 0uLL;
      }
      if (a9 >= 8)
      {
        v25 = a6;
        v26 = a8 >> 3;
        v27 = a8 >> 3;
        v28 = a3 + 2 * v15;
        do
        {
          v29 = (float16x8_t *)(v28 + 2 * (v27 << 6));
          v30 = *v25++;
          v16 = vmlaq_laneq_f16(vmlaq_n_f16(v16, *v29, *(short float *)v30.i16), v29[4], v30, 4);
          v19 = vmlaq_laneq_f16(vmlaq_lane_f16(v19, v29[1], *(float16x4_t *)v30.i8, 1), v29[5], v30, 5);
          v18 = vmlaq_laneq_f16(vmlaq_lane_f16(v18, v29[2], *(float16x4_t *)v30.i8, 2), v29[6], v30, 6);
          v17 = vmlaq_laneq_f16(vmlaq_lane_f16(v17, v29[3], *(float16x4_t *)v30.i8, 3), v29[7], v30, 7);
          ++v26;
          ++v27;
        }
        while (v26 < (a8 >> 3) + (a9 >> 3));
      }
      result = vaddq_f16(v17, vaddq_f16(v18, vaddq_f16(v19, v16)));
      *(float16x8_t *)(a7 + 16 * (_DWORD)v12++) = result;
    }
    while (v13 > v12);
  }
  return result;
}

void NeonDecoderManager::attention_query_matmul(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float16x8_t *a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9, int a10, int a11, unsigned int a12)
{
  int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float16x8_t v19;
  uint64_t v20;
  uint64_t v21;
  float16x8_t *v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  float16x8_t *v26;
  float16x8_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;

  v12 = (a8 >> 3) / a12;
  LODWORD(v13) = v12 * a11;
  v14 = v12 * a11 + v12;
  if (v12 * a11 < v14)
  {
    v15 = (a10 + a9) >> 2;
    if (a7 >> 3 <= 1)
      v16 = 1;
    else
      v16 = a7 >> 3;
    v17 = (int)(32 * (a8 >> 3));
    if (v15 <= 1)
      v18 = 1;
    else
      v18 = v15;
    v13 = (int)v13;
    do
    {
      v19 = 0uLL;
      if (a7 >= 8)
      {
        v20 = 0;
        v21 = v16;
        v22 = a5;
        v23 = 0uLL;
        v24 = 0uLL;
        v25 = 0uLL;
        do
        {
          v26 = (float16x8_t *)(a2 + 2 * v13 * (int)((8 * a7) & 0xFFFFFFE0) + (v20 << 7));
          v27 = *v22++;
          v19 = vmlaq_laneq_f16(vmlaq_n_f16(v19, *v26, *(short float *)v27.i16), v26[4], v27, 4);
          v23 = vmlaq_laneq_f16(vmlaq_lane_f16(v23, v26[1], *(float16x4_t *)v27.i8, 1), v26[5], v27, 5);
          v24 = vmlaq_laneq_f16(vmlaq_lane_f16(v24, v26[2], *(float16x4_t *)v27.i8, 2), v26[6], v27, 6);
          v25 = vmlaq_laneq_f16(vmlaq_lane_f16(v25, v26[3], *(float16x4_t *)v27.i8, 3), v26[7], v27, 7);
          ++v20;
          --v21;
        }
        while (v21);
        v19 = vaddq_f16(v25, vaddq_f16(v24, vaddq_f16(v23, v19)));
      }
      if ((a10 + a9) >= 4)
      {
        v28 = 0;
        v29 = v18;
        do
        {
          v30 = a3 + 64 * (_DWORD)v13 + 2 * v28 * v17;
          v31 = a4 + 64 * (_DWORD)v13 + 2 * v28 * v17;
          v32 = a6 + 64 * (_DWORD)v13 + 2 * v28 * v17;
          v33 = *(float16x8_t *)(v30 + 32);
          v34 = *(float16x8_t *)(v30 + 48);
          v35 = *(float16x8_t *)(v31 + 32);
          v36 = *(float16x8_t *)(v31 + 48);
          v37 = vaddq_f16(vaddq_f16(v19, *(float16x8_t *)(v30 + 16)), *(float16x8_t *)(v31 + 16));
          *(float16x8_t *)v32 = vaddq_f16(vaddq_f16(v19, *(float16x8_t *)v30), *(float16x8_t *)v31);
          *(float16x8_t *)(v32 + 16) = v37;
          *(float16x8_t *)(v32 + 32) = vaddq_f16(vaddq_f16(v19, v33), v35);
          *(float16x8_t *)(v32 + 48) = vaddq_f16(vaddq_f16(v19, v34), v36);
          ++v28;
          --v29;
        }
        while (v29);
      }
      ++v13;
    }
    while (v14 > v13);
  }
}

void NeonDecoderManager::attention_tanh(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned int a9)
{
  int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  unsigned int v18;
  uint64_t v19;
  float16x8_t v20;
  uint64_t v21;
  uint64_t v22;
  float16x8_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float16x8_t v29;
  float16x8_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float16x8_t *v70;

  v9 = (a5 >> 3) / a9 * a8;
  v10 = v9 + (a5 >> 3) / a9;
  if (v9 < v10)
  {
    v11 = a7 + a6;
    LODWORD(v12) = (a7 + a6) >> 2;
    if (v12 <= 1)
      v12 = 1;
    else
      v12 = v12;
    v13 = (float32x4_t)vdupq_n_s32(0x401C7BF8u);
    v14 = (float32x4_t)vdupq_n_s32(0x3F508C6Du);
    v15 = (float32x4_t)vdupq_n_s32(0x401D2709u);
    v16 = (float32x4_t)vdupq_n_s32(0x3F523BE9u);
    v17 = (float32x4_t)vdupq_n_s32(0x3F64AAB6u);
    do
    {
      if (v11 >= 4)
      {
        v18 = 0;
        v19 = 0;
        v20 = *(float16x8_t *)(a2 + 16 * v9);
        v21 = v12;
        do
        {
          v22 = a3 + ((uint64_t)v9 << 6) + 2 * v19 * (int)(32 * (a5 >> 3));
          v23 = *(float16x8_t *)(v22 + 16);
          v24 = vcvtq_f32_f16(*(float16x4_t *)v22);
          v25 = vcvt_hight_f32_f16(*(float16x8_t *)v22);
          v26 = vabsq_f32(v24);
          v27 = vabsq_f32(v25);
          v28 = vmulq_f32(v24, v24);
          v30 = *(float16x8_t *)(v22 + 32);
          v29 = *(float16x8_t *)(v22 + 48);
          v31 = vmulq_f32(v25, v25);
          v32 = vmulq_f32(vaddq_f32(v28, v13), vabsq_f32(vaddq_f32(v24, vmulq_f32(vmulq_f32(v24, v26), v14))));
          v33 = vmulq_f32(vaddq_f32(v31, v13), vabsq_f32(vaddq_f32(v25, vmulq_f32(vmulq_f32(v25, v27), v14))));
          v34 = vmulq_f32(v26, v15);
          v35 = vmulq_f32(v28, vaddq_f32(vmulq_f32(v26, v16), v17));
          v36 = vaddq_f32(v32, v13);
          v37 = vaddq_f32(v34, v35);
          v38 = vmulq_f32(v27, v15);
          v39 = vmulq_f32(v31, vaddq_f32(vmulq_f32(v27, v16), v17));
          v40 = vaddq_f32(v33, v13);
          v41 = vaddq_f32(v38, v39);
          v42 = vcvtq_f32_f16(*(float16x4_t *)v23.i8);
          v43 = vcvt_hight_f32_f16(v23);
          v44 = vabsq_f32(v42);
          v45 = vabsq_f32(v43);
          v46 = vmulq_f32(v42, v42);
          v47 = vmulq_f32(v43, v43);
          v48 = vaddq_f32(vmulq_f32(vaddq_f32(v46, v13), vabsq_f32(vaddq_f32(v42, vmulq_f32(vmulq_f32(v42, v44), v14)))), v13);
          v49 = vaddq_f32(vmulq_f32(vaddq_f32(v47, v13), vabsq_f32(vaddq_f32(v43, vmulq_f32(vmulq_f32(v43, v45), v14)))), v13);
          v50 = vaddq_f32(vmulq_f32(v44, v15), vmulq_f32(v46, vaddq_f32(vmulq_f32(v44, v16), v17)));
          v51 = vcvtq_f32_f16(*(float16x4_t *)v30.i8);
          v52 = vaddq_f32(vaddq_f32(vmulq_f32(v45, v15), vmulq_f32(v47, vaddq_f32(vmulq_f32(v45, v16), v17))), v15);
          v53 = vcvt_hight_f32_f16(v30);
          v54 = vabsq_f32(v51);
          v55 = vabsq_f32(v53);
          v56 = vmulq_f32(v51, v51);
          v57 = vmulq_f32(v53, v53);
          v58 = vdivq_f32(vaddq_f32(v37, v15), v36);
          v59 = vdivq_f32(vaddq_f32(v41, v15), v40);
          v60 = vdivq_f32(vaddq_f32(v50, v15), v48);
          v61 = vdivq_f32(v52, v49);
          v62 = vdivq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v54, v15), vmulq_f32(v56, vaddq_f32(vmulq_f32(v54, v16), v17))), v15), vaddq_f32(vmulq_f32(vaddq_f32(v56, v13), vabsq_f32(vaddq_f32(v51, vmulq_f32(vmulq_f32(v51, v54), v14)))), v13));
          v63 = vcvtq_f32_f16(*(float16x4_t *)v29.i8);
          v64 = vcvt_hight_f32_f16(v29);
          v65 = vabsq_f32(v63);
          v66 = vmulq_f32(v25, v59);
          v67 = vabsq_f32(v64);
          v68 = vmulq_f32(v63, v63);
          v69 = vmulq_f32(v64, v64);
          v70 = (float16x8_t *)(a4 + 16 * v9 + 2 * v18);
          *v70 = vmulq_f16(v20, vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_f32(v24, v58)), v66));
          *(float16x8_t *)((char *)v70 + 2 * a5) = vmulq_f16(v20, vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_f32(v42, v60)), vmulq_f32(v43, v61)));
          *(float16x8_t *)((char *)v70 + 4 * a5) = vmulq_f16(v20, vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_f32(v51, v62)), vmulq_f32(v53, vdivq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v55, v15), vmulq_f32(v57, vaddq_f32(vmulq_f32(v55, v16), v17))), v15), vaddq_f32(vmulq_f32(vaddq_f32(v57, v13), vabsq_f32(vaddq_f32(v53, vmulq_f32(vmulq_f32(v53, v55), v14)))), v13)))));
          *(float16x8_t *)((char *)v70 + 6 * a5) = vmulq_f16(v20, vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_f32(v63, vdivq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v65, v15), vmulq_f32(v68, vaddq_f32(vmulq_f32(v65, v16), v17))), v15), vaddq_f32(vmulq_f32(vaddq_f32(v68, v13), vabsq_f32(vaddq_f32(v63,
                                                                                vmulq_f32(vmulq_f32(v63, v65), v14)))),
                                                                          v13)))),
                                                       vmulq_f32(v64, vdivq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v67, v15), vmulq_f32(v69, vaddq_f32(vmulq_f32(v67, v16), v17))), v15), vaddq_f32(vmulq_f32(vaddq_f32(v69, v13), vabsq_f32(vaddq_f32(v64, vmulq_f32(vmulq_f32(v64, v67), v14)))), v13)))));
          ++v19;
          v18 += 4 * a5;
          --v21;
        }
        while (v21);
      }
      ++v9;
    }
    while (v10 > v9);
  }
}

void NeonDecoderManager::attention_location_feature(uint64_t a1, uint64_t a2, uint64_t a3, float16x4_t *a4, uint64_t a5, int a6, int a7, unsigned int a8, unsigned int a9, int a10, unsigned int a11)
{
  unsigned int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  float16x8_t *v21;
  float16x4_t *v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t v30;
  uint64_t v31;
  float16x4_t *v32;
  uint64_t v33;
  float16x8_t *v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t *v57;
  float16x8_t *v58;

  v11 = a8 >> 3;
  v12 = (a8 >> 3) / a11;
  LODWORD(v13) = v12 * a10;
  v14 = v12 * a10 + v12;
  if (v12 * a10 < v14)
  {
    LODWORD(v15) = a9 >> 3;
    v16 = a7 + a6;
    LODWORD(v17) = (a7 + a6) >> 3;
    v18 = v11 << 6;
    v19 = a5 + 2 * (int)(32 * v11);
    if (a9 >> 3 <= 1)
      v15 = 1;
    else
      v15 = v15;
    if (v17 <= 1)
      v17 = 1;
    else
      v17 = v17;
    v13 = (int)v13;
    do
    {
      if (v16 >= 8)
      {
        v20 = 0;
        v21 = (float16x8_t *)(a3 + 16 * (int)v13);
        v22 = a4 + 1;
        do
        {
          v23 = *v21;
          if (a9 >= 8)
          {
            v31 = 0;
            v32 = v22;
            v33 = v15;
            v30 = *v21;
            v29 = *v21;
            v28 = *v21;
            v27 = *v21;
            v26 = *v21;
            v25 = *v21;
            v24 = *v21;
            do
            {
              v34 = (float16x8_t *)(a2 + 2 * v13 * (int)((8 * a9) & 0xFFFFFFE0) + (v31 << 7));
              v35 = v34[1];
              v36 = *(float16x8_t *)v32[-1].i8;
              v37 = *(float16x8_t *)&v32[-1].i16[1];
              v38 = *(float16x8_t *)&v32[-1].u8[4];
              v39 = *(float16x8_t *)((char *)&v32[-1].u32[1] + 2);
              v40 = v34[2];
              v41 = v34[3];
              v42 = *(float16x8_t *)&v32->i16[1];
              v43 = *(float16x8_t *)&v32->u8[4];
              v44 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v23, *v34, *(short float *)v36.i16), v35, *(float16x4_t *)v36.i8, 1), v40, *(float16x4_t *)v36.i8, 2), v41, *(float16x4_t *)v36.i8, 3);
              v45 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v30, *v34, *(short float *)v37.i16), v35, *(float16x4_t *)v37.i8, 1), v40, *(float16x4_t *)v37.i8, 2), v41, *(float16x4_t *)v37.i8, 3);
              v46 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v29, *v34, *(short float *)v38.i16), v35, *(float16x4_t *)v38.i8, 1), v40, *(float16x4_t *)v38.i8, 2), v41, *(float16x4_t *)v38.i8, 3);
              v47 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v28, *v34, *(short float *)v39.i16), v35, *(float16x4_t *)v39.i8, 1), v40, *(float16x4_t *)v39.i8, 2), v41, *(float16x4_t *)v39.i8, 3);
              v48 = *(float16x8_t *)((char *)&v32->u32[1] + 2);
              v49 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v27, *v34, COERCE_SHORT_FLOAT(*(_OWORD *)v32->i8)), v35, *v32, 1), v40, *v32, 2), v41, *v32, 3);
              v50 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v26, *v34, *(short float *)v42.i16), v35, *(float16x4_t *)v42.i8, 1), v40, *(float16x4_t *)v42.i8, 2), v41, *(float16x4_t *)v42.i8, 3);
              v51 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v25, *v34, *(short float *)v43.i16), v35, *(float16x4_t *)v43.i8, 1), v40, *(float16x4_t *)v43.i8, 2), v41, *(float16x4_t *)v43.i8, 3);
              v52 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v24, *v34, *(short float *)v48.i16), v35, *(float16x4_t *)v48.i8, 1), v40, *(float16x4_t *)v48.i8, 2), v41, *(float16x4_t *)v48.i8, 3);
              v53 = v34[4];
              v54 = v34[5];
              v56 = v34[6];
              v55 = v34[7];
              v23 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v44, v53, v36, 4), v54, v36, 5), v56, v36, 6), v55, v36, 7);
              v30 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v45, v53, v37, 4), v54, v37, 5), v56, v37, 6), v55, v37, 7);
              v29 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v46, v53, v38, 4), v54, v38, 5), v56, v38, 6), v55, v38, 7);
              v28 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v47, v53, v39, 4), v54, v39, 5), v56, v39, 6), v55, v39, 7);
              v27 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v49, v53, *(float16x8_t *)v32->i8, 4), v54, *(float16x8_t *)v32->i8, 5), v56, *(float16x8_t *)v32->i8, 6), v55, *(float16x8_t *)v32->i8, 7);
              v26 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v50, v53, v42, 4), v54, v42, 5), v56, v42, 6), v55, v42, 7);
              v25 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v51, v53, v43, 4), v54, v43, 5), v56, v43, 6), v55, v43, 7);
              ++v31;
              v32 += 2;
              v24 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v52, v53, v48, 4), v54, v48, 5), v56, v48, 6), v55, v48, 7);
              --v33;
            }
            while (v33);
          }
          else
          {
            v24 = *v21;
            v25 = *v21;
            v26 = *v21;
            v27 = *v21;
            v28 = *v21;
            v29 = *v21;
            v30 = *v21;
          }
          v57 = (float16x8_t *)(a5 + ((uint64_t)(int)v13 << 6) + 2 * v20 * v18);
          *v57 = v23;
          v57[1] = v30;
          v57[2] = v29;
          v57[3] = v28;
          v58 = (float16x8_t *)(v19 + ((uint64_t)(int)v13 << 6) + 2 * v20 * v18);
          *v58 = v27;
          v58[1] = v26;
          v58[2] = v25;
          v58[3] = v24;
          ++v20;
          v22 += 2;
        }
        while (v20 != v17);
      }
      ++v13;
    }
    while (v14 > v13);
  }
}

void NeonDecoderManager::attention_location_matmul(uint64_t a1, uint64_t a2, uint64_t a3, float16x4_t *a4, uint64_t a5, unsigned int a6, unsigned int a7, int a8, int a9, int a10, unsigned int a11)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  float16x8_t v26;
  uint64_t v27;
  float16x4_t *v28;
  uint64_t v29;
  float16x8_t *v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t *v53;
  float16x8_t *v54;

  if ((a9 + a8) >= 8)
  {
    v11 = 0;
    v12 = (a9 + a8) >> 3;
    LODWORD(v13) = a6 >> 3;
    v14 = (a7 >> 3) / a11;
    v15 = v14 * a10 + v14;
    v16 = (int)(a7 >> 3 << 6);
    if (a6 >> 3 <= 1)
      v13 = 1;
    else
      v13 = v13;
    v17 = 2 * (int)(32 * (a6 >> 3));
    do
    {
      if (v14 * a10 < v15)
      {
        v18 = v14 * a10;
        do
        {
          v19 = *(float16x8_t *)(a3 + 16 * (int)v18);
          if (a6 >= 8)
          {
            v27 = 0;
            v28 = a4;
            v29 = v13;
            v26 = *(float16x8_t *)(a3 + 16 * (int)v18);
            v25 = v26;
            v24 = v26;
            v23 = v26;
            v22 = v26;
            v21 = v26;
            v20 = v26;
            do
            {
              v30 = (float16x8_t *)(a2 + 2 * v18 * (int)((8 * a6) & 0xFFFFFFE0) + (v27 << 7));
              v31 = v30[1];
              v32 = *(float16x8_t *)v28[2].i8;
              v34 = *(float16x8_t *)v28[4].i8;
              v33 = *(float16x8_t *)v28[6].i8;
              v35 = v30[2];
              v36 = v30[3];
              v38 = *(float16x8_t *)&v28->i8[64 * (a6 >> 3)];
              v37 = *(float16x8_t *)&v28[2].i8[v17];
              v39 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v19, *v30, COERCE_SHORT_FLOAT(*(_OWORD *)v28->i8)), v31, *v28, 1), v35, *v28, 2), v36, *v28, 3);
              v40 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v26, *v30, *(short float *)v32.i16), v31, *(float16x4_t *)v32.i8, 1), v35, *(float16x4_t *)v32.i8, 2), v36, *(float16x4_t *)v32.i8, 3);
              v41 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v25, *v30, *(short float *)v34.i16), v31, *(float16x4_t *)v34.i8, 1), v35, *(float16x4_t *)v34.i8, 2), v36, *(float16x4_t *)v34.i8, 3);
              v42 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v24, *v30, *(short float *)v33.i16), v31, *(float16x4_t *)v33.i8, 1), v35, *(float16x4_t *)v33.i8, 2), v36, *(float16x4_t *)v33.i8, 3);
              v44 = *(float16x8_t *)&v28[4].i8[v17];
              v43 = *(float16x8_t *)&v28[6].i8[v17];
              v45 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v23, *v30, *(short float *)v38.i16), v31, *(float16x4_t *)v38.i8, 1), v35, *(float16x4_t *)v38.i8, 2), v36, *(float16x4_t *)v38.i8, 3);
              v46 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v22, *v30, *(short float *)v37.i16), v31, *(float16x4_t *)v37.i8, 1), v35, *(float16x4_t *)v37.i8, 2), v36, *(float16x4_t *)v37.i8, 3);
              v47 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v21, *v30, *(short float *)v44.i16), v31, *(float16x4_t *)v44.i8, 1), v35, *(float16x4_t *)v44.i8, 2), v36, *(float16x4_t *)v44.i8, 3);
              v48 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v20, *v30, *(short float *)v43.i16), v31, *(float16x4_t *)v43.i8, 1), v35, *(float16x4_t *)v43.i8, 2), v36, *(float16x4_t *)v43.i8, 3);
              v49 = v30[4];
              v50 = v30[5];
              v52 = v30[6];
              v51 = v30[7];
              v19 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v39, v49, *(float16x8_t *)v28->i8, 4), v50, *(float16x8_t *)v28->i8, 5), v52, *(float16x8_t *)v28->i8, 6), v51, *(float16x8_t *)v28->i8, 7);
              v26 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v40, v49, v32, 4), v50, v32, 5), v52, v32, 6), v51, v32, 7);
              v25 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v41, v49, v34, 4), v50, v34, 5), v52, v34, 6), v51, v34, 7);
              v24 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v42, v49, v33, 4), v50, v33, 5), v52, v33, 6), v51, v33, 7);
              v23 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v45, v49, v38, 4), v50, v38, 5), v52, v38, 6), v51, v38, 7);
              v22 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v46, v49, v37, 4), v50, v37, 5), v52, v37, 6), v51, v37, 7);
              v21 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v47, v49, v44, 4), v50, v44, 5), v52, v44, 6), v51, v44, 7);
              ++v27;
              v28 += 8;
              v20 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v48, v49, v43, 4), v50, v43, 5), v52, v43, 6), v51, v43, 7);
              --v29;
            }
            while (v29);
          }
          else
          {
            v20 = *(float16x8_t *)(a3 + 16 * (int)v18);
            v21 = v20;
            v22 = v20;
            v23 = v20;
            v24 = v20;
            v25 = v20;
            v26 = v20;
          }
          v53 = (float16x8_t *)(a5 + 2 * v11 * v16 + ((uint64_t)(int)v18 << 6));
          *v53 = v19;
          v53[1] = v26;
          v53[2] = v25;
          v53[3] = v24;
          v54 = (float16x8_t *)(a5 + 2 * (int)(32 * (a7 >> 3)) + 2 * v11 * v16 + ((uint64_t)(int)v18 << 6));
          *v54 = v23;
          v54[1] = v22;
          v54[2] = v21;
          v54[3] = v20;
          ++v18;
        }
        while (v15 > v18);
      }
      ++v11;
      a4 = (float16x4_t *)((char *)a4 + 2 * (int)(a6 >> 3 << 6));
    }
    while (v11 != v12);
  }
}

void NeonDecoderManager::attention_out(uint64_t a1, uint64_t a2, float16x8_t *a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, unsigned int a8)
{
  int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  float16x8_t v12;
  uint64_t v13;
  uint64_t v14;
  float16x8_t *v15;
  float16x8_t v16;
  float16x8_t v17;
  float16x8_t v18;
  float16x8_t *v19;
  float16x8_t v20;

  v8 = (a6 >> 3) / a8;
  LODWORD(v9) = v8 * a7;
  v10 = v8 * a7 + v8;
  if (v9 < v10)
  {
    LODWORD(v11) = a5 >> 3;
    if (a5 >> 3 <= 1)
      v11 = 1;
    else
      v11 = v11;
    v9 = (int)v9;
    do
    {
      v12 = 0uLL;
      if (a5 >= 8)
      {
        v13 = 0;
        v14 = v11;
        v15 = a3;
        v16 = 0uLL;
        v17 = 0uLL;
        v18 = 0uLL;
        do
        {
          v19 = (float16x8_t *)(a2 + 2 * v9 * (int)((8 * a5) & 0xFFFFFFE0) + (v13 << 7));
          v20 = *v15++;
          v12 = vmlaq_laneq_f16(vmlaq_n_f16(v12, *v19, *(short float *)v20.i16), v19[4], v20, 4);
          v16 = vmlaq_laneq_f16(vmlaq_lane_f16(v16, v19[1], *(float16x4_t *)v20.i8, 1), v19[5], v20, 5);
          v17 = vmlaq_laneq_f16(vmlaq_lane_f16(v17, v19[2], *(float16x4_t *)v20.i8, 2), v19[6], v20, 6);
          v18 = vmlaq_laneq_f16(vmlaq_lane_f16(v18, v19[3], *(float16x4_t *)v20.i8, 3), v19[7], v20, 7);
          ++v13;
          --v14;
        }
        while (v14);
        v12 = vaddq_f16(v18, vaddq_f16(v17, vaddq_f16(v16, v12)));
      }
      *(float16x8_t *)(a4 + 16 * (_DWORD)v9++) = v12;
    }
    while (v10 > v9);
  }
}

float16x8_t *NeonDecoderManager::stoptoken_linear_projection(float16x8_t *result, float16x8_t *a2, uint64_t a3, float16x8_t *a4, float16x8_t *a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned int a9, unsigned int a10)
{
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  float16x8_t *v16;
  uint64_t v17;
  uint64_t i64;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t *v23;
  uint64_t v24;
  float16x8_t *v25;
  float16x8_t v26;
  float16x8_t *v27;
  float16x8_t *v28;
  unint64_t v29;
  float16x8_t v30;
  float16x8_t v31;

  if (a10 >= 8)
  {
    v10 = 0;
    v11 = a8 >> 3;
    v12 = result[4].i32[0];
    v13 = v12 + 3;
    if (v12 >= 0)
      v13 = result[4].i32[0];
    if (v11 <= 1)
      v14 = 1;
    else
      v14 = v11;
    v15 = (uint64_t)v13 >> 2;
    v16 = a2 + 4;
    v17 = 2 * (int)((8 * (a9 + a8)) & 0xFFFFFFE0);
    i64 = (uint64_t)a2[8 * v11 + 4].i64;
    do
    {
      v19 = *(float16x8_t *)(a3 + 16 * v10);
      v20 = 0uLL;
      if (a8 >= 8)
      {
        v22 = 0uLL;
        v23 = v16;
        v24 = v14;
        v25 = a4;
        v21 = 0uLL;
        do
        {
          v26 = *v25++;
          v19 = vmlaq_laneq_f16(vmlaq_n_f16(v19, v23[-4], *(short float *)v26.i16), *v23, v26, 4);
          v22 = vmlaq_laneq_f16(vmlaq_lane_f16(v22, v23[-3], *(float16x4_t *)v26.i8, 1), v23[1], v26, 5);
          v21 = vmlaq_laneq_f16(vmlaq_lane_f16(v21, v23[-2], *(float16x4_t *)v26.i8, 2), v23[2], v26, 6);
          v20 = vmlaq_laneq_f16(vmlaq_lane_f16(v20, v23[-1], *(float16x4_t *)v26.i8, 3), v23[3], v26, 7);
          v23 += 8;
          --v24;
        }
        while (v24);
      }
      else
      {
        v21 = 0uLL;
        v22 = 0uLL;
      }
      v27 = (float16x8_t *)i64;
      v28 = a5;
      v29 = a8 >> 3;
      if (a9 >= 8)
      {
        do
        {
          v30 = *v28++;
          v19 = vmlaq_laneq_f16(vmlaq_n_f16(v19, v27[-4], *(short float *)v30.i16), *v27, v30, 4);
          v22 = vmlaq_laneq_f16(vmlaq_lane_f16(v22, v27[-3], *(float16x4_t *)v30.i8, 1), v27[1], v30, 5);
          v21 = vmlaq_laneq_f16(vmlaq_lane_f16(v21, v27[-2], *(float16x4_t *)v30.i8, 2), v27[2], v30, 6);
          v20 = vmlaq_laneq_f16(vmlaq_lane_f16(v20, v27[-1], *(float16x4_t *)v30.i8, 3), v27[3], v30, 7);
          ++v29;
          v27 += 8;
        }
        while (v29 < v11 + (a9 >> 3));
      }
      result = (float16x8_t *)(a6 + 16 * v10);
      if (v10 >= v15)
      {
        v31 = vaddq_f16(v20, vaddq_f16(v21, vaddq_f16(v22, v19)));
        *result = v31;
        *(float16x8_t *)(a7 + 16 * ((int)v10 - (int)v15)) = v31;
      }
      else
      {
        *result = vaddq_f16(v20, vaddq_f16(v21, vaddq_f16(v22, v19)));
      }
      ++v10;
      v16 = (float16x8_t *)((char *)v16 + v17);
      i64 += v17;
    }
    while (v10 != a10 >> 3);
  }
  return result;
}

float16x8_t NeonDecoderManager::stoptoken_stop_projection(float16x8_t result, uint64_t a2, float16x8_t *a3, uint64_t a4, float16x8_t *a5, float16x8_t *a6, uint64_t a7, unsigned int a8, unsigned int a9, unsigned int a10)
{
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  float16x8_t *v13;
  uint64_t v14;
  uint64_t i64;
  float16x8_t v16;
  float16x8_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t *v20;
  uint64_t v21;
  float16x8_t *v22;
  float16x8_t v23;
  float16x8_t *v24;
  float16x8_t *v25;
  unint64_t v26;
  float16x8_t v27;

  if (a10 >= 8)
  {
    v10 = 0;
    v11 = a8 >> 3;
    if (a8 >> 3 <= 1)
      v12 = 1;
    else
      v12 = v11;
    v13 = a3 + 4;
    v14 = 2 * (int)((8 * (a9 + a8)) & 0xFFFFFFE0);
    i64 = (uint64_t)a3[8 * v11 + 4].i64;
    do
    {
      v16 = *(float16x8_t *)(a4 + 16 * v10);
      v17 = 0uLL;
      if (a8 >= 8)
      {
        v19 = 0uLL;
        v20 = v13;
        v21 = v12;
        v22 = a5;
        v18 = 0uLL;
        do
        {
          v23 = *v22++;
          v16 = vmlaq_laneq_f16(vmlaq_n_f16(v16, v20[-4], *(short float *)v23.i16), *v20, v23, 4);
          v19 = vmlaq_laneq_f16(vmlaq_lane_f16(v19, v20[-3], *(float16x4_t *)v23.i8, 1), v20[1], v23, 5);
          v18 = vmlaq_laneq_f16(vmlaq_lane_f16(v18, v20[-2], *(float16x4_t *)v23.i8, 2), v20[2], v23, 6);
          v17 = vmlaq_laneq_f16(vmlaq_lane_f16(v17, v20[-1], *(float16x4_t *)v23.i8, 3), v20[3], v23, 7);
          v20 += 8;
          --v21;
        }
        while (v21);
      }
      else
      {
        v18 = 0uLL;
        v19 = 0uLL;
      }
      v24 = (float16x8_t *)i64;
      v25 = a6;
      v26 = a8 >> 3;
      if (a9 >= 8)
      {
        do
        {
          v27 = *v25++;
          v16 = vmlaq_laneq_f16(vmlaq_n_f16(v16, v24[-4], *(short float *)v27.i16), *v24, v27, 4);
          v19 = vmlaq_laneq_f16(vmlaq_lane_f16(v19, v24[-3], *(float16x4_t *)v27.i8, 1), v24[1], v27, 5);
          v18 = vmlaq_laneq_f16(vmlaq_lane_f16(v18, v24[-2], *(float16x4_t *)v27.i8, 2), v24[2], v27, 6);
          v17 = vmlaq_laneq_f16(vmlaq_lane_f16(v17, v24[-1], *(float16x4_t *)v27.i8, 3), v24[3], v27, 7);
          ++v26;
          v24 += 8;
        }
        while (v26 < (a8 >> 3) + (a9 >> 3));
      }
      result = vaddq_f16(v17, vaddq_f16(v18, vaddq_f16(v19, v16)));
      *(float16x8_t *)(a7 + 16 * v10++) = result;
      v13 = (float16x8_t *)((char *)v13 + v14);
      i64 += v14;
    }
    while (v10 != a10 >> 3);
  }
  return result;
}

uint64_t NeonDecoderManager::SetUp(int *a1)
{
  NeonTC2Container *v2;
  uint64_t result;

  v2 = (NeonTC2Container *)*((_QWORD *)a1 + 3);
  if (!*((_BYTE *)v2 + 2304)
    || (result = NeonTC2Container::EngineMCSetUp(v2, a1, 3, (void (*)(void *, int))mc_Decoder_do_loop_inference), (_DWORD)result))
  {
    *((_QWORD *)a1 + 61) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 1024);
    *((_QWORD *)a1 + 62) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 1024);
    *((_QWORD *)a1 + 63) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 1024);
    *((_QWORD *)a1 + 64) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 1024);
    *((_QWORD *)a1 + 65) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 2 * a1[16]);
    *((_QWORD *)a1 + 67) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 2 * *(int *)(*((_QWORD *)a1 + 3) + 3384));
    *(_QWORD *)(*((_QWORD *)a1 + 3) + 3344) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72)
                                                                                           + 32))(*((_QWORD *)a1 + 72), 12000 * a1[16]);
    *((_QWORD *)a1 + 19) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 512);
    *((_QWORD *)a1 + 20) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 2 * *(int *)(*((_QWORD *)a1 + 3) + 3388));
    *((_QWORD *)a1 + 21) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 4096);
    *((_QWORD *)a1 + 22) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 2048);
    *((_QWORD *)a1 + 23) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 2048);
    *((_QWORD *)a1 + 24) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 2048);
    *((_QWORD *)a1 + 32) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 480);
    *((_QWORD *)a1 + 31) = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a1 + 72) + 32))(*((_QWORD *)a1 + 72), 2 * a1[112]);
    return 1;
  }
  return result;
}

uint64_t mc_Decoder_do_loop_inference(uint64_t result, int a2)
{
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  short float v6;
  int v7;
  int v8;
  uint64_t v9;
  __n128 v10;
  uint64_t v11;
  __n128 v12;
  uint64_t v13;
  float16x8_t v14;
  float16x8_t matmul;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  _WORD *v20;
  _WORD *v21;
  __int16 *v22;
  _WORD *v23;
  float v30;
  float v31;
  __int16 v34;
  int v38;
  uint64_t v39;
  int v40;
  float16x8_t *v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t *v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t *v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t *v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t v60;
  int v61;
  __int16 *v62;
  __int16 *v63;
  _WORD *v64;
  uint64_t v65;
  __int16 v66;
  float v69;
  float v70;
  __int16 v71;
  uint64_t v74;
  int v75;
  float16x8_t *v76;
  float16x8_t v77;
  float16x8_t v78;
  float16x8_t v79;
  float16x8_t v80;
  uint64_t v81;
  float16x8_t v82;
  float16x8_t v83;
  float16x8_t v84;
  uint64_t v85;
  float16x8_t v86;
  float16x8_t v87;
  uint64_t v88;
  int v89;
  int v90;
  uint64_t v91;
  _WORD *v92;
  _WORD *v93;
  __int16 *v94;
  _WORD *v95;
  float v98;
  float v99;
  __int16 v102;
  int v106;
  uint64_t v107;
  int v108;
  int v109;
  float16x8_t *v110;
  float16x8_t v111;
  float16x8_t v112;
  float16x8_t v113;
  float16x8_t v114;
  float16x8_t *v115;
  float16x8_t v116;
  float16x8_t v117;
  float16x8_t v118;
  float16x8_t v119;
  float16x8_t *v120;
  float16x8_t v121;
  float16x8_t v122;
  float16x8_t v123;
  float16x8_t v124;
  float16x8_t v125;
  float16x8_t *v126;
  float16x8_t v127;
  float16x8_t v128;
  float16x8_t v129;
  int v130;
  __int16 *v131;
  __int16 *v132;
  _WORD *v133;
  uint64_t v134;
  __int16 v135;
  float v138;
  float v139;
  __int16 v140;
  uint64_t v143;
  int v144;
  float16x8_t *v145;
  float16x8_t v146;
  float16x8_t v147;
  float16x8_t v148;
  float16x8_t v149;
  uint64_t v150;
  float16x8_t v151;
  float16x8_t v152;
  float16x8_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  short float *v162;
  uint64_t v163;
  short float v164;
  uint64_t v166;
  short float *v167;
  short float v168;
  short float v169;
  uint64_t v172;
  short float *v173;
  __int16 v175;
  uint64_t v182;
  short float *v183;
  short float *v187;
  short float v188;
  uint64_t v189;
  uint64_t v190;
  float16x8_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v198;
  uint64_t v199;
  float32x4_t *v200;
  float16x8_t v201;
  int v202;
  int v203;
  int v204;
  int v205;
  int v206;
  int v207;
  float16x8_t v208;
  float16x8_t v209;
  _WORD v211[1536];
  uint64_t v212;

  v2 = a2;
  v3 = result;
  v4 = 0;
  v212 = *MEMORY[0x24BDAC8D0];
  v5 = a2 + 1;
  v207 = 32 * a2;
  LOWORD(v6) = COERCE_UNSIGNED_INT(0.5);
  v208 = (float16x8_t)vdupq_n_s16(0x2E66u);
  v209 = (float16x8_t)vdupq_n_s16(0x3B33u);
  do
  {
    v7 = *(_DWORD *)(v3 + 556);
    if (v7 + v4 >= *(_DWORD *)(v3 + 564) || v4 >= *(_DWORD *)(v3 + 560))
      break;
    v206 = v4;
    if (!v2)
    {
      v8 = (*(_DWORD *)(v3 + 572) << 9) + (v7 << 8);
      *(_DWORD *)(v3 + 548) = v8;
      *(_DWORD *)(v3 + 552) = v8 + 256;
    }
    v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672));
    v10.n128_u16[0] = *(_WORD *)(v3 + 296);
    NeonDecoderManager::prenet_matmul(v10, v9, *(_QWORD *)(v3 + 264), *(_QWORD *)(v3 + 272), *(_QWORD *)(v3 + 304), *(_DWORD *)(v3 + 548), *(float16x8_t **)(v3 + 520), *(_QWORD *)(v3 + 152), *(_DWORD *)(v3 + 64), 0x100u, v202, v2, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 2308));
    v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672));
    v12.n128_u16[0] = *(_WORD *)(v3 + 298);
    NeonDecoderManager::prenet_matmul(v12, v11, *(_QWORD *)(v3 + 280), *(_QWORD *)(v3 + 288), *(_QWORD *)(v3 + 304), *(_DWORD *)(v3 + 552), *(float16x8_t **)(v3 + 152), *(_QWORD *)(v3 + 160), 0x100u, 0x100u, v203, v2, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 2308));
    v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672));
    matmul = NeonDecoderManager::lstm_first_matmul(v14, v13, *(_QWORD *)(v3 + 312), *(_QWORD *)(v3 + 320), (float16x8_t *)*(_QWORD *)(v3 + 160), (float16x8_t *)*(_QWORD *)(v3 + 536), (float16x8_t *)*(_QWORD *)(v3 + 496), *(_QWORD *)(v3 + 168), 0x100u, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 3384), 0x200u, 0x800u, v2, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 2308));
    (*(void (**)(_QWORD, __n128))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672), (__n128)matmul);
    v16 = *(_QWORD *)(v3 + 24);
    v17 = *(_DWORD *)(v16 + 2308);
    v18 = 512 / v17 * v2;
    v204 = 512 / v17 * v5;
    if (v18 < v204)
    {
      v19 = v204 - (uint64_t)v18;
      v20 = (_WORD *)(*(_QWORD *)(v3 + 168) + 2 * v18);
      v21 = &v211[v18 + 1024];
      v22 = (__int16 *)(*(_QWORD *)(v3 + 488) + 2 * v18);
      v23 = &v211[v18 + 512];
      do
      {
        _H0 = v20[512];
        __asm { FCVT            S0, H0 }
        v30 = fabsf(_S0);
        v31 = (float)((float)((float)((float)(v30 * 2.4555) + 2.4555)
                            + (float)((float)((float)(v30 * 0.82123) + 0.89323) * (float)(_S0 * _S0)))
                    * _S0)
            / (float)((float)((float)((float)(_S0 * _S0) + 2.4451) * fabsf(_S0 + (float)((float)(_S0 * 0.81464) * v30)))
                    + 2.4451);
        LOWORD(_S0) = *v20;
        __asm { FCVT            S0, H0 }
        _S0 = (float)(1.0 / (float)(expf(-_S0) + 1.0)) * v31;
        __asm { FCVT            H0, S0 }
        *v21++ = LOWORD(_S0);
        v34 = *v22++;
        LOWORD(_S0) = v34;
        __asm { FCVT            S15, H0 }
        LOWORD(_S0) = v20[1024];
        __asm { FCVT            S0, H0 }
        _S0 = (float)(1.0 / (float)(expf(-(float)(_S0 + 1.0)) + 1.0)) * _S15;
        __asm { FCVT            H0, S0 }
        *v23++ = LOWORD(_S0);
        ++v20;
        --v19;
      }
      while (v19);
    }
    v38 = 16 / v17;
    LODWORD(v39) = 16 / v17 * a2;
    if ((int)v39 >= 16 / v17 * v5)
    {
      v61 = 512 / v17 * v5;
    }
    else
    {
      v39 = (int)v39;
      v40 = v207 * v38;
      do
      {
        v41 = (float16x8_t *)&v211[v40 + 1024];
        v42 = *v41;
        v43 = v41[1];
        v44 = v41[2];
        v45 = v41[3];
        v46 = (float16x8_t *)&v211[v40 + 512];
        v47 = *v46;
        v48 = v46[1];
        v49 = v46[2];
        v50 = v46[3];
        v51 = (float16x8_t *)(*(_QWORD *)(v3 + 488) + 2 * v40);
        v52 = *v51;
        v53 = v51[1];
        v54 = v51[2];
        v55 = v51[3];
        v56 = vaddq_f16(v42, v47);
        v57 = (float16x8_t *)&v211[v40];
        v58 = vaddq_f16(v43, v48);
        *v57 = v56;
        v57[1] = v58;
        v59 = vaddq_f16(v44, v49);
        v60 = vaddq_f16(v45, v50);
        v57[2] = v59;
        v57[3] = v60;
        *v51 = vaddq_f16(vmulq_f16(v56, v209), vmulq_f16(v52, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 488) + 2 * v40 + 16) = vaddq_f16(vmulq_f16(v58, v209), vmulq_f16(v53, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 488) + 2 * v40 + 32) = vaddq_f16(vmulq_f16(v59, v209), vmulq_f16(v54, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 488) + 2 * v40 + 48) = vaddq_f16(vmulq_f16(v60, v209), vmulq_f16(v55, v208));
        ++v39;
        v16 = *(_QWORD *)(v3 + 24);
        v17 = *(_DWORD *)(v16 + 2308);
        v38 = 16 / v17;
        v40 += 32;
      }
      while (v39 < 16 / v17 * v5);
      v18 = 512 / v17 * a2;
      v61 = 512 / v17 * v5;
    }
    if (v18 < v61)
    {
      v62 = (__int16 *)(*(_QWORD *)(v3 + 168) + 2 * v18 + 3072);
      v63 = &v211[v18];
      v64 = (_WORD *)(*(_QWORD *)(v3 + 176) + 2 * v18);
      v65 = v61 - (uint64_t)v18;
      do
      {
        v66 = *v63++;
        _H0 = v66;
        __asm { FCVT            S0, H0 }
        v69 = fabsf(_S0);
        v70 = (float)((float)((float)((float)(v69 * 2.4555) + 2.4555)
                            + (float)((float)((float)(v69 * 0.82123) + 0.89323) * (float)(_S0 * _S0)))
                    * _S0)
            / (float)((float)((float)((float)(_S0 * _S0) + 2.4451) * fabsf(_S0 + (float)((float)(_S0 * 0.81464) * v69)))
                    + 2.4451);
        v71 = *v62++;
        LOWORD(_S0) = v71;
        __asm { FCVT            S0, H0 }
        _S0 = v70 * (float)(1.0 / (float)(expf(-_S0) + 1.0));
        __asm { FCVT            H0, S0 }
        *v64++ = LOWORD(_S0);
        --v65;
      }
      while (v65);
    }
    LODWORD(v74) = v38 * a2;
    if (v38 * a2 < 16 / v17 * v5)
    {
      v74 = (int)v74;
      v75 = v207 * v38;
      do
      {
        v76 = (float16x8_t *)(*(_QWORD *)(v3 + 176) + 2 * v75);
        v77 = *v76;
        v78 = v76[1];
        v79 = v76[2];
        v80 = v76[3];
        v81 = *(_QWORD *)(v3 + 496) + 2 * v75;
        v82 = *(float16x8_t *)(v81 + 16);
        v83 = *(float16x8_t *)(v81 + 32);
        v84 = *(float16x8_t *)(v81 + 48);
        *(float16x8_t *)v81 = vaddq_f16(vmulq_f16(v77, v209), vmulq_f16(*(float16x8_t *)v81, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 496) + 2 * v75 + 16) = vaddq_f16(vmulq_f16(v78, v209), vmulq_f16(v82, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 496) + 2 * v75 + 32) = vaddq_f16(vmulq_f16(v79, v209), vmulq_f16(v83, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 496) + 2 * v75 + 48) = vaddq_f16(vmulq_f16(v80, v209), vmulq_f16(v84, v208));
        ++v74;
        v16 = *(_QWORD *)(v3 + 24);
        v75 += 32;
      }
      while (v74 < 16 / *(_DWORD *)(v16 + 2308) * v5);
    }
    v85 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v16 + 2672) + 8))(*(_QWORD *)(v16 + 2672));
    v87 = NeonDecoderManager::lstm_second_matmul(v86, v85, *(_QWORD *)(v3 + 328), *(_QWORD *)(v3 + 336), (float16x8_t *)*(_QWORD *)(v3 + 176), (float16x8_t *)*(_QWORD *)(v3 + 512), *(_QWORD *)(v3 + 168), 0x200u, 0x200u, 0x800u, a2, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 2308));
    (*(void (**)(_QWORD, __n128))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672), (__n128)v87);
    v88 = *(_QWORD *)(v3 + 24);
    v89 = *(_DWORD *)(v88 + 2308);
    v90 = 512 / v89 * a2;
    v205 = 512 / v89 * v5;
    if (v90 < v205)
    {
      v91 = v205 - (uint64_t)v90;
      v92 = (_WORD *)(*(_QWORD *)(v3 + 168) + 2 * v90);
      v93 = &v211[v90 + 1024];
      v94 = (__int16 *)(*(_QWORD *)(v3 + 504) + 2 * v90);
      v95 = &v211[v90 + 512];
      do
      {
        _H0 = v92[512];
        __asm { FCVT            S0, H0 }
        v98 = fabsf(_S0);
        v99 = (float)((float)((float)((float)(v98 * 2.4555) + 2.4555)
                            + (float)((float)((float)(v98 * 0.82123) + 0.89323) * (float)(_S0 * _S0)))
                    * _S0)
            / (float)((float)((float)((float)(_S0 * _S0) + 2.4451) * fabsf(_S0 + (float)((float)(_S0 * 0.81464) * v98)))
                    + 2.4451);
        LOWORD(_S0) = *v92;
        __asm { FCVT            S0, H0 }
        _S0 = (float)(1.0 / (float)(expf(-_S0) + 1.0)) * v99;
        __asm { FCVT            H0, S0 }
        *v93++ = LOWORD(_S0);
        v102 = *v94++;
        LOWORD(_S0) = v102;
        __asm { FCVT            S15, H0 }
        LOWORD(_S0) = v92[1024];
        __asm { FCVT            S0, H0 }
        _S0 = (float)(1.0 / (float)(expf(-(float)(_S0 + 1.0)) + 1.0)) * _S15;
        __asm { FCVT            H0, S0 }
        *v95++ = LOWORD(_S0);
        ++v92;
        --v91;
      }
      while (v91);
    }
    v106 = 16 / v89;
    LODWORD(v107) = 16 / v89 * a2;
    if ((int)v107 >= 16 / v89 * v5)
    {
      v108 = v206;
      v130 = 512 / v89 * v5;
    }
    else
    {
      v107 = (int)v107;
      v108 = v206;
      v109 = v207 * v106;
      do
      {
        v110 = (float16x8_t *)&v211[v109 + 1024];
        v111 = *v110;
        v112 = v110[1];
        v113 = v110[2];
        v114 = v110[3];
        v115 = (float16x8_t *)&v211[v109 + 512];
        v116 = *v115;
        v117 = v115[1];
        v118 = v115[2];
        v119 = v115[3];
        v120 = (float16x8_t *)(*(_QWORD *)(v3 + 504) + 2 * v109);
        v121 = *v120;
        v122 = v120[1];
        v123 = v120[2];
        v124 = v120[3];
        v125 = vaddq_f16(v111, v116);
        v126 = (float16x8_t *)&v211[v109];
        v127 = vaddq_f16(v112, v117);
        *v126 = v125;
        v126[1] = v127;
        v128 = vaddq_f16(v113, v118);
        v129 = vaddq_f16(v114, v119);
        v126[2] = v128;
        v126[3] = v129;
        *v120 = vaddq_f16(vmulq_f16(v125, v209), vmulq_f16(v121, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 504) + 2 * v109 + 16) = vaddq_f16(vmulq_f16(v127, v209), vmulq_f16(v122, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 504) + 2 * v109 + 32) = vaddq_f16(vmulq_f16(v128, v209), vmulq_f16(v123, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 504) + 2 * v109 + 48) = vaddq_f16(vmulq_f16(v129, v209), vmulq_f16(v124, v208));
        ++v107;
        v88 = *(_QWORD *)(v3 + 24);
        v89 = *(_DWORD *)(v88 + 2308);
        v106 = 16 / v89;
        v109 += 32;
      }
      while (v107 < 16 / v89 * v5);
      v90 = 512 / v89 * a2;
      v130 = 512 / v89 * v5;
    }
    if (v90 < v130)
    {
      v131 = (__int16 *)(*(_QWORD *)(v3 + 168) + 2 * v90 + 3072);
      v132 = &v211[v90];
      v133 = (_WORD *)(*(_QWORD *)(v3 + 176) + 2 * v90);
      v134 = v130 - (uint64_t)v90;
      do
      {
        v135 = *v132++;
        _H0 = v135;
        __asm { FCVT            S0, H0 }
        v138 = fabsf(_S0);
        v139 = (float)((float)((float)((float)(v138 * 2.4555) + 2.4555)
                             + (float)((float)((float)(v138 * 0.82123) + 0.89323) * (float)(_S0 * _S0)))
                     * _S0)
             / (float)((float)((float)((float)(_S0 * _S0) + 2.4451) * fabsf(_S0 + (float)((float)(_S0 * 0.81464) * v138)))
                     + 2.4451);
        v140 = *v131++;
        LOWORD(_S0) = v140;
        __asm { FCVT            S0, H0 }
        _S0 = v139 * (float)(1.0 / (float)(expf(-_S0) + 1.0));
        __asm { FCVT            H0, S0 }
        *v133++ = LOWORD(_S0);
        --v134;
      }
      while (v134);
    }
    v2 = a2;
    LODWORD(v143) = v106 * a2;
    if (v106 * a2 < 16 / v89 * v5)
    {
      v143 = (int)v143;
      v144 = v207 * v106;
      do
      {
        v145 = (float16x8_t *)(*(_QWORD *)(v3 + 176) + 2 * v144);
        v146 = *v145;
        v147 = v145[1];
        v148 = v145[2];
        v149 = v145[3];
        v150 = *(_QWORD *)(v3 + 512) + 2 * v144;
        v151 = *(float16x8_t *)(v150 + 16);
        v152 = *(float16x8_t *)(v150 + 32);
        v153 = *(float16x8_t *)(v150 + 48);
        *(float16x8_t *)v150 = vaddq_f16(vmulq_f16(v146, v209), vmulq_f16(*(float16x8_t *)v150, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 512) + 2 * v144 + 16) = vaddq_f16(vmulq_f16(v147, v209), vmulq_f16(v151, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 512) + 2 * v144 + 32) = vaddq_f16(vmulq_f16(v148, v209), vmulq_f16(v152, v208));
        *(float16x8_t *)(*(_QWORD *)(v3 + 512) + 2 * v144 + 48) = vaddq_f16(vmulq_f16(v149, v209), vmulq_f16(v153, v208));
        ++v143;
        v88 = *(_QWORD *)(v3 + 24);
        v144 += 32;
      }
      while (v143 < 16 / *(_DWORD *)(v88 + 2308) * v5);
    }
    v154 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v88 + 2672) + 8))(*(_QWORD *)(v88 + 2672));
    NeonDecoderManager::attention_location_feature(v154, *(_QWORD *)(v3 + 352), *(_QWORD *)(v3 + 360), *(float16x4_t **)(v3 + 528), *(_QWORD *)(v3 + 216), *(_DWORD *)(*(_QWORD *)(v3 + 24) + 3396), *(_DWORD *)(v3 + 544), 0x20u, *(_DWORD *)(v3 + 368), a2, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 2308));
    v155 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672));
    NeonDecoderManager::attention_location_matmul(v155, *(_QWORD *)(v3 + 376), *(_QWORD *)(v3 + 384), *(float16x4_t **)(v3 + 216), *(_QWORD *)(v3 + 224), 0x20u, 0x80u, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 3396), *(_DWORD *)(v3 + 544), a2, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 2308));
    v156 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672));
    NeonDecoderManager::attention_query_matmul(v156, *(_QWORD *)(v3 + 344), *(_QWORD *)(*(_QWORD *)(v3 + 24) + 3368), *(_QWORD *)(v3 + 224), *(float16x8_t **)(v3 + 176), *(_QWORD *)(v3 + 200), 0x200u, 0x80u, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 3396), *(_DWORD *)(v3 + 544), a2, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 2308));
    v157 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672));
    NeonDecoderManager::attention_tanh(v157, *(_QWORD *)(v3 + 392), *(_QWORD *)(v3 + 200), *(_QWORD *)(v3 + 224), 0x80u, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 3396), *(_DWORD *)(v3 + 544), a2, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 2308));
    (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672));
    v158 = *(_QWORD *)(v3 + 24);
    if (!a2)
    {
      v159 = *(unsigned int *)(v158 + 3396);
      if ((int)v159 >= 1)
      {
        v160 = 0;
        v161 = *(_QWORD *)(v3 + 224);
        v162 = *(short float **)(v3 + 232);
        do
        {
          v163 = 0;
          LOWORD(v164) = 0;
          do
          {
            v164 = (short float)((short float)((short float)((short float)((short float)((short float)((short float)(v164 + COERCE_SHORT_FLOAT(*(_OWORD *)(v161 + v163))) + COERCE_SHORT_FLOAT(WORD1(*(_OWORD *)(v161 + v163))))
                                                                                       + COERCE_SHORT_FLOAT(HIDWORD(*(_QWORD *)(v161 + v163))))
                                                                         + COERCE_SHORT_FLOAT(HIWORD(*(_QWORD *)(v161 + v163))))
                                                           + COERCE_SHORT_FLOAT(*(_QWORD *)(v161 + v163 + 8)))
                                             + COERCE_SHORT_FLOAT(WORD1(*(_QWORD *)(v161 + v163 + 8))))
                               + COERCE_SHORT_FLOAT(HIDWORD(*(_OWORD *)(v161 + v163))))
                 + COERCE_SHORT_FLOAT(HIWORD(*(_OWORD *)(v161 + v163)));
            v163 += 16;
          }
          while (v163 != 256);
          v162[v160++] = v164;
          v161 += 256;
        }
        while (v160 != v159);
        _H0 = *v162;
        v166 = v159;
        v167 = v162;
        do
        {
          v168 = *v167++;
          v169 = v168;
          if (_H0 <= v168)
            _H0 = v169;
          --v166;
        }
        while (v166);
        __asm { FCVT            S15, H0 }
        _H0 = 0;
        v172 = v159;
        v173 = v162;
        do
        {
          __asm { FCVT            S14, H0 }
          v175 = *(_WORD *)v173++;
          _H0 = v175;
          __asm { FCVT            S0, H0 }
          _S0 = expf(_S0 - _S15) + _S14;
          __asm { FCVT            H0, S0 }
          --v172;
        }
        while (v172);
        __asm { FCVT            S0, H0; float }
        _S0 = logf(_S0) + _S15;
        __asm
        {
          FCVT            H0, S0
          FCVT            S15, H0
        }
        v182 = v159;
        v183 = v162;
        do
        {
          _H0 = *(_WORD *)v183;
          __asm { FCVT            S0, H0 }
          _S0 = expf(_S0 - _S15);
          __asm { FCVT            H0, S0 }
          *v183++ = *(short float *)&_S0;
          --v182;
        }
        while (v182);
        v187 = (short float *)(*(_QWORD *)(v3 + 528) + 30);
        LOWORD(v6) = COERCE_UNSIGNED_INT(0.5);
        do
        {
          v188 = *v162++;
          *v187 = *v187 + v188;
          ++v187;
          --v159;
        }
        while (v159);
      }
    }
    v189 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v158 + 2672) + 8))(*(_QWORD *)(v158 + 2672));
    NeonDecoderManager::attention_out(v189, *(_QWORD *)(v3 + 408), *(float16x8_t **)(v3 + 232), *(_QWORD *)(v3 + 536), *(_DWORD *)(v3 + 400), *(_DWORD *)(*(_QWORD *)(v3 + 24) + 3384), a2, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 2308));
    (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672));
    v190 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v3 + 24) + 2672) + 8))(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 2672));
    if (a2)
    {
      v192 = *(_QWORD *)(v3 + 24);
      if (a2 == 1)
      {
        NeonDecoderManager::stoptoken_stop_projection(v191, v190, *(float16x8_t **)(v3 + 432), *(_QWORD *)(v3 + 440), *(float16x8_t **)(v3 + 176), *(float16x8_t **)(v3 + 536), *(_QWORD *)(v3 + 248), 0x200u, *(_DWORD *)(v192 + 3384), *(_DWORD *)(v3 + 448));
        v193 = 0;
        v194 = *(_QWORD *)(v3 + 248);
        do
        {
          _H0 = *(_WORD *)(v194 + v193);
          __asm { FCVT            S0, H0 }
          _S0 = 1.0 / (float)(expf(-_S0) + 1.0);
          __asm { FCVT            H0, S0 }
          *(_WORD *)(v194 + v193) = LOWORD(_S0);
          if (*(short float *)&_S0 > v6)
            *(_BYTE *)(v3 + 568) = 1;
          v193 += 2;
        }
        while (v193 != 6);
        v192 = *(_QWORD *)(v3 + 24);
      }
    }
    else
    {
      NeonDecoderManager::stoptoken_linear_projection((float16x8_t *)v3, *(float16x8_t **)(v3 + 416), *(_QWORD *)(v3 + 424), *(float16x8_t **)(v3 + 176), *(float16x8_t **)(v3 + 536), *(_QWORD *)(v3 + 256), *(_QWORD *)(v3 + 520), 0x200u, *(_DWORD *)(*(_QWORD *)(v3 + 24) + 3384), 0xF0u);
      v198 = 0;
      v199 = *(_QWORD *)(v3 + 256);
      v192 = *(_QWORD *)(v3 + 24);
      v200 = (float32x4_t *)(*(_QWORD *)(v192 + 3344) + 960 * (*(_DWORD *)(v3 + 556) + v108));
      do
      {
        v201 = *(float16x8_t *)(v199 + v198);
        *v200 = vcvtq_f32_f16(*(float16x4_t *)v201.i8);
        v200[1] = vcvt_hight_f32_f16(v201);
        v200 += 2;
        v198 += 16;
      }
      while (v198 != 480);
    }
    v4 = v108 + 1;
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v192 + 2672) + 8))(*(_QWORD *)(v192 + 2672));
  }
  while (!*(_BYTE *)(v3 + 568));
  if (!v2)
    *(_DWORD *)(v3 + 572) = v4;
  return result;
}

uint64_t NeonDecoderManager::do_step_inference(NeonDecoderManager *this, int a2, __n128 a3)
{
  __n128 v5;
  uint64_t v6;
  uint64_t v7;
  float16x8_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float v21;
  float32x4_t v22;
  float v23;
  float32x4_t v24;
  float32x4_t v25;
  float v26;
  float32x4_t v27;
  float v28;
  float32x4_t v29;
  unint64_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t *v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  _OWORD *v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  float v55;
  float v58;
  uint64_t v61;
  uint64_t v63;
  float16x8_t v64;
  float16x8_t v65;
  float16x8_t *v66;
  float16x8_t v67;
  float16x8_t v68;
  float16x8_t v69;
  float16x8_t v70;
  float16x8_t *v71;
  float16x8_t v72;
  float16x8_t v73;
  float16x8_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float v82;
  float32x4_t v83;
  float v84;
  float32x4_t v85;
  float32x4_t v86;
  float v87;
  float32x4_t v88;
  float v89;
  float32x4_t v90;
  unint64_t v91;
  float16x8_t v92;
  float16x8_t v93;
  float16x8_t v94;
  float16x8_t v95;
  float16x8_t v96;
  float16x8_t v97;
  float16x8_t v98;
  float16x8_t v99;
  float16x8_t *v100;
  float16x8_t v101;
  float16x8_t v102;
  float16x8_t v103;
  float16x8_t v104;
  float16x8_t v105;
  _OWORD *v106;
  float16x8_t v107;
  float16x8_t v108;
  float16x8_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  float v115;
  float v116;
  uint64_t v118;
  uint64_t v120;
  float16x8_t v121;
  float16x8_t v122;
  float16x8_t *v123;
  float16x8_t v124;
  float16x8_t v125;
  float16x8_t v126;
  float16x8_t v127;
  float16x8_t *v128;
  float16x8_t v129;
  float16x8_t v130;
  float16x8_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  float16x8_t *v138;
  uint64_t v139;
  short float v140;
  unint64_t v141;
  uint64_t v143;
  unint64_t v144;
  unint64_t v151;
  unint64_t v157;
  uint64_t v158;
  float16x8_t *v159;
  float16x8_t v160;
  uint64_t v161;
  char v162;
  uint64_t v163;
  int v168;
  int v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  _BYTE v199[3072];
  uint64_t v200;
  _QWORD v201[5];

  v200 = *MEMORY[0x24BDAC8D0];
  a3.n128_u16[0] = *((_WORD *)this + 148);
  NeonDecoderManager::prenet_matmul(a3, (uint64_t)this, *((_QWORD *)this + 33), *((_QWORD *)this + 34), *((_QWORD *)this + 38), *((_DWORD *)this + 143) << 9, *((float16x8_t **)this + 65), *((_QWORD *)this + 19), *((_DWORD *)this + 16), 0x100u, v168, 0, *(_DWORD *)(*((_QWORD *)this + 3) + 2308));
  v5.n128_u16[0] = *((_WORD *)this + 149);
  NeonDecoderManager::prenet_matmul(v5, v6, *((_QWORD *)this + 35), *((_QWORD *)this + 36), *((_QWORD *)this + 38), (*((_DWORD *)this + 143) << 9) | 0x100, *((float16x8_t **)this + 19), *((_QWORD *)this + 20), 0x100u, 0x100u, v169, 0, *(_DWORD *)(*((_QWORD *)this + 3) + 2308));
  NeonDecoderManager::lstm_first_matmul(v8, v7, *((_QWORD *)this + 39), *((_QWORD *)this + 40), *((float16x8_t **)this + 20), *((float16x8_t **)this + 67), *((float16x8_t **)this + 62), *((_QWORD *)this + 21), 0x100u, *(_DWORD *)(*((_QWORD *)this + 3) + 3384), 0x200u, 0x800u, 0, *(_DWORD *)(*((_QWORD *)this + 3) + 2308));
  v9 = 0;
  v10 = *((_QWORD *)this + 21);
  v176 = (float32x4_t)vdupq_n_s32(0x3F523BE9u);
  v178 = (float32x4_t)vdupq_n_s32(0x401D2709u);
  v172 = (float32x4_t)vdupq_n_s32(0x401C7BF8u);
  v174 = (float32x4_t)vdupq_n_s32(0x3F64AAB6u);
  v11 = *((_QWORD *)this + 61);
  __asm { FMOV            V1.4S, #1.0 }
  v170 = (float32x4_t)vdupq_n_s32(0x3F508C6Du);
  v198 = _Q1;
  do
  {
    v17 = vcvtq_f32_f16(*(float16x4_t *)(v10 + v9 + 1024));
    v18 = vabsq_f32(v17);
    v19 = vmulq_f32(v17, v17);
    v180 = vdivq_f32(vmulq_f32(vmlaq_f32(vmlaq_f32(v178, v178, v18), v19, vmlaq_f32(v174, v176, v18)), v17), vmlaq_f32(v172, vabsq_f32(vmlaq_f32(v17, v18, vmulq_f32(v17, v170))), vaddq_f32(v19, v172)));
    v194 = vnegq_f32(vcvtq_f32_f16(*(float16x4_t *)(v10 + v9)));
    v184 = expf(v194.f32[1]);
    v20.f32[0] = expf(v194.f32[0]);
    v20.f32[1] = v184;
    v185 = v20;
    v21 = expf(v194.f32[2]);
    v22 = v185;
    v22.f32[2] = v21;
    v186 = v22;
    v23 = expf(v194.f32[3]);
    v24 = v186;
    v24.f32[3] = v23;
    *(float16x4_t *)&v199[v9 + 2048] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v198, vaddq_f32(v24, v198)), v180));
    v181 = vcvtq_f32_f16(*(float16x4_t *)(v11 + v9));
    v195 = vnegq_f32(vaddq_f32(vcvtq_f32_f16(*(float16x4_t *)(v10 + v9 + 2048)), v198));
    v186.i32[0] = expf(v195.f32[1]);
    v25.f32[0] = expf(v195.f32[0]);
    v25.i32[1] = v186.i32[0];
    v187 = v25;
    v26 = expf(v195.f32[2]);
    v27 = v187;
    v27.f32[2] = v26;
    v188 = v27;
    v28 = expf(v195.f32[3]);
    v29 = v188;
    v29.f32[3] = v28;
    *(float16x4_t *)&v199[v9 + 1024] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v198, vaddq_f32(v29, v198)), v181));
    v9 += 8;
  }
  while (v9 != 1024);
  v30 = -1024;
  v31 = (float16x8_t)vdupq_n_s16(0x3B33u);
  v32 = (float16x8_t)vdupq_n_s16(0x2E66u);
  do
  {
    v33 = *(float16x8_t *)&v201[v30 / 8];
    v34 = *(float16x8_t *)&v201[v30 / 8 + 2];
    v35 = *(float16x8_t *)&v201[v30 / 8 + 4];
    v36 = *(float16x8_t *)&v199[v30 + 2064];
    v37 = *(float16x8_t *)&v199[v30 + 2080];
    v38 = *(float16x8_t *)&v199[v30 + 2096];
    v39 = (float16x8_t *)(*((_QWORD *)this + 61) + v30);
    v40 = v39[64];
    v41 = v39[65];
    v42 = v39[66];
    v43 = v39[67];
    v44 = vaddq_f16(*(float16x8_t *)&v199[v30 + 3072], *(float16x8_t *)&v199[v30 + 2048]);
    v45 = &v199[v30];
    v45[64] = v44;
    v46 = vaddq_f16(v33, v36);
    v45[65] = v46;
    v47 = vaddq_f16(v34, v37);
    v45[66] = v47;
    v48 = vaddq_f16(v35, v38);
    v45[67] = v48;
    v39[64] = vaddq_f16(vmulq_f16(v44, v31), vmulq_f16(v40, v32));
    *(float16x8_t *)(*((_QWORD *)this + 61) + v30 + 1040) = vaddq_f16(vmulq_f16(v46, v31), vmulq_f16(v41, v32));
    *(float16x8_t *)(*((_QWORD *)this + 61) + v30 + 1056) = vaddq_f16(vmulq_f16(v47, v31), vmulq_f16(v42, v32));
    *(float16x8_t *)(*((_QWORD *)this + 61) + v30 + 1072) = vaddq_f16(vmulq_f16(v48, v31), vmulq_f16(v43, v32));
    v30 += 64;
  }
  while (v30);
  v49 = 0;
  v50 = *((_QWORD *)this + 22);
  v51 = *((_QWORD *)this + 21) + 3072;
  do
  {
    _H0 = *(_WORD *)&v199[v49];
    __asm { FCVT            S8, H0 }
    _S0 = fabsf(_S8);
    v55 = (float)((float)((float)((float)(_S0 * 2.4555) + 2.4555)
                        + (float)((float)((float)(_S0 * 0.82123) + 0.89323) * (float)(_S8 * _S8)))
                * _S8)
        / (float)((float)((float)((float)(_S8 * _S8) + 2.4451) * fabsf(_S8 + (float)((float)(_S8 * 0.81464) * _S0)))
                + 2.4451);
    LOWORD(_S0) = *(_WORD *)(v51 + v49);
    __asm { FCVT            S0, H0 }
    _S0 = v55 * (float)(1.0 / (float)(expf(-_S0) + 1.0));
    __asm { FCVT            H0, S0 }
    *(_WORD *)(v50 + v49) = LOWORD(_S0);
    v58 = tanhf(_S8);
    _H0 = *(_WORD *)(v51 + v49);
    __asm { FCVT            S0, H0 }
    _S0 = v58 * (float)(1.0 / (float)(expf(-_S0) + 1.0));
    __asm { FCVT            H0, S0 }
    *(_WORD *)(v50 + v49) = LOWORD(_S0);
    v49 += 2;
  }
  while (v49 != 1024);
  v63 = -1024;
  v64 = (float16x8_t)vdupq_n_s16(0x3B33u);
  v65 = (float16x8_t)vdupq_n_s16(0x2E66u);
  do
  {
    v66 = (float16x8_t *)(*((_QWORD *)this + 22) + v63);
    v67 = v66[64];
    v68 = v66[65];
    v69 = v66[66];
    v70 = v66[67];
    v71 = (float16x8_t *)(*((_QWORD *)this + 62) + v63);
    v72 = v71[65];
    v73 = v71[66];
    v74 = v71[67];
    v71[64] = vaddq_f16(vmulq_f16(v67, v64), vmulq_f16(v71[64], v65));
    *(float16x8_t *)(*((_QWORD *)this + 62) + v63 + 1040) = vaddq_f16(vmulq_f16(v68, v64), vmulq_f16(v72, v65));
    *(float16x8_t *)(*((_QWORD *)this + 62) + v63 + 1056) = vaddq_f16(vmulq_f16(v69, v64), vmulq_f16(v73, v65));
    *(float16x8_t *)(*((_QWORD *)this + 62) + v63 + 1072) = vaddq_f16(vmulq_f16(v70, v64), vmulq_f16(v74, v65));
    v63 += 64;
  }
  while (v63);
  NeonDecoderManager::lstm_second_matmul(v64, v61, *((_QWORD *)this + 41), *((_QWORD *)this + 42), *((float16x8_t **)this + 22), *((float16x8_t **)this + 64), *((_QWORD *)this + 21), 0x200u, 0x200u, 0x800u, 0, *(_DWORD *)(*((_QWORD *)this + 3) + 2308));
  v75 = 0;
  v76 = *((_QWORD *)this + 21);
  v177 = (float32x4_t)vdupq_n_s32(0x3F523BE9u);
  v179 = (float32x4_t)vdupq_n_s32(0x401D2709u);
  v173 = (float32x4_t)vdupq_n_s32(0x401C7BF8u);
  v175 = (float32x4_t)vdupq_n_s32(0x3F64AAB6u);
  v171 = (float32x4_t)vdupq_n_s32(0x3F508C6Du);
  v77 = *((_QWORD *)this + 63);
  do
  {
    v78 = vcvtq_f32_f16(*(float16x4_t *)(v76 + v75 + 1024));
    v79 = vabsq_f32(v78);
    v80 = vmulq_f32(v78, v78);
    v182 = vdivq_f32(vmulq_f32(vmlaq_f32(vmlaq_f32(v179, v179, v79), v80, vmlaq_f32(v175, v177, v79)), v78), vmlaq_f32(v173, vabsq_f32(vmlaq_f32(v78, v79, vmulq_f32(v78, v171))), vaddq_f32(v80, v173)));
    v196 = vnegq_f32(vcvtq_f32_f16(*(float16x4_t *)(v76 + v75)));
    v189 = expf(v196.f32[1]);
    v81.f32[0] = expf(v196.f32[0]);
    v81.f32[1] = v189;
    v190 = v81;
    v82 = expf(v196.f32[2]);
    v83 = v190;
    v83.f32[2] = v82;
    v191 = v83;
    v84 = expf(v196.f32[3]);
    v85 = v191;
    v85.f32[3] = v84;
    *(float16x4_t *)&v199[v75 + 2048] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v198, vaddq_f32(v85, v198)), v182));
    v183 = vcvtq_f32_f16(*(float16x4_t *)(v77 + v75));
    v197 = vnegq_f32(vaddq_f32(vcvtq_f32_f16(*(float16x4_t *)(v76 + v75 + 2048)), v198));
    v191.i32[0] = expf(v197.f32[1]);
    v86.f32[0] = expf(v197.f32[0]);
    v86.i32[1] = v191.i32[0];
    v192 = v86;
    v87 = expf(v197.f32[2]);
    v88 = v192;
    v88.f32[2] = v87;
    v193 = v88;
    v89 = expf(v197.f32[3]);
    v90 = v193;
    v90.f32[3] = v89;
    *(float16x4_t *)&v199[v75 + 1024] = vcvt_f16_f32(vmulq_f32(vdivq_f32(v198, vaddq_f32(v90, v198)), v183));
    v75 += 8;
  }
  while (v75 != 1024);
  v91 = -1024;
  v92 = (float16x8_t)vdupq_n_s16(0x3B33u);
  v93 = (float16x8_t)vdupq_n_s16(0x2E66u);
  do
  {
    v94 = *(float16x8_t *)&v201[v91 / 8];
    v95 = *(float16x8_t *)&v201[v91 / 8 + 2];
    v96 = *(float16x8_t *)&v201[v91 / 8 + 4];
    v97 = *(float16x8_t *)&v199[v91 + 2064];
    v98 = *(float16x8_t *)&v199[v91 + 2080];
    v99 = *(float16x8_t *)&v199[v91 + 2096];
    v100 = (float16x8_t *)(*((_QWORD *)this + 63) + v91);
    v101 = v100[64];
    v102 = v100[65];
    v103 = v100[66];
    v104 = v100[67];
    v105 = vaddq_f16(*(float16x8_t *)&v199[v91 + 3072], *(float16x8_t *)&v199[v91 + 2048]);
    v106 = &v199[v91];
    v106[64] = v105;
    v107 = vaddq_f16(v94, v97);
    v106[65] = v107;
    v108 = vaddq_f16(v95, v98);
    v106[66] = v108;
    v109 = vaddq_f16(v96, v99);
    v106[67] = v109;
    v100[64] = vaddq_f16(vmulq_f16(v105, v92), vmulq_f16(v101, v93));
    *(float16x8_t *)(*((_QWORD *)this + 63) + v91 + 1040) = vaddq_f16(vmulq_f16(v107, v92), vmulq_f16(v102, v93));
    *(float16x8_t *)(*((_QWORD *)this + 63) + v91 + 1056) = vaddq_f16(vmulq_f16(v108, v92), vmulq_f16(v103, v93));
    *(float16x8_t *)(*((_QWORD *)this + 63) + v91 + 1072) = vaddq_f16(vmulq_f16(v109, v92), vmulq_f16(v104, v93));
    v91 += 64;
  }
  while (v91);
  v110 = 0;
  v111 = *((_QWORD *)this + 22);
  v112 = *((_QWORD *)this + 21) + 3072;
  do
  {
    _H0 = *(_WORD *)&v199[v110];
    __asm { FCVT            S0, H0 }
    v115 = fabsf(_S0);
    v116 = (float)((float)((float)((float)(v115 * 2.4555) + 2.4555)
                         + (float)((float)((float)(v115 * 0.82123) + 0.89323) * (float)(_S0 * _S0)))
                 * _S0)
         / (float)((float)((float)((float)(_S0 * _S0) + 2.4451) * fabsf(_S0 + (float)((float)(_S0 * 0.81464) * v115)))
                 + 2.4451);
    LOWORD(_S0) = *(_WORD *)(v112 + v110);
    __asm { FCVT            S0, H0 }
    _S0 = v116 * (float)(1.0 / (float)(expf(-_S0) + 1.0));
    __asm { FCVT            H0, S0 }
    *(_WORD *)(v111 + v110) = LOWORD(_S0);
    v110 += 2;
  }
  while (v110 != 1024);
  v120 = -1024;
  v121 = (float16x8_t)vdupq_n_s16(0x3B33u);
  v122 = (float16x8_t)vdupq_n_s16(0x2E66u);
  do
  {
    v123 = (float16x8_t *)(*((_QWORD *)this + 22) + v120);
    v124 = v123[64];
    v125 = v123[65];
    v126 = v123[66];
    v127 = v123[67];
    v128 = (float16x8_t *)(*((_QWORD *)this + 64) + v120);
    v129 = v128[65];
    v130 = v128[66];
    v131 = v128[67];
    v128[64] = vaddq_f16(vmulq_f16(v124, v121), vmulq_f16(v128[64], v122));
    *(float16x8_t *)(*((_QWORD *)this + 64) + v120 + 1040) = vaddq_f16(vmulq_f16(v125, v121), vmulq_f16(v129, v122));
    *(float16x8_t *)(*((_QWORD *)this + 64) + v120 + 1056) = vaddq_f16(vmulq_f16(v126, v121), vmulq_f16(v130, v122));
    *(float16x8_t *)(*((_QWORD *)this + 64) + v120 + 1072) = vaddq_f16(vmulq_f16(v127, v121), vmulq_f16(v131, v122));
    v120 += 64;
  }
  while (v120);
  NeonDecoderManager::attention_location_feature(v118, *((_QWORD *)this + 44), *((_QWORD *)this + 45), *((float16x4_t **)this + 66), *((_QWORD *)this + 27), a2, *((_DWORD *)this + 136), 0x20u, *((_DWORD *)this + 92), 0, *(_DWORD *)(*((_QWORD *)this + 3) + 2308));
  NeonDecoderManager::attention_location_matmul(v132, *((_QWORD *)this + 47), *((_QWORD *)this + 48), *((float16x4_t **)this + 27), *((_QWORD *)this + 28), 0x20u, 0x80u, a2, *((_DWORD *)this + 136), 0, *(_DWORD *)(*((_QWORD *)this + 3) + 2308));
  NeonDecoderManager::attention_query_matmul(v133, *((_QWORD *)this + 43), *(_QWORD *)(*((_QWORD *)this + 3) + 3368), *((_QWORD *)this + 28), *((float16x8_t **)this + 22), *((_QWORD *)this + 25), 0x200u, 0x80u, a2, *((_DWORD *)this + 136), 0, *(_DWORD *)(*((_QWORD *)this + 3) + 2308));
  NeonDecoderManager::attention_tanh(v134, *((_QWORD *)this + 49), *((_QWORD *)this + 25), *((_QWORD *)this + 28), 0x80u, *(_DWORD *)(*((_QWORD *)this + 3) + 3396), *((_DWORD *)this + 136), 0, *(_DWORD *)(*((_QWORD *)this + 3) + 2308));
  if (a2 <= 0)
  {
    v138 = (float16x8_t *)*((_QWORD *)this + 29);
  }
  else
  {
    v136 = 0;
    v137 = *((_QWORD *)this + 28);
    v138 = (float16x8_t *)*((_QWORD *)this + 29);
    do
    {
      v139 = 0;
      LOWORD(v140) = 0;
      do
      {
        v140 = (short float)((short float)((short float)((short float)((short float)((short float)((short float)(v140 + COERCE_SHORT_FLOAT(*(_OWORD *)(v137 + v139)))
                                                                                                 + COERCE_SHORT_FLOAT(WORD1(*(_OWORD *)(v137 + v139))))
                                                                                   + COERCE_SHORT_FLOAT(HIDWORD(*(_QWORD *)(v137 + v139))))
                                                                     + COERCE_SHORT_FLOAT(HIWORD(*(_QWORD *)(v137 + v139))))
                                                       + COERCE_SHORT_FLOAT(*(_QWORD *)(v137 + v139 + 8)))
                                         + COERCE_SHORT_FLOAT(WORD1(*(_QWORD *)(v137 + v139 + 8))))
                           + COERCE_SHORT_FLOAT(HIDWORD(*(_OWORD *)(v137 + v139))))
             + COERCE_SHORT_FLOAT(HIWORD(*(_OWORD *)(v137 + v139)));
        v139 += 16;
      }
      while (v139 != 256);
      *(short float *)&v138->i16[v136++] = v140;
      v137 += 256;
    }
    while (v136 != a2);
    v141 = 0;
    _H0 = *(short float *)v138->i16;
    v143 = 2 * a2;
    do
    {
      if (_H0 <= *(short float *)&v138->i16[v141 / 2])
        _H0 = *(short float *)&v138->i16[v141 / 2];
      v141 += 2;
    }
    while (v143 != v141);
    v144 = 0;
    __asm { FCVT            S8, H0 }
    LOWORD(_H9) = 0;
    do
    {
      _H0 = v138->i16[v144 / 2];
      __asm { FCVT            S0, H0 }
      _S0 = expf(_S0 - _S8);
      __asm { FCVT            H0, S0 }
      _H9 = _H9 + *(short float *)&_S0;
      v144 += 2;
    }
    while (v143 != v144);
    __asm { FCVT            S0, H9; float }
    v151 = 0;
    _S0 = logf(_S0) + _S8;
    __asm
    {
      FCVT            H0, S0
      FCVT            S8, H0
    }
    do
    {
      _H0 = v138->i16[v151 / 2];
      __asm { FCVT            S0, H0 }
      _S0 = expf(_S0 - _S8);
      __asm { FCVT            H0, S0 }
      v138->i16[v151 / 2] = LOWORD(_S0);
      v151 += 2;
    }
    while (v143 != v151);
    v157 = 0;
    v158 = *((_QWORD *)this + 66) + 30;
    do
    {
      *(short float *)(v158 + v157) = *(short float *)(v158 + v157) + *(short float *)&v138->i16[v157 / 2];
      v157 += 2;
    }
    while (v143 != v157);
  }
  NeonDecoderManager::attention_out(v135, *((_QWORD *)this + 51), v138, *((_QWORD *)this + 67), *((_DWORD *)this + 100), *(_DWORD *)(*((_QWORD *)this + 3) + 3384), 0, *(_DWORD *)(*((_QWORD *)this + 3) + 2308));
  v159 = NeonDecoderManager::stoptoken_linear_projection((float16x8_t *)this, *((float16x8_t **)this + 52), *((_QWORD *)this + 53), *((float16x8_t **)this + 22), *((float16x8_t **)this + 67), *((_QWORD *)this + 32), *((_QWORD *)this + 65), 0x200u, *(_DWORD *)(*((_QWORD *)this + 3) + 3384), 0xF0u);
  NeonDecoderManager::stoptoken_stop_projection(v160, (uint64_t)v159, *((float16x8_t **)this + 54), *((_QWORD *)this + 55), *((float16x8_t **)this + 22), *((float16x8_t **)this + 67), *((_QWORD *)this + 31), 0x200u, *(_DWORD *)(*((_QWORD *)this + 3) + 3384), *((_DWORD *)this + 112));
  v161 = 0;
  v162 = 0;
  v163 = *((_QWORD *)this + 31);
  do
  {
    _H0 = *(_WORD *)(v163 + v161);
    __asm { FCVT            S0, H0 }
    _S0 = 1.0 / (float)(expf(-_S0) + 1.0);
    __asm { FCVT            H0, S0 }
    *(_WORD *)(v163 + v161) = LOWORD(_S0);
    v162 |= *(short float *)&_S0 > COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(0.5));
    v161 += 2;
  }
  while (v161 != 6);
  return v162 & 1;
}

uint64_t NeonDecoderManager::do_loop_inference(NeonDecoderManager *this, int a2, int a3, int a4)
{
  *((_DWORD *)this + 143) = 0;
  *((_BYTE *)this + 568) = 0;
  *((_DWORD *)this + 139) = a2;
  *((_DWORD *)this + 140) = a3;
  *((_DWORD *)this + 141) = a4;
  SynchroManager::cond_broadcast_on_entry((SynchroManager *)(*((_QWORD *)this + 3) + 2312), *(_DWORD *)(*((_QWORD *)this + 3) + 2308), 4);
  SynchroManager::cond_wait_less_on_exit((SynchroManager *)(*((_QWORD *)this + 3) + 2312), *(_DWORD *)(*((_QWORD *)this + 3) + 2308));
  return *((unsigned int *)this + 143);
}

uint64_t NeonDecoderManager::do_inference(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  void *v14;
  int v15;
  void *v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  int v34;
  int v35;
  uint64_t i;
  _QWORD *v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  void *v59;
  __n128 v60;
  uint64_t v61;
  int v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  float32x4_t *v67;
  float16x8_t v68;
  float32x4_t v69;
  _QWORD *v70;
  unint64_t v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _QWORD *v79;
  _QWORD *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  _QWORD *v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  _QWORD *v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  _QWORD *v99;
  _QWORD *v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  _QWORD *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t result;
  _QWORD *v114;
  _QWORD *v115;
  _QWORD *v116;
  uint64_t v117;
  _QWORD *v118;

  srand(0x4D2u);
  v10 = *(_QWORD *)(a1 + 24);
  if (!*(_BYTE *)(v10 + 2722))
  {
    if (a3[1] - *a3 <= 8uLL)
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    *(_DWORD *)(v10 + 3396) = *(_QWORD *)(*a3 + 8);
  }
  bzero(*(void **)(a1 + 488), 0x400uLL);
  bzero(*(void **)(a1 + 496), 0x400uLL);
  bzero(*(void **)(a1 + 504), 0x400uLL);
  bzero(*(void **)(a1 + 512), 0x400uLL);
  bzero(*(void **)(a1 + 536), 2 * *(int *)(*(_QWORD *)(a1 + 24) + 3384));
  bzero(*(void **)(*(_QWORD *)(a1 + 24) + 3344), 12000 * *(_DWORD *)(a1 + 64));
  bzero(*(void **)(a1 + 520), 2 * *(int *)(a1 + 64));
  v11 = *(int *)(*(_QWORD *)(a1 + 24) + 3396);
  if ((int)v11 <= 0)
    v12 = -(-(int)v11 & 7);
  else
    v12 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396) & 7;
  if (v12)
  {
    v13 = 8 - v12;
    *(_DWORD *)(a1 + 544) = v13;
    *(_QWORD *)(a1 + 200) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 2 * ((v13 + (int)v11) << 7));
    v14 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 2 * (*(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396) + *(_DWORD *)(a1 + 544) + 31));
    *(_QWORD *)(a1 + 528) = v14;
    bzero(v14, 2 * (*(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396) + *(_DWORD *)(a1 + 544) + 31));
    *(_QWORD *)(a1 + 216) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 64 * (*(_DWORD *)(a1 + 544) + *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396)));
    v15 = *(_DWORD *)(a1 + 544) + *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396);
  }
  else
  {
    *(_DWORD *)(a1 + 544) = 0;
    *(_QWORD *)(a1 + 200) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), v11 << 8);
    v16 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 2 * *(int *)(*(_QWORD *)(a1 + 24) + 3396) + 62);
    *(_QWORD *)(a1 + 528) = v16;
    bzero(v16, 2 * *(int *)(*(_QWORD *)(a1 + 24) + 3396) + 62);
    *(_QWORD *)(a1 + 216) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), (uint64_t)*(int *)(*(_QWORD *)(a1 + 24) + 3396) << 6);
    v15 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3396);
  }
  *(_QWORD *)(a1 + 224) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 2 * (v15 << 7));
  v17 = *(_QWORD *)(a1 + 24);
  v18 = *(_DWORD *)(v17 + 3396);
  if (v18 <= 0)
    v19 = -(-v18 & 7);
  else
    v19 = *(_DWORD *)(v17 + 3396) & 7;
  v20 = v18 - v19 + 8;
  *(_DWORD *)(a1 + 400) = v20;
  v21 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 2 * v20 * *(_DWORD *)(v17 + 3384));
  *(_QWORD *)(a1 + 408) = v21;
  v22 = *(_QWORD *)(a1 + 24);
  if (!*(_BYTE *)(v22 + 2722))
  {
    v23 = *(int *)(v22 + 3396);
    v24 = *(_DWORD *)(a1 + 544) + v23;
    if (v24 >= 4)
    {
      v25 = 0;
      v26 = 0;
      v27 = v24 >> 2;
      do
      {
        v28 = 0;
        v29 = v25 >> 3;
        v30 = v25 >> 3;
        do
        {
          v31 = 0;
          v32 = *a2;
          v33 = (a2[1] - *a2) >> 2;
          v34 = v29;
          v35 = v30;
          do
          {
            if (v31 + 4 * v26 >= v23)
            {
              v42 = (_QWORD *)(*(_QWORD *)(v22 + 3368) + ((v26 & 0x7FFFFF) << 10) + (v28 << 6) + 16 * v31);
              *v42 = 0;
              v42[1] = 0;
            }
            else
            {
              for (i = 0; i != 8; ++i)
              {
                if (v33 <= 8 * (unint64_t)(v34 & 0x1FFFFFFF) + i)
                  std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
                _S0 = *(_DWORD *)(v32 + 32 * (v34 & 0x1FFFFFFF) + 4 * i);
                __asm { FCVT            H0, S0 }
                *(_WORD *)(*(_QWORD *)(v22 + 3368) + 16 * (v35 & 0x1FFFFFFF) + 2 * i) = _S0;
              }
            }
            ++v31;
            ++v35;
            v34 += 16;
          }
          while (v31 != 4);
          ++v28;
          LODWORD(v30) = v30 + 4;
          LODWORD(v29) = v29 + 1;
        }
        while (v28 != 16);
        ++v26;
        v25 += 512;
      }
      while (v26 != v27);
    }
  }
  v43 = *(_DWORD *)(v22 + 3384);
  if (v43 >= 0)
    v44 = *(_DWORD *)(v22 + 3384);
  else
    v44 = v43 + 7;
  v45 = *(int *)(a1 + 400);
  if (v43 >= 8)
  {
    v46 = 0;
    v47 = 0;
    v48 = 0;
    v49 = v44 >> 3;
    do
    {
      if ((int)v45 >= 8)
      {
        v50 = 0;
        v51 = *(_DWORD *)(v22 + 3396);
        v52 = v46;
        do
        {
          v53 = 0;
          v54 = v52;
          do
          {
            v55 = (_QWORD *)(v21 + 2 * v48);
            if (v53 + 8 * v50 >= v51)
            {
              *v55 = 0;
              v55[1] = 0;
              v48 += 8;
            }
            else
            {
              v56 = 0;
              v57 = *(_QWORD *)(v22 + 3328);
              do
              {
                _S0 = *(_DWORD *)(v57 + 4 * (v54 + (int)v56));
                __asm { FCVT            H0, S0 }
                *((_WORD *)v55 + v56++) = _S0;
              }
              while (v56 != 8);
              v48 += 8;
            }
            ++v53;
            v54 += v43;
          }
          while (v53 != 8);
          ++v50;
          v52 += 8 * v43;
        }
        while (v50 != (int)v45 / 8);
      }
      ++v47;
      v46 += 8;
    }
    while (v47 != v49);
  }
  v59 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 576) + 32))(*(_QWORD *)(a1 + 576), 2 * v45);
  *(_QWORD *)(a1 + 232) = v59;
  bzero(v59, 2 * *(int *)(a1 + 400));
  *(_BYTE *)(a1 + 568) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  v61 = *(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(v61 + 2304))
  {
    *(_DWORD *)(a1 + 556) = 0;
    *(int32x2_t *)(a1 + 560) = vdup_n_s32(0x3E8u);
    SynchroManager::cond_broadcast_on_entry((SynchroManager *)(v61 + 2312), *(_DWORD *)(v61 + 2308), 4);
    SynchroManager::cond_wait_less_on_exit((SynchroManager *)(*(_QWORD *)(a1 + 24) + 2312), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    v62 = *(_DWORD *)(a1 + 572);
    v61 = *(_QWORD *)(a1 + 24);
  }
  else
  {
    while (1)
    {
      v63 = NeonDecoderManager::do_step_inference((NeonDecoderManager *)a1, *(_DWORD *)(v61 + 3396), v60);
      v64 = 0;
      *(_BYTE *)(a1 + 568) = v63;
      v65 = *(_QWORD *)(a1 + 256);
      v61 = *(_QWORD *)(a1 + 24);
      v66 = *(_DWORD *)(a1 + 572);
      v67 = (float32x4_t *)(*(_QWORD *)(v61 + 3344) + 960 * v66);
      do
      {
        v68 = *(float16x8_t *)(v65 + v64);
        v69 = vcvtq_f32_f16(*(float16x4_t *)v68.i8);
        v60 = (__n128)vcvt_hight_f32_f16(v68);
        *v67 = v69;
        v67[1] = (float32x4_t)v60;
        v67 += 2;
        v64 += 16;
      }
      while (v64 != 480);
      v62 = v66 + 1;
      *(_DWORD *)(a1 + 572) = v66 + 1;
      if (v66 >= 999)
        break;
      if (v63)
        goto LABEL_50;
    }
    *(_BYTE *)(a1 + 568) = 1;
  }
LABEL_50:
  *(_DWORD *)(v61 + 3304) = 3 * v62;
  v70 = (_QWORD *)a5[1];
  v71 = a5[2];
  if ((unint64_t)v70 >= v71)
  {
    v73 = (_QWORD *)*a5;
    v74 = ((uint64_t)v70 - *a5) >> 3;
    v75 = v74 + 1;
    if ((unint64_t)(v74 + 1) >> 61)
      goto LABEL_103;
    v76 = v71 - (_QWORD)v73;
    if (v76 >> 2 > v75)
      v75 = v76 >> 2;
    if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8)
      v77 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v77 = v75;
    v118 = a5 + 3;
    if (v77)
    {
      v78 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v77);
      v73 = (_QWORD *)*a5;
      v70 = (_QWORD *)a5[1];
    }
    else
    {
      v78 = 0;
    }
    v79 = (_QWORD *)(v78 + 8 * v74);
    *v79 = 1;
    if (v70 == v73)
    {
      v81 = v78 + 8 * v74;
    }
    else
    {
      v80 = v70;
      v81 = v78 + 8 * v74;
      do
      {
        v82 = *--v80;
        *(_QWORD *)(v81 - 8) = v82;
        v81 -= 8;
      }
      while (v80 != v73);
    }
    v72 = v79 + 1;
    *a5 = v81;
    a5[1] = (uint64_t)(v79 + 1);
    v83 = a5[2];
    a5[2] = v78 + 8 * v77;
    v116 = v70;
    v117 = v83;
    v114 = v73;
    v115 = v73;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v114);
    v61 = *(_QWORD *)(a1 + 24);
    v71 = a5[2];
  }
  else
  {
    *v70 = 1;
    v72 = v70 + 1;
  }
  a5[1] = (uint64_t)v72;
  v84 = *(int *)(v61 + 3304);
  if ((unint64_t)v72 >= v71)
  {
    v86 = (_QWORD *)*a5;
    v87 = ((uint64_t)v72 - *a5) >> 3;
    v88 = v87 + 1;
    if ((unint64_t)(v87 + 1) >> 61)
      goto LABEL_103;
    v89 = v71 - (_QWORD)v86;
    if (v89 >> 2 > v88)
      v88 = v89 >> 2;
    if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8)
      v90 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v90 = v88;
    v118 = a5 + 3;
    if (v90)
    {
      v91 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v90);
      v86 = (_QWORD *)*a5;
      v72 = (_QWORD *)a5[1];
    }
    else
    {
      v91 = 0;
    }
    v92 = (_QWORD *)(v91 + 8 * v87);
    *v92 = v84;
    if (v72 == v86)
    {
      v94 = v91 + 8 * v87;
    }
    else
    {
      v93 = v72;
      v94 = v91 + 8 * v87;
      do
      {
        v95 = *--v93;
        *(_QWORD *)(v94 - 8) = v95;
        v94 -= 8;
      }
      while (v93 != v86);
    }
    v85 = v92 + 1;
    *a5 = v94;
    a5[1] = (uint64_t)(v92 + 1);
    v96 = a5[2];
    a5[2] = v91 + 8 * v90;
    v116 = v72;
    v117 = v96;
    v114 = v86;
    v115 = v86;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v114);
    v71 = a5[2];
  }
  else
  {
    *v72 = v84;
    v85 = v72 + 1;
  }
  a5[1] = (uint64_t)v85;
  v97 = *(_DWORD *)(a1 + 64);
  v98 = v97;
  if ((unint64_t)v85 < v71)
  {
    *v85 = v97;
    v99 = v85 + 1;
    goto LABEL_101;
  }
  v100 = (_QWORD *)*a5;
  v101 = ((uint64_t)v85 - *a5) >> 3;
  v102 = v101 + 1;
  if ((unint64_t)(v101 + 1) >> 61)
LABEL_103:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  v103 = v71 - (_QWORD)v100;
  if (v103 >> 2 > v102)
    v102 = v103 >> 2;
  if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF8)
    v104 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v104 = v102;
  v118 = a5 + 3;
  if (v104)
  {
    v105 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v104);
    v100 = (_QWORD *)*a5;
    v85 = (_QWORD *)a5[1];
  }
  else
  {
    v105 = 0;
  }
  v106 = (_QWORD *)(v105 + 8 * v101);
  *v106 = v98;
  if (v85 == v100)
  {
    v108 = v105 + 8 * v101;
  }
  else
  {
    v107 = v85;
    v108 = v105 + 8 * v101;
    do
    {
      v109 = *--v107;
      *(_QWORD *)(v108 - 8) = v109;
      v108 -= 8;
    }
    while (v107 != v100);
  }
  v99 = v106 + 1;
  *a5 = v108;
  a5[1] = (uint64_t)(v106 + 1);
  v110 = a5[2];
  a5[2] = v105 + 8 * v104;
  v116 = v85;
  v117 = v110;
  v114 = v100;
  v115 = v100;
  std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v114);
  v97 = *(_DWORD *)(a1 + 64);
LABEL_101:
  a5[1] = (uint64_t)v99;
  v111 = *(_QWORD *)(a1 + 24);
  v112 = *(int *)(v111 + 3304) * (uint64_t)v97;
  std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a4, *(char **)(v111 + 3344), *(_QWORD *)(v111 + 3344) + 4 * v112, v112);
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), *(_QWORD *)(a1 + 200));
  *(_QWORD *)(a1 + 200) = 0;
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), *(_QWORD *)(a1 + 528));
  *(_QWORD *)(a1 + 528) = 0;
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), *(_QWORD *)(a1 + 216));
  *(_QWORD *)(a1 + 216) = 0;
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), *(_QWORD *)(a1 + 224));
  *(_QWORD *)(a1 + 224) = 0;
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), *(_QWORD *)(a1 + 408));
  *(_QWORD *)(a1 + 408) = 0;
  result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 576) + 56))(*(_QWORD *)(a1 + 576), *(_QWORD *)(a1 + 232));
  *(_QWORD *)(a1 + 232) = 0;
  return result;
}

std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this)
{
  size_t i;
  size_t v2;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3;

  i = this->__i_;
  v2 = (i + 1) % 0x270;
  v3 = this->__x_[(i + 397) % 0x270] ^ ((this->__x_[v2] & 0x7FFFFFFE | this->__x_[i] & 0x80000000) >> 1) ^ ((int)(this->__x_[v2] << 31) >> 31) & 0x9908B0DF;
  this->__x_[i] = v3;
  this->__i_ = v2;
  LODWORD(i) = ((v3 ^ (v3 >> 11)) << 7) & 0x9D2C5680 ^ v3 ^ (v3 >> 11);
  return ((_DWORD)i << 15) & 0xEFC60000 ^ i ^ ((((_DWORD)i << 15) & 0xEFC60000 ^ i) >> 18);
}

uint64_t NeonPostNetManager::NeonPostNetManager(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 464) = 0;
  *(_QWORD *)(a1 + 472) = 0;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]((_QWORD *)(a1 + 464), a3);
  *(_DWORD *)(a1 + 64) = 80;
  *(_BYTE *)(*(_QWORD *)(a1 + 24) + 2724) = 0;
  return a1;
}

{
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = CustomAllocator::mRsrc;
  *(_QWORD *)(a1 + 464) = 0;
  *(_QWORD *)(a1 + 472) = 0;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = 0;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]((_QWORD *)(a1 + 464), a3);
  *(_DWORD *)(a1 + 64) = 80;
  *(_BYTE *)(*(_QWORD *)(a1 + 24) + 2724) = 0;
  return a1;
}

void NeonPostNetManager::~NeonPostNetManager(NeonPostNetManager *this)
{
  _QWORD *v2;
  char *v3;
  _QWORD *v4;
  uint64_t v5;

  v2 = (_QWORD *)((char *)this + 464);
  v3 = (char *)this + 152;
  v4 = (_QWORD *)((char *)this + 160);
  v5 = -160;
  do
  {
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 56))(*v2, *(v4 - 1));
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 56))(*v2, *v4);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 56))(*v2, *(_QWORD *)&v3[v5 + 240]);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 56))(*v2, *(_QWORD *)&v3[v5 + 248]);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 56))(*v2, *(_QWORD *)&v3[v5 + 256]);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 56))(*v2, *(_QWORD *)&v3[v5 + 264]);
    v4 += 2;
    v5 += 32;
  }
  while (v5);
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 58) + 56))(*((_QWORD *)this + 58), *((_QWORD *)this + 17));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 58) + 56))(*((_QWORD *)this + 58), *((_QWORD *)this + 18));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 58) + 56))(*((_QWORD *)this + 58), *(_QWORD *)(*((_QWORD *)this + 3) + 3352));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 58) + 56))(*((_QWORD *)this + 58), *((_QWORD *)this + 50));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 58) + 56))(*((_QWORD *)this + 58), *((_QWORD *)this + 49));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 58) + 56))(*((_QWORD *)this + 58), *((_QWORD *)this + 53));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 58) + 56))(*((_QWORD *)this + 58), *((_QWORD *)this + 52));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 58) + 56))(*((_QWORD *)this + 58), *((_QWORD *)this + 51));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  if (*((char *)this + 55) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 7) + 8), *((_QWORD *)this + 4));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

uint64_t NeonPostNetManager::ModelNpy(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  uint64_t i;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _WORD *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  _QWORD *v39;
  const std::locale::facet *v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  _WORD *v45;
  unint64_t v46;
  int v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  int j;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _WORD *v73;
  uint64_t v74;
  _QWORD *v75;
  const std::locale::facet *v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _WORD *v85;
  uint64_t v86;
  _QWORD *v87;
  const std::locale::facet *v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  _QWORD *v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  _WORD *v97;
  uint64_t v98;
  _QWORD *v99;
  const std::locale::facet *v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  _WORD *v109;
  uint64_t v110;
  _QWORD *v111;
  const std::locale::facet *v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  _QWORD *v116;
  _QWORD *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  _QWORD *v128;
  const std::locale::facet *v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  _QWORD *v133;
  _QWORD *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  _WORD *v141;
  unint64_t v142;
  int v143;
  uint64_t v144;
  unint64_t v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  uint64_t v156;
  int v157;
  _QWORD *v158;
  const std::locale::facet *v159;
  int v160;
  uint64_t v161;
  uint64_t v162;
  _QWORD *v163;
  _QWORD *v164;
  uint64_t v165;
  _WORD *v166;
  uint64_t v167;
  __int16 *v168;
  uint64_t v169;
  __int16 v170;
  _QWORD *v171;
  const std::locale::facet *v172;
  _QWORD *v174;
  uint64_t v175[2];
  char v176;
  uint64_t v177;
  uint64_t v178[2];
  char v179;
  uint64_t v180;
  uint64_t v181[2];
  char v182;
  uint64_t v183;
  uint64_t v184[2];
  char v185;
  uint64_t v186;
  uint64_t v187[2];
  char v188;
  uint64_t v189;
  uint64_t v190[2];
  char v191;
  uint64_t v192;
  uint64_t v193[2];
  char v194;
  uint64_t v195;
  uint64_t v196[2];
  char v197;
  uint64_t v198;
  std::locale v199;
  void *v200;
  void *v201;
  uint64_t v202;
  char v203;
  uint64_t v204;
  _QWORD v205[19];
  std::locale v206;
  void *v207;
  _QWORD v208[10];
  char v209;
  uint64_t v210;
  void *v211;
  _WORD *v212;
  _WORD *v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;

  v220 = 0;
  v221 = 0;
  v222 = 0;
  v223 = CustomAllocator::mRsrc;
  v216 = 0;
  v217 = 0;
  v218 = 0;
  v219 = CustomAllocator::mRsrc;
  v212 = 0;
  v213 = 0;
  v214 = 0;
  v215 = CustomAllocator::mRsrc;
  v174 = (_QWORD *)(a2 + 16);
  v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a2 + 16), (uint64_t)"path: ", 6);
  v4 = *(char *)(a1 + 55);
  if (v4 >= 0)
    v5 = a1 + 32;
  else
    v5 = *(_QWORD *)(a1 + 32);
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a1 + 55);
  else
    v6 = *(_QWORD *)(a1 + 40);
  v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, v5, v6);
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
  v8 = std::locale::use_facet(&v206, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v206);
  std::ostream::put();
  std::ostream::flush();
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v206);
  for (i = 0; i != 5; ++i)
  {
    v221 = v220;
    v213 = v212;
    v217 = v216;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v199);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v199, (uint64_t *)&v206);
    v199.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v205[0] = &unk_24D29B3D8;
    v200 = &unk_24D29B3B0;
    v201 = &unk_24D29B578;
    if (v203 < 0)
      heap_Free(*(_QWORD **)(v204 + 8), v202);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v205);
    v10 = *(char *)(a1 + 55);
    if (v10 >= 0)
      v11 = a1 + 32;
    else
      v11 = *(_QWORD *)(a1 + 32);
    if (v10 >= 0)
      v12 = *(unsigned __int8 *)(a1 + 55);
    else
      v12 = *(_QWORD *)(a1 + 40);
    v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v207, v11, v12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"/w", 2);
    v14 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"/npy", 4);
    v15 = *(_QWORD *)(a1 + 464);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v208, v196);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v15 + 24))(v15, v196, &v220, &v212, 1);
    if (v197 < 0)
      heap_Free(*(_QWORD **)(v198 + 8), v196[0]);
    if (v213 == v212)
    {
      v39 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v174, (uint64_t)"error: conv_weight", 18);
      std::ios_base::getloc((const std::ios_base *)((char *)v39 + *(_QWORD *)(*v39 - 24)));
      v40 = std::locale::use_facet(&v199, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v40->__vftable[2].~facet_0)(v40, 10);
      std::locale::~locale(&v199);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v16 = *(_QWORD *)(a1 + 464);
      if (i)
      {
        v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v16 + 32))(v16, 2621440);
        v18 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 2621440);
        v19 = 0;
        *(_QWORD *)(a1 + 16 * i + 152) = v18;
        v20 = v212;
        v21 = v213 - v212;
        v22 = v17;
        do
        {
          v23 = 0;
          v24 = v19;
          v25 = v22;
          do
          {
            v26 = 0;
            v27 = v24;
            do
            {
              if (v21 <= v27)
                std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
              *(_WORD *)(v25 + v26) = v20[v27];
              v26 += 2;
              v27 += 2560;
            }
            while (v26 != 1024);
            ++v23;
            v25 += 1024;
            v24 += 5;
          }
          while (v23 != 512);
          ++v19;
          v22 += 0x80000;
        }
        while (v19 != 5);
        v28 = 0;
        v29 = 0;
        v30 = v17;
        do
        {
          v31 = 0;
          v32 = v30;
          do
          {
            v33 = 0;
            v34 = v32;
            do
            {
              v35 = 0;
              v36 = v34;
              do
              {
                v37 = 0;
                v38 = v29;
                do
                {
                  *(_WORD *)(v18 + 2 * v29 + 2 * v37) = *(_WORD *)(v36 + 2 * v37);
                  ++v37;
                }
                while (v37 != 8);
                ++v35;
                v36 += 1024;
                v29 += 8;
              }
              while (v35 != 4);
              ++v33;
              v34 += 4096;
              v29 = v38 + 8;
            }
            while (v33 != 128);
            ++v31;
            v32 += 0x80000;
            v29 = v38 + 8;
          }
          while (v31 != 5);
          ++v28;
          v30 += 16;
          v29 = v38 + 8;
        }
        while (v28 != 64);
      }
      else
      {
        v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v16 + 32))(v16, 5120 * *(int *)(a1 + 64));
        v41 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 5120 * *(int *)(a1 + 64));
        v42 = 0;
        v43 = 0;
        *(_QWORD *)(a1 + 152) = v41;
        v44 = *(_DWORD *)(a1 + 64);
        v45 = v212;
        v46 = v213 - v212;
        v47 = v44 << 9;
        do
        {
          if (v44 >= 1)
          {
            v48 = 0;
            v49 = v43;
            v50 = v42;
            do
            {
              v51 = 0;
              v52 = v49;
              do
              {
                if (v46 <= v52)
                  std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
                *(_WORD *)(v17 + 2 * (v50 + (int)v51++)) = v45[v52];
                v52 += 5 * v44;
              }
              while (v51 != 512);
              ++v48;
              v50 += 512;
              v49 += 5;
            }
            while (v48 != v44);
          }
          ++v43;
          v42 += v47;
        }
        while (v43 != 5);
        v53 = 0;
        v54 = 0;
        for (j = 0; j != 64; ++j)
        {
          v56 = 0;
          v57 = v53;
          do
          {
            if (v44 >= 4)
            {
              v58 = 0;
              v59 = v57;
              do
              {
                v60 = 0;
                v61 = v59;
                do
                {
                  v62 = 0;
                  v63 = v54;
                  v64 = v41 + 2 * v54;
                  do
                  {
                    *(_WORD *)(v64 + 2 * v62) = *(_WORD *)(v17 + 2 * (v61 + (int)v62));
                    ++v62;
                  }
                  while (v62 != 8);
                  v54 = v63 + 8;
                  ++v60;
                  v61 += 512;
                }
                while (v60 != 4);
                ++v58;
                v59 += 2048;
                v54 = v63 + 8;
              }
              while (v58 != v44 / 4);
              v54 = v63 + 8;
            }
            ++v56;
            v57 += v47;
          }
          while (v56 != 5);
          v53 += 8;
        }
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 56))(*(_QWORD *)(a1 + 464), v17);
    }
    v221 = v220;
    v213 = v212;
    v217 = v216;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v199);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v199, (uint64_t *)&v206);
    v199.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v200 = &unk_24D29B3B0;
    v205[0] = &unk_24D29B3D8;
    v201 = &unk_24D29B578;
    if (v203 < 0)
      heap_Free(*(_QWORD **)(v204 + 8), v202);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v205);
    v65 = *(char *)(a1 + 55);
    if (v65 >= 0)
      v66 = a1 + 32;
    else
      v66 = *(_QWORD *)(a1 + 32);
    if (v65 >= 0)
      v67 = *(unsigned __int8 *)(a1 + 55);
    else
      v67 = *(_QWORD *)(a1 + 40);
    v68 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v207, v66, v67);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)"/b", 2);
    v69 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v69, (uint64_t)"/npy", 4);
    v70 = *(_QWORD *)(a1 + 464);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v208, v193);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v70 + 24))(v70, v193, &v220, &v212, 1);
    if (v194 < 0)
      heap_Free(*(_QWORD **)(v195 + 8), v193[0]);
    if (v213 != v212)
    {
      v71 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 1024);
      v72 = 0;
      *(_QWORD *)(a1 + 16 * i + 160) = v71;
      v73 = v212;
      v74 = v213 - v212;
      while (v74 != v72)
      {
        *(_WORD *)(v71 + 2 * v72) = v73[v72];
        if (++v72 == 512)
          goto LABEL_76;
      }
LABEL_193:
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    }
    v75 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v174, (uint64_t)"error: conv_bias", 16);
    std::ios_base::getloc((const std::ios_base *)((char *)v75 + *(_QWORD *)(*v75 - 24)));
    v76 = std::locale::use_facet(&v199, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v76->__vftable[2].~facet_0)(v76, 10);
    std::locale::~locale(&v199);
    std::ostream::put();
    std::ostream::flush();
LABEL_76:
    v221 = v220;
    v213 = v212;
    v217 = v216;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v199);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v199, (uint64_t *)&v206);
    v199.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v200 = &unk_24D29B3B0;
    v205[0] = &unk_24D29B3D8;
    v201 = &unk_24D29B578;
    if (v203 < 0)
      heap_Free(*(_QWORD **)(v204 + 8), v202);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v205);
    v77 = *(char *)(a1 + 55);
    if (v77 >= 0)
      v78 = a1 + 32;
    else
      v78 = *(_QWORD *)(a1 + 32);
    if (v77 >= 0)
      v79 = *(unsigned __int8 *)(a1 + 55);
    else
      v79 = *(_QWORD *)(a1 + 40);
    v80 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v207, v78, v79);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v80, (uint64_t)"/gamma", 6);
    v81 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v81, (uint64_t)"/npy", 4);
    v82 = *(_QWORD *)(a1 + 464);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v208, v190);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v82 + 24))(v82, v190, &v220, &v212, 1);
    if (v191 < 0)
      heap_Free(*(_QWORD **)(v192 + 8), v190[0]);
    if (v213 != v212)
    {
      v83 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 1024);
      v84 = 0;
      *(_QWORD *)(a1 + 32 * i + 232) = v83;
      v85 = v212;
      v86 = v213 - v212;
      while (v86 != v84)
      {
        *(_WORD *)(v83 + 2 * v84) = v85[v84];
        if (++v84 == 512)
          goto LABEL_92;
      }
      goto LABEL_193;
    }
    v87 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v174, (uint64_t)"error: batch norm gamma", 23);
    std::ios_base::getloc((const std::ios_base *)((char *)v87 + *(_QWORD *)(*v87 - 24)));
    v88 = std::locale::use_facet(&v199, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v88->__vftable[2].~facet_0)(v88, 10);
    std::locale::~locale(&v199);
    std::ostream::put();
    std::ostream::flush();
LABEL_92:
    v221 = v220;
    v213 = v212;
    v217 = v216;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v199);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v199, (uint64_t *)&v206);
    v199.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v200 = &unk_24D29B3B0;
    v205[0] = &unk_24D29B3D8;
    v201 = &unk_24D29B578;
    if (v203 < 0)
      heap_Free(*(_QWORD **)(v204 + 8), v202);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v205);
    v89 = *(char *)(a1 + 55);
    if (v89 >= 0)
      v90 = a1 + 32;
    else
      v90 = *(_QWORD *)(a1 + 32);
    if (v89 >= 0)
      v91 = *(unsigned __int8 *)(a1 + 55);
    else
      v91 = *(_QWORD *)(a1 + 40);
    v92 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v207, v90, v91);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)"/beta", 5);
    v93 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v93, (uint64_t)"/npy", 4);
    v94 = *(_QWORD *)(a1 + 464);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v208, v187);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v94 + 24))(v94, v187, &v220, &v212, 1);
    if (v188 < 0)
      heap_Free(*(_QWORD **)(v189 + 8), v187[0]);
    if (v213 != v212)
    {
      v95 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 1024);
      v96 = 0;
      *(_QWORD *)(a1 + 32 * i + 240) = v95;
      v97 = v212;
      v98 = v213 - v212;
      while (v98 != v96)
      {
        *(_WORD *)(v95 + 2 * v96) = v97[v96];
        if (++v96 == 512)
          goto LABEL_108;
      }
      goto LABEL_193;
    }
    v99 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v174, (uint64_t)"error: batch norm beta", 22);
    std::ios_base::getloc((const std::ios_base *)((char *)v99 + *(_QWORD *)(*v99 - 24)));
    v100 = std::locale::use_facet(&v199, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v100->__vftable[2].~facet_0)(v100, 10);
    std::locale::~locale(&v199);
    std::ostream::put();
    std::ostream::flush();
LABEL_108:
    v221 = v220;
    v213 = v212;
    v217 = v216;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v199);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v199, (uint64_t *)&v206);
    v199.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v200 = &unk_24D29B3B0;
    v205[0] = &unk_24D29B3D8;
    v201 = &unk_24D29B578;
    if (v203 < 0)
      heap_Free(*(_QWORD **)(v204 + 8), v202);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v205);
    v101 = *(char *)(a1 + 55);
    if (v101 >= 0)
      v102 = a1 + 32;
    else
      v102 = *(_QWORD *)(a1 + 32);
    if (v101 >= 0)
      v103 = *(unsigned __int8 *)(a1 + 55);
    else
      v103 = *(_QWORD *)(a1 + 40);
    v104 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v207, v102, v103);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v104, (uint64_t)"/mu", 3);
    v105 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v105, (uint64_t)"/npy", 4);
    v106 = *(_QWORD *)(a1 + 464);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v208, v184);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v106 + 24))(v106, v184, &v220, &v212, 1);
    if (v185 < 0)
      heap_Free(*(_QWORD **)(v186 + 8), v184[0]);
    if (v213 != v212)
    {
      v107 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 1024);
      v108 = 0;
      *(_QWORD *)(a1 + 32 * i + 248) = v107;
      v109 = v212;
      v110 = v213 - v212;
      while (v110 != v108)
      {
        *(_WORD *)(v107 + 2 * v108) = v109[v108];
        if (++v108 == 512)
          goto LABEL_124;
      }
      goto LABEL_193;
    }
    v111 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v174, (uint64_t)"error: batch norm mu", 20);
    std::ios_base::getloc((const std::ios_base *)((char *)v111 + *(_QWORD *)(*v111 - 24)));
    v112 = std::locale::use_facet(&v199, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v112->__vftable[2].~facet_0)(v112, 10);
    std::locale::~locale(&v199);
    std::ostream::put();
    std::ostream::flush();
LABEL_124:
    v221 = v220;
    v213 = v212;
    v217 = v216;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v199);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v199, (uint64_t *)&v206);
    v199.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v200 = &unk_24D29B3B0;
    v205[0] = &unk_24D29B3D8;
    v201 = &unk_24D29B578;
    if (v203 < 0)
      heap_Free(*(_QWORD **)(v204 + 8), v202);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v205);
    v113 = *(char *)(a1 + 55);
    if (v113 >= 0)
      v114 = a1 + 32;
    else
      v114 = *(_QWORD *)(a1 + 32);
    if (v113 >= 0)
      v115 = *(unsigned __int8 *)(a1 + 55);
    else
      v115 = *(_QWORD *)(a1 + 40);
    v116 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v207, v114, v115);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v116, (uint64_t)"/sigma", 6);
    v117 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v117, (uint64_t)"/npy", 4);
    v118 = *(_QWORD *)(a1 + 464);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v208, v181);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v118 + 16))(v118, v181, &v220, &v216, 1);
    if (v182 < 0)
      heap_Free(*(_QWORD **)(v183 + 8), v181[0]);
    if (v217 == v216)
    {
      v128 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v174, (uint64_t)"error: batch norm sigma [sqrt]", 30);
      std::ios_base::getloc((const std::ios_base *)((char *)v128 + *(_QWORD *)(*v128 - 24)));
      v129 = std::locale::use_facet(&v199, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v129->__vftable[2].~facet_0)(v129, 10);
      std::locale::~locale(&v199);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v119 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 1024);
      v120 = 0;
      *(_QWORD *)(a1 + 32 * i + 256) = v119;
      v121 = v216;
      v122 = (v217 - v216) >> 2;
      do
      {
        if (v122 == v120)
          std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
        _S0 = sqrtf(*(float *)(v121 + 4 * v120) + 0.001);
        __asm { FCVT            H0, S0 }
        *(_WORD *)(v119 + 2 * v120++) = LOWORD(_S0);
      }
      while (v120 != 512);
    }
  }
  v221 = v220;
  v213 = v212;
  v217 = v216;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v199);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v199, (uint64_t *)&v206);
  v199.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v200 = &unk_24D29B3B0;
  v205[0] = &unk_24D29B3D8;
  v201 = &unk_24D29B578;
  if (v203 < 0)
    heap_Free(*(_QWORD **)(v204 + 8), v202);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v205);
  v130 = *(char *)(a1 + 55);
  if (v130 >= 0)
    v131 = a1 + 32;
  else
    v131 = *(_QWORD *)(a1 + 32);
  if (v130 >= 0)
    v132 = *(unsigned __int8 *)(a1 + 55);
  else
    v132 = *(_QWORD *)(a1 + 40);
  v133 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v207, v131, v132);
  v134 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v133, (uint64_t)"/inference/dense/tensordot", 26);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v134, (uint64_t)"/npy", 4);
  v135 = *(_QWORD *)(a1 + 464);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v208, v178);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v135 + 24))(v135, v178, &v220, &v212, 1);
  if (v179 < 0)
    heap_Free(*(_QWORD **)(v180 + 8), v178[0]);
  if (v213 == v212)
  {
    v158 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v174, (uint64_t)"error: matmul layer weight", 26);
    std::ios_base::getloc((const std::ios_base *)((char *)v158 + *(_QWORD *)(*v158 - 24)));
    v159 = std::locale::use_facet(&v199, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v159->__vftable[2].~facet_0)(v159, 10);
    std::locale::~locale(&v199);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v136 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), (uint64_t)*(int *)(a1 + 64) << 10);
    v137 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), (uint64_t)*(int *)(a1 + 64) << 10);
    v138 = 0;
    v139 = 0;
    *(_QWORD *)(a1 + 136) = v137;
    v140 = *(unsigned int *)(a1 + 64);
    v141 = v212;
    v142 = v213 - v212;
    v143 = *(_DWORD *)(a1 + 64);
    do
    {
      v144 = v140;
      v145 = v138;
      if (v143 >= 1)
      {
        do
        {
          if (v142 <= v145)
            std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
          *(_WORD *)(v136 + 2 * v145) = v141[v145];
          ++v145;
          --v144;
        }
        while (v144);
      }
      ++v139;
      v138 += (int)v140;
    }
    while (v139 != 512);
    if ((int)v140 >= 0)
      v146 = v140;
    else
      v146 = v140 + 7;
    if (v143 >= 8)
    {
      v147 = 0;
      v148 = 0;
      v149 = 0;
      v150 = v146 >> 3;
      v151 = 4 * v143;
      do
      {
        v152 = 0;
        v153 = v147;
        do
        {
          v154 = 0;
          v155 = v153;
          do
          {
            v156 = 0;
            v157 = v148;
            do
            {
              *(_WORD *)(v137 + 2 * v148 + 2 * v156) = *(_WORD *)(v136 + 2 * (v155 + (int)v156));
              ++v156;
            }
            while (v156 != 8);
            ++v154;
            v155 += v140;
            v148 += 8;
          }
          while (v154 != 4);
          ++v152;
          v153 += v151;
          v148 = v157 + 8;
        }
        while (v152 != 128);
        ++v149;
        v147 += 8;
        v148 = v157 + 8;
      }
      while (v149 != v150);
    }
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 56))(*(_QWORD *)(a1 + 464), v136);
  }
  v221 = v220;
  v213 = v212;
  v217 = v216;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v199);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v199, (uint64_t *)&v206);
  v199.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v200 = &unk_24D29B3B0;
  v205[0] = &unk_24D29B3D8;
  v201 = &unk_24D29B578;
  if (v203 < 0)
    heap_Free(*(_QWORD **)(v204 + 8), v202);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v205);
  v160 = *(char *)(a1 + 55);
  if (v160 >= 0)
    v161 = a1 + 32;
  else
    v161 = *(_QWORD *)(a1 + 32);
  if (v160 >= 0)
    v162 = *(unsigned __int8 *)(a1 + 55);
  else
    v162 = *(_QWORD *)(a1 + 40);
  v163 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v207, v161, v162);
  v164 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v163, (uint64_t)"/inference/dense/bias", 21);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v164, (uint64_t)"/npy", 4);
  v165 = *(_QWORD *)(a1 + 464);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v208, v175);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v165 + 24))(v165, v175, &v220, &v212, 1);
  if (v176 < 0)
    heap_Free(*(_QWORD **)(v177 + 8), v175[0]);
  if (v213 == v212)
  {
    v171 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v174, (uint64_t)"error: matmul layer bias", 24);
    std::ios_base::getloc((const std::ios_base *)((char *)v171 + *(_QWORD *)(*v171 - 24)));
    v172 = std::locale::use_facet(&v199, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v172->__vftable[2].~facet_0)(v172, 10);
    std::locale::~locale(&v199);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v166 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 2 * *(int *)(a1 + 64));
    *(_QWORD *)(a1 + 144) = v166;
    v167 = *(unsigned int *)(a1 + 64);
    if ((int)v167 >= 1)
    {
      v168 = v212;
      v169 = v213 - v212;
      while (v169)
      {
        v170 = *v168++;
        *v166++ = v170;
        --v169;
        if (!--v167)
          goto LABEL_189;
      }
      goto LABEL_193;
    }
  }
LABEL_189:
  v206.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v207 = &unk_24D29B3B0;
  v211 = &unk_24D29B3D8;
  v208[0] = &unk_24D29B578;
  if (v209 < 0)
    heap_Free(*(_QWORD **)(v210 + 8), v208[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v211);
  v206.__locale_ = (std::locale::__imp *)&v212;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v206);
  v206.__locale_ = (std::locale::__imp *)&v216;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v206);
  v206.__locale_ = (std::locale::__imp *)&v220;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v206);
  return 1;
}

void sub_214EA4AD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,std::locale a45)
{
  uint64_t v45;
  uint64_t v46;

  std::locale::~locale(&a45);
  STACK[0x240] = v45 + 24;
  STACK[0x250] = v45 + 64;
  STACK[0x2C8] = v45 + 104;
  STACK[0x258] = (unint64_t)&unk_24D29B578;
  if (SLOBYTE(STACK[0x2AF]) < 0)
    heap_Free(*(_QWORD **)(STACK[0x2B0] + 8), STACK[0x298]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&STACK[0x2C8]);
  *(_QWORD *)(v46 - 112) = v46 - 208;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v46 - 112));
  *(_QWORD *)(v46 - 208) = v46 - 176;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v46 - 208));
  *(_QWORD *)(v46 - 176) = v46 - 144;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v46 - 176));
  _Unwind_Resume(a1);
}

void NeonPostNetManager::neon_postnet_convert_f2h(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  float32x4_t *v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t *v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t *v24;
  float32x4_t *v25;
  float32x4_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t *v30;
  uint64_t v31;
  uint64_t v32;
  float32x4_t *v33;

  v8 = (a4 >> 3) / a8;
  v9 = (v8 * a7);
  v10 = (v9 + v8);
  if (v9 < v10)
  {
    if (a5 >= 0)
      v11 = a5;
    else
      v11 = a5 + 3;
    v12 = (v11 >> 2);
    v13 = a6 + a5;
    if (a6 + a5 < 0 != __OFADD__(a6, a5))
      v13 = a6 + a5 + 3;
    v14 = v13 >> 2;
    v15 = v11 & 0xFFFFFFFC;
    do
    {
      if (a5 >= 4)
      {
        v16 = 0;
        v17 = v12;
        do
        {
          v18 = (float32x4_t *)(a2 + 4 * (int)(8 * v9 + 4 * a4 * v16));
          v19 = *v18;
          v20 = v18[1];
          v21 = (float32x4_t *)((char *)v18 + 4 * a4);
          v22 = *v21;
          v23 = v21[1];
          v24 = (float32x4_t *)((char *)v18 + 8 * a4);
          v25 = (float32x4_t *)((char *)v18 + 12 * a4);
          v26 = v25[1];
          v27 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v19), v20);
          v28 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v22), v23);
          v29 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v24), v24[1]);
          *(float16x4_t *)v23.f32 = vcvt_f16_f32(*v25);
          v30 = (float16x8_t *)(a3 + 64 * (v14 * (int)v9 + (int)v16));
          *v30 = v27;
          v30[1] = v28;
          v30[2] = v29;
          v30[3] = vcvt_hight_f16_f32(*(int16x4_t *)v23.f32, v26);
          ++v16;
          --v17;
        }
        while (v17);
      }
      if ((int)(a5 - v15) >= 1)
      {
        v31 = 0;
        v32 = a5 - v15;
        do
        {
          v33 = (float32x4_t *)(a2 + 4 * (int)(8 * v9 + (v15 + v31) * a4));
          *(float16x8_t *)(a3 + 2 * (32 * ((int)v12 + v14 * (int)v9) + 8 * (int)v31++)) = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v33), v33[1]);
          --v32;
        }
        while (v32);
      }
      ++v9;
    }
    while (v9 != v10);
  }
}

void NeonPostNetManager::neon_postnet_conv_input_shift_by_coloums(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6, unsigned int a7)
{
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 *v24;
  __int128 v25;
  _OWORD *v26;
  _OWORD *v27;
  _OWORD *v28;
  _OWORD *v29;
  _OWORD *v30;
  _OWORD *v31;
  _OWORD *v32;
  _OWORD *v33;
  _OWORD *v34;
  _OWORD *v35;

  v7 = a4 >> 3;
  v8 = (a4 >> 3) / a7 * a6;
  v9 = v8 + (a4 >> 3) / a7;
  if (v8 < v9)
  {
    v10 = 4 * v7;
    v11 = (a5 / 4);
    v12 = v7 << 8;
    v13 = (int)(v7 << 6);
    v14 = (int)(v7 << 7);
    v15 = 24 * v7;
    do
    {
      if (a5 <= 3)
      {
        v17 = 32 * v8;
        v20 = 0uLL;
        v19 = 0uLL;
        v18 = 0uLL;
      }
      else
      {
        v16 = 0;
        v17 = 32 * v8;
        v18 = 0uLL;
        v19 = 0uLL;
        v20 = 0uLL;
        do
        {
          v21 = v20;
          v22 = v19;
          v23 = v18;
          v24 = (__int128 *)(a2 + 2 * (int)(32 * (v11 * v8 + v16)));
          v25 = *v24;
          v18 = v24[1];
          v19 = v24[2];
          v20 = v24[3];
          v26 = (_OWORD *)(a3
                         + 2 * (int)(v17 + v12 * (v16 >> 1))
                         + 2 * (((int)((_DWORD)v16 << 31) >> 31) & (v10 * 8)));
          *v26 = v23;
          v26[1] = v22;
          v26[2] = v21;
          v26[3] = v25;
          v27 = (_OWORD *)((char *)v26 + 2 * v13);
          *v27 = v22;
          v27[1] = v21;
          v27[2] = v25;
          v27[3] = v18;
          v28 = (_OWORD *)((char *)v26 + 2 * v14);
          *v28 = v21;
          v28[1] = v25;
          v28[2] = v18;
          v28[3] = v19;
          v29 = &v26[v15];
          *v29 = v25;
          v29[1] = v18;
          v29[2] = v19;
          v29[3] = v20;
          ++v16;
        }
        while (v11 != v16);
      }
      v30 = (_OWORD *)(a3 + 2 * (v17 + v12 * (a5 / 8)));
      *v30 = v18;
      v30[1] = v19;
      v30[2] = v20;
      v30[3] = 0uLL;
      v31 = &v30[v10];
      v31[2] = 0uLL;
      v31[3] = 0uLL;
      v32 = (_OWORD *)((char *)v30 + 2 * v13);
      *v31 = 0uLL;
      v31[1] = 0uLL;
      *v32 = v19;
      v32[1] = v20;
      v33 = &v32[v10];
      v32[2] = 0uLL;
      v32[3] = 0uLL;
      v34 = (_OWORD *)((char *)v30 + 2 * v14);
      v33[2] = 0uLL;
      v33[3] = 0uLL;
      *v33 = 0uLL;
      v33[1] = 0uLL;
      v35 = &v34[v10];
      *v34 = v20;
      v34[1] = 0uLL;
      v34[2] = 0uLL;
      v34[3] = 0uLL;
      ++v8;
      v35[2] = 0uLL;
      v35[3] = 0uLL;
      *v35 = 0uLL;
      v35[1] = 0uLL;
    }
    while (v9 > v8);
  }
}

void NeonPostNetManager::neon_postnet_conv_rows(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, unsigned int a8, unsigned int a9, int a10, int a11)
{
  uint64_t v11;
  unsigned int v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  unsigned int v28;
  float16x8_t v29;
  unint64_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t *v38;
  signed int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  float16x8_t *v43;
  uint64_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t v63;
  float16x8_t v64;
  float16x8_t v65;
  float16x8_t v66;
  float16x8_t v67;
  float16x8_t v68;
  float16x8_t *v69;
  int v70;

  if (a9 >= 8)
  {
    v11 = 0;
    v12 = a7 >> 3;
    v13 = 32 * (a7 >> 3);
    v14 = (a6 - 1) >> 1;
    v15 = 3 - ((a6 - 1) >> 1);
    if ((a6 - 1) > 7)
      v15 = 0;
    v16 = v12 << 6;
    v17 = (v12 << 6) * v15;
    v18 = (int)(a8 >> 3) / a11;
    v19 = v18 * a10;
    v20 = v18 * a10 + v18;
    if (v12 <= 1)
      v21 = 1;
    else
      v21 = a7 >> 3;
    v22 = (unint64_t)v21 << 6;
    v23 = a4 + 2 * v17;
    v24 = a6 * ((a7 >> 2) & 0x7FFFFFF);
    v70 = 32 * v24 * v19;
    v25 = a2 + 64;
    v26 = 32 * v24;
    do
    {
      if (v19 < v20)
      {
        v27 = v70;
        v28 = v19;
        do
        {
          v29 = *(float16x8_t *)(a3 + 2 * (int)(8 * v28));
          if (a6)
          {
            v30 = 0;
            v31 = *(float16x8_t *)(a3 + 2 * (int)(8 * v28));
            v32 = v31;
            v33 = v31;
            v34 = v31;
            v35 = v31;
            v36 = v31;
            v37 = v31;
            v38 = (float16x8_t *)(v25 + 2 * v27);
            do
            {
              if (v30 <= v14)
              {
                v39 = v16 * v30;
                v40 = v16 * v30 + v13;
              }
              else
              {
                v39 = v13 * (a6 - 6) + v30 % ((int)v14 + 1) * v16;
                v40 = v16 * v30;
              }
              if (a7 >= 8)
              {
                v41 = 0;
                v42 = v23 + 2 * v39;
                v43 = v38;
                v44 = v23 + 2 * v40;
                do
                {
                  v45 = v43[-4];
                  v46 = v43[-3];
                  v48 = *(float16x8_t *)(v42 + v41);
                  v47 = *(float16x8_t *)(v42 + v41 + 16);
                  v50 = *(float16x8_t *)(v42 + v41 + 32);
                  v49 = *(float16x8_t *)(v42 + v41 + 48);
                  v51 = v43[-2];
                  v52 = v43[-1];
                  v54 = *(float16x8_t *)(v44 + v41);
                  v53 = *(float16x8_t *)(v44 + v41 + 16);
                  v55 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v29, v45, *(short float *)v48.i16), v46, *(float16x4_t *)v48.i8, 1), v51, *(float16x4_t *)v48.i8, 2), v52, *(float16x4_t *)v48.i8, 3);
                  v56 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v31, v45, *(short float *)v47.i16), v46, *(float16x4_t *)v47.i8, 1), v51, *(float16x4_t *)v47.i8, 2), v52, *(float16x4_t *)v47.i8, 3);
                  v57 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v32, v45, *(short float *)v50.i16), v46, *(float16x4_t *)v50.i8, 1), v51, *(float16x4_t *)v50.i8, 2), v52, *(float16x4_t *)v50.i8, 3);
                  v58 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v33, v45, *(short float *)v49.i16), v46, *(float16x4_t *)v49.i8, 1), v51, *(float16x4_t *)v49.i8, 2), v52, *(float16x4_t *)v49.i8, 3);
                  v60 = *(float16x8_t *)(v44 + v41 + 32);
                  v59 = *(float16x8_t *)(v44 + v41 + 48);
                  v61 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v34, v45, *(short float *)v54.i16), v46, *(float16x4_t *)v54.i8, 1), v51, *(float16x4_t *)v54.i8, 2), v52, *(float16x4_t *)v54.i8, 3);
                  v62 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v35, v45, *(short float *)v53.i16), v46, *(float16x4_t *)v53.i8, 1), v51, *(float16x4_t *)v53.i8, 2), v52, *(float16x4_t *)v53.i8, 3);
                  v63 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v36, v45, *(short float *)v60.i16), v46, *(float16x4_t *)v60.i8, 1), v51, *(float16x4_t *)v60.i8, 2), v52, *(float16x4_t *)v60.i8, 3);
                  v64 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v37, v45, *(short float *)v59.i16), v46, *(float16x4_t *)v59.i8, 1), v51, *(float16x4_t *)v59.i8, 2), v52, *(float16x4_t *)v59.i8, 3);
                  v65 = v43[1];
                  v67 = v43[2];
                  v66 = v43[3];
                  v29 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v55, *v43, v48, 4), v65, v48, 5), v67, v48, 6), v66, v48, 7);
                  v31 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v56, *v43, v47, 4), v65, v47, 5), v67, v47, 6), v66, v47, 7);
                  v32 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v57, *v43, v50, 4), v65, v50, 5), v67, v50, 6), v66, v50, 7);
                  v33 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v58, *v43, v49, 4), v65, v49, 5), v67, v49, 6), v66, v49, 7);
                  v68 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v64, *v43, v59, 4), v65, v59, 5), v67, v59, 6);
                  v34 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v61, *v43, v54, 4), v65, v54, 5), v67, v54, 6), v66, v54, 7);
                  v35 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v62, *v43, v53, 4), v65, v53, 5), v67, v53, 6), v66, v53, 7);
                  v41 += 64;
                  v36 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v63, *v43, v60, 4), v65, v60, 5), v67, v60, 6), v66, v60, 7);
                  v43 += 8;
                  v37 = vmlaq_laneq_f16(v68, v66, v59, 7);
                }
                while (v22 != v41);
              }
              ++v30;
              v38 = (float16x8_t *)((char *)v38 + 2 * (int)((8 * a7) & 0xFFFFFFE0));
            }
            while (v30 != a6);
          }
          else
          {
            v37 = *(float16x8_t *)(a3 + 2 * (int)(8 * v28));
            v36 = v37;
            v35 = v37;
            v34 = v37;
            v33 = v37;
            v32 = v37;
            v31 = v37;
          }
          v69 = (float16x8_t *)(a5 + 2 * ((_DWORD)v11 << 6) + 2 * (int)(((8 * a9) & 0xFFFFFFE0) * v28));
          *v69 = v29;
          v69[1] = v31;
          v69[2] = v32;
          v69[3] = v33;
          v69[4] = v34;
          v69[5] = v35;
          v69[6] = v36;
          v69[7] = v37;
          ++v28;
          v27 += v26;
        }
        while (v20 > v28);
      }
      ++v11;
      v23 += 2 * (int)(v12 << 8);
    }
    while (v11 != a9 >> 3);
  }
}

void NeonPostNetManager::neon_batch_norm_row(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9, int a10, int a11)
{
  int v11;
  float16x8_t *v12;
  int v13;
  int v14;
  signed int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  uint64_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;

  v11 = (int)(a7 >> 3) / a11;
  if (v11 >= 1)
  {
    v12 = 0;
    v13 = v11 * a10;
    v14 = v11 * a10 + v11;
    v15 = (8 * a8) & 0xFFFFFFE0;
    LODWORD(v16) = a8 >> 3;
    if (a8 >> 3 <= 1)
      v16 = 1;
    else
      v16 = v16;
    v17 = v13;
    v18 = a6 + 2 * v13 * (uint64_t)v15 - 128;
    v19 = 2 * v15;
    do
    {
      if (a8 >= 8)
      {
        v20 = 16 * (_DWORD)v17;
        v21 = *(float16x8_t *)(a2 + v20);
        v22 = *(float16x8_t *)(a3 + v20);
        v23 = *(float16x8_t *)(a4 + v20);
        v24 = *(float16x8_t *)(a5 + v20);
        v25 = v16;
        v12 = (float16x8_t *)v18;
        do
        {
          v26 = v12[8];
          v27 = v12[9];
          v12 += 8;
          v28 = vmlaq_f16(v24, vdivq_f16(vsubq_f16(v26, v22), v23), v21);
          v29 = vmlaq_f16(v24, vdivq_f16(vsubq_f16(v12[2], v22), v23), v21);
          v30 = vmlaq_f16(v24, vdivq_f16(vsubq_f16(v12[3], v22), v23), v21);
          v31 = vmlaq_f16(v24, vdivq_f16(vsubq_f16(v12[4], v22), v23), v21);
          v32 = vmlaq_f16(v24, vdivq_f16(vsubq_f16(v12[5], v22), v23), v21);
          v33 = vmlaq_f16(v24, vdivq_f16(vsubq_f16(v12[6], v22), v23), v21);
          v34 = vdivq_f16(vsubq_f16(v12[7], v22), v23);
          *v12 = v28;
          v12[1] = vmlaq_f16(v24, vdivq_f16(vsubq_f16(v27, v22), v23), v21);
          v12[2] = v29;
          v12[3] = v30;
          v12[4] = v31;
          v12[5] = v32;
          v12[6] = v33;
          v12[7] = vmlaq_f16(v24, v34, v21);
          --v25;
        }
        while (v25);
      }
      switch(a9)
      {
        case 1:
          v12[7] = 0uLL;
          break;
        case 2:
          v12[6] = 0uLL;
          v12[7] = 0uLL;
          break;
        case 3:
          v12[6] = 0uLL;
          v12[7] = 0uLL;
          v12[5] = 0uLL;
          break;
        case 4:
          v12[6] = 0uLL;
          v12[7] = 0uLL;
          v12[4] = 0uLL;
          v12[5] = 0uLL;
          break;
        case 5:
          v12[6] = 0uLL;
          v12[7] = 0uLL;
          v12[4] = 0uLL;
          v12[5] = 0uLL;
          v12[3] = 0uLL;
          break;
        case 6:
          v12[6] = 0uLL;
          v12[7] = 0uLL;
          v12[4] = 0uLL;
          v12[5] = 0uLL;
          v12[2] = 0uLL;
          v12[3] = 0uLL;
          break;
        case 7:
          v12[6] = 0uLL;
          v12[7] = 0uLL;
          v12[4] = 0uLL;
          v12[5] = 0uLL;
          v12[2] = 0uLL;
          v12[3] = 0uLL;
          v12[1] = 0uLL;
          break;
        default:
          break;
      }
      ++v17;
      v18 += v19;
    }
    while (v17 < v14);
  }
}

float16x8_t *NeonPostNetManager::neon_batch_norm_column(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned int a9, int a10, int a11, unsigned int a12)
{
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  uint64_t v22;
  float16x8_t *result;
  uint64_t v24;
  float16x8_t v25;
  float16x8_t v26;
  float16x8_t v27;

  v12 = (a8 >> 3) / a12;
  LODWORD(v13) = v12 * a11;
  v14 = v12 * a11 + v12;
  if (v12 * a11 < v14)
  {
    LODWORD(v15) = a9 >> 2;
    v16 = (int)(32 * (a8 >> 3));
    if (a9 >> 2 <= 1)
      v15 = 1;
    else
      v15 = v15;
    v13 = (int)v13;
    do
    {
      if (a9 >= 4)
      {
        v17 = 0;
        v18 = *(float16x8_t *)(a2 + 16 * (int)v13);
        v19 = *(float16x8_t *)(a3 + 16 * (int)v13);
        v20 = *(float16x8_t *)(a4 + 16 * (int)v13);
        v21 = *(float16x8_t *)(a5 + 16 * (int)v13);
        v22 = v15;
        do
        {
          result = (float16x8_t *)(a6 + 2 * v13 * (int)(32 * (a9 >> 2)) + (v17 << 6));
          v24 = a7 + ((uint64_t)(int)v13 << 6) + 2 * v17 * v16;
          v25 = vmlaq_f16(v21, vdivq_f16(vsubq_f16(result[1], v19), v20), v18);
          v26 = vmlaq_f16(v21, vdivq_f16(vsubq_f16(result[2], v19), v20), v18);
          v27 = vdivq_f16(vsubq_f16(result[3], v19), v20);
          *(float16x8_t *)v24 = vmlaq_f16(v21, vdivq_f16(vsubq_f16(*result, v19), v20), v18);
          *(float16x8_t *)(v24 + 16) = v25;
          *(float16x8_t *)(v24 + 32) = v26;
          *(float16x8_t *)(v24 + 48) = vmlaq_f16(v21, v27, v18);
          ++v17;
          --v22;
        }
        while (v22);
      }
      ++v13;
    }
    while (v14 > v13);
  }
  return result;
}

void NeonPostNetManager::neon_postnet_matmul(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float16x4_t *a5, uint64_t a6, unsigned int a7, unsigned int a8, unsigned int a9, int a10, unsigned int a11)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  float16x8_t v26;
  float16x8_t v27;
  uint64_t v28;
  float16x4_t *v29;
  uint64_t v30;
  float16x8_t *v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  uint64_t v54;
  float16x8_t *v55;
  float16x8_t v56;
  float16x8_t *v57;
  float16x8_t *v58;
  float16x8_t v59;
  float16x8_t v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t v63;
  float16x8_t v64;
  float16x8_t *v65;
  uint64_t v66;

  if (a9 >= 8)
  {
    v11 = 0;
    v12 = (a8 >> 3) / a11;
    v13 = 2 * a8;
    v66 = (int)(a8 >> 3 << 6);
    v14 = v12 * a10 + v12;
    v15 = v12 * a10;
    if (a7 >> 3 <= 1)
      v16 = 1;
    else
      v16 = a7 >> 3;
    v17 = 2 * (int)(32 * (a7 >> 3));
    do
    {
      if (v15 < v14)
      {
        v18 = v15;
        do
        {
          v19 = 8 * v18;
          v20 = *(float16x8_t *)(a3 + 16 * (_DWORD)v18);
          if (a7 >= 8)
          {
            v28 = 0;
            v29 = a5;
            v30 = v16;
            v27 = *(float16x8_t *)(a3 + 2 * v19);
            v26 = v27;
            v25 = v27;
            v24 = v27;
            v23 = v27;
            v22 = v27;
            v21 = v27;
            do
            {
              v31 = (float16x8_t *)(a2 + 2 * v18 * (int)((8 * a7) & 0xFFFFFFE0) + (v28 << 7));
              v32 = v31[1];
              v33 = *(float16x8_t *)v29[2].i8;
              v35 = *(float16x8_t *)v29[4].i8;
              v34 = *(float16x8_t *)v29[6].i8;
              v36 = v31[2];
              v37 = v31[3];
              v39 = *(float16x8_t *)&v29->i8[64 * (a7 >> 3)];
              v38 = *(float16x8_t *)&v29[2].i8[v17];
              v40 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v20, *v31, COERCE_SHORT_FLOAT(*(_OWORD *)v29->i8)), v32, *v29, 1), v36, *v29, 2), v37, *v29, 3);
              v41 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v27, *v31, *(short float *)v33.i16), v32, *(float16x4_t *)v33.i8, 1), v36, *(float16x4_t *)v33.i8, 2), v37, *(float16x4_t *)v33.i8, 3);
              v42 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v26, *v31, *(short float *)v35.i16), v32, *(float16x4_t *)v35.i8, 1), v36, *(float16x4_t *)v35.i8, 2), v37, *(float16x4_t *)v35.i8, 3);
              v43 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v25, *v31, *(short float *)v34.i16), v32, *(float16x4_t *)v34.i8, 1), v36, *(float16x4_t *)v34.i8, 2), v37, *(float16x4_t *)v34.i8, 3);
              v45 = *(float16x8_t *)&v29[4].i8[v17];
              v44 = *(float16x8_t *)&v29[6].i8[v17];
              v46 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v24, *v31, *(short float *)v39.i16), v32, *(float16x4_t *)v39.i8, 1), v36, *(float16x4_t *)v39.i8, 2), v37, *(float16x4_t *)v39.i8, 3);
              v47 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v23, *v31, *(short float *)v38.i16), v32, *(float16x4_t *)v38.i8, 1), v36, *(float16x4_t *)v38.i8, 2), v37, *(float16x4_t *)v38.i8, 3);
              v48 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v22, *v31, *(short float *)v45.i16), v32, *(float16x4_t *)v45.i8, 1), v36, *(float16x4_t *)v45.i8, 2), v37, *(float16x4_t *)v45.i8, 3);
              v49 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v21, *v31, *(short float *)v44.i16), v32, *(float16x4_t *)v44.i8, 1), v36, *(float16x4_t *)v44.i8, 2), v37, *(float16x4_t *)v44.i8, 3);
              v50 = v31[4];
              v51 = v31[5];
              v53 = v31[6];
              v52 = v31[7];
              v20 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v40, v50, *(float16x8_t *)v29->i8, 4), v51, *(float16x8_t *)v29->i8, 5), v53, *(float16x8_t *)v29->i8, 6), v52, *(float16x8_t *)v29->i8, 7);
              v27 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v41, v50, v33, 4), v51, v33, 5), v53, v33, 6), v52, v33, 7);
              v26 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v42, v50, v35, 4), v51, v35, 5), v53, v35, 6), v52, v35, 7);
              v25 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v43, v50, v34, 4), v51, v34, 5), v53, v34, 6), v52, v34, 7);
              v24 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v46, v50, v39, 4), v51, v39, 5), v53, v39, 6), v52, v39, 7);
              v23 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v47, v50, v38, 4), v51, v38, 5), v53, v38, 6), v52, v38, 7);
              v22 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v48, v50, v45, 4), v51, v45, 5), v53, v45, 6), v52, v45, 7);
              ++v28;
              v29 += 8;
              v21 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v49, v50, v44, 4), v51, v44, 5), v53, v44, 6), v52, v44, 7);
              --v30;
            }
            while (v30);
          }
          else
          {
            v21 = *(float16x8_t *)(a3 + 2 * v19);
            v22 = v21;
            v23 = v21;
            v24 = v21;
            v25 = v21;
            v26 = v21;
            v27 = v21;
          }
          v54 = a4 + 2 * ((8 * a9) & 0xFFFFFFE0) * v18;
          v55 = (float16x8_t *)(v54 + 2 * ((_DWORD)v11 << 6));
          v56 = v55[1];
          v57 = (float16x8_t *)(v54 + 2 * (((_DWORD)v11 << 6) | 0x20u));
          v58 = (float16x8_t *)(a6 + 2 * v11 * v66 + 2 * v19);
          v59 = v55[2];
          v60 = v55[3];
          v61 = *v57;
          v62 = v57[1];
          v63 = v57[2];
          v64 = v57[3];
          *v58 = vaddq_f16(v20, *v55);
          *(float16x8_t *)((char *)v58 + 2 * a8) = vaddq_f16(v27, v56);
          *(float16x8_t *)((char *)v58 + 2 * v13) = vaddq_f16(v26, v59);
          v65 = (float16x8_t *)(a6 + 2 * (v11 * v66 + (int)(32 * (a8 >> 3))) + 2 * v19);
          *(float16x8_t *)((char *)v58 + 6 * a8) = vaddq_f16(v25, v60);
          *v65 = vaddq_f16(v24, v61);
          *(float16x8_t *)((char *)v65 + 2 * a8) = vaddq_f16(v23, v62);
          *(float16x8_t *)((char *)v65 + 2 * v13) = vaddq_f16(v22, v63);
          *(float16x8_t *)((char *)v65 + 6 * a8) = vaddq_f16(v21, v64);
          ++v18;
        }
        while (v14 > v18);
      }
      ++v11;
      a5 = (float16x4_t *)((char *)a5 + 2 * (int)(a7 >> 3 << 6));
    }
    while (v11 != a9 >> 3);
  }
}

uint64_t NeonPostNetManager::SetUp(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), (uint64_t)*(int *)(a1 + 64) << 9);
  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v3 + 3352) = v2;
  if (!*(_BYTE *)(v3 + 2304)
    || (result = NeonTC2Container::EngineMCSetUp((NeonTC2Container *)v3, (void *)a1, 4, (void (*)(void *, int))mc_PostNet_do_inference), (_DWORD)result))
  {
    *(_QWORD *)(a1 + 400) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 0x80000);
    *(_QWORD *)(a1 + 392) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 0x20000);
    *(_QWORD *)(a1 + 424) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), (uint64_t)*(int *)(a1 + 64) << 8);
    *(_QWORD *)(a1 + 416) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), 264 * *(int *)(a1 + 64));
    *(_QWORD *)(a1 + 408) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 464) + 32))(*(_QWORD *)(a1 + 464), (uint64_t)*(int *)(a1 + 64) << 9);
    return 1;
  }
  return result;
}

uint64_t *mc_PostNet_do_inference(uint64_t a1, int a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  unint64_t i;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  __int16 *v32;
  uint64_t v33;
  float v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t *result;
  uint64_t v47;
  int v48;
  uint64_t v49;
  __int16 *v50;
  _DWORD *v51;
  __int16 v52;
  uint64_t *v55;
  _QWORD *v56;
  unint64_t v57;
  uint64_t *v58;
  _QWORD *v59;
  _QWORD *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _QWORD *v72;
  unint64_t v73;
  uint64_t *v74;
  _QWORD *v75;
  _QWORD *v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  _QWORD *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  _QWORD *v89;
  unint64_t v90;
  _QWORD *v91;
  _QWORD *v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  _QWORD *v98;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  int v105;
  _QWORD *v106;
  _QWORD *v107;
  _QWORD *v108;
  uint64_t v109;
  _QWORD *v110;

  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(_DWORD *)(v4 + 2308);
  if (v5 != 4)
  {
    v6 = **(_QWORD **)(a1 + 432);
    v7 = *(_QWORD *)(a1 + 416);
    v8 = *(_DWORD *)(a1 + 64);
    v9 = *(_DWORD *)(a1 + 68);
    v10 = *(_DWORD *)(v4 + 3304) - v9;
    v11 = a2;
    goto LABEL_5;
  }
  if (a2 <= 1)
  {
    v6 = **(_QWORD **)(a1 + 432);
    v7 = *(_QWORD *)(a1 + 416);
    v8 = *(_DWORD *)(a1 + 64);
    v9 = *(_DWORD *)(a1 + 68);
    v10 = *(_DWORD *)(v4 + 3304) - v9;
    v11 = a2;
    v5 = 2;
LABEL_5:
    NeonPostNetManager::neon_postnet_convert_f2h(a1, v6, v7, v8, v10, v9, v11, v5);
  }
  v12 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 24) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2656));
  for (i = 0; i != 5; ++i)
  {
    if (i)
    {
      v14 = *(_QWORD *)(a1 + 392);
      v15 = *(_QWORD *)(a1 + 400);
      v16 = *(_QWORD *)(a1 + 24);
      v17 = *(_DWORD *)(v16 + 3304);
      v18 = *(_DWORD *)(v16 + 2308);
      v19 = 512;
LABEL_13:
      v21 = a2;
      goto LABEL_14;
    }
    v20 = *(_QWORD *)(a1 + 24);
    v18 = *(_DWORD *)(v20 + 2308);
    if (v18 != 4)
    {
      v14 = *(_QWORD *)(a1 + 416);
      v15 = *(_QWORD *)(a1 + 400);
      v19 = *(_DWORD *)(a1 + 64);
      v17 = *(_DWORD *)(v20 + 3304);
      goto LABEL_13;
    }
    if (a2 > 1)
      goto LABEL_15;
    v14 = *(_QWORD *)(a1 + 416);
    v15 = *(_QWORD *)(a1 + 400);
    v19 = *(_DWORD *)(a1 + 64);
    v17 = *(_DWORD *)(v20 + 3304);
    v21 = a2;
    v18 = 2;
LABEL_14:
    NeonPostNetManager::neon_postnet_conv_input_shift_by_coloums(v12, v14, v15, v19, v17, v21, v18);
LABEL_15:
    v22 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 24) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2656));
    if (i)
      NeonPostNetManager::neon_postnet_conv_rows(v22, *(_QWORD *)(a1 + 16 * i + 152), *(_QWORD *)(a1 + 16 * i + 160), *(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 392), 5, 0x200u, 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), a2, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    else
      NeonPostNetManager::neon_postnet_conv_rows(v22, *(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 160), *(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 392), 5, *(_DWORD *)(a1 + 64), 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), a2, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 24) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2656));
    v23 = *(_QWORD *)(a1 + 24);
    if (i > 3)
    {
      v43 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v23 + 2656) + 8))(*(_QWORD *)(v23 + 2656));
      NeonPostNetManager::neon_batch_norm_column(v43, *(_QWORD *)(a1 + 360), *(_QWORD *)(a1 + 376), *(_QWORD *)(a1 + 384), *(_QWORD *)(a1 + 368), *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), v105, a2, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    }
    else
    {
      v24 = *(unsigned int *)(v23 + 3304);
      if ((int)v24 >= 1)
      {
        v25 = 0;
        v26 = 0;
        v27 = 512 / *(_DWORD *)(v23 + 2308);
        v28 = v27 * a2;
        v29 = v27 * (a2 + 1);
        v30 = v28;
        v31 = v29 - (uint64_t)v28;
        do
        {
          if ((int)v30 < v29)
          {
            v32 = (__int16 *)(*(_QWORD *)(a1 + 392) + 2 * (v30 + v25));
            v33 = v31;
            do
            {
              _H0 = *v32;
              __asm { FCVT            S0, H0 }
              v40 = fabsf(_S0);
              _S0 = (float)((float)((float)((float)(v40 * 2.4555) + 2.4555)
                                  + (float)((float)((float)(v40 * 0.82123) + 0.89323) * (float)(_S0 * _S0)))
                          * _S0)
                  / (float)((float)((float)((float)(_S0 * _S0) + 2.4451)
                                  * fabsf(_S0 + (float)((float)(_S0 * 0.81464) * v40)))
                          + 2.4451);
              __asm { FCVT            H0, S0 }
              *v32++ = LOWORD(_S0);
              --v33;
            }
            while (v33);
          }
          ++v26;
          v25 += 512;
        }
        while (v26 != v24);
      }
      v42 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v23 + 2656) + 8))(*(_QWORD *)(v23 + 2656));
      NeonPostNetManager::neon_batch_norm_row(v42, *(_QWORD *)(a1 + 32 * i + 232), *(_QWORD *)(a1 + 32 * i + 248), *(_QWORD *)(a1 + 32 * i + 256), *(_QWORD *)(a1 + 32 * i + 240), *(_QWORD *)(a1 + 392), 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), *(_DWORD *)(a1 + 68), a2, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    }
    v12 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 24) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2656));
  }
  v44 = *(_QWORD *)(a1 + 24);
  v45 = *(_DWORD *)(v44 + 2308);
  if (v45 != 4 || a2 <= 1)
  {
    if (v45 == 4)
      v45 = 2;
    NeonPostNetManager::neon_postnet_matmul(v12, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), *(_QWORD *)(a1 + 416), *(float16x4_t **)(a1 + 400), *(_QWORD *)(a1 + 424), 0x200u, *(_DWORD *)(a1 + 64), *(_DWORD *)(v44 + 3304), a2, v45);
  }
  result = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 24) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2656));
  if (!a2)
  {
    v47 = *(_QWORD *)(a1 + 24);
    v48 = *(_DWORD *)(v47 + 3304) - *(_DWORD *)(a1 + 68);
    *(_DWORD *)(v47 + 3304) = v48;
    v49 = (*(_DWORD *)(a1 + 64) * v48);
    if ((int)v49 >= 1)
    {
      v50 = *(__int16 **)(a1 + 424);
      v51 = *(_DWORD **)(v47 + 3352);
      do
      {
        v52 = *v50++;
        _H0 = v52;
        __asm { FCVT            S0, H0 }
        *v51++ = _S0;
        --v49;
      }
      while (v49);
    }
    v55 = *(uint64_t **)(a1 + 456);
    v56 = (_QWORD *)v55[1];
    v57 = v55[2];
    if ((unint64_t)v56 < v57)
    {
      *v56 = 1;
      v58 = v55;
      v59 = v56 + 1;
      goto LABEL_54;
    }
    v60 = (_QWORD *)*v55;
    v61 = ((uint64_t)v56 - *v55) >> 3;
    v62 = v61 + 1;
    if ((unint64_t)(v61 + 1) >> 61)
      goto LABEL_90;
    v63 = v57 - (_QWORD)v60;
    if (v63 >> 2 > v62)
      v62 = v63 >> 2;
    if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF8)
      v64 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v64 = v62;
    v110 = v55 + 3;
    if (v64)
    {
      v65 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v55 + 3), v64);
      v60 = (_QWORD *)*v55;
      v56 = (_QWORD *)v55[1];
    }
    else
    {
      v65 = 0;
    }
    v66 = (_QWORD *)(v65 + 8 * v61);
    *v66 = 1;
    if (v56 == v60)
    {
      v68 = v65 + 8 * v61;
    }
    else
    {
      v67 = v56;
      v68 = v65 + 8 * v61;
      do
      {
        v69 = *--v67;
        *(_QWORD *)(v68 - 8) = v69;
        v68 -= 8;
      }
      while (v67 != v60);
    }
    v59 = v66 + 1;
    *v55 = v68;
    v106 = v60;
    v107 = v60;
    v55[1] = (uint64_t)(v66 + 1);
    v108 = v56;
    v70 = v55[2];
    v55[2] = v65 + 8 * v64;
    v109 = v70;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v106);
    v58 = *(uint64_t **)(a1 + 456);
    v48 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304);
LABEL_54:
    v55[1] = (uint64_t)v59;
    v71 = v48;
    v72 = (_QWORD *)v58[1];
    v73 = v58[2];
    if ((unint64_t)v72 >= v73)
    {
      v76 = (_QWORD *)*v58;
      v77 = ((uint64_t)v72 - *v58) >> 3;
      v78 = v77 + 1;
      if ((unint64_t)(v77 + 1) >> 61)
        std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
      v79 = v73 - (_QWORD)v76;
      if (v79 >> 2 > v78)
        v78 = v79 >> 2;
      if ((unint64_t)v79 >= 0x7FFFFFFFFFFFFFF8)
        v80 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v80 = v78;
      v110 = v58 + 3;
      if (v80)
      {
        v81 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v58 + 3), v80);
        v76 = (_QWORD *)*v58;
        v72 = (_QWORD *)v58[1];
      }
      else
      {
        v81 = 0;
      }
      v82 = (_QWORD *)(v81 + 8 * v77);
      *v82 = v71;
      if (v72 == v76)
      {
        v84 = v81 + 8 * v77;
      }
      else
      {
        v83 = v72;
        v84 = v81 + 8 * v77;
        do
        {
          v85 = *--v83;
          *(_QWORD *)(v84 - 8) = v85;
          v84 -= 8;
        }
        while (v83 != v76);
      }
      v75 = v82 + 1;
      *v58 = v84;
      v106 = v76;
      v107 = v76;
      v58[1] = (uint64_t)(v82 + 1);
      v108 = v72;
      v86 = v58[2];
      v58[2] = v81 + 8 * v80;
      v109 = v86;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v106);
      v74 = *(uint64_t **)(a1 + 456);
    }
    else
    {
      *v72 = v48;
      v74 = v58;
      v75 = v72 + 1;
    }
    v58[1] = (uint64_t)v75;
    v87 = *(_DWORD *)(a1 + 64);
    v88 = v87;
    v89 = (_QWORD *)v74[1];
    v90 = v74[2];
    if ((unint64_t)v89 < v90)
    {
      *v89 = v87;
      v91 = v89 + 1;
      goto LABEL_88;
    }
    v92 = (_QWORD *)*v74;
    v93 = ((uint64_t)v89 - *v74) >> 3;
    v94 = v93 + 1;
    if ((unint64_t)(v93 + 1) >> 61)
LABEL_90:
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    v95 = v90 - (_QWORD)v92;
    if (v95 >> 2 > v94)
      v94 = v95 >> 2;
    if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF8)
      v96 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v96 = v94;
    v110 = v74 + 3;
    if (v96)
    {
      v97 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v74 + 3), v96);
      v92 = (_QWORD *)*v74;
      v89 = (_QWORD *)v74[1];
    }
    else
    {
      v97 = 0;
    }
    v98 = (_QWORD *)(v97 + 8 * v93);
    *v98 = v88;
    if (v89 == v92)
    {
      v100 = v97 + 8 * v93;
    }
    else
    {
      v99 = v89;
      v100 = v97 + 8 * v93;
      do
      {
        v101 = *--v99;
        *(_QWORD *)(v100 - 8) = v101;
        v100 -= 8;
      }
      while (v99 != v92);
    }
    v91 = v98 + 1;
    *v74 = v100;
    v106 = v92;
    v107 = v92;
    v74[1] = (uint64_t)(v98 + 1);
    v108 = v89;
    v102 = v74[2];
    v74[2] = v97 + 8 * v96;
    v109 = v102;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v106);
    v87 = *(_DWORD *)(a1 + 64);
LABEL_88:
    v74[1] = (uint64_t)v91;
    v103 = *(_QWORD *)(a1 + 24);
    v104 = *(int *)(v103 + 3304) * (uint64_t)v87;
    return std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(*(uint64_t **)(a1 + 448), *(char **)(v103 + 3352), *(_QWORD *)(v103 + 3352) + 4 * v104, v104);
  }
  return result;
}

void NeonPostNetManager::do_inference(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int *v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  float16x8_t *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t i;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  __int16 *v42;
  _DWORD *v43;
  __int16 v44;
  _QWORD *v51;
  unint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _QWORD *v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  int v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  _QWORD *v100;
  _QWORD *v101;
  _QWORD *v102;
  uint64_t v103;
  _QWORD *v104;

  v9 = *(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(v9 + 2304))
  {
    *(_QWORD *)(a1 + 432) = a2;
    *(_QWORD *)(a1 + 440) = a3;
    *(_QWORD *)(a1 + 448) = a4;
    *(_QWORD *)(a1 + 456) = a5;
    v10 = *a3;
    v11 = a3[1] - *a3;
    if (v11 > 8)
    {
      v12 = *(_DWORD *)(v10 + 8);
      *(_DWORD *)(v9 + 3304) = v12;
      if (v11 > 0x10)
      {
        v13 = *(_DWORD *)(v10 + 16);
        if (v12 <= 0)
          v14 = -(-v12 & 7);
        else
          v14 = v12 & 7;
        if (v14)
          v15 = 8 - v14;
        else
          v15 = 0;
        *(_DWORD *)(a1 + 64) = v13;
        *(_DWORD *)(a1 + 68) = v15;
        bzero(*(void **)(a1 + 416), 2 * (v15 + v12) * v13);
        v16 = *(int **)(a1 + 24);
        v16[826] += *(_DWORD *)(a1 + 68);
        SynchroManager::cond_broadcast_on_entry((SynchroManager *)(v16 + 578), v16[577], 5);
        SynchroManager::cond_wait_less_on_exit((SynchroManager *)(*(_QWORD *)(a1 + 24) + 2312), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
        return;
      }
    }
LABEL_86:
    std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
  }
  v17 = *a3;
  v18 = a3[1] - *a3;
  if (v18 <= 8)
    goto LABEL_86;
  v19 = *(_DWORD *)(v17 + 8);
  *(_DWORD *)(v9 + 3304) = v19;
  if (v18 <= 0x10)
    goto LABEL_86;
  v20 = *(_DWORD *)(v17 + 16);
  if (v19 <= 0)
    v21 = -(-v19 & 7);
  else
    v21 = v19 & 7;
  if (v21)
    v22 = 8 - v21;
  else
    v22 = 0;
  *(_DWORD *)(a1 + 64) = v20;
  *(_DWORD *)(a1 + 68) = v22;
  bzero(*(void **)(a1 + 416), 2 * (v22 + v19) * v20);
  NeonPostNetManager::neon_postnet_convert_f2h(v23, *a2, *(_QWORD *)(a1 + 416), *(_DWORD *)(a1 + 64), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), *(_DWORD *)(a1 + 68), 0, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
  v25 = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304) += *(_DWORD *)(a1 + 68);
  v98 = (float32x4_t)vdupq_n_s32(0x3F523BE9u);
  v99 = (float32x4_t)vdupq_n_s32(0x401D2709u);
  v96 = (float32x4_t)vdupq_n_s32(0x401C7BF8u);
  v97 = (float32x4_t)vdupq_n_s32(0x3F64AAB6u);
  v95 = (float32x4_t)vdupq_n_s32(0x3F508C6Du);
  do
  {
    v26 = *(_QWORD *)(a1 + 400);
    if (v25)
    {
      NeonPostNetManager::neon_postnet_conv_input_shift_by_coloums((uint64_t)v24, *(_QWORD *)(a1 + 392), v26, 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), 0, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
      NeonPostNetManager::neon_postnet_conv_rows(v27, *(_QWORD *)(a1 + 16 * v25 + 152), *(_QWORD *)(a1 + 16 * v25 + 160), *(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 392), 5, 0x200u, 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), 0, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
      if (v25 > 3)
      {
        v24 = NeonPostNetManager::neon_batch_norm_column(v28, *(_QWORD *)(a1 + 360), *(_QWORD *)(a1 + 376), *(_QWORD *)(a1 + 384), *(_QWORD *)(a1 + 368), *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), v94, 0, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
        goto LABEL_30;
      }
    }
    else
    {
      NeonPostNetManager::neon_postnet_conv_input_shift_by_coloums((uint64_t)v24, *(_QWORD *)(a1 + 416), v26, *(_DWORD *)(a1 + 64), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), 0, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
      NeonPostNetManager::neon_postnet_conv_rows(v29, *(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 160), *(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 392), 5, *(_DWORD *)(a1 + 64), 0x200u, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), 0, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
    }
    v30 = *(_QWORD *)(a1 + 24);
    v31 = *(unsigned int *)(v30 + 3304);
    v32 = *(_QWORD *)(a1 + 392);
    if ((int)v31 >= 1)
    {
      v33 = 0;
      v34 = *(_QWORD *)(a1 + 392);
      do
      {
        for (i = 0; i != 1024; i += 8)
        {
          v36 = vcvtq_f32_f16(*(float16x4_t *)(v34 + i));
          v37 = vabsq_f32(v36);
          v38 = vmulq_f32(v36, v36);
          *(float16x4_t *)(v34 + i) = vcvt_f16_f32(vdivq_f32(vmulq_f32(vmlaq_f32(vmlaq_f32(v99, v99, v37), v38, vmlaq_f32(v97, v98, v37)), v36), vmlaq_f32(v96, vabsq_f32(vmlaq_f32(v36, v37, vmulq_f32(v36, v95))), vaddq_f32(v38, v96))));
        }
        ++v33;
        v34 += 1024;
      }
      while (v33 != v31);
    }
    NeonPostNetManager::neon_batch_norm_row(v28, *(_QWORD *)(a1 + 32 * v25 + 232), *(_QWORD *)(a1 + 32 * v25 + 248), *(_QWORD *)(a1 + 32 * v25 + 256), *(_QWORD *)(a1 + 32 * v25 + 240), v32, 0x200u, v31, *(_DWORD *)(a1 + 68), 0, *(_DWORD *)(v30 + 2308));
LABEL_30:
    ++v25;
  }
  while (v25 != 5);
  NeonPostNetManager::neon_postnet_matmul((uint64_t)v24, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144), *(_QWORD *)(a1 + 416), *(float16x4_t **)(a1 + 400), *(_QWORD *)(a1 + 424), 0x200u, *(_DWORD *)(a1 + 64), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304), 0, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2308));
  v39 = *(_QWORD *)(a1 + 24);
  v40 = *(_DWORD *)(v39 + 3304) - *(_DWORD *)(a1 + 68);
  *(_DWORD *)(v39 + 3304) = v40;
  v41 = (*(_DWORD *)(a1 + 64) * v40);
  if ((int)v41 >= 1)
  {
    v42 = *(__int16 **)(a1 + 424);
    v43 = *(_DWORD **)(v39 + 3352);
    do
    {
      v44 = *v42++;
      _H0 = v44;
      __asm { FCVT            S0, H0 }
      *v43++ = _S0;
      --v41;
    }
    while (v41);
  }
  v51 = (_QWORD *)a5[1];
  v52 = a5[2];
  if ((unint64_t)v51 < v52)
  {
    *v51 = 1;
    v53 = v51 + 1;
    goto LABEL_51;
  }
  v54 = (_QWORD *)*a5;
  v55 = ((uint64_t)v51 - *a5) >> 3;
  v56 = v55 + 1;
  if ((unint64_t)(v55 + 1) >> 61)
    goto LABEL_87;
  v57 = v52 - (_QWORD)v54;
  if (v57 >> 2 > v56)
    v56 = v57 >> 2;
  if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8)
    v58 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v58 = v56;
  v104 = a5 + 3;
  if (v58)
  {
    v59 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v58);
    v54 = (_QWORD *)*a5;
    v51 = (_QWORD *)a5[1];
  }
  else
  {
    v59 = 0;
  }
  v60 = (_QWORD *)(v59 + 8 * v55);
  *v60 = 1;
  if (v51 == v54)
  {
    v62 = v59 + 8 * v55;
  }
  else
  {
    v61 = v51;
    v62 = v59 + 8 * v55;
    do
    {
      v63 = *--v61;
      *(_QWORD *)(v62 - 8) = v63;
      v62 -= 8;
    }
    while (v61 != v54);
  }
  v53 = v60 + 1;
  *a5 = v62;
  a5[1] = (uint64_t)(v60 + 1);
  v64 = a5[2];
  a5[2] = v59 + 8 * v58;
  v102 = v51;
  v103 = v64;
  v100 = v54;
  v101 = v54;
  std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v100);
  v40 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3304);
  v52 = a5[2];
LABEL_51:
  a5[1] = (uint64_t)v53;
  v65 = v40;
  if ((unint64_t)v53 < v52)
  {
    *v53 = v40;
    v66 = v53 + 1;
    goto LABEL_68;
  }
  v67 = (_QWORD *)*a5;
  v68 = ((uint64_t)v53 - *a5) >> 3;
  v69 = v68 + 1;
  if ((unint64_t)(v68 + 1) >> 61)
    goto LABEL_87;
  v70 = v52 - (_QWORD)v67;
  if (v70 >> 2 > v69)
    v69 = v70 >> 2;
  if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF8)
    v71 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v71 = v69;
  v104 = a5 + 3;
  if (v71)
  {
    v72 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v71);
    v67 = (_QWORD *)*a5;
    v53 = (_QWORD *)a5[1];
  }
  else
  {
    v72 = 0;
  }
  v73 = (_QWORD *)(v72 + 8 * v68);
  *v73 = v65;
  if (v53 == v67)
  {
    v75 = v72 + 8 * v68;
  }
  else
  {
    v74 = v53;
    v75 = v72 + 8 * v68;
    do
    {
      v76 = *--v74;
      *(_QWORD *)(v75 - 8) = v76;
      v75 -= 8;
    }
    while (v74 != v67);
  }
  v66 = v73 + 1;
  *a5 = v75;
  a5[1] = (uint64_t)(v73 + 1);
  v77 = a5[2];
  a5[2] = v72 + 8 * v71;
  v102 = v53;
  v103 = v77;
  v100 = v67;
  v101 = v67;
  std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v100);
  v52 = a5[2];
LABEL_68:
  a5[1] = (uint64_t)v66;
  v78 = *(_DWORD *)(a1 + 64);
  v79 = v78;
  if ((unint64_t)v66 < v52)
  {
    *v66 = v78;
    v80 = v66 + 1;
    goto LABEL_85;
  }
  v81 = (_QWORD *)*a5;
  v82 = ((uint64_t)v66 - *a5) >> 3;
  v83 = v82 + 1;
  if ((unint64_t)(v82 + 1) >> 61)
LABEL_87:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  v84 = v52 - (_QWORD)v81;
  if (v84 >> 2 > v83)
    v83 = v84 >> 2;
  if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFF8)
    v85 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v85 = v83;
  v104 = a5 + 3;
  if (v85)
  {
    v86 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v85);
    v81 = (_QWORD *)*a5;
    v66 = (_QWORD *)a5[1];
  }
  else
  {
    v86 = 0;
  }
  v87 = (_QWORD *)(v86 + 8 * v82);
  *v87 = v79;
  if (v66 == v81)
  {
    v89 = v86 + 8 * v82;
  }
  else
  {
    v88 = v66;
    v89 = v86 + 8 * v82;
    do
    {
      v90 = *--v88;
      *(_QWORD *)(v89 - 8) = v90;
      v89 -= 8;
    }
    while (v88 != v81);
  }
  v80 = v87 + 1;
  *a5 = v89;
  a5[1] = (uint64_t)(v87 + 1);
  v91 = a5[2];
  a5[2] = v86 + 8 * v85;
  v102 = v66;
  v103 = v91;
  v100 = v81;
  v101 = v81;
  std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v100);
  v78 = *(_DWORD *)(a1 + 64);
LABEL_85:
  a5[1] = (uint64_t)v80;
  v92 = *(_QWORD *)(a1 + 24);
  v93 = *(int *)(v92 + 3304) * (uint64_t)v78;
  std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a4, *(char **)(v92 + 3352), *(_QWORD *)(v92 + 3352) + 4 * v93, v93);
}

char **NeonFirstConvMelManager::NeonFirstConvMelManager(char **a1, char *a2, uint64_t a3, uint64_t a4, char **a5)
{
  char **v7;
  uint64_t v8;
  NeonMELContainer *v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  _QWORD v13[13];
  char v14;
  uint64_t v15;
  void *v16;
  std::locale v17;

  a1[19] = 0;
  v7 = a1 + 19;
  a1[1] = 0;
  a1[2] = 0;
  a1[14] = 0;
  a1[15] = 0;
  v8 = CustomAllocator::mRsrc;
  a1[16] = 0;
  a1[17] = (char *)v8;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = (char *)v8;
  a1[28] = 0;
  a1[29] = 0;
  a1[18] = a2;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v13);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=(v7, a5);
  NeonFirstConvMelManager::ModelNpy((uint64_t)a1, (uint64_t)v13);
  v9 = (NeonMELContainer *)a1[18];
  *((_BYTE *)v9 + 3496) = 0;
  if (*((_BYTE *)v9 + 2304)
    && (NeonMELContainer::EngineMCSetUp(v9, a1, 0, (void (*)(void *, int))mc_FirstConv_do_inference) & 1) == 0)
  {
    v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"WARNING: error set up multi-core engine", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
    v11 = std::locale::use_facet(&v17, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
    std::locale::~locale(&v17);
    std::ostream::put();
    std::ostream::flush();
  }
  v13[0] = &unk_24D29B388;
  v13[2] = &unk_24D29B3B0;
  v16 = &unk_24D29B3D8;
  v13[3] = &unk_24D29B578;
  if (v14 < 0)
    heap_Free(*(_QWORD **)(v15 + 8), v13[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v16);
  return a1;
}

void sub_214EA6848(_Unwind_Exception *a1, uint64_t a2, ...)
{
  SplitMELManager *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  std::locale::~locale((std::locale *)(v5 - 56));
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v4);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v3);
  SplitMELManager::~SplitMELManager(v2);
  _Unwind_Resume(a1);
}

uint64_t NeonFirstConvMelManager::ModelNpy(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  const std::locale::facet *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  _QWORD *v37;
  const std::locale::facet *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  const std::locale::facet *v46;
  uint64_t v48[2];
  char v49;
  uint64_t v50;
  uint64_t v51[2];
  char v52;
  uint64_t v53;
  std::locale v54;
  void *v55;
  void *v56;
  uint64_t v57;
  char v58;
  uint64_t v59;
  _QWORD v60[19];
  std::locale v61;
  void *v62;
  _QWORD v63[10];
  char v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = CustomAllocator::mRsrc;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = CustomAllocator::mRsrc;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = CustomAllocator::mRsrc;
  v3 = (_QWORD *)(a2 + 16);
  v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a2 + 16), (uint64_t)"path: ", 6);
  v5 = *(char *)(a1 + 175);
  if (v5 >= 0)
    v6 = a1 + 152;
  else
    v6 = *(_QWORD *)(a1 + 152);
  if (v5 >= 0)
    v7 = *(unsigned __int8 *)(a1 + 175);
  else
    v7 = *(_QWORD *)(a1 + 160);
  v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, v6, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24)));
  v9 = std::locale::use_facet(&v61, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v61);
  std::ostream::put();
  std::ostream::flush();
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v61);
  v76 = v75;
  v68 = v67;
  v72 = v71;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v54);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v54, (uint64_t *)&v61);
  v54.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v55 = &unk_24D29B3B0;
  v60[0] = &unk_24D29B3D8;
  v56 = &unk_24D29B578;
  if (v58 < 0)
    heap_Free(*(_QWORD **)(v59 + 8), v57);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v60);
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v62, (uint64_t)"initial/layer/conv/weight", 25);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"/npy", 4);
  v11 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v63, v51);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v11 + 24))(v11, v51, &v75, &v67, 1);
  if (v52 < 0)
    heap_Free(*(_QWORD **)(v53 + 8), v51[0]);
  if (v68 == v67)
  {
    v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"error: initial_layer_conv_weight", 32);
    std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(_QWORD *)(*v37 - 24)));
    v38 = std::locale::use_facet(&v54, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
    std::locale::~locale(&v54);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v12 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 5376 * *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4080));
    v13 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 5376 * *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4080));
    v14 = 0;
    v15 = 0;
    v16 = *(_QWORD *)(a1 + 144);
    *(_QWORD *)(v16 + 2720) = v13;
    v17 = *(_DWORD *)(v16 + 4080);
    v18 = v67;
    v19 = (v68 - v67) >> 1;
    do
    {
      if (v17 >= 1)
      {
        v20 = 0;
        v21 = v15;
        v22 = v14;
        do
        {
          v23 = 0;
          v24 = v21;
          do
          {
            if (v19 <= v24)
              std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
            *(_WORD *)(v12 + 2 * (v22 + (int)v23++)) = *(_WORD *)(v18 + 2 * v24);
            v24 += 7 * v17;
          }
          while (v23 != 384);
          ++v20;
          v22 += 384;
          v21 += 7;
        }
        while (v20 != v17);
      }
      ++v15;
      v14 += 384 * v17;
    }
    while (v15 != 7);
    v25 = 0;
    v26 = 0;
    v27 = 0;
    do
    {
      v28 = 0;
      v29 = v25;
      do
      {
        if (v17 >= 4)
        {
          v30 = 0;
          v31 = v29;
          do
          {
            v32 = 0;
            v33 = v31;
            do
            {
              v34 = 0;
              v35 = v27;
              v36 = v13 + 2 * v27;
              do
              {
                *(_WORD *)(v36 + 2 * v34) = *(_WORD *)(v12 + 2 * (v33 + (int)v34));
                ++v34;
              }
              while (v34 != 8);
              v27 = v35 + 8;
              ++v32;
              v33 += 384;
            }
            while (v32 != 4);
            ++v30;
            v27 = v35 + 8;
            v31 += 1536;
          }
          while (v30 != v17 / 4);
          v27 = v35 + 8;
        }
        ++v28;
        v29 += 384 * v17;
      }
      while (v28 != 7);
      ++v26;
      v25 += 8;
    }
    while (v26 != 48);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v12);
  }
  v76 = v75;
  v68 = v67;
  v72 = v71;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v54);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v54, (uint64_t *)&v61);
  v54.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v60[0] = &unk_24D29B3D8;
  v55 = &unk_24D29B3B0;
  v56 = &unk_24D29B578;
  if (v58 < 0)
    heap_Free(*(_QWORD **)(v59 + 8), v57);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v60);
  v39 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v62, (uint64_t)"initial/layer/conv/bias", 23);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)"/npy", 4);
  v40 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v63, v48);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v40 + 24))(v40, v48, &v75, &v67, 1);
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48[0]);
  if (v68 == v67)
  {
    v45 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"error: initial_layer_conv1_bias", 31);
    std::ios_base::getloc((const std::ios_base *)((char *)v45 + *(_QWORD *)(*v45 - 24)));
    v46 = std::locale::use_facet(&v54, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v46->__vftable[2].~facet_0)(v46, 10);
    std::locale::~locale(&v54);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v41 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 768);
    v42 = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2728) = v41;
    v43 = v67;
    v44 = (v68 - v67) >> 1;
    do
    {
      if (v44 == v42)
        std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
      *(_WORD *)(v41 + 2 * v42) = *(_WORD *)(v43 + 2 * v42);
      ++v42;
    }
    while (v42 != 384);
  }
  v61.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v66 = &unk_24D29B3D8;
  v62 = &unk_24D29B3B0;
  v63[0] = &unk_24D29B578;
  if (v64 < 0)
    heap_Free(*(_QWORD **)(v65 + 8), v63[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v66);
  v61.__locale_ = (std::locale::__imp *)&v67;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v61);
  v61.__locale_ = (std::locale::__imp *)&v71;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v61);
  v61.__locale_ = (std::locale::__imp *)&v75;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v61);
  return 1;
}

void sub_214EA6F3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, std::locale a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,std::locale a54)
{
  uint64_t v54;

  std::locale::~locale(&a18);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)&a54);
  *(_QWORD *)(v54 - 88) = v54 - 184;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v54 - 88));
  *(_QWORD *)(v54 - 184) = v54 - 152;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v54 - 184));
  *(_QWORD *)(v54 - 152) = v54 - 120;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v54 - 152));
  _Unwind_Resume(a1);
}

uint64_t *mc_FirstConv_do_inference(uint64_t a1, int a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float16x8_t *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t *result;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t *v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t *v37;
  _QWORD *v38;
  _QWORD *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  unint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  _QWORD *v65;
  _QWORD *v66;
  uint64_t v67;
  _QWORD *v68;

  v4 = *(_QWORD *)(a1 + 144);
  v5 = *(_DWORD *)(v4 + 2308);
  if (v5 == 4)
  {
    if (a2 > 1)
      goto LABEL_5;
    v5 = 2;
  }
  SplitMELManager::neon_conv1_input_shift_by_columns(a1, *(_QWORD *)(v4 + 2840), *(_QWORD *)(v4 + 2760), *(_DWORD *)(v4 + 4080), *(_DWORD *)(v4 + 4088), a2, v5);
LABEL_5:
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
  v7 = *(_QWORD *)(a1 + 144);
  v8 = *(_QWORD *)(v7 + 2720);
  v9 = *(_QWORD *)(v7 + 2728);
  v10 = *(float16x8_t **)(v7 + 2760);
  v11 = *(_DWORD *)(v7 + 4080);
  v12 = *(_DWORD *)(v7 + 4088);
  v13 = *(_DWORD *)(v7 + 2308);
  if (*(_BYTE *)(v7 + 3497))
    SplitMELManager::neon_conv1_cols(v6, v8, v9, v10, *(_QWORD *)(v7 + 2776), v11, 0x180u, v12, a2, v13);
  else
    SplitMELManager::neon_conv1_cols(v6, v8, v9, v10, *(_QWORD *)(v7 + 2848), v11, 0x180u, v12, a2, v13);
  result = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
  if (!a2)
  {
    v15 = *(_QWORD *)(a1 + 144);
    v16 = *(_DWORD *)(a1 + 184);
    if (*(_BYTE *)(v15 + 3497))
    {
      *(_DWORD *)(v15 + 4092) = v16;
LABEL_63:
      *(_DWORD *)(a1 + 184) = 0;
      return result;
    }
    v17 = *(_DWORD *)(v15 + 4088) - v16;
    *(_DWORD *)(v15 + 4088) = v17;
    v18 = *(uint64_t **)(a1 + 216);
    v19 = (_QWORD *)v18[1];
    v20 = v18[2];
    if ((unint64_t)v19 >= v20)
    {
      v23 = (_QWORD *)*v18;
      v24 = ((uint64_t)v19 - *v18) >> 3;
      v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 61)
        goto LABEL_65;
      v26 = v20 - (_QWORD)v23;
      if (v26 >> 2 > v25)
        v25 = v26 >> 2;
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
        v27 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v27 = v25;
      v68 = v18 + 3;
      if (v27)
      {
        v28 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v18 + 3), v27);
        v23 = (_QWORD *)*v18;
        v19 = (_QWORD *)v18[1];
      }
      else
      {
        v28 = 0;
      }
      v29 = (_QWORD *)(v28 + 8 * v24);
      *v29 = 1;
      if (v19 == v23)
      {
        v31 = v28 + 8 * v24;
      }
      else
      {
        v30 = v19;
        v31 = v28 + 8 * v24;
        do
        {
          v32 = *--v30;
          *(_QWORD *)(v31 - 8) = v32;
          v31 -= 8;
        }
        while (v30 != v23);
      }
      v22 = v29 + 1;
      *v18 = v31;
      v64 = v23;
      v65 = v23;
      v18[1] = (uint64_t)(v29 + 1);
      v66 = v19;
      v33 = v18[2];
      v18[2] = v28 + 8 * v27;
      v67 = v33;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v64);
      v21 = *(uint64_t **)(a1 + 216);
      v17 = *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4088);
    }
    else
    {
      *v19 = 1;
      v21 = v18;
      v22 = v19 + 1;
    }
    v18[1] = (uint64_t)v22;
    v34 = v17;
    v35 = (_QWORD *)v21[1];
    v36 = v21[2];
    if ((unint64_t)v35 >= v36)
    {
      v39 = (_QWORD *)*v21;
      v40 = ((uint64_t)v35 - *v21) >> 3;
      v41 = v40 + 1;
      if ((unint64_t)(v40 + 1) >> 61)
        std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
      v42 = v36 - (_QWORD)v39;
      if (v42 >> 2 > v41)
        v41 = v42 >> 2;
      if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8)
        v43 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v43 = v41;
      v68 = v21 + 3;
      if (v43)
      {
        v44 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v21 + 3), v43);
        v39 = (_QWORD *)*v21;
        v35 = (_QWORD *)v21[1];
      }
      else
      {
        v44 = 0;
      }
      v45 = (_QWORD *)(v44 + 8 * v40);
      *v45 = v34;
      if (v35 == v39)
      {
        v47 = v44 + 8 * v40;
      }
      else
      {
        v46 = v35;
        v47 = v44 + 8 * v40;
        do
        {
          v48 = *--v46;
          *(_QWORD *)(v47 - 8) = v48;
          v47 -= 8;
        }
        while (v46 != v39);
      }
      v38 = v45 + 1;
      *v21 = v47;
      v64 = v39;
      v65 = v39;
      v21[1] = (uint64_t)(v45 + 1);
      v66 = v35;
      v49 = v21[2];
      v21[2] = v44 + 8 * v43;
      v67 = v49;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v64);
      v37 = *(uint64_t **)(a1 + 216);
    }
    else
    {
      *v35 = v17;
      v37 = v21;
      v38 = v35 + 1;
    }
    v21[1] = (uint64_t)v38;
    v50 = (_QWORD *)v37[1];
    v51 = v37[2];
    if ((unint64_t)v50 < v51)
    {
      *v50 = 384;
      v52 = v50 + 1;
LABEL_62:
      v37[1] = (uint64_t)v52;
      result = std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(*(uint64_t **)(a1 + 208), *(char **)(*(_QWORD *)(a1 + 144) + 2848), *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2848) + 1536 * *(int *)(*(_QWORD *)(a1 + 144) + 4088), 384 * *(int *)(*(_QWORD *)(a1 + 144) + 4088));
      goto LABEL_63;
    }
    v53 = (_QWORD *)*v37;
    v54 = ((uint64_t)v50 - *v37) >> 3;
    v55 = v54 + 1;
    if (!((unint64_t)(v54 + 1) >> 61))
    {
      v56 = v51 - (_QWORD)v53;
      if (v56 >> 2 > v55)
        v55 = v56 >> 2;
      if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF8)
        v57 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v57 = v55;
      v68 = v37 + 3;
      if (v57)
      {
        v58 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v37 + 3), v57);
        v53 = (_QWORD *)*v37;
        v50 = (_QWORD *)v37[1];
      }
      else
      {
        v58 = 0;
      }
      v59 = (_QWORD *)(v58 + 8 * v54);
      *v59 = 384;
      if (v50 == v53)
      {
        v61 = v58 + 8 * v54;
      }
      else
      {
        v60 = v50;
        v61 = v58 + 8 * v54;
        do
        {
          v62 = *--v60;
          *(_QWORD *)(v61 - 8) = v62;
          v61 -= 8;
        }
        while (v60 != v53);
      }
      v52 = v59 + 1;
      *v37 = v61;
      v64 = v53;
      v65 = v53;
      v37[1] = (uint64_t)(v59 + 1);
      v66 = v50;
      v63 = v37[2];
      v37[2] = v58 + 8 * v57;
      v67 = v63;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v64);
      goto LABEL_62;
    }
LABEL_65:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  }
  return result;
}

void SplitMELManager::~SplitMELManager(SplitMELManager *this)
{
  if (*((char *)this + 135) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 17) + 8), *((_QWORD *)this + 14));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

_QWORD *NeonFirstConvMelManager::NeonFirstConvMelManager(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  uint64_t v5;
  NeonMELContainer *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  std::locale v10;

  a1[19] = 0;
  v4 = a1 + 19;
  a1[1] = 0;
  a1[2] = 0;
  a1[14] = 0;
  a1[15] = 0;
  v5 = CustomAllocator::mRsrc;
  a1[16] = 0;
  a1[17] = v5;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = v5;
  a1[28] = 0;
  a1[29] = 0;
  a1[18] = a2;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 28, a3);
  v6 = (NeonMELContainer *)*(v4 - 1);
  *((_BYTE *)v6 + 3496) = 0;
  if (*((_BYTE *)v6 + 2304)
    && (NeonMELContainer::EngineMCSetUp(v6, a1, 0, (void (*)(void *, int))mc_FirstConv_do_inference) & 1) == 0)
  {
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"WARNING: error set up multi-core engine", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v10, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v10);
    std::ostream::put();
    std::ostream::flush();
  }
  return a1;
}

void sub_214EA752C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  SplitMELManager *v10;
  uint64_t v11;
  uint64_t v12;

  std::locale::~locale(&a10);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v12);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v11);
  SplitMELManager::~SplitMELManager(v10);
  _Unwind_Resume(a1);
}

void NeonFirstConvMelManager::~NeonFirstConvMelManager(NeonFirstConvMelManager *this)
{
  char *v2;

  v2 = (char *)this + 224;
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 2720));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 2728));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  if (*((char *)this + 175) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 22) + 8), *((_QWORD *)this + 19));
  if (*((char *)this + 135) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 17) + 8), *((_QWORD *)this + 14));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

void SplitMELManager::neon_conv1_input_shift_by_columns(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, int a6, unsigned int a7)
{
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  int v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 *v25;
  __int128 v26;
  _OWORD *v27;
  _OWORD *v28;
  _OWORD *v29;
  _OWORD *v30;
  _OWORD *v31;
  _OWORD *v32;
  _OWORD *v33;

  v7 = a4 >> 3;
  v8 = (a4 >> 3) / a7 * a6;
  v9 = v8 + (a4 >> 3) / a7;
  if (v8 < v9)
  {
    v10 = 12 * v7;
    v11 = v7 << 6;
    v12 = 4 * v7;
    v13 = a5 >> 2;
    v14 = v7 << 7;
    if (a5 >> 2 <= 1)
      v15 = 1;
    else
      v15 = v13;
    do
    {
      v16 = 32 * v8;
      v17 = 0uLL;
      v18 = 0uLL;
      v19 = 0uLL;
      if (a5 >= 4)
      {
        v20 = 0;
        v21 = 0uLL;
        v22 = v15;
        v23 = 0uLL;
        v24 = 0uLL;
        do
        {
          v25 = (__int128 *)(a2 + 2 * (int)(32 * (v13 * v8 + v20)));
          v26 = *v25;
          v19 = v25[1];
          v18 = v25[2];
          v17 = v25[3];
          v27 = (_OWORD *)(a3 + 2 * (v16 + v14 * (int)v20));
          *v27 = v21;
          v27[1] = v23;
          v27[2] = v24;
          v27[3] = v26;
          v28 = &v27[v12];
          *v28 = v23;
          v28[1] = v24;
          v28[2] = v26;
          v28[3] = v19;
          v29 = (_OWORD *)((char *)v27 + 2 * v11);
          *v29 = v24;
          v29[1] = v26;
          v29[2] = v19;
          v29[3] = v18;
          v30 = &v27[v10];
          *v30 = v26;
          v30[1] = v19;
          ++v20;
          v21 = v19;
          v23 = v18;
          v24 = v17;
          v30[2] = v18;
          v30[3] = v17;
          --v22;
        }
        while (v22);
      }
      v31 = (_OWORD *)(a3 + 2 * (int)(v16 + v14 * (a5 >> 2)));
      *v31 = v19;
      v31[1] = v18;
      v31[2] = v17;
      v31[3] = 0uLL;
      v32 = &v31[v12];
      *v32 = v18;
      v32[1] = v17;
      v33 = (_OWORD *)((char *)v31 + 2 * v11);
      v32[2] = 0uLL;
      v32[3] = 0uLL;
      ++v8;
      *v33 = v17;
      v33[1] = 0uLL;
      v33[2] = 0uLL;
      v33[3] = 0uLL;
    }
    while (v9 > v8);
  }
}

void SplitMELManager::neon_conv1_cols(uint64_t a1, uint64_t a2, uint64_t a3, float16x8_t *a4, uint64_t a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9, unsigned int a10)
{
  uint64_t v10;
  uint64_t v11;
  signed int v12;
  int v13;
  int v14;
  float16x8_t v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float16x8_t *v22;
  uint64_t v23;
  uint64_t v24;
  float16x8_t v25;
  float16x8_t *v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  uint64_t v30;
  uint64_t v31;
  float16x8_t *v32;
  uint64_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t *v49;

  if (a8 >= 4)
  {
    v10 = 0;
    v11 = a8 >> 2;
    v12 = (8 * a6) & 0xFFFFFFE0;
    v13 = 32 * (a7 >> 3);
    v14 = (a7 >> 3) / a10;
    v15 = (float16x8_t)vdupq_n_s16(0x3266u);
    v16 = 7 * v12;
    v17 = v12;
    v18 = v14 * a9 + v14;
    if (a6 >> 3 <= 1)
      v19 = 1;
    else
      v19 = a6 >> 3;
    v20 = v16;
    v21 = v14 * a9;
    v22 = a4 + 2;
    do
    {
      if (v21 < v18)
      {
        v23 = v21;
        do
        {
          v24 = 0;
          v25 = *(float16x8_t *)(a3 + 16 * (int)v23);
          v26 = v22;
          v27 = v25;
          v28 = v25;
          v29 = v25;
          do
          {
            if (a6 >= 8)
            {
              v30 = 0;
              v31 = v19;
              v32 = v26;
              do
              {
                v33 = a2 + 2 * v23 * v20 + 2 * v24 * v17 + (v30 << 7);
                v34 = *(float16x8_t *)(v33 + 16);
                v35 = *(float16x8_t *)(v33 + 32);
                v36 = *(float16x8_t *)(v33 + 48);
                v38 = v32[-2];
                v37 = v32[-1];
                v40 = *v32;
                v39 = v32[1];
                v32 += 4;
                v41 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v25, *(float16x8_t *)v33, *(short float *)v38.i16), v34, *(float16x4_t *)v38.i8, 1), v35, *(float16x4_t *)v38.i8, 2), v36, *(float16x4_t *)v38.i8, 3);
                v42 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v27, *(float16x8_t *)v33, *(short float *)v37.i16), v34, *(float16x4_t *)v37.i8, 1), v35, *(float16x4_t *)v37.i8, 2), v36, *(float16x4_t *)v37.i8, 3);
                v43 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v28, *(float16x8_t *)v33, *(short float *)v40.i16), v34, *(float16x4_t *)v40.i8, 1), v35, *(float16x4_t *)v40.i8, 2), v36, *(float16x4_t *)v40.i8, 3);
                v44 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v29, *(float16x8_t *)v33, *(short float *)v39.i16), v34, *(float16x4_t *)v39.i8, 1), v35, *(float16x4_t *)v39.i8, 2), v36, *(float16x4_t *)v39.i8, 3);
                v45 = *(float16x8_t *)(v33 + 64);
                v46 = *(float16x8_t *)(v33 + 80);
                v47 = *(float16x8_t *)(v33 + 96);
                v48 = *(float16x8_t *)(v33 + 112);
                v25 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v41, v45, v38, 4), v46, v38, 5), v47, v38, 6), v48, v38, 7);
                v27 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v42, v45, v37, 4), v46, v37, 5), v47, v37, 6), v48, v37, 7);
                v28 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v43, v45, v40, 4), v46, v40, 5), v47, v40, 6), v48, v40, 7);
                v29 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v44, v45, v39, 4), v46, v39, 5), v47, v39, 6), v48, v39, 7);
                ++v30;
                --v31;
              }
              while (v31);
            }
            ++v24;
            v26 = (float16x8_t *)((char *)v26 + 2 * (int)(32 * (a6 >> 3)));
          }
          while (v24 != 7);
          v49 = (float16x8_t *)(a5 + 2 * (v13 * v10) + ((uint64_t)(int)v23 << 6));
          *v49 = vaddq_f16(vmaxq_f16(v25, (float16x8_t)0), vmulq_f16(vminq_f16(v25, (float16x8_t)0), v15));
          v49[1] = vaddq_f16(vmaxq_f16(v27, (float16x8_t)0), vmulq_f16(vminq_f16(v27, (float16x8_t)0), v15));
          v49[2] = vaddq_f16(vmaxq_f16(v28, (float16x8_t)0), vmulq_f16(vminq_f16(v28, (float16x8_t)0), v15));
          v49[3] = vaddq_f16(vmaxq_f16(v29, (float16x8_t)0), vmulq_f16(vminq_f16(v29, (float16x8_t)0), v15));
          ++v23;
        }
        while (v18 > v23);
      }
      ++v10;
      v22 = (float16x8_t *)((char *)v22 + 2 * (int)(a6 >> 3 << 7));
    }
    while (v10 != v11);
  }
}

{
  uint64_t v10;
  signed int v11;
  uint64_t v12;
  float16x8_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  float16x8_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float16x8_t v24;
  float16x8_t *v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  uint64_t v29;
  uint64_t v30;
  float16x8_t *v31;
  uint64_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float32x4_t *v48;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;

  if (a8 >= 4)
  {
    v10 = 0;
    v11 = (8 * a6) & 0xFFFFFFE0;
    LODWORD(v12) = a6 >> 3;
    v13 = (float16x8_t)vdupq_n_s16(0x3266u);
    v14 = (a7 >> 3) / a10;
    v15 = 2 * a7;
    v16 = v11;
    v17 = 7 * v11;
    v18 = v14 * a9 + v14;
    v19 = v14 * a9;
    if (a6 >> 3 <= 1)
      v12 = 1;
    else
      v12 = v12;
    v20 = a4 + 2;
    do
    {
      if (v19 < v18)
      {
        v21 = v19;
        do
        {
          v22 = 0;
          v23 = 8 * (int)v21;
          v24 = *(float16x8_t *)(a3 + 2 * v23);
          v25 = v20;
          v26 = v24;
          v27 = v24;
          v28 = v24;
          do
          {
            if (a6 >= 8)
            {
              v29 = 0;
              v30 = v12;
              v31 = v25;
              do
              {
                v32 = a2 + 2 * v21 * v17 + 2 * v22 * v16 + (v29 << 7);
                v33 = *(float16x8_t *)(v32 + 16);
                v34 = *(float16x8_t *)(v32 + 32);
                v35 = *(float16x8_t *)(v32 + 48);
                v37 = v31[-2];
                v36 = v31[-1];
                v39 = *v31;
                v38 = v31[1];
                v31 += 4;
                v40 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v24, *(float16x8_t *)v32, *(short float *)v37.i16), v33, *(float16x4_t *)v37.i8, 1), v34, *(float16x4_t *)v37.i8, 2), v35, *(float16x4_t *)v37.i8, 3);
                v41 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v26, *(float16x8_t *)v32, *(short float *)v36.i16), v33, *(float16x4_t *)v36.i8, 1), v34, *(float16x4_t *)v36.i8, 2), v35, *(float16x4_t *)v36.i8, 3);
                v42 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v27, *(float16x8_t *)v32, *(short float *)v39.i16), v33, *(float16x4_t *)v39.i8, 1), v34, *(float16x4_t *)v39.i8, 2), v35, *(float16x4_t *)v39.i8, 3);
                v43 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v28, *(float16x8_t *)v32, *(short float *)v38.i16), v33, *(float16x4_t *)v38.i8, 1), v34, *(float16x4_t *)v38.i8, 2), v35, *(float16x4_t *)v38.i8, 3);
                v44 = *(float16x8_t *)(v32 + 64);
                v45 = *(float16x8_t *)(v32 + 80);
                v46 = *(float16x8_t *)(v32 + 96);
                v47 = *(float16x8_t *)(v32 + 112);
                v24 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v40, v44, v37, 4), v45, v37, 5), v46, v37, 6), v47, v37, 7);
                v26 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v41, v44, v36, 4), v45, v36, 5), v46, v36, 6), v47, v36, 7);
                v27 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v42, v44, v39, 4), v45, v39, 5), v46, v39, 6), v47, v39, 7);
                v28 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v43, v44, v38, 4), v45, v38, 5), v46, v38, 6), v47, v38, 7);
                ++v29;
                --v30;
              }
              while (v30);
            }
            ++v22;
            v25 = (float16x8_t *)((char *)v25 + 2 * (int)(32 * (a6 >> 3)));
          }
          while (v22 != 7);
          v48 = (float32x4_t *)(a5 + 4 * (int)(4 * a7 * v10) + 4 * v23);
          v49 = (int8x16_t)vaddq_f16(vmaxq_f16(v24, (float16x8_t)0), vmulq_f16(vminq_f16(v24, (float16x8_t)0), v13));
          v50 = (int8x16_t)vaddq_f16(vmaxq_f16(v26, (float16x8_t)0), vmulq_f16(vminq_f16(v26, (float16x8_t)0), v13));
          v51 = (int8x16_t)vaddq_f16(vmaxq_f16(v27, (float16x8_t)0), vmulq_f16(vminq_f16(v27, (float16x8_t)0), v13));
          v52 = (int8x16_t)vaddq_f16(vmaxq_f16(v28, (float16x8_t)0), vmulq_f16(vminq_f16(v28, (float16x8_t)0), v13));
          *v48 = vcvtq_f32_f16(*(float16x4_t *)v49.i8);
          *(float32x4_t *)((char *)v48 + 4 * a7) = vcvtq_f32_f16(*(float16x4_t *)v50.i8);
          *(float32x4_t *)((char *)v48 + 4 * v15) = vcvtq_f32_f16(*(float16x4_t *)v51.i8);
          *(float32x4_t *)((char *)v48 + 12 * a7) = vcvtq_f32_f16(*(float16x4_t *)v52.i8);
          v48[1] = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL));
          *(float32x4_t *)((char *)++v48 + 4 * a7) = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL));
          *(float32x4_t *)((char *)v48 + 4 * v15) = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v51, v51, 8uLL));
          *(float32x4_t *)((char *)v48 + 12 * a7) = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL));
          ++v21;
        }
        while (v18 > v21);
      }
      ++v10;
      v20 = (float16x8_t *)((char *)v20 + 2 * (int)(a6 >> 3 << 7));
    }
    while (v10 != a8 >> 2);
  }
}

void NeonFirstConvMelManager::do_inference(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  BOOL v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x4_t *v19;
  unint64_t v20;
  float32x4_t *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _DWORD *v27;
  float32x4_t *v28;
  uint64_t v29;
  __int32 v30;
  float32x4_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int *v40;
  int v41;
  float32x4_t *v42;
  unint64_t v43;
  float32x4_t *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _DWORD *v50;
  float32x4_t *v51;
  uint64_t v52;
  __int32 v53;
  float32x4_t *v54;
  uint64_t v55;
  int v56;
  int *v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  float16x8_t *v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  uint64_t v68;
  int v69;
  int v70;
  int v71;
  float32x4_t *v72;
  unint64_t v73;
  float32x4_t *v74;
  float32x4_t *v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  float32x4_t *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  float32x4_t *v87;
  float32x4_t *v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  float32x4_t *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  float32x4_t *v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  float32x4_t *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  float32x4_t *v113;
  float32x4_t *v114;
  float32x4_t *v115;
  uint64_t v116;
  _QWORD *v117;

  v5 = a5;
  v6 = a4;
  v8 = a1;
  v9 = *(_QWORD *)(a1 + 144);
  if (!*(_BYTE *)(v9 + 2304))
  {
    v33 = *a3;
    v34 = a3[1] - *a3;
    if (v34 <= 8 || (v35 = *(_DWORD *)(v33 + 8), *(_DWORD *)(v9 + 4084) = v35, v34 <= 0x10))
LABEL_125:
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    *(_DWORD *)(v9 + 4080) = *(_QWORD *)(v33 + 16);
    v13 = -v35 < 0;
    v36 = -v35 & 3;
    v37 = v35 & 3;
    if (v13)
      v38 = v37;
    else
      v38 = -v36;
    if (v38)
    {
      v39 = 0;
      v38 = 4 - v38;
      *(_DWORD *)(a1 + 184) = v38;
      v40 = (int *)(a1 + 184);
      do
      {
        if (*(int *)(v9 + 4080) >= 1)
        {
          v41 = 0;
          v42 = *(float32x4_t **)(a2 + 8);
          do
          {
            v43 = *(_QWORD *)(a2 + 16);
            if ((unint64_t)v42 >= v43)
            {
              v44 = *(float32x4_t **)a2;
              v45 = ((uint64_t)v42 - *(_QWORD *)a2) >> 2;
              v46 = v45 + 1;
              if ((unint64_t)(v45 + 1) >> 62)
LABEL_124:
                std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
              v47 = v43 - (_QWORD)v44;
              if (v47 >> 1 > v46)
                v46 = v47 >> 1;
              if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL)
                v48 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v48 = v46;
              v117 = (_QWORD *)(a2 + 24);
              if (v48)
              {
                v49 = ENTTS::Allocator<int>::allocate(a2 + 24, v48);
                v44 = *(float32x4_t **)a2;
                v42 = *(float32x4_t **)(a2 + 8);
              }
              else
              {
                v49 = 0;
              }
              v50 = (_DWORD *)(v49 + 4 * v45);
              *v50 = 0;
              if (v42 == v44)
              {
                v52 = v49 + 4 * v45;
              }
              else
              {
                v51 = v42;
                v52 = v49 + 4 * v45;
                do
                {
                  v53 = v51[-1].i32[3];
                  v51 = (float32x4_t *)((char *)v51 - 4);
                  *(_DWORD *)(v52 - 4) = v53;
                  v52 -= 4;
                }
                while (v51 != v44);
              }
              v54 = (float32x4_t *)(v50 + 1);
              *(_QWORD *)a2 = v52;
              *(_QWORD *)(a2 + 8) = v50 + 1;
              v55 = *(_QWORD *)(a2 + 16);
              *(_QWORD *)(a2 + 16) = v49 + 4 * v48;
              v115 = v42;
              v116 = v55;
              v113 = v44;
              v114 = v44;
              a1 = std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&v113);
              v9 = *(_QWORD *)(v8 + 144);
              v42 = v54;
            }
            else
            {
              v42->i32[0] = 0;
              v42 = (float32x4_t *)((char *)v42 + 4);
            }
            *(_QWORD *)(a2 + 8) = v42;
            ++v41;
          }
          while (v41 < *(_DWORD *)(v9 + 4080));
          v38 = *v40;
        }
        ++v39;
      }
      while (v39 < v38);
      v6 = a4;
      v5 = a5;
    }
    else
    {
      *(_DWORD *)(a1 + 184) = 0;
      v40 = (int *)(a1 + 184);
    }
    v58 = *(_DWORD *)(v9 + 4084) + v38;
    *(_DWORD *)(v9 + 4084) = v58;
    SplitMELManager::neon_replicate_and_tensor_placement_half(a1, *(float32x4_t **)a2, *(_QWORD *)(v9 + 2840), *(_DWORD *)(v9 + 4080), v58, 4);
    SplitMELManager::neon_conv1_input_shift_by_columns(v59, *(_QWORD *)(*(_QWORD *)(v8 + 144) + 2840), *(_QWORD *)(*(_QWORD *)(v8 + 144) + 2760), *(_DWORD *)(*(_QWORD *)(v8 + 144) + 4080), *(_DWORD *)(*(_QWORD *)(v8 + 144) + 4084) + 4, 0, *(_DWORD *)(*(_QWORD *)(v8 + 144) + 2308));
    v61 = *(_QWORD *)(v8 + 144);
    v62 = *(_QWORD *)(v61 + 2720);
    v63 = *(_QWORD *)(v61 + 2728);
    v64 = *(float16x8_t **)(v61 + 2760);
    v65 = *(_DWORD *)(v61 + 4080);
    v66 = *(_DWORD *)(v61 + 4084) + 4;
    v67 = *(_DWORD *)(v61 + 2308);
    if (*(_BYTE *)(v61 + 3497))
      SplitMELManager::neon_conv1_cols(v60, v62, v63, v64, *(_QWORD *)(v61 + 2776), v65, 0x180u, v66, 0, v67);
    else
      SplitMELManager::neon_conv1_cols(v60, v62, v63, v64, *(_QWORD *)(v61 + 2848), v65, 0x180u, v66, 0, v67);
    v68 = *(_QWORD *)(v8 + 144);
    v69 = *(_DWORD *)(v68 + 4084) + 4;
    *(_DWORD *)(v68 + 4088) = v69;
    v70 = *(_DWORD *)(v8 + 184);
    if (*(_BYTE *)(v68 + 3497))
    {
      *(_DWORD *)(v68 + 4092) = v70;
LABEL_122:
      *v40 = 0;
      return;
    }
    v71 = v69 - v70;
    *(_DWORD *)(v68 + 4088) = v71;
    v72 = (float32x4_t *)v5[1];
    v73 = v5[2];
    if ((unint64_t)v72 >= v73)
    {
      v75 = (float32x4_t *)*v5;
      v76 = ((uint64_t)v72 - *v5) >> 3;
      v77 = v76 + 1;
      if ((unint64_t)(v76 + 1) >> 61)
        goto LABEL_126;
      v78 = v73 - (_QWORD)v75;
      if (v78 >> 2 > v77)
        v77 = v78 >> 2;
      if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFF8)
        v79 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v79 = v77;
      v117 = v5 + 3;
      if (v79)
      {
        v80 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v79);
        v75 = (float32x4_t *)*v5;
        v72 = (float32x4_t *)v5[1];
      }
      else
      {
        v80 = 0;
      }
      v81 = (_QWORD *)(v80 + 8 * v76);
      *v81 = 1;
      if (v72 == v75)
      {
        v83 = v80 + 8 * v76;
      }
      else
      {
        v82 = v72;
        v83 = v80 + 8 * v76;
        do
        {
          v84 = v82[-1].i64[1];
          v82 = (float32x4_t *)((char *)v82 - 8);
          *(_QWORD *)(v83 - 8) = v84;
          v83 -= 8;
        }
        while (v82 != v75);
      }
      v74 = (float32x4_t *)(v81 + 1);
      *v5 = v83;
      v5[1] = (uint64_t)(v81 + 1);
      v85 = v5[2];
      v5[2] = v80 + 8 * v79;
      v115 = v72;
      v116 = v85;
      v113 = v75;
      v114 = v75;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v113);
      v71 = *(_DWORD *)(*(_QWORD *)(v8 + 144) + 4088);
      v73 = v5[2];
    }
    else
    {
      v72->i64[0] = 1;
      v74 = (float32x4_t *)&v72->u32[2];
    }
    v5[1] = (uint64_t)v74;
    v86 = v71;
    if ((unint64_t)v74 >= v73)
    {
      v88 = (float32x4_t *)*v5;
      v89 = ((uint64_t)v74 - *v5) >> 3;
      v90 = v89 + 1;
      if ((unint64_t)(v89 + 1) >> 61)
        goto LABEL_126;
      v91 = v73 - (_QWORD)v88;
      if (v91 >> 2 > v90)
        v90 = v91 >> 2;
      if ((unint64_t)v91 >= 0x7FFFFFFFFFFFFFF8)
        v92 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v92 = v90;
      v117 = v5 + 3;
      if (v92)
      {
        v93 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v92);
        v88 = (float32x4_t *)*v5;
        v74 = (float32x4_t *)v5[1];
      }
      else
      {
        v93 = 0;
      }
      v94 = (_QWORD *)(v93 + 8 * v89);
      *v94 = v86;
      if (v74 == v88)
      {
        v96 = v93 + 8 * v89;
      }
      else
      {
        v95 = v74;
        v96 = v93 + 8 * v89;
        do
        {
          v97 = v95[-1].i64[1];
          v95 = (float32x4_t *)((char *)v95 - 8);
          *(_QWORD *)(v96 - 8) = v97;
          v96 -= 8;
        }
        while (v95 != v88);
      }
      v87 = (float32x4_t *)(v94 + 1);
      *v5 = v96;
      v5[1] = (uint64_t)(v94 + 1);
      v98 = v5[2];
      v5[2] = v93 + 8 * v92;
      v115 = v74;
      v116 = v98;
      v113 = v88;
      v114 = v88;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v113);
      v73 = v5[2];
    }
    else
    {
      v74->i64[0] = v71;
      v87 = (float32x4_t *)&v74->u32[2];
    }
    v5[1] = (uint64_t)v87;
    if ((unint64_t)v87 < v73)
    {
      v87->i64[0] = 384;
      v99 = &v87->i64[1];
LABEL_121:
      v5[1] = (uint64_t)v99;
      std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(v6, *(char **)(*(_QWORD *)(v8 + 144) + 2848), *(_QWORD *)(*(_QWORD *)(v8 + 144) + 2848) + 1536 * *(int *)(*(_QWORD *)(v8 + 144) + 4088), 384 * *(int *)(*(_QWORD *)(v8 + 144) + 4088));
      goto LABEL_122;
    }
    v100 = (float32x4_t *)*v5;
    v101 = ((uint64_t)v87 - *v5) >> 3;
    v102 = v101 + 1;
    if (!((unint64_t)(v101 + 1) >> 61))
    {
      v103 = v73 - (_QWORD)v100;
      if (v103 >> 2 > v102)
        v102 = v103 >> 2;
      if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF8)
        v104 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v104 = v102;
      v117 = v5 + 3;
      if (v104)
      {
        v105 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v104);
        v100 = (float32x4_t *)*v5;
        v87 = (float32x4_t *)v5[1];
      }
      else
      {
        v105 = 0;
      }
      v106 = (_QWORD *)(v105 + 8 * v101);
      *v106 = 384;
      if (v87 == v100)
      {
        v108 = v105 + 8 * v101;
      }
      else
      {
        v107 = v87;
        v108 = v105 + 8 * v101;
        do
        {
          v109 = v107[-1].i64[1];
          v107 = (float32x4_t *)((char *)v107 - 8);
          *(_QWORD *)(v108 - 8) = v109;
          v108 -= 8;
        }
        while (v107 != v100);
      }
      v99 = v106 + 1;
      *v5 = v108;
      v5[1] = (uint64_t)(v106 + 1);
      v110 = v5[2];
      v5[2] = v105 + 8 * v104;
      v115 = v87;
      v116 = v110;
      v113 = v100;
      v114 = v100;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v113);
      goto LABEL_121;
    }
LABEL_126:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  }
  *(_QWORD *)(a1 + 192) = a2;
  *(_QWORD *)(a1 + 200) = a3;
  *(_QWORD *)(a1 + 208) = a4;
  *(_QWORD *)(a1 + 216) = a5;
  v10 = *a3;
  v11 = a3[1] - *a3;
  if (v11 <= 8)
    goto LABEL_125;
  v12 = *(_DWORD *)(v10 + 8);
  *(_DWORD *)(v9 + 4084) = v12;
  if (v11 <= 0x10)
    goto LABEL_125;
  *(_DWORD *)(v9 + 4080) = *(_QWORD *)(v10 + 16);
  v13 = -v12 < 0;
  v14 = -v12 & 3;
  v15 = v12 & 3;
  if (v13)
    v16 = v15;
  else
    v16 = -v14;
  if (v16)
  {
    v17 = 0;
    v16 = 4 - v16;
    *(_DWORD *)(a1 + 184) = v16;
    do
    {
      if (*(int *)(v9 + 4080) >= 1)
      {
        v18 = 0;
        v19 = *(float32x4_t **)(a2 + 8);
        do
        {
          v20 = *(_QWORD *)(a2 + 16);
          if ((unint64_t)v19 >= v20)
          {
            v21 = *(float32x4_t **)a2;
            v22 = ((uint64_t)v19 - *(_QWORD *)a2) >> 2;
            v23 = v22 + 1;
            if ((unint64_t)(v22 + 1) >> 62)
              goto LABEL_124;
            v24 = v20 - (_QWORD)v21;
            if (v24 >> 1 > v23)
              v23 = v24 >> 1;
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
              v25 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v25 = v23;
            v117 = (_QWORD *)(a2 + 24);
            if (v25)
            {
              v26 = ENTTS::Allocator<int>::allocate(a2 + 24, v25);
              v21 = *(float32x4_t **)a2;
              v19 = *(float32x4_t **)(a2 + 8);
            }
            else
            {
              v26 = 0;
            }
            v27 = (_DWORD *)(v26 + 4 * v22);
            *v27 = 0;
            if (v19 == v21)
            {
              v29 = v26 + 4 * v22;
            }
            else
            {
              v28 = v19;
              v29 = v26 + 4 * v22;
              do
              {
                v30 = v28[-1].i32[3];
                v28 = (float32x4_t *)((char *)v28 - 4);
                *(_DWORD *)(v29 - 4) = v30;
                v29 -= 4;
              }
              while (v28 != v21);
            }
            v31 = (float32x4_t *)(v27 + 1);
            *(_QWORD *)a2 = v29;
            *(_QWORD *)(a2 + 8) = v27 + 1;
            v32 = *(_QWORD *)(a2 + 16);
            *(_QWORD *)(a2 + 16) = v26 + 4 * v25;
            v115 = v19;
            v116 = v32;
            v113 = v21;
            v114 = v21;
            a1 = std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&v113);
            v9 = *(_QWORD *)(v8 + 144);
            v19 = v31;
          }
          else
          {
            v19->i32[0] = 0;
            v19 = (float32x4_t *)((char *)v19 + 4);
          }
          *(_QWORD *)(a2 + 8) = v19;
          ++v18;
        }
        while (v18 < *(_DWORD *)(v9 + 4080));
        v16 = *(_DWORD *)(v8 + 184);
      }
      ++v17;
    }
    while (v17 < v16);
  }
  else
  {
    *(_DWORD *)(a1 + 184) = 0;
  }
  v56 = *(_DWORD *)(v9 + 4084) + v16;
  *(_DWORD *)(v9 + 4084) = v56;
  SplitMELManager::neon_replicate_and_tensor_placement_half(a1, *(float32x4_t **)a2, *(_QWORD *)(v9 + 2840), *(_DWORD *)(v9 + 4080), v56, 4);
  v57 = *(int **)(v8 + 144);
  v57[1022] = v57[1021] + 4;
  SynchroManager::cond_broadcast_on_entry((SynchroManager *)(v57 + 578), v57[577], 1);
  SynchroManager::cond_wait_less_on_exit((SynchroManager *)(*(_QWORD *)(v8 + 144) + 2312), *(_DWORD *)(*(_QWORD *)(v8 + 144) + 2308));
}

float16x8_t SplitMELManager::neon_replicate_and_tensor_placement_half(uint64_t a1, float32x4_t *a2, uint64_t a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  float32x4_t *v9;
  float16x8_t result;
  float16x8_t v11;
  float16x8_t *v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  float32x4_t *v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t *v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t *v27;
  float32x4_t *v28;
  float32x4_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t *v32;
  int v33;
  unsigned int v34;
  signed int v35;
  float32x4_t *v36;
  float16x8_t v37;
  float16x8_t *v38;

  LODWORD(v6) = a4 >> 3;
  if (a4 >= 8)
  {
    v7 = 0;
    if (v6 <= 1)
      v8 = 1;
    else
      v8 = v6;
    v9 = a2;
    do
    {
      result = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v9), v9[1]);
      v11 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v9 + 4 * a4)), *(float32x4_t *)((char *)v9 + 4 * a4 + 16));
      v12 = (float16x8_t *)(a3 + 2 * v7);
      *v12 = result;
      v12[1] = result;
      v12[2] = result;
      v12[3] = v11;
      v7 += (8 * (a6 + a5)) & 0xFFFFFFE0;
      v9 += 2;
      --v8;
    }
    while (v8);
  }
  v13 = a5 - a6;
  if ((a5 - a6) >= 4)
  {
    v14 = 0;
    if (v6 <= 1)
      v15 = 1;
    else
      v15 = v6;
    v16 = 32;
    v17 = 2 * a4;
    do
    {
      v18 = v15;
      v19 = v17;
      v20 = v16;
      if (a4 >= 8)
      {
        do
        {
          v21 = (float32x4_t *)((char *)a2 + 4 * v19);
          v22 = *v21;
          v23 = v21[1];
          v24 = (float32x4_t *)((char *)v21 + 4 * a4);
          v25 = *v24;
          v26 = v24[1];
          v27 = (float32x4_t *)((char *)v21 + 8 * a4);
          v28 = (float32x4_t *)((char *)v21 + 12 * a4);
          v29 = v28[1];
          result = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v22), v23);
          v30 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v25), v26);
          v31 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v27), v27[1]);
          *(float16x4_t *)v26.f32 = vcvt_f16_f32(*v28);
          v32 = (float16x8_t *)(a3 + 2 * v20);
          *v32 = result;
          v32[1] = v30;
          v32[2] = v31;
          v32[3] = vcvt_hight_f16_f32(*(int16x4_t *)v26.f32, v29);
          v20 += (8 * (a6 + a5)) & 0xFFFFFFE0;
          v19 += 8;
          --v18;
        }
        while (v18);
      }
      ++v14;
      v16 += 32;
      v17 += 4 * a4;
    }
    while (v14 != v13 >> 2);
  }
  if (a4 >= 8)
  {
    v33 = v13 * a4;
    v34 = (8 * (a6 + a5)) & 0xFFFFFFE0;
    v35 = v34 - 32;
    if (v6 <= 1)
      v6 = 1;
    else
      v6 = v6;
    do
    {
      v36 = (float32x4_t *)((char *)a2 + 4 * v33);
      result = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v36), v36[1]);
      v37 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*(float32x4_t *)((char *)v36 + 4 * a4)), *(float32x4_t *)((char *)v36 + 4 * a4 + 16));
      v38 = (float16x8_t *)(a3 + 2 * v35);
      *v38 = result;
      v38[1] = v37;
      v38[2] = v37;
      v38[3] = v37;
      v35 += v34;
      v33 += 8;
      --v6;
    }
    while (v6);
  }
  return result;
}

char **NeonFirstBlockMelManager::NeonFirstBlockMelManager(char **a1, char *a2, uint64_t a3, uint64_t a4, char **a5)
{
  char **v7;
  uint64_t v8;
  NeonMELContainer *v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  _QWORD v13[13];
  char v14;
  uint64_t v15;
  void *v16;
  std::locale v17;

  a1[19] = 0;
  v7 = a1 + 19;
  a1[1] = 0;
  a1[2] = 0;
  a1[14] = 0;
  a1[15] = 0;
  v8 = CustomAllocator::mRsrc;
  a1[16] = 0;
  a1[17] = (char *)v8;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = (char *)v8;
  a1[28] = 0;
  a1[29] = 0;
  a1[18] = a2;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v13);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=(v7, a5);
  NeonFirstBlockMelManager::ModelNpy((uint64_t)a1, (uint64_t)v13);
  v9 = (NeonMELContainer *)a1[18];
  *((_BYTE *)v9 + 3497) = 0;
  if (*((_BYTE *)v9 + 2304)
    && (NeonMELContainer::EngineMCSetUp(v9, a1, 1, (void (*)(void *, int))mc_FirstBlock_do_inference) & 1) == 0)
  {
    v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"WARNING: error set up multi-core engine", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
    v11 = std::locale::use_facet(&v17, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
    std::locale::~locale(&v17);
    std::ostream::put();
    std::ostream::flush();
  }
  v13[0] = &unk_24D29B388;
  v13[2] = &unk_24D29B3B0;
  v16 = &unk_24D29B3D8;
  v13[3] = &unk_24D29B578;
  if (v14 < 0)
    heap_Free(*(_QWORD **)(v15 + 8), v13[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v16);
  return a1;
}

void sub_214EA85F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  SplitMELManager *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  std::locale::~locale((std::locale *)(v5 - 56));
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v4);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v3);
  SplitMELManager::~SplitMELManager(v2);
  _Unwind_Resume(a1);
}

uint64_t NeonFirstBlockMelManager::ModelNpy(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int i;
  int v18;
  uint64_t v19;
  _WORD *v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  _QWORD *v42;
  const std::locale::facet *v43;
  _QWORD *v44;
  _QWORD *v45;
  uint64_t v46;
  _WORD *v47;
  uint64_t v48;
  __int16 *v49;
  uint64_t v50;
  __int16 v51;
  _QWORD *v52;
  const std::locale::facet *v53;
  uint64_t j;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  int v63;
  _WORD *v64;
  unint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  float16x4_t *v77;
  int v78;
  unint64_t v79;
  uint64_t v80;
  float16x4_t *v81;
  float32x4_t v82;
  __int128 v83;
  float16x8_t v84;
  float16x8_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  _QWORD *v96;
  _QWORD *v97;
  const std::locale::facet *v98;
  _QWORD *v99;
  _QWORD *v100;
  _QWORD *v101;
  uint64_t v102;
  _WORD *v103;
  uint64_t v104;
  __int16 *v105;
  uint64_t v106;
  __int16 v107;
  _QWORD *v108;
  _QWORD *v109;
  _QWORD *v110;
  _QWORD *v111;
  const std::locale::facet *v112;
  _QWORD *v113;
  _QWORD *v114;
  _QWORD *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  _WORD *v121;
  unint64_t v122;
  _WORD *v123;
  uint64_t v124;
  unint64_t v125;
  _WORD *v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  uint64_t v134;
  int v135;
  _QWORD *v136;
  _QWORD *v137;
  _QWORD *v138;
  _QWORD *v139;
  const std::locale::facet *v140;
  _QWORD *v141;
  _QWORD *v142;
  _QWORD *v143;
  uint64_t v144;
  _WORD *v145;
  uint64_t v146;
  __int16 *v147;
  uint64_t v148;
  __int16 v149;
  _QWORD *v150;
  _QWORD *v151;
  _QWORD *v152;
  _QWORD *v153;
  const std::locale::facet *v154;
  _QWORD *v155;
  _QWORD *v156;
  _QWORD *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unint64_t v162;
  _WORD *v163;
  unint64_t v164;
  _WORD *v165;
  uint64_t v166;
  unint64_t v167;
  _WORD *v168;
  int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  uint64_t v176;
  int v177;
  _QWORD *v178;
  _QWORD *v179;
  _QWORD *v180;
  _QWORD *v181;
  const std::locale::facet *v182;
  _QWORD *v183;
  _QWORD *v184;
  _QWORD *v185;
  uint64_t v186;
  _WORD *v187;
  uint64_t v188;
  __int16 *v189;
  uint64_t v190;
  __int16 v191;
  _QWORD *v192;
  _QWORD *v193;
  _QWORD *v194;
  _QWORD *v195;
  const std::locale::facet *v196;
  _QWORD *v198;
  uint64_t v199[2];
  char v200;
  uint64_t v201;
  uint64_t v202[2];
  char v203;
  uint64_t v204;
  uint64_t v205[2];
  char v206;
  uint64_t v207;
  uint64_t v208[2];
  char v209;
  uint64_t v210;
  uint64_t v211[2];
  char v212;
  uint64_t v213;
  uint64_t v214[2];
  char v215;
  uint64_t v216;
  uint64_t v217[2];
  char v218;
  uint64_t v219;
  uint64_t v220[2];
  char v221;
  uint64_t v222;
  std::locale v223;
  void *v224;
  void *v225;
  uint64_t v226;
  char v227;
  uint64_t v228;
  _QWORD v229[19];
  std::locale v230;
  void *v231;
  _QWORD v232[10];
  char v233;
  uint64_t v234;
  void *v235;
  _WORD *v236;
  _WORD *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  __int128 v248;
  uint64_t v249;

  v249 = *MEMORY[0x24BDAC8D0];
  v244 = 0;
  v245 = 0;
  v246 = 0;
  v247 = CustomAllocator::mRsrc;
  v240 = 0;
  v241 = 0;
  v242 = 0;
  v243 = CustomAllocator::mRsrc;
  v236 = 0;
  v237 = 0;
  v238 = 0;
  v239 = CustomAllocator::mRsrc;
  v198 = (_QWORD *)(a2 + 16);
  v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a2 + 16), (uint64_t)"path: ", 6);
  v4 = *(char *)(a1 + 175);
  if (v4 >= 0)
    v5 = a1 + 152;
  else
    v5 = *(_QWORD *)(a1 + 152);
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a1 + 175);
  else
    v6 = *(_QWORD *)(a1 + 160);
  v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, v5, v6);
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
  v8 = std::locale::use_facet(&v230, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v230);
  std::ostream::put();
  std::ostream::flush();
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v230);
  *(_QWORD *)(a1 + 80) = 0xC000000180;
  *(_DWORD *)(a1 + 88) = 16;
  v245 = v244;
  v237 = v236;
  v241 = v240;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
  v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v224 = &unk_24D29B3B0;
  v229[0] = &unk_24D29B3D8;
  v225 = &unk_24D29B578;
  if (v227 < 0)
    heap_Free(*(_QWORD **)(v228 + 8), v226);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v229);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
  v9 = (_QWORD *)std::ostream::operator<<();
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"/upsampler/layer/transposed/weight", 34);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"/npy", 4);
  v11 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v220);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v11 + 24))(v11, v220, &v244, &v236, 1);
  if (v221 < 0)
    heap_Free(*(_QWORD **)(v222 + 8), v220[0]);
  if (v237 == v236)
  {
    v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: upsampler_layer_transposed_weight", 40);
    std::ios_base::getloc((const std::ios_base *)((char *)v42 + *(_QWORD *)(*v42 - 24)));
    v43 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
    std::locale::~locale(&v223);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v12 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 80) * *(_DWORD *)(a1 + 88));
    v13 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 80) * *(_DWORD *)(a1 + 88));
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2872) = v13;
    v14 = *(_DWORD *)(a1 + 80);
    v15 = *(_DWORD *)(a1 + 84);
    if (v14 >= 1)
    {
      v16 = 0;
      for (i = 0; i != v14; ++i)
      {
        if (v15 >= 1)
        {
          v18 = 0;
          v19 = *(unsigned int *)(a1 + 88);
          v20 = v236;
          v21 = v237 - v236;
          v22 = v19 * v16;
          do
          {
            if ((int)v19 >= 1)
            {
              v23 = v19;
              v24 = v22;
              do
              {
                if (v21 <= v24)
                  std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
                *(_WORD *)(v12 + 2 * v24) = v20[v24];
                ++v24;
                --v23;
              }
              while (v23);
            }
            ++v18;
            v22 += v19;
          }
          while (v18 != v15);
        }
        v16 += v15;
      }
    }
    if (v15 >= 0)
      v25 = v15;
    else
      v25 = v15 + 7;
    if (v15 >= 8)
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = v25 >> 3;
      v30 = *(_DWORD *)(a1 + 88);
      v31 = v15 * v30;
      do
      {
        if (v30 >= 1)
        {
          v32 = 0;
          v33 = v26;
          do
          {
            if (v14 >= 4)
            {
              v34 = 0;
              v35 = v33;
              do
              {
                v36 = 0;
                v37 = v35;
                do
                {
                  v38 = 0;
                  v39 = v27;
                  v40 = v13 + 2 * v27;
                  v41 = v37;
                  do
                  {
                    *(_WORD *)(v40 + 2 * v38++) = *(_WORD *)(v12 + 2 * v41);
                    v41 += v30;
                  }
                  while (v38 != 8);
                  v27 = v39 + 8;
                  ++v36;
                  v37 += v31;
                }
                while (v36 != 4);
                ++v34;
                v35 += 4 * v31;
                v27 = v39 + 8;
              }
              while (v34 != v14 / 4);
              v27 = v39 + 8;
            }
            ++v32;
            ++v33;
          }
          while (v32 != v30);
        }
        ++v28;
        v26 += 8 * v30;
      }
      while (v28 != v29);
    }
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v12);
  }
  v245 = v244;
  v237 = v236;
  v241 = v240;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
  v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v229[0] = &unk_24D29B3D8;
  v224 = &unk_24D29B3B0;
  v225 = &unk_24D29B578;
  if (v227 < 0)
    heap_Free(*(_QWORD **)(v228 + 8), v226);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v229);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
  v44 = (_QWORD *)std::ostream::operator<<();
  v45 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)"/upsampler/layer/transposed/bias", 32);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"/npy", 4);
  v46 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v217);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v46 + 24))(v46, v217, &v244, &v236, 1);
  if (v218 < 0)
    heap_Free(*(_QWORD **)(v219 + 8), v217[0]);
  if (v237 == v236)
  {
    v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: upsampler_layer_transposed_bias", 38);
    std::ios_base::getloc((const std::ios_base *)((char *)v52 + *(_QWORD *)(*v52 - 24)));
    v53 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v53->__vftable[2].~facet_0)(v53, 10);
    std::locale::~locale(&v223);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v47 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2880) = v47;
    v48 = *(unsigned int *)(a1 + 84);
    if ((int)v48 >= 1)
    {
      v49 = v236;
      v50 = v237 - v236;
      while (v50)
      {
        v51 = *v49++;
        *v47++ = v51;
        --v50;
        if (!--v48)
          goto LABEL_52;
      }
LABEL_158:
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    }
  }
LABEL_52:
  for (j = 0; j != 4; ++j)
  {
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v55 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v55, (uint64_t)"/block/", 7);
    v56 = (_QWORD *)std::ostream::operator<<();
    v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v56, (uint64_t)"/first/conv1d/weight", 20);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"/npy", 4);
    v58 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v214);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v58 + 24))(v58, v214, &v244, &v236, 1);
    if (v215 < 0)
      heap_Free(*(_QWORD **)(v216 + 8), v214[0]);
    if (v237 == v236)
    {
      v94 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v94, (uint64_t)"[", 1);
      v95 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v95, (uint64_t)"][", 2);
      v96 = (_QWORD *)std::ostream::operator<<();
      v97 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v96, (uint64_t)"] first_conv1d_weight", 21);
      std::ios_base::getloc((const std::ios_base *)((char *)v97 + *(_QWORD *)(*v97 - 24)));
      v98 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v98->__vftable[2].~facet_0)(v98, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v59 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (6 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      v60 = 0;
      v61 = 0;
      v62 = *(unsigned int *)(a1 + 84);
      do
      {
        if ((int)v62 >= 1)
        {
          v63 = 0;
          v64 = v236;
          v65 = v237 - v236;
          v66 = v61;
          v67 = v60;
          do
          {
            v68 = 0;
            v69 = v66;
            do
            {
              if (v65 <= v69)
                std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
              *(_WORD *)(v59 + 2 * (v67 + (int)v68++)) = v64[v69];
              v69 += 3 * v62;
            }
            while (v62 != v68);
            ++v63;
            v67 += v62;
            v66 += 3;
          }
          while (v63 != (_DWORD)v62);
        }
        ++v61;
        v60 += v62 * v62;
      }
      while (v61 != 3);
      v70 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (8 * v62 * v62));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 2888) = v70;
      v71 = *(unsigned int *)(a1 + 84);
      if ((int)v71 >= 8)
      {
        v72 = 0;
        v73 = 0;
        v74 = (v71 * v71);
        v75 = 2 * v74;
        v76 = v74 << 33;
        v77 = (float16x4_t *)v59;
        do
        {
          v78 = 0;
          v79 = v71;
          v80 = v76;
          v81 = v77;
          v82.i64[0] = 0x3F0000003F000000;
          v82.i64[1] = 0x3F0000003F000000;
          do
          {
            v83 = *(_OWORD *)(v59 + (v80 >> 31));
            v84 = *(float16x8_t *)(v59 + 2 * ((int)v74 + v78));
            v85 = *(float16x8_t *)(v59 + 2 * (v75 + v78));
            v86 = vcvtq_f32_f16(*v81);
            v87 = vcvt_hight_f32_f16(*(float16x8_t *)v81->i8);
            v88 = vcvtq_f32_f16(*(float16x4_t *)v84.i8);
            v89 = vcvt_hight_f32_f16(v84);
            v90 = vcvt_hight_f32_f16(v85);
            v91 = vcvtq_f32_f16(*(float16x4_t *)v85.i8);
            *(_OWORD *)(v70 + 2 * (int)v73) = *(_OWORD *)v81->i8;
            *(float16x8_t *)(v70 + (((v73 << 32) + 0x800000000) >> 31)) = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_f32(vaddq_f32(vaddq_f32(v86, v88), v91), v82)), vmulq_f32(vaddq_f32(vaddq_f32(v87, v89), v90), v82));
            v92 = ((v73 << 32) + 0x1000000000) >> 31;
            v93 = (v73 << 32) + 0x1800000000;
            *(float16x8_t *)(v70 + v92) = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_f32(vaddq_f32(vsubq_f32(v86, v88), v91), v82)), vmulq_f32(vaddq_f32(vsubq_f32(v87, v89), v90), v82));
            *(_OWORD *)(v70 + (v93 >> 31)) = v83;
            v73 = (v93 >> 32) + 8;
            v248 = v83;
            v81 = (float16x4_t *)((char *)v81 + 2 * v71);
            v78 += v71;
            v80 += v71 << 32;
            --v79;
          }
          while (v79);
          ++v72;
          v77 += 2;
          v75 += 8;
          LODWORD(v74) = v74 + 8;
          v76 += 0x800000000;
        }
        while (v72 != v71 >> 3);
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v59);
    }
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v99 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v99, (uint64_t)"/block/", 7);
    v100 = (_QWORD *)std::ostream::operator<<();
    v101 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v100, (uint64_t)"/first/conv1d/bias", 18);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v101, (uint64_t)"/npy", 4);
    v102 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v211);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v102 + 24))(v102, v211, &v244, &v236, 1);
    if (v212 < 0)
      heap_Free(*(_QWORD **)(v213 + 8), v211[0]);
    if (v237 == v236)
    {
      v108 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v108, (uint64_t)"[", 1);
      v109 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v109, (uint64_t)"][", 2);
      v110 = (_QWORD *)std::ostream::operator<<();
      v111 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v110, (uint64_t)"] first_conv1d_bias", 19);
      std::ios_base::getloc((const std::ios_base *)((char *)v111 + *(_QWORD *)(*v111 - 24)));
      v112 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v112->__vftable[2].~facet_0)(v112, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v103 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 2896) = v103;
      v104 = *(unsigned int *)(a1 + 84);
      if ((int)v104 >= 1)
      {
        v105 = v236;
        v106 = v237 - v236;
        while (v106)
        {
          v107 = *v105++;
          *v103++ = v107;
          --v106;
          if (!--v104)
            goto LABEL_84;
        }
        goto LABEL_158;
      }
    }
LABEL_84:
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v113 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v113, (uint64_t)"/block/", 7);
    v114 = (_QWORD *)std::ostream::operator<<();
    v115 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v114, (uint64_t)"/second/conv1d/weight", 21);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v115, (uint64_t)"/npy", 4);
    v116 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v208);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v116 + 24))(v116, v208, &v244, &v236, 1);
    if (v209 < 0)
      heap_Free(*(_QWORD **)(v210 + 8), v208[0]);
    if (v237 == v236)
    {
      v136 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v136, (uint64_t)"[", 1);
      v137 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v137, (uint64_t)"][", 2);
      v138 = (_QWORD *)std::ostream::operator<<();
      v139 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v138, (uint64_t)"] second_conv1d_weight", 22);
      std::ios_base::getloc((const std::ios_base *)((char *)v139 + *(_QWORD *)(*v139 - 24)));
      v140 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v140->__vftable[2].~facet_0)(v140, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v117 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      v118 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 2904) = v118;
      v119 = *(unsigned int *)(a1 + 84);
      if ((int)v119 >= 1)
      {
        v120 = 0;
        v121 = v236;
        v122 = v237 - v236;
        v123 = (_WORD *)v117;
        do
        {
          v124 = v119;
          v125 = v120;
          v126 = v123;
          do
          {
            if (v122 <= v125)
              std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
            *v126++ = v121[v125];
            v125 += v119;
            --v124;
          }
          while (v124);
          ++v120;
          v123 += v119;
        }
        while (v120 != v119);
        if ((int)v119 >= 8)
        {
          v127 = 0;
          v128 = 0;
          v129 = 0;
          do
          {
            v130 = 0;
            v131 = v127;
            do
            {
              v132 = 0;
              v133 = v131;
              do
              {
                v134 = 0;
                v135 = v129;
                do
                {
                  *(_WORD *)(v118 + 2 * v129 + 2 * v134) = *(_WORD *)(v117 + 2 * (v133 + (int)v134));
                  ++v134;
                }
                while (v134 != 8);
                ++v132;
                v133 += v119;
                v129 += 8;
              }
              while (v132 != 4);
              ++v130;
              v131 += 4 * v119;
              v129 = v135 + 8;
            }
            while (v130 != v119 >> 2);
            ++v128;
            v127 += 8;
            v129 = v135 + 8;
          }
          while (v128 != (int)v119 >> 3);
        }
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v117);
    }
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v141 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v141, (uint64_t)"/block/", 7);
    v142 = (_QWORD *)std::ostream::operator<<();
    v143 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v142, (uint64_t)"/second/conv1d/bias", 19);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v143, (uint64_t)"/npy", 4);
    v144 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v205);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v144 + 24))(v144, v205, &v244, &v236, 1);
    if (v206 < 0)
      heap_Free(*(_QWORD **)(v207 + 8), v205[0]);
    if (v237 == v236)
    {
      v150 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v150, (uint64_t)"[", 1);
      v151 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v151, (uint64_t)"][", 2);
      v152 = (_QWORD *)std::ostream::operator<<();
      v153 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v152, (uint64_t)"] second_conv1d_bias", 20);
      std::ios_base::getloc((const std::ios_base *)((char *)v153 + *(_QWORD *)(*v153 - 24)));
      v154 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v154->__vftable[2].~facet_0)(v154, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v145 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 2912) = v145;
      v146 = *(unsigned int *)(a1 + 84);
      if ((int)v146 >= 1)
      {
        v147 = v236;
        v148 = v237 - v236;
        while (v148)
        {
          v149 = *v147++;
          *v145++ = v149;
          --v148;
          if (!--v146)
            goto LABEL_117;
        }
        goto LABEL_158;
      }
    }
LABEL_117:
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v155 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v155, (uint64_t)"/shortcut/", 10);
    v156 = (_QWORD *)std::ostream::operator<<();
    v157 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v156, (uint64_t)"/conv1d/weight", 14);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v157, (uint64_t)"/npy", 4);
    v158 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v202);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v158 + 24))(v158, v202, &v244, &v236, 1);
    if (v203 < 0)
      heap_Free(*(_QWORD **)(v204 + 8), v202[0]);
    if (v237 == v236)
    {
      v178 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v178, (uint64_t)"[", 1);
      v179 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v179, (uint64_t)"][", 2);
      v180 = (_QWORD *)std::ostream::operator<<();
      v181 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v180, (uint64_t)"] shortcut conv1d_weight", 24);
      std::ios_base::getloc((const std::ios_base *)((char *)v181 + *(_QWORD *)(*v181 - 24)));
      v182 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v182->__vftable[2].~facet_0)(v182, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v159 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      v160 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 16 * j + 3016) = v160;
      v161 = *(unsigned int *)(a1 + 84);
      if ((int)v161 >= 1)
      {
        v162 = 0;
        v163 = v236;
        v164 = v237 - v236;
        v165 = (_WORD *)v159;
        do
        {
          v166 = v161;
          v167 = v162;
          v168 = v165;
          do
          {
            if (v164 <= v167)
              std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
            *v168++ = v163[v167];
            v167 += v161;
            --v166;
          }
          while (v166);
          ++v162;
          v165 += v161;
        }
        while (v162 != v161);
        if ((int)v161 >= 8)
        {
          v169 = 0;
          v170 = 0;
          v171 = 0;
          do
          {
            v172 = 0;
            v173 = v169;
            do
            {
              v174 = 0;
              v175 = v173;
              do
              {
                v176 = 0;
                v177 = v171;
                do
                {
                  *(_WORD *)(v160 + 2 * v171 + 2 * v176) = *(_WORD *)(v159 + 2 * (v175 + (int)v176));
                  ++v176;
                }
                while (v176 != 8);
                ++v174;
                v175 += v161;
                v171 += 8;
              }
              while (v174 != 4);
              ++v172;
              v173 += 4 * v161;
              v171 = v177 + 8;
            }
            while (v172 != v161 >> 2);
            ++v170;
            v169 += 8;
            v171 = v177 + 8;
          }
          while (v170 != (int)v161 >> 3);
        }
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v159);
    }
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v183 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v183, (uint64_t)"/shortcut/", 10);
    v184 = (_QWORD *)std::ostream::operator<<();
    v185 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v184, (uint64_t)"/conv1d/bias", 12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v185, (uint64_t)"/npy", 4);
    v186 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v199);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v186 + 24))(v186, v199, &v244, &v236, 1);
    if (v200 < 0)
      heap_Free(*(_QWORD **)(v201 + 8), v199[0]);
    if (v237 == v236)
    {
      v192 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v192, (uint64_t)"[", 1);
      v193 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v193, (uint64_t)"][", 2);
      v194 = (_QWORD *)std::ostream::operator<<();
      v195 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v194, (uint64_t)"] shortcut conv1d_bias", 22);
      std::ios_base::getloc((const std::ios_base *)((char *)v195 + *(_QWORD *)(*v195 - 24)));
      v196 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v196->__vftable[2].~facet_0)(v196, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v187 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 16 * j + 3024) = v187;
      v188 = *(unsigned int *)(a1 + 84);
      if ((int)v188 >= 1)
      {
        v189 = v236;
        v190 = v237 - v236;
        while (v190)
        {
          v191 = *v189++;
          *v187++ = v191;
          --v190;
          if (!--v188)
            goto LABEL_150;
        }
        goto LABEL_158;
      }
    }
LABEL_150:
    ;
  }
  v230.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v231 = &unk_24D29B3B0;
  v235 = &unk_24D29B3D8;
  v232[0] = &unk_24D29B578;
  if (v233 < 0)
    heap_Free(*(_QWORD **)(v234 + 8), v232[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v235);
  v230.__locale_ = (std::locale::__imp *)&v236;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v230);
  v230.__locale_ = (std::locale::__imp *)&v240;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v230);
  v230.__locale_ = (std::locale::__imp *)&v244;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v230);
  return 1;
}

void sub_214EA9EF0(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t *mc_FirstBlock_do_inference(char *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float16x8_t v7;
  float16x8_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  long double v13;
  uint64_t v14;
  int conv_input_shift_by_rows;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t *result;
  int v31;
  uint64_t v32;
  _DWORD *v33;
  int v34;
  uint64_t *v35;
  _QWORD *v36;
  unint64_t v37;
  uint64_t *v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t *v54;
  _QWORD *v55;
  _QWORD *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  _QWORD *v69;
  unint64_t v70;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  _QWORD *v85;
  _QWORD *v86;
  _QWORD *v87;
  uint64_t v88;
  _QWORD *v89;

  v4 = *((_QWORD *)a1 + 18);
  SplitMELManager::neon_transpose_rows((uint64_t)a1, *(_QWORD *)(v4 + 2872), *(float16x8_t **)(v4 + 2776), *(_QWORD *)(v4 + 2792), *((_DWORD *)a1 + 20), *((_DWORD *)a1 + 21), *(_DWORD *)(v4 + 4088), *((_DWORD *)a1 + 46), *((_DWORD *)a1 + 22), *((_DWORD *)a1 + 23), a2, *(_DWORD *)(v4 + 2308));
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 18) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 18) + 2656));
  v6 = *((_QWORD *)a1 + 18);
  v8 = SplitMELManager::neon_transpose_rearrange_rows_0(v7, v5, *(_QWORD *)(v6 + 2792), *(_QWORD *)(v6 + 2800), *(_QWORD *)(v6 + 2880), *((_DWORD *)a1 + 21), *(_DWORD *)(v6 + 4088), *((_DWORD *)a1 + 46), *((_DWORD *)a1 + 23), a2, *(_DWORD *)(v6 + 2308));
  v9 = (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(*((_QWORD *)a1 + 18) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 18) + 2656), (__n128)v8);
  SplitMELManager::neon_block_input(v9, *(_QWORD *)(*((_QWORD *)a1 + 18) + 2800), *(_QWORD *)(*((_QWORD *)a1 + 18) + 2816), *(_QWORD *)(*((_QWORD *)a1 + 18) + 2808), *((_DWORD *)a1 + 46), *((_DWORD *)a1 + 21), a2, *(_DWORD *)(*((_QWORD *)a1 + 18) + 2308));
  (*(void (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 18) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 18)
                                                                                                  + 2656));
  v10 = 0;
  v11 = 2888;
  v12 = 3016;
  do
  {
    v13 = pow(3.0, (double)v10);
    *((_DWORD *)a1 + 26) = (int)v13;
    *((_DWORD *)a1 + 27) = (int)v13;
    conv_input_shift_by_rows = SplitMELManager::neon_first_conv_input_shift_by_rows((uint64_t)a1, *(_QWORD *)(*((_QWORD *)a1 + 18) + 2808), *(_QWORD *)(*((_QWORD *)a1 + 18) + 2784), *((_DWORD *)a1 + 46), *((_DWORD *)a1 + 21), v14, (int)v13, 6 * (int)v13, a2, *(_DWORD *)(*((_QWORD *)a1 + 18) + 2308));
    v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 18) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 18) + 2656));
    v17 = *((_QWORD *)a1 + 18);
    SplitMELManager::neon_first_conv_cols(v16, *(_QWORD *)(v17 + v11), *(_QWORD *)(v17 + v11 + 8), *(_QWORD *)(v17 + 2784), *(_QWORD *)(v17 + 2824), v18, *((_DWORD *)a1 + 27), *((_DWORD *)a1 + 21), 4 * conv_input_shift_by_rows * *((_DWORD *)a1 + 27), a2, *(_DWORD *)(v17 + 2308));
    v19 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 18) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 18) + 2656));
    v20 = *((_QWORD *)a1 + 18);
    SplitMELManager::neon_conv_single_kernel_cols(v19, *(_QWORD *)(v20 + v11 + 16), *(_QWORD *)(v20 + v11 + 24), *(float16x4_t **)(v20 + 2824), *(_QWORD *)(v20 + 2832), *((_DWORD *)a1 + 21), *((_DWORD *)a1 + 46), a2, *(_DWORD *)(v20 + 2308));
    v21 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 18) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 18) + 2656));
    v22 = *((_QWORD *)a1 + 18);
    SplitMELManager::neon_conv_single_kernel_cols(v21, *(_QWORD *)(v22 + v12), *(_QWORD *)(v22 + v12 + 8), *(float16x4_t **)(v22 + 2816), *(_QWORD *)(v22 + 2824), *((_DWORD *)a1 + 21), *((_DWORD *)a1 + 46), a2, *(_DWORD *)(v22 + 2308));
    v23 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 18) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 18) + 2656));
    v24 = *((_QWORD *)a1 + 18);
    if (v11 == 2984)
    {
      v25 = *(_QWORD *)(v24 + 2832);
      v26 = *(_QWORD *)(v24 + 2824);
      v27 = *((_DWORD *)a1 + 46);
      v28 = *((_DWORD *)a1 + 21);
      v29 = *(_DWORD *)(v24 + 2308);
      if (*(_BYTE *)(v24 + 3498))
        SplitMELManager::neon_add_signals_loop_relu(v23, v25, v26, *(_QWORD *)(v24 + 2776), v27, v28, a2, v29);
      else
        SplitMELManager::neon_add_signals_relu_colums(v23, v25, v26, *(_QWORD *)(v24 + 2848), v27, v28, a2, v29);
    }
    else
    {
      SplitMELManager::neon_add_signals(v23, *(_QWORD *)(v24 + 2832), *(_QWORD *)(v24 + 2824), *(_QWORD *)(v24 + 2816), *(_QWORD *)(v24 + 2808), *((_DWORD *)a1 + 46), *((_DWORD *)a1 + 21), a2, *(_DWORD *)(v24 + 2308));
    }
    result = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 18) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 18) + 2656));
    v11 += 32;
    v12 += 16;
    ++v10;
  }
  while (v11 != 3016);
  if (!a2)
  {
    v31 = *((_DWORD *)a1 + 46);
    v32 = *((_QWORD *)a1 + 18);
    *(_DWORD *)(v32 + 4088) = v31;
    if (*(_BYTE *)(v32 + 3498))
    {
      if (*(_BYTE *)(v32 + 3496))
        return result;
      *(_DWORD *)(v32 + 4092) = *((_DWORD *)a1 + 47);
      v33 = a1 + 188;
      goto LABEL_64;
    }
    v33 = a1 + 188;
    v34 = v31 - 8 * *((_DWORD *)a1 + 47);
    *(_DWORD *)(v32 + 4088) = v34;
    v35 = (uint64_t *)*((_QWORD *)a1 + 27);
    v36 = (_QWORD *)v35[1];
    v37 = v35[2];
    if ((unint64_t)v36 >= v37)
    {
      v40 = (_QWORD *)*v35;
      v41 = ((uint64_t)v36 - *v35) >> 3;
      v42 = v41 + 1;
      if ((unint64_t)(v41 + 1) >> 61)
        goto LABEL_66;
      v43 = v37 - (_QWORD)v40;
      if (v43 >> 2 > v42)
        v42 = v43 >> 2;
      if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8)
        v44 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v44 = v42;
      v89 = v35 + 3;
      if (v44)
      {
        v45 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v35 + 3), v44);
        v40 = (_QWORD *)*v35;
        v36 = (_QWORD *)v35[1];
      }
      else
      {
        v45 = 0;
      }
      v46 = (_QWORD *)(v45 + 8 * v41);
      *v46 = 1;
      if (v36 == v40)
      {
        v48 = v45 + 8 * v41;
      }
      else
      {
        v47 = v36;
        v48 = v45 + 8 * v41;
        do
        {
          v49 = *--v47;
          *(_QWORD *)(v48 - 8) = v49;
          v48 -= 8;
        }
        while (v47 != v40);
      }
      v39 = v46 + 1;
      *v35 = v48;
      v85 = v40;
      v86 = v40;
      v35[1] = (uint64_t)(v46 + 1);
      v87 = v36;
      v50 = v35[2];
      v35[2] = v45 + 8 * v44;
      v88 = v50;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v85);
      v38 = (uint64_t *)*((_QWORD *)a1 + 27);
      v34 = *(_DWORD *)(*((_QWORD *)a1 + 18) + 4088);
    }
    else
    {
      *v36 = 1;
      v38 = v35;
      v39 = v36 + 1;
    }
    v35[1] = (uint64_t)v39;
    v51 = v34;
    v52 = (_QWORD *)v38[1];
    v53 = v38[2];
    if ((unint64_t)v52 >= v53)
    {
      v56 = (_QWORD *)*v38;
      v57 = ((uint64_t)v52 - *v38) >> 3;
      v58 = v57 + 1;
      if ((unint64_t)(v57 + 1) >> 61)
        std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
      v59 = v53 - (_QWORD)v56;
      if (v59 >> 2 > v58)
        v58 = v59 >> 2;
      if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8)
        v60 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v60 = v58;
      v89 = v38 + 3;
      if (v60)
      {
        v61 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v38 + 3), v60);
        v56 = (_QWORD *)*v38;
        v52 = (_QWORD *)v38[1];
      }
      else
      {
        v61 = 0;
      }
      v62 = (_QWORD *)(v61 + 8 * v57);
      *v62 = v51;
      if (v52 == v56)
      {
        v64 = v61 + 8 * v57;
      }
      else
      {
        v63 = v52;
        v64 = v61 + 8 * v57;
        do
        {
          v65 = *--v63;
          *(_QWORD *)(v64 - 8) = v65;
          v64 -= 8;
        }
        while (v63 != v56);
      }
      v55 = v62 + 1;
      *v38 = v64;
      v85 = v56;
      v86 = v56;
      v38[1] = (uint64_t)(v62 + 1);
      v87 = v52;
      v66 = v38[2];
      v38[2] = v61 + 8 * v60;
      v88 = v66;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v85);
      v54 = (uint64_t *)*((_QWORD *)a1 + 27);
    }
    else
    {
      *v52 = v34;
      v54 = v38;
      v55 = v52 + 1;
    }
    v38[1] = (uint64_t)v55;
    v67 = *((_DWORD *)a1 + 21);
    v68 = v67;
    v69 = (_QWORD *)v54[1];
    v70 = v54[2];
    if ((unint64_t)v69 < v70)
    {
      *v69 = v67;
      v71 = v69 + 1;
LABEL_63:
      v54[1] = (uint64_t)v71;
      v83 = *((_QWORD *)a1 + 18);
      v84 = *(int *)(v83 + 4088) * (uint64_t)v67;
      result = std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(*((uint64_t **)a1 + 26), *(char **)(v83 + 2848), *(_QWORD *)(v83 + 2848) + 4 * v84, v84);
LABEL_64:
      *v33 = 0;
      return result;
    }
    v72 = (_QWORD *)*v54;
    v73 = ((uint64_t)v69 - *v54) >> 3;
    v74 = v73 + 1;
    if (!((unint64_t)(v73 + 1) >> 61))
    {
      v75 = v70 - (_QWORD)v72;
      if (v75 >> 2 > v74)
        v74 = v75 >> 2;
      if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8)
        v76 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v76 = v74;
      v89 = v54 + 3;
      if (v76)
      {
        v77 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v54 + 3), v76);
        v72 = (_QWORD *)*v54;
        v69 = (_QWORD *)v54[1];
      }
      else
      {
        v77 = 0;
      }
      v78 = (_QWORD *)(v77 + 8 * v73);
      *v78 = v68;
      if (v69 == v72)
      {
        v80 = v77 + 8 * v73;
      }
      else
      {
        v79 = v69;
        v80 = v77 + 8 * v73;
        do
        {
          v81 = *--v79;
          *(_QWORD *)(v80 - 8) = v81;
          v80 -= 8;
        }
        while (v79 != v72);
      }
      v71 = v78 + 1;
      *v54 = v80;
      v85 = v72;
      v86 = v72;
      v54[1] = (uint64_t)(v78 + 1);
      v87 = v69;
      v82 = v54[2];
      v54[2] = v77 + 8 * v76;
      v88 = v82;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v85);
      v67 = *((_DWORD *)a1 + 21);
      goto LABEL_63;
    }
LABEL_66:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  }
  return result;
}

_QWORD *NeonFirstBlockMelManager::NeonFirstBlockMelManager(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  uint64_t v5;
  NeonMELContainer *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  std::locale v10;

  a1[19] = 0;
  v4 = a1 + 19;
  a1[1] = 0;
  a1[2] = 0;
  a1[14] = 0;
  a1[15] = 0;
  v5 = CustomAllocator::mRsrc;
  a1[16] = 0;
  a1[17] = v5;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = v5;
  a1[28] = 0;
  a1[29] = 0;
  a1[18] = a2;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 28, a3);
  v6 = (NeonMELContainer *)*(v4 - 1);
  *((_BYTE *)v6 + 3497) = 0;
  if (*((_BYTE *)v6 + 2304)
    && (NeonMELContainer::EngineMCSetUp(v6, a1, 1, (void (*)(void *, int))mc_FirstBlock_do_inference) & 1) == 0)
  {
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"WARNING: error set up multi-core engine", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v10, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v10);
    std::ostream::put();
    std::ostream::flush();
  }
  return a1;
}

void sub_214EAA7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  SplitMELManager *v10;
  uint64_t v11;
  uint64_t v12;

  std::locale::~locale(&a10);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v12);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v11);
  SplitMELManager::~SplitMELManager(v10);
  _Unwind_Resume(a1);
}

void NeonFirstBlockMelManager::~NeonFirstBlockMelManager(NeonFirstBlockMelManager *this)
{
  char *v2;
  uint64_t v3;
  uint64_t i;

  v2 = (char *)this + 224;
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 2872));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 2880));
  v3 = 2888;
  for (i = 3016; i != 3080; i += 16)
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3 + 8));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3 + 16));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3 + 24));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + i));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + i + 8));
    v3 += 32;
  }
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  if (*((char *)this + 175) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 22) + 8), *((_QWORD *)this + 19));
  if (*((char *)this + 135) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 17) + 8), *((_QWORD *)this + 14));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

void SplitMELManager::neon_transpose_rows(uint64_t a1, uint64_t a2, float16x8_t *a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, int a8, int a9, int a10, int a11, unsigned int a12)
{
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  float16x8_t *v16;
  uint64_t v17;
  float16x8_t *v18;
  uint64_t i;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  uint64_t v24;
  uint64_t v25;
  float16x8_t *v26;
  uint64_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t *v43;

  v12 = (a6 >> 3) / a12 * a11;
  v13 = v12 + (a6 >> 3) / a12;
  if (v12 < v13)
  {
    LODWORD(v14) = a5 >> 3;
    LODWORD(v15) = a7 >> 2;
    if (a5 >> 3 <= 1)
      v14 = 1;
    else
      v14 = v14;
    if (v15 <= 1)
      v15 = 1;
    else
      v15 = v15;
    v16 = a3 + 2;
    do
    {
      if (a7 >= 4)
      {
        v17 = 0;
        v18 = v16;
        do
        {
          if (a9)
          {
            for (i = 0; i != a9; ++i)
            {
              v20 = 0uLL;
              v21 = 0uLL;
              v22 = 0uLL;
              v23 = 0uLL;
              if (a5 >= 8)
              {
                v24 = 0;
                v25 = v14;
                v26 = v18;
                do
                {
                  v27 = a2
                      + 2 * (int)(((8 * a5) & 0xFFFFFFE0) * a9 * v12)
                      + 2 * i * (int)((8 * a5) & 0xFFFFFFE0)
                      + (v24 << 7);
                  v28 = *(float16x8_t *)(v27 + 16);
                  v29 = *(float16x8_t *)(v27 + 32);
                  v30 = *(float16x8_t *)(v27 + 48);
                  v32 = v26[-2];
                  v31 = v26[-1];
                  v34 = *v26;
                  v33 = v26[1];
                  v26 += 4;
                  v35 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v23, *(float16x8_t *)v27, *(short float *)v32.i16), v28, *(float16x4_t *)v32.i8, 1), v29, *(float16x4_t *)v32.i8, 2), v30, *(float16x4_t *)v32.i8, 3);
                  v36 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v22, *(float16x8_t *)v27, *(short float *)v31.i16), v28, *(float16x4_t *)v31.i8, 1), v29, *(float16x4_t *)v31.i8, 2), v30, *(float16x4_t *)v31.i8, 3);
                  v37 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v21, *(float16x8_t *)v27, *(short float *)v34.i16), v28, *(float16x4_t *)v34.i8, 1), v29, *(float16x4_t *)v34.i8, 2), v30, *(float16x4_t *)v34.i8, 3);
                  v38 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v20, *(float16x8_t *)v27, *(short float *)v33.i16), v28, *(float16x4_t *)v33.i8, 1), v29, *(float16x4_t *)v33.i8, 2), v30, *(float16x4_t *)v33.i8, 3);
                  v39 = *(float16x8_t *)(v27 + 64);
                  v40 = *(float16x8_t *)(v27 + 80);
                  v41 = *(float16x8_t *)(v27 + 96);
                  v42 = *(float16x8_t *)(v27 + 112);
                  v23 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v35, v39, v32, 4), v40, v32, 5), v41, v32, 6), v42, v32, 7);
                  v22 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v36, v39, v31, 4), v40, v31, 5), v41, v31, 6), v42, v31, 7);
                  v21 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v37, v39, v34, 4), v40, v34, 5), v41, v34, 6), v42, v34, 7);
                  v20 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v38, v39, v33, 4), v40, v33, 5), v41, v33, 6), v42, v33, 7);
                  ++v24;
                  --v25;
                }
                while (v25);
              }
              v43 = (float16x8_t *)(a4
                                  + 2
                                  * (int)(((16 * a8) & 0xFFFFFFC0) * v12 + (a10 << 6) * v17 + ((32 * i) & 0x7FFFFF80))
                                  + 16 * (i & 3));
              *v43 = v23;
              v43[4] = v22;
              v43[8] = v21;
              v43[12] = v20;
            }
          }
          ++v17;
          v18 = (float16x8_t *)((char *)v18 + 2 * (int)(32 * (a5 >> 3)));
        }
        while (v17 != v15);
      }
      ++v12;
    }
    while (v13 > v12);
  }
}

float16x8_t SplitMELManager::neon_transpose_rearrange_rows_0(float16x8_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9, int a10, unsigned int a11)
{
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  float16x8_t v20;
  int v21;
  float16x8_t *v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  float16x8_t v26;
  int v27;
  float16x8_t *v28;
  float16x8_t *v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t *v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t *v38;
  float16x8_t *v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t *v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t *v48;
  float16x8_t *v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t *v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t v57;
  float16x8_t *v58;
  float16x8_t *v59;
  float16x8_t v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t v63;
  float16x8_t *v64;
  float16x8_t v65;
  float16x8_t v66;
  float16x8_t v67;
  float16x8_t *v68;
  float16x8_t *v69;
  float16x8_t v70;
  float16x8_t v71;
  float16x8_t v72;
  float16x8_t v73;
  float16x8_t *v74;
  float16x8_t v75;
  float16x8_t v76;
  float16x8_t v77;
  float16x8_t *v78;
  float16x8_t *v79;
  float16x8_t v80;
  float16x8_t v81;
  float16x8_t v82;
  float16x8_t v83;
  float16x8_t *v84;
  float16x8_t v85;
  float16x8_t v86;
  float16x8_t v87;
  float16x8_t *v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  float16x8_t *v92;
  float16x8_t v93;
  float16x8_t v94;
  float16x8_t *v95;
  float16x8_t v96;
  float16x8_t v97;
  float16x8_t v98;
  float16x8_t *v99;
  float16x8_t v100;
  float16x8_t *v101;
  float16x8_t *v102;
  float16x8_t v103;
  float16x8_t v104;
  float16x8_t v105;
  float16x8_t v106;
  float16x8_t *v107;
  float16x8_t v108;
  float16x8_t v109;
  float16x8_t *v110;
  float16x8_t v111;
  float16x8_t *v112;
  float16x8_t *v113;
  float16x8_t v114;
  float16x8_t v115;
  float16x8_t v116;
  float16x8_t v117;
  float16x8_t *v118;
  float16x8_t v119;
  float16x8_t v120;
  float16x8_t *v121;
  float16x8_t v122;
  float16x8_t *v123;
  float16x8_t *v124;
  float16x8_t v125;
  float16x8_t v126;
  float16x8_t v127;
  float16x8_t v128;
  float16x8_t *v129;
  float16x8_t v130;
  float16x8_t v131;
  float16x8_t *v132;
  float16x8_t v133;
  float16x8_t *v134;
  float16x8_t v135;
  float16x8_t v136;
  float16x8_t v137;
  float16x8_t v138;
  float16x8_t *v139;
  float16x8_t v140;
  uint64_t v141;

  v11 = (a6 >> 3) / a11 * a10;
  v12 = v11 + (a6 >> 3) / a11;
  if (v11 < v12)
  {
    v13 = a8 >> 2 << 6;
    v14 = 32 * (a8 >> 2);
    LODWORD(v15) = a7 >> 2;
    v16 = a9 << 6;
    v17 = 32 * a9;
    v18 = (((a7 >> 2) * a9) << 6) - 160;
    v19 = 32 * (a7 >> 2) * a9 - 32;
    if (a7 >> 2 <= 2)
      v15 = 2;
    else
      v15 = v15;
    v141 = v15 - 1;
    do
    {
      v20 = *(float16x8_t *)(a5 + 2 * (int)(8 * v11));
      v21 = v13 * v11;
      v22 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 128));
      v23 = *v22;
      v24 = v22[1];
      v25 = v22[2];
      v26 = v22[3];
      v27 = v14 * v11;
      v28 = (float16x8_t *)(a4 + 2 * (int)(v14 * v11));
      *v28 = vaddq_f16(v20, v23);
      v28[1] = vaddq_f16(v20, v24);
      v28[2] = vaddq_f16(v20, v25);
      v28[3] = vaddq_f16(v20, v26);
      v29 = (float16x8_t *)(a3 + 2 * (int)((v13 * v11) | 0x20));
      v30 = *v29;
      v31 = v29[1];
      v32 = v29[2];
      v33 = v29[3];
      v34 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 256));
      v35 = vaddq_f16(v31, v34[1]);
      v36 = vaddq_f16(v32, v34[2]);
      v37 = vaddq_f16(v33, v34[3]);
      v38 = (float16x8_t *)(a4 + 2 * (int)(v14 * v11 + 32));
      *v38 = vaddq_f16(v20, vaddq_f16(v30, *v34));
      v38[1] = vaddq_f16(v20, v35);
      v38[2] = vaddq_f16(v20, v36);
      v38[3] = vaddq_f16(v20, v37);
      v39 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 160));
      v40 = *v39;
      v41 = v39[1];
      v42 = v39[2];
      v43 = v39[3];
      v44 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 384));
      v45 = vaddq_f16(v41, v44[1]);
      v46 = vaddq_f16(v42, v44[2]);
      v47 = vaddq_f16(v43, v44[3]);
      v48 = (float16x8_t *)(a4 + 2 * (int)(v14 * v11 + 64));
      *v48 = vaddq_f16(v20, vaddq_f16(v40, *v44));
      v48[1] = vaddq_f16(v20, v45);
      v48[2] = vaddq_f16(v20, v46);
      v48[3] = vaddq_f16(v20, v47);
      v49 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 64));
      v50 = *v49;
      v51 = v49[1];
      v52 = v49[2];
      v53 = v49[3];
      v54 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 288));
      v55 = vaddq_f16(v51, v54[1]);
      v56 = vaddq_f16(v52, v54[2]);
      v57 = vaddq_f16(v53, v54[3]);
      v58 = (float16x8_t *)(a4 + 2 * (int)(v14 * v11 + 96));
      *v58 = vaddq_f16(v20, vaddq_f16(v50, *v54));
      v58[1] = vaddq_f16(v20, v55);
      v58[2] = vaddq_f16(v20, v56);
      v58[3] = vaddq_f16(v20, v57);
      v59 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 192));
      v60 = *v59;
      v61 = v59[1];
      v62 = v59[2];
      v63 = v59[3];
      v64 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 416));
      v65 = vaddq_f16(v61, v64[1]);
      v66 = vaddq_f16(v62, v64[2]);
      v67 = vaddq_f16(v63, v64[3]);
      v68 = (float16x8_t *)(a4 + 2 * (int)(v14 * v11 + 128));
      *v68 = vaddq_f16(v20, vaddq_f16(v60, *v64));
      v68[1] = vaddq_f16(v20, v65);
      v68[2] = vaddq_f16(v20, v66);
      v68[3] = vaddq_f16(v20, v67);
      v69 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 96));
      v70 = *v69;
      v71 = v69[1];
      v72 = v69[2];
      v73 = v69[3];
      v74 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 320));
      v75 = vaddq_f16(v71, v74[1]);
      v76 = vaddq_f16(v72, v74[2]);
      v77 = vaddq_f16(v73, v74[3]);
      v78 = (float16x8_t *)(a4 + 2 * (int)(v14 * v11 + 160));
      *v78 = vaddq_f16(v20, vaddq_f16(v70, *v74));
      v78[1] = vaddq_f16(v20, v75);
      v78[2] = vaddq_f16(v20, v76);
      v78[3] = vaddq_f16(v20, v77);
      v79 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 224));
      v80 = *v79;
      v81 = v79[1];
      v82 = v79[2];
      v83 = v79[3];
      v84 = (float16x8_t *)(a3 + 2 * (int)(v13 * v11 + 448));
      v85 = vaddq_f16(v81, v84[1]);
      v86 = vaddq_f16(v82, v84[2]);
      v87 = vaddq_f16(v83, v84[3]);
      v88 = (float16x8_t *)(a4 + 2 * (int)(v14 * v11 + 192));
      *v88 = vaddq_f16(v20, vaddq_f16(v80, *v84));
      v88[1] = vaddq_f16(v20, v85);
      v88[2] = vaddq_f16(v20, v86);
      v88[3] = vaddq_f16(v20, v87);
      if (a7 >= 8)
      {
        v89 = v141;
        v90 = 1;
        do
        {
          v91 = v21 + v16 * v90;
          v92 = (float16x8_t *)(a3 + 2 * v91);
          v93 = vaddq_f16(v92[2], v92[-18]);
          v94 = vaddq_f16(v92[3], v92[-17]);
          v95 = (float16x8_t *)(a4 + 2 * (v27 - 32 + v17 * (int)v90));
          v96 = vaddq_f16(v20, vaddq_f16(v92[1], v92[-19]));
          *v95 = vaddq_f16(v20, vaddq_f16(*v92, v92[-20]));
          v95[1] = v96;
          v95[2] = vaddq_f16(v20, v93);
          v95[3] = vaddq_f16(v20, v94);
          v97 = vaddq_f16(v92[18], v92[-2]);
          v98 = vaddq_f16(v92[19], v92[-1]);
          v99 = (float16x8_t *)(a4 + 2 * (v17 * (int)v90 + v27));
          v100 = vaddq_f16(v20, vaddq_f16(v92[17], v92[-3]));
          *v99 = vaddq_f16(v20, vaddq_f16(v92[16], v92[-4]));
          v99[1] = v100;
          v99[2] = vaddq_f16(v20, v97);
          v99[3] = vaddq_f16(v20, v98);
          v101 = (float16x8_t *)(a3 + ((2 * v91) | 0x40));
          v102 = (float16x8_t *)(a3 + 2 * (v91 + 256));
          v103 = vaddq_f16(*v101, *v102);
          v104 = vaddq_f16(v101[1], v102[1]);
          v105 = vaddq_f16(v101[2], v102[2]);
          v106 = vaddq_f16(v101[3], v102[3]);
          v107 = (float16x8_t *)(a4 + 2 * (v27 + 32 + v17 * (int)v90));
          *v107 = vaddq_f16(v20, v103);
          v107[1] = vaddq_f16(v20, v104);
          v107[2] = vaddq_f16(v20, v105);
          v107[3] = vaddq_f16(v20, v106);
          v108 = vaddq_f16(v92[22], v92[50]);
          v109 = vaddq_f16(v92[23], v92[51]);
          v110 = (float16x8_t *)(a4 + 2 * (v27 + 64 + v17 * (int)v90));
          v111 = vaddq_f16(v20, vaddq_f16(v92[21], v92[49]));
          *v110 = vaddq_f16(v20, vaddq_f16(v92[20], v92[48]));
          v110[1] = v111;
          v110[2] = vaddq_f16(v20, v108);
          v110[3] = vaddq_f16(v20, v109);
          v112 = (float16x8_t *)(a3 + 2 * (v91 + 64));
          v113 = (float16x8_t *)(a3 + 2 * (v91 + 288));
          v114 = vaddq_f16(*v112, *v113);
          v115 = vaddq_f16(v112[1], v113[1]);
          v116 = vaddq_f16(v112[2], v113[2]);
          v117 = vaddq_f16(v112[3], v113[3]);
          v118 = (float16x8_t *)(a4 + 2 * (v27 + 96 + v17 * (int)v90));
          *v118 = vaddq_f16(v20, v114);
          v118[1] = vaddq_f16(v20, v115);
          v118[2] = vaddq_f16(v20, v116);
          v118[3] = vaddq_f16(v20, v117);
          v119 = vaddq_f16(v92[26], v92[54]);
          v120 = vaddq_f16(v92[27], v92[55]);
          v121 = (float16x8_t *)(a4 + 2 * (v27 + 128 + v17 * (int)v90));
          v122 = vaddq_f16(v20, vaddq_f16(v92[25], v92[53]));
          *v121 = vaddq_f16(v20, vaddq_f16(v92[24], v92[52]));
          v121[1] = v122;
          v121[2] = vaddq_f16(v20, v119);
          v121[3] = vaddq_f16(v20, v120);
          v123 = (float16x8_t *)(a3 + 2 * (v91 + 96));
          v124 = (float16x8_t *)(a3 + 2 * (v91 + 320));
          v125 = vaddq_f16(v123[1], v124[1]);
          v126 = vaddq_f16(v123[2], v124[2]);
          v127 = vaddq_f16(v123[3], v124[3]);
          v128 = vaddq_f16(v20, vaddq_f16(*v123, *v124));
          v129 = (float16x8_t *)(a4 + 2 * (v27 + 160 + v17 * (int)v90));
          *v129 = v128;
          v129[1] = vaddq_f16(v20, v125);
          v129[2] = vaddq_f16(v20, v126);
          v129[3] = vaddq_f16(v20, v127);
          v130 = vaddq_f16(v92[30], v92[58]);
          v131 = vaddq_f16(v92[31], v92[59]);
          v132 = (float16x8_t *)(a4 + 2 * (v27 + 192 + v17 * (int)v90));
          v133 = vaddq_f16(v20, vaddq_f16(v92[29], v92[57]));
          *v132 = vaddq_f16(v20, vaddq_f16(v92[28], v92[56]));
          v132[1] = v133;
          v132[2] = vaddq_f16(v20, v130);
          v132[3] = vaddq_f16(v20, v131);
          ++v90;
          --v89;
        }
        while (v89);
      }
      v134 = (float16x8_t *)(a3 + 2 * (v18 + v21));
      v135 = v134[1];
      v136 = v134[2];
      v137 = v134[3];
      v138 = vaddq_f16(v20, *v134);
      v139 = (float16x8_t *)(a4 + 2 * (v19 + v27));
      *v139 = v138;
      v139[1] = vaddq_f16(v20, v135);
      v140 = vaddq_f16(v20, v136);
      result = vaddq_f16(v20, v137);
      v139[2] = v140;
      v139[3] = result;
      ++v11;
    }
    while (v12 > v11);
  }
  return result;
}

uint64_t SplitMELManager::neon_block_input(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, unsigned int a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  __int128 *v15;
  __int128 v16;
  __int128 v17;
  uint64_t result;
  __int128 v19;
  __int128 v20;
  __int128 *v21;
  _OWORD *v22;

  v8 = (a6 >> 3) / a8 * a7;
  v9 = v8 + (a6 >> 3) / a8;
  if (v8 < v9)
  {
    v10 = a5 >> 2;
    if (a5 >> 2 <= 1)
      v11 = 1;
    else
      v11 = v10;
    do
    {
      if (a5 >= 4)
      {
        v12 = 0;
        v13 = v11;
        do
        {
          v14 = 32 * (v8 * v10 + v12);
          v15 = (__int128 *)(a2 + 2 * v14);
          v16 = *v15;
          v17 = v15[1];
          result = v8 + (a6 >> 3) * (_DWORD)v12;
          v19 = v15[2];
          v20 = v15[3];
          v21 = (__int128 *)(a4 + 2 * v14);
          *v21 = *v15;
          v21[1] = v17;
          v21[2] = v19;
          v21[3] = v20;
          v22 = (_OWORD *)(a3 + 64 * (_DWORD)result);
          *v22 = v16;
          v22[1] = v17;
          v22[2] = v19;
          v22[3] = v20;
          ++v12;
          --v13;
        }
        while (v13);
      }
      ++v8;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t SplitMELManager::neon_first_conv_input_shift_by_rows(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9, unsigned int a10)
{
  uint64_t *v11;
  int v12;
  unsigned int v13;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  float16x8_t v18;
  float16x8_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  float16x8_t *v24;
  float16x8_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  float16x8_t *v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  unsigned int v51;
  int v52;
  unsigned int v53;
  int v54;
  unsigned int v55;
  int v56;
  int v57;
  unsigned int v58;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  unsigned int v64;
  int v65;
  uint64_t v66;
  int v67;
  float16x8_t v68;
  uint64_t v69;
  int v70;
  float16x8_t v71;
  unsigned int v72;
  float16x8_t v73;
  float16x8_t v74;
  int v75;
  unsigned int v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;

  v78 = a3;
  v79 = *MEMORY[0x24BDAC8D0];
  v11 = &v60 - 2 * a8;
  v77 = a5 >> 3;
  v12 = (a5 >> 3) / a10;
  v13 = v12 * a9;
  v67 = v12 * a9 + v12;
  if (v13 >= v13 + v12)
  {
    v32 = 0;
  }
  else
  {
    v15 = a2;
    v16 = a4 >> 2;
    v75 = 2 * a7;
    v76 = a8 - 4;
    v17 = 6 * a7;
    v63 = 4 * a7 + 4;
    v64 = (8 * a4) & 0xFFFFFFE0;
    v62 = 4 * (a4 >> 2);
    v65 = 5 * a7;
    v61 = -a8;
    v18 = 0uLL;
    v19 = (float16x8_t)vdupq_n_s16(0x3266u);
    v60 = a7;
    v72 = a4 >> 2;
    v71 = v19;
    v69 = a2;
    v66 = v17;
    do
    {
      if (a7)
      {
        v20 = 0;
        v21 = 0;
        v22 = 0;
        v23 = v13 * v64;
        do
        {
          v24 = (float16x8_t *)(v15 + 2 * (v23 + 32 * (int)v22));
          v25 = *v24;
          v26 = v24[1];
          v27 = v24[2];
          v28 = v24[3];
          v29 = vmaxq_f16(*v24, v18);
          *(float16x8_t *)&v11[2 * (v20 % a8)] = v18;
          *(float16x8_t *)&v11[2 * ((v21 / a7 + 6 * (v21 % a7) + 1) % a8)] = vaddq_f16(v29, vmulq_f16(vminq_f16(v25, v18), v19));
          *(float16x8_t *)&v11[2 * (((v21 + 1) / a7 + 6 * ((v21 + 1) % a7) + 1) % a8)] = vaddq_f16(vmaxq_f16(v26, v18), vmulq_f16(vminq_f16(v26, v18), v19));
          *(float16x8_t *)&v11[2 * (((v21 + 2) / a7 + 6 * ((v21 + 2) % a7) + 1) % a8)] = vaddq_f16(vmaxq_f16(v27, v18), vmulq_f16(vminq_f16(v27, v18), v19));
          *(float16x8_t *)&v11[2 * (((v21 + 3) / a7 + 6 * ((v21 + 3) % a7) + 1) % a8)] = vaddq_f16(vmaxq_f16(v28, v18), vmulq_f16(vminq_f16(v28, v18), v19));
          ++v22;
          v21 += 4;
          v20 += 6;
        }
        while (v17 != v20);
      }
      if (v16 <= a7)
      {
        v32 = 0;
        v31 = 0;
        v30 = 0;
        v34 = 1;
        v37 = v65;
      }
      else
      {
        v30 = 0;
        v31 = 0;
        v32 = 0;
        v33 = v13 * v16;
        v34 = 1;
        v35 = v63;
        v36 = v60;
        v37 = v65;
        v70 = v13 * v16;
        do
        {
          v38 = (float16x8_t *)(v15 + 2 * (int)(32 * (v33 + v36)));
          v39 = vaddq_f16(vmaxq_f16(*v38, v18), vmulq_f16(vminq_f16(*v38, v18), v19));
          v40 = vaddq_f16(vmaxq_f16(v38[1], v18), vmulq_f16(vminq_f16(v38[1], v18), v19));
          v41 = vaddq_f16(vmaxq_f16(v38[2], v18), vmulq_f16(vminq_f16(v38[2], v18), v19));
          v42 = vaddq_f16(vmaxq_f16(v38[3], v18), vmulq_f16(vminq_f16(v38[3], v18), v19));
          v43 = v30 + v34;
          v44 = 6 * ((v35 - 4) % a7);
          v45 = (v35 - 4 - v31) / a7;
          if (v37 >= v76)
          {
            v47 = 4 * v36;
            *(float16x8_t *)&v11[2 * ((v43 + v44 + v45) % a8)] = v39;
            v48 = v37 + 1;
            v73 = v41;
            v74 = v42;
            if (v48 == a8)
            {
              v68 = v40;
              SplitMELManager::neon_write_page(a1, (uint64_t)v11, v78, v77, v32, v13, a7, v30, a8);
              v40 = v68;
              v30 = (v30 + 4) % a8;
              v49 = v35 - 3;
              v32 += a7;
              v34 = 2;
              v31 = v35 - 3;
              v48 = v75;
            }
            else
            {
              v49 = v47 | 1;
            }
            *(float16x8_t *)&v11[2 * ((v30 + v34 + 6 * (v49 % a7) + (v49 - v31) / a7) % a8)] = v40;
            v50 = v48 + 1;
            if (v50 == a8)
            {
              SplitMELManager::neon_write_page(a1, (uint64_t)v11, v78, v77, v32, v13, a7, v30, a8);
              v30 = (v30 + 4) % a8;
              v51 = v35 - 2;
              v32 += a7;
              v34 = 2;
              v31 = v35 - 2;
              v50 = v75;
            }
            else
            {
              v51 = v47 | 2;
            }
            *(float16x8_t *)&v11[2 * ((v30 + v34 + 6 * (v51 % a7) + (v51 - v31) / a7) % a8)] = v73;
            v52 = v50 + 1;
            if (v52 == a8)
            {
              SplitMELManager::neon_write_page(a1, (uint64_t)v11, v78, v77, v32, v13, a7, v30, a8);
              v30 = (v30 + 4) % a8;
              v53 = v35 - 1;
              v32 += a7;
              v34 = 2;
              v31 = v35 - 1;
              v52 = v75;
            }
            else
            {
              v53 = v47 | 3;
            }
            v15 = v69;
            *(float16x8_t *)&v11[2 * ((v30 + v34 + 6 * (v53 % a7) + (v53 - v31) / a7) % a8)] = v74;
            v37 = v52 + 1;
            if (v37 == a8)
            {
              SplitMELManager::neon_write_page(a1, (uint64_t)v11, v78, v77, v32, v13, a7, v30, a8);
              v30 = (v30 + 4) % a8;
              v32 += a7;
              v34 = 2;
              v31 = v35;
              v37 = v75;
            }
            v16 = v72;
            v18 = 0uLL;
            v19 = v71;
            v33 = v70;
          }
          else
          {
            *(float16x8_t *)&v11[2 * ((v44 + v43 + v45) % a8)] = v39;
            v46 = v35 - v31;
            *(float16x8_t *)&v11[2 * ((v43 + 6 * ((v35 - 3) % a7) + (v46 - 3) / a7) % a8)] = v40;
            *(float16x8_t *)&v11[2 * ((v43 + 6 * ((v35 - 2) % a7) + (v46 - 2) / a7) % a8)] = v41;
            *(float16x8_t *)&v11[2 * ((v43 + 6 * ((v35 - 1) % a7) + (v35 - v31 - 1) / a7) % a8)] = v42;
            v37 += 4;
          }
          ++v36;
          v35 += 4;
        }
        while (v16 > v36);
      }
      if (v37 >= a8)
      {
        v17 = v66;
      }
      else
      {
        v54 = 0;
        v55 = v30 + v34;
        v56 = v62;
        v57 = v62 - v31;
        v58 = v61 + v37;
        v17 = v66;
        while (1)
        {
          *(float16x8_t *)&v11[2 * ((v55 + 6 * ((v56 + v54) % a7) + (v57 + v54) / a7) % a8)] = v18;
          if (v58 + v54 == -1)
            break;
          *(float16x8_t *)&v11[2 * ((v55 + 6 * ((v56 + v54 + 1) % a7) + (v57 + v54 + 1) / a7) % a8)] = v18;
          if (v58 + v54 == -2)
            break;
          *(float16x8_t *)&v11[2 * ((v55 + 6 * ((v56 + v54 + 2) % a7) + (v57 + v54 + 2) / a7) % a8)] = v18;
          if (v58 + v54 == -3)
            break;
          *(float16x8_t *)&v11[2 * ((v55 + 6 * ((v56 + v54 + 3) % a7) + (v57 + v54 + 3) / a7) % a8)] = v18;
          if (v58 + v54 == -4)
            break;
          v54 += 4;
          if (v37 + v54 >= a8)
            goto LABEL_35;
        }
        SplitMELManager::neon_write_page(a1, (uint64_t)v11, v78, v77, v32, v13, a7, v30, a8);
        v18 = 0uLL;
        v32 += a7;
LABEL_35:
        v16 = v72;
        v19 = v71;
      }
      ++v13;
    }
    while (v13 != v67);
  }
  return v32 / a7;
}

void SplitMELManager::neon_first_conv_cols(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, unsigned int a9, int a10, unsigned int a11)
{
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  unsigned int v15;
  float16x8_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  signed int v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  uint64_t v29;
  float16x4_t *v30;
  uint64_t v31;
  uint64_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t v63;
  float16x8_t v64;
  float16x8_t v65;
  float16x8_t v66;
  float16x8_t v67;
  float16x8_t v68;
  float16x8_t v69;
  float16x8_t v70;
  float16x8_t v71;
  float16x8_t v72;
  float16x8_t v73;
  float16x8_t v74;
  float16x8_t v75;
  float16x8_t v76;
  float16x8_t v77;
  float16x8_t v78;
  float16x8_t v79;
  float16x8_t v80;
  float16x8_t v81;
  float16x8_t v82;
  float16x8_t v83;
  float16x8_t v84;
  float16x8_t v85;
  float16x8_t v86;
  float16x8_t v87;
  float16x8_t v88;
  float16x8_t v89;
  float16x8_t v90;
  float16x8_t v91;
  float16x8_t v92;
  float16x8_t v93;
  float16x8_t v94;
  float16x8_t v95;
  float16x8_t v96;
  float16x8_t v97;
  float16x8_t v98;
  float16x8_t v99;
  float16x8_t v100;
  float16x8_t v101;
  float16x8_t v102;
  float16x8_t v103;
  float16x8_t v104;
  float16x8_t v105;
  float16x8_t v106;
  float16x8_t v107;
  float16x8_t v108;
  float16x8_t v109;
  float16x8_t v110;
  float16x8_t v111;
  float16x8_t v112;
  float16x8_t v113;
  float16x8_t v114;
  float16x8_t v115;
  float16x8_t v116;
  float16x8_t v117;
  float16x8_t v118;
  float16x8_t v119;
  float16x8_t v120;
  float16x8_t v121;
  float16x8_t v122;
  float16x8_t v123;
  float16x8_t v124;
  uint64_t v125;
  float16x8_t v126;
  float16x8_t v127;
  float16x8_t v128;
  float16x8_t v129;

  if (a9 >= 4)
  {
    v11 = 0;
    v12 = 0;
    v13 = 32 * (a8 >> 3);
    v14 = (a8 >> 3) / a11;
    v15 = v14 * a10;
    v16 = (float16x8_t)vdupq_n_s16(0x3266u);
    v17 = v14 * a10 + v14;
    if (a8 >> 3 <= 1)
      v18 = 1;
    else
      v18 = a8 >> 3;
    v19 = a4 + 64;
    do
    {
      if (v15 < v17)
      {
        v20 = v15;
        do
        {
          v21 = *(float16x8_t *)(a3 + 16 * v20);
          v22 = 0uLL;
          if (a8 >= 8)
          {
            v29 = 0;
            v28 = 0uLL;
            v30 = (float16x4_t *)(v19 + 2 * v11);
            v31 = v18;
            v27 = 0uLL;
            v26 = 0uLL;
            v25 = 0uLL;
            v24 = *(float16x8_t *)(a3 + 16 * v20);
            v23 = 0uLL;
            do
            {
              v32 = a2 + 2 * (int)(32 * a8 * v20) + (v29 << 9);
              v34 = *(float16x8_t *)v30[-8].i8;
              v33 = *(float16x8_t *)v30[-6].i8;
              v35 = *(float16x8_t *)(v32 + 16);
              v36 = vmlaq_n_f16(v21, v35, *(short float *)v33.i16);
              v38 = *(float16x8_t *)v30[-4].i8;
              v37 = *(float16x8_t *)v30[-2].i8;
              v39 = *(float16x8_t *)(v32 + 32);
              v40 = *(float16x8_t *)(v32 + 48);
              v41 = vmlaq_n_f16(v27, v39, *(short float *)v38.i16);
              v42 = vmlaq_n_f16(v26, v40, *(short float *)v37.i16);
              v43 = *(float16x8_t *)v30[2].i8;
              v44 = vmlaq_n_f16(v24, v35, *(short float *)v43.i16);
              v46 = *(float16x8_t *)v30[4].i8;
              v45 = *(float16x8_t *)v30[6].i8;
              v47 = vmlaq_n_f16(v23, v39, *(short float *)v46.i16);
              v48 = vmlaq_n_f16(v22, v40, *(short float *)v45.i16);
              v49 = *(float16x8_t *)(v32 + 64);
              v50 = *(float16x8_t *)(v32 + 80);
              v51 = vmlaq_lane_f16(vmlaq_n_f16(v28, *(float16x8_t *)v32, *(short float *)v34.i16), v49, *(float16x4_t *)v34.i8, 1);
              v52 = vmlaq_lane_f16(v36, v50, *(float16x4_t *)v33.i8, 1);
              v53 = *(float16x8_t *)(v32 + 96);
              v54 = *(float16x8_t *)(v32 + 112);
              v55 = vmlaq_lane_f16(v41, v53, *(float16x4_t *)v38.i8, 1);
              v56 = vmlaq_lane_f16(v42, v54, *(float16x4_t *)v37.i8, 1);
              v57 = vmlaq_lane_f16(vmlaq_n_f16(v25, *(float16x8_t *)v32, COERCE_SHORT_FLOAT(*(_OWORD *)v30->i8)), v49, *v30, 1);
              v58 = vmlaq_lane_f16(v44, v50, *(float16x4_t *)v43.i8, 1);
              v59 = vmlaq_lane_f16(v47, v53, *(float16x4_t *)v46.i8, 1);
              v60 = vmlaq_lane_f16(v48, v54, *(float16x4_t *)v45.i8, 1);
              v61 = *(float16x8_t *)(v32 + 128);
              v62 = *(float16x8_t *)(v32 + 144);
              v63 = vmlaq_lane_f16(v51, v61, *(float16x4_t *)v34.i8, 2);
              v64 = vmlaq_lane_f16(v52, v62, *(float16x4_t *)v33.i8, 2);
              v65 = *(float16x8_t *)(v32 + 160);
              v66 = *(float16x8_t *)(v32 + 176);
              v67 = vmlaq_lane_f16(v55, v65, *(float16x4_t *)v38.i8, 2);
              v68 = vmlaq_lane_f16(v56, v66, *(float16x4_t *)v37.i8, 2);
              v69 = vmlaq_lane_f16(v57, v61, *v30, 2);
              v70 = vmlaq_lane_f16(v58, v62, *(float16x4_t *)v43.i8, 2);
              v71 = vmlaq_lane_f16(v59, v65, *(float16x4_t *)v46.i8, 2);
              v72 = vmlaq_lane_f16(v60, v66, *(float16x4_t *)v45.i8, 2);
              v73 = *(float16x8_t *)(v32 + 192);
              v74 = *(float16x8_t *)(v32 + 208);
              v75 = vmlaq_lane_f16(v63, v73, *(float16x4_t *)v34.i8, 3);
              v76 = vmlaq_lane_f16(v64, v74, *(float16x4_t *)v33.i8, 3);
              v77 = *(float16x8_t *)(v32 + 224);
              v78 = *(float16x8_t *)(v32 + 240);
              v79 = vmlaq_lane_f16(v67, v77, *(float16x4_t *)v38.i8, 3);
              v80 = vmlaq_lane_f16(v68, v78, *(float16x4_t *)v37.i8, 3);
              v81 = vmlaq_lane_f16(v69, v73, *v30, 3);
              v82 = vmlaq_lane_f16(v70, v74, *(float16x4_t *)v43.i8, 3);
              v83 = vmlaq_lane_f16(v71, v77, *(float16x4_t *)v46.i8, 3);
              v84 = vmlaq_lane_f16(v72, v78, *(float16x4_t *)v45.i8, 3);
              v85 = *(float16x8_t *)(v32 + 256);
              v86 = *(float16x8_t *)(v32 + 272);
              v87 = vmlaq_laneq_f16(v75, v85, v34, 4);
              v88 = vmlaq_laneq_f16(v76, v86, v33, 4);
              v89 = *(float16x8_t *)(v32 + 288);
              v90 = *(float16x8_t *)(v32 + 304);
              v91 = vmlaq_laneq_f16(v79, v89, v38, 4);
              v92 = vmlaq_laneq_f16(v80, v90, v37, 4);
              v93 = vmlaq_laneq_f16(v81, v85, *(float16x8_t *)v30->i8, 4);
              v94 = vmlaq_laneq_f16(v82, v86, v43, 4);
              v95 = vmlaq_laneq_f16(v83, v89, v46, 4);
              v96 = vmlaq_laneq_f16(v84, v90, v45, 4);
              v97 = *(float16x8_t *)(v32 + 320);
              v98 = *(float16x8_t *)(v32 + 336);
              v99 = *(float16x8_t *)(v32 + 352);
              v100 = *(float16x8_t *)(v32 + 368);
              v101 = vmlaq_laneq_f16(v87, v97, v34, 5);
              v102 = vmlaq_laneq_f16(v88, v98, v33, 5);
              v103 = vmlaq_laneq_f16(v91, v99, v38, 5);
              v104 = vmlaq_laneq_f16(v92, v100, v37, 5);
              v105 = vmlaq_laneq_f16(v93, v97, *(float16x8_t *)v30->i8, 5);
              v106 = vmlaq_laneq_f16(v94, v98, v43, 5);
              v107 = vmlaq_laneq_f16(v95, v99, v46, 5);
              v108 = vmlaq_laneq_f16(v96, v100, v45, 5);
              v109 = *(float16x8_t *)(v32 + 384);
              v110 = *(float16x8_t *)(v32 + 400);
              v111 = *(float16x8_t *)(v32 + 416);
              v112 = *(float16x8_t *)(v32 + 432);
              v113 = vmlaq_laneq_f16(v101, v109, v34, 6);
              v114 = vmlaq_laneq_f16(v102, v110, v33, 6);
              v115 = vmlaq_laneq_f16(v103, v111, v38, 6);
              v116 = vmlaq_laneq_f16(v104, v112, v37, 6);
              v117 = vmlaq_laneq_f16(v105, v109, *(float16x8_t *)v30->i8, 6);
              v118 = vmlaq_laneq_f16(v106, v110, v43, 6);
              v119 = vmlaq_laneq_f16(v107, v111, v46, 6);
              v120 = vmlaq_laneq_f16(v108, v112, v45, 6);
              v121 = *(float16x8_t *)(v32 + 448);
              v122 = *(float16x8_t *)(v32 + 464);
              v28 = vmlaq_laneq_f16(v113, v121, v34, 7);
              v21 = vmlaq_laneq_f16(v114, v122, v33, 7);
              v123 = *(float16x8_t *)(v32 + 480);
              v124 = *(float16x8_t *)(v32 + 496);
              v27 = vmlaq_laneq_f16(v115, v123, v38, 7);
              v26 = vmlaq_laneq_f16(v116, v124, v37, 7);
              v25 = vmlaq_laneq_f16(v117, v121, *(float16x8_t *)v30->i8, 7);
              v24 = vmlaq_laneq_f16(v118, v122, v43, 7);
              v23 = vmlaq_laneq_f16(v119, v123, v46, 7);
              ++v29;
              v30 += 16;
              v22 = vmlaq_laneq_f16(v120, v124, v45, 7);
              --v31;
            }
            while (v31);
          }
          else
          {
            v23 = 0uLL;
            v24 = *(float16x8_t *)(a3 + 16 * v20);
            v25 = 0uLL;
            v26 = 0uLL;
            v27 = 0uLL;
            v28 = 0uLL;
          }
          v125 = a5 + 2 * (int)(v13 * a7 * (v12 / a7)) + ((uint64_t)v20 << 6);
          v126 = vaddq_f16(v27, vaddq_f16(v21, v28));
          v127 = vsubq_f16(vsubq_f16(v21, v27), v26);
          v128 = vaddq_f16(v23, vaddq_f16(v24, v25));
          v129 = vsubq_f16(vsubq_f16(v24, v23), v22);
          *(float16x8_t *)(v125
                         + 2 * (int)((((v12 % a7) >> 2) * v13) | (8 * ((v12 % a7) & 3)))) = vaddq_f16(vmaxq_f16(v126, (float16x8_t)0), vmulq_f16(vminq_f16(v126, (float16x8_t)0), v16));
          *(float16x8_t *)(v125
                         + 2
                         * (int)((((v12 % a7 + a7) >> 2) * v13) | (8 * ((v12 % a7 + a7) & 3)))) = vaddq_f16(vmaxq_f16(v127, (float16x8_t)0), vmulq_f16(vminq_f16(v127, (float16x8_t)0), v16));
          *(float16x8_t *)(v125
                         + 2
                         * (int)((((v12 % a7 + 2 * a7) >> 2) * v13) | (8
                                                                                   * ((v12 % a7 + 2 * a7) & 3)))) = vaddq_f16(vmaxq_f16(v128, (float16x8_t)0), vmulq_f16(vminq_f16(v128, (float16x8_t)0), v16));
          *(float16x8_t *)(v125
                         + 2
                         * (int)((((v12 % a7 + 3 * a7) >> 2) * v13) | (8
                                                                                   * ((v12 % a7 + 3 * a7) & 3)))) = vaddq_f16(vmaxq_f16(v129, (float16x8_t)0), vmulq_f16(vminq_f16(v129, (float16x8_t)0), v16));
          ++v20;
        }
        while (v17 > v20);
      }
      ++v12;
      v11 += a8 >> 3 << 6;
    }
    while (v12 != a9 >> 2);
  }
}

void SplitMELManager::neon_conv_single_kernel_cols(uint64_t a1, uint64_t a2, uint64_t a3, float16x4_t *a4, uint64_t a5, unsigned int a6, unsigned int a7, int a8, unsigned int a9)
{
  uint64_t v9;
  uint64_t v10;
  signed int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  uint64_t v26;
  float16x4_t *v27;
  uint64_t v28;
  float16x8_t *v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t *v52;
  float16x8_t *v53;

  if (a7 >= 8)
  {
    v9 = 0;
    LODWORD(v10) = a6 >> 3;
    v11 = a6 >> 3 << 6;
    v12 = 2 * (int)(32 * (a6 >> 3));
    v13 = (a6 >> 3) / a9 * a8;
    v14 = v13 + (a6 >> 3) / a9;
    v15 = v11;
    if (a6 >> 3 <= 1)
      v10 = 1;
    else
      v10 = v10;
    v16 = 2 * v11;
    do
    {
      if (v13 < v14)
      {
        v17 = v13;
        do
        {
          v18 = *(float16x8_t *)(a3 + 16 * (int)v17);
          if (a6 >= 8)
          {
            v26 = 0;
            v27 = a4;
            v28 = v10;
            v25 = *(float16x8_t *)(a3 + 16 * (int)v17);
            v24 = v25;
            v23 = v25;
            v22 = v25;
            v21 = v25;
            v20 = v25;
            v19 = v25;
            do
            {
              v29 = (float16x8_t *)(a2 + 2 * v17 * (int)((8 * a6) & 0xFFFFFFE0) + (v26 << 7));
              v30 = v29[1];
              v31 = *(float16x8_t *)v27[2].i8;
              v33 = *(float16x8_t *)v27[4].i8;
              v32 = *(float16x8_t *)v27[6].i8;
              v34 = v29[2];
              v35 = v29[3];
              v37 = *(float16x8_t *)&v27->i8[64 * (a6 >> 3)];
              v36 = *(float16x8_t *)&v27[2].i8[v12];
              v38 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v18, *v29, COERCE_SHORT_FLOAT(*(_OWORD *)v27->i8)), v30, *v27, 1), v34, *v27, 2), v35, *v27, 3);
              v39 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v25, *v29, *(short float *)v31.i16), v30, *(float16x4_t *)v31.i8, 1), v34, *(float16x4_t *)v31.i8, 2), v35, *(float16x4_t *)v31.i8, 3);
              v40 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v24, *v29, *(short float *)v33.i16), v30, *(float16x4_t *)v33.i8, 1), v34, *(float16x4_t *)v33.i8, 2), v35, *(float16x4_t *)v33.i8, 3);
              v41 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v23, *v29, *(short float *)v32.i16), v30, *(float16x4_t *)v32.i8, 1), v34, *(float16x4_t *)v32.i8, 2), v35, *(float16x4_t *)v32.i8, 3);
              v43 = *(float16x8_t *)&v27[4].i8[v12];
              v42 = *(float16x8_t *)&v27[6].i8[v12];
              v44 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v22, *v29, *(short float *)v37.i16), v30, *(float16x4_t *)v37.i8, 1), v34, *(float16x4_t *)v37.i8, 2), v35, *(float16x4_t *)v37.i8, 3);
              v45 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v21, *v29, *(short float *)v36.i16), v30, *(float16x4_t *)v36.i8, 1), v34, *(float16x4_t *)v36.i8, 2), v35, *(float16x4_t *)v36.i8, 3);
              v46 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v20, *v29, *(short float *)v43.i16), v30, *(float16x4_t *)v43.i8, 1), v34, *(float16x4_t *)v43.i8, 2), v35, *(float16x4_t *)v43.i8, 3);
              v47 = vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_lane_f16(vmlaq_n_f16(v19, *v29, *(short float *)v42.i16), v30, *(float16x4_t *)v42.i8, 1), v34, *(float16x4_t *)v42.i8, 2), v35, *(float16x4_t *)v42.i8, 3);
              v48 = v29[4];
              v49 = v29[5];
              v51 = v29[6];
              v50 = v29[7];
              v18 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v38, v48, *(float16x8_t *)v27->i8, 4), v49, *(float16x8_t *)v27->i8, 5), v51, *(float16x8_t *)v27->i8, 6), v50, *(float16x8_t *)v27->i8, 7);
              v25 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v39, v48, v31, 4), v49, v31, 5), v51, v31, 6), v50, v31, 7);
              v24 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v40, v48, v33, 4), v49, v33, 5), v51, v33, 6), v50, v33, 7);
              v23 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v41, v48, v32, 4), v49, v32, 5), v51, v32, 6), v50, v32, 7);
              v22 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v44, v48, v37, 4), v49, v37, 5), v51, v37, 6), v50, v37, 7);
              v21 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v45, v48, v36, 4), v49, v36, 5), v51, v36, 6), v50, v36, 7);
              v20 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v46, v48, v43, 4), v49, v43, 5), v51, v43, 6), v50, v43, 7);
              ++v26;
              v27 += 8;
              v19 = vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(vmlaq_laneq_f16(v47, v48, v42, 4), v49, v42, 5), v51, v42, 6), v50, v42, 7);
              --v28;
            }
            while (v28);
          }
          else
          {
            v19 = *(float16x8_t *)(a3 + 16 * (int)v17);
            v20 = v19;
            v21 = v19;
            v22 = v19;
            v23 = v19;
            v24 = v19;
            v25 = v19;
          }
          v52 = (float16x8_t *)(a5 + 2 * v9 * v15 + ((uint64_t)(int)v17 << 6));
          *v52 = v18;
          v52[1] = v25;
          v52[2] = v24;
          v52[3] = v23;
          v53 = (float16x8_t *)(a5 + 2 * (int)(32 * (a6 >> 3)) + 2 * v9 * v15 + ((uint64_t)(int)v17 << 6));
          *v53 = v22;
          v53[1] = v21;
          v53[2] = v20;
          v53[3] = v19;
          ++v17;
        }
        while (v14 > v17);
      }
      ++v9;
      a4 = (float16x4_t *)((char *)a4 + v16);
    }
    while (v9 != a7 >> 3);
  }
}

void SplitMELManager::neon_add_signals_loop_relu(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, unsigned int a8)
{
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  float16x8_t v12;
  uint64_t v13;
  int v14;
  float16x8_t *v15;
  float16x8_t v16;
  float16x8_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t *v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t *v25;

  if (a5 >= 4)
  {
    v8 = 0;
    v9 = a6 >> 3;
    v10 = (a6 >> 3) / a8 * a7;
    v11 = v10 + (a6 >> 3) / a8;
    v12 = (float16x8_t)vdupq_n_s16(0x3266u);
    do
    {
      if (v10 < v11)
      {
        v13 = v9 / a8 * a7;
        do
        {
          v14 = 32 * (v8 * v9 + v13);
          v15 = (float16x8_t *)(a2 + 2 * v14);
          v16 = *v15;
          v17 = v15[1];
          v18 = v15[2];
          v19 = v15[3];
          v20 = (float16x8_t *)(a3 + 2 * v14);
          v21 = vaddq_f16(v16, *v20);
          v22 = vaddq_f16(v17, v20[1]);
          v23 = vaddq_f16(v18, v20[2]);
          v24 = vaddq_f16(v19, v20[3]);
          v25 = (float16x8_t *)(a4 + 2 * v14);
          *v25 = vaddq_f16(vmaxq_f16(v21, (float16x8_t)0), vmulq_f16(vminq_f16(v21, (float16x8_t)0), v12));
          v25[1] = vaddq_f16(vmaxq_f16(v22, (float16x8_t)0), vmulq_f16(vminq_f16(v22, (float16x8_t)0), v12));
          v25[2] = vaddq_f16(vmaxq_f16(v23, (float16x8_t)0), vmulq_f16(vminq_f16(v23, (float16x8_t)0), v12));
          v25[3] = vaddq_f16(vmaxq_f16(v24, (float16x8_t)0), vmulq_f16(vminq_f16(v24, (float16x8_t)0), v12));
          ++v13;
        }
        while (v11 > v13);
      }
      ++v8;
    }
    while (v8 != a5 >> 2);
  }
}

void SplitMELManager::neon_add_signals_relu_colums(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, unsigned int a8)
{
  int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  float16x8_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  float16x8_t *v19;
  float16x8_t *v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  float32x4_t *v29;

  if (a5 >= 4)
  {
    v8 = 0;
    v9 = 4 * a6;
    v10 = a6 >> 3;
    v11 = (a6 >> 3) / a8 * a7;
    v12 = v11 + (a6 >> 3) / a8;
    v13 = (float16x8_t)vdupq_n_s16(0x3266u);
    v14 = 4 * a6;
    v15 = 8 * a6;
    v16 = 12 * a6;
    do
    {
      if (v11 < v12)
      {
        v17 = v11;
        do
        {
          v18 = 32 * (v8 * v10 + v17);
          v19 = (float16x8_t *)(a2 + 2 * v18);
          v20 = (float16x8_t *)(a3 + 2 * v18);
          v21 = vaddq_f16(*v19, *v20);
          v22 = vaddq_f16(v19[1], v20[1]);
          v23 = vaddq_f16(v19[2], v20[2]);
          v24 = vaddq_f16(v19[3], v20[3]);
          v25 = (int8x16_t)vaddq_f16(vmaxq_f16(v21, (float16x8_t)0), vmulq_f16(vminq_f16(v21, (float16x8_t)0), v13));
          v26 = (int8x16_t)vaddq_f16(vmaxq_f16(v22, (float16x8_t)0), vmulq_f16(vminq_f16(v22, (float16x8_t)0), v13));
          v27 = (int8x16_t)vaddq_f16(vmaxq_f16(v23, (float16x8_t)0), vmulq_f16(vminq_f16(v23, (float16x8_t)0), v13));
          v28 = (int8x16_t)vaddq_f16(vmaxq_f16(v24, (float16x8_t)0), vmulq_f16(vminq_f16(v24, (float16x8_t)0), v13));
          v29 = (float32x4_t *)(a4 + 4 * (v9 * v8 + 8 * (int)v17));
          *v29 = vcvtq_f32_f16(*(float16x4_t *)v25.i8);
          *(float32x4_t *)((char *)v29 + v14) = vcvtq_f32_f16(*(float16x4_t *)v26.i8);
          *(float32x4_t *)((char *)v29 + v15) = vcvtq_f32_f16(*(float16x4_t *)v27.i8);
          *(float32x4_t *)((char *)v29 + v16) = vcvtq_f32_f16(*(float16x4_t *)v28.i8);
          v29[1] = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL));
          *(float32x4_t *)((char *)++v29 + v14) = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
          *(float32x4_t *)((char *)v29 + v15) = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL));
          *(float32x4_t *)((char *)v29 + v16) = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
          ++v17;
        }
        while (v12 > v17);
      }
      ++v8;
    }
    while (v8 != a5 >> 2);
  }
}

float16x8_t *SplitMELManager::neon_add_signals(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, int a8, unsigned int a9)
{
  int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  int v14;
  float16x8_t *v15;
  float16x8_t v16;
  float16x8_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t *result;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t *v25;
  float16x8_t *v26;

  if (a6 >= 4)
  {
    v9 = 0;
    v10 = (a7 >> 3) / a9 * a8;
    v11 = v10 + (a7 >> 3) / a9;
    if (a6 >> 2 <= 1)
      v12 = 1;
    else
      v12 = a6 >> 2;
    do
    {
      if (v10 < v11)
      {
        v13 = (a7 >> 3) / a9 * a8;
        do
        {
          v14 = 32 * (v9 * (a7 >> 3) + v13);
          v15 = (float16x8_t *)(a2 + 2 * v14);
          v16 = *v15;
          v17 = v15[1];
          v18 = v15[2];
          v19 = v15[3];
          result = (float16x8_t *)(a3 + 2 * v14);
          v21 = vaddq_f16(v16, *result);
          v22 = vaddq_f16(v17, result[1]);
          v23 = vaddq_f16(v18, result[2]);
          v24 = vaddq_f16(v19, result[3]);
          v25 = (float16x8_t *)(a5 + 2 * (int)(32 * (v9 + (a6 >> 2) * v13)));
          *v25 = v21;
          v25[1] = v22;
          v25[2] = v23;
          v25[3] = v24;
          v26 = (float16x8_t *)(a4 + 2 * v14);
          *v26 = v21;
          v26[1] = v22;
          v26[2] = v23;
          v26[3] = v24;
          ++v13;
        }
        while (v11 > v13);
      }
      ++v9;
    }
    while (v9 != v12);
  }
  return result;
}

void NeonFirstBlockMelManager::do_inference(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  unint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  _DWORD *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  unint64_t v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _DWORD *v50;
  _DWORD *v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  float16x8_t v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t i;
  long double v66;
  uint64_t v67;
  uint64_t conv_input_shift_by_rows;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  int v82;
  uint64_t v83;
  int v84;
  _QWORD *v85;
  unint64_t v86;
  _QWORD *v87;
  _QWORD *v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  _QWORD *v100;
  _QWORD *v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  _QWORD *v107;
  _QWORD *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  _QWORD *v114;
  _QWORD *v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  _QWORD *v121;
  _QWORD *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v130;
  uint64_t v131;
  _QWORD *v132;
  uint64_t v133;
  uint64_t *v134;

  v5 = a5;
  v6 = a4;
  v9 = a1;
  v10 = *(_QWORD *)(a1 + 144);
  if (*(_BYTE *)(v10 + 2304))
  {
    *(_QWORD *)(a1 + 192) = a2;
    *(_QWORD *)(a1 + 200) = a3;
    *(_QWORD *)(a1 + 208) = a4;
    *(_QWORD *)(a1 + 216) = a5;
    if (*(_BYTE *)(v10 + 3496))
    {
      *(_DWORD *)(a1 + 188) = 0;
LABEL_67:
      *(_OWORD *)(v9 + 80) = xmmword_214FBF890;
      *(_QWORD *)(v9 + 96) = 0x400000000;
      *(_DWORD *)(v9 + 184) = 8 * *(_DWORD *)(v10 + 4088);
      SynchroManager::cond_broadcast_on_entry((SynchroManager *)(v10 + 2312), *(_DWORD *)(v10 + 2308), 2);
      SynchroManager::cond_wait_less_on_exit((SynchroManager *)(*(_QWORD *)(v9 + 144) + 2312), *(_DWORD *)(*(_QWORD *)(v9 + 144) + 2308));
      return;
    }
    if (a3[1] - *a3 > 8uLL)
    {
      v11 = *(_DWORD *)(*a3 + 8);
      *(_DWORD *)(v10 + 4088) = v11;
      v12 = -v11 < 0;
      v13 = -v11 & 3;
      v14 = v11 & 3;
      if (!v12)
        v14 = -v13;
      if (v14)
      {
        v15 = 0;
        *(_DWORD *)(a1 + 188) = 4 - v14;
        v16 = *a3;
        v17 = a3[1];
        while (1)
        {
          if ((unint64_t)(v17 - v16) < 0x11)
            goto LABEL_134;
          if (*(_QWORD *)(v16 + 16))
            break;
LABEL_33:
          ++v15;
          v33 = *(_DWORD *)(v9 + 188);
          if (v15 >= v33)
          {
            v10 = *(_QWORD *)(v9 + 144);
            goto LABEL_65;
          }
        }
        v18 = 0;
        while (1)
        {
          v19 = (_DWORD *)a2[1];
          v20 = a2[2];
          if ((unint64_t)v19 >= v20)
          {
            v22 = *a2;
            v23 = ((uint64_t)v19 - *a2) >> 2;
            v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 62)
              goto LABEL_135;
            v25 = v20 - v22;
            if (v25 >> 1 > v24)
              v24 = v25 >> 1;
            v26 = (unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v24;
            v134 = a2 + 3;
            if (v26)
            {
              v27 = ENTTS::Allocator<int>::allocate((uint64_t)(a2 + 3), v26);
              v22 = *a2;
              v19 = (_DWORD *)a2[1];
            }
            else
            {
              v27 = 0;
            }
            v28 = (_DWORD *)(v27 + 4 * v23);
            *v28 = 0;
            if (v19 == (_DWORD *)v22)
            {
              v30 = v27 + 4 * v23;
            }
            else
            {
              v29 = v19;
              v30 = v27 + 4 * v23;
              do
              {
                v31 = *--v29;
                *(_DWORD *)(v30 - 4) = v31;
                v30 -= 4;
              }
              while (v29 != (_DWORD *)v22);
            }
            v21 = v28 + 1;
            *a2 = v30;
            a2[1] = (uint64_t)(v28 + 1);
            v32 = a2[2];
            a2[2] = v27 + 4 * v26;
            v132 = v19;
            v133 = v32;
            v130 = v22;
            v131 = v22;
            a1 = std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&v130);
            v16 = *a3;
            v17 = a3[1];
          }
          else
          {
            *v19 = 0;
            v21 = v19 + 1;
          }
          a2[1] = (uint64_t)v21;
          if ((unint64_t)(v17 - v16) <= 0x10)
            break;
          if (*(_QWORD *)(v16 + 16) <= (unint64_t)++v18)
            goto LABEL_33;
        }
      }
      else
      {
        v33 = 0;
        *(_DWORD *)(a1 + 188) = 0;
        v16 = *a3;
        v17 = a3[1];
LABEL_65:
        v56 = *(_DWORD *)(v10 + 4088) + v33;
        *(_DWORD *)(v10 + 4088) = v56;
        if ((unint64_t)(v17 - v16) > 0x10)
        {
          SplitMELManager::neon_convert_f2h_column(a1, *a2, *(_QWORD *)(v10 + 2776), *(_DWORD *)(v16 + 16), v56);
          v10 = *(_QWORD *)(v9 + 144);
          goto LABEL_67;
        }
      }
    }
    goto LABEL_134;
  }
  if (*(_BYTE *)(v10 + 3496))
  {
    *(_DWORD *)(a1 + 188) = 0;
  }
  else
  {
    if (a3[1] - *a3 <= 8uLL)
      goto LABEL_134;
    v34 = *(_DWORD *)(*a3 + 8);
    *(_DWORD *)(v10 + 4088) = v34;
    v12 = -v34 < 0;
    v35 = -v34 & 3;
    v36 = v34 & 3;
    if (!v12)
      v36 = -v35;
    if (v36)
    {
      v37 = 0;
      *(_DWORD *)(a1 + 188) = 4 - v36;
      v38 = *a3;
      v39 = a3[1];
      while (1)
      {
        if ((unint64_t)(v39 - v38) < 0x11)
          goto LABEL_134;
        if (*(_QWORD *)(v38 + 16))
          break;
LABEL_62:
        ++v37;
        v55 = *(_DWORD *)(v9 + 188);
        if (v37 >= v55)
        {
          v10 = *(_QWORD *)(v9 + 144);
          v6 = a4;
          v5 = a5;
          goto LABEL_69;
        }
      }
      v40 = 0;
      while (1)
      {
        v41 = (_DWORD *)a2[1];
        v42 = a2[2];
        if ((unint64_t)v41 >= v42)
        {
          v44 = *a2;
          v45 = ((uint64_t)v41 - *a2) >> 2;
          v46 = v45 + 1;
          if ((unint64_t)(v45 + 1) >> 62)
LABEL_135:
            std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
          v47 = v42 - v44;
          if (v47 >> 1 > v46)
            v46 = v47 >> 1;
          v48 = (unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v46;
          v134 = a2 + 3;
          if (v48)
          {
            v49 = ENTTS::Allocator<int>::allocate((uint64_t)(a2 + 3), v48);
            v44 = *a2;
            v41 = (_DWORD *)a2[1];
          }
          else
          {
            v49 = 0;
          }
          v50 = (_DWORD *)(v49 + 4 * v45);
          *v50 = 0;
          if (v41 == (_DWORD *)v44)
          {
            v52 = v49 + 4 * v45;
          }
          else
          {
            v51 = v41;
            v52 = v49 + 4 * v45;
            do
            {
              v53 = *--v51;
              *(_DWORD *)(v52 - 4) = v53;
              v52 -= 4;
            }
            while (v51 != (_DWORD *)v44);
          }
          v43 = v50 + 1;
          *a2 = v52;
          a2[1] = (uint64_t)(v50 + 1);
          v54 = a2[2];
          a2[2] = v49 + 4 * v48;
          v132 = v41;
          v133 = v54;
          v130 = v44;
          v131 = v44;
          a1 = std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&v130);
          v38 = *a3;
          v39 = a3[1];
        }
        else
        {
          *v41 = 0;
          v43 = v41 + 1;
        }
        a2[1] = (uint64_t)v43;
        if ((unint64_t)(v39 - v38) <= 0x10)
          goto LABEL_134;
        if (*(_QWORD *)(v38 + 16) <= (unint64_t)++v40)
          goto LABEL_62;
      }
    }
    v55 = 0;
    *(_DWORD *)(a1 + 188) = 0;
    v38 = *a3;
    v39 = a3[1];
LABEL_69:
    v57 = *(_DWORD *)(v10 + 4088) + v55;
    *(_DWORD *)(v10 + 4088) = v57;
    if ((unint64_t)(v39 - v38) <= 0x10)
LABEL_134:
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    SplitMELManager::neon_convert_f2h_column(a1, *a2, *(_QWORD *)(v10 + 2776), *(_DWORD *)(v38 + 16), v57);
    v10 = *(_QWORD *)(v9 + 144);
  }
  *(_OWORD *)(v9 + 80) = xmmword_214FBF890;
  *(_QWORD *)(v9 + 96) = 0x400000000;
  v58 = *(_DWORD *)(v10 + 4088);
  *(_DWORD *)(v9 + 184) = 8 * v58;
  SplitMELManager::neon_transpose_rows(a1, *(_QWORD *)(v10 + 2872), *(float16x8_t **)(v10 + 2776), *(_QWORD *)(v10 + 2792), 0x180u, 0xC0u, v58, 8 * v58, 16, 8, 0, *(_DWORD *)(v10 + 2308));
  v59 = *(_QWORD *)(v9 + 144);
  SplitMELManager::neon_transpose_rearrange_rows_0(v61, v60, *(_QWORD *)(v59 + 2792), *(_QWORD *)(v59 + 2800), *(_QWORD *)(v59 + 2880), *(_DWORD *)(v9 + 84), *(_DWORD *)(v59 + 4088), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 92), 0, *(_DWORD *)(v59 + 2308));
  SplitMELManager::neon_block_input(v62, *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2800), *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2816), *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2808), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 84), 0, *(_DWORD *)(*(_QWORD *)(v9 + 144) + 2308));
  v63 = 0;
  v64 = 2888;
  for (i = 3016; ; i += 16)
  {
    v66 = pow(3.0, (double)v63);
    *(_DWORD *)(v9 + 104) = (int)v66;
    *(_DWORD *)(v9 + 108) = (int)v66;
    conv_input_shift_by_rows = SplitMELManager::neon_first_conv_input_shift_by_rows(v9, *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2808), *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2784), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 84), v67, (int)v66, 6 * (int)v66, 0, *(_DWORD *)(*(_QWORD *)(v9 + 144) + 2308));
    v69 = *(_QWORD *)(v9 + 144);
    SplitMELManager::neon_first_conv_cols(conv_input_shift_by_rows, *(_QWORD *)(v69 + v64), *(_QWORD *)(v69 + v64 + 8), *(_QWORD *)(v69 + 2784), *(_QWORD *)(v69 + 2824), v70, *(_DWORD *)(v9 + 108), *(_DWORD *)(v9 + 84), 4 * conv_input_shift_by_rows * *(_DWORD *)(v9 + 108), 0, *(_DWORD *)(v69 + 2308));
    v71 = *(_QWORD *)(v9 + 144);
    SplitMELManager::neon_conv_single_kernel_cols(v72, *(_QWORD *)(v71 + v64 + 16), *(_QWORD *)(v71 + v64 + 24), *(float16x4_t **)(v71 + 2824), *(_QWORD *)(v71 + 2832), *(_DWORD *)(v9 + 84), *(_DWORD *)(v9 + 184), 0, *(_DWORD *)(v71 + 2308));
    v73 = *(_QWORD *)(v9 + 144);
    SplitMELManager::neon_conv_single_kernel_cols(v74, *(_QWORD *)(v73 + i), *(_QWORD *)(v73 + i + 8), *(float16x4_t **)(v73 + 2816), *(_QWORD *)(v73 + 2824), *(_DWORD *)(v9 + 84), *(_DWORD *)(v9 + 184), 0, *(_DWORD *)(v73 + 2308));
    v76 = *(_QWORD *)(v9 + 144);
    if (v64 == 2984)
      break;
    SplitMELManager::neon_add_signals(v75, *(_QWORD *)(v76 + 2832), *(_QWORD *)(v76 + 2824), *(_QWORD *)(v76 + 2816), *(_QWORD *)(v76 + 2808), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 84), 0, *(_DWORD *)(v76 + 2308));
    v64 += 32;
    ++v63;
  }
  v77 = *(_QWORD *)(v76 + 2832);
  v78 = *(_QWORD *)(v76 + 2824);
  v79 = *(_DWORD *)(v9 + 184);
  v80 = *(_DWORD *)(v9 + 84);
  v81 = *(_DWORD *)(v76 + 2308);
  if (*(_BYTE *)(v76 + 3498))
    SplitMELManager::neon_add_signals_loop_relu(v75, v77, v78, *(_QWORD *)(v76 + 2776), v79, v80, 0, v81);
  else
    SplitMELManager::neon_add_signals_relu_colums(v75, v77, v78, *(_QWORD *)(v76 + 2848), v79, v80, 0, v81);
  v82 = *(_DWORD *)(v9 + 184);
  v83 = *(_QWORD *)(v9 + 144);
  *(_DWORD *)(v83 + 4088) = v82;
  if (!*(_BYTE *)(v83 + 3498))
  {
    v84 = v82 - 8 * *(_DWORD *)(v9 + 188);
    *(_DWORD *)(v83 + 4088) = v84;
    v85 = (_QWORD *)v5[1];
    v86 = v5[2];
    if ((unint64_t)v85 >= v86)
    {
      v88 = (_QWORD *)*v5;
      v89 = ((uint64_t)v85 - *v5) >> 3;
      v90 = v89 + 1;
      if ((unint64_t)(v89 + 1) >> 61)
        goto LABEL_136;
      v91 = v86 - (_QWORD)v88;
      if (v91 >> 2 > v90)
        v90 = v91 >> 2;
      if ((unint64_t)v91 >= 0x7FFFFFFFFFFFFFF8)
        v92 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v92 = v90;
      v134 = v5 + 3;
      if (v92)
      {
        v93 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v92);
        v88 = (_QWORD *)*v5;
        v85 = (_QWORD *)v5[1];
      }
      else
      {
        v93 = 0;
      }
      v94 = (_QWORD *)(v93 + 8 * v89);
      *v94 = 1;
      if (v85 == v88)
      {
        v96 = v93 + 8 * v89;
      }
      else
      {
        v95 = v85;
        v96 = v93 + 8 * v89;
        do
        {
          v97 = *--v95;
          *(_QWORD *)(v96 - 8) = v97;
          v96 -= 8;
        }
        while (v95 != v88);
      }
      v87 = v94 + 1;
      *v5 = v96;
      v5[1] = (uint64_t)(v94 + 1);
      v98 = v5[2];
      v5[2] = v93 + 8 * v92;
      v132 = v85;
      v133 = v98;
      v130 = (uint64_t)v88;
      v131 = (uint64_t)v88;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v130);
      v84 = *(_DWORD *)(*(_QWORD *)(v9 + 144) + 4088);
      v86 = v5[2];
    }
    else
    {
      *v85 = 1;
      v87 = v85 + 1;
    }
    v5[1] = (uint64_t)v87;
    v99 = v84;
    if ((unint64_t)v87 >= v86)
    {
      v101 = (_QWORD *)*v5;
      v102 = ((uint64_t)v87 - *v5) >> 3;
      v103 = v102 + 1;
      if ((unint64_t)(v102 + 1) >> 61)
        goto LABEL_136;
      v104 = v86 - (_QWORD)v101;
      if (v104 >> 2 > v103)
        v103 = v104 >> 2;
      if ((unint64_t)v104 >= 0x7FFFFFFFFFFFFFF8)
        v105 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v105 = v103;
      v134 = v5 + 3;
      if (v105)
      {
        v106 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v105);
        v101 = (_QWORD *)*v5;
        v87 = (_QWORD *)v5[1];
      }
      else
      {
        v106 = 0;
      }
      v107 = (_QWORD *)(v106 + 8 * v102);
      *v107 = v99;
      if (v87 == v101)
      {
        v109 = v106 + 8 * v102;
      }
      else
      {
        v108 = v87;
        v109 = v106 + 8 * v102;
        do
        {
          v110 = *--v108;
          *(_QWORD *)(v109 - 8) = v110;
          v109 -= 8;
        }
        while (v108 != v101);
      }
      v100 = v107 + 1;
      *v5 = v109;
      v5[1] = (uint64_t)(v107 + 1);
      v111 = v5[2];
      v5[2] = v106 + 8 * v105;
      v132 = v87;
      v133 = v111;
      v130 = (uint64_t)v101;
      v131 = (uint64_t)v101;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v130);
      v86 = v5[2];
    }
    else
    {
      *v87 = v84;
      v100 = v87 + 1;
    }
    v5[1] = (uint64_t)v100;
    v112 = *(_DWORD *)(v9 + 84);
    v113 = v112;
    if ((unint64_t)v100 < v86)
    {
      *v100 = v112;
      v114 = v100 + 1;
LABEL_131:
      v5[1] = (uint64_t)v114;
      v126 = *(_QWORD *)(v9 + 144);
      v127 = *(int *)(v126 + 4088) * (uint64_t)v112;
      std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(v6, *(char **)(v126 + 2848), *(_QWORD *)(v126 + 2848) + 4 * v127, v127);
      goto LABEL_132;
    }
    v115 = (_QWORD *)*v5;
    v116 = ((uint64_t)v100 - *v5) >> 3;
    v117 = v116 + 1;
    if (!((unint64_t)(v116 + 1) >> 61))
    {
      v118 = v86 - (_QWORD)v115;
      if (v118 >> 2 > v117)
        v117 = v118 >> 2;
      if ((unint64_t)v118 >= 0x7FFFFFFFFFFFFFF8)
        v119 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v119 = v117;
      v134 = v5 + 3;
      if (v119)
      {
        v120 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v119);
        v115 = (_QWORD *)*v5;
        v100 = (_QWORD *)v5[1];
      }
      else
      {
        v120 = 0;
      }
      v121 = (_QWORD *)(v120 + 8 * v116);
      *v121 = v113;
      if (v100 == v115)
      {
        v123 = v120 + 8 * v116;
      }
      else
      {
        v122 = v100;
        v123 = v120 + 8 * v116;
        do
        {
          v124 = *--v122;
          *(_QWORD *)(v123 - 8) = v124;
          v123 -= 8;
        }
        while (v122 != v115);
      }
      v114 = v121 + 1;
      *v5 = v123;
      v5[1] = (uint64_t)(v121 + 1);
      v125 = v5[2];
      v5[2] = v120 + 8 * v119;
      v132 = v100;
      v133 = v125;
      v130 = (uint64_t)v115;
      v131 = (uint64_t)v115;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v130);
      v112 = *(_DWORD *)(v9 + 84);
      goto LABEL_131;
    }
LABEL_136:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  }
  if (*(_BYTE *)(v83 + 3496))
    return;
  *(_DWORD *)(v83 + 4092) = *(_DWORD *)(v9 + 188);
LABEL_132:
  *(_DWORD *)(v9 + 188) = 0;
}

void SplitMELManager::neon_convert_f2h_column(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  float32x4_t *v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t *v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t *v23;
  float32x4_t *v24;
  float32x4_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t *v29;

  if (a4 >= 8)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = a4 >> 3;
    v9 = 4 * a4;
    v10 = 2 * a4;
    v11 = 32 * (a4 >> 3);
    if (a4 >> 3 <= 1)
      v8 = 1;
    v12 = a4;
    v13 = 3 * a4;
    do
    {
      if (a5 >= 4)
      {
        v14 = (a5 / 4);
        v15 = v5;
        v16 = v6;
        do
        {
          v17 = (float32x4_t *)(a2 + 4 * v15);
          v18 = *v17;
          v19 = v17[1];
          v20 = (float32x4_t *)((char *)v17 + 4 * v12);
          v21 = *v20;
          v22 = v20[1];
          v23 = (float32x4_t *)((char *)v17 + 4 * v10);
          v24 = (float32x4_t *)((char *)v17 + 4 * v13);
          v25 = v24[1];
          v26 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v18), v19);
          v27 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v21), v22);
          v28 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(*v23), v23[1]);
          *(float16x4_t *)v22.f32 = vcvt_f16_f32(*v24);
          v29 = (float16x8_t *)(a3 + 2 * v16);
          *v29 = v26;
          v29[1] = v27;
          v29[2] = v28;
          v29[3] = vcvt_hight_f16_f32(*(int16x4_t *)v22.f32, v25);
          v16 += v11;
          v15 += v9;
          --v14;
        }
        while (v14);
      }
      ++v7;
      v6 += 32;
      v5 += 8;
    }
    while (v7 != v8);
  }
}

char **NeonSecondBlockMelManager::NeonSecondBlockMelManager(char **a1, char *a2, uint64_t a3, uint64_t a4, char **a5)
{
  char **v7;
  uint64_t v8;
  NeonMELContainer *v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  _QWORD v13[13];
  char v14;
  uint64_t v15;
  void *v16;
  std::locale v17;

  a1[19] = 0;
  v7 = a1 + 19;
  a1[1] = 0;
  a1[2] = 0;
  a1[14] = 0;
  a1[15] = 0;
  v8 = CustomAllocator::mRsrc;
  a1[16] = 0;
  a1[17] = (char *)v8;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = (char *)v8;
  a1[28] = 0;
  a1[29] = 0;
  a1[18] = a2;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v13);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=(v7, a5);
  NeonSecondBlockMelManager::ModelNpy((uint64_t)a1, (uint64_t)v13);
  v9 = (NeonMELContainer *)a1[18];
  *((_BYTE *)v9 + 3498) = 0;
  if (*((_BYTE *)v9 + 2304)
    && (NeonMELContainer::EngineMCSetUp(v9, a1, 2, (void (*)(void *, int))mc_SecondBlock_do_inference) & 1) == 0)
  {
    v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"WARNING: error set up multi-core engine", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
    v11 = std::locale::use_facet(&v17, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
    std::locale::~locale(&v17);
    std::ostream::put();
    std::ostream::flush();
  }
  v13[0] = &unk_24D29B388;
  v13[2] = &unk_24D29B3B0;
  v16 = &unk_24D29B3D8;
  v13[3] = &unk_24D29B578;
  if (v14 < 0)
    heap_Free(*(_QWORD **)(v15 + 8), v13[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v16);
  return a1;
}

void sub_214EACC98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  SplitMELManager *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  std::locale::~locale((std::locale *)(v5 - 56));
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v4);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v3);
  SplitMELManager::~SplitMELManager(v2);
  _Unwind_Resume(a1);
}

uint64_t NeonSecondBlockMelManager::ModelNpy(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int i;
  int v18;
  uint64_t v19;
  _WORD *v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  _QWORD *v42;
  const std::locale::facet *v43;
  _QWORD *v44;
  _QWORD *v45;
  uint64_t v46;
  _WORD *v47;
  uint64_t v48;
  __int16 *v49;
  uint64_t v50;
  __int16 v51;
  _QWORD *v52;
  const std::locale::facet *v53;
  uint64_t j;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  int v63;
  _WORD *v64;
  unint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  float16x4_t *v77;
  int v78;
  unint64_t v79;
  uint64_t v80;
  float16x4_t *v81;
  float32x4_t v82;
  __int128 v83;
  float16x8_t v84;
  float16x8_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  _QWORD *v96;
  _QWORD *v97;
  const std::locale::facet *v98;
  _QWORD *v99;
  _QWORD *v100;
  _QWORD *v101;
  uint64_t v102;
  _WORD *v103;
  uint64_t v104;
  __int16 *v105;
  uint64_t v106;
  __int16 v107;
  _QWORD *v108;
  _QWORD *v109;
  _QWORD *v110;
  _QWORD *v111;
  const std::locale::facet *v112;
  _QWORD *v113;
  _QWORD *v114;
  _QWORD *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  _WORD *v121;
  unint64_t v122;
  _WORD *v123;
  uint64_t v124;
  unint64_t v125;
  _WORD *v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  uint64_t v134;
  int v135;
  _QWORD *v136;
  _QWORD *v137;
  _QWORD *v138;
  _QWORD *v139;
  const std::locale::facet *v140;
  _QWORD *v141;
  _QWORD *v142;
  _QWORD *v143;
  uint64_t v144;
  _WORD *v145;
  uint64_t v146;
  __int16 *v147;
  uint64_t v148;
  __int16 v149;
  _QWORD *v150;
  _QWORD *v151;
  _QWORD *v152;
  _QWORD *v153;
  const std::locale::facet *v154;
  _QWORD *v155;
  _QWORD *v156;
  _QWORD *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unint64_t v162;
  _WORD *v163;
  unint64_t v164;
  _WORD *v165;
  uint64_t v166;
  unint64_t v167;
  _WORD *v168;
  int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  uint64_t v176;
  int v177;
  _QWORD *v178;
  _QWORD *v179;
  _QWORD *v180;
  _QWORD *v181;
  const std::locale::facet *v182;
  _QWORD *v183;
  _QWORD *v184;
  _QWORD *v185;
  uint64_t v186;
  _WORD *v187;
  uint64_t v188;
  __int16 *v189;
  uint64_t v190;
  __int16 v191;
  _QWORD *v192;
  _QWORD *v193;
  _QWORD *v194;
  _QWORD *v195;
  const std::locale::facet *v196;
  _QWORD *v198;
  uint64_t v199[2];
  char v200;
  uint64_t v201;
  uint64_t v202[2];
  char v203;
  uint64_t v204;
  uint64_t v205[2];
  char v206;
  uint64_t v207;
  uint64_t v208[2];
  char v209;
  uint64_t v210;
  uint64_t v211[2];
  char v212;
  uint64_t v213;
  uint64_t v214[2];
  char v215;
  uint64_t v216;
  uint64_t v217[2];
  char v218;
  uint64_t v219;
  uint64_t v220[2];
  char v221;
  uint64_t v222;
  std::locale v223;
  void *v224;
  void *v225;
  uint64_t v226;
  char v227;
  uint64_t v228;
  _QWORD v229[19];
  std::locale v230;
  void *v231;
  _QWORD v232[10];
  char v233;
  uint64_t v234;
  void *v235;
  _WORD *v236;
  _WORD *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  __int128 v248;
  uint64_t v249;

  v249 = *MEMORY[0x24BDAC8D0];
  v244 = 0;
  v245 = 0;
  v246 = 0;
  v247 = CustomAllocator::mRsrc;
  v240 = 0;
  v241 = 0;
  v242 = 0;
  v243 = CustomAllocator::mRsrc;
  v236 = 0;
  v237 = 0;
  v238 = 0;
  v239 = CustomAllocator::mRsrc;
  v198 = (_QWORD *)(a2 + 16);
  v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a2 + 16), (uint64_t)"path: ", 6);
  v4 = *(char *)(a1 + 175);
  if (v4 >= 0)
    v5 = a1 + 152;
  else
    v5 = *(_QWORD *)(a1 + 152);
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a1 + 175);
  else
    v6 = *(_QWORD *)(a1 + 160);
  v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, v5, v6);
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
  v8 = std::locale::use_facet(&v230, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v230);
  std::ostream::put();
  std::ostream::flush();
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v230);
  *(_QWORD *)(a1 + 80) = 0x60000000C0;
  *(_DWORD *)(a1 + 88) = 8;
  v245 = v244;
  v237 = v236;
  v241 = v240;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
  v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v224 = &unk_24D29B3B0;
  v229[0] = &unk_24D29B3D8;
  v225 = &unk_24D29B578;
  if (v227 < 0)
    heap_Free(*(_QWORD **)(v228 + 8), v226);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v229);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
  v9 = (_QWORD *)std::ostream::operator<<();
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"/upsampler/layer/transposed/weight", 34);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"/npy", 4);
  v11 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v220);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v11 + 24))(v11, v220, &v244, &v236, 1);
  if (v221 < 0)
    heap_Free(*(_QWORD **)(v222 + 8), v220[0]);
  if (v237 == v236)
  {
    v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: upsampler_layer_transposed_weight", 40);
    std::ios_base::getloc((const std::ios_base *)((char *)v42 + *(_QWORD *)(*v42 - 24)));
    v43 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
    std::locale::~locale(&v223);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v12 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 80) * *(_DWORD *)(a1 + 88));
    v13 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 80) * *(_DWORD *)(a1 + 88));
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 3080) = v13;
    v14 = *(_DWORD *)(a1 + 80);
    v15 = *(_DWORD *)(a1 + 84);
    if (v14 >= 1)
    {
      v16 = 0;
      for (i = 0; i != v14; ++i)
      {
        if (v15 >= 1)
        {
          v18 = 0;
          v19 = *(unsigned int *)(a1 + 88);
          v20 = v236;
          v21 = v237 - v236;
          v22 = v19 * v16;
          do
          {
            if ((int)v19 >= 1)
            {
              v23 = v19;
              v24 = v22;
              do
              {
                if (v21 <= v24)
                  std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
                *(_WORD *)(v12 + 2 * v24) = v20[v24];
                ++v24;
                --v23;
              }
              while (v23);
            }
            ++v18;
            v22 += v19;
          }
          while (v18 != v15);
        }
        v16 += v15;
      }
    }
    if (v15 >= 0)
      v25 = v15;
    else
      v25 = v15 + 7;
    if (v15 >= 8)
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = v25 >> 3;
      v30 = *(_DWORD *)(a1 + 88);
      v31 = v15 * v30;
      do
      {
        if (v30 >= 1)
        {
          v32 = 0;
          v33 = v26;
          do
          {
            if (v14 >= 4)
            {
              v34 = 0;
              v35 = v33;
              do
              {
                v36 = 0;
                v37 = v35;
                do
                {
                  v38 = 0;
                  v39 = v27;
                  v40 = v13 + 2 * v27;
                  v41 = v37;
                  do
                  {
                    *(_WORD *)(v40 + 2 * v38++) = *(_WORD *)(v12 + 2 * v41);
                    v41 += v30;
                  }
                  while (v38 != 8);
                  v27 = v39 + 8;
                  ++v36;
                  v37 += v31;
                }
                while (v36 != 4);
                ++v34;
                v35 += 4 * v31;
                v27 = v39 + 8;
              }
              while (v34 != v14 / 4);
              v27 = v39 + 8;
            }
            ++v32;
            ++v33;
          }
          while (v32 != v30);
        }
        ++v28;
        v26 += 8 * v30;
      }
      while (v28 != v29);
    }
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v12);
  }
  v245 = v244;
  v237 = v236;
  v241 = v240;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
  v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v229[0] = &unk_24D29B3D8;
  v224 = &unk_24D29B3B0;
  v225 = &unk_24D29B578;
  if (v227 < 0)
    heap_Free(*(_QWORD **)(v228 + 8), v226);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v229);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
  v44 = (_QWORD *)std::ostream::operator<<();
  v45 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)"/upsampler/layer/transposed/bias", 32);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"/npy", 4);
  v46 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v217);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v46 + 24))(v46, v217, &v244, &v236, 1);
  if (v218 < 0)
    heap_Free(*(_QWORD **)(v219 + 8), v217[0]);
  if (v237 == v236)
  {
    v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: upsampler_layer_transposed_bias", 38);
    std::ios_base::getloc((const std::ios_base *)((char *)v52 + *(_QWORD *)(*v52 - 24)));
    v53 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v53->__vftable[2].~facet_0)(v53, 10);
    std::locale::~locale(&v223);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v47 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 3088) = v47;
    v48 = *(unsigned int *)(a1 + 84);
    if ((int)v48 >= 1)
    {
      v49 = v236;
      v50 = v237 - v236;
      while (v50)
      {
        v51 = *v49++;
        *v47++ = v51;
        --v50;
        if (!--v48)
          goto LABEL_52;
      }
LABEL_158:
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    }
  }
LABEL_52:
  for (j = 0; j != 4; ++j)
  {
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v55 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v55, (uint64_t)"/block/", 7);
    v56 = (_QWORD *)std::ostream::operator<<();
    v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v56, (uint64_t)"/first/conv1d/weight", 20);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"/npy", 4);
    v58 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v214);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v58 + 24))(v58, v214, &v244, &v236, 1);
    if (v215 < 0)
      heap_Free(*(_QWORD **)(v216 + 8), v214[0]);
    if (v237 == v236)
    {
      v94 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v94, (uint64_t)"[", 1);
      v95 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v95, (uint64_t)"][", 2);
      v96 = (_QWORD *)std::ostream::operator<<();
      v97 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v96, (uint64_t)"] first_conv1d_weight", 21);
      std::ios_base::getloc((const std::ios_base *)((char *)v97 + *(_QWORD *)(*v97 - 24)));
      v98 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v98->__vftable[2].~facet_0)(v98, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v59 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (6 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      v60 = 0;
      v61 = 0;
      v62 = *(unsigned int *)(a1 + 84);
      do
      {
        if ((int)v62 >= 1)
        {
          v63 = 0;
          v64 = v236;
          v65 = v237 - v236;
          v66 = v61;
          v67 = v60;
          do
          {
            v68 = 0;
            v69 = v66;
            do
            {
              if (v65 <= v69)
                std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
              *(_WORD *)(v59 + 2 * (v67 + (int)v68++)) = v64[v69];
              v69 += 3 * v62;
            }
            while (v62 != v68);
            ++v63;
            v67 += v62;
            v66 += 3;
          }
          while (v63 != (_DWORD)v62);
        }
        ++v61;
        v60 += v62 * v62;
      }
      while (v61 != 3);
      v70 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (8 * v62 * v62));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 3096) = v70;
      v71 = *(unsigned int *)(a1 + 84);
      if ((int)v71 >= 8)
      {
        v72 = 0;
        v73 = 0;
        v74 = (v71 * v71);
        v75 = 2 * v74;
        v76 = v74 << 33;
        v77 = (float16x4_t *)v59;
        do
        {
          v78 = 0;
          v79 = v71;
          v80 = v76;
          v81 = v77;
          v82.i64[0] = 0x3F0000003F000000;
          v82.i64[1] = 0x3F0000003F000000;
          do
          {
            v83 = *(_OWORD *)(v59 + (v80 >> 31));
            v84 = *(float16x8_t *)(v59 + 2 * ((int)v74 + v78));
            v85 = *(float16x8_t *)(v59 + 2 * (v75 + v78));
            v86 = vcvtq_f32_f16(*v81);
            v87 = vcvt_hight_f32_f16(*(float16x8_t *)v81->i8);
            v88 = vcvtq_f32_f16(*(float16x4_t *)v84.i8);
            v89 = vcvt_hight_f32_f16(v84);
            v90 = vcvt_hight_f32_f16(v85);
            v91 = vcvtq_f32_f16(*(float16x4_t *)v85.i8);
            *(_OWORD *)(v70 + 2 * (int)v73) = *(_OWORD *)v81->i8;
            *(float16x8_t *)(v70 + (((v73 << 32) + 0x800000000) >> 31)) = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_f32(vaddq_f32(vaddq_f32(v86, v88), v91), v82)), vmulq_f32(vaddq_f32(vaddq_f32(v87, v89), v90), v82));
            v92 = ((v73 << 32) + 0x1000000000) >> 31;
            v93 = (v73 << 32) + 0x1800000000;
            *(float16x8_t *)(v70 + v92) = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_f32(vaddq_f32(vsubq_f32(v86, v88), v91), v82)), vmulq_f32(vaddq_f32(vsubq_f32(v87, v89), v90), v82));
            *(_OWORD *)(v70 + (v93 >> 31)) = v83;
            v73 = (v93 >> 32) + 8;
            v248 = v83;
            v81 = (float16x4_t *)((char *)v81 + 2 * v71);
            v78 += v71;
            v80 += v71 << 32;
            --v79;
          }
          while (v79);
          ++v72;
          v77 += 2;
          v75 += 8;
          LODWORD(v74) = v74 + 8;
          v76 += 0x800000000;
        }
        while (v72 != v71 >> 3);
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v59);
    }
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v99 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v99, (uint64_t)"/block/", 7);
    v100 = (_QWORD *)std::ostream::operator<<();
    v101 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v100, (uint64_t)"/first/conv1d/bias", 18);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v101, (uint64_t)"/npy", 4);
    v102 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v211);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v102 + 24))(v102, v211, &v244, &v236, 1);
    if (v212 < 0)
      heap_Free(*(_QWORD **)(v213 + 8), v211[0]);
    if (v237 == v236)
    {
      v108 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v108, (uint64_t)"[", 1);
      v109 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v109, (uint64_t)"][", 2);
      v110 = (_QWORD *)std::ostream::operator<<();
      v111 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v110, (uint64_t)"] first_conv1d_bias", 19);
      std::ios_base::getloc((const std::ios_base *)((char *)v111 + *(_QWORD *)(*v111 - 24)));
      v112 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v112->__vftable[2].~facet_0)(v112, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v103 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 3104) = v103;
      v104 = *(unsigned int *)(a1 + 84);
      if ((int)v104 >= 1)
      {
        v105 = v236;
        v106 = v237 - v236;
        while (v106)
        {
          v107 = *v105++;
          *v103++ = v107;
          --v106;
          if (!--v104)
            goto LABEL_84;
        }
        goto LABEL_158;
      }
    }
LABEL_84:
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v113 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v113, (uint64_t)"/block/", 7);
    v114 = (_QWORD *)std::ostream::operator<<();
    v115 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v114, (uint64_t)"/second/conv1d/weight", 21);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v115, (uint64_t)"/npy", 4);
    v116 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v208);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v116 + 24))(v116, v208, &v244, &v236, 1);
    if (v209 < 0)
      heap_Free(*(_QWORD **)(v210 + 8), v208[0]);
    if (v237 == v236)
    {
      v136 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v136, (uint64_t)"[", 1);
      v137 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v137, (uint64_t)"][", 2);
      v138 = (_QWORD *)std::ostream::operator<<();
      v139 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v138, (uint64_t)"] second_conv1d_weight", 22);
      std::ios_base::getloc((const std::ios_base *)((char *)v139 + *(_QWORD *)(*v139 - 24)));
      v140 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v140->__vftable[2].~facet_0)(v140, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v117 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      v118 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 3112) = v118;
      v119 = *(unsigned int *)(a1 + 84);
      if ((int)v119 >= 1)
      {
        v120 = 0;
        v121 = v236;
        v122 = v237 - v236;
        v123 = (_WORD *)v117;
        do
        {
          v124 = v119;
          v125 = v120;
          v126 = v123;
          do
          {
            if (v122 <= v125)
              std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
            *v126++ = v121[v125];
            v125 += v119;
            --v124;
          }
          while (v124);
          ++v120;
          v123 += v119;
        }
        while (v120 != v119);
        if ((int)v119 >= 8)
        {
          v127 = 0;
          v128 = 0;
          v129 = 0;
          do
          {
            v130 = 0;
            v131 = v127;
            do
            {
              v132 = 0;
              v133 = v131;
              do
              {
                v134 = 0;
                v135 = v129;
                do
                {
                  *(_WORD *)(v118 + 2 * v129 + 2 * v134) = *(_WORD *)(v117 + 2 * (v133 + (int)v134));
                  ++v134;
                }
                while (v134 != 8);
                ++v132;
                v133 += v119;
                v129 += 8;
              }
              while (v132 != 4);
              ++v130;
              v131 += 4 * v119;
              v129 = v135 + 8;
            }
            while (v130 != v119 >> 2);
            ++v128;
            v127 += 8;
            v129 = v135 + 8;
          }
          while (v128 != (int)v119 >> 3);
        }
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v117);
    }
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v141 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v141, (uint64_t)"/block/", 7);
    v142 = (_QWORD *)std::ostream::operator<<();
    v143 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v142, (uint64_t)"/second/conv1d/bias", 19);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v143, (uint64_t)"/npy", 4);
    v144 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v205);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v144 + 24))(v144, v205, &v244, &v236, 1);
    if (v206 < 0)
      heap_Free(*(_QWORD **)(v207 + 8), v205[0]);
    if (v237 == v236)
    {
      v150 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v150, (uint64_t)"[", 1);
      v151 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v151, (uint64_t)"][", 2);
      v152 = (_QWORD *)std::ostream::operator<<();
      v153 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v152, (uint64_t)"] second_conv1d_bias", 20);
      std::ios_base::getloc((const std::ios_base *)((char *)v153 + *(_QWORD *)(*v153 - 24)));
      v154 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v154->__vftable[2].~facet_0)(v154, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v145 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 3120) = v145;
      v146 = *(unsigned int *)(a1 + 84);
      if ((int)v146 >= 1)
      {
        v147 = v236;
        v148 = v237 - v236;
        while (v148)
        {
          v149 = *v147++;
          *v145++ = v149;
          --v148;
          if (!--v146)
            goto LABEL_117;
        }
        goto LABEL_158;
      }
    }
LABEL_117:
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v155 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v155, (uint64_t)"/shortcut/", 10);
    v156 = (_QWORD *)std::ostream::operator<<();
    v157 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v156, (uint64_t)"/conv1d/weight", 14);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v157, (uint64_t)"/npy", 4);
    v158 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v202);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v158 + 24))(v158, v202, &v244, &v236, 1);
    if (v203 < 0)
      heap_Free(*(_QWORD **)(v204 + 8), v202[0]);
    if (v237 == v236)
    {
      v178 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v178, (uint64_t)"[", 1);
      v179 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v179, (uint64_t)"][", 2);
      v180 = (_QWORD *)std::ostream::operator<<();
      v181 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v180, (uint64_t)"] shortcut conv1d_weight", 24);
      std::ios_base::getloc((const std::ios_base *)((char *)v181 + *(_QWORD *)(*v181 - 24)));
      v182 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v182->__vftable[2].~facet_0)(v182, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v159 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      v160 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 16 * j + 3224) = v160;
      v161 = *(unsigned int *)(a1 + 84);
      if ((int)v161 >= 1)
      {
        v162 = 0;
        v163 = v236;
        v164 = v237 - v236;
        v165 = (_WORD *)v159;
        do
        {
          v166 = v161;
          v167 = v162;
          v168 = v165;
          do
          {
            if (v164 <= v167)
              std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
            *v168++ = v163[v167];
            v167 += v161;
            --v166;
          }
          while (v166);
          ++v162;
          v165 += v161;
        }
        while (v162 != v161);
        if ((int)v161 >= 8)
        {
          v169 = 0;
          v170 = 0;
          v171 = 0;
          do
          {
            v172 = 0;
            v173 = v169;
            do
            {
              v174 = 0;
              v175 = v173;
              do
              {
                v176 = 0;
                v177 = v171;
                do
                {
                  *(_WORD *)(v160 + 2 * v171 + 2 * v176) = *(_WORD *)(v159 + 2 * (v175 + (int)v176));
                  ++v176;
                }
                while (v176 != 8);
                ++v174;
                v175 += v161;
                v171 += 8;
              }
              while (v174 != 4);
              ++v172;
              v173 += 4 * v161;
              v171 = v177 + 8;
            }
            while (v172 != v161 >> 2);
            ++v170;
            v169 += 8;
            v171 = v177 + 8;
          }
          while (v170 != (int)v161 >> 3);
        }
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v159);
    }
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v183 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v183, (uint64_t)"/shortcut/", 10);
    v184 = (_QWORD *)std::ostream::operator<<();
    v185 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v184, (uint64_t)"/conv1d/bias", 12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v185, (uint64_t)"/npy", 4);
    v186 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v199);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v186 + 24))(v186, v199, &v244, &v236, 1);
    if (v200 < 0)
      heap_Free(*(_QWORD **)(v201 + 8), v199[0]);
    if (v237 == v236)
    {
      v192 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v192, (uint64_t)"[", 1);
      v193 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v193, (uint64_t)"][", 2);
      v194 = (_QWORD *)std::ostream::operator<<();
      v195 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v194, (uint64_t)"] shortcut conv1d_bias", 22);
      std::ios_base::getloc((const std::ios_base *)((char *)v195 + *(_QWORD *)(*v195 - 24)));
      v196 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v196->__vftable[2].~facet_0)(v196, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v187 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 16 * j + 3232) = v187;
      v188 = *(unsigned int *)(a1 + 84);
      if ((int)v188 >= 1)
      {
        v189 = v236;
        v190 = v237 - v236;
        while (v190)
        {
          v191 = *v189++;
          *v187++ = v191;
          --v190;
          if (!--v188)
            goto LABEL_150;
        }
        goto LABEL_158;
      }
    }
LABEL_150:
    ;
  }
  v230.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v231 = &unk_24D29B3B0;
  v235 = &unk_24D29B3D8;
  v232[0] = &unk_24D29B578;
  if (v233 < 0)
    heap_Free(*(_QWORD **)(v234 + 8), v232[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v235);
  v230.__locale_ = (std::locale::__imp *)&v236;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v230);
  v230.__locale_ = (std::locale::__imp *)&v240;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v230);
  v230.__locale_ = (std::locale::__imp *)&v244;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v230);
  return 1;
}

void sub_214EAE598(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t *mc_SecondBlock_do_inference(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  long double v11;
  uint64_t v12;
  int conv_input_shift_by_rows;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t *result;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t *v32;
  _QWORD *v33;
  unint64_t v34;
  uint64_t *v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  unint64_t v50;
  uint64_t *v51;
  _QWORD *v52;
  _QWORD *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  _QWORD *v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _QWORD *v75;
  _QWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  _QWORD *v82;
  _QWORD *v83;
  _QWORD *v84;
  uint64_t v85;
  _QWORD *v86;

  v4 = *(_QWORD *)(a1 + 144);
  SplitMELManager::neon_transpose_rows(a1, *(_QWORD *)(v4 + 3080), *(float16x8_t **)(v4 + 2776), *(_QWORD *)(v4 + 2792), *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 84), *(_DWORD *)(v4 + 4088), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 88), *(_DWORD *)(a1 + 92), a2, *(_DWORD *)(v4 + 2308));
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
  v6 = *(_QWORD *)(a1 + 144);
  SplitMELManager::neon_transpose_rearrange_rows_1(v5, *(_QWORD *)(v6 + 2792), *(_QWORD *)(v6 + 2800), *(_QWORD *)(v6 + 3088), *(_DWORD *)(a1 + 84), *(_DWORD *)(v6 + 4088), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 92), a2, *(_DWORD *)(v6 + 2308));
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
  SplitMELManager::neon_block_input(v7, *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2800), *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2816), *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2808), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 84), a2, *(_DWORD *)(*(_QWORD *)(a1 + 144) + 2308));
  (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
  v8 = 0;
  v9 = 3096;
  v10 = 3224;
  do
  {
    v11 = pow(3.0, (double)v8);
    *(_DWORD *)(a1 + 104) = (int)v11;
    *(_DWORD *)(a1 + 108) = (int)v11;
    conv_input_shift_by_rows = SplitMELManager::neon_first_conv_input_shift_by_rows(a1, *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2808), *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2784), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 84), v12, (int)v11, 6 * (int)v11, a2, *(_DWORD *)(*(_QWORD *)(a1 + 144) + 2308));
    v14 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
    v15 = *(_QWORD *)(a1 + 144);
    SplitMELManager::neon_first_conv_cols(v14, *(_QWORD *)(v15 + v9), *(_QWORD *)(v15 + v9 + 8), *(_QWORD *)(v15 + 2784), *(_QWORD *)(v15 + 2824), v16, *(_DWORD *)(a1 + 108), *(_DWORD *)(a1 + 84), 4 * conv_input_shift_by_rows * *(_DWORD *)(a1 + 108), a2, *(_DWORD *)(v15 + 2308));
    v17 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
    v18 = *(_QWORD *)(a1 + 144);
    SplitMELManager::neon_conv_single_kernel_cols(v17, *(_QWORD *)(v18 + v9 + 16), *(_QWORD *)(v18 + v9 + 24), *(float16x4_t **)(v18 + 2824), *(_QWORD *)(v18 + 2832), *(_DWORD *)(a1 + 84), *(_DWORD *)(a1 + 184), a2, *(_DWORD *)(v18 + 2308));
    v19 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
    v20 = *(_QWORD *)(a1 + 144);
    SplitMELManager::neon_conv_single_kernel_cols(v19, *(_QWORD *)(v20 + v10), *(_QWORD *)(v20 + v10 + 8), *(float16x4_t **)(v20 + 2816), *(_QWORD *)(v20 + 2824), *(_DWORD *)(a1 + 84), *(_DWORD *)(a1 + 184), a2, *(_DWORD *)(v20 + 2308));
    v21 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
    v22 = *(_QWORD *)(a1 + 144);
    if (v9 == 3192)
    {
      v23 = *(_QWORD *)(v22 + 2832);
      v24 = *(_QWORD *)(v22 + 2824);
      v25 = *(_DWORD *)(a1 + 184);
      v26 = *(_DWORD *)(a1 + 84);
      v27 = *(_DWORD *)(v22 + 2308);
      if (*(_BYTE *)(v22 + 3499))
        SplitMELManager::neon_add_signals_loop_relu(v21, v23, v24, *(_QWORD *)(v22 + 2776), v25, v26, a2, v27);
      else
        SplitMELManager::neon_add_signals_relu_colums(v21, v23, v24, *(_QWORD *)(v22 + 2848), v25, v26, a2, v27);
    }
    else
    {
      SplitMELManager::neon_add_signals(v21, *(_QWORD *)(v22 + 2832), *(_QWORD *)(v22 + 2824), *(_QWORD *)(v22 + 2816), *(_QWORD *)(v22 + 2808), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 84), a2, *(_DWORD *)(v22 + 2308));
    }
    result = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
    v9 += 32;
    v10 += 16;
    ++v8;
  }
  while (v9 != 3224);
  if (!a2)
  {
    v29 = *(_DWORD *)(a1 + 184);
    v30 = *(_QWORD *)(a1 + 144);
    *(_DWORD *)(v30 + 4088) = v29;
    if (!*(_BYTE *)(v30 + 3499))
    {
      v31 = v29 - 4 * *(_DWORD *)(a1 + 188);
      *(_DWORD *)(v30 + 4088) = v31;
      v32 = *(uint64_t **)(a1 + 216);
      v33 = (_QWORD *)v32[1];
      v34 = v32[2];
      if ((unint64_t)v33 >= v34)
      {
        v37 = (_QWORD *)*v32;
        v38 = ((uint64_t)v33 - *v32) >> 3;
        v39 = v38 + 1;
        if ((unint64_t)(v38 + 1) >> 61)
          goto LABEL_63;
        v40 = v34 - (_QWORD)v37;
        if (v40 >> 2 > v39)
          v39 = v40 >> 2;
        if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8)
          v41 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v41 = v39;
        v86 = v32 + 3;
        if (v41)
        {
          v42 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v32 + 3), v41);
          v37 = (_QWORD *)*v32;
          v33 = (_QWORD *)v32[1];
        }
        else
        {
          v42 = 0;
        }
        v43 = (_QWORD *)(v42 + 8 * v38);
        *v43 = 1;
        if (v33 == v37)
        {
          v45 = v42 + 8 * v38;
        }
        else
        {
          v44 = v33;
          v45 = v42 + 8 * v38;
          do
          {
            v46 = *--v44;
            *(_QWORD *)(v45 - 8) = v46;
            v45 -= 8;
          }
          while (v44 != v37);
        }
        v36 = v43 + 1;
        *v32 = v45;
        v82 = v37;
        v83 = v37;
        v32[1] = (uint64_t)(v43 + 1);
        v84 = v33;
        v47 = v32[2];
        v32[2] = v42 + 8 * v41;
        v85 = v47;
        std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v82);
        v35 = *(uint64_t **)(a1 + 216);
        v31 = *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4088);
      }
      else
      {
        *v33 = 1;
        v35 = v32;
        v36 = v33 + 1;
      }
      v32[1] = (uint64_t)v36;
      v48 = v31;
      v49 = (_QWORD *)v35[1];
      v50 = v35[2];
      if ((unint64_t)v49 >= v50)
      {
        v53 = (_QWORD *)*v35;
        v54 = ((uint64_t)v49 - *v35) >> 3;
        v55 = v54 + 1;
        if ((unint64_t)(v54 + 1) >> 61)
          std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
        v56 = v50 - (_QWORD)v53;
        if (v56 >> 2 > v55)
          v55 = v56 >> 2;
        if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF8)
          v57 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v57 = v55;
        v86 = v35 + 3;
        if (v57)
        {
          v58 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v35 + 3), v57);
          v53 = (_QWORD *)*v35;
          v49 = (_QWORD *)v35[1];
        }
        else
        {
          v58 = 0;
        }
        v59 = (_QWORD *)(v58 + 8 * v54);
        *v59 = v48;
        if (v49 == v53)
        {
          v61 = v58 + 8 * v54;
        }
        else
        {
          v60 = v49;
          v61 = v58 + 8 * v54;
          do
          {
            v62 = *--v60;
            *(_QWORD *)(v61 - 8) = v62;
            v61 -= 8;
          }
          while (v60 != v53);
        }
        v52 = v59 + 1;
        *v35 = v61;
        v82 = v53;
        v83 = v53;
        v35[1] = (uint64_t)(v59 + 1);
        v84 = v49;
        v63 = v35[2];
        v35[2] = v58 + 8 * v57;
        v85 = v63;
        std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v82);
        v51 = *(uint64_t **)(a1 + 216);
      }
      else
      {
        *v49 = v31;
        v51 = v35;
        v52 = v49 + 1;
      }
      v35[1] = (uint64_t)v52;
      v64 = *(_DWORD *)(a1 + 84);
      v65 = v64;
      v66 = (_QWORD *)v51[1];
      v67 = v51[2];
      if ((unint64_t)v66 < v67)
      {
        *v66 = v64;
        v68 = v66 + 1;
LABEL_61:
        v51[1] = (uint64_t)v68;
        v80 = *(_QWORD *)(a1 + 144);
        v81 = *(int *)(v80 + 4088) * (uint64_t)v64;
        result = std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(*(uint64_t **)(a1 + 208), *(char **)(v80 + 2848), *(_QWORD *)(v80 + 2848) + 4 * v81, v81);
        *(_DWORD *)(a1 + 188) = 0;
        return result;
      }
      v69 = (_QWORD *)*v51;
      v70 = ((uint64_t)v66 - *v51) >> 3;
      v71 = v70 + 1;
      if (!((unint64_t)(v70 + 1) >> 61))
      {
        v72 = v67 - (_QWORD)v69;
        if (v72 >> 2 > v71)
          v71 = v72 >> 2;
        if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8)
          v73 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v73 = v71;
        v86 = v51 + 3;
        if (v73)
        {
          v74 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v51 + 3), v73);
          v69 = (_QWORD *)*v51;
          v66 = (_QWORD *)v51[1];
        }
        else
        {
          v74 = 0;
        }
        v75 = (_QWORD *)(v74 + 8 * v70);
        *v75 = v65;
        if (v66 == v69)
        {
          v77 = v74 + 8 * v70;
        }
        else
        {
          v76 = v66;
          v77 = v74 + 8 * v70;
          do
          {
            v78 = *--v76;
            *(_QWORD *)(v77 - 8) = v78;
            v77 -= 8;
          }
          while (v76 != v69);
        }
        v68 = v75 + 1;
        *v51 = v77;
        v82 = v69;
        v83 = v69;
        v51[1] = (uint64_t)(v75 + 1);
        v84 = v66;
        v79 = v51[2];
        v51[2] = v74 + 8 * v73;
        v85 = v79;
        std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v82);
        v64 = *(_DWORD *)(a1 + 84);
        goto LABEL_61;
      }
LABEL_63:
      std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
    }
  }
  return result;
}

_QWORD *NeonSecondBlockMelManager::NeonSecondBlockMelManager(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  uint64_t v5;
  NeonMELContainer *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  std::locale v10;

  a1[19] = 0;
  v4 = a1 + 19;
  a1[1] = 0;
  a1[2] = 0;
  a1[14] = 0;
  a1[15] = 0;
  v5 = CustomAllocator::mRsrc;
  a1[16] = 0;
  a1[17] = v5;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = v5;
  a1[28] = 0;
  a1[29] = 0;
  a1[18] = a2;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 28, a3);
  v6 = (NeonMELContainer *)*(v4 - 1);
  *((_BYTE *)v6 + 3498) = 0;
  if (*((_BYTE *)v6 + 2304)
    && (NeonMELContainer::EngineMCSetUp(v6, a1, 2, (void (*)(void *, int))mc_SecondBlock_do_inference) & 1) == 0)
  {
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"WARNING: error set up multi-core engine", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v10, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v10);
    std::ostream::put();
    std::ostream::flush();
  }
  return a1;
}

void sub_214EAEE88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  SplitMELManager *v10;
  uint64_t v11;
  uint64_t v12;

  std::locale::~locale(&a10);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v12);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v11);
  SplitMELManager::~SplitMELManager(v10);
  _Unwind_Resume(a1);
}

void NeonSecondBlockMelManager::~NeonSecondBlockMelManager(NeonSecondBlockMelManager *this)
{
  char *v2;
  uint64_t v3;
  uint64_t i;

  v2 = (char *)this + 224;
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 3080));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 3088));
  v3 = 3096;
  for (i = 3224; i != 3288; i += 16)
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3 + 8));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3 + 16));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3 + 24));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + i));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + i + 8));
    v3 += 32;
  }
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  if (*((char *)this + 175) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 22) + 8), *((_QWORD *)this + 19));
  if (*((char *)this + 135) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 17) + 8), *((_QWORD *)this + 14));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

void SplitMELManager::neon_transpose_rearrange_rows_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, int a8, int a9, unsigned int a10)
{
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  float16x8_t v20;
  int v21;
  float16x8_t *v22;
  float16x8_t v23;
  float16x8_t v24;
  uint64_t v25;
  uint64_t v26;
  float16x8_t v27;
  uint64_t v28;
  float16x8_t v29;
  float16x8_t *v30;
  float16x8_t *v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t *v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  float16x8_t *v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  float16x8_t *v50;
  float16x8_t *v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t *v56;
  float16x8_t *v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t *v60;

  v10 = (a5 >> 3) / a10;
  v11 = v10 * a9;
  v12 = v10 * a9 + v10;
  if (v11 < v11 + v10)
  {
    v13 = a7 >> 2;
    v14 = a7 >> 2 << 6;
    LODWORD(v15) = a6 >> 2;
    v16 = a8 << 6;
    v17 = (a6 >> 2) * a8;
    v18 = ((a7 >> 2) * a9 * v10) << 6;
    v19 = v18 + (a8 << 6);
    if (a6 >> 2 <= 2)
      v15 = 2;
    else
      v15 = v15;
    do
    {
      v20 = *(float16x8_t *)(a4 + 2 * (int)(8 * v11));
      v21 = v14 * v11;
      v22 = (float16x8_t *)(a2 + 2 * (int)(v14 * v11));
      v24 = v22[2];
      v23 = v22[3];
      if (a8 == 1)
      {
        v29 = 0uLL;
        v27 = 0uLL;
      }
      else
      {
        v25 = 0;
        v26 = v18;
        v27 = 0uLL;
        v28 = (a8 - 1);
        v29 = 0uLL;
        do
        {
          v30 = (float16x8_t *)(a2 + 2 * v26);
          v26 += 32;
          v31 = (float16x8_t *)(a2 + 2 * v26);
          v32 = *v31;
          v33 = v31[1];
          v34 = v30[16];
          v35 = v30[17];
          v36 = (float16x8_t *)(a3 + 2 * (int)(32 * (v13 * v11 + v25)));
          *v36 = vaddq_f16(v20, vaddq_f16(v27, v24));
          v36[1] = vaddq_f16(v20, vaddq_f16(v29, v23));
          v36[2] = vaddq_f16(v20, vaddq_f16(v32, v34));
          v36[3] = vaddq_f16(v20, vaddq_f16(v33, v35));
          v27 = v30[18];
          v29 = v30[19];
          ++v25;
          v24 = v31[2];
          v23 = v31[3];
          --v28;
        }
        while (v28);
      }
      v37 = v13 * v11;
      if (a6 >= 8)
      {
        v38 = 1;
        v39 = v19;
        do
        {
          v40 = v37 + v38 * a8;
          v41 = (float16x8_t *)(a2 + 2 * (v21 + v16 * (int)v38));
          v42 = *v41;
          v43 = v41[1];
          v44 = v41[-4];
          v45 = v41[-3];
          v46 = (float16x8_t *)(a3 + 2 * (32 * v40 - 32));
          *v46 = vaddq_f16(v20, vaddq_f16(v27, v24));
          v46[1] = vaddq_f16(v20, vaddq_f16(v29, v23));
          v46[2] = vaddq_f16(v20, vaddq_f16(v42, v44));
          v46[3] = vaddq_f16(v20, vaddq_f16(v43, v45));
          v24 = v41[2];
          v23 = v41[3];
          v27 = v41[-2];
          v29 = v41[-1];
          if (a8 != 1)
          {
            v47 = 0;
            v48 = v39;
            v49 = (a8 - 1);
            do
            {
              v50 = (float16x8_t *)(a2 + 2 * v48);
              v48 += 32;
              v51 = (float16x8_t *)(a2 + 2 * v48);
              v52 = *v51;
              v53 = v51[1];
              v54 = v50[16];
              v55 = v50[17];
              v56 = (float16x8_t *)(a3 + 64 * (v40 + (int)v47));
              *v56 = vaddq_f16(v20, vaddq_f16(v24, v27));
              v56[1] = vaddq_f16(v20, vaddq_f16(v23, v29));
              v56[2] = vaddq_f16(v20, vaddq_f16(v52, v54));
              v56[3] = vaddq_f16(v20, vaddq_f16(v53, v55));
              ++v47;
              v24 = v51[2];
              v23 = v51[3];
              v27 = v50[18];
              v29 = v50[19];
              --v49;
            }
            while (v49);
          }
          ++v38;
          v39 += v16;
        }
        while (v38 != v15);
      }
      v57 = (float16x8_t *)(a2 + 2 * ((v17 << 6) - 32 + v21));
      v58 = *v57;
      v59 = v57[1];
      v60 = (float16x8_t *)(a3 + 2 * (32 * (v37 + v17) - 32));
      *v60 = vaddq_f16(v20, vaddq_f16(v27, v24));
      v60[1] = vaddq_f16(v20, vaddq_f16(v29, v23));
      v60[2] = vaddq_f16(v20, vaddq_f16(v58, (float16x8_t)0));
      v60[3] = vaddq_f16(v20, vaddq_f16(v59, (float16x8_t)0));
      ++v11;
      v18 += v14;
      v19 += v14;
    }
    while (v12 > v11);
  }
}

void NeonSecondBlockMelManager::do_inference(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  unint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  _DWORD *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  unint64_t v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _DWORD *v50;
  _DWORD *v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t i;
  long double v65;
  uint64_t v66;
  uint64_t conv_input_shift_by_rows;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  uint64_t v82;
  int v83;
  _QWORD *v84;
  unint64_t v85;
  _QWORD *v86;
  _QWORD *v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  _QWORD *v93;
  _QWORD *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  _QWORD *v99;
  _QWORD *v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  _QWORD *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  uint64_t v112;
  _QWORD *v113;
  _QWORD *v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  _QWORD *v120;
  _QWORD *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v129;
  uint64_t v130;
  _QWORD *v131;
  uint64_t v132;
  uint64_t *v133;

  v5 = a5;
  v6 = a4;
  v9 = a1;
  v10 = *(_QWORD *)(a1 + 144);
  if (*(_BYTE *)(v10 + 2304))
  {
    *(_QWORD *)(a1 + 192) = a2;
    *(_QWORD *)(a1 + 200) = a3;
    *(_QWORD *)(a1 + 208) = a4;
    *(_QWORD *)(a1 + 216) = a5;
    if (*(_BYTE *)(v10 + 3497))
    {
      *(_DWORD *)(a1 + 188) = 0;
LABEL_67:
      *(_OWORD *)(v9 + 80) = xmmword_214FBF8A0;
      *(_QWORD *)(v9 + 96) = 0x200000000;
      *(_DWORD *)(v9 + 184) = 4 * *(_DWORD *)(v10 + 4088);
      SynchroManager::cond_broadcast_on_entry((SynchroManager *)(v10 + 2312), *(_DWORD *)(v10 + 2308), 3);
      SynchroManager::cond_wait_less_on_exit((SynchroManager *)(*(_QWORD *)(v9 + 144) + 2312), *(_DWORD *)(*(_QWORD *)(v9 + 144) + 2308));
      return;
    }
    if (a3[1] - *a3 > 8uLL)
    {
      v11 = *(_DWORD *)(*a3 + 8);
      *(_DWORD *)(v10 + 4088) = v11;
      v12 = -v11 < 0;
      v13 = -v11 & 3;
      v14 = v11 & 3;
      if (!v12)
        v14 = -v13;
      if (v14)
      {
        v15 = 0;
        *(_DWORD *)(a1 + 188) = 4 - v14;
        v16 = *a3;
        v17 = a3[1];
        while (1)
        {
          if ((unint64_t)(v17 - v16) < 0x11)
            goto LABEL_131;
          if (*(_QWORD *)(v16 + 16))
            break;
LABEL_33:
          ++v15;
          v33 = *(_DWORD *)(v9 + 188);
          if (v15 >= v33)
          {
            v10 = *(_QWORD *)(v9 + 144);
            goto LABEL_65;
          }
        }
        v18 = 0;
        while (1)
        {
          v19 = (_DWORD *)a2[1];
          v20 = a2[2];
          if ((unint64_t)v19 >= v20)
          {
            v22 = *a2;
            v23 = ((uint64_t)v19 - *a2) >> 2;
            v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 62)
              goto LABEL_132;
            v25 = v20 - v22;
            if (v25 >> 1 > v24)
              v24 = v25 >> 1;
            v26 = (unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v24;
            v133 = a2 + 3;
            if (v26)
            {
              v27 = ENTTS::Allocator<int>::allocate((uint64_t)(a2 + 3), v26);
              v22 = *a2;
              v19 = (_DWORD *)a2[1];
            }
            else
            {
              v27 = 0;
            }
            v28 = (_DWORD *)(v27 + 4 * v23);
            *v28 = 0;
            if (v19 == (_DWORD *)v22)
            {
              v30 = v27 + 4 * v23;
            }
            else
            {
              v29 = v19;
              v30 = v27 + 4 * v23;
              do
              {
                v31 = *--v29;
                *(_DWORD *)(v30 - 4) = v31;
                v30 -= 4;
              }
              while (v29 != (_DWORD *)v22);
            }
            v21 = v28 + 1;
            *a2 = v30;
            a2[1] = (uint64_t)(v28 + 1);
            v32 = a2[2];
            a2[2] = v27 + 4 * v26;
            v131 = v19;
            v132 = v32;
            v129 = v22;
            v130 = v22;
            a1 = std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&v129);
            v16 = *a3;
            v17 = a3[1];
          }
          else
          {
            *v19 = 0;
            v21 = v19 + 1;
          }
          a2[1] = (uint64_t)v21;
          if ((unint64_t)(v17 - v16) <= 0x10)
            break;
          if (*(_QWORD *)(v16 + 16) <= (unint64_t)++v18)
            goto LABEL_33;
        }
      }
      else
      {
        v33 = 0;
        *(_DWORD *)(a1 + 188) = 0;
        v16 = *a3;
        v17 = a3[1];
LABEL_65:
        v56 = *(_DWORD *)(v10 + 4088) + v33;
        *(_DWORD *)(v10 + 4088) = v56;
        if ((unint64_t)(v17 - v16) > 0x10)
        {
          SplitMELManager::neon_convert_f2h_column(a1, *a2, *(_QWORD *)(v10 + 2776), *(_DWORD *)(v16 + 16), v56);
          v10 = *(_QWORD *)(v9 + 144);
          goto LABEL_67;
        }
      }
    }
    goto LABEL_131;
  }
  if (*(_BYTE *)(v10 + 3497))
  {
    *(_DWORD *)(a1 + 188) = 0;
  }
  else
  {
    if (a3[1] - *a3 <= 8uLL)
      goto LABEL_131;
    v34 = *(_DWORD *)(*a3 + 8);
    *(_DWORD *)(v10 + 4088) = v34;
    v12 = -v34 < 0;
    v35 = -v34 & 3;
    v36 = v34 & 3;
    if (!v12)
      v36 = -v35;
    if (v36)
    {
      v37 = 0;
      *(_DWORD *)(a1 + 188) = 4 - v36;
      v38 = *a3;
      v39 = a3[1];
      while (1)
      {
        if ((unint64_t)(v39 - v38) < 0x11)
          goto LABEL_131;
        if (*(_QWORD *)(v38 + 16))
          break;
LABEL_62:
        ++v37;
        v55 = *(_DWORD *)(v9 + 188);
        if (v37 >= v55)
        {
          v10 = *(_QWORD *)(v9 + 144);
          v6 = a4;
          v5 = a5;
          goto LABEL_69;
        }
      }
      v40 = 0;
      while (1)
      {
        v41 = (_DWORD *)a2[1];
        v42 = a2[2];
        if ((unint64_t)v41 >= v42)
        {
          v44 = *a2;
          v45 = ((uint64_t)v41 - *a2) >> 2;
          v46 = v45 + 1;
          if ((unint64_t)(v45 + 1) >> 62)
LABEL_132:
            std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
          v47 = v42 - v44;
          if (v47 >> 1 > v46)
            v46 = v47 >> 1;
          v48 = (unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v46;
          v133 = a2 + 3;
          if (v48)
          {
            v49 = ENTTS::Allocator<int>::allocate((uint64_t)(a2 + 3), v48);
            v44 = *a2;
            v41 = (_DWORD *)a2[1];
          }
          else
          {
            v49 = 0;
          }
          v50 = (_DWORD *)(v49 + 4 * v45);
          *v50 = 0;
          if (v41 == (_DWORD *)v44)
          {
            v52 = v49 + 4 * v45;
          }
          else
          {
            v51 = v41;
            v52 = v49 + 4 * v45;
            do
            {
              v53 = *--v51;
              *(_DWORD *)(v52 - 4) = v53;
              v52 -= 4;
            }
            while (v51 != (_DWORD *)v44);
          }
          v43 = v50 + 1;
          *a2 = v52;
          a2[1] = (uint64_t)(v50 + 1);
          v54 = a2[2];
          a2[2] = v49 + 4 * v48;
          v131 = v41;
          v132 = v54;
          v129 = v44;
          v130 = v44;
          a1 = std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&v129);
          v38 = *a3;
          v39 = a3[1];
        }
        else
        {
          *v41 = 0;
          v43 = v41 + 1;
        }
        a2[1] = (uint64_t)v43;
        if ((unint64_t)(v39 - v38) <= 0x10)
          goto LABEL_131;
        if (*(_QWORD *)(v38 + 16) <= (unint64_t)++v40)
          goto LABEL_62;
      }
    }
    v55 = 0;
    *(_DWORD *)(a1 + 188) = 0;
    v38 = *a3;
    v39 = a3[1];
LABEL_69:
    v57 = *(_DWORD *)(v10 + 4088) + v55;
    *(_DWORD *)(v10 + 4088) = v57;
    if ((unint64_t)(v39 - v38) <= 0x10)
LABEL_131:
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    SplitMELManager::neon_convert_f2h_column(a1, *a2, *(_QWORD *)(v10 + 2776), *(_DWORD *)(v38 + 16), v57);
    v10 = *(_QWORD *)(v9 + 144);
  }
  *(_OWORD *)(v9 + 80) = xmmword_214FBF8A0;
  *(_QWORD *)(v9 + 96) = 0x200000000;
  v58 = *(_DWORD *)(v10 + 4088);
  *(_DWORD *)(v9 + 184) = 4 * v58;
  SplitMELManager::neon_transpose_rows(a1, *(_QWORD *)(v10 + 3080), *(float16x8_t **)(v10 + 2776), *(_QWORD *)(v10 + 2792), 0xC0u, 0x60u, v58, 4 * v58, 8, 4, 0, *(_DWORD *)(v10 + 2308));
  v59 = *(_QWORD *)(v9 + 144);
  SplitMELManager::neon_transpose_rearrange_rows_1(v60, *(_QWORD *)(v59 + 2792), *(_QWORD *)(v59 + 2800), *(_QWORD *)(v59 + 3088), *(_DWORD *)(v9 + 84), *(_DWORD *)(v59 + 4088), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 92), 0, *(_DWORD *)(v59 + 2308));
  SplitMELManager::neon_block_input(v61, *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2800), *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2816), *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2808), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 84), 0, *(_DWORD *)(*(_QWORD *)(v9 + 144) + 2308));
  v62 = 0;
  v63 = 3096;
  for (i = 3224; ; i += 16)
  {
    v65 = pow(3.0, (double)v62);
    *(_DWORD *)(v9 + 104) = (int)v65;
    *(_DWORD *)(v9 + 108) = (int)v65;
    conv_input_shift_by_rows = SplitMELManager::neon_first_conv_input_shift_by_rows(v9, *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2808), *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2784), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 84), v66, (int)v65, 6 * (int)v65, 0, *(_DWORD *)(*(_QWORD *)(v9 + 144) + 2308));
    v68 = *(_QWORD *)(v9 + 144);
    SplitMELManager::neon_first_conv_cols(conv_input_shift_by_rows, *(_QWORD *)(v68 + v63), *(_QWORD *)(v68 + v63 + 8), *(_QWORD *)(v68 + 2784), *(_QWORD *)(v68 + 2824), v69, *(_DWORD *)(v9 + 108), *(_DWORD *)(v9 + 84), 4 * conv_input_shift_by_rows * *(_DWORD *)(v9 + 108), 0, *(_DWORD *)(v68 + 2308));
    v70 = *(_QWORD *)(v9 + 144);
    SplitMELManager::neon_conv_single_kernel_cols(v71, *(_QWORD *)(v70 + v63 + 16), *(_QWORD *)(v70 + v63 + 24), *(float16x4_t **)(v70 + 2824), *(_QWORD *)(v70 + 2832), *(_DWORD *)(v9 + 84), *(_DWORD *)(v9 + 184), 0, *(_DWORD *)(v70 + 2308));
    v72 = *(_QWORD *)(v9 + 144);
    SplitMELManager::neon_conv_single_kernel_cols(v73, *(_QWORD *)(v72 + i), *(_QWORD *)(v72 + i + 8), *(float16x4_t **)(v72 + 2816), *(_QWORD *)(v72 + 2824), *(_DWORD *)(v9 + 84), *(_DWORD *)(v9 + 184), 0, *(_DWORD *)(v72 + 2308));
    v75 = *(_QWORD *)(v9 + 144);
    if (v63 == 3192)
      break;
    SplitMELManager::neon_add_signals(v74, *(_QWORD *)(v75 + 2832), *(_QWORD *)(v75 + 2824), *(_QWORD *)(v75 + 2816), *(_QWORD *)(v75 + 2808), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 84), 0, *(_DWORD *)(v75 + 2308));
    v63 += 32;
    ++v62;
  }
  v76 = *(_QWORD *)(v75 + 2832);
  v77 = *(_QWORD *)(v75 + 2824);
  v78 = *(_DWORD *)(v9 + 184);
  v79 = *(_DWORD *)(v9 + 84);
  v80 = *(_DWORD *)(v75 + 2308);
  if (*(_BYTE *)(v75 + 3499))
    SplitMELManager::neon_add_signals_loop_relu(v74, v76, v77, *(_QWORD *)(v75 + 2776), v78, v79, 0, v80);
  else
    SplitMELManager::neon_add_signals_relu_colums(v74, v76, v77, *(_QWORD *)(v75 + 2848), v78, v79, 0, v80);
  v81 = *(_DWORD *)(v9 + 184);
  v82 = *(_QWORD *)(v9 + 144);
  *(_DWORD *)(v82 + 4088) = v81;
  if (!*(_BYTE *)(v82 + 3499))
  {
    v83 = v81 - 4 * *(_DWORD *)(v9 + 188);
    *(_DWORD *)(v82 + 4088) = v83;
    v84 = (_QWORD *)v5[1];
    v85 = v5[2];
    if ((unint64_t)v84 >= v85)
    {
      v87 = (_QWORD *)*v5;
      v88 = ((uint64_t)v84 - *v5) >> 3;
      v89 = v88 + 1;
      if ((unint64_t)(v88 + 1) >> 61)
        goto LABEL_133;
      v90 = v85 - (_QWORD)v87;
      if (v90 >> 2 > v89)
        v89 = v90 >> 2;
      if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFF8)
        v91 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v91 = v89;
      v133 = v5 + 3;
      if (v91)
      {
        v92 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v91);
        v87 = (_QWORD *)*v5;
        v84 = (_QWORD *)v5[1];
      }
      else
      {
        v92 = 0;
      }
      v93 = (_QWORD *)(v92 + 8 * v88);
      *v93 = 1;
      if (v84 == v87)
      {
        v95 = v92 + 8 * v88;
      }
      else
      {
        v94 = v84;
        v95 = v92 + 8 * v88;
        do
        {
          v96 = *--v94;
          *(_QWORD *)(v95 - 8) = v96;
          v95 -= 8;
        }
        while (v94 != v87);
      }
      v86 = v93 + 1;
      *v5 = v95;
      v5[1] = (uint64_t)(v93 + 1);
      v97 = v5[2];
      v5[2] = v92 + 8 * v91;
      v131 = v84;
      v132 = v97;
      v129 = (uint64_t)v87;
      v130 = (uint64_t)v87;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v129);
      v83 = *(_DWORD *)(*(_QWORD *)(v9 + 144) + 4088);
      v85 = v5[2];
    }
    else
    {
      *v84 = 1;
      v86 = v84 + 1;
    }
    v5[1] = (uint64_t)v86;
    v98 = v83;
    if ((unint64_t)v86 >= v85)
    {
      v100 = (_QWORD *)*v5;
      v101 = ((uint64_t)v86 - *v5) >> 3;
      v102 = v101 + 1;
      if ((unint64_t)(v101 + 1) >> 61)
        goto LABEL_133;
      v103 = v85 - (_QWORD)v100;
      if (v103 >> 2 > v102)
        v102 = v103 >> 2;
      if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF8)
        v104 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v104 = v102;
      v133 = v5 + 3;
      if (v104)
      {
        v105 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v104);
        v100 = (_QWORD *)*v5;
        v86 = (_QWORD *)v5[1];
      }
      else
      {
        v105 = 0;
      }
      v106 = (_QWORD *)(v105 + 8 * v101);
      *v106 = v98;
      if (v86 == v100)
      {
        v108 = v105 + 8 * v101;
      }
      else
      {
        v107 = v86;
        v108 = v105 + 8 * v101;
        do
        {
          v109 = *--v107;
          *(_QWORD *)(v108 - 8) = v109;
          v108 -= 8;
        }
        while (v107 != v100);
      }
      v99 = v106 + 1;
      *v5 = v108;
      v5[1] = (uint64_t)(v106 + 1);
      v110 = v5[2];
      v5[2] = v105 + 8 * v104;
      v131 = v86;
      v132 = v110;
      v129 = (uint64_t)v100;
      v130 = (uint64_t)v100;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v129);
      v85 = v5[2];
    }
    else
    {
      *v86 = v83;
      v99 = v86 + 1;
    }
    v5[1] = (uint64_t)v99;
    v111 = *(_DWORD *)(v9 + 84);
    v112 = v111;
    if ((unint64_t)v99 < v85)
    {
      *v99 = v111;
      v113 = v99 + 1;
LABEL_129:
      v5[1] = (uint64_t)v113;
      v125 = *(_QWORD *)(v9 + 144);
      v126 = *(int *)(v125 + 4088) * (uint64_t)v111;
      std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(v6, *(char **)(v125 + 2848), *(_QWORD *)(v125 + 2848) + 4 * v126, v126);
      *(_DWORD *)(v9 + 188) = 0;
      return;
    }
    v114 = (_QWORD *)*v5;
    v115 = ((uint64_t)v99 - *v5) >> 3;
    v116 = v115 + 1;
    if (!((unint64_t)(v115 + 1) >> 61))
    {
      v117 = v85 - (_QWORD)v114;
      if (v117 >> 2 > v116)
        v116 = v117 >> 2;
      if ((unint64_t)v117 >= 0x7FFFFFFFFFFFFFF8)
        v118 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v118 = v116;
      v133 = v5 + 3;
      if (v118)
      {
        v119 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v118);
        v114 = (_QWORD *)*v5;
        v99 = (_QWORD *)v5[1];
      }
      else
      {
        v119 = 0;
      }
      v120 = (_QWORD *)(v119 + 8 * v115);
      *v120 = v112;
      if (v99 == v114)
      {
        v122 = v119 + 8 * v115;
      }
      else
      {
        v121 = v99;
        v122 = v119 + 8 * v115;
        do
        {
          v123 = *--v121;
          *(_QWORD *)(v122 - 8) = v123;
          v122 -= 8;
        }
        while (v121 != v114);
      }
      v113 = v120 + 1;
      *v5 = v122;
      v5[1] = (uint64_t)(v120 + 1);
      v124 = v5[2];
      v5[2] = v119 + 8 * v118;
      v131 = v99;
      v132 = v124;
      v129 = (uint64_t)v114;
      v130 = (uint64_t)v114;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v129);
      v111 = *(_DWORD *)(v9 + 84);
      goto LABEL_129;
    }
LABEL_133:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  }
}

char **NeonThirdBlockMelManager::NeonThirdBlockMelManager(char **a1, char *a2, uint64_t a3, uint64_t a4, char **a5)
{
  char **v7;
  uint64_t v8;
  NeonMELContainer *v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  _QWORD v13[13];
  char v14;
  uint64_t v15;
  void *v16;
  std::locale v17;

  a1[19] = 0;
  v7 = a1 + 19;
  a1[1] = 0;
  a1[2] = 0;
  a1[14] = 0;
  a1[15] = 0;
  v8 = CustomAllocator::mRsrc;
  a1[16] = 0;
  a1[17] = (char *)v8;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = (char *)v8;
  a1[28] = 0;
  a1[29] = 0;
  a1[18] = a2;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v13);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=(v7, a5);
  NeonThirdBlockMelManager::ModelNpy((uint64_t)a1, (uint64_t)v13);
  v9 = (NeonMELContainer *)a1[18];
  *((_BYTE *)v9 + 3499) = 0;
  if (*((_BYTE *)v9 + 2304)
    && (NeonMELContainer::EngineMCSetUp(v9, a1, 3, (void (*)(void *, int))mc_ThirdBlock_do_inference) & 1) == 0)
  {
    v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"WARNING: error set up multi-core engine", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
    v11 = std::locale::use_facet(&v17, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
    std::locale::~locale(&v17);
    std::ostream::put();
    std::ostream::flush();
  }
  v13[0] = &unk_24D29B388;
  v13[2] = &unk_24D29B3B0;
  v16 = &unk_24D29B3D8;
  v13[3] = &unk_24D29B578;
  if (v14 < 0)
    heap_Free(*(_QWORD **)(v15 + 8), v13[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v16);
  return a1;
}

void sub_214EAFD00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  SplitMELManager *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  std::locale::~locale((std::locale *)(v5 - 56));
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v4);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v3);
  SplitMELManager::~SplitMELManager(v2);
  _Unwind_Resume(a1);
}

uint64_t NeonThirdBlockMelManager::ModelNpy(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int i;
  int v18;
  uint64_t v19;
  _WORD *v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  _QWORD *v42;
  const std::locale::facet *v43;
  _QWORD *v44;
  _QWORD *v45;
  uint64_t v46;
  _WORD *v47;
  uint64_t v48;
  __int16 *v49;
  uint64_t v50;
  __int16 v51;
  _QWORD *v52;
  const std::locale::facet *v53;
  uint64_t j;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  int v63;
  _WORD *v64;
  unint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  float16x4_t *v77;
  int v78;
  unint64_t v79;
  uint64_t v80;
  float16x4_t *v81;
  float32x4_t v82;
  __int128 v83;
  float16x8_t v84;
  float16x8_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  _QWORD *v96;
  _QWORD *v97;
  const std::locale::facet *v98;
  _QWORD *v99;
  _QWORD *v100;
  _QWORD *v101;
  uint64_t v102;
  _WORD *v103;
  uint64_t v104;
  __int16 *v105;
  uint64_t v106;
  __int16 v107;
  _QWORD *v108;
  _QWORD *v109;
  _QWORD *v110;
  _QWORD *v111;
  const std::locale::facet *v112;
  _QWORD *v113;
  _QWORD *v114;
  _QWORD *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  _WORD *v121;
  unint64_t v122;
  _WORD *v123;
  uint64_t v124;
  unint64_t v125;
  _WORD *v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  uint64_t v134;
  int v135;
  _QWORD *v136;
  _QWORD *v137;
  _QWORD *v138;
  _QWORD *v139;
  const std::locale::facet *v140;
  _QWORD *v141;
  _QWORD *v142;
  _QWORD *v143;
  uint64_t v144;
  _WORD *v145;
  uint64_t v146;
  __int16 *v147;
  uint64_t v148;
  __int16 v149;
  _QWORD *v150;
  _QWORD *v151;
  _QWORD *v152;
  _QWORD *v153;
  const std::locale::facet *v154;
  _QWORD *v155;
  _QWORD *v156;
  _QWORD *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unint64_t v162;
  _WORD *v163;
  unint64_t v164;
  _WORD *v165;
  uint64_t v166;
  unint64_t v167;
  _WORD *v168;
  int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  uint64_t v176;
  int v177;
  _QWORD *v178;
  _QWORD *v179;
  _QWORD *v180;
  _QWORD *v181;
  const std::locale::facet *v182;
  _QWORD *v183;
  _QWORD *v184;
  _QWORD *v185;
  uint64_t v186;
  _WORD *v187;
  uint64_t v188;
  __int16 *v189;
  uint64_t v190;
  __int16 v191;
  _QWORD *v192;
  _QWORD *v193;
  _QWORD *v194;
  _QWORD *v195;
  const std::locale::facet *v196;
  _QWORD *v198;
  uint64_t v199[2];
  char v200;
  uint64_t v201;
  uint64_t v202[2];
  char v203;
  uint64_t v204;
  uint64_t v205[2];
  char v206;
  uint64_t v207;
  uint64_t v208[2];
  char v209;
  uint64_t v210;
  uint64_t v211[2];
  char v212;
  uint64_t v213;
  uint64_t v214[2];
  char v215;
  uint64_t v216;
  uint64_t v217[2];
  char v218;
  uint64_t v219;
  uint64_t v220[2];
  char v221;
  uint64_t v222;
  std::locale v223;
  void *v224;
  void *v225;
  uint64_t v226;
  char v227;
  uint64_t v228;
  _QWORD v229[19];
  std::locale v230;
  void *v231;
  _QWORD v232[10];
  char v233;
  uint64_t v234;
  void *v235;
  _WORD *v236;
  _WORD *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  __int128 v248;
  uint64_t v249;

  v249 = *MEMORY[0x24BDAC8D0];
  v244 = 0;
  v245 = 0;
  v246 = 0;
  v247 = CustomAllocator::mRsrc;
  v240 = 0;
  v241 = 0;
  v242 = 0;
  v243 = CustomAllocator::mRsrc;
  v236 = 0;
  v237 = 0;
  v238 = 0;
  v239 = CustomAllocator::mRsrc;
  v198 = (_QWORD *)(a2 + 16);
  v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a2 + 16), (uint64_t)"path: ", 6);
  v4 = *(char *)(a1 + 175);
  if (v4 >= 0)
    v5 = a1 + 152;
  else
    v5 = *(_QWORD *)(a1 + 152);
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a1 + 175);
  else
    v6 = *(_QWORD *)(a1 + 160);
  v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, v5, v6);
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
  v8 = std::locale::use_facet(&v230, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v230);
  std::ostream::put();
  std::ostream::flush();
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v230);
  *(_QWORD *)(a1 + 80) = 0x3000000060;
  *(_DWORD *)(a1 + 88) = 4;
  v245 = v244;
  v237 = v236;
  v241 = v240;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
  v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v224 = &unk_24D29B3B0;
  v229[0] = &unk_24D29B3D8;
  v225 = &unk_24D29B578;
  if (v227 < 0)
    heap_Free(*(_QWORD **)(v228 + 8), v226);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v229);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
  v9 = (_QWORD *)std::ostream::operator<<();
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"/upsampler/layer/transposed/weight", 34);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"/npy", 4);
  v11 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v220);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v11 + 24))(v11, v220, &v244, &v236, 1);
  if (v221 < 0)
    heap_Free(*(_QWORD **)(v222 + 8), v220[0]);
  if (v237 == v236)
  {
    v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: upsampler_layer_transposed_weight", 40);
    std::ios_base::getloc((const std::ios_base *)((char *)v42 + *(_QWORD *)(*v42 - 24)));
    v43 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
    std::locale::~locale(&v223);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v12 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 80) * *(_DWORD *)(a1 + 88));
    v13 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 80) * *(_DWORD *)(a1 + 88));
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 3288) = v13;
    v14 = *(_DWORD *)(a1 + 80);
    v15 = *(_DWORD *)(a1 + 84);
    if (v14 >= 1)
    {
      v16 = 0;
      for (i = 0; i != v14; ++i)
      {
        if (v15 >= 1)
        {
          v18 = 0;
          v19 = *(unsigned int *)(a1 + 88);
          v20 = v236;
          v21 = v237 - v236;
          v22 = v19 * v16;
          do
          {
            if ((int)v19 >= 1)
            {
              v23 = v19;
              v24 = v22;
              do
              {
                if (v21 <= v24)
                  std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
                *(_WORD *)(v12 + 2 * v24) = v20[v24];
                ++v24;
                --v23;
              }
              while (v23);
            }
            ++v18;
            v22 += v19;
          }
          while (v18 != v15);
        }
        v16 += v15;
      }
    }
    if (v15 >= 0)
      v25 = v15;
    else
      v25 = v15 + 7;
    if (v15 >= 8)
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = v25 >> 3;
      v30 = *(_DWORD *)(a1 + 88);
      v31 = v15 * v30;
      do
      {
        if (v30 >= 1)
        {
          v32 = 0;
          v33 = v26;
          do
          {
            if (v14 >= 4)
            {
              v34 = 0;
              v35 = v33;
              do
              {
                v36 = 0;
                v37 = v35;
                do
                {
                  v38 = 0;
                  v39 = v27;
                  v40 = v13 + 2 * v27;
                  v41 = v37;
                  do
                  {
                    *(_WORD *)(v40 + 2 * v38++) = *(_WORD *)(v12 + 2 * v41);
                    v41 += v30;
                  }
                  while (v38 != 8);
                  v27 = v39 + 8;
                  ++v36;
                  v37 += v31;
                }
                while (v36 != 4);
                ++v34;
                v35 += 4 * v31;
                v27 = v39 + 8;
              }
              while (v34 != v14 / 4);
              v27 = v39 + 8;
            }
            ++v32;
            ++v33;
          }
          while (v32 != v30);
        }
        ++v28;
        v26 += 8 * v30;
      }
      while (v28 != v29);
    }
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v12);
  }
  v245 = v244;
  v237 = v236;
  v241 = v240;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
  v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v229[0] = &unk_24D29B3D8;
  v224 = &unk_24D29B3B0;
  v225 = &unk_24D29B578;
  if (v227 < 0)
    heap_Free(*(_QWORD **)(v228 + 8), v226);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v229);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
  v44 = (_QWORD *)std::ostream::operator<<();
  v45 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)"/upsampler/layer/transposed/bias", 32);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"/npy", 4);
  v46 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v217);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v46 + 24))(v46, v217, &v244, &v236, 1);
  if (v218 < 0)
    heap_Free(*(_QWORD **)(v219 + 8), v217[0]);
  if (v237 == v236)
  {
    v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: upsampler_layer_transposed_bias", 38);
    std::ios_base::getloc((const std::ios_base *)((char *)v52 + *(_QWORD *)(*v52 - 24)));
    v53 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v53->__vftable[2].~facet_0)(v53, 10);
    std::locale::~locale(&v223);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v47 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 3296) = v47;
    v48 = *(unsigned int *)(a1 + 84);
    if ((int)v48 >= 1)
    {
      v49 = v236;
      v50 = v237 - v236;
      while (v50)
      {
        v51 = *v49++;
        *v47++ = v51;
        --v50;
        if (!--v48)
          goto LABEL_52;
      }
LABEL_158:
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    }
  }
LABEL_52:
  for (j = 0; j != 4; ++j)
  {
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v55 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v55, (uint64_t)"/block/", 7);
    v56 = (_QWORD *)std::ostream::operator<<();
    v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v56, (uint64_t)"/first/conv1d/weight", 20);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"/npy", 4);
    v58 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v214);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v58 + 24))(v58, v214, &v244, &v236, 1);
    if (v215 < 0)
      heap_Free(*(_QWORD **)(v216 + 8), v214[0]);
    if (v237 == v236)
    {
      v94 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v94, (uint64_t)"[", 1);
      v95 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v95, (uint64_t)"][", 2);
      v96 = (_QWORD *)std::ostream::operator<<();
      v97 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v96, (uint64_t)"] first_conv1d_weight", 21);
      std::ios_base::getloc((const std::ios_base *)((char *)v97 + *(_QWORD *)(*v97 - 24)));
      v98 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v98->__vftable[2].~facet_0)(v98, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v59 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (6 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      v60 = 0;
      v61 = 0;
      v62 = *(unsigned int *)(a1 + 84);
      do
      {
        if ((int)v62 >= 1)
        {
          v63 = 0;
          v64 = v236;
          v65 = v237 - v236;
          v66 = v61;
          v67 = v60;
          do
          {
            v68 = 0;
            v69 = v66;
            do
            {
              if (v65 <= v69)
                std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
              *(_WORD *)(v59 + 2 * (v67 + (int)v68++)) = v64[v69];
              v69 += 3 * v62;
            }
            while (v62 != v68);
            ++v63;
            v67 += v62;
            v66 += 3;
          }
          while (v63 != (_DWORD)v62);
        }
        ++v61;
        v60 += v62 * v62;
      }
      while (v61 != 3);
      v70 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (8 * v62 * v62));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 3304) = v70;
      v71 = *(unsigned int *)(a1 + 84);
      if ((int)v71 >= 8)
      {
        v72 = 0;
        v73 = 0;
        v74 = (v71 * v71);
        v75 = 2 * v74;
        v76 = v74 << 33;
        v77 = (float16x4_t *)v59;
        do
        {
          v78 = 0;
          v79 = v71;
          v80 = v76;
          v81 = v77;
          v82.i64[0] = 0x3F0000003F000000;
          v82.i64[1] = 0x3F0000003F000000;
          do
          {
            v83 = *(_OWORD *)(v59 + (v80 >> 31));
            v84 = *(float16x8_t *)(v59 + 2 * ((int)v74 + v78));
            v85 = *(float16x8_t *)(v59 + 2 * (v75 + v78));
            v86 = vcvtq_f32_f16(*v81);
            v87 = vcvt_hight_f32_f16(*(float16x8_t *)v81->i8);
            v88 = vcvtq_f32_f16(*(float16x4_t *)v84.i8);
            v89 = vcvt_hight_f32_f16(v84);
            v90 = vcvt_hight_f32_f16(v85);
            v91 = vcvtq_f32_f16(*(float16x4_t *)v85.i8);
            *(_OWORD *)(v70 + 2 * (int)v73) = *(_OWORD *)v81->i8;
            *(float16x8_t *)(v70 + (((v73 << 32) + 0x800000000) >> 31)) = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_f32(vaddq_f32(vaddq_f32(v86, v88), v91), v82)), vmulq_f32(vaddq_f32(vaddq_f32(v87, v89), v90), v82));
            v92 = ((v73 << 32) + 0x1000000000) >> 31;
            v93 = (v73 << 32) + 0x1800000000;
            *(float16x8_t *)(v70 + v92) = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmulq_f32(vaddq_f32(vsubq_f32(v86, v88), v91), v82)), vmulq_f32(vaddq_f32(vsubq_f32(v87, v89), v90), v82));
            *(_OWORD *)(v70 + (v93 >> 31)) = v83;
            v73 = (v93 >> 32) + 8;
            v248 = v83;
            v81 = (float16x4_t *)((char *)v81 + 2 * v71);
            v78 += v71;
            v80 += v71 << 32;
            --v79;
          }
          while (v79);
          ++v72;
          v77 += 2;
          v75 += 8;
          LODWORD(v74) = v74 + 8;
          v76 += 0x800000000;
        }
        while (v72 != v71 >> 3);
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v59);
    }
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v99 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v99, (uint64_t)"/block/", 7);
    v100 = (_QWORD *)std::ostream::operator<<();
    v101 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v100, (uint64_t)"/first/conv1d/bias", 18);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v101, (uint64_t)"/npy", 4);
    v102 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v211);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v102 + 24))(v102, v211, &v244, &v236, 1);
    if (v212 < 0)
      heap_Free(*(_QWORD **)(v213 + 8), v211[0]);
    if (v237 == v236)
    {
      v108 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v108, (uint64_t)"[", 1);
      v109 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v109, (uint64_t)"][", 2);
      v110 = (_QWORD *)std::ostream::operator<<();
      v111 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v110, (uint64_t)"] first_conv1d_bias", 19);
      std::ios_base::getloc((const std::ios_base *)((char *)v111 + *(_QWORD *)(*v111 - 24)));
      v112 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v112->__vftable[2].~facet_0)(v112, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v103 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 3312) = v103;
      v104 = *(unsigned int *)(a1 + 84);
      if ((int)v104 >= 1)
      {
        v105 = v236;
        v106 = v237 - v236;
        while (v106)
        {
          v107 = *v105++;
          *v103++ = v107;
          --v106;
          if (!--v104)
            goto LABEL_84;
        }
        goto LABEL_158;
      }
    }
LABEL_84:
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v113 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v113, (uint64_t)"/block/", 7);
    v114 = (_QWORD *)std::ostream::operator<<();
    v115 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v114, (uint64_t)"/second/conv1d/weight", 21);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v115, (uint64_t)"/npy", 4);
    v116 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v208);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v116 + 24))(v116, v208, &v244, &v236, 1);
    if (v209 < 0)
      heap_Free(*(_QWORD **)(v210 + 8), v208[0]);
    if (v237 == v236)
    {
      v136 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v136, (uint64_t)"[", 1);
      v137 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v137, (uint64_t)"][", 2);
      v138 = (_QWORD *)std::ostream::operator<<();
      v139 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v138, (uint64_t)"] second_conv1d_weight", 22);
      std::ios_base::getloc((const std::ios_base *)((char *)v139 + *(_QWORD *)(*v139 - 24)));
      v140 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v140->__vftable[2].~facet_0)(v140, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v117 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      v118 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 3320) = v118;
      v119 = *(unsigned int *)(a1 + 84);
      if ((int)v119 >= 1)
      {
        v120 = 0;
        v121 = v236;
        v122 = v237 - v236;
        v123 = (_WORD *)v117;
        do
        {
          v124 = v119;
          v125 = v120;
          v126 = v123;
          do
          {
            if (v122 <= v125)
              std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
            *v126++ = v121[v125];
            v125 += v119;
            --v124;
          }
          while (v124);
          ++v120;
          v123 += v119;
        }
        while (v120 != v119);
        if ((int)v119 >= 8)
        {
          v127 = 0;
          v128 = 0;
          v129 = 0;
          do
          {
            v130 = 0;
            v131 = v127;
            do
            {
              v132 = 0;
              v133 = v131;
              do
              {
                v134 = 0;
                v135 = v129;
                do
                {
                  *(_WORD *)(v118 + 2 * v129 + 2 * v134) = *(_WORD *)(v117 + 2 * (v133 + (int)v134));
                  ++v134;
                }
                while (v134 != 8);
                ++v132;
                v133 += v119;
                v129 += 8;
              }
              while (v132 != 4);
              ++v130;
              v131 += 4 * v119;
              v129 = v135 + 8;
            }
            while (v130 != v119 >> 2);
            ++v128;
            v127 += 8;
            v129 = v135 + 8;
          }
          while (v128 != (int)v119 >> 3);
        }
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v117);
    }
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v141 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v141, (uint64_t)"/block/", 7);
    v142 = (_QWORD *)std::ostream::operator<<();
    v143 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v142, (uint64_t)"/second/conv1d/bias", 19);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v143, (uint64_t)"/npy", 4);
    v144 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v205);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v144 + 24))(v144, v205, &v244, &v236, 1);
    if (v206 < 0)
      heap_Free(*(_QWORD **)(v207 + 8), v205[0]);
    if (v237 == v236)
    {
      v150 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v150, (uint64_t)"[", 1);
      v151 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v151, (uint64_t)"][", 2);
      v152 = (_QWORD *)std::ostream::operator<<();
      v153 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v152, (uint64_t)"] second_conv1d_bias", 20);
      std::ios_base::getloc((const std::ios_base *)((char *)v153 + *(_QWORD *)(*v153 - 24)));
      v154 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v154->__vftable[2].~facet_0)(v154, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v145 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 32 * j + 3328) = v145;
      v146 = *(unsigned int *)(a1 + 84);
      if ((int)v146 >= 1)
      {
        v147 = v236;
        v148 = v237 - v236;
        while (v148)
        {
          v149 = *v147++;
          *v145++ = v149;
          --v148;
          if (!--v146)
            goto LABEL_117;
        }
        goto LABEL_158;
      }
    }
LABEL_117:
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v155 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v155, (uint64_t)"/shortcut/", 10);
    v156 = (_QWORD *)std::ostream::operator<<();
    v157 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v156, (uint64_t)"/conv1d/weight", 14);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v157, (uint64_t)"/npy", 4);
    v158 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v202);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v158 + 24))(v158, v202, &v244, &v236, 1);
    if (v203 < 0)
      heap_Free(*(_QWORD **)(v204 + 8), v202[0]);
    if (v237 == v236)
    {
      v178 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v178, (uint64_t)"[", 1);
      v179 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v179, (uint64_t)"][", 2);
      v180 = (_QWORD *)std::ostream::operator<<();
      v181 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v180, (uint64_t)"] shortcut conv1d_weight", 24);
      std::ios_base::getloc((const std::ios_base *)((char *)v181 + *(_QWORD *)(*v181 - 24)));
      v182 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v182->__vftable[2].~facet_0)(v182, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v159 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      v160 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), (2 * *(_DWORD *)(a1 + 84) * *(_DWORD *)(a1 + 84)));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 16 * j + 3432) = v160;
      v161 = *(unsigned int *)(a1 + 84);
      if ((int)v161 >= 1)
      {
        v162 = 0;
        v163 = v236;
        v164 = v237 - v236;
        v165 = (_WORD *)v159;
        do
        {
          v166 = v161;
          v167 = v162;
          v168 = v165;
          do
          {
            if (v164 <= v167)
              std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
            *v168++ = v163[v167];
            v167 += v161;
            --v166;
          }
          while (v166);
          ++v162;
          v165 += v161;
        }
        while (v162 != v161);
        if ((int)v161 >= 8)
        {
          v169 = 0;
          v170 = 0;
          v171 = 0;
          do
          {
            v172 = 0;
            v173 = v169;
            do
            {
              v174 = 0;
              v175 = v173;
              do
              {
                v176 = 0;
                v177 = v171;
                do
                {
                  *(_WORD *)(v160 + 2 * v171 + 2 * v176) = *(_WORD *)(v159 + 2 * (v175 + (int)v176));
                  ++v176;
                }
                while (v176 != 8);
                ++v174;
                v175 += v161;
                v171 += 8;
              }
              while (v174 != 4);
              ++v172;
              v173 += 4 * v161;
              v171 = v177 + 8;
            }
            while (v172 != v161 >> 2);
            ++v170;
            v169 += 8;
            v171 = v177 + 8;
          }
          while (v170 != (int)v161 >> 3);
        }
      }
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v159);
    }
    v245 = v244;
    v237 = v236;
    v241 = v240;
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v223);
    std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v223, (uint64_t *)&v230);
    v223.__locale_ = (std::locale::__imp *)&unk_24D29B388;
    v229[0] = &unk_24D29B3D8;
    v224 = &unk_24D29B3B0;
    v225 = &unk_24D29B578;
    if (v227 < 0)
      heap_Free(*(_QWORD **)(v228 + 8), v226);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2199DA5E8](v229);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v231, (uint64_t)"upsample/", 9);
    v183 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v183, (uint64_t)"/shortcut/", 10);
    v184 = (_QWORD *)std::ostream::operator<<();
    v185 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v184, (uint64_t)"/conv1d/bias", 12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v185, (uint64_t)"/npy", 4);
    v186 = *(_QWORD *)(a1 + 224);
    std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v232, v199);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, _WORD **, uint64_t))(*(_QWORD *)v186 + 24))(v186, v199, &v244, &v236, 1);
    if (v200 < 0)
      heap_Free(*(_QWORD **)(v201 + 8), v199[0]);
    if (v237 == v236)
    {
      v192 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)"error: ", 7);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v192, (uint64_t)"[", 1);
      v193 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v193, (uint64_t)"][", 2);
      v194 = (_QWORD *)std::ostream::operator<<();
      v195 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v194, (uint64_t)"] shortcut conv1d_bias", 22);
      std::ios_base::getloc((const std::ios_base *)((char *)v195 + *(_QWORD *)(*v195 - 24)));
      v196 = std::locale::use_facet(&v223, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v196->__vftable[2].~facet_0)(v196, 10);
      std::locale::~locale(&v223);
      std::ostream::put();
      std::ostream::flush();
    }
    else
    {
      v187 = (_WORD *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 2 * *(int *)(a1 + 84));
      *(_QWORD *)(*(_QWORD *)(a1 + 144) + 16 * j + 3440) = v187;
      v188 = *(unsigned int *)(a1 + 84);
      if ((int)v188 >= 1)
      {
        v189 = v236;
        v190 = v237 - v236;
        while (v190)
        {
          v191 = *v189++;
          *v187++ = v191;
          --v190;
          if (!--v188)
            goto LABEL_150;
        }
        goto LABEL_158;
      }
    }
LABEL_150:
    ;
  }
  v230.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v231 = &unk_24D29B3B0;
  v235 = &unk_24D29B3D8;
  v232[0] = &unk_24D29B578;
  if (v233 < 0)
    heap_Free(*(_QWORD **)(v234 + 8), v232[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v235);
  v230.__locale_ = (std::locale::__imp *)&v236;
  std::vector<half,ENTTS::Allocator<half>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v230);
  v230.__locale_ = (std::locale::__imp *)&v240;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v230);
  v230.__locale_ = (std::locale::__imp *)&v244;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v230);
  return 1;
}

void sub_214EB1600(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t *mc_ThirdBlock_do_inference(uint64_t a1, int a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  int conv_input_shift_by_rows;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  uint64_t *result;
  int v48;
  uint64_t v49;
  int v50;
  uint64_t *v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t *v54;
  _QWORD *v55;
  _QWORD *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  unint64_t v69;
  uint64_t *v70;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  _QWORD *v85;
  unint64_t v86;
  _QWORD *v87;
  _QWORD *v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  _QWORD *v101;
  _QWORD *v102;
  _QWORD *v103;
  uint64_t v104;
  _QWORD *v105;

  v4 = *(_QWORD *)(a1 + 144);
  v5 = *(_DWORD *)(v4 + 2308);
  if (v5 == 4)
  {
    if (a2 > 2)
      goto LABEL_5;
    v5 = 3;
  }
  SplitMELManager::neon_transpose_rows(a1, *(_QWORD *)(v4 + 3288), *(float16x8_t **)(v4 + 2776), *(_QWORD *)(v4 + 2792), *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 84), *(_DWORD *)(v4 + 4088), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 88), *(_DWORD *)(a1 + 92), a2, v5);
LABEL_5:
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
  v7 = *(_QWORD *)(a1 + 144);
  v8 = *(_DWORD *)(v7 + 2308);
  if (v8 == 4)
  {
    if (a2 > 2)
      goto LABEL_9;
    v8 = 3;
  }
  SplitMELManager::neon_transpose_rearrange_rows_2(v6, *(_QWORD *)(v7 + 2792), *(_QWORD *)(v7 + 2800), *(_QWORD *)(v7 + 3296), *(_DWORD *)(a1 + 84), *(_DWORD *)(v7 + 4088), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 92), a2, v8);
LABEL_9:
  v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
  v10 = *(_QWORD *)(a1 + 144);
  v11 = *(_DWORD *)(v10 + 2308);
  if (v11 != 4)
  {
LABEL_12:
    SplitMELManager::neon_block_input(v9, *(_QWORD *)(v10 + 2800), *(_QWORD *)(v10 + 2816), *(_QWORD *)(v10 + 2808), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 84), a2, v11);
    goto LABEL_13;
  }
  if (a2 <= 2)
  {
    v11 = 3;
    goto LABEL_12;
  }
LABEL_13:
  (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
  v12 = 0;
  v13 = 0;
  conv_input_shift_by_rows = 0;
  v15 = 3432;
  do
  {
    v17 = (int)pow(3.0, (double)v12);
    *(_DWORD *)(a1 + 104) = v17;
    *(_DWORD *)(a1 + 108) = v17;
    v18 = *(_QWORD *)(a1 + 144);
    v19 = *(_DWORD *)(v18 + 2308);
    if (v19 != 4 || a2 <= 2)
    {
      if (v19 == 4)
        v19 = 3;
      conv_input_shift_by_rows = SplitMELManager::neon_first_conv_input_shift_by_rows(a1, *(_QWORD *)(v18 + 2808), *(_QWORD *)(v18 + 2784), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 84), v16, v17, 6 * v17, a2, v19);
    }
    v21 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
    v23 = *(_QWORD *)(a1 + 144);
    v24 = *(_DWORD *)(v23 + 2308);
    if (v24 == 4)
    {
      if (a2 <= 2)
        SplitMELManager::neon_first_conv_cols(v21, *(_QWORD *)(v23 + v13 + 3304), *(_QWORD *)(v23 + v13 + 3312), *(_QWORD *)(v23 + 2784), *(_QWORD *)(v23 + 2824), v22, *(_DWORD *)(a1 + 108), *(_DWORD *)(a1 + 84), 4 * conv_input_shift_by_rows * *(_DWORD *)(a1 + 108), a2, 3u);
    }
    else
    {
      SplitMELManager::neon_first_conv_cols(v21, *(_QWORD *)(v23 + v13 + 3304), *(_QWORD *)(v23 + v13 + 3312), *(_QWORD *)(v23 + 2784), *(_QWORD *)(v23 + 2824), v22, *(_DWORD *)(a1 + 108), *(_DWORD *)(a1 + 84), 4 * conv_input_shift_by_rows * *(_DWORD *)(a1 + 108), a2, v24);
    }
    v25 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
    v26 = *(_QWORD *)(a1 + 144);
    v27 = *(_DWORD *)(v26 + 2308);
    if (v27 != 4 || a2 <= 2)
    {
      if (v27 == 4)
        v27 = 3;
      SplitMELManager::neon_conv_single_kernel_cols(v25, *(_QWORD *)(v26 + v13 + 3320), *(_QWORD *)(v26 + v13 + 3328), *(float16x4_t **)(v26 + 2824), *(_QWORD *)(v26 + 2832), *(_DWORD *)(a1 + 84), *(_DWORD *)(a1 + 184), a2, v27);
    }
    v28 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
    v29 = *(_QWORD *)(a1 + 144);
    v30 = *(_DWORD *)(v29 + 2308);
    if (v30 != 4 || a2 <= 2)
    {
      if (v30 == 4)
        v30 = 3;
      SplitMELManager::neon_conv_single_kernel_cols(v28, *(_QWORD *)(v29 + v15), *(_QWORD *)(v29 + v15 + 8), *(float16x4_t **)(v29 + 2816), *(_QWORD *)(v29 + 2824), *(_DWORD *)(a1 + 84), *(_DWORD *)(a1 + 184), a2, v30);
    }
    v31 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
    v32 = *(_QWORD *)(a1 + 144);
    if (v13 == 96)
    {
      v33 = *(_DWORD *)(v32 + 2308);
      if (*(_BYTE *)(v32 + 3500))
      {
        if (v33 == 4)
        {
          if (a2 > 2)
            goto LABEL_52;
          v35 = *(_QWORD *)(v32 + 2832);
          v36 = *(_QWORD *)(v32 + 2824);
          v37 = *(_QWORD *)(v32 + 2848);
          v38 = *(_DWORD *)(a1 + 184);
          v39 = *(_DWORD *)(a1 + 84);
          v40 = a2;
          v33 = 3;
        }
        else
        {
          v35 = *(_QWORD *)(v32 + 2832);
          v36 = *(_QWORD *)(v32 + 2824);
          v37 = *(_QWORD *)(v32 + 2848);
          v38 = *(_DWORD *)(a1 + 184);
          v39 = *(_DWORD *)(a1 + 84);
          v40 = a2;
        }
        SplitMELManager::neon_add_signals_relu_tensor(v31, v35, v36, v37, v38, v39, v40, v33);
      }
      else
      {
        if (v33 == 4)
        {
          if (a2 > 2)
            goto LABEL_52;
          v41 = *(_QWORD *)(v32 + 2832);
          v42 = *(_QWORD *)(v32 + 2824);
          v43 = *(_QWORD *)(v32 + 2848);
          v44 = *(_DWORD *)(a1 + 184);
          v45 = *(_DWORD *)(a1 + 84);
          v46 = a2;
          v33 = 3;
        }
        else
        {
          v41 = *(_QWORD *)(v32 + 2832);
          v42 = *(_QWORD *)(v32 + 2824);
          v43 = *(_QWORD *)(v32 + 2848);
          v44 = *(_DWORD *)(a1 + 184);
          v45 = *(_DWORD *)(a1 + 84);
          v46 = a2;
        }
        SplitMELManager::neon_add_signals_relu_colums(v31, v41, v42, v43, v44, v45, v46, v33);
      }
    }
    else
    {
      v34 = *(_DWORD *)(v32 + 2308);
      if (v34 == 4)
      {
        if (a2 <= 2)
          SplitMELManager::neon_add_signals(v31, *(_QWORD *)(v32 + 2832), *(_QWORD *)(v32 + 2824), *(_QWORD *)(v32 + 2816), *(_QWORD *)(v32 + 2808), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 84), a2, 3u);
      }
      else
      {
        SplitMELManager::neon_add_signals(v31, *(_QWORD *)(v32 + 2832), *(_QWORD *)(v32 + 2824), *(_QWORD *)(v32 + 2816), *(_QWORD *)(v32 + 2808), *(_DWORD *)(a1 + 184), *(_DWORD *)(a1 + 84), a2, v34);
      }
    }
LABEL_52:
    result = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 144) + 2656) + 8))(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 2656));
    v15 += 16;
    v13 += 32;
    ++v12;
  }
  while (v13 != 128);
  if (!a2)
  {
    v48 = *(_DWORD *)(a1 + 184);
    v49 = *(_QWORD *)(a1 + 144);
    *(_DWORD *)(v49 + 4088) = v48;
    if (!*(_BYTE *)(v49 + 3500))
    {
      v50 = v48 - 2 * *(_DWORD *)(a1 + 188);
      *(_DWORD *)(v49 + 4088) = v50;
      v51 = *(uint64_t **)(a1 + 216);
      v52 = (_QWORD *)v51[1];
      v53 = v51[2];
      if ((unint64_t)v52 < v53)
      {
        *v52 = 1;
        v54 = v51;
        v55 = v52 + 1;
        goto LABEL_72;
      }
      v56 = (_QWORD *)*v51;
      v57 = ((uint64_t)v52 - *v51) >> 3;
      v58 = v57 + 1;
      if ((unint64_t)(v57 + 1) >> 61)
        goto LABEL_108;
      v59 = v53 - (_QWORD)v56;
      if (v59 >> 2 > v58)
        v58 = v59 >> 2;
      if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8)
        v60 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v60 = v58;
      v105 = v51 + 3;
      if (v60)
      {
        v61 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v51 + 3), v60);
        v56 = (_QWORD *)*v51;
        v52 = (_QWORD *)v51[1];
      }
      else
      {
        v61 = 0;
      }
      v62 = (_QWORD *)(v61 + 8 * v57);
      *v62 = 1;
      if (v52 == v56)
      {
        v64 = v61 + 8 * v57;
      }
      else
      {
        v63 = v52;
        v64 = v61 + 8 * v57;
        do
        {
          v65 = *--v63;
          *(_QWORD *)(v64 - 8) = v65;
          v64 -= 8;
        }
        while (v63 != v56);
      }
      v55 = v62 + 1;
      *v51 = v64;
      v101 = v56;
      v102 = v56;
      v51[1] = (uint64_t)(v62 + 1);
      v103 = v52;
      v66 = v51[2];
      v51[2] = v61 + 8 * v60;
      v104 = v66;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v101);
      v54 = *(uint64_t **)(a1 + 216);
      v50 = *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4088);
LABEL_72:
      v51[1] = (uint64_t)v55;
      v67 = v50;
      v68 = (_QWORD *)v54[1];
      v69 = v54[2];
      if ((unint64_t)v68 >= v69)
      {
        v72 = (_QWORD *)*v54;
        v73 = ((uint64_t)v68 - *v54) >> 3;
        v74 = v73 + 1;
        if ((unint64_t)(v73 + 1) >> 61)
          std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
        v75 = v69 - (_QWORD)v72;
        if (v75 >> 2 > v74)
          v74 = v75 >> 2;
        if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8)
          v76 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v76 = v74;
        v105 = v54 + 3;
        if (v76)
        {
          v77 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v54 + 3), v76);
          v72 = (_QWORD *)*v54;
          v68 = (_QWORD *)v54[1];
        }
        else
        {
          v77 = 0;
        }
        v78 = (_QWORD *)(v77 + 8 * v73);
        *v78 = v67;
        if (v68 == v72)
        {
          v80 = v77 + 8 * v73;
        }
        else
        {
          v79 = v68;
          v80 = v77 + 8 * v73;
          do
          {
            v81 = *--v79;
            *(_QWORD *)(v80 - 8) = v81;
            v80 -= 8;
          }
          while (v79 != v72);
        }
        v71 = v78 + 1;
        *v54 = v80;
        v101 = v72;
        v102 = v72;
        v54[1] = (uint64_t)(v78 + 1);
        v103 = v68;
        v82 = v54[2];
        v54[2] = v77 + 8 * v76;
        v104 = v82;
        std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v101);
        v70 = *(uint64_t **)(a1 + 216);
      }
      else
      {
        *v68 = v50;
        v70 = v54;
        v71 = v68 + 1;
      }
      v54[1] = (uint64_t)v71;
      v83 = *(_DWORD *)(a1 + 84);
      v84 = v83;
      v85 = (_QWORD *)v70[1];
      v86 = v70[2];
      if ((unint64_t)v85 < v86)
      {
        *v85 = v83;
        v87 = v85 + 1;
        goto LABEL_106;
      }
      v88 = (_QWORD *)*v70;
      v89 = ((uint64_t)v85 - *v70) >> 3;
      v90 = v89 + 1;
      if ((unint64_t)(v89 + 1) >> 61)
LABEL_108:
        std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
      v91 = v86 - (_QWORD)v88;
      if (v91 >> 2 > v90)
        v90 = v91 >> 2;
      if ((unint64_t)v91 >= 0x7FFFFFFFFFFFFFF8)
        v92 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v92 = v90;
      v105 = v70 + 3;
      if (v92)
      {
        v93 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v70 + 3), v92);
        v88 = (_QWORD *)*v70;
        v85 = (_QWORD *)v70[1];
      }
      else
      {
        v93 = 0;
      }
      v94 = (_QWORD *)(v93 + 8 * v89);
      *v94 = v84;
      if (v85 == v88)
      {
        v96 = v93 + 8 * v89;
      }
      else
      {
        v95 = v85;
        v96 = v93 + 8 * v89;
        do
        {
          v97 = *--v95;
          *(_QWORD *)(v96 - 8) = v97;
          v96 -= 8;
        }
        while (v95 != v88);
      }
      v87 = v94 + 1;
      *v70 = v96;
      v101 = v88;
      v102 = v88;
      v70[1] = (uint64_t)(v94 + 1);
      v103 = v85;
      v98 = v70[2];
      v70[2] = v93 + 8 * v92;
      v104 = v98;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v101);
      v83 = *(_DWORD *)(a1 + 84);
LABEL_106:
      v70[1] = (uint64_t)v87;
      v99 = *(_QWORD *)(a1 + 144);
      v100 = *(int *)(v99 + 4088) * (uint64_t)v83;
      result = std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(*(uint64_t **)(a1 + 208), *(char **)(v99 + 2848), *(_QWORD *)(v99 + 2848) + 4 * v100, v100);
      *(_DWORD *)(a1 + 188) = 0;
    }
  }
  return result;
}

_QWORD *NeonThirdBlockMelManager::NeonThirdBlockMelManager(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  uint64_t v5;
  NeonMELContainer *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  std::locale v10;

  a1[19] = 0;
  v4 = a1 + 19;
  a1[1] = 0;
  a1[2] = 0;
  a1[14] = 0;
  a1[15] = 0;
  v5 = CustomAllocator::mRsrc;
  a1[16] = 0;
  a1[17] = v5;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = v5;
  a1[28] = 0;
  a1[29] = 0;
  a1[18] = a2;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 28, a3);
  v6 = (NeonMELContainer *)*(v4 - 1);
  *((_BYTE *)v6 + 3499) = 0;
  if (*((_BYTE *)v6 + 2304)
    && (NeonMELContainer::EngineMCSetUp(v6, a1, 3, (void (*)(void *, int))mc_ThirdBlock_do_inference) & 1) == 0)
  {
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"WARNING: error set up multi-core engine", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v10, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v10);
    std::ostream::put();
    std::ostream::flush();
  }
  return a1;
}

void sub_214EB2060(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  SplitMELManager *v10;
  uint64_t v11;
  uint64_t v12;

  std::locale::~locale(&a10);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v12);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v11);
  SplitMELManager::~SplitMELManager(v10);
  _Unwind_Resume(a1);
}

void NeonThirdBlockMelManager::~NeonThirdBlockMelManager(NeonThirdBlockMelManager *this)
{
  char *v2;
  uint64_t v3;
  uint64_t i;

  v2 = (char *)this + 224;
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 3288));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 3296));
  v3 = 3304;
  for (i = 3432; i != 3496; i += 16)
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3 + 8));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3 + 16));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + v3 + 24));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + i));
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + i + 8));
    v3 += 32;
  }
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  if (*((char *)this + 175) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 22) + 8), *((_QWORD *)this + 19));
  if (*((char *)this + 135) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 17) + 8), *((_QWORD *)this + 14));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

void SplitMELManager::neon_transpose_rearrange_rows_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, int a8, int a9, unsigned int a10)
{
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  float16x8_t v20;
  int v21;
  float16x8_t *v22;
  float16x8_t v23;
  float16x8_t v24;
  uint64_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t *v28;
  float16x8_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  uint64_t v34;
  float16x8_t *v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  uint64_t v39;
  uint64_t v40;
  float16x8_t v41;
  uint64_t v42;
  int v43;
  float16x8_t *v44;
  float16x8_t v45;
  float16x8_t *v46;
  float16x8_t v47;
  float16x8_t v48;
  uint64_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t *v52;
  float16x8_t v53;
  float16x8_t *v54;
  float16x8_t *v55;

  v10 = (a5 >> 3) / a10 * a9;
  v11 = v10 + (a5 >> 3) / a10;
  if (v10 < v11)
  {
    v12 = a7 >> 2 << 6;
    v13 = 32 * (a7 >> 2);
    v14 = a2 + 48;
    LODWORD(v15) = a6 >> 2;
    v16 = a8 << 6;
    v17 = 32 * a8;
    v18 = 32 * (a6 >> 2) * a8 - 32;
    if (a6 >> 2 <= 2)
      v15 = 2;
    else
      v15 = v15;
    v19 = v15 - 1;
    do
    {
      v20 = *(float16x8_t *)(a4 + 2 * (int)(8 * v10));
      v21 = v13 * v10;
      v22 = (float16x8_t *)(a2 + 2 * (int)(v12 * v10));
      v23 = v22[3];
      v24 = v22[8];
      v25 = (2 * (int)(v12 * v10)) | 0x40;
      v26 = *(float16x8_t *)(a2 + v25 + 16);
      v27 = *(float16x8_t *)(a2 + v25 + 32);
      v28 = (float16x8_t *)(a3 + 2 * (int)(v13 * v10));
      v29 = vaddq_f16(v20, vaddq_f16(v22[2], *(float16x8_t *)(a2 + v25)));
      *v28 = vaddq_f16(v20, vaddq_f16(v22[1], (float16x8_t)0));
      v28[1] = v29;
      v28[2] = vaddq_f16(v20, vaddq_f16(v23, v26));
      v28[3] = vaddq_f16(v20, vaddq_f16(v24, v27));
      v31 = v22[9];
      v30 = v22[10];
      v32 = v22[11];
      v33 = *(float16x8_t *)(v14 + v25);
      v34 = (int)(v12 * v10) + 96;
      v35 = (float16x8_t *)(a2 + 2 * v34);
      v37 = *v35;
      v36 = v35[1];
      v38 = v35[2];
      if (a6 >= 8)
      {
        v39 = v19;
        v40 = 1;
        do
        {
          v41 = *(float16x8_t *)(v14 + 2 * v34);
          v42 = (int)(v12 * v10 + v16 * v40);
          v43 = v21 + v17 * v40;
          v44 = (float16x8_t *)(a2 + 2 * v42);
          v45 = *v44;
          v46 = (float16x8_t *)(a3 + 2 * (v43 - 32));
          *v46 = vaddq_f16(v20, vaddq_f16(v31, v33));
          v46[1] = vaddq_f16(v20, vaddq_f16(v30, v37));
          v46[2] = vaddq_f16(v20, vaddq_f16(v32, v36));
          v46[3] = vaddq_f16(v20, vaddq_f16(v38, v45));
          v47 = v44[3];
          v48 = v44[8];
          v49 = (2 * v42) | 0x40;
          v50 = *(float16x8_t *)(a2 + v49 + 16);
          v51 = *(float16x8_t *)(a2 + v49 + 32);
          v52 = (float16x8_t *)(a3 + 2 * v43);
          v53 = vaddq_f16(v20, vaddq_f16(v44[2], *(float16x8_t *)(a2 + v49)));
          *v52 = vaddq_f16(v20, vaddq_f16(v41, v44[1]));
          v52[1] = v53;
          v52[2] = vaddq_f16(v20, vaddq_f16(v47, v50));
          v52[3] = vaddq_f16(v20, vaddq_f16(v48, v51));
          ++v40;
          v31 = v44[9];
          v30 = v44[10];
          v32 = v44[11];
          v33 = *(float16x8_t *)(v14 + v49);
          v34 = v42 + 96;
          v54 = (float16x8_t *)(a2 + 2 * (v42 + 96));
          v37 = *v54;
          v36 = v54[1];
          v38 = v54[2];
          --v39;
        }
        while (v39);
      }
      v55 = (float16x8_t *)(a3 + 2 * (v18 + v21));
      *v55 = vaddq_f16(v20, vaddq_f16(v31, v33));
      v55[1] = vaddq_f16(v20, vaddq_f16(v30, v37));
      v55[2] = vaddq_f16(v20, vaddq_f16(v32, v36));
      v55[3] = vaddq_f16(v20, vaddq_f16(v38, (float16x8_t)0));
      ++v10;
    }
    while (v11 > v10);
  }
}

uint64_t SplitMELManager::neon_add_signals_relu_tensor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, unsigned int a8)
{
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  float16x8_t v13;
  uint64_t v14;
  int v15;
  uint64_t result;
  float16x8_t *v17;
  float16x8_t *v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float32x4_t *v27;

  if (a5 >= 4)
  {
    v8 = 0;
    v9 = a5 >> 2;
    v10 = (a6 >> 3) / a8;
    v11 = (v10 * a7);
    v12 = v11 + v10;
    v13 = (float16x8_t)vdupq_n_s16(0x3266u);
    do
    {
      if (v11 < v12)
      {
        v14 = v11;
        do
        {
          v15 = 32 * (a6 >> 3) * v8 + 32 * v14;
          result = v8 * ((4 * a6) & 0xFFFFFFF0) + 32 * (_DWORD)v14;
          v17 = (float16x8_t *)(a2 + 2 * v15);
          v18 = (float16x8_t *)(a3 + 2 * v15);
          v19 = vaddq_f16(*v17, *v18);
          v20 = vaddq_f16(v17[1], v18[1]);
          v21 = vaddq_f16(v17[2], v18[2]);
          v22 = vaddq_f16(v17[3], v18[3]);
          v23 = (int8x16_t)vaddq_f16(vmaxq_f16(v19, (float16x8_t)0), vmulq_f16(vminq_f16(v19, (float16x8_t)0), v13));
          v24 = (int8x16_t)vaddq_f16(vmaxq_f16(v20, (float16x8_t)0), vmulq_f16(vminq_f16(v20, (float16x8_t)0), v13));
          v25 = (int8x16_t)vaddq_f16(vmaxq_f16(v21, (float16x8_t)0), vmulq_f16(vminq_f16(v21, (float16x8_t)0), v13));
          v26 = (int8x16_t)vaddq_f16(vmaxq_f16(v22, (float16x8_t)0), vmulq_f16(vminq_f16(v22, (float16x8_t)0), v13));
          v27 = (float32x4_t *)(a4 + 4 * (int)result);
          *v27 = vcvtq_f32_f16(*(float16x4_t *)v23.i8);
          v27[1] = vcvtq_f32_f16(*(float16x4_t *)v24.i8);
          v27[2] = vcvtq_f32_f16(*(float16x4_t *)v25.i8);
          v27[3] = vcvtq_f32_f16(*(float16x4_t *)v26.i8);
          v27[4] = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
          v27[5] = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
          v27[6] = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL));
          v27[7] = vcvtq_f32_f16((float16x4_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
          ++v14;
        }
        while (v12 > v14);
      }
      ++v8;
    }
    while (v8 != v9);
  }
  return result;
}

void NeonThirdBlockMelManager::do_inference(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  unint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  _DWORD *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  unint64_t v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _DWORD *v50;
  _DWORD *v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t i;
  long double v65;
  uint64_t v66;
  uint64_t conv_input_shift_by_rows;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  int v82;
  uint64_t v83;
  int v84;
  _QWORD *v85;
  unint64_t v86;
  _QWORD *v87;
  _QWORD *v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  _QWORD *v100;
  _QWORD *v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  _QWORD *v107;
  _QWORD *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  _QWORD *v114;
  _QWORD *v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  _QWORD *v121;
  _QWORD *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v130;
  uint64_t v131;
  _QWORD *v132;
  uint64_t v133;
  uint64_t *v134;

  v5 = a5;
  v6 = a4;
  v9 = a1;
  v10 = *(_QWORD *)(a1 + 144);
  if (*(_BYTE *)(v10 + 2304))
  {
    *(_QWORD *)(a1 + 192) = a2;
    *(_QWORD *)(a1 + 200) = a3;
    *(_QWORD *)(a1 + 208) = a4;
    *(_QWORD *)(a1 + 216) = a5;
    if (*(_BYTE *)(v10 + 3498))
    {
      *(_DWORD *)(a1 + 188) = 0;
LABEL_67:
      *(_OWORD *)(v9 + 80) = xmmword_214FBF8B0;
      *(_QWORD *)(v9 + 96) = 0x100000000;
      *(_DWORD *)(v9 + 184) = 2 * *(_DWORD *)(v10 + 4088);
      SynchroManager::cond_broadcast_on_entry((SynchroManager *)(v10 + 2312), *(_DWORD *)(v10 + 2308), 4);
      SynchroManager::cond_wait_less_on_exit((SynchroManager *)(*(_QWORD *)(v9 + 144) + 2312), *(_DWORD *)(*(_QWORD *)(v9 + 144) + 2308));
      return;
    }
    if (a3[1] - *a3 > 8uLL)
    {
      v11 = *(_DWORD *)(*a3 + 8);
      *(_DWORD *)(v10 + 4088) = v11;
      v12 = -v11 < 0;
      v13 = -v11 & 3;
      v14 = v11 & 3;
      if (!v12)
        v14 = -v13;
      if (v14)
      {
        v15 = 0;
        *(_DWORD *)(a1 + 188) = 4 - v14;
        v16 = *a3;
        v17 = a3[1];
        while (1)
        {
          if ((unint64_t)(v17 - v16) < 0x11)
            goto LABEL_131;
          if (*(_QWORD *)(v16 + 16))
            break;
LABEL_33:
          ++v15;
          v33 = *(_DWORD *)(v9 + 188);
          if (v15 >= v33)
          {
            v10 = *(_QWORD *)(v9 + 144);
            goto LABEL_65;
          }
        }
        v18 = 0;
        while (1)
        {
          v19 = (_DWORD *)a2[1];
          v20 = a2[2];
          if ((unint64_t)v19 >= v20)
          {
            v22 = *a2;
            v23 = ((uint64_t)v19 - *a2) >> 2;
            v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 62)
              goto LABEL_132;
            v25 = v20 - v22;
            if (v25 >> 1 > v24)
              v24 = v25 >> 1;
            v26 = (unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v24;
            v134 = a2 + 3;
            if (v26)
            {
              v27 = ENTTS::Allocator<int>::allocate((uint64_t)(a2 + 3), v26);
              v22 = *a2;
              v19 = (_DWORD *)a2[1];
            }
            else
            {
              v27 = 0;
            }
            v28 = (_DWORD *)(v27 + 4 * v23);
            *v28 = 0;
            if (v19 == (_DWORD *)v22)
            {
              v30 = v27 + 4 * v23;
            }
            else
            {
              v29 = v19;
              v30 = v27 + 4 * v23;
              do
              {
                v31 = *--v29;
                *(_DWORD *)(v30 - 4) = v31;
                v30 -= 4;
              }
              while (v29 != (_DWORD *)v22);
            }
            v21 = v28 + 1;
            *a2 = v30;
            a2[1] = (uint64_t)(v28 + 1);
            v32 = a2[2];
            a2[2] = v27 + 4 * v26;
            v132 = v19;
            v133 = v32;
            v130 = v22;
            v131 = v22;
            a1 = std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&v130);
            v16 = *a3;
            v17 = a3[1];
          }
          else
          {
            *v19 = 0;
            v21 = v19 + 1;
          }
          a2[1] = (uint64_t)v21;
          if ((unint64_t)(v17 - v16) <= 0x10)
            break;
          if (*(_QWORD *)(v16 + 16) <= (unint64_t)++v18)
            goto LABEL_33;
        }
      }
      else
      {
        v33 = 0;
        *(_DWORD *)(a1 + 188) = 0;
        v16 = *a3;
        v17 = a3[1];
LABEL_65:
        v56 = *(_DWORD *)(v10 + 4088) + v33;
        *(_DWORD *)(v10 + 4088) = v56;
        if ((unint64_t)(v17 - v16) > 0x10)
        {
          SplitMELManager::neon_convert_f2h_column(a1, *a2, *(_QWORD *)(v10 + 2776), *(_DWORD *)(v16 + 16), v56);
          v10 = *(_QWORD *)(v9 + 144);
          goto LABEL_67;
        }
      }
    }
    goto LABEL_131;
  }
  if (*(_BYTE *)(v10 + 3498))
  {
    *(_DWORD *)(a1 + 188) = 0;
  }
  else
  {
    if (a3[1] - *a3 <= 8uLL)
      goto LABEL_131;
    v34 = *(_DWORD *)(*a3 + 8);
    *(_DWORD *)(v10 + 4088) = v34;
    v12 = -v34 < 0;
    v35 = -v34 & 3;
    v36 = v34 & 3;
    if (!v12)
      v36 = -v35;
    if (v36)
    {
      v37 = 0;
      *(_DWORD *)(a1 + 188) = 4 - v36;
      v38 = *a3;
      v39 = a3[1];
      while (1)
      {
        if ((unint64_t)(v39 - v38) < 0x11)
          goto LABEL_131;
        if (*(_QWORD *)(v38 + 16))
          break;
LABEL_62:
        ++v37;
        v55 = *(_DWORD *)(v9 + 188);
        if (v37 >= v55)
        {
          v10 = *(_QWORD *)(v9 + 144);
          v6 = a4;
          v5 = a5;
          goto LABEL_69;
        }
      }
      v40 = 0;
      while (1)
      {
        v41 = (_DWORD *)a2[1];
        v42 = a2[2];
        if ((unint64_t)v41 >= v42)
        {
          v44 = *a2;
          v45 = ((uint64_t)v41 - *a2) >> 2;
          v46 = v45 + 1;
          if ((unint64_t)(v45 + 1) >> 62)
LABEL_132:
            std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
          v47 = v42 - v44;
          if (v47 >> 1 > v46)
            v46 = v47 >> 1;
          v48 = (unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v46;
          v134 = a2 + 3;
          if (v48)
          {
            v49 = ENTTS::Allocator<int>::allocate((uint64_t)(a2 + 3), v48);
            v44 = *a2;
            v41 = (_DWORD *)a2[1];
          }
          else
          {
            v49 = 0;
          }
          v50 = (_DWORD *)(v49 + 4 * v45);
          *v50 = 0;
          if (v41 == (_DWORD *)v44)
          {
            v52 = v49 + 4 * v45;
          }
          else
          {
            v51 = v41;
            v52 = v49 + 4 * v45;
            do
            {
              v53 = *--v51;
              *(_DWORD *)(v52 - 4) = v53;
              v52 -= 4;
            }
            while (v51 != (_DWORD *)v44);
          }
          v43 = v50 + 1;
          *a2 = v52;
          a2[1] = (uint64_t)(v50 + 1);
          v54 = a2[2];
          a2[2] = v49 + 4 * v48;
          v132 = v41;
          v133 = v54;
          v130 = v44;
          v131 = v44;
          a1 = std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&v130);
          v38 = *a3;
          v39 = a3[1];
        }
        else
        {
          *v41 = 0;
          v43 = v41 + 1;
        }
        a2[1] = (uint64_t)v43;
        if ((unint64_t)(v39 - v38) <= 0x10)
          goto LABEL_131;
        if (*(_QWORD *)(v38 + 16) <= (unint64_t)++v40)
          goto LABEL_62;
      }
    }
    v55 = 0;
    *(_DWORD *)(a1 + 188) = 0;
    v38 = *a3;
    v39 = a3[1];
LABEL_69:
    v57 = *(_DWORD *)(v10 + 4088) + v55;
    *(_DWORD *)(v10 + 4088) = v57;
    if ((unint64_t)(v39 - v38) <= 0x10)
LABEL_131:
      std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
    SplitMELManager::neon_convert_f2h_column(a1, *a2, *(_QWORD *)(v10 + 2776), *(_DWORD *)(v38 + 16), v57);
    v10 = *(_QWORD *)(v9 + 144);
  }
  *(_OWORD *)(v9 + 80) = xmmword_214FBF8B0;
  *(_QWORD *)(v9 + 96) = 0x100000000;
  v58 = *(_DWORD *)(v10 + 4088);
  *(_DWORD *)(v9 + 184) = 2 * v58;
  SplitMELManager::neon_transpose_rows(a1, *(_QWORD *)(v10 + 3288), *(float16x8_t **)(v10 + 2776), *(_QWORD *)(v10 + 2792), 0x60u, 0x30u, v58, 2 * v58, 4, 2, 0, *(_DWORD *)(v10 + 2308));
  v59 = *(_QWORD *)(v9 + 144);
  SplitMELManager::neon_transpose_rearrange_rows_2(v60, *(_QWORD *)(v59 + 2792), *(_QWORD *)(v59 + 2800), *(_QWORD *)(v59 + 3296), *(_DWORD *)(v9 + 84), *(_DWORD *)(v59 + 4088), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 92), 0, *(_DWORD *)(v59 + 2308));
  SplitMELManager::neon_block_input(v61, *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2800), *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2816), *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2808), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 84), 0, *(_DWORD *)(*(_QWORD *)(v9 + 144) + 2308));
  v62 = 0;
  v63 = 3304;
  for (i = 3432; ; i += 16)
  {
    v65 = pow(3.0, (double)v62);
    *(_DWORD *)(v9 + 104) = (int)v65;
    *(_DWORD *)(v9 + 108) = (int)v65;
    conv_input_shift_by_rows = SplitMELManager::neon_first_conv_input_shift_by_rows(v9, *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2808), *(_QWORD *)(*(_QWORD *)(v9 + 144) + 2784), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 84), v66, (int)v65, 6 * (int)v65, 0, *(_DWORD *)(*(_QWORD *)(v9 + 144) + 2308));
    v68 = *(_QWORD *)(v9 + 144);
    SplitMELManager::neon_first_conv_cols(conv_input_shift_by_rows, *(_QWORD *)(v68 + v63), *(_QWORD *)(v68 + v63 + 8), *(_QWORD *)(v68 + 2784), *(_QWORD *)(v68 + 2824), v69, *(_DWORD *)(v9 + 108), *(_DWORD *)(v9 + 84), 4 * conv_input_shift_by_rows * *(_DWORD *)(v9 + 108), 0, *(_DWORD *)(v68 + 2308));
    v70 = *(_QWORD *)(v9 + 144);
    SplitMELManager::neon_conv_single_kernel_cols(v71, *(_QWORD *)(v70 + v63 + 16), *(_QWORD *)(v70 + v63 + 24), *(float16x4_t **)(v70 + 2824), *(_QWORD *)(v70 + 2832), *(_DWORD *)(v9 + 84), *(_DWORD *)(v9 + 184), 0, *(_DWORD *)(v70 + 2308));
    v72 = *(_QWORD *)(v9 + 144);
    SplitMELManager::neon_conv_single_kernel_cols(v73, *(_QWORD *)(v72 + i), *(_QWORD *)(v72 + i + 8), *(float16x4_t **)(v72 + 2816), *(_QWORD *)(v72 + 2824), *(_DWORD *)(v9 + 84), *(_DWORD *)(v9 + 184), 0, *(_DWORD *)(v72 + 2308));
    v75 = *(_QWORD *)(v9 + 144);
    if (v63 == 3400)
      break;
    SplitMELManager::neon_add_signals(v74, *(_QWORD *)(v75 + 2832), *(_QWORD *)(v75 + 2824), *(_QWORD *)(v75 + 2816), *(_QWORD *)(v75 + 2808), *(_DWORD *)(v9 + 184), *(_DWORD *)(v9 + 84), 0, *(_DWORD *)(v75 + 2308));
    v63 += 32;
    ++v62;
  }
  v76 = *(_QWORD *)(v75 + 2832);
  v77 = *(_QWORD *)(v75 + 2824);
  v78 = *(_QWORD *)(v75 + 2848);
  v79 = *(_DWORD *)(v9 + 184);
  v80 = *(_DWORD *)(v9 + 84);
  v81 = *(_DWORD *)(v75 + 2308);
  if (*(_BYTE *)(v75 + 3500))
    SplitMELManager::neon_add_signals_relu_tensor(v74, v76, v77, v78, v79, v80, 0, v81);
  else
    SplitMELManager::neon_add_signals_relu_colums(v74, v76, v77, v78, v79, v80, 0, v81);
  v82 = *(_DWORD *)(v9 + 184);
  v83 = *(_QWORD *)(v9 + 144);
  *(_DWORD *)(v83 + 4088) = v82;
  if (!*(_BYTE *)(v83 + 3500))
  {
    v84 = v82 - 2 * *(_DWORD *)(v9 + 188);
    *(_DWORD *)(v83 + 4088) = v84;
    v85 = (_QWORD *)v5[1];
    v86 = v5[2];
    if ((unint64_t)v85 >= v86)
    {
      v88 = (_QWORD *)*v5;
      v89 = ((uint64_t)v85 - *v5) >> 3;
      v90 = v89 + 1;
      if ((unint64_t)(v89 + 1) >> 61)
        goto LABEL_133;
      v91 = v86 - (_QWORD)v88;
      if (v91 >> 2 > v90)
        v90 = v91 >> 2;
      if ((unint64_t)v91 >= 0x7FFFFFFFFFFFFFF8)
        v92 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v92 = v90;
      v134 = v5 + 3;
      if (v92)
      {
        v93 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v92);
        v88 = (_QWORD *)*v5;
        v85 = (_QWORD *)v5[1];
      }
      else
      {
        v93 = 0;
      }
      v94 = (_QWORD *)(v93 + 8 * v89);
      *v94 = 1;
      if (v85 == v88)
      {
        v96 = v93 + 8 * v89;
      }
      else
      {
        v95 = v85;
        v96 = v93 + 8 * v89;
        do
        {
          v97 = *--v95;
          *(_QWORD *)(v96 - 8) = v97;
          v96 -= 8;
        }
        while (v95 != v88);
      }
      v87 = v94 + 1;
      *v5 = v96;
      v5[1] = (uint64_t)(v94 + 1);
      v98 = v5[2];
      v5[2] = v93 + 8 * v92;
      v132 = v85;
      v133 = v98;
      v130 = (uint64_t)v88;
      v131 = (uint64_t)v88;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v130);
      v84 = *(_DWORD *)(*(_QWORD *)(v9 + 144) + 4088);
      v86 = v5[2];
    }
    else
    {
      *v85 = 1;
      v87 = v85 + 1;
    }
    v5[1] = (uint64_t)v87;
    v99 = v84;
    if ((unint64_t)v87 >= v86)
    {
      v101 = (_QWORD *)*v5;
      v102 = ((uint64_t)v87 - *v5) >> 3;
      v103 = v102 + 1;
      if ((unint64_t)(v102 + 1) >> 61)
        goto LABEL_133;
      v104 = v86 - (_QWORD)v101;
      if (v104 >> 2 > v103)
        v103 = v104 >> 2;
      if ((unint64_t)v104 >= 0x7FFFFFFFFFFFFFF8)
        v105 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v105 = v103;
      v134 = v5 + 3;
      if (v105)
      {
        v106 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v105);
        v101 = (_QWORD *)*v5;
        v87 = (_QWORD *)v5[1];
      }
      else
      {
        v106 = 0;
      }
      v107 = (_QWORD *)(v106 + 8 * v102);
      *v107 = v99;
      if (v87 == v101)
      {
        v109 = v106 + 8 * v102;
      }
      else
      {
        v108 = v87;
        v109 = v106 + 8 * v102;
        do
        {
          v110 = *--v108;
          *(_QWORD *)(v109 - 8) = v110;
          v109 -= 8;
        }
        while (v108 != v101);
      }
      v100 = v107 + 1;
      *v5 = v109;
      v5[1] = (uint64_t)(v107 + 1);
      v111 = v5[2];
      v5[2] = v106 + 8 * v105;
      v132 = v87;
      v133 = v111;
      v130 = (uint64_t)v101;
      v131 = (uint64_t)v101;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v130);
      v86 = v5[2];
    }
    else
    {
      *v87 = v84;
      v100 = v87 + 1;
    }
    v5[1] = (uint64_t)v100;
    v112 = *(_DWORD *)(v9 + 84);
    v113 = v112;
    if ((unint64_t)v100 < v86)
    {
      *v100 = v112;
      v114 = v100 + 1;
LABEL_129:
      v5[1] = (uint64_t)v114;
      v126 = *(_QWORD *)(v9 + 144);
      v127 = *(int *)(v126 + 4088) * (uint64_t)v112;
      std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(v6, *(char **)(v126 + 2848), *(_QWORD *)(v126 + 2848) + 4 * v127, v127);
      *(_DWORD *)(v9 + 188) = 0;
      return;
    }
    v115 = (_QWORD *)*v5;
    v116 = ((uint64_t)v100 - *v5) >> 3;
    v117 = v116 + 1;
    if (!((unint64_t)(v116 + 1) >> 61))
    {
      v118 = v86 - (_QWORD)v115;
      if (v118 >> 2 > v117)
        v117 = v118 >> 2;
      if ((unint64_t)v118 >= 0x7FFFFFFFFFFFFFF8)
        v119 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v119 = v117;
      v134 = v5 + 3;
      if (v119)
      {
        v120 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v5 + 3), v119);
        v115 = (_QWORD *)*v5;
        v100 = (_QWORD *)v5[1];
      }
      else
      {
        v120 = 0;
      }
      v121 = (_QWORD *)(v120 + 8 * v116);
      *v121 = v113;
      if (v100 == v115)
      {
        v123 = v120 + 8 * v116;
      }
      else
      {
        v122 = v100;
        v123 = v120 + 8 * v116;
        do
        {
          v124 = *--v122;
          *(_QWORD *)(v123 - 8) = v124;
          v123 -= 8;
        }
        while (v122 != v115);
      }
      v114 = v121 + 1;
      *v5 = v123;
      v5[1] = (uint64_t)(v121 + 1);
      v125 = v5[2];
      v5[2] = v120 + 8 * v119;
      v132 = v100;
      v133 = v125;
      v130 = (uint64_t)v115;
      v131 = (uint64_t)v115;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v130);
      v112 = *(_DWORD *)(v9 + 84);
      goto LABEL_129;
    }
LABEL_133:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  }
}

char **NeonPqmfBlockMelManager::NeonPqmfBlockMelManager(char **a1, char *a2, uint64_t a3, uint64_t a4, char **a5)
{
  char **v7;
  uint64_t v8;
  NeonMELContainer *v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  _QWORD v13[13];
  char v14;
  uint64_t v15;
  void *v16;
  std::locale v17;

  a1[19] = 0;
  v7 = a1 + 19;
  a1[1] = 0;
  a1[2] = 0;
  a1[14] = 0;
  a1[15] = 0;
  v8 = CustomAllocator::mRsrc;
  a1[16] = 0;
  a1[17] = (char *)v8;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = (char *)v8;
  a1[28] = 0;
  a1[29] = 0;
  a1[18] = a2;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v13);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::operator=(v7, a5);
  NeonPqmfBlockMelManager::ModelNpy((uint64_t)a1, (uint64_t)v13);
  v9 = (NeonMELContainer *)a1[18];
  *((_BYTE *)v9 + 3500) = 0;
  if (*((_BYTE *)v9 + 2304)
    && (NeonMELContainer::EngineMCSetUp(v9, a1, 4, (void (*)(void *, int))mc_PqmfBlock_do_inference) & 1) == 0)
  {
    v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"WARNING: error set up multi-core engine", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
    v11 = std::locale::use_facet(&v17, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
    std::locale::~locale(&v17);
    std::ostream::put();
    std::ostream::flush();
  }
  v13[0] = &unk_24D29B388;
  v13[2] = &unk_24D29B3B0;
  v16 = &unk_24D29B3D8;
  v13[3] = &unk_24D29B578;
  if (v14 < 0)
    heap_Free(*(_QWORD **)(v15 + 8), v13[11]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v16);
  return a1;
}

void sub_214EB2F8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  SplitMELManager *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  std::locale::~locale((std::locale *)(v5 - 56));
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)va);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v4);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v3);
  SplitMELManager::~SplitMELManager(v2);
  _Unwind_Resume(a1);
}

uint64_t NeonPqmfBlockMelManager::ModelNpy(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  const std::locale::facet *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  _QWORD *v34;
  const std::locale::facet *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  const std::locale::facet *v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  _QWORD *v65;
  const std::locale::facet *v66;
  uint64_t v68[2];
  char v69;
  uint64_t v70;
  uint64_t v71[2];
  char v72;
  uint64_t v73;
  uint64_t v74[2];
  char v75;
  uint64_t v76;
  std::locale v77;
  void *v78;
  void *v79;
  uint64_t v80;
  char v81;
  uint64_t v82;
  _QWORD v83[19];
  std::locale v84;
  void *v85;
  _QWORD v86[10];
  char v87;
  uint64_t v88;
  void *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;

  v94 = 0;
  v95 = 0;
  v96 = 0;
  v97 = CustomAllocator::mRsrc;
  v90 = 0;
  v91 = 0;
  v92 = 0;
  v93 = CustomAllocator::mRsrc;
  v3 = (_QWORD *)(a2 + 16);
  v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a2 + 16), (uint64_t)"path: ", 6);
  v5 = *(char *)(a1 + 175);
  if (v5 >= 0)
    v6 = a1 + 152;
  else
    v6 = *(_QWORD *)(a1 + 152);
  if (v5 >= 0)
    v7 = *(unsigned __int8 *)(a1 + 175);
  else
    v7 = *(_QWORD *)(a1 + 160);
  v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, v6, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24)));
  v9 = std::locale::use_facet(&v84, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v84);
  std::ostream::put();
  std::ostream::flush();
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v84);
  *(_QWORD *)(a1 + 80) = 0x3000000060;
  *(_DWORD *)(a1 + 88) = 4;
  v95 = v94;
  v91 = v90;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v77);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v77, (uint64_t *)&v84);
  v77.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v78 = &unk_24D29B3B0;
  v83[0] = &unk_24D29B3D8;
  v79 = &unk_24D29B578;
  if (v81 < 0)
    heap_Free(*(_QWORD **)(v82 + 8), v80);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v83);
  v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v85, (uint64_t)"final/layer/conv/weight", 23);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"/npy", 4);
  v11 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v86, v74);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v11 + 16))(v11, v74, &v94, &v90, 1);
  if (v75 < 0)
    heap_Free(*(_QWORD **)(v76 + 8), v74[0]);
  if (v91 == v90)
  {
    v34 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"error: final_layer_conv_weight", 30);
    std::ios_base::getloc((const std::ios_base *)((char *)v34 + *(_QWORD *)(*v34 - 24)));
    v35 = std::locale::use_facet(&v77, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 10);
    std::locale::~locale(&v77);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v12 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 112 * *(int *)(a1 + 84));
    v13 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 112 * *(int *)(a1 + 84));
    v15 = 0;
    v16 = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2736) = v13;
    v17 = *(_DWORD *)(a1 + 84);
    v18 = v90;
    v19 = (v91 - v90) >> 2;
    v20 = (4 * v17);
    do
    {
      if (v17 >= 1)
      {
        v21 = 0;
        v22 = v16;
        v23 = v15;
        do
        {
          v24 = 0;
          LODWORD(v14) = v22;
          do
          {
            if (v19 <= (int)v14)
              std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
            *(_DWORD *)(v12 + 4 * (v23 + (int)v24++)) = *(_DWORD *)(v18 + 4 * (int)v14);
            v14 = (v14 + 7 * v17);
          }
          while (v24 != 4);
          ++v21;
          v23 += 4;
          v22 += 7;
        }
        while (v21 != v17);
      }
      ++v16;
      v15 += v20;
    }
    while (v16 != 7);
    v25 = 0;
    v26 = 0;
    v27 = 0;
    do
    {
      if (v17 >= 4)
      {
        v28 = 0;
        v29 = v25;
        do
        {
          v30 = 0;
          v14 = v29;
          do
          {
            v31 = 0;
            v32 = v27;
            v33 = v13 + 4 * v27;
            do
            {
              *(_DWORD *)(v33 + 4 * v31) = *(_DWORD *)(v12 + 4 * ((int)v14 + (int)v31));
              ++v31;
            }
            while (v31 != 4);
            v27 = v32 + 4;
            ++v30;
            v14 += 4;
          }
          while (v30 != 4);
          ++v28;
          v27 = v32 + 4;
          v29 += 16;
        }
        while (v28 != v17 / 4);
        v27 = v32 + 4;
      }
      ++v26;
      v25 += v20;
    }
    while (v26 != 7);
    (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v12, v14);
  }
  v95 = v94;
  v91 = v90;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v77);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v77, (uint64_t *)&v84);
  v77.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v83[0] = &unk_24D29B3D8;
  v78 = &unk_24D29B3B0;
  v79 = &unk_24D29B578;
  if (v81 < 0)
    heap_Free(*(_QWORD **)(v82 + 8), v80);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v83);
  v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v85, (uint64_t)"final/layer/conv/bias", 21);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)"/npy", 4);
  v37 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v86, v71);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v37 + 16))(v37, v71, &v94, &v90, 1);
  if (v72 < 0)
    heap_Free(*(_QWORD **)(v73 + 8), v71[0]);
  if (v91 == v90)
  {
    v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"error: final_layer_conv1_bias", 29);
    std::ios_base::getloc((const std::ios_base *)((char *)v42 + *(_QWORD *)(*v42 - 24)));
    v43 = std::locale::use_facet(&v77, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
    std::locale::~locale(&v77);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v38 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 16);
    v39 = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2744) = v38;
    v40 = v90;
    v41 = (v91 - v90) >> 2;
    do
    {
      if (v41 == v39)
        std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
      *(_DWORD *)(v38 + 4 * v39) = *(_DWORD *)(v40 + 4 * v39);
      ++v39;
    }
    while (v39 != 4);
  }
  v95 = v94;
  v91 = v90;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v77);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v77, (uint64_t *)&v84);
  v77.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v83[0] = &unk_24D29B3D8;
  v78 = &unk_24D29B3B0;
  v79 = &unk_24D29B578;
  if (v81 < 0)
    heap_Free(*(_QWORD **)(v82 + 8), v80);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v83);
  v44 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v85, (uint64_t)"pqmf/conv/weight", 16);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)"/npy", 4);
  v45 = *(_QWORD *)(a1 + 224);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str((uint64_t)v86, v68);
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)v45 + 16))(v45, v68, &v94, &v90, 1);
  if (v69 < 0)
    heap_Free(*(_QWORD **)(v70 + 8), v68[0]);
  if (v91 == v90)
  {
    v65 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"error: pqmf_conv_weight", 23);
    std::ios_base::getloc((const std::ios_base *)((char *)v65 + *(_QWORD *)(*v65 - 24)));
    v66 = std::locale::use_facet(&v77, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v66->__vftable[2].~facet_0)(v66, 10);
    std::locale::~locale(&v77);
    std::ostream::put();
    std::ostream::flush();
  }
  else
  {
    v46 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 1008);
    v47 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 32))(*(_QWORD *)(a1 + 224), 1024);
    v48 = 0;
    v49 = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 2752) = v47;
    v50 = v90;
    v51 = (v91 - v90) >> 2;
    do
    {
      v52 = 63;
      v53 = v48;
      do
      {
        if (v51 <= v53)
          std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
        *(_DWORD *)(v46 + 4 * v53) = *(_DWORD *)(v50 + 4 * v53);
        ++v53;
        --v52;
      }
      while (v52);
      ++v49;
      v48 += 63;
    }
    while (v49 != 4);
    v54 = 0;
    LODWORD(v55) = 0;
    v56 = v46;
    do
    {
      v57 = 0;
      v58 = v56;
      do
      {
        v59 = 0;
        v55 = (int)v55;
        do
        {
          *(_DWORD *)(v47 + 4 * v55++) = *(_DWORD *)(v58 + v59);
          v59 += 252;
        }
        while (v59 != 1008);
        ++v57;
        v58 += 4;
      }
      while (v57 != 4);
      ++v54;
      v56 += 16;
    }
    while (v54 != 15);
    v60 = 0;
    v61 = v46 + 240;
    do
    {
      v62 = 0;
      v63 = v55 << 32;
      v55 = (int)v55;
      do
      {
        *(_DWORD *)(v47 + 4 * v55++) = *(_DWORD *)(v61 + v62);
        v63 += 0x100000000;
        v62 += 252;
      }
      while (v62 != 1008);
      ++v60;
      v61 += 4;
    }
    while (v60 != 3);
    v64 = (_QWORD *)(v47 + (v63 >> 30));
    *v64 = 0;
    v64[1] = 0;
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 224) + 56))(*(_QWORD *)(a1 + 224), v46);
  }
  v84.__locale_ = (std::locale::__imp *)&unk_24D29B388;
  v89 = &unk_24D29B3D8;
  v85 = &unk_24D29B3B0;
  v86[0] = &unk_24D29B578;
  if (v87 < 0)
    heap_Free(*(_QWORD **)(v88 + 8), v86[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](&v89);
  v84.__locale_ = (std::locale::__imp *)&v90;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v84);
  v84.__locale_ = (std::locale::__imp *)&v94;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)&v84);
  return 1;
}

void sub_214EB38E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,std::locale a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,std::locale a58)
{
  uint64_t v58;

  std::locale::~locale(&a22);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream((uint64_t)&a58);
  *(_QWORD *)(v58 - 88) = v58 - 152;
  std::vector<float,ENTTS::Allocator<float>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v58 - 88));
  *(_QWORD *)(v58 - 152) = v58 - 120;
  std::vector<unsigned long,ENTTS::Allocator<unsigned long>>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)(v58 - 152));
  _Unwind_Resume(a1);
}

uint64_t mc_PqmfBlock_do_inference(void *a1, unsigned int a2)
{
  SplitMELManager *v4;
  uint64_t v5;
  unsigned int v6;
  SplitMELManager *v7;
  unsigned int v8;
  uint64_t v9;
  SplitMELManager *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t *v34;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  unint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v62;
  _QWORD *v63;
  _QWORD *v64;
  _QWORD *v65;
  uint64_t v66;
  _QWORD *v67;

  SplitMELManager::neon_final_conv_input_shift_by_columns((SplitMELManager *)a1, *(float **)(*((_QWORD *)a1 + 18) + 2848), *(float **)(*((_QWORD *)a1 + 18) + 2856), *(_DWORD *)(*((_QWORD *)a1 + 18) + 4088), *((_DWORD *)a1 + 21), a2, *(_DWORD *)(*((_QWORD *)a1 + 18) + 2308));
  v4 = (SplitMELManager *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 18) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 18) + 2656));
  v5 = *((_QWORD *)a1 + 18);
  SplitMELManager::neon_final_conv_cols(v4, *(float **)(v5 + 2736), *(float **)(v5 + 2744), *(float **)(v5 + 2856), *(float **)(v5 + 2848), v6, *((_DWORD *)a1 + 21), 4u, *(_DWORD *)(v5 + 4088), a2, *(_DWORD *)(v5 + 2308));
  v7 = (SplitMELManager *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)a1 + 18) + 2656) + 8))(*(_QWORD *)(*((_QWORD *)a1 + 18) + 2656));
  v9 = *((_QWORD *)a1 + 18);
  if (!a2)
  {
    v10 = (SplitMELManager *)SplitMELManager::neon_pqmf_shift_by_columns(v7, *(float **)(v9 + 2848), *(float **)(v9 + 2856), v8, 0x20u, 4u, *(_DWORD *)(v9 + 4088));
    SplitMELManager::neon_pqmf_compressed(v10, *(float32x4_t **)(*((_QWORD *)a1 + 18) + 2752), *(float **)(*((_QWORD *)a1 + 18) + 2856), *(float **)(*((_QWORD *)a1 + 18) + 2864), 0x40u, v11, v12, 4 * *(_DWORD *)(*((_QWORD *)a1 + 18) + 4088), v62);
    v13 = *((_QWORD *)a1 + 18);
    v14 = 4 * *(_DWORD *)(v13 + 4088) - (*(_DWORD *)(v13 + 4092) << 8) - 1024;
    *(_DWORD *)(v13 + 4088) = v14;
    v15 = (uint64_t *)*((_QWORD *)a1 + 27);
    v16 = (_QWORD *)v15[1];
    v17 = v15[2];
    if ((unint64_t)v16 >= v17)
    {
      v20 = (_QWORD *)*v15;
      v21 = ((uint64_t)v16 - *v15) >> 3;
      v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61)
        goto LABEL_55;
      v23 = v17 - (_QWORD)v20;
      if (v23 >> 2 > v22)
        v22 = v23 >> 2;
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
        v24 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v24 = v22;
      v67 = v15 + 3;
      if (v24)
      {
        v25 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v15 + 3), v24);
        v20 = (_QWORD *)*v15;
        v16 = (_QWORD *)v15[1];
      }
      else
      {
        v25 = 0;
      }
      v26 = (_QWORD *)(v25 + 8 * v21);
      *v26 = 1;
      if (v16 == v20)
      {
        v28 = v25 + 8 * v21;
      }
      else
      {
        v27 = v16;
        v28 = v25 + 8 * v21;
        do
        {
          v29 = *--v27;
          *(_QWORD *)(v28 - 8) = v29;
          v28 -= 8;
        }
        while (v27 != v20);
      }
      v19 = v26 + 1;
      *v15 = v28;
      v63 = v20;
      v64 = v20;
      v15[1] = (uint64_t)(v26 + 1);
      v65 = v16;
      v30 = v15[2];
      v15[2] = v25 + 8 * v24;
      v66 = v30;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v63);
      v18 = (uint64_t *)*((_QWORD *)a1 + 27);
      v14 = *(_DWORD *)(*((_QWORD *)a1 + 18) + 4088);
    }
    else
    {
      *v16 = 1;
      v18 = v15;
      v19 = v16 + 1;
    }
    v15[1] = (uint64_t)v19;
    v31 = v14;
    v32 = (_QWORD *)v18[1];
    v33 = v18[2];
    if ((unint64_t)v32 >= v33)
    {
      v36 = (_QWORD *)*v18;
      v37 = ((uint64_t)v32 - *v18) >> 3;
      v38 = v37 + 1;
      if ((unint64_t)(v37 + 1) >> 61)
        std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
      v39 = v33 - (_QWORD)v36;
      if (v39 >> 2 > v38)
        v38 = v39 >> 2;
      if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8)
        v40 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v40 = v38;
      v67 = v18 + 3;
      if (v40)
      {
        v41 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v18 + 3), v40);
        v36 = (_QWORD *)*v18;
        v32 = (_QWORD *)v18[1];
      }
      else
      {
        v41 = 0;
      }
      v42 = (_QWORD *)(v41 + 8 * v37);
      *v42 = v31;
      if (v32 == v36)
      {
        v44 = v41 + 8 * v37;
      }
      else
      {
        v43 = v32;
        v44 = v41 + 8 * v37;
        do
        {
          v45 = *--v43;
          *(_QWORD *)(v44 - 8) = v45;
          v44 -= 8;
        }
        while (v43 != v36);
      }
      v35 = v42 + 1;
      *v18 = v44;
      v63 = v36;
      v64 = v36;
      v18[1] = (uint64_t)(v42 + 1);
      v65 = v32;
      v46 = v18[2];
      v18[2] = v41 + 8 * v40;
      v66 = v46;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v63);
      v34 = (uint64_t *)*((_QWORD *)a1 + 27);
    }
    else
    {
      *v32 = v14;
      v34 = v18;
      v35 = v32 + 1;
    }
    v18[1] = (uint64_t)v35;
    v47 = (_QWORD *)v34[1];
    v48 = v34[2];
    if ((unint64_t)v47 < v48)
    {
      *v47 = 1;
      v49 = v47 + 1;
LABEL_53:
      v34[1] = (uint64_t)v49;
      std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(*((uint64_t **)a1 + 26), *(char **)(*((_QWORD *)a1 + 18) + 2864), *(_QWORD *)(*((_QWORD *)a1 + 18) + 2864) + 4 * *(int *)(*((_QWORD *)a1 + 18) + 4088), *(int *)(*((_QWORD *)a1 + 18) + 4088));
      v9 = *((_QWORD *)a1 + 18);
      *(_DWORD *)(v9 + 4092) = 0;
      return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v9 + 2656) + 8))(*(_QWORD *)(v9 + 2656));
    }
    v50 = (_QWORD *)*v34;
    v51 = ((uint64_t)v47 - *v34) >> 3;
    v52 = v51 + 1;
    if (!((unint64_t)(v51 + 1) >> 61))
    {
      v53 = v48 - (_QWORD)v50;
      if (v53 >> 2 > v52)
        v52 = v53 >> 2;
      if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
        v54 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v54 = v52;
      v67 = v34 + 3;
      if (v54)
      {
        v55 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(v34 + 3), v54);
        v50 = (_QWORD *)*v34;
        v47 = (_QWORD *)v34[1];
      }
      else
      {
        v55 = 0;
      }
      v56 = (_QWORD *)(v55 + 8 * v51);
      *v56 = 1;
      if (v47 == v50)
      {
        v58 = v55 + 8 * v51;
      }
      else
      {
        v57 = v47;
        v58 = v55 + 8 * v51;
        do
        {
          v59 = *--v57;
          *(_QWORD *)(v58 - 8) = v59;
          v58 -= 8;
        }
        while (v57 != v50);
      }
      v49 = v56 + 1;
      *v34 = v58;
      v63 = v50;
      v64 = v50;
      v34[1] = (uint64_t)(v56 + 1);
      v65 = v47;
      v60 = v34[2];
      v34[2] = v55 + 8 * v54;
      v66 = v60;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v63);
      goto LABEL_53;
    }
LABEL_55:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v9 + 2656) + 8))(*(_QWORD *)(v9 + 2656));
}

_QWORD *NeonPqmfBlockMelManager::NeonPqmfBlockMelManager(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v4;
  uint64_t v5;
  NeonMELContainer *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  std::locale v10;

  a1[19] = 0;
  v4 = a1 + 19;
  a1[1] = 0;
  a1[2] = 0;
  a1[14] = 0;
  a1[15] = 0;
  v5 = CustomAllocator::mRsrc;
  a1[16] = 0;
  a1[17] = v5;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = v5;
  a1[28] = 0;
  a1[29] = 0;
  a1[18] = a2;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100](a1 + 28, a3);
  v6 = (NeonMELContainer *)*(v4 - 1);
  *((_BYTE *)v6 + 3500) = 0;
  if (*((_BYTE *)v6 + 2304)
    && (NeonMELContainer::EngineMCSetUp(v6, a1, 4, (void (*)(void *, int))mc_PqmfBlock_do_inference) & 1) == 0)
  {
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"WARNING: error set up multi-core engine", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v10, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v10);
    std::ostream::put();
    std::ostream::flush();
  }
  return a1;
}

void sub_214EB3EB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  SplitMELManager *v10;
  uint64_t v11;
  uint64_t v12;

  std::locale::~locale(&a10);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100](v12);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string(v11);
  SplitMELManager::~SplitMELManager(v10);
  _Unwind_Resume(a1);
}

void NeonPqmfBlockMelManager::~NeonPqmfBlockMelManager(NeonPqmfBlockMelManager *this)
{
  char *v2;

  v2 = (char *)this + 224;
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 2736));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 2744));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 28) + 56))(*((_QWORD *)this + 28), *(_QWORD *)(*((_QWORD *)this + 18) + 2752));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)v2);
  if (*((char *)this + 175) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 22) + 8), *((_QWORD *)this + 19));
  if (*((char *)this + 135) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 17) + 8), *((_QWORD *)this + 14));
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

uint64_t SplitMELManager::neon_final_conv_input_shift_by_columns(SplitMELManager *this, float *a2, float *a3, int a4, unsigned int a5, int a6, unsigned int a7)
{
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t result;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  float *v25;
  __int128 v26;
  float *v27;
  float *v28;
  float *v29;
  float *v30;
  float *v31;
  float *v32;
  float *v33;

  v7 = a5 >> 2;
  v8 = (a5 >> 2) / a7 * a6;
  v9 = v8 + (a5 >> 2) / a7;
  if (v8 < v9)
  {
    v10 = 16 * v7;
    v11 = 48 * v7;
    v12 = 32 * v7;
    v13 = v7 << 6;
    v14 = (a4 / 4 * v7) << 6;
    do
    {
      v15 = 16 * v8;
      v16 = 0uLL;
      v17 = 0uLL;
      v18 = 0uLL;
      if (a4 >= 4)
      {
        v19 = 0;
        result = v15;
        v21 = 0uLL;
        v22 = (a4 / 4);
        v23 = 0uLL;
        v24 = 0uLL;
        do
        {
          v25 = &a2[v15 + v19 * v10];
          v26 = *(_OWORD *)v25;
          v18 = *((_OWORD *)v25 + 1);
          v17 = *((_OWORD *)v25 + 2);
          v16 = *((_OWORD *)v25 + 3);
          v27 = &a3[v15 + v19 * v13];
          *(_OWORD *)v27 = v21;
          *((_OWORD *)v27 + 1) = v23;
          *((_OWORD *)v27 + 2) = v24;
          *((_OWORD *)v27 + 3) = v26;
          v28 = &v27[v10];
          *(_OWORD *)v28 = v23;
          *((_OWORD *)v28 + 1) = v24;
          *((_OWORD *)v28 + 2) = v26;
          *((_OWORD *)v28 + 3) = v18;
          v29 = &v27[v12];
          *(_OWORD *)v29 = v24;
          *((_OWORD *)v29 + 1) = v26;
          *((_OWORD *)v29 + 2) = v18;
          *((_OWORD *)v29 + 3) = v17;
          v30 = &v27[v11];
          *(_OWORD *)v30 = v26;
          *((_OWORD *)v30 + 1) = v18;
          ++v19;
          *((_OWORD *)v30 + 2) = v17;
          *((_OWORD *)v30 + 3) = v16;
          v21 = v18;
          v23 = v17;
          v24 = v16;
          --v22;
        }
        while (v22);
      }
      v31 = &a3[v15 + v14];
      *(_OWORD *)v31 = v18;
      *((_OWORD *)v31 + 1) = v17;
      *((_OWORD *)v31 + 2) = v16;
      *((_QWORD *)v31 + 6) = 0;
      *((_QWORD *)v31 + 7) = 0;
      v32 = &v31[v10];
      *(_OWORD *)v32 = v17;
      *((_OWORD *)v32 + 1) = v16;
      v33 = &v31[v12];
      *((_OWORD *)v32 + 2) = 0uLL;
      *((_OWORD *)v32 + 3) = 0uLL;
      ++v8;
      *(_OWORD *)v33 = v16;
      *((_OWORD *)v33 + 1) = 0uLL;
      *((_OWORD *)v33 + 2) = 0uLL;
      *((_OWORD *)v33 + 3) = 0uLL;
    }
    while (v9 > v8);
  }
  return result;
}

void SplitMELManager::neon_final_conv_cols(SplitMELManager *this, float *a2, float *a3, float *a4, float *a5, unsigned int a6, int a7, unsigned int a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  unsigned int v11;
  unsigned int v12;
  signed int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v25;
  float *v26;
  float *v27;
  uint64_t v28;
  float32x4_t v29;
  float32x4_t *v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  uint64_t v34;
  float32x4_t *v35;
  float32x2_t *v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float v41;
  float32x4_t v42;
  float v43;
  float32x4_t v44;
  float v45;
  float32x4_t v46;
  float v47;
  float32x4_t v48;
  float *v49;
  uint64_t v50;
  unsigned int v53;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;

  v11 = (a9 >> 2) / a11;
  v12 = v11 * a10;
  v53 = v11 * a10 + v11;
  if (v12 < v12 + v11)
  {
    v14 = (4 * a7) & 0xFFFFFFF0;
    v15 = v14;
    if (a8 >> 2 <= 1)
      v16 = 1;
    else
      v16 = a8 >> 2;
    v17 = (int)v12;
    v49 = a2 + 8;
    v50 = 4 * v14;
    v18 = 28 * v14;
    v19 = 4 * v14;
    __asm { FMOV            V0.4S, #4.0 }
    v69 = _Q0;
    do
    {
      if (a8 >= 4)
      {
        v25 = 0;
        v26 = &a5[v17 * 16 * (a8 >> 2)];
        v27 = v49;
        do
        {
          v28 = 0;
          v29 = *(float32x4_t *)&a3[4 * v25];
          v30 = (float32x4_t *)v27;
          v31 = v29;
          v32 = v29;
          v33 = v29;
          do
          {
            if ((int)v15 >= 1)
            {
              v34 = 0;
              v35 = v30;
              do
              {
                v36 = (float32x2_t *)&a4[v17 * v50 + v28 * v15 + v34];
                v38 = v35[-2];
                v37 = v35[-1];
                v39 = *v35;
                v40 = v35[1];
                v35 += 4;
                v29 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmlaq_n_f32(v29, v38, COERCE_FLOAT(*(_OWORD *)v36->f32)), v37, *v36, 1), v39, *(float32x4_t *)v36->f32, 2), v40, *(float32x4_t *)v36->f32, 3);
                v31 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmlaq_n_f32(v31, v38, COERCE_FLOAT(*(_OWORD *)v36[2].f32)), v37, v36[2], 1), v39, *(float32x4_t *)v36[2].f32, 2), v40, *(float32x4_t *)v36[2].f32, 3);
                v32 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmlaq_n_f32(v32, v38, COERCE_FLOAT(*(_OWORD *)v36[4].f32)), v37, v36[4], 1), v39, *(float32x4_t *)v36[4].f32, 2), v40, *(float32x4_t *)v36[4].f32, 3);
                v33 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmlaq_n_f32(v33, v38, COERCE_FLOAT(*(_OWORD *)v36[6].f32)), v37, v36[6], 1), v39, *(float32x4_t *)v36[6].f32, 2), v40, *(float32x4_t *)v36[6].f32, 3);
                v34 += 16;
              }
              while (v34 < v15);
            }
            ++v28;
            v30 = (float32x4_t *)((char *)v30 + v19);
          }
          while (v28 != 7);
          v72 = v32;
          v74 = v33;
          v70 = v31;
          v67 = v29;
          v62 = tanhf(v29.f32[0]);
          v64 = tanhf(v70.f32[0]);
          v65 = tanhf(v72.f32[0]);
          v66 = tanhf(v74.f32[0]);
          v57 = tanhf(v67.f32[1]);
          v59 = tanhf(v70.f32[1]);
          v61 = tanhf(v72.f32[1]);
          v63 = tanhf(v74.f32[1]);
          v55 = tanhf(v67.f32[2]);
          v56 = tanhf(v70.f32[2]);
          v58 = tanhf(v72.f32[2]);
          v60 = tanhf(v74.f32[2]);
          v41 = tanhf(v67.f32[3]);
          v42.i64[0] = __PAIR64__(LODWORD(v57), LODWORD(v62));
          v42.i64[1] = __PAIR64__(LODWORD(v41), LODWORD(v55));
          v68 = vmulq_f32(v42, v69);
          v43 = tanhf(v70.f32[3]);
          v44.i64[0] = __PAIR64__(LODWORD(v59), LODWORD(v64));
          v44.i64[1] = __PAIR64__(LODWORD(v43), LODWORD(v56));
          v71 = vmulq_f32(v44, v69);
          v45 = tanhf(v72.f32[3]);
          v46.i64[0] = __PAIR64__(LODWORD(v61), LODWORD(v65));
          v46.i64[1] = __PAIR64__(LODWORD(v45), LODWORD(v58));
          v73 = vmulq_f32(v46, v69);
          v47 = tanhf(v74.f32[3]);
          v48.i64[0] = __PAIR64__(LODWORD(v63), LODWORD(v66));
          v48.i64[1] = __PAIR64__(LODWORD(v47), LODWORD(v60));
          *(float32x4_t *)v26 = v68;
          *((float32x4_t *)v26 + 1) = v71;
          *((float32x4_t *)v26 + 2) = v73;
          *((float32x4_t *)v26 + 3) = vmulq_f32(v48, v69);
          ++v25;
          v27 = (float *)((char *)v27 + v18);
        }
        while (v25 != v16);
      }
      ++v17;
    }
    while (v53 > v17);
  }
}

uint64_t SplitMELManager::neon_pqmf_shift_by_columns(SplitMELManager *this, float *a2, float *a3, unsigned int a4, unsigned int a5, unsigned int a6, unsigned int a7)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  float *v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  __int128 v15;
  __int128 v16;
  int v17;
  uint64_t v18;
  int v19;
  float *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t result;
  float *v26;
  float *v27;
  int v28;
  float *v29;
  int v30;
  float *v31;

  LODWORD(v7) = a5 >> 3;
  if (a5 >= 8)
  {
    v8 = 0;
    if (v7 <= 1)
      v9 = 1;
    else
      v9 = v7;
    do
    {
      v10 = &a3[v8];
      *((_OWORD *)v10 + 2) = 0uLL;
      *((_OWORD *)v10 + 3) = 0uLL;
      *(_OWORD *)v10 = 0uLL;
      *((_OWORD *)v10 + 1) = 0uLL;
      v8 += (4 * a6) & 0xFFFFFFF0;
      --v9;
    }
    while (v9);
  }
  v11 = a7 >> 2;
  if (a7 > 3)
  {
    v17 = 0;
    v13 = a6 >> 2;
    v12 = 16 * v7;
    v14 = 32 * (a6 >> 2);
    if (v11 <= 1)
      v18 = 1;
    else
      v18 = v11;
    v16 = 0uLL;
    v19 = 16 * v7;
    v15 = 0uLL;
    do
    {
      v20 = &a2[v17];
      v21 = *(_OWORD *)v20;
      v22 = *((_OWORD *)v20 + 1);
      v23 = v15;
      v24 = v16;
      result = (v19 - 16);
      v16 = *((_OWORD *)v20 + 2);
      v15 = *((_OWORD *)v20 + 3);
      v26 = &a3[(int)result];
      *(_OWORD *)v26 = v24;
      *((_OWORD *)v26 + 1) = v23;
      *((_OWORD *)v26 + 2) = v23;
      *((_OWORD *)v26 + 3) = v21;
      v27 = &a3[v19];
      *(_OWORD *)v27 = v21;
      *((_OWORD *)v27 + 1) = v22;
      *((_OWORD *)v27 + 2) = v22;
      *((_OWORD *)v27 + 3) = v16;
      v19 += v14;
      v17 += 16 * (a6 >> 2);
      --v18;
    }
    while (v18);
  }
  else
  {
    v12 = 16 * v7;
    v13 = a6 >> 2;
    v14 = 32 * (a6 >> 2);
    v15 = 0uLL;
    v16 = 0uLL;
  }
  v28 = v12 + v14 * v11;
  v29 = &a3[v28 - 16];
  *(_OWORD *)v29 = v16;
  *((_OWORD *)v29 + 1) = v15;
  *((_OWORD *)v29 + 2) = v15;
  *((_QWORD *)v29 + 6) = 0;
  *((_QWORD *)v29 + 7) = 0;
  if (a5 >= 8)
  {
    v30 = 16 * v13;
    if (v7 <= 1)
      v7 = 1;
    else
      v7 = v7;
    do
    {
      v31 = &a3[v28];
      *((_OWORD *)v31 + 2) = 0uLL;
      *((_OWORD *)v31 + 3) = 0uLL;
      *(_OWORD *)v31 = 0uLL;
      *((_OWORD *)v31 + 1) = 0uLL;
      v28 += v30;
      --v7;
    }
    while (v7);
  }
  return result;
}

float32x2_t SplitMELManager::neon_pqmf_compressed(SplitMELManager *this, float32x4_t *a2, float *a3, float *a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9)
{
  uint64_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  uint64_t v15;
  uint64_t v16;
  float32x4_t v17;
  float *v18;
  float32x4_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  float32x4_t v29;
  float *v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int v36;
  uint64_t v37;
  float *f32;
  uint64_t v39;
  float *v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int32x2_t *v49;
  uint64_t v50;
  float32x4_t v51;
  int v52;
  uint64_t v53;
  float32x4_t v54;
  float *v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x2_t result;

  LODWORD(v9) = a5 >> 2;
  v10 = 0uLL;
  v11 = 0uLL;
  v12 = 0uLL;
  v13 = 0uLL;
  v14 = 0uLL;
  if (a5 >= 4)
  {
    v15 = 0;
    if (v9 <= 1)
      v16 = 1;
    else
      v16 = v9;
    v17 = 0uLL;
    v13 = 0u;
    do
    {
      if ((v15 & 1) == 0)
      {
        v18 = &a3[(8 * (_DWORD)v15) & 0x7FFFFFF0];
        v17 = *(float32x4_t *)(v18 + 4);
        v14 = *(float32x4_t *)(v18 + 8);
        v13 = *(float32x4_t *)(v18 + 12);
      }
      v19 = &a2[4 * v15];
      v12 = vmlaq_f32(v12, v19[3], v17);
      v11 = vmlaq_f32(v11, v19[2], v17);
      v10 = vmlaq_f32(v10, v19[1], v17);
      ++v15;
      v17 = v13;
    }
    while (v15 != v16);
  }
  v20 = (float32x4_t)vdupq_n_s32(0xBF7FF972);
  v21 = vmaxq_f32(v10, v20);
  v22 = (float32x4_t)vdupq_n_s32(0x3F7FF972u);
  v23 = (int8x16_t)vminq_f32(vmaxq_f32(v12, v20), v22);
  v24 = (int8x16_t)vminq_f32(vmaxq_f32(v11, v20), v22);
  v25 = (int8x16_t)vminq_f32(v21, v22);
  *(float32x2_t *)v23.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(float32x2_t *)v23.i8);
  *(float32x2_t *)v24.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), *(float32x2_t *)v24.i8);
  *(int32x2_t *)a4 = vzip1_s32((int32x2_t)vpadd_f32(*(float32x2_t *)v23.i8, *(float32x2_t *)v23.i8), (int32x2_t)vpadd_f32(*(float32x2_t *)v24.i8, *(float32x2_t *)v24.i8));
  *(float32x2_t *)v24.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), *(float32x2_t *)v25.i8);
  *((_DWORD *)a4 + 2) = vpadd_f32(*(float32x2_t *)v24.i8, *(float32x2_t *)v24.i8).u32[0];
  if (a8 >= 8)
  {
    if (v9 <= 1)
      v26 = 1;
    else
      v26 = v9;
    v27 = 1;
    v28 = 3;
    while (1)
    {
      v29 = v14;
      if ((v27 & 1) != 0)
      {
        v30 = &a3[(8 * v27) & 0x7FFFFFF0];
        v29 = *(float32x4_t *)(v30 + 8);
        v13 = *(float32x4_t *)(v30 + 12);
      }
      v31 = 0uLL;
      if (a5 >= 4)
        break;
      v32 = 0uLL;
      v33 = 0uLL;
      v34 = 0uLL;
      v35 = v13;
      v14 = v29;
LABEL_26:
      v45 = (int8x16_t)vminq_f32(vmaxq_f32(v34, v20), v22);
      v46 = (int8x16_t)vminq_f32(vmaxq_f32(v33, v20), v22);
      v47 = (int8x16_t)vminq_f32(vmaxq_f32(v32, v20), v22);
      v48 = (int8x16_t)vminq_f32(vmaxq_f32(v31, v20), v22);
      *(float32x2_t *)v45.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL), *(float32x2_t *)v45.i8);
      *(float32x2_t *)v46.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v46, v46, 8uLL), *(float32x2_t *)v46.i8);
      *(float32x2_t *)v47.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL), *(float32x2_t *)v47.i8);
      *(float32x2_t *)v48.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL), *(float32x2_t *)v48.i8);
      v49 = (int32x2_t *)&a4[v28];
      *v49 = vzip1_s32((int32x2_t)vpadd_f32(*(float32x2_t *)v45.i8, *(float32x2_t *)v45.i8), (int32x2_t)vpadd_f32(*(float32x2_t *)v46.i8, *(float32x2_t *)v46.i8));
      v49[1] = vzip1_s32((int32x2_t)vpadd_f32(*(float32x2_t *)v47.i8, *(float32x2_t *)v47.i8), (int32x2_t)vpadd_f32(*(float32x2_t *)v48.i8, *(float32x2_t *)v48.i8));
      v28 += 4;
      ++v27;
      v13 = v35;
      if (v27 == a8 >> 2)
      {
        v50 = v28;
        goto LABEL_29;
      }
    }
    v36 = 0;
    v37 = 0;
    v34 = 0uLL;
    f32 = a2[2].f32;
    v33 = 0uLL;
    v32 = 0uLL;
    while (1)
    {
      v35 = v13;
      v14 = v29;
      if ((v27 & 1) != 0)
      {
        if ((v37 & 1) != 0)
        {
          v39 = (int)(((8 * v27 - 8) & 0xFFFFFFF0) + 16 + (v36 & 0xFFFFFFF0));
          goto LABEL_24;
        }
      }
      else if ((v37 & 1) == 0)
      {
        v39 = (v36 & 0x7FFFFFF0) + ((8 * v27) & 0x7FFFFFF0u);
LABEL_24:
        v40 = &a3[v39];
        v29 = *(float32x4_t *)v40;
        v13 = *(float32x4_t *)(v40 + 4);
        v14 = *(float32x4_t *)(v40 + 8);
        v35 = *(float32x4_t *)(v40 + 12);
      }
      v41 = *(float32x4_t *)(f32 - 8);
      v42 = *(float32x4_t *)(f32 - 4);
      v43 = *(float32x4_t *)f32;
      v44 = *(float32x4_t *)(f32 + 4);
      f32 += 16;
      v34 = vmlaq_f32(v34, v41, v29);
      v33 = vmlaq_f32(v33, v44, v13);
      v32 = vmlaq_f32(v32, v43, v13);
      ++v37;
      v31 = vmlaq_f32(v31, v42, v13);
      v36 += 8;
      v29 = v14;
      v13 = v35;
      if (v26 == v37)
        goto LABEL_26;
    }
  }
  v50 = 3;
LABEL_29:
  v51 = 0uLL;
  if (a5 >= 4)
  {
    v52 = 0;
    v53 = 0;
    if (v9 <= 1)
      v9 = 1;
    else
      v9 = v9;
    v54 = v14;
    do
    {
      if ((v53 & 1) == 0)
      {
        v55 = &a3[(v52 & 0x7FFFFFF0) + ((2 * a8) & 0xFFFFFFF0)];
        v14 = *(float32x4_t *)v55;
        v54 = *(float32x4_t *)(v55 + 8);
      }
      v56 = *a2;
      a2 += 4;
      ++v53;
      v51 = vmlaq_f32(v51, v56, v14);
      v52 += 8;
      v14 = v54;
    }
    while (v9 != v53);
  }
  v57 = (int8x16_t)vminq_f32(vmaxq_f32(v51, (float32x4_t)vdupq_n_s32(0xBF7FF972)), (float32x4_t)vdupq_n_s32(0x3F7FF972u));
  *(float32x2_t *)v57.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL), *(float32x2_t *)v57.i8);
  result = vpadd_f32(*(float32x2_t *)v57.i8, *(float32x2_t *)v57.i8);
  a4[v50] = result.f32[0];
  return result;
}

void NeonPqmfBlockMelManager::do_inference(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  signed int v13;
  BOOL v14;
  int v15;
  int v16;
  int v17;
  int v18;
  signed int v19;
  float *v20;
  unint64_t v21;
  float *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  float *v29;
  uint64_t v30;
  int v31;
  float *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  int v36;
  signed int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  signed int v42;
  float *v43;
  unint64_t v44;
  float *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _DWORD *v51;
  float *v52;
  uint64_t v53;
  int v54;
  float *v55;
  uint64_t v56;
  int v57;
  int v58;
  SplitMELManager *v59;
  uint64_t v60;
  unsigned int v61;
  SplitMELManager *v62;
  unsigned int v63;
  SplitMELManager *v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  int v68;
  float *v69;
  unint64_t v70;
  float *v71;
  float *v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  float *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  float *v84;
  float *v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  _QWORD *v91;
  float *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  float *v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  _QWORD *v103;
  float *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unsigned int v108;
  float *v109;
  float *v110;
  float *v111;
  uint64_t v112;
  _QWORD *v113;

  v8 = a1;
  v9 = *(_QWORD *)(a1 + 144);
  if (*(_BYTE *)(v9 + 2304))
  {
    *(_QWORD *)(a1 + 192) = a2;
    *(_QWORD *)(a1 + 200) = a3;
    *(_QWORD *)(a1 + 208) = a4;
    *(_QWORD *)(a1 + 216) = a5;
    if (*(_BYTE *)(v9 + 3499))
    {
      *(_DWORD *)(a1 + 184) = 0;
LABEL_68:
      SynchroManager::cond_broadcast_on_entry((SynchroManager *)(v9 + 2312), *(_DWORD *)(v9 + 2308), 5);
      SynchroManager::cond_wait_less_on_exit((SynchroManager *)(*(_QWORD *)(v8 + 144) + 2312), *(_DWORD *)(*(_QWORD *)(v8 + 144) + 2308));
      return;
    }
    v10 = *a3;
    v11 = a3[1] - *a3;
    if (v11 > 8)
    {
      v12 = *(_DWORD *)(v10 + 8);
      *(_DWORD *)(v9 + 4088) = v12;
      if (v11 > 0x10)
      {
        v13 = *(_DWORD *)(v10 + 16);
        *(_DWORD *)(a1 + 84) = v13;
        v14 = -v12 < 0;
        v15 = -v12 & 3;
        v16 = v12 & 3;
        if (v14)
          v17 = v16;
        else
          v17 = -v15;
        if (v17)
        {
          v18 = 0;
          v17 = 4 - v17;
          *(_DWORD *)(a1 + 184) = v17;
          do
          {
            if (v13 >= 1)
            {
              v19 = 0;
              v20 = *(float **)(a2 + 8);
              do
              {
                v21 = *(_QWORD *)(a2 + 16);
                if ((unint64_t)v20 >= v21)
                {
                  v22 = *(float **)a2;
                  v23 = ((uint64_t)v20 - *(_QWORD *)a2) >> 2;
                  v24 = v23 + 1;
                  if ((unint64_t)(v23 + 1) >> 62)
                    goto LABEL_124;
                  v25 = v21 - (_QWORD)v22;
                  if (v25 >> 1 > v24)
                    v24 = v25 >> 1;
                  if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL)
                    v26 = 0x3FFFFFFFFFFFFFFFLL;
                  else
                    v26 = v24;
                  v113 = (_QWORD *)(a2 + 24);
                  if (v26)
                  {
                    v27 = ENTTS::Allocator<int>::allocate(a2 + 24, v26);
                    v22 = *(float **)a2;
                    v20 = *(float **)(a2 + 8);
                  }
                  else
                  {
                    v27 = 0;
                  }
                  v28 = (_DWORD *)(v27 + 4 * v23);
                  *v28 = 0;
                  if (v20 == v22)
                  {
                    v30 = v27 + 4 * v23;
                  }
                  else
                  {
                    v29 = v20;
                    v30 = v27 + 4 * v23;
                    do
                    {
                      v31 = *((_DWORD *)v29-- - 1);
                      *(_DWORD *)(v30 - 4) = v31;
                      v30 -= 4;
                    }
                    while (v29 != v22);
                  }
                  v32 = (float *)(v28 + 1);
                  *(_QWORD *)a2 = v30;
                  *(_QWORD *)(a2 + 8) = v28 + 1;
                  v33 = *(_QWORD *)(a2 + 16);
                  *(_QWORD *)(a2 + 16) = v27 + 4 * v26;
                  v111 = v20;
                  v112 = v33;
                  v109 = v22;
                  v110 = v22;
                  a1 = std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&v109);
                  v13 = *(_DWORD *)(v8 + 84);
                  v20 = v32;
                }
                else
                {
                  *v20++ = 0.0;
                }
                *(_QWORD *)(a2 + 8) = v20;
                ++v19;
              }
              while (v19 < v13);
              v17 = *(_DWORD *)(v8 + 184);
            }
            ++v18;
          }
          while (v18 < v17);
          v9 = *(_QWORD *)(v8 + 144);
        }
        else
        {
          *(_DWORD *)(a1 + 184) = 0;
        }
        v57 = *(_DWORD *)(v9 + 4088) + v17;
        *(_DWORD *)(v9 + 4088) = v57;
        SplitMELManager::neon_convert_column2tensor((SplitMELManager *)a1, *(float **)a2, *(float **)(v9 + 2848), v13, v57);
        v9 = *(_QWORD *)(v8 + 144);
        goto LABEL_68;
      }
    }
LABEL_125:
    std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
  }
  if (*(_BYTE *)(v9 + 3499))
  {
    *(_DWORD *)(a1 + 184) = 0;
  }
  else
  {
    v34 = *a3;
    v35 = a3[1] - *a3;
    if (v35 <= 8)
      goto LABEL_125;
    v36 = *(_DWORD *)(v34 + 8);
    *(_DWORD *)(v9 + 4088) = v36;
    if (v35 <= 0x10)
      goto LABEL_125;
    v37 = *(_DWORD *)(v34 + 16);
    *(_DWORD *)(a1 + 84) = v37;
    v14 = -v36 < 0;
    v38 = -v36 & 3;
    v39 = v36 & 3;
    if (v14)
      v40 = v39;
    else
      v40 = -v38;
    if (v40)
    {
      v41 = 0;
      v40 = 4 - v40;
      *(_DWORD *)(a1 + 184) = v40;
      do
      {
        if (v37 >= 1)
        {
          v42 = 0;
          v43 = *(float **)(a2 + 8);
          do
          {
            v44 = *(_QWORD *)(a2 + 16);
            if ((unint64_t)v43 >= v44)
            {
              v45 = *(float **)a2;
              v46 = ((uint64_t)v43 - *(_QWORD *)a2) >> 2;
              v47 = v46 + 1;
              if ((unint64_t)(v46 + 1) >> 62)
LABEL_124:
                std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
              v48 = v44 - (_QWORD)v45;
              if (v48 >> 1 > v47)
                v47 = v48 >> 1;
              if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFFCLL)
                v49 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v49 = v47;
              v113 = (_QWORD *)(a2 + 24);
              if (v49)
              {
                v50 = ENTTS::Allocator<int>::allocate(a2 + 24, v49);
                v45 = *(float **)a2;
                v43 = *(float **)(a2 + 8);
              }
              else
              {
                v50 = 0;
              }
              v51 = (_DWORD *)(v50 + 4 * v46);
              *v51 = 0;
              if (v43 == v45)
              {
                v53 = v50 + 4 * v46;
              }
              else
              {
                v52 = v43;
                v53 = v50 + 4 * v46;
                do
                {
                  v54 = *((_DWORD *)v52-- - 1);
                  *(_DWORD *)(v53 - 4) = v54;
                  v53 -= 4;
                }
                while (v52 != v45);
              }
              v55 = (float *)(v51 + 1);
              *(_QWORD *)a2 = v53;
              *(_QWORD *)(a2 + 8) = v51 + 1;
              v56 = *(_QWORD *)(a2 + 16);
              *(_QWORD *)(a2 + 16) = v50 + 4 * v49;
              v111 = v43;
              v112 = v56;
              v109 = v45;
              v110 = v45;
              a1 = std::__split_buffer<float,ENTTS::Allocator<float> &>::~__split_buffer((uint64_t)&v109);
              v37 = *(_DWORD *)(v8 + 84);
              v43 = v55;
            }
            else
            {
              *v43++ = 0.0;
            }
            *(_QWORD *)(a2 + 8) = v43;
            ++v42;
          }
          while (v42 < v37);
          v40 = *(_DWORD *)(v8 + 184);
        }
        ++v41;
      }
      while (v41 < v40);
      v9 = *(_QWORD *)(v8 + 144);
    }
    else
    {
      *(_DWORD *)(a1 + 184) = 0;
    }
    v58 = *(_DWORD *)(v9 + 4088) + v40;
    *(_DWORD *)(v9 + 4088) = v58;
    SplitMELManager::neon_convert_column2tensor((SplitMELManager *)a1, *(float **)a2, *(float **)(v9 + 2848), v37, v58);
    v9 = *(_QWORD *)(v8 + 144);
  }
  v59 = (SplitMELManager *)SplitMELManager::neon_final_conv_input_shift_by_columns((SplitMELManager *)a1, *(float **)(v9 + 2848), *(float **)(v9 + 2856), *(_DWORD *)(v9 + 4088), *(_DWORD *)(v8 + 84), 0, *(_DWORD *)(v9 + 2308));
  v60 = *(_QWORD *)(v8 + 144);
  SplitMELManager::neon_final_conv_cols(v59, *(float **)(v60 + 2736), *(float **)(v60 + 2744), *(float **)(v60 + 2856), *(float **)(v60 + 2848), v61, *(_DWORD *)(v8 + 84), 4u, *(_DWORD *)(v60 + 4088), 0, *(_DWORD *)(v60 + 2308));
  v64 = (SplitMELManager *)SplitMELManager::neon_pqmf_shift_by_columns(v62, *(float **)(*(_QWORD *)(v8 + 144) + 2848), *(float **)(*(_QWORD *)(v8 + 144) + 2856), v63, 0x20u, 4u, *(_DWORD *)(*(_QWORD *)(v8 + 144) + 4088));
  SplitMELManager::neon_pqmf_compressed(v64, *(float32x4_t **)(*(_QWORD *)(v8 + 144) + 2752), *(float **)(*(_QWORD *)(v8 + 144) + 2856), *(float **)(*(_QWORD *)(v8 + 144) + 2864), 0x40u, v65, v66, 4 * *(_DWORD *)(*(_QWORD *)(v8 + 144) + 4088), v108);
  v67 = *(_QWORD *)(v8 + 144);
  v68 = 4 * *(_DWORD *)(v67 + 4088) - (*(_DWORD *)(v67 + 4092) << 8) - 1024;
  *(_DWORD *)(v67 + 4088) = v68;
  v69 = (float *)a5[1];
  v70 = a5[2];
  if ((unint64_t)v69 >= v70)
  {
    v72 = (float *)*a5;
    v73 = ((uint64_t)v69 - *a5) >> 3;
    v74 = v73 + 1;
    if ((unint64_t)(v73 + 1) >> 61)
      goto LABEL_126;
    v75 = v70 - (_QWORD)v72;
    if (v75 >> 2 > v74)
      v74 = v75 >> 2;
    if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8)
      v76 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v76 = v74;
    v113 = a5 + 3;
    if (v76)
    {
      v77 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v76);
      v72 = (float *)*a5;
      v69 = (float *)a5[1];
    }
    else
    {
      v77 = 0;
    }
    v78 = (_QWORD *)(v77 + 8 * v73);
    *v78 = 1;
    if (v69 == v72)
    {
      v80 = v77 + 8 * v73;
    }
    else
    {
      v79 = v69;
      v80 = v77 + 8 * v73;
      do
      {
        v81 = *((_QWORD *)v79 - 1);
        v79 -= 2;
        *(_QWORD *)(v80 - 8) = v81;
        v80 -= 8;
      }
      while (v79 != v72);
    }
    v71 = (float *)(v78 + 1);
    *a5 = v80;
    a5[1] = (uint64_t)(v78 + 1);
    v82 = a5[2];
    a5[2] = v77 + 8 * v76;
    v111 = v69;
    v112 = v82;
    v109 = v72;
    v110 = v72;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v109);
    v68 = *(_DWORD *)(*(_QWORD *)(v8 + 144) + 4088);
    v70 = a5[2];
  }
  else
  {
    *(_QWORD *)v69 = 1;
    v71 = v69 + 2;
  }
  a5[1] = (uint64_t)v71;
  v83 = v68;
  if ((unint64_t)v71 >= v70)
  {
    v85 = (float *)*a5;
    v86 = ((uint64_t)v71 - *a5) >> 3;
    v87 = v86 + 1;
    if ((unint64_t)(v86 + 1) >> 61)
      goto LABEL_126;
    v88 = v70 - (_QWORD)v85;
    if (v88 >> 2 > v87)
      v87 = v88 >> 2;
    if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8)
      v89 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v89 = v87;
    v113 = a5 + 3;
    if (v89)
    {
      v90 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v89);
      v85 = (float *)*a5;
      v71 = (float *)a5[1];
    }
    else
    {
      v90 = 0;
    }
    v91 = (_QWORD *)(v90 + 8 * v86);
    *v91 = v83;
    if (v71 == v85)
    {
      v93 = v90 + 8 * v86;
    }
    else
    {
      v92 = v71;
      v93 = v90 + 8 * v86;
      do
      {
        v94 = *((_QWORD *)v92 - 1);
        v92 -= 2;
        *(_QWORD *)(v93 - 8) = v94;
        v93 -= 8;
      }
      while (v92 != v85);
    }
    v84 = (float *)(v91 + 1);
    *a5 = v93;
    a5[1] = (uint64_t)(v91 + 1);
    v95 = a5[2];
    a5[2] = v90 + 8 * v89;
    v111 = v71;
    v112 = v95;
    v109 = v85;
    v110 = v85;
    std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v109);
    v70 = a5[2];
  }
  else
  {
    *(_QWORD *)v71 = v68;
    v84 = v71 + 2;
  }
  a5[1] = (uint64_t)v84;
  if ((unint64_t)v84 >= v70)
  {
    v97 = (float *)*a5;
    v98 = ((uint64_t)v84 - *a5) >> 3;
    v99 = v98 + 1;
    if (!((unint64_t)(v98 + 1) >> 61))
    {
      v100 = v70 - (_QWORD)v97;
      if (v100 >> 2 > v99)
        v99 = v100 >> 2;
      if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF8)
        v101 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v101 = v99;
      v113 = a5 + 3;
      if (v101)
      {
        v102 = ENTTS::Allocator<unsigned long>::allocate((uint64_t)(a5 + 3), v101);
        v97 = (float *)*a5;
        v84 = (float *)a5[1];
      }
      else
      {
        v102 = 0;
      }
      v103 = (_QWORD *)(v102 + 8 * v98);
      *v103 = 1;
      if (v84 == v97)
      {
        v105 = v102 + 8 * v98;
      }
      else
      {
        v104 = v84;
        v105 = v102 + 8 * v98;
        do
        {
          v106 = *((_QWORD *)v104 - 1);
          v104 -= 2;
          *(_QWORD *)(v105 - 8) = v106;
          v105 -= 8;
        }
        while (v104 != v97);
      }
      v96 = v103 + 1;
      *a5 = v105;
      a5[1] = (uint64_t)(v103 + 1);
      v107 = a5[2];
      a5[2] = v102 + 8 * v101;
      v111 = v84;
      v112 = v107;
      v109 = v97;
      v110 = v97;
      std::__split_buffer<unsigned long,ENTTS::Allocator<unsigned long> &>::~__split_buffer((uint64_t)&v109);
      goto LABEL_122;
    }
LABEL_126:
    std::vector<int,ENTTS::Allocator<int>>::__throw_length_error[abi:ne180100]();
  }
  *(_QWORD *)v84 = 1;
  v96 = v84 + 2;
LABEL_122:
  a5[1] = (uint64_t)v96;
  std::vector<float,ENTTS::Allocator<float>>::__assign_with_size[abi:ne180100]<float *,float *>(a4, *(char **)(*(_QWORD *)(v8 + 144) + 2864), *(_QWORD *)(*(_QWORD *)(v8 + 144) + 2864) + 4 * *(int *)(*(_QWORD *)(v8 + 144) + 4088), *(int *)(*(_QWORD *)(v8 + 144) + 4088));
  *(_DWORD *)(*(_QWORD *)(v8 + 144) + 4092) = 0;
}

void SplitMELManager::neon_convert_column2tensor(SplitMELManager *this, float *a2, float *a3, unsigned int a4, int a5)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  float *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  float *v22;

  if (a4 >= 4)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = a4 >> 2;
    v9 = 16 * (a4 >> 2);
    if (a4 >> 2 <= 1)
      v8 = 1;
    v10 = 4 * a4;
    v11 = a4;
    v12 = 2 * a4;
    v13 = 3 * a4;
    do
    {
      if (a5 >= 4)
      {
        v14 = (a5 / 4);
        v15 = v5;
        v16 = v6;
        do
        {
          v17 = &a2[v15];
          v18 = *(_OWORD *)v17;
          v19 = *(_OWORD *)&v17[v11];
          v20 = *(_OWORD *)&v17[v12];
          v21 = *(_OWORD *)&v17[v13];
          v22 = &a3[v16];
          *(_OWORD *)v22 = v18;
          *((_OWORD *)v22 + 1) = v19;
          *((_OWORD *)v22 + 2) = v20;
          *((_OWORD *)v22 + 3) = v21;
          v16 += v9;
          v15 += v10;
          --v14;
        }
        while (v14);
      }
      ++v7;
      v6 += 16;
      v5 += 4;
    }
    while (v7 != v8);
  }
}

float16x8_t SplitMELManager::neon_write_page(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, unsigned int a7, int a8, unsigned int a9)
{
  uint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  float16x8_t *v16;
  float16x8_t result;

  if (a7)
  {
    v9 = 0;
    v10 = (a6 + a5 * a4) << 6;
    v11 = a4 << 6;
    do
    {
      v12 = (a8 + (int)v9 + 2) % a9;
      v13 = (a8 + (int)v9 + 1) % a9;
      v14 = (a8 + (int)v9 + 3) % a9;
      v15 = (a8 + (int)v9 + 4) % a9;
      v16 = (float16x8_t *)(a3 + 2 * v10);
      *v16 = vsubq_f16(*(float16x8_t *)(a2 + 16 * ((a8 + (int)v9) % a9)), *(float16x8_t *)(a2 + 16 * v12));
      v16[1] = vaddq_f16(*(float16x8_t *)(a2 + 16 * v13), *(float16x8_t *)(a2 + 16 * v12));
      v16[2] = vsubq_f16(*(float16x8_t *)(a2 + 16 * v12), *(float16x8_t *)(a2 + 16 * v13));
      v16[3] = vsubq_f16(*(float16x8_t *)(a2 + 16 * v13), *(float16x8_t *)(a2 + 16 * v14));
      v16[4] = vsubq_f16(*(float16x8_t *)(a2 + 16 * v12), *(float16x8_t *)(a2 + 16 * v15));
      v16[5] = vaddq_f16(*(float16x8_t *)(a2 + 16 * v14), *(float16x8_t *)(a2 + 16 * v15));
      v16[6] = vsubq_f16(*(float16x8_t *)(a2 + 16 * v15), *(float16x8_t *)(a2 + 16 * v14));
      result = vsubq_f16(*(float16x8_t *)(a2 + 16 * v14), *(float16x8_t *)(a2 + 16 * ((a8 + (int)v9 + 5) % a9)));
      v16[7] = result;
      v9 += 6;
      v10 += v11;
    }
    while (6 * a7 != v9);
  }
  return result;
}

void SplitMELManager::neon_print_page(SplitMELManager *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  unsigned int v10;
  _QWORD *v11;
  const char *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  const std::locale::facet *v17;
  std::locale v18;

  if (a8 == 1)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"[ ", 2);
    if (a3 >= 1)
    {
      v10 = 0;
      v11 = (_QWORD *)MEMORY[0x24BEDB318];
      do
      {
        if (v10 && 6 * (v10 / 6) == v10)
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" ] [ ", 5);
        if (a2 == v10)
          v12 = "X ";
        else
          v12 = "- ";
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)v12, 2);
        ++v10;
      }
      while (a3 != v10);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"] (", 3);
    v13 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" + ", 3);
    v14 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)" + ", 3);
    v15 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)") ", 2);
    v16 = (_QWORD *)std::ostream::operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(_QWORD *)(*v16 - 24)));
    v17 = std::locale::use_facet(&v18, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
    std::locale::~locale(&v18);
    std::ostream::put();
    std::ostream::flush();
  }
}

void sub_214EB5238(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

uint64_t NeonTC2Container::NeonTC2Container(uint64_t a1, _QWORD *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  void **v21;
  uint64_t v22;
  void **v23;
  uint64_t v24;
  void **v25;
  uint64_t v26;
  void **v27;
  uint64_t v28;
  void **v29;
  uint64_t v30;
  void **v31;
  uint64_t v32;
  void **v33;
  uint64_t v34;
  void **v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t i;
  unint64_t v41;
  _DWORD *v42;
  void **v44;
  uint64_t v45;
  void *v46;
  _QWORD **v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  _QWORD v51[19];
  uint64_t v52;
  std::__shared_weak_count *v53;

  v19 = (std::__shared_weak_count *)a2[1];
  v52 = *a2;
  v53 = v19;
  if (v19)
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  NeonContainer::NeonContainer(a1, &v52);
  v20 = v53;
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)a1);
  v44 = (void **)&unk_24D29B388;
  v46 = &unk_24D29B3B0;
  v51[0] = &unk_24D29B3D8;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a4 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v21 = (void **)&v44;
  else
    v21 = v44;
  if (SHIBYTE(v46) >= 0)
    v22 = HIBYTE(v46);
  else
    v22 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 16), (uint64_t)v21, v22);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 864));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a5 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v23 = (void **)&v44;
  else
    v23 = v44;
  if (SHIBYTE(v46) >= 0)
    v24 = HIBYTE(v46);
  else
    v24 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 880), (uint64_t)v23, v24);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 288));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a6 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v25 = (void **)&v44;
  else
    v25 = v44;
  if (SHIBYTE(v46) >= 0)
    v26 = HIBYTE(v46);
  else
    v26 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 304), (uint64_t)v25, v26);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 1152));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a7 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v27 = (void **)&v44;
  else
    v27 = v44;
  if (SHIBYTE(v46) >= 0)
    v28 = HIBYTE(v46);
  else
    v28 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 1168), (uint64_t)v27, v28);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 576));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a8 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v29 = (void **)&v44;
  else
    v29 = v44;
  if (SHIBYTE(v46) >= 0)
    v30 = HIBYTE(v46);
  else
    v30 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 592), (uint64_t)v29, v30);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 1440));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a9 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v31 = (void **)&v44;
  else
    v31 = v44;
  if (SHIBYTE(v46) >= 0)
    v32 = HIBYTE(v46);
  else
    v32 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 1456), (uint64_t)v31, v32);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 1728));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a10 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v33 = (void **)&v44;
  else
    v33 = v44;
  if (SHIBYTE(v46) >= 0)
    v34 = HIBYTE(v46);
  else
    v34 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 1744), (uint64_t)v33, v34);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 2016));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a11 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v35 = (void **)&v44;
  else
    v35 = v44;
  if (SHIBYTE(v46) >= 0)
    v36 = HIBYTE(v46);
  else
    v36 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 2032), (uint64_t)v35, v36);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  *(_BYTE *)(a1 + 2724) = 0;
  *(_DWORD *)(a1 + 2720) = 0;
  if (!(*(unsigned int (**)(_QWORD))(*(_QWORD *)*a2 + 64))(*a2))
  {
    *(_DWORD *)(a1 + 2308) = 1;
    goto LABEL_99;
  }
  v37 = affinity_safeguard24(a3);
  *(_DWORD *)(a1 + 2308) = v37;
  if ((_DWORD)v37 == 1)
  {
LABEL_99:
    *(_BYTE *)(a1 + 2304) = 0;
    return a1;
  }
  *(_BYTE *)(a1 + 2304) = 1;
  if ((int)v37 >= 1)
  {
    v38 = 0;
    v39 = a1 + 2752;
    do
    {
      for (i = 0; i != 120; i += 24)
        *(_BYTE *)(v39 + i) = 0;
      ++v38;
      v39 += 144;
    }
    while (v38 != v37);
  }
  *(_DWORD *)(a1 + 2648) = 0;
  *(_QWORD *)(a1 + 2640) = 0x100000000;
  SynchroManager::init((SynchroManager *)(a1 + 2312), v37);
  if (*(int *)(a1 + 2308) >= 1)
  {
    v41 = 0;
    v42 = (_DWORD *)(a1 + 2728);
    do
    {
      *(_QWORD *)v42 = a1;
      v42[3] = v41;
      if (v41 >= (a3[1] - *a3) >> 2)
        std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
      v42[4] = *(_DWORD *)(*a3 + 4 * v41);
      SynchroManager::start_thread((SynchroManager *)(a1 + 2312), v41++, (void *(*)(void *))NeonTC2MultiCore, v42);
      v42 += 36;
    }
    while ((uint64_t)v41 < *(int *)(a1 + 2308));
  }
  return a1;
}

{
  return NeonTC2Container::NeonTC2Container(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

void sub_214EB5A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  NeonContainer *v4;
  va_list va;

  va_start(va, a4);
  std::basic_string<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_string((uint64_t)va);
  NeonContainer::~NeonContainer(v4);
  _Unwind_Resume(a1);
}

uint64_t NeonTC2MultiCore(char *a1)
{
  int v2;
  char *v3;
  char *v4;

  sysconf(58);
  while (1)
  {
    v2 = SynchroManager::cond_wait_less_equal_on_entry((SynchroManager *)(*(_QWORD *)a1 + 2312), 0);
    v3 = a1 + 40;
    v4 = a1 + 32;
    switch(v2)
    {
      case 0:
        return SynchroManager::exit_from_thread((SynchroManager *)(*(_QWORD *)a1 + 2312));
      case 1:
        goto LABEL_7;
      case 2:
        v3 = a1 + 64;
        v4 = a1 + 56;
        goto LABEL_7;
      case 3:
        v3 = a1 + 88;
        v4 = a1 + 80;
        goto LABEL_7;
      case 4:
        v3 = a1 + 112;
        v4 = a1 + 104;
        goto LABEL_7;
      case 5:
        v4 = a1 + 128;
        v3 = a1 + 136;
LABEL_7:
        (*(void (**)(_QWORD, _QWORD))v3)(*(_QWORD *)v4, *((unsigned int *)a1 + 3));
        break;
      default:
        break;
    }
    SynchroManager::cond_signal_on_exit((SynchroManager *)(*(_QWORD *)a1 + 2312));
  }
}

void NeonTC2Container::~NeonTC2Container(NeonTC2Container *this)
{
  int v2;

  if (*((_BYTE *)this + 2304))
  {
    SynchroManager::cond_broadcast_on_entry((NeonTC2Container *)((char *)this + 2312), *((_DWORD *)this + 577), 0);
    if (*((int *)this + 577) >= 1)
    {
      v2 = 0;
      do
      {
        SynchroManager::join_thread_by_id((NeonTC2Container *)((char *)this + 2312), v2);
        SynchroManager::remove_thread((NeonTC2Container *)((char *)this + 2312), v2++);
      }
      while (v2 < *((_DWORD *)this + 577));
    }
  }
  NeonContainer::~NeonContainer(this);
}

uint64_t NeonTC2Container::EngineMCSetUp(NeonTC2Container *this, void *a2, int a3, void (*a4)(void *, int))
{
  uint64_t v4;
  _QWORD *v5;

  v4 = *((unsigned int *)this + 577);
  if ((int)v4 >= 1)
  {
    v5 = (_QWORD *)((char *)this + 24 * a3 + 2768);
    do
    {
      *((_BYTE *)v5 - 16) = 1;
      *(v5 - 1) = a2;
      *v5 = a4;
      v5 += 18;
      --v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t NeonMELContainer::NeonMELContainer(uint64_t a1, _QWORD *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  void **v21;
  uint64_t v22;
  void **v23;
  uint64_t v24;
  void **v25;
  uint64_t v26;
  void **v27;
  uint64_t v28;
  void **v29;
  uint64_t v30;
  void **v31;
  uint64_t v32;
  void **v33;
  uint64_t v34;
  void **v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t i;
  unint64_t v41;
  _DWORD *v42;
  void **v44;
  uint64_t v45;
  void *v46;
  _QWORD **v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  _QWORD v51[19];
  uint64_t v52;
  std::__shared_weak_count *v53;

  v19 = (std::__shared_weak_count *)a2[1];
  v52 = *a2;
  v53 = v19;
  if (v19)
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  NeonContainer::NeonContainer(a1, &v52);
  v20 = v53;
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)a1);
  v44 = (void **)&unk_24D29B388;
  v46 = &unk_24D29B3B0;
  v51[0] = &unk_24D29B3D8;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a4 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v21 = (void **)&v44;
  else
    v21 = v44;
  if (SHIBYTE(v46) >= 0)
    v22 = HIBYTE(v46);
  else
    v22 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 16), (uint64_t)v21, v22);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 864));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a5 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v23 = (void **)&v44;
  else
    v23 = v44;
  if (SHIBYTE(v46) >= 0)
    v24 = HIBYTE(v46);
  else
    v24 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 880), (uint64_t)v23, v24);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 288));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a6 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v25 = (void **)&v44;
  else
    v25 = v44;
  if (SHIBYTE(v46) >= 0)
    v26 = HIBYTE(v46);
  else
    v26 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 304), (uint64_t)v25, v26);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 1152));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a7 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v27 = (void **)&v44;
  else
    v27 = v44;
  if (SHIBYTE(v46) >= 0)
    v28 = HIBYTE(v46);
  else
    v28 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 1168), (uint64_t)v27, v28);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 576));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a8 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v29 = (void **)&v44;
  else
    v29 = v44;
  if (SHIBYTE(v46) >= 0)
    v30 = HIBYTE(v46);
  else
    v30 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 592), (uint64_t)v29, v30);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 1440));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a9 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v31 = (void **)&v44;
  else
    v31 = v44;
  if (SHIBYTE(v46) >= 0)
    v32 = HIBYTE(v46);
  else
    v32 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 1456), (uint64_t)v31, v32);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 1728));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a10 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v33 = (void **)&v44;
  else
    v33 = v44;
  if (SHIBYTE(v46) >= 0)
    v34 = HIBYTE(v46);
  else
    v34 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 1744), (uint64_t)v33, v34);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::swap[abi:ne180100]((uint64_t *)&v44, (uint64_t *)(a1 + 2016));
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  std::basic_stringbuf<char,std::char_traits<char>,ENTTS::Allocator<char>>::str(a11 + 24, &v44);
  if (SHIBYTE(v46) >= 0)
    v35 = (void **)&v44;
  else
    v35 = v44;
  if (SHIBYTE(v46) >= 0)
    v36 = HIBYTE(v46);
  else
    v36 = v45;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((_QWORD *)(a1 + 2032), (uint64_t)v35, v36);
  if (SHIBYTE(v46) < 0)
    heap_Free(v47[1], (uint64_t)v44);
  *(_DWORD *)(a1 + 4080) = 80;
  *(_DWORD *)(a1 + 4092) = 0;
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v44);
  NeonMELContainer::SetUp(a1);
  if (!(*(unsigned int (**)(_QWORD))(*(_QWORD *)*a2 + 64))(*a2))
  {
    *(_DWORD *)(a1 + 2308) = 1;
    goto LABEL_99;
  }
  v37 = affinity_safeguard24(a3);
  *(_DWORD *)(a1 + 2308) = v37;
  if ((_DWORD)v37 == 1)
  {
LABEL_99:
    *(_BYTE *)(a1 + 2304) = 0;
    goto LABEL_100;
  }
  *(_BYTE *)(a1 + 2304) = 1;
  if ((int)v37 >= 1)
  {
    v38 = 0;
    v39 = a1 + 3528;
    do
    {
      for (i = 0; i != 120; i += 24)
        *(_BYTE *)(v39 + i) = 0;
      ++v38;
      v39 += 144;
    }
    while (v38 != v37);
  }
  *(_DWORD *)(a1 + 2648) = 0;
  *(_QWORD *)(a1 + 2640) = 0x100000000;
  SynchroManager::init((SynchroManager *)(a1 + 2312), v37);
  if (*(int *)(a1 + 2308) >= 1)
  {
    v41 = 0;
    v42 = (_DWORD *)(a1 + 3504);
    do
    {
      *(_QWORD *)v42 = a1;
      v42[3] = v41;
      if (v41 >= (a3[1] - *a3) >> 2)
        std::vector<float,ENTTS::Allocator<float>>::__throw_out_of_range[abi:ne180100]();
      v42[4] = *(_DWORD *)(*a3 + 4 * v41);
      SynchroManager::start_thread((SynchroManager *)(a1 + 2312), v41++, (void *(*)(void *))NeonMELMultiCore, v42);
      v42 += 36;
    }
    while ((uint64_t)v41 < *(int *)(a1 + 2308));
  }
LABEL_100:
  v44 = (void **)&unk_24D29B388;
  v51[0] = &unk_24D29B3D8;
  v46 = &unk_24D29B3B0;
  v47 = (_QWORD **)&unk_24D29B578;
  if (v49 < 0)
    heap_Free(*(_QWORD **)(v50 + 8), v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8](v51);
  return a1;
}

{
  return NeonMELContainer::NeonMELContainer(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

void sub_214EB6534(_Unwind_Exception *a1)
{
  NeonContainer *v1;

  NeonContainer::~NeonContainer(v1);
  _Unwind_Resume(a1);
}

uint64_t NeonMELContainer::SetUp(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  void *v14;
  void *v15;

  *(_BYTE *)(a1 + 3500) = 0;
  *(_DWORD *)(a1 + 3496) = 0;
  *(_QWORD *)(a1 + 2840) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 264 * *(int *)(a1 + 4080));
  *(_QWORD *)(a1 + 2760) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 1088 * *(int *)(a1 + 4080));
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  *(_QWORD *)(a1 + 2864) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 0x20000);
  *(_DWORD *)(a1 + 4088) = 132;
  do
  {
    v6 = v2 + 1;
    v7 = (int)(384.0 / ldexp(1.0, (int)v2 + 1));
    v8 = upsample_factors[v2];
    v9 = v8 & 1;
    if (v8 >= 0)
    {
      v10 = upsample_factors[v2];
    }
    else
    {
      v9 = -v9;
      v10 = v8 + 1;
    }
    v11 = v8 * *(_DWORD *)(a1 + 4088);
    v12 = v9 - 2 * (v9 + (v10 >> 1)) + v8 + v11;
    if ((int)v3 <= 2 * v11 * v7)
      v3 = 2 * v11 * v7;
    v13 = v12 * v7;
    if ((int)v4 <= v13)
      v4 = v13;
    if (v5 <= 4 * v13)
      v5 = 4 * v13;
    *(_DWORD *)(a1 + 4088) = v12;
    ++v2;
  }
  while (v6 != 3);
  if (v5 <= 16 * v12)
    v5 = 16 * v12;
  if ((int)v4 <= 16 * v12)
    v4 = 16 * v12;
  v14 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 2 * v3);
  *(_QWORD *)(a1 + 2792) = v14;
  bzero(v14, 2 * v3);
  *(_QWORD *)(a1 + 2776) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 2 * v4);
  *(_QWORD *)(a1 + 2848) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 4 * v4);
  v15 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 2 * v4);
  *(_QWORD *)(a1 + 2800) = v15;
  bzero(v15, 2 * v4);
  *(_QWORD *)(a1 + 2784) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 2 * v5);
  *(_QWORD *)(a1 + 2856) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 4 * v5);
  *(_QWORD *)(a1 + 2808) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 2 * v4);
  *(_QWORD *)(a1 + 2816) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 2 * v4);
  *(_QWORD *)(a1 + 2824) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 2 * v4);
  *(_QWORD *)(a1 + 2832) = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 2704) + 32))(*(_QWORD *)(a1 + 2704), 2 * v4);
  return 1;
}

uint64_t NeonMELMultiCore(char *a1)
{
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  int v10;
  void (**v11)(_QWORD, _QWORD);
  _QWORD *v12;
  char *v14;
  char *v15;

  v14 = a1 + 128;
  v15 = a1 + 136;
  v2 = a1 + 112;
  v3 = a1 + 104;
  v4 = a1 + 88;
  v5 = a1 + 80;
  v6 = a1 + 64;
  v7 = a1 + 56;
  v8 = a1 + 40;
  v9 = a1 + 32;
  while (1)
  {
    v10 = SynchroManager::cond_wait_less_equal_on_entry((SynchroManager *)(*(_QWORD *)a1 + 2312), 0);
    v11 = (void (**)(_QWORD, _QWORD))v8;
    v12 = v9;
    switch(v10)
    {
      case 0:
        return SynchroManager::exit_from_thread((SynchroManager *)(*(_QWORD *)a1 + 2312));
      case 1:
        goto LABEL_7;
      case 2:
        v11 = (void (**)(_QWORD, _QWORD))v6;
        v12 = v7;
        goto LABEL_7;
      case 3:
        v11 = (void (**)(_QWORD, _QWORD))v4;
        v12 = v5;
        goto LABEL_7;
      case 4:
        v11 = (void (**)(_QWORD, _QWORD))v2;
        v12 = v3;
        goto LABEL_7;
      case 5:
        v12 = v14;
        v11 = (void (**)(_QWORD, _QWORD))v15;
LABEL_7:
        (*v11)(*v12, *((unsigned int *)a1 + 3));
        break;
      default:
        break;
    }
    SynchroManager::cond_signal_on_exit((SynchroManager *)(*(_QWORD *)a1 + 2312));
  }
}

void NeonMELContainer::~NeonMELContainer(NeonMELContainer *this)
{
  int v2;

  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 355));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 345));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 358));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 349));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 347));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 356));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 350));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 348));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 357));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 351));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 352));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 353));
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 338) + 56))(*((_QWORD *)this + 338), *((_QWORD *)this + 354));
  if (*((_BYTE *)this + 2304))
  {
    SynchroManager::cond_broadcast_on_entry((NeonMELContainer *)((char *)this + 2312), *((_DWORD *)this + 577), 0);
    if (*((int *)this + 577) >= 1)
    {
      v2 = 0;
      do
      {
        SynchroManager::join_thread_by_id((NeonMELContainer *)((char *)this + 2312), v2);
        SynchroManager::remove_thread((NeonMELContainer *)((char *)this + 2312), v2++);
      }
      while (v2 < *((_DWORD *)this + 577));
    }
  }
  NeonContainer::~NeonContainer(this);
}

uint64_t NeonMELContainer::EngineMCSetUp(NeonMELContainer *this, void *a2, int a3, void (*a4)(void *, int))
{
  uint64_t v4;
  _QWORD *v5;

  v4 = *((unsigned int *)this + 577);
  if ((int)v4 >= 1)
  {
    v5 = (_QWORD *)((char *)this + 24 * a3 + 3544);
    do
    {
      *((_BYTE *)v5 - 16) = 1;
      *(v5 - 1) = a2;
      *v5 = a4;
      v5 += 18;
      --v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t NeonContainer::NeonContainer(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v8;
  std::__shared_weak_count *v9;

  v4 = std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100](a1);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100](v4 + 288);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100](a1 + 576);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100](a1 + 864);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100](a1 + 1152);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100](a1 + 1440);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100](a1 + 1728);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::basic_stringstream[abi:ne180100](a1 + 2016);
  v5 = a2[1];
  v8 = *a2;
  v9 = (std::__shared_weak_count *)v5;
  if (v5)
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  SynchroManager::SynchroManager(a1 + 2312, &v8);
  v6 = v9;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *(_OWORD *)(a1 + 2704) = 0u;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]((_QWORD *)(a1 + 2704), a2);
  return a1;
}

void sub_214EB6C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v16);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v15);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v14);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v13);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v12);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v11);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v10);
  std::basic_stringstream<char,std::char_traits<char>,ENTTS::Allocator<char>>::~basic_stringstream(v9);
  _Unwind_Resume(a1);
}

void sub_214EB6CA8()
{
  JUMPOUT(0x214EB6C88);
}

void sub_214EB6CB0()
{
  JUMPOUT(0x214EB6C90);
}

void sub_214EB6CB8()
{
  JUMPOUT(0x214EB6C98);
}

void NeonContainer::~NeonContainer(NeonContainer *this)
{
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 2704);
  SynchroManager::~SynchroManager((NeonContainer *)((char *)this + 2312));
  *((_QWORD *)this + 252) = &unk_24D29B388;
  *((_QWORD *)this + 269) = &unk_24D29B3D8;
  *((_QWORD *)this + 254) = &unk_24D29B3B0;
  *((_QWORD *)this + 255) = &unk_24D29B578;
  if (*((char *)this + 2127) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 266) + 8), *((_QWORD *)this + 263));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8]((char *)this + 2152);
  *((_QWORD *)this + 216) = &unk_24D29B388;
  *((_QWORD *)this + 233) = &unk_24D29B3D8;
  *((_QWORD *)this + 218) = &unk_24D29B3B0;
  *((_QWORD *)this + 219) = &unk_24D29B578;
  if (*((char *)this + 1839) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 230) + 8), *((_QWORD *)this + 227));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8]((char *)this + 1864);
  *((_QWORD *)this + 180) = &unk_24D29B388;
  *((_QWORD *)this + 197) = &unk_24D29B3D8;
  *((_QWORD *)this + 182) = &unk_24D29B3B0;
  *((_QWORD *)this + 183) = &unk_24D29B578;
  if (*((char *)this + 1551) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 194) + 8), *((_QWORD *)this + 191));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8]((char *)this + 1576);
  *((_QWORD *)this + 144) = &unk_24D29B388;
  *((_QWORD *)this + 161) = &unk_24D29B3D8;
  *((_QWORD *)this + 146) = &unk_24D29B3B0;
  *((_QWORD *)this + 147) = &unk_24D29B578;
  if (*((char *)this + 1263) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 158) + 8), *((_QWORD *)this + 155));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8]((char *)this + 1288);
  *((_QWORD *)this + 108) = &unk_24D29B388;
  *((_QWORD *)this + 125) = &unk_24D29B3D8;
  *((_QWORD *)this + 110) = &unk_24D29B3B0;
  *((_QWORD *)this + 111) = &unk_24D29B578;
  if (*((char *)this + 975) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 122) + 8), *((_QWORD *)this + 119));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8]((char *)this + 1000);
  *((_QWORD *)this + 72) = &unk_24D29B388;
  *((_QWORD *)this + 89) = &unk_24D29B3D8;
  *((_QWORD *)this + 74) = &unk_24D29B3B0;
  *((_QWORD *)this + 75) = &unk_24D29B578;
  if (*((char *)this + 687) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 86) + 8), *((_QWORD *)this + 83));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8]((char *)this + 712);
  *((_QWORD *)this + 36) = &unk_24D29B388;
  *((_QWORD *)this + 53) = &unk_24D29B3D8;
  *((_QWORD *)this + 38) = &unk_24D29B3B0;
  *((_QWORD *)this + 39) = &unk_24D29B578;
  if (*((char *)this + 399) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 50) + 8), *((_QWORD *)this + 47));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8]((char *)this + 424);
  *((_QWORD *)this + 17) = &unk_24D29B3D8;
  *(_QWORD *)this = &unk_24D29B388;
  *((_QWORD *)this + 2) = &unk_24D29B3B0;
  *((_QWORD *)this + 3) = &unk_24D29B578;
  if (*((char *)this + 111) < 0)
    heap_Free(*(_QWORD **)(*((_QWORD *)this + 14) + 8), *((_QWORD *)this + 11));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2199DA5E8]((char *)this + 136);
}

void SynchroManager::~SynchroManager(SynchroManager *this)
{
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 376);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 360);
  std::shared_ptr<IJsonWrapper>::~shared_ptr[abi:ne180100]((uint64_t)this + 344);
  std::condition_variable::~condition_variable((std::condition_variable *)this + 5);
  std::mutex::~mutex((std::mutex *)((char *)this + 176));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 128));
  std::mutex::~mutex((std::mutex *)this + 1);
  std::mutex::~mutex((std::mutex *)this);
}

uint64_t SynchroManager::SynchroManager(uint64_t a1, uint64_t *a2)
{
  *(_QWORD *)a1 = 850045863;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 850045863;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 1018212795;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 850045863;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = 1018212795;
  *(_QWORD *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]((_QWORD *)(a1 + 376), a2);
  return a1;
}

{
  *(_QWORD *)a1 = 850045863;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 850045863;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 1018212795;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 850045863;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = 1018212795;
  *(_QWORD *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]((_QWORD *)(a1 + 376), a2);
  return a1;
}

void SynchroManager::cond_broadcast_on_entry(SynchroManager *this, int a2, int a3)
{
  std::mutex *v6;

  v6 = (std::mutex *)((char *)this + 64);
  lock_mutex((std::mutex *)this + 1);
  *((_DWORD *)this + 82) = a2;
  *((_DWORD *)this + 83) = a3;
  condition_broadcast((std::condition_variable *)((char *)this + 128));
  unlock_mutex(v6);
}

void SynchroManager::cond_signal_on_exit(SynchroManager *this)
{
  std::mutex *v2;

  v2 = (std::mutex *)((char *)this + 176);
  lock_mutex((std::mutex *)((char *)this + 176));
  ++*((_DWORD *)this + 84);
  condition_signal((std::condition_variable *)this + 5);
  unlock_mutex(v2);
}

uint64_t SynchroManager::cond_wait_less_equal_on_entry(SynchroManager *this, int a2)
{
  int v3;

  v3 = a2;
  return cond_wait_less_equal((int *)this + 82, &v3, (unsigned int *)this + 83, (std::mutex *)this + 1, (std::condition_variable *)((char *)this + 128));
}

void SynchroManager::cond_wait_less_on_exit(SynchroManager *this, int a2)
{
  int v2;

  v2 = a2;
  cond_wait_less((int *)this + 84, &v2, (std::mutex *)((char *)this + 176), (std::condition_variable *)this + 5);
}

uint64_t SynchroManager::join_thread_by_id(SynchroManager *this, int a2)
{
  return (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this + 47) + 80))(*((_QWORD *)this + 47), (char *)this + 8 * a2 + 296);
}

uint64_t SynchroManager::init(SynchroManager *this, uint64_t a2)
{
  _QWORD *v4;
  std::__shared_weak_count *v5;
  _QWORD *v6;
  std::__shared_weak_count *v7;
  __int128 v9;

  init_mutex((std::mutex *)this);
  init_mutex((std::mutex *)this + 1);
  init_condition((std::condition_variable *)((char *)this + 128));
  init_mutex((std::mutex *)((char *)this + 176));
  init_condition((std::condition_variable *)this + 5);
  (*(void (**)(_QWORD, char *))(**((_QWORD **)this + 47) + 88))(*((_QWORD *)this + 47), (char *)this + 288);
  create_barrier(&v9);
  v4 = (_QWORD *)((char *)this + 344);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)this + 344, &v9);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v9 + 1);
  if (*((_QWORD *)&v9 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v9 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  create_barrier(&v9);
  v6 = (_QWORD *)((char *)this + 360);
  std::shared_ptr<IExternalServices>::operator=[abi:ne180100]<PipelineServices,void>((uint64_t)v6, &v9);
  v7 = (std::__shared_weak_count *)*((_QWORD *)&v9 + 1);
  if (*((_QWORD *)&v9 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((_QWORD *)&v9 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  (**(void (***)(_QWORD, uint64_t))*v4)(*v4, a2);
  return (**(uint64_t (***)(_QWORD, uint64_t))*v6)(*v6, a2);
}

uint64_t SynchroManager::start_thread(SynchroManager *this, int a2, void *(*a3)(void *), void *a4)
{
  return (*(uint64_t (**)(_QWORD, char *, char *, void *(*)(void *), void *))(**((_QWORD **)this + 47)
                                                                                                 + 72))(*((_QWORD *)this + 47), (char *)this + 8 * a2 + 296, (char *)this + 288, a3, a4);
}

uint64_t SynchroManager::exit_from_thread(SynchroManager *this)
{
  (*(void (**)(_QWORD))(**((_QWORD **)this + 47) + 96))(*((_QWORD *)this + 47));
  return 0;
}

uint64_t SynchroManager::remove_thread(SynchroManager *this, int a2)
{
  return (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this + 47) + 104))(*((_QWORD *)this + 47), (char *)this + 8 * a2 + 296);
}

double create_barrier@<D0>(_OWORD *a1@<X8>)
{
  double result;
  __int128 v3;

  ENTTS::make_shared<SpinBarrier>(&v3);
  result = *(double *)&v3;
  *a1 = v3;
  return result;
}

double ENTTS::make_shared<SpinBarrier>@<D0>(_OWORD *a1@<X8>)
{
  _QWORD *v2;
  double result;
  __int128 v4;

  v2 = (_QWORD *)operator new(24);
  v2[2] = 0;
  *v2 = &unk_24D29C488;
  v2[1] = 0;
  std::shared_ptr<SpinBarrier>::shared_ptr[abi:ne180100]<SpinBarrier,ENTTS::Deleter<SpinBarrier>,ENTTS::Allocator<SpinBarrier>,void>(&v4, (uint64_t)v2);
  result = *(double *)&v4;
  *a1 = v4;
  return result;
}

uint64_t cond_wait_less_equal(int *a1, int *a2, unsigned int *a3, std::mutex *this, std::condition_variable *a5)
{
  uint64_t v9;
  _BOOL4 owns;
  std::unique_lock<std::mutex> v12;

  v12.__m_ = this;
  v12.__owns_ = 1;
  std::mutex::lock(this);
  if (*a1 > *a2)
  {
    --*a1;
    v9 = *a3;
LABEL_5:
    std::mutex::unlock(v12.__m_);
    return v9;
  }
  do
    std::condition_variable::wait(a5, &v12);
  while (*a1 <= *a2);
  owns = v12.__owns_;
  --*a1;
  v9 = *a3;
  if (owns)
    goto LABEL_5;
  return v9;
}

void cond_wait_less(int *a1, int *a2, std::mutex *this, std::condition_variable *a4)
{
  _BOOL4 owns;
  std::unique_lock<std::mutex> v8;

  v8.__m_ = this;
  v8.__owns_ = 1;
  std::mutex::lock(this);
  if (*a1 >= *a2)
  {
    *a1 = 0;
LABEL_6:
    std::mutex::unlock(v8.__m_);
    return;
  }
  do
    std::condition_variable::wait(a4, &v8);
  while (*a1 < *a2);
  owns = v8.__owns_;
  *a1 = 0;
  if (owns)
    goto LABEL_6;
}

void SpinBarrier::init(SpinBarrier *this, unsigned int a2)
{
  *((_DWORD *)this + 2) = a2;
  atomic_store(a2, (unsigned int *)this + 3);
  atomic_store(0, (unsigned int *)this + 4);
}

unsigned int *SpinBarrier::wait(unsigned int *this)
{
  unsigned int v1;
  unsigned int v2;

  v1 = atomic_load(this + 4);
  if (atomic_fetch_add((atomic_uint *volatile)this + 3, 0xFFFFFFFF) == 1)
  {
    atomic_store(this[2], this + 3);
    atomic_fetch_add((atomic_uint *volatile)this + 4, 1u);
  }
  else
  {
    do
      v2 = atomic_load(this + 4);
    while (v2 == v1);
  }
  return this;
}

_QWORD *std::shared_ptr<SpinBarrier>::shared_ptr[abi:ne180100]<SpinBarrier,ENTTS::Deleter<SpinBarrier>,ENTTS::Allocator<SpinBarrier>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  *a1 = a2;
  v6 = CustomAllocator::mRsrc;
  v4 = (_QWORD *)ENTTS::Allocator<std::__shared_ptr_pointer<PipelineServices *,ENTTS::Deleter<PipelineServices>,ENTTS::Allocator<PipelineServices>>>::allocate((uint64_t)&v6, 1);
  *v4 = &unk_24D29C4D0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = CustomAllocator::mRsrc;
  a1[1] = v4;
  return a1;
}

void sub_214EB7710(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  if (v1)
    operator delete(v1);
  __cxa_rethrow();
}

void sub_214EB7728(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_pointer<SpinBarrier *,ENTTS::Deleter<SpinBarrier>,ENTTS::Allocator<SpinBarrier>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *result;

  result = *(_QWORD **)(a1 + 24);
  if (result)
    return operator delete((uint64_t)result);
  return result;
}

uint64_t std::__shared_ptr_pointer<SpinBarrier *,ENTTS::Deleter<SpinBarrier>,ENTTS::Allocator<SpinBarrier>>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

_QWORD *std::__shared_ptr_pointer<SpinBarrier *,ENTTS::Deleter<SpinBarrier>,ENTTS::Allocator<SpinBarrier>>::__on_zero_shared_weak(uint64_t a1)
{
  return heap_Free(*(_QWORD **)(CustomAllocator::mRsrc + 8), a1);
}

float *Stream_ComputeStats(float *result, int a2, uint64_t a3)
{
  float v3;
  uint64_t v4;
  float v5;
  uint64_t v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float v11;

  *(_QWORD *)a3 = 0;
  *(float *)(a3 + 8) = (float)a2;
  v3 = 1.0 / (float)a2;
  if (a2 <= 0)
  {
    v10 = 0.0;
    *(float *)a3 = v3 * 0.0;
  }
  else
  {
    v4 = a2;
    v5 = 0.0;
    v6 = a2;
    v7 = result;
    do
    {
      v8 = *v7++;
      v5 = v8 + v5;
      *(float *)a3 = v5;
      --v6;
    }
    while (v6);
    v9 = v3 * v5;
    *(float *)a3 = v3 * v5;
    v10 = 0.0;
    do
    {
      v11 = *result++;
      v10 = v10 + (float)((float)(v11 - v9) * (float)(v11 - v9));
      *(float *)(a3 + 4) = v10;
      --v4;
    }
    while (v4);
  }
  *(float *)(a3 + 4) = v3 * v10;
  return result;
}

void mlpg_gv(uint64_t a1)
{
  uint64_t v2;
  float v3;

  v3 = *(float *)(a1 + 720);
  v2 = 10;
  MFS__mlpg2(a1, 0);
  if (v3 != 0.0 && *(int *)(a1 + 20) >= 2)
    mlpgGradHessian((uint64_t)&v2, (int *)a1, 0);
}

float *mlpgGradHessian(uint64_t a1, int *a2, int a3)
{
  float *result;
  float *v6;
  int *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t *v13;
  uint64_t v14;
  float *v15;
  uint64_t v16;
  int *v17;
  float v18;
  int v19;
  float v20;
  float *v21;
  float **v22;
  float *v23;
  float v24;
  BOOL v25;
  char v26;
  float v27;
  float v28;
  float v29;
  int v30;
  float v31;
  float v32;
  unint64_t v33;
  uint64_t v34;
  float **v35;
  float *v36;
  float *v37;
  float v38;
  uint64_t v39;
  unint64_t i;
  float v41;
  _BYTE *v42;
  uint64_t v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  BOOL v54;
  float v55;
  float v56;
  float *v57;
  float *v58;
  float *v59;
  float **v60;
  unint64_t v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float *v68;
  unint64_t v69;
  float *v70;
  float v71;
  unint64_t v72;
  float *v73;
  float *v74;
  float v75;
  uint64_t *v76;
  unint64_t v77;
  float *v78;
  float v79;
  float v80;
  uint64_t v81;
  float v83;
  float v84;
  float v85;
  float v86;
  char v87;
  int v88;
  int *v89;
  float v90;
  uint64_t v91;
  int v92;

  result = (float *)heap_Calloc(*(_QWORD **)(*(_QWORD *)a2 + 8), 4, (2 * a2[5]));
  if (result)
  {
    v6 = result;
    v7 = a2;
    if (a2[4] >= 1)
    {
      v8 = 0;
      LODWORD(v9) = a2[5];
      v10 = (int)v9;
      v11 = 1.0e10;
      v12 = 1.0;
      v89 = a2;
      do
      {
        if ((int)v9 >= 1)
        {
          v13 = (uint64_t *)*((_QWORD *)v7 + 5);
          v14 = v9;
          v15 = v6;
          do
          {
            v16 = *v13++;
            *v15++ = *(float *)(v16 + 4 * v8);
            --v14;
          }
          while (v14);
        }
        v17 = &v7[v8];
        v18 = *((float *)v17 + 80);
        v90 = *((float *)v17 + 30);
        VarianceNormalize(v6, v9, *(_DWORD *)(a1 + 4), v90);
        calc_R_and_r_opt(v89, v8);
        v7 = v89;
        v9 = v89[5];
        v88 = *(_DWORD *)a1;
        if (*(int *)a1 >= 1)
        {
          v19 = 0;
          v20 = 1.0 / (float)((int)v9 * **((_DWORD **)v89 + 4));
          v21 = (float *)*((_QWORD *)v89 + 11);
          v22 = (float **)*((_QWORD *)v89 + 12);
          v23 = (float *)*((_QWORD *)v89 + 13);
          v85 = v18 * -2.0;
          v83 = v18 + v18;
          v84 = v18 * (float)((int)v9 - 1);
          v24 = -v20;
          if (a3)
            v25 = (int)v9 < 1;
          else
            v25 = 1;
          v26 = v25;
          v87 = v26;
          v27 = v11;
          v86 = v18;
          do
          {
            v92 = 0;
            v91 = 0;
            Stream_ComputeStats(v6, v9, (uint64_t)&v91);
            v29 = v28;
            v30 = *(_DWORD *)(a1 + 4);
            v31 = *((float *)&v91 + 1);
            v32 = *((float *)&v91 + 1);
            if (v30)
              v32 = log(*((float *)&v91 + 1));
            v7 = v89;
            if ((int)v9 < 1)
            {
              v42 = (_BYTE *)*((_QWORD *)v89 + 14);
              v54 = v42 == 0;
              v47 = 0.0;
              v48 = v86;
            }
            else
            {
              v33 = 0;
              v34 = v89[6];
              v35 = v22;
              v36 = v6;
              do
              {
                v37 = v22[v33];
                v38 = *v37 * v6[v33];
                v21[v33] = v38;
                if ((int)v34 >= 2)
                {
                  v39 = -1;
                  for (i = 1; i != v34; ++i)
                  {
                    if (v33 + i < v9)
                    {
                      v38 = v38 + (float)(v37[i] * v36[i]);
                      v21[v33] = v38;
                    }
                    if (v33 >= i)
                    {
                      v38 = v38 + (float)(v35[v39][i] * v36[v39]);
                      v21[v33] = v38;
                    }
                    --v39;
                  }
                }
                ++v33;
                ++v36;
                ++v35;
              }
              while (v33 != v9);
              v41 = (float)(2.0 / (float)((int)v9 * (int)v9)) * (float)(v83 + (float)(v84 * (float)(v32 - v90)));
              v42 = (_BYTE *)*((_QWORD *)v89 + 14);
              if (v42)
              {
                v43 = 0;
                v44 = 1.0 / v31;
                if (v30 != 1)
                  v44 = 1.0;
                v45 = *(float *)&v91;
                v46 = -v41;
                v47 = 0.0;
                v48 = v86;
                do
                {
                  v49 = v6[v43];
                  v50 = v23[v43];
                  v51 = v21[v43];
                  v52 = *v22[v43];
                  v53 = v20 * (float)(v50 - v51);
                  v21[v43] = v53;
                  if (v42[v43])
                    v53 = v53
                        + (float)((float)((float)(v29 * (float)(v85 * (float)(v32 - v90))) * (float)(v6[v43] - v45))
                                * v44);
                  v47 = v47 + (float)((float)(v20 * v49) * (float)(v50 + (float)(v51 * -0.5)));
                  v21[v43++] = (float)(1.0
                                     / (float)((float)((float)((float)(v49 - v45) * (float)(v49 - v45)) * v46)
                                             + (float)(v24 * v52)))
                             * v53;
                }
                while (v9 != v43);
                v54 = 0;
              }
              else
              {
                v55 = *(float *)&v91;
                v56 = -v41;
                v57 = v6;
                v47 = 0.0;
                v58 = v23;
                v59 = v21;
                v60 = v22;
                v61 = v9;
                v48 = v86;
                do
                {
                  v62 = *v57++;
                  v63 = v62;
                  v64 = v20 * v62;
                  v65 = *v58++;
                  v66 = v65;
                  v67 = v65 + (float)(*v59 * -0.5);
                  v68 = *v60++;
                  v47 = v47 + (float)(v64 * v67);
                  *v59 = (float)(v20 * (float)(v66 - *v59))
                       / (float)((float)((float)((float)(v63 - v55) * (float)(v63 - v55)) * v56) + (float)(v24 * *v68));
                  ++v59;
                  --v61;
                }
                while (v61);
                v42 = 0;
                v54 = 1;
              }
            }
            if ((v87 & 1) == 0)
            {
              v69 = v9;
              v70 = v21;
              do
              {
                if (!v54 && *v42 == 1)
                  *v70 = 0.0;
                ++v70;
                ++v42;
                --v69;
              }
              while (v69);
            }
            v71 = v47 + (float)((float)(v32 + (float)(v90 * -2.0)) * (float)(v48 * (float)(v32 * -0.5)));
            v11 = -v71;
            if (v19)
            {
              if (fabsf(v27 + v71) < 0.000001)
              {
                v11 = v27;
                break;
              }
              if (v27 < v11)
                v12 = v12 * 0.5;
              if (v27 > v11)
                v12 = v12 * 1.2;
            }
            if ((int)v9 >= 1)
            {
              v72 = v9;
              v73 = v21;
              v74 = v6;
              do
              {
                *v74 = *v74 + (float)(v12 * *v73);
                v75 = *v73++;
                v74[v10] = v75;
                ++v74;
                --v72;
              }
              while (v72);
            }
            ++v19;
            v27 = -v71;
          }
          while (v19 != v88);
        }
        if ((int)v9 >= 1)
        {
          v76 = (uint64_t *)*((_QWORD *)v7 + 5);
          v77 = v9;
          v78 = v6;
          do
          {
            v79 = *v78++;
            v80 = v79;
            v81 = *v76++;
            *(float *)(v81 + 4 * v8) = *(float *)(v81 + 4 * v8)
                                     + (float)(*(float *)(a1 + 8) * (float)(v80 - *(float *)(v81 + 4 * v8)));
            --v77;
          }
          while (v77);
        }
        ++v8;
      }
      while (v8 < v7[4]);
    }
    return (float *)heap_Free(*(_QWORD **)(*(_QWORD *)v7 + 8), (uint64_t)v6);
  }
  return result;
}

void mlpg_gvc(uint64_t a1)
{
  uint64_t v2;
  float v3;

  v3 = *(float *)(a1 + 720);
  v2 = 10;
  mlpg_c(a1, 0);
  if (v3 != 0.0)
    mlpgGradHessian((uint64_t)&v2, (int *)a1, 1);
}

void mlpg_gvnorm(uint64_t a1)
{
  float v2;
  float *v3;
  uint64_t v4;
  int v5;
  float **v6;
  uint64_t v7;
  float *v8;
  float *v9;
  uint64_t v10;
  float **v11;
  float *v12;
  float v13;
  float v14;
  float *v15;

  v2 = *(float *)(a1 + 720);
  MFS__mlpg2(a1, 0);
  if (v2 != 0.0)
  {
    v3 = (float *)heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), 4, *(unsigned int *)(a1 + 20));
    if (v3)
    {
      v4 = (uint64_t)v3;
      v5 = *(_DWORD *)(a1 + 20);
      if (v5 >= 1)
      {
        v6 = *(float ***)(a1 + 40);
        v7 = *(unsigned int *)(a1 + 20);
        v8 = v3;
        do
        {
          v9 = *v6++;
          *v8++ = *v9;
          --v7;
        }
        while (v7);
      }
      VarianceNormalize(v3, v5, 0, *(float *)(a1 + 120));
      v10 = *(unsigned int *)(a1 + 20);
      if ((int)v10 >= 1)
      {
        v11 = *(float ***)(a1 + 40);
        v12 = (float *)v4;
        do
        {
          v13 = *v12++;
          v14 = v13;
          v15 = *v11++;
          *v15 = *v15 + (float)(v2 * (float)(v14 - *v15));
          --v10;
        }
        while (v10);
      }
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v4);
    }
  }
}

void VarianceNormalize(float *a1, int a2, int a3, float a4)
{
  float *v7;
  float v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  v7 = a1;
  v12 = 0;
  v11 = 0;
  Stream_ComputeStats(a1, a2, (uint64_t)&v11);
  if (a3 == 1)
    a4 = exp(a4);
  if (a2 >= 1)
  {
    v8 = *(float *)&v11;
    v9 = sqrtf(a4 / *((float *)&v11 + 1));
    v10 = a2;
    do
    {
      *v7 = v8 + (float)((float)(*v7 - v8) * v9);
      ++v7;
      --v10;
    }
    while (v10);
  }
}

uint64_t ForcedEEController_TimeGet(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;

  v2 = 0;
  if (a1 && a2)
  {
    v4 = *(_QWORD *)(a1 + 16);
    if (v4 && (v5 = heap_Calloc(*(_QWORD **)(v4 + 8), 1, 12)) != 0)
    {
      v6 = (_DWORD *)v5;
      if (((**(uint64_t (***)(_QWORD, uint64_t))(v4 + 384))(*(_QWORD *)(v4 + 392), v5) & 0x80000000) != 0)
      {
        v2 = 0;
      }
      else
      {
        *a2 = *v6;
        v2 = 1;
      }
      heap_Free(*(_QWORD **)(v4 + 8), (uint64_t)v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t ForcedEEController_Clear(uint64_t result)
{
  if (result)
  {
    *(_DWORD *)(result + 8) = 0;
    *(_QWORD *)result = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)(result + 32) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 40) = 0;
  }
  return result;
}

uint64_t ForcedEEController_SetProcessStart(uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  unsigned int *v6;
  char *__s1;

  result = 1;
  if (!a1 || !a2)
    return result;
  __s1 = 0;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  if ((paramc_ParamGetStr(a1[5], (uint64_t)"bet4earlyemissionmode", &__s1) & 0x80000000) == 0)
  {
    if (cstdlib_strcmp(__s1, "forced"))
    {
      if (cstdlib_strcmp(__s1, "forced-deterministic"))
      {
LABEL_9:
        paramc_ParamRelease(a1[5]);
        goto LABEL_10;
      }
      v5 = 2;
    }
    else
    {
      v5 = 1;
    }
    *(_DWORD *)a2 = v5;
    goto LABEL_9;
  }
LABEL_10:
  if (!*(_DWORD *)a2)
    return 1;
  if (!a1[48] || !a1[49])
    return 0;
  if ((paramc_ParamGetUInt(a1[5], (uint64_t)"bet4earlyemissionforcedoutputlead", (unsigned int *)(a2 + 28)) & 0x80000000) != 0)
    *(_DWORD *)(a2 + 28) = 0;
  *(_QWORD *)(a2 + 16) = a1;
  result = ForcedEEController_TimeGet(a2, (_DWORD *)(a2 + 4));
  if ((_DWORD)result)
  {
    *(_QWORD *)(a2 + 32) = 0;
    *(_DWORD *)(a2 + 40) = 0;
    if (*(_DWORD *)a2 == 2)
    {
      *(_DWORD *)(a2 + 24) = 100;
      v6 = (unsigned int *)(a2 + 24);
      if ((paramc_ParamGetUInt(a1[5], (uint64_t)"bet4earlyemissionforceddeterministicrtf", v6) & 0x80000000) != 0)
        *v6 = 100;
    }
    return 1;
  }
  *(_DWORD *)(a2 + 8) = 0;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  return result;
}

uint64_t ForcedEEController_SetStartedPlayback(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    return 1;
  if (!*(_DWORD *)a1)
    return 1;
  result = ForcedEEController_TimeGet(a1, (_DWORD *)(a1 + 8));
  if ((_DWORD)result)
    return 1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

BOOL ForcedEEController_HasStartedPlayback(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)(result + 8) != 0;
  return result;
}

BOOL ForcedEEController_CheckRiskForBufferUnderrun(_BOOL8 result)
{
  _DWORD *v1;
  _DWORD *v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;

  if (result)
  {
    v1 = (_DWORD *)result;
    if (!*(_DWORD *)result || !*(_DWORD *)(result + 8))
      return 0;
    v2 = (_DWORD *)(result + 40);
    if ((paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)(result + 16) + 40), (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", (unsigned int *)(result + 40)) & 0x80000000) != 0)*v2 = 0;
    if (*v1 == 1)
    {
      v8 = 0;
      if (ForcedEEController_TimeGet((uint64_t)v1, &v8))
      {
        v3 = v1[2];
        v4 = v8 >= v3;
        v5 = v8 - v3;
        if (v5 != 0 && v4)
        {
          v1[8] = v8 - v1[1];
          v1[9] = v5;
        }
      }
    }
    else
    {
      v6 = v1[10];
      v7 = v1[7];
      if (v6 >= v7 - 1)
      {
        if (-1431655765 * v6 <= 0x55555555)
          v6 = v6 - v7 + 1;
        else
          v6 += ~v7;
      }
      v1[9] = v6;
    }
    return *v2 && (v1[7] + v1[9]) >= *v2;
  }
  return result;
}

uint64_t mfs_symData_Init(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  unsigned __int8 *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t result;
  uint64_t v27;
  float v28;
  float v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float v46;
  float v47;
  uint64_t v48;
  float *v49;
  float **v50;
  uint64_t v51;
  uint64_t v52;
  float **v53;
  float *v54;
  int v55;
  uint64_t v56;
  uint64_t i;
  int *v58;
  int *v59;
  uint64_t j;
  uint64_t v61;
  float *v62;
  float v63;
  int *v64;
  uint64_t v65;
  int v66;
  int v67;

  v6 = a1 + 16432;
  v7 = *(_QWORD *)(a1 + 17144);
  *((_QWORD *)a2 + 306) = v7;
  *((_QWORD *)a2 + 307) = *(_QWORD *)(a1 + 16424);
  v8 = *(unsigned int *)(a1 + 16432);
  a2[610] = v8;
  v9 = *(unsigned __int8 **)(a1 + 16664);
  *((_QWORD *)a2 + 302) = v9;
  if (v9)
  {
    v10 = a2[606];
    if ((_DWORD)v8)
    {
      do
      {
        v11 = *v9++;
        v10 += v11;
        --v8;
      }
      while (v8);
    }
    a2[606] = v10;
  }
  if ((*(_DWORD *)(a1 + 8360) - 1) < 2)
  {
    MFS__log_select_Diag(a3, 1, (uint64_t)"%s, Decompression compressed symdata.dat\n");
    v12 = *(_QWORD *)(a1 + 16904);
    v13 = bswap32(*(_DWORD *)(v12 + 8));
    v14 = *(_DWORD *)(v6 + 480);
    v15 = heap_Calloc(*(_QWORD **)(a3 + 8), (104 * v13 + 50) / 0x64u + 384, 1);
    if (!v15)
    {
      MFS__log_select_Error(a3, 1, (uint64_t)"%s, Error, out of memory!\n", v16, v17, v18, v19, v20);
      return 0;
    }
    v21 = (_BYTE *)v15;
    v22 = (unsigned __int8 *)(v12 + 12);
    v23 = *(_DWORD *)(a1 + 8360);
    if (v23 == 2)
    {
      LZ_Uncompress(v22, (uint64_t)v21, v14 - 12);
      v24 = "After lz_77 decoding on symdata.dat, size: %d\n";
      v25 = "Before lz_77 decoding on symdata.dat, size: %d\n";
    }
    else
    {
      if (v23 != 1)
      {
LABEL_14:
        *(_QWORD *)(a1 + 16904) = v21;
        *(_DWORD *)(v6 + 480) = v13;
        *((_QWORD *)a2 + 1556) = v21;
        v7 = *((_QWORD *)a2 + 306);
        goto LABEL_15;
      }
      Huffman_Uncompress(v22, v21, v14 - 12, v13);
      v24 = "After huffman decoding on symdata.dat, size: %d\n";
      v25 = "Before huffman decoding on symdata.dat, size: %d\n";
    }
    MFS__log_select_Diag(a3, 1, (uint64_t)v25);
    MFS__log_select_Diag(a3, 1, (uint64_t)v24);
    goto LABEL_14;
  }
  v21 = *(_BYTE **)(a1 + 16904);
LABEL_15:
  *((_QWORD *)a2 + 304) = v21;
  if (v7 && *((_QWORD *)a2 + 307) && v21)
  {
    v27 = 0;
    *((_QWORD *)a2 + 301) = a3;
    a2[619] = 0;
    do
    {
      v28 = *(float *)(a1 + 8040 + v27 * 4);
      *(float *)&a2[v27 + 616] = v28;
      v29 = v28 + *((float *)a2 + 619);
      *((float *)a2 + 619) = v29;
      ++v27;
    }
    while (v27 != 3);
    *((float *)a2 + 619) = MFS__bet3_finv(v29);
  }
  else
  {
    *((_QWORD *)a2 + 301) = 0;
    MFS__log_select_Diag(a3, 1, (uint64_t)"%s, Warning, has loaded no SYM data\n");
  }
  v30 = *(_DWORD *)(a1 + 8956);
  if (v30 < 1)
  {
    *((_QWORD *)a2 + 1516) = 0;
    MFS__log_select_Diag(a3, 1, (uint64_t)"%s, Warning, has loaded no STYLE data\n");
LABEL_37:
    LODWORD(v48) = *a2;
    if (*a2 < 1)
    {
      v55 = v48 + 2;
    }
    else
    {
      v49 = (float *)(a2 + 622);
      v50 = (float **)(a2 + 660);
      v51 = 2;
      do
      {
        v52 = 0;
        v53 = v50;
        v54 = v49;
        do
        {
          mfs_symData_PreInstallStreamWeights((uint64_t)a2, v52++, *a2, v51, v54, v53);
          v54 += 9;
          v53 += 9;
        }
        while (v52 != 3);
        ++v51;
        v48 = *a2;
        v55 = v48 + 2;
        ++v49;
        ++v50;
      }
      while (v51 < v48 + 2);
    }
    if (*(_DWORD *)(a1 + 8328))
    {
      v56 = a2[610];
      if ((int)v56 >= 1)
      {
        for (i = 0; i != v56; ++i)
        {
          if (v55 >= 3)
          {
            v58 = a2 + 622;
            v59 = a2 + 660;
            for (j = 2; j != v55; ++j)
            {
              v61 = 0;
              v62 = (float *)&a2[256 * j + 728 + i];
              *v62 = 0.0;
              v63 = 0.0;
              v64 = v59;
              do
              {
                v65 = *(_QWORD *)v64;
                v64 += 18;
                v63 = v63 + (float)(*(float *)(v65 + 4 * i) * *(float *)&v58[v61]);
                *v62 = v63;
                v61 += 9;
              }
              while (v61 != 27);
              v59 += 2;
              ++v58;
            }
          }
        }
      }
    }
    if (*(_DWORD *)(*((_QWORD *)a2 + 134) + 8372))
      return 1;
    v66 = a2[610];
    a2[3108] = 0;
    result = 1;
    if (v66 > 47)
    {
      if (v66 == 48)
      {
        if ((_DWORD)v48 != 3)
          return result;
        v67 = 16;
      }
      else if (v66 == 51)
      {
        if ((_DWORD)v48 != 3)
          return result;
        v67 = 17;
      }
      else
      {
        if (v66 != 54 || (_DWORD)v48 != 3)
          return result;
        v67 = 18;
      }
LABEL_74:
      a2[3108] = v67;
      return result;
    }
    switch(v66)
    {
      case '$':
        if ((_DWORD)v48 == 3)
        {
          v67 = 12;
          goto LABEL_74;
        }
        break;
      case '\'':
        if ((_DWORD)v48 == 3)
        {
          v67 = 13;
          goto LABEL_74;
        }
        break;
      case '*':
        if ((_DWORD)v48 == 3)
        {
          v67 = 14;
          goto LABEL_74;
        }
        break;
      case '-':
        if ((_DWORD)v48 == 3)
        {
          v67 = 15;
          goto LABEL_74;
        }
        break;
      default:
        return result;
    }
  }
  else
  {
    v31 = 0;
    *((_QWORD *)a2 + 1518) = *(_QWORD *)(a1 + 17384);
    *((_BYTE *)a2 + 12136) = v30;
    *((_QWORD *)a2 + 1516) = a3;
    a2[3047] = 0;
    v32 = ((v30 - 1) * v30) >> 1;
    LODWORD(v33) = *a2;
    v34 = 4 * v32;
    while (1)
    {
      result = heap_Calloc(*(_QWORD **)(*((_QWORD *)a2 + 1516) + 8), (int)v33, 8);
      v35 = (uint64_t)&a2[2 * v31 + 3032];
      *(_QWORD *)(v35 + 24) = result;
      v36 = (uint64_t *)(v35 + 24);
      if (!result)
        break;
      *v36 = result - 16;
      LODWORD(v33) = *a2;
      if (*a2 >= 1)
      {
        v37 = *(_QWORD *)(a1 + 24 * v31 + 17624);
        v38 = *(_QWORD *)(a1 + 24 * v31 + 17864);
        v39 = 2;
        while (1)
        {
          *(_QWORD *)(*v36 + 8 * v39) = heap_Calloc(*(_QWORD **)(*((_QWORD *)a2 + 1516) + 8), *(unsigned int *)(v37 + 4 * (v39 - 2)), 8);
          v40 = *v36;
          v41 = *(_QWORD *)(*v36 + 8 * v39);
          if (!v41)
            break;
          *(_QWORD *)(v40 + 8 * v39) = v41 - 8;
          v42 = *(unsigned int *)(v37 + 4 * (v39 - 2));
          if ((int)v42 >= 1)
          {
            v43 = 8 * v42 + 8;
            v44 = 8;
            do
            {
              *(_QWORD *)(*(_QWORD *)(*v36 + 8 * v39) + v44) = v38;
              v44 += 8;
              v38 += v34;
            }
            while (v43 != v44);
          }
          v33 = *a2;
          if (v39++ > v33)
            goto LABEL_32;
        }
        heap_Free(*(_QWORD **)(*((_QWORD *)a2 + 1516) + 8), v40);
        result = 0;
        break;
      }
LABEL_32:
      v46 = *(float *)(a1 + 4 * v31 + 8080);
      *(float *)&a2[v31 + 3044] = v46;
      v47 = v46 + *((float *)a2 + 3047);
      *((float *)a2 + 3047) = v47;
      if (++v31 == 3)
      {
        *((float *)a2 + 3047) = MFS__bet3_finv(v47);
        goto LABEL_37;
      }
    }
    *((_QWORD *)a2 + 1516) = 0;
  }
  return result;
}

uint64_t GenreTableSize(int a1)
{
  return (((a1 - 1) * a1) >> 1);
}

float mfs_symData_PreInstallStreamWeights(uint64_t a1, unsigned int a2, int a3, int a4, float *a5, float **a6)
{
  uint64_t v7;
  float *v8;
  float v9;
  float v10;
  float result;

  v7 = *(unsigned int *)(a1 + 2440);
  v8 = (float *)(*(_QWORD *)(a1 + 2448) + 4 * v7 * (a4 + a3 * a2 - 2));
  *a6 = v8;
  *a5 = 0.0;
  v9 = 0.0;
  if ((_DWORD)v7)
  {
    do
    {
      v10 = *v8++;
      v9 = v10 + v9;
      *a5 = v9;
      --v7;
    }
    while (v7);
  }
  result = (float)(MFS__bet3_finv(v9) * *(float *)(a1 + 4 * a2 + 2464)) * *(float *)(a1 + 2476);
  *a5 = result;
  return result;
}

_QWORD *mfs_symData_DeInit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t i;
  int v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v1 = result;
  result[304] = 0;
  result[307] = 0;
  result[306] = 0;
  if (result[1516])
  {
    for (i = 0; i != 3; ++i)
    {
      v3 = *(_DWORD *)v1;
      if (*(int *)v1 < 1)
      {
        v7 = 2;
      }
      else
      {
        v4 = &v1[i + 1519];
        v5 = 2;
        do
        {
          *(_QWORD *)(*v4 + 8 * v5) += 8;
          v6 = *(_QWORD *)(*v4 + 8 * v5);
          if (v6)
          {
            result = heap_Free(*(_QWORD **)(v1[1516] + 8), v6);
            v3 = *(_DWORD *)v1;
          }
          v7 = v5 + 1;
        }
        while (v5++ <= v3);
      }
      v9 = &v1[i];
      v10 = v9[1519] + 16;
      v9[1519] = v10;
      v11 = *(_QWORD *)(v10 + 8 * v7);
      if (v11)
        result = heap_Free(*(_QWORD **)(v1[1516] + 8), v11);
    }
  }
  v1[1516] = 0;
  v1[301] = 0;
  return result;
}

uint64_t mfs_symData_GetTargetVector(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(unsigned int *)(result + 2440);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = a4 + 2;
    v7 = a4 + 1;
    while (2)
    {
      v8 = *(unsigned __int8 *)(*(_QWORD *)(result + 2456) + v5);
      switch(*(_BYTE *)(*(_QWORD *)(result + 2456) + v5))
      {
        case 0xFC:
          if (a4 < 2)
            goto LABEL_17;
          LOBYTE(v9) = *(_BYTE *)(*(_QWORD *)(a3 + 32) + (a4 - 2));
          goto LABEL_25;
        case 0xFD:
          if (a4 < 1)
            goto LABEL_17;
          LOBYTE(v9) = *(_BYTE *)(*(_QWORD *)(a3 + 32) + (a4 - 1));
          goto LABEL_25;
        case 0xFE:
          if ((int)v7 >= *(__int16 *)(a3 + 10))
            goto LABEL_17;
          LOBYTE(v9) = *(_BYTE *)(*(_QWORD *)(a3 + 32) + v7);
          goto LABEL_25;
        case 0xFF:
          if ((int)v6 >= *(__int16 *)(a3 + 10))
LABEL_17:
            LOBYTE(v9) = 0;
          else
            LOBYTE(v9) = *(_BYTE *)(*(_QWORD *)(a3 + 32) + v6);
          goto LABEL_25;
        default:
          if ((_DWORD)v8 == 22)
          {
            v9 = *(unsigned __int8 *)(*(_QWORD *)(a3 + 32) + a4);
            if (v9 != 1)
            {
              v9 = *(char *)(*(_QWORD *)(a3 + 192) + a4);
              if (v9 < 0)
                LOBYTE(v9) = -1;
              else
                LOBYTE(v9) = 2 * v9;
            }
          }
          else if ((_DWORD)v8 == 29)
          {
            v10 = *(_QWORD *)(a3 + 248);
            if (v10)
            {
              v9 = *(unsigned __int8 *)(v10 + a4);
              if (!v9)
                LOBYTE(v9) = -1;
            }
            else
            {
              LOBYTE(v9) = -1;
            }
          }
          else
          {
            v11 = *(_QWORD *)(a3 + 8 * v8 + 16);
            if (!v11)
              goto LABEL_26;
            LOBYTE(v9) = *(_BYTE *)(v11 + a4);
          }
LABEL_25:
          *(_BYTE *)(a2 + 4 + v5) = v9;
          v4 = *(unsigned int *)(result + 2440);
LABEL_26:
          if (++v5 >= v4)
            return result;
          continue;
      }
    }
  }
  return result;
}

uint64_t mfs_symData_GetCandVector(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6, uint64_t *a7)
{
  int v7;
  unsigned int v8;

  v7 = *(_DWORD *)(a2 + 12432);
  if (v7)
    v8 = a5 - a6 + 2;
  else
    v8 = (a5 - a6 + 2) / a4;
  if (*(_DWORD *)(*(_QWORD *)(a2 + 1072) + 8372) == 1)
  {
    mfs_symData_recoverCompactFeatVect(a1, a2, a3, v8, a7);
  }
  else
  {
    if (!v7)
      v7 = *(_DWORD *)(a2 + 2440);
    *a7 = *(_QWORD *)(a2 + 2432) + v7 * v8;
  }
  return 0;
}

uint64_t mfs_symData_PrintVector(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;

  result = *(_QWORD *)(a1 + 2408);
  if (result)
  {
    MFS__log_select_Diag(result, 1, (uint64_t)"TargetVector:");
    if (*(_DWORD *)(a1 + 2440))
    {
      v3 = 0;
      do
      {
        MFS__log_select_Diag(*(_QWORD *)(a1 + 2408), 1, (uint64_t)"%d ");
        ++v3;
      }
      while (v3 < *(unsigned int *)(a1 + 2440));
    }
    return MFS__log_select_Diag(*(_QWORD *)(a1 + 2408), 1, (uint64_t)"\n");
  }
  return result;
}

float mfs_symData_InstallStreamWeights(uint64_t a1, uint64_t a2, unsigned int a3, int a4, int a5, float result)
{
  uint64_t v7;
  float *v8;
  float v9;
  float v10;

  if (*(_QWORD *)(a1 + 2408))
  {
    v7 = *(unsigned int *)(a1 + 2440);
    v8 = (float *)(*(_QWORD *)(a1 + 2448) + 4 * v7 * (a5 + a4 * a3 - 2));
    *(_QWORD *)(a2 + 184) = v8;
    *(_DWORD *)a2 = 0;
    v9 = 0.0;
    if ((_DWORD)v7)
    {
      do
      {
        v10 = *v8++;
        v9 = v10 + v9;
        *(float *)a2 = v9;
        --v7;
      }
      while (v7);
    }
    result = (float)(MFS__bet3_finv(v9) * *(float *)(a1 + 4 * a3 + 2464)) * *(float *)(a1 + 2476);
    *(float *)a2 = result;
  }
  return result;
}

uint64_t mfs_symData_recoverCompactFeatVect(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  int v12;
  unint64_t v13;
  int v14;

  v5 = *(unsigned int *)(a2 + 2440);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = *a5;
    v8 = *(_DWORD *)(a2 + 2424) * a4;
    v9 = *(_QWORD *)(a2 + 2432) + (v8 >> 3);
    v10 = v8 & 7;
    do
    {
      v11 = v8 & 7;
      v12 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 2416) + v6);
      v13 = (unint64_t)v10 >> 3;
      if ((v11 + v12) < 9)
        v14 = 0;
      else
        v14 = *(unsigned __int8 *)(v9 + v13 + 1);
      *(_BYTE *)(v7 + v6) = (unsigned __int16)((v14 | (*(unsigned __int8 *)(v9 + v13) << 8)) << v11) >> (16 - v12);
      v8 = v10 + v12;
      ++v6;
      v10 = v8;
    }
    while (v5 != v6);
  }
  return 0;
}

uint64_t mfs_symData_DistanceOnUid_PreCalc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v14;
  uint64_t result;
  unsigned int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  _OWORD v21[11];
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v14 = *(_QWORD *)(a2 + 2400);
  v22 = 0;
  memset(v21, 0, sizeof(v21));
  v20 = v21;
  result = mfs_symData_GetCandVector(a1, a2, a3, *(_DWORD *)a2, a6, a7, (uint64_t *)&v20);
  v16 = *(_DWORD *)(a2 + 2440);
  if (v16)
  {
    v17 = 0;
    v18 = (uint64_t)v20;
    v19 = a4 + 4;
    do
    {
      *(_DWORD *)(a9 + 4 * v17) = 0;
      if (*(_DWORD *)(a10 + 4 * v17))
      {
        result = *(unsigned __int8 *)(v19 + v17);
        if ((_DWORD)result != *(unsigned __int8 *)(v18 + v17))
          *(_DWORD *)(a9 + 4 * v17) = 1065353216;
      }
      else if (v14
             && ((result = *(_QWORD *)(v14 + 8 * (v17 + (a7 - 1 - a8 + 8 * a8) * v16))) != 0
              || (result = *(_QWORD *)(v14 + 8 * (v17 + v16 * (a7 - 1)))) != 0
              || (result = *(_QWORD *)(v14 + 8 * v17)) != 0))
      {
        *(_DWORD *)(a9 + 4 * v17) = *(_DWORD *)(result
                                              + 4
                                              * (*(unsigned __int8 *)(v18 + v17)
                                               + ((unint64_t)*(unsigned __int8 *)(v19 + v17) << 7)));
      }
      else
      {
        result = *(unsigned __int8 *)(v19 + v17);
        if ((_DWORD)result != *(unsigned __int8 *)(v18 + v17))
        {
          *(_DWORD *)(a9 + 4 * v17) = 1065353216;
          *(_DWORD *)(a10 + 4 * v17) = 1;
          v16 = *(_DWORD *)(a2 + 2440);
        }
      }
      ++v17;
    }
    while (v17 < v16);
  }
  return result;
}

float mfs_symData_DistanceOnUid_Tahoe(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float *a9)
{
  uint64_t v9;
  float *v11;
  float v12;
  float v13;
  float v14;
  float v15;

  v9 = *(unsigned int *)(a2 + 2440);
  if ((_DWORD)v9)
  {
    v11 = *(float **)(a4 + 184);
    v12 = 0.0;
    do
    {
      v13 = *a9++;
      v14 = v13;
      v15 = *v11++;
      v12 = v12 + (float)(v14 * v15);
      --v9;
    }
    while (v9);
  }
  else
  {
    v12 = 0.0;
  }
  return v12 * *(float *)a4;
}

float mfs_symData_DistanceOnUid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  uint64_t v17;
  _OWORD *v19;
  _OWORD v20[11];
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  v19 = v20;
  v12 = *(_QWORD *)(a2 + 2400);
  mfs_symData_GetCandVector(a1, a2, a3, *(_DWORD *)a2, a6, a7, (uint64_t *)&v19);
  if (!*(_QWORD *)(a2 + 2408))
    return 0.0;
  v13 = *(unsigned int *)(a2 + 2440);
  if ((_DWORD)v13)
  {
    v14 = 0;
    v15 = a4 + 4;
    v16 = 0.0;
    do
    {
      if (v12
        && ((v17 = *(_QWORD *)(v12 + 8 * (v13 * (a7 - 1 - a8 + 8 * a8) + v14))) != 0
         || (v17 = *(_QWORD *)(v12 + 8 * (v13 * (a7 - 1) + v14))) != 0
         || (v17 = *(_QWORD *)(v12 + 8 * v14)) != 0))
      {
        v16 = v16
            + (float)(*(float *)(v17
                               + 4
                               * (*((unsigned __int8 *)v19 + v14)
                                + ((unint64_t)*(unsigned __int8 *)(v15 + v14) << 7)))
                    * *(float *)(*(_QWORD *)(a4 + 184) + 4 * v14));
      }
      else if (*(unsigned __int8 *)(v15 + v14) != *((unsigned __int8 *)v19 + v14))
      {
        v16 = v16 + *(float *)(*(_QWORD *)(a4 + 184) + 4 * v14);
      }
      ++v14;
    }
    while (v13 != v14);
  }
  else
  {
    v16 = 0.0;
  }
  return v16 * *(float *)a4;
}

float mfs_symData_Distance(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  float v5;

  if (!*(_QWORD *)(a1 + 2408))
    return 0.0;
  v3 = *(unsigned int *)(a1 + 2440);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = 0.0;
    do
    {
      if (*(unsigned __int8 *)(a2 + 4 + v4) != *(unsigned __int8 *)(a3 + v4))
        v5 = v5 + *(float *)(*(_QWORD *)(a2 + 184) + 4 * v4);
      ++v4;
    }
    while (v3 != v4);
  }
  else
  {
    v5 = 0.0;
  }
  return v5 * *(float *)a2;
}

float mfs_symData_GenreDivergence(uint64_t a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6;
  float v7;
  unsigned int v8;

  if (!*(_QWORD *)(a1 + 12128))
    return 0.0;
  v6 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 12144) + a6);
  v7 = 0.0;
  if (v6 != a5)
  {
    if (a5 <= v6)
      v8 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 12144) + a6);
    else
      v8 = a5;
    if (a5 < v6)
      v6 = a5;
    v7 = *(float *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8 * a2 + 12152) + 8 * a3) + 8 * a4)
                  + 4 * (int)(v6 + ((int)((v8 - 1) * v8) >> 1)));
  }
  return (float)(v7 * *(float *)(a1 + 4 * a2 + 12176)) * *(float *)(a1 + 12188);
}

float mfsLLCost(float a1, float a2)
{
  return (float)(a1 * a2) * (float)(a1 * a2);
}

float mfsLLCostVar(float a1, float a2)
{
  return (float)(a1 * a1) * a2;
}

void mfsProbToPenalty(float a1, float a2)
{
  float v2;
  float v3;
  float v4;

  v2 = a2 * 0.39894;
  v3 = exp((float)((float)((float)(a1 * a2) * (float)(a1 * a2)) * -0.5));
  v4 = v2 * v3;
  if ((float)(v2 * v3) > 1.0e-10 && v4 < 0.9)
    log(v4);
}

float mfsLogLikelihood(float a1, float a2)
{
  float v3;
  float v4;
  float v5;

  v3 = -(float)(a1 * a1);
  v4 = MFS__bet3_finv(a2);
  v5 = log(v4);
  return -(float)(v5 - (float)(v3 * a2));
}

char *mfs_InitParam(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  char *result;
  unint64_t v10;
  float *v11;
  uint64x2_t v12;
  int32x2_t v13;

  v2 = a1 + 24116;
  v3 = (_OWORD *)(a1 + 8316);
  cstdlib_memset((void *)a1, 0, 0x62D0uLL);
  *(_QWORD *)(v2 + 1064) = 20;
  *(_DWORD *)(v2 + 1080) = 40;
  *(_QWORD *)(v2 + 1072) = 0x2800000000;
  *(_QWORD *)(a1 + 25216) = 100000;
  *(_QWORD *)(a1 + 25208) = 0;
  *(_DWORD *)(v2 + 1024) = 0;
  *(_DWORD *)(a1 + 7624) = 0;
  *(_DWORD *)(a1 + 8388) = 0;
  *(_QWORD *)(a1 + 8224) = -4294965296;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 8232) = _D0;
  *(int32x2_t *)(a1 + 8240) = vdup_n_s32(0x7D0u);
  *(_OWORD *)(a1 + 8160) = xmmword_214FA6840;
  *(_QWORD *)(a1 + 8876) = 0x3C00000001;
  *(_QWORD *)(a1 + 8884) = 0x142480000;
  *(_QWORD *)(a1 + 8892) = 0;
  *(_DWORD *)(a1 + 8900) = 50;
  *(_DWORD *)(a1 + 8912) = -1;
  *(_QWORD *)(a1 + 8904) = 0xBF80000040600000;
  *(_DWORD *)(a1 + 8928) = 3;
  *(_QWORD *)(a1 + 8932) = 1056964608;
  *(_DWORD *)(a1 + 8248) = 1084227584;
  *(_OWORD *)(a1 + 8256) = xmmword_214FA32A0;
  *(_QWORD *)(a1 + 8272) = 0x100000001;
  *(_DWORD *)(a1 + 8284) = 1056964608;
  *(_OWORD *)(a1 + 8288) = xmmword_214FBFA00;
  *(_QWORD *)(a1 + 8304) = 0x400000003F800000;
  *(_DWORD *)(a1 + 8312) = 1065353216;
  *v3 = xmmword_214FBFA10;
  *(_DWORD *)(a1 + 8332) = 0;
  *(_OWORD *)((char *)v3 + 28) = xmmword_214FBFA20;
  *(_QWORD *)(a1 + 8376) = 1148846080;
  *(_OWORD *)(a1 + 25144) = xmmword_214FA6880;
  *(_DWORD *)(a1 + 8384) = 1092616192;
  *(int32x2_t *)(a1 + 25160) = vdup_n_s32(0xFA0u);
  *(_DWORD *)(v2 + 1052) = 2000;
  *(_DWORD *)(a1 + 8952) = 0;
  *(_OWORD *)(a1 + 8560) = xmmword_214FBFA30;
  *(_DWORD *)(a1 + 8576) = 12;
  MFS__InitVParam((_DWORD *)a1);
  result = cstdlib_strcpy((char *)(a1 + 7672), "mfs");
  v10 = 0;
  *(_DWORD *)(a1 + 8180) = 1056964608;
  *(_DWORD *)v2 = 1065353216;
  v11 = (float *)(a1 + 24124);
  v12.i64[0] = 255;
  v12.i64[1] = 255;
  do
  {
    v13 = vmovn_s64((int64x2_t)vcgtq_u64(v12, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v10), (int8x16_t)xmmword_214F962F0)));
    if ((v13.i8[0] & 1) != 0)
      *(v11 - 1) = 1.0 / (float)(v10 + 1);
    if ((v13.i8[4] & 1) != 0)
      *v11 = 1.0 / (float)(v10 + 2);
    v10 += 2;
    v11 += 2;
  }
  while (v10 != 256);
  return result;
}

void *mfs_DeInitParam(uint64_t a1, _DWORD *__b)
{
  int v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*((_QWORD *)__b + 1453))
  {
    if (*((_QWORD *)__b + 1483))
    {
      v4 = __b[33];
      if (v4 >= 1)
      {
        v5 = 0;
        v6 = (char *)(__b + 2846);
        do
        {
          if (__b[v5 + 56] && *(_QWORD *)v6)
          {
            heap_Free(*(_QWORD **)(a1 + 8), *(_QWORD *)v6);
            *(_QWORD *)v6 = 0;
            *((_DWORD *)v6 + 2) = 0;
            v4 = __b[33];
          }
          ++v5;
          v6 += 24;
        }
        while (v5 < v4);
      }
    }
  }
  MFS__DeInitVParam(a1, __b);
  v7 = *((_QWORD *)__b + 999);
  if (v7)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v7);
    *((_QWORD *)__b + 999) = 0;
  }
  v8 = *((_QWORD *)__b + 3012);
  if (v8)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v8);
    *((_QWORD *)__b + 3012) = 0;
  }
  v9 = *((_QWORD *)__b + 3013);
  if (v9)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v9);
    *((_QWORD *)__b + 3013) = 0;
  }
  return cstdlib_memset(__b, 0, 0x62D0uLL);
}

uint64_t mfs_kld_lookup(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, float *a6, uint64_t a7, uint64_t a8)
{
  float v9;
  uint64_t result;
  int v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned __int8 *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  float v33;
  float v34;
  unsigned int v35;
  float v36;
  float *v37;
  __int16 v38;
  __int16 v39;

  v9 = 0.0;
  if (a3 != (_DWORD)a4)
  {
    v12 = *(_DWORD *)(a1 + 12256);
    if (v12 == 2)
    {
      v39 = 0;
      v13 = *(unsigned __int8 **)(a1 + 12264);
      v14 = *(_DWORD *)&v13[8 * (int)a5 - 4];
      v15 = (v14 + a4);
      v16 = *(unsigned __int16 *)&v13[4 * v15 + 32];
      if ((_DWORD)v16 == 0xFFFF)
      {
        MFS__log_select_Error(a2, 0, (uint64_t)"Error in KLD partitioning - Target MCP index belongs to a removed partition", a4, a5, (uint64_t)a6, a7, a8);
        return 2229280783;
      }
      v24 = v14 + a3;
      v25 = *(unsigned __int16 *)&v13[4 * v24 + 32];
      if (v25 == 0xFFFF)
      {
        MFS__log_select_Diag(a2, 0, (uint64_t)"Warning: Suspicious KLD partitioning - Candidate MCP index belongs to a removed partition");
        v9 = 1.0e10;
      }
      else
      {
        if (v25 == (_DWORD)v16)
        {
          v28 = *v13;
          v27 = v13 + 32;
          v26 = v28;
          v29 = *(unsigned __int16 *)&v27[4 * v15 + 2];
          v30 = *(unsigned __int16 *)&v27[4 * v24 + 2];
          if (v29 >= v30)
            v31 = v30;
          else
            v31 = v29;
          if (v29 > v30)
            v30 = v29;
          v32 = *(_QWORD *)(a1 + 12272) + 16 * v16;
          mfs_calcKLDIdx(v26, *(_QWORD *)(a1 + 12280) + *(unsigned int *)(v32 + 12), v30 + ~*(_DWORD *)(v32 + 8) + *(_DWORD *)(v32 + 8) * v31 - ((v31 + v31 * v31) >> 1), &v39);
          v33 = *(float *)v32;
          v34 = *(float *)(v32 + 4);
          LOWORD(v35) = v39;
          v36 = (float)v35;
        }
        else
        {
          MFS__log_select_Diag(a2, 0, (uint64_t)"Warning: Suspicious KLD partitioning - Candidate and target MCP index do not belong to the same partition");
          v37 = (float *)(*(_QWORD *)(a1 + 12272) + 16 * v16);
          v33 = *v37;
          v34 = v37[1];
          v36 = (float)~(-1 << **(_DWORD **)(a1 + 12264));
        }
        v9 = v33 + (float)(v34 * v36);
      }
    }
    else
    {
      v17 = (int)a5;
      if (a3 >= a4)
        v19 = a4;
      else
        v19 = a3;
      if (a3 <= a4)
        v20 = a4;
      else
        v20 = a3;
      v18 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * (int)a5);
      v21 = v20 + ~v18 + v18 * v19 - ((v19 + v19 * v19) >> 1);
      if (v12 == 1)
      {
        v38 = 0;
        v22 = a1 + 12264;
        mfs_calcKLDIdx(*(unsigned __int8 *)(a1 + 12264), *(_QWORD *)(a1 + 12264 + 8 * (int)a5 + 8), v21, &v38);
        LOWORD(v23) = v38;
        v9 = *(float *)(v22 + 4 * v17 + 88) + (float)(*(float *)(v22 + 4 * v17 + 128) * (float)v23);
      }
      else
      {
        v9 = *(float *)(*(_QWORD *)(a1 + 8 * (int)a5 + 12264) + 4 * v21);
      }
    }
  }
  result = 0;
  if (a6)
    *a6 = v9;
  return result;
}

uint64_t mfs_calcKLDIdx(uint64_t result, uint64_t a2, unsigned int a3, _WORD *a4)
{
  unsigned int v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;

  if ((_DWORD)result)
  {
    if ((_DWORD)result == 16)
    {
      v4 = bswap32(*(unsigned __int16 *)(a2 + 2 * a3)) >> 16;
    }
    else if ((_DWORD)result == 8)
    {
      LOWORD(v4) = *(unsigned __int8 *)(a2 + a3);
    }
    else
    {
      v5 = 0;
      v4 = 0;
      v6 = (unint64_t)(result * a3) >> 3;
      v7 = *(unsigned __int8 *)(a2 + v6);
      v8 = ((_BYTE)result * (_BYTE)a3) & 7;
      do
      {
        if ((++v5 & 7) != 0)
        {
          v9 = v8 + 1;
          v10 = v7;
        }
        else
        {
          v9 = 0;
          LODWORD(v6) = v6 + 1;
          v10 = *(unsigned __int8 *)(a2 + v6);
        }
        v4 = (2 * v4) | ((_DWORD)v7 << v8 >> 7) & 1;
        v7 = v10;
        v8 = v9;
      }
      while ((_DWORD)result != v5);
    }
  }
  else
  {
    LOWORD(v4) = 0;
  }
  *a4 = v4;
  return result;
}

uint64_t mfs_GetLeafIndex(uint64_t a1, int a2, int a3)
{
  unsigned int *v3;

  if (a2)
    v3 = (unsigned int *)(*(_QWORD *)(a1 + 8 * a2 + 72) + 4 * a3);
  else
    v3 = (unsigned int *)(a1 + 8);
  return *v3;
}

uint64_t mfs_IsPerceptualInvariantState(uint64_t a1, uint64_t a2, int *a3)
{
  int v6;

  v6 = *a3;
  if (v6 + 1 < *(_DWORD *)(a2 + 608))
  {
    mfs_Ling_IsInvariantPhoneme(a1, *(_QWORD *)(a2 + 8), *(_DWORD *)(*(_QWORD *)(a2 + 600) + 528 * (v6 + 1)));
    v6 = *a3;
  }
  if (v6 >= 2)
  {
    mfs_Ling_IsInvariantPhoneme(a1, *(_QWORD *)(a2 + 8), *(_DWORD *)(*(_QWORD *)(a2 + 600) + 528 * (v6 - 1)));
    v6 = *a3;
  }
  return mfs_Ling_IsInvariantPhoneme(a1, *(_QWORD *)(a2 + 8), v6);
}

float mfs_ProbSynthNoDegradation(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  char *v4;
  int v5;
  int v6;
  char v7;
  char v8;

  if (a2 < 1)
  {
    v5 = 1;
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 24);
    v3 = *(_DWORD *)(v2 + 3056);
    v4 = (char *)(*(_QWORD *)(a1 + 48) + *(int *)(v2 + 1528));
    v5 = 1;
    v6 = a2;
    do
    {
      v8 = *v4++;
      v7 = v8;
      if ((v8 & 4) != 0 && **(float **)(*(_QWORD *)(v2 + 3120) + 8 * v3) > 4.7)
        ++v5;
      v3 += (v7 & 4) >> 2;
      --v6;
    }
    while (v6);
  }
  return (float)(a2 - v5) / (float)a2;
}

float mfs_PhoneticContextCost(unsigned __int8 *a1, unsigned __int8 *a2, float a3)
{
  int v3;
  float v4;

  v3 = a2[1];
  v4 = 5000.5;
  if (v3 != 1)
    v4 = 0.5;
  if (a1[1] != v3)
    v4 = v4 + 100.0;
  if (*a1 != *a2)
    v4 = v4 + 20.0;
  if (a1[2] != a2[2])
    v4 = v4 + 20.0;
  return v4 * a3;
}

uint64_t mfs_CleanUpTgtVect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a3 + 24) = 0;
  return 0;
}

uint64_t mfs_loc_AddMainCandidates(uint64_t a1, uint64_t a2, _DWORD *a3, _QWORD *a4, int a5, _QWORD *a6, signed int a7, unsigned int a8, float a9, int a10, int a11, unsigned __int8 *a12, _QWORD *a13, uint64_t a14, int a15)
{
  uint64_t Ids;
  uint64_t v22;
  unsigned int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  int v28;

  mfs_S32Vect_Clear((_QWORD *)a14);
  if (a13)
  {
    Ids = mfs_Harch_GetIds(a13, (_QWORD *)a14);
    if ((Ids & 0x80000000) != 0)
      return Ids;
  }
  else
  {
    Ids = 0;
  }
  if (*(_DWORD *)(a14 + 16))
  {
    v22 = 0;
    while (1)
    {
      Ids = mfs_loc_AddCandidate(a2, a6, a7, *(_DWORD *)(*(_QWORD *)(a14 + 8) + 4 * v22), a12, a15, a9, 1.0);
      if ((Ids & 0x80000000) != 0)
        break;
      if (++v22 >= (unint64_t)*(unsigned int *)(a14 + 16))
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    mfs_S32Vect_Clear((_QWORD *)a14);
    v28 = *(_DWORD *)(a6[1] + 32 * a7 + 16);
    if (!a10
      || a3[2197]
      || (Ids = mfs_IbAddtoVect(a1, a2, (uint64_t)a3, 0, 1, a5, *(_DWORD *)(a4[10] + 4 * a5), v28, a9, 1.0, 0.25, a8, a6, a7, a12, a15), (Ids & 0x80000000) == 0))
    {
      if (a3[2198]
        && ((v23 = *(_DWORD *)(a6[1] + 32 * a7 + 16) - v28, v23 <= 0xC7) ? (v24 = v23 >= a8) : (v24 = 1),
            !v24 && *(_DWORD *)(a4[45] + 4 * a5)))
      {
        v25 = 0;
        while (1)
        {
          Ids = mfs_IbAddtoVect(a1, a2, (uint64_t)a3, 0, 1, a5, *(_DWORD *)(*(_QWORD *)(a4[44] + 8 * a5) + 4 * v25), v28, a9, 1.0, 0.25, a8, a6, a7, a12, a15);
          if ((Ids & 0x80000000) != 0)
            break;
          if (++v25 >= (unint64_t)*(unsigned int *)(a4[45] + 4 * a5))
            goto LABEL_21;
        }
      }
      else
      {
LABEL_21:
        if (!a11 && a5 >= 3)
        {
          if (a3[2196])
          {
            mfs_S32Vect_Clear((_QWORD *)a14);
            Ids = mfs_StateNGram_GetAlternatives(a2 + 2280, *(_DWORD *)(a4[10] + 4 * (a5 - 1)), -1, a5, (_QWORD *)a14);
            if ((Ids & 0x80000000) == 0)
            {
              if (*(_DWORD *)(a14 + 16))
              {
                v26 = 0;
                while (1)
                {
                  Ids = mfs_IbAddtoVect(a1, a2, (uint64_t)a3, 0, 1, a5, *(_DWORD *)(*(_QWORD *)(a14 + 8) + 4 * v26), v28, a9, 1.0, 0.25, a8, a6, a7, a12, a15);
                  if ((Ids & 0x80000000) != 0)
                    break;
                  if (++v26 >= (unint64_t)*(unsigned int *)(a14 + 16))
                    goto LABEL_29;
                }
              }
              else
              {
LABEL_29:
                mfs_S32Vect_Clear((_QWORD *)a14);
              }
            }
          }
        }
      }
    }
  }
  return Ids;
}

uint64_t mfs_loc_AddCandidate(uint64_t a1, _QWORD *a2, signed int a3, unsigned int a4, unsigned __int8 *a5, int a6, float a7, float a8)
{
  uint64_t result;
  int v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float *v23;
  _QWORD v24[2];
  unsigned int v25;

  v25 = 0;
  v24[0] = 0;
  v24[1] = 0;
  v23 = (float *)v24;
  mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, a4, (uint64_t *)&v23);
  result = 0;
  v17 = a5[1];
  v18 = 5000.5;
  if (v17 != 1)
    v18 = 0.5;
  if (*((unsigned __int8 *)v23 + 13) != v17)
    v18 = v18 + 100.0;
  if (*((unsigned __int8 *)v23 + 12) != *a5)
    v18 = v18 + 20.0;
  if (*((unsigned __int8 *)v23 + 14) != a5[2])
    v18 = v18 + 20.0;
  v19 = v18 * 0.0071174;
  if ((float)(1.0 / (float)(v19 / 0.0071174)) > a7)
  {
    v20 = 1.0 - v19;
    result = mfs_CostList_Add(a1, a2, a3, a4, *(_QWORD *)(a1 + 2384), *(_DWORD *)(a1 + 2392), &v25, (float)((float)-(float)(*v23 * a8) * (float)(1.0 - v19)) + 1000.0);
    if ((result & 0x80001FFF) == 0x80000002)
    {
      v21 = *(float *)(*(_QWORD *)(a2[1] + 32 * a3) + 8 * v25 + 4);
      if (a6)
        v22 = v21 * 0.5;
      else
        v22 = v21 + (float)((float)-(float)(*v23 * a8) * v20);
      mfs_CostList_UpdateCost((uint64_t)a2, a3, v25, v22);
      return 0;
    }
  }
  return result;
}

uint64_t mfs_IbAddtoVect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, float a9, float a10, float a11, unsigned int a12, _QWORD *a13, signed int a14, unsigned __int8 *a15, int a16)
{
  unint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v29;
  uint64_t v30;
  int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t CandVector;
  float v37;
  unsigned int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  float *v48;
  _QWORD v49[2];
  _OWORD *v50;
  _OWORD v51[11];
  int v52;
  uint64_t v53;

  v20 = 0;
  v21 = 0;
  v53 = *MEMORY[0x24BDAC8D0];
  v46 = a2 + 1552;
  v22 = (uint64_t *)(a2 + 1552 + 8 * a5);
  v24 = *v22;
  v23 = v22 + 10;
  v44 = *(_DWORD *)(*(_QWORD *)(v24 + 8 * a6) + 8 * a7);
  v43 = *(_DWORD *)(a2 + 1096) - 1;
  v52 = 0;
  v45 = a5;
  v25 = a6;
  v26 = a7;
  memset(v51, 0, sizeof(v51));
  v49[1] = 0;
  v50 = v51;
  v48 = (float *)v49;
  v49[0] = 0;
  do
  {
    v27 = *(_DWORD *)(a13[1] + 32 * a14 + 16);
    if (v20 >= *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v46 + 8 * v45) + 8 * v25) + 8 * v26 + 4) || v27 - a8 >= a12)
      break;
    v29 = *(_DWORD *)(*v23 + 4 * (v44 + v20));
    mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v29, (uint64_t *)&v48);
    if (v29 >= v43)
      goto LABEL_22;
    v30 = a3;
    if (*(_DWORD *)(a3 + 8888) && v27 >= 0xA && *v48 != -999.0 && *v48 <= *(float *)(a3 + 8884))
      goto LABEL_22;
    if (!a4 || (v32 = *(_DWORD *)(a3 + 8968)) == 0)
    {
      v21 = mfs_loc_AddCandidate(a2, a13, a14, v29, a15, a16, a9, a10);
      goto LABEL_22;
    }
    if (v32 == 2)
    {
      if (a15[1] != *((unsigned __int8 *)v48 + 13))
        goto LABEL_22;
      v33 = *(_DWORD *)a2;
      v34 = a1;
      v35 = a2;
      v30 = a3;
    }
    else
    {
      v33 = *(_DWORD *)a2;
      v34 = a1;
      v35 = a2;
    }
    CandVector = mfs_symData_GetCandVector(v34, v35, v30, v33, v29, a6, (uint64_t *)&v50);
    if ((CandVector & 0x80000000) != 0)
      return CandVector;
    v37 = mfs_symData_Distance(a2, a4, (uint64_t)v50);
    mfs_loc_AddCandidate_f2(a2, a13, a14, v29, v37, a11);
    v21 = 0;
LABEL_22:
    ++v20;
  }
  while ((v21 & 0x80000000) == 0);
  return v21;
}

uint64_t mfs_VennDiaGrams_Tahoe(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, int a7, int a8, float a9, unsigned int a10, _QWORD *a11, signed int a12, unsigned __int8 a13, int a14)
{
  unint64_t v17;
  uint64_t CandVector;
  uint64_t v19;
  uint64_t *v20;
  _QWORD *v21;
  uint64_t v22;
  int v23;
  unsigned int v25;
  _BOOL4 v26;
  BOOL v27;
  float v28;
  int v29;
  int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _OWORD *v41;
  float *v42;
  _QWORD v43[2];
  unsigned int v44;
  _OWORD v45[11];
  int v46;
  uint64_t v47;

  v17 = 0;
  CandVector = 0;
  v47 = *MEMORY[0x24BDAC8D0];
  v44 = 0;
  v36 = *(_DWORD *)(a2 + 1096) - 1;
  v19 = a2 + 1552;
  v20 = (uint64_t *)(a2 + 1552 + 8 * a4);
  v22 = *v20;
  v21 = v20 + 10;
  v39 = a4;
  v38 = a5;
  v37 = a7;
  v35 = *(_DWORD *)(*(_QWORD *)(v22 + 8 * a5) + 8 * a7);
  v43[0] = 0;
  v43[1] = 0;
  v41 = v45;
  v42 = (float *)v43;
  v46 = 0;
  memset(v45, 0, sizeof(v45));
  v23 = *(_DWORD *)(a11[1] + 32 * a12 + 16);
  do
  {
    if (v17 >= *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v19 + 8 * v39) + 8 * v38) + 8 * v37 + 4) || v23 - a8 >= a10)
      break;
    v25 = *(_DWORD *)(*v21 + 4 * (v35 + v17));
    if (*(_DWORD *)(a3 + 8356) == 1)
    {
      CandVector = mfs_symData_GetCandVector(a1, a2, a3, *(_DWORD *)a2, *(_DWORD *)(*v21 + 4 * (v35 + v17)), a5, (uint64_t *)&v41);
      v26 = *((unsigned __int8 *)v41 + a14) == a13;
    }
    else
    {
      v26 = 1;
    }
    mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v25, (uint64_t *)&v42);
    v27 = v25 >= v36 || !v26;
    if (v27 || *v42 != -999.0 && *(_DWORD *)(a3 + 8888) && *v42 <= *(float *)(a3 + 8884))
      goto LABEL_21;
    v44 = 0;
    v28 = a9;
    if (*((unsigned __int8 *)v42 + 13) == *(unsigned __int8 *)(a6 + 1))
      goto LABEL_18;
    if (a4 == 1)
    {
      v29 = *(_DWORD *)(a3 + 8260);
      if ((v29 & 0x80000000) == 0)
      {
        v28 = (float)v29 + a9;
LABEL_18:
        if ((mfs_CostList_Add(a2, a11, a12, v25, *(_QWORD *)(a2 + 2384), *(_DWORD *)(a2 + 2392), &v44, v28) & 0x80001FFF) == 0x80000002)
          mfs_CostList_UpdateCost((uint64_t)a11, a12, v44, *(float *)(*(_QWORD *)(a11[1] + 32 * a12) + 8 * v44 + 4) + -1.0);
      }
    }
    v23 = *(_DWORD *)(a11[1] + 32 * a12 + 16);
LABEL_21:
    ++v17;
  }
  while ((CandVector & 0x80000000) == 0);
  return CandVector;
}

uint64_t mfs_loc_AddCandidate_f2(uint64_t a1, _QWORD *a2, signed int a3, unsigned int a4, float a5, float a6)
{
  uint64_t result;
  unsigned int v11;

  v11 = 0;
  result = mfs_CostList_Add(a1, a2, a3, a4, *(_QWORD *)(a1 + 2384), *(_DWORD *)(a1 + 2392), &v11, a5);
  if ((result & 0x80001FFF) == 0x80000002)
    return mfs_CostList_UpdateCost((uint64_t)a2, a3, v11, (float)(*(float *)(*(_QWORD *)(a2[1] + 32 * a3) + 8 * v11 + 4) + a5) * a6);
  return result;
}

uint64_t mfs_IbAddtoVect_MCP(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, unsigned int a8, _QWORD *a9, signed int a10, uint64_t a11)
{
  uint64_t v11;
  int *v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  BOOL v16;
  unsigned int v20;
  uint64_t v21;
  unint64_t v22;
  unsigned int v23;
  BOOL v24;
  BOOL v25;
  int v26;
  float v27;
  int v33;
  float *v34;
  _QWORD v35[2];
  int v36;

  v11 = 0;
  v36 = 0;
  v12 = (int *)(*(_QWORD *)(*((_QWORD *)a2 + 195) + 8 * a5) + 8 * a6);
  v13 = *v12;
  v14 = v12[1];
  v35[0] = 0;
  v35[1] = 0;
  v33 = v13;
  v34 = (float *)v35;
  v15 = *(_DWORD *)(a9[1] + 32 * a10 + 16);
  if ((_DWORD)v14)
    v16 = v15 - a7 >= a8;
  else
    v16 = 1;
  if (!v16)
  {
    v11 = 0;
    v20 = a2[274] - 1;
    v21 = *((_QWORD *)a2 + 205);
    v22 = 1;
    do
    {
      v23 = *(_DWORD *)(v21 + 4 * (v33 + v22 - 1));
      mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v23, (uint64_t *)&v34);
      if (v23 < v20)
      {
        v24 = *(_DWORD *)(a3 + 8888) && v15 >= 0xA;
        if (!v24 || (*v34 != -999.0 ? (v25 = *v34 <= *(float *)(a3 + 8884)) : (v25 = 0), !v25))
        {
          v26 = *(unsigned __int8 *)(a11 + 1);
          if (v26 == *((unsigned __int8 *)v34 + 13))
          {
            v27 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v23, a5, v26);
            v11 = mfs_CostList_Pad((uint64_t)a2, a9, a10, v23, *((_QWORD *)a2 + 298), a2[598], &v36, v27);
          }
          v15 = *(_DWORD *)(a9[1] + 32 * a10 + 16);
        }
      }
      if ((v11 & 0x80000000) != 0)
        break;
      if (v22 >= v14)
        break;
      ++v22;
    }
    while (v15 - a7 < a8);
  }
  return v11;
}

uint64_t mfs_IbAddtoVect_LF0(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, unsigned int a8, uint64_t a9, signed int a10, uint64_t a11, _QWORD *a12, unsigned int a13)
{
  uint64_t v13;
  int *v14;
  unint64_t v15;
  uint64_t v16;
  unsigned int v17;
  BOOL v18;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  BOOL v26;
  BOOL v27;
  int IsNodeInList;
  float v29;
  uint64_t v31;
  int v35;
  int v37;
  unsigned int v38;
  float *v39;
  _QWORD v40[2];
  _DWORD v41[3];

  v13 = 0;
  v14 = (int *)(*(_QWORD *)(*((_QWORD *)a2 + 196) + 8 * a5) + 8 * a6);
  v15 = v14[1];
  v37 = *v14;
  v16 = *(_QWORD *)(a9 + 8) + 32 * a10;
  v31 = *(_QWORD *)v16;
  v41[0] = 0;
  v40[0] = 0;
  v40[1] = 0;
  v39 = (float *)v40;
  v17 = *(_DWORD *)(v16 + 16);
  if ((_DWORD)v15)
    v18 = v17 - a7 >= a8;
  else
    v18 = 1;
  if (!v18)
  {
    v13 = 0;
    v35 = 0;
    v22 = a2[274] - 1;
    v23 = *((_QWORD *)a2 + 206);
    v24 = 1;
    do
    {
      v25 = *(_DWORD *)(v23 + 4 * (v37 + v24 - 1));
      mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v25, (uint64_t *)&v39);
      if (v25 < v22)
      {
        v26 = *(_DWORD *)(a3 + 8888) && v17 >= 0xA;
        if (!v26 || (*v39 != -999.0 ? (v27 = *v39 <= *(float *)(a3 + 8884)) : (v27 = 0), !v27))
        {
          if (*(unsigned __int8 *)(a11 + 1) == *((unsigned __int8 *)v39 + 13))
          {
            v38 = 0;
            IsNodeInList = mfs_CostList_IsNodeInList(a9, a10, v25, (uint64_t)a2, &v38);
            v29 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v25, a5, *(unsigned __int8 *)(a11 + 1));
            if (IsNodeInList)
            {
              *(float *)(v31 + 8 * v38 + 4) = (float)(v29 + *(float *)(v31 + 8 * v38 + 4)) * 0.025;
            }
            else
            {
              v13 = mfs_CostList_Pad((uint64_t)a2, a12, a13, v25, *((_QWORD *)a2 + 298), a2[598], v41, v29);
              ++v35;
            }
          }
          v17 = *(_DWORD *)(*(_QWORD *)(a9 + 8) + 32 * a10 + 16) + v35;
        }
      }
      if ((v13 & 0x80000000) != 0)
        break;
      if (v24 >= v15)
        break;
      ++v24;
    }
    while (v17 - a7 < a8);
  }
  mfs_CostList_UpdateCostEnd_inlined(a9, a10);
  return v13;
}

uint64_t mfs_IbAddtoVect_DUR(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, unsigned int a8, uint64_t a9, signed int a10, uint64_t a11, _QWORD *a12, signed int a13, unsigned int a14)
{
  uint64_t v14;
  int *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  BOOL v21;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  unsigned int v29;
  _QWORD *v32;
  float v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int IsNodeInList;
  uint64_t v38;
  int v42;
  int v44;
  unsigned int v45;
  float *v46;
  _QWORD v47[2];
  _DWORD v48[3];

  v14 = 0;
  v15 = (int *)(*(_QWORD *)(*((_QWORD *)a2 + 194) + 8 * a5) + 8 * a6);
  v16 = v15[1];
  v44 = *v15;
  v17 = *(_QWORD *)(a9 + 8) + 32 * a10;
  v38 = *(_QWORD *)v17;
  v18 = a12[1] + 32 * a13;
  v36 = *(_QWORD *)v18;
  v46 = (float *)v47;
  v47[0] = 0;
  v19 = a2[274];
  v48[0] = 0;
  v47[1] = 0;
  v20 = *(_DWORD *)(v18 + 16) + *(_DWORD *)(v17 + 16);
  if ((_DWORD)v16)
    v21 = v20 - a7 >= a8;
  else
    v21 = 1;
  if (!v21)
  {
    v14 = 0;
    v42 = 0;
    v26 = v19 - 1;
    v27 = *((_QWORD *)a2 + 204);
    v28 = 1;
    while (1)
    {
      v29 = *(_DWORD *)(v27 + 4 * (v44 + v28 - 1));
      mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v29, (uint64_t *)&v46);
      if (v29 >= v26)
        goto LABEL_25;
      if (*(_DWORD *)(a3 + 8888) && v20 >= 0xA && *v46 != -999.0 && *v46 <= *(float *)(a3 + 8884))
        goto LABEL_25;
      if (*(unsigned __int8 *)(a11 + 1) == *((unsigned __int8 *)v46 + 13))
      {
        v45 = 0;
        v32 = a12;
        if (mfs_CostList_IsNodeInList(a9, a10, v29, (uint64_t)a2, &v45))
        {
          v33 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v29, a5, *(unsigned __int8 *)(a11 + 1));
          v34 = v45;
          v35 = v38;
        }
        else
        {
          IsNodeInList = mfs_CostList_IsNodeInList((uint64_t)a12, a13, v29, (uint64_t)a2, &v45);
          v33 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v29, a5, *(unsigned __int8 *)(a11 + 1));
          if (!IsNodeInList)
          {
            v14 = mfs_CostList_Pad((uint64_t)a2, a12, a14, v29, *((_QWORD *)a2 + 298), a2[598], v48, v33);
            ++v42;
            goto LABEL_24;
          }
          v34 = v45;
          v35 = v36;
        }
        *(float *)(v35 + 8 * v34 + 4) = (float)(v33 + *(float *)(v35 + 8 * v34 + 4)) * 0.025;
      }
      else
      {
        v32 = a12;
      }
LABEL_24:
      v20 = *(_DWORD *)(*(_QWORD *)(a9 + 8) + 32 * a10 + 16) + v42 + *(_DWORD *)(v32[1] + 32 * a13 + 16);
LABEL_25:
      if ((v14 & 0x80000000) == 0 && v28 < v16)
      {
        ++v28;
        if (v20 - a7 < a8)
          continue;
      }
      break;
    }
  }
  mfs_CostList_UpdateCostEnd_inlined(a9, a10);
  return v14;
}

float mfs_JCostProb(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v12;
  unsigned int v13;
  float v14;
  unsigned int v15;
  float v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  float v32;
  float v33;
  float v34;
  float v35;
  BOOL v36;
  float v37;
  float v38;

  v8 = *(_QWORD *)(a1 + 2152);
  v9 = *(_QWORD *)(a1 + 2136);
  v10 = *(_DWORD *)(a2 + 2064);
  if (v10 == 1)
  {
    v18 = *(_QWORD *)(a2 + 2048);
    v19 = *(_QWORD *)(v18 + 8 * (int)a3);
    if (v19)
    {
      v20 = *(_QWORD *)(v18 + 8 * (int)a4);
      if (v20)
      {
        v14 = 0.0;
        if (!*(_BYTE *)(v19 + 1) && !*(_BYTE *)v20)
          v14 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 8)
              * *(float *)(v8
                         + ((4 * *(unsigned __int8 *)(v19 + 3)) | ((unint64_t)*(unsigned __int8 *)(v20 + 2) << 10)));
        v16 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 4);
        v17 = *(unsigned __int16 *)(v19 + 6) + ((unint64_t)*(unsigned __int16 *)(v20 + 4) << 9);
        return v14 + (float)(v16 * *(float *)(v9 + 4 * v17));
      }
      v28 = *(_QWORD *)(a2 + 1928);
    }
    else
    {
      v28 = *(_QWORD *)(a2 + 1928);
    }
    MFS__log_select_Diag(v28, 3, (uint64_t)"Unexpected NULL JoinElem for UID %d");
    return 0.0;
  }
  else
  {
    if (v10 == 2)
    {
      v12 = *(_QWORD *)(a1 + 12224);
      v13 = *(_DWORD *)(v12 + 12 * (int)a3);
      v14 = 0.0;
      if (v13 <= 0xFF)
      {
        v15 = *(unsigned __int16 *)(v12 + 12 * (int)a4 + 6);
        if (v15 <= 0xFF)
          v14 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 8)
              * *(float *)(v8 + 4 * (v13 + (v15 << 8)));
      }
      v16 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 4);
      v17 = *(unsigned __int16 *)(v12 + 12 * (int)a3 + 4)
          + ((unint64_t)*(unsigned __int16 *)(v12 + 12 * (int)a4 + 8) << 9);
      return v14 + (float)(v16 * *(float *)(v9 + 4 * v17));
    }
    v22 = *(_DWORD *)(a1 + 2164);
    v23 = *(_DWORD *)(a1 + 2148);
    v24 = *(_QWORD *)(a2 + 2032);
    v25 = *(_DWORD *)(a2 + 2060);
    v26 = *(_QWORD *)(v24 + 8 * (v25 & a3));
    if (v26)
    {
      while (*(_DWORD *)v26 != a3)
      {
        v26 = *(_QWORD *)(v26 + 16);
        if (!v26)
          goto LABEL_17;
      }
      v27 = *(_DWORD *)(v26 + 8);
    }
    else
    {
LABEL_17:
      MFS__log_select_Diag(*(_QWORD *)(a2 + 1928), 3, (uint64_t)"Unexpected NULL JoinElem returned for UID %d");
      v27 = 0;
      v24 = *(_QWORD *)(a2 + 2032);
      v25 = *(_DWORD *)(a2 + 2060);
    }
    v29 = *(_QWORD *)(v24 + 8 * (v25 & a4));
    if (v29)
    {
      while (*(_DWORD *)v29 != a4)
      {
        v29 = *(_QWORD *)(v29 + 16);
        if (!v29)
          goto LABEL_23;
      }
      v30 = *(_DWORD *)(v29 + 4);
    }
    else
    {
LABEL_23:
      MFS__log_select_Diag(*(_QWORD *)(a2 + 1928), 3, (uint64_t)"Unexpected NULL JoinElem returned for UID %d");
      v30 = 0;
    }
    v31 = *(_QWORD *)(a1 + 1072);
    if (!*(_DWORD *)(v31 + 8392) && ((v27 | v30) & 2) != 0)
    {
      v36 = *(_DWORD *)(v31 + 8892) == 0;
      v35 = 0.0;
    }
    else
    {
      v32 = *(float *)(v8 + 4 * (((v27 >> 14) & 0x1FF) + ((v30 >> 14) & 0x1FF) * v22));
      v33 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 8);
      v34 = v32 * v33;
      v35 = v32 + v33;
      v36 = *(_DWORD *)(v31 + 8892) == 0;
      if (v36)
        v35 = v34;
    }
    v37 = *(float *)(v9 + 4 * (((v27 >> 2) & 0xFFF) + ((v30 >> 2) & 0xFFF) * v23));
    v38 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 2072) + 8 * a5) + 4);
    if (v36)
      return v35 + (float)(v38 * v37);
    else
      return v37 + (float)(v35 + v38);
  }
}

uint64_t mfs_BPESymData_Init_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  int *v11;
  int v12;

  if (*(_DWORD *)(a1 + 8344) != 4)
  {
    v10 = *(_DWORD *)(a2 + 2440);
LABEL_6:
    v9 = 0;
    *(_DWORD *)(a2 + 1928) = v10;
    *(_QWORD *)(a2 + 1904) = *(_QWORD *)(a1 + 23624);
    v11 = *(int **)(a1 + 23864);
    *(_QWORD *)(a2 + 1920) = *(_QWORD *)(a1 + 16904);
    v12 = *v11;
    *(_QWORD *)(a2 + 1912) = v11 + 1;
    *(_BYTE *)(a2 + 1932) = v12;
    *(_DWORD *)(a2 + 1936) = *(_DWORD *)(a1 + 23872);
    return v9;
  }
  v8 = *(_DWORD *)(a2 + 2424);
  if ((v8 & 7) == 0)
  {
    v10 = v8 >> 3;
    goto LABEL_6;
  }
  MFS__log_select_Error(*(_QWORD *)(a2 + 2408), 1, (uint64_t)"%s, only byte-aligned row are supported for BPE of bit-packed symdata", a4, a5, a6, a7, a8);
  return 2229281034;
}

void *mfs_BPESymData_DeInit_Obersee(uint64_t a1)
{
  return cstdlib_memset((void *)(a1 + 1904), 0, 8uLL);
}

uint64_t mfs_BPESymDataCache_Init_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, int, unsigned int, uint64_t);

  v9 = *(_QWORD *)(a2 + 1072);
  if ((*(_DWORD *)(v9 + 8344) - 3) > 1)
  {
    MFS__log_select_Error(a3, 1, (uint64_t)"%s: compression mode %d not supported!", a4, a5, a6, a7, a8);
    return 2229280775;
  }
  else
  {
    v12 = heap_Alloc(*(_QWORD *)(a3 + 8), 24);
    if (v12)
    {
      if (*(_DWORD *)(v9 + 8344) == 3)
        v13 = mfs_symData_recoverFeatVectBPE_Obersee;
      else
        v13 = mfs_symData_recoverFeatVectBPEBitPack_Obersee;
      *(_QWORD *)(v12 + 8) = a2;
      *(_QWORD *)(v12 + 16) = v13;
      return mfs_DataCachePair_Init_Obersee(a1, 0x800u, 0x40u, (uint64_t)mfs_symdata_BPECache_callback, v12, a3);
    }
    else
    {
      return 2229280774;
    }
  }
}

uint64_t mfs_symData_recoverFeatVectBPE_Obersee(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  return mfs_symdata_BPEUncompressRow((uint64_t *)(a1 + 1904), a2, a3, a4);
}

uint64_t mfs_symData_recoverFeatVectBPEBitPack_Obersee(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  unsigned int v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;
  _BYTE v14[256];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v6 = *(unsigned int *)(a1 + 2440);
  result = mfs_symdata_BPEUncompressRow((uint64_t *)(a1 + 1904), a2, a3, (uint64_t)v14);
  if ((result & 0x80000000) == 0 && (_DWORD)v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    do
    {
      v11 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 2416) + v8);
      v12 = (unint64_t)v9 >> 3;
      v13 = v14[v12] << 8;
      if ((v10 + v11) >= 9)
        v13 |= v14[v12 + 1];
      *(_BYTE *)(a4 + v8) = (unsigned __int16)(v13 << v10) >> (16 - v11);
      v9 += v11;
      v10 = v9 & 7;
      ++v8;
    }
    while (v6 != v8);
  }
  return result;
}

uint64_t mfs_symdata_BPECache_callback(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  (*((void (**)(_QWORD, _QWORD, _QWORD, uint64_t))a1 + 2))(*((_QWORD *)a1 + 1), *a1, a1[1], a3);
  return 0;
}

void *mfs_BPESymDataCache_DeInit_Obersee(_QWORD *a1, uint64_t a2)
{
  heap_Free(*(_QWORD **)(a2 + 8), a1[1]);
  return mfs_DataCachePair_DeInit_Obersee(a1, a2);
}

uint64_t mfs_symData_recoverCompactFeatVect_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *__dst, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unsigned int *v9;
  char v10;
  unsigned int v11;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  int v19;
  unint64_t v20;
  int v21;

  v8 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8344);
  if ((v8 - 3) >= 2)
  {
    if (v8 == 1)
    {
      v13 = *(unsigned int *)(a1 + 2440);
      if ((_DWORD)v13)
      {
        v14 = 0;
        v15 = *(_DWORD *)(a1 + 2424) * a4;
        v16 = *(_QWORD *)(a1 + 2432) + (v15 >> 3);
        v17 = v15 & 7;
        do
        {
          v18 = v15 & 7;
          v19 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 2416) + v14);
          v20 = (unint64_t)v17 >> 3;
          v21 = *(unsigned __int8 *)(v16 + v20) << 8;
          if ((v18 + v19) >= 9)
            v21 |= *(unsigned __int8 *)(v16 + v20 + 1);
          __dst[v14] = (unsigned __int16)(v21 << v18) >> (16 - v19);
          v15 = v17 + v19;
          ++v14;
          v17 = v15;
        }
        while (v13 != v14);
      }
      return 0;
    }
    else
    {
      MFS__log_select_Error(a2, 1, (uint64_t)"%s: compression mode %d not supported!", a4, (uint64_t)__dst, a6, a7, a8);
      return 2229280775;
    }
  }
  else
  {
    v9 = *(unsigned int **)(a3 + 8);
    v10 = *(_BYTE *)(a1 + 1932);
    v11 = ((0xFFFFFFFF >> -v10) & a4) + *(_DWORD *)(*(_QWORD *)(a1 + 1912) + 4 * (a4 >> v10));
    *v9 = a4 >> v10;
    v9[1] = v11;
    return mfs_DataCachePair_ReadAndWrite_Obersee(a3, v11, __dst);
  }
}

uint64_t mfs_symData_recoverCompactNFeatVect_Obersee(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  unint64_t v18;
  int v19;
  uint64_t result;
  char v21;
  int v22;
  int v23;
  uint64_t *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned __int8 *v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  int v34;
  unint64_t v35;
  int v36;
  _BYTE v37[256];
  uint64_t v38;

  v9 = a4;
  v38 = *MEMORY[0x24BDAC8D0];
  v11 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8344);
  switch(v11)
  {
    case 4:
      v21 = *(_BYTE *)(a1 + 1932);
      v22 = a3 >> v21;
      v23 = *(_DWORD *)(*(_QWORD *)(a1 + 1912) + 4 * (a3 >> v21));
      v24 = (uint64_t *)(a1 + 1904);
      v25 = ((0xFFFFFFFF >> -v21) & a3) + v23;
      v26 = 0;
      if ((_DWORD)a4)
      {
        v27 = *(unsigned __int8 **)(a1 + 2416);
        v28 = a4;
        do
        {
          v29 = *v27++;
          v26 += v29;
          --v28;
        }
        while (v28);
      }
      if ((v26 & 7) != 0)
        v30 = (v26 >> 3) + 1;
      else
        v30 = v26 >> 3;
      result = mfs_symdata_BPEUncompressNBytes(v24, v22, v25, v30, (uint64_t)v37);
      if (v9 && (result & 0x80000000) == 0)
      {
        v31 = 0;
        v32 = 0;
        v33 = 0;
        do
        {
          v34 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 2416) + v31);
          v35 = (unint64_t)v32 >> 3;
          v36 = v37[v35] << 8;
          if ((v33 + v34) >= 9)
            v36 |= v37[v35 + 1];
          *(_BYTE *)(a5 + v31) = (unsigned __int16)(v36 << v33) >> (16 - v34);
          v32 += v34;
          v33 = v32 & 7;
          ++v31;
        }
        while (v9 != v31);
      }
      break;
    case 3:
      return mfs_symdata_BPEUncompressNBytes((uint64_t *)(a1 + 1904), a3 >> *(_BYTE *)(a1 + 1932), ((0xFFFFFFFF >> -*(_BYTE *)(a1 + 1932)) & a3)+ *(_DWORD *)(*(_QWORD *)(a1 + 1912) + 4 * (a3 >> *(_BYTE *)(a1 + 1932))), a4, a5);
    case 1:
      if ((_DWORD)a4)
      {
        v12 = 0;
        v13 = *(_DWORD *)(a1 + 2424) * a3;
        v14 = *(_QWORD *)(a1 + 2432) + (v13 >> 3);
        v15 = v13 & 7;
        do
        {
          v16 = v13 & 7;
          v17 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 2416) + v12);
          v18 = (unint64_t)v15 >> 3;
          v19 = *(unsigned __int8 *)(v14 + v18) << 8;
          if ((v16 + v17) >= 9)
            v19 |= *(unsigned __int8 *)(v14 + v18 + 1);
          *(_BYTE *)(a5 + v12) = (unsigned __int16)(v19 << v16) >> (16 - v17);
          v13 = v15 + v17;
          ++v12;
          v15 = v13;
        }
        while (a4 != v12);
      }
      return 0;
    default:
      MFS__log_select_Error(a2, 1, (uint64_t)"%s, compression mode %d not supported!", a4, a5, a6, a7, a8);
      return 2229280775;
  }
  return result;
}

void mfs_symData_DistanceOnUid_PreCalcVitSymRulesForTargetVector_Obersee(uint64_t a1, int a2, unsigned int a3, unsigned __int8 *a4, unsigned __int8 *a5, _QWORD *a6)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t *v10;
  uint64_t v11;

  v6 = *(unsigned int *)(a1 + 2440);
  v7 = *(_QWORD *)(a1 + 2400);
  if (v7 && a5[v6] > a3)
  {
    if ((_DWORD)v6)
    {
      v8 = v6 * (a2 - 1);
      v9 = v6 * (a2 + 4 * a3 - 1);
      v10 = *(uint64_t **)(a1 + 2400);
      do
      {
        v11 = *(_QWORD *)(v7 + 8 * v9);
        if (v11 || (v11 = *(_QWORD *)(v7 + 8 * v8)) != 0 || (v11 = *v10) != 0)
        {
          if (*a4 >= *a5)
            v11 = 0;
          else
            v11 += 2 * *a5 * (unint64_t)*a4;
        }
        *a6++ = v11;
        ++v10;
        ++a4;
        ++a5;
        ++v8;
        ++v9;
        --v6;
      }
      while (v6);
    }
  }
  else if ((_DWORD)v6)
  {
    bzero(a6, 8 * v6);
  }
}

float mfs_symData_DistanceOnUid_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  float v12;
  uint64_t v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE __dst[256];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v11 = *(unsigned int *)(a1 + 2440);
  mfs_symData_recoverCompactFeatVect_Obersee(a1, a2, a7, a4, __dst, a6, a7, a8);
  if ((_DWORD)v11)
  {
    v13 = 0;
    v14 = 0.0;
    while (1)
    {
      v15 = __dst[v13];
      if (*(unsigned __int8 *)(a3 + 4 + v13) != (_DWORD)v15)
      {
        v16 = *(_QWORD *)(a6 + 8 * v13);
        if (!v16)
        {
          v17 = *(_QWORD *)(a3 + 184);
LABEL_8:
          v12 = *(float *)(v17 + 4 * v13);
          v14 = v14 + (float)(v12 * 10.0);
          goto LABEL_9;
        }
        v17 = *(_QWORD *)(a3 + 184);
        if (v15 >= *(unsigned __int8 *)(a5 + v13))
          goto LABEL_8;
        LOWORD(v12) = *(_WORD *)(v16 + 2 * v15);
        v12 = (float)LODWORD(v12);
        v14 = v14 + (float)(v12 * *(float *)(v17 + 4 * v13));
      }
LABEL_9:
      if (v11 == ++v13)
        return v14 / 10.0;
    }
  }
  v14 = 0.0;
  return v14 / 10.0;
}

uint64_t mfs_symdata_BPEUncompressRow(uint64_t *a1, int a2, unsigned int a3, uint64_t a4)
{
  _BYTE *v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  int v16;
  char *v17;
  uint64_t result;
  _OWORD v19[16];
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v4 = (_BYTE *)(a1[2] + a3);
  v5 = *a1;
  v20 = 0;
  memset(v19, 0, sizeof(v19));
  v6 = *((_DWORD *)a1 + 6);
  v7 = v6 - 1;
  if (v6 == 1)
  {
    result = 0;
    v8 = 0;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = v5 + (a2 << 9);
    do
    {
      v12 = v10 - 1;
      v13 = &v4[v9];
      if (v10)
      {
        v14 = (unsigned __int8 *)v19 + v12;
      }
      else
      {
        LODWORD(v12) = 0;
        ++v9;
        v14 = v13;
      }
      v15 = *v14;
      v16 = *(unsigned __int8 *)(v11 + v15);
      if ((_DWORD)v15 == v16)
      {
        *(_BYTE *)(a4 + v8++) = v15;
        v10 = v12;
      }
      else
      {
        v17 = (char *)v19 + v12;
        *v17 = *(_BYTE *)(v11 + 256 + v15);
        v10 = v12 + 2;
        v17[1] = v16;
      }
    }
    while (v10 <= 0xFF && v8 < v7);
    if (v10 >= 0x101)
      result = 2229281034;
    else
      result = 0;
    if (v10)
      v4 = (char *)v19 + v10 - 1;
    else
      v4 += v9;
  }
  *(_BYTE *)(a4 + v8) = *v4;
  return result;
}

uint64_t mfs_symdata_BPEUncompressNBytes(uint64_t *a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  int v16;
  char *v17;
  _OWORD v19[16];
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v5 = a1[2];
  v6 = *a1;
  v20 = 0;
  memset(v19, 0, sizeof(v19));
  if (!a4)
    return 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = v5 + a3;
  v11 = v6 + (a2 << 9);
  do
  {
    v12 = v9 - 1;
    v13 = (unsigned __int8 *)(v10 + v8);
    if (v9)
    {
      v14 = (unsigned __int8 *)v19 + v12;
    }
    else
    {
      LODWORD(v12) = 0;
      ++v8;
      v14 = v13;
    }
    v15 = *v14;
    v16 = *(unsigned __int8 *)(v11 + v15);
    if ((_DWORD)v15 == v16)
    {
      *(_BYTE *)(a5 + v7++) = v15;
      v9 = v12;
    }
    else
    {
      v17 = (char *)v19 + v12;
      *v17 = *(_BYTE *)(v11 + 256 + v15);
      v9 = v12 + 2;
      v17[1] = v16;
    }
  }
  while (v9 <= 0xFF && v7 < a4);
  if (v9 >= 0x100)
    return 2229281034;
  else
    return 0;
}

uint64_t mfs_CostList_QSelect(uint64_t a1, int a2, int a3, uint64_t (*a4)(char *, char *), unsigned int a5)
{
  unsigned int v6;
  unsigned int v9;
  char *v10;
  int v11;
  char *v12;
  char *v13;
  char v14;
  unsigned int v15;
  uint64_t v16;
  char *v17;
  char *v18;
  int v19;
  char v20;
  char *v21;
  int v22;
  char v23;
  uint64_t v25;
  char *v26;
  unsigned int v28;

  v25 = a5 * a3;
  v6 = a2 - 1;
  if (a2 != 1)
  {
    v9 = 0;
    v28 = 0;
    v26 = (char *)(a1 + v25);
    do
    {
      v10 = (char *)(a1 + v6 * a3);
      if (a3)
      {
        v11 = a3;
        v12 = (char *)(a1 + v6 * a3);
        v13 = v26;
        do
        {
          v14 = *v13;
          *v13++ = *v12;
          *v12++ = v14;
          --v11;
        }
        while (v11);
      }
      v15 = v9;
      if (v9 < v6)
      {
        v16 = v9;
        v15 = v9;
        do
        {
          v17 = (char *)(a1 + (v16 * a3));
          if ((a4(v17, v10) & 0x80000000) != 0)
          {
            if (a3)
            {
              v18 = (char *)(a1 + v15 * a3);
              v19 = a3;
              do
              {
                v20 = *v17;
                *v17++ = *v18;
                *v18++ = v20;
                --v19;
              }
              while (v19);
            }
            ++v15;
          }
          ++v16;
        }
        while (v16 != v6);
      }
      if (a3)
      {
        v21 = (char *)(a1 + v15 * a3);
        v22 = a3;
        do
        {
          v23 = *v10;
          *v10++ = *v21;
          *v21++ = v23;
          --v22;
        }
        while (v22);
      }
      if (v15 == a5)
        break;
      if (v15 >= a5)
        v6 = v15 - 1;
      else
        v9 = v15 + 1;
      ++v28;
    }
    while (v28 < v6);
  }
  return a1 + v25;
}

char *mfs_SwapItem(char *result, char *a2, int a3)
{
  char v3;

  for (; a3; --a3)
  {
    v3 = *result;
    *result++ = *a2;
    *a2++ = v3;
  }
  return result;
}

uint64_t mfs_Viterbi_Init_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v10 = 2229280778;
  cstdlib_memset((void *)a1, 0, 0x308uLL);
  *(_QWORD *)(a1 + 712) = 0;
  *(_QWORD *)a1 = a2;
  fastallo_Init((_WORD *)(a1 + 24), *(_QWORD *)(a2 + 8), 4096);
  *(_QWORD *)(a1 + 8) = a4;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 760) = a5;
  *(_QWORD *)(a1 + 604) = 0;
  *(_QWORD *)(a1 + 612) = 0;
  *(_QWORD *)(a1 + 596) = 0;
  *(_DWORD *)(a1 + 720) = 1065353216;
  v11 = *(_QWORD *)(a3 + 1072);
  *(float *)(a1 + 724) = *(float *)(v11 + 8384) + 1.0;
  *(float *)(a1 + 728) = *(float *)(v11 + 8384) + 1.0;
  *(_DWORD *)(a1 + 732) = 0;
  *(_DWORD *)(a1 + 736) = *(_DWORD *)(v11 + 8384);
  *(_DWORD *)(a1 + 740) = *(_DWORD *)(v11 + 8384);
  *(_DWORD *)(a1 + 744) = 1065353216;
  *(float *)(a1 + 748) = *(float *)(v11 + 8384) + 1.0;
  *(float *)(a1 + 752) = *(float *)(v11 + 8384) + 1.0;
  v12 = *(unsigned int *)(v11 + 8240);
  v13 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 32 * v12);
  *(_QWORD *)(a1 + 624) = v13;
  if (v13)
  {
    v14 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 32 * v12);
    *(_QWORD *)(a1 + 632) = v14;
    if (v14)
    {
      *(_DWORD *)(a1 + 660) = v12;
      *(_DWORD *)(a1 + 680) = v12;
      v15 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * v12);
      *(_QWORD *)(a1 + 672) = v15;
      if (v15)
      {
        v16 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), *(unsigned int *)(a1 + 680));
        *(_QWORD *)(a1 + 704) = v16;
        if (v16)
        {
          v17 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * *(unsigned int *)(a1 + 680));
          *(_QWORD *)(a1 + 688) = v17;
          if (v17)
          {
            v18 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 4 * *(unsigned int *)(a1 + 680));
            *(_QWORD *)(a1 + 696) = v18;
            if (v18)
            {
              v19 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 2 * *(unsigned int *)(a1 + 680));
              *(_QWORD *)(a1 + 640) = v19;
              if (v19)
              {
                *(_WORD *)(a1 + 592) = 200;
                v20 = heap_Alloc(*(_QWORD *)(*(_QWORD *)a1 + 8), 400);
                *(_QWORD *)(a1 + 584) = v20;
                if (v20)
                {
                  MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"S8_X2B Viterbi Decoder Variant 2 has been selected\n");
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return v10;
}

uint64_t mfs_Viterbi_Reset_Obersee(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 596) = a2;
  *(_DWORD *)(a1 + 612) = a2;
  *(_DWORD *)(a1 + 616) = 0;
  *(_DWORD *)(a1 + 648) = 0;
  *(_QWORD *)(a1 + 600) = 0;
  *(_DWORD *)(a1 + 608) = 0;
  MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi regular search and emission, from=%d to=?\n");
  return 0;
}

uint64_t mfs_Viterbi_DeInit_Obersee(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*(_QWORD *)(a1 + 8))
  {
    fastallo_Terminate((_QWORD *)(a1 + 24));
    v2 = *(_QWORD *)(a1 + 624);
    if (v2)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v2);
      *(_QWORD *)(a1 + 624) = 0;
    }
    v3 = *(_QWORD *)(a1 + 632);
    if (v3)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v3);
      *(_QWORD *)(a1 + 632) = 0;
    }
    *(_DWORD *)(a1 + 680) = 0;
    v4 = *(_QWORD *)(a1 + 672);
    if (v4)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v4);
      *(_QWORD *)(a1 + 672) = 0;
    }
    v5 = *(_QWORD *)(a1 + 704);
    if (v5)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v5);
      *(_QWORD *)(a1 + 704) = 0;
    }
    v6 = *(_QWORD *)(a1 + 688);
    if (v6)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v6);
      *(_QWORD *)(a1 + 688) = 0;
    }
    v7 = *(_QWORD *)(a1 + 696);
    if (v7)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v7);
      *(_QWORD *)(a1 + 696) = 0;
    }
    v8 = *(_QWORD *)(a1 + 640);
    if (v8)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v8);
      *(_QWORD *)(a1 + 640) = 0;
    }
    v9 = *(_QWORD *)(a1 + 584);
    if (v9)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v9);
      *(_QWORD *)(a1 + 584) = 0;
      *(_WORD *)(a1 + 592) = 0;
    }
    *(_QWORD *)(a1 + 8) = 0;
  }
  return 0;
}

uint64_t mfs_Viterbi_DumpHeapStats(uint64_t *a1)
{
  int v2;
  int UsedMemory;

  v2 = 79 * *(_DWORD *)(*(_QWORD *)(a1[2] + 1072) + 8240);
  MFS__log_select_Diag(*a1, 9, (uint64_t)"memstats:viterbi mem usage: %d bytes (prev&cur timeslice+unitid+bSLL+joinENDLF0+MCP)\n");
  UsedMemory = fastallo_GetUsedMemory((uint64_t)(a1 + 3));
  MFS__log_select_Diag(*a1, 9, (uint64_t)"memstats:viterbi backtrace mem usage: %d bytes from %d entries (%d states,%d bytes overhead)\n");
  return (UsedMemory + v2);
}

uint64_t mfs_Viterbi_FillPrevStateCacheTables(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*(_DWORD *)(result + 656))
  {
    v2 = 0;
    v3 = *(_QWORD *)(a2 + 32);
    do
    {
      v4 = v3 + 24 * *(unsigned __int16 *)(*(_QWORD *)(result + 640) + 2 * v2);
      *(_DWORD *)(*(_QWORD *)(result + 672) + 4 * v2) = *(_DWORD *)(v4 + 4);
      v5 = *(_QWORD *)(v4 + 16);
      *(_DWORD *)(*(_QWORD *)(result + 688) + 4 * v2) = *(_DWORD *)(v5 + 12);
      *(_DWORD *)(*(_QWORD *)(result + 696) + 4 * v2) = *(unsigned __int16 *)(v5 + 16);
      *(_BYTE *)(*(_QWORD *)(result + 704) + v2++) = *(_BYTE *)(v5 + 28);
    }
    while (v2 < *(unsigned int *)(result + 656));
  }
  return result;
}

uint64_t mfs_Viterbi_DecodeState_MCP_S9_LF0_S8_X2B_Obersee(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  unsigned __int8 *v8;
  float v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned __int16 v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  unint64_t v26;
  float v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unsigned __int16 *v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  uint64_t v36;
  float v37;
  float v38;
  float *v39;
  float v40;
  float v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  unsigned int v46;
  unint64_t v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  float v52;
  float v53;
  float v54;
  float v55;
  uint64_t v56;
  float v57;
  float v58;
  int *v59;
  int v60;
  unsigned int *v61;
  unsigned int *v62;
  int v63;
  unint64_t v64;
  uint64_t v65;
  float v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  float v70;
  unsigned int *v71;
  unsigned __int16 *v72;
  unsigned int *v73;
  uint64_t v74;
  _DWORD *v75;
  unsigned __int8 *v76;
  uint64_t v77;
  unsigned int v78;
  float v79;
  unsigned int v80;
  float v81;
  unsigned int v82;
  float v83;
  float v84;
  int v85;
  unsigned int v86;
  unsigned int *v87;
  unsigned __int16 *v88;
  unsigned int *v89;
  uint64_t v90;
  _DWORD *v91;
  unsigned __int8 *v92;
  uint64_t v93;
  unsigned int v94;
  float v95;
  unsigned int v96;
  float v97;
  unsigned int v98;
  float v99;
  float v100;
  float *v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  unsigned int v109;
  uint64_t v110;
  int v111;
  float v112;
  uint64_t v113;
  uint64_t v114;
  float v115;
  float v116;
  int v117;
  uint64_t v118;
  float v119;
  float v120;
  int v121;
  uint64_t v122;
  float v123;
  float v124;
  int v125;
  uint64_t v126;
  uint64_t v127;
  float v128;
  float v129;
  float v130;
  int v131;
  unsigned int *v132;
  unsigned __int16 *v133;
  unsigned int *v134;
  uint64_t v135;
  int *v136;
  unsigned __int8 *v137;
  unsigned int v138;
  unsigned int v139;
  float v140;
  unsigned int v141;
  float v142;
  unsigned int v143;
  float v144;
  unsigned int v145;
  float v146;
  int v147;
  float v148;
  unsigned int v149;
  uint64_t v150;
  uint64_t v151;
  float *v152;
  float v153;
  float v154;
  float v155;
  float v156;
  float v157;
  float v158;
  float v159;
  float v160;
  float v161;
  float *v162;
  float v163;
  float v164;
  float v165;
  float v166;
  float v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float *v172;
  float v173;
  float v174;
  float v175;
  float v176;
  float v177;
  float v178;
  float v179;
  float v180;
  float v181;
  uint64_t v182;
  uint64_t v183;
  float v184;
  float v185;
  float v186;
  float *v187;
  float v188;
  float v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  unsigned __int16 *v195;
  float v196;
  uint64_t v197;
  _DWORD *v198;
  unsigned __int16 *v199;
  unsigned int v200;
  unsigned int v201;
  unsigned int v202;
  uint64_t v203;
  unsigned int v204;
  float v205;
  float v206;
  float v207;
  unsigned int v208;
  float v209;
  float v210;
  uint64_t v211;
  float v212;
  float v213;
  float v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t MemoryFromChunk;
  float v221;
  uint64_t v222;
  int v223;
  uint64_t v224;
  float v225;
  uint64_t v226;
  __int16 v227;
  BOOL v228;
  int v229;
  unint64_t v230;
  int v231;
  int v232;
  _QWORD *v233;
  uint64_t v234;
  __int16 v235;
  _DWORD *v236;
  unint64_t v237;
  uint64_t v238;
  int *v239;
  int v240;
  uint64_t v242;
  int v243;
  int v244;
  unsigned int v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  float v249;
  float v250;
  uint64_t v251;
  int v252;
  uint64_t v253;
  int v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  _QWORD v258[2];

  v2 = a2;
  v258[0] = 0;
  v4 = *(_QWORD **)(a1 + 16);
  v5 = v4[134];
  v6 = a1 + 24;
  v7 = *(_DWORD **)(a1 + 672);
  v8 = *(unsigned __int8 **)(a1 + 704);
  v9 = *(float *)(v5 + 8388);
  v10 = *(float *)(v5 + 8172);
  v255 = v4[267];
  v256 = v4[269];
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 2072);
  v12 = *(_QWORD *)(a2 + 32);
  v13 = -1431655765 * ((unint64_t)(*(_QWORD *)(a2 + 40) - v12) >> 3);
  v14 = *(_DWORD *)(a1 + 616);
  if (v14)
  {
    v15 = *(_DWORD *)(v5 + 8564);
    v16 = *(_DWORD *)(a1 + 612) + v14;
    v253 = *(_QWORD *)(a2 + 32);
    if (v15)
    {
      v17 = v16 + ~*(_DWORD *)(a1 + 596);
      v18 = *(unsigned __int16 *)(a1 + 592);
      if (v17 >= v18)
      {
        v19 = v18 + 100;
        *(_WORD *)(a1 + 592) = v19;
        v243 = v15;
        v21 = v11;
        v22 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 584), 2 * v19);
        v11 = v21;
        v2 = a2;
        v15 = v243;
        *(_QWORD *)(a1 + 584) = v22;
        if (!v22)
          return 10;
      }
    }
    else
    {
      v17 = 0;
    }
    *(_WORD *)(*(_QWORD *)(a1 + 584) + 2 * v17) = 0;
    v34 = 0.0;
    v35 = 0.0;
    if (*(_DWORD *)(v5 + 8264))
      v35 = *(float *)(v2 + 64);
    v246 = v6;
    v247 = v17;
    if (*(_DWORD *)(v5 + 8268))
    {
      v252 = *(_DWORD *)(v2 + 68);
      v34 = (float)*(int *)(v2 + 72);
    }
    else
    {
      v252 = 0;
    }
    v36 = *(_QWORD *)(a1 + 8);
    v37 = *(float *)(*(_QWORD *)(v36 + 2088) + 4 * v16);
    v38 = *(float *)(*(_QWORD *)(v36 + 2096) + 4 * v16);
    v39 = *(float **)(v11 + 8 * v16);
    v40 = v37 * *v39;
    v41 = v37 * v39[2];
    v42 = v37 * v39[1];
    MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Join cost %d\n");
    MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Normalized ADJ weight %f\n");
    MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Normalized LF0 weight %f\n");
    MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Normalized MCP weight %f\n");
    v43 = *(_QWORD *)(a1 + 624);
    v44 = *(_QWORD *)(a1 + 632);
    *(_QWORD *)(a1 + 624) = v44;
    *(_QWORD *)(a1 + 632) = v43;
    v45 = *(_DWORD *)(a1 + 656);
    *(_DWORD *)(a1 + 652) = v45;
    v46 = *(_DWORD *)(v2 + 60);
    if (v46 >= v13)
      v46 = v13;
    *(_DWORD *)(a1 + 656) = v46;
    if (v46)
    {
      v244 = v15;
      v242 = v2;
      v47 = 0;
      v254 = 0;
      v48 = 0;
      v49 = a1 + 744;
      v50 = v45 & 3;
      v51 = v252;
      v52 = v38;
      v53 = (float)v252;
      v245 = v16 % 3;
      v248 = 4 * ((v45 & 3) - 1) + 4;
      HIWORD(v54) = 19224;
      v55 = 10000000.0;
      v56 = v253;
      v251 = v43;
      v250 = v52;
      v249 = v35;
      do
      {
        LODWORD(v258[0]) = 0;
        v57 = 0.0;
        v257 = v47;
        if (v35 != 0.0)
        {
          v58 = v55;
          mfs_getBeginEndPitch_Obersee(*(_QWORD *)(a1 + 16), *(_QWORD *)(v56 + 24 * v47 + 16), (float *)v258, 0);
          v47 = v257;
          v55 = v58;
          v35 = v249;
          v50 = v45 & 3;
          v52 = v250;
          v51 = v252;
          v43 = v251;
          v56 = v253;
          HIWORD(v54) = WORD1(v258[0]);
          if (*(float *)v258 >= 0.0)
            v57 = *(float *)v258;
          else
            v57 = 0.0;
          *(float *)v258 = v57;
        }
        v59 = *(int **)(v56 + 24 * v47 + 16);
        if (*(_DWORD *)(v5 + 8268))
          v60 = *((unsigned __int8 *)v59 + 27);
        else
          v60 = 0;
        v61 = *(unsigned int **)(a1 + 688);
        v62 = *(unsigned int **)(a1 + 696);
        LOWORD(v54) = *(_WORD *)(v56 + 24 * v47 + 8);
        v63 = *v59;
        v64 = *((unsigned __int8 *)v59 + 28);
        if (v64 <= 2)
        {
          v65 = 4 * v64;
          do
          {
            *(float *)(v49 + v65) = (float)(v9 * *(float *)(v49 + v65 - 12)) + (float)(v40 * *(float *)(v49 + v65 - 24));
            v65 += 4;
          }
          while (v65 != 12);
        }
        v66 = (float)((float)(1.0 - v37) * (float)LODWORD(v54)) / 100.0;
        v67 = v49 + 4 * v64;
        v68 = v255 + ((unint64_t)*((unsigned __int16 *)v59 + 10) << 11);
        v69 = v256 + ((unint64_t)*((unsigned __int16 *)v59 + 9) << 10);
        v70 = 10000000.0 - v66;
        if (v51)
        {
          if ((_DWORD)v50)
          {
            v71 = (unsigned int *)((char *)v61 + v248);
            v72 = *(unsigned __int16 **)(a1 + 640);
            v73 = (unsigned int *)((char *)v62 + v248);
            v74 = v50;
            v75 = v7;
            v76 = v8;
            while (1)
            {
              v78 = *v72++;
              v77 = v78;
              v79 = *(float *)(v44 + 32 * v78);
              if (v79 > v70)
                break;
              v80 = *v61++;
              v81 = *(float *)(v67 + 4 * *v76) + (float)(v41 * *(float *)(v69 + 4 * v80));
              v82 = *v62++;
              v83 = v81 + (float)(v42 * *(float *)(v68 + 4 * v82));
              if (v63 == *v75)
                v83 = 0.0;
              v84 = v79 + v83;
              v85 = v60 - v51 + *(__int16 *)(v44 + 32 * v77 + 16);
              if (v85 < 0)
                v85 = -v85;
              if ((float)(*(float *)(v5 + 8308) * v34) <= (float)v85)
                v84 = v84 + (float)((float)(*(float *)(v5 + 8312) * (float)v85) / v53);
              if (v84 < v70)
              {
                v70 = v84;
                v48 = v77;
              }
              ++v76;
              ++v75;
              if (!--v74)
              {
                v62 = v73;
                v61 = v71;
                v86 = v50;
                goto LABEL_78;
              }
            }
          }
          else
          {
            v86 = 0;
LABEL_78:
            if (v86 < v45)
            {
              v110 = *(_QWORD *)(a1 + 640);
              v111 = v60 - v51;
              v112 = *(float *)(v5 + 8308) * v34;
              do
              {
                v113 = *(unsigned __int16 *)(v110 + 2 * v86);
                v114 = v44 + 32 * v113;
                v115 = (float)(*(float *)(v67 + 4 * v8[v86]) + (float)(v41 * *(float *)(v69 + 4 * *v61)))
                     + (float)(v42 * *(float *)(v68 + 4 * *v62));
                if (v63 == v7[v86])
                  v115 = 0.0;
                v116 = *(float *)v114 + v115;
                v117 = v111 + *(__int16 *)(v114 + 16);
                if (v117 < 0)
                  v117 = -v117;
                if (v112 <= (float)v117)
                  v116 = v116 + (float)((float)(*(float *)(v5 + 8312) * (float)v117) / v53);
                if (v116 >= v70)
                  LODWORD(v113) = v48;
                else
                  v70 = v116;
                v118 = v44 + 32 * *(unsigned __int16 *)(v110 + 2 * (v86 + 1));
                v119 = (float)(*(float *)(v67 + 4 * v8[v86 + 1]) + (float)(v41 * *(float *)(v69 + 4 * v61[1])))
                     + (float)(v42 * *(float *)(v68 + 4 * v62[1]));
                if (v63 == v7[v86 + 1])
                  v119 = 0.0;
                v120 = *(float *)v118 + v119;
                v121 = v111 + *(__int16 *)(v118 + 16);
                if (v121 < 0)
                  v121 = -v121;
                if (v112 <= (float)v121)
                  v120 = v120 + (float)((float)(*(float *)(v5 + 8312) * (float)v121) / v53);
                if (v120 < v70)
                {
                  v70 = v120;
                  LODWORD(v113) = *(unsigned __int16 *)(v110 + 2 * (v86 + 1));
                }
                v122 = v44 + 32 * *(unsigned __int16 *)(v110 + 2 * (v86 + 2));
                v123 = (float)(*(float *)(v67 + 4 * v8[v86 + 2]) + (float)(v41 * *(float *)(v69 + 4 * v61[2])))
                     + (float)(v42 * *(float *)(v68 + 4 * v62[2]));
                if (v63 == v7[v86 + 2])
                  v123 = 0.0;
                v124 = *(float *)v122 + v123;
                v125 = v111 + *(__int16 *)(v122 + 16);
                if (v125 < 0)
                  v125 = -v125;
                if (v112 <= (float)v125)
                  v124 = v124 + (float)((float)(*(float *)(v5 + 8312) * (float)v125) / v53);
                if (v124 >= v70)
                {
                  v48 = v113;
                }
                else
                {
                  v70 = v124;
                  v48 = *(unsigned __int16 *)(v110 + 2 * (v86 + 2));
                }
                v126 = v86 + 3;
                v127 = *(unsigned __int16 *)(v110 + 2 * v126);
                v128 = *(float *)(v44 + 32 * v127);
                if (v128 > v70)
                  break;
                v129 = (float)(*(float *)(v67 + 4 * v8[v126]) + (float)(v41 * *(float *)(v69 + 4 * v61[3])))
                     + (float)(v42 * *(float *)(v68 + 4 * v62[3]));
                if (v63 == v7[v126])
                  v129 = 0.0;
                v130 = v128 + v129;
                v131 = v111 + *(__int16 *)(v44 + 32 * v127 + 16);
                if (v131 < 0)
                  v131 = -v131;
                if (v112 <= (float)v131)
                  v130 = v130 + (float)((float)(*(float *)(v5 + 8312) * (float)v131) / v53);
                if (v130 < v70)
                {
                  v70 = v130;
                  v48 = v127;
                }
                v86 += 4;
                v61 += 4;
                v62 += 4;
              }
              while (v86 < v45);
            }
          }
        }
        else if (v57 == 0.0)
        {
          if (v245)
          {
            if ((_DWORD)v50)
            {
              v132 = (unsigned int *)((char *)v61 + v248);
              v133 = *(unsigned __int16 **)(a1 + 640);
              v134 = (unsigned int *)((char *)v62 + v248);
              v135 = v50;
              v136 = v7;
              v137 = v8;
              while (1)
              {
                v139 = *v133++;
                v138 = v139;
                v140 = *(float *)(v44 + 32 * v139);
                if (v140 > v70)
                  break;
                v141 = *v137++;
                v142 = *(float *)(v67 + 4 * v141);
                v143 = *v61++;
                v144 = v142 + (float)(v41 * *(float *)(v69 + 4 * v143));
                v145 = *v62++;
                v146 = v144 + (float)(v42 * *(float *)(v68 + 4 * v145));
                v147 = *v136++;
                if (v63 == v147)
                  v146 = 0.0;
                v148 = v140 + v146;
                if (v148 < v70)
                {
                  v70 = v148;
                  v48 = v138;
                }
                if (!--v135)
                {
                  v62 = v134;
                  v61 = v132;
                  v149 = v50;
                  goto LABEL_223;
                }
              }
            }
            else
            {
              v149 = 0;
LABEL_223:
              if (v149 < v45)
              {
                v203 = *(_QWORD *)(a1 + 640);
                do
                {
                  v204 = *(unsigned __int16 *)(v203 + 2 * v149);
                  v205 = (float)(*(float *)(v67 + 4 * v8[v149]) + (float)(v41 * *(float *)(v69 + 4 * *v61)))
                       + (float)(v42 * *(float *)(v68 + 4 * *v62));
                  if (v63 == v7[v149])
                    v205 = 0.0;
                  if ((float)(*(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * v149)) + v205) < v70)
                    v70 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * v149)) + v205;
                  else
                    v204 = v48;
                  v206 = (float)(*(float *)(v67 + 4 * v8[v149 + 1]) + (float)(v41 * *(float *)(v69 + 4 * v61[1])))
                       + (float)(v42 * *(float *)(v68 + 4 * v62[1]));
                  if (v63 == v7[v149 + 1])
                    v206 = 0.0;
                  v207 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * (v149 + 1))) + v206;
                  v208 = v149 + 2;
                  if (v207 < v70)
                  {
                    v70 = v207;
                    v204 = *(unsigned __int16 *)(v203 + 2 * (v149 + 1));
                  }
                  v209 = (float)(*(float *)(v67 + 4 * v8[v208]) + (float)(v41 * *(float *)(v69 + 4 * v61[2])))
                       + (float)(v42 * *(float *)(v68 + 4 * v62[2]));
                  if (v63 == v7[v208])
                    v209 = 0.0;
                  v210 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * (v149 + 2))) + v209;
                  if (v210 >= v70)
                  {
                    v48 = v204;
                  }
                  else
                  {
                    v70 = v210;
                    v48 = *(unsigned __int16 *)(v203 + 2 * (v149 + 2));
                  }
                  v211 = v149 + 3;
                  v212 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * v211));
                  if (v212 > v70)
                    break;
                  v213 = (float)(*(float *)(v67 + 4 * v8[v211]) + (float)(v41 * *(float *)(v69 + 4 * v61[3])))
                       + (float)(v42 * *(float *)(v68 + 4 * v62[3]));
                  if (v63 == v7[v211])
                    v213 = 0.0;
                  v214 = v212 + v213;
                  if (v214 < v70)
                  {
                    v70 = v214;
                    v48 = *(unsigned __int16 *)(v203 + 2 * v211);
                  }
                  v149 += 4;
                  v61 += 4;
                  v62 += 4;
                }
                while (v149 < v45);
              }
            }
          }
          else
          {
            v195 = *(unsigned __int16 **)(a1 + 640);
            v48 = *v195;
            v196 = *(float *)(v44 + 32 * *v195) + 4.0;
            if ((_DWORD)v50)
            {
              v197 = v50;
              v198 = v7;
              v199 = *(unsigned __int16 **)(a1 + 640);
              while (1)
              {
                v201 = *v199++;
                v200 = v201;
                v70 = *(float *)(v44 + 32 * v201);
                if (v70 > v196)
                  break;
                if (v63 == *v198)
                {
                  v48 = v200;
                  goto LABEL_259;
                }
                ++v198;
                if (!--v197)
                {
                  v202 = v50;
                  goto LABEL_247;
                }
              }
            }
            else
            {
              v202 = 0;
LABEL_247:
              while (v202 < v45)
              {
                v215 = v202;
                if (v63 == v7[v202])
                  goto LABEL_257;
                v216 = v202 + 1;
                if (v63 == v7[v216] || (v216 = (v215 + 2), v63 == v7[v216]))
                {
                  v215 = v216;
LABEL_257:
                  v48 = v195[v215];
                  v70 = *(float *)(v44 + 32 * v195[v215]);
                  goto LABEL_259;
                }
                v217 = (v215 + 3);
                v70 = *(float *)(v44 + 32 * v195[v217]);
                if (v70 > v196)
                  break;
                if (v63 == v7[v217])
                {
                  v48 = v195[v217];
                  goto LABEL_259;
                }
                v202 = v215 + 4;
              }
            }
            v70 = *(float *)(v44 + 32 * *v195) + 4.0;
          }
        }
        else if ((_DWORD)v50)
        {
          v87 = (unsigned int *)((char *)v61 + v248);
          v88 = *(unsigned __int16 **)(a1 + 640);
          v89 = (unsigned int *)((char *)v62 + v248);
          v90 = v50;
          v91 = v7;
          v92 = v8;
          while (1)
          {
            v94 = *v88++;
            v93 = v94;
            v95 = *(float *)(v44 + 32 * v94);
            if (v95 > v70)
              break;
            v96 = *v61++;
            v97 = *(float *)(v67 + 4 * *v92) + (float)(v41 * *(float *)(v69 + 4 * v96));
            v98 = *v62++;
            v99 = v97 + (float)(v42 * *(float *)(v68 + 4 * v98));
            if (v63 == *v91)
              v99 = 0.0;
            v100 = v95 + v99;
            v101 = (float *)(v44 + 32 * v93);
            v102 = v101[2];
            if (v102 != 0.0)
            {
              v103 = v102 - v57;
              v104 = -v103;
              if (v103 >= 0.0)
                v104 = v103;
              v105 = v103 - (float)(v101[1] - v35);
              if (v105 < 0.0)
                v105 = -v105;
              v106 = v101[3];
              v107 = v106 - v57;
              if ((float)(v106 - v57) < 0.0)
                v107 = -(float)(v106 - v57);
              if (v106 == 0.0)
                v108 = 0.0;
              else
                v108 = v107;
              if (v104 > *(float *)(v5 + 8284))
                v100 = v100 + (float)(*(float *)(v5 + 8288) * v104);
              if (v108 > *(float *)(v5 + 8292))
                v100 = v100 + (float)(*(float *)(v5 + 8296) * v108);
              if (v105 > *(float *)(v5 + 8300))
                v100 = v100 + (float)(*(float *)(v5 + 8304) * v105);
            }
            if (v100 < v70)
            {
              v70 = v100;
              v48 = v93;
            }
            ++v92;
            ++v91;
            if (!--v90)
            {
              v62 = v89;
              v61 = v87;
              v109 = v50;
              goto LABEL_129;
            }
          }
        }
        else
        {
          v109 = 0;
LABEL_129:
          if (v109 < v45)
          {
            v150 = *(_QWORD *)(a1 + 640);
            do
            {
              v151 = *(unsigned __int16 *)(v150 + 2 * v109);
              v152 = (float *)(v44 + 32 * v151);
              v153 = (float)(*(float *)(v67 + 4 * v8[v109]) + (float)(v41 * *(float *)(v69 + 4 * *v61)))
                   + (float)(v42 * *(float *)(v68 + 4 * *v62));
              if (v63 == v7[v109])
                v153 = 0.0;
              v154 = *v152 + v153;
              v155 = v152[2];
              if (v155 != 0.0)
              {
                v156 = v155 - v57;
                v157 = -v156;
                if (v156 >= 0.0)
                  v157 = v156;
                v158 = v156 - (float)(v152[1] - v35);
                if (v158 < 0.0)
                  v158 = -v158;
                v159 = v152[3];
                v160 = v159 - v57;
                if ((float)(v159 - v57) < 0.0)
                  v160 = -(float)(v159 - v57);
                if (v159 == 0.0)
                  v161 = 0.0;
                else
                  v161 = v160;
                if (v157 > *(float *)(v5 + 8284))
                  v154 = v154 + (float)(*(float *)(v5 + 8288) * v157);
                if (v161 > *(float *)(v5 + 8292))
                  v154 = v154 + (float)(*(float *)(v5 + 8296) * v161);
                if (v158 > *(float *)(v5 + 8300))
                  v154 = v154 + (float)(*(float *)(v5 + 8304) * v158);
              }
              if (v154 >= v70)
                LODWORD(v151) = v48;
              else
                v70 = v154;
              v162 = (float *)(v44 + 32 * *(unsigned __int16 *)(v150 + 2 * (v109 + 1)));
              v163 = (float)(*(float *)(v67 + 4 * v8[v109 + 1]) + (float)(v41 * *(float *)(v69 + 4 * v61[1])))
                   + (float)(v42 * *(float *)(v68 + 4 * v62[1]));
              if (v63 == v7[v109 + 1])
                v163 = 0.0;
              v164 = *v162 + v163;
              v165 = v162[2];
              if (v165 != 0.0)
              {
                v166 = v165 - v57;
                v167 = -v166;
                if (v166 >= 0.0)
                  v167 = v166;
                v168 = v166 - (float)(v162[1] - v35);
                if (v168 < 0.0)
                  v168 = -v168;
                v169 = v162[3];
                v170 = v169 - v57;
                if ((float)(v169 - v57) < 0.0)
                  v170 = -(float)(v169 - v57);
                if (v169 == 0.0)
                  v171 = 0.0;
                else
                  v171 = v170;
                if (v167 > *(float *)(v5 + 8284))
                  v164 = v164 + (float)(*(float *)(v5 + 8288) * v167);
                if (v171 > *(float *)(v5 + 8292))
                  v164 = v164 + (float)(*(float *)(v5 + 8296) * v171);
                if (v168 > *(float *)(v5 + 8300))
                  v164 = v164 + (float)(*(float *)(v5 + 8304) * v168);
              }
              if (v164 < v70)
              {
                v70 = v164;
                LODWORD(v151) = *(unsigned __int16 *)(v150 + 2 * (v109 + 1));
              }
              v172 = (float *)(v44 + 32 * *(unsigned __int16 *)(v150 + 2 * (v109 + 2)));
              v173 = (float)(*(float *)(v67 + 4 * v8[v109 + 2]) + (float)(v41 * *(float *)(v69 + 4 * v61[2])))
                   + (float)(v42 * *(float *)(v68 + 4 * v62[2]));
              if (v63 == v7[v109 + 2])
                v173 = 0.0;
              v174 = *v172 + v173;
              v175 = v172[2];
              if (v175 != 0.0)
              {
                v176 = v175 - v57;
                v177 = -v176;
                if (v176 >= 0.0)
                  v177 = v176;
                v178 = v176 - (float)(v172[1] - v35);
                if (v178 < 0.0)
                  v178 = -v178;
                v179 = v172[3];
                v180 = v179 - v57;
                if ((float)(v179 - v57) < 0.0)
                  v180 = -(float)(v179 - v57);
                if (v179 == 0.0)
                  v181 = 0.0;
                else
                  v181 = v180;
                if (v177 > *(float *)(v5 + 8284))
                  v174 = v174 + (float)(*(float *)(v5 + 8288) * v177);
                if (v181 > *(float *)(v5 + 8292))
                  v174 = v174 + (float)(*(float *)(v5 + 8296) * v181);
                if (v178 > *(float *)(v5 + 8300))
                  v174 = v174 + (float)(*(float *)(v5 + 8304) * v178);
              }
              if (v174 >= v70)
              {
                v48 = v151;
              }
              else
              {
                v70 = v174;
                v48 = *(unsigned __int16 *)(v150 + 2 * (v109 + 2));
              }
              v182 = v109 + 3;
              v183 = *(unsigned __int16 *)(v150 + 2 * v182);
              v184 = *(float *)(v44 + 32 * v183);
              if (v184 > v70)
                break;
              v185 = (float)(*(float *)(v67 + 4 * v8[v182]) + (float)(v41 * *(float *)(v69 + 4 * v61[3])))
                   + (float)(v42 * *(float *)(v68 + 4 * v62[3]));
              if (v63 == v7[v182])
                v185 = 0.0;
              v186 = v184 + v185;
              v187 = (float *)(v44 + 32 * v183);
              v188 = v187[2];
              if (v188 != 0.0)
              {
                v189 = v188 - v57;
                v190 = -v189;
                if (v189 >= 0.0)
                  v190 = v189;
                v191 = v189 - (float)(v187[1] - v35);
                if (v191 < 0.0)
                  v191 = -v191;
                v192 = v187[3];
                v193 = v192 - v57;
                if ((float)(v192 - v57) < 0.0)
                  v193 = -(float)(v192 - v57);
                if (v192 == 0.0)
                  v194 = 0.0;
                else
                  v194 = v193;
                if (v190 > *(float *)(v5 + 8284))
                  v186 = v186 + (float)(*(float *)(v5 + 8288) * v190);
                if (v194 > *(float *)(v5 + 8292))
                  v186 = v186 + (float)(*(float *)(v5 + 8296) * v194);
                if (v191 > *(float *)(v5 + 8300))
                  v186 = v186 + (float)(*(float *)(v5 + 8304) * v191);
              }
              if (v186 < v70)
              {
                v70 = v186;
                v48 = v183;
              }
              v109 += 4;
              v61 += 4;
              v62 += 4;
            }
            while (v109 < v45);
          }
        }
LABEL_259:
        v54 = v66 + v70;
        v218 = v257;
        v219 = v43 + 32 * v257;
        if (v54 <= (float)(v52 + v55))
        {
          *(float *)v219 = v54;
          MemoryFromChunk = *(_QWORD *)(a1 + 80);
          if (MemoryFromChunk)
          {
            *(_QWORD *)(a1 + 80) = *(_QWORD *)MemoryFromChunk;
          }
          else
          {
            v221 = v55;
            MemoryFromChunk = fastallo_AllocateMemoryFromChunk(v246, 2u, (int *)v258 + 1);
            v218 = v257;
            v55 = v221;
            v35 = v249;
            v50 = v45 & 3;
            v52 = v250;
            v51 = v252;
            v43 = v251;
            v56 = v253;
          }
          v23 = HIDWORD(v258[0]);
          if ((v258[0] & 0x8000000000000000) != 0)
            return v23;
          ++*(_DWORD *)(a1 + 648);
          *(_DWORD *)MemoryFromChunk = *(_DWORD *)(v56 + 24 * v218 + 4);
          *(_WORD *)(MemoryFromChunk + 4) = 0;
          v222 = *(_QWORD *)(*(_QWORD *)(a1 + 624) + 32 * v48 + 24);
          v223 = *(unsigned __int16 *)(v222 + 4);
          *(_WORD *)(v222 + 4) = v223 + 1;
          if (!v223)
            ++*(_WORD *)(*(_QWORD *)(a1 + 584) + 2 * v247);
          *(_QWORD *)(MemoryFromChunk + 8) = v222;
          *(_QWORD *)(v43 + 32 * v218 + 24) = MemoryFromChunk;
          if (*(_DWORD *)(v5 + 8264))
          {
            if (*(float *)v258 == 0.0)
            {
              v226 = v44 + 32 * v48;
              *(_QWORD *)(v43 + 32 * v218 + 8) = *(_QWORD *)(v226 + 8);
              v225 = *(float *)(v226 + 4);
            }
            else
            {
              v224 = v43 + 32 * v218;
              *(_DWORD *)(v224 + 12) = *(_DWORD *)(v44 + 32 * v48 + 8);
              *(_DWORD *)(v224 + 8) = v258[0];
              v225 = v35;
            }
            *(float *)(v43 + 32 * v218 + 4) = v225;
          }
          if (*(_DWORD *)(v5 + 8268))
          {
            if (v51)
              v227 = 0;
            else
              v227 = *(_WORD *)(v44 + 32 * v48 + 16) + v60;
            *(_WORD *)(v43 + 32 * v218 + 16) = v227;
          }
          v54 = *(float *)v219;
          v228 = *(float *)v219 < v55;
          if (*(float *)v219 < v55)
            v55 = *(float *)v219;
          v229 = v254;
          if (v228)
            v229 = v218;
          v254 = v229;
        }
        else
        {
          *(_DWORD *)v219 = 1259902592;
          *(_QWORD *)(v219 + 24) = 0;
        }
        v47 = v218 + 1;
        v230 = *(unsigned int *)(a1 + 656);
      }
      while (v47 < v230);
      v231 = 0;
      if (v52 > 4.0)
      {
        v2 = v242;
        v232 = v254;
LABEL_311:
        mfs_Viterbi_sortCurrentStateByScore(a1);
        *(_DWORD *)(a1 + 656) -= v231;
        mfs_Viterbi_FillPrevStateCacheTables(a1, v2);
        *(_DWORD *)(a1 + 664) = v232;
        goto LABEL_312;
      }
      if ((_DWORD)v230)
      {
        v2 = v242;
        v15 = v244;
        v232 = v254;
        do
        {
          v233 = *(_QWORD **)(v43 + 24);
          if (*(float *)v43 <= (float)(v52 + v55))
          {
            v236 = (_DWORD *)v233[1];
            if (v236)
              *v236 |= 0x80000000;
          }
          else
          {
            *(_DWORD *)v43 = 1259902592;
            ++v231;
            if (v233)
            {
              v234 = v233[1];
              v235 = *(_WORD *)(v234 + 4) - 1;
              *(_WORD *)(v234 + 4) = v235;
              if (!v235)
                --*(_WORD *)(*(_QWORD *)(a1 + 584) + 2 * v247);
              *v233 = *(_QWORD *)(a1 + 80);
              *(_QWORD *)(a1 + 80) = v233;
              --*(_DWORD *)(a1 + 648);
              *(_QWORD *)(v43 + 24) = 0;
            }
          }
          v43 += 32;
          --v230;
        }
        while (v230);
      }
      else
      {
        v2 = v242;
        v15 = v244;
        v232 = v254;
      }
    }
    else
    {
      v232 = 0;
      v231 = 0;
      if (v38 > 4.0)
        goto LABEL_311;
    }
    v237 = *(unsigned int *)(a1 + 652);
    if (!(_DWORD)v237)
      goto LABEL_311;
    v238 = 0;
    while (1)
    {
      v239 = *(int **)(v44 + 32 * *(unsigned __int16 *)(*(_QWORD *)(a1 + 640) + 2 * v238) + 24);
      if (v239)
      {
        v240 = *v239;
        if (v15)
        {
          if (*((_WORD *)v239 + 2) && v240 < 0)
          {
LABEL_309:
            *v239 = v240 & 0x7FFFFFFF;
            goto LABEL_310;
          }
          if ((_DWORD)v247)
          {
            mfs_Viterbi_DecrementRefCountCascade(a1, *((_QWORD *)v239 + 1), v247 - 1);
            v237 = *(unsigned int *)(a1 + 652);
          }
        }
        else if (v240 < 0)
        {
          goto LABEL_309;
        }
        *(_QWORD *)v239 = *(_QWORD *)(a1 + 80);
        *(_QWORD *)(a1 + 80) = v239;
        --*(_DWORD *)(a1 + 648);
      }
LABEL_310:
      if (++v238 >= v237)
        goto LABEL_311;
    }
  }
  v24 = *(_DWORD *)(a2 + 60);
  if (v24 >= v13)
    v24 = -1431655765 * ((unint64_t)(*(_QWORD *)(a2 + 40) - v12) >> 3);
  *(_DWORD *)(a1 + 656) = v24;
  if (!v24)
  {
LABEL_15:
    mfs_Viterbi_sortCurrentStateByScore(a1);
    mfs_Viterbi_FillPrevStateCacheTables(a1, v2);
LABEL_312:
    v23 = 0;
    ++*(_DWORD *)(a1 + 616);
    return v23;
  }
  v25 = 0;
  v26 = 0;
  v27 = 1.0 - v10;
  v28 = *(_QWORD *)(a1 + 632);
  v29 = (unsigned __int16 *)(v12 + 8);
  v30 = (unsigned __int16 *)(v12 + 8);
  while (1)
  {
    v31 = *v30;
    v30 += 12;
    v32 = v28 + v25;
    *(float *)v32 = v27 * (float)((float)v31 / 100.0);
    *(_QWORD *)(v32 + 4) = 0;
    *(_QWORD *)(v32 + 10) = 0;
    v33 = *(_QWORD *)(a1 + 80);
    if (v33)
      *(_QWORD *)(a1 + 80) = *(_QWORD *)v33;
    else
      v33 = fastallo_AllocateMemoryFromChunk(v6, 2u, (int *)v258 + 1);
    v23 = HIDWORD(v258[0]);
    if ((v258[0] & 0x8000000000000000) != 0)
      return v23;
    ++*(_DWORD *)(a1 + 648);
    *(_DWORD *)v33 = *((_DWORD *)v29 - 1);
    *(_WORD *)(v33 + 4) = 0;
    *(_QWORD *)(v33 + 8) = 0;
    v28 = *(_QWORD *)(a1 + 632);
    *(_QWORD *)(v28 + v25 + 24) = v33;
    ++v26;
    v25 += 32;
    v29 = v30;
    if (v26 >= *(unsigned int *)(a1 + 656))
      goto LABEL_15;
  }
}

uint64_t mfs_Viterbi_sortCurrentStateByScore(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t i;

  v2 = *(unsigned int *)(a1 + 656);
  v3 = *(_QWORD *)(a1 + 640);
  if ((_DWORD)v2)
  {
    for (i = 0; i != v2; ++i)
      *(_WORD *)(v3 + 2 * i) = i;
  }
  return qsortex(v3, v2, 2, (uint64_t (*)(char *, char *, uint64_t))mfs_SortIndex_By_PathScore_Obersee, a1);
}

uint64_t mfs_Viterbi_DecrementRefCountCascade(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  __int16 v4;
  uint64_t v5;

  v3 = a3;
  do
  {
    v4 = *(_WORD *)(a2 + 4) - 1;
    *(_WORD *)(a2 + 4) = v4;
    if (v4)
      break;
    --*(_WORD *)(*(_QWORD *)(result + 584) + 2 * v3);
    v5 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)a2 = *(_QWORD *)(result + 80);
    *(_QWORD *)(result + 80) = a2;
    --*(_DWORD *)(result + 648);
    if (!(_DWORD)v3)
      break;
    --v3;
    a2 = v5;
  }
  while (v5);
  return result;
}

uint64_t mfs_Viterbi_SelectBestPath(uint64_t a1, int a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD **v19;
  int v20;
  _DWORD *v21;

  v4 = *(_DWORD *)(a1 + 612);
  v5 = *(_DWORD *)(a1 + 616);
  v6 = *(_DWORD *)(a1 + 596);
  if (a2)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 632) + 32 * *(unsigned int *)(a1 + 664) + 24);
    if (v7)
    {
      v8 = a2 - 1;
      do
      {
        *(_DWORD *)v7 |= 0x80000000;
        if (!v8)
          break;
        v7 = *(_QWORD *)(v7 + 8);
        --v8;
      }
      while (v7);
    }
  }
  if (!*(_DWORD *)(a1 + 656))
  {
    *(_DWORD *)(a1 + 656) = 0;
    return 1;
  }
  v9 = 0;
  v10 = 0;
  v11 = v4 + v5 + ~v6 - 1;
  do
  {
    v12 = *(_QWORD *)(a1 + 640);
    v13 = *(unsigned __int16 *)(v12 + 2 * v9);
    if (*(_DWORD *)(a1 + 664) == (_DWORD)v13)
      goto LABEL_11;
    v14 = *(_QWORD *)(*(_QWORD *)(a1 + 632) + 32 * v13 + 24);
    if (checkMarkBackTracesAlive(v14))
    {
      v12 = *(_QWORD *)(a1 + 640);
LABEL_11:
      *(_WORD *)(v12 + 2 * v10++) = v13;
      goto LABEL_12;
    }
    v15 = *(_QWORD *)(v14 + 8);
    if (v15)
      mfs_Viterbi_DecrementRefCountCascade(a1, v15, v11);
LABEL_12:
    ++v9;
  }
  while (v9 < *(unsigned int *)(a1 + 656));
  *(_DWORD *)(a1 + 656) = v10;
  if (v10)
  {
    v16 = 0;
    v17 = *(_QWORD *)(a1 + 640);
    v18 = *(_QWORD *)(a1 + 632);
    do
    {
      if (a2)
      {
        v19 = (_DWORD **)(v18 + 32 * *(unsigned __int16 *)(v17 + 2 * v16) + 24);
        v20 = a2;
        do
        {
          v21 = *v19;
          if (!v21)
            break;
          if ((*v21 & 0x80000000) == 0)
            break;
          *v21 &= ~0x80000000;
          v19 = (_DWORD **)(v21 + 2);
          --v20;
        }
        while (v20);
      }
      ++v16;
    }
    while (v16 != v10);
  }
  return 1;
}

uint64_t checkMarkBackTracesAlive(uint64_t result)
{
  _DWORD *v1;

  if (result)
  {
    v1 = (_DWORD *)result;
    if ((*(_DWORD *)result & 0x80000000) == 0)
    {
      result = checkMarkBackTracesAlive(*(_QWORD *)(result + 8));
      if (!(_DWORD)result)
        return result;
      *v1 |= 0x80000000;
    }
    return 1;
  }
  return result;
}

BOOL mfs_Viterbi_CheckRiskForBufferUnderrun(uint64_t *a1, _BOOL8 a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  uint64_t v10;
  const char *v11;

  if (!ForcedEEController_HasStartedPlayback(a2))
    return 0;
  v9 = ForcedEEController_CheckRiskForBufferUnderrun(a2);
  v10 = *a1;
  if (v9)
  {
    MFS__log_out_Event(v10, 27, (uint64_t)"%s%u%s%u%s%u%s%u", v4, v5, v6, v7, v8, "ETIME_PROCESS_START");
    v10 = *a1;
    v11 = "WARNING: RiskForBufferUnderrun at idx %d : %u | %u + %u >= %u (msec since ProcessStart | msec since StartedPla"
          "yback + msec lead >= msec audio)  \n";
  }
  else
  {
    v11 = "No RiskForBufferUnderrun at idx %d : %u | %u + %u < %u (msec since ProcessStart | msec since StartedPlayback +"
          " msec lead < msec audio)  \n";
  }
  MFS__log_select_Diag(v10, 1, (uint64_t)v11);
  return v9;
}

uint64_t mfs_Viterbi_ReadyForEarlyEmission_OnUniquePath(uint64_t a1, unsigned int a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  BOOL v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;

  v2 = *(_DWORD *)(a1 + 612);
  v3 = *(_DWORD *)(a1 + 616) + v2;
  v4 = *(_DWORD *)(a1 + 596);
  v5 = v3 + ~v4;
  v6 = v3 <= v4 || (_DWORD)v5 == 0;
  if (v6)
    return 0;
  v7 = *(_DWORD *)(a1 + 608);
  if (v7 >= v5)
    return 0;
  v8 = *(unsigned int *)(a1 + 608);
  while (*(_WORD *)(*(_QWORD *)(a1 + 584) + 2 * v8) == 1)
  {
    if (++v8 >= v5)
      goto LABEL_11;
  }
  LODWORD(v5) = v8;
LABEL_11:
  if (v5 <= v7)
    return 0;
  v9 = v5 + v4;
  v10 = 3 * ((v5 + v4) / 3);
  v11 = v10 - a2;
  if (v10 <= a2)
    return 0;
  v12 = 0;
  if (v10 < a2)
    v11 = 0;
  v6 = v4 == v2;
  v13 = 8576;
  if (v6)
    v13 = 8572;
  if (v11 >= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + v13))
  {
    *(_DWORD *)(a1 + 600) = v9;
    *(_DWORD *)(a1 + 604) = v10;
    *(_DWORD *)(a1 + 608) = v5;
    v12 = 1;
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"EarlyEmissionEval3:At utt.state %u we have %u known units (= +%d), %u full segment emittable (vit from %u) emitNow:%d\n");
  }
  return v12;
}

uint64_t mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  BOOL v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  int v25;
  int v26;
  unsigned int v28;

  v3 = 0;
  v28 = 0;
  v4 = *(_DWORD *)(a1 + 612);
  v5 = *(_DWORD *)(a1 + 616);
  v6 = *(_DWORD *)(a1 + 596);
  v7 = v5 + v4 + ~v6;
  if (v5 + v4 > v6 && v7 != 0)
  {
    if ((a3 - 1) > 1
      || *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + 8588) == -1
      || (paramc_ParamGetUInt(*(_QWORD *)(*(_QWORD *)a1 + 40), (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", &v28) & 0x80000000) != 0|| v28 < 2 * *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + 8588))
    {
      if (a3 == 3)
      {
        v16 = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612);
        v18 = v16 != 0;
        v15 = v16 - 1;
        if (!v18)
          v15 = 0;
        if (v15)
          goto LABEL_31;
      }
      else
      {
        if (a3 != 2)
        {
          if (a3 == 1)
          {
            v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + 8580);
            if (v12 != -1)
            {
              v13 = v5 + v4 - v6;
              while (1)
              {
                v14 = v13 - 2;
                if ((int)(v13 - 2) < 0)
                  break;
                --v13;
                if (v12 >= *(unsigned __int16 *)(*(_QWORD *)(a1 + 584) + 2 * v14))
                {
                  v15 = *(_DWORD *)(a1 + 596) + v13;
                  if (v15)
                    goto LABEL_31;
                  return 0;
                }
              }
            }
          }
          return 0;
        }
        v17 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + 8584);
        v18 = v17 != -1 && v7 >= v17;
        if (v18)
        {
          v19 = v5 + v4 - v6 - v17;
          do
          {
            v20 = v19;
            if (v19 >= v7)
              break;
            v21 = *(_QWORD *)(a1 + 584);
            v22 = *(unsigned __int16 *)(v21 + 2 * (v19 - 1));
            LODWORD(v21) = *(unsigned __int16 *)(v21 + 2 * v19++);
          }
          while (v22 == (_DWORD)v21);
          v15 = *(_DWORD *)(a1 + 596) + v20;
          if (v15)
          {
LABEL_31:
            v23 = 3 * (v15 / 3);
            if (v23 > a2 && v23 > *(_DWORD *)(a1 + 596))
            {
              v25 = *(_DWORD *)(a1 + 612);
              v26 = *(_DWORD *)(a1 + 616);
              if (v26 + v25 >= v23)
              {
                mfs_Viterbi_SelectBestPath(a1, v25 - v23 + v26);
                *(_DWORD *)(a1 + 600) = v23;
                *(_DWORD *)(a1 + 604) = v23;
                *(_DWORD *)(a1 + 608) = 0;
                v3 = 1;
                MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"WARNING: %s Early Emission at idx %u :  emit from %u to %u (%u states) \n");
                return v3;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return v3;
}

uint64_t mfs_Viterbi_IsEarlyEmissionPossible(uint64_t *a1, _BOOL8 a2, unsigned int a3)
{
  int v5;
  uint64_t v7;

  if (!*(_DWORD *)(*(_QWORD *)(a1[2] + 1072) + 8564))
    return 0;
  if (mfs_Viterbi_CheckRiskForBufferUnderrun(a1, a2))
  {
    v5 = 3;
    return mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath((uint64_t)a1, a3, v5);
  }
  v7 = 1;
  if (!mfs_Viterbi_ReadyForEarlyEmission_OnUniquePath((uint64_t)a1, a3)
    && !mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath((uint64_t)a1, a3, 1))
  {
    v5 = 2;
    return mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath((uint64_t)a1, a3, v5);
  }
  return v7;
}

uint64_t mfs_Viterbi_ResultScore_Obersee(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  uint64_t v10;
  const char *v11;
  int v12;
  int v13;
  int v14;

  v4 = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612) - 1;
  if (v4 >= *(_DWORD *)(a1 + 596))
  {
    v5 = (_QWORD *)(*(_QWORD *)(a1 + 632) + 32 * *(unsigned int *)(a1 + 664) + 24);
    v6 = *(_QWORD *)(a2 + 8);
    v7 = *(_QWORD *)(a3 + 8);
    do
    {
      v8 = (_DWORD *)*v5;
      v9 = *v8;
      v5 = v8 + 2;
      *(_DWORD *)(v6 + 4 * v4) = v9 & 0x7FFFFFFF;
      *(_DWORD *)(v7 + 4 * v4--) = 0;
    }
    while (v4 >= *(_DWORD *)(a1 + 596));
  }
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 1072) + 8564))
  {
    if (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 2580))
    {
      MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"EarlyEmissionEval1:Subsequent emission:At utt.state %u we can emit %u utt.states (%u more were determined)\n");
      v10 = *(_QWORD *)a1;
      v11 = "EarlyEmissionEval1:Subsequent emission:After first emission of %u, cumulSubseqEmit %u & cumulSubseqCalc %u a"
            "fter emit utt.state %u (deltaBuffer %d)\n";
    }
    else
    {
      *(_DWORD *)(a1 + 768) = *(_DWORD *)(a1 + 604);
      *(_DWORD *)(a1 + 772) = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612);
      v10 = *(_QWORD *)a1;
      v11 = "EarlyEmissionEval1:First emission:At utt.state %u we can emit %u utt.states (%u more were determined)\n";
    }
    MFS__log_select_Diag(v10, 1, (uint64_t)v11);
  }
  v12 = *(_DWORD *)(a1 + 600);
  if (v12)
  {
    v13 = *(_DWORD *)(a1 + 596);
    v14 = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612) + ~v13;
    *(_DWORD *)(a1 + 596) = v12;
    *(_DWORD *)(a1 + 600) = 0;
    memmove(*(void **)(a1 + 584), (const void *)(*(_QWORD *)(a1 + 584) + 2 * (v12 - v13)), 2 * (v14 - (v12 - v13)));
    *(_DWORD *)(a1 + 608) = 0;
  }
  return 0;
}

uint64_t mfs_SortIndex_By_PathScore_Obersee(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;

  v3 = *(_QWORD *)(a3 + 632);
  v4 = *(_DWORD *)(v3 + 32 * *a1);
  LODWORD(v3) = *(_DWORD *)(v3 + 32 * *a2);
  v5 = v4 > v3;
  if (v4 >= v3)
    v6 = 0;
  else
    v6 = -1;
  if (v5)
    return 1;
  else
    return v6;
}

uint64_t mfs_SegmentList_Init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a3 = a1;
  *(_QWORD *)(a3 + 8) = a2;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  return 0;
}

_QWORD *mfs_SegmentList_DeInit(_QWORD *result)
{
  _QWORD *v1;

  v1 = result;
  if (result[1])
  {
    result = heap_Free(*(_QWORD **)(*result + 8), result[2]);
    v1[2] = 0;
  }
  *((_DWORD *)v1 + 8) = 0;
  v1[3] = 0;
  return result;
}

uint64_t mfs_SegmentList_AddSeg(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;

  v4 = *(_DWORD *)(a1 + 24);
  if (v4 < *(_DWORD *)(a1 + 32))
  {
    v5 = *(_QWORD *)(a1 + 16);
LABEL_5:
    result = 0;
    v9 = v5 + 28 * v4;
    *(_DWORD *)v9 = *(_DWORD *)a2;
    *(_BYTE *)(v9 + 4) = *(_BYTE *)(a2 + 4);
    *(_QWORD *)(v9 + 8) = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(v9 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 24) = v4 + 1;
    return result;
  }
  v6 = v4 + 64;
  v7 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 16), 28 * (v4 + 64));
  if (v7)
  {
    v5 = v7;
    *(_QWORD *)(a1 + 16) = v7;
    *(_DWORD *)(a1 + 32) = v6;
    v4 = *(_DWORD *)(a1 + 24);
    goto LABEL_5;
  }
  return 2229280778;
}

uint64_t mfs_SegmentList_Add(uint64_t a1, int a2, char a3, int a4, int a5)
{
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;

  v10 = *(_DWORD *)(a1 + 24);
  if (v10 < *(_DWORD *)(a1 + 32))
  {
    v11 = *(_QWORD *)(a1 + 16);
LABEL_5:
    result = 0;
    v15 = v11 + 28 * v10;
    *(_DWORD *)v15 = a2;
    *(_BYTE *)(v15 + 4) = a3;
    *(_DWORD *)(v15 + 8) = a4;
    *(_DWORD *)(v15 + 12) = a5;
    *(_DWORD *)(v15 + 16) = 1;
    *(_DWORD *)(a1 + 24) = v10 + 1;
    return result;
  }
  v12 = v10 + 64;
  v13 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 16), 28 * (v10 + 64));
  if (v13)
  {
    v11 = v13;
    *(_QWORD *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 32) = v12;
    v10 = *(_DWORD *)(a1 + 24);
    goto LABEL_5;
  }
  return 2229280778;
}

uint64_t mfs_SegmentList_Merge(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t result;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  const float *v27;
  float32x2_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  _DWORD *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  int v49;
  _DWORD *v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  unsigned int v56;
  uint64_t v57;
  int v58;
  int v59;
  unsigned int v60;
  int v61;
  int v62;
  int *v63;
  _DWORD *v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  _OWORD v72[2];
  _QWORD *v73;
  _QWORD v74[2];
  __int128 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  v70 = *(_QWORD *)(a4 + 1072);
  v75 = *(_OWORD *)a1;
  v77 = 0;
  v78 = 0;
  v76 = 0;
  if (*((_DWORD *)a1 + 7))
  {
    v9 = 0;
    v10 = 0;
    LODWORD(v11) = 0;
    do
    {
      v12 = a1[2] + v9;
      v13 = *(_DWORD *)(v12 + 16);
      result = mfs_SegmentList_AddSeg((uint64_t)&v75, v12);
      if ((result & 0x80000000) != 0)
        return result;
      v11 = (v13 + v11);
      ++v10;
      v9 += 28;
    }
    while (v10 < *((unsigned int *)a1 + 7));
    v15 = v77;
    v16 = a2;
  }
  else
  {
    v16 = a2;
    result = 2229280775;
    if (!a2)
      return result;
    v60 = *((_DWORD *)a1 + 6);
    if (!v60 || v60 > *(_DWORD *)(a2 + 24))
      return result;
    v15 = 0;
    LODWORD(v10) = 0;
    v11 = 0;
  }
  v17 = *((_DWORD *)a1 + 6);
  v18 = v17 - v10;
  if (v17 <= v10)
    goto LABEL_65;
  v68 = a3;
  v66 = a5;
  v67 = (unsigned __int8 *)a4;
  v19 = 0;
  v69 = 0;
  v20 = v10;
  v21 = 28 * v10;
  v22 = 28 * v11 + 12;
  v23 = -1;
  while (v11 < *(unsigned int *)(v16 + 24))
  {
    v24 = a1[2] + v21;
    if (*(_DWORD *)v24 == -1)
    {
      v26 = *(_QWORD *)(v16 + 16);
      v24 = v26 + 28 * v11;
      v25 = *(_DWORD *)(v26 + v22);
      HIDWORD(v69) += v25;
      LODWORD(v69) = v69 + 1;
    }
    else
    {
      v25 = *(_DWORD *)(v24 + 12);
    }
    if (v20 == *((_DWORD *)a1 + 7))
    {
      result = mfs_SegmentList_Add((uint64_t)&v75, *(_DWORD *)v24, *(_BYTE *)(v24 + 4), *(_DWORD *)(v24 + 8), *(_DWORD *)(v24 + 12));
      if ((result & 0x80000000) != 0)
        return result;
      v23 = *(_DWORD *)v24;
      v27 = (const float *)(v24 + 12);
      v28 = vld1_dup_f32(v27);
      *(float32x2_t *)(v76 + 28 * v15 + 20) = v28;
      v16 = a2;
      goto LABEL_59;
    }
    if (*(_BYTE *)(v24 + 4) != 1
      || (v29 = *(_DWORD *)a1[1], *(_DWORD *)(v70 + 8256)) && (v11 % v29 || *(_DWORD *)v24 != -1))
    {
      v74[0] = 0;
      v74[1] = 0;
      v73 = v74;
      if (*(_DWORD *)(v70 + 8328))
      {
        memset(v72, 0, sizeof(v72));
        v30 = *(_DWORD *)v24;
        if (v23 == -1)
        {
          if (v30 == -1)
            goto LABEL_35;
        }
        else if (v30 != -1)
        {
          result = mfs_getUnitData_Obersee((uint64_t)v67, v66, v23, (uint64_t)v72);
          if ((result & 0x80000000) != 0)
            return result;
          v16 = a2;
          if (DWORD1(v72[0]) == *(_DWORD *)v24)
          {
LABEL_35:
            v31 = v76;
            v32 = v15;
            v36 = *(_DWORD *)(v76 + 28 * v15 + 12);
LABEL_36:
            v47 = v31 + 28 * v32;
            v48 = v36 + *(_DWORD *)(v24 + 12);
            v51 = *(_DWORD *)(v47 + 16);
            v50 = (_DWORD *)(v47 + 16);
            v49 = v51;
            *(v50 - 1) = v48;
            if (v51 >= 1)
              *(_DWORD *)(v31 + 28 * v32 + 24) = *(_DWORD *)(v24 + 12);
            *v50 = v49 + 1;
            v23 = *(_DWORD *)v24;
            goto LABEL_59;
          }
        }
        goto LABEL_53;
      }
      if (!v68)
      {
        v31 = v76;
        v32 = v15;
        v33 = v76 + 28 * v15;
        v35 = *(_DWORD *)(v33 + 8);
        v34 = (_DWORD *)(v33 + 8);
        v36 = v34[1];
        v37 = v36 + v35;
        v38 = *(_DWORD *)(v24 + 8);
        if (v36 + v35 == v38)
        {
          v39 = *(_DWORD *)(v76 + 28 * v15);
          if (v39 != -1 && *(_DWORD *)v24 != -1)
          {
            v65 = v76;
            v63 = v34 + 1;
            v64 = v34;
            mfs_getUnitDataFromMfsData(v67, v39, (uint64_t *)&v73);
            v62 = *((unsigned __int16 *)v73 + 5);
            mfs_getUnitDataFromMfsData(v67, *(_DWORD *)v24, (uint64_t *)&v73);
            v40 = v62;
            v32 = v15;
            v31 = v65;
            v16 = a2;
            v41 = *((unsigned __int16 *)v73 + 5);
            v36 = *v63;
            v38 = *(_DWORD *)(v24 + 8);
            v37 = *v63 + *v64;
            goto LABEL_43;
          }
          v41 = 0;
          v40 = 0;
LABEL_49:
          v55 = *(_DWORD *)(v31 + 28 * v32);
          if (v55 == *(_DWORD *)v24 || v55 != -1 && *(_DWORD *)v24 != -1 && v40 == v41)
            goto LABEL_36;
        }
        else
        {
          v40 = 0;
          v41 = 0;
LABEL_43:
          if (v37 == v38)
            goto LABEL_49;
        }
      }
LABEL_53:
      result = mfs_SegmentList_Add((uint64_t)&v75, *(_DWORD *)v24, *(_BYTE *)(v24 + 4), *(_DWORD *)(v24 + 8), *(_DWORD *)(v24 + 12));
      if ((result & 0x80000000) != 0)
        return result;
      v23 = *(_DWORD *)v24;
      v56 = v15 + 1;
      v15 = v56;
      v57 = v76;
      v58 = *(_DWORD *)(v76 + 28 * v56 + 16);
      v16 = a2;
      if (v58 == 1)
      {
        v59 = *(_DWORD *)(v24 + 12);
        *(_DWORD *)(v76 + 28 * v56 + 20) = v59;
LABEL_58:
        *(_DWORD *)(v57 + 28 * v56 + 24) = v59;
        goto LABEL_59;
      }
      if (v58 >= 1)
      {
        v59 = *(_DWORD *)(v24 + 12);
        goto LABEL_58;
      }
      goto LABEL_59;
    }
    if (v11 % v29)
    {
      v42 = v76;
      v43 = v76 + 28 * v15;
      v46 = *(_DWORD *)(v43 + 16);
      v44 = (_DWORD *)(v43 + 16);
      v45 = v46;
      *(v44 - 1) += *(_DWORD *)(v24 + 12);
      if (v46 >= 1)
        *(_DWORD *)(v42 + 28 * v15 + 24) = *(_DWORD *)(v24 + 12);
      *v44 = v45 + 1;
      goto LABEL_59;
    }
    result = mfs_SegmentList_Add((uint64_t)&v75, *(_DWORD *)v24, 1, *(_DWORD *)(v24 + 8), *(_DWORD *)(v24 + 12));
    if ((result & 0x80000000) != 0)
      return result;
    v23 = *(_DWORD *)v24;
    ++v15;
    v52 = v76;
    v53 = *(_DWORD *)(v76 + 28 * v15 + 16);
    v16 = a2;
    if (v53 == 1)
    {
      v54 = *(_DWORD *)(v24 + 12);
      *(_DWORD *)(v76 + 28 * v15 + 20) = v54;
LABEL_47:
      *(_DWORD *)(v52 + 28 * v15 + 24) = v54;
      goto LABEL_59;
    }
    if (v53 >= 1)
    {
      v54 = *(_DWORD *)(v24 + 12);
      goto LABEL_47;
    }
LABEL_59:
    v19 += v25;
    ++v20;
    ++v11;
    v21 += 28;
    v22 += 28;
    if (!--v18)
      break;
  }
  v15 = v77;
LABEL_65:
  heap_Free(*(_QWORD **)(*a1 + 8), a1[2]);
  a1[2] = v76;
  v61 = v78;
  *((_DWORD *)a1 + 7) = v15;
  *((_DWORD *)a1 + 8) = v61;
  *((_DWORD *)a1 + 6) = v15;
  MFS__log_select_Diag(*a1, 1, (uint64_t)"hybrid at %1.0f %% parameteric states at %1.0f %% dur\n");
  return 0;
}

uint64_t mfs_SegmentList_Length(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 24);
  return result;
}

uint64_t mfs_SegmentList_Get(uint64_t a1, unsigned int a2, _DWORD *a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8)
{
  uint64_t result;
  uint64_t v10;
  _DWORD *v11;

  if (a1 && *(_DWORD *)(a1 + 24) > a2)
  {
    result = 0;
    v10 = *(_QWORD *)(a1 + 16) + 28 * a2;
    *a3 = *(_DWORD *)v10;
    *a4 = *(_BYTE *)(v10 + 4);
    v11 = (_DWORD *)(*(_QWORD *)(a1 + 16) + 28 * a2);
    *a5 = v11[2];
    *a6 = v11[3];
    *a7 = v11[5];
    *a8 = v11[6];
  }
  else
  {
    *a3 = 0;
    *a4 = 0;
    *a6 = 0;
    result = 2229280775;
    *a5 = 0;
  }
  return result;
}

uint64_t mfs_InitHashTable(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  uint64_t result;
  unsigned int v10;
  uint64_t v11;
  int v12;
  void *v13;

  if (!a1 || !a2 || !a4)
  {
    MFS__log_select_Diag(a1, 1, (uint64_t)"\n");
    return 0;
  }
  v5 = *(_DWORD *)(a3 + 25140);
  if ((v5 & 0xFFFFFFFE) != 2)
  {
    if (v5 == 1 && a2[541] == 256 && a2[537] == 512)
    {
      v10 = 1;
      *(_DWORD *)(a4 + 2064) = 1;
      v11 = a2[274];
      v12 = 32;
      do
      {
        if (v11 <= v10)
          break;
        v10 *= 2;
        --v12;
      }
      while (v12);
      *(_DWORD *)(a4 + 2060) = v10 - 1;
      *(_DWORD *)(a4 + 2056) = v11;
      v13 = (void *)heap_Calloc(*(_QWORD **)(a1 + 8), v11, 8);
      *(_QWORD *)(a4 + 2048) = v13;
      if (v13)
        goto LABEL_21;
      return 2229280778;
    }
LABEL_20:
    *(_DWORD *)(a4 + 2064) = 0;
    *(_QWORD *)(a4 + 2056) = 0x1FFFF00020000;
    v13 = (void *)heap_Calloc(*(_QWORD **)(a1 + 8), 0x20000, 8);
    *(_QWORD *)(a4 + 2032) = v13;
    if (v13)
    {
LABEL_21:
      cstdlib_memset(v13, 0, 8 * *(unsigned int *)(a4 + 2056));
      return 0;
    }
    return 2229280778;
  }
  if (a2[541] != 256 || a2[537] != 512)
    goto LABEL_20;
  *(_DWORD *)(a4 + 2064) = 2;
  v6 = a2[274];
  v7 = 1;
  v8 = 32;
  do
  {
    if (v6 <= v7)
      break;
    v7 *= 2;
    --v8;
  }
  while (v8);
  result = 0;
  *(_DWORD *)(a4 + 2060) = v7 - 1;
  *(_DWORD *)(a4 + 2056) = v6;
  return result;
}

uint64_t mfs_DeInitHashTable(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  _QWORD *v5;

  v3 = *(_DWORD *)(a2 + 2064);
  if (v3 != 2)
  {
    if (v3 == 1)
    {
      v4 = *(_QWORD *)(a2 + 2048);
      if (v4)
      {
        v5 = (_QWORD *)(a2 + 2048);
LABEL_7:
        heap_Free(*(_QWORD **)(a1 + 8), v4);
        *v5 = 0;
      }
    }
    else
    {
      v4 = *(_QWORD *)(a2 + 2032);
      if (v4)
      {
        v5 = (_QWORD *)(a2 + 2032);
        goto LABEL_7;
      }
    }
  }
  *(_DWORD *)(a2 + 2056) = 0;
  return 0;
}

uint64_t mfs_Search_FindNodeCandidates_StatSelect(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  float v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  float v16;
  float v17;
  unsigned __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  int v26;
  float v27;
  signed int v28;
  uint64_t v29;
  uint64_t AcousticVector;
  unsigned int v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  _DWORD *v42;
  float v43;
  float v44;
  uint64_t v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  float v49;
  int LeafIndex;
  int v51;
  float v52;
  BOOL v53;
  float v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  int *v61;
  uint64_t v62;
  int v63;
  const char *v64;
  unsigned __int8 *v66;
  int v67;
  unsigned __int8 v68;
  _QWORD *v69;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _DWORD *v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  _QWORD *v86;
  _QWORD v87[2];
  _OWORD __b[9];
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  _QWORD v94[3];
  __int16 v95;
  char v96;
  _BYTE v97[80];
  float v98[4];
  _DWORD v99[44];
  __int128 v100;
  uint64_t v101;

  v4 = a2;
  v101 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a2 + 1928);
  v96 = 0;
  v95 = 0;
  memset(v94, 0, sizeof(v94));
  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  v89 = 0u;
  memset(__b, 0, sizeof(__b));
  v7 = *(float *)(a3 + 8972);
  v100 = 0u;
  memset(v99, 0, sizeof(v99));
  v87[0] = 0;
  v87[1] = 0;
  v86 = v87;
  *(_QWORD *)(a2 + 2192) = 0;
  mfs_S32Vect_Init(v6, v94);
  v84 = v6;
  mfs_TCost_Init(v6, a3, __b);
  v8 = *(float *)(a3 + 8180);
  v83 = *((_QWORD *)a1 + 1516);
  v9 = a1[610];
  if ((int)v9 < 1)
  {
    v11 = 0;
  }
  else
  {
    v10 = 0;
    while (*(_BYTE *)(*((_QWORD *)a1 + 307) + v10) != 31)
    {
      if (v9 == ++v10)
        goto LABEL_9;
    }
    v11 = v10;
  }
  if (v11 == (_DWORD)v9)
  {
LABEL_9:
    MFS__log_select_Diag(v6, 3, (uint64_t)"Can not identify DIFFERENTIATOR ID (%d), please CHECK!\n");
    v11 = 0;
  }
  v80 = a3;
  MFS__log_select_Diag(v6, 3, (uint64_t)"TARGET DIFFERENTIATOR FEATURE ID = %d\n");
  if (*(int *)(v4 + 608) < 1)
  {
    v14 = 0;
    v19 = a3;
LABEL_67:
    if (*(_DWORD *)(v19 + 8564) == 1)
    {
      v54 = *(float *)(v4 + 2616);
      if (v54 == 0.0)
      {
        v64 = "Early emission enabled in pipeline header but no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(v4 + 2608) = (int)((double)*(int *)(v4 + 2604) / (v54 * 0.8 + 1.0));
        MFS__log_select_Diag(v84, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        v55 = *(unsigned int *)(v4 + 608);
        v56 = *(_DWORD *)(v4 + 2596);
        if ((int)v55 >= 2)
        {
          v57 = 0;
          v58 = 1;
          v59 = *(_DWORD *)(v4 + 2596);
          do
          {
            if (v59)
              break;
            v60 = *a1;
            if ((int)*a1 >= 1)
            {
              v61 = (int *)(*(_QWORD *)(*(_QWORD *)(v4 + 600) + 528 * v58 + 16) + 8);
              v62 = *a1;
              do
              {
                v63 = *v61++;
                v57 += v63 * *(_DWORD *)(v19 + 24);
                --v62;
              }
              while (v62);
            }
            ++v58;
            if (v57 >= *(_DWORD *)(v4 + 2608))
            {
              v56 = v60 * v58;
              *(_DWORD *)(v4 + 2596) = v60 * v58;
              v59 = v60 * v58;
            }
            else
            {
              v59 = 0;
            }
          }
          while (v58 != v55);
        }
        if (!v56)
          goto LABEL_85;
        v64 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      v64 = "Early emission not enabled in pipeline header\n";
    }
    MFS__log_select_Diag(v84, 1, (uint64_t)v64);
LABEL_85:
    *(_DWORD *)(v4 + 2200) = 0;
    goto LABEL_86;
  }
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = (_QWORD *)(v4 + 1944);
  v16 = v7 * 0.5;
  v17 = 1.0 - v8;
  v67 = v11;
  v18 = (unsigned __int8 *)&v99[1] + v11;
  v19 = a3;
  v75 = (_DWORD *)(a3 + 25288);
  v72 = v4 + 1944;
  v73 = v4;
  v66 = v18;
  while (1)
  {
    v70 = v12;
    v20 = *(_QWORD *)(v4 + 600);
    MFS__log_select_Diag(v84, 3, (uint64_t)"phoneme %d\n");
    mfs_symData_GetTargetVector((uint64_t)a1, (uint64_t)v99, *(_QWORD *)(v4 + 8), v12);
    MFS__log_select_Diag(v84, 3, (uint64_t)"TARGET DIFFERENTIATOR %d\n");
    v68 = *v18;
    mfs_Ling_GetPhonCtxt(*(_QWORD *)(v4 + 8), v12, &v95);
    mfs_Ling_LogPhonCtxt(v84, v19, *(_QWORD *)(v4 + 8), v12);
    if ((int)*a1 >= 1)
      break;
LABEL_64:
    ++v12;
    v19 = v80;
    if (v12 >= *(int *)(v4 + 608))
      goto LABEL_67;
  }
  v82 = v20 + 528 * v12;
  v21 = (uint64_t *)(v82 + 16);
  v69 = (_QWORD *)(v82 + 312);
  v71 = (_QWORD *)(v82 + 80);
  v22 = v13;
  v78 = 2488;
  v77 = 2640;
  v23 = 2;
  v24 = (_DWORD *)v80;
  while (1)
  {
    v79 = v22;
    if (v12)
    {
      v25 = *v21;
      v26 = v67;
      if (v12 != *(_DWORD *)(v4 + 608) - 1)
        *(_DWORD *)(v4 + 2604) += *(_DWORD *)(v25 + 4 * v23) * v24[6];
    }
    else
    {
      v25 = *v21;
      v26 = v67;
    }
    v14 = mfs_FillTgtVect((uint64_t)v24, v4, (uint64_t)__b, *(_DWORD *)(v25 + 4 * v23));
    if ((v14 & 0x80000000) != 0)
      break;
    if ((*(_BYTE *)(*v69 + v23) & 4) != 0)
      v27 = 2.0;
    else
      v27 = 1.0;
    v28 = v24[2056];
    if (HIBYTE(v95) != 1
      || *(_DWORD *)(v80 + 8256) && (v12 && v23 == 2 || v23 == *a1 + 1 && v12 != *(_DWORD *)(v4 + 608) - 1))
    {
      v29 = mfs_VennDiaGrams_Tahoe(v84, (uint64_t)a1, v80, 1, v23, (uint64_t)&v95, *(_DWORD *)(*v71 + 4 * v23), *(_DWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v79 + 16), v27, v28, v15, v79, v68, v26);
      if ((v29 & 0x80000000) != 0)
        return v29;
      if ((*(_BYTE *)(*v69 + v23) & 4) != 0)
      {
        AcousticVector = mfs_VennDiaGrams_Tahoe(v84, (uint64_t)a1, v80, 2, v23, (uint64_t)&v95, *(_DWORD *)(*(_QWORD *)(v82 + 88) + 4 * v23), *(_DWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v79 + 16), v27, v28, v15, v79, v68, v26);
        if ((AcousticVector & 0x80000000) != 0)
          goto LABEL_81;
      }
      v14 = mfs_VennDiaGrams_Tahoe(v84, (uint64_t)a1, v80, 0, v23, (uint64_t)&v95, *(_DWORD *)(v82 + 8), *(_DWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v79 + 16), v27, v28, v15, v79, v68, v26);
      if ((v14 & 0x80000000) != 0)
        break;
    }
    v31 = *(_DWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v79 + 16);
    if (v31 < 0x33)
    {
      v76 = v14;
      v32 = v79;
      v24 = (_DWORD *)v80;
      if (v31)
        goto LABEL_41;
    }
    else
    {
      v32 = v79;
      v33 = (int)(float)(*(float *)(v80 + 8232) * (float)v31);
      if (v28 < v33)
        v33 = v28;
      v24 = (_DWORD *)v80;
      if (v33 <= 50)
        v34 = 50;
      else
        v34 = v33;
      if (v31 == v34)
        goto LABEL_41;
      MFS__log_select_Diag(v84, 1, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
      v35 = mfs_CostList_Sort((uint64_t)v15, v79, 1);
      v14 = v35;
      if ((v35 & 0x80000000) != 0)
        break;
      v76 = v35;
      mfs_CostList_Prune(v15, v79, v34);
      v31 = *(_DWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v79 + 16);
      v32 = v79;
      if (v31)
      {
LABEL_41:
        v36 = 0;
        v37 = v24[2240];
        v74 = v31;
        while (1)
        {
          v85 = 0;
          memset(v97, 0, sizeof(v97));
          v38 = 32 * v32;
          v81 = v36;
          v39 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v32) + 8 * v36);
          AcousticVector = mfs_ParamMap_GetAcousticVector(v84, (uint64_t)a1, v4, v39, (uint64_t)v97, &v85);
          if ((AcousticVector & 0x80000000) != 0)
            break;
          if ((int)v89 <= v85)
            v40 = v85;
          else
            v40 = v89;
          LODWORD(v91) = v40;
          v14 = mfs_S32Vect_Reserve((uint64_t)&v90, v40);
          if ((v14 & 0x80000000) != 0)
            return v14;
          if (*v75)
          {
            v14 = mfs_TCost_CandidateCostStream_kld((uint64_t)__b, (uint64_t)a1, v80, v84, (uint64_t)v97, v85, v39, *(unsigned int *)(*v71 + 4 * v23), v23, (uint64_t)v98);
            if ((v14 & 0x80000000) != 0)
              goto LABEL_86;
          }
          else
          {
            mfs_TCost_CandidateCostStream_Faster((uint64_t)__b, v80, (uint64_t)v97, v85, (uint64_t)v98);
          }
          v76 = v14;
          v41 = *(_QWORD *)(*(_QWORD *)(v4 + 1952) + v38) + 8 * v81;
          v43 = *(float *)(v41 + 4);
          v42 = (_DWORD *)(v41 + 4);
          v44 = v43;
          if (v43 < 0.0)
          {
            *v42 = 0;
            v44 = 0.0;
          }
          v45 = 0;
          v46 = 0.0;
          v48 = v77;
          v47 = v78;
          v24 = (_DWORD *)v80;
          do
          {
            *((_QWORD *)&v100 + 1) = *(_QWORD *)((char *)a1 + v48);
            v99[0] = *(unsigned int *)((char *)a1 + v47);
            v49 = mfs_symData_DistanceOnUid(v84, (uint64_t)a1, v80, (uint64_t)v99, *a1, v39, v23, HIBYTE(v95));
            LeafIndex = mfs_GetLeafIndex(v82, v45, v23);
            if (v83)
            {
              v51 = LeafIndex;
              mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, v39, (uint64_t *)&v86);
              v52 = (float)(v8 * v98[v45])
                  + (float)((float)(v17 * v49)
                          * (float)((float)(mfs_symData_GenreDivergence((uint64_t)a1, v45, v23, v51, v37, *((unsigned __int16 *)v86 + 5))* *(float *)(v80 + 8964))+ 1.0));
            }
            else
            {
              v52 = (float)(v8 * v98[v45]) + (float)(v17 * v49);
            }
            v46 = v46 + v52;
            ++v45;
            v48 += 72;
            v47 += 36;
          }
          while (v45 != 3);
          v4 = v73;
          mfs_ParamMap_UnMapSection(v73);
          v15 = (_QWORD *)v72;
          v32 = v79;
          mfs_CostList_UpdateCost(v72, v79, v81, (float)((float)(v44 * v16) + 1.0) * v46);
          v36 = v81 + 1;
          if (v81 + 1 == v74)
            goto LABEL_59;
        }
LABEL_81:
        v14 = AcousticVector;
        break;
      }
    }
LABEL_59:
    v22 = v32 + 1;
    v77 += 8;
    v78 += 4;
    v53 = v23++ <= (int)*a1;
    v12 = v70;
    v21 = (uint64_t *)(v82 + 16);
    if (!v53)
    {
      v13 = v22;
      v18 = v66;
      v14 = v76;
      goto LABEL_64;
    }
  }
LABEL_86:
  mfs_S32Vect_Clear(v94);
  mfs_TCost_Clear(__b);
  return v14;
}

uint64_t mfs_Search_FindNodeCandidates_StatSelect_Tahoe(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v7;
  int v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  float v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t *v25;
  unsigned int v26;
  uint64_t v27;
  signed int v28;
  unsigned int AcousticVector;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  unsigned int CandVector;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  int IsNodeInList;
  int v51;
  _DWORD *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  signed int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float v62;
  int v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  int v67;
  unsigned int v68;
  int v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  float v75;
  float v76;
  uint64_t v77;
  float v78;
  uint64_t v79;
  uint64_t v80;
  BOOL v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unsigned int v92;
  float v93;
  uint64_t v94;
  int v95;
  int v96;
  uint64_t v97;
  int v98;
  int v99;
  int *v100;
  uint64_t v101;
  int v102;
  const char *v103;
  uint64_t v105;
  unsigned __int8 *v106;
  uint64_t v107;
  int *v108;
  int v109;
  int *v110;
  _QWORD *v111;
  unsigned int v112;
  _QWORD *v113;
  _QWORD *v114;
  unsigned int v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  _DWORD *v119;
  int *v120;
  uint64_t v121;
  uint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  _QWORD *v128;
  int v129;
  unsigned __int8 v130;
  _QWORD *v131;
  int v132;
  uint64_t v133;
  unsigned int v134;
  int v135;
  signed int v136;
  _QWORD *v137;
  uint64_t v138;
  uint64_t v139;
  _OWORD v140[2];
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  _QWORD v153[3];
  __int16 v154;
  unsigned __int8 v155;
  uint64_t v156[2];
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  int v168;
  _DWORD v169[3];
  _BYTE v170[1024];
  float __b[256];
  _DWORD v172[44];
  __int128 v173;
  uint64_t v174;

  v174 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 1928);
  if (*a1 != 3)
  {
    MFS__log_select_Diag(*(_QWORD *)(a2 + 1928), 1, (uint64_t)"CONFIG ERROR : Search is implemented for 3 states only\n");
    return -2065686262;
  }
  v4 = a3;
  v5 = a2;
  v7 = *(float *)(a3 + 8972);
  v155 = 0;
  v154 = 0;
  memset(v153, 0, sizeof(v153));
  memset(v140, 0, sizeof(v140));
  v141 = 0u;
  v142 = 0u;
  v143 = 0u;
  v144 = 0u;
  v145 = 0u;
  v146 = 0u;
  v147 = 0u;
  v148 = 0u;
  v149 = 0u;
  v150 = 0u;
  v151 = 0u;
  v152 = 0u;
  v173 = 0u;
  memset(v172, 0, sizeof(v172));
  cstdlib_memset(__b, 0, 0x400uLL);
  cstdlib_memset(v170, 0, 0x400uLL);
  *(_QWORD *)(v5 + 2192) = 0;
  mfs_S32Vect_Init(v3, v153);
  mfs_TCost_Init(v3, v4, v140);
  v8 = 0;
  v9 = *(float *)(v4 + 8180);
  if (*(_DWORD *)(v4 + 8356) == 1)
  {
    v10 = a1[610];
    if ((int)v10 < 1)
    {
      v8 = 0;
    }
    else
    {
      v11 = 0;
      while (*(_BYTE *)(*((_QWORD *)a1 + 307) + v11) != 31)
      {
        if (v10 == ++v11)
          goto LABEL_12;
      }
      v8 = v11;
    }
    if (v8 == (_DWORD)v10)
    {
LABEL_12:
      MFS__log_select_Diag(v3, 3, (uint64_t)"Can not identify DIFFERENTIATOR ID (%d), please CHECK!\n");
      v8 = 0;
    }
    MFS__log_select_Diag(v3, 3, (uint64_t)"TARGET DIFFERENTIATOR FEATURE ID = %d\n");
  }
  if (*(int *)(v5 + 608) < 1)
  {
    v134 = 0;
LABEL_166:
    if (*(_DWORD *)(v4 + 8564) == 1)
    {
      v93 = *(float *)(v5 + 2616);
      if (v93 == 0.0)
      {
        v103 = "Early emission enabled in pipeline header but no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(v5 + 2608) = (int)((double)*(int *)(v5 + 2604) / (v93 * 0.8 + 1.0));
        MFS__log_select_Diag(v3, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        v94 = *(unsigned int *)(v5 + 608);
        v95 = *(_DWORD *)(v5 + 2596);
        if ((int)v94 >= 2)
        {
          v96 = 0;
          v97 = 1;
          v98 = *(_DWORD *)(v5 + 2596);
          do
          {
            if (v98)
              break;
            v99 = *a1;
            if ((int)*a1 >= 1)
            {
              v100 = (int *)(*(_QWORD *)(*(_QWORD *)(v5 + 600) + 528 * v97 + 16) + 8);
              v101 = *a1;
              do
              {
                v102 = *v100++;
                v96 += v102 * *(_DWORD *)(v4 + 24);
                --v101;
              }
              while (v101);
            }
            ++v97;
            if (v96 >= *(_DWORD *)(v5 + 2608))
            {
              v95 = v99 * v97;
              *(_DWORD *)(v5 + 2596) = v99 * v97;
              v98 = v99 * v97;
            }
            else
            {
              v98 = 0;
            }
          }
          while (v97 != v94);
        }
        if (!v95)
          goto LABEL_185;
        v103 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      v103 = "Early emission not enabled in pipeline header\n";
    }
    MFS__log_select_Diag(v3, 1, (uint64_t)v103);
LABEL_185:
    *(_DWORD *)(v5 + 2200) = 0;
    goto LABEL_186;
  }
  v12 = 0;
  v134 = 0;
  v130 = 0;
  v109 = 0;
  v137 = (_QWORD *)(v5 + 1944);
  v13 = v7 * 0.5;
  v105 = 0;
  v106 = (unsigned __int8 *)&v172[1] + v8;
  v14 = (_QWORD *)(v5 + 1968);
  v119 = (_DWORD *)(v4 + 25288);
  v138 = v5;
  v128 = (_QWORD *)(v5 + 1968);
  v129 = v8;
  v117 = v4;
  v118 = v3;
  while (1)
  {
    v15 = *(_QWORD *)(v5 + 600);
    MFS__log_select_Diag(v3, 3, (uint64_t)"phoneme %d %d %d\n");
    mfs_symData_GetTargetVector((uint64_t)a1, (uint64_t)v172, *(_QWORD *)(v5 + 8), v12);
    if (*(_DWORD *)(v4 + 8356) == 1)
    {
      MFS__log_select_Diag(v3, 3, (uint64_t)"TARGET DIFFERENTIATOR %d\n");
      v130 = *v106;
      v14 = v128;
    }
    mfs_Ling_GetPhonCtxt(*(_QWORD *)(v5 + 8), v12, &v154);
    mfs_Ling_LogPhonCtxt(v3, v4, *(_QWORD *)(v5 + 8), v12);
    LODWORD(v16) = *a1;
    if ((int)*a1 >= 1)
    {
      v17 = 0;
      v18 = v15 + 528 * v12;
      v131 = (_QWORD *)(v18 + 312);
      v111 = (_QWORD *)(v18 + 88);
      v114 = (_QWORD *)(v18 + 16);
      v120 = (int *)(v18 + 8);
      v123 = (_QWORD *)(v18 + 80);
      v19 = (32 * v109) | 0x10;
      while (1)
      {
        v20 = v17;
        if (v12 && v12 != *(_DWORD *)(v138 + 608) - 1)
          *(_DWORD *)(v138 + 2604) += *(_DWORD *)(*v114 + 4 * v17 + 8) * *(_DWORD *)(v4 + 24);
        if ((*(_BYTE *)(*v131 + v17 + 2) & 4) != 0)
          v21 = 2.0;
        else
          v21 = 1.0;
        v136 = *(_DWORD *)(v4 + 8224);
        v169[v17] = 0;
        if (HIBYTE(v154) != 1)
        {
LABEL_38:
          v23 = v12;
          v24 = *(_DWORD *)(*(_QWORD *)(v138 + 1952) + v19);
          v25 = *(uint64_t **)(v138 + 2640);
          if (!v25
            || (v26 = v109 + v20 + *((_DWORD *)v25 + 5), LODWORD(v157) = 0, v27 = *v25, *(_DWORD *)(v27 + 48 * v26))
            || (v30 = *(_DWORD *)(v27 + 48 * v26 + 24)) == 0
            || (v31 = *(_DWORD *)(*(_QWORD *)(v27 + 48 * v26 + 8) + 4 * (v30 - 1)), v31 >= a1[274] - 1)
            || (v32 = mfs_CostList_Add((uint64_t)a1, v137, v109 + (int)v20, v31, *((_QWORD *)a1 + 298), a1[598], (unsigned int *)&v157, v21), (v32 & 0x80000000) != 0))
          {
            v28 = v109 + v20;
            AcousticVector = mfs_VennDiaGrams_Tahoe(v3, (uint64_t)a1, v4, 1, (int)v20 + 2, (uint64_t)&v154, *(_DWORD *)(*v123 + 4 * v20 + 8), v24, v21, v136, v137, v109 + (int)v20, v130, v129);
            if ((AcousticVector & 0x80000000) != 0
              || (*(_BYTE *)(*v131 + v20 + 2) & 4) != 0
              && (AcousticVector = mfs_VennDiaGrams_Tahoe(v3, (uint64_t)a1, v4, 2, (int)v20 + 2, (uint64_t)&v154, *(_DWORD *)(*v111 + 4 * v20 + 8), *(_DWORD *)(*(_QWORD *)(v138 + 1952) + v19), v21, v136, v137, v28, v130, v129), (AcousticVector & 0x80000000) != 0))
            {
LABEL_180:
              v134 = AcousticVector;
              goto LABEL_186;
            }
            v12 = v23;
            v134 = mfs_VennDiaGrams_Tahoe(v3, (uint64_t)a1, v4, 0, (int)v20 + 2, (uint64_t)&v154, *v120, *(_DWORD *)(*(_QWORD *)(v138 + 1952) + v19), v21, v136, v137, v28, v130, v129);
            if ((v134 & 0x80000000) != 0)
              goto LABEL_186;
          }
          else
          {
            v134 = v32;
            v169[v20] = 1;
            v12 = v23;
          }
          goto LABEL_44;
        }
        if (v17 != 1 && *(_DWORD *)(v4 + 8256))
        {
          if (v17)
          {
            if (v17 + 2 != (_DWORD)v16 + 1)
              goto LABEL_38;
            if (v12 == *(_DWORD *)(v138 + 608) - 1 || v155 == 1)
              goto LABEL_44;
            v22 = v154;
          }
          else
          {
            if (!v12 || v154 == 1)
              goto LABEL_44;
            v22 = v155;
          }
          if (v22 != 1)
            goto LABEL_38;
        }
LABEL_44:
        v16 = (int)*a1;
        v19 += 32;
        v17 = v20 + 1;
        if (v20 + 2 > v16)
        {
          v109 += v17;
          v5 = v138;
          v14 = v128;
          goto LABEL_51;
        }
      }
    }
    v136 = *(_DWORD *)(v4 + 8224);
LABEL_51:
    v107 = v12;
    if (HIBYTE(v154) != 1)
    {
      if ((int)v16 >= -1)
        v33 = v16 + 1;
      else
        v33 = v16 + 2;
      v34 = (v109 - (v33 >> 1));
      v139 = 0;
      v35 = *(_QWORD *)(v5 + 1976);
      *(_DWORD *)(v35 + 208) = 0;
      *(_DWORD *)(v35 + 240) = 0;
      v36 = (v34 - 1);
      v37 = (v34 + 1);
      v38 = *(_QWORD *)(v5 + 1952);
      v39 = *(unsigned int *)(v38 + 32 * v34 + 16);
      v40 = v36;
      v121 = v34;
      v124 = v37;
      if ((_DWORD)v39)
      {
        v41 = 0;
        v135 = v169[0];
        v132 = v169[2];
        v115 = *(_DWORD *)(v38 + 32 * v37 + 16);
        v112 = *(_DWORD *)(v38 + 32 * v36 + 16);
        v126 = 8 * v39;
        while (1)
        {
          v168 = 0;
          v166 = 0u;
          v167 = 0u;
          v164 = 0u;
          v165 = 0u;
          v162 = 0u;
          v163 = 0u;
          v160 = 0u;
          v161 = 0u;
          v158 = 0u;
          v159 = 0u;
          v157 = 0u;
          v156[0] = (uint64_t)&v157;
          v42 = *(_QWORD *)(v5 + 1952);
          v43 = 32 * v34;
          v44 = *(_DWORD *)(*(_QWORD *)(v42 + 32 * v34) + v41);
          CandVector = mfs_symData_GetCandVector(v3, (uint64_t)a1, v4, *a1, v44, 3, v156);
          v46 = CandVector;
          if ((CandVector & 0x80000000) != 0)
          {
            v134 = CandVector;
            goto LABEL_186;
          }
          if (v135)
            goto LABEL_64;
          v47 = CandVector;
          if ((v112 < 0x64 || *(unsigned __int8 *)v156[0] == v154)
            && !mfs_CostList_IsNodeInList((uint64_t)v137, v36, v44 - 1, (uint64_t)a1, (unsigned int *)&v139))
          {
            if (!mfs_CostList_IsNodeInList((uint64_t)v128, 0, v44 - 1, (uint64_t)a1, (unsigned int *)&v139))
            {
              IsNodeInList = mfs_CostList_IsNodeInList((uint64_t)v128, 1u, v44 - 1, (uint64_t)a1, (unsigned int *)&v139);
              v46 = v47;
              v36 = v40;
              v34 = v121;
              if (!IsNodeInList)
                v46 = mfs_CostList_Pad((uint64_t)a1, v128, 6u, v44 - 1, *((_QWORD *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(_QWORD *)(*(_QWORD *)(v138 + 1952) + v43) + v41 + 4));
              goto LABEL_64;
            }
            v46 = v47;
            v36 = v40;
          }
          else
          {
            v46 = v47;
          }
          v34 = v121;
LABEL_64:
          if (!v132)
          {
            v48 = v46;
            if ((v115 < 0x64 || *(unsigned __int8 *)(v156[0] + 2) == v155)
              && (v49 = v44 + 1,
                  !mfs_CostList_IsNodeInList((uint64_t)v137, v124, v49, (uint64_t)a1, (unsigned int *)&v139)))
            {
              if (mfs_CostList_IsNodeInList((uint64_t)v128, 4u, v49, (uint64_t)a1, (unsigned int *)&v139))
              {
                v46 = v48;
                v36 = v40;
              }
              else
              {
                v51 = mfs_CostList_IsNodeInList((uint64_t)v128, 5u, v49, (uint64_t)a1, (unsigned int *)&v139);
                v46 = v48;
                v36 = v40;
                if (!v51)
                  v46 = mfs_CostList_Pad((uint64_t)a1, v128, 7u, v49, *((_QWORD *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(_QWORD *)(*(_QWORD *)(v138 + 1952) + v43) + v41 + 4));
              }
            }
            else
            {
              v46 = v48;
            }
          }
          v41 += 8;
          v5 = v138;
          if (v126 == v41)
          {
            v134 = v46;
            v35 = *(_QWORD *)(v138 + 1976);
            if (*(_DWORD *)(v35 + 208))
            {
              v14 = v128;
              mfs_ConcatTwoLists(v128, 1u, (uint64_t)v128, 6u);
              v35 = *(_QWORD *)(v138 + 1976);
              v12 = v107;
            }
            else
            {
              v12 = v107;
              v14 = v128;
            }
            v37 = v124;
            break;
          }
        }
      }
      if (*(_DWORD *)(v35 + 240))
      {
        mfs_ConcatTwoLists(v14, 5u, (uint64_t)v14, 7u);
        v37 = v124;
        v35 = *(_QWORD *)(v5 + 1976);
      }
      LODWORD(v139) = 0;
      *(_DWORD *)(v35 + 208) = 0;
      v52 = (_DWORD *)(v35 + 208);
      if (v169[1])
      {
        *v52 = 0;
      }
      else
      {
        v82 = *(unsigned int *)(*(_QWORD *)(v5 + 1952) + 32 * v36 + 16);
        if ((_DWORD)v82)
        {
          v83 = 0;
          v84 = 8 * v82;
          do
          {
            v85 = 32 * v36;
            v86 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + v85) + v83) + 1;
            if (!mfs_CostList_IsNodeInList((uint64_t)v137, v34, v86, (uint64_t)a1, (unsigned int *)&v139))
            {
              if (mfs_CostList_IsNodeInList((uint64_t)v128, 2u, v86, (uint64_t)a1, (unsigned int *)&v139))
              {
                LODWORD(v34) = v121;
              }
              else
              {
                LODWORD(v34) = v121;
                if (!mfs_CostList_IsNodeInList((uint64_t)v128, 3u, v86, (uint64_t)a1, (unsigned int *)&v139))v134 = mfs_CostList_Pad((uint64_t)a1, v128, 6u, v86, *((_QWORD *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + v85) + v83 + 4) * 20.0);
              }
            }
            v83 += 8;
            v36 = v40;
          }
          while (v84 != v83);
          v87 = *(_QWORD *)(v5 + 1976);
          if (*(_DWORD *)(v87 + 208))
          {
            v14 = v128;
            mfs_ConcatTwoLists(v128, 3u, (uint64_t)v128, 6u);
            v87 = *(_QWORD *)(v5 + 1976);
            v12 = v107;
          }
          else
          {
            v12 = v107;
            v14 = v128;
          }
          LODWORD(v139) = 0;
          v52 = (_DWORD *)(v87 + 208);
          v37 = v124;
        }
        *v52 = 0;
        v88 = *(unsigned int *)(*(_QWORD *)(v5 + 1952) + 32 * v37 + 16);
        if ((_DWORD)v88)
        {
          v89 = 0;
          v90 = 8 * v88;
          do
          {
            v91 = 32 * v37;
            v92 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + 32 * v37) + v89) - 1;
            if (!mfs_CostList_IsNodeInList((uint64_t)v137, v34, v92, (uint64_t)a1, (unsigned int *)&v139))
            {
              if (mfs_CostList_IsNodeInList((uint64_t)v128, 2u, v92, (uint64_t)a1, (unsigned int *)&v139))
              {
                LODWORD(v34) = v121;
              }
              else
              {
                LODWORD(v34) = v121;
                if (!mfs_CostList_IsNodeInList((uint64_t)v128, 3u, v92, (uint64_t)a1, (unsigned int *)&v139))v134 = mfs_CostList_Pad((uint64_t)a1, v128, 6u, v92, *((_QWORD *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + v91) + v89 + 4) * 20.0);
              }
            }
            v89 += 8;
            v37 = v124;
          }
          while (v90 != v89);
          if (!*(_DWORD *)(*(_QWORD *)(v5 + 1976) + 208))
          {
            v12 = v107;
            v53 = v137;
            v14 = v128;
LABEL_88:
            LODWORD(v16) = *a1;
            if ((int)*a1 >= 1)
            {
              v54 = v12;
              v55 = 0;
              v56 = 1;
              v57 = 1;
              do
              {
                v58 = *(_QWORD *)(v5 + 1976);
                if (*(_DWORD *)(v58 + (v55 >> 27) + 16))
                {
                  mfs_ConcatTwoLists(v53, v40 + v56 - 1, (uint64_t)v128, v57 - 1);
                  v58 = *(_QWORD *)(v5 + 1976);
                }
                if (*(_DWORD *)(v58 + 32 * v57 + 16))
                  mfs_ConcatTwoLists(v53, v40 + v56 - 1, (uint64_t)v128, v57);
                v16 = (int)*a1;
                ++v56;
                v57 += 2;
                v55 += 0x200000000;
              }
              while (v56 <= v16);
              v12 = v54;
              v14 = v128;
            }
            goto LABEL_96;
          }
          v14 = v128;
          mfs_ConcatTwoLists(v128, 3u, (uint64_t)v128, 6u);
          v12 = v107;
        }
      }
      v53 = v137;
      goto LABEL_88;
    }
LABEL_96:
    if ((int)v16 >= 1)
      break;
    v109 -= v16;
LABEL_140:
    if (++v12 >= *(int *)(v5 + 608))
      goto LABEL_166;
  }
  v59 = v109 - (int)v16;
  v127 = 2488;
  v125 = 2640;
  v60 = 2;
  while (1)
  {
    v61 = *(_QWORD *)(v5 + 600);
    v134 = mfs_FillTgtVect(v4, v5, (uint64_t)v140, *(_DWORD *)(*(_QWORD *)(v61 + 528 * v12 + 16) + 4 * v60));
    if ((v134 & 0x80000000) != 0)
      break;
    if ((_DWORD)v60 == 4)
    {
      if (!mfs_Ling_IsSilence(v4, *(_QWORD *)(v5 + 8), v12))
      {
        v64 = v61 + 528 * v12;
        v65 = v105;
        v66 = v5 + 4 * v105;
        *(_DWORD *)(v66 + 3468) = *(_DWORD *)(v64 + 24);
        v67 = *(_DWORD *)(v64 + 28);
        if (v105 < 0x190)
          v65 = v105 + 1;
        LODWORD(v105) = v65;
        if (!v67)
          v67 = 1;
        *(_DWORD *)(v66 + 5072) = v67;
      }
    }
    else if ((_DWORD)v60 == 3 && mfs_Ling_IsVowel(v4, *(_QWORD *)(v5 + 8), v12))
    {
      v62 = fmaxf(*(float *)v141, 0.0);
      v63 = HIDWORD(v105);
      if (HIDWORD(v105) < 0xC8)
        v63 = HIDWORD(v105) + 1;
      *(float *)(v5 + 4 * HIDWORD(v105) + 2664) = v62;
      HIDWORD(v105) = v63;
    }
    v68 = *(_DWORD *)(*(_QWORD *)(v5 + 1952) + 32 * v59 + 16);
    if (v68 >= 0x33)
    {
      v69 = (int)(float)(*(float *)(v4 + 8232) * (float)v68);
      if (v136 < v69)
        v69 = v136;
      if (v69 <= 50)
        v70 = 50;
      else
        v70 = v69;
      if (v68 == v70)
      {
LABEL_121:
        v71 = v61 + 528 * v107;
        v72 = 0;
        v113 = (_QWORD *)(v71 + 80);
        v108 = (int *)(v71 + 28);
        v110 = (int *)(v71 + 24);
        v116 = v68;
        v122 = v59;
        while (1)
        {
          HIDWORD(v139) = 0;
          v160 = 0u;
          v161 = 0u;
          v158 = 0u;
          v159 = 0u;
          v157 = 0u;
          v73 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + 32 * v59) + 8 * v72);
          AcousticVector = mfs_ParamMap_GetAcousticVector(v3, (uint64_t)a1, v5, v73, (uint64_t)&v157, (int *)&v139 + 1);
          if ((AcousticVector & 0x80000000) != 0)
            goto LABEL_180;
          if ((int)v148 <= SHIDWORD(v139))
            v74 = HIDWORD(v139);
          else
            v74 = v148;
          LODWORD(v150) = v74;
          v134 = mfs_S32Vect_Reserve((uint64_t)&v149, v74);
          if ((v134 & 0x80000000) != 0)
            goto LABEL_186;
          if (*v119)
          {
            v134 = mfs_TCost_CandidateCostStream_kld((uint64_t)v140, (uint64_t)a1, v4, v3, (uint64_t)&v157, SHIDWORD(v139), v73, *(unsigned int *)(*v113 + 4 * v60), v60, (uint64_t)v156);
            if ((v134 & 0x80000000) != 0)
              goto LABEL_186;
          }
          else
          {
            mfs_TCost_CandidateCostStream_Faster((uint64_t)v140, v4, (uint64_t)&v157, SHIDWORD(v139), (uint64_t)v156);
          }
          v75 = *(float *)(*(_QWORD *)(*(_QWORD *)(v5 + 1952) + 32 * v59) + 8 * v72 + 4);
          mfs_symData_DistanceOnUid_PreCalc(v3, (uint64_t)a1, v4, (uint64_t)v172, *a1, v73, v60, HIBYTE(v154), (uint64_t)__b, (uint64_t)v170);
          v76 = 0.0;
          v133 = v72;
          if (*(_DWORD *)(v4 + 8272) && HIBYTE(v154) != 1)
            v76 = (float)(int)CandidatePhonemeDurationDistance((uint64_t)a1, v73, v60, *v110, *v108) * 0.01 + 0.0;
          v77 = 0;
          v78 = (float)(v75 * v13) + 1.0;
          v80 = v125;
          v79 = v127;
          v4 = v117;
          v3 = v118;
          do
          {
            *((_QWORD *)&v173 + 1) = *(_QWORD *)((char *)a1 + v80);
            v172[0] = *(unsigned int *)((char *)a1 + v79);
            v76 = v76
                + (float)((float)(v9 * *(float *)((char *)v156 + v77))
                        + (float)((float)(1.0 - v9)
                                * mfs_symData_DistanceOnUid_Tahoe(v118, (uint64_t)a1, v117, (uint64_t)v172, *a1, v73, v60, HIBYTE(v154), __b)));
            v77 += 4;
            v80 += 72;
            v79 += 36;
          }
          while (v77 != 12);
          v5 = v138;
          mfs_ParamMap_UnMapSection(v138);
          v59 = v122;
          mfs_CostList_UpdateCost((uint64_t)v137, v122, v133, v78 * v76);
          v72 = v133 + 1;
          if (v133 + 1 == v116)
            goto LABEL_137;
        }
      }
      MFS__log_select_Diag(v3, 1, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
      v134 = mfs_CostList_Sort((uint64_t)v137, v59, 1);
      if ((v134 & 0x80000000) != 0)
        break;
      mfs_CostList_Prune(v137, v59, v70);
      v68 = *(_DWORD *)(*(_QWORD *)(v5 + 1952) + 32 * v59 + 16);
    }
    if (v68)
      goto LABEL_121;
LABEL_137:
    ++v59;
    v125 += 8;
    v127 += 4;
    v81 = v60++ <= (int)*a1;
    v12 = v107;
    if (!v81)
    {
      v109 = v59;
      v14 = v128;
      goto LABEL_140;
    }
  }
LABEL_186:
  mfs_S32Vect_Clear(v153);
  mfs_TCost_Clear(v140);
  return v134;
}

uint64_t mfs_Search_FindNodeCandidates(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  _BOOL4 IsBoundary;
  uint64_t v11;
  _BOOL4 v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  _BOOL4 v16;
  int v17;
  uint64_t v18;
  int IsPerceptualInvariantState;
  int v20;
  uint64_t AcousticVector;
  uint64_t v23;
  float v24;
  _QWORD *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  signed int v32;
  unsigned int v33;
  char v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  int v40;
  signed int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unsigned int v53;
  float v54;
  float v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  int v60;
  int v61;
  int *v62;
  uint64_t v63;
  int v64;
  const char *v65;
  _QWORD *v67;
  uint64_t *v68;
  uint64_t v69;
  unsigned int v70;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  int *v74;
  signed int v75;
  _QWORD *v76;
  int v77;
  int v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  _QWORD *v84;
  int v85;
  unsigned __int8 *v86;
  _QWORD v87[2];
  unsigned int v88;
  _OWORD v89[9];
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  uint64_t *__b[20];
  _QWORD v96[3];
  __int16 v97;
  char v98;
  _BYTE v99[88];
  uint64_t v100;

  v100 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a2 + 1928);
  v98 = 0;
  v97 = 0;
  memset(v96, 0, sizeof(v96));
  v94 = 0u;
  memset(__b, 0, 152);
  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  memset(v89, 0, sizeof(v89));
  v88 = 0;
  v87[0] = 0;
  v87[1] = 0;
  v86 = (unsigned __int8 *)v87;
  *(_QWORD *)(a2 + 2192) = 0;
  mfs_Harch_Init(v6, __b);
  mfs_S32Vect_Init(v6, v96);
  mfs_TCost_Init(v6, a3, v89);
  if (*(int *)(a2 + 608) < 1)
  {
    v11 = 0;
LABEL_94:
    if (*(_DWORD *)(a3 + 8564) == 1)
    {
      v55 = *(float *)(a2 + 2616);
      if (v55 == 0.0)
      {
        v65 = "Early emission configured in pipeline header, no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(a2 + 2608) = (int)((double)*(int *)(a2 + 2604) / (v55 * 0.8 + 1.0));
        MFS__log_select_Diag(v6, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        v56 = *(unsigned int *)(a2 + 608);
        v57 = *(_DWORD *)(a2 + 2596);
        if ((int)v56 >= 2)
        {
          v58 = 0;
          v59 = 1;
          v60 = *(_DWORD *)(a2 + 2596);
          do
          {
            if (v60)
              break;
            v61 = *a1;
            if ((int)*a1 >= 1)
            {
              v62 = (int *)(*(_QWORD *)(*(_QWORD *)(a2 + 600) + 528 * v59 + 16) + 8);
              v63 = *a1;
              do
              {
                v64 = *v62++;
                v58 += v64 * *(_DWORD *)(a3 + 24);
                --v63;
              }
              while (v63);
            }
            ++v59;
            if (v58 >= *(_DWORD *)(a2 + 2608))
            {
              v57 = v61 * v59;
              *(_DWORD *)(a2 + 2596) = v61 * v59;
              v60 = v61 * v59;
            }
            else
            {
              v60 = 0;
            }
          }
          while (v59 != v56);
        }
        if (!v57)
          goto LABEL_112;
        v65 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      v65 = "Early emission not configured in pipeline header\n";
    }
    MFS__log_select_Diag(v6, 1, (uint64_t)v65);
LABEL_112:
    if (*(int *)(a2 + 2192) < 5 || *(int *)(a2 + 2196) <= 4)
      *(_DWORD *)(a2 + 2200) = 0;
    goto LABEL_115;
  }
  v7 = 0;
  v82 = 0;
  v84 = (_QWORD *)(a2 + 1944);
  v8 = (uint64_t *)(a1 + 486);
  while (1)
  {
    v9 = *(_QWORD *)(a2 + 600);
    MFS__log_select_Diag(v6, 3, (uint64_t)"phoneme %d\n");
    mfs_Ling_GetPhonCtxt(*(_QWORD *)(a2 + 8), v7, &v97);
    mfs_Ling_LogPhonCtxt(v6, a3, *(_QWORD *)(a2 + 8), v7);
    IsBoundary = mfs_Harch_IsBoundary((uint64_t)__b, 1u);
    v11 = mfs_Harch_Search(v6, v8, __b, a2, v7);
    if ((v11 & 0x80000000) != 0)
      break;
    MFS__log_select_Diag(v6, 3, (uint64_t)"\n");
    v12 = IsBoundary && mfs_Ling_IsVowelVowelTrans(a3, *(_QWORD *)(a2 + 8), v7)
       || mfs_Harch_FewCands((int *)__b);
    mfs_Harch_FewCands((int *)__b);
    v78 = v12;
    MFS__log_select_Diag(v6, 3, (uint64_t)"wordbound(%d) breakwords(%d) few(%d)\n");
    v70 = mfs_Ling_IsVowel(a3, *(_QWORD *)(a2 + 8), v7);
    if ((int)*a1 >= 1)
    {
      v13 = (int *)(v9 + 528 * v7);
      v76 = v13 + 4;
      v79 = v13 + 78;
      v67 = v13 + 22;
      v68 = v8;
      v71 = v13 + 84;
      v72 = v13 + 86;
      v14 = v82;
      v15 = 2;
      v81 = v6;
      v73 = a3;
      v74 = v13;
      v69 = v7;
      while (1)
      {
        v83 = v14;
        if (v7 && v7 != *(_DWORD *)(a2 + 608) - 1)
          *(_DWORD *)(a2 + 2604) += *(_DWORD *)(*v76 + 4 * v15) * *(_DWORD *)(a3 + 24);
        v16 = (*(_BYTE *)(*v79 + v15) & 4) == 0;
        v17 = *(_DWORD *)(a3 + 8656);
        v18 = v15;
        IsPerceptualInvariantState = mfs_IsPerceptualInvariantState(a3, a2, v13);
        if (v17)
          v20 = IsPerceptualInvariantState | v16;
        else
          v20 = IsPerceptualInvariantState & v16;
        v80 = v18;
        if (v20)
        {
          if (mfs_ProbSynthNoDegradation(a2, *(_DWORD *)(*v76 + 4 * v18)) == 0.0 && HIBYTE(v97) != 1)
          {
            MFS__log_select_Diag(v6, 3, (uint64_t)"F0 low -> made made Variant !\n");
            v20 = 0;
          }
        }
        AcousticVector = mfs_FillTgtVect(a3, a2, (uint64_t)v89, *(_DWORD *)(*v76 + 4 * v18));
        if ((AcousticVector & 0x80000000) != 0)
        {
LABEL_108:
          v11 = AcousticVector;
          goto LABEL_115;
        }
        v23 = 8224;
        if (v20)
          v23 = 8228;
        v24 = 0.009901;
        v25 = (_QWORD *)(a2 + 1944);
        if (v78)
        {
          if (v20)
          {
            v24 = *(float *)(a3 + 8164);
          }
          else
          {
            v24 = 0.047619;
            if (!v70)
              v24 = *(float *)(a3 + 8168);
          }
        }
        v26 = *(_DWORD *)(a3 + v23);
        if ((*(_BYTE *)(*v79 + v80) & 4) != 0)
          ++*(_DWORD *)(a2 + 2192);
        else
          ++*(_DWORD *)(a2 + 2196);
        v75 = v26;
        mfs_loc_AddMainCandidates(v6, (uint64_t)a1, (_DWORD *)a3, v13, v80, v84, v83, v26, v24, v78, v20, (unsigned __int8 *)&v97, __b, (uint64_t)v96, 1);
        v27 = *(_QWORD *)(a2 + 1952);
        v77 = v20;
        if (v20)
          break;
        v28 = v80;
        if ((*(_BYTE *)(*v79 + v80) & 4) == 0)
          goto LABEL_55;
        v29 = *(_DWORD *)(v27 + 32 * v83 + 16);
        v30 = *(_DWORD *)(a3 + 8944);
        v31 = v78;
        v32 = v75;
        if (v29 < v30)
        {
          if ((int)v30 >= v75)
            v33 = v75;
          else
            v33 = *(_DWORD *)(a3 + 8944);
          v34 = v78 ^ 1;
          if (*(_DWORD *)(a3 + 8788))
            v34 = 1;
          if ((v34 & 1) == 0)
          {
            AcousticVector = mfs_IbAddtoVect(v6, (uint64_t)a1, a3, 0, 2, v80, *(_DWORD *)(*v67 + 4 * v80), v29, v24, 0.8, 0.25, v33, v84, v83, (unsigned __int8 *)&v97, 0);
            if ((AcousticVector & 0x80000000) != 0)
              goto LABEL_108;
            v27 = *(_QWORD *)(a2 + 1952);
            v25 = (_QWORD *)(a2 + 1944);
            v28 = v80;
            v32 = v75;
            v31 = v78;
          }
          if (*(_DWORD *)(a3 + 8792))
          {
            v35 = *(_DWORD *)(v27 + 32 * v83 + 16) - v29;
            if (v35 <= 0xC7 && v35 < v33)
            {
              if (*(int *)(*v72 + 4 * v28) >= 1)
              {
                v36 = 0;
                while (1)
                {
                  v37 = v28;
                  AcousticVector = mfs_IbAddtoVect(v6, (uint64_t)a1, a3, 0, 2, v28, *(_DWORD *)(*(_QWORD *)(*v71 + 8 * v28) + 4 * v36), v29, v24, 0.8, 0.25, v33, v25, v83, (unsigned __int8 *)&v97, 0);
                  if ((AcousticVector & 0x80000000) != 0)
                    goto LABEL_108;
                  ++v36;
                  v25 = (_QWORD *)(a2 + 1944);
                  v28 = v37;
                  if (v36 >= *(int *)(*v72 + 4 * v37))
                  {
                    v20 = v77;
                    break;
                  }
                }
              }
              MFS__log_select_Diag(v6, 3, (uint64_t)"@@@@@@@@@@@@ BACKOFF %lu\n");
              v27 = *(_QWORD *)(a2 + 1952);
              LODWORD(v28) = v80;
              goto LABEL_55;
            }
          }
        }
LABEL_56:
        v38 = (int)(float)(*(float *)(a3 + 8232) * (float)*(unsigned int *)(v27 + 32 * v83 + 16));
        if (v32 < v38)
          v38 = v32;
        if (v38 <= 1)
          v39 = 1;
        else
          v39 = v38;
        if (v39 < 0x28)
          v40 = v31;
        else
          v40 = 0;
        if (!v20 && v40)
        {
          v41 = v32;
          mfs_loc_AddMainCandidates(v6, (uint64_t)a1, (_DWORD *)a3, v74, v28, v25, v83, v32, 0.0, v31, 0, (unsigned __int8 *)&v97, 0, (uint64_t)v96, 0);
          v27 = *(_QWORD *)(a2 + 1952);
          v42 = (int)(float)(*(float *)(a3 + 8232) * (float)*(unsigned int *)(v27 + 32 * v83 + 16));
          if (v41 < v42)
            v42 = v41;
          if (v42 <= 1)
            v39 = 1;
          else
            v39 = v42;
        }
        if (*(_DWORD *)(a3 + 8948))
        {
          v43 = v83 - 1;
          if (*(_DWORD *)(v27 + 32 * (v83 - 1) + 16))
          {
            v44 = 0;
            v45 = 0;
            do
            {
              v46 = *(_DWORD *)(*(_QWORD *)(v27 + 32 * v43) + v44) + 1;
              mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, v46, (uint64_t *)&v86);
              if (mfs_PhoneticContextCost(v86 + 12, (unsigned __int8 *)&v97, 1.0) <= 0.5)
              {
                v47 = mfs_CostList_Add((uint64_t)a1, v25, v83, v46, *((_QWORD *)a1 + 298), a1[598], &v88, (float)(1000.0 - *(float *)v86) + 100.0);
                if ((v47 & 0x80000000) != 0)
                {
                  v11 = v47;
                  if ((v47 & 0x1FFF) != 2)
                    goto LABEL_115;
                  v25 = (_QWORD *)(a2 + 1944);
                  mfs_CostList_UpdateCost((uint64_t)v84, v83, v88, *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 1952) + 32 * v83) + 8 * v88 + 4) - *(float *)v86);
                }
                else
                {
                  ++v39;
                  MFS__log_select_Diag(v81, 3, (uint64_t)"CostList %lu, backfilled tri-phone %lu\n");
                  v25 = (_QWORD *)(a2 + 1944);
                }
              }
              ++v45;
              v27 = *(_QWORD *)(a2 + 1952);
              v44 += 8;
            }
            while (v45 < *(unsigned int *)(v27 + 32 * v43 + 16));
          }
        }
        v6 = v81;
        MFS__log_select_Diag(v81, 3, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
        v48 = mfs_CostList_Sort((uint64_t)v25, v83, 1);
        v49 = v25;
        v11 = v48;
        if ((v48 & 0x80000000) != 0)
          goto LABEL_115;
        mfs_CostList_Prune(v49, v83, v39);
        v50 = *(_QWORD *)(a2 + 1952);
        a3 = v73;
        if (*(_DWORD *)(v50 + 32 * v83 + 16))
        {
          v51 = 0;
          v52 = 0;
          do
          {
            v85 = 0;
            memset(v99, 0, 80);
            AcousticVector = mfs_ParamMap_GetAcousticVector(v81, (uint64_t)a1, a2, *(unsigned int *)(*(_QWORD *)(v50 + 32 * v83) + v51), (uint64_t)v99, &v85);
            if ((AcousticVector & 0x80000000) != 0)
              goto LABEL_108;
            if ((int)v90 <= v85)
              v53 = v85;
            else
              v53 = v90;
            LODWORD(v92) = v53;
            v11 = mfs_S32Vect_Reserve((uint64_t)&v91, v53);
            if ((v11 & 0x80000000) != 0)
              return v11;
            v54 = mfs_TCost_CandidateCost((uint64_t)v89, v73, (uint64_t)v99, v85);
            mfs_ParamMap_UnMapSection(a2);
            mfs_CostList_UpdateCost((uint64_t)v84, v83, v52++, v54);
            v50 = *(_QWORD *)(a2 + 1952);
            v51 += 8;
          }
          while (v52 < *(unsigned int *)(v50 + 32 * v83 + 16));
        }
        v14 = v83 + 1;
        v15 = v80 + 1;
        v8 = v68;
        v7 = v69;
        v13 = v74;
        if (v80 > (int)*a1)
        {
          v82 = v83 + 1;
          goto LABEL_91;
        }
      }
      LODWORD(v28) = v80;
LABEL_55:
      v32 = v75;
      v31 = v78;
      goto LABEL_56;
    }
LABEL_91:
    if (++v7 >= *(int *)(a2 + 608))
      goto LABEL_94;
  }
LABEL_115:
  mfs_Harch_DeInit((uint64_t)__b);
  mfs_S32Vect_Clear(v96);
  mfs_TCost_Clear(v89);
  return v11;
}

uint64_t mfs_Search_SparseDP(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unsigned int LogLevel;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  int v36;
  float v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  uint64_t v44;
  int *v45;
  uint64_t v46;
  int v47;
  int v49;
  uint64_t *v50;
  uint64_t *v51;
  unsigned int v52;
  uint64_t v53;
  int v54;
  _OWORD v55[5];
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(a2 + 1928);
  v9 = (uint64_t *)(a2 + 2112);
  v10 = (_QWORD *)(a2 + 2168);
  v11 = *(_DWORD *)(a1 + 1096);
  if (*(_DWORD *)(a2 + 2592) == 1)
  {
    v12 = *(_QWORD *)(a2 + 2624);
    *(_QWORD *)(a2 + 2624) = 0;
    mfs_SegmentList_DeInit((_QWORD *)(a2 + 2248));
    v13 = mfs_SegmentList_Init(v8, a1, a2 + 2248);
    if ((v13 & 0x80000000) != 0)
      return v13;
    mfs_SegmentList_DeInit((_QWORD *)(a2 + 2208));
    v13 = mfs_SegmentList_Init(v8, a1, a2 + 2208);
    if ((v13 & 0x80000000) != 0)
      return v13;
    mfs_UnitSequence_DeInit((uint64_t)v9);
    v13 = mfs_UnitSequence_Init(v8, v9, a1);
    if ((v13 & 0x80000000) != 0)
      return v13;
  }
  else
  {
    v15 = (unsigned int *)heap_Calloc(*(_QWORD **)(v8 + 8), 1, 136);
    if (!v15)
    {
      mfs_F32Vect_Clear(v10);
      return 0;
    }
    v12 = (uint64_t)v15;
    v16 = mfs_Viterbi_Init(a1, a2, a4, v15);
    if ((v16 & 0x80000000) != 0)
    {
      v14 = v16;
      mfs_F32Vect_Clear(v10);
      goto LABEL_89;
    }
  }
  v17 = mfs_S32Vect_Reserve(a2 + 2144, *(_DWORD *)(a2 + 1936));
  if ((v17 & 0x80000000) != 0)
    goto LABEL_87;
  v17 = mfs_F32Vect_Create((uint64_t)v10, *(_DWORD *)(a2 + 1936));
  if ((v17 & 0x80000000) != 0)
    goto LABEL_87;
  v53 = a3;
  v18 = v11 - 1;
  if (*(int *)(a2 + 1936) >= 1)
  {
    v19 = 0;
    do
    {
      v17 = mfs_F32Vect_Pad((uint64_t)v10, 0.0);
      if ((v17 & 0x80000000) != 0)
        goto LABEL_87;
      mfs_S32Vect_Add(a2 + 2144, v18);
    }
    while (++v19 < *(_DWORD *)(a2 + 1936));
  }
  v20 = *(_DWORD *)(a2 + 2592);
  if (v20)
    goto LABEL_15;
  MFS__log_select_Diag(v8, 3, (uint64_t)"path_len = %dL %d : %d\n");
  MFS__log_select_Diag(v8, 3, (uint64_t)"viterbi::begin_with_early_emission\n");
  v17 = mfs_Viterbi_Reset(v12, **(_DWORD **)(a2 + 2000), *(_DWORD *)(*(_QWORD *)(a2 + 2000) + 4));
  if ((v17 & 0x80000000) != 0)
    goto LABEL_87;
  v25 = *(_DWORD *)(a2 + 2064);
  if (v25 == 1)
  {
    v17 = mfs_Viterbi_Decode_MCP_S9_LF0_S8(v12);
    if ((v17 & 0x80000000) != 0)
      goto LABEL_87;
  }
  else if (v25 == 2)
  {
    v17 = mfs_Viterbi_Decode_MCP_S9_LF0_S8_X2B(v12);
    if ((v17 & 0x80000000) != 0)
      goto LABEL_87;
  }
  else
  {
    v17 = mfs_Viterbi_Decode(v12);
    if ((v17 & 0x80000000) != 0)
      goto LABEL_87;
  }
  if (*(_DWORD *)(a2 + 2592) == 2)
    goto LABEL_33;
  MFS__log_select_Diag(v8, 3, (uint64_t)"viterbi::end_for_early_emission\n");
  v17 = mfs_Viterbi_ResultScore(v12, a2 + 2144, (uint64_t)v10);
  if ((v17 & 0x80000000) != 0)
  {
LABEL_87:
    v14 = v17;
LABEL_88:
    mfs_F32Vect_Clear(v10);
    if (!v12)
      return v14;
LABEL_89:
    mfs_Viterbi_DeInit((_QWORD *)v12);
    return v14;
  }
  *(_QWORD *)(a2 + 2624) = v12;
  v20 = *(_DWORD *)(a2 + 2592);
  if (!v20)
    goto LABEL_48;
LABEL_15:
  if (v20 != 2)
  {
    v50 = v9;
    MFS__log_select_Diag(v8, 3, (uint64_t)"viterbi::resume_after_early_emission\n");
    v21 = *(unsigned int *)(v12 + 68);
    if ((int)v21 >= 1)
    {
      v22 = *(_QWORD *)(v12 + 56);
      v23 = (*(_DWORD *)(a2 + 2636) - *(_DWORD *)(v12 + 32));
      v24 = *(_DWORD *)(a2 + 2632);
      do
      {
        if (*(_DWORD *)(*(_QWORD *)(v22 + 24) + 4 * v23) != v24)
          *(_DWORD *)v22 = 1259902592;
        v22 += 32;
        --v21;
      }
      while (v21);
    }
    goto LABEL_34;
  }
LABEL_33:
  v50 = v9;
  MFS__log_select_Diag(v8, 3, (uint64_t)"viterbi::begin_regular_emission\n");
LABEL_34:
  if (*(int *)(a2 + 2008) >= 1)
  {
    v26 = 0;
    v27 = 0;
    do
    {
      if (v26 || *(_DWORD *)(a2 + 2592) != 1)
      {
        v17 = mfs_Viterbi_Reset(v12, *(_DWORD *)(*(_QWORD *)(a2 + 2000) + v26), *(_DWORD *)(*(_QWORD *)(a2 + 2000) + v26 + 4));
        if ((v17 & 0x80000000) != 0)
          goto LABEL_87;
      }
      MFS__log_select_Diag(v8, 3, (uint64_t)"path_len = %dL %d : %d\n");
      v28 = *(_DWORD *)(a2 + 2064);
      if (v28 == 1)
      {
        mfs_Viterbi_Decode_MCP_S9_LF0_S8(v12);
      }
      else if (v28 == 2)
      {
        v17 = mfs_Viterbi_Decode_MCP_S9_LF0_S8_X2B(v12);
        if ((v17 & 0x80000000) != 0)
          goto LABEL_87;
      }
      else
      {
        v17 = mfs_Viterbi_Decode(v12);
        if ((v17 & 0x80000000) != 0)
          goto LABEL_87;
      }
      MFS__log_select_Diag(v8, 3, (uint64_t)"viterbi::end\n");
      v17 = mfs_Viterbi_ResultScore(v12, a2 + 2144, (uint64_t)v10);
      if ((v17 & 0x80000000) != 0)
        goto LABEL_87;
      *(_DWORD *)(a2 + 2592) = 2;
      ++v27;
      v26 += 8;
    }
    while (v27 < *(int *)(a2 + 2008));
  }
  mfs_Viterbi_DeInit((_QWORD *)v12);
  v9 = v50;
LABEL_48:
  if (MFS__log_select_GetLogLevel(*(_QWORD *)(v8 + 32)) < 2)
    goto LABEL_75;
  LogLevel = MFS__log_select_GetLogLevel(*(_QWORD *)(v8 + 32));
  v30 = *(_DWORD *)(a2 + 2160);
  v31 = v30 - 1;
  if (LogLevel >= 3)
  {
    if (v31 < 1)
      goto LABEL_71;
    v51 = v9;
    v32 = 0;
    v33 = 0;
    v49 = 0;
    v52 = 0;
    do
    {
      v54 = 0;
      memset(v55, 0, sizeof(v55));
      mfs_ParamMap_GetAcousticVector(v8, a1, a2, *(unsigned int *)(*(_QWORD *)(a2 + 2152) + 4 * v32), (uint64_t)v55, &v54);
      v33 += v54;
      MFS__log_select_Diag(v8, 3, (uint64_t)"unit %d: %d %f\n");
      if (v32 % 3 == 2)
      {
        if (!mfs_Ling_IsSilence(a4, *(_QWORD *)(a2 + 8), v32 / 3))
        {
          MFS__log_select_Diag(v8, 1, (uint64_t)"model duration: %d %d\n");
          ++v49;
          MFS__log_select_Diag(v8, 1, (uint64_t)"candidate duration: %d\n");
          v33 = 0;
        }
      }
      else if (v32 % 3 == 1
             && mfs_Ling_IsVowel(a4, *(_QWORD *)(a2 + 8), v32 / 3))
      {
        if (v52 >= 0xC8)
          v34 = v52;
        else
          v34 = v52 + 1;
        MFS__log_select_Diag(v8, 1, (uint64_t)"model pitch: %f\n");
        MFS__log_select_Diag(v8, 1, (uint64_t)"candidate pitch: %f\n");
        v52 = v34;
      }
      ++v32;
      v30 = *(_DWORD *)(a2 + 2160);
      v31 = v30 - 1;
    }
    while (v32 < v30 - 1);
    v9 = v51;
  }
  if (v31 >= 1)
  {
    v35 = 0;
    v36 = 0;
    v37 = 0.0;
    do
    {
      v38 = *(_QWORD *)(a2 + 2152);
      v39 = *(_DWORD *)(v38 + 4 * v35);
      if (v39 == v18 || (v40 = *(_DWORD *)(v38 + 4 * v35 + 4), v40 == v18))
      {
        ++v36;
      }
      else
      {
        v37 = v37 + mfs_JCostProb(a1, a2, v39, v40, v35);
        v30 = *(_DWORD *)(a2 + 2160);
      }
      ++v35;
    }
    while (v35 < v30 - 1);
    goto LABEL_72;
  }
LABEL_71:
  v36 = 0;
  v37 = 0.0;
LABEL_72:
  v41 = v30 - v36;
  if (v41)
    exp((float)(v37 / (float)v41));
  MFS__log_select_Diag(v8, 2, (uint64_t)"ACC : %f\n");
LABEL_75:
  v14 = mfs_UnitSequence_Sequence((uint64_t)v9, v53);
  if ((v14 & 0x80000000) != 0)
    goto LABEL_88;
  if (MFS__log_select_GetLogLevel(*(_QWORD *)(v8 + 32)) >= 3)
    mfs_UnitSequence_Log((uint64_t)v9);
  if (*(_DWORD *)(a2 + 2592))
  {
    *(_DWORD *)(a2 + 2604) = 0;
    v42 = *(_DWORD *)(a2 + 2272);
    if (v42 >= 3)
    {
      v43 = 0;
      v44 = (v42 - 1);
      v45 = (int *)(*(_QWORD *)(a2 + 2264) + 40);
      v46 = v44 - 1;
      do
      {
        v47 = *v45;
        v45 += 7;
        v43 += v47;
        --v46;
      }
      while (v46);
      *(_DWORD *)(a2 + 2604) = v43;
    }
    mfs_Viterbi_DeInit((_QWORD *)v12);
    heap_Free(*(_QWORD **)(v8 + 8), v12);
    mfs_F32Vect_Clear(v10);
  }
  return v14;
}

uint64_t mfs_Search_FindNodeCandidates_StatSelect_UltraLight(int *a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v3;
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  float v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  signed int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t result;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  signed int v28;
  int LeafIndex;
  int v30;
  int v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  signed int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  int v50;
  float v51;
  int v52;
  _QWORD *v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  int v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  signed int v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  uint64_t v98;
  uint64_t AcousticVector;
  signed int v100;
  signed int v101;
  signed int v102;
  uint64_t v103;
  unsigned int v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int v107;
  float v108;
  float v109;
  float v110;
  uint64_t v111;
  float v112;
  uint64_t v113;
  int v114;
  int v115;
  uint64_t v116;
  int v117;
  int v118;
  int *v119;
  uint64_t v120;
  int v121;
  const char *v122;
  int v123;
  int *v124;
  int *v125;
  signed int v126;
  int *v127;
  int *v128;
  _QWORD *v129;
  _QWORD *v130;
  int v131;
  uint64_t v132;
  _QWORD *v133;
  _QWORD *v134;
  uint64_t v135;
  uint64_t v136;
  unsigned int v137;
  _QWORD *v138;
  unsigned int v139;
  int *v140;
  uint64_t v141;
  _QWORD *v143;
  unsigned int v144;
  int *v145;
  _QWORD *v147;
  _QWORD *v148;
  unsigned int v149;
  _QWORD *v150;
  signed int v151;
  _DWORD *v152;
  _QWORD *v153;
  int v154;
  _OWORD __b[9];
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int16 v161;
  char v162;
  unsigned int v163[20];
  unsigned int v164[4];
  _DWORD v165[44];
  __int128 v166;
  unsigned int v167;
  uint64_t v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  uint64_t v173;

  v3 = (_DWORD *)a3;
  v4 = a2;
  v173 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a2 + 1928);
  v162 = 0;
  v161 = 0;
  v7 = (_QWORD *)(a2 + 1944);
  v171 = 0u;
  v172 = 0u;
  v169 = 0u;
  v170 = 0u;
  v159 = 0u;
  v160 = 0u;
  v157 = 0u;
  v158 = 0u;
  v156 = 0u;
  memset(__b, 0, sizeof(__b));
  v166 = 0u;
  memset(v165, 0, sizeof(v165));
  *(_QWORD *)(a2 + 2192) = 0;
  v8 = *(float *)(a3 + 8180);
  v141 = v6;
  if (*(int *)(a2 + 608) < 1)
  {
    v139 = 0;
LABEL_115:
    mfs_TCost_Init(v6, (uint64_t)v3, __b);
    v90 = *(_DWORD *)(v4 + 608);
    if (v90 >= 1)
    {
      v91 = 0;
      LODWORD(v92) = 0;
      v152 = v3 + 6322;
      LODWORD(v93) = *a1;
      v94 = v139;
      v130 = v7;
      while ((int)v93 < 1)
      {
LABEL_146:
        if (++v91 >= v90)
          goto LABEL_149;
      }
      v95 = a2;
      v96 = *(_QWORD *)(a2 + 600) + 528 * v91;
      v97 = (_QWORD *)(v96 + 16);
      v133 = (_QWORD *)(v96 + 312);
      v136 = v91;
      v150 = (_QWORD *)(v96 + 80);
      v145 = (int *)(v96 + 24);
      v138 = (_QWORD *)(v96 + 16);
      v140 = (int *)(v96 + 28);
      v92 = (int)v92;
      v98 = 2;
      while (1)
      {
        AcousticVector = mfs_FillTgtVect((uint64_t)v3, v95, (uint64_t)__b, *(_DWORD *)(*v97 + 4 * v98));
        if ((AcousticVector & 0x80000000) != 0)
          break;
        mfs_Ling_GetPhonCtxt(*(_QWORD *)(v95 + 8), v91, &v161);
        result = mfs_CostList_Sort((uint64_t)v130, v92, 1);
        if ((result & 0x80000000) != 0)
          return result;
        v100 = *(_DWORD *)(*(_QWORD *)(v95 + 1952) + 32 * v92 + 16);
        MFS__log_select_Diag(v6, 1, (uint64_t)"before prune %lu, ");
        v101 = v3[2064];
        if (!v101 || HIBYTE(v161) != 1)
        {
          if ((*(_BYTE *)(*v133 + v98) & 4) != 0)
            v101 = v3[2060];
          else
            v101 = v3[2061];
        }
        if (v100 >= v101)
          v102 = v101;
        else
          v102 = v100;
        MFS__log_select_Diag(v6, 1, (uint64_t)"after prune %lu\n");
        mfs_CostList_Prune(v130, v92, v102);
        v95 = a2;
        if (v102 >= 1)
        {
          v103 = 0;
          v104 = 0;
          v105 = 8 * v102;
          do
          {
            v154 = 0;
            memset(v163, 0, sizeof(v163));
            v106 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v95 + 1952) + 32 * v92) + v103);
            AcousticVector = mfs_ParamMap_GetAcousticVector(v141, (uint64_t)a1, v95, v106, (uint64_t)v163, &v154);
            if ((AcousticVector & 0x80000000) != 0)
              goto LABEL_163;
            if ((int)v156 <= v154)
              v107 = v154;
            else
              v107 = v156;
            LODWORD(v158) = v107;
            result = mfs_S32Vect_Reserve((uint64_t)&v157, v107);
            if ((result & 0x80000000) != 0)
              return result;
            if (*v152)
            {
              AcousticVector = mfs_TCost_CandidateCostStream_kld((uint64_t)__b, (uint64_t)a1, a3, v141, (uint64_t)v163, v154, v106, *(unsigned int *)(*v150 + 4 * v98), v98, (uint64_t)v164);
              if ((AcousticVector & 0x80000000) != 0)
                goto LABEL_163;
            }
            else
            {
              mfs_TCost_CandidateCostStream_Faster((uint64_t)__b, a3, (uint64_t)v163, v154, (uint64_t)v164);
            }
            v108 = 0.0;
            if (HIBYTE(v161) != 1 && *(_DWORD *)(a3 + 8968) == 6)
            {
              v109 = (float)(*((float *)__b + 1) * *((float *)&v156 + 3)) * 0.01;
              v108 = (float)(v109 * (float)(int)CandidatePhonemeDurationDistance((uint64_t)a1, v106, v98, *v145, *v140))
                   + 0.0;
            }
            v95 = a2;
            v110 = (float)(v8
                         * (float)(v108 + (float)((float)(*(float *)&v164[1] + *(float *)&v164[2]) + *(float *)v164)))
                 + (float)(*(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 1952) + 32 * v92) + v103 + 4) * (float)(1.0 - v8));
            mfs_ParamMap_UnMapSection(a2);
            mfs_CostList_UpdateCost_inlined((uint64_t)v130, v92, v104++, v110);
            v103 += 8;
          }
          while (v105 != v103);
        }
        mfs_CostList_UpdateCostEnd_inlined((uint64_t)v130, v92);
        v3 = (_DWORD *)a3;
        v94 = mfs_CleanUpTgtVect(a3, v95, (uint64_t)__b);
        ++v92;
        v93 = *a1;
        v32 = v98++ <= v93;
        v6 = v141;
        v91 = v136;
        v97 = v138;
        if (!v32)
        {
          v90 = *(_DWORD *)(v95 + 608);
          goto LABEL_146;
        }
      }
LABEL_163:
      v111 = AcousticVector;
      goto LABEL_167;
    }
    v94 = v139;
LABEL_149:
    *(_DWORD *)(a2 + 2200) = 0;
    v111 = v94;
    if (v3[2141] == 1)
    {
      v112 = *(float *)(a2 + 2616);
      if (v112 == 0.0)
      {
        v122 = "Early emission enabled in pipeline header but no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(a2 + 2608) = (int)((double)*(int *)(a2 + 2604) / (v112 * 0.8 + 1.0));
        MFS__log_select_Diag(v6, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        v113 = *(unsigned int *)(a2 + 608);
        v114 = *(_DWORD *)(a2 + 2596);
        if ((int)v113 >= 2)
        {
          v115 = 0;
          v116 = 1;
          v117 = *(_DWORD *)(a2 + 2596);
          do
          {
            if (v117)
              break;
            v118 = *a1;
            if (*a1 >= 1)
            {
              v119 = (int *)(*(_QWORD *)(*(_QWORD *)(a2 + 600) + 528 * v116 + 16) + 8);
              v120 = *a1;
              do
              {
                v121 = *v119++;
                v115 += v121 * v3[6];
                --v120;
              }
              while (v120);
            }
            ++v116;
            if (v115 >= *(_DWORD *)(a2 + 2608))
            {
              v114 = v118 * v116;
              *(_DWORD *)(a2 + 2596) = v118 * v116;
              v117 = v118 * v116;
            }
            else
            {
              v117 = 0;
            }
          }
          while (v116 != v113);
        }
        if (!v114)
          goto LABEL_167;
        v122 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      v122 = "Early emission not enabled in pipeline header\n";
    }
    MFS__log_select_Diag(v6, 1, (uint64_t)v122);
LABEL_167:
    mfs_TCost_Clear(__b);
    return v111;
  }
  v9 = 0;
  v139 = 0;
  v126 = 0;
  v137 = *(_DWORD *)(a3 + 8224);
  v127 = a1 + 620;
  v128 = a1 + 656;
  v10 = (_QWORD *)(a2 + 1968);
  v124 = a1 + 696;
  v125 = a1 + 640;
  v153 = (_QWORD *)(a2 + 1968);
  while (1)
  {
    v11 = *(_QWORD *)(v4 + 600);
    v12 = (uint64_t)v3;
    v13 = v6;
    v14 = v9;
    v15 = v11 + 528 * v9;
    MFS__log_select_Diag(v13, 3, (uint64_t)"phoneme %d\n");
    mfs_symData_GetTargetVector((uint64_t)a1, (uint64_t)v165, *(_QWORD *)(v4 + 8), v14);
    mfs_Ling_GetPhonCtxt(*(_QWORD *)(v4 + 8), v14, &v161);
    v16 = v13;
    v17 = v13;
    v3 = (_DWORD *)v12;
    mfs_Ling_LogPhonCtxt(v17, v12, *(_QWORD *)(v4 + 8), v14);
    LODWORD(v18) = *a1;
    v132 = v14;
    if (*a1 == 3)
    {
      v21 = v11 + 528 * v14;
      v134 = (_QWORD *)(v21 + 16);
      v147 = (_QWORD *)(v21 + 312);
      v19 = v126;
      v20 = v126 - 1;
      LODWORD(v21) = 3;
      v22 = 2;
      LODWORD(result) = v139;
      v24 = v15;
      v25 = v14;
      while (1)
      {
        v151 = v19;
        if (v25 && v25 != *(_DWORD *)(v4 + 608) - 1)
          *(_DWORD *)(v4 + 2604) += *(_DWORD *)(*v134 + 4 * v22) * *(_DWORD *)(a3 + 24);
        v26 = 2 * v22;
        v27 = *(_QWORD *)(v4 + 1976);
        *(_DWORD *)(v27 + (((v22 << 33) - 0x400000000) >> 27) + 16) = 0;
        *(_DWORD *)(v27 + 32 * (2 * (int)v22 - 3) + 16) = 0;
        v28 = v19;
        if (HIBYTE(v161) != 1
          || *(_DWORD *)(a3 + 8256) && (v25 && v22 == 2 || v22 == (_DWORD)v21 + 1 && v25 != *(_DWORD *)(a2 + 608) - 1))
        {
          *((_QWORD *)&v166 + 1) = *(_QWORD *)&a1[2 * v22 + 674];
          v165[0] = a1[v22 + 629];
          LeafIndex = mfs_GetLeafIndex(v24, 1, v22);
          result = mfs_IbAddtoVect_MCP(v141, (unsigned int *)a1, a3, (uint64_t)v165, v22, LeafIndex, 0, v137, v7, v28, (uint64_t)&v161);
          if ((result & 0x80000000) != 0)
            return result;
          if ((*(_BYTE *)(*v147 + v22) & 4) != 0)
          {
            *((_QWORD *)&v166 + 1) = *(_QWORD *)&a1[2 * v22 + 692];
            v165[0] = a1[v22 + 638];
            v30 = mfs_GetLeafIndex(v24, 2, v22);
            result = mfs_IbAddtoVect_LF0(v141, (unsigned int *)a1, a3, (uint64_t)v165, v22, v30, 0, v137, (uint64_t)v7, v151, (uint64_t)&v161, v10, v26 - 4);
            if ((result & 0x80000000) != 0)
              return result;
            *((_QWORD *)&v166 + 1) = *(_QWORD *)&v128[2 * v22];
            v165[0] = v127[v22];
            v31 = mfs_GetLeafIndex(v24, 0, v22);
            result = mfs_IbAddtoVect_DUR(v141, (unsigned int *)a1, a3, (uint64_t)v165, v22, v31, 0, v137, (uint64_t)v7, v151, (uint64_t)&v161, v10, v26 - 4, v26 - 3);
            v25 = v14;
            v28 = v151;
            if ((result & 0x80000000) != 0)
              return result;
          }
        }
        v19 = v28 + 1;
        v21 = *a1;
        ++v20;
        v32 = v22++ <= v21;
        v4 = a2;
        if (!v32)
        {
          v139 = result;
          v126 = v19;
          if (HIBYTE(v161) == 1)
          {
            v6 = v141;
            v3 = (_DWORD *)a3;
          }
          else
          {
            v131 = v20;
            v57 = 0;
            v163[0] = 0;
            v58 = *(_QWORD *)(a2 + 1976);
            if ((int)v21 >= -1)
              v59 = v21 + 1;
            else
              v59 = v21 + 2;
            *(_DWORD *)(v58 + 208) = 0;
            v123 = -(v59 >> 1);
            *(_DWORD *)(v58 + 240) = 0;
            v164[0] = 0;
            v167 = v19 - (v59 >> 1);
            v60 = (uint64_t)v7;
            *(_QWORD *)&v169 = v7;
            *((_QWORD *)&v169 + 1) = v10;
            *(_QWORD *)&v170 = v10;
            v168 = 0x300000002;
            v149 = v151 - (v59 >> 1);
            v144 = v167;
            do
            {
              v61 = *((_QWORD *)&v169 + v57);
              v135 = v57;
              v62 = *(&v167 + v57);
              v63 = *(unsigned int *)(*(_QWORD *)(v61 + 8) + 32 * v62 + 16);
              if ((int)v63 >= 1)
              {
                v64 = 0;
                v65 = 8 * v63;
                do
                {
                  v66 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v61 + 8) + 32 * v62) + v64);
                  if (!mfs_CostList_IsNodeInList(v60, v149, v66 - 1, (uint64_t)a1, v164)
                    && !mfs_CostList_IsNodeInList((uint64_t)v153, 0, v66 - 1, (uint64_t)a1, v164)
                    && !mfs_CostList_IsNodeInList((uint64_t)v153, 1u, v66 - 1, (uint64_t)a1, v164))
                  {
                    v139 = mfs_CostList_Pad((uint64_t)a1, v153, 6u, v66 - 1, *((_QWORD *)a1 + 298), a1[598], v163, *(float *)(*(_QWORD *)(*(_QWORD *)(v61 + 8) + 32 * v62) + v64 + 4) * 10.0);
                  }
                  if (!mfs_CostList_IsNodeInList(v60, v144 + 1, v66 + 1, (uint64_t)a1, v164)
                    && !mfs_CostList_IsNodeInList((uint64_t)v153, 4u, v66 + 1, (uint64_t)a1, v164)
                    && !mfs_CostList_IsNodeInList((uint64_t)v153, 5u, v66 + 1, (uint64_t)a1, v164))
                  {
                    v139 = mfs_CostList_Pad((uint64_t)a1, v153, 7u, v66 + 1, *((_QWORD *)a1 + 298), a1[598], v163, *(float *)(*(_QWORD *)(*(_QWORD *)(v61 + 8) + 32 * v62) + v64 + 4) * 10.0);
                  }
                  v64 += 8;
                }
                while (v65 != v64);
              }
              v57 = v135 + 1;
            }
            while (v135 != 2);
            v4 = a2;
            v67 = *(_QWORD *)(a2 + 1976);
            if (*(_DWORD *)(v67 + 208))
            {
              v10 = v153;
              mfs_ConcatTwoLists(v153, 1u, (uint64_t)v153, 6u);
              v67 = *(_QWORD *)(a2 + 1976);
              v3 = (_DWORD *)a3;
            }
            else
            {
              v3 = (_DWORD *)a3;
              v10 = v153;
            }
            v68 = v20;
            v7 = (_QWORD *)v60;
            if (*(_DWORD *)(v67 + 240))
              mfs_ConcatTwoLists(v10, 5u, (uint64_t)v10, 7u);
            v69 = v144;
            if (v3[2242] == 6)
            {
              v70 = 0;
              v164[0] = 0;
              v167 = v149;
              *(_QWORD *)&v169 = v7;
              *((_QWORD *)&v169 + 1) = v10;
              *(_QWORD *)&v170 = v10;
              v168 = 0x100000000;
              *(_DWORD *)(*(_QWORD *)(a2 + 1976) + 208) = 0;
              do
              {
                v71 = *((_QWORD *)&v169 + v70);
                v72 = *(&v167 + v70);
                v73 = *(unsigned int *)(*(_QWORD *)(v71 + 8) + 32 * v72 + 16);
                if ((int)v73 >= 1)
                {
                  v74 = 0;
                  v75 = 8 * v73;
                  do
                  {
                    v76 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v71 + 8) + 32 * v72) + v74) + 1;
                    if (!mfs_CostList_IsNodeInList((uint64_t)v7, v69, v76, (uint64_t)a1, v164))
                    {
                      if (mfs_CostList_IsNodeInList((uint64_t)v153, 3u, v76, (uint64_t)a1, v164))
                      {
                        v69 = v144;
                      }
                      else
                      {
                        v69 = v144;
                        if (!mfs_CostList_IsNodeInList((uint64_t)v153, 4u, v76, (uint64_t)a1, v164))
                          v139 = mfs_CostList_Pad((uint64_t)a1, v153, 6u, v76, *((_QWORD *)a1 + 298), a1[598], v163, *(float *)(*(_QWORD *)(*(_QWORD *)(v71 + 8) + 32 * v72) + v74 + 4) * 20.0);
                      }
                    }
                    v74 += 8;
                  }
                  while (v75 != v74);
                }
                ++v70;
              }
              while (v70 != 3);
              v77 = *(_QWORD *)(a2 + 1976);
              if (*(_DWORD *)(v77 + 208))
              {
                mfs_ConcatTwoLists(v153, 3u, (uint64_t)v153, 6u);
                v77 = *(_QWORD *)(a2 + 1976);
              }
              v78 = 0;
              v164[0] = 0;
              v167 = v144 + 1;
              *(_QWORD *)&v169 = v7;
              *((_QWORD *)&v169 + 1) = v153;
              *(_QWORD *)&v170 = v153;
              v168 = 0x500000004;
              *(_DWORD *)(v77 + 208) = 0;
              do
              {
                v79 = *((_QWORD *)&v169 + v78);
                v80 = *(&v167 + v78);
                v81 = *(unsigned int *)(*(_QWORD *)(v79 + 8) + 32 * v80 + 16);
                if ((int)v81 >= 1)
                {
                  v82 = 0;
                  v83 = 8 * v81;
                  do
                  {
                    v84 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v79 + 8) + 32 * v80) + v82) - 1;
                    if (!mfs_CostList_IsNodeInList((uint64_t)v7, v69, v84, (uint64_t)a1, v164))
                    {
                      if (mfs_CostList_IsNodeInList((uint64_t)v153, 3u, v84, (uint64_t)a1, v164))
                      {
                        v69 = v144;
                      }
                      else
                      {
                        v69 = v144;
                        if (!mfs_CostList_IsNodeInList((uint64_t)v153, 4u, v84, (uint64_t)a1, v164))
                          v139 = mfs_CostList_Pad((uint64_t)a1, v153, 6u, v84, *((_QWORD *)a1 + 298), a1[598], v163, *(float *)(*(_QWORD *)(*(_QWORD *)(v79 + 8) + 32 * v80) + v82 + 4) * 20.0);
                      }
                    }
                    v82 += 8;
                  }
                  while (v83 != v82);
                }
                ++v78;
              }
              while (v78 != 3);
              v4 = a2;
              if (*(_DWORD *)(*(_QWORD *)(a2 + 1976) + 208))
              {
                v10 = v153;
                mfs_ConcatTwoLists(v153, 3u, (uint64_t)v153, 6u);
                v3 = (_DWORD *)a3;
                v25 = v132;
              }
              else
              {
                v3 = (_DWORD *)a3;
                v25 = v132;
                v10 = v153;
              }
              v68 = v131;
            }
            else
            {
              v25 = v132;
            }
            if (*a1 >= 1)
            {
              v85 = 0;
              v86 = v123 + v68;
              v87 = 1;
              v88 = 1;
              do
              {
                v89 = *(_QWORD *)(v4 + 1976);
                if (*(_DWORD *)(v89 + (v85 >> 27) + 16))
                {
                  mfs_ConcatTwoLists(v7, v86 + v87 - 1, (uint64_t)v10, v88 - 1);
                  v89 = *(_QWORD *)(v4 + 1976);
                }
                if (*(_DWORD *)(v89 + 32 * v88 + 16))
                  mfs_ConcatTwoLists(v7, v86 + v87 - 1, (uint64_t)v10, v88);
                ++v87;
                v88 += 2;
                v85 += 0x200000000;
              }
              while (v87 <= *a1);
            }
            v6 = v141;
          }
          goto LABEL_112;
        }
      }
    }
    LODWORD(result) = v139;
    if ((int)v18 >= 1)
      break;
    v25 = v14;
    v6 = v16;
LABEL_40:
    if (HIBYTE(v161) == 1)
    {
      v139 = result;
    }
    else
    {
      v43 = v18 + 2;
      if ((int)v18 >= -1)
        v43 = v18 + 1;
      v44 = v126 - (v43 >> 1);
      v45 = *(unsigned int *)(*(_QWORD *)(v4 + 1952) + 32 * v44 + 16);
      v163[0] = 0;
      if ((int)v45 >= 1)
      {
        v46 = 0;
        v47 = 0;
        v48 = 0;
        do
        {
          if ((int)v18 >= 3)
          {
            v49 = *(_QWORD *)(*(_QWORD *)(v4 + 1952) + 32 * v44) + 8 * v46;
            v50 = *(_DWORD *)v49;
            v51 = *(float *)(v49 + 4) * 10.0;
            v52 = 1;
            v53 = v7;
            v54 = -1;
            do
            {
              v55 = v48
                  + ((int)mfs_CostList_Add((uint64_t)a1, v53, (int)v44 + v54, v50 + v54, *((_QWORD *)a1 + 298), a1[598], v163, v51) >= 0);
              LODWORD(result) = mfs_CostList_Add((uint64_t)a1, v53, (int)v44 + v52, v50 + v52, *((_QWORD *)a1 + 298), a1[598], v163, v51);
              v48 = v55 + ((int)result >= 0);
              v47 += 2;
              ++v52;
              LODWORD(v18) = *a1;
              v56 = *a1 + 2;
              if (*a1 >= -1)
                v56 = v18 + 1;
              --v54;
            }
            while (v52 < v56 >> 1);
            v4 = a2;
            v7 = v53;
            v25 = v132;
          }
          ++v46;
        }
        while (v46 != v45);
      }
      v139 = result;
      v6 = v141;
      MFS__log_select_Diag(v141, 1, (uint64_t)"MCP Phoneme filler added %lu states %lu\n");
      v3 = (_DWORD *)a3;
      v10 = v153;
    }
LABEL_112:
    v9 = v25 + 1;
    if (v9 >= *(int *)(v4 + 608))
      goto LABEL_115;
  }
  v33 = 0;
  v34 = v11 + 528 * v14;
  v143 = (_QWORD *)(v34 + 16);
  v148 = (_QWORD *)(v34 + 312);
  v35 = v124;
  v36 = v125;
  v37 = v15;
  v25 = v14;
  v129 = v7;
  while (1)
  {
    v38 = v33;
    if (v25 && v25 != *(_DWORD *)(v4 + 608) - 1)
      *(_DWORD *)(v4 + 2604) += *(_DWORD *)(*v143 + 4 * v33 + 8) * *(_DWORD *)(a3 + 24);
    if (HIBYTE(v161) != 1
      || *(_DWORD *)(a3 + 8256) && (v25 && !v33 || v33 + 2 == (_DWORD)v18 + 1 && v25 != *(_DWORD *)(a2 + 608) - 1))
    {
      v39 = v126 + v33;
      *((_QWORD *)&v166 + 1) = *((_QWORD *)v35 - 9);
      v165[0] = *(v36 - 9);
      v40 = mfs_GetLeafIndex(v37, 1, (int)v33 + 2);
      result = mfs_IbAddtoVect(v141, (uint64_t)a1, a3, (uint64_t)v165, 1, (int)v38 + 2, v40, 0, 1.0, 1.0, 0.025, v137, v7, v126 + (int)v38, (unsigned __int8 *)&v161, 0);
      if ((result & 0x80000000) != 0)
        return result;
      if ((*(_BYTE *)(*v148 + v38 + 2) & 4) != 0)
      {
        *((_QWORD *)&v166 + 1) = *(_QWORD *)v35;
        v165[0] = *v36;
        v41 = mfs_GetLeafIndex(v37, 2, (int)v38 + 2);
        result = mfs_IbAddtoVect(v141, (uint64_t)a1, a3, (uint64_t)v165, 2, (int)v38 + 2, v41, 0, 1.0, 1.0, 0.025, v137, v7, v39, (unsigned __int8 *)&v161, 1);
        if ((result & 0x80000000) != 0)
          return result;
        *((_QWORD *)&v166 + 1) = *((_QWORD *)v35 - 18);
        v165[0] = *(v36 - 18);
        v42 = mfs_GetLeafIndex(v37, 0, (int)v38 + 2);
        result = mfs_IbAddtoVect(v141, (uint64_t)a1, a3, (uint64_t)v165, 0, (int)v38 + 2, v42, 0, 1.0, 1.0, 0.025, v137, v129, v39, (unsigned __int8 *)&v161, 0);
        v7 = v129;
        v10 = v153;
        v25 = v132;
        if ((result & 0x80000000) != 0)
          return result;
      }
    }
    v18 = *a1;
    v33 = v38 + 1;
    ++v36;
    v35 += 2;
    v4 = a2;
    if (v38 + 2 > v18)
    {
      v126 += v33;
      v6 = v141;
      v3 = (_DWORD *)a3;
      goto LABEL_40;
    }
  }
}

uint64_t concat_applyBPF(uint64_t a1, char *a2, unsigned int a3)
{
  uint64_t v6;
  _DWORD *v7;
  float32x4_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const float *v12;
  float32x4_t v13;
  _OWORD v15[2];
  int v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  v17[0] = 0xBF95F27700000000;
  v17[1] = 0x3FE0EBB200000000;
  v17[2] = 0xBF95F27700000000;
  v17[3] = 0x3E95F27700000000;
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  v6 = a3;
  v7 = (_DWORD *)heap_Calloc(*(_QWORD **)(a1 + 8), a3, 4);
  if (!v7)
    return 2229280778;
  v9 = (uint64_t)v7;
  if (a3)
  {
    v10 = 0;
    do
    {
      v11 = 0;
      v12 = (const float *)&a2[4 * v10];
      v8.f32[0] = *(float *)v15 + (float)(*v12 * 0.29287);
      v7[v10] = v8.i32[0];
      v13 = vld1q_dup_f32(v12);
      v8 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 0);
      do
      {
        v15[v11 / 2] = vmlsq_f32(vmlaq_f32(*(float32x4_t *)((char *)&v15[v11 / 2] + 4), v13, *(float32x4_t *)&v17[v11]), v8, *(float32x4_t *)((char *)&unk_214FBFAB0 + v11 * 8 + 4));
        v11 += 2;
      }
      while (v11 != 4);
      ++v10;
    }
    while (v10 != v6);
  }
  cstdlib_memcpy(a2, v7, 4 * v6);
  heap_Free(*(_QWORD **)(a1 + 8), v9);
  return 0;
}

uint64_t ConnectedContextLength_TahoeVersion(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  float v18;
  float v19;
  int v20;
  int v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  __int16 v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  _BYTE v52[60];
  _BYTE v53[180];
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v50 = 0;
  v51 = 0;
  v49 = 0;
  v48 = 0;
  v4 = *(_DWORD *)(a3 + 608);
  if (v4 >= 1)
  {
    v5 = 0;
    v6 = 0;
    v45 = a3 + 1944;
    v41 = -1;
    v43 = 1;
    v40 = 528;
    do
    {
      if ((v5 & 0xFFFFFFFE) != 0)
      {
        v7 = 0;
        v8 = v41;
        while (1)
        {
          v9 = v7;
          if (v7 >= *(int *)(a1 + 8880))
            break;
          mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), *(_DWORD *)(*(_QWORD *)(a3 + 600) + 528 * v8), &v48);
          if (HIBYTE(v48) == 1)
            break;
          v53[v9 + 120] = HIBYTE(v48);
          --v8;
          v7 = v9 + 1;
          if (v41 == v9 + 1)
          {
            v10 = v41;
            goto LABEL_10;
          }
        }
        v10 = v9;
LABEL_10:
        v4 = *(_DWORD *)(a3 + 608);
      }
      else
      {
        v10 = 0;
      }
      if (v4 <= (int)++v5)
      {
        v15 = 0;
      }
      else
      {
        v11 = v10;
        v12 = v6;
        v13 = 0;
        v14 = v40;
        while (v13 < *(int *)(a1 + 8880))
        {
          mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), *(_DWORD *)(*(_QWORD *)(a3 + 600) + v14), &v48);
          if (HIBYTE(v48) == 1)
            break;
          v53[v13 + 60] = HIBYTE(v48);
          v15 = v13 + 1;
          v14 += 528;
          v16 = v43 + ++v13;
          if (*(_DWORD *)(a3 + 608) <= v16)
            goto LABEL_20;
        }
        v15 = v13;
LABEL_20:
        v6 = v12;
        v10 = v11;
      }
      v17 = *(_DWORD *)a2;
      if (*(int *)a2 >= 1)
      {
        v18 = (float)v15;
        v19 = (float)v10;
        v20 = 2;
        v42 = v5;
        do
        {
          v21 = *(_DWORD *)(a1 + 8880);
          v22 = (int)v6 >= v21 && v21 + (int)v6 < *(_DWORD *)(a3 + 608) * v17;
          if (v22)
          {
            v23 = (int)v6;
            v24 = *(_QWORD *)(a3 + 1952);
            if (*(_DWORD *)(v24 + 32 * (int)v6 + 16))
            {
              v44 = v20;
              v25 = 0;
              do
              {
                v26 = *(_QWORD *)(v24 + 32 * v23);
                CandGetContext(a1, a2, a3, *(_DWORD *)(v26 + 8 * v25), (uint64_t)v53, (_DWORD *)&v51 + 1, 1, v6, (_DWORD *)&v50 + 1);
                CandGetContext(a1, a2, a3, *(_DWORD *)(v26 + 8 * v25), (uint64_t)v52, &v51, 0, v6, &v50);
                if (v15 >= (int)v51)
                  v27 = v51;
                else
                  v27 = v15;
                v28 = 0.0;
                if ((_DWORD)v27)
                {
                  if ((int)v27 < 1)
                  {
                    LODWORD(v27) = 0;
                  }
                  else
                  {
                    v29 = 0;
                    while (v53[v29 + 60] == v52[v29])
                    {
                      if (v27 == ++v29)
                        goto LABEL_41;
                    }
                    LODWORD(v27) = v29;
                  }
LABEL_41:
                  v28 = (float)(int)v27 / v18;
                }
                if (v15 >= (int)v50)
                  v30 = v50;
                else
                  v30 = v15;
                v31 = 0.0;
                if ((_DWORD)v30)
                {
                  if ((int)v30 < 1)
                  {
                    LODWORD(v30) = 0;
                  }
                  else
                  {
                    v32 = 0;
                    while (v53[v32 + 60] == v52[v32])
                    {
                      if (v30 == ++v32)
                        goto LABEL_53;
                    }
                    LODWORD(v30) = v32;
                  }
LABEL_53:
                  v31 = (float)(int)v30 / v18;
                }
                if (v10 >= SHIDWORD(v50))
                  v33 = HIDWORD(v50);
                else
                  v33 = v10;
                v34 = 0.0;
                v35 = 0.0;
                if ((_DWORD)v33)
                {
                  if ((int)v33 < 1)
                  {
                    LODWORD(v33) = 0;
                  }
                  else
                  {
                    v36 = 0;
                    while (v53[v36 + 120] == v53[v36])
                    {
                      if (v33 == ++v36)
                        goto LABEL_65;
                    }
                    LODWORD(v33) = v36;
                  }
LABEL_65:
                  v35 = (float)(int)v33 / v19;
                }
                if (v10 >= SHIDWORD(v51))
                  v37 = HIDWORD(v51);
                else
                  v37 = v10;
                if ((_DWORD)v37)
                {
                  if ((int)v37 < 1)
                  {
                    LODWORD(v37) = 0;
                  }
                  else
                  {
                    v38 = 0;
                    while (v53[v38 + 120] == v53[v38])
                    {
                      if (v37 == ++v38)
                        goto LABEL_77;
                    }
                    LODWORD(v37) = v38;
                  }
LABEL_77:
                  v34 = (float)(int)v37 / v19;
                }
                mfs_CostList_UpdateCost(v45, v6, v25, (float)(*(float *)(v26 + 8 * v25 + 4) * 0.1)+ (float)((float)((float)(1.0- (float)((float)((float)((float)((float)(v28 * 0.1) + 0.0) + (float)(v31 * 0.4))+ (float)(v35 * 0.4))+ (float)(v34 * 0.1)))* 0.9)* *(float *)(v26 + 8 * v25 + 4)));
                ++v25;
                v24 = *(_QWORD *)(a3 + 1952);
                v23 = (int)v6;
              }
              while (v25 < *(unsigned int *)(v24 + 32 * (int)v6 + 16));
              v17 = *(_DWORD *)a2;
              v5 = v42;
              v20 = v44;
            }
            v6 = (v6 + 1);
          }
          v22 = v20++ <= v17;
        }
        while (v22);
      }
      v4 = *(_DWORD *)(a3 + 608);
      ++v43;
      v40 += 528;
      ++v41;
    }
    while (v4 > (int)v5);
  }
  mfs_CostList_FreeUidIndex((_QWORD *)(a3 + 1944));
  return 0;
}

uint64_t CandGetContext(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, uint64_t a5, _DWORD *a6, int a7, signed int a8, _DWORD *a9)
{
  unsigned int v13;
  int v16;
  uint64_t result;
  int v18;
  int v19;
  signed int v20;
  uint64_t v21;
  int v22;
  signed int v23;
  unsigned int v24;
  int v25;
  _DWORD *v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  int v32;
  _QWORD *v33;
  _QWORD v34[2];

  v13 = a4;
  v16 = *(_DWORD *)a2;
  v34[0] = 0;
  v34[1] = 0;
  v33 = v34;
  result = mfs_getUnitDataFromMfsData(a2, a4, (uint64_t *)&v33);
  if (a7 == 1)
    v18 = -v16;
  else
    v18 = v16;
  if (a7 == 1)
    v19 = -1;
  else
    v19 = 1;
  v30 = v18;
  v20 = v18 + v13;
  if ((int)(v18 + v13) < 0)
  {
    LODWORD(v21) = 0;
    v25 = 0;
  }
  else
  {
    v26 = a6;
    v21 = 0;
    v22 = *((unsigned __int16 *)v33 + 5);
    v32 = 1;
    v29 = a5;
    v27 = 0;
    v28 = v22;
    do
    {
      result = mfs_getUnitDataFromMfsData(a2, v20, (uint64_t *)&v33);
      if ((result & 0x80000000) != 0)
        break;
      if (v22 != *((unsigned __int16 *)v33 + 5))
        break;
      if (v21 >= *(int *)(a1 + 8880))
        break;
      if (v20 <= *(_DWORD *)a2)
        break;
      result = mfs_getUnitDataFromMfsData(a2, v20, (uint64_t *)&v33);
      if (*((_BYTE *)v33 + 13) == 1)
        break;
      if (v32)
      {
        while (1)
        {
          v23 = a8;
          a8 += v19;
          if (a8 < 0)
            break;
          v24 = v13 + v19;
          if (((v13 + v19) & 0x80000000) != 0
            || a8 == *(_DWORD *)(a3 + 1960)
            || !mfs_CostList_HasUnit((_QWORD *)(a3 + 1944), a8, v13 + v19))
          {
            break;
          }
          v13 += v19;
          if (v20 == v24)
          {
            ++v27;
            a8 = v19 + v23;
            v13 = v20;
            goto LABEL_22;
          }
        }
        v32 = 0;
        a8 = v19 + v23;
        v13 += v19;
LABEL_22:
        a5 = v29;
        v22 = v28;
      }
      else
      {
        v32 = 0;
      }
      result = mfs_getUnitDataFromMfsData(a2, v20, (uint64_t *)&v33);
      *(_BYTE *)(a5 + v21++) = *((_BYTE *)v33 + 13);
      v20 += v30;
    }
    while (v20 >= 0);
    a6 = v26;
    v25 = v27;
  }
  *a6 = v21;
  *a9 = v25;
  return result;
}

uint64_t ConnectedContextLength(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  float v19;
  float v20;
  int v21;
  BOOL v22;
  unsigned int v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  uint64_t v31;
  uint64_t v32;
  float v33;
  uint64_t v34;
  uint64_t v35;
  float v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  __int16 v50;
  char v51;
  uint64_t v52;
  uint64_t v53;
  _BYTE v54[60];
  _BYTE v55[180];
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v52 = 0;
  v53 = 0;
  v51 = 0;
  v50 = 0;
  LODWORD(v4) = *(_DWORD *)(a3 + 608);
  if ((int)v4 >= 1)
  {
    v5 = 0;
    LODWORD(v6) = 0;
    v7 = a3 + 1944;
    v44 = -1;
    v45 = 1;
    v43 = 528;
    do
    {
      v8 = *(_QWORD *)(a3 + 600);
      if (v5 < 2)
      {
        v13 = 0;
      }
      else
      {
        v9 = *(_QWORD *)(a3 + 600);
        v10 = 0;
        v11 = v44;
        while (1)
        {
          v12 = v10;
          if (v10 >= *(int *)(a1 + 8880))
            break;
          mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), *(_DWORD *)(*(_QWORD *)(a3 + 600) + 528 * v11), &v50);
          if (HIBYTE(v50) == 1)
            break;
          v55[v12 + 120] = HIBYTE(v50);
          --v11;
          v10 = v12 + 1;
          if (v44 == v12 + 1)
          {
            v13 = v44;
            goto LABEL_11;
          }
        }
        v13 = v12;
LABEL_11:
        LODWORD(v4) = *(_DWORD *)(a3 + 608);
        v8 = v9;
      }
      v42 = v5 + 1;
      if ((uint64_t)(v5 + 1) >= (int)v4)
      {
        v16 = 0;
      }
      else
      {
        v46 = v8;
        v14 = 0;
        v15 = v43;
        while (v14 < *(int *)(a1 + 8880))
        {
          mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), *(_DWORD *)(*(_QWORD *)(a3 + 600) + v15), &v50);
          if (HIBYTE(v50) == 1)
            break;
          v55[v14 + 60] = HIBYTE(v50);
          v16 = v14 + 1;
          v15 += 528;
          v17 = v45 + ++v14;
          if (*(_DWORD *)(a3 + 608) <= v17)
            goto LABEL_20;
        }
        v16 = v14;
LABEL_20:
        v8 = v46;
      }
      mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), *(_DWORD *)(v8 + 528 * v5), &v50);
      v18 = *(_DWORD *)a2;
      if (*(int *)a2 >= 1)
      {
        v19 = (float)v16;
        v20 = (float)v13;
        v6 = (int)v6;
        v21 = 2;
        do
        {
          v22 = v21 == v18 + 1 && v51 == 1;
          if (v22 && *(_DWORD *)(*(_QWORD *)(a3 + 1952) + 32 * v6 + 16))
          {
            v23 = 0;
            do
              mfs_CostList_UpdateCost(v7, v6, v23++, 0.0);
            while (v23 < *(_DWORD *)(*(_QWORD *)(a3 + 1952) + 32 * v6 + 16));
            v18 = *(_DWORD *)a2;
          }
          v24 = *(int *)(a1 + 8880);
          v25 = v6 >= v24 && (int)v24 + (int)v6 < v18 * *(_DWORD *)(a3 + 608);
          if (v25)
          {
            v26 = *(_QWORD *)(a3 + 1952);
            if (*(_DWORD *)(v26 + 32 * v6 + 16))
            {
              v47 = v21;
              v27 = 0;
              do
              {
                v28 = *(_QWORD *)(v26 + 32 * v6);
                CandGetContext(a1, a2, a3, *(_DWORD *)(v28 + 8 * v27), (uint64_t)v55, (_DWORD *)&v53 + 1, 1, v6, (_DWORD *)&v52 + 1);
                CandGetContext(a1, a2, a3, *(_DWORD *)(v28 + 8 * v27), (uint64_t)v54, &v53, 0, v6, &v52);
                if (v16 >= (int)v53)
                  v29 = v53;
                else
                  v29 = v16;
                v30 = 0.0;
                if ((_DWORD)v29)
                {
                  if ((int)v29 < 1)
                  {
                    LODWORD(v29) = 0;
                  }
                  else
                  {
                    v31 = 0;
                    while (v55[v31 + 60] == v54[v31])
                    {
                      if (v29 == ++v31)
                        goto LABEL_50;
                    }
                    LODWORD(v29) = v31;
                  }
LABEL_50:
                  v30 = (float)(int)v29 / v19;
                }
                if (v16 >= (int)v52)
                  v32 = v52;
                else
                  v32 = v16;
                v33 = 0.0;
                if ((_DWORD)v32)
                {
                  if ((int)v32 < 1)
                  {
                    LODWORD(v32) = 0;
                  }
                  else
                  {
                    v34 = 0;
                    while (v55[v34 + 60] == v54[v34])
                    {
                      if (v32 == ++v34)
                        goto LABEL_62;
                    }
                    LODWORD(v32) = v34;
                  }
LABEL_62:
                  v33 = (float)(int)v32 / v19;
                }
                if (v13 >= SHIDWORD(v52))
                  v35 = HIDWORD(v52);
                else
                  v35 = v13;
                v36 = 0.0;
                v37 = 0.0;
                if ((_DWORD)v35)
                {
                  if ((int)v35 < 1)
                  {
                    LODWORD(v35) = 0;
                  }
                  else
                  {
                    v38 = 0;
                    while (v55[v38 + 120] == v55[v38])
                    {
                      if (v35 == ++v38)
                        goto LABEL_74;
                    }
                    LODWORD(v35) = v38;
                  }
LABEL_74:
                  v37 = (float)(int)v35 / v20;
                }
                if (v13 >= SHIDWORD(v53))
                  v39 = HIDWORD(v53);
                else
                  v39 = v13;
                if ((_DWORD)v39)
                {
                  if ((int)v39 < 1)
                  {
                    LODWORD(v39) = 0;
                  }
                  else
                  {
                    v40 = 0;
                    while (v55[v40 + 120] == v55[v40])
                    {
                      if (v39 == ++v40)
                        goto LABEL_86;
                    }
                    LODWORD(v39) = v40;
                  }
LABEL_86:
                  v36 = (float)(int)v39 / v20;
                }
                mfs_CostList_UpdateCost(v7, v6, v27, *(float *)(v28 + 8 * v27 + 4)* (float)(1.0- (float)((float)((float)((float)((float)(v30 * 0.1) + 0.0) + (float)(v33 * 0.4))+ (float)(v37 * 0.4))+ (float)(v36 * 0.1))));
                ++v27;
                v26 = *(_QWORD *)(a3 + 1952);
              }
              while (v27 < *(unsigned int *)(v26 + 32 * v6 + 16));
              v18 = *(_DWORD *)a2;
              v21 = v47;
            }
          }
          ++v6;
          v25 = v21++ <= v18;
        }
        while (v25);
      }
      v4 = *(int *)(a3 + 608);
      ++v44;
      ++v45;
      v43 += 528;
      ++v5;
    }
    while (v42 < v4);
  }
  mfs_CostList_FreeUidIndex((_QWORD *)(a3 + 1944));
  return 0;
}

uint64_t PruneDPListOnContext(uint64_t a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  signed int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  float v26;
  float v27;
  uint64_t v28;
  signed int v29;
  signed int *v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v40;
  _QWORD v41[2];
  __int16 v42;
  char v43;

  v41[0] = 0;
  v41[1] = 0;
  v40 = v41;
  if (*(int *)(a3 + 608) >= 1)
  {
    v6 = a1;
    v36 = 0;
    v7 = 0;
    v8 = 0;
    v43 = 0;
    v42 = 0;
    v9 = (_QWORD *)(a3 + 1944);
    while (1)
    {
      v10 = *(_QWORD *)(a3 + 600);
      v11 = v36;
      mfs_Ling_GetPhonCtxt(*(_QWORD *)(a3 + 8), v36, &v42);
      v12 = *(_DWORD *)a2;
      if (HIBYTE(v42) == 1)
      {
        if (v12 >= 1)
        {
          v13 = 0;
          v14 = (32 * v7) | 0x10;
          while (!a4)
          {
            v16 = *(_DWORD *)(v6 + 8256);
            if (v16)
            {
              if (v16 >= *(_DWORD *)(v6 + 8240))
                v17 = *(_DWORD *)(v6 + 8240);
              else
                v17 = *(_DWORD *)(v6 + 8256);
            }
            else
            {
              v17 = 20;
            }
            *(_DWORD *)(*(_QWORD *)(a3 + 2016) + 4 * v7 + 4 * v13) = v17;
            if (*(_DWORD *)(*(_QWORD *)(a3 + 1952) + v14) > v17)
            {
              v15 = mfs_CostList_SelectAndPrune(v9, v7 + (int)v13, 1, v17);
LABEL_15:
              v8 = v15;
              if ((v15 & 0x80000000) != 0)
                return v8;
              goto LABEL_16;
            }
            v8 = 0;
LABEL_16:
            ++v13;
            v14 += 32;
            if ((int)v13 + 1 > *(_DWORD *)a2)
            {
              v7 += v13;
              goto LABEL_51;
            }
          }
          v15 = mfs_CostList_Sort((uint64_t)v9, v7 + (int)v13, 1);
          goto LABEL_15;
        }
      }
      else if (v12 >= 1)
      {
        v37 = (_QWORD *)(v10 + 528 * v36 + 312);
        v18 = v7;
        v19 = 2;
        v20 = a4;
        do
        {
          v21 = *(_QWORD *)(a3 + 1952);
          if (v20)
          {
            if (!*(_DWORD *)(v21 + 32 * v18 + 16))
              goto LABEL_34;
            v22 = 0;
            v23 = 0;
            v24 = 0;
            do
            {
              v25 = *(_QWORD *)(v21 + 32 * v18);
              mfs_getUnitDataFromMfsData(a2, *(_DWORD *)(v25 + v22), (uint64_t *)&v40);
              if (*((unsigned __int8 *)v40 + 13) == HIBYTE(v42))
              {
                if (v42 != *((unsigned __int8 *)v40 + 12))
                  mfs_CostList_UpdateCost((uint64_t)v9, v18, v23, *(float *)(v25 + v22 + 4) * 1.2);
                ++v24;
              }
              else
              {
                v26 = *(float *)(v25 + v22 + 4);
                if (v26 == 0.0)
                  v27 = 300.0;
                else
                  v27 = (float)(v26 * 1.2) * 300.0;
                mfs_CostList_UpdateCost((uint64_t)v9, v18, v23, v27);
              }
              ++v23;
              v21 = *(_QWORD *)(a3 + 1952);
              v22 += 8;
            }
            while (v23 < *(unsigned int *)(v21 + 32 * v18 + 16));
            v20 = a4;
            if (!v24)
            {
LABEL_34:
              MFS__log_select_Diag(*(_QWORD *)(a3 + 1928), 1, (uint64_t)"*** No CurMatch Candidates for (%d) (%d)\n");
              v21 = *(_QWORD *)(a3 + 1952);
            }
          }
          v28 = v21 + 32 * v18;
          v31 = *(_DWORD *)(v28 + 16);
          v30 = (signed int *)(v28 + 16);
          v29 = v31;
          v6 = a1;
          if (v31 >= 21)
          {
            if (*(_DWORD *)(a1 + 8240) >= (int)(float)(*(float *)(a1 + 8236) * (float)v29))
              v29 = (int)(float)(*(float *)(a1 + 8236) * (float)v29);
            else
              v29 = *(_DWORD *)(a1 + 8240);
          }
          v32 = *(_QWORD *)(a3 + 2016);
          *(_DWORD *)(v32 + 4 * v18) = v29;
          if (*(_DWORD *)(a1 + 8968) == 5 && (*(_BYTE *)(*v37 + v19) & 4) == 0)
          {
            v33 = *(_DWORD *)(a1 + 8244);
            if (v33 < *(_DWORD *)(a1 + 8240))
            {
              v29 = *v30;
              if (*v30 >= 21)
              {
                if (v33 >= (int)(float)(*(float *)(a1 + 8236) * (float)v29))
                  v29 = (int)(float)(*(float *)(a1 + 8236) * (float)v29);
                else
                  v29 = *(_DWORD *)(a1 + 8244);
              }
              *(_DWORD *)(v32 + 4 * v18) = v29;
            }
          }
          if (*v30 > v29)
          {
            v8 = mfs_CostList_SelectAndPrune(v9, v18, 1, v29);
            if ((v8 & 0x80000000) != 0)
              return v8;
          }
          ++v18;
        }
        while (v19++ <= *(int *)a2);
        v7 = v18;
LABEL_51:
        v11 = v36;
      }
      v36 = v11 + 1;
      if (v11 + 1 >= *(int *)(a3 + 608))
        return v8;
    }
  }
  return 0;
}

uint64_t mfs_StatisticalSelection_Obersee(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t *v14;
  uint64_t inited;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int **v26;
  uint64_t v27;
  int v28;
  int *v29;
  __int16 *v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  float v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  float v52;
  _QWORD *v53;
  int32x2_t v54;
  _QWORD *v55;
  uint64_t *v56;
  uint64_t v57;
  int v58;
  int *v59;
  int v60;
  int v61;
  uint64_t v62;
  float32x4_t **v63;
  float v64;
  float32x4_t *v65;
  float v66;
  float32x4_t *v67;
  int v68;
  float **v69;
  int v70;
  float v71;
  float *v72;
  float v73;
  float32x4_t *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t *v83;
  uint64_t v84;
  unsigned int v85;
  unsigned int UsedMemory;
  uint64_t v87;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  _QWORD *v97;
  int v98;
  int v99;
  uint64_t *v100;
  int v101;
  uint64_t v102;
  int v104;
  float32x4_t v105;
  unsigned int v106;
  _QWORD v107[2];

  v6 = *(_QWORD *)(a1 + 1928);
  v7 = *(unsigned int *)(a1 + 620);
  v107[0] = 0;
  *(_DWORD *)(a1 + 2580) = *(_DWORD *)(a1 + 2584);
  v96 = v6;
  if (*(_DWORD *)(a1 + 2592) != 1)
  {
    v8 = 2229280778;
    MFS__log_select_Diag(v6, 1, (uint64_t)"HybridStatisticalSelection(emfs obersee:%s) {\n");
    MFS__log_select_Diag(v6, 2, (uint64_t)"Search mode: MFS_SEARCHMODE_DRAGON_TAHOE\n");
    v47 = (uint64_t *)heap_Calloc(*(_QWORD **)(v6 + 8), 1, 18240);
    *(_QWORD *)(a1 + 2568) = v47;
    if (!v47)
      return v8;
    v102 = (uint64_t)v47;
    inited = mfs_uselect_Init_Obersee(v47, a1, (uint64_t)a3, a4);
    if ((inited & 0x80000000) != 0)
      goto LABEL_94;
    *(_DWORD *)(a1 + 2064) = 2;
    *(_DWORD *)(a1 + 1936) = v7;
    v48 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 1928) + 8), (2 * v7), 4);
    *(_QWORD *)(a1 + 2088) = v48;
    if (!v48)
      goto LABEL_95;
    v49 = v48 + 4 * v7;
    *(_QWORD *)(a1 + 2096) = v49;
    if ((_DWORD)v7)
    {
      v50 = 0;
      do
      {
        *(_DWORD *)(v49 + v50) = *(_DWORD *)(a4 + 8248);
        *(_DWORD *)(v48 + v50) = *(_DWORD *)(a4 + 8172);
        v50 += 4;
      }
      while (4 * v7 != v50);
    }
    inited = mfs_Search_InitPrefilter(v102);
    if ((inited & 0x80000000) != 0)
      goto LABEL_94;
    v99 = *a3;
    if (*a3 >= 0)
      v51 = *a3;
    else
      v51 = *a3 + 1;
    if ((*(_DWORD *)(a4 + 8968) - 7) >= 5)
      v52 = 1.0;
    else
      v52 = 2.0;
    v53 = MFS__ffcalloc(*(_QWORD **)(*(_QWORD *)(a1 + 1928) + 8), v7, 4);
    if (v53)
    {
      v55 = v53;
      v54.i32[0] = 1.0;
      if ((*(_DWORD *)(a4 + 8968) - 7) >= 5)
        *(float *)v54.i32 = (float)(*(float *)(a4 + 8160) + *(float *)(a4 + 8124)) + *(float *)(a4 + 8128);
      v56 = (uint64_t *)v102;
      if (*(int *)(a1 + 608) >= 1)
      {
        v57 = 0;
        v58 = 0;
        v59 = 0;
        v60 = v51 >> 1;
        if (v60 <= 2)
          v61 = 2;
        else
          v61 = v60;
        v98 = v61;
        v95 = v61 - 1;
        v101 = v60;
        v105 = (float32x4_t)vdupq_lane_s32(v54, 0);
        do
        {
          v62 = *(_QWORD *)(a1 + 600);
          if (v59)
          {
            if (v60 < *a3)
            {
              v63 = (float32x4_t **)&v55[v58];
              do
              {
                (*v63)->f32[0] = mfs_Ling_TransWeightsDiphADJ(*(_QWORD **)(a1 + 8), *v59) * *(float *)(a4 + 8160);
                (*v63)->f32[1] = mfs_Ling_TransWeightsDiphMCP(*(_QWORD **)(a1 + 8), *v59) * *(float *)(a4 + 8124);
                v64 = mfs_Ling_TransWeightsDiphLF0(*(_QWORD **)(a1 + 8), *v59);
                v65 = *v63++;
                v65->f32[2] = v64 * *(float *)(a4 + 8128);
                v65->i32[3] = 0;
                *v65 = vdivq_f32(*v65, v105);
                ++v60;
                ++v58;
              }
              while (v60 < *a3);
            }
            *(float *)v55[v58] = v52
                               * (float)(mfs_Ling_TransWeightsPhonADJ(*(_QWORD **)(a1 + 8), *v59) * *(float *)(a4 + 8160));
            *(float *)(v55[v58] + 4) = v52
                                       * (float)(mfs_Ling_TransWeightsPhonMCP(*(_QWORD **)(a1 + 8), *v59)
                                               * *(float *)(a4 + 8124));
            v66 = mfs_Ling_TransWeightsPhonLF0(*(_QWORD **)(a1 + 8), *v59);
            v67 = (float32x4_t *)v55[v58];
            v67->f32[2] = v52 * (float)(v66 * *(float *)(a4 + 8128));
            v67->i32[3] = 0;
            *v67 = vdivq_f32(*v67, v105);
            v68 = v58 + 1;
            v56 = (uint64_t *)v102;
            v60 = v101;
            if (v99 >= 4)
            {
              v69 = (float **)&v55[v68];
              v68 = v98 + v58;
              v70 = v95;
              do
              {
                v71 = v52 * (float)(mfs_Ling_TransWeightsDiphADJ(*(_QWORD **)(a1 + 8), *v59) * *(float *)(a4 + 8160));
                v72 = *v69;
                **v69 = v71;
                if ((*(_DWORD *)(a4 + 8968) - 7) <= 4 && v59[6] == *a3)
                  *v72 = v71 + 1.0;
                (*v69)[1] = v52
                          * (float)(mfs_Ling_TransWeightsDiphMCP(*(_QWORD **)(a1 + 8), *v59) * *(float *)(a4 + 8124));
                v73 = mfs_Ling_TransWeightsDiphLF0(*(_QWORD **)(a1 + 8), *v59);
                v74 = (float32x4_t *)*v69++;
                v74->f32[2] = v52 * (float)(v73 * *(float *)(a4 + 8128));
                v74->i32[3] = 0;
                *v74 = vdivq_f32(*v74, v105);
                --v70;
              }
              while (v70);
              v56 = (uint64_t *)v102;
              v60 = v101;
            }
          }
          else
          {
            v68 = v58 + v60;
          }
          v59 = (int *)(v62 + 528 * v57++);
          v58 = v68;
        }
        while (v57 < *(int *)(a1 + 608));
      }
      *(_QWORD *)(a1 + 2072) = v55;
      v75 = v56[72];
      v76 = v56[73];
      v77 = *(_DWORD *)(v76 + 1096);
      v78 = v56;
      v79 = mfs_Viterbi_Init_Obersee((uint64_t)(v56 + 106), *v56, v76, v75, (uint64_t)(v56 + 203));
      if ((v79 & 0x80000000) == 0)
      {
        v80 = v75 + 2144;
        inited = mfs_S32Vect_Reserve(v75 + 2144, *(_DWORD *)(v78[72] + 1936));
        v6 = v96;
        if ((inited & 0x80000000) == 0)
        {
          v81 = v75 + 2168;
          v8 = mfs_F32Vect_Create(v81, *(_DWORD *)(v78[72] + 1936));
          if ((v8 & 0x80000000) != 0)
            goto LABEL_95;
          if (*(_DWORD *)(v78[72] + 1936))
          {
            v82 = 0;
            do
            {
              v8 = mfs_F32Vect_Pad(v81, 0.0);
              if ((v8 & 0x80000000) != 0)
                goto LABEL_100;
              mfs_S32Vect_Add(v80, v77 - 1);
              ++v82;
              v83 = (uint64_t *)v102;
            }
            while (v82 < *(_DWORD *)(*(_QWORD *)(v102 + 576) + 1936));
            v6 = v96;
          }
          else
          {
            v83 = v78;
          }
          MFS__log_select_Diag(*v83, 3, (uint64_t)"viterbi::init  SegsDp %d\n");
          v10 = v102;
          v9 = 0;
          goto LABEL_3;
        }
LABEL_94:
        v8 = inited;
        goto LABEL_95;
      }
      v8 = v79;
    }
LABEL_100:
    v6 = v96;
    goto LABEL_95;
  }
  v8 = 0;
  v9 = *(_DWORD *)(a1 + 2576);
  *(_DWORD *)(a1 + 2576) = 0;
  v10 = *(_QWORD *)(a1 + 2568);
LABEL_3:
  v102 = v10;
  if (v9 >= *(_DWORD *)(a1 + 608))
    goto LABEL_106;
  v11 = v10 + 600;
  v100 = (uint64_t *)(v10 + 848);
  v97 = (_QWORD *)(v10 + 8);
  v12 = v9;
  v93 = v10 + 600;
  while (2)
  {
    v13 = v12;
    v94 = v12;
    v14 = (uint64_t *)v10;
    MFS__log_select_Diag(v6, 3, (uint64_t)"phoneme %d %d %d\n");
    ForcedEEController_TimeGet(a2, (_DWORD *)v107 + 1);
    inited = mfs_Search_FindNodeCandidates_StatSelect_Obersee((uint64_t)v14, v13);
    if ((inited & 0x80000000) != 0)
      goto LABEL_94;
    inited = mfs_PruneDPListOnContext_Obersee(v14, v13);
    if ((inited & 0x80000000) != 0)
      goto LABEL_94;
    if (ForcedEEController_TimeGet(a2, v107))
      MFS__log_select_Diag(v6, 1, (uint64_t)"Timing phoneme %d Prefilter : elapsetime : %u msecs  (number of candidates : %u %u %u)\n");
    v16 = *(uint64_t **)(a1 + 2640);
    if (v16)
    {
      v17 = 0;
      v18 = *((_DWORD *)v16 + 5);
      v19 = *v16;
      do
      {
        v20 = v18 + v17 + 3 * v94;
        if (*(_DWORD *)(v19 + 48 * v20) == 1)
        {
          v21 = *(_QWORD *)(v11 + 80 * v17 + 32);
          v22 = -1431655765 * ((unint64_t)(*(_QWORD *)(v11 + 80 * v17 + 40) - v21) >> 3);
          if ((_DWORD)v22)
          {
            v23 = 0;
            v24 = v19 + 48 * v20;
            v25 = *(unsigned int *)(v24 + 24);
            v26 = (int **)(v24 + 8);
            do
            {
              if ((_DWORD)v25)
              {
                v27 = v21 + 24 * v23;
                v28 = *(_DWORD *)(v27 + 4);
                v29 = *v26;
                v30 = (__int16 *)(v27 + 8);
                v31 = v25;
                do
                {
                  v32 = *v29++;
                  if (v28 == v32)
                  {
                    v33 = (unsigned __int16)*v30;
                    if (v33 > 0xEC77)
                      v34 = -1;
                    else
                      v34 = v33 + 5000;
                    *v30 = v34;
                  }
                  --v31;
                }
                while (v31);
              }
              ++v23;
            }
            while (v23 != v22);
          }
        }
        ++v17;
      }
      while (v17 != 3);
      v104 = 3 * v94;
    }
    else
    {
      v104 = 3 * v94;
    }
    v35 = 0;
    v36 = (uint64_t)v97;
    do
    {
      ForcedEEController_TimeGet(a2, (_DWORD *)v107 + 1);
      v37 = -1431655765 * ((*(_QWORD *)(v11 + 40) - *(_QWORD *)(v11 + 32)) >> 3);
      if (v37 >= 21)
      {
        v38 = (float)v37;
        v39 = *(_QWORD *)(v102 + 592);
        v40 = (int)(float)(*(float *)(v39 + 8236) * v38);
        v37 = *(_DWORD *)(v39 + 8240);
        if (v37 >= v40)
          v37 = v40;
      }
      v41 = v104 + v35;
      v42 = *(_DWORD *)(v102 + 840);
      if (v37)
      {
        if (v42 != -1)
          goto LABEL_34;
        *(_DWORD *)(v102 + 840) = v41;
        v43 = mfs_Viterbi_Reset_Obersee((uint64_t)v100, v41);
        if ((v43 & 0x80000000) == 0)
        {
          MFS__log_select_Diag(*(_QWORD *)v102, 3, (uint64_t)"viterbi::start path %d\n");
          v36 = (uint64_t)v97;
LABEL_34:
          v8 = mfs_Viterbi_DecodeState_MCP_S9_LF0_S8_X2B_Obersee((uint64_t)v100, v11);
          goto LABEL_41;
        }
        v8 = v43;
        v36 = (uint64_t)v97;
      }
      else if (v42 == -1)
      {
        v8 = 0;
      }
      else
      {
        MFS__log_select_Diag(*(_QWORD *)v102, 3, (uint64_t)"Stopping viterbi at frame %u because of a dead part\n");
        v44 = *(_QWORD *)(v102 + 576);
        MFS__log_select_Diag(*(_QWORD *)v102, 3, (uint64_t)"viterbi::end path %d\n");
        v8 = mfs_Viterbi_ResultScore_Obersee((uint64_t)v100, v44 + 2144, v44 + 2168);
        if ((v8 & 0x80000000) == 0)
          *(_DWORD *)(v102 + 840) = -1;
        v6 = v96;
        v36 = (uint64_t)v97;
      }
LABEL_41:
      if (ForcedEEController_TimeGet(a2, v107))
        MFS__log_select_Diag(v6, 1, (uint64_t)"Timing phoneme %d Viterbi state %d  : elapsetime  %u msecs\n");
      if ((v8 & 0x80000000) != 0)
        goto LABEL_95;
      mfs_CandidateList_Reset_Obersee(v11, *(_QWORD *)(v6 + 8), v36);
      ++v35;
      v11 += 80;
    }
    while (v35 != 3);
    v12 = v94 + 1;
    v45 = *(_DWORD *)(a1 + 608);
    if (!*(_DWORD *)(a4 + 8564))
    {
      v11 = v93;
LABEL_50:
      v10 = v102;
      if (v12 >= v45)
        goto LABEL_106;
      continue;
    }
    break;
  }
  v11 = v93;
  if (v12 >= v45)
    goto LABEL_50;
  if (!mfs_Viterbi_IsEarlyEmissionPossible(v100, a2, *(_DWORD *)(a1 + 2584)))
  {
    v45 = *(_DWORD *)(a1 + 608);
    goto LABEL_50;
  }
  v85 = *(_DWORD *)(v102 + 1452);
  mfs_Search_StopViterbi((uint64_t *)v102, (3 * v12), 1);
  UsedMemory = fastallo_GetUsedMemory((uint64_t)v97);
  if (UsedMemory > *(_DWORD *)(v102 + 568))
    *(_DWORD *)(v102 + 568) = UsedMemory;
  fastallo_Terminate(v97);
  fastallo_Init(v97, *(_QWORD *)(*(_QWORD *)v102 + 8), 4096);
  *(_DWORD *)(a1 + 2592) = 0;
  *(_DWORD *)(a1 + 2576) = v12;
  *(_DWORD *)(a1 + 2584) = v85;
  mfs_Search_LogSelectedUnits((uint64_t *)v102, *(_DWORD *)(a1 + 2580), v85);
  MFS__log_select_Diag(v6, 3, (uint64_t)"previous units were emitted via early emission at phoneme %d\n");
  v87 = mfs_UnitSequence_SequenceEarlyEmission_Obersee((uint64_t *)v102, *(_DWORD *)(a1 + 2580), *(_DWORD *)(a1 + 2584));
  v10 = v102;
  v8 = v87;
  if ((v87 & 0x80000000) != 0)
  {
LABEL_95:
    v84 = mfs_uselect_Finalize_Obersee((uint64_t *)v102);
    if ((v84 & 0x80000000) != 0)
    {
      return v84;
    }
    else
    {
      *(_DWORD *)(a1 + 2592) = 2;
      if ((v8 & 0x80000000) == 0)
        goto LABEL_107;
    }
  }
  else
  {
LABEL_106:
    mfs_Search_EndPrefilterRun(v10);
    if (!*(_DWORD *)(a1 + 2576))
    {
      *(_DWORD *)(a1 + 2584) = 3 * *(_DWORD *)(a1 + 608);
      v8 = mfs_Search_FinishViterbi(v102);
      if ((v8 & 0x80000000) != 0)
        goto LABEL_95;
      if (!*(_DWORD *)(a1 + 2200) && !*(_DWORD *)(a4 + 8564))
      {
        FreeRemainingStreams(a1);
        v89 = *(_DWORD *)(a1 + 32);
        if (v89 >= 1)
        {
          v90 = 0;
          v91 = 12;
          do
          {
            v92 = *(_QWORD *)(a1 + 24);
            if (*(_DWORD *)(v92 + v91) != 2)
            {
              MFS__FreePStreamParam((_QWORD *)(v92 + v91 + 12));
              v89 = *(_DWORD *)(a1 + 32);
            }
            ++v90;
            v91 += 1528;
          }
          while (v90 < v89);
        }
      }
      MFS__log_select_Diag(v6, 1, (uint64_t)"}\n");
      if (!*(_DWORD *)(a1 + 2576))
        goto LABEL_95;
    }
LABEL_107:
    if (!ForcedEEController_HasStartedPlayback(a2))
    {
      v106 = 0;
      if (*(_DWORD *)(a4 + 8588) == -1
        || (paramc_ParamGetUInt(*(_QWORD *)(v6 + 40), (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", &v106) & 0x80000000) != 0|| v106 >= *(_DWORD *)(a4 + 8588))
      {
        ForcedEEController_SetStartedPlayback(a2);
      }
    }
  }
  return v8;
}

uint64_t mfs_Search_StopViterbi(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;

  v4 = a1[72];
  v5 = *a1;
  if (a3)
    v6 = "viterbi::early emission:at state index %d we have a fully determined path up to state index %d\n";
  else
    v6 = "viterbi::end path %d\n";
  MFS__log_select_Diag(v5, 3, (uint64_t)v6);
  return mfs_Viterbi_ResultScore_Obersee((uint64_t)(a1 + 106), v4 + 2144, v4 + 2168);
}

uint64_t *mfs_Search_LogSelectedUnits(uint64_t *result, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _OWORD v8[2];

  v3 = a3 - a2;
  if (a3 > a2)
  {
    v4 = result;
    v5 = *result;
    v6 = result[72];
    v7 = a2;
    do
    {
      memset(v8, 0, sizeof(v8));
      mfs_getUnitData_Obersee(v4[73], *v4, *(_DWORD *)(*(_QWORD *)(v6 + 2152) + 4 * v7), (uint64_t)v8);
      result = (uint64_t *)MFS__log_select_Diag(v5, 3, (uint64_t)"unit %d: %d %f\n");
      ++v7;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t mfs_Search_FinishViterbi(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t UnitData_Obersee;
  uint64_t v6;
  uint64_t v7;
  _OWORD *v8;
  int v9;
  int v10;
  float v11;
  uint64_t v12;
  _OWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  float v18;
  unsigned int v19;
  int v20;
  _DWORD *v21;
  int v22;
  uint64_t i;
  unsigned int UsedMemory;
  uint64_t v26;
  _OWORD v27[4];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)a1;
  v3 = *(_QWORD *)(a1 + 576);
  v4 = (_QWORD *)(v3 + 2168);
  if (*(_DWORD *)(a1 + 840) == -1)
  {
    UnitData_Obersee = 0;
  }
  else
  {
    MFS__log_select_Diag(v2, 3, (uint64_t)"viterbi::end path %d\n");
    UnitData_Obersee = mfs_Viterbi_ResultScore_Obersee(a1 + 848, v3 + 2144, v3 + 2168);
    if ((UnitData_Obersee & 0x80000000) != 0)
      goto LABEL_30;
  }
  if (MFS__log_select_GetLogLevel(*(_QWORD *)(v2 + 32)) < 2)
    goto LABEL_25;
  if (MFS__log_select_GetLogLevel(*(_QWORD *)(v2 + 32)) >= 3)
    mfs_Search_LogSelectedUnits((uint64_t *)a1, *(_DWORD *)(*(_QWORD *)(a1 + 576) + 2580), *(_DWORD *)(v3 + 2160) - 1);
  LODWORD(v6) = *(_DWORD *)(v3 + 2160);
  if ((int)v6 < 1)
  {
    v9 = 0;
    v11 = 0.0;
LABEL_22:
    v20 = v6 - v9;
    if (v20 >= 1)
      exp((float)(v11 / (float)v20));
    MFS__log_select_Diag(v2, 2, (uint64_t)"ACC : %f\n");
LABEL_25:
    v21 = *(_DWORD **)(a1 + 576);
    if (v21[569])
    {
      mfs_UnitSequence_SequenceEarlyEmission_Obersee((uint64_t *)a1, v21[645], 3 * v21[152]);
    }
    else
    {
      UnitData_Obersee = mfs_UnitSequence_Sequence_Obersee((uint64_t)(v21 + 528), (uint64_t)(v21 + 562), *(_QWORD *)a1);
      if ((UnitData_Obersee & 0x80000000) != 0)
      {
LABEL_30:
        if (MFS__log_select_GetLogLevel(*(_QWORD *)(v2 + 32)) >= 0x16)
        {
          v22 = 0;
          for (i = 600; i != 840; i += 80)
            v22 += mfs_CandidateList_GetUsedMemory((_DWORD *)(a1 + i));
          MFS__log_select_Diag(*(_QWORD *)a1, 9, (uint64_t)"memstats:%d candidate lists mem usage: %d bytes\n");
          UsedMemory = fastallo_GetUsedMemory(a1 + 8);
          if (UsedMemory > *(_DWORD *)(a1 + 568))
            *(_DWORD *)(a1 + 568) = UsedMemory;
          MFS__log_select_Diag(*(_QWORD *)a1, 9, (uint64_t)"memstats:candidatelist unit data cache: %d bytes (unit data size %d)\n");
          mfs_Viterbi_DumpHeapStats((uint64_t *)(a1 + 848));
          MFS__log_select_Diag(*(_QWORD *)a1, 9, (uint64_t)"memstats:Obersee huffman uncompress buffer: %d bytes\n");
          MFS__log_select_Diag(*(_QWORD *)a1, 9, (uint64_t)"memstats:Obersee uselect total mem usage: %d bytes\n");
        }
        mfs_Viterbi_DeInit_Obersee(a1 + 848);
        mfs_F32Vect_Clear(v4);
        MFS__log_select_Diag(v2, 3, (uint64_t)"viterbi::finish\n");
        return UnitData_Obersee;
      }
    }
    if (MFS__log_select_GetLogLevel(*(_QWORD *)(v2 + 32)) >= 3)
      mfs_UnitSequence_Log(*(_QWORD *)(a1 + 576) + 2112);
    goto LABEL_30;
  }
  v26 = v2;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = *(_DWORD *)(*(_QWORD *)(a1 + 584) + 1096) - 1;
  v11 = 0.0;
  while (1)
  {
    v12 = v7 & 1;
    v13 = &v27[2 * v12];
    UnitData_Obersee = mfs_getUnitData_Obersee(*(_QWORD *)(a1 + 584), *(_QWORD *)a1, *(_DWORD *)(*(_QWORD *)(v3 + 2152) + 4 * v7), (uint64_t)v13);
    if ((UnitData_Obersee & 0x80000000) != 0)
      return UnitData_Obersee;
    if (v7)
    {
      v14 = *(_QWORD *)(v3 + 2152);
      if (*(_DWORD *)(v14 + 4 * (v7 - 1)) == v10 || *(_DWORD *)(v14 + 4 * v7) == v10)
      {
        ++v9;
      }
      else
      {
        v15 = *(_QWORD *)(a1 + 584);
        v16 = *(_QWORD *)(a1 + 576);
        v17 = *((_DWORD *)v8 + 3);
        v18 = 0.0;
        if (v17 <= 0xFF)
        {
          v19 = WORD1(v27[2 * v12 + 1]);
          if (v19 <= 0xFF)
            v18 = *(float *)(*(_QWORD *)(*(_QWORD *)(v16 + 2072) + 8 * v7) + 8)
                * *(float *)(*(_QWORD *)(v15 + 2152) + 4 * (v17 + (v19 << 8)));
        }
        v11 = v11
            + (float)(v18
                    + (float)(*(float *)(*(_QWORD *)(*(_QWORD *)(v16 + 2072) + 8 * v7) + 4)
                            * *(float *)(*(_QWORD *)(v15 + 2136)
                                       + 4
                                       * (*((unsigned __int16 *)v8 + 8)
                                        + ((unint64_t)WORD2(v27[2 * v12 + 1]) << 9)))));
      }
    }
    ++v7;
    v6 = *(int *)(v3 + 2160);
    v8 = v13;
    if (v7 >= v6)
    {
      v4 = (_QWORD *)(v3 + 2168);
      v2 = v26;
      goto LABEL_22;
    }
  }
}

uint64_t mfs_SwapItem_Obersee(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  int v4;

  if (a3)
  {
    v3 = 0;
    do
    {
      v4 = *(_DWORD *)(result + v3);
      *(_DWORD *)(result + v3) = *(_DWORD *)(a2 + v3);
      *(_DWORD *)(a2 + v3) = v4;
      v3 += 4;
    }
    while (v3 < a3);
  }
  return result;
}

uint64_t mfs_Array_QSelect_Obersee(uint64_t a1, int a2, unsigned int a3, uint64_t (*a4)(uint64_t, uint64_t), unsigned int a5)
{
  unsigned int v6;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v25;
  unsigned int v27;
  unsigned int v28;

  v25 = a5 * a3;
  v6 = a2 - 1;
  if (a2 != 1)
  {
    v9 = 0;
    v27 = 0;
    v10 = a1 + v25;
    do
    {
      v11 = a1 + v6 * a3;
      if (a3)
      {
        v12 = 0;
        do
        {
          v13 = *(_DWORD *)(v10 + v12);
          *(_DWORD *)(v10 + v12) = *(_DWORD *)(v11 + v12);
          *(_DWORD *)(v11 + v12) = v13;
          v12 += 4;
        }
        while (v12 < a3);
      }
      v14 = v9;
      v28 = v6;
      if (v9 < v6)
      {
        v15 = v9;
        v16 = a3 * v9;
        v14 = v9;
        do
        {
          if ((a4(a1 + v15 * a3, v11) & 0x80000000) != 0)
          {
            if (a3)
            {
              v17 = 0;
              v18 = a1 + v16;
              v19 = a1 + v14 * a3;
              do
              {
                v20 = *(_DWORD *)(v18 + v17);
                *(_DWORD *)(v18 + v17) = *(_DWORD *)(v19 + v17);
                *(_DWORD *)(v19 + v17) = v20;
                v17 += 4;
              }
              while (v17 < a3);
            }
            ++v14;
          }
          ++v15;
          v16 += a3;
        }
        while (v15 != v28);
      }
      if (a3)
      {
        v21 = 0;
        v22 = a1 + v14 * a3;
        do
        {
          v23 = *(_DWORD *)(v11 + v21);
          *(_DWORD *)(v11 + v21) = *(_DWORD *)(v22 + v21);
          *(_DWORD *)(v22 + v21) = v23;
          v21 += 4;
        }
        while (v21 < a3);
      }
      v6 = v28;
      if (v14 == a5)
        break;
      if (v14 >= a5)
        v6 = v14 - 1;
      else
        v9 = v14 + 1;
      ++v27;
    }
    while (v27 < v6);
  }
  return a1 + v25;
}

uint64_t qsortex(uint64_t result, unsigned int a2, uint64_t a3, uint64_t (*a4)(char *, char *, uint64_t), uint64_t a5)
{
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  int v15;
  BOOL v16;
  __int16 v17;
  int v18;
  char *v19;
  char v20;
  uint64_t v21;
  int v22;
  int v23;
  __int16 v24;
  int v25;
  char *v26;
  char *v27;
  char v28;
  uint64_t v29;
  int v30;
  __int16 v31;
  int v32;
  char *v33;
  char *v34;
  char v35;
  uint64_t v36;
  int v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  char *v43;
  char *v44;
  __int16 v45;
  uint64_t v46;
  int v47;
  char *v48;
  char v49;
  uint64_t v50;
  char *v51;
  int v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  __int16 v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  int v62;
  unsigned int v63;
  int v64;
  char *v65;
  unsigned int v66;
  char *v67;
  _OWORD v68[31];
  _OWORD v69[31];
  uint64_t v70;

  v70 = *MEMORY[0x24BDAC8D0];
  memset(v69, 0, sizeof(v69));
  memset(v68, 0, sizeof(v68));
  if (a2 >= 2)
  {
    v7 = a3;
    v8 = (char *)result;
    v64 = 0;
    v9 = (char *)(result + (a2 - 1) * a3);
    v10 = a3;
    v66 = a3 % 3;
    v11 = -(uint64_t)a3;
    while (2)
    {
      while (2)
      {
        v67 = v9;
        while (1)
        {
          v12 = (v9 - v8) / v10 + 1;
          if (v12 <= 8)
          {
            if (v9 > v8)
            {
              v54 = v8;
              v55 = &v8[v10];
              do
              {
                v56 = v54;
                if (v55 <= v9)
                {
                  v57 = v55;
                  do
                  {
                    result = a4(v57, v54, a5);
                    if ((int)result > 0)
                      v54 = v57;
                    v57 += v10;
                  }
                  while (v57 <= v9);
                }
                if (v54 != v9)
                {
                  if ((_DWORD)v7 == 2)
                  {
                    v58 = *(_WORD *)v54;
                    *(_WORD *)v54 = *(_WORD *)v9;
                    *(_WORD *)v9 = v58;
                  }
                  else if (v66)
                  {
                    if ((_DWORD)v7)
                    {
                      v59 = 0;
                      do
                      {
                        v60 = v54[v59];
                        v54[v59] = v9[v59];
                        v9[v59++] = v60;
                      }
                      while ((_DWORD)v10 != (_DWORD)v59);
                    }
                  }
                  else if ((_DWORD)v7)
                  {
                    v61 = 0;
                    do
                    {
                      v62 = *(_DWORD *)&v54[v61];
                      *(_DWORD *)&v54[v61] = *(_DWORD *)&v9[v61];
                      *(_DWORD *)&v9[v61] = v62;
                      v61 += 4;
                    }
                    while (v61 < v7);
                  }
                }
                v9 += v11;
                v54 = v56;
              }
              while (v9 > v56);
            }
            goto LABEL_107;
          }
          v13 = (v12 >> 1) * v7;
          v14 = &v8[v13];
          v15 = a4(v8, &v8[v13], a5);
          if ((_DWORD)v13)
            v16 = v15 < 1;
          else
            v16 = 1;
          if (!v16)
          {
            if ((_DWORD)v7 == 2)
            {
              v17 = *(_WORD *)v8;
              *(_WORD *)v8 = *(_WORD *)v14;
              *(_WORD *)v14 = v17;
            }
            else if (v66)
            {
              if ((_DWORD)v7)
              {
                v18 = v7;
                v19 = v8;
                do
                {
                  v20 = *v19;
                  *v19 = v19[v13];
                  v19[v13] = v20;
                  ++v19;
                  --v18;
                }
                while (v18);
              }
            }
            else if ((_DWORD)v7)
            {
              v21 = 0;
              do
              {
                v22 = *(_DWORD *)&v8[v21];
                *(_DWORD *)&v8[v21] = *(_DWORD *)&v14[v21];
                *(_DWORD *)&v14[v21] = v22;
                v21 += 4;
              }
              while (v21 < v7);
            }
          }
          v23 = a4(v8, v9, a5);
          if (v8 != v9 && v23 >= 1)
          {
            if ((_DWORD)v7 == 2)
            {
              v24 = *(_WORD *)v8;
              *(_WORD *)v8 = *(_WORD *)v9;
              *(_WORD *)v9 = v24;
            }
            else if (v66)
            {
              if ((_DWORD)v7)
              {
                v25 = v7;
                v26 = v9;
                v27 = v8;
                do
                {
                  v28 = *v27;
                  *v27++ = *v26;
                  *v26++ = v28;
                  --v25;
                }
                while (v25);
              }
            }
            else if ((_DWORD)v7)
            {
              v29 = 0;
              do
              {
                v30 = *(_DWORD *)&v8[v29];
                *(_DWORD *)&v8[v29] = *(_DWORD *)&v9[v29];
                *(_DWORD *)&v9[v29] = v30;
                v29 += 4;
              }
              while (v29 < v7);
            }
          }
          v65 = v8;
          result = a4(&v8[v13], v9, a5);
          if (v14 != v9 && (int)result >= 1)
          {
            if ((_DWORD)v7 == 2)
            {
              v31 = *(_WORD *)v14;
              *(_WORD *)v14 = *(_WORD *)v9;
              *(_WORD *)v9 = v31;
            }
            else if (v66)
            {
              if ((_DWORD)v7)
              {
                v32 = v7;
                v33 = v9;
                v34 = &v8[v13];
                do
                {
                  v35 = *v34;
                  *v34++ = *v33;
                  *v33++ = v35;
                  --v32;
                }
                while (v32);
              }
            }
            else if ((_DWORD)v7)
            {
              v36 = 0;
              do
              {
                v37 = *(_DWORD *)&v14[v36];
                *(_DWORD *)&v14[v36] = *(_DWORD *)&v9[v36];
                *(_DWORD *)&v9[v36] = v37;
                v36 += 4;
              }
              while (v36 < v7);
            }
          }
          v38 = v9;
          v39 = v65;
          while (1)
          {
            if (v14 > v39)
            {
              v40 = &v39[v10];
              do
              {
                v39 = v40;
                if (v40 >= v14)
                  break;
                result = a4(v40, v14, a5);
                v40 = &v39[v10];
              }
              while ((int)result < 1);
            }
            if (v14 <= v39)
            {
              v41 = &v39[v10];
              do
              {
                v39 = v41;
                if (v41 > v9)
                  break;
                result = a4(v41, v14, a5);
                v41 = &v39[v10];
              }
              while ((int)result < 1);
            }
            v42 = v7;
            v43 = &v38[v11];
            do
            {
              v9 = v38;
              v44 = v43;
              v38 += v11;
              if (v38 <= v14)
                break;
              result = a4(v38, v14, a5);
              v43 = &v44[v11];
            }
            while ((int)result > 0);
            if (v38 < v39)
              break;
            v7 = v42;
            if (v38 != v39)
            {
              if ((_DWORD)v42 == 2)
              {
                v45 = *(_WORD *)v39;
                *(_WORD *)v39 = *(_WORD *)v38;
                *(_WORD *)v38 = v45;
              }
              else if (v66)
              {
                if ((_DWORD)v42)
                {
                  v46 = v11;
                  v47 = v42;
                  v48 = v39;
                  do
                  {
                    v49 = *v48;
                    *v48++ = v9[v46];
                    v9[v46++] = v49;
                    --v47;
                  }
                  while (v47);
                }
              }
              else if ((_DWORD)v42)
              {
                v50 = 0;
                v51 = &v9[v11];
                do
                {
                  v52 = *(_DWORD *)&v39[v50];
                  *(_DWORD *)&v39[v50] = *(_DWORD *)&v51[v50];
                  *(_DWORD *)&v51[v50] = v52;
                  v50 += 4;
                }
                while (v50 < v42);
              }
            }
            if (v38 == v14)
              v14 = v39;
            v9 = v67;
          }
          v8 = v65;
          if (v14 < v9)
          {
            do
            {
              v9 = v44;
              if (v44 <= v14)
                break;
              result = a4(v44, v14, a5);
              v44 += v11;
            }
            while (!(_DWORD)result);
          }
          if (v14 >= v9)
          {
            v53 = &v9[v11];
            v7 = v42;
            do
            {
              v9 = v53;
              if (v53 <= v65)
                break;
              result = a4(v53, v14, a5);
              v53 = &v9[v11];
            }
            while (!(_DWORD)result);
          }
          else
          {
            v7 = v42;
          }
          if (v9 - v65 < v67 - v39)
            break;
          if (v65 < v9)
          {
            *((_QWORD *)v69 + v64) = v65;
            *((_QWORD *)v68 + v64++) = v9;
          }
          v8 = v39;
          v9 = v67;
          if (v39 >= v67)
            goto LABEL_107;
        }
        if (v39 < v67)
        {
          *((_QWORD *)v69 + v64) = v39;
          *((_QWORD *)v68 + v64++) = v67;
        }
        if (v65 < v9)
          continue;
        break;
      }
LABEL_107:
      v63 = v64 - 1;
      if (v64 >= 1)
      {
        v8 = (char *)*((_QWORD *)v69 + v63);
        --v64;
        v9 = (char *)*((_QWORD *)v68 + v63);
        continue;
      }
      break;
    }
  }
  return result;
}

uint64_t mfs_FSM_Load(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int *v4;
  uint64_t v5;
  BOOL v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  char *v10;
  _DWORD *v11;
  char *v12;
  unint64_t v13;

  result = 2229280772;
  v4 = *(int **)(a2 + 8);
  v5 = *(unsigned int *)(a2 + 16);
  if (v4)
    v6 = (_DWORD)v5 == 0;
  else
    v6 = 1;
  if (!v6)
  {
    v7 = *v4;
    *(_DWORD *)a1 = *v4;
    if (v5 >= 5)
    {
      v8 = v4[1];
      *(_DWORD *)(a1 + 4) = v8;
      if (v5 >= 9)
      {
        v9 = v4[2];
        *(_DWORD *)(a1 + 8) = v9;
        if (v5 >= 0xD)
        {
          v10 = (char *)v4 + v5;
          v11 = v4 + 3;
          *(_QWORD *)(a1 + 16) = v11;
          v12 = (char *)&v11[2 * (v7 + 1)];
          if (v12 < v10)
          {
            *(_QWORD *)(a1 + 24) = v12;
            v13 = (unint64_t)&v12[8 * v8];
            if (v13 < (unint64_t)v10)
            {
              *(_QWORD *)(a1 + 32) = v13;
              if ((char *)(v13 + 12 * v9) == v10)
                return 0;
              else
                return 2229280772;
            }
          }
        }
      }
    }
  }
  return result;
}

void *mfs_FSM_DeInit(void *a1)
{
  return cstdlib_memset(a1, 0, 0x28uLL);
}

uint64_t mfs_HarchData_Load(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;

  *(_QWORD *)a1 = a2;
  v2 = *(_DWORD *)(a2 + 13552);
  *(_DWORD *)(a1 + 28) = v2 / 0xC;
  if (v2 >= 0xC)
  {
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 13544);
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 13064);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 13304);
  }
  v3 = *(_DWORD *)(a2 + 14272);
  *(_DWORD *)(a1 + 24) = v3 / 0xC;
  if (v3 >= 0xC)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 14264);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 13784);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 14024);
  }
  return 0;
}

void *mfs_HarchData_DeInit(void *a1)
{
  return cstdlib_memset(a1, 0, 0x40uLL);
}

uint64_t mfs_Harch_Init(uint64_t a1, void *__b)
{
  cstdlib_memset(__b, 0, 0x98uLL);
  mfs_S32Vect_Init(a1, (_QWORD *)__b + 12);
  return mfs_S32Vect_Init(a1, (_QWORD *)__b + 15);
}

_QWORD *mfs_Harch_DeInit(uint64_t a1)
{
  mfs_S32Vect_Clear((_QWORD *)(a1 + 96));
  return mfs_S32Vect_Clear((_QWORD *)(a1 + 120));
}

uint64_t mfs_Harch_Search(uint64_t a1, uint64_t *a2, uint64_t **a3, uint64_t a4, int a5)
{
  int v5;
  uint64_t v9;
  uint64_t *v10;
  char v11;
  char v12;
  uint64_t v13;
  int v14;
  _DWORD *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  _BYTE *v21;
  _BYTE *v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t i;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t *v37;
  uint64_t v38;
  unint64_t v39;
  int v40;
  char v42;
  char v43;
  unsigned int v45;
  uint64_t *v46;
  _BYTE v48[41];
  uint64_t v49;

  v5 = a5;
  v9 = 0;
  v45 = 0;
  v49 = *MEMORY[0x24BDAC8D0];
  *a3 = a2;
  v10 = (uint64_t *)(a3 + 1);
  v11 = 1;
  v46 = (uint64_t *)(a3 + 1);
  do
  {
    v12 = v11;
    if (!*((_DWORD *)*a3 + v9 + 6))
      goto LABEL_46;
    v13 = (uint64_t)a3 + 4 * v9;
    v16 = *(_DWORD *)(v13 + 88);
    v15 = (_DWORD *)(v13 + 88);
    v14 = v16;
    if (v16)
    {
      *v15 = v14 - 1;
      goto LABEL_46;
    }
    if ((v12 & 1) != 0)
    {
      *((_DWORD *)a3 + 22) = 0;
      *((_BYTE *)a3 + 8) = 0;
      if (mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v5) != 1)
      {
        v42 = mfs_Ling_SylPos(*(_QWORD *)(a4 + 8), v5);
        v17 = 0;
        v18 = v5;
        do
        {
          v19 = mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v18);
          if (v19 != 1)
            *((_BYTE *)v10 + v17++) = v19;
          ++v18;
        }
        while (v18 < *(_DWORD *)(a4 + 608) && !mfs_Ling_IsSyllableBegin(*(_QWORD *)(a4 + 8), v18) && v17 < 39);
        v20 = mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v18);
        if (v20 != 1)
          *((_BYTE *)v10 + v17++) = v20;
        *((_DWORD *)a3 + 22) = v17 - 1;
        v21 = (char *)v10 + v17;
        *v21 = v42;
        v22 = v21 + 1;
LABEL_26:
        *v22 = 0;
      }
    }
    else
    {
      *((_DWORD *)a3 + 23) = 0;
      *((_BYTE *)a3 + 48) = 0;
      if (mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v5) != 1)
      {
        v43 = mfs_Ling_WrdPosInPhrs(*(_QWORD *)(a4 + 8), v5);
        v23 = 0;
        v24 = v5;
        do
        {
          v25 = mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v24);
          if (v25 != 1)
          {
            v26 = (uint64_t)a3 + v23++;
            *(_BYTE *)(v26 + 48) = v25;
          }
          ++v24;
        }
        while (v24 < *(_DWORD *)(a4 + 608) && !mfs_Ling_IsWordBegin(*(_QWORD *)(a4 + 8), v24) && v23 < 37);
        v27 = mfs_Ling_CenterPhoneme(*(_QWORD *)(a4 + 8), v24);
        if (v27 != 1)
          *((_BYTE *)a3 + v23++ + 48) = v27;
        *((_DWORD *)a3 + 23) = v23 - 1;
        v28 = (uint64_t)a3 + v23;
        *(_BYTE *)(v28 + 48) = v43;
        v22 = (_BYTE *)(v28 + 49);
        goto LABEL_26;
      }
    }
    if (!*v15)
      goto LABEL_46;
    if (MFS__log_select_GetLogLevel(*(_QWORD *)(a1 + 32)) >= 3)
    {
      for (i = 0; i != 40; ++i)
        v48[i] = mfs_Ling_HmmPhonemeToLhTts(*a2, *((unsigned __int8 *)&v46[5 * v9] + i));
      v48[40] = 0;
      MFS__log_select_Diag(a1, 3, (uint64_t)" -* (%s) ");
    }
    v30 = *((_DWORD *)*a3 + v9 + 6);
    mfs_S32Vect_Clear(&a3[3 * v9 + 12]);
    v31 = v30 - 1;
    if (v30 < 1)
    {
      v36 = 0;
      goto LABEL_43;
    }
    v32 = 0;
    while (1)
    {
      v33 = v32 + v31;
      if (v32 + v31 < 0 != __OFADD__(v32, v31))
        ++v33;
      v34 = (uint64_t)v33 >> 1;
      v35 = cstdlib_strcmp((const char *)((*a3)[v9 + 4] + *(unsigned int *)((*a3)[v9 + 1] + 12 * (v33 >> 1))), (const char *)&a3[5 * v9 + 1]);
      if (v35 < 0)
      {
        v32 = v34 + 1;
        goto LABEL_40;
      }
      if (!v35)
        break;
      v31 = v34 - 1;
LABEL_40:
      if (v32 > v31)
        goto LABEL_41;
    }
    v37 = *a3;
    v38 = (*a3)[v9 + 1] + 12 * (int)v34;
    if (!*(_DWORD *)(v38 + 8))
    {
LABEL_41:
      v36 = 0;
      goto LABEL_43;
    }
    v39 = 0;
    v40 = *(_DWORD *)(v38 + 4);
    do
    {
      v36 = mfs_S32Vect_Add((uint64_t)&a3[3 * v9 + 12], *(_DWORD *)(v37[v9 + 6] + 4 * (v40 + v39)));
      if (v36 < 0)
        break;
      ++v39;
      v37 = *a3;
    }
    while (v39 < *(unsigned int *)((*a3)[v9 + 1] + 12 * (int)v34 + 8));
LABEL_43:
    v45 = v36 & ~(v36 >> 31);
    if (LODWORD(a3[3 * v9 + 14]))
    {
      MFS__log_select_Diag(a1, 3, (uint64_t)" found %d");
      *((_DWORD *)a3 + v9 + 36) = 0;
    }
    v5 = a5;
    v10 = v46;
LABEL_46:
    v11 = 0;
    v9 = 1;
  }
  while ((v12 & 1) != 0);
  return v45;
}

BOOL mfs_Harch_IsBoundary(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 88) == 0;
}

uint64_t mfs_Harch_GetIds(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t result;
  char i;
  char v7;
  _QWORD *v8;
  unsigned int *v9;
  int v10;
  uint64_t v11;

  mfs_S32Vect_Clear(a2);
  v4 = 0;
  result = 0;
  for (i = 1; ; i = 0)
  {
    v7 = i;
    if (!*(_DWORD *)(*a1 + 4 * v4 + 24) || (*((_DWORD *)a1 + v4 + 22) & 0x80000000) != 0)
      goto LABEL_9;
    v8 = &a1[3 * v4];
    v10 = *((_DWORD *)v8 + 28);
    v9 = (unsigned int *)(v8 + 14);
    if (v10)
      break;
LABEL_8:
    ++*((_DWORD *)a1 + v4 + 36);
LABEL_9:
    v4 = 1;
    if ((v7 & 1) == 0)
      return result;
  }
  v11 = 0;
  while (1)
  {
    result = mfs_S32Vect_Add((uint64_t)a2, *((_DWORD *)a1 + v4 + 36) + *(_DWORD *)(a1[3 * v4 + 13] + 4 * v11));
    if ((result & 0x80000000) != 0)
      return result;
    if (++v11 >= (unint64_t)*v9)
      goto LABEL_8;
  }
}

BOOL mfs_Harch_FewCands(int *a1)
{
  uint64_t v1;
  unsigned int v2;
  char v3;
  char v4;

  v1 = 0;
  v2 = 0;
  v3 = 1;
  do
  {
    v4 = v3;
    if (*(_DWORD *)(*(_QWORD *)a1 + 4 * v1 + 24) && a1[v1 + 36] >= 2)
      v2 += a1[6 * v1 + 28];
    v3 = 0;
    v1 = 1;
  }
  while ((v4 & 1) != 0);
  return v2 < 0x28;
}

uint64_t mfs_Version_Init()
{
  return 3341;
}

uint64_t mfs_Version_Retrieve(uint64_t a1, _BYTE *a2)
{
  char v2;
  char *v3;
  const char *v4;
  int v6;

  *(_QWORD *)(a1 + 64) = a2;
  v2 = 86;
  v3 = &byte_214FBFAD9;
  v4 = "vljpollet";
  do
  {
    *a2++ = *v4 ^ v2;
    if (!*(unsigned __int8 *)++v4)
      v4 = "vljpollet";
    v6 = *v3++;
    v2 = v6;
  }
  while (v6);
  *(a2 - 1) = 0;
  return __sprintf_chk((char *)a1, 0, 0x40uLL, "%d.%02d %s", 3, 0, "alphadelpi");
}

uint64_t mfs_Version_DeInit(uint64_t a1)
{
  *(_QWORD *)(a1 + 64) = 0;
  return 0;
}

uint64_t mfs_Version_DataCheck(uint64_t a1, const char *a2)
{
  return strcmp(VersionMetaData01, a2);
}

uint64_t mfs_CostList_CompareNodesScore_Obersee(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(unsigned __int16 *)(a1 + 8);
  v3 = *(unsigned __int16 *)(a2 + 8);
  v4 = v2 > v3;
  if (v2 >= v3)
    v5 = 0;
  else
    v5 = -1;
  if (v4)
    return 1;
  else
    return v5;
}

uint64_t mfs_CandidateList_Init_Obersee(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  v4 = 2229280778;
  *(_QWORD *)a1 = 0x1FFFLL;
  v5 = heap_Alloc(a2, 32764);
  *(_QWORD *)(a1 + 8) = v5;
  if (v5)
  {
    v6 = *(_QWORD *)a1;
    v7 = v5 + 4 * *(_QWORD *)a1;
    *(_QWORD *)(a1 + 16) = v7;
    if (v6 >= 1)
    {
      if (v7 <= v5 + 4)
        v7 = v5 + 4;
      memset((void *)v5, 255, ((v7 + ~v5) & 0xFFFFFFFFFFFFFFFCLL) + 4);
    }
    *(_QWORD *)(a1 + 24) = 2048;
    v8 = heap_Alloc(a2, 49152);
    *(_QWORD *)(a1 + 32) = v8;
    if (v8)
    {
      v4 = 0;
      *(_QWORD *)(a1 + 40) = v8;
      *(_DWORD *)(a1 + 48) = -1;
      *(_WORD *)(a1 + 56) = -1;
      *(_QWORD *)(a1 + 68) = 0;
      *(_QWORD *)(a1 + 60) = 0;
    }
  }
  return v4;
}

_QWORD *mfs_CandidateList_DeInit_Obersee(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = result;
  v4 = result[1];
  if (v4)
    result = heap_Free(a2, v4);
  v5 = v3[4];
  if (v5)
    return heap_Free(a2, v5);
  return result;
}

uint64_t mfs_CandidateList_ReserveSpaceAtEndIfNotPresent_Obersee(uint64_t a1, uint64_t a2, unsigned int a3, char **a4, uint64_t *a5)
{
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  unsigned int v13;
  uint64_t result;
  unint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  unsigned int v24;
  _DWORD *v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;

  v9 = a3;
  v10 = *(char **)(a1 + 8);
  v11 = *(_QWORD *)(a1 + 16) - (_QWORD)v10;
  v12 = &v10[4 * (a3 % (unint64_t)(v11 >> 2))];
  while (1)
  {
    v13 = *(_DWORD *)v12;
    if ((v13 & 0x80000000) != 0)
      break;
    v12 = (char *)(*(_QWORD *)(a1 + 32) + 24 * v13);
    if (*((_DWORD *)v12 + 1) == a3)
    {
      result = 2229280770;
LABEL_34:
      *a4 = v12;
      return result;
    }
  }
  LODWORD(v15) = *(_DWORD *)(a1 + 48);
  if ((_DWORD)v15 != -1)
  {
    v16 = *(_DWORD *)(a1 + 48);
    v17 = *(_QWORD *)(a1 + 32) + 24 * (int)v15;
    *(_DWORD *)(a1 + 48) = (*(_DWORD *)v17 & 0xBFFFFFFF) - 1;
    *(_DWORD *)v17 = 0;
    *(_DWORD *)(v17 + 4) = a3;
    *(_QWORD *)(v17 + 8) = 0;
    *(_QWORD *)(v17 + 16) = 0;
LABEL_33:
    result = 0;
    v35 = *(_QWORD *)(a1 + 8);
    v36 = v9 % ((*(_QWORD *)(a1 + 16) - v35) >> 2);
    v12 = (char *)(*(_QWORD *)(a1 + 32) + 24 * v16);
    *(_DWORD *)v12 = *(_DWORD *)(v35 + 4 * v36);
    *(_DWORD *)(v35 + 4 * v36) = v15;
    goto LABEL_34;
  }
  v18 = *(_QWORD *)(a1 + 32);
  v19 = *(_QWORD *)(a1 + 40);
  v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v18) >> 3);
  if (v15 > v11 >> 1)
  {
    v20 = (v11 >> 1) + 1;
    if (v20 <= *(_QWORD *)a1)
    {
      v22 = 4 * *(_QWORD *)a1;
    }
    else
    {
      if (v20 >= 9)
        v21 = (v11 >> 1) + 1;
      else
        v21 = 8;
      v22 = 4 * v21;
      v23 = heap_Realloc(a5, (uint64_t)v10, 4 * v21);
      *(_QWORD *)(a1 + 8) = v23;
      if (!v23)
        return 2229280778;
      v10 = (char *)v23;
      *(_QWORD *)a1 = v21;
    }
    *(_QWORD *)(a1 + 16) = &v10[4 * v20];
    cstdlib_memset(v10, 255, v22);
    v18 = *(_QWORD *)(a1 + 32);
    v19 = *(_QWORD *)(a1 + 40);
    if (v19 == v18)
    {
      v15 = 0;
      v18 = *(_QWORD *)(a1 + 40);
    }
    else
    {
      v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v18) >> 3);
      v24 = 1;
      v25 = *(_DWORD **)(a1 + 32);
      do
      {
        if (((*v25 + 1) & 0x40000000) == 0)
        {
          v26 = v25[1] % v20;
          v27 = *(_QWORD *)(a1 + 8);
          *v25 = *(_DWORD *)(v27 + 4 * v26);
          *(_DWORD *)(v27 + 4 * v26) = v24 - 1;
        }
        v25 += 6;
      }
      while (v15 > v24++);
    }
  }
  v29 = v15 + 1;
  v30 = *(_QWORD *)(a1 + 24);
  if (v15 + 1 <= v30)
  {
LABEL_32:
    *(_QWORD *)(a1 + 40) = v19 + 24;
    *(_DWORD *)v19 = 0;
    *(_DWORD *)(v19 + 4) = a3;
    *(_OWORD *)(v19 + 8) = 0uLL;
    v16 = v15;
    goto LABEL_33;
  }
  v31 = 2 * v30;
  v32 = v30 + 1000000;
  if (v31 >= v32)
    v31 = v32;
  if (v31 > v29)
    v29 = v31;
  if (v29 <= 8)
    v33 = 8;
  else
    v33 = v29;
  v34 = heap_Realloc(a5, v18, 24 * v33);
  *(_QWORD *)(a1 + 32) = v34;
  if (v34)
  {
    *(_QWORD *)(a1 + 24) = v33;
    v19 = v34 + 24 * v15;
    goto LABEL_32;
  }
  return 2229280778;
}

uint64_t mfs_CandidateList_ReserveInsertSpaceSortedProbablyAppend_Obersee(uint64_t a1, unsigned int a2, char **a3, uint64_t *a4)
{
  unint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  unsigned int v12;
  uint64_t result;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  unsigned int v23;
  _DWORD *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;

  v8 = a2;
  v9 = *(char **)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 16) - (_QWORD)v9;
  v11 = &v9[4 * (a2 % (unint64_t)(v10 >> 2))];
  while (1)
  {
    v12 = *(_DWORD *)v11;
    if ((v12 & 0x80000000) != 0)
      break;
    v11 = (char *)(*(_QWORD *)(a1 + 32) + 24 * v12);
    if (*((_DWORD *)v11 + 1) == a2)
    {
      result = 2229280770;
LABEL_34:
      *a3 = v11;
      return result;
    }
  }
  LODWORD(v14) = *(_DWORD *)(a1 + 48);
  if ((_DWORD)v14 != -1)
  {
    v15 = *(_DWORD *)(a1 + 48);
    v16 = *(_QWORD *)(a1 + 32) + 24 * (int)v14;
    *(_DWORD *)(a1 + 48) = (*(_DWORD *)v16 & 0xBFFFFFFF) - 1;
    *(_DWORD *)v16 = 0;
    *(_DWORD *)(v16 + 4) = a2;
    *(_QWORD *)(v16 + 8) = 0;
    *(_QWORD *)(v16 + 16) = 0;
LABEL_33:
    result = 0;
    v34 = *(_QWORD *)(a1 + 8);
    v35 = v8 % ((*(_QWORD *)(a1 + 16) - v34) >> 2);
    v11 = (char *)(*(_QWORD *)(a1 + 32) + 24 * v15);
    *(_DWORD *)v11 = *(_DWORD *)(v34 + 4 * v35);
    *(_DWORD *)(v34 + 4 * v35) = v14;
    goto LABEL_34;
  }
  v17 = *(_QWORD *)(a1 + 32);
  v18 = *(_QWORD *)(a1 + 40);
  v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v18 - v17) >> 3);
  if (v14 > v10 >> 1)
  {
    v19 = (v10 >> 1) + 1;
    if (v19 <= *(_QWORD *)a1)
    {
      v21 = 4 * *(_QWORD *)a1;
    }
    else
    {
      if (v19 >= 9)
        v20 = (v10 >> 1) + 1;
      else
        v20 = 8;
      v21 = 4 * v20;
      v22 = heap_Realloc(a4, (uint64_t)v9, 4 * v20);
      *(_QWORD *)(a1 + 8) = v22;
      if (!v22)
        return 2229280778;
      v9 = (char *)v22;
      *(_QWORD *)a1 = v20;
    }
    *(_QWORD *)(a1 + 16) = &v9[4 * v19];
    cstdlib_memset(v9, 255, v21);
    v17 = *(_QWORD *)(a1 + 32);
    v18 = *(_QWORD *)(a1 + 40);
    if (v18 == v17)
    {
      v14 = 0;
      v17 = *(_QWORD *)(a1 + 40);
    }
    else
    {
      v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v18 - v17) >> 3);
      v23 = 1;
      v24 = *(_DWORD **)(a1 + 32);
      do
      {
        if (((*v24 + 1) & 0x40000000) == 0)
        {
          v25 = v24[1] % v19;
          v26 = *(_QWORD *)(a1 + 8);
          *v24 = *(_DWORD *)(v26 + 4 * v25);
          *(_DWORD *)(v26 + 4 * v25) = v23 - 1;
        }
        v24 += 6;
      }
      while (v14 > v23++);
    }
  }
  v28 = v14 + 1;
  v29 = *(_QWORD *)(a1 + 24);
  if (v14 + 1 <= v29)
  {
LABEL_32:
    *(_QWORD *)(a1 + 40) = v18 + 24;
    *(_DWORD *)v18 = 0;
    *(_DWORD *)(v18 + 4) = a2;
    *(_OWORD *)(v18 + 8) = 0uLL;
    v15 = v14;
    goto LABEL_33;
  }
  v30 = 2 * v29;
  v31 = v29 + 1000000;
  if (v30 >= v31)
    v30 = v31;
  if (v30 > v28)
    v28 = v30;
  if (v28 <= 8)
    v32 = 8;
  else
    v32 = v28;
  v33 = heap_Realloc(a4, v17, 24 * v32);
  *(_QWORD *)(a1 + 32) = v33;
  if (v33)
  {
    *(_QWORD *)(a1 + 24) = v32;
    v18 = v33 + 24 * v14;
    goto LABEL_32;
  }
  return 2229280778;
}

uint64_t mfs_CandidateList_InsertSortedProbablyAppend_Obersee(uint64_t a1, unsigned int a2, __int16 a3, char **a4, uint64_t a5, uint64_t *a6)
{
  uint64_t result;
  char *v11;

  result = mfs_CandidateList_ReserveInsertSpaceSortedProbablyAppend_Obersee(a1, a2, a4, a6);
  if (!(_DWORD)result)
  {
    v11 = *a4;
    *((_DWORD *)v11 + 1) = a2;
    *((_WORD *)v11 + 4) = a3;
    *((_QWORD *)v11 + 2) = a5;
  }
  return result;
}

uint64_t mfs_CandidateList_Sort_Obersee(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = -1431655765 * ((unint64_t)(*(_QWORD *)(a1 + 40) - v2) >> 3);
  if ((_DWORD)v3)
    ssft_qsort(v2, v3, 24, (uint64_t (*)(unint64_t, unint64_t))mfs_CostList_CompareNodesScore_Obersee);
  return 0;
}

uint64_t mfs_CandidateList_SelectAndPrune_Obersee(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD **v13;
  _QWORD *v14;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = (unint64_t)(*(_QWORD *)(a1 + 40) - v5) >> 3;
  v7 = -1431655765 * v6;
  if (-1431655765 * (_DWORD)v6)
  {
    mfs_Array_QSelect_Obersee(v5, -1431655765 * v6, 0x18u, mfs_CostList_CompareNodesScore_Obersee, a2);
    if (v7 > a2)
    {
      v10 = *(_QWORD *)(a1 + 32);
      if (-1431655765 * ((*(_QWORD *)(a1 + 40) - v10) >> 3) > a2)
      {
        v11 = *(_QWORD **)(a4 + 72);
        v12 = -1431655765 * ((*(_QWORD *)(a1 + 40) - v10) >> 3) - (unint64_t)a2;
        v13 = (_QWORD **)(v10 + 24 * a2 + 16);
        do
        {
          v14 = *v13;
          v13 += 3;
          *v14 = v11;
          *(_QWORD *)(a4 + 72) = v14;
          v11 = v14;
          --v12;
        }
        while (v12);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 32) + 24 * a2;
      }
    }
  }
  return 0;
}

uint64_t mfs_CandidateList_Prune_Obersee(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unsigned int v5;
  _QWORD *v6;
  _QWORD **v7;
  unint64_t v8;
  _QWORD *v9;

  v4 = *(_QWORD *)(result + 32);
  v5 = -1431655765 * ((*(_QWORD *)(result + 40) - v4) >> 3);
  if (v5 > a2)
  {
    v6 = *(_QWORD **)(a4 + 72);
    v7 = (_QWORD **)(v4 + 24 * a2 + 16);
    v8 = v5 - (unint64_t)a2;
    do
    {
      v9 = *v7;
      v7 += 3;
      *v9 = v6;
      *(_QWORD *)(a4 + 72) = v9;
      v6 = v9;
      --v8;
    }
    while (v8);
    *(_QWORD *)(result + 40) = *(_QWORD *)(result + 32) + 24 * a2;
  }
  return result;
}

void *mfs_CandidateList_Reset_Obersee(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD **v7;
  _QWORD *v8;
  void *result;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = -1431655765 * ((unint64_t)(*(_QWORD *)(a1 + 40) - v4) >> 3);
  if ((_DWORD)v5)
  {
    v6 = *(_QWORD **)(a3 + 72);
    v7 = (_QWORD **)(v4 + 16);
    do
    {
      v8 = *v7;
      v7 += 3;
      *v8 = v6;
      *(_QWORD *)(a3 + 72) = v8;
      v6 = v8;
      --v5;
    }
    while (v5);
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 32);
  }
  *(_WORD *)(a1 + 56) = -1;
  result = cstdlib_memset(*(void **)(a1 + 8), 255, 4 * *(_QWORD *)a1);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 48) = -1;
  return result;
}

uint64_t mfs_CandidateList_Filter_Obersee(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = -1431655765 * ((unint64_t)(*(_QWORD *)(a1 + 40) - v2) >> 3);
  v4 = v3 - 1;
  if (v3 < 1)
    return 0;
  v6 = 0;
  do
  {
    v7 = v2 + 24 * (int)v6;
    if (*(unsigned __int16 *)(v7 + 8) >= a2)
    {
      if (*(unsigned __int16 *)(v2 + 24 * v4 + 8) < a2)
      {
        mfs_SwapItem_Obersee(v7, v2 + 24 * v4, 0x18u);
        v6 = (v6 + 1);
      }
      --v4;
    }
    else
    {
      v6 = (v6 + 1);
    }
  }
  while (v4 >= (int)v6);
  return v6;
}

uint64_t mfs_CandidateList_UpdateCost_Obersee(uint64_t result, unsigned int a2, __int16 a3)
{
  *(_WORD *)(*(_QWORD *)(result + 32) + 24 * a2 + 8) = a3;
  return result;
}

uint64_t mfs_CandidateListNode_UpdateCost_Obersee(uint64_t result, int a2)
{
  *(_WORD *)(result + 8) = (*(_WORD *)(result + 8) + a2) & ~(unsigned __int16)((*(unsigned __int16 *)(result + 8) + a2) >> 31);
  return result;
}

uint64_t mfs_CandidateList_GetUsedMemory(_DWORD *a1)
{
  return (24 * a1[6] + 4 * *a1);
}

uint64_t mfs_Search_InitPrefilter(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 584);
  if (*(_DWORD *)v2 == 3)
  {
    if (*(_DWORD *)(*(_QWORD *)(a1 + 592) + 8356) == 1)
    {
      v3 = *(unsigned int *)(v2 + 2440);
      if ((int)v3 < 1)
      {
        LODWORD(v4) = 0;
      }
      else
      {
        v4 = 0;
        v5 = *(_QWORD *)(v2 + 2456);
        while (*(_BYTE *)(v5 + v4) != 31)
        {
          if (v3 == ++v4)
            goto LABEL_12;
        }
      }
      if ((_DWORD)v4 == (_DWORD)v3)
      {
LABEL_12:
        MFS__log_select_Diag(*(_QWORD *)a1, 3, (uint64_t)"Can not identify DIFFERENTIATOR ID (%d), please CHECK!\n");
        LODWORD(v4) = 0;
      }
      MFS__log_select_Diag(*(_QWORD *)a1, 3, (uint64_t)"TARGET DIFFERENTIATOR FEATURE ID = %d\n");
    }
    else
    {
      LODWORD(v4) = 0;
    }
    result = 0;
    *(_DWORD *)(a1 + 18016) = v4;
  }
  else
  {
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"CONFIG ERROR : Search is implemented for 3 states only\n");
    return 2229281034;
  }
  return result;
}

uint64_t mfs_Search_FindNodeCandidates_StatSelect_Obersee(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  _QWORD *v13;
  int *v14;
  unsigned __int8 v15;
  int v16;
  int v17;
  uint64_t *v18;
  int *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t UnitData_Obersee;
  uint64_t v23;
  _DWORD *v24;
  int v25;
  _QWORD *MemoryFromChunk;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  unsigned int **v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t i;
  unsigned int v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  float v54;
  float v55;
  uint64_t v56;
  int v57;
  float v58;
  unsigned int v59;
  float v60;
  _WORD *v61;
  uint64_t v62;
  unsigned int v63;
  float v64;
  uint64_t v65;
  float v66;
  float v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  unsigned int v73;
  unsigned int v74;
  __int16 v75;
  _QWORD *v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  unsigned int **v80;
  unsigned int v81;
  unsigned int v82;
  __int16 v83;
  int v85;
  uint64_t v86;
  uint64_t v87;
  int *v88;
  uint64_t v89;
  _DWORD *v90;
  int v91[2];
  uint64_t v92;
  _QWORD *v93;
  _QWORD *v94;
  int v95[2];
  unsigned int v96;
  uint64_t v97;
  uint64_t v98;
  unsigned __int8 v99;
  uint64_t v100;
  int *v102;
  uint64_t v103;
  int v104;
  unsigned __int8 *v105;
  _QWORD *v106;
  uint64_t v107;
  __int16 v108;
  unsigned __int8 v109;
  unsigned int inserted;
  _OWORD __b[2];
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  _DWORD v124[3];
  unsigned __int8 v125[176];
  __int128 v126;
  _BYTE v127[16];
  char *v128[260];

  v128[257] = *(char **)MEMORY[0x24BDAC8D0];
  inserted = 0;
  v3 = *(_QWORD *)(a1 + 584);
  v4 = *(_QWORD *)(a1 + 592);
  v5 = *(_QWORD *)a1;
  v6 = *(_QWORD *)(a1 + 576);
  v109 = 0;
  v108 = 0;
  v126 = 0u;
  memset(v125, 0, sizeof(v125));
  v7 = *(_QWORD *)(v6 + 600);
  v98 = v6;
  *(_QWORD *)v91 = v3;
  mfs_symData_GetTargetVector(v3, (uint64_t)v125, *(_QWORD *)(v6 + 8), a2);
  v99 = 0;
  v107 = v4;
  if (*(_DWORD *)(v4 + 8356) == 1)
  {
    MFS__log_select_Diag(v5, 3, (uint64_t)"TARGET DIFFERENTIATOR %d\n");
    v99 = v125[*(int *)(a1 + 18016) + 4];
  }
  mfs_Ling_GetPhonCtxt(*(_QWORD *)(v98 + 8), a2, &v108);
  v87 = v5;
  mfs_Ling_LogPhonCtxt(v5, v4, *(_QWORD *)(v98 + 8), a2);
  v9 = 0;
  v10 = a1 + 600;
  v85 = a2;
  v86 = v7;
  v11 = v7 + 528 * a2;
  v12 = *(_DWORD *)(v4 + 8224);
  v13 = (_QWORD *)(v11 + 312);
  *(_QWORD *)v95 = v11 + 312;
  v89 = a1 + 8;
  v106 = (_QWORD *)(v11 + 80);
  v14 = (int *)(a1 + 18016);
  v92 = a1 + 600;
  v93 = (_QWORD *)(v11 + 88);
  v102 = (int *)(v11 + 8);
  v104 = *(_DWORD *)(v107 + 8224);
  v15 = v99;
  do
  {
    if ((*(_BYTE *)(*v13 + v9 + 2) & 4) != 0)
      v16 = 200;
    else
      v16 = 100;
    v124[v9] = 0;
    if (HIBYTE(v108) == 1)
    {
      if (v9 == 1 || !*(_DWORD *)(v107 + 8256))
        goto LABEL_27;
      if ((_DWORD)v9 == 2)
      {
        if (*(_DWORD *)(v98 + 608) - 1 == a2 || v109 == 1)
          goto LABEL_27;
        v17 = v108;
        goto LABEL_18;
      }
      if (!(_DWORD)v9)
      {
        if (!a2 || v108 == 1)
          goto LABEL_27;
        v17 = v109;
LABEL_18:
        if (v17 == 1)
          goto LABEL_27;
      }
    }
    v18 = *(uint64_t **)(*(_QWORD *)(a1 + 576) + 2640);
    if (v18)
    {
      v19 = v14;
      v20 = 3 * a2 + v9 + *((_DWORD *)v18 + 5);
      v21 = *v18;
      v128[0] = 0;
      if (!*(_DWORD *)(v21 + 48 * v20))
      {
        v23 = v21 + 48 * v20;
        v25 = *(_DWORD *)(v23 + 24);
        v24 = (_DWORD *)(v23 + 24);
        if (v25)
        {
          MemoryFromChunk = *(_QWORD **)(a1 + 80);
          if (MemoryFromChunk)
            *(_QWORD *)(a1 + 80) = *MemoryFromChunk;
          else
            MemoryFromChunk = (_QWORD *)fastallo_AllocateMemoryFromChunk(v89, 4u, (int *)&inserted);
          v27 = inserted;
          if ((inserted & 0x80000000) != 0)
            return v27;
          v28 = *(_DWORD *)(*(_QWORD *)(v21 + 48 * v20 + 8) + 4 * (*v24 - 1));
          if (v28 < *(_DWORD *)(*(_QWORD *)v91 + 1096) - 1)
          {
            UnitData_Obersee = mfs_getUnitData_Obersee(*(_QWORD *)(a1 + 584), *(_QWORD *)a1, v28, (uint64_t)MemoryFromChunk);
            inserted = UnitData_Obersee;
            if ((UnitData_Obersee & 0x80000000) != 0)
              return UnitData_Obersee;
            inserted = mfs_CandidateList_InsertSortedProbablyAppend_Obersee(v10, v28, v16, v128, (uint64_t)MemoryFromChunk, *(uint64_t **)(*(_QWORD *)a1 + 8));
            if ((inserted & 0x80000000) == 0)
            {
              v124[v9] = 1;
              v12 = v104;
              v15 = v99;
              v14 = v19;
              v13 = *(_QWORD **)v95;
              goto LABEL_27;
            }
          }
        }
      }
      v12 = v104;
      v15 = v99;
      v14 = v19;
      v13 = *(_QWORD **)v95;
    }
    UnitData_Obersee = mfs_VennDiaGrams_Obersee((uint64_t *)a1, 1u, (int)v9 + 2, (unsigned __int8 *)&v108, *(_DWORD *)(*v106 + 4 * v9 + 8), v12, v10, v16, v15, *v14);
    inserted = UnitData_Obersee;
    if ((UnitData_Obersee & 0x80000000) != 0)
      return UnitData_Obersee;
    if ((*(_BYTE *)(*v13 + v9 + 2) & 4) != 0 && mfs_Ling_IsVoiced(v107, *(_QWORD *)(v98 + 8), a2))
    {
      UnitData_Obersee = mfs_VennDiaGrams_Obersee((uint64_t *)a1, 2u, (int)v9 + 2, (unsigned __int8 *)&v108, *(_DWORD *)(*v93 + 4 * v9 + 8), v12, v10, v16, v15, *v14);
      inserted = UnitData_Obersee;
      if ((UnitData_Obersee & 0x80000000) != 0)
        return UnitData_Obersee;
    }
    UnitData_Obersee = mfs_VennDiaGrams_Obersee((uint64_t *)a1, 0, (int)v9 + 2, (unsigned __int8 *)&v108, *v102, v12, v10, v16, v15, *v14);
    inserted = UnitData_Obersee;
    if ((UnitData_Obersee & 0x80000000) != 0)
      return UnitData_Obersee;
LABEL_27:
    ++v9;
    v10 += 80;
  }
  while (v9 != 3);
  if (HIBYTE(v108) != 1)
  {
    v29 = -1431655765 * ((*(_QWORD *)(a1 + 640) - *(_QWORD *)(a1 + 632)) >> 3);
    v30 = -1431655765 * ((*(_QWORD *)(a1 + 800) - *(_QWORD *)(a1 + 792)) >> 3);
    v31 = *(_QWORD *)(a1 + 712);
    v32 = -1431655765 * ((unint64_t)(*(_QWORD *)(a1 + 720) - v31) >> 3);
    if (v32)
    {
      v33 = v124[0];
      v34 = v124[2];
      v35 = (unsigned int **)(v31 + 16);
      do
      {
        if (!v33)
        {
          v36 = **v35;
          if (v36 != -1 && (v29 < 0x64 || *((unsigned __int8 *)*v35 + 24) == v108))
          {
            UnitData_Obersee = mfs_AppendUnsortedToCandidateListIfNotPresent_Obersee((uint64_t *)a1, v92, v29, v36, *((_WORD *)v35 - 4));
            inserted = UnitData_Obersee;
            if ((UnitData_Obersee & 0x1FFF) == 0xA)
              return UnitData_Obersee;
          }
        }
        if (!v34)
        {
          v37 = (*v35)[1];
          if (v37 != -1 && (v30 < 0x64 || *((unsigned __int8 *)*v35 + 26) == v109))
          {
            UnitData_Obersee = mfs_AppendUnsortedToCandidateListIfNotPresent_Obersee((uint64_t *)a1, a1 + 760, v30, v37, *((_WORD *)v35 - 4));
            inserted = UnitData_Obersee;
            if ((UnitData_Obersee & 0x1FFF) == 0xA)
              return UnitData_Obersee;
          }
        }
        v35 += 3;
      }
      while (--v32);
    }
    if (!v124[1])
    {
      if (!(_DWORD)v29)
      {
LABEL_112:
        if ((_DWORD)v30)
        {
          v79 = -1431655765 * ((*(_QWORD *)(a1 + 720) - *(_QWORD *)(a1 + 712)) >> 3);
          v80 = (unsigned int **)(*(_QWORD *)(a1 + 792) + 16);
          while (1)
          {
            v81 = **v80;
            if (v81 != -1)
            {
              v82 = *((unsigned __int16 *)v80 - 4);
              if (*(_DWORD *)(v107 + 8324) > (signed int)v82)
              {
                v83 = v82 > 0xCCC ? -1 : 20 * v82;
                UnitData_Obersee = mfs_AppendUnsortedToCandidateListIfNotPresent_Obersee((uint64_t *)a1, a1 + 680, v79, v81, v83);
                inserted = UnitData_Obersee;
                if ((UnitData_Obersee & 0x1FFF) == 0xA)
                  return UnitData_Obersee;
              }
            }
            v80 += 3;
            LODWORD(v30) = v30 - 1;
            if (!(_DWORD)v30)
              goto LABEL_53;
          }
        }
        goto LABEL_53;
      }
      v72 = *(_QWORD *)(a1 + 632) + 16;
      while (1)
      {
        v73 = *(_DWORD *)(*(_QWORD *)v72 + 4);
        if (v73 != -1)
        {
          v74 = *(unsigned __int16 *)(v72 - 8);
          if (*(_DWORD *)(v107 + 8324) > (signed int)v74)
            break;
        }
LABEL_111:
        v72 += 24;
        LODWORD(v29) = v29 - 1;
        if (!(_DWORD)v29)
          goto LABEL_112;
      }
      if (v74 > 0xCCC)
        v75 = -1;
      else
        v75 = 20 * v74;
      v128[0] = 0;
      v27 = mfs_CandidateList_ReserveInsertSpaceSortedProbablyAppend_Obersee(a1 + 680, v73, v128, *(uint64_t **)(*(_QWORD *)a1 + 8));
      LODWORD(__b[0]) = v27;
      if (!(_DWORD)v27)
      {
        v76 = *(_QWORD **)(a1 + 80);
        if (v76)
        {
          *(_QWORD *)(a1 + 80) = *v76;
        }
        else
        {
          v77 = fastallo_AllocateMemoryFromChunk(v89, 4u, (int *)__b);
          v27 = LODWORD(__b[0]);
          if ((__b[0] & 0x80000000) != 0)
            goto LABEL_110;
          v76 = (_QWORD *)v77;
        }
        v27 = mfs_getUnitData_Obersee(*(_QWORD *)(a1 + 584), *(_QWORD *)a1, v73, (uint64_t)v76);
        if ((v27 & 0x80000000) == 0)
        {
          v78 = v128[0];
          *((_DWORD *)v128[0] + 1) = v73;
          *((_WORD *)v78 + 4) = v75;
          *((_QWORD *)v78 + 2) = v76;
        }
      }
LABEL_110:
      inserted = v27;
      if ((v27 & 0x1FFF) == 0xA)
        return v27;
      goto LABEL_111;
    }
  }
LABEL_53:
  for (i = 0; i != 240; i += 80)
  {
    v39 = -1431655765 * ((*(_QWORD *)(a1 + i + 640) - *(_QWORD *)(a1 + i + 632)) >> 3);
    if (v39 >= 0x33)
    {
      v40 = (int)(float)(*(float *)(v107 + 8232) * (float)v39);
      if (v104 < v40)
        v40 = v104;
      v41 = v40 <= 50 ? 50 : v40;
      if (v41 != v39)
      {
        MFS__log_select_Diag(v87, 1, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
        UnitData_Obersee = mfs_CandidateList_Sort_Obersee(a1 + i + 600);
        inserted = UnitData_Obersee;
        if ((UnitData_Obersee & 0x80000000) != 0)
          return UnitData_Obersee;
        mfs_CandidateList_Prune_Obersee(a1 + i + 600, v41, *(_QWORD *)(*(_QWORD *)a1 + 8), v89);
      }
    }
  }
  v42 = 0;
  v103 = a1 + 18024;
  v43 = v86 + 528 * v85;
  v94 = (_QWORD *)(v43 + 16);
  v90 = (_DWORD *)(v43 + 24);
  v88 = (int *)(v43 + 28);
  while (2)
  {
    switch((_DWORD)v42)
    {
      case 2:
        mfs_DataCachePair_SwapCaches_Obersee(v103);
        break;
      case 1:
        v44 = a1 + 18024;
        v45 = 1;
LABEL_71:
        mfs_DataCachePair_SetMode_Obersee(v44, v45);
        break;
      case 0:
        v44 = a1 + 18024;
        v45 = 0;
        goto LABEL_71;
    }
    v46 = v124[v42];
    v96 = HIBYTE(v108);
    v47 = v92 + 80 * v42;
    v122 = 0u;
    v123 = 0u;
    v120 = 0u;
    v121 = 0u;
    v118 = 0u;
    v119 = 0u;
    v116 = 0u;
    v117 = 0u;
    v114 = 0u;
    v115 = 0u;
    v112 = 0u;
    v113 = 0u;
    memset(__b, 0, sizeof(__b));
    v49 = *(_QWORD *)(v47 + 32);
    v48 = *(_QWORD *)(v47 + 40);
    v100 = v47;
    v50 = *(_QWORD *)(a1 + 584);
    v51 = *(_QWORD *)(a1 + 592);
    v52 = *(_QWORD *)a1;
    v53 = *(_QWORD *)(a1 + 576);
    v54 = *(float *)(v51 + 8972);
    memset(v128, 0, 512);
    v105 = *(unsigned __int8 **)(v51 + 23144);
    v55 = *(float *)(v51 + 8180);
    mfs_TCost_Init(v52, v51, __b);
    if (v46 == 1)
      BYTE8(v123) = 0;
    v97 = v42;
    v56 = v42 + 2;
    v27 = mfs_FillTgtVect(v51, v53, (uint64_t)__b, *(_DWORD *)(*v94 + 4 * (v42 + 2)));
    if ((v27 & 0x80000000) != 0)
      goto LABEL_95;
    v57 = -1431655765 * ((unint64_t)(v48 - v49) >> 3);
    v58 = *(float *)v112;
    mfs_symData_DistanceOnUid_PreCalcVitSymRulesForTargetVector_Obersee(v50, v42 + 2, v96, &v125[4], v105, v128);
    *((_QWORD *)&v126 + 1) = v50 + (v56 << 10) + 2912;
    if (!v57)
    {
LABEL_85:
      mfs_TCost_Clear(__b);
      inserted = v27;
      v69 = v92 + 80 * v97;
      *(_DWORD *)(v69 + 64) = 0;
      v70 = v69 + 64;
      *(_DWORD *)(v70 + 4) = 0;
      *(_DWORD *)(v70 + 8) = 0;
      if ((_DWORD)v97 == 2)
      {
        if (!mfs_Ling_IsSilence(v107, *(_QWORD *)(v98 + 8), a2))
        {
          *(_DWORD *)(v70 + 4) = *v90;
          v71 = *v88;
          if (*v88 <= 1)
            v71 = 1;
          *(_DWORD *)(v70 + 8) = v71;
        }
      }
      else if ((_DWORD)v97 == 1 && mfs_Ling_IsVowel(v107, *(_QWORD *)(v98 + 8), a2))
      {
        *(float *)v70 = fmaxf(v58, 0.0);
      }
      v42 = v97 + 1;
      if (v97 == 2)
        return inserted;
      continue;
    }
    break;
  }
  v59 = 0;
  v60 = v54 * 0.5;
  v61 = (_WORD *)(v92 + 80 * v42 + 56);
  while (1)
  {
    v27 = mfs_TCost_CandidateCostStream_kld_Obersee((uint64_t)__b, v50, *(_QWORD *)a1, *(_QWORD *)(v49 + 16), *(unsigned int *)(*v106 + 4 * v56), v56, (uint64_t)v127);
    if ((v27 & 0x80000000) != 0)
      break;
    v63 = *(unsigned __int16 *)(v49 + 8);
    v64 = mfs_symData_DistanceOnUid_Obersee(v50, *(_QWORD *)a1, (uint64_t)v125, *(unsigned int *)(*(_QWORD *)(v49 + 16) + 8), (uint64_t)v105, (uint64_t)v128, v103, v62);
    v65 = 0;
    v66 = (float)(1.0 - v55) * v64;
    do
    {
      v66 = v66 + (float)(v55 * *(float *)&v127[v65]);
      v65 += 4;
    }
    while (v65 != 12);
    v67 = (float)((float)((float)v63 * v60) + 100.0) * v66;
    if (v67 >= 65535.0)
      v67 = 65535.0;
    mfs_CandidateList_UpdateCost_Obersee(v100, v59, (int)v67);
    v68 = *(unsigned __int16 *)(v49 + 8);
    if (v68 < (unsigned __int16)*v61)
      *v61 = v68;
    v49 += 24;
    if (++v59 == v57)
      goto LABEL_85;
  }
LABEL_95:
  mfs_TCost_Clear(__b);
  return v27;
}

uint64_t mfs_VennDiaGrams_Obersee(uint64_t *a1, unsigned int a2, unsigned int a3, unsigned __int8 *a4, int a5, unsigned int a6, uint64_t a7, int a8, unsigned __int8 a9, int a10)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t result;
  _DWORD *v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  _DWORD *v29;
  _BYTE *v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int *v34;
  BOOL v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t MemoryFromChunk;
  int v44;
  int v45;
  int v46;
  int v47;
  unsigned int v48;
  BOOL v49;
  int *v51;
  int v56[4];
  __int128 v57;
  uint64_t v58;
  char *__dst[34];

  __dst[32] = *(char **)MEMORY[0x24BDAC8D0];
  v58 = 0;
  v12 = a1[73];
  v13 = v12 + 8 * a2;
  v14 = *(_QWORD *)(*(_QWORD *)(v13 + 1712) + 8 * a3);
  v15 = a5;
  v16 = (unsigned int *)(v14 + 16 * a5);
  v17 = *(_DWORD *)(v12 + 1096);
  v18 = v16[2];
  v19 = *(_QWORD *)(v13 + 1792);
  v20 = a1[74];
  if (*(_DWORD *)(v20 + 8336) != 2)
  {
    if (v19)
    {
      v32 = v19 + *v16;
      goto LABEL_12;
    }
LABEL_11:
    v32 = 0;
    goto LABEL_12;
  }
  if (!v19)
    goto LABEL_11;
  v21 = v14 + 16 * a5;
  v22 = *(_DWORD *)(v21 + 4);
  if (v22 < 2)
    goto LABEL_11;
  result = 2229280777;
  v26 = *v16;
  v24 = v16 + 4;
  v25 = v26;
  v27 = v20 + 24 * a2;
  v28 = *(_QWORD *)(v27 + 22184) + *(unsigned int *)(v27 + 22192);
  v29 = (_DWORD *)(v27 + 22432);
  if ((unint64_t)v24 >= v28)
    v24 = v29;
  v30 = (_BYTE *)a1[2251];
  if (v30)
  {
    v31 = *(_DWORD *)(v21 + 12) * (v22 - 1);
    if (v31 <= *(_DWORD *)(v20 + 8340))
    {
      Huffman_Uncompress((unsigned __int8 *)(v19 + v25), v30, *v24 - v25, v31);
      v32 = a1[2251];
      LODWORD(v58) = 0;
LABEL_12:
      v33 = v14 + 16 * v15;
      v34 = (unsigned int *)(v33 + 4);
      if (*(_DWORD *)(v33 + 4))
        v35 = a6 == 0;
      else
        v35 = 1;
      if (v35)
        return 0;
      v36 = v17 - 1;
      v37 = -1431655765 * ((*(_QWORD *)(a7 + 40) - *(_QWORD *)(a7 + 32)) >> 3);
      v51 = (int *)(v33 + 12);
      v38 = 1;
      v39 = v37;
      while (1)
      {
        if (v18 >= v36)
          goto LABEL_46;
        if (*(_DWORD *)(a1[74] + 8356) == 1)
        {
          *(_OWORD *)v56 = 0u;
          v57 = 0u;
          result = mfs_getUnitData_Obersee(a1[73], *a1, v18, (uint64_t)v56);
          HIDWORD(v58) = result;
          if ((result & 0x80000000) != 0)
            return result;
          result = mfs_symData_recoverCompactFeatVect_Obersee(a1[73], *a1, (uint64_t)(a1 + 2253), v56[2], __dst, v40, v41, v42);
          HIDWORD(v58) = result;
          if ((result & 0x80000000) != 0)
            return result;
          if (*((unsigned __int8 *)__dst + a10) != a9)
            goto LABEL_46;
        }
        MemoryFromChunk = a1[10];
        if (MemoryFromChunk)
          a1[10] = *(_QWORD *)MemoryFromChunk;
        else
          MemoryFromChunk = fastallo_AllocateMemoryFromChunk((uint64_t)(a1 + 1), 4u, (int *)&v58 + 1);
        result = HIDWORD(v58);
        if (v58 < 0)
          return result;
        result = mfs_getUnitData_Obersee(a1[73], *a1, v18, MemoryFromChunk);
        HIDWORD(v58) = result;
        if ((result & 0x80000000) != 0)
          return result;
        if (*(unsigned __int8 *)(MemoryFromChunk + 25) == a4[1])
        {
          LOWORD(v44) = a8;
          if (a2 != 2)
            goto LABEL_38;
          if (a3 == 4)
          {
            v45 = *(unsigned __int8 *)(MemoryFromChunk + 26);
            v46 = a4[2];
          }
          else
          {
            LOWORD(v44) = a8;
            if (a3 == 3)
              goto LABEL_38;
            if (a3 != 2)
              goto LABEL_45;
            v45 = *(unsigned __int8 *)(MemoryFromChunk + 24);
            v46 = *a4;
          }
          LOWORD(v44) = a8;
          if (v45 == v46)
            goto LABEL_38;
        }
        else if (a2 == 1)
        {
          v47 = *(_DWORD *)(a1[74] + 8260);
          if ((v47 & 0x80000000) == 0)
          {
            v44 = a8 + 100 * v47;
            if (v44 >= 0xFFFF)
              LOWORD(v44) = -1;
LABEL_38:
            __dst[0] = 0;
            result = mfs_CandidateList_InsertSortedProbablyAppend_Obersee(a7, v18, v44, __dst, MemoryFromChunk, *(uint64_t **)(*a1 + 8));
            if ((result & 0x80001FFF) == 0x80000002)
            {
              mfs_CandidateListNode_UpdateCost_Obersee((uint64_t)__dst[0], -100);
              *(_QWORD *)MemoryFromChunk = a1[10];
              a1[10] = MemoryFromChunk;
            }
            else if ((result & 0x80001FFF) == 0x8000000A)
            {
              return result;
            }
            v39 = -1431655765 * ((*(_QWORD *)(a7 + 40) - *(_QWORD *)(a7 + 32)) >> 3);
            goto LABEL_46;
          }
        }
LABEL_45:
        *(_QWORD *)MemoryFromChunk = a1[10];
        a1[10] = MemoryFromChunk;
LABEL_46:
        v48 = *v34;
        if (v38 - 1 < *v34 - 1)
        {
          if (v32)
          {
            v18 += readBytesIntoU32(v32, &v58, *v51);
            v48 = *v34;
          }
          else
          {
            ++v18;
          }
        }
        v49 = v38++ >= v48;
        v49 = v49 || v39 - v37 >= a6;
        if (v49)
          return HIDWORD(v58);
      }
    }
  }
  return result;
}

uint64_t mfs_AppendUnsortedToCandidateListIfNotPresent_Obersee(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned int a4, __int16 a5)
{
  uint64_t result;
  uint64_t *MemoryFromChunk;
  char *v10;
  unsigned int v11;
  char *v12;

  v12 = 0;
  result = mfs_CandidateList_ReserveSpaceAtEndIfNotPresent_Obersee(a2, a3, a4, &v12, *(uint64_t **)(*a1 + 8));
  v11 = result;
  if (!(_DWORD)result)
  {
    MemoryFromChunk = (uint64_t *)a1[10];
    if (MemoryFromChunk)
    {
      a1[10] = *MemoryFromChunk;
    }
    else
    {
      MemoryFromChunk = (uint64_t *)fastallo_AllocateMemoryFromChunk((uint64_t)(a1 + 1), 4u, (int *)&v11);
      result = v11;
      if ((v11 & 0x80000000) != 0)
        return result;
    }
    result = mfs_getUnitData_Obersee(a1[73], *a1, a4, (uint64_t)MemoryFromChunk);
    if ((result & 0x80000000) == 0)
    {
      v10 = v12;
      *((_DWORD *)v12 + 1) = a4;
      *((_WORD *)v10 + 4) = a5;
      *((_QWORD *)v10 + 2) = MemoryFromChunk;
    }
  }
  return result;
}

uint64_t mfs_Search_EndPrefilterRun(uint64_t result)
{
  *(_DWORD *)(*(_QWORD *)(result + 576) + 2200) = 0;
  return result;
}

uint64_t mfs_PruneDPListOnContext_Obersee(uint64_t *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  signed int v12;
  uint64_t v13;
  signed int v14;
  __int16 v17;
  char v18;

  v18 = 0;
  v17 = 0;
  mfs_Ling_GetPhonCtxt(*(_QWORD *)(a1[72] + 8), a2, &v17);
  v4 = 0;
  v5 = 0;
  v6 = 2 * a2;
  do
  {
    v7 = (_DWORD *)a1[74];
    if (HIBYTE(v17) == 1)
    {
      v8 = v7[2064];
      if (v8)
      {
        if (v8 >= v7[2060])
          v8 = v7[2060];
      }
      else
      {
        v8 = 20;
      }
    }
    else
    {
      v8 = v7[2060];
    }
    v9 = a1[v4 + 80];
    v10 = a1[v4 + 79];
    v11 = &a1[v4];
    HIDWORD(a1[v4 + 82]) = v8;
    v12 = mfs_CandidateList_Filter_Obersee((uint64_t)&a1[v4 + 75], v7[2079] + LOWORD(a1[v4 + 82]));
    v13 = a1[74];
    if (SHIDWORD(a1[v4 + 82]) >= v12)
    {
      v14 = *(_DWORD *)(v13 + 8320);
      if (v12 >= v14 || v14 >= (int)(-1431655765 * ((unint64_t)(v9 - v10) >> 3)))
      {
        *((_DWORD *)v11 + 165) = v12;
        mfs_CandidateList_Prune_Obersee((uint64_t)&a1[v4 + 75], v12, *(_QWORD *)(*a1 + 8), (uint64_t)(a1 + 1));
        goto LABEL_16;
      }
    }
    else
    {
      v14 = *(_DWORD *)(v13 + 8240);
    }
    *((_DWORD *)v11 + 165) = v14;
    v5 = mfs_CandidateList_SelectAndPrune_Obersee((uint64_t)&a1[v4 + 75], v14, *a1, (uint64_t)(a1 + 1));
    if ((v5 & 0x80000000) != 0)
      return v5;
LABEL_16:
    v4 += 10;
    ++v6;
  }
  while (v4 != 30);
  return v5;
}

uint64_t mfs_CostList_CompareNodesScore_faster(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = v2 > v3;
  if (v2 >= v3)
    v5 = 0;
  else
    v5 = -1;
  if (v4)
    return 1;
  else
    return v5;
}

uint64_t mfs_CostList_Init(uint64_t a1, _QWORD *__b, unsigned int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v8 = 2229280778;
  cstdlib_memset(__b, 0, 0x18uLL);
  *__b = a1;
  v9 = heap_Calloc(*(_QWORD **)(a1 + 8), a3, 32);
  __b[1] = v9;
  if (v9)
  {
    if (a3)
    {
      v10 = 0;
      while (1)
      {
        v11 = heap_Calloc(*(_QWORD **)(a1 + 8), 2048, 8);
        v12 = __b[1];
        *(_QWORD *)(v12 + v10) = v11;
        if (!v11)
          break;
        v13 = v12 + v10;
        *(_QWORD *)(v13 + 16) = 0x80000000000;
        *(_DWORD *)(v13 + 24) = a4;
        *(_DWORD *)(v13 + 28) = 1;
        v10 += 32;
        if (32 * a3 == v10)
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      v8 = 0;
      *((_DWORD *)__b + 4) = a3;
    }
  }
  return v8;
}

_QWORD *mfs_CostList_DeInit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = result;
  v2 = result[1];
  if (v2)
  {
    if (*((_DWORD *)result + 4))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        heap_Free(*(_QWORD **)(*v1 + 8), *(_QWORD *)(v1[1] + v3));
        v5 = v1[1] + v3;
        v6 = *(_QWORD *)(v5 + 8);
        if (v6)
        {
          heap_Free(*(_QWORD **)(*v1 + 8), v6);
          *(_QWORD *)(v5 + 8) = 0;
        }
        ++v4;
        v3 += 32;
      }
      while (v4 < *((unsigned int *)v1 + 4));
      v2 = v1[1];
    }
    result = heap_Free(*(_QWORD **)(*v1 + 8), v2);
    v1[1] = 0;
  }
  *((_DWORD *)v1 + 4) = 0;
  return result;
}

uint64_t mfs_CostList_IsNodeInList(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int InsertionPoint_0;
  int v14;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;

  v7 = *(_QWORD *)(a4 + 2384);
  v8 = *(_DWORD *)(a4 + 2392);
  v9 = *(_QWORD *)(a1 + 8);
  v10 = a2;
  v11 = v9 + 32 * a2;
  *a5 = -1;
  if (v7)
  {
    if (!*(_DWORD *)(a4 + 2376))
      goto LABEL_11;
    if (mfs_isUnitRemoved(v7, a3))
      return 0;
    if (!*(_DWORD *)(a4 + 2376))
    {
LABEL_11:
      v16 = 0;
      v17 = v8 - 1;
      do
      {
        while (1)
        {
          v18 = (v17 + v16) >> 1;
          v19 = *(_DWORD *)(v7 + 4 * v18);
          if (v19 <= a3)
            break;
          if (v17 + v16 >= 2)
          {
            v17 = v18 - 1;
            if (v18 - 1 >= v16)
              continue;
          }
          goto LABEL_5;
        }
        if (v19 >= a3)
          return 0;
        v16 = v18 + 1;
      }
      while (v17 > v18);
    }
LABEL_5:
    InsertionPoint_0 = mfs_CostList_FindInsertionPoint_0((uint64_t *)v11, a3);
    if (InsertionPoint_0 >= *(_DWORD *)(v9 + 32 * v10 + 16))
      return 0;
    v14 = *(_DWORD *)(*(_QWORD *)v11 + 8 * InsertionPoint_0);
  }
  else
  {
    InsertionPoint_0 = mfs_CostList_FindInsertionPoint_0((uint64_t *)(v9 + 32 * a2), a3);
    if (InsertionPoint_0 >= *(_DWORD *)(v11 + 16))
      return 0;
    v14 = *(_DWORD *)(*(_QWORD *)v11 + 8 * InsertionPoint_0);
  }
  if (v14 == a3)
  {
    *a5 = InsertionPoint_0;
    return 1;
  }
  return 0;
}

uint64_t mfs_CostList_FindInsertionPoint_0(uint64_t *a1, unsigned int a2)
{
  int v2;
  BOOL v3;
  int v4;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;

  v2 = *((_DWORD *)a1 + 4);
  v3 = __OFSUB__(v2, 1);
  v4 = v2 - 1;
  if (v4 < 0 != v3)
    return 0;
  result = 0;
  v7 = *a1;
  while (1)
  {
    v8 = ((v4 + (int)result) >> 1);
    v9 = *(_DWORD *)(v7 + 8 * (int)v8);
    if (v9 >= a2)
    {
      if (v9 <= a2)
        return v8;
      v4 = v8 - 1;
    }
    else
    {
      result = (v8 + 1);
    }
    if ((int)result <= v4)
    {
      v8 = ((v4 + (int)result) >> 1);
      v10 = *(_DWORD *)(v7 + 8 * (int)v8);
      if (v10 >= a2)
      {
        if (v10 <= a2)
          return v8;
        v4 = v8 - 1;
      }
      else
      {
        result = (v8 + 1);
      }
      if ((int)result <= v4)
        break;
    }
LABEL_17:
    if ((int)result > v4)
      return result;
  }
  v8 = ((v4 + (int)result) >> 1);
  v11 = *(_DWORD *)(v7 + 8 * (int)v8);
  if (v11 < a2)
  {
    result = (v8 + 1);
    goto LABEL_17;
  }
  if (v11 > a2)
  {
    v4 = v8 - 1;
    goto LABEL_17;
  }
  return v8;
}

uint64_t mfs_CostList_Resize(_QWORD *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;

  v3 = a1[1];
  v4 = v3 + 32 * a2;
  v6 = *(_DWORD *)(v4 + 20);
  v5 = (unsigned int *)(v4 + 20);
  if (v6 >= a3)
    return 0;
  v7 = 32 * a2;
  *v5 = a3;
  v8 = heap_Realloc(*(uint64_t **)(*a1 + 8), *(_QWORD *)(v3 + v7), 8 * a3);
  *(_QWORD *)(v3 + v7) = v8;
  if (v8)
    return 0;
  *v5 -= 64;
  return 2229280778;
}

uint64_t mfs_CostList_Add(uint64_t a1, _QWORD *a2, unsigned int a3, unsigned int a4, uint64_t a5, int a6, unsigned int *a7, float a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v19;
  unsigned int InsertionPoint_0;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int *v24;
  uint64_t v25;
  unsigned int *v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;

  v8 = 2229280769;
  v9 = a2[1];
  v10 = a3;
  v11 = v9 + 32 * a3;
  *a7 = -1;
  if (!*(_DWORD *)(v11 + 24))
  {
    if (a5)
    {
      v19 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8368);
      if (v19 == 1)
      {
        if (mfs_isUnitRemoved(a5, a4))
          return 0;
        v19 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8368);
      }
      if (!v19)
      {
        v32 = a6 - 1;
        do
        {
          while (1)
          {
            v33 = (v32 + v19) >> 1;
            v34 = *(_DWORD *)(a5 + 4 * v33);
            if (v34 <= a4)
              break;
            if (v32 + v19 >= 2)
            {
              v32 = v33 - 1;
              if (v33 - 1 >= v19)
                continue;
            }
            goto LABEL_8;
          }
          if (v34 >= a4)
            return 0;
          v19 = v33 + 1;
        }
        while (v32 > v33);
      }
    }
LABEL_8:
    InsertionPoint_0 = mfs_CostList_FindInsertionPoint_0((uint64_t *)v11, a4);
    v21 = InsertionPoint_0;
    v22 = v9 + 32 * v10;
    v24 = (unsigned int *)(v22 + 16);
    v23 = *(_DWORD *)(v22 + 16);
    v25 = *(_QWORD *)v11;
    if (InsertionPoint_0 < v23 && *(_DWORD *)(v25 + 8 * InsertionPoint_0) == a4)
    {
      *a7 = InsertionPoint_0;
      return 2229280770;
    }
    else
    {
      v27 = *(_DWORD *)(v22 + 20);
      v26 = (unsigned int *)(v22 + 20);
      if (v27 == v23)
      {
        v28 = v23 + 64;
        *v26 = v28;
        v29 = heap_Realloc(*(uint64_t **)(*a2 + 8), v25, 8 * v28);
        *(_QWORD *)v11 = v29;
        if (!v29)
        {
          *v26 -= 64;
          return 2229280778;
        }
        v25 = v29;
        v23 = *v24;
      }
      v30 = v23 - v21;
      if (v30)
      {
        cstdlib_memmove((void *)(v25 + 8 * (v21 + 1)), (const void *)(v25 + 8 * v21), 8 * v30);
        v25 = *(_QWORD *)v11;
      }
      v8 = 0;
      v31 = v25 + 8 * v21;
      *(_DWORD *)v31 = a4;
      *(float *)(v31 + 4) = a8;
      *a7 = v21;
      ++*v24;
    }
  }
  return v8;
}

uint64_t mfs_CostList_Pad(uint64_t a1, _QWORD *a2, unsigned int a3, unsigned int a4, uint64_t a5, int a6, _DWORD *a7, float a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  unsigned int v23;
  _DWORD *v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;

  v8 = 2229280769;
  v9 = a2[1];
  v10 = a3;
  v11 = v9 + 32 * a3;
  *a7 = -1;
  if (!*(_DWORD *)(v11 + 24))
  {
    if (a5)
    {
      v19 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8368);
      if (v19 == 1)
      {
        if (mfs_isUnitRemoved(a5, a4))
          return 0;
        v19 = *(_DWORD *)(*(_QWORD *)(a1 + 1072) + 8368);
      }
      if (!v19)
      {
        v28 = a6 - 1;
        do
        {
          while (1)
          {
            v29 = (v28 + v19) >> 1;
            v30 = *(_DWORD *)(a5 + 4 * v29);
            if (v30 <= a4)
              break;
            if (v28 + v19 >= 2)
            {
              v28 = v29 - 1;
              if (v29 - 1 >= v19)
                continue;
            }
            goto LABEL_8;
          }
          if (v30 >= a4)
            return 0;
          v19 = v29 + 1;
        }
        while (v28 > v29);
      }
    }
LABEL_8:
    v20 = v9 + 32 * v10;
    v23 = *(_DWORD *)(v20 + 16);
    v21 = (_DWORD *)(v20 + 16);
    v22 = v23;
    v24 = v21 + 1;
    v25 = *(_QWORD *)v11;
    if (v21[1] == v23
      && (*v24 = v22 + 64,
          v25 = heap_Realloc(*(uint64_t **)(*a2 + 8), v25, 8 * (v22 + 64)),
          (*(_QWORD *)v11 = v25) == 0))
    {
      *v24 -= 64;
      return 2229280778;
    }
    else
    {
      v8 = 0;
      v26 = v25 + 8 * v22;
      *(_DWORD *)v26 = a4;
      *(float *)(v26 + 4) = a8;
      *a7 = v22;
      ++*v21;
    }
  }
  return v8;
}

uint64_t mfs_ConcatTwoLists(_QWORD *a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t result;

  v4 = *(_QWORD *)(a3 + 8) + 32 * a4;
  v5 = (unsigned int *)(v4 + 16);
  v6 = *(_DWORD *)(v4 + 16);
  if (!v6)
    goto LABEL_6;
  v7 = a1[1];
  v8 = a2;
  v9 = v7 + 32 * a2;
  v10 = (_DWORD *)(v9 + 16);
  v11 = *(_DWORD *)(v9 + 16) + 2 * v6;
  v12 = (unsigned int *)(v9 + 20);
  if (v11 <= *(_DWORD *)(v9 + 20))
    goto LABEL_5;
  *v12 = v11;
  v13 = heap_Realloc(*(uint64_t **)(*a1 + 8), *(_QWORD *)v9, 8 * v11);
  *(_QWORD *)v9 = v13;
  if (!v13)
  {
    *v12 -= v6;
    result = 2229280778;
    goto LABEL_8;
  }
  v6 = *v5;
  if (*v5)
  {
LABEL_5:
    memcpy((void *)(*(_QWORD *)v9 + 8 * *v10), *(const void **)v4, 8 * v6);
    result = 0;
    *v10 += *v5;
    *(_DWORD *)(v7 + 32 * v8 + 28) = 0;
  }
  else
  {
LABEL_6:
    result = 0;
  }
LABEL_8:
  *v5 = 0;
  return result;
}

uint64_t mfs_CostList_Sort(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t result;
  unsigned int v9;
  uint64_t (*v10)(unint64_t, unint64_t);

  v4 = *(_QWORD *)(a1 + 8);
  v5 = a2;
  v6 = v4 + 32 * a2;
  v7 = (_DWORD *)(v6 + 24);
  if (*(_DWORD *)(v6 + 24) == a3 && *(_DWORD *)(v6 + 28))
    return 0;
  if (!a3)
  {
    v9 = *(_DWORD *)(v4 + 32 * a2 + 16);
    if (v9)
    {
      v10 = (uint64_t (*)(unint64_t, unint64_t))mfs_CostList_CompareNodesUid_0;
      goto LABEL_10;
    }
LABEL_11:
    result = 0;
    *v7 = a3;
    *(_DWORD *)(v4 + 32 * v5 + 28) = 1;
    return result;
  }
  if (a3 == 1)
  {
    v9 = *(_DWORD *)(v4 + 32 * a2 + 16);
    if (v9)
    {
      v10 = (uint64_t (*)(unint64_t, unint64_t))mfs_CostList_CompareNodesScore_faster;
LABEL_10:
      ssft_qsort(*(_QWORD *)v6, v9, 8, v10);
      goto LABEL_11;
    }
    goto LABEL_11;
  }
  return 2229280769;
}

uint64_t mfs_CostList_CompareNodesUid_0(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

uint64_t mfs_CostList_SelectAndPrune(_QWORD *a1, unsigned int a2, int a3, unsigned int a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  int v12;
  unsigned int *v13;
  int v14;
  int v15;

  v7 = a1[1];
  v8 = a2;
  v9 = v7 + 32 * a2;
  if (*(_DWORD *)(v9 + 24) == a3 && *(_DWORD *)(v9 + 28))
    return 0;
  if (!a3)
  {
    v15 = *(_DWORD *)(v7 + 32 * a2 + 16);
    if (v15)
      mfs_CostList_QSelect(*(_QWORD *)v9, v15, 8, (uint64_t (*)(char *, char *))mfs_CostList_CompareNodesUid_0, a4);
    goto LABEL_11;
  }
  if (a3 == 1)
  {
    v11 = v7 + 32 * a2;
    v14 = *(_DWORD *)(v11 + 16);
    v13 = (unsigned int *)(v11 + 16);
    v12 = v14;
    if (v14)
    {
      mfs_CostList_QSelect(*(_QWORD *)v9, v12, 8, (uint64_t (*)(char *, char *))mfs_CostList_CompareNodesScore_faster, a4);
      if (*v13 > a4)
        mfs_CostList_Prune(a1, a2, a4);
    }
LABEL_11:
    result = 0;
    *(_DWORD *)(v7 + 32 * v8 + 28) = 0;
    return result;
  }
  return 2229280769;
}

_QWORD *mfs_CostList_Prune(_QWORD *result, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v3 = a2;
  v4 = result[1] + 32 * a2;
  if (*(_DWORD *)(v4 + 16) > a3)
  {
    v5 = result;
    *(int32x2_t *)(v4 + 16) = vdup_n_s32(a3);
    result = (_QWORD *)heap_Realloc(*(uint64_t **)(*result + 8), *(_QWORD *)v4, 8 * a3);
    if (result)
      *(_QWORD *)v4 = result;
    v6 = v5[1] + 32 * v3;
    v9 = *(_QWORD *)(v6 + 8);
    v8 = (_QWORD *)(v6 + 8);
    v7 = v9;
    if (v9)
    {
      result = heap_Free(*(_QWORD **)(*v5 + 8), v7);
      *v8 = 0;
    }
  }
  return result;
}

uint64_t mfs_CostList_UpdateCost_inlined(uint64_t result, unsigned int a2, unsigned int a3, float a4)
{
  *(float *)(*(_QWORD *)(*(_QWORD *)(result + 8) + 32 * a2) + 8 * a3 + 4) = a4;
  return result;
}

uint64_t mfs_CostList_UpdateCostEnd_inlined(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8) + 32 * a2;
  if (*(_DWORD *)(v2 + 24) == 1)
    *(_DWORD *)(v2 + 28) = 0;
  return result;
}

uint64_t mfs_CostList_UpdateCost(uint64_t result, unsigned int a2, unsigned int a3, float a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(result + 8) + 32 * a2;
  *(float *)(*(_QWORD *)v4 + 8 * a3 + 4) = a4;
  if (*(_DWORD *)(v4 + 24) == 1)
    *(_DWORD *)(v4 + 28) = 0;
  return result;
}

uint64_t mfs_CostList_HasUnit(_QWORD *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int *v14;
  int v15;
  unint64_t v16;
  BOOL v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  int *v22;
  int v23;
  uint64_t result;
  int v25;
  int v26;
  int v27;
  unsigned int v28;

  v3 = a1[1];
  v4 = v3 + 32 * a2;
  v6 = (_DWORD *)(v4 + 16);
  v5 = *(unsigned int *)(v4 + 16);
  if (!*(_DWORD *)(v4 + 16))
    return 0;
  if (!*(_DWORD *)(v4 + 24))
  {
    v17 = __OFSUB__((_DWORD)v5, 1);
    v18 = v5 - 1;
    if (v18 < 0 == v17)
    {
      v19 = 0;
      do
      {
        v20 = (v18 + v19) / 2;
        v21 = *(_DWORD *)(*(_QWORD *)v4 + 8 * v20);
        if (v21 >= a3)
        {
          if (v21 <= a3)
            return 1;
          v18 = v20 - 1;
        }
        else
        {
          v19 = v20 + 1;
        }
      }
      while (v19 <= v18);
    }
    return 0;
  }
  v8 = v3 + 32 * a2;
  v10 = *(_QWORD *)(v8 + 8);
  v9 = (uint64_t *)(v8 + 8);
  if (v10)
    goto LABEL_24;
  v11 = heap_Alloc(*(_QWORD *)(*a1 + 8), 4 * v5);
  *v9 = v11;
  v12 = *v6;
  if (v11)
  {
    if ((_DWORD)v12)
    {
      v13 = 0;
      v14 = *(int **)v4;
      do
      {
        v15 = *v14;
        v14 += 2;
        *(_DWORD *)(v11 + 4 * v13++) = v15;
        v16 = *v6;
      }
      while (v13 < v16);
    }
    else
    {
      v16 = 0;
    }
    ssft_qsort(v11, v16, 4, (uint64_t (*)(unint64_t, unint64_t))mfs_CostList_CompareNodesUid_0);
    LODWORD(v5) = *v6;
LABEL_24:
    v17 = __OFSUB__((_DWORD)v5, 1);
    v25 = v5 - 1;
    if (v25 < 0 == v17)
    {
      v26 = 0;
      do
      {
        v27 = (v25 + v26) / 2;
        v28 = *(_DWORD *)(*v9 + 4 * v27);
        if (v28 >= a3)
        {
          if (v28 <= a3)
            return 1;
          v25 = v27 - 1;
        }
        else
        {
          v26 = v27 + 1;
        }
      }
      while (v26 <= v25);
    }
    return 0;
  }
  if (!(_DWORD)v12)
    return 0;
  v22 = *(int **)v4;
  while (1)
  {
    v23 = *v22;
    v22 += 2;
    if (v23 == a3)
      break;
    result = 0;
    if (!--v12)
      return result;
  }
  return 1;
}

_QWORD *mfs_CostList_FreeUidIndex(_QWORD *result)
{
  _QWORD *v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (result[1])
  {
    v1 = result;
    v2 = *((unsigned int *)result + 4);
    if ((_DWORD)v2)
    {
      v3 = 0;
      v4 = 8;
      do
      {
        v5 = v1[1];
        v6 = *(_QWORD *)(v5 + v4);
        if (v6)
        {
          result = heap_Free(*(_QWORD **)(*v1 + 8), v6);
          *(_QWORD *)(v5 + v4) = 0;
          v2 = *((unsigned int *)v1 + 4);
        }
        ++v3;
        v4 += 32;
      }
      while (v3 < v2);
    }
  }
  return result;
}

uint64_t mfs_SparseMtx_Load(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  float v5;
  float v6;
  float v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;

  v2 = 2229280772;
  v3 = *(_QWORD *)(a2 + 8);
  if (v3)
  {
    v4 = *(_DWORD *)(a2 + 16);
    if (v4)
    {
      *(_QWORD *)a1 = v3;
      v5 = (float)v4 * 0.25;
      v6 = sqrtf(v5);
      if ((float)(v6 - floorf(v6)) <= 0.0)
      {
        v9 = v6;
        v10 = v4 >> 2;
        do
        {
          v11 = v9 * v9;
          ++v9;
        }
        while (v11 < v10);
        v8 = v9 - 1;
      }
      else
      {
        v7 = sqrt((v5 + -1.0) * 0.5);
        v8 = v7;
      }
      v2 = 0;
      *(_DWORD *)(a1 + 8) = v8;
      *(_DWORD *)(a1 + 12) = v8;
    }
  }
  return v2;
}

void *mfs_SparseMtx_DeInit(void *a1)
{
  return cstdlib_memset(a1, 0, 0x10uLL);
}

uint64_t mfs_SplitFeatures(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  _DWORD *v11;
  _DWORD *v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned __int16 *v16;
  int v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  unsigned __int16 v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  unint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  int v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v60;
  unsigned int *v61;
  uint64_t *v62;
  unsigned int v63;
  _DWORD *v64;
  uint64_t v65;

  v8 = 2229280778;
  v9 = *(__int16 *)(a2 + 10);
  v10 = heap_Calloc(*(_QWORD **)(a1 + 8), v9, 4);
  if (!v10)
    return v8;
  v11 = (_DWORD *)v10;
  v12 = (_DWORD *)heap_Calloc(*(_QWORD **)(a1 + 8), v9 + 1, 4);
  if (!v12)
  {
    v57 = *(_QWORD **)(a1 + 8);
    v58 = (uint64_t)v11;
LABEL_63:
    heap_Free(v57, v58);
    return v8;
  }
  v13 = (uint64_t)v12;
  v65 = a1;
  *v12 = 0;
  v14 = *(__int16 *)(a2 + 10);
  v61 = a4;
  v62 = a3;
  if (v14 < 1)
    goto LABEL_30;
  v15 = 0;
  v16 = *(unsigned __int16 **)(a2 + 1800);
  v17 = (__int16)(v14 + 1);
  v18 = v17 <= 2 ? 2 : v17;
  v19 = v12 + 1;
  v20 = v18 - 1;
  do
  {
    v21 = *v16++;
    v15 += v21;
    *v19++ = v15;
    --v20;
  }
  while (v20);
  if (v14 < 2)
  {
LABEL_30:
    v29 = 0;
    *v11 = 1;
    v36 = 2;
  }
  else
  {
    v22 = v12[1];
    v23 = 1;
    v64 = v11;
    do
    {
      v24 = v23 + 1;
      v25 = *(_DWORD *)(v13 + 4 * (v23 + 1));
      if (v25 << 16 > v22 << 16)
      {
        v26 = v23 - 1;
        do
        {
          if (*(_DWORD *)(*(_QWORD *)(a2 + 3512) + 32 * (__int16)v22) == 50)
          {
            MFS__log_select_Diag(a1, 2, (uint64_t)"PROSODY_DEBUG: MARKER_PROSODY detected at phoneme %d, phoneme value for previous phoneme is %d\n");
            if (*(_BYTE *)(*(_QWORD *)(a2 + 32) + v26) != 1 && (_WORD)v23 != 1)
            {
              v27 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 152) + v26);
              v28 = v23 - 1;
              do
              {
                if (*(unsigned __int8 *)(*(_QWORD *)(a2 + 152) + v28) != v27)
                  break;
                *(_BYTE *)(*(_QWORD *)(a2 + 296) + v28) = 2;
                *(_BYTE *)(*(_QWORD *)(a2 + 104) + v28) = 4;
                *(_BYTE *)(*(_QWORD *)(a2 + 152) + v28) = 1;
                *(_BYTE *)(*(_QWORD *)(a2 + 120) + v28) = 2;
                *(_BYTE *)(*(_QWORD *)(a2 + 136) + v28) = 1;
                *(_BYTE *)(*(_QWORD *)(a2 + 176) + v28--) = 2;
              }
              while (v28);
            }
          }
          LOWORD(v22) = v22 + 1;
          v25 = *(_DWORD *)(v13 + 4 * v24);
        }
        while ((__int16)v25 > (__int16)v22);
        LOWORD(v14) = *(_WORD *)(a2 + 10);
        v11 = v64;
      }
      v22 = v25;
      ++v23;
    }
    while (v24 < (__int16)v14);
    *v11 = 1;
    if ((__int16)v14 < 3)
    {
      v29 = 0;
      v36 = 2;
      v8 = 2229280778;
    }
    else
    {
      v29 = 0;
      v30 = (__int16)v14 - 1;
      v31 = *(_QWORD *)(a2 + 32);
      v32 = 1;
      v33 = 1;
      LOWORD(v34) = 1;
      v8 = 2229280778;
      do
      {
        v34 = (__int16)v34;
        if (*(_BYTE *)(v31 + (__int16)v34) == 1
          && *(_BYTE *)(v31 + v33 + 1) != 1
          && !*(_WORD *)(*(_QWORD *)(a2 + 1800) + 2 * v34))
        {
          v11[v29++] = v32 + 1;
        }
        v35 = v11[v29];
        v32 = v35 + 1;
        v11[v29] = v35 + 1;
        LOWORD(v34) = v34 + 1;
        v33 = (__int16)v34;
      }
      while (v30 > (__int16)v34);
      v36 = v35 + 2;
    }
  }
  v11[v29] = v36;
  v37 = v29 + 1;
  v38 = heap_Calloc(*(_QWORD **)(v65 + 8), (v29 + 1), 8);
  if (!v38)
  {
    heap_Free(*(_QWORD **)(v65 + 8), (uint64_t)v11);
    v57 = *(_QWORD **)(v65 + 8);
    v58 = v13;
    goto LABEL_63;
  }
  v39 = v38;
  if ((v29 - 1) > 0xFFFFFFFD)
  {
LABEL_60:
    heap_Free(*(_QWORD **)(v65 + 8), (uint64_t)v11);
    heap_Free(*(_QWORD **)(v65 + 8), v13);
    v8 = 0;
    *v61 = v37;
    *v62 = v39;
  }
  else
  {
    v40 = 0;
    v63 = 0;
    if (v37 <= 1)
      v41 = 1;
    else
      v41 = v37;
    v60 = v41;
    while (1)
    {
      v42 = (void *)heap_Calloc(*(_QWORD **)(v65 + 8), 1, 3656);
      *(_QWORD *)(v39 + 8 * v40) = v42;
      if (!v42)
        break;
      cstdlib_memset(v42, 0, 0xE48uLL);
      v43 = 0;
      v44 = *(_QWORD *)(v39 + 8 * v40);
      *(_QWORD *)v44 = *(_QWORD *)a2;
      v45 = v40 * *(unsigned __int16 *)(*(_QWORD *)a2 + 3360);
      *(_QWORD *)(*(_QWORD *)(v39 + 8 * v40) + 3584) = *(_QWORD *)(a2 + 3584) + 4 * v45;
      v46 = v11[v40];
      *(_WORD *)(v44 + 10) = v46;
      *(_QWORD *)(*(_QWORD *)(v39 + 8 * v40) + 3592) = *(_QWORD *)(a2 + 3592) + 4 * v45;
      do
      {
        v47 = a2 + 8 * v43;
        v49 = *(_QWORD *)(v47 + 16);
        v48 = (_QWORD *)(v47 + 16);
        if (v49)
        {
          *(_QWORD *)(*(_QWORD *)(v39 + 8 * v40) + 8 * v43 + 16) = heap_Calloc(*(_QWORD **)(v65 + 8), v46, 1);
          if (!*(_QWORD *)(*(_QWORD *)(v39 + 8 * v40) + 8 * v43 + 16))
            goto LABEL_64;
        }
        else if (*(_QWORD *)(a2 + 8 * v43 + 1760))
        {
          *(_QWORD *)(*(_QWORD *)(v39 + 8 * v40) + 8 * v43 + 1760) = heap_Calloc(*(_QWORD **)(v65 + 8), v46, 2);
          if (!*(_QWORD *)(*(_QWORD *)(v39 + 8 * v40) + 8 * v43 + 1760))
            goto LABEL_64;
        }
        v46 = v11[v40];
        if ((_DWORD)v46)
        {
          v50 = 0;
          v51 = (_QWORD *)(a2 + 8 * v43 + 1760);
          do
          {
            if (*v48)
            {
              *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v39 + 8 * v40) + 8 * v43 + 16) + v50) = *(_BYTE *)(*v48
                                                                                                  + v63
                                                                                                  + v50);
              v46 = v11[v40];
            }
            else if (*v51)
            {
              *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v39 + 8 * v40) + 8 * v43 + 1760) + 2 * v50) = *(_WORD *)(*v51 + 2 * (v63 + v50));
            }
            ++v50;
          }
          while (v50 < v46);
        }
        else
        {
          v46 = 0;
        }
        ++v43;
      }
      while (v43 != 218);
      v52 = *(_QWORD *)(v39 + 8 * v40);
      *(_DWORD *)(v52 + 3520) = 0;
      if (v11[v40])
      {
        v53 = 0;
        v54 = 0;
        v55 = *(_QWORD *)(v52 + 1800);
        do
        {
          v53 += *(unsigned __int16 *)(v55 + 2 * v54);
          *(_DWORD *)(v52 + 3520) = v53;
          ++v54;
          v56 = v11[v40];
        }
        while (v54 < v56);
      }
      else
      {
        LODWORD(v56) = 0;
      }
      *(_QWORD *)(v52 + 3512) = *(_QWORD *)(a2 + 3512) + 32 * *(unsigned int *)(v13 + 4 * v63);
      v63 = v63 + v56 - 1;
      if (++v40 == v60)
        goto LABEL_60;
    }
LABEL_64:
    heap_Free(*(_QWORD **)(v65 + 8), (uint64_t)v11);
    heap_Free(*(_QWORD **)(v65 + 8), v13);
    mfs_FreeSplitFeatures(v65, v39, v37);
    return 2229280778;
  }
  return v8;
}

_QWORD *mfs_FreeSplitFeatures(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a3 >= 2)
  {
    v5 = 0;
    v6 = a3;
    do
    {
      if (*(_QWORD *)(a2 + 8 * v5))
      {
        for (i = 1760; i != 3504; i += 8)
        {
          v8 = *(_QWORD *)(a2 + 8 * v5);
          v9 = *(_QWORD *)(v8 + i - 1744);
          if (v9)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v9);
            v8 = *(_QWORD *)(a2 + 8 * v5);
          }
          v10 = *(_QWORD *)(v8 + i);
          if (v10)
            heap_Free(*(_QWORD **)(a1 + 8), v10);
        }
        v11 = *(_QWORD *)(a2 + 8 * v5);
      }
      else
      {
        v11 = 0;
      }
      heap_Free(*(_QWORD **)(a1 + 8), v11);
      ++v5;
    }
    while (v5 != v6);
  }
  return heap_Free(*(_QWORD **)(a1 + 8), a2);
}

uint64_t mfs_ParamMap_MapSection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v8;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  const char *v17;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v23;
  int v24;
  uint64_t v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float *v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  float v34;
  unsigned int v35;
  float v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  unsigned __int8 v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  unsigned int v46;
  char v47;
  _DWORD *v48;
  int *v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  float v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t *v78;
  unsigned int v80;
  uint64_t v81;
  _BYTE *v83;
  uint64_t v84;
  uint64_t *v85;
  int v87;
  int v88;

  v8 = a6;
  v12 = *(_DWORD *)(a5 + 4);
  v13 = *(unsigned __int16 *)(a5 + 8);
  v14 = *(_QWORD *)(a2 + 1072);
  v15 = *(_DWORD *)(v14 + 8280);
  if (v15 == 1 && *(_DWORD *)(v14 + 25288) == 1)
    goto LABEL_10;
  if ((v12 + v13) <= *(_DWORD *)(a2 + 1544))
  {
    if (v15 == 1 || *(_QWORD *)(a2 + 12440) != 0)
    {
LABEL_10:
      v85 = (uint64_t *)(a2 + 12440);
      v19 = 0;
      v83 = (_BYTE *)(a2 + 12456);
      v81 = a1;
      v80 = a4;
      do
      {
        v20 = *(_QWORD *)(a2 + 1072);
        v21 = *(_DWORD *)(v20 + 4 * v19 + 224);
        if (v21)
        {
          if (v21 == 2 && *(_DWORD *)(v20 + 8280) == 1)
          {
            v23 = 0;
            v24 = v13;
          }
          else
          {
            v23 = *(_DWORD *)(v20 + 4 * v19 + 264);
            v24 = v23 * v13;
          }
          v26 = (4 * v24);
          v27 = a3 + 4 * v19;
          if (*(_DWORD *)(v27 + 2528) < (4 * v24))
          {
            v28 = a3 + 8 * v19;
            v29 = heap_Realloc(*(uint64_t **)(*(_QWORD *)(a3 + 1928) + 8), *(_QWORD *)(v28 + 2448), v26);
            *(_QWORD *)(v28 + 2448) = v29;
            if (!v29)
              return 2229280778;
            *(_DWORD *)(v27 + 2528) = v26;
            v20 = *(_QWORD *)(a2 + 1072);
          }
          if (*(_DWORD *)(v20 + 25288) && *(_DWORD *)(v20 + 4 * v19 + 224) == 1)
          {
            cstdlib_memset(*(void **)(a3 + 8 * v19 + 2448), 0, v26);
            v8 = a6;
          }
          else
          {
            v8 = a6;
            if (*(_DWORD *)(v20 + 8280) == 1 && *(_DWORD *)(v20 + 4 * v19 + 224) == 2)
            {
              if (*(_DWORD *)(a3 + 2064) == 2)
              {
                if ((_DWORD)v13)
                {
                  v30 = *(float **)(a3 + 8 * v19 + 2448);
                  v31 = *(_QWORD *)(v20 + 18104);
                  bzero(v30, 4 * v13);
                  v32 = v31 + 12 * v80;
                  v33 = *(unsigned __int16 *)(v32 + 6);
                  v34 = -1.0e10;
                  if (v33 != 256)
                    v34 = (float)((float)v33 / *(float *)(v20 + 8752)) + *(float *)(v20 + 8672);
                  v35 = *(_DWORD *)v32;
                  v36 = -1.0e10;
                  if (v35 != 0x10000)
                    v36 = (float)((float)v35 / *(float *)(v20 + 8752)) + *(float *)(v20 + 8672);
                  *v30 = v34;
                  v30[(v13 - 1)] = v36;
                }
              }
              else
              {
                MFS__log_select_Error(v81, 0, (uint64_t)"decoding LF0 only works with MCP_S9__LF0_S8_X2B, but now is %d \n", a4, a5, a6, (uint64_t)a7, a8);
              }
            }
            else if ((_DWORD)v13)
            {
              v37 = 0;
              v38 = 0;
              v39 = *(_QWORD *)(a3 + 8 * v19 + 2448);
              v40 = *(_DWORD *)(v20 + 4 * v19 + 224);
              do
              {
                if (v40 == 2)
                {
                  if (!*v83)
                  {
                    v16 = 2229280775;
                    v17 = "Invalid VQ unitparams data, 0 codebook found!\n";
                    a1 = v81;
                    goto LABEL_5;
                  }
                  v41 = *v83 - 1;
                  if (v23)
                    goto LABEL_41;
                }
                else
                {
                  v41 = 0;
                  if (v23)
                  {
LABEL_41:
                    v42 = 0;
                    v43 = (v12 + v38);
                    v44 = *v85;
                    do
                    {
                      v45 = *(unsigned __int8 *)(v44 + 24 * v41 + 4);
                      if (v45 == 2)
                      {
                        v46 = *(unsigned __int16 *)(*(_QWORD *)(v44 + 24 * v41 + 16) + 2 * v43);
                      }
                      else
                      {
                        if (v45 != 1)
                        {
                          MFS__log_select_Error(0, 0, (uint64_t)"Error: %d Bytes Codebook not supported!\n", a4, a5, a6, (uint64_t)a7, a8);
                          return 2229280772;
                        }
                        v46 = *(unsigned __int8 *)(*(_QWORD *)(v44 + 24 * v41 + 16) + v43);
                      }
                      v47 = *(_BYTE *)(v44 + 24 * v41 + 5);
                      if (v47)
                      {
                        v48 = (_DWORD *)(v39 + 4 * (v37 + v42));
                        v49 = (int *)(*(_QWORD *)(v44 + 24 * v41 + 8)
                                    + 4 * v46 * (unint64_t)*(unsigned __int8 *)(v44 + 24 * v41 + 5));
                        v50 = *(unsigned __int8 *)(v44 + 24 * v41 + 5);
                        do
                        {
                          v51 = *v49++;
                          *v48++ = v51;
                          --v50;
                        }
                        while (v50);
                      }
                      ++v41;
                      v42 = (v47 + v42);
                    }
                    while (v23 > v42);
                  }
                }
                ++v38;
                v37 += v23;
              }
              while (v38 != v13);
            }
          }
          v25 = *(_QWORD *)(a3 + 8 * v19 + 2448);
        }
        else
        {
          v25 = 0;
        }
        *(_QWORD *)(v8 + 8 * v19++) = v25;
      }
      while (v19 != 10);
      goto LABEL_93;
    }
    if (*(_QWORD *)(a2 + 1256))
    {
      v52 = 0;
      v53 = 0;
      v16 = 0;
      v54 = (uint64_t *)(a3 + 2296);
      while (1)
      {
        v55 = *(_QWORD *)(a2 + 8 * v52 + 1224);
        if (v55)
        {
          v56 = v55 + 4 * (*(_DWORD *)(*(_QWORD *)(a2 + 1072) + v52 + 264) * v12);
        }
        else
        {
          v57 = *(v54 - 1);
          if (!v57)
          {
            *(_QWORD *)(v8 + v53) = 0;
            goto LABEL_66;
          }
          v88 = 0;
          v58 = *(_QWORD *)(a2 + 1072);
          v88 = 4 * v13 * *(_DWORD *)(v58 + v52 + 264);
          if (*v54)
          {
            brk_DataUnmap(*(_QWORD *)(*(_QWORD *)(a3 + 1928) + 24), v57, *v54);
            *v54 = 0;
            v57 = *(v54 - 1);
            v58 = *(_QWORD *)(a2 + 1072);
          }
          v16 = brk_DataMapEx(*(_QWORD *)(*(_QWORD *)(a3 + 1928) + 24), v57, (*(_DWORD *)(a2 + 4 * v53 + 1232) + 4 * v12 * *(_DWORD *)(v58 + v52 + 264)), (uint64_t)&v88, (uint64_t)v54);
          v56 = *v54;
        }
        *(_QWORD *)(v8 + v53) = v56;
LABEL_66:
        v53 += 8;
        v52 += 4;
        v54 += 2;
        if (v52 == 40)
          goto LABEL_94;
      }
    }
    if (!*(_QWORD *)(a2 + 1280))
    {
LABEL_93:
      v16 = 0;
LABEL_94:
      *a7 = v13;
      return v16;
    }
    v59 = 0;
    v16 = 0;
    while (1)
    {
      v60 = *(_QWORD *)(a2 + 32 * v59 + 1240);
      if (v60)
      {
        v61 = v60 + 2 * (*(_DWORD *)(*(_QWORD *)(a2 + 1072) + 4 * v59 + 264) * v12);
        if (v61)
          goto LABEL_73;
      }
      else
      {
        v73 = a3 + 16 * v59;
        v74 = *(_QWORD *)(v73 + 2288);
        if (!v74)
        {
          v72 = 0;
          goto LABEL_91;
        }
        v87 = 0;
        v75 = *(_QWORD *)(a2 + 1072);
        v87 = 2 * v13 * *(_DWORD *)(v75 + 4 * v59 + 264);
        v76 = (uint64_t *)(v73 + 2296);
        v77 = *(_QWORD *)(v73 + 2296);
        if (v77)
        {
          v78 = (uint64_t *)(v73 + 2288);
          brk_DataUnmap(*(_QWORD *)(*(_QWORD *)(a3 + 1928) + 24), v74, v77);
          *v76 = 0;
          v74 = *v78;
          v75 = *(_QWORD *)(a2 + 1072);
        }
        v16 = brk_DataMapEx(*(_QWORD *)(*(_QWORD *)(a3 + 1928) + 24), v74, (*(_DWORD *)(a2 + 32 * v59 + 1232) + 2 * v12 * *(_DWORD *)(v75 + 4 * v59 + 264)), (uint64_t)&v87, (uint64_t)v76);
        v61 = *v76;
        if (*v76)
        {
LABEL_73:
          v62 = (4 * v13 * *(_DWORD *)(*(_QWORD *)(a2 + 1072) + 4 * v59 + 264));
          v63 = a3 + 4 * v59;
          if (*(_DWORD *)(v63 + 2528) < v62)
          {
            v84 = a3 + 8 * v59;
            v64 = heap_Realloc(*(uint64_t **)(*(_QWORD *)(a3 + 1928) + 8), *(_QWORD *)(v84 + 2448), v62);
            *(_QWORD *)(v84 + 2448) = v64;
            if (!v64)
              return 2229280778;
            *(_DWORD *)(v63 + 2528) = v62;
          }
          v8 = a6;
          if ((_DWORD)v13)
          {
            v65 = 0;
            v66 = 0;
            v67 = *(unsigned int *)(*(_QWORD *)(a2 + 1072) + 4 * v59 + 264);
            v68 = *(_DWORD *)(*(_QWORD *)(a2 + 1072) + 4 * v59 + 264);
            do
            {
              if ((int)v67 >= 1)
              {
                v69 = 0;
                v70 = *(_QWORD *)(a3 + 8 * v59 + 2448) + v65;
                do
                {
                  v71 = -1.0e10;
                  if (*(_WORD *)(v61 + 2 * v69))
                    v71 = *(float *)(*(_QWORD *)(a2 + 32 * v59 + 1248)
                                   + 4 * (v69 + 2 * *(unsigned __int16 *)(a5 + 10) * (uint64_t)v68))
                        + (float)((float)*(unsigned __int16 *)(v61 + 2 * v69)
                                * *(float *)(*(_QWORD *)(a2 + 32 * v59 + 1248)
                                           + 4 * (v69 + ((2 * *(unsigned __int16 *)(a5 + 10)) | 1) * (int)v67)));
                  *(float *)(v70 + 4 * v69++) = v71;
                }
                while (v67 != v69);
              }
              ++v66;
              v65 += 4 * (int)v67;
              v61 += 2 * (int)v67;
            }
            while (v66 != v13);
          }
          v72 = *(_QWORD *)(a3 + 8 * v59 + 2448);
          goto LABEL_91;
        }
      }
      v72 = 0;
      v8 = a6;
LABEL_91:
      *(_QWORD *)(v8 + 8 * v59++) = v72;
      if (v59 == 10)
        goto LABEL_94;
    }
  }
  v16 = 2229280775;
  v17 = "Data Corrupt: Offset out of map file, %lu + %hu > %lu\n";
LABEL_5:
  MFS__log_select_Error(a1, 58012, (uint64_t)v17, a4, a5, a6, (uint64_t)a7, a8);
  return v16;
}

uint64_t mfs_ParamMap_UnMapSection(uint64_t result)
{
  uint64_t v1;
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v1 = result;
  for (i = 0; i != 160; i += 16)
  {
    v3 = v1 + i;
    v4 = *(_QWORD *)(v1 + i + 2296);
    if (v4)
    {
      result = brk_DataUnmap(*(_QWORD *)(*(_QWORD *)(v1 + 1928) + 24), *(_QWORD *)(v3 + 2288), v4);
      *(_QWORD *)(v3 + 2296) = 0;
    }
  }
  return result;
}

uint64_t mfs_ParamMap_GetAcousticVector(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t *v21;
  unsigned int v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  float *v30;
  float v31;
  float v32;
  char v33;
  float v34;
  uint64_t v35;
  _DWORD *v36;
  _DWORD *v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  float *v42;
  float v43;
  float v44;
  unsigned int v45;
  int v46;
  unsigned int v47;
  float v48;
  unsigned int v49;
  unsigned int v50;
  char v51;
  float v52;
  int v53;
  int v54;
  float v55;
  unsigned int v56;
  uint64_t v57;
  _DWORD *v58;
  int v59;
  int v60;
  uint64_t v61;
  _DWORD *v63;
  unsigned int v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD v67[2];

  v12 = *(_QWORD *)(a2 + 1072);
  v67[0] = 0;
  v67[1] = 0;
  v66 = v67;
  mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, a4, (uint64_t *)&v66);
  v14 = *(_DWORD *)(a3 + 2064);
  if (v14 == 1)
  {
    v16 = *(uint64_t **)(a3 + 2040);
    if (v16 && (v17 = *(unsigned int *)(a3 + 2068), (_DWORD)v17 != 20000))
    {
      v19 = *v16;
    }
    else
    {
      v15 = 2229280778;
      v18 = heap_Calloc(*(_QWORD **)(a1 + 8), 20000, 8);
      if (!v18)
        return v15;
      v19 = v18;
      v20 = (_QWORD *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, 16);
      if (!v20)
        goto LABEL_34;
      v17 = 0;
      *v20 = v19;
      v20[1] = *(_QWORD *)(a3 + 2040);
      *(_QWORD *)(a3 + 2040) = v20;
      *(_DWORD *)(a3 + 2068) = 0;
    }
    v15 = mfs_ParamMap_MapSection(a1, a2, a3, a4, (uint64_t)v66, a5, a6, v13);
    if ((v15 & 0x80000000) != 0)
      return v15;
    v25 = v19 + 8 * v17;
    v26 = *((int *)v66 + 1);
    v27 = *a6;
    v28 = v26 + *((unsigned __int16 *)v66 + 4) - 1;
    v29 = *(_QWORD *)(a2 + 2096);
    *(_WORD *)(v25 + 4) = *(_WORD *)(v29 + 2 * v26);
    *(_WORD *)(v25 + 6) = *(_WORD *)(v29 + 2 * v28);
    v30 = *(float **)(a5 + 16);
    v31 = *v30;
    v32 = *v30;
    if (v27 >= 2)
      v32 = v30[v27 - 1];
    if (v31 <= 0.0)
    {
      v33 = 1;
    }
    else
    {
      v33 = 0;
      v34 = *(float *)(v12 + 8672);
      if (v31 < v34)
        v31 = *(float *)(v12 + 8672);
      if (v31 > *(float *)(v12 + 8712))
        v31 = *(float *)(v12 + 8712);
      *(_BYTE *)(v19 + 8 * v17 + 2) = (float)((float)((float)(v31 - v34) * *(float *)(v12 + 8752)) + 0.5);
    }
    *(_BYTE *)v25 = v33;
    if (v32 <= 0.0)
    {
      v51 = 1;
    }
    else
    {
      v51 = 0;
      v52 = *(float *)(v12 + 8672);
      if (v32 < v52)
        v32 = *(float *)(v12 + 8672);
      if (v32 > *(float *)(v12 + 8712))
        v32 = *(float *)(v12 + 8712);
      *(_BYTE *)(v19 + 8 * v17 + 3) = (float)((float)((float)(v32 - v52) * *(float *)(v12 + 8752)) + 0.5);
    }
    *(_BYTE *)(v19 + 8 * v17 + 1) = v51;
    *(_QWORD *)(*(_QWORD *)(a3 + 2048) + 8 * (int)a4) = v25;
LABEL_57:
    ++*(_DWORD *)(a3 + 2068);
    return v15;
  }
  if (v14 != 2)
  {
    v21 = *(uint64_t **)(a3 + 2024);
    if (v21)
    {
      v22 = *(_DWORD *)(a3 + 2068);
      if (v22 != 20000)
      {
        v19 = *v21;
LABEL_25:
        v64 = v22;
        v65 = v19;
        v35 = v19 + 24 * v22;
        *(_DWORD *)(v35 + 8) = 0;
        v36 = (_DWORD *)(v35 + 8);
        v63 = (_DWORD *)v35;
        *(_DWORD *)(v35 + 4) = 0;
        v37 = (_DWORD *)(v35 + 4);
        v15 = mfs_ParamMap_MapSection(a1, a2, a3, a4, (uint64_t)v66, a5, a6, v13);
        if ((v15 & 0x80000000) != 0)
          return v15;
        v38 = *((int *)v66 + 1);
        v39 = v38 + *((unsigned __int16 *)v66 + 4) - 1;
        v40 = *(_QWORD *)(a2 + 2096);
        v41 = *(unsigned __int16 *)(v40 + 2 * v38);
        v42 = *(float **)(a5 + 16);
        v43 = *v42;
        v44 = *v42;
        if (*a6 >= 2)
          v44 = v42[*a6 - 1];
        v45 = *v36 & 0xFFFFC003;
        v46 = *(unsigned __int16 *)(v40 + 2 * v39);
        v47 = *v37 & 0xFFFFC003 | (4 * v41);
        if (v43 <= 0.0)
        {
          v53 = v47 | 2;
          *v37 = v53;
          v50 = v64;
          if (!*(_DWORD *)(v12 + 8392))
            goto LABEL_45;
          v49 = v53 & 0xFF803FFF | (*(_DWORD *)(v12 + 8396) << 14);
        }
        else
        {
          v48 = *(float *)(v12 + 8672);
          if (v43 < v48)
            v43 = *(float *)(v12 + 8672);
          if (v43 > *(float *)(v12 + 8712))
            v43 = *(float *)(v12 + 8712);
          v49 = v47 & 0xFF803FFD | ((float)((float)((float)(v43 - v48) * *(float *)(v12 + 8752)) + 0.5) << 14);
          v50 = v64;
        }
        *v37 = v49;
LABEL_45:
        v54 = v45 | (4 * v46);
        if (v44 <= 0.0)
        {
          v59 = v54 | 2;
          *v36 = v59;
          v57 = v65;
          v58 = v63;
          if (!*(_DWORD *)(v12 + 8392))
          {
LABEL_56:
            v60 = *(_DWORD *)(a3 + 2060) & a4;
            *v58 = a4;
            v61 = *(_QWORD *)(a3 + 2032);
            *(_QWORD *)(v57 + 24 * v50 + 16) = *(_QWORD *)(v61 + 8 * v60);
            *(_QWORD *)(v61 + 8 * v60) = v58;
            goto LABEL_57;
          }
          v56 = v59 & 0xFF803FFF | (*(_DWORD *)(v12 + 8396) << 14);
        }
        else
        {
          v55 = *(float *)(v12 + 8672);
          if (v44 < v55)
            v44 = *(float *)(v12 + 8672);
          if (v44 > *(float *)(v12 + 8712))
            v44 = *(float *)(v12 + 8712);
          v56 = v54 & 0xFF803FFD | ((float)((float)((float)(v44 - v55) * *(float *)(v12 + 8752)) + 0.5) << 14);
          v57 = v65;
          v58 = v63;
        }
        *v36 = v56;
        goto LABEL_56;
      }
    }
    v15 = 2229280778;
    v23 = heap_Calloc(*(_QWORD **)(a1 + 8), 20000, 24);
    if (!v23)
      return v15;
    v19 = v23;
    v24 = (_QWORD *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, 16);
    if (v24)
    {
      v22 = 0;
      *v24 = v19;
      v24[1] = *(_QWORD *)(a3 + 2024);
      *(_QWORD *)(a3 + 2024) = v24;
      *(_DWORD *)(a3 + 2068) = 0;
      goto LABEL_25;
    }
LABEL_34:
    heap_Free(*(_QWORD **)(a1 + 8), v19);
    return v15;
  }
  return mfs_ParamMap_MapSection(a1, a2, a3, a4, (uint64_t)v66, a5, a6, v13);
}

uint64_t mfs_Stub_ParamMap_GetAcousticVector(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int *a7)
{
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  float v26;
  uint64_t *v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unsigned int v32;
  _DWORD *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  unsigned int v44;
  _QWORD *v45;
  _QWORD v46[2];

  v14 = *(_QWORD *)(a2 + 1072);
  v46[0] = 0;
  v46[1] = 0;
  v45 = v46;
  mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, a4, (uint64_t *)&v45);
  if (!*(_QWORD *)(a2 + 2104))
    return mfs_ParamMap_GetAcousticVector(a1, a2, a3, a4, a5, a7);
  v15 = *((unsigned int *)v45 + 1);
  v16 = *a7;
  v17 = *((unsigned __int16 *)v45 + 4);
  if (!*a7)
  {
    *a7 = v17;
    v16 = v17;
  }
  v44 = v17;
  if (a6 == 1)
  {
    if ((_DWORD)v15)
      v18 = v15 - 1;
    else
      v18 = 0;
    v16 += 2;
    *a7 = v16;
  }
  else
  {
    v18 = v15;
  }
  v19 = 2229280778;
  if (*(_DWORD *)(a3 + 2536) < v16)
  {
    v20 = heap_Realloc(*(uint64_t **)(a1 + 8), *(_QWORD *)(a3 + 2464), 4 * (int)(v16 + 50));
    *(_QWORD *)(a3 + 2464) = v20;
    if (!v20)
      return v19;
    *(_DWORD *)(a3 + 2536) = *a7 + 50;
    v16 = *a7;
  }
  if (v16)
  {
    v21 = 0;
    v22 = *(_DWORD *)(v14 + 8396);
    v23 = *(_QWORD *)(a2 + 2104);
    v24 = *(_QWORD *)(a3 + 2464);
    do
    {
      v25 = *(unsigned __int16 *)(v23 + 2 * (v18 + v21));
      v26 = -1.0e10;
      if (v22 != v25)
        v26 = (float)((float)v25 / *(float *)(v14 + 8752)) + *(float *)(v14 + 8672);
      *(float *)(v24 + 4 * v21++) = v26;
    }
    while (v16 != v21);
  }
  else
  {
    v24 = *(_QWORD *)(a3 + 2464);
  }
  *(_QWORD *)(a5 + 16) = v24;
  v27 = *(uint64_t **)(a3 + 2024);
  if (v27 && (v28 = *(_DWORD *)(a3 + 2068), v28 != 20000))
  {
    v30 = *v27;
  }
  else
  {
    v29 = heap_Calloc(*(_QWORD **)(a1 + 8), 20000, 24);
    if (!v29)
      return v19;
    v30 = v29;
    v31 = (_QWORD *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, 16);
    if (!v31)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v30);
      return v19;
    }
    v28 = 0;
    *v31 = v30;
    v31[1] = *(_QWORD *)(a3 + 2024);
    *(_QWORD *)(a3 + 2024) = v31;
    *(_DWORD *)(a3 + 2068) = 0;
  }
  v32 = v15 + v44 - 1;
  v33 = (_DWORD *)(v30 + 24 * v28);
  v34 = *(_QWORD *)(a2 + 2096);
  v35 = *(_QWORD *)(a2 + 2104);
  v36 = *(unsigned __int16 *)(v35 + 2 * v32);
  v37 = (4 * (*(_WORD *)(v34 + 2 * v32) & 0xFFF)) | (v36 << 14);
  v33[2] = v37;
  v38 = *(unsigned __int16 *)(v35 + 2 * v15);
  v39 = (4 * (*(_WORD *)(v34 + 2 * v15) & 0xFFF)) | (v38 << 14);
  v33[1] = v39;
  v40 = *(_DWORD *)(v14 + 8396);
  if (v40 == v38)
    v33[1] = v39 | 2;
  if (v40 == v36)
    v33[2] = v37 | 2;
  v19 = 0;
  v41 = *(_DWORD *)(a3 + 2060) & a4;
  *v33 = a4;
  v42 = *(_QWORD *)(a3 + 2032);
  *(_QWORD *)(v30 + 24 * v28 + 16) = *(_QWORD *)(v42 + 8 * v41);
  *(_QWORD *)(v42 + 8 * v41) = v33;
  *(_DWORD *)(a3 + 2068) = v28 + 1;
  return v19;
}

uint64_t fastallo_AllocateMemoryFromChunk(uint64_t a1, unsigned int a2, int *a3)
{
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unsigned int v11;
  uint64_t result;
  int v13;

  v6 = *(unsigned __int16 *)(a1 + 10);
  if (v6 >= a2)
  {
    result = *(_QWORD *)(a1 + 32);
    goto LABEL_10;
  }
  v8 = *(unsigned int *)(a1 + 12);
  v7 = *(_DWORD *)(a1 + 16);
  if (*(_WORD *)(a1 + 10))
  {
    v9 = a1 + ((v6 + 7) & 0x1FFF8);
    v10 = *(_QWORD **)(a1 + 32);
    *v10 = *(_QWORD *)(v9 + 40);
    *(_QWORD *)(v9 + 40) = v10;
  }
  if (v8 >= v7)
  {
    v11 = v7 + 64;
    result = heap_Realloc(*(uint64_t **)a1, *(_QWORD *)(a1 + 24), 8 * (v7 + 64));
    if (!result)
    {
LABEL_11:
      v13 = -2065686518;
      goto LABEL_12;
    }
    *(_DWORD *)(a1 + 16) = v11;
    *(_QWORD *)(a1 + 24) = result;
  }
  result = heap_Alloc(*(_QWORD *)a1, *(unsigned __int16 *)(a1 + 8));
  if (!result)
    goto LABEL_11;
  *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v8) = result;
  *(_DWORD *)(a1 + 12) = v8 + 1;
  v6 = *(unsigned __int16 *)(a1 + 8) >> 3;
LABEL_10:
  v13 = 0;
  *(_WORD *)(a1 + 10) = v6 - a2;
  *(_QWORD *)(a1 + 32) = result + 8 * a2;
LABEL_12:
  *a3 = v13;
  return result;
}

void *fastallo_Init(_WORD *a1, uint64_t a2, __int16 a3)
{
  void *result;

  result = cstdlib_memset(a1, 0, 0x230uLL);
  a1[4] = a3;
  *(_QWORD *)a1 = a2;
  return result;
}

_QWORD *fastallo_Terminate(_QWORD *result)
{
  _QWORD **v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = (_QWORD **)result;
  v2 = *((unsigned int *)result + 3);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = 8 * v2;
    do
    {
      result = heap_Free(*v1, v1[3][v3 / 8]);
      v3 += 8;
    }
    while (v4 != v3);
  }
  v5 = (uint64_t)v1[3];
  if (v5)
    return heap_Free(*v1, v5);
  return result;
}

uint64_t fastallo_GetUsedMemory(uint64_t a1)
{
  return *(_DWORD *)(a1 + 12) * *(unsigned __int16 *)(a1 + 8) + 8 * *(_DWORD *)(a1 + 16);
}

uint64_t redistributeInjectDur(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  unsigned int *v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  BOOL v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  int v44;

  v10 = mfs_SegmentList_Length(a1 + 2248);
  if (*a2 != 3)
    return 2229280775;
  if (v10 >= 7)
  {
    v11 = 0;
    v12 = *(_DWORD *)(a3 + 24);
    v13 = 4 * v12;
    v14 = 3 * v12;
    v15 = (unsigned int *)(a5 + 16);
    v16 = (_DWORD *)(a4 + 196);
    v17 = 28 * (v10 - 3) - 84;
    v18 = 3;
    do
    {
      v19 = *a2;
      v20 = (*a2 & 1) == 0 || v19 < 2;
      v21 = (*a2 - 1) >> 1;
      if (v20)
        v21 = (*a2 >> 1) - 1;
      if (v18 != v21 + (int)v18 / *a2 * v19)
        goto LABEL_48;
      if (*(v16 - 11) == 1 && !*(v16 - 21))
      {
        v22 = *(v15 - 2);
        v23 = *(_QWORD *)(a1 + 2264);
        v24 = *(_DWORD *)(v23 + v11 + 68);
        v25 = v22 - v24;
        if (v22 > v24)
        {
          if (v25 >= 0)
            v26 = v22 - v24;
          else
            v26 = v25 + 1;
          v27 = v26 >> 1;
          if (v25 >= v13)
            v25 = v27;
          *(v15 - 1) += v25;
          v28 = v22 - v25;
          goto LABEL_19;
        }
        if (v22 < v24)
        {
          v29 = __OFSUB__(v24, v22);
          v30 = v24 - v22;
          if (v30 < 0 != v29)
            v31 = v30 + 1;
          else
            v31 = v30;
          v32 = v31 >> 1;
          if (v30 >= v13)
            v30 = v32;
          if (*(_DWORD *)(v23 + v11 + 96) > v14)
          {
            v33 = *(v15 - 1);
            if (v25 + v33 > v14)
            {
              *(v15 - 1) = v33 - v30;
              v28 = v22 + v30;
LABEL_19:
              *(v15 - 2) = v28;
            }
          }
        }
      }
      if (*(v16 - 10) == 1 && !*v16)
      {
        v34 = *v15;
        v35 = *(_QWORD *)(a1 + 2264);
        v36 = *(_DWORD *)(v35 + v11 + 124);
        v37 = *v15 - v36;
        if (*v15 <= v36)
        {
          if (v34 >= v36)
            goto LABEL_48;
          v29 = __OFSUB__(v36, v34);
          v41 = v36 - v34;
          if (v41 < 0 != v29)
            v42 = v41 + 1;
          else
            v42 = v41;
          v43 = v42 >> 1;
          if (v41 >= v13)
            v41 = v43;
          if (*(_DWORD *)(v35 + v11 + 96) <= v14)
            goto LABEL_48;
          v44 = *(v15 - 1);
          if (v37 + v44 <= v14)
            goto LABEL_48;
          *(v15 - 1) = v44 - v41;
          v40 = v34 + v41;
        }
        else
        {
          if (v37 >= 0)
            v38 = *v15 - v36;
          else
            v38 = v37 + 1;
          v39 = v38 >> 1;
          if (v37 >= v13)
            v37 = v39;
          *(v15 - 1) += v37;
          v40 = v34 - v37;
        }
        *v15 = v40;
      }
LABEL_48:
      ++v15;
      v16 += 10;
      v11 += 28;
      ++v18;
    }
    while (v17 != v11);
  }
  return 0;
}

uint64_t mfs_Psola_CalculateAdjustments(int *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  int *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t i;
  float v39;
  uint64_t v41;
  _DWORD *v42;
  uint64_t v43;
  int v44;
  int v45;
  float *v46;
  float v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  _DWORD *v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  _DWORD *v57;
  uint64_t v58;
  unsigned int *v59;
  uint64_t AcousticVector;
  unsigned int v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unsigned int v66;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  signed int v71;
  unint64_t v72;
  unint64_t v74;
  int32x2_t *v75;
  int32x2_t *v76;
  __int32 v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  int v82;
  uint64_t v83;
  int v84;
  _DWORD *v85;
  int v86;
  int v88;
  int v89;
  int v90;
  int v91;
  uint64_t v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  float v101;
  int v102;
  float v103;
  float v104;
  uint64_t v105;
  int v106;
  int v107;
  int v108;
  int v109;
  uint64_t v110;
  _BOOL4 v111;
  int v112;
  unsigned int v113;
  int v114;
  int v115;
  _DWORD *v116;
  float v117;
  int v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  const char *v123;
  const char *v124;
  const char *v125;
  int v127;
  uint64_t v128;
  _DWORD *v129;
  int v130;
  uint64_t v131;
  int *v132;
  uint64_t v133;
  _DWORD *v134;
  _DWORD *v135;
  unsigned int v136;
  unsigned int v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unsigned int v142;
  uint64_t v143;
  uint64_t v144;
  char v145;
  unsigned int v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  uint64_t v152;

  v152 = *MEMORY[0x24BDAC8D0];
  v4 = 2229280778;
  v5 = *(_QWORD *)a2;
  v6 = *((_QWORD *)a1 + 134);
  v141 = a2 + 2248;
  v7 = mfs_SegmentList_Length(a2 + 2248);
  v8 = *(_DWORD *)(v6 + 24);
  v146 = 0;
  v150 = 0u;
  v151 = 0u;
  v148 = 0u;
  v149 = 0u;
  v147 = 0u;
  v9 = heap_Calloc(*(_QWORD **)(v5 + 8), (*a1 * *(_DWORD *)(a2 + 608)), 4);
  if (!v9)
    return v4;
  v10 = (_DWORD *)v9;
  v11 = heap_Calloc(*(_QWORD **)(v5 + 8), (*a1 * *(_DWORD *)(a2 + 608)), 4);
  if (!v11)
  {
    v36 = (uint64_t)v10;
    goto LABEL_223;
  }
  v130 = v8;
  v135 = (_DWORD *)v11;
  v12 = (int *)(v6 + 25184);
  v13 = *(_DWORD *)(a2 + 608);
  LODWORD(v14) = *a1;
  v15 = (*a1 * v13);
  if ((*(_DWORD *)(v6 + 25184) & 0xFFFFFFFE) == 2 && (v16 = *(_DWORD *)(a2 + 32), v16 >= 1))
  {
    v17 = 0;
    v18 = 0;
    v19 = *(_QWORD *)(a2 + 24);
    do
    {
      if (*(_DWORD *)(v19 + 1528 * v17 + 1480))
        v20 = v13 < 1;
      else
        v20 = 1;
      if (!v20)
      {
        v21 = 0;
        v22 = 0;
        v23 = *(_QWORD *)(a2 + 600);
        do
        {
          if ((int)v14 >= 1)
          {
            v24 = 0;
            v25 = *(_QWORD *)(v23 + 528 * v21 + 328) + 8;
            do
            {
              v26 = *(_DWORD *)(v25 + 4 * v24);
              v10[v22 + v24] = v26;
              v18 += v26;
              v14 = *a1;
              v27 = v24 + 2;
              ++v24;
            }
            while (v27 <= v14);
            v22 += v24;
            v13 = *(_DWORD *)(a2 + 608);
          }
          ++v21;
        }
        while (v21 < v13);
        v16 = *(_DWORD *)(a2 + 32);
      }
      ++v17;
    }
    while (v17 < v16);
  }
  else
  {
    v18 = 0;
  }
  v28 = heap_Calloc(*(_QWORD **)(v5 + 8), v15, 40);
  *(_QWORD *)(a2 + 2656) = v28;
  if (!v28 || (v133 = heap_Calloc(*(_QWORD **)(v5 + 8), v15, 4)) == 0)
  {
    v34 = 0;
    v35 = 0;
    v36 = 0;
    goto LABEL_217;
  }
  v127 = v7;
  v29 = heap_Calloc(*(_QWORD **)(v5 + 8), v15, 4);
  if (!v29)
  {
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v30 = v133;
    goto LABEL_216;
  }
  v30 = v29;
  v31 = *v12;
  if (*v12 == 2)
  {
    if (!*(_DWORD *)(v6 + 25188))
    {
      v33 = 0;
      goto LABEL_71;
    }
    v32 = heap_Calloc(*(_QWORD **)(v5 + 8), v15, 1);
    if (!v32)
    {
      v34 = 0;
      v35 = 0;
      v134 = 0;
      v37 = v133;
      goto LABEL_215;
    }
    v33 = v32;
    v31 = *v12;
  }
  else
  {
    v33 = 0;
  }
  if (v31 == 3)
  {
    v139 = v33;
    v134 = (_DWORD *)heap_Calloc(*(_QWORD **)(v5 + 8), v18, 4);
    if (v134)
    {
      if (v18 >= 1)
      {
        for (i = 0; i != v18; ++i)
        {
          v39 = *(float *)(*(_QWORD *)(a2 + 2648) + i * 4);
          if (v39 < 70.0 || v39 > 450.0)
            v39 = 1000.0;
          *(float *)&v134[i] = v39;
        }
      }
      v37 = v133;
      v129 = (_DWORD *)heap_Calloc(*(_QWORD **)(v5 + 8), v15, 4);
      if (v129)
      {
        v128 = heap_Calloc(*(_QWORD **)(v5 + 8), v15, 4);
        if (!v128)
        {
          v35 = 0;
          v33 = v139;
          v34 = (uint64_t)v129;
          goto LABEL_213;
        }
        v33 = v139;
        if ((int)v15 < 1)
          goto LABEL_75;
        v41 = 0;
        while (v41)
        {
          v42 = &v135[v41];
          v43 = *(v42 - 1);
          v44 = v10[v41];
          v45 = v44 + v43;
          *v42 = v44 + v43;
          v129[v41] = v134[v43];
          v46 = (float *)(v128 + 4 * v41);
          *v46 = *(float *)&v134[(v44 + v43 - 1)];
          v47 = *(float *)&v129[v41];
          if (v47 == 1000.0)
          {
            v48 = v10[v41];
            v49 = 1;
            if (v48 >= 2)
            {
              while (*(float *)&v134[(v43 + v49)] == 1000.0)
              {
                if (v48 == ++v49)
                  goto LABEL_67;
              }
            }
            if ((_DWORD)v49 == (_DWORD)v48)
              goto LABEL_67;
            v47 = *(float *)&v134[(v49 + v43)];
            *(float *)&v129[v41] = v47;
          }
          if (v47 != 1000.0 && *v46 == 1000.0)
          {
            v53 = v10[v41];
            if (v53 < 2)
            {
              v56 = 1;
            }
            else
            {
              v54 = 0;
              v55 = v43 + v44 - 2;
              while (*(float *)&v134[(v55 + v54)] == 1000.0)
              {
                if (1 - v53 == --v54)
                  goto LABEL_67;
              }
              v56 = 1 - v54;
            }
            if (v56 != (_DWORD)v53)
            {
              v52 = v45 + ~v56;
              v51 = v134;
              goto LABEL_54;
            }
          }
LABEL_67:
          v10[v41++] *= v130;
          if (v41 == v15)
            goto LABEL_75;
        }
        v50 = *v10;
        *v135 = *v10;
        v51 = v134;
        *v129 = *v134;
        v52 = v50 - 1;
        v46 = (float *)v128;
LABEL_54:
        *v46 = *(float *)&v51[v52];
        goto LABEL_67;
      }
      v34 = 0;
      v35 = 0;
    }
    else
    {
      v34 = 0;
      v35 = 0;
      v134 = 0;
      v37 = v133;
    }
    v33 = v139;
    goto LABEL_213;
  }
  if (v31 != 2)
  {
    v128 = 0;
    v129 = 0;
    v134 = 0;
    v37 = v133;
    goto LABEL_75;
  }
LABEL_71:
  v37 = v133;
  if ((int)v15 >= 1)
  {
    v57 = v10;
    do
    {
      *v57++ *= v130;
      --v15;
    }
    while (v15);
  }
  v128 = 0;
  v129 = 0;
  v134 = 0;
LABEL_75:
  v138 = (v127 - 1);
  v140 = v33;
  v131 = v30;
  v132 = (int *)(v6 + 25184);
  if (v127 < 1)
  {
    v4 = 0;
    goto LABEL_185;
  }
  v58 = 0;
  v4 = 0;
  do
  {
    v145 = 0;
    v143 = 0;
    v144 = 0;
    v142 = 0;
    mfs_SegmentList_Get(v141, v58, &v142, &v145, (_DWORD *)&v144 + 1, &v144, (_DWORD *)&v143 + 1, &v143);
    v59 = (unsigned int *)(*(_QWORD *)(a2 + 2656) + 40 * v58);
    *v59 = v142;
    v59[1] = HIDWORD(v144);
    v59[2] = v144;
    if (v140)
      *(_BYTE *)(v140 + v58) = v145;
    if (v142 == -1)
    {
      v61 = 1000;
      *(_DWORD *)(v37 + 4 * v58) = 1000;
    }
    else
    {
      v146 = 0;
      if ((*(_DWORD *)(v6 + 8968) - 7) > 4)
        AcousticVector = mfs_ParamMap_GetAcousticVector(v5, (uint64_t)a1, a2, v142, (uint64_t)&v147, (int *)&v146);
      else
        AcousticVector = mfs_Stub_ParamMap_GetAcousticVector(v5, (uint64_t)a1, a2, v142, (uint64_t)&v147, 0, (int *)&v146);
      v4 = AcousticVector;
      if ((AcousticVector & 0x80000000) != 0)
      {
        v33 = v140;
        goto LABEL_212;
      }
      v136 = AcousticVector;
      v62 = v6;
      v63 = v146;
      if ((int)v146 < 1)
        goto LABEL_93;
      v64 = 0;
      v65 = v148;
      do
        v66 = (exp(*(float *)(v65 + 4 * v64++)) + 0.5);
      while (v66 <= 0x45 && v64 < v63);
      if (v66 <= 0x45)
LABEL_93:
        v66 = 1000;
      *(_DWORD *)(v37 + 4 * v58) = v66;
      v68 = v146;
      if ((int)v146 < 1)
        goto LABEL_102;
      v69 = v5;
      v70 = v148;
      v71 = v146 - 1;
      v72 = 1;
      do
        v61 = (exp(*(float *)(v70 + 4 * v71--)) + 0.5);
      while (v61 <= 0x45 && v72++ < v68);
      v5 = v69;
      v37 = v133;
      if (v61 <= 0x45)
LABEL_102:
        v61 = 1000;
      v30 = v131;
      v12 = v132;
      v6 = v62;
      v4 = v136;
    }
    *(_DWORD *)(v30 + 4 * v58++) = v61;
  }
  while (v58 != v127);
  v74 = 0;
  v75 = *(int32x2_t **)(a2 + 2656);
  v76 = v75 + 5;
  do
  {
    if (v74)
    {
      v77 = v76[-5].i32[0];
      v76[-1].i32[0] = v76[-10].i32[0] + 1 == v77;
      v76[-1].i32[1] = v74 < v138 && v77 + 1 == v76->i32[0];
    }
    else
    {
      v75[4] = (int32x2_t)0x100000000;
    }
    v76[-2] = vsub_s32((int32x2_t)vand_s8((int8x8_t)vceqz_s32(v76[-1]), (int8x8_t)0x6400000064), vtst_s32(v76[-1], v76[-1]));
    ++v74;
    v76 += 5;
  }
  while (v127 != v74);
  v78 = 0;
  v79 = *(_QWORD *)(a2 + 2656);
  v80 = 1000;
  v81 = 1000;
  v82 = 1000;
  do
  {
    if (!v78)
    {
LABEL_127:
      v96 = 1000;
      v97 = 1000;
      v98 = 1000;
      goto LABEL_180;
    }
    v83 = v79 + 40 * v78;
    v86 = *(_DWORD *)(v83 - 40);
    v85 = (_DWORD *)(v83 - 40);
    v84 = v86;
    if (v86 == -1 || v78 == v138)
    {
      v90 = 1000;
      v88 = 1000;
      v89 = 1000;
      if (v84 == -1)
        goto LABEL_121;
    }
    else
    {
      v90 = *(_DWORD *)(v37 + 4 * v78 + 4);
    }
    v88 = *(_DWORD *)(v37 + 4 * v78);
    v89 = *(_DWORD *)(v30 + 4 * v78);
LABEL_121:
    v91 = *(_DWORD *)(v79 + 40 * v78);
    if (v91 == -1)
      goto LABEL_127;
    v92 = v78 - 1;
    v93 = *v12;
    if ((*v12 - 1) > 1)
    {
      if (v93 != 3)
        goto LABEL_175;
      if (v88 == 1000)
      {
        v82 = 1000;
      }
      else
      {
        v101 = *(float *)&v129[v78];
        if (v101 == 1000.0)
        {
          v82 = 1000;
          v88 = 1000;
        }
        else
        {
          v103 = *(float *)(v128 + 4 * v92);
          if (v103 == 1000.0)
            v82 = (int)v101;
          else
            v82 = (int)(float)(v101 + v103) / 2;
        }
      }
      if (v89 != 1000)
      {
        v104 = *(float *)(v128 + 4 * v78);
        if (v104 != 1000.0)
        {
          v117 = *(float *)&v129[v78 + 1];
          v81 = (int)v104;
          if (v117 != 1000.0)
            v81 = (int)(float)(v104 + v117) / 2;
LABEL_155:
          v105 = *a1;
          v106 = (int)v78 / (int)v105 * v105;
          v107 = (int)v78 % (int)v105;
          v108 = *(_DWORD *)(v79 + 40 * ((int)v105 - 1 + v106));
          v109 = v105 - 1 + *(_DWORD *)(v79 + 40 * v106);
          LODWORD(v110) = *a1;
          if (v108 != v109)
          {
            if ((int)v105 <= 0)
            {
              v111 = 0;
              goto LABEL_167;
            }
            v110 = 0;
            while (*(_DWORD *)(v79 + 40 * ((int)v78 - v107 + (int)v110) + 8) != v130)
            {
              if (v105 == ++v110)
              {
                LODWORD(v110) = *a1;
                break;
              }
            }
          }
          v111 = v110 == v105;
          if ((int)v105 >= 1)
          {
            v112 = 0;
            v113 = 0;
            v114 = v78 - v107;
            do
            {
              v113 += v10[v114];
              v112 += *(_DWORD *)(v79 + 40 * v114++ + 8);
              --v105;
            }
            while (v105);
            if (v112)
            {
              v80 = (int)((double)v113 * 1000.0 / (double)v112);
LABEL_168:
              if (v80 >= 1300)
                v115 = 1300;
              else
                v115 = v80;
              if (v115 <= 700)
                v115 = 700;
              if (!v111)
                v80 = v115;
              goto LABEL_175;
            }
          }
LABEL_167:
          v80 = 1000;
          goto LABEL_168;
        }
        v89 = 1000;
      }
      v81 = 1000;
      goto LABEL_155;
    }
    v82 = 1000;
    if (v88 == 1000)
    {
      v95 = 1000;
    }
    else
    {
      v94 = *(_DWORD *)(v30 + 4 * v92);
      v95 = 1000;
      if (v94 != 1000)
      {
        if (v91 == *v85 + 1)
        {
          v82 = 1000;
        }
        else
        {
          v99 = v94 + v88;
          if (v94 + v88 < 0 != __OFADD__(v94, v88))
            ++v99;
          v82 = v99 >> 1;
          v95 = v88;
        }
      }
    }
    v81 = 1000;
    if (v89 == 1000)
      goto LABEL_139;
    v100 = 1000;
    if (v90 != 1000)
    {
      if (*(_DWORD *)(v79 + 40 * v78 + 40) != v91 + 1)
      {
        v102 = v89 + v90;
        if (v89 + v90 < 0 != __OFADD__(v89, v90))
          ++v102;
        v81 = v102 >> 1;
        v100 = v89;
        goto LABEL_145;
      }
      v81 = 1000;
LABEL_139:
      v100 = 1000;
    }
LABEL_145:
    if ((v93 & 0xFFFFFFFE) == 2)
    {
      v89 = v100;
      v88 = v95;
      goto LABEL_155;
    }
    v80 = 1000;
    v89 = v100;
    v88 = v95;
LABEL_175:
    v96 = 1000 * v82 / v88;
    v98 = v12[8];
    if (v80 < v98)
      v98 = v80;
    if (v98 <= v12[7])
      v98 = v12[7];
    v97 = 1000 * v81 / v89;
LABEL_180:
    v116 = (_DWORD *)(v79 + 40 * v78);
    v116[3] = v96;
    v116[4] = v97;
    v116[5] = v98;
    ++v78;
  }
  while (v78 != v127);
  v33 = v140;
LABEL_185:
  if (*v12 == 2 && v12[1])
  {
    v118 = *a1;
    if (*a1 < v127 + 1 - *a1)
    {
      v137 = v4;
      v119 = 0;
      v120 = v118;
      v121 = 40 * v118 + 20;
      while (1)
      {
        v122 = (int)v120 / v118;
        if ((int)v120 % v118)
        {
          if (!v119)
            goto LABEL_199;
        }
        else
        {
          v123 = *(const char **)(*(_QWORD *)(v6 + 7616) + 8 * *(unsigned __int8 *)(v33 + v120));
          if (v123 && !cstdlib_strcmp(v123, "SIL"))
            goto LABEL_206;
          if (!mfs_Ling_IsVowel(v6, *(_QWORD *)(a2 + 8), v122))
          {
            if (!mfs_Ling_IsVowel(v6, *(_QWORD *)(a2 + 8), v122 - 1))
            {
              v33 = v140;
              v124 = *(const char **)(*(_QWORD *)(v6 + 7616) + 8 * *(unsigned __int8 *)(v140 - *a1 + v120));
              if (!v124)
                goto LABEL_207;
              if (cstdlib_strcmp(v124, "SIL"))
                goto LABEL_206;
            }
            if (!mfs_Ling_IsVowel(v6, *(_QWORD *)(a2 + 8), v122 + 1))
            {
              v33 = v140;
              v125 = *(const char **)(*(_QWORD *)(v6 + 7616) + 8 * *(unsigned __int8 *)(v140 + *a1 + v120));
              if (!v125)
              {
LABEL_207:
                v119 = 0;
                goto LABEL_199;
              }
              if (cstdlib_strcmp(v125, "SIL"))
              {
LABEL_206:
                v119 = 0;
                v33 = v140;
                goto LABEL_199;
              }
            }
          }
          v119 = 1;
          v33 = v140;
        }
        *(_DWORD *)(*(_QWORD *)(a2 + 2656) + v121) = 1000;
LABEL_199:
        ++v120;
        v118 = *a1;
        v121 += 40;
        if (v120 >= v127 + 1 - *a1)
        {
          v30 = v131;
          v12 = v132;
          v4 = v137;
          v37 = v133;
          goto LABEL_212;
        }
      }
    }
    v30 = v131;
    v12 = v132;
  }
LABEL_212:
  v35 = v128;
  v34 = (uint64_t)v129;
LABEL_213:
  if (v33)
    heap_Free(*(_QWORD **)(v5 + 8), v33);
LABEL_215:
  heap_Free(*(_QWORD **)(v5 + 8), v37);
  v36 = (uint64_t)v134;
LABEL_216:
  heap_Free(*(_QWORD **)(v5 + 8), v30);
LABEL_217:
  heap_Free(*(_QWORD **)(v5 + 8), (uint64_t)v10);
  heap_Free(*(_QWORD **)(v5 + 8), (uint64_t)v135);
  if (*v12 == 3)
  {
    if (v34)
      heap_Free(*(_QWORD **)(v5 + 8), v34);
    if (v35)
      heap_Free(*(_QWORD **)(v5 + 8), v35);
    if (v36)
LABEL_223:
      heap_Free(*(_QWORD **)(v5 + 8), v36);
  }
  return v4;
}

float mfs_TCost_LF0_SLP_distance(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float result;

  result = (float)((float)(a1 - a3) / a5) - (float)((float)(a2 - a4) / a6);
  if (result < 0.0)
    return -result;
  return result;
}

float mfs_TCost_LF0_BND_distance(float a1, float a2, float a3, float a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;

  if (a1 <= a2)
    v4 = a2;
  else
    v4 = a1;
  if (a3 <= a4)
    v5 = a4;
  else
    v5 = a3;
  v6 = a1 - a2;
  if (v6 < 0.0)
    v6 = -v6;
  v7 = v6 / v4;
  v8 = a3 - a4;
  v9 = -(float)(a3 - a4);
  if (v8 < 0.0)
    v8 = v9;
  return v7 + (float)(v8 / v5);
}

uint64_t mfs_TCost_Init(uint64_t a1, uint64_t a2, _DWORD *__b)
{
  float v6;
  float v7;
  int v8;
  uint64_t result;

  cstdlib_memset(__b, 0, 0xE0uLL);
  *__b = *(_DWORD *)(a2 + 272) + *(_DWORD *)(a2 + 268);
  v6 = 1.0 / (float)(*(float *)(a2 + 8004) + *(float *)(a2 + 8008));
  *((float *)__b + 1) = v6;
  __b[3] = *(_DWORD *)(a2 + 8188);
  __b[2] = *(_DWORD *)(a2 + 268);
  __b[37] = *(_DWORD *)(a2 + 8008);
  __b[38] = *(_DWORD *)(a2 + 8004);
  v7 = *(float *)(a2 + 8000);
  *((float *)__b + 39) = v7;
  *((float *)__b + 1) = v6 * v7;
  mfs_F32Vect_Init(a1, (_QWORD *)__b + 12);
  mfs_F32Vect_Init(a1, (_QWORD *)__b + 15);
  mfs_S32Vect_Init(a1, (_QWORD *)__b + 20);
  v8 = __b[3];
  if (v8 < 0)
    return 2229280783;
  *((float *)__b + 46) = 1.0 / (float)v8;
  *((_BYTE *)__b + 216) = 0;
  if (v8)
  {
    if (*((float *)__b + 38) > 0.0)
      *((_BYTE *)__b + 216) = 1;
  }
  result = 0;
  *((_QWORD *)__b + 3) = 0;
  *((_QWORD *)__b + 4) = 0;
  return result;
}

uint64_t mfs_FillTgtVect(uint64_t a1, uint64_t a2, uint64_t a3, signed int a4)
{
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  int v17;
  float v18;
  float v19;
  float v20;
  float v21;
  uint64_t v22;
  float v23;
  uint64_t v24;

  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(_DWORD *)(v8 + 1528);
  v10 = *(_DWORD *)(v8 + 3056);
  *(_DWORD *)(a3 + 144) = a4;
  v11 = a3 + 96;
  mfs_F32Vect_Clear((_QWORD *)(a3 + 96));
  result = mfs_F32Vect_Create(v11, a4);
  if ((result & 0x80000000) != 0)
    return result;
  v13 = a3 + 120;
  mfs_F32Vect_Clear((_QWORD *)(a3 + 120));
  result = mfs_F32Vect_Create(a3 + 120, a4 + *(_DWORD *)a3 - 1);
  if ((result & 0x80000000) != 0)
    return result;
  v14 = v9;
  v15 = *(_QWORD *)(a3 + 104);
  *(_QWORD *)(a3 + 24) = *(_QWORD *)(*(_QWORD *)(v8 + 1592) + 8 * v9);
  *(_QWORD *)(a3 + 32) = v15;
  if (a4 < 1)
  {
LABEL_21:
    v24 = *(_QWORD *)(a2 + 24);
    *(_DWORD *)(v24 + 3056) = v10;
    *(_DWORD *)(v24 + 1528) = v9;
    return result;
  }
  v16 = 0;
  v17 = 0;
  v18 = -1.0;
  v19 = 1.0;
  while ((*(_BYTE *)(*(_QWORD *)(a2 + 48) + v14) & 4) == 0)
  {
    v20 = -1.0e10;
    v21 = 1.0;
    if ((v16 & 1) == 0)
      goto LABEL_9;
LABEL_13:
    result = mfs_F32Vect_Pad(v11, v20);
    if ((result & 0x80000000) != 0)
      return result;
    v23 = sqrtf(v21);
    if (v18 != v21)
      v19 = v23;
    result = mfs_F32Vect_Pad(v13, v19);
    if ((result & 0x80000000) != 0)
      return result;
    if (v18 != v21)
      v18 = v21;
    ++v14;
    ++v17;
    v16 = 1;
    if (v17 == a4)
    {
      v9 = v14;
      goto LABEL_21;
    }
  }
  v20 = **(float **)(*(_QWORD *)(v8 + 3120) + 8 * v10);
  v21 = **(float **)(*(_QWORD *)(v8 + 3160) + 8 * v10++);
  if ((v16 & 1) != 0)
    goto LABEL_13;
LABEL_9:
  if (*(int *)(a1 + 268) < 1)
    goto LABEL_13;
  v22 = 0;
  while (1)
  {
    result = mfs_F32Vect_Pad(v13, sqrtf(*(float *)(*(_QWORD *)(*(_QWORD *)(v8 + 1632) + 8 * v14) + 4 * v22)));
    if ((result & 0x80000000) != 0)
      return result;
    if (++v22 >= *(int *)(a1 + 268))
      goto LABEL_13;
  }
}

_QWORD *mfs_TCost_Clear(_QWORD *a1)
{
  mfs_F32Vect_Clear(a1 + 12);
  mfs_F32Vect_Clear(a1 + 15);
  return mfs_S32Vect_Clear(a1 + 20);
}

float mfs_TCost_CandidateCostStream_Faster(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  float *v5;
  float *v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t *v10;
  uint64_t *v11;
  float v12;
  float *v13;
  uint64_t v14;
  unsigned int v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  signed int *v21;
  float v22;
  float v23;
  signed int v24;
  int v25;
  float v26;
  BOOL v27;
  _BOOL4 v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  int v34;
  float v35;
  uint64_t v36;
  float v37;
  float v38;
  int v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  uint64_t v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  unint64_t v56;
  float v57;
  unsigned int v58;
  unint64_t v59;
  float *v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  int v69;
  float *v70;
  uint64_t v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float result;

  v5 = *(float **)(a1 + 32);
  v6 = *(float **)(a3 + 16);
  v7 = *(_DWORD *)(a1 + 144);
  v8 = *(_QWORD *)(a1 + 168);
  v9 = v7 - a4;
  if (v7 <= a4)
  {
    v10 = (uint64_t *)(a3 + 8);
    v11 = (uint64_t *)(a1 + 24);
    v12 = *(float *)(a2 + 4 * v7 + 24116) * (float)a4;
    v9 = a4 - v7;
    v13 = *(float **)(a1 + 32);
    v14 = *(_QWORD *)(a3 + 16);
    v15 = *(_DWORD *)(a1 + 144);
  }
  else
  {
    v10 = (uint64_t *)(a1 + 24);
    v11 = (uint64_t *)(a3 + 8);
    v12 = *(float *)(a2 + 4 * a4 + 24116) * (float)v7;
    v13 = *(float **)(a3 + 16);
    v14 = *(_QWORD *)(a1 + 32);
    v15 = a4;
  }
  v16 = *(float *)(a1 + 152);
  v17 = *(float *)(a1 + 184);
  v18 = *v10;
  v19 = *v11;
  if (v15)
  {
    v20 = v15;
    v21 = *(signed int **)(a1 + 168);
    v22 = 0.0;
    v23 = 0.0;
    do
    {
      v24 = vcvtms_s32_f32(v12 * v22);
      *v21 = v24;
      v25 = *(_DWORD *)(a2 + 8928);
      if (v25 != 6)
      {
        v26 = *(float *)(v14 + 4 * v24);
        v27 = v26 < 0.0;
        v28 = *v13 < 0.0 || v26 < 0.0;
        v29 = *v13 - v26;
        if (v27 && *v13 < 0.0)
          v30 = 0.0;
        else
          v30 = 4.7;
        if (v28)
          v29 = v30;
        v23 = v23 + (float)(*(float *)(*(_QWORD *)(a1 + 128) + 4 * *(unsigned int *)(a1 + 8)) * (float)(v29 * v29));
      }
      v22 = v22 + 1.0;
      ++v21;
      ++v13;
      --v20;
    }
    while (v20);
  }
  else
  {
    v25 = *(_DWORD *)(a2 + 8928);
    v23 = 0.0;
  }
  if (v25 == 6)
  {
    v31 = *v5;
    v32 = 0.01;
    if (*v5 < 0.0)
      v31 = 0.01;
    v33 = *v6;
    if (*v6 < 0.0)
      v33 = 0.01;
    v34 = v7 - 1;
    v35 = v5[v7 - 1];
    if (v35 < 0.0)
      v35 = 0.01;
    v36 = a4 - 1;
    v37 = v6[v36];
    if (v37 < 0.0)
      v37 = 0.01;
    if (v34 < 0)
      v34 = v7;
    v38 = v5[v34 >> 1];
    if (v38 < 0.0)
      v38 = 0.01;
    if ((int)v36 >= 0)
      v39 = a4 - 1;
    else
      v39 = a4;
    if (v6[v39 >> 1] >= 0.0)
      v32 = v6[v39 >> 1];
    if (v31 <= v33)
      v40 = v33;
    else
      v40 = v31;
    if (v35 <= v37)
      v41 = v37;
    else
      v41 = v35;
    if (v38 <= v32)
      v42 = v32;
    else
      v42 = v38;
    v43 = v31 - v33;
    if ((float)(v31 - v33) < 0.0)
      v43 = -(float)(v31 - v33);
    v44 = v43 / v40;
    v45 = v35 - v37;
    if ((float)(v35 - v37) < 0.0)
      v45 = -(float)(v35 - v37);
    v46 = v44 + (float)(v45 / v41);
    v47 = v38 - v32;
    if (v47 < 0.0)
      v47 = -v47;
    v48 = v46 + (float)(v47 / v42);
    v49 = (float)((float)(v31 - v35) / (float)v7) - (float)((float)(v33 - v37) / (float)a4);
    if (v49 < 0.0)
      v49 = -v49;
    v50 = (float)(*(float *)(a2 + 8932) * v49) + (float)((float)(1.0 - *(float *)(a2 + 8932)) * v48);
    v51 = *(float *)(a1 + 4) * *(float *)(a1 + 148);
  }
  else
  {
    v50 = sqrtf(v23) * *(float *)(a1 + 148);
    v51 = *(float *)(a1 + 4);
  }
  *(float *)(a5 + 8) = v51 * v50;
  *(_DWORD *)(a5 + 4) = 0;
  if (*(_BYTE *)(a1 + 216))
  {
    if (v15)
    {
      v52 = 0;
      v53 = 0;
      v54 = *(_DWORD *)(a1 + 8);
      v55 = *(unsigned int *)(a1 + 12);
      v56 = v55 & 0xFFFFFFFC;
      v57 = 0.0;
      do
      {
        v58 = *(_DWORD *)(v8 + 4 * v52) * v54;
        if ((_DWORD)v56)
        {
          v59 = 0;
          v60 = (float *)(*(_QWORD *)(a1 + 128) + 8);
          do
          {
            v61 = *(float *)(v19 + 4 * (v53 + v59)) - *(float *)(v18 + 4 * (v58 + v59));
            v62 = *(float *)(v19 + 4 * (v53 + v59 + 1))
                - *(float *)(v18 + 4 * (v58 + v59 + 1));
            v63 = *(float *)(v19 + 4 * (v53 + v59 + 2))
                - *(float *)(v18 + 4 * (v58 + v59 + 2));
            v64 = *(float *)(v19 + 4 * (v53 + v59 + 3))
                - *(float *)(v18 + 4 * (v58 + v59 + 3));
            v65 = (float)(v61 * v61) * *(v60 - 2);
            v66 = (float)(v62 * v62) * *(v60 - 1);
            v67 = *v60;
            v68 = v60[1];
            v60 += 4;
            v57 = v57
                + (float)((float)((float)(v65 + v66) + (float)((float)(v63 * v63) * v67))
                        + (float)((float)(v64 * v64) * v68));
            v59 += 4;
          }
          while (v59 < v56);
          v53 += v59;
          v58 += v59;
        }
        else
        {
          LODWORD(v59) = 0;
        }
        if (v59 < v55)
        {
          v69 = v55 + v53;
          v70 = (float *)(*(_QWORD *)(a1 + 128) + 4 * v59);
          v71 = v55 - v59;
          do
          {
            v72 = *(float *)(v19 + 4 * v53++);
            v73 = *(float *)(v18 + 4 * v58++);
            v74 = *v70++;
            v57 = v57 + (float)((float)((float)(v72 - v73) * (float)(v72 - v73)) * v74);
            --v71;
          }
          while (v71);
          v53 = v69 - v59;
        }
        v53 += v54 - v55;
        ++v52;
      }
      while (v52 != v15);
    }
    else
    {
      v57 = 0.0;
    }
    if (*(_DWORD *)(a2 + 8352) == 1)
      v76 = *(float *)(a1 + 152) * sqrtf(v57 * *(float *)(a1 + 184));
    else
      v76 = (float)(v16 * v17) * sqrtf(v57);
    v75 = v76 + 0.0;
    *(float *)(a5 + 4) = v76 + 0.0;
  }
  else
  {
    v75 = 0.0;
  }
  v77 = (float)v9;
  *(float *)(a5 + 4) = *(float *)(a1 + 4) * v75;
  v78 = *(float *)(a1 + 4) * *(float *)(a1 + 156);
  if (v25 == 6)
  {
    v79 = (float)(v77 * 0.03) / (float)a4;
  }
  else
  {
    v79 = v78 * v77;
    v78 = 0.01;
  }
  result = v79 * v78;
  *(float *)a5 = result;
  return result;
}

uint64_t mfs_TCost_CandidateCostStream_kld(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, unsigned int a9, uint64_t a10)
{
  float *v13;
  float *v14;
  int v15;
  int v16;
  float v17;
  float *v18;
  uint64_t v19;
  int v20;
  signed int *v21;
  uint64_t v22;
  float v23;
  float v24;
  signed int v25;
  int v26;
  float v27;
  BOOL v28;
  _BOOL4 v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  uint64_t v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  int v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  unsigned int v59;
  uint64_t result;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;

  v13 = *(float **)(a1 + 32);
  v14 = *(float **)(a5 + 16);
  v15 = *(_DWORD *)(a1 + 144);
  v16 = v15 - a6;
  if (v15 <= a6)
  {
    v17 = *(float *)(a3 + 4 * v15 + 24116) * (float)a6;
    v16 = a6 - v15;
    v18 = *(float **)(a1 + 32);
    v19 = *(_QWORD *)(a5 + 16);
    v20 = *(_DWORD *)(a1 + 144);
  }
  else
  {
    v17 = *(float *)(a3 + 4 * a6 + 24116) * (float)v15;
    v18 = *(float **)(a5 + 16);
    v19 = *(_QWORD *)(a1 + 32);
    v20 = a6;
  }
  if (v20 <= 0)
  {
    v26 = *(_DWORD *)(a3 + 8928);
    v24 = 0.0;
  }
  else
  {
    v21 = *(signed int **)(a1 + 168);
    v22 = v20;
    v23 = 0.0;
    v24 = 0.0;
    do
    {
      v25 = vcvtms_s32_f32(v17 * v23);
      *v21 = v25;
      v26 = *(_DWORD *)(a3 + 8928);
      if (v26 != 6)
      {
        v27 = *(float *)(v19 + 4 * v25);
        v28 = v27 < 0.0;
        v29 = *v18 < 0.0 || v27 < 0.0;
        v30 = *v18 - v27;
        if (v28 && *v18 < 0.0)
          v31 = 0.0;
        else
          v31 = 4.7;
        if (v29)
          v30 = v31;
        v24 = v24 + (float)(*(float *)(*(_QWORD *)(a1 + 128) + 4 * *(unsigned int *)(a1 + 8)) * (float)(v30 * v30));
      }
      v23 = v23 + 1.0;
      ++v18;
      ++v21;
      --v22;
    }
    while (v22);
  }
  if (v26 == 6)
  {
    v32 = 0.01;
    if (*v13 >= 0.0)
      v33 = *v13;
    else
      v33 = 0.01;
    v34 = *v14;
    if (*v14 < 0.0)
      v34 = 0.01;
    v35 = v13[v15 - 1];
    if (v35 < 0.0)
      v35 = 0.01;
    v36 = a6 - 1;
    v37 = v14[v36];
    if (v37 < 0.0)
      v37 = 0.01;
    if (*(_DWORD *)(a3 + 8280))
    {
      if (v33 <= v34)
        v38 = v34;
      else
        v38 = v33;
      if (v35 <= v37)
        v39 = v37;
      else
        v39 = v35;
      v40 = v33 - v34;
      if ((float)(v33 - v34) < 0.0)
        v40 = -(float)(v33 - v34);
      v41 = v40 / v38;
      v42 = v35 - v37;
      if ((float)(v35 - v37) < 0.0)
        v42 = -(float)(v35 - v37);
      v43 = v41 + (float)(v42 / v39);
      v44 = (float)((float)(v33 - v35) / (float)v15) - (float)((float)(v34 - v37) / (float)a6);
      if (v44 < 0.0)
        v44 = -v44;
      v45 = (float)(v44 * *(float *)(a3 + 8932)) + (float)((float)(1.0 - *(float *)(a3 + 8932)) * v43);
    }
    else
    {
      v47 = v13[(v15 - 1) / 2];
      if (v47 < 0.0)
        v47 = 0.01;
      if ((int)v36 >= 0)
        v48 = a6 - 1;
      else
        v48 = a6;
      if (v14[v48 >> 1] >= 0.0)
        v32 = v14[v48 >> 1];
      if (v33 <= v34)
        v49 = v34;
      else
        v49 = v33;
      if (v35 <= v37)
        v50 = v37;
      else
        v50 = v35;
      if (v47 <= v32)
        v51 = v32;
      else
        v51 = v47;
      v52 = v33 - v34;
      if ((float)(v33 - v34) < 0.0)
        v52 = -(float)(v33 - v34);
      v53 = v52 / v49;
      v54 = v35 - v37;
      if ((float)(v35 - v37) < 0.0)
        v54 = -(float)(v35 - v37);
      v55 = v53 + (float)(v54 / v50);
      v56 = v47 - v32;
      if (v56 < 0.0)
        v56 = -v56;
      v57 = v55 + (float)(v56 / v51);
      v58 = (float)((float)(v33 - v35) / (float)v15) - (float)((float)(v34 - v37) / (float)a6);
      if (v58 < 0.0)
        v58 = -v58;
      v45 = (float)(v58 * *(float *)(a3 + 8932)) + (float)((float)(1.0 - *(float *)(a3 + 8932)) * v57);
    }
    v46 = v45 * (float)(*(float *)(a1 + 4) * *(float *)(a1 + 148));
  }
  else
  {
    v46 = *(float *)(a1 + 4) * (float)(sqrtf(v24) * *(float *)(a1 + 148));
  }
  *(float *)(a10 + 8) = v46;
  *(_DWORD *)(a10 + 4) = 0;
  if (*(_BYTE *)(a1 + 216))
  {
    v59 = *(unsigned __int16 *)(*(_QWORD *)(a2 + 12248) + 2 * a7);
    v65 = 0.0;
    result = mfs_kld_lookup(a2, a4, v59, a8, a9, &v65, a7, a8);
    if ((result & 0x80000000) != 0)
      return result;
    v61 = *(float *)(a10 + 4) + (float)(v65 * *(float *)(a1 + 152));
    *(float *)(a10 + 4) = v61;
    v26 = *(_DWORD *)(a3 + 8928);
  }
  else
  {
    v61 = 0.0;
  }
  v62 = (float)v16;
  *(float *)(a10 + 4) = *(float *)(a1 + 4) * v61;
  v63 = *(float *)(a1 + 4) * *(float *)(a1 + 156);
  if (v26 == 6)
    v64 = (float)((float)(v62 * 0.03) / (float)a6) * v63;
  else
    v64 = (float)(v63 * v62) * 0.01;
  result = 0;
  *(float *)a10 = v64;
  return result;
}

float mfs_TCost_CandidateCostStream(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v5;
  BOOL v6;
  uint64_t *v7;
  uint64_t *v8;
  int v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  signed int v22;
  float v23;
  float v24;
  int v25;
  int v26;
  float v27;
  float v28;
  uint64_t i;
  int v30;
  unsigned int v31;
  float *v32;
  unsigned int v33;
  uint64_t v34;
  float v35;
  float v36;
  int v37;
  float result;

  LODWORD(v5) = *(_DWORD *)(a1 + 144);
  v6 = (int)v5 <= a4;
  v7 = (uint64_t *)(a3 + 8);
  v8 = (uint64_t *)(a1 + 32);
  if ((int)v5 > a4)
    v9 = *(_DWORD *)(a1 + 144);
  else
    v9 = a4;
  if ((int)v5 > a4)
    v5 = a4;
  else
    v5 = v5;
  if (v6)
    v10 = (uint64_t *)(a1 + 24);
  else
    v10 = (uint64_t *)(a3 + 8);
  if (v6)
    v11 = (uint64_t *)(a1 + 32);
  else
    v11 = (uint64_t *)(a3 + 16);
  if (v6)
    v8 = (uint64_t *)(a3 + 16);
  else
    v7 = (uint64_t *)(a1 + 24);
  v12 = *v7;
  v13 = *v10;
  v14 = 0.0;
  v15 = 0.0;
  if ((int)v5 >= 1)
  {
    v16 = 0;
    v17 = *(float *)(a2 + 4 * (int)v5 + 24116) * (float)v9;
    v18 = *v8;
    v19 = *v11;
    v20 = *(_QWORD *)(a1 + 168);
    v21 = *(_QWORD *)(a1 + 128);
    do
    {
      v22 = vcvtms_s32_f32(v17 * (float)(int)v16);
      *(_DWORD *)(v20 + 4 * v16) = v22;
      v23 = *(float *)(v19 + 4 * v16);
      v24 = *(float *)(v18 + 4 * v22);
      v25 = v24 < 0.0;
      v26 = v23 < 0.0;
      v27 = v23 - v24;
      if (v26 != v25)
        v27 = 4.7;
      if ((v25 & v26) != 0)
        v27 = 0.0;
      v15 = v15 + (float)(*(float *)(v21 + 4 * *(unsigned int *)(a1 + 8)) * (float)(v27 * v27));
      ++v16;
    }
    while (v5 != v16);
  }
  *(float *)(a5 + 8) = *(float *)(a1 + 4) * (float)(sqrtf(v15) * *(float *)(a1 + 148));
  *(_DWORD *)(a5 + 4) = 0;
  if (*(_BYTE *)(a1 + 216))
  {
    v28 = 0.0;
    if ((int)v5 >= 1)
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(int *)(a1 + 12) >= 1)
        {
          v30 = *(_DWORD *)(a1 + 8);
          v31 = v30 * *(_DWORD *)(*(_QWORD *)(a1 + 168) + 4 * i);
          v32 = *(float **)(a1 + 128);
          v33 = v30 * i;
          v34 = *(unsigned int *)(a1 + 12);
          do
          {
            v35 = *(float *)(v13 + 4 * v33) - *(float *)(v12 + 4 * v31);
            v36 = *v32++;
            v28 = v28 + (float)((float)(v35 * v35) * v36);
            ++v31;
            ++v33;
            --v34;
          }
          while (v34);
        }
      }
    }
    v14 = (float)((float)(sqrtf(v28) * *(float *)(a1 + 152)) * *(float *)(a1 + 184)) + 0.0;
    *(float *)(a5 + 4) = v14;
  }
  *(float *)(a5 + 4) = *(float *)(a1 + 4) * v14;
  v37 = *(_DWORD *)(a1 + 144) - a4;
  if (v37 < 0)
    v37 = a4 - *(_DWORD *)(a1 + 144);
  result = (float)((float)(*(float *)(a1 + 4) * *(float *)(a1 + 156)) * (float)v37) * 0.01;
  *(float *)a5 = result;
  return result;
}

float mfs_TCost_CandidateCost(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  float v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  signed int v19;
  float v20;
  float v21;
  int v22;
  int v23;
  float v24;
  float v25;
  float v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  float v31;
  unsigned int v32;
  uint64_t v33;
  float *v34;
  unsigned int v35;
  float v36;
  float v37;

  v4 = *(_DWORD *)(a1 + 144);
  if (v4 <= a4)
  {
    v5 = (uint64_t *)(a3 + 8);
    v6 = (uint64_t *)(a3 + 16);
    v7 = (uint64_t *)(a1 + 24);
    v8 = (uint64_t *)(a1 + 32);
    v9 = *(float *)(a2 + 4 * v4 + 24116);
    v10 = v9 * (float)a4;
    a4 = *(_DWORD *)(a1 + 144);
  }
  else
  {
    v5 = (uint64_t *)(a1 + 24);
    v6 = (uint64_t *)(a1 + 32);
    v7 = (uint64_t *)(a3 + 8);
    v8 = (uint64_t *)(a3 + 16);
    v9 = *(float *)(a2 + 4 * a4 + 24116);
    v10 = v9 * (float)v4;
  }
  v11 = *v5;
  v12 = *v7;
  if (a4 < 1)
  {
    v18 = 0.0;
  }
  else
  {
    v13 = 0;
    v14 = *v6;
    v15 = *v8;
    v16 = *(_QWORD *)(a1 + 168);
    v17 = *(_QWORD *)(a1 + 128);
    v18 = 0.0;
    do
    {
      v19 = vcvtms_s32_f32(v10 * (float)(int)v13);
      *(_DWORD *)(v16 + 4 * v13) = v19;
      v20 = *(float *)(v15 + 4 * v13);
      v21 = *(float *)(v14 + 4 * v19);
      v22 = v21 < 0.0;
      v23 = v20 < 0.0;
      v24 = v20 - v21;
      if (v23 != v22)
        v24 = 4.7;
      if ((v22 & v23) != 0)
        v24 = 0.0;
      v18 = v18 + (float)(*(float *)(v17 + 4 * *(unsigned int *)(a1 + 8)) * (float)(v24 * v24));
      ++v13;
    }
    while (a4 != v13);
  }
  v25 = sqrtf(v18) * *(float *)(a1 + 148);
  if (*(int *)(a1 + 12) >= 1)
  {
    v26 = *(float *)(a1 + 152);
    if (v26 > 0.0)
    {
      if (a4 < 1)
      {
        v31 = 0.0;
      }
      else
      {
        v27 = 0;
        v28 = 0;
        v29 = a4;
        v30 = *(_DWORD *)(a1 + 8);
        v31 = 0.0;
        do
        {
          v32 = v30 * *(_DWORD *)(*(_QWORD *)(a1 + 168) + 4 * v28);
          v33 = *(unsigned int *)(a1 + 12);
          v34 = *(float **)(a1 + 128);
          v35 = v27;
          do
          {
            v36 = *(float *)(v12 + 4 * v35) - *(float *)(v11 + 4 * v32);
            v37 = *v34++;
            v31 = v31 + (float)((float)(v36 * v36) * v37);
            ++v32;
            ++v35;
            --v33;
          }
          while (v33);
          ++v28;
          v27 += v30;
        }
        while (v28 != v29);
      }
      v25 = v25 + (float)(v26 * (float)(sqrtf(v31) * *(float *)(a1 + 184)));
    }
  }
  return v9 * (float)(v10 * (float)(v25 * *(float *)(a1 + 4)));
}

uint64_t mfs_TCost_SetTarget(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, int a5)
{
  uint64_t v8;

  v8 = mfs_FillTgtVect(*(_QWORD *)(a2 + 1072), a3, a1, *(_DWORD *)(a4[2] + 4 * a5));
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(*(_QWORD *)(a4[21] + 8 * a5) + 4);
  *(float *)(a1 + 204) = MFS__bet3_finv(sqrtf(*(float *)(*(_QWORD *)(a4[31] + 8 * a5) + 4)));
  *(_DWORD *)(a1 + 196) = *(_DWORD *)(*(_QWORD *)(a4[21] + 8 * a5) + 8);
  *(float *)(a1 + 208) = MFS__bet3_finv(sqrtf(*(float *)(*(_QWORD *)(a4[31] + 8 * a5) + 8)));
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(*(_QWORD *)(a4[21] + 8 * a5) + 12);
  *(float *)(a1 + 212) = MFS__bet3_finv(sqrtf(*(float *)(*(_QWORD *)(a4[31] + 8 * a5) + 12)));
  *(_DWORD *)(a1 + 188) = (*(unsigned __int8 *)(a4[39] + a5) >> 2) & 1;
  return v8;
}

uint64_t mfs_TCost_PrepareForComputation(uint64_t a1, signed int a2)
{
  if (*(_DWORD *)(a1 + 144) > a2)
    a2 = *(_DWORD *)(a1 + 144);
  *(_DWORD *)(a1 + 176) = a2;
  return mfs_S32Vect_Reserve(a1 + 160, a2);
}

uint64_t mfs_TCost_Copy(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t result;
  uint64_t v16;

  v4 = a1 + 96;
  mfs_F32Vect_Clear((_QWORD *)(a1 + 96));
  mfs_F32Vect_Clear((_QWORD *)(a1 + 120));
  mfs_S32Vect_Clear((_QWORD *)(a1 + 160));
  v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v5;
  v6 = *(_OWORD *)(a2 + 32);
  v7 = *(_OWORD *)(a2 + 48);
  v8 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v8;
  *(_OWORD *)(a1 + 32) = v6;
  *(_OWORD *)(a1 + 48) = v7;
  v9 = *(_OWORD *)(a2 + 96);
  v10 = *(_OWORD *)(a2 + 112);
  v11 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v10;
  v12 = *(_OWORD *)(a2 + 160);
  v13 = *(_OWORD *)(a2 + 176);
  v14 = *(_OWORD *)(a2 + 208);
  *(_OWORD *)(a1 + 192) = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  mfs_F32Vect_Copy(v4, (uint64_t *)(a2 + 96));
  mfs_F32Vect_Copy(a1 + 120, (uint64_t *)(a2 + 120));
  result = mfs_S32Vect_Copy(a1 + 160, (uint64_t *)(a2 + 160));
  v16 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = v16;
  return result;
}

uint64_t mfs_StateNGram_Load(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result;
  int *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int v10;
  int v11;

  result = 2229280772;
  v5 = *(int **)(a3 + 8);
  if (v5)
  {
    v6 = (int *)((char *)v5 + *(unsigned int *)(a3 + 16));
    if (a2 < 1)
    {
LABEL_7:
      if (v5 == v6)
        return 0;
      else
        return 2229280772;
    }
    else
    {
      v7 = 0;
      v8 = a1 + 48;
      while (v5 < v6)
      {
        v11 = *v5;
        v9 = v5 + 1;
        v10 = v11;
        *(_DWORD *)(v8 + 4 * v7 - 40) = v11;
        if (v9 >= v6)
          break;
        *(_QWORD *)(v8 + 8 * v7) = v9;
        v5 = &v9[v10 * v10];
        if ((a2 + 2) - 2 == ++v7)
          goto LABEL_7;
      }
    }
  }
  return result;
}

void *mfs_StateNGram_DeInit(void *a1)
{
  return cstdlib_memset(a1, 0, 0x60uLL);
}

uint64_t mfs_StateNGram_GetAlternatives(uint64_t a1, int a2, int a3, int a4, _QWORD *a5)
{
  int v5;
  uint64_t result;
  uint64_t v13;
  int v14;
  float v15;
  int v16;
  float v17;

  v5 = *(_DWORD *)(a1 + 4 * a4);
  if (v5 <= a3 || v5 == 0 || v5 <= a2)
    return 2229280775;
  v13 = a4;
  mfs_S32Vect_Clear(a5);
  v14 = *(_DWORD *)(a1 + 4 * v13);
  if (a3 < 0)
    v15 = 0.0;
  else
    v15 = *(float *)(*(_QWORD *)(a1 + 8 * v13 + 32) + 4 * (a2 + v14 * a3));
  if (v14 < 1)
    return 0;
  v16 = 0;
  result = 0;
  do
  {
    v17 = *(float *)(*(_QWORD *)(a1 + 8 * v13 + 32) + 4 * (a2 + v14 * v16));
    if (v17 > v15)
    {
      result = mfs_S32Vect_Add((uint64_t)a5, v16);
      if ((result & 0x80000000) != 0)
        return result;
      v14 = *(_DWORD *)(a1 + 4 * v13);
      v15 = v17;
    }
    ++v16;
  }
  while (v16 < v14);
  return result;
}

uint64_t read1ByteIntoU32(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = v2 + 1;
  return *(unsigned __int8 *)(a1 + v2);
}

uint64_t read2BytesIntoU32(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *a2;
  result = *(unsigned __int16 *)(a1 + v2);
  *a2 = v2 + 2;
  return result;
}

uint64_t read3BytesIntoU32(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *a2;
  result = *(unsigned __int16 *)(a1 + v2) | (*(unsigned __int8 *)(a1 + v2 + 2) << 16);
  *a2 = v2 + 3;
  return result;
}

uint64_t read4BytesIntoU32(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  int v3;
  uint64_t result;

  v2 = *a2;
  v3 = 8 * (*a2 & 3);
  if (v3)
    result = ((2 * *(_DWORD *)(a1 + (v2 & 0xFFFFFFFC) + 4)) << (v3 ^ 0x1F)) | (*(_DWORD *)(a1 + (v2 & 0xFFFFFFFC)) >> v3);
  else
    result = *(unsigned int *)(a1 + v2);
  *a2 = v2 + 4;
  return result;
}

uint64_t (*selectReadBytesIntoU32Proc(int a1))()
{
  return off_24D29C520[a1 - 1];
}

uint64_t readBytesIntoU32(uint64_t a1, _DWORD *a2, int a3)
{
  uint64_t result;
  uint64_t v5;
  unsigned __int8 *v6;

  result = 0;
  v5 = *a2;
  v6 = (unsigned __int8 *)(a1 + v5);
  switch(a3)
  {
    case 1:
      goto LABEL_5;
    case 2:
      goto LABEL_4;
    case 3:
      goto LABEL_3;
    case 4:
      LODWORD(result) = v6[3] << 24;
LABEL_3:
      LODWORD(result) = result | (v6[2] << 16);
LABEL_4:
      LODWORD(result) = result | (v6[1] << 8);
LABEL_5:
      result = result | *v6;
      *a2 = v5 + a3;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mfs_isUnitExcluded_Obersee(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  int v4;
  BOOL v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;

  result = *(_QWORD *)(a1 + 2384);
  if (result)
  {
    if (*(_DWORD *)(a1 + 2376))
      return mfs_isUnitRemoved(result, a2);
    v4 = *(_DWORD *)(a1 + 2392);
    v5 = __OFSUB__(v4, 1);
    v6 = v4 - 1;
    if (v6 < 0 == v5)
    {
      v7 = 0;
      do
      {
        v8 = (v7 + v6) / 2;
        v9 = *(_DWORD *)(result + 4 * v8);
        if (v9 >= a2)
        {
          if (v9 <= a2)
            return 1;
          v6 = v8 - 1;
        }
        else
        {
          v7 = v8 + 1;
        }
      }
      while (v7 <= v6);
    }
    return 0;
  }
  return result;
}

uint64_t mfs_getUnitDataRecordSize_Obersee()
{
  unsigned int v1;
  _BYTE v2[32];
  _OWORD v3[12];
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v4 = 0;
  memset(v3, 0, sizeof(v3));
  v1 = 0;
  readUnitDataAndAdvanceOffset((uint64_t)v3, (uint64_t)v2, &v1);
  return v1;
}

uint64_t readUnitDataAndAdvanceOffset(uint64_t result, uint64_t a2, _DWORD *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  __int16 v14;
  __int16 v15;
  __int16 v16;

  v3 = *a3;
  v4 = *(unsigned __int16 *)(result + v3) | (*(unsigned __int8 *)(result + v3 + 2) << 16);
  *a3 = v3 + 3;
  if (v4 == 0xFFFFFF)
    v4 = -1;
  *(_DWORD *)a2 = v4;
  v5 = *a3;
  v6 = *(unsigned __int16 *)(result + v5) | (*(unsigned __int8 *)(result + v5 + 2) << 16);
  *a3 = v5 + 3;
  if (v6 == 0xFFFFFF)
    v7 = -1;
  else
    v7 = v6;
  *(_DWORD *)(a2 + 4) = v7;
  v8 = *a3;
  v9 = *(unsigned __int16 *)(result + v8) | (*(unsigned __int8 *)(result + v8 + 2) << 16);
  *a3 = v8 + 3;
  *(_DWORD *)(a2 + 8) = v9;
  v10 = *a3;
  *(_WORD *)(a2 + 22) = *(_WORD *)(result + v10);
  *a3 = v10 + 3;
  *(_BYTE *)(a2 + 27) = *(_BYTE *)(result + (v10 + 2));
  v11 = *(unsigned __int16 *)(result + (v10 + 3));
  *a3 = v10 + 5;
  v12 = v11 << 8;
  if (v11 <= 0xFF)
    v12 = v11;
  *(_DWORD *)(a2 + 12) = v12;
  v13 = *a3;
  v14 = *(_WORD *)(result + v13);
  *a3 = v13 + 2;
  *(_WORD *)(a2 + 16) = v14;
  v15 = *(_WORD *)(result + (v13 + 2));
  *a3 = v13 + 4;
  *(_WORD *)(a2 + 18) = v15;
  v16 = *(_WORD *)(result + (v13 + 4));
  *a3 = v13 + 6;
  *(_WORD *)(a2 + 20) = v16;
  *(_BYTE *)(a2 + 28) = 0;
  return result;
}

uint64_t mfs_getUnitData_Obersee(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  _DWORD *v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;
  char v21;
  __int16 v22;
  int v23;
  char v24;
  unsigned int v25;

  if (a3 == -1 || *(_DWORD *)(a1 + 1096) - 1 == a3)
  {
    result = 0;
    *(_QWORD *)a4 = -1;
    *(_DWORD *)(a4 + 8) = -1;
    *(_BYTE *)(a4 + 28) = 0;
    *(_QWORD *)(a4 + 12) = 0;
    *(_DWORD *)(a4 + 20) = -65536;
    *(_DWORD *)(a4 + 24) = 65793;
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 1072);
    if (*(_DWORD *)(v7 + 8332) == 1)
    {
      v8 = *(_QWORD *)(a1 + 1896);
      v9 = *(unsigned __int8 **)(a1 + 1872);
      v10 = *(_DWORD **)(a1 + 1880);
      v11 = *(_DWORD *)(a1 + 1888) * a3;
      v25 = v11 >> 3;
      v24 = v11 & 7;
      v12 = readU32AndAdvanceOffsets(v8, *v9, &v24, &v25);
      *(_DWORD *)a4 = v12;
      v13 = readU32AndAdvanceOffsets(v8, v9[1], &v24, &v25);
      *(_DWORD *)(a4 + 4) = v13;
      v14 = readU32AndAdvanceOffsets(v8, v9[2], &v24, &v25);
      *(_DWORD *)(a4 + 8) = v14;
      *(_WORD *)(a4 + 22) = readU32AndAdvanceOffsets(v8, v9[3], &v24, &v25);
      *(_BYTE *)(a4 + 27) = readU32AndAdvanceOffsets(v8, v9[4], &v24, &v25);
      v15 = readU32AndAdvanceOffsets(v8, v9[5], &v24, &v25);
      *(_DWORD *)(a4 + 12) = v15;
      *(_WORD *)(a4 + 16) = readU32AndAdvanceOffsets(v8, v9[6], &v24, &v25);
      *(_WORD *)(a4 + 18) = readU32AndAdvanceOffsets(v8, v9[7], &v24, &v25);
      *(_WORD *)(a4 + 20) = readU32AndAdvanceOffsets(v8, v9[8], &v24, &v25);
      *(_BYTE *)(a4 + 28) = 0;
      if (v12 == *v10)
        *(_DWORD *)a4 = -1;
      if (v13 == v10[1])
        *(_DWORD *)(a4 + 4) = -1;
      if (v15 == v10[5])
        *(_DWORD *)(a4 + 12) = v15 << 8;
    }
    else
    {
      v20 = *(_QWORD *)(v7 + 21704);
      v23 = *(_DWORD *)(a1 + 1100) * a3;
      readUnitDataAndAdvanceOffset(v20, a4, &v23);
      v14 = *(_DWORD *)(a4 + 8);
    }
    result = mfs_symData_recoverCompactNFeatVect_Obersee(a1, a2, v14, 3, (uint64_t)&v21, v16, v17, v18);
    if ((result & 0x80000000) == 0)
    {
      result = 0;
      *(_BYTE *)(a4 + 24) = v21;
      *(_WORD *)(a4 + 25) = v22;
    }
  }
  return result;
}

uint64_t mfs_getBeginEndPitch_Obersee(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  uint64_t v4;
  unsigned int v5;
  float v6;
  unsigned int v7;
  float v8;

  v4 = *(_QWORD *)(a1 + 1072);
  if (a3)
  {
    v5 = *(unsigned __int16 *)(a2 + 18);
    if (v5 == 256)
      v6 = -1.0e10;
    else
      v6 = (float)((float)v5 / *(float *)(v4 + 8752)) + *(float *)(v4 + 8672);
    *a3 = v6;
  }
  if (a4)
  {
    v7 = *(_DWORD *)(a2 + 12);
    if (v7 == 0x10000)
      v8 = -1.0e10;
    else
      v8 = (float)((float)v7 / *(float *)(v4 + 8752)) + *(float *)(v4 + 8672);
    *a4 = v8;
  }
  return 0;
}

uint64_t mfs_AllUnitCompData_Init_Obersee(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;

  v2 = 0;
  v3 = 0;
  v4 = a1[2833];
  *(_QWORD *)(a2 + 1872) = v4;
  *(_QWORD *)(a2 + 1880) = a1[2863];
  *(_DWORD *)(a2 + 1888) = 0;
  do
  {
    v3 += *(unsigned __int8 *)(v4 + v2);
    *(_DWORD *)(a2 + 1888) = v3;
    ++v2;
  }
  while (v2 != 9);
  *(_QWORD *)(a2 + 1896) = a1[2713];
  return 1;
}

double mfs_AllUnitCompData_DeInit_Obersee(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 1896) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 1872) = 0u;
  return result;
}

uint64_t readU32AndAdvanceOffsets(uint64_t a1, int a2, _BYTE *a3, _DWORD *a4)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t result;
  int v8;
  char v9;
  unsigned int v10;

  v4 = *a4;
  v5 = *a3;
  v6 = v5 + a2;
  switch((int)(v6 - 1 + (((v6 - 1) & 0xE000) >> 13)) >> 3)
  {
    case 0:
      result = ((0xFFu >> v5) & *(unsigned __int8 *)(a1 + v4)) >> (8 - v6);
      break;
    case 1:
      v8 = *(unsigned __int8 *)(a1 + v4 + 1) | (*(unsigned __int8 *)(a1 + v4) << 8);
      v9 = 16 - a2 - v5;
      v10 = 0xFFFF;
      goto LABEL_7;
    case 2:
      v8 = (*(unsigned __int8 *)(a1 + v4) << 16) | (*(unsigned __int8 *)(a1 + v4 + 1) << 8) | *(unsigned __int8 *)(a1 + v4 + 2);
      v9 = 24 - a2 - v5;
      v10 = 0xFFFFFF;
      goto LABEL_7;
    case 3:
      v8 = bswap32(*(_DWORD *)(a1 + v4));
      v9 = 32 - a2 - v5;
      v10 = -1;
LABEL_7:
      result = (v8 & (v10 >> v5)) >> v9;
      break;
    default:
      result = 0;
      break;
  }
  *a4 = v4 + (v6 >> 3);
  *a3 = v6 & 7;
  return result;
}

uint64_t mfs_StatisticalSelection(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int **v21;
  _DWORD *v22;
  float *v23;
  int v24;
  int v25;
  int *v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t NodeCandidates;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t inited;
  unsigned int v44;
  int v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int8x8_t v52;
  float32x2_t v53;
  float32x2_t v54;
  float32x2_t v55;
  float32x2_t v56;
  int8x8_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  char v61;
  unint64_t v62;
  float v63;
  float v64;
  float v65;
  uint64_t v66;
  _DWORD *v67;
  uint64_t v68;
  _DWORD *v69;
  uint64_t NodeCandidates_StatSelect;
  const char *v71;
  int v72;
  _DWORD *v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  _DWORD *v79;
  int8x8_t v80;

  v6 = *(_QWORD *)(a1 + 1928);
  v7 = *(unsigned int *)(a1 + 620);
  MFS__log_select_Diag(v6, 1, (uint64_t)"HybridStatisticalSelection {\n");
  MFS__log_select_Diag(v6, 1, (uint64_t)"eBet4EmissionType is set to %d\n");
  if (*(_DWORD *)(a1 + 2592) != 1)
  {
    inited = mfs_InitHashTable(v6, a2, a3, a1);
    if ((inited & 0x80000000) != 0)
      return inited;
    *(_DWORD *)(a1 + 1936) = v7;
    inited = mfs_CostList_Init(v6, (_QWORD *)(a1 + 1944), v7, 0);
    if ((inited & 0x80000000) != 0)
      return inited;
    v44 = *(_DWORD *)(a3 + 8968);
    if (v44 <= 6 && ((1 << v44) & 0x64) != 0 && *a2 == 3)
    {
      inited = mfs_CostList_Init(v6, (_QWORD *)(a1 + 1968), 8u, 0);
      if ((inited & 0x80000000) != 0)
        return inited;
    }
    else
    {
      *(_QWORD *)(a1 + 1976) = 0;
      *(_DWORD *)(a1 + 1984) = 0;
    }
    v46 = *(_DWORD *)(a1 + 2064);
    if (v46 != 2)
    {
      if (v46 == 1)
      {
        cstdlib_memset(*(void **)(a1 + 2048), 0, 8 * *(unsigned int *)(a1 + 2056));
        v47 = (_QWORD *)(a1 + 2040);
      }
      else
      {
        cstdlib_memset(*(void **)(a1 + 2032), 0, 8 * *(unsigned int *)(a1 + 2056));
        v47 = (_QWORD *)(a1 + 2024);
      }
      *v47 = 0;
    }
    NodeCandidates = 2229280778;
    if ((*(_DWORD *)(a3 + 8968) | 4) == 6)
    {
      v48 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 1928) + 8), 2 * (int)v7, 4);
      *(_QWORD *)(a1 + 2088) = v48;
      if (!v48)
        return NodeCandidates;
      v79 = (_DWORD *)(a3 + 8968);
      *(_QWORD *)(a1 + 2096) = v48 + 4 * (int)v7;
      if (*(int *)(a1 + 608) >= 1)
      {
        v49 = 0;
        LODWORD(v50) = 0;
        do
        {
          v51 = *(_QWORD *)(a1 + 600);
          v52.i32[0] = *(_DWORD *)(a3 + 8172);
          v52.i32[1] = *(_DWORD *)(a3 + 8248);
          v80 = v52;
          switch(mfs_Ling_WrdPosInPhrs(*(_QWORD *)(a1 + 8), v49))
          {
            case 1u:
              v53 = *(float32x2_t *)(a3 + 8416);
              goto LABEL_68;
            case 2u:
              v53 = *(float32x2_t *)(a3 + 8432);
              goto LABEL_68;
            case 3u:
              v53 = *(float32x2_t *)(a3 + 8424);
              goto LABEL_68;
            case 4u:
              v53 = *(float32x2_t *)(a3 + 8408);
              goto LABEL_68;
            case 5u:
              v53 = *(float32x2_t *)(a3 + 8400);
LABEL_68:
              v80 = vbsl_s8((int8x8_t)vceqz_f32(v53), v80, (int8x8_t)v53);
              break;
            default:
              break;
          }
          switch(mfs_Ling_WrdPosShpInPhrs(*(_QWORD *)(a1 + 8), v49))
          {
            case 0u:
              v54 = *(float32x2_t *)(a3 + 8440);
              goto LABEL_76;
            case 1u:
              v54 = *(float32x2_t *)(a3 + 8456);
              goto LABEL_76;
            case 2u:
              v54 = *(float32x2_t *)(a3 + 8448);
              goto LABEL_76;
            case 3u:
              v54 = *(float32x2_t *)(a3 + 8464);
              goto LABEL_76;
            case 4u:
              v54 = *(float32x2_t *)(a3 + 8480);
              goto LABEL_76;
            case 5u:
              v54 = *(float32x2_t *)(a3 + 8472);
LABEL_76:
              v80 = vbsl_s8((int8x8_t)vceqz_f32(v54), v80, (int8x8_t)v54);
              break;
            default:
              break;
          }
          switch(mfs_Ling_WrdProminence(*(_QWORD *)(a1 + 8), v49))
          {
            case 0u:
              v55 = *(float32x2_t *)(a3 + 8488);
              goto LABEL_82;
            case 1u:
              v55 = *(float32x2_t *)(a3 + 8496);
              goto LABEL_82;
            case 2u:
              v55 = *(float32x2_t *)(a3 + 8504);
              goto LABEL_82;
            case 3u:
              v55 = *(float32x2_t *)(a3 + 8512);
LABEL_82:
              v80 = vbsl_s8((int8x8_t)vceqz_f32(v55), v80, (int8x8_t)v55);
              break;
            default:
              break;
          }
          switch(mfs_Ling_WrdShpProminence(*(_QWORD *)(a1 + 8), v49))
          {
            case 0u:
              v56 = *(float32x2_t *)(a3 + 8520);
              goto LABEL_90;
            case 1u:
              v56 = *(float32x2_t *)(a3 + 8528);
              goto LABEL_90;
            case 2u:
              v56 = *(float32x2_t *)(a3 + 8536);
              goto LABEL_90;
            case 3u:
              v56 = *(float32x2_t *)(a3 + 8544);
              goto LABEL_90;
            case 4u:
              v56 = *(float32x2_t *)(a3 + 8552);
LABEL_90:
              v57 = vbsl_s8((int8x8_t)vceqz_f32(v56), v80, (int8x8_t)v56);
              break;
            default:
              v57 = v80;
              break;
          }
          v58 = *a2;
          if ((int)v58 >= 1)
          {
            v50 = (int)v50;
            v59 = *(_QWORD *)(a1 + 2096);
            v60 = (char *)(*(_QWORD *)(v51 + 528 * v49 + 312) + 2);
            do
            {
              v61 = *v60++;
              v62 = (unint64_t)v57;
              if ((v61 & 4) == 0)
              {
                v63 = *(float *)(a3 + 8252);
                if (v63 == 0.0)
                  v63 = 1.0;
                v64 = *(float *)(a3 + 8176);
                v62 = __PAIR64__(*(float *)&v57.i32[1] * v63, v57.u32[0]);
                if (v64 != 0.0)
                  *(float *)&v62 = *(float *)v57.i32 * v64;
              }
              if (*(float *)&v62 >= 0.0)
                v65 = *(float *)&v62;
              else
                v65 = 0.0;
              if (v65 > 1.0)
                v65 = 1.0;
              LODWORD(v62) = HIDWORD(v62);
              if (*((float *)&v62 + 1) < 0.0)
                *(float *)&v62 = 0.0;
              if (*(float *)&v62 > 5.0)
                *(float *)&v62 = 5.0;
              if (v50 < 1)
              {
                *(_DWORD *)(v59 + 4 * v50) = v62;
                *(float *)(*(_QWORD *)(a1 + 2088) + 4 * v50) = v65;
              }
              else
              {
                v66 = 4 * v50;
                *(float *)(v59 + v66) = (float)(*(float *)(v59 + 4 * (v50 - 1)) * 0.6)
                                      + (float)(*(float *)&v62 * 0.4);
                *(float *)(*(_QWORD *)(a1 + 2088) + v66) = (float)(*(float *)(*(_QWORD *)(a1 + 2088)
                                                                            + 4 * (v50 - 1))
                                                                 * 0.6)
                                                         + (float)(v65 * 0.4);
              }
              ++v50;
              --v58;
            }
            while (v58);
          }
          ++v49;
        }
        while (v49 < *(int *)(a1 + 608));
      }
    }
    else
    {
      v67 = (_DWORD *)heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 1928) + 8), 2 * (int)v7, 4);
      *(_QWORD *)(a1 + 2088) = v67;
      if (!v67)
        return NodeCandidates;
      v79 = (_DWORD *)(a3 + 8968);
      *(_QWORD *)(a1 + 2096) = &v67[(int)v7];
      if ((int)v7 >= 1)
      {
        v68 = v7;
        do
        {
          v67[(int)v7] = *(_DWORD *)(a3 + 8248);
          *v67++ = *(_DWORD *)(a3 + 8172);
          --v68;
        }
        while (v68);
      }
    }
    v69 = v79;
    switch(*v79)
    {
      case 1:
        MFS__log_select_Diag(v6, 2, (uint64_t)"Search mode: MFS_SEARCHMODE_DRAGON\n");
        NodeCandidates_StatSelect = mfs_Search_FindNodeCandidates_StatSelect(a2, a1, a3);
        goto LABEL_125;
      case 2:
        v71 = "Search mode: MFS_SEARCHMODE_FAST\n";
        goto LABEL_124;
      case 5:
        MFS__log_select_Diag(v6, 2, (uint64_t)"Search mode: MFS_SEARCHMODE_DRAGON_TAHOE\n");
        NodeCandidates_StatSelect = mfs_Search_FindNodeCandidates_StatSelect_Tahoe(a2, a1, a3);
        goto LABEL_125;
      case 6:
        v71 = "Search mode: MFS_SEARCHMODE_FAST_TAHOE\n";
LABEL_124:
        MFS__log_select_Diag(v6, 2, (uint64_t)v71);
        NodeCandidates_StatSelect = mfs_Search_FindNodeCandidates_StatSelect_UltraLight((int *)a2, a1, a3);
LABEL_125:
        NodeCandidates = NodeCandidates_StatSelect;
        v72 = 0;
        goto LABEL_126;
      case 7:
      case 8:
        MFS__log_select_Diag(v6, 2, (uint64_t)"Search mode not supported\n");
        return 2229280769;
      default:
        MFS__log_select_Diag(v6, 2, (uint64_t)"Search mode: MFS_DEFAULT\n");
        NodeCandidates = mfs_Search_FindNodeCandidates(a2, a1, a3);
        v72 = 1;
LABEL_126:
        if ((NodeCandidates & 0x80000000) != 0)
          return NodeCandidates;
        v73 = (_DWORD *)heap_Calloc(*(_QWORD **)(v6 + 8), v7, 4);
        *(_QWORD *)(a1 + 2016) = v73;
        NodeCandidates = 2229280778;
        if (!v73)
          return NodeCandidates;
        if ((_DWORD)v7)
        {
          v74 = v7;
          do
          {
            *v73++ = *(_DWORD *)(a3 + 8240);
            --v74;
          }
          while (v74);
        }
        if (*(_DWORD *)(a3 + 8876))
        {
          v75 = (*v79 - 7) > 4
              ? ConnectedContextLength_TahoeVersion(a3, (unsigned __int8 *)a2, a1)
              : ConnectedContextLength(a3, (unsigned __int8 *)a2, a1);
          NodeCandidates = v75;
          if ((v75 & 0x80000000) != 0)
            return NodeCandidates;
        }
        v76 = *v79 - 2;
        if (v76 < 0xA && ((0x3F1u >> v76) & 1) != 0)
        {
          v69 = (_DWORD *)((char *)&unk_214FC0864 + 4 * (int)v76);
        }
        else
        {
          inited = PruneDPListOnContext(a3, (unsigned __int8 *)a2, a1, v72);
          if ((inited & 0x80000000) != 0)
            return inited;
        }
        if (*v69 == 8)
          v77 = TransWeights_InitCopy_Default(a3, (int *)a2, a1, v7);
        else
          v77 = TransWeights_InitCopy_0(a3, (int *)a2, a1, v7);
        NodeCandidates = v77;
        if ((v77 & 0x80000000) != 0)
          return NodeCandidates;
        inited = Detect_Sparse_Grid(a3, a1);
        if ((inited & 0x80000000) != 0)
          return inited;
        v78 = *(_QWORD *)(a1 + 2000);
        if (!*(_DWORD *)v78 && *(_DWORD *)(v78 + 4) == 6)
          *(_QWORD *)v78 = 0x300000003;
        break;
    }
  }
  v8 = (int *)(a3 + 25140);
  v9 = *(uint64_t **)(a1 + 2640);
  if (v9)
  {
    v10 = *(unsigned int *)(a1 + 1960);
    if ((_DWORD)v10)
    {
      v11 = 0;
      v12 = *((_DWORD *)v9 + 5);
      v13 = *v9;
      do
      {
        v14 = v12 + v11;
        v15 = *(_DWORD *)(v13 + 48 * (v12 + v11));
        if (v15)
        {
          if (v15 == 1)
          {
            v16 = *(_QWORD *)(a1 + 1952) + 32 * v11;
            v17 = *(unsigned int *)(v16 + 16);
            if ((_DWORD)v17)
            {
              v18 = 0;
              v19 = v13 + 48 * v14;
              v20 = *(unsigned int *)(v19 + 24);
              v21 = (int **)(v19 + 8);
              do
              {
                if ((_DWORD)v20)
                {
                  v22 = (_DWORD *)(*(_QWORD *)v16 + 8 * v18);
                  v25 = *v22;
                  v23 = (float *)(v22 + 1);
                  v24 = v25;
                  v26 = *v21;
                  v27 = v20;
                  do
                  {
                    v28 = *v26++;
                    if (v24 == v28)
                      *v23 = *v23 + 5000.0;
                    --v27;
                  }
                  while (v27);
                }
                ++v18;
              }
              while (v18 != v17);
            }
          }
        }
        else
        {
          v29 = *(_DWORD *)(*(_QWORD *)(v13 + 48 * v14 + 8)
                          + 4 * (*(_DWORD *)(v13 + 48 * v14 + 24) - 1));
          if (v29 < a2[274] - 1)
          {
            v30 = *(_QWORD *)(a1 + 1952) + 32 * v11;
            v31 = *(unsigned int *)(v30 + 16);
            if ((_DWORD)v31)
            {
              v32 = 0;
              v33 = *(int **)v30;
              while (1)
              {
                v34 = *v33;
                v33 += 2;
                if (v34 == v29)
                  break;
                if (v31 == ++v32)
                  goto LABEL_25;
              }
              v32 = v32;
            }
            else
            {
              v32 = 0;
            }
            if (v32 != v31)
              goto LABEL_27;
LABEL_25:
            if (*v8 >= 2)
            {
              v32 = 0;
              **(_DWORD **)v30 = v29;
LABEL_27:
              if (v31)
              {
                v35 = 0;
                v36 = 8 * v32;
                v37 = 8 * v31;
                do
                {
                  if (v36 != v35)
                    *(float *)(*(_QWORD *)v30 + v35 + 4) = *(float *)(*(_QWORD *)v30 + v35 + 4) + 5000.0;
                  v35 += 8;
                }
                while (v37 != v35);
              }
            }
          }
        }
        ++v11;
      }
      while (v11 != v10);
    }
  }
  NodeCandidates = mfs_Search_SparseDP((uint64_t)a2, a1, a1 + 2248, a3);
  if ((NodeCandidates & 0x80000000) == 0)
  {
    if (!*(_DWORD *)(a1 + 2200))
    {
      FreeRemainingStreams(a1);
      v39 = *(_DWORD *)(a1 + 32);
      if (v39 >= 1)
      {
        v40 = 0;
        v41 = 12;
        do
        {
          v42 = *(_QWORD *)(a1 + 24);
          if (*(_DWORD *)(v42 + v41) != 2)
          {
            MFS__FreePStreamParam((_QWORD *)(v42 + v41 + 12));
            v39 = *(_DWORD *)(a1 + 32);
          }
          ++v40;
          v41 += 1528;
        }
        while (v40 < v39);
      }
    }
    MFS__log_select_Diag(v6, 1, (uint64_t)"}\n");
    if (*(_DWORD *)(a1 + 2592) && (!v8[11] || *v8 >= 2))
      mfs_DeInitHashTable(v6, a1);
  }
  return NodeCandidates;
}

uint64_t TransWeights_InitCopy_0(uint64_t a1, int *a2, uint64_t a3, unsigned int a4)
{
  int v7;
  float v8;
  _QWORD *v9;
  int32x2_t v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  int *v14;
  int v15;
  int v16;
  uint64_t v17;
  float32x4_t **v18;
  float v19;
  float32x4_t *v20;
  float v21;
  float32x4_t *v22;
  int v23;
  float **v24;
  int v25;
  float v26;
  float *v27;
  float v28;
  float32x4_t *v29;
  uint64_t result;
  int v31;
  int v32;
  int v33;
  int v34;
  float32x4_t v35;

  v33 = *a2;
  if (*a2 >= 0)
    v7 = *a2;
  else
    v7 = *a2 + 1;
  if ((*(_DWORD *)(a1 + 8968) - 7) >= 5)
    v8 = 1.0;
  else
    v8 = 2.0;
  v9 = MFS__ffcalloc(*(_QWORD **)(*(_QWORD *)(a3 + 1928) + 8), a4, 4);
  if (!v9)
    return 2229280778;
  v11 = v9;
  v10.i32[0] = 1.0;
  if ((*(_DWORD *)(a1 + 8968) - 7) >= 5)
    *(float *)v10.i32 = (float)(*(float *)(a1 + 8160) + *(float *)(a1 + 8124)) + *(float *)(a1 + 8128);
  if (*(int *)(a3 + 608) >= 1)
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = v7 >> 1;
    if (v7 >> 1 <= 2)
      v16 = 2;
    else
      v16 = v7 >> 1;
    v32 = v16;
    v31 = v16 - 1;
    v34 = v7 >> 1;
    v35 = (float32x4_t)vdupq_lane_s32(v10, 0);
    do
    {
      v17 = *(_QWORD *)(a3 + 600);
      if (v14)
      {
        if (v15 < *a2)
        {
          v18 = (float32x4_t **)&v11[v13];
          do
          {
            (*v18)->f32[0] = mfs_Ling_TransWeightsDiphADJ(*(_QWORD **)(a3 + 8), *v14) * *(float *)(a1 + 8160);
            (*v18)->f32[1] = mfs_Ling_TransWeightsDiphMCP(*(_QWORD **)(a3 + 8), *v14) * *(float *)(a1 + 8124);
            v19 = mfs_Ling_TransWeightsDiphLF0(*(_QWORD **)(a3 + 8), *v14);
            v20 = *v18++;
            v20->f32[2] = v19 * *(float *)(a1 + 8128);
            v20->i32[3] = 0;
            *v20 = vdivq_f32(*v20, v35);
            ++v15;
            ++v13;
          }
          while (v15 < *a2);
        }
        *(float *)v11[v13] = v8
                           * (float)(mfs_Ling_TransWeightsPhonADJ(*(_QWORD **)(a3 + 8), *v14) * *(float *)(a1 + 8160));
        *(float *)(v11[v13] + 4) = v8
                                   * (float)(mfs_Ling_TransWeightsPhonMCP(*(_QWORD **)(a3 + 8), *v14)
                                           * *(float *)(a1 + 8124));
        v21 = mfs_Ling_TransWeightsPhonLF0(*(_QWORD **)(a3 + 8), *v14);
        v22 = (float32x4_t *)v11[v13];
        v22->f32[2] = v8 * (float)(v21 * *(float *)(a1 + 8128));
        v22->i32[3] = 0;
        *v22 = vdivq_f32(*v22, v35);
        v23 = v13 + 1;
        v15 = v34;
        if (v33 >= 4)
        {
          v24 = (float **)&v11[v23];
          v23 = v32 + v13;
          v25 = v31;
          do
          {
            v26 = v8 * (float)(mfs_Ling_TransWeightsDiphADJ(*(_QWORD **)(a3 + 8), *v14) * *(float *)(a1 + 8160));
            v27 = *v24;
            **v24 = v26;
            if ((*(_DWORD *)(a1 + 8968) - 7) <= 4 && v14[6] == *a2)
              *v27 = v26 + 1.0;
            (*v24)[1] = v8 * (float)(mfs_Ling_TransWeightsDiphMCP(*(_QWORD **)(a3 + 8), *v14) * *(float *)(a1 + 8124));
            v28 = mfs_Ling_TransWeightsDiphLF0(*(_QWORD **)(a3 + 8), *v14);
            v29 = (float32x4_t *)*v24++;
            v29->f32[2] = v8 * (float)(v28 * *(float *)(a1 + 8128));
            v29->i32[3] = 0;
            *v29 = vdivq_f32(*v29, v35);
            --v25;
          }
          while (v25);
          v15 = v34;
        }
      }
      else
      {
        v23 = v13 + v15;
      }
      v14 = (int *)(v17 + 528 * v12++);
      v13 = v23;
    }
    while (v12 < *(int *)(a3 + 608));
  }
  result = 0;
  *(_QWORD *)(a3 + 2072) = v11;
  return result;
}

uint64_t TransWeights_InitCopy_Default(uint64_t a1, int *a2, uint64_t a3, unsigned int a4)
{
  int v7;
  int v8;
  _QWORD *v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  float32x4_t v18;
  int v19;
  float32x4_t **v20;
  int v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t **v24;
  int v25;
  float32x4_t *v26;
  uint64_t v27;

  v7 = *a2;
  if (*a2 >= 0)
    v8 = *a2;
  else
    v8 = v7 + 1;
  v9 = MFS__ffcalloc(*(_QWORD **)(*(_QWORD *)(a3 + 1928) + 8), a4, 4);
  if (!v9)
    return 2229280778;
  v10.i32[0] = 1.0;
  if ((*(_DWORD *)(a1 + 8968) - 7) >= 5)
    *(float *)v10.i32 = (float)(*(float *)(a1 + 8160) + *(float *)(a1 + 8124)) + *(float *)(a1 + 8128);
  v11 = *(unsigned int *)(a3 + 608);
  if ((int)v11 >= 1)
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = v8 >> 1;
    v16 = *(_QWORD *)(a3 + 600);
    if (v8 >> 1 <= 2)
      v17 = 2;
    else
      v17 = v8 >> 1;
    v18 = (float32x4_t)vdupq_lane_s32(v10, 0);
    v19 = v17 - 1;
    do
    {
      if (v14)
      {
        if (v15 < *a2)
        {
          v20 = (float32x4_t **)&v9[v13];
          v21 = *a2 - v15;
          v13 += v21;
          do
          {
            v22 = *v20++;
            v22->i32[0] = *(_DWORD *)(a1 + 8160);
            v22->i32[1] = *(_DWORD *)(a1 + 8124);
            v22->i32[2] = *(_DWORD *)(a1 + 8128);
            v22->i32[3] = 0;
            *v22 = vdivq_f32(*v22, v18);
            --v21;
          }
          while (v21);
        }
        v23 = (float32x4_t *)v9[v13];
        v23->i32[0] = *(_DWORD *)(a1 + 8160);
        v23->i32[1] = *(_DWORD *)(a1 + 8124);
        v23->i32[2] = *(_DWORD *)(a1 + 8128);
        v23->i32[3] = 0;
        *v23 = vdivq_f32(*v23, v18);
        ++v13;
        if (v7 >= 4)
        {
          v24 = (float32x4_t **)&v9[v13];
          v25 = v19;
          do
          {
            v26 = *v24++;
            v26->i32[0] = *(_DWORD *)(a1 + 8160);
            v26->i32[1] = *(_DWORD *)(a1 + 8124);
            v26->i32[2] = *(_DWORD *)(a1 + 8128);
            v26->i32[3] = 0;
            *v26 = vdivq_f32(*v26, v18);
            ++v13;
            --v25;
          }
          while (v25);
        }
      }
      else
      {
        v13 += v15;
      }
      v14 = v16 + 528 * v12++;
    }
    while (v12 != v11);
  }
  v27 = 0;
  *(_QWORD *)(a3 + 2072) = v9;
  return v27;
}

uint64_t Detect_Sparse_Grid(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t result;
  int v10;
  uint64_t v11;

  v4 = a2 + 1992;
  v11 = 0;
  mfs_DPLinks_Clear((_QWORD *)(a2 + 1992));
  v5 = *(_DWORD *)(a2 + 1936);
  if (v5 < 1)
  {
    result = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    result = 0;
    do
    {
      v10 = *(_DWORD *)(*(_QWORD *)(a2 + 1952) + 32 * v6 + 16);
      if (v10 >= 21)
      {
        v10 = (int)(float)(*(float *)(a1 + 8236) * (float)v10);
        if (*(_DWORD *)(a1 + 8240) < v10)
          v10 = *(_DWORD *)(a1 + 8240);
      }
      if (v10 < 1)
      {
        if (!v8)
        {
          if (v6 - (int)v11 < 2)
          {
            LODWORD(v11) = v6;
          }
          else
          {
            result = mfs_DPLinks_Add(v4, &v11);
            if ((result & 0x80000000) != 0)
              return result;
            v7 = 0;
            v6 = HIDWORD(v11);
            v5 = *(_DWORD *)(a2 + 1936);
          }
          v8 = 1;
        }
      }
      else if (v8 == 1)
      {
        v8 = 0;
        LODWORD(v11) = v6;
        v7 = 1;
      }
      HIDWORD(v11) = ++v6;
    }
    while (v6 < v5);
    if (v7 && !v8)
      result = mfs_DPLinks_Add(v4, &v11);
  }
  if (!*(_DWORD *)(a2 + 2008))
    return mfs_DPLinks_Add(v4, &v11);
  return result;
}

uint64_t mfs_S32Vect_Init(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v2;
  return result;
}

_QWORD *mfs_S32Vect_Clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  v1 = result;
  v2 = result[1];
  if (v2)
  {
    result = heap_Free((_QWORD *)*result, v2);
    v1[1] = 0;
  }
  v1[2] = 0;
  return result;
}

uint64_t mfs_S32Vect_Reserve(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 && *(_DWORD *)(a1 + 20) >= a2)
    return 0;
  v5 = heap_Realloc(*(uint64_t **)a1, v4, 4 * a2);
  if (!v5)
    return 2229280778;
  v6 = v5;
  v7 = *(unsigned int *)(a1 + 16);
  if (a2 > v7)
    cstdlib_memset((void *)(v5 + 4 * v7), 0, 4 * (a2 - v7));
  result = 0;
  *(_QWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 20) = a2;
  return result;
}

uint64_t mfs_S32Vect_Copy(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t result;
  unsigned int v6;

  v4 = *a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = v4;
  result = mfs_S32Vect_Reserve(a1, *((_DWORD *)a2 + 4));
  v6 = *(_DWORD *)(a1 + 16);
  while (v6 < *((_DWORD *)a2 + 4))
  {
    if (v6 < *(_DWORD *)(a1 + 20))
    {
      *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v6) = *(_DWORD *)(a2[1] + 4 * v6);
      v6 = *(_DWORD *)(a1 + 16) + 1;
      *(_DWORD *)(a1 + 16) = v6;
    }
  }
  return result;
}

uint64_t mfs_S32Vect_Pad(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(unsigned int *)(a1 + 16);
  if (v2 >= *(_DWORD *)(a1 + 20))
    return 2229280778;
  result = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v2) = a2;
  ++*(_DWORD *)(a1 + 16);
  return result;
}

uint64_t mfs_S32Vect_Add(uint64_t a1, int a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(_DWORD *)(a1 + 16);
  if (v4 >= *(_DWORD *)(a1 + 20))
  {
    v5 = heap_Realloc(*(uint64_t **)a1, *(_QWORD *)(a1 + 8), 4 * (v4 + 1));
    if (!v5)
      return 2229280778;
    *(_QWORD *)(a1 + 8) = v5;
    v4 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) = v4 + 1;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 8);
  }
  v6 = 0;
  *(_DWORD *)(v5 + 4 * v4) = a2;
  ++*(_DWORD *)(a1 + 16);
  return v6;
}

uint64_t mfs_U32Vect_Init(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v2;
  return result;
}

_QWORD *mfs_U32Vect_Clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  v1 = result;
  v2 = result[1];
  if (v2)
  {
    result = heap_Free((_QWORD *)*result, v2);
    v1[1] = 0;
  }
  v1[2] = 0;
  return result;
}

uint64_t mfs_U32Vect_Reserve(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_DWORD *)(a1 + 20) == a2)
    return 0;
  result = 0;
  if (a2 && *(_DWORD *)(a1 + 16) <= a2)
  {
    v5 = heap_Realloc(*(uint64_t **)a1, *(_QWORD *)(a1 + 8), 4 * a2);
    if (v5)
    {
      v6 = v5;
      v7 = *(unsigned int *)(a1 + 16);
      if (a2 > v7)
        cstdlib_memset((void *)(v5 + 4 * v7), 0, 4 * (a2 - v7));
      result = 0;
      *(_QWORD *)(a1 + 8) = v6;
      *(_DWORD *)(a1 + 20) = a2;
    }
    else
    {
      return 2229280778;
    }
  }
  return result;
}

uint64_t mfs_U32Vect_Add(uint64_t a1, int a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(_DWORD *)(a1 + 16);
  if (v4 >= *(_DWORD *)(a1 + 20))
  {
    v5 = heap_Realloc(*(uint64_t **)a1, *(_QWORD *)(a1 + 8), 4 * (v4 + 1));
    if (!v5)
      return 2229280778;
    *(_QWORD *)(a1 + 8) = v5;
    v4 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) = v4 + 1;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 8);
  }
  v6 = 0;
  *(_DWORD *)(v5 + 4 * v4) = a2;
  ++*(_DWORD *)(a1 + 16);
  return v6;
}

uint64_t mfs_F32Vect_Init(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v2;
  return result;
}

float mfs_F32Vect_Copy(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  float result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v4 = *a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = v4;
  mfs_F32Vect_Create(a1, *((_DWORD *)a2 + 4));
  v6 = *(unsigned int *)(a1 + 16);
  v7 = *((unsigned int *)a2 + 4);
  if (v6 < v7)
  {
    v8 = *(unsigned int *)(a1 + 20);
    do
    {
      if (v6 < v8)
      {
        result = *(float *)(a2[1] + 4 * v6);
        *(float *)(*(_QWORD *)(a1 + 8) + 4 * v6++) = result;
        *(_DWORD *)(a1 + 16) = v6;
        v7 = *((unsigned int *)a2 + 4);
      }
    }
    while (v6 < v7);
  }
  return result;
}

uint64_t mfs_F32Vect_Create(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t result;

  *(_QWORD *)(a1 + 16) = 0;
  if (!a2)
    return 0;
  v4 = 4 * a2;
  v5 = (void *)heap_Alloc(*(_QWORD *)a1, v4);
  if (!v5)
    return 2229280778;
  v6 = v5;
  cstdlib_memset(v5, 0, v4);
  result = 0;
  *(_QWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 20) = a2;
  return result;
}

uint64_t mfs_F32Vect_Pad(uint64_t a1, float a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(unsigned int *)(a1 + 16);
  if (v2 >= *(_DWORD *)(a1 + 20))
    return 2229280778;
  result = 0;
  *(float *)(*(_QWORD *)(a1 + 8) + 4 * v2) = a2;
  *(_DWORD *)(a1 + 16) = v2 + 1;
  return result;
}

_QWORD *mfs_F32Vect_Clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  v1 = result;
  v2 = result[1];
  if (v2)
  {
    result = heap_Free((_QWORD *)*result, v2);
    v1[1] = 0;
  }
  v1[2] = 0;
  return result;
}

uint64_t mfs_DPLinks_Init(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v2;
  return result;
}

_QWORD *mfs_DPLinks_Clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  v1 = result;
  v2 = result[1];
  if (v2)
  {
    result = heap_Free((_QWORD *)*result, v2);
    v1[1] = 0;
  }
  v1[2] = 0;
  return result;
}

uint64_t mfs_DPLinks_Reserve(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_DWORD *)(a1 + 20) == a2)
    return 0;
  result = 0;
  if (a2 && *(_DWORD *)(a1 + 16) <= a2)
  {
    v5 = heap_Realloc(*(uint64_t **)a1, *(_QWORD *)(a1 + 8), 8 * a2);
    if (v5)
    {
      v6 = v5;
      v7 = *(unsigned int *)(a1 + 16);
      if (a2 > v7)
        cstdlib_memset((void *)(v5 + 8 * v7), 0, 8 * (a2 - v7));
      result = 0;
      *(_QWORD *)(a1 + 8) = v6;
      *(_DWORD *)(a1 + 20) = a2;
    }
    else
    {
      return 2229280778;
    }
  }
  return result;
}

uint64_t mfs_DPLinks_Add(uint64_t a1, _QWORD *a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(_DWORD *)(a1 + 16);
  if (v4 >= *(_DWORD *)(a1 + 20))
  {
    v5 = heap_Realloc(*(uint64_t **)a1, *(_QWORD *)(a1 + 8), 8 * (v4 + 1));
    if (!v5)
      return 2229280778;
    *(_QWORD *)(a1 + 8) = v5;
    v4 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) = v4 + 1;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 8);
  }
  v6 = 0;
  *(_QWORD *)(v5 + 8 * v4) = *a2;
  ++*(_DWORD *)(a1 + 16);
  return v6;
}

uint64_t mfs_TCost_CandidateCostStream_kld_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v14;
  float *v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  uint64_t result;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;

  v14 = *(_DWORD *)(a1 + 144);
  v15 = *(float **)(a1 + 32);
  v34 = 0.0;
  v35 = 0.0;
  if (*v15 >= 0.0)
    v16 = *v15;
  else
    v16 = 0.01;
  if (v15[v14 - 1] >= 0.0)
    v17 = v15[v14 - 1];
  else
    v17 = 0.01;
  mfs_getBeginEndPitch_Obersee(a2, a4, &v35, &v34);
  if (v35 >= 0.0)
    v18 = v35;
  else
    v18 = 0.01;
  if (v34 >= 0.0)
    v19 = v34;
  else
    v19 = 0.01;
  v34 = v19;
  v35 = v18;
  v20 = 1.0 - *(float *)(*(_QWORD *)(a2 + 1072) + 8932);
  v21 = mfs_TCost_LF0_BND_distance(v16, v18, v17, v19);
  v22 = v21;
  v23 = *(float *)(*(_QWORD *)(a2 + 1072) + 8932);
  LOBYTE(v21) = *(_BYTE *)(a4 + 27);
  *(float *)(a7 + 8) = (float)((float)(v23
                                     * mfs_TCost_LF0_SLP_distance(v16, v35, v17, v34, (float)v14, (float)LODWORD(v21)))
                             + (float)(v20 * v22))
                     * (float)(*(float *)(a1 + 4) * *(float *)(a1 + 148));
  v26 = *(unsigned __int16 *)(a4 + 22);
  v27 = *(unsigned __int8 *)(a4 + 27);
  if ((int)(*(_DWORD *)(a1 + 144) - v27) >= 0)
    v28 = *(_DWORD *)(a1 + 144) - v27;
  else
    v28 = v27 - *(_DWORD *)(a1 + 144);
  *(_DWORD *)(a7 + 4) = 0;
  if (*(_BYTE *)(a1 + 216))
  {
    v36 = 0.0;
    result = mfs_kld_lookup(a2, a3, v26, a5, a6, &v36, v24, v25);
    if ((result & 0x80000000) != 0)
      return result;
    v30 = *(float *)(a7 + 4) + (float)(v36 * *(float *)(a1 + 152));
    *(float *)(a7 + 4) = v30;
  }
  else
  {
    v30 = 0.0;
  }
  v31 = (float)v28;
  *(float *)(a7 + 4) = v30 * *(float *)(a1 + 4);
  v32 = *(float *)(a1 + 4) * *(float *)(a1 + 156);
  if (*(_DWORD *)(*(_QWORD *)(a2 + 1072) + 8928) == 6)
    v33 = (float)((float)(v31 * 0.03) / (float)v27) * v32;
  else
    v33 = (float)(v32 * v31) * 0.01;
  result = 0;
  *(float *)a7 = v33;
  return result;
}

uint64_t mfs_GetTimeStamp()
{
  return 0;
}

uint64_t mfs_InitStream(uint64_t a1, void *__b, _DWORD *a3)
{
  cstdlib_memset(__b, 0, 0x1A18uLL);
  *((_QWORD *)__b + 241) = a1;
  return MFS__InitVStream(a1, (char *)__b, a3);
}

void *mfs_DeInitStream(unsigned int *__b)
{
  unsigned int v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t i;
  uint64_t v14;
  uint64_t j;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;

  if (*((_QWORD *)__b + 241))
  {
    mfs_CostList_DeInit((_QWORD *)__b + 243);
    if (__b[496])
      mfs_CostList_DeInit((_QWORD *)__b + 246);
    v2 = __b[516];
    if (v2)
    {
      if (v2 == 1)
      {
        v3 = (uint64_t *)*((_QWORD *)__b + 255);
        if (v3)
        {
          do
          {
            if (*v3)
            {
              heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), *v3);
              *v3 = 0;
            }
            v4 = (uint64_t *)v3[1];
            heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), (uint64_t)v3);
            v3 = v4;
          }
          while (v4);
        }
      }
    }
    else
    {
      v5 = (uint64_t *)*((_QWORD *)__b + 253);
      if (v5)
      {
        do
        {
          if (*v5)
          {
            heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), *v5);
            *v5 = 0;
          }
          v6 = (uint64_t *)v5[1];
          heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), (uint64_t)v5);
          v5 = v6;
        }
        while (v6);
      }
    }
    v7 = (uint64_t *)*((_QWORD *)__b + 321);
    if (v7)
    {
      mfs_uselect_Finalize_Obersee(v7);
      v8 = *((_QWORD *)__b + 321);
      if (v8)
      {
        heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), v8);
        *((_QWORD *)__b + 321) = 0;
      }
    }
    v9 = *((_QWORD *)__b + 252);
    if (v9)
    {
      heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), v9);
      *((_QWORD *)__b + 252) = 0;
    }
    MFS__ff_free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), *((uint64_t **)__b + 259));
    v10 = *((_QWORD *)__b + 261);
    if (v10)
    {
      heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), v10);
      *((_QWORD *)__b + 261) = 0;
    }
    v11 = *((_QWORD *)__b + 263);
    if (v11)
    {
      v12 = __b[155];
      if (!(_DWORD)v12)
        goto LABEL_29;
      for (i = 0; i < v12; ++i)
      {
        v14 = *(_QWORD *)(*((_QWORD *)__b + 263) + 8 * i);
        if (v14)
        {
          heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), v14);
          *(_QWORD *)(*((_QWORD *)__b + 263) + 8 * i) = 0;
          v12 = __b[155];
        }
      }
      v11 = *((_QWORD *)__b + 263);
      if (v11)
      {
LABEL_29:
        heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), v11);
        *((_QWORD *)__b + 263) = 0;
      }
    }
    for (j = 612; j != 632; j += 2)
    {
      v16 = *(_QWORD *)&__b[j];
      if (v16)
      {
        heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), v16);
        *(_QWORD *)&__b[j] = 0;
      }
    }
    v17 = *((_QWORD *)__b + 254);
    if (v17)
    {
      heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), v17);
      *((_QWORD *)__b + 254) = 0;
    }
    v18 = *((_QWORD *)__b + 256);
    if (v18)
    {
      heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), v18);
      *((_QWORD *)__b + 256) = 0;
    }
    v19 = *((_QWORD *)__b + 331);
    if (v19)
    {
      heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), v19);
      *((_QWORD *)__b + 331) = 0;
    }
    v20 = *((_QWORD *)__b + 332);
    if (v20)
    {
      heap_Free(*(_QWORD **)(*((_QWORD *)__b + 241) + 8), v20);
      *((_QWORD *)__b + 332) = 0;
    }
    mfs_DPLinks_Clear((_QWORD *)__b + 249);
    mfs_UnitSequence_DeInit((uint64_t)(__b + 528));
    mfs_SegmentList_DeInit((_QWORD *)__b + 276);
    mfs_SegmentList_DeInit((_QWORD *)__b + 281);
    v21 = *((_QWORD *)__b + 8);
    if (v21 && *(_DWORD *)(v21 + 456))
    {
      v22 = 0;
      do
      {
        if (*(_DWORD *)(v21 + 4 * v22 + 416))
        {
          MFS__DeInitMSDUttModel((_QWORD *)__b + 7, v22);
          v21 = *((_QWORD *)__b + 8);
        }
        ++v22;
      }
      while (v22 < *(unsigned int *)(v21 + 456));
    }
    MFS__DeInitVStream(__b);
  }
  return cstdlib_memset(__b, 0, 0x1A18uLL);
}

uint64_t mfs_LoadStream(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  int *v12;
  _DWORD *v13;
  int v14;
  int *v15;
  int v16;

  result = MFS__LoadVStream((uint64_t *)a1, a2, a3);
  if ((result & 0x80000000) == 0)
  {
    v7 = *(unsigned int *)(a1 + 32);
    if ((int)v7 >= 1)
    {
      v8 = 0;
      v9 = *(_QWORD *)(a1 + 24);
      v10 = (_DWORD *)(v9 + 344);
      do
      {
        if (*(_DWORD *)(v9 + 1528 * v8 + 12))
        {
          v11 = *(unsigned int *)(a3 + 4 * v8 + 264);
          if ((int)v11 >= 1)
          {
            v12 = (int *)(*(_QWORD *)(a2 + 8 * v8 + 2016) + 4);
            v13 = v10;
            do
            {
              *(v13 - 50) = *(v12 - 1);
              v14 = *v12;
              v12 += 2;
              *v13++ = v14;
              --v11;
            }
            while (v11);
          }
        }
        ++v8;
        v10 += 382;
      }
      while (v8 != v7);
      v15 = *(int **)(a1 + 24);
      do
      {
        v16 = *(_DWORD *)(a3 + 4 * v15[3] + 8796);
        v15[368] = v16;
        v15[186] = v16;
        v15 += 382;
        --v7;
      }
      while (v7);
    }
    mfs_DPLinks_Init(*(_QWORD *)(a1 + 1928), (_QWORD *)(a1 + 1992));
    result = mfs_UnitSequence_Init(*(_QWORD *)(a1 + 1928), (uint64_t *)(a1 + 2112), a2);
    if ((result & 0x80000000) == 0)
    {
      result = mfs_SegmentList_Init(*(_QWORD *)(a1 + 1928), a2, a1 + 2208);
      if ((result & 0x80000000) == 0)
        return mfs_SegmentList_Init(*(_QWORD *)(a1 + 1928), a2, a1 + 2248);
    }
  }
  return result;
}

uint64_t mfs_UnitSequence_Init(uint64_t a1, uint64_t *__b, uint64_t a3)
{
  cstdlib_memset(__b, 0, 0x50uLL);
  *__b = a1;
  __b[1] = a3;
  mfs_S32Vect_Init(a1, __b + 4);
  mfs_F32Vect_Init(a1, __b + 7);
  return 0;
}

_QWORD *mfs_UnitSequence_DeInit(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 24) = 0;
  mfs_S32Vect_Clear((_QWORD *)(a1 + 32));
  return mfs_F32Vect_Clear((_QWORD *)(a1 + 56));
}

uint64_t mfs_UnitSequence_Sequence(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t result;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int *v16;
  uint64_t v17;
  int *v18;
  int v19;
  int MessageOffsetMsec;
  int v21;
  _QWORD *v22;
  _QWORD v23[2];
  _BYTE __b[264];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  memset(__b, 0, sizeof(__b));
  v23[0] = 0;
  v23[1] = 0;
  v22 = v23;
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 1096);
  cstdlib_memset(__b, 0, 0x108uLL);
  v5 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 16), 264 * *(unsigned int *)(a1 + 48));
  if (!v5)
    return 2229280778;
  v6 = v5;
  *(_QWORD *)(a1 + 16) = v5;
  v7 = *(unsigned int *)(a1 + 48);
  if (v7 <= 1)
  {
    v11 = *(_DWORD *)&__b[4];
  }
  else
  {
    v8 = 0;
    do
    {
      v9 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v8 + 4);
      v10 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v8) + 1;
      v11 = ++*(_DWORD *)&__b[4];
      if (v9 != v10)
      {
        memcpy((void *)(*(_QWORD *)(a1 + 16) + 264 * *(unsigned int *)(a1 + 24)), __b, 0x108uLL);
        ++*(_DWORD *)(a1 + 24);
        v11 = *(_DWORD *)&__b[4];
        *(_DWORD *)__b = *(_DWORD *)&__b[4];
        v7 = *(unsigned int *)(a1 + 48);
      }
      ++v8;
    }
    while (v8 + 1 < v7);
  }
  if (v11 == *(_DWORD *)__b)
  {
    v13 = *(_DWORD *)(a1 + 24);
    if (v13)
      goto LABEL_12;
    return 0;
  }
  *(_DWORD *)&__b[4] = v11 + 1;
  memcpy((void *)(*(_QWORD *)(a1 + 16) + 264 * *(unsigned int *)(a1 + 24)), __b, 0x108uLL);
  v13 = *(_DWORD *)(a1 + 24) + 1;
  *(_DWORD *)(a1 + 24) = v13;
  if (!v13)
    return 0;
LABEL_12:
  v14 = 0;
  result = 0;
  v15 = v4 - 1;
  while (1)
  {
    v16 = (int *)(v6 + 264 * v14);
    v17 = *v16;
    v19 = v16[1];
    v18 = v16 + 1;
    if ((int)v17 < v19)
      break;
LABEL_20:
    if (++v14 >= (unint64_t)v13)
      return result;
  }
  while (1)
  {
    mfs_getUnitDataFromMfsData(*(unsigned __int8 **)(a1 + 8), *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v17), (uint64_t *)&v22);
    MessageOffsetMsec = mfs_GetMessageOffsetMsec(*(_QWORD *)(a1 + 8), *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v17));
    v21 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v17) == v15 ? -1 : *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v17);
    result = mfs_SegmentList_Add(a2, v21, *((_BYTE *)v22 + 13), MessageOffsetMsec, (unsigned __int16)(*((_WORD *)v22 + 4) * *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1072) + 24)));
    if ((result & 0x80000000) != 0)
      return result;
    if (++v17 >= *v18)
    {
      v13 = *(_DWORD *)(a1 + 24);
      goto LABEL_20;
    }
  }
}

uint64_t mfs_UnitSequence_GetTemplateDur(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t v4;
  __int128 v6;
  __int128 v7;
  __int128 *v8;

  if ((a3 & 0x80000000) != 0)
    return 0;
  if (*(_DWORD *)(a1 + 48) <= (signed int)a3)
    return 0;
  v3 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * a3);
  v4 = *(_QWORD *)(a1 + 8);
  if (*(_DWORD *)(*(_QWORD *)(v4 + 1072) + 8328))
  {
    v6 = 0u;
    v7 = 0u;
    mfs_getUnitData_Obersee(v4, a2, v3, (uint64_t)&v6);
    return BYTE11(v7);
  }
  else
  {
    v6 = 0uLL;
    v8 = &v6;
    mfs_getUnitDataFromMfsData((unsigned __int8 *)v4, v3, (uint64_t *)&v8);
    return *((unsigned __int16 *)v8 + 4);
  }
}

uint64_t mfs_UnitSequence_GetTemplateId(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(a1 + 48) <= (signed int)a2)
    return 0x7FFFFFFFLL;
  else
    return *(unsigned int *)(*(_QWORD *)(a1 + 40) + 4 * a2);
}

uint64_t mfs_UnitSequence_Log(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  _DWORD *v8;
  unint64_t v9;

  if (*(_DWORD *)(result + 24))
  {
    v1 = result;
    v2 = 0;
    v3 = *(_QWORD *)(result + 40);
    v4 = *(_QWORD *)(result + 16);
    do
    {
      v5 = (unsigned int *)(v4 + 264 * v2);
      v6 = *(_DWORD *)(v3 + 4 * (int)*v5);
      v7 = *(_QWORD *)(v1 + 8);
      if (v6 < *(_DWORD *)(v7 + 1096) - 1)
        mfs_GetMsgName(v7, v6);
      v8 = (_DWORD *)(v4 + 264 * v2 + 4);
      MFS__log_select_Diag(*(_QWORD *)v1, 1, (uint64_t)"%s.pcm : %d - %d\n");
      v9 = *v5;
      if (v9 < *v8)
      {
        do
        {
          MFS__log_select_Diag(*(_QWORD *)v1, 1, (uint64_t)"%d , ");
          ++v9;
        }
        while (v9 < *v8);
      }
      result = MFS__log_select_Diag(*(_QWORD *)v1, 1, (uint64_t)"\n");
      ++v2;
    }
    while (v2 < *(unsigned int *)(v1 + 24));
  }
  return result;
}

uint64_t mfs_DataCache_Init_Obersee(unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;
  void *v9;
  uint64_t v10;

  result = 2229280774;
  if (a1 && a4 && a6)
  {
    if (a3 <= 0x40)
    {
      *a1 = a2;
      a1[1] = a3;
      *((_QWORD *)a1 + 1) = a4;
      *((_QWORD *)a1 + 2) = a5;
      *((_QWORD *)a1 + 5) = a6;
      v9 = (void *)heap_Calloc(*(_QWORD **)(a6 + 8), 1, 4 * a2);
      *((_QWORD *)a1 + 4) = v9;
      if (v9)
      {
        cstdlib_memset(v9, 255, 4 * *a1);
        v10 = heap_Calloc(*(_QWORD **)(a6 + 8), 1, a1[1] * (unint64_t)*a1);
        *((_QWORD *)a1 + 3) = v10;
        if (v10)
          return 0;
        else
          return 2229280778;
      }
      else
      {
        return 2229280778;
      }
    }
    else
    {
      return 2229280775;
    }
  }
  return result;
}

_QWORD *mfs_DataCache_DeInit_Obersee(_QWORD *__b, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  if (__b)
  {
    v3 = __b;
    v4 = __b[4];
    if (v4)
      heap_Free(*(_QWORD **)(a2 + 8), v4);
    v5 = v3[3];
    if (v5)
      heap_Free(*(_QWORD **)(a2 + 8), v5);
    return cstdlib_memset(v3, 0, 0x30uLL);
  }
  return __b;
}

BOOL mfs_DataCache_Check_Obersee(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 32) + 4 * (a2 % *(_DWORD *)a1)) == a2;
}

void *mfs_DataCache_Read_Obersee(uint64_t a1, unsigned int a2, void *__dst)
{
  return cstdlib_memcpy(__dst, (const void *)(*(_QWORD *)(a1 + 24) + ((a2 % *(_DWORD *)a1) << 6)), *(unsigned int *)(a1 + 4));
}

void *mfs_DataCache_Write_Obersee(uint64_t a1, unsigned int a2, const void *a3)
{
  unsigned int v5;

  v5 = a2 % *(_DWORD *)a1;
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 4 * v5) = a2;
  (*(void (**)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16));
  return cstdlib_memcpy((void *)(*(_QWORD *)(a1 + 24) + (v5 << 6)), a3, *(unsigned int *)(a1 + 4));
}

uint64_t mfs_DataCache_ReadAndWrite_Obersee(uint64_t a1, unsigned int a2, void *__dst)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;

  v5 = a2 % *(_DWORD *)a1;
  v6 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v6 + 4 * v5) == a2)
  {
    v7 = 0;
    v8 = (const void *)(*(_QWORD *)(a1 + 24) + ((_DWORD)v5 << 6));
  }
  else
  {
    *(_DWORD *)(v6 + 4 * v5) = a2;
    v7 = (*(uint64_t (**)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16));
    v8 = __dst;
    __dst = (void *)(*(_QWORD *)(a1 + 24) + ((_DWORD)v5 << 6));
  }
  cstdlib_memcpy(__dst, v8, *(unsigned int *)(a1 + 4));
  return v7;
}

uint64_t mfs_DataCachePair_Init_Obersee(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;

  result = 2229280774;
  if (a1 && a4 && a6)
  {
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 4) = a3;
    *(_QWORD *)(a1 + 8) = a5;
    v13 = heap_Calloc(*(_QWORD **)(a6 + 8), 1, 48);
    *(_QWORD *)(a1 + 24) = v13;
    if (v13)
    {
      v14 = heap_Calloc(*(_QWORD **)(a6 + 8), 1, 48);
      *(_QWORD *)(a1 + 32) = v14;
      result = 2229280778;
      if (v14)
      {
        result = mfs_DataCache_Init_Obersee(*(unsigned int **)(a1 + 24), a2, a3, a4, a5, a6);
        if ((result & 0x80000000) == 0)
        {
          result = mfs_DataCache_Init_Obersee(*(unsigned int **)(a1 + 32), a2, a3, a4, a5, a6);
          if ((result & 0x80000000) == 0)
          {
            result = 0;
            *(_DWORD *)(a1 + 16) = 0;
          }
        }
      }
    }
    else
    {
      return 2229280778;
    }
  }
  return result;
}

void *mfs_DataCachePair_DeInit_Obersee(_QWORD *__b, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  v4 = (_QWORD *)__b[3];
  if (v4)
  {
    mfs_DataCache_DeInit_Obersee(v4, a2);
    heap_Free(*(_QWORD **)(a2 + 8), __b[3]);
  }
  v5 = (_QWORD *)__b[4];
  if (v5)
  {
    mfs_DataCache_DeInit_Obersee(v5, a2);
    heap_Free(*(_QWORD **)(a2 + 8), __b[4]);
  }
  return cstdlib_memset(__b, 0, 0x28uLL);
}

uint64_t mfs_DataCachePair_SetMode_Obersee(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

int8x16_t mfs_DataCachePair_SwapCaches_Obersee(uint64_t a1)
{
  int8x16_t result;

  result = vextq_s8(*(int8x16_t *)(a1 + 24), *(int8x16_t *)(a1 + 24), 8uLL);
  *(int8x16_t *)(a1 + 24) = result;
  return result;
}

uint64_t mfs_DataCachePair_ReadAndWrite_Obersee(uint64_t a1, unsigned int a2, void *__dst)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;

  v3 = *(_DWORD *)(a1 + 16);
  if (v3 == 1)
  {
    v5 = *(_QWORD *)(a1 + 24);
    v6 = a2 % *(_DWORD *)v5;
    if (*(_DWORD *)(*(_QWORD *)(v5 + 32) + 4 * v6) == a2)
    {
      cstdlib_memcpy(__dst, (const void *)(*(_QWORD *)(v5 + 24) + (v6 << 6)), *(unsigned int *)(v5 + 4));
      return 0;
    }
    v4 = *(_QWORD *)(a1 + 32);
    return mfs_DataCache_ReadAndWrite_Obersee(v4, a2, __dst);
  }
  if (!v3)
  {
    v4 = *(_QWORD *)(a1 + 24);
    return mfs_DataCache_ReadAndWrite_Obersee(v4, a2, __dst);
  }
  return 2229280775;
}

uint64_t select_bet4_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2229280769;
  result = 0;
  *a2 = &ISelect_Bet4;
  return result;
}

uint64_t select_bet4_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  if (!a3)
    return 2229280775;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 25967;
  }
  return result;
}

uint64_t select_bet4_ClassClose()
{
  return 0;
}

uint64_t select_bet4_ObjOpen(uint64_t a1, int a2, _WORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t inited;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t Object;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t ObjOpen;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t i;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  __int128 v83;
  uint64_t v84;
  int v85[2];
  char *__s;
  unsigned int v87;
  _OWORD v88[8];
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  v87 = 0;
  *(_QWORD *)v85 = 0;
  __s = 0;
  v5 = 2229280775;
  v84 = 0;
  memset(v88, 0, sizeof(v88));
  if (a5)
  {
    inited = InitRsrcFunction(a3, a4, v85);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      if ((safeh_HandleCheck(a1, a2, 25967, 408) & 0x80000000) == 0)
      {
        *a5 = 0;
        *((_DWORD *)a5 + 2) = 0;
        log_OutText(*(_QWORD *)(*(_QWORD *)v85 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Entering select_bet4_ObjOpen", v12, v13, v14, v80);
        v15 = heap_Calloc(*(_QWORD **)(*(_QWORD *)v85 + 8), 1, 10992);
        if (!v15)
        {
          log_OutPublic(*(_QWORD *)(*(_QWORD *)v85 + 32), (uint64_t)"SELECT_BET4", 58000, 0, v16, v17, v18, v19, v81);
          v5 = 2229280778;
LABEL_28:
          log_OutText(*(_QWORD *)(*(_QWORD *)v85 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Leaving select_bet4_ObjOpen: %x", v44, v45, v46, v5);
          return v5;
        }
        v20 = v15;
        *(_QWORD *)v15 = a3;
        *(_QWORD *)(v15 + 8) = a4;
        v21 = *(_QWORD *)v85;
        *(_DWORD *)(v15 + 10928) = 0;
        *(_QWORD *)(v15 + 16) = v21;
        *(_QWORD *)(v15 + 24) = a1;
        ForcedEEController_Clear(v15 + 10944);
        Object = objc_GetObject(*(_QWORD *)(*(_QWORD *)v85 + 48), (uint64_t)"SYNTHSTREAM", &v84);
        if ((Object & 0x80000000) != 0
          || (*(_QWORD *)(v20 + 40) = *(_QWORD *)(v84 + 8),
              Object = objc_GetObject(*(_QWORD *)(*(_QWORD *)v85 + 48), (uint64_t)"LINGDB", &v84),
              (Object & 0x80000000) != 0))
        {
          v5 = Object;
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 32), (uint64_t)"SELECT_BET4", 58001, 0, v23, v24, v25, v26, v81);
        }
        else
        {
          v27 = *(_QWORD *)(v84 + 8);
          *(_QWORD *)(v20 + 48) = v27;
          ObjOpen = MFS__select_bet3_FeatureExtractObjOpen(a3, a4, *(_QWORD *)(v20 + 40), v27, (_QWORD *)(v20 + 224));
          if ((ObjOpen & 0x80000000) == 0)
          {
            ObjOpen = betX_CreateRegularBrokerString(*(uint64_t *)v85, 0, (char *)v88, 0x80uLL);
            if ((ObjOpen & 0x80000000) == 0)
            {
              v29 = *(_QWORD *)(v20 + 24);
              if (!v29 || (v30 = *(_QWORD *)(v29 + 48)) == 0)
                v30 = *(_QWORD *)(*(_QWORD *)(v20 + 16) + 48);
              ObjOpen = objc_GetAddRefCountedObject(v30, (uint64_t)v88, (uint64_t (*)(_QWORD, _QWORD, uint64_t, _OWORD *, uint64_t))select_bet4_loc_ObjcVoiceOpen, (void (*)(_QWORD, _QWORD, _OWORD *))select_bet4_loc_ObjcVoiceClose, *(uint64_t *)v85, &v84);
              if ((ObjOpen & 0x80000000) == 0)
              {
                v31 = *(_QWORD *)v85;
                v32 = *(_QWORD *)(v84 + 32);
                *(_QWORD *)(v20 + 56) = v32;
                paramc_ParamSetStr(*(_QWORD *)(v31 + 40), (uint64_t)"voicecomponentid", (char *)(v32 + 66842));
                ObjOpen = select_bet4_loc_VoiceSetup((_QWORD *)v20);
                if ((ObjOpen & 0x80000000) == 0)
                {
                  v33 = *(_QWORD *)(*(_QWORD *)v85 + 40);
                  v82 = v20;
                  v83 = xmmword_24D29C5F8;
                  if ((paramc_ListenerAdd(v33, "frequencyhz", &v82) & 0x80000000) != 0)
                    log_OutPublic(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 32), (uint64_t)"SELECT_BET4", 58002, (uint64_t)"%s%s", v34, v35, v36, v37, "param");
                  if (((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)v85 + 40), (uint64_t)"bet4suppresschunking", &__s) & 0x80000000) != 0
                     || !cstdlib_strlen(__s))
                    && (v38 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)v85 + 40), (uint64_t)"bet4suppresschunking", "no"), (v38 & 0x80000000) != 0))
                  {
                    v5 = v38;
                  }
                  else
                  {
                    v43 = *(_QWORD *)(*(_QWORD *)v85 + 40);
                    v82 = v20;
                    v83 = xmmword_24D29C5F8;
                    v5 = paramc_ListenerAdd(v43, "bet4suppresschunking", &v82);
                    if ((v5 & 0x80000000) == 0)
                    {
LABEL_32:
                      if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)v85 + 40), (uint64_t)"model_template_ratio", &__s) & 0x80000000) == 0&& __s)
                      {
                        v48 = *(_QWORD *)(v20 + 56);
                        if (LH_stricmp(__s, "median"))
                        {
                          if (LH_stricmp(__s, "high"))
                            goto LABEL_39;
                          *(_DWORD *)(v48 + 9080) = 2;
                          v52 = *(_QWORD *)(*(_QWORD *)v85 + 32);
                          v53 = "Model Template Ration: high has not been implemented yet!";
                        }
                        else
                        {
                          *(_QWORD *)(v48 + 8292) = 0x3D23D70A40066666;
                          *(_QWORD *)(v48 + 9004) = 0x400000000;
                          *(_DWORD *)(v48 + 9080) = 1;
                          *(_DWORD *)(v48 + 140) = 1068708659;
                          *(_DWORD *)(v48 + 168) = 1068708659;
                          select_bet4_loc_SetSynthParamFloat(*(uint64_t *)v85, (uint64_t)"bet2voicevuvrelamp", 1.4);
                          select_bet4_loc_SetSynthParamFloat(*(uint64_t *)v85, (uint64_t)"bet2voicemvfboost", *(float *)(v48 + 168));
                          log_OutText(*(_QWORD *)(*(_QWORD *)v85 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Parameter change: f32WContext: %4.2f", v54, v55, v56, COERCE__INT64(*(float *)(v48 + 8292)));
                          log_OutText(*(_QWORD *)(*(_QWORD *)v85 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Parameter change: f32WGenericContext: %4.2f", v57, v58, v59, COERCE__INT64(*(float *)(v48 + 8296)));
                          log_OutText(*(_QWORD *)(*(_QWORD *)v85 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Parameter change: bEnableCCL: %d", v60, v61, v62, *(unsigned int *)(v48 + 9004));
                          log_OutText(*(_QWORD *)(*(_QWORD *)v85 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Parameter change: s32LenCCL: %d", v63, v64, v65, *(unsigned int *)(v48 + 9008));
                          log_OutText(*(_QWORD *)(*(_QWORD *)v85 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Parameter change: s32ModelTemplateRatio: %d", v66, v67, v68, *(unsigned int *)(v48 + 9080));
                          log_OutText(*(_QWORD *)(*(_QWORD *)v85 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Parameter change: VUV_REL_AMP: %4.2f", v69, v70, v71, COERCE__INT64(*(float *)(v48 + 140)));
                          v52 = *(_QWORD *)(*(_QWORD *)v85 + 32);
                          v53 = "Parameter change: MVF_BOOST: %4.2f";
                          *(double *)&v81 = *(float *)(v48 + 168);
                        }
                        log_OutText(v52, (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)v53, v49, v50, v51, v81);
                      }
LABEL_39:
                      if ((v5 & 0x80000000) == 0)
                      {
                        for (i = 0; i != 3; ++i)
                        {
                          v73 = off_24D29C5D0[i];
                          if (cstdlib_strcmp(v73, "bet4suppresschunking"))
                          {
                            if ((paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)v85 + 40), (uint64_t)v73, &v87) & 0x80000000) != 0)
                            {
                              v87 = dword_214FC0898[i];
                              v74 = paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)v85 + 40), (uint64_t)v73, v87);
                              if ((v74 & 0x80000000) != 0)
                                goto LABEL_51;
                            }
                            v74 = select_bet4_loc_ParamSet(v20, v73, v87);
                            if ((v74 & 0x80000000) != 0)
                              goto LABEL_51;
                            v79 = *(_QWORD *)(*(_QWORD *)v85 + 40);
                            v82 = v20;
                            v83 = xmmword_24D29C5F8;
                            v74 = paramc_ListenerAdd(v79, v73, &v82);
                            if ((v74 & 0x80000000) != 0)
                              goto LABEL_51;
                          }
                          v74 = select_bet4_RegisterObject(*a5, a5[1], *(uint64_t *)v85);
                          if ((v74 & 0x80000000) != 0)
                          {
LABEL_51:
                            v5 = v74;
                            log_OutPublic(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 32), (uint64_t)"SELECT_BET4", 58002, (uint64_t)"%s%s", v75, v76, v77, v78, "param");
                            goto LABEL_27;
                          }
                          *(_DWORD *)(v20 + 10928) = 1;
                        }
                        *a5 = v20;
                        *((_DWORD *)a5 + 2) = 25968;
                        if ((select_bet4_RegisterObject(v20, a5[1], *(uint64_t *)v85) & 0x80000000) == 0)
                          *(_DWORD *)(v20 + 10928) = 1;
                        v5 = critsec_ObjOpen(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 16), *(_QWORD **)(*(_QWORD *)(v20 + 16) + 8), (uint64_t *)(v20 + 32));
                        goto LABEL_28;
                      }
                      goto LABEL_27;
                    }
                  }
                  log_OutPublic(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 32), (uint64_t)"SELECT_BET4", 58002, (uint64_t)"%s%s", v39, v40, v41, v42, "param");
                  goto LABEL_32;
                }
              }
            }
          }
          v5 = ObjOpen;
        }
LABEL_27:
        *a5 = v20;
        *((_DWORD *)a5 + 2) = 25968;
        select_bet4_ObjClose(v20, a5[1]);
        *a5 = 0;
        *((_DWORD *)a5 + 2) = 0;
        goto LABEL_28;
      }
      return 2229280776;
    }
  }
  return v5;
}

uint64_t select_bet4_ObjClose(uint64_t a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t i;
  char *v12;
  uint64_t v13;
  int v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v21;
  int ObjClose;
  int v24;
  int v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;

  v3 = safeh_HandleCheck(a1, a2, 25968, 10992);
  if (v3 < 0)
    return 2229280776;
  LODWORD(v7) = v3;
  v8 = *(_QWORD *)(a1 + 16);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Entering select_bet4_ObjClose", v4, v5, v6, v32);
  v9 = *(_QWORD *)(a1 + 32);
  if (v9)
  {
    v10 = critsec_ObjClose(v9);
    if (v10 < 0)
      LODWORD(v7) = v10;
  }
  for (i = 0; i != 4; ++i)
  {
    v12 = off_24D29C608[i];
    v13 = *(_QWORD *)(v8 + 40);
    v33 = a1;
    v34 = xmmword_24D29C5F8;
    v14 = paramc_ListenerRemove(v13, v12, (__int128 *)&v33);
    if ((int)v7 > -1 && v14 < 0)
      v7 = v14;
    else
      v7 = v7;
  }
  v16 = *(_QWORD *)(a1 + 56);
  if (v16)
  {
    v17 = *(_QWORD *)(a1 + 24);
    if (!v17 || (v18 = *(_QWORD *)(v17 + 48)) == 0)
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48);
    v19 = objc_ReleaseObject(v18, v16);
    *(_QWORD *)(a1 + 56) = 0;
    if ((int)v7 > -1 && v19 < 0)
      v7 = v19;
    else
      v7 = v7;
    select_bet4_loc_VoiceSetup((_QWORD *)a1);
  }
  v21 = *(_QWORD *)(a1 + 224);
  if (v21)
  {
    ObjClose = MFS__select_bet3_FeatureExtractObjClose(v21);
    if ((int)v7 > -1 && ObjClose < 0)
      v7 = ObjClose;
    else
      v7 = v7;
  }
  if (*(_QWORD *)(a1 + 48))
  {
    v24 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"LINGDB");
    if ((int)v7 > -1 && v24 < 0)
      v7 = v24;
    else
      v7 = v7;
  }
  if (*(_QWORD *)(a1 + 40))
  {
    v26 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
    if ((int)v7 > -1 && v26 < 0)
      v7 = v26;
    else
      v7 = v7;
  }
  if (*(_DWORD *)(a1 + 10928) == 1)
    objc_UnregisterObject(*(_QWORD *)(v8 + 48), (uint64_t)"SELECTBET4");
  heap_Free(*(_QWORD **)(v8 + 8), a1);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Leaving select_bet4_ObjClose: %x", v28, v29, v30, v7);
  return v7;
}

uint64_t select_bet4_ObjReopen(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AddRefCountedObject;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  char __s2[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  *(_OWORD *)__s2 = 0u;
  v22 = 0u;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 25968, 10992) & 0x80000000) != 0)
    return 2229280776;
  v6 = a1[2];
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Entering select_bet4_ObjReopen", v3, v4, v5, v19);
  if ((betX_CreateRegularBrokerString(v6, 0, __s2, 0x80uLL) & 0x80000000) != 0
    || (v7 = (const char *)a1[7]) != 0 && !cstdlib_strcmp(v7, __s2))
  {
    AddRefCountedObject = select_bet4_loc_SetSynthParams((uint64_t)a1);
  }
  else
  {
    v8 = a1[3];
    if (!v8 || (v9 = *(_QWORD *)(v8 + 48)) == 0)
      v9 = *(_QWORD *)(a1[2] + 48);
    AddRefCountedObject = objc_GetAddRefCountedObject(v9, (uint64_t)__s2, (uint64_t (*)(_QWORD, _QWORD, uint64_t, _OWORD *, uint64_t))select_bet4_loc_ObjcVoiceOpen, (void (*)(_QWORD, _QWORD, _OWORD *))select_bet4_loc_ObjcVoiceClose, v6, &v20);
    if ((AddRefCountedObject & 0x80000000) == 0)
    {
      v11 = a1[7];
      if (v11)
      {
        v12 = a1[3];
        if (!v12 || (v13 = *(_QWORD *)(v12 + 48)) == 0)
          v13 = *(_QWORD *)(a1[2] + 48);
        objc_ReleaseObject(v13, v11);
      }
      a1[7] = *(_QWORD *)(v20 + 32);
      AddRefCountedObject = select_bet4_loc_VoiceSetup(a1);
    }
  }
  v14 = AddRefCountedObject;
  paramc_ParamSetStr(*(_QWORD *)(v6 + 40), (uint64_t)"voicecomponentid", (char *)(a1[7] + 66842));
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SELECT_BET4", 4, 0, (uint64_t)"Leaving select_bet4_ObjReopen: %x", v15, v16, v17, v14);
  return v14;
}

uint64_t select_bet4_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;

  v8 = 2229280776;
  if ((safeh_HandleCheck(a1, a2, 25968, 10992) & 0x80000000) == 0)
  {
    *(_QWORD *)(a1 + 10936) = *(_QWORD *)(a1 + 56) + 128;
    if (ForcedEEController_SetProcessStart(*(uint64_t **)(a1 + 16), a1 + 10944))
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40)
                                                                                               + 64))(a3, a4, 78, "application/x-realspeak-cspp-sptchk;version=4.0",
        0,
        0,
        a1 + 512);
      (*(void (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40)
                                                                                               + 64))(a3, a4, 78, "application/x-realspeak-cspp-sgt;version=4.0",
        0,
        0,
        a1 + 528);
      v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-bet3-speech-frames;version=5.0",
              0,
              1,
              a1 + 256);
      if ((v12 & 0x80000000) == 0)
      {
        v17 = *(_QWORD *)(a1 + 40);
        v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t))(v17 + 64);
        v19 = (*(uint64_t (**)(void))(v17 + 152))();
        v12 = v18(a3, a4, 78, "application/x-realspeak-markers-pp;version=4.0", v19, 1, a1 + 272);
        if ((v12 & 0x80000000) == 0)
        {
          v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-bandpass-filter;version=4.0",
                  0,
                  1,
                  a1 + 240);
          if ((v12 & 0x80000000) == 0)
          {
            v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-psola-f0begin;version=4.0",
                    0,
                    1,
                    a1 + 400);
            if ((v12 & 0x80000000) == 0)
            {
              v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-psola-f0end;version=4.0",
                      0,
                      1,
                      a1 + 416);
              if ((v12 & 0x80000000) == 0)
              {
                v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-psola-duration;version=4.0",
                        0,
                        1,
                        a1 + 432);
                if ((v12 & 0x80000000) == 0)
                {
                  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-psola-maxfade-l;version=4.0",
                          0,
                          1,
                          a1 + 448);
                  if ((v12 & 0x80000000) == 0)
                  {
                    v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-psola-maxfade-r;version=4.0",
                            0,
                            1,
                            a1 + 464);
                    if ((v12 & 0x80000000) == 0)
                    {
                      v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-psola-adjacent-l;version=4.0",
                              0,
                              1,
                              a1 + 480);
                      if ((v12 & 0x80000000) == 0)
                      {
                        v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-psola-adjacent-r;version=4.0",
                                0,
                                1,
                                a1 + 496);
                        if ((v12 & 0x80000000) == 0)
                        {
                          v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-usids;version=4.0",
                                  0,
                                  1,
                                  a1 + 288);
                          if ((v12 & 0x80000000) == 0)
                          {
                            v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-usoffsets;version=5.0",
                                    0,
                                    1,
                                    a1 + 304);
                            if ((v12 & 0x80000000) == 0)
                            {
                              v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-usdurs-32;version=5.0",
                                      0,
                                      1,
                                      a1 + 320);
                              if ((v12 & 0x80000000) == 0)
                              {
                                v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-stsids;version=4.0",
                                        0,
                                        1,
                                        a1 + 336);
                                if ((v12 & 0x80000000) == 0)
                                {
                                  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-usfrozen;version=4.0",
                                          0,
                                          0,
                                          a1 + 384) & 0x80000000) == 0)
                                    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Optional input stream %s opened", v20, v21, v22, (uint64_t)"application/x-realspeak-usfrozen;version=4.0");
                                  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-usnoreusebias;version=4.0",
                                          0,
                                          0,
                                          a1 + 352) & 0x80000000) == 0)
                                    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Optional input stream %s opened", v23, v24, v25, (uint64_t)"application/x-realspeak-usnoreusebias;version=4.0");
                                  v26 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 64))(a3, a4, 78, "application/x-realspeak-usprosodybias;version=4.0",
                                          0,
                                          0,
                                          a1 + 368);
                                  if ((v26 & 0x80000000) != 0)
                                  {
                                    v8 = 0;
                                  }
                                  else
                                  {
                                    v8 = v26;
                                    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Optional input stream %s opened", v27, v28, v29, (uint64_t)"application/x-realspeak-usprosodybias;version=4.0");
                                  }
                                  goto LABEL_26;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v8 = v12;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58004, (uint64_t)"%s%s", v13, v14, v15, v16, "contentType");
    }
    else
    {
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Forced early emission requires a clock external service", v9, v10, v11, v31);
      v8 = 2229280786;
    }
    select_bet4_ProcessEnd(a1, a2);
LABEL_26:
    *(_DWORD *)(*(_QWORD *)(a1 + 10936) + 8564) = select_bet4_UpdateEarlyEmission(*(_QWORD *)(a1 + 16));
  }
  return v8;
}

uint64_t select_bet4_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t inited;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  float v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v55;
  int v56;
  int v58;
  int v60;
  int v62;
  int v64;
  int v66;
  int v68;
  int v70;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int ProcessEnd;
  int v83;
  int v84;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t Process;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  unsigned int v104;
  uint64_t v105;
  const char *v106;
  uint64_t v107;
  int v108;
  unsigned int v109;
  unsigned int v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  unsigned int v114;
  int v115;
  unsigned int i;
  _DWORD *v117;
  uint64_t Stream;
  int v119;
  uint64_t v120;
  const float *v121;
  float32x2_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  _DWORD *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  int v148;
  uint64_t v149;
  int *v150;
  int v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  unsigned int v156;
  uint64_t v157;
  unsigned int v158;
  int v159;
  int v160;
  int v161;
  _DWORD *v162;
  int v163;
  double v164;
  uint64_t v165;
  unsigned int v166;
  uint64_t v167;
  uint64_t v168;
  int v169;
  uint64_t *v170;
  uint64_t v171;
  uint64_t v172;
  unsigned int v173;
  int v174;
  int *v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  unsigned int v181;
  unsigned int v182;
  int v183;
  BOOL v184;
  int v185;
  uint64_t v186;
  unsigned int v187;
  unsigned int v188;
  int v189;
  _DWORD *v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  unint64_t v194;
  uint64_t v195;
  int v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  int hasCharPtrArg;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  int v206;
  uint64_t v207;
  _DWORD *v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  unsigned int v217;
  unsigned int v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  unsigned int v224;
  uint64_t v225;
  uint64_t v226;
  int v227;
  _DWORD *v228;
  uint64_t v229;
  float v230;
  uint64_t v231;
  unsigned int *v232;
  unsigned int v233;
  unsigned int v234;
  uint64_t v235;
  _DWORD *v236;
  _DWORD *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  int v242;
  int v243;
  float v244;
  float v245;
  int v246;
  _DWORD *v247;
  _DWORD *v248;
  _DWORD *v249;
  int v250;
  uint64_t v251;
  _QWORD *v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  int v256;
  uint64_t v257;
  int v258;
  double v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  _DWORD *v301;
  uint64_t v302;
  _DWORD *v303;
  _DWORD *v304;
  _DWORD *v305;
  _DWORD *v306;
  _DWORD *v307;
  _DWORD *v308;
  _DWORD *v309;
  uint64_t v310;
  _DWORD *v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  unsigned int v334;
  int *v335;
  int v336;
  uint64_t v338;
  int v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  int v345;
  uint64_t v346;
  int v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  _DWORD *v358;
  int v359;
  int *v360;
  int *v361;
  _DWORD *v362;
  _DWORD *v363;
  _DWORD *v364;
  _DWORD *v365;
  _DWORD *v366;
  _DWORD *v367;
  _DWORD *v368;
  int v369;
  uint64_t v370;
  uint64_t v371;
  _QWORD v372[2];

  v369 = 0;
  if ((safeh_HandleCheck(a1, a2, 25968, 10992) & 0x80000000) != 0)
    return 2229280776;
  *a5 = 1;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Entering select_bet4_Process function", v9, v10, v11, v351);
  v15 = (unsigned int *)(a1 + 4200);
  v16 = *(_DWORD *)(a1 + 10880);
  if (!*(_QWORD *)(a1 + 6128))
  {
    if (!v16)
      goto LABEL_19;
    goto LABEL_14;
  }
  if (v16)
  {
LABEL_14:
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Finally deinitialising stream", v12, v13, v14, v352);
    critsec_Enter(*(_QWORD **)(a1 + 32));
    v25 = *(_QWORD *)(a1 + 16);
    v26 = *(_QWORD *)(a1 + 56);
    v27 = mfs_GetTimeStamp() - *(_DWORD *)(a1 + 6812);
    log_OutText(*(_QWORD *)(v25 + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"For early emission timing estimate, utterance consisted of %d ms, computation time was %d ms", v28, v29, v30, *(unsigned int *)(a1 + 6804));
    v34 = *(_DWORD *)(a1 + 6804);
    v35 = *(_QWORD *)(v26 + 37640);
    v36 = *(unsigned int *)(v35 + 6408);
    *(_DWORD *)(v35 + 6400) += v34 - *(_DWORD *)(v35 + 4 * v36);
    *(_DWORD *)(v35 + 4 * v36) = v34;
    v37 = v35 + 4 * *(unsigned int *)(v35 + 6408);
    *(_DWORD *)(v35 + 6404) += v27 - *(_DWORD *)(v37 + 3200);
    *(_DWORD *)(v37 + 3200) = v27;
    v38 = (*(_DWORD *)(v35 + 6408) + 1) % 0x320u;
    *(_DWORD *)(v35 + 6408) = v38;
    v39 = *(float *)(v35 + 6412);
    if (v39 != 0.0 || v38 >= 0x32)
    {
      v40 = *(_DWORD *)(v35 + 6404);
      if (v40)
      {
        v39 = (double)*(int *)(v35 + 6400) / (double)v40;
        *(float *)(v35 + 6412) = v39;
      }
    }
    log_OutText(*(_QWORD *)(v25 + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Current search-xRT estimate for early emission is %.4f", v31, v32, v33, COERCE__INT64(v39));
    critsec_Leave(*(_QWORD **)(a1 + 32));
    mfs_DeInitStream((unsigned int *)(a1 + 4200));
    *(_DWORD *)(a1 + 10880) = 0;
LABEL_19:
    *(_DWORD *)(a1 + 10916) = 0;
    v41 = a1 + 544;
    inited = MFS__select_bet3_FeatureExtractProcessStart(*(uint64_t **)(a1 + 224), *(_QWORD *)(a1 + 56) + 37888, a3, a4, (_QWORD *)(a1 + 544), &v369);
    if ((inited & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58005, (uint64_t)"%s%x", v42, v43, v44, v45, "lhError");
      return inited;
    }
    if (*(__int16 *)(a1 + 554) <= 1)
    {
      v46 = v369;
      if (v369)
      {
        v47 = *(_QWORD *)(a1 + 256);
        if (v47)
        {
          LODWORD(inited) = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v47, *(_QWORD *)(a1 + 264));
          *(_QWORD *)(a1 + 256) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 264) = v48;
        }
        if (*(_QWORD *)(a1 + 272))
        {
          if (*(_DWORD *)(a1 + 4064))
          {
            LODWORD(inited) = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 104))();
            if ((inited & 0x80000000) != 0)
              log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v49, v50, v51, v52, "contentType");
          }
          v53 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(*(_QWORD *)(a1 + 272), *(_QWORD *)(a1 + 280));
          if ((int)inited > -1 && v53 < 0)
            v55 = v53;
          else
            v55 = inited;
          v56 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(*(_QWORD *)(a1 + 288), *(_QWORD *)(a1 + 296));
          if (v55 > -1 && v56 < 0)
            v55 = v56;
          v58 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(*(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 408));
          if (v55 > -1 && v58 < 0)
            v55 = v58;
          v60 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(*(_QWORD *)(a1 + 416), *(_QWORD *)(a1 + 424));
          if (v55 > -1 && v60 < 0)
            v55 = v60;
          v62 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(*(_QWORD *)(a1 + 432), *(_QWORD *)(a1 + 440));
          if (v55 > -1 && v62 < 0)
            v55 = v62;
          v64 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(*(_QWORD *)(a1 + 448), *(_QWORD *)(a1 + 456));
          if (v55 > -1 && v64 < 0)
            v55 = v64;
          v66 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(*(_QWORD *)(a1 + 464), *(_QWORD *)(a1 + 472));
          if (v55 > -1 && v66 < 0)
            v55 = v66;
          v68 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(*(_QWORD *)(a1 + 480), *(_QWORD *)(a1 + 488));
          if (v55 > -1 && v68 < 0)
            v55 = v68;
          v70 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(*(_QWORD *)(a1 + 496), *(_QWORD *)(a1 + 504));
          if (v55 > -1 && v70 < 0)
            LODWORD(inited) = v70;
          else
            LODWORD(inited) = v55;
          *(_QWORD *)(a1 + 400) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 408) = v72;
          *(_QWORD *)(a1 + 416) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 424) = v73;
          *(_QWORD *)(a1 + 432) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 440) = v74;
          *(_QWORD *)(a1 + 448) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 456) = v75;
          *(_QWORD *)(a1 + 464) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 472) = v76;
          *(_QWORD *)(a1 + 480) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 488) = v77;
          *(_QWORD *)(a1 + 496) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 504) = v78;
          *(_QWORD *)(a1 + 272) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 280) = v79;
          *(_QWORD *)(a1 + 288) = safeh_GetNullHandle();
          *(_QWORD *)(a1 + 296) = v80;
        }
        v46 = 1;
      }
      *a5 = v46;
      ProcessEnd = MFS__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 224), (_QWORD *)(a1 + 544));
      if ((int)inited > -1 && ProcessEnd < 0)
        v83 = ProcessEnd;
      else
        v83 = inited;
      v84 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 48) + 64))(a3, a4);
      if (v83 > -1 && v84 < 0)
        return v84;
      else
        return v83;
    }
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Features have been extracted", v43, v44, v45, v352);
    *(_DWORD *)(a1 + 10900) = 0;
    inited = mfs_InitStream(*(_QWORD *)(a1 + 16), (void *)(a1 + 4200), *(_DWORD **)(a1 + 10936));
    critsec_Enter(*(_QWORD **)(a1 + 32));
    *(_DWORD *)(a1 + 6816) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 37640) + 6412);
    critsec_Leave(*(_QWORD **)(a1 + 32));
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Stream initialised for the first time", v86, v87, v88, v353);
    if ((inited & 0x80000000) == 0)
    {
      cstdlib_memcpy((void *)(a1 + 6488), (const void *)(a1 + 64), 0xA0uLL);
      Process = MFS__select_bet3_FeatureExtractProcess(*(uint64_t **)(a1 + 224), *(_QWORD *)(a1 + 10936), a3, a4, *(_QWORD *)(a1 + 512), *(_QWORD *)(a1 + 520), *(_QWORD *)(a1 + 528), *(_QWORD *)(a1 + 536), (unsigned int *)(a1 + 232), a1 + 544, (uint64_t *)(a1 + 10888), (_DWORD *)(a1 + 10896));
      if ((Process & 0x80000000) != 0)
      {
        inited = Process;
      }
      else if (*(__int16 *)(a1 + 554) < 1)
      {
        inited = 0;
      }
      else
      {
        v93 = 0;
        v94 = *(_QWORD *)(a1 + 56);
        v95 = v94 + 66288;
        v96 = v94 + 37888;
        do
        {
          if (*(_DWORD *)(v95 + 8))
          {
            v97 = 0;
            v98 = 0;
            do
            {
              if (featex_bet5_loc_TransRulesMatch(v96, *(_QWORD *)v95, a1 + 544, (__int16)v93, v98))
              {
                v99 = *(_QWORD *)v95 + v97;
                v100 = *(unsigned __int8 *)(v99 + 7) + v93 * *(unsigned __int16 *)(*(_QWORD *)(a1 + 544) + 3360);
                *(_DWORD *)(*(_QWORD *)(a1 + 4128) + 4 * v100) = (float)((float)(*(float *)(v99 + 8)
                                                                                               * (float)*(unsigned int *)(*(_QWORD *)(a1 + 4128) + 4 * v100))
                                                                                       + 0.5);
              }
              ++v98;
              v97 += 12;
            }
            while (v98 < *(unsigned int *)(v95 + 8));
          }
          if (*(_DWORD *)(v95 + 24))
          {
            v101 = 0;
            v102 = 0;
            do
            {
              if (featex_bet5_loc_TransRulesMatch(v96, *(_QWORD *)(v95 + 16), a1 + 544, (__int16)v93, v102))
              {
                v103 = *(_QWORD *)(v95 + 16) + v101;
                v104 = *(unsigned __int8 *)(v103 + 7) + v93 * *(unsigned __int16 *)(*(_QWORD *)(a1 + 544) + 3360);
                *(_DWORD *)(*(_QWORD *)(a1 + 4136) + 4 * v104) = (float)((float)(*(float *)(v103 + 8)
                                                                                               * (float)*(unsigned int *)(*(_QWORD *)(a1 + 4136) + 4 * v104))
                                                                                       + 0.5);
              }
              ++v102;
              v101 += 12;
            }
            while (v102 < *(unsigned int *)(v95 + 24));
          }
          ++v93;
        }
        while (v93 < *(__int16 *)(a1 + 554));
        inited = 0;
      }
    }
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Feature extraction successful", v89, v90, v91, v354);
    *(_DWORD *)(a1 + 10916) = 0;
    *(_DWORD *)(a1 + 10896) = 0;
    v107 = *(_QWORD *)(a1 + 6840);
    if (v107)
    {
      FreeBET4TuningData((_QWORD *)a1, v107);
      *(_QWORD *)(a1 + 6840) = 0;
    }
    if ((inited & 0x80000000) != 0)
      goto LABEL_324;
    v371 = 0;
    v372[0] = 0;
    v370 = 0;
    LODWORD(v368) = 0;
    v108 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, _DWORD **))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 384), *(_QWORD *)(a1 + 392), v372, &v368);
    v109 = v368;
    if (v108 < 0 || !(_DWORD)v368)
      v372[0] = 0;
    v110 = v368 >> 2;
    LODWORD(v368) = 0;
    if (((*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, _DWORD **))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 352), *(_QWORD *)(a1 + 360), &v371, &v368) & 0x80000000) != 0|| !(_DWORD)v368)
    {
      v371 = 0;
    }
    else if (v109 >= 4)
    {
      if (v368 / 0x1F8 != v110)
        goto LABEL_315;
    }
    else
    {
      v110 = v368 / 0x1F8;
    }
    LODWORD(v368) = 0;
    if (((*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, _DWORD **))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 368), *(_QWORD *)(a1 + 376), &v370, &v368) & 0x80000000) != 0|| !(_DWORD)v368)
    {
      v370 = 0;
      if (!v110)
      {
LABEL_133:
        v115 = *(__int16 *)(a1 + 4068);
        if (v115 < 1)
        {
          i = 0;
        }
        else
        {
          for (i = 0; i < v115; i = (unsigned __int16)(i + 1))
          {
            if (*(_DWORD *)(*(_QWORD *)(a1 + 4152) + 4 * i) != -1)
              break;
          }
        }
        if (i == v115)
          goto LABEL_315;
        v110 = *(unsigned __int16 *)(a1 + 4068);
      }
    }
    else
    {
      v114 = v368 >> 3;
      if (v110)
      {
        if (v114 != (unsigned __int16)v110)
          goto LABEL_315;
        goto LABEL_273;
      }
      v110 = v368 >> 3;
      if (!v114)
        goto LABEL_133;
    }
LABEL_273:
    v220 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), 1, 24);
    v221 = v220;
    if (!v220)
      goto LABEL_316;
    *(_DWORD *)(v220 + 8) = v110;
    v222 = v110;
    v223 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v110, 48);
    *(_QWORD *)v221 = v223;
    if (v223)
    {
      v361 = a5;
      v224 = -1;
      if (v110)
      {
        v225 = 0;
        while (1)
        {
          v226 = v225;
          *(_BYTE *)(v223 + 48 * v225 + 28) = 0;
          if (!v371)
            break;
          v227 = *(_DWORD *)(v371 + 504 * v225);
          if (!v227)
            break;
          v228 = (_DWORD *)(*(_QWORD *)v221 + 48 * v226);
          *v228 = 1;
          v228[6] = v227;
          v229 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), (v227 + 1), 4);
          v223 = *(_QWORD *)v221;
          *(_QWORD *)(*(_QWORD *)v221 + 48 * v226 + 8) = v229;
          if (!v229)
            goto LABEL_326;
          v231 = v223 + 48 * v226;
          LODWORD(v368) = 0;
          v234 = *(_DWORD *)(v231 + 24);
          v232 = (unsigned int *)(v231 + 24);
          v233 = v234;
          if (v234)
          {
            v233 = 0;
            v235 = v371;
            do
            {
              *(_DWORD *)(v229 + 4 * v233) = *(_DWORD *)(v235 + 504 * v226 + 4 * v233 + 4);
              v233 = (_DWORD)v368 + 1;
              LODWORD(v368) = v233;
            }
            while (v233 < *v232);
          }
          v236 = (_DWORD *)(v229 + 4 * v233);
LABEL_293:
          *v236 = -1;
          v240 = v370;
          if (!v370)
            goto LABEL_305;
          v241 = v370 + 8 * v226;
          v242 = *(unsigned __int8 *)(v241 + 6);
          v243 = *(unsigned __int8 *)(v241 + 4);
          if (!(v242 | v243))
            goto LABEL_305;
          if (v243 == 1)
          {
            v244 = 2.5;
          }
          else
          {
            if (v243 != 2)
              goto LABEL_300;
            v244 = -2.5;
          }
          *(_DWORD *)(v221 + 16) = 1;
          LOBYTE(v230) = *(_BYTE *)(v240 + 8 * v226 + 5);
          v230 = (float)LODWORD(v230) / 100.0;
          *(float *)(v223 + 48 * v226 + 20) = v244 * v230;
LABEL_300:
          if (v242 == 1)
          {
            v245 = 2.5;
            goto LABEL_304;
          }
          if (v242 == 2)
          {
            v245 = -2.5;
LABEL_304:
            *(_DWORD *)(v221 + 12) = 1;
            LOBYTE(v230) = *(_BYTE *)(v240 + 8 * v226 + 7);
            *(float *)(v223 + 48 * v226 + 16) = v245 * (float)((float)LODWORD(v230) / 100.0);
          }
LABEL_305:
          v225 = v226 + 1;
          if (v226 + 1 == v222)
          {
            v224 = v226;
            v15 = (unsigned int *)(a1 + 4200);
            goto LABEL_307;
          }
        }
        v237 = (_DWORD *)heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), 2, 4);
        v223 = *(_QWORD *)v221;
        *(_QWORD *)(*(_QWORD *)v221 + 48 * v226 + 8) = v237;
        if (!v237)
        {
LABEL_326:
          FreeBET4TuningData((_QWORD *)a1, v221);
          v221 = 0;
          a5 = v361;
          v15 = (unsigned int *)(a1 + 4200);
          goto LABEL_316;
        }
        *(_DWORD *)(v223 + 48 * v226 + 24) = 1;
        if (!v372[0] || *(_DWORD *)(v372[0] + 4 * v226) == -1)
        {
          if (*(_DWORD *)(*(_QWORD *)(a1 + 4152) + 4 * v226) == -1)
          {
            *(_DWORD *)(v223 + 48 * v226) = 2;
            *v237 = 0;
            goto LABEL_292;
          }
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 5, 0, (uint64_t)"%s: %u", v111, v112, v113, (uint64_t)"Locked unit");
          v223 = *(_QWORD *)v221;
          v238 = *(_QWORD *)v221 + 48 * v226;
          *(_DWORD *)v238 = 0;
          v239 = *(_QWORD *)(a1 + 4152);
        }
        else
        {
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 5, 0, (uint64_t)"%s: %u", v111, v112, v113, (uint64_t)"Locked unit");
          v223 = *(_QWORD *)v221;
          v238 = *(_QWORD *)v221 + 48 * v226;
          *(_DWORD *)v238 = 0;
          v239 = v372[0];
        }
        v237 = *(_DWORD **)(v238 + 8);
        *v237 = *(_DWORD *)(v239 + 4 * v226);
LABEL_292:
        v236 = v237 + 1;
        goto LABEL_293;
      }
LABEL_307:
      *(_DWORD *)(v223 + 48 * v224) = 4;
      v246 = *(_DWORD *)(v221 + 12);
      if (v246 || *(_DWORD *)(v221 + 16))
      {
        a5 = v361;
        if (!*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 8328))
        {
          v247 = (_DWORD *)heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), 1, 25296);
          if (v247)
          {
            v248 = v247;
            v249 = v247 + 6286;
            cstdlib_memcpy(v247, (const void *)(*(_QWORD *)(a1 + 56) + 128), 0x62D0uLL);
            v248[2062] = *v249;
            v250 = v249[3];
            v248[2040] = v249[2];
            v248[2045] = v250;
            *((_QWORD *)v248 + 1028) = *((_QWORD *)v248 + 3145);
            v248[2060] = v249[6];
            if (v246)
              v248[2000] = v249[1];
            *(_QWORD *)(a1 + 10936) = v248;
          }
        }
      }
      else
      {
        a5 = v361;
      }
LABEL_316:
      *(_QWORD *)(a1 + 6840) = v221;
      v251 = *(_QWORD *)(a1 + 16);
      if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 8560) == 1)
      {
        log_OutText(*(_QWORD *)(v251 + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Chunking suppressed therefore features will not be chunked", v111, v112, v113, v355);
        *(_DWORD *)(a1 + 10912) = 1;
        v252 = (_QWORD *)heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), 1, 8);
        *(_QWORD *)(a1 + 10920) = v252;
        if (v252)
        {
          inited = 0;
          *v252 = v41;
LABEL_322:
          v256 = 4;
LABEL_426:
          *a5 = v256;
          return inited;
        }
        inited = 2229280778;
      }
      else
      {
        inited = mfs_SplitFeatures(v251, a1 + 544, (uint64_t *)(a1 + 10920), (unsigned int *)(a1 + 10912));
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Number of feature objects after chunking is %d", v253, v254, v255, *(unsigned int *)(a1 + 10912));
        if (*(_DWORD *)(a1 + 10912) == 1)
          **(_QWORD **)(a1 + 10920) = v41;
        if ((inited & 0x80000000) == 0)
          goto LABEL_322;
      }
LABEL_324:
      mfs_DeInitStream(v15);
      return inited;
    }
    FreeBET4TuningData((_QWORD *)a1, v221);
LABEL_315:
    v221 = 0;
    goto LABEL_316;
  }
  if (!*(_DWORD *)(a1 + 10916))
  {
    if (*(_DWORD *)(a1 + 6792))
    {
      v105 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
      v106 = "u32SplitFeatIdx is 0, restart after early emission";
    }
    else if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 8564) == 1)
    {
      v105 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
      v106 = "u32SplitFeatIdx is 0, early emission first entry";
    }
    else
    {
      *(_DWORD *)(a1 + 6792) = 2;
      v105 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
      v106 = "u32SplitFeatIdx is 0, regular emission selected";
    }
    log_OutText(v105, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v106, v12, v13, v14, v352);
    goto LABEL_143;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 8328) && *(_DWORD *)(a1 + 6792) == 1)
  {
LABEL_143:
    inited = 0;
    goto LABEL_144;
  }
  v17 = *(_QWORD *)(a1 + 6840);
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Reinitialising stream for chunked input", v12, v13, v14, v352);
  v18 = *(_QWORD *)(a1 + 6840);
  if (v18)
    *(_DWORD *)(v18 + 20) += (*(__int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 10920)
                                                     + 8 * (*(_DWORD *)(a1 + 10916) - 1))
                                         + 10)
                            - 1)
                           * *(_DWORD *)(*(_QWORD *)(a1 + 56) + 25424);
  mfs_DeInitStream((unsigned int *)(a1 + 4200));
  inited = mfs_InitStream(*(_QWORD *)(a1 + 16), (void *)(a1 + 4200), *(_DWORD **)(a1 + 10936));
  *(_QWORD *)(a1 + 6840) = v17;
  if ((inited & 0x80000000) == 0)
  {
    v23 = *(_QWORD *)(a1 + 10936);
    if (*(_DWORD *)(v23 + 8328))
      v24 = 2 * (*(_DWORD *)(v23 + 8564) == 0);
    else
      v24 = 2;
    *(_DWORD *)(a1 + 6792) = v24;
    cstdlib_memcpy((void *)(a1 + 6488), (const void *)(a1 + 64), 0xA0uLL);
  }
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"u32SplitFeatIdx is %d, stream reinitialised for reuse", v19, v20, v21, *(unsigned int *)(a1 + 10916));
LABEL_144:
  v117 = (_DWORD *)(a1 + 10880);
  if (*(_DWORD *)(a1 + 6792) != 1)
  {
    Stream = mfs_LoadStream(a1 + 4200, *(_QWORD *)(a1 + 56) + 25424, *(_QWORD *)(a1 + 10936));
    *(_QWORD *)(a1 + 4208) = *(_QWORD *)(*(_QWORD *)(a1 + 10920) + 8 * *(unsigned int *)(a1 + 10916));
    if ((Stream & 0x80000000) != 0)
    {
      inited = Stream;
      goto LABEL_160;
    }
    inited = mfs_ParamGenStart(a1 + 4200, (int *)(*(_QWORD *)(a1 + 56) + 25424), *(_DWORD **)(a1 + 10936));
  }
  if ((inited & 0x80000000) == 0)
  {
    v119 = *(_DWORD *)(a1 + 6792);
    v120 = *(unsigned int *)(a1 + 4232);
    if ((int)v120 >= 1)
    {
      v121 = (const float *)(*(_QWORD *)(a1 + 4224) + 8);
      do
      {
        v122 = vld1_dup_f32(v121);
        *((float32x2_t *)v121 - 1) = v122;
        v121 += 382;
        --v120;
      }
      while (v120);
    }
    v123 = *(_QWORD *)(a1 + 10936);
    if (*(_DWORD *)(v123 + 8328))
      v124 = mfs_StatisticalSelection_Obersee(a1 + 4200, a1 + 10944, (int *)(*(_QWORD *)(a1 + 56) + 25424), v123);
    else
      v124 = mfs_StatisticalSelection(a1 + 4200, (unsigned int *)(*(_QWORD *)(a1 + 56) + 25424), *(_QWORD *)(a1 + 10936));
    inited = v124;
    v128 = *(unsigned int *)(a1 + 4232);
    if ((int)v128 >= 1)
    {
      v129 = (_DWORD *)(*(_QWORD *)(a1 + 4224) + 8);
      do
      {
        *v129 = *(v129 - 2);
        v129 += 382;
        --v128;
      }
      while (v128);
    }
    if ((v124 & 0x80000000) == 0)
      goto LABEL_162;
    goto LABEL_161;
  }
LABEL_160:
  v119 = 0;
LABEL_161:
  MFS__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 224), (_QWORD *)(a1 + 544));
LABEL_162:
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Ready to synthesize", v125, v126, v127, v352);
  if ((inited & 0x80000000) == 0)
    inited = mfs_ParamGen(a1 + 4200, (int *)(*(_QWORD *)(a1 + 56) + 25424), *(_QWORD *)(a1 + 10936), (_DWORD *)(a1 + 10880));
  if (*(_DWORD *)(a1 + 6792))
  {
    v133 = 0;
  }
  else if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 8328) == 1)
  {
    v133 = *(_DWORD *)(a1 + 6784) / *(_DWORD *)(*(_QWORD *)(a1 + 56) + 25424);
  }
  else
  {
    v359 = v119;
    if (*(_DWORD *)(a1 + 6472) < 2u)
    {
      LODWORD(v135) = 1;
    }
    else
    {
      v134 = 0;
      v135 = 1;
      do
      {
        if (v134)
        {
          if (*(_DWORD *)(*(_QWORD *)(a1 + 6464) + v134 + 28) == -1)
            break;
          v136 = v135;
        }
        else
        {
          v136 = 1;
        }
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Potential early-emission segment # %d has %d states, starts with unit %d, is %d ms", v130, v131, v132, v136);
        ++v135;
        v134 += 28;
      }
      while (v135 < *(unsigned int *)(a1 + 6472));
    }
    v137 = v135;
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Early emission target is %d ms\n", v130, v131, v132, *(unsigned int *)(a1 + 6808));
    v141 = 0;
    v142 = 0;
    v143 = 12;
    while (v142 < *(_DWORD *)(a1 + 6808))
    {
      v142 += *(_DWORD *)(*(_QWORD *)(a1 + 6464) + v143);
      ++v141;
      v143 += 28;
      if (v137 == v141)
        goto LABEL_182;
    }
    v137 = v141;
LABEL_182:
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"To satisfy early emission requirement, %d segments will be emitted", v138, v139, v140, v137);
    v147 = *(_QWORD *)(a1 + 6464);
    v148 = 0;
    if ((_DWORD)v137)
    {
      v149 = v137;
      v150 = (int *)(v147 + 16);
      do
      {
        v151 = *v150;
        v150 += 7;
        v148 += v151;
        --v149;
      }
      while (v149);
    }
    *(_DWORD *)(a1 + 6836) = v148 - 1;
    v152 = (*(_DWORD *)(v147 + 28 * (v137 - 1))
                        + *(_DWORD *)(v147 + 28 * (v137 - 1) + 16)
                        - 1);
    *(_DWORD *)(a1 + 6832) = v152;
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Subsequent emission will be forced to have unit %d at time index %d\n", v144, v145, v146, v152);
    *(_DWORD *)(a1 + 6800) = v137;
    v133 = v148 / *(_DWORD *)(*(_QWORD *)(a1 + 56) + 25424);
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Early emission will consist of %d segments (including silence) for a total of %d ms\n", v153, v154, v155, v137);
    v119 = v359;
  }
  v156 = *(_DWORD *)(a1 + 6472);
  if (!v156)
    goto LABEL_191;
  v157 = *(_QWORD *)(a1 + 10936);
  if (!*(_DWORD *)(v157 + 8328))
  {
    v158 = *(_DWORD *)(a1 + 6792);
    if (!v158)
      goto LABEL_198;
  }
  v159 = *(_DWORD *)(a1 + 10912);
  v160 = v159 - 1;
  if (v159 == 1)
  {
    v156 = 0;
LABEL_191:
    v158 = 0;
    goto LABEL_199;
  }
  v161 = *(_DWORD *)(a1 + 10916);
  if (v161 && (v162 = *(_DWORD **)(a1 + 6464), *v162 == -1))
  {
    v163 = v162[3];
    v164 = (double)v163 * 0.4;
    v162[3] = (int)v164;
    v158 = (v163 - (int)v164) / *(_DWORD *)(v157 + 24);
  }
  else
  {
    v158 = 0;
  }
  if (v161 != v160 && (v165 = *(_QWORD *)(a1 + 6464), v166 = v156 - 1, *(_DWORD *)(v165 + 28 * v166) == -1))
  {
    v257 = v165 + 28 * v166;
    v258 = *(_DWORD *)(v257 + 12);
    v259 = (double)v258 * 0.4;
    *(_DWORD *)(v257 + 12) = (int)v259;
    v156 = (v258 - (int)v259) / *(_DWORD *)(v157 + 24);
  }
  else
  {
LABEL_198:
    v156 = 0;
  }
LABEL_199:
  if (v119 != 1)
  {
    v167 = *(unsigned int *)(a1 + 10916);
    v168 = *(_QWORD *)(*(_QWORD *)(a1 + 10920) + 8 * v167);
    v169 = *(_DWORD *)(v168 + 3520) + *(__int16 *)(v168 + 10) + *(_DWORD *)(a1 + 10896);
    *(_DWORD *)(a1 + 10896) = v169;
    if ((_DWORD)v167)
    {
      if (*(_DWORD *)(a1 + 10912) != 1)
        *(_DWORD *)(a1 + 10896) = v169 - 1;
    }
  }
  if ((inited & 0x80000000) != 0)
    goto LABEL_425;
  v170 = (uint64_t *)(a1 + 10888);
  v171 = *(_QWORD *)(a1 + 10888);
  if (v171)
  {
    v172 = *(unsigned int *)(a1 + 10900);
    v173 = *(_DWORD *)(a1 + 10896);
    v174 = *(_DWORD *)(a1 + 6792);
    if (v173 > v172)
    {
      v175 = (int *)(v171 + 32 * v172);
      v176 = v133;
      if (v174)
        v176 = *(_DWORD *)(a1 + 4808);
      v177 = *(_DWORD *)(a1 + 4816);
      if (v177 < v176)
      {
        v178 = 0;
        v179 = *(_DWORD *)(a1 + 10908);
        while (1)
        {
          v180 = *v175;
          v175[3] = v179;
          if (v180 != 33)
          {
            v175[4] = 0;
            goto LABEL_223;
          }
          v181 = *(_DWORD *)(*(_QWORD *)(a1 + 4800) + 528 * v177 + 24);
          v175[4] = v181;
          if (v175[6] == 35)
          {
            if (!v158 || v177)
            {
              if (!v156)
                goto LABEL_222;
              v183 = *(_DWORD *)(a1 + 4808);
              v184 = __OFSUB__(v183, 1);
              v185 = v183 - 1;
              if (v185 < 0 != v184 || v177 != v185)
                goto LABEL_222;
              if (v177)
              {
                v182 = v156;
                if (v181 <= v156)
                  goto LABEL_222;
LABEL_215:
                v181 -= v182;
                v175[4] = v181;
                goto LABEL_222;
              }
            }
            v182 = v158;
            if (v181 > v158)
              goto LABEL_215;
          }
LABEL_222:
          v179 += v181;
          *(_DWORD *)(a1 + 10908) = v179;
          *(_DWORD *)(a1 + 4816) = ++v177;
LABEL_223:
          v175 += 8;
          v186 = (v178 + 1);
          if (v177 < v176)
          {
            v187 = v172 + 1 + v178++;
            if (v187 < v173)
              continue;
          }
          goto LABEL_228;
        }
      }
      v186 = 0;
LABEL_228:
      if (v174 || v133 == *(_DWORD *)(a1 + 4808))
      {
        if (*v117)
        {
          v188 = v186 + v172;
          if ((int)v186 + (int)v172 < v173)
          {
            v189 = *(_DWORD *)(a1 + 10908);
            v190 = v175 + 4;
            do
            {
              *(v190 - 1) = v189;
              *v190 = 0;
              v190 += 8;
              ++v188;
            }
            while (v188 < v173);
            v186 = v173 - v172;
          }
        }
      }
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"About to write %d markers, starting with index %d", v130, v131, v132, v186);
      v194 = *(unsigned int *)(a1 + 10900);
      if (v194 < (int)v194 + (int)v186)
      {
        v360 = a5;
        v195 = 32 * v194;
        do
        {
          v196 = *(_DWORD *)(*v170 + v195);
          if (v196 == 0x4000)
          {
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Outputting marker with index %4d:tag=%d Value=?some pointer? posCur=%d lenCur=%d", v191, v192, v193, v194);
          }
          else
          {
            hasCharPtrArg = marker_hasCharPtrArg(v196);
            v201 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
            if (hasCharPtrArg)
              log_OutText(v201, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Outputting marker with index %4d:tag=%d szValue=%s posCur=%d lenCur=%d", v197, v198, v199, v194);
            else
              log_OutText(v201, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Outputting marker with index %4d:tag=%d u32Value=%d posCur=%d lenCur=%d", v197, v198, v199, v194);
          }
          if (*(_DWORD *)(*v170 + v195) == 33)
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Marker was a PHONEME_MARKER with symbol %c", v191, v192, v193, *(unsigned int *)(*v170 + v195 + 24));
          ++v194;
          v195 += 32;
        }
        while (v194 < (*(_DWORD *)(a1 + 10900) + v186));
        LODWORD(v194) = *(_DWORD *)(a1 + 10900);
        a5 = v360;
        v117 = (_DWORD *)(a1 + 10880);
      }
      if ((_DWORD)v186)
      {
        inited = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 104))(*(_QWORD *)(a1 + 272), *(_QWORD *)(a1 + 280), *(_QWORD *)(a1 + 10888) + 32 * v194, (32 * v186));
        if ((inited & 0x80000000) != 0)
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v202, v203, v204, v205, "contentType");
      }
      v206 = *(_DWORD *)(a1 + 10900) + v186;
      *(_DWORD *)(a1 + 10900) = v206;
      v174 = *(_DWORD *)(a1 + 6792);
      if (v174)
      {
        v15 = (unsigned int *)(a1 + 4200);
        if (*(_DWORD *)(a1 + 10912) != 1)
          *(_DWORD *)(a1 + 10900) = v206 - 1;
      }
      else
      {
        v15 = (unsigned int *)(a1 + 4200);
      }
    }
  }
  else
  {
    v174 = *(_DWORD *)(a1 + 6792);
  }
  if (v174 != 1 && (inited & 0x80000000) == 0)
  {
    v372[0] = v15;
    v207 = *(unsigned int *)(a1 + 4232);
    if ((int)v207 >= 1)
    {
      v208 = *(_DWORD **)(a1 + 4224);
      do
      {
        *v208 = 0;
        v208 += 382;
        --v207;
      }
      while (v207);
    }
    inited = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)(a1 + 40) + 104))(*(_QWORD *)(a1 + 256), *(_QWORD *)(a1 + 264), v372, 8);
    if ((inited & 0x80000000) != 0)
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v209, v210, v211, v212, "contentType");
  }
  if ((inited & 0x80000000) != 0)
    goto LABEL_425;
  inited = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 104))(*(_QWORD *)(a1 + 240), *(_QWORD *)(a1 + 248), *(_QWORD *)(a1 + 10936) + 8348, 4);
  if ((inited & 0x80000000) != 0)
  {
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_424:
    log_OutPublic(v219, (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v213, v214, v215, v216, "contentType");
    goto LABEL_425;
  }
  if (!*v117)
    goto LABEL_425;
  v371 = 0;
  v372[0] = 0;
  v370 = 0;
  v367 = 0;
  v368 = 0;
  v365 = 0;
  v366 = 0;
  v363 = 0;
  v364 = 0;
  v362 = 0;
  v358 = v117;
  if (v119 == 2)
    goto LABEL_268;
  if (v119 != 1)
  {
    if (v119)
    {
      v218 = 0;
    }
    else
    {
      if (*(_DWORD *)(a1 + 6792) == 2)
      {
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Early emission was countermanded, regular emission took place instead", v214, v215, v216, v356);
LABEL_268:
        v217 = 0;
        v218 = *(_DWORD *)(a1 + 6472);
        goto LABEL_332;
      }
      v217 = *(_DWORD *)(a1 + 6800);
      if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 8328))
        goto LABEL_331;
      v218 = *(_DWORD *)(a1 + 6800);
    }
    v217 = 0;
    goto LABEL_332;
  }
  v217 = *(_DWORD *)(a1 + 6800);
LABEL_331:
  v218 = *(_DWORD *)(a1 + 6472) - v217;
LABEL_332:
  v260 = 4 * v218;
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v261 = v260;
  else
    v261 = 4;
  if (((*(uint64_t (**)(_QWORD, _QWORD, _DWORD **, uint64_t))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 408), &v368, v261) & 0x80000000) != 0)log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v262, v263, v264, v265, "contentType");
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v266 = v260;
  else
    v266 = 4;
  if (((*(uint64_t (**)(_QWORD, _QWORD, _DWORD **, uint64_t))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 416), *(_QWORD *)(a1 + 424), &v367, v266) & 0x80000000) != 0)log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v267, v268, v269, v270, "contentType");
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v271 = v260;
  else
    v271 = 4;
  if (((*(uint64_t (**)(_QWORD, _QWORD, _DWORD **, uint64_t))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 432), *(_QWORD *)(a1 + 440), &v366, v271) & 0x80000000) != 0)log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v272, v273, v274, v275, "contentType");
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v276 = v260;
  else
    v276 = 4;
  if (((*(uint64_t (**)(_QWORD, _QWORD, _DWORD **, uint64_t))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 448), *(_QWORD *)(a1 + 456), &v365, v276) & 0x80000000) != 0)log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v277, v278, v279, v280, "contentType");
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v281 = v260;
  else
    v281 = 4;
  if (((*(uint64_t (**)(_QWORD, _QWORD, _DWORD **, uint64_t))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 464), *(_QWORD *)(a1 + 472), &v364, v281) & 0x80000000) != 0)log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v282, v283, v284, v285, "contentType");
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v286 = v260;
  else
    v286 = 4;
  if (((*(uint64_t (**)(_QWORD, _QWORD, _DWORD **, uint64_t))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 480), *(_QWORD *)(a1 + 488), &v363, v286) & 0x80000000) != 0)log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v287, v288, v289, v290, "contentType");
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v291 = v260;
  else
    v291 = 4;
  if (((*(uint64_t (**)(_QWORD, _QWORD, _DWORD **, uint64_t))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 496), *(_QWORD *)(a1 + 504), &v362, v291) & 0x80000000) != 0)log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v292, v293, v294, v295, "contentType");
  v296 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, _QWORD))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 288), *(_QWORD *)(a1 + 296), v372, 4 * v218);
  if ((v296 & 0x80000000) != 0)
  {
LABEL_423:
    inited = v296;
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_424;
  }
  v297 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, _QWORD))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 304), *(_QWORD *)(a1 + 312), &v371, 4 * v218);
  if ((v297 & 0x80000000) != 0)
  {
    inited = v297;
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_424;
  }
  inited = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, _QWORD))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 320), *(_QWORD *)(a1 + 328), &v370, 4 * v218);
  if ((inited & 0x80000000) != 0)
  {
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_424;
  }
  if (v218)
  {
    v298 = 0;
    LODWORD(v299) = 0;
    v300 = v370;
    do
    {
      v301 = (_DWORD *)(*(_QWORD *)(a1 + 6464) + 28 * (v217 + v298));
      *(_DWORD *)(v372[0] + 4 * v298) = *v301;
      *(_DWORD *)(v371 + 4 * v298) = v301[2];
      *(_DWORD *)(v300 + 4 * v298) = v301[3];
      v356 = v217 + v298;
      MFS__log_select_Diag(*(_QWORD *)(a1 + 16), 1, (uint64_t)"syntheval:Feeding segment %4d unit sequence to synth: id:%u  ofs:%d  dur:%d\n");
      v300 = v370;
      v299 = (*(_DWORD *)(v370 + 4 * v298++) + v299);
    }
    while (v218 != v298);
  }
  else
  {
    v299 = 0;
  }
  v302 = *(_QWORD *)(a1 + 10936);
  if (*(_DWORD *)(v302 + 8328))
  {
    mfs_EarlyEmissionStatistics_Obersee(v15, v299);
    v302 = *(_QWORD *)(a1 + 10936);
  }
  if (!*(_DWORD *)(v302 + 25184))
    goto LABEL_385;
  inited = mfs_Psola_CalculateAdjustments((int *)(*(_QWORD *)(a1 + 56) + 25424), (uint64_t)v15);
  if ((inited & 0x80000000) != 0)
  {
LABEL_425:
    v256 = 2;
    goto LABEL_426;
  }
  if (!v218)
    goto LABEL_386;
  v304 = v367;
  v303 = v368;
  v306 = v365;
  v305 = v366;
  v308 = v363;
  v307 = v364;
  v309 = v362;
  v310 = v218;
  v311 = (_DWORD *)(*(_QWORD *)(a1 + 6856) + 20);
  do
  {
    *v303++ = *(v311 - 2);
    *v304++ = *(v311 - 1);
    *v305++ = *v311;
    *v306++ = v311[1];
    *v307++ = v311[2];
    *v308++ = v311[3];
    *v309++ = v311[4];
    v311 += 10;
    --v310;
  }
  while (v310);
LABEL_385:
  if ((inited & 0x80000000) != 0)
    goto LABEL_425;
LABEL_386:
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v312 = v260;
  else
    v312 = 4;
  v313 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 408), v312);
  if ((v313 & 0x80000000) != 0)
  {
    inited = v313;
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_424;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v314 = v260;
  else
    v314 = 4;
  v315 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 416), *(_QWORD *)(a1 + 424), v314);
  if ((v315 & 0x80000000) != 0)
  {
    inited = v315;
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_424;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v316 = v260;
  else
    v316 = 4;
  v317 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 432), *(_QWORD *)(a1 + 440), v316);
  if ((v317 & 0x80000000) != 0)
  {
    inited = v317;
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_424;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v318 = v260;
  else
    v318 = 4;
  v319 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 448), *(_QWORD *)(a1 + 456), v318);
  if ((v319 & 0x80000000) != 0)
  {
    inited = v319;
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_424;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v320 = v260;
  else
    v320 = 4;
  v321 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 464), *(_QWORD *)(a1 + 472), v320);
  if ((v321 & 0x80000000) != 0)
  {
    inited = v321;
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_424;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v322 = v260;
  else
    v322 = 4;
  v323 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 480), *(_QWORD *)(a1 + 488), v322);
  if ((v323 & 0x80000000) != 0)
  {
    inited = v323;
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_424;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 10936) + 25184))
    v324 = v260;
  else
    v324 = 4;
  v325 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 496), *(_QWORD *)(a1 + 504), v324);
  if ((v325 & 0x80000000) != 0)
  {
    inited = v325;
    v219 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_424;
  }
  v296 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 288), *(_QWORD *)(a1 + 296), v260);
  if ((v296 & 0x80000000) != 0)
    goto LABEL_423;
  v326 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 304), *(_QWORD *)(a1 + 312), v260);
  if ((v326 & 0x80000000) != 0)
  {
    inited = v326;
    v338 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_438:
    log_OutPublic(v338, (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v327, v328, v329, v330, "contentType");
    goto LABEL_425;
  }
  v331 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 320), *(_QWORD *)(a1 + 328), v260);
  if ((v331 & 0x80000000) != 0)
  {
    inited = v331;
    v338 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_438;
  }
  v332 = *(_QWORD *)(a1 + 10936);
  if (*(_DWORD *)(v332 + 8328) && *(_DWORD *)(v332 + 8564))
  {
    v333 = *(unsigned int *)(a1 + 6472);
    if ((_DWORD)v333)
    {
      v334 = 0;
      v335 = (int *)(*(_QWORD *)(a1 + 6464) + 16);
      do
      {
        v336 = *v335;
        v335 += 7;
        v334 += v336;
        --v333;
      }
      while (v333);
    }
    else
    {
      v334 = 0;
    }
    if (v334 < 3 * *(_DWORD *)(a1 + 4808) - 1)
      goto LABEL_445;
  }
  v339 = *(_DWORD *)(a1 + 6360);
  if (!v339)
  {
LABEL_445:
    inited = 0;
  }
  else
  {
    inited = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 104))(*(_QWORD *)(a1 + 336), *(_QWORD *)(a1 + 344), *(_QWORD *)(a1 + 6352), (4 * v339));
    if ((inited & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v340, v328, v329, v330, "contentType");
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 58008, (uint64_t)"%s%s%s%x", v341, v342, v343, v344, "contentType");
      goto LABEL_425;
    }
  }
  if (!*v358)
    goto LABEL_425;
  if (*(_DWORD *)(a1 + 6792))
  {
    v345 = *(_DWORD *)(a1 + 10916) + 1;
    *(_DWORD *)(a1 + 10916) = v345;
    *(_QWORD *)(a1 + 6780) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 6792) = 1;
    v345 = *(_DWORD *)(a1 + 10916);
  }
  v346 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
  if (v345 == *(_DWORD *)(a1 + 10912))
  {
    log_OutText(v346, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Completed synthesis", v328, v329, v330, v356);
    if (*v170)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), *v170);
      *v170 = 0;
      *(_QWORD *)(a1 + 10896) = 0;
      *(_DWORD *)(a1 + 10904) = 0;
    }
    mfs_FreeSplitFeatures(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 10920), *(_DWORD *)(a1 + 10912));
    *(_QWORD *)(a1 + 10912) = 0;
    *(_QWORD *)(a1 + 10920) = 0;
    FreeBET4TuningData((_QWORD *)a1, *(_QWORD *)(a1 + 6840));
    *(_QWORD *)(a1 + 6840) = 0;
    v347 = MFS__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 224), (_QWORD *)(a1 + 544));
    if (v347 >= 0)
      inited = inited;
    else
      inited = v347;
    *a5 = 1;
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Setting *peResults to FULL", v348, v349, v350, v357);
  }
  else
  {
    log_OutText(v346, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Setting *peResults to PARTIAL", v328, v329, v330, v356);
    *a5 = 2;
    *v358 = 0;
  }
  return inited;
}

uint64_t select_bet4_ProcessEnd(uint64_t a1, int a2)
{
  int v3;
  uint64_t v4;
  int ProcessEnd;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v72;
  int v73;
  uint64_t v74;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v80;
  int v81;
  uint64_t v82;

  v3 = safeh_HandleCheck(a1, a2, 25968, 10992);
  if (v3 < 0)
    return 2229280776;
  LODWORD(v4) = v3;
  FreeBET4TuningData((_QWORD *)a1, *(_QWORD *)(a1 + 6840));
  mfs_DeInitStream((unsigned int *)(a1 + 4200));
  *(_DWORD *)(a1 + 10880) = 0;
  ProcessEnd = MFS__select_bet3_FeatureExtractProcessEnd(*(uint64_t **)(a1 + 224), (_QWORD *)(a1 + 544));
  if (ProcessEnd >= 0)
    v4 = v4;
  else
    v4 = ProcessEnd;
  v6 = *(_QWORD *)(a1 + 10888);
  if (v6)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v6);
    *(_QWORD *)(a1 + 10888) = 0;
    *(_QWORD *)(a1 + 10896) = 0;
    *(_DWORD *)(a1 + 10904) = 0;
  }
  *(_DWORD *)(a1 + 10908) = 0;
  v7 = *(_QWORD *)(a1 + 10920);
  if (v7)
  {
    mfs_FreeSplitFeatures(*(_QWORD *)(a1 + 16), v7, *(_DWORD *)(a1 + 10912));
    *(_QWORD *)(a1 + 10920) = 0;
  }
  FreeBET4TuningData((_QWORD *)a1, *(_QWORD *)(a1 + 6840));
  *(_QWORD *)(a1 + 6840) = 0;
  *(_QWORD *)(a1 + 10912) = 0;
  v8 = *(_QWORD *)(a1 + 512);
  if (v8)
  {
    v9 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v8, *(_QWORD *)(a1 + 520));
    *(_QWORD *)(a1 + 512) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 520) = v10;
    if (v9 >= 0 || (int)v4 <= -1)
      v4 = v4;
    else
      v4 = v9;
  }
  v12 = *(_QWORD *)(a1 + 528);
  if (v12)
  {
    v13 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v12, *(_QWORD *)(a1 + 536));
    *(_QWORD *)(a1 + 528) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 536) = v14;
    if ((int)v4 > -1 && v13 < 0)
      v4 = v13;
    else
      v4 = v4;
  }
  v16 = *(_QWORD *)(a1 + 256);
  if (v16)
  {
    v17 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v16, *(_QWORD *)(a1 + 264));
    *(_QWORD *)(a1 + 256) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 264) = v18;
    if ((int)v4 > -1 && v17 < 0)
      v4 = v17;
    else
      v4 = v4;
  }
  v20 = *(_QWORD *)(a1 + 272);
  if (v20)
  {
    v21 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v20, *(_QWORD *)(a1 + 280));
    *(_QWORD *)(a1 + 272) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 280) = v22;
    if ((int)v4 > -1 && v21 < 0)
      v4 = v21;
    else
      v4 = v4;
  }
  v24 = *(_QWORD *)(a1 + 352);
  if (v24)
  {
    v25 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v24, *(_QWORD *)(a1 + 360));
    *(_QWORD *)(a1 + 352) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 360) = v26;
    if ((int)v4 > -1 && v25 < 0)
      v4 = v25;
    else
      v4 = v4;
  }
  v28 = *(_QWORD *)(a1 + 368);
  if (v28)
  {
    v29 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v28, *(_QWORD *)(a1 + 376));
    *(_QWORD *)(a1 + 368) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 376) = v30;
    if ((int)v4 > -1 && v29 < 0)
      v4 = v29;
    else
      v4 = v4;
  }
  v32 = *(_QWORD *)(a1 + 384);
  if (v32)
  {
    v33 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v32, *(_QWORD *)(a1 + 392));
    *(_QWORD *)(a1 + 384) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 392) = v34;
    if ((int)v4 > -1 && v33 < 0)
      v4 = v33;
    else
      v4 = v4;
  }
  v36 = *(_QWORD *)(a1 + 336);
  if (v36)
  {
    v37 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v36, *(_QWORD *)(a1 + 344));
    *(_QWORD *)(a1 + 336) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 344) = v38;
    if ((int)v4 > -1 && v37 < 0)
      v4 = v37;
    else
      v4 = v4;
  }
  v40 = *(_QWORD *)(a1 + 288);
  if (v40)
  {
    v41 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v40, *(_QWORD *)(a1 + 296));
    *(_QWORD *)(a1 + 288) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 296) = v42;
    if ((int)v4 > -1 && v41 < 0)
      v4 = v41;
    else
      v4 = v4;
  }
  v44 = *(_QWORD *)(a1 + 304);
  if (v44)
  {
    v45 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v44, *(_QWORD *)(a1 + 312));
    *(_QWORD *)(a1 + 304) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 312) = v46;
    if ((int)v4 > -1 && v45 < 0)
      v4 = v45;
    else
      v4 = v4;
  }
  v48 = *(_QWORD *)(a1 + 320);
  if (v48)
  {
    v49 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v48, *(_QWORD *)(a1 + 328));
    *(_QWORD *)(a1 + 320) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 328) = v50;
    if ((int)v4 > -1 && v49 < 0)
      v4 = v49;
    else
      v4 = v4;
  }
  v52 = *(_QWORD *)(a1 + 240);
  if (v52)
  {
    v53 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v52, *(_QWORD *)(a1 + 248));
    *(_QWORD *)(a1 + 240) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 248) = v54;
    if ((int)v4 > -1 && v53 < 0)
      v4 = v53;
    else
      v4 = v4;
  }
  v56 = *(_QWORD *)(a1 + 400);
  if (v56)
  {
    v57 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v56, *(_QWORD *)(a1 + 408));
    *(_QWORD *)(a1 + 400) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 408) = v58;
    if ((int)v4 > -1 && v57 < 0)
      v4 = v57;
    else
      v4 = v4;
  }
  v60 = *(_QWORD *)(a1 + 416);
  if (v60)
  {
    v61 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v60, *(_QWORD *)(a1 + 424));
    *(_QWORD *)(a1 + 416) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 424) = v62;
    if ((int)v4 > -1 && v61 < 0)
      v4 = v61;
    else
      v4 = v4;
  }
  v64 = *(_QWORD *)(a1 + 432);
  if (v64)
  {
    v65 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v64, *(_QWORD *)(a1 + 440));
    *(_QWORD *)(a1 + 432) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 440) = v66;
    if ((int)v4 > -1 && v65 < 0)
      v4 = v65;
    else
      v4 = v4;
  }
  v68 = *(_QWORD *)(a1 + 448);
  if (v68)
  {
    v69 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v68, *(_QWORD *)(a1 + 456));
    *(_QWORD *)(a1 + 448) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 456) = v70;
    if ((int)v4 > -1 && v69 < 0)
      v4 = v69;
    else
      v4 = v4;
  }
  v72 = *(_QWORD *)(a1 + 464);
  if (v72)
  {
    v73 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v72, *(_QWORD *)(a1 + 472));
    *(_QWORD *)(a1 + 464) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 472) = v74;
    if ((int)v4 > -1 && v73 < 0)
      v4 = v73;
    else
      v4 = v4;
  }
  v76 = *(_QWORD *)(a1 + 480);
  if (v76)
  {
    v77 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v76, *(_QWORD *)(a1 + 488));
    *(_QWORD *)(a1 + 480) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 488) = v78;
    if ((int)v4 > -1 && v77 < 0)
      v4 = v77;
    else
      v4 = v4;
  }
  v80 = *(_QWORD *)(a1 + 496);
  if (v80)
  {
    v81 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 72))(v80, *(_QWORD *)(a1 + 504));
    *(_QWORD *)(a1 + 496) = safeh_GetNullHandle();
    *(_QWORD *)(a1 + 504) = v82;
    if ((int)v4 > -1 && v81 < 0)
      return v81;
    else
      return v4;
  }
  return v4;
}

uint64_t select_bet4_GetAlphabetInformation(uint64_t a1, int a2, char *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  char *v9;
  const char **v10;
  const char *v11;
  int v12;
  char *v13;

  v5 = safeh_HandleCheck(a1, a2, 25968, 10992);
  if ((v5 & 0x80000000) != 0)
    return 2229280776;
  if (!*(_QWORD *)(a1 + 56))
    return 2229280785;
  v6 = v5;
  cstdlib_memset(a3, 0, 0x985uLL);
  v7 = 0;
  v8 = 0;
  do
  {
    if (*(unsigned __int8 *)(*(_QWORD *)(a1 + 56) + v7 + 40032) != 255)
    {
      v9 = &a3[(unsigned __int16)v8];
      *v9 = v7;
      v9[514] = *(_BYTE *)(*(_QWORD *)(a1 + 56) + *(unsigned __int8 *)(*(_QWORD *)(a1 + 56) + v7 + 40032) + 39004);
      v9[257] = *(_BYTE *)(*(_QWORD *)(a1 + 56) + *(unsigned __int8 *)(*(_QWORD *)(a1 + 56) + v7 + 40032) + 38747);
      v9[771] = *(_BYTE *)(*(_QWORD *)(a1 + 56) + *(unsigned __int8 *)(*(_QWORD *)(a1 + 56) + v7 + 40032) + 39261);
      v9[1028] = *(_BYTE *)(*(_QWORD *)(a1 + 56) + *(unsigned __int8 *)(*(_QWORD *)(a1 + 56) + v7 + 40032) + 39518);
      ++v8;
    }
    ++v7;
  }
  while (v7 != 256);
  cstdlib_strcpy(a3 + 1285, (const char *)(*(_QWORD *)(a1 + 56) + 40288));
  v10 = *(const char ***)(*(_QWORD *)(a1 + 56) + 40352);
  if (v10)
  {
    v11 = *v10;
    if (*v10)
    {
      v12 = 0;
      v13 = a3 + 1413;
      do
      {
        cstdlib_strcat(v13, v11);
        cstdlib_strcat(v13, " ");
        v11 = *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40352) + 8 * (unsigned __int16)++v12);
      }
      while (v11);
    }
  }
  return v6;
}

uint64_t select_bet4_QueryCapability(uint64_t a1, int a2, const char *a3, _DWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v7 = 2229280768;
  v8 = safeh_HandleCheck(a1, a2, 25968, 10992);
  if ((v8 & 0x80000000) != 0)
    return 2229280776;
  if (!*(_QWORD *)(a1 + 56))
    return 2229280785;
  v9 = v8;
  if (!cstdlib_strcmp(a3, "PRM"))
  {
    if ((*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41056) & 0x80000000) == 0
      || (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41064) & 0x80000000) == 0)
    {
      goto LABEL_22;
    }
    goto LABEL_11;
  }
  if (!cstdlib_strcmp(a3, "BND"))
  {
    if ((*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41060) & 0x80000000) == 0
      || (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41064) & 0x80000000) == 0
      || (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41068) & 0x80000000) == 0
      || (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41072) & 0x80000000) == 0
      || (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41076) & 0x80000000) == 0
      || (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41080) & 0x80000000) == 0
      || (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41084) & 0x80000000) == 0
      || (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41088) & 0x80000000) == 0
      || (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41092) & 0x80000000) == 0
      || (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 41100) & 0x80000000) == 0)
    {
LABEL_22:
      *a4 = 1;
      return v9;
    }
LABEL_11:
    *a4 = 0;
    return v9;
  }
  if (!cstdlib_strcmp(a3, "max-PRM"))
  {
    *(_BYTE *)a4 = 3;
    return v9;
  }
  return v7;
}

uint64_t select_bet4_loc_ObjcVoiceOpen(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t inited;
  int v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t Data;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  const char *v52;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  const char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  const char *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  const char *v82;
  unsigned int v83;
  _DWORD *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  float v98;
  uint64_t v99;
  uint64_t v100;
  const char *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  const char *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  float v111;
  uint64_t v112;
  uint64_t v113;
  const char *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  float v118;
  uint64_t v119;
  uint64_t v120;
  const char *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  const char *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  const char *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  const char *v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  const char *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  const char *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  const char *v157;
  unsigned int v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  _OWORD __dst[2];
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  uint64_t v190;
  void *__src;
  char *v192;
  unsigned int v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  _QWORD *v201;
  char __s1[256];
  char __b[80];
  uint64_t v204;

  v204 = *MEMORY[0x24BDAC8D0];
  __src = 0;
  v190 = 0;
  v188 = 0u;
  v189 = 0u;
  v186 = 0u;
  v187 = 0u;
  v184 = 0u;
  v185 = 0u;
  v182 = 0u;
  v183 = 0u;
  v180 = 0u;
  v181 = 0u;
  v178 = 0u;
  v179 = 0u;
  v176 = 0u;
  v177 = 0u;
  v174 = 0u;
  v175 = 0u;
  v172 = 0u;
  v173 = 0u;
  v170 = 0u;
  v171 = 0u;
  v168 = 0u;
  v169 = 0u;
  v167 = 0u;
  memset(__dst, 0, sizeof(__dst));
  inited = InitRsrcFunction(a1, a2, &__src);
  if ((inited & 0x80000000) != 0)
    return inited;
  cstdlib_memcpy(__dst, __src, 0x198uLL);
  v167 = *(_OWORD *)(a5 + 32);
  v201 = 0;
  v200 = 0;
  v199 = 0;
  v198 = 0;
  v196 = 0;
  v197 = 0;
  v194 = 0;
  v195 = 0;
  v193 = 0;
  v192 = 0;
  *(_QWORD *)(a4 + 32) = 0;
  v11 = ssftriff_reader_ObjOpen(a1, a2, 0, a3, "SEL4", 1031, (uint64_t *)&v201);
  if (v11 < 0)
    return (v11 & 0x1FFFu) - 2065686528;
  v12 = (char *)heap_Calloc(*((_QWORD **)&__dst[0] + 1), 1, 66912);
  v17 = (uint64_t)v12;
  if (!v12)
  {
    log_OutPublic(v167, (uint64_t)"SELECT_BET4", 58000, 0, v13, v14, v15, v16, v158);
    Data = 2229280778;
    goto LABEL_47;
  }
  v18 = v12 + 66316;
  v19 = v12 + 25312;
  cstdlib_strcpy(v12, a3);
  cstdlib_strcpy((char *)(v17 + 38040), a3);
  cstdlib_memset((void *)(v17 + 40032), 255, 0x100uLL);
  cstdlib_memset((void *)(v17 + 40936), 255, 0x11CuLL);
  cstdlib_memset((void *)(v17 + 41264), 255, 0x20uLL);
  *(_DWORD *)(v17 + 40412) = 1;
  if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4maxstaticmemmap", (unsigned int *)(v17 + 66316)) & 0x80000000) != 0)
    *v18 = -1;
  *(_BYTE *)(v17 + 66842) = 0;
  mfs_InitParam(v17 + 128);
  cstdlib_memset(__b, 0, 0x50uLL);
  v21 = select_bet4_ParseRiff((uint64_t)__dst, v17, (uint64_t)v201, 0, __b, 0, 0, v20);
  if ((v21 & 0x80000000) != 0)
  {
    Data = v21;
    cstdlib_strcpy(__s1, "");
    if (__b[0])
    {
      v51 = 0;
      v52 = __b;
      do
      {
        cstdlib_strcat(__s1, "/");
        cstdlib_strcat(__s1, v52);
        v52 = &__b[5 * (unsigned __int16)++v51];
      }
      while (*v52);
    }
    log_OutPublic(v167, (uint64_t)"SELECT_BET4", 58003, (uint64_t)"%s%s%s%s%s%x", v47, v48, v49, v50, "file");
    goto LABEL_47;
  }
  paramc_ParamSetStr(*((uint64_t *)&v167 + 1), (uint64_t)"voicecomponentid", (char *)(v17 + 66842));
  if (!*(_BYTE *)(v17 + 7519) || *(int *)(v17 + 260) <= 0)
  {
    Data = 2229280772;
    log_OutPublic(v167, (uint64_t)"SELECT_BET4", 58006, (uint64_t)"%s%s", v22, v23, v24, v25, "file");
    goto LABEL_47;
  }
  v26 = (_DWORD *)(v17 + 25424);
  v27 = *(uint64_t **)(v17 + 40352);
  if (v27)
  {
    v28 = *v27;
    if (v28)
    {
      v29 = 0;
      v30 = 0;
      do
      {
        *(_QWORD *)(v17 + 8 * v29 + 5432) = v28;
        v29 = (unsigned __int16)++v30;
        v28 = *(_QWORD *)(*(_QWORD *)(v17 + 40352) + 8 * (unsigned __int16)v30);
      }
      while (v28);
    }
  }
  log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Memory mapped %s: %lu bytes in %lu chunks", v23, v24, v25, (uint64_t)a3);
  v31 = mfs_InitData((uint64_t)__dst, (void *)(v17 + 25424), (_DWORD *)(v17 + 128));
  if ((v31 & 0x80000000) != 0)
  {
    Data = v31;
    goto LABEL_47;
  }
  Data = mfs_LoadData((uint64_t)__dst, (int *)(v17 + 25424), v17 + 128);
  if ((Data & 0x80000000) == 0)
  {
    logAverageSizesOfClusters((uint64_t)__dst, (int *)(v17 + 25424), 1u);
    logAverageSizesOfClusters((uint64_t)__dst, (int *)(v17 + 25424), 2u);
    logAverageSizesOfClusters((uint64_t)__dst, (int *)(v17 + 25424), 0);
    *(_WORD *)(v17 + 41466) = *v26;
    *(_QWORD *)&v40 = 0x100000001;
    *((_QWORD *)&v40 + 1) = 0x100000001;
    *(_OWORD *)(v17 + 41056) = v40;
    *(_OWORD *)(v17 + 41072) = v40;
    *(_QWORD *)(v17 + 41088) = 0x100000001;
    *(_DWORD *)(v17 + 41100) = 1;
    *(_OWORD *)(v17 + 41108) = v40;
    *(_OWORD *)(v17 + 41124) = v40;
    *(_OWORD *)(v17 + 41140) = v40;
    *(_OWORD *)(v17 + 41156) = v40;
    *(_OWORD *)(v17 + 41172) = v40;
    *(_OWORD *)(v17 + 41188) = v40;
    *(_DWORD *)(v17 + 41204) = 1;
    *(_DWORD *)(v17 + 40638) = 33620481;
    *(_BYTE *)(v17 + 40665) = 1;
    *(_QWORD *)(v17 + 40643) = 0x101010101010101;
    *(_QWORD *)(v17 + 40651) = 0x101010101010101;
    *(_DWORD *)(v17 + 40687) = -1;
    *(_WORD *)(v17 + 40691) = -255;
    BYTE1(v40) = 1;
    WORD1(v40) = 257;
    BYTE5(v40) = 1;
    WORD3(v40) = 257;
    BYTE9(v40) = 1;
    WORD5(v40) = 257;
    BYTE13(v40) = 1;
    HIWORD(v40) = 257;
    *(_OWORD *)(v17 + 40786) = v40;
    *(_OWORD *)(v17 + 40773) = v40;
    *(_OWORD *)(v17 + 40757) = v40;
    *(_QWORD *)(v17 + 40809) = 0x101010101010101;
    *(_QWORD *)(v17 + 40817) = 0x101010101010101;
    *(_QWORD *)(v17 + 40825) = 0x101010101010101;
    if ((*(_DWORD *)(v17 + 40992) & 0x80000000) == 0)
    {
      *(_WORD *)(v17 + 40667) = 257;
      if ((*(_DWORD *)(v17 + 41096) & 0x80000000) == 0)
        *(_BYTE *)(v17 + 40711) = 1;
    }
    if ((*(_DWORD *)(v17 + 41008) & 0x80000000) == 0)
      *(_BYTE *)(v17 + 40669) = 1;
    if ((*(_DWORD *)(v17 + 41024) & 0x80000000) == 0)
      *(_BYTE *)(v17 + 40670) = 1;
    if ((*(_DWORD *)(v17 + 41028) & 0x80000000) == 0)
      *(_BYTE *)(v17 + 40671) = 1;
    *(_WORD *)(v17 + 40807) = 257;
    if ((*(_DWORD *)(v17 + 41032) & 0x80000000) == 0)
      *(_BYTE *)(v17 + 40672) = 1;
    if ((*(_DWORD *)(v17 + 41036) & 0x80000000) == 0)
      *(_BYTE *)(v17 + 40673) = 1;
    if ((*(_DWORD *)(v17 + 40956) & 0x80000000) == 0)
      *(_WORD *)(v17 + 40661) = 257;
    if ((*(_DWORD *)(v17 + 41280) & 0x80000000) == 0 || (*(_DWORD *)(v17 + 41284) & 0x80000000) == 0)
      *(_BYTE *)(v17 + 40660) = 8;
    if ((*(_DWORD *)(v17 + 40960) & 0x80000000) == 0)
      *(_WORD *)(v17 + 40663) = 257;
    if (*(_DWORD *)(v17 + 40448))
      *(_BYTE *)(v17 + 40682) = 9;
    *(_WORD *)(v17 + 40712) = 257;
    *(_QWORD *)(v17 + 40701) = 0x101010101010101;
    *(_WORD *)(v17 + 40709) = 257;
    if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4silvit", (unsigned int *)&v197) & 0x80000000) != 0)
    {
      v45 = v167;
      v44 = *(unsigned int *)(v17 + 8384);
      v46 = "Silence Prune Max remains at its default of %d";
    }
    else
    {
      v44 = v197;
      *(_DWORD *)(v17 + 8384) = v197;
      v45 = v167;
      v46 = "Silence Prune Max set to %d from pipeline header";
    }
    log_OutText(v45, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v46, v41, v42, v43, v44);
    if ((paramc_ParamGetStr(*((uint64_t *)&v167 + 1), (uint64_t)"bet4suppresschunking", &v192) & 0x80000000) != 0)
    {
      *(_DWORD *)(v17 + 8688) = 0;
    }
    else
    {
      v57 = cstdlib_strcmp(v192, "yes");
      *(_DWORD *)(v17 + 8688) = v57 == 0;
      if (!v57)
      {
        v58 = "BET4 input chunking will be switched off, from pipeline header";
        goto LABEL_63;
      }
    }
    v58 = "BET4 input chunking will not be switched off";
LABEL_63:
    log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v58, v54, v55, v56, v159);
    if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4psolamode", (unsigned int *)&v196 + 1) & 0x80000000) != 0)
    {
      v63 = v167;
      v62 = *v19;
      v64 = "PSOLA mode remains at its default of %d";
    }
    else
    {
      v62 = HIDWORD(v196);
      if (!HIDWORD(v196))
      {
        *v19 = 0;
        log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"PSOLA mode set to zero (i.e. disabled) from pipeline header", v59, v60, v61, v160);
LABEL_69:
        if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4earlyemissionadditionalstates", &v193) & 0x80000000) != 0)
        {
          v69 = v167;
          v68 = *(unsigned int *)(v17 + 8696);
          v70 = "Early-emission additional states remains at its default of %d (ignored - was only used in old obsolete v"
                "ersion of early-emission)";
        }
        else
        {
          v68 = v193;
          *(_DWORD *)(v17 + 8696) = v193;
          v69 = v167;
          v70 = "Early-emission additional search states set to %d from pipeline header (ignored - was only used in old o"
                "bsolete version of early-emission)";
        }
        log_OutText(v69, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v70, v65, v66, v67, v68);
        if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4earlyemissionminphonsfirst", (unsigned int *)&v194 + 1) & 0x80000000) != 0)
        {
          v75 = v167;
          v74 = *(unsigned int *)(v17 + 8700);
          v76 = "Early-emission minimum number of states for first emission remains at its default of %d";
        }
        else
        {
          v74 = (*v26 * HIDWORD(v194));
          *(_DWORD *)(v17 + 8700) = v74;
          v75 = v167;
          v76 = "Early-emission minimum number of states for first emission set to %d from pipeline header";
        }
        log_OutText(v75, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v76, v71, v72, v73, v74);
        if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4earlyemissionminphonssubsequent", (unsigned int *)&v194 + 1) & 0x80000000) != 0)
        {
          v80 = *(_DWORD *)(v17 + 8700) >> 1;
          *(_DWORD *)(v17 + 8704) = v80;
          v81 = v167;
          v82 = "Early-emission minimum number of states for subsequent emission remains at its default of %d";
        }
        else
        {
          v80 = (*v26 * HIDWORD(v194));
          *(_DWORD *)(v17 + 8704) = v80;
          v81 = v167;
          v82 = "Early-emission minimum number of states for subsequent emission set to %d from pipeline header";
        }
        log_OutText(v81, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v82, v77, v78, v79, v80);
        v83 = *(_DWORD *)(v17 + 8704);
        if (v83 >= 1000 * *v26)
          *(_DWORD *)(v17 + 8704) = v83 % 0x3E8;
        v84 = (_DWORD *)(v17 + 8708);
        if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4earlyemissionmaxhypotheses", (unsigned int *)(v17 + 8708)) & 0x80000000) != 0)
        {
          *v84 = -1;
          log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Early-emission maximum number of hypotheses: not set", v85, v86, v87, v161);
        }
        else
        {
          log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Early-emission maximum number of hypotheses set to %d from pipeline header", v85, v86, v87, *v84);
        }
        if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4earlyemissionmaxphonambiguitywindow", (unsigned int *)&v194) & 0x80000000) != 0)
        {
          *(_DWORD *)(v17 + 8712) = -1;
          log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Early-emission maximum size of ambiguity window: not set", v88, v89, v90, v162);
        }
        else
        {
          v91 = v194;
          *(_DWORD *)(v17 + 8712) = *v26 * v194;
          log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Early-emission maximum size of ambiguity window set to %d phons from pipeline header", v88, v89, v90, v91);
        }
        if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"applicationstartbuffersizebytes", (unsigned int *)&v194) & 0x80000000) != 0|| *(int *)(v17 + 136) < 1)
        {
          *(_DWORD *)(v17 + 8716) = -1;
          log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Application start buffer size: not set", v92, v93, v94, v163);
        }
        else
        {
          log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Application start buffer size is set to %d bytes from pipeline header", v92, v93, v94, v194);
          *(_DWORD *)(v17 + 8716) = 1000 * (int)v194 / (2 * *(_DWORD *)(v17 + 136));
        }
        *(_DWORD *)(v17 + 8692) = select_bet4_UpdateEarlyEmission((uint64_t)__dst);
        if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4beamwidth", (unsigned int *)&v200 + 1) & 0x80000000) != 0
          || !HIDWORD(v200))
        {
          v99 = v167;
          *(double *)&v100 = *(float *)(v17 + 8376);
          v101 = "Beam Width remains at its default of %.2f";
        }
        else
        {
          v98 = (double)HIDWORD(v200) / 1000.0;
          *(float *)(v17 + 8376) = v98;
          v99 = v167;
          *(double *)&v100 = v98;
          v101 = "Beam Width set to %.2f from pipeline header";
        }
        log_OutText(v99, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v101, v95, v96, v97, v100);
        if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4nodelimit", (unsigned int *)&v200) & 0x80000000) != 0
          || (v105 = v200, !(_DWORD)v200))
        {
          v106 = v167;
          v105 = *(unsigned int *)(v17 + 8352);
          v107 = "Node Limit remains at its default of %d";
        }
        else
        {
          *(_DWORD *)(v17 + 8352) = v200;
          *(_DWORD *)(v17 + 8356) = v105;
          v106 = v167;
          v107 = "Node Limit set to %d from pipeline header";
        }
        log_OutText(v106, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v107, v102, v103, v104, v105);
        if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4prunepercent", (unsigned int *)&v199 + 1) & 0x80000000) != 0)
        {
          v112 = v167;
          *(double *)&v113 = *(float *)(v17 + 8360);
          v114 = "Prune Percent remains at its default of %.2f";
        }
        else
        {
          if (HIDWORD(v199) > 0x64)
          {
            log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Prune Percent value from pipeline header out of range, ignored.", v108, v109, v110, v164);
LABEL_104:
            if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4prunepercent", (unsigned int *)&v199) & 0x80000000) != 0)
            {
              v119 = v167;
              *(double *)&v120 = *(float *)(v17 + 8364);
              v121 = "Node Prune Percent remains at its default of %.2f";
            }
            else
            {
              if (v199 > 0x64)
              {
                log_OutText(v167, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Node Prune Percent value from pipeline header out of range, ignored.", v115, v116, v117, v165);
LABEL_110:
                if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4nodeprunemax", (unsigned int *)&v198 + 1) & 0x80000000) != 0|| (v125 = HIDWORD(v198), !HIDWORD(v198)))
                {
                  v126 = v167;
                  v125 = *(unsigned int *)(v17 + 8368);
                  v127 = "Node Prune Max remains at its default of %d";
                }
                else
                {
                  *(_DWORD *)(v17 + 8368) = HIDWORD(v198);
                  v126 = v167;
                  v127 = "Node Prune Max set to %d from pipeline header";
                }
                log_OutText(v126, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v127, v122, v123, v124, v125);
                if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4nodeprunemaxunvoiced", (unsigned int *)&v198) & 0x80000000) != 0|| (v131 = v198, !(_DWORD)v198))
                {
                  v132 = v167;
                  v131 = *(unsigned int *)(v17 + 8372);
                  v133 = "Node Prune Max Unvoiced remains at its default of %d";
                }
                else
                {
                  *(_DWORD *)(v17 + 8372) = v198;
                  v132 = v167;
                  v133 = "Node Prune Max Unvoiced set to %d from pipeline header";
                }
                log_OutText(v132, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v133, v128, v129, v130, v131);
                if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4searchmode", (unsigned int *)&v197 + 1) & 0x80000000) != 0)
                {
                  v138 = v167;
                  v137 = *(unsigned int *)(v17 + 9096);
                  v139 = "Search mode remains at its default of %d";
                }
                else
                {
                  v137 = HIDWORD(v197);
                  *(_DWORD *)(v17 + 9096) = HIDWORD(v197);
                  v138 = v167;
                  v139 = "Search mode set to %d from pipeline header";
                }
                log_OutText(v138, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v139, v134, v135, v136, v137);
                if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4nodescoremax", (unsigned int *)&v196) & 0x80000000) != 0
                  || (v143 = v196, !(_DWORD)v196))
                {
                  v144 = v167;
                  v143 = *(unsigned int *)(v17 + 8444);
                  v145 = "Node Score Max remains at its default of %d";
                }
                else
                {
                  *(_DWORD *)(v17 + 8444) = v196;
                  v144 = v167;
                  v145 = "Node Score Max set to %d from pipeline header";
                }
                log_OutText(v144, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v145, v140, v141, v142, v143);
                if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4nodeprunemin", (unsigned int *)&v195 + 1) & 0x80000000) != 0|| (v149 = HIDWORD(v195), !HIDWORD(v195)))
                {
                  v150 = v167;
                  v149 = *(unsigned int *)(v17 + 8448);
                  v151 = "Node Prune Min remains at its default of %d";
                }
                else
                {
                  *(_DWORD *)(v17 + 8448) = HIDWORD(v195);
                  v150 = v167;
                  v151 = "Node Prune Min set to %d from pipeline header";
                }
                log_OutText(v150, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v151, v146, v147, v148, v149);
                if ((paramc_ParamGetUInt(*((uint64_t *)&v167 + 1), (uint64_t)"bet4earlypruning", (unsigned int *)&v195) & 0x80000000) != 0
                  || (v155 = v195, !(_DWORD)v195))
                {
                  v156 = v167;
                  v155 = *(unsigned int *)(v17 + 8452);
                  v157 = "Early Pruning remains at its default of %d";
                }
                else
                {
                  *(_DWORD *)(v17 + 8452) = v195;
                  v156 = v167;
                  v157 = "Early Pruning set to %d from pipeline header";
                }
                log_OutText(v156, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v157, v152, v153, v154, v155);
                goto LABEL_47;
              }
              v118 = (double)v199 / 100.0;
              *(float *)(v17 + 8364) = v118;
              v119 = v167;
              *(double *)&v120 = v118;
              v121 = "Node Prune Percent set to %.2f from pipeline header";
            }
            log_OutText(v119, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v121, v115, v116, v117, v120);
            goto LABEL_110;
          }
          v111 = (double)HIDWORD(v199) / 100.0;
          *(float *)(v17 + 8360) = v111;
          v112 = v167;
          *(double *)&v113 = v111;
          v114 = "Prune Percent set to %.2f from pipeline header";
        }
        log_OutText(v112, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v114, v108, v109, v110, v113);
        goto LABEL_104;
      }
      *v19 = HIDWORD(v196);
      v63 = v167;
      v64 = "PSOLA mode set to non-zero %d from pipeline header";
    }
    log_OutText(v63, (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v64, v59, v60, v61, v62);
    goto LABEL_69;
  }
LABEL_47:
  if (v201)
  {
    ssftriff_reader_ObjClose(v201, v32, v33, v34, v35, v36, v37, v38);
    v201 = 0;
  }
  if ((Data & 0x80000000) != 0)
  {
    if ((Data & 0x7FF01FFF) == 0xA200014)
      Data = 2229280772;
    else
      Data = Data;
    select_bet4_loc_VoiceClose(__dst, v17);
  }
  else
  {
    *(_QWORD *)(a4 + 32) = v17;
  }
  return Data;
}

uint64_t select_bet4_loc_ObjcVoiceClose(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t inited;
  _QWORD *v6;

  v6 = 0;
  inited = InitRsrcFunction(a1, a2, &v6);
  if ((inited & 0x80000000) == 0)
    select_bet4_loc_VoiceClose(v6, *(_QWORD *)(a3 + 32));
  return inited;
}

uint64_t select_bet4_loc_ParamCheckChange(uint64_t a1, char *__s1, const char *a3, _DWORD *a4)
{
  uint64_t result;

  *a4 = 1;
  if (!cstdlib_strcmp(__s1, "frequencyhz"))
  {
    if (*(_QWORD *)(a1 + 256))
    {
      result = 2229280785;
LABEL_12:
      *a4 = 0;
      return result;
    }
    return 0;
  }
  if (!cstdlib_strcmp(__s1, "waitfactor"))
  {
    if ((LH_atoi(a3) & 0x80000000) != 0)
    {
LABEL_11:
      result = 2229280783;
      goto LABEL_12;
    }
    return 0;
  }
  if (cstdlib_strcmp(__s1, "bet4suppresschunking"))
    return 0;
  result = cstdlib_strcmp(a3, "yes");
  if ((_DWORD)result)
  {
    result = cstdlib_strcmp(a3, "no");
    if ((_DWORD)result)
      goto LABEL_11;
  }
  return result;
}

uint64_t select_bet4_loc_ParamLearnChange(_QWORD *a1, char *__s1, const char *a3)
{
  float v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v12;

  if (cstdlib_strcmp(__s1, "frequencyhz"))
  {
    if (cstdlib_strcmp(__s1, "rate") && cstdlib_strcmp(__s1, "waitfactor"))
    {
      if (!cstdlib_strcmp(__s1, "bet4suppresschunking"))
      {
        v6 = *(float *)(a1[1367] + 8248);
        if (v6 > 0.0 && v6 < 10.0)
        {
          *(_DWORD *)(a1[1367] + 8560) = cstdlib_strcmp(a3, "yes") == 0;
          log_OutText(*(_QWORD *)(a1[2] + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Set suppress-chunking value %s", v8, v9, v10, (uint64_t)a3);
        }
      }
      return 0;
    }
    else
    {
      v12 = LH_atoi(a3);
      return select_bet4_loc_ParamSet((uint64_t)a1, __s1, (uint64_t)v12);
    }
  }
  else if (a1[32])
  {
    return 2229280785;
  }
  else
  {
    return 0;
  }
}

uint64_t select_bet4_loc_VoiceSetup(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t result;

  v2 = a1[2];
  v3 = a1[7];
  for (i = 8; i != 28; i += 2)
  {
    v5 = a1[i];
    if (v5)
    {
      brk_DataClose(*(_QWORD *)(v2 + 24), v5);
      a1[i] = 0;
    }
  }
  if (!v3)
    return 0;
  v6 = (_DWORD *)(v3 + 26656);
  v7 = 8;
  while (1)
  {
    if (!*((_QWORD *)v6 - 1))
    {
      if (*v6)
      {
        result = brk_DataOpenEx(*(_QWORD *)(v2 + 24), v3, 0, (uint64_t)&a1[v7]);
        if ((result & 0x80000000) != 0)
          break;
      }
    }
    v6 += 8;
    v7 += 2;
    if (v7 == 28)
    {
      a1[1367] = v3 + 128;
      return select_bet4_loc_SetSynthParams((uint64_t)a1);
    }
  }
  return result;
}

uint64_t select_bet4_loc_SetSynthParamFloat(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v11[32];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  __sprintf_chk(v11, 0, 0x20uLL, "%f", a3);
  v9 = paramc_ParamSetStr(*(_QWORD *)(a1 + 40), a2, v11);
  if ((v9 & 0x80000000) != 0)
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET4", 58009, (uint64_t)"%s%s%s%f%s%x", v5, v6, v7, v8, "parameter");
  return v9;
}

uint64_t select_bet4_loc_ParamSet(uint64_t a1, char *__s1, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (cstdlib_strcmp(__s1, "waitfactor"))
    return 0;
  if ((a3 & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 232) = a3;
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Set wait factor %d", v5, v6, v7, a3);
    return 0;
  }
  return 2229280783;
}

uint64_t select_bet4_RegisterObject(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = 0;
  v7 = 0u;
  v8 = 0u;
  cstdlib_memset(&v7, 0, 0x28uLL);
  LOBYTE(v7) = 1;
  *((_QWORD *)&v7 + 1) = &ISelect_Bet4;
  *(_QWORD *)&v8 = a1;
  *((_QWORD *)&v8 + 1) = a2;
  v9 = 0;
  return objc_RegisterObject(*(_QWORD *)(a3 + 48), (uint64_t)"SELECTBET4", &v7);
}

uint64_t select_bet4_ParseRiff(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  int v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  unsigned int v179;
  unsigned int v180;
  int v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  unint64_t v202;
  unsigned __int16 *v203;
  uint64_t v204;
  unsigned __int16 *v205;
  unsigned int v206;
  unsigned int v207;
  unsigned int v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float v213;
  float v214;
  float v215;
  float v216;
  float v217;
  char *v218;
  float v219;
  float v220;
  float v221;
  float v222;
  float v223;
  float v224;
  float v225;
  float v226;
  float v227;
  float v228;
  float v229;
  float v230;
  float v231;
  float v232;
  float v233;
  float v234;
  float v235;
  float v236;
  float v237;
  float v238;
  float v239;
  float v240;
  float v241;
  float v242;
  float v243;
  float v244;
  float v245;
  float v246;
  float v247;
  float v248;
  float v249;
  float v250;
  float v251;
  float v252;
  float v253;
  float v254;
  float v255;
  float v256;
  float v257;
  float v258;
  float v259;
  float v260;
  float v261;
  float v262;
  float v263;
  float v264;
  float v265;
  float v266;
  float v267;
  float v268;
  float v269;
  float v270;
  float v271;
  float v272;
  float v273;
  float v274;
  float v275;
  float v276;
  float v277;
  float v278;
  float v279;
  float v280;
  float v281;
  float v282;
  uint64_t v283;
  unint64_t v284;
  int RiffStringTable;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t ChunkData;
  const char *v290;
  uint64_t v291;
  uint64_t v292;
  size_t v293;
  int v294;
  unsigned __int8 *v295;
  unsigned int v296;
  size_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  unsigned __int16 *v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  int v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t *v310;
  size_t v311;
  void *v312;
  int *v313;
  unsigned int v314;
  uint64_t v315;
  uint64_t v316;
  int v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  unsigned int v327;
  uint64_t v328;
  _BYTE *v329;
  char *v330;
  _QWORD *v331;
  uint64_t v332;
  _QWORD *v333;
  _QWORD *v334;
  int StringZ;
  unint64_t v336;
  int v337;
  unsigned __int16 *v338;
  uint64_t v339;
  int v340;
  unsigned __int16 v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  unsigned int v345;
  uint64_t v346;
  unint64_t v347;
  int v348;
  int *v349;
  unsigned __int16 v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  char *v354;
  uint64_t v355;
  uint64_t v356;
  int Position;
  unsigned int v358;
  int v359;
  unsigned int v360;
  int v361;
  unsigned int v362;
  unsigned __int16 *v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  const char *v369;
  uint64_t v370;
  uint64_t v371;
  unsigned int v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  unsigned int v376;
  int *v377;
  uint64_t v378;
  int *v379;
  _QWORD *v380;
  int v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  unsigned int v385;
  uint64_t v386;
  int MfsData;
  uint64_t v388;
  int v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  unint64_t v393;
  int v394;
  int v395;
  uint64_t v397;
  unsigned __int16 *v398;
  int v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t *v402;
  unint64_t v403;
  int v404;
  unint64_t v405;
  int v406;
  unint64_t v407;
  int v408;
  unint64_t v409;
  int v410;
  unint64_t v411;
  int v412;
  unint64_t v413;
  int v414;
  unint64_t v415;
  int v416;
  unint64_t v417;
  int v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  unint64_t v425;
  uint64_t v426;
  unint64_t v427;
  int v428;
  unint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  unsigned int v433;
  int v434;
  uint64_t v436;
  int *v437;
  unsigned int v438;
  _QWORD *v439;
  _QWORD *v440;
  _QWORD *v441;
  _QWORD *v442;
  _QWORD *v443;
  _QWORD *v444;
  _QWORD *v445;
  _QWORD *v446;
  _QWORD *v447;
  _QWORD *v448;
  uint64_t *v449;
  _QWORD *v450;
  uint64_t *v451;
  uint64_t *v452;
  uint64_t *v453;
  uint64_t *v454;
  _BYTE *v455;
  _BYTE *v456;
  _QWORD *v457;
  _BYTE *v458;
  _QWORD *v459;
  _QWORD *v460;
  _BYTE *v461;
  void *v462;
  _BYTE *v463;
  uint64_t *v464;
  _BYTE *v465;
  uint64_t *v466;
  unsigned int v467;
  void *v468;
  uint64_t *v469;
  char *v470;
  uint64_t v471;
  char *__s;
  unsigned __int8 *v474;
  char *__s1;
  char *__dst;
  int *v478;
  int v479[2];
  char *v480;
  unsigned int v481;
  char __src[4];
  char v483;
  int v484;
  char v485[8];
  char v486[8];
  char __s2[8];
  uint64_t v488;

  v8 = a7;
  v9 = a6;
  v14 = a1;
  v488 = *MEMORY[0x24BDAC8D0];
  v467 = 0;
  v471 = a2 + 66296;
  v474 = (unsigned __int8 *)(a2 + 40384);
  v478 = (int *)(a2 + 16560);
  v484 = 0;
  v483 = 0;
  *(_DWORD *)__src = 0;
  __dst = (char *)&a5[5 * a4];
  v462 = (void *)(a2 + 7484);
  v468 = (void *)(a2 + 40388);
  v439 = (_QWORD *)(a2 + 14632);
  v440 = (_QWORD *)(a2 + 16792);
  v441 = (_QWORD *)(a2 + 17272);
  v442 = (_QWORD *)(a2 + 17032);
  v443 = (_QWORD *)(a2 + 16552);
  v444 = (_QWORD *)(a2 + 23512);
  v445 = (_QWORD *)(a2 + 23272);
  v446 = (_QWORD *)(a2 + 18472);
  v448 = (_QWORD *)(a2 + 9352);
  v447 = (_QWORD *)(a2 + 9592);
  v450 = (_QWORD *)(a2 + 18232);
  v460 = (_QWORD *)(a2 + 11992);
  v469 = (uint64_t *)(a2 + 7744);
  v470 = (char *)(a2 + 66842);
  v457 = (_QWORD *)(a2 + 66304);
  v459 = (_QWORD *)(a2 + 66288);
  v464 = (uint64_t *)(a2 + 41320);
  v466 = (uint64_t *)(a2 + 41312);
  v449 = (uint64_t *)(a2 + 40360);
  v451 = (uint64_t *)(a2 + 40352);
  v454 = (uint64_t *)(a2 + 41224);
  v453 = (uint64_t *)(a2 + 41232);
  v452 = (uint64_t *)(a2 + 41240);
  v455 = (_BYTE *)(a2 + 66160);
  v456 = (_BYTE *)(a2 + 40288);
  v458 = (_BYTE *)(a2 + 39261);
  v461 = (_BYTE *)(a2 + 39518);
  v463 = (_BYTE *)(a2 + 39004);
  v465 = (_BYTE *)(a2 + 38747);
  __s1 = (char *)(a5 + 5);
  __s = (char *)(a2 + 38490);
  do
  {
    v15 = ssftriff_reader_OpenChunk(a3, (__int32 *)__src, (unsigned int *)&v484, 0, (uint64_t)a5, a6, a7, a8);
    if ((v15 & 0x80000000) != 0)
      break;
    cstdlib_strcpy(__dst, __src);
    if (a4 == 1)
    {
      if (!cstdlib_strcmp(a5, "FEEX"))
      {
        if (!cstdlib_strcmp(__src, "VCAT"))
        {
          *(_QWORD *)__s2 = 0;
          if (v9)
          {
            *(_QWORD *)__s2 = v9 + ssftriff_reader_GetPosition(a3) - v8;
          }
          else
          {
            ChunkData = ssftriff_reader_GetChunkData(a3, v484, __s2, v118, v119, v120, v121, v122);
            if ((ChunkData & 0x80000000) != 0)
              return ChunkData;
          }
          v175 = v14;
          v176 = a2;
          v177 = a3;
          v178 = 2;
LABEL_414:
          v290 = a5;
          v291 = 0;
          v292 = 0;
LABEL_415:
          RiffStringTable = select_bet4_ParseRiff(v175, v176, v177, v178, v290, v291, v292);
          goto LABEL_610;
        }
        if (!cstdlib_strcmp(__src, "VBOP"))
        {
          *(_QWORD *)__s2 = 0;
          if (v9)
          {
            v205 = (unsigned __int16 *)(v9 + ssftriff_reader_GetPosition(a3) - v8);
            *(_QWORD *)__s2 = v205;
          }
          else
          {
            v15 = ssftriff_reader_GetChunkData(a3, v484, __s2, v123, v124, v125, v126, v127);
            if ((v15 & 0x80000000) != 0)
              return v15;
            v205 = *(unsigned __int16 **)__s2;
          }
          if (v484 >= 0xF8)
            v311 = 248;
          else
            v311 = v484;
          v312 = v468;
LABEL_460:
          cstdlib_memcpy(v312, v205, v311);
          goto LABEL_611;
        }
        if (!cstdlib_strcmp(__src, "PRE3"))
        {
          *(_WORD *)v486 = 0;
          *(_QWORD *)__s2 = 0;
          if (v9)
          {
            *(_QWORD *)__s2 = v9 + ssftriff_reader_GetPosition(a3) - v8;
          }
          else
          {
            v15 = ssftriff_reader_GetChunkData(a3, v484, __s2, v128, v129, v130, v131, v132);
            if ((v15 & 0x80000000) != 0)
              return v15;
          }
          if (v484 >= 2)
          {
            v341 = 0;
            do
            {
              cstdlib_memcpy(v486, (const void *)(*(_QWORD *)__s2 + 2 * v341), 2uLL);
              if (*(unsigned __int16 *)v486 < 0x47u)
                *(_DWORD *)(a2 + 4 * *(unsigned __int16 *)v486 + 40936) = 1;
              else
                log_OutText(*(_QWORD *)(v14 + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Unknown preselection feature: %u for %s", v342, v343, v344, *(unsigned __int16 *)v486);
              ++v341;
            }
            while (v484 >> 1 > v341);
          }
          goto LABEL_611;
        }
        if (!cstdlib_strcmp(__src, "TRA3"))
        {
          *(_WORD *)v486 = 0;
          *(_QWORD *)__s2 = 0;
          if (v9)
          {
            *(_QWORD *)__s2 = v9 + ssftriff_reader_GetPosition(a3) - v8;
          }
          else
          {
            v15 = ssftriff_reader_GetChunkData(a3, v484, __s2, v133, v134, v135, v136, v137);
            if ((v15 & 0x80000000) != 0)
              return v15;
          }
          if (v484 >= 2)
          {
            v350 = 0;
            do
            {
              cstdlib_memcpy(v486, (const void *)(*(_QWORD *)__s2 + 2 * v350), 2uLL);
              if (*(unsigned __int16 *)v486 < 8u)
                *(_DWORD *)(a2 + 4 * *(unsigned __int16 *)v486 + 41264) = 1;
              else
                log_OutText(*(_QWORD *)(v14 + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Unknown transition feature: %u for %s", v351, v352, v353, *(unsigned __int16 *)v486);
              ++v350;
            }
            while (v484 >> 1 > v350);
          }
          goto LABEL_611;
        }
        if (!cstdlib_strcmp(__src, "TRAF"))
        {
          *(_QWORD *)__s2 = 0;
          if (v9)
          {
            v338 = (unsigned __int16 *)(v9 + ssftriff_reader_GetPosition(a3) - v8);
            *(_QWORD *)__s2 = v338;
          }
          else
          {
            ChunkData = ssftriff_reader_GetChunkData(a3, v484, __s2, v138, v139, v140, v141, v142);
            if ((ChunkData & 0x80000000) != 0)
              return ChunkData;
            v338 = *(unsigned __int16 **)__s2;
          }
          *((_WORD *)v474 + 432) = *(_DWORD *)v338;
          ssftriff_reader_Seek(a3, 4u, 1);
          v364 = heap_Calloc(*(_QWORD **)(v14 + 8), 12, *((unsigned __int16 *)v474 + 432));
          *((_QWORD *)v474 + 109) = v364;
          if (!v364)
            return 2229280778;
LABEL_561:
          v365 = v14;
          v366 = a2;
          v367 = a3;
          v368 = 2;
          v369 = a5;
          v370 = 0;
          v371 = 0;
LABEL_562:
          v348 = select_bet4_ParseRiff(v365, v366, v367, v368, v369, v370, v371);
          goto LABEL_563;
        }
        if (!cstdlib_strcmp(__src, "PHM3"))
        {
          *(_QWORD *)__s2 = 0;
          if (v9)
          {
            v205 = (unsigned __int16 *)(v9 + ssftriff_reader_GetPosition(a3) - v8);
            *(_QWORD *)__s2 = v205;
          }
          else
          {
            v15 = ssftriff_reader_GetChunkData(a3, v484, __s2, v143, v144, v145, v146, v147);
            if ((v15 & 0x80000000) != 0)
              return v15;
            v205 = *(unsigned __int16 **)__s2;
          }
          if (v484 >= 0x100)
            v311 = 256;
          else
            v311 = v484;
          v312 = v462;
          goto LABEL_460;
        }
        if (!cstdlib_strcmp(__src, "CTXR"))
          goto LABEL_561;
        goto LABEL_599;
      }
      if (!cstdlib_strcmp(a5, "STM3"))
      {
        *(_DWORD *)v485 = 0;
        v148 = *(int *)(a2 + 260);
        if (!cstdlib_strcmp(__src, "STC3"))
        {
          LODWORD(v480) = 0;
          *(_QWORD *)v486 = 0;
          if (a6)
          {
            v283 = a6 + ssftriff_reader_GetPosition(a3) - v8;
            *(_QWORD *)v486 = v283;
          }
          else
          {
            v15 = ssftriff_reader_GetChunkData(a3, v484, v486, v149, v150, v151, v152, v153);
            if ((v15 & 0x80000000) != 0)
              return v15;
            v283 = *(_QWORD *)v486;
          }
          v313 = (int *)(a2 + 4 * v148);
          cstdlib_memcpy(v313 + 88, (const void *)(v283 + *(unsigned int *)v485), 4uLL);
          *(_DWORD *)v485 += 4;
          v437 = v313 + 98;
          cstdlib_memcpy(v313 + 98, (const void *)(*(_QWORD *)v486 + *(unsigned int *)v485), 4uLL);
          v314 = *(_DWORD *)v485;
          *(_DWORD *)v485 += 4;
          v315 = *(_QWORD *)v486;
          v313[568] = *(_BYTE *)(*(_QWORD *)v486 + *(unsigned int *)v485) != 0;
          v316 = v314 + 5;
          *(_DWORD *)v485 = v316;
          cstdlib_memcpy(v313 + 558, (const void *)(v315 + v316), 4uLL);
          v317 = *(_DWORD *)v485 + 4;
          *(_DWORD *)v485 += 4;
          v318 = v313[98];
          v319 = v148;
          v438 = v8;
          if ((int)v318 < 1)
          {
            v322 = v148;
            v320 = a1;
LABEL_472:
            __s2[0] = 0;
            LODWORD(v480) = 256;
            LODWORD(v15) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v486, v484, v317, __s2, (unsigned int *)&v480);
            if ((v15 & 0x80000000) == 0)
            {
              v330 = MFS__heap_StrDup(*(_QWORD **)(v320 + 8), __s2);
              v331 = (_QWORD *)(a2 + 8 * v322);
              v331[34] = v330;
              *(_DWORD *)v485 += (_DWORD)v480;
              if (!v330)
                goto LABEL_583;
              if (*v437 >= 1)
              {
                v332 = 0;
                v333 = v331 + 309;
                v334 = v331 + 289;
                while (1)
                {
                  __s2[0] = 0;
                  LODWORD(v480) = 256;
                  StringZ = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v486, v484, *(unsigned int *)v485, __s2, (unsigned int *)&v480);
                  if (StringZ < 0)
                    break;
                  *(_QWORD *)(*v333 + 8 * v332) = MFS__heap_StrDup(*(_QWORD **)(a1 + 8), __s2);
                  if (!*(_QWORD *)(*v333 + 8 * v332))
                    goto LABEL_583;
                  *(_DWORD *)v485 += (_DWORD)v480;
                  __s2[0] = 0;
                  LODWORD(v480) = 256;
                  LODWORD(v15) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v486, v484, *(unsigned int *)v485, __s2, (unsigned int *)&v480);
                  if ((v15 & 0x80000000) == 0)
                  {
                    *(_QWORD *)(*v334 + 8 * v332) = MFS__heap_StrDup(*(_QWORD **)(a1 + 8), __s2);
                    if (!*(_QWORD *)(*v334 + 8 * v332))
                      goto LABEL_583;
                    *(_DWORD *)v485 += (_DWORD)v480;
                    if (++v332 < *v437)
                      continue;
                  }
                  goto LABEL_584;
                }
                LODWORD(v15) = StringZ;
              }
            }
          }
          else
          {
            v320 = a1;
            v321 = heap_Calloc(*(_QWORD **)(a1 + 8), v318, 8);
            v322 = v319;
            v323 = a2 + 8 * v319;
            *(_QWORD *)(v323 + 2472) = v321;
            if (!v321)
              LODWORD(v15) = -2065686518;
            if ((v15 & 0x80000000) == 0)
            {
              v324 = heap_Calloc(*(_QWORD **)(a1 + 8), *v437, 8);
              *(_QWORD *)(v323 + 2312) = v324;
              if (v324)
              {
                v325 = heap_Calloc(*(_QWORD **)(a1 + 8), *v437, 8);
                *(_QWORD *)(a2 + 8 * v319 + 2392) = v325;
                if (v325)
                {
                  v317 = *(_DWORD *)v485;
                  goto LABEL_472;
                }
LABEL_583:
                LODWORD(v15) = -2065686518;
              }
              else
              {
                LODWORD(v15) = -2065686518;
              }
            }
          }
LABEL_584:
          v8 = v438;
          v9 = a6;
          v14 = a1;
          goto LABEL_611;
        }
        if (cstdlib_strcmp(__src, "TRE3"))
        {
          if (cstdlib_strcmp(__src, "PDF3"))
          {
            if (cstdlib_strcmp(__src, "WIN3"))
            {
              if (!cstdlib_strcmp(__src, "STC4"))
              {
                LODWORD(v480) = 0;
                *(_QWORD *)v486 = 0;
                v438 = v8;
                if (a6)
                {
                  v349 = (int *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
                }
                else
                {
                  v15 = ssftriff_reader_GetChunkData(a3, v484, v486, v164, v165, v166, v167, v168);
                  if ((v15 & 0x80000000) != 0)
                    return v15;
                  v349 = *(int **)v486;
                }
                v377 = (int *)(a2 + 4 * v148);
                v377[2032] = *v349;
                v377[2062] = v349[1];
                v377[2078] = v349[2];
                v377[2218] = v349[3];
                v377[2198] = v349[4];
                v377[2208] = v349[5];
                v377[2231] = v349[6];
                v377[2241] = v349[7];
                *(_QWORD *)v486 = v349 + 8;
                if (v377[98] >= 1)
                {
                  v378 = 0;
                  v379 = v377 + 98;
                  v380 = (_QWORD *)(a2 + 8 * v148 + 2392);
                  v381 = *(_DWORD *)v485;
                  do
                  {
                    __s2[0] = 0;
                    LODWORD(v480) = 256;
                    LODWORD(v15) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v486, v484, v381, __s2, (unsigned int *)&v480);
                    if ((v15 & 0x80000000) != 0)
                      break;
                    *(_QWORD *)(*v380 + 8 * v378) = MFS__heap_StrDup(*(_QWORD **)(a1 + 8), __s2);
                    if (!*(_QWORD *)(*v380 + 8 * v378))
                      goto LABEL_583;
                    v381 = *(_DWORD *)v485 + (_DWORD)v480;
                    *(_DWORD *)v485 += (_DWORD)v480;
                    ++v378;
                  }
                  while (v378 < *v379);
                }
                goto LABEL_584;
              }
              if (cstdlib_strcmp(__src, "STW4"))
              {
                if (!cstdlib_strcmp(__src, "UQD4"))
                {
                  v373 = v484;
                  v374 = a2;
                  v375 = a3;
                  v376 = 13;
LABEL_620:
                  v397 = v148;
                  v9 = a6;
                  LODWORD(v15) = select_bet4_LoadMfsData(v374, v375, v376, v397, v373, a6, v8, 1);
                  goto LABEL_611;
                }
                if (!cstdlib_strcmp(__src, "UQB4"))
                {
                  v382 = v484;
                  v383 = a2;
                  v384 = a3;
                  v385 = 14;
                  goto LABEL_588;
                }
                if (!cstdlib_strcmp(__src, "UNP4"))
                {
                  v373 = v484;
                  v374 = a2;
                  v375 = a3;
                  v376 = 10;
                  goto LABEL_620;
                }
                if (!cstdlib_strcmp(__src, "PCI4"))
                {
                  v9 = a6;
                  MfsData = select_bet4_ParseRiff(v14, a2, a3, 2, a5, a6, v8);
                  goto LABEL_597;
                }
                if (!cstdlib_strcmp(__src, "GVM4"))
                {
                  v382 = v484;
                  v383 = a2;
                  v384 = a3;
                  v385 = 24;
                  goto LABEL_588;
                }
                if (!cstdlib_strcmp(__src, "JCI4"))
                {
                  v382 = v484;
                  v383 = a2;
                  v384 = a3;
                  v385 = 26;
                  goto LABEL_588;
                }
                if (!cstdlib_strcmp(__src, "JCS4"))
                {
                  v382 = v484;
                  v383 = a2;
                  v384 = a3;
                  v385 = 27;
                  goto LABEL_588;
                }
                if (!cstdlib_strcmp(__src, "SNG4"))
                {
                  v382 = v484;
                  v383 = a2;
                  v384 = a3;
                  v385 = 28;
LABEL_588:
                  v386 = v148;
                  v9 = a6;
                  MfsData = select_bet4_LoadMfsData(v383, v384, v385, v386, v382, a6, v8, 0);
LABEL_597:
                  LODWORD(v15) = MfsData;
                  goto LABEL_611;
                }
                v174 = 0;
LABEL_593:
                v9 = a6;
                if (v174)
                  goto LABEL_611;
LABEL_599:
                cstdlib_strcpy(__s2, "");
                v389 = 0;
                do
                {
                  cstdlib_strcat(__s2, "/");
                  cstdlib_strcat(__s2, &a5[5 * (unsigned __int16)v389++]);
                }
                while (a4 >= (unsigned __int16)v389);
                log_OutText(*(_QWORD *)(v14 + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Unknown data: %s for %s", v390, v391, v392, (uint64_t)__s2);
                goto LABEL_611;
              }
              *(_QWORD *)__s2 = 0;
              if (a6)
              {
                v363 = (unsigned __int16 *)(a6 + ssftriff_reader_GetPosition(a3) - v8);
              }
              else
              {
                v15 = ssftriff_reader_GetChunkData(a3, v484, __s2, v169, v170, v171, v172, v173);
                if ((v15 & 0x80000000) != 0)
                  return v15;
                v363 = *(unsigned __int16 **)__s2;
              }
              v388 = a2 + 4 * v148;
              *(_DWORD *)(v388 + 8168) = *(_DWORD *)v363;
              *(_DWORD *)(v388 + 8208) = *((_DWORD *)v363 + 1);
              goto LABEL_592;
            }
            v339 = a2 + 128 + 4 * v148;
            v340 = *(_DWORD *)(v339 + 304);
            v288 = a2 + 128 + 120 * (int)v148 + 24 * v340 + 3864;
            *(_DWORD *)(v339 + 304) = v340 + 1;
          }
          else
          {
            *(_QWORD *)v486 = 0;
            if (a6)
            {
              v306 = a6 + ssftriff_reader_GetPosition(a3) - v8;
              *(_QWORD *)v486 = v306;
            }
            else
            {
              ChunkData = ssftriff_reader_GetChunkData(a3, v484, v486, v159, v160, v161, v162, v163);
              if ((ChunkData & 0x80000000) != 0)
                return ChunkData;
              v306 = *(_QWORD *)v486;
            }
            *(_DWORD *)v485 = 256;
            LODWORD(v15) = ssftriff_reader_ReadStringZ(a3, v306, v484, 0, __s2, (unsigned int *)v485);
            if ((v15 & 0x80000000) != 0)
            {
              v288 = 0;
            }
            else
            {
              v354 = MFS__heap_StrDup(*(_QWORD **)(v14 + 8), __s2);
              v355 = a2 + 128 + 4 * v148;
              v356 = *(int *)(v355 + 344);
              *(_QWORD *)(a2 + 128 + 40 * (int)v148 + 8 * v356 + 1304) = v354;
              if ((v485[0] & 3) != 0)
                *(_DWORD *)v485 -= *(_DWORD *)v485 | 0xFFFFFFFC;
              v288 = a2 + 120 * (int)v148 + 24 * (int)v356 + 2792;
              *(_DWORD *)(v355 + 344) = v356 + 1;
            }
          }
        }
        else
        {
          v288 = a2 + 24 * (int)v148 + 2552;
        }
        v174 = 1;
        if ((v15 & 0x80000000) != 0 || !v288)
          goto LABEL_593;
        *(_QWORD *)__s2 = 0;
        if (a6)
        {
          Position = ssftriff_reader_GetPosition(a3);
          v358 = *(_DWORD *)v485;
          *(_QWORD *)(v288 + 8) = a6 + (Position - v8) + *(unsigned int *)v485;
          v359 = v484 - v358;
        }
        else
        {
          v360 = *(unsigned __int16 *)(v471 + 544);
          LODWORD(v15) = -2065686524;
          if (v360 > 0x3F)
            goto LABEL_592;
          if (*(_DWORD *)v485)
          {
            ssftriff_reader_Seek(a3, *(unsigned int *)v485, 1);
            v360 = *(unsigned __int16 *)(v471 + 544);
          }
          LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v360 + 66328), __s2, v154, v155, v156, v157, v158);
          if ((v15 & 0x80000000) != 0)
            goto LABEL_592;
          ++*(_WORD *)(v471 + 544);
          v361 = v484;
          *(_DWORD *)(v471 + 24) += v484;
          *(_QWORD *)(v288 + 8) = *(_QWORD *)__s2;
          v359 = v361 - *(_DWORD *)v485;
        }
        *(_DWORD *)(v288 + 16) = v359;
LABEL_592:
        v174 = 1;
        goto LABEL_593;
      }
      if (!cstdlib_strcmp(a5, "WCI4"))
      {
        if (!cstdlib_strcmp(__src, "STRP"))
        {
          v103 = v484;
          v104 = a2;
          v105 = a3;
          v106 = 17;
          goto LABEL_608;
        }
        if (!cstdlib_strcmp(__src, "STI4"))
        {
          v103 = v484;
          v104 = a2;
          v105 = a3;
          v106 = 19;
          goto LABEL_608;
        }
        if (!cstdlib_strcmp(__src, "PCIL"))
        {
          v99 = v484;
          v100 = a2;
          v101 = a3;
          v102 = 18;
          goto LABEL_126;
        }
        goto LABEL_599;
      }
      if (!cstdlib_strcmp(a5, "SCI4"))
      {
        if (!cstdlib_strcmp(__src, "STRP"))
        {
          v103 = v484;
          v104 = a2;
          v105 = a3;
          v106 = 20;
          goto LABEL_608;
        }
        if (!cstdlib_strcmp(__src, "STI4"))
        {
          v103 = v484;
          v104 = a2;
          v105 = a3;
          v106 = 22;
          goto LABEL_608;
        }
        if (!cstdlib_strcmp(__src, "PCIL"))
        {
          v99 = v484;
          v100 = a2;
          v101 = a3;
          v102 = 21;
LABEL_126:
          v204 = 0;
LABEL_516:
          v348 = select_bet4_LoadMfsData(v100, v101, v102, v204, v99, v9, v8, 0);
LABEL_563:
          LODWORD(v15) = v348;
          goto LABEL_611;
        }
        goto LABEL_599;
      }
      if (cstdlib_strcmp(a5, "UND4"))
        goto LABEL_599;
      if (!cstdlib_strcmp(__src, "USLL"))
      {
        v103 = v484;
        v104 = a2;
        v105 = a3;
        v106 = 3;
        goto LABEL_608;
      }
      if (!cstdlib_strcmp(__src, "ULEN"))
      {
        v103 = v484;
        v104 = a2;
        v105 = a3;
        v106 = 4;
        goto LABEL_608;
      }
      if (!cstdlib_strcmp(__src, "UCTX"))
      {
        v103 = v484;
        v104 = a2;
        v105 = a3;
        v106 = 5;
        goto LABEL_608;
      }
      if (!cstdlib_strcmp(__src, "UDUR"))
      {
        v103 = v484;
        v104 = a2;
        v105 = a3;
        v106 = 6;
        goto LABEL_608;
      }
      if (!cstdlib_strcmp(__src, "UBSL"))
      {
        v103 = v484;
        v104 = a2;
        v105 = a3;
        v106 = 7;
        goto LABEL_608;
      }
      if (!cstdlib_strcmp(__src, "UISR"))
      {
        v103 = v484;
        v104 = a2;
        v105 = a3;
        v106 = 8;
LABEL_608:
        v303 = v9;
        v304 = v8;
        v305 = 0;
LABEL_609:
        RiffStringTable = select_bet4_LoadMfsData(v104, v105, v106, 0, v103, v303, v304, v305);
LABEL_610:
        LODWORD(v15) = RiffStringTable;
        goto LABEL_611;
      }
      if (!cstdlib_strcmp(__src, "UMOF"))
      {
        v103 = v484;
        v104 = a2;
        v105 = a3;
        v106 = 9;
        goto LABEL_608;
      }
    }
    else
    {
      if (a4)
      {
        if (cstdlib_strcmp(a5, "FEEX") || cstdlib_strcmp(__s1, "VCAT"))
        {
          if (!cstdlib_strcmp(a5, "FEEX") && !cstdlib_strcmp(__s1, "TRAF") && !cstdlib_strcmp(__src, "FEAT"))
          {
            *(_QWORD *)__s2 = 0;
            if (v9)
            {
              v302 = (unsigned __int16 *)(v9 + ssftriff_reader_GetPosition(a3) - v8);
            }
            else
            {
              v15 = ssftriff_reader_GetChunkData(a3, v484, __s2, v112, v113, v114, v115, v116);
              if ((v15 & 0x80000000) != 0)
                return v15;
              v302 = *(unsigned __int16 **)__s2;
            }
            v345 = *v302;
            *(_QWORD *)__s2 = v302 + 1;
            if (v345 >= 8)
            {
              log_OutPublic(*(_QWORD *)(v14 + 32), (uint64_t)"SELECT_BET4", 58010, (uint64_t)"%s%hu", v298, v299, v300, v301, "feature");
              return 2229280772;
            }
            *(_DWORD *)(a2 + 4 * v345 + 41264) = v467;
            v346 = *((_QWORD *)v474 + 109) + 12 * v467;
            *(_DWORD *)v346 = v345;
            *(_WORD *)(v346 + 8) = v302[1];
            *(_DWORD *)(v346 + 4) = *((_DWORD *)v302 + 1);
            ++v467;
            goto LABEL_611;
          }
          if (cstdlib_strcmp(a5, "FEEX") || cstdlib_strcmp(__s1, "CTXR"))
          {
            if (!cstdlib_strcmp(a5, "STM3") && !cstdlib_strcmp(__s1, "PCI4"))
            {
              v117 = *(unsigned int *)(a2 + 260);
              if (*(_DWORD *)(a2 + 8456))
              {
                if (!cstdlib_strcmp(__src, "OPCI"))
                {
                  v99 = v484;
                  v100 = a2;
                  v101 = a3;
                  v102 = 55;
                  goto LABEL_515;
                }
                if (!cstdlib_strcmp(__src, "OPCL"))
                {
                  v99 = v484;
                  v100 = a2;
                  v101 = a3;
                  v102 = 56;
LABEL_515:
                  v204 = v117;
                  goto LABEL_516;
                }
              }
              else
              {
                if (!cstdlib_strcmp(__src, "PCII"))
                {
                  v99 = v484;
                  v100 = a2;
                  v101 = a3;
                  v102 = 15;
                  goto LABEL_515;
                }
                if (!cstdlib_strcmp(__src, "PCIL"))
                {
                  v99 = v484;
                  v100 = a2;
                  v101 = a3;
                  v102 = 16;
                  goto LABEL_515;
                }
              }
            }
          }
          else
          {
            if (!cstdlib_strcmp(__src, "RULF"))
            {
              *(_QWORD *)__s2 = 0;
              if (v9)
              {
                v203 = (unsigned __int16 *)(v9 + ssftriff_reader_GetPosition(a3) - v8);
                *(_QWORD *)__s2 = v203;
              }
              else
              {
                ChunkData = ssftriff_reader_GetChunkData(a3, v484, __s2, v182, v183, v184, v185, v186);
                if ((ChunkData & 0x80000000) != 0)
                  return ChunkData;
                v203 = *(unsigned __int16 **)__s2;
              }
              v307 = v484;
              v308 = v14;
              v309 = a3;
              v310 = v466;
LABEL_552:
              RiffStringTable = uselect_LoadRiffStringTable(v308, v309, v203, v307, v310);
              goto LABEL_610;
            }
            if (!cstdlib_strcmp(__src, "RULT"))
            {
              *(_QWORD *)__s2 = 0;
              if (v9)
              {
                v203 = (unsigned __int16 *)(v9 + ssftriff_reader_GetPosition(a3) - v8);
                *(_QWORD *)__s2 = v203;
              }
              else
              {
                ChunkData = ssftriff_reader_GetChunkData(a3, v484, __s2, v187, v188, v189, v190, v191);
                if ((ChunkData & 0x80000000) != 0)
                  return ChunkData;
                v203 = *(unsigned __int16 **)__s2;
              }
              v307 = v484;
              v308 = v14;
              v309 = a3;
              v310 = v464;
              goto LABEL_552;
            }
            if (!cstdlib_strcmp(__src, "TRD4"))
            {
              v347 = *(unsigned __int16 *)(v471 + 544);
              if (v347 <= 0x3F)
              {
                LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v347 + 66328), v459, v192, v193, v194, v195, v196);
                if ((v15 & 0x80000000) == 0)
                {
                  ++*(_WORD *)(v471 + 544);
                  v362 = v484;
                  *(_DWORD *)(v471 + 24) += v484;
                  *(_DWORD *)v471 = v362 / 0xC;
                }
                goto LABEL_611;
              }
LABEL_510:
              LODWORD(v15) = -2065686524;
              goto LABEL_611;
            }
            if (!cstdlib_strcmp(__src, "TRP4"))
            {
              v202 = *(unsigned __int16 *)(v471 + 544);
              if (v202 <= 0x3F)
              {
                LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v202 + 66328), v457, v197, v198, v199, v200, v201);
                if ((v15 & 0x80000000) == 0)
                {
                  ++*(_WORD *)(v471 + 544);
                  v372 = v484;
                  *(_DWORD *)(v471 + 24) += v484;
                  *(_DWORD *)(v471 + 16) = v372 / 0xC;
                }
              }
              else
              {
                LODWORD(v15) = -2065686524;
              }
              goto LABEL_611;
            }
          }
        }
        else
        {
          *(_QWORD *)__s2 = 0;
          if (v9)
          {
            *(_QWORD *)__s2 = v9 + ssftriff_reader_GetPosition(a3) - v8;
          }
          else
          {
            v15 = ssftriff_reader_GetChunkData(a3, v484, __s2, v107, v108, v109, v110, v111);
            if ((v15 & 0x80000000) != 0)
              return v15;
          }
          if (!cstdlib_strcmp(__src, "ALPH"))
          {
            *(_DWORD *)v486 = 257;
            LODWORD(v15) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)__s2, v484, 0, __s, (unsigned int *)v486);
            if ((v15 & 0x80000000) == 0)
            {
              *(_WORD *)v474 = 255;
              if (cstdlib_strlen(__s))
              {
                v293 = 0;
                v294 = 0;
                do
                {
                  v295 = (unsigned __int8 *)(a2 + v293 + 38490);
                  v296 = *v295;
                  if (v296 < *v474)
                  {
                    *v474 = v296;
                    v296 = *v295;
                  }
                  if (v296 > v474[1])
                  {
                    v474[1] = v296;
                    v296 = *v295;
                  }
                  *(_BYTE *)(a2 + v296 + 40032) = v294;
                  v293 = (v294 + 1);
                  v297 = cstdlib_strlen(__s);
                  v294 = v293;
                }
                while (v297 > v293);
              }
            }
            goto LABEL_611;
          }
          if (!cstdlib_strcmp(__src, "VOIC"))
          {
            *(_DWORD *)v486 = 257;
            v326 = *(_QWORD *)__s2;
            v327 = v484;
            v328 = a3;
            v329 = v465;
            goto LABEL_596;
          }
          if (!cstdlib_strcmp(__src, "COVO"))
          {
            *(_DWORD *)v486 = 257;
            v326 = *(_QWORD *)__s2;
            v327 = v484;
            v328 = a3;
            v329 = v463;
            goto LABEL_596;
          }
          if (!cstdlib_strcmp(__src, "SAFE"))
          {
            *(_DWORD *)v486 = 257;
            v326 = *(_QWORD *)__s2;
            v327 = v484;
            v328 = a3;
            v329 = v461;
            goto LABEL_596;
          }
          if (!cstdlib_strcmp(__src, "PLOS"))
          {
            *(_DWORD *)v486 = 257;
            v326 = *(_QWORD *)__s2;
            v327 = v484;
            v328 = a3;
            v329 = v458;
            goto LABEL_596;
          }
          if (!cstdlib_strcmp(__src, "DIFF"))
          {
            *(_DWORD *)v486 = 64;
            v326 = *(_QWORD *)__s2;
            v327 = v484;
            v328 = a3;
            v329 = v456;
            goto LABEL_596;
          }
          if (!cstdlib_strcmp(__src, "NUCL"))
          {
            *(_DWORD *)v486 = 128;
            v326 = *(_QWORD *)__s2;
            v327 = v484;
            v328 = a3;
            v329 = v455;
LABEL_596:
            MfsData = ssftriff_reader_ReadStringZ(v328, v326, v327, 0, v329, (unsigned int *)v486);
            goto LABEL_597;
          }
          if (!cstdlib_strcmp(__src, "GENF"))
          {
            MfsData = select_bet4_LoadRiffGenericFeatureMap(v14, a3, *(unsigned __int16 **)__s2, v484, v454, v453, v452);
            goto LABEL_597;
          }
          if (!cstdlib_strcmp(__src, "TAGA"))
          {
            v398 = *(unsigned __int16 **)__s2;
            v399 = v484;
            v400 = v14;
            v401 = a3;
            v402 = v451;
LABEL_631:
            MfsData = uselect_LoadRiffStringTable(v400, v401, v398, v399, v402);
            goto LABEL_597;
          }
          if (!cstdlib_strcmp(__src, "BTOA"))
          {
            v398 = *(unsigned __int16 **)__s2;
            v399 = v484;
            v400 = v14;
            v401 = a3;
            v402 = v449;
            goto LABEL_631;
          }
        }
        goto LABEL_599;
      }
      if (!cstdlib_strcmp(__src, "VINF"))
      {
        LODWORD(v480) = 0;
        *(_QWORD *)v485 = 0;
        if (v9)
        {
          *(_QWORD *)v485 = v9 + ssftriff_reader_GetPosition(a3) - v8;
        }
        else
        {
          v15 = ssftriff_reader_GetChunkData(a3, v484, v485, v16, v17, v18, v19, v20);
          if ((v15 & 0x80000000) != 0)
            return v15;
        }
        v179 = v484;
        if (!v484)
          goto LABEL_611;
        v180 = 0;
        while (1)
        {
          v486[0] = 0;
          __s2[0] = 0;
          LODWORD(v480) = 1024;
          LODWORD(v15) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v485, v179, v180, __s2, (unsigned int *)&v480);
          if ((v15 & 0x80000000) == 0 && v180 < v484)
          {
            v180 += v480;
            LODWORD(v480) = 1024;
            LODWORD(v15) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v485, v484, v180, v486, (unsigned int *)&v480);
          }
          if ((v15 & 0x80000000) != 0)
            goto LABEL_113;
          v181 = (int)v480;
          if (!cstdlib_strcmp("GUID", __s2) || !cstdlib_strcmp("ComponentID", __s2))
          {
            cstdlib_strcpy(v470, v486);
            goto LABEL_113;
          }
          v180 += v181;
          v179 = v484;
          v14 = a1;
          if (v180 >= v484)
            goto LABEL_611;
        }
      }
      if (!cstdlib_strcmp(__src, "VCFG"))
      {
        v481 = 0;
        *(_QWORD *)v479 = 0;
        v480 = 0;
        if (v9)
        {
          *(_QWORD *)v479 = v9 + ssftriff_reader_GetPosition(a3) - v8;
        }
        else
        {
          v15 = ssftriff_reader_GetChunkData(a3, v484, v479, v21, v22, v23, v24, v25);
          if ((v15 & 0x80000000) != 0)
            return v15;
        }
        v206 = v484;
        if (v484)
        {
          v207 = 0;
          do
          {
            __s2[0] = 0;
            v485[0] = 0;
            v481 = 64;
            LODWORD(v15) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v479, v206, v207, v485, &v481);
            if ((v15 & 0x80000000) == 0 && v207 < v484)
            {
              v207 += v481;
              v481 = 256;
              LODWORD(v15) = ssftriff_reader_ReadStringZ(a3, *(uint64_t *)v479, v484, v207, __s2, &v481);
            }
            if ((v15 & 0x80000000) != 0)
              break;
            v208 = v481;
            cstdlib_strcpy(v486, "bet4voiceoverride.");
            cstdlib_strcat(v486, v485);
            if ((paramc_ParamGetStr(*(_QWORD *)(v14 + 40), (uint64_t)v486, &v480) & 0x80000000) != 0 || !v480 || !*v480)
              v480 = __s2;
            if (!cstdlib_strcmp(v485, "ALPHA"))
            {
              v209 = atof(v480);
              *(float *)(a2 + 128) = v209;
            }
            if (!cstdlib_strcmp(v485, "BETA"))
            {
              v210 = atof(v480);
              *(float *)(a2 + 132) = v210;
            }
            if (!cstdlib_strcmp(v485, "FS"))
              *(_DWORD *)(a2 + 136) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "VUV_REL_AMP"))
            {
              v211 = atof(v480);
              *(float *)(a2 + 140) = v211;
            }
            if (!cstdlib_strcmp(v485, "ORDER"))
              *(_DWORD *)(a2 + 144) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "FRAME_SIZE"))
              *(_DWORD *)(a2 + 152) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "RHO"))
            {
              v212 = atof(v480);
              *(float *)(a2 + 160) = v212;
            }
            if (!cstdlib_strcmp(v485, "VOL"))
            {
              v213 = atof(v480);
              *(float *)(a2 + 164) = v213;
            }
            if (!cstdlib_strcmp(v485, "MVF_BOOST"))
            {
              v214 = atof(v480);
              *(float *)(a2 + 168) = v214;
            }
            if (!cstdlib_strcmp(v485, "F0_RHO"))
            {
              v215 = atof(v480);
              *(float *)(a2 + 172) = v215;
            }
            if (!cstdlib_strcmp(v485, "F0_STD"))
            {
              v216 = atof(v480);
              *(float *)(a2 + 176) = v216;
            }
            if (!cstdlib_strcmp(v485, "F0_MEAN"))
            {
              v217 = atof(v480);
              *(float *)(a2 + 180) = v217;
            }
            if (!cstdlib_strcmp(v485, "B_SILENCE_SYNTH"))
              *(_DWORD *)(a2 + 7752) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "SPEECH_F0_MEAN"))
              *(_DWORD *)(a2 + 184) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "PDF_VARIANCE_TYPE"))
              *(_DWORD *)(a2 + 200) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "BREAKER"))
            {
              v218 = MFS__heap_StrDup(*(_QWORD **)(v14 + 8), v480);
              *(_QWORD *)(a2 + 208) = v218;
              if (!v218)
                LODWORD(v15) = -2065686518;
            }
            if (!cstdlib_strcmp(v485, "BRK_LENGTH"))
              *(_DWORD *)(a2 + 216) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "BRK_TC"))
              *(_DWORD *)(a2 + 220) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "BRK_ZPAD"))
              *(_DWORD *)(a2 + 224) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "ALGN_ST"))
              *(_DWORD *)(a2 + 240) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "ALGN_PH"))
              *(_DWORD *)(a2 + 244) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "F_JCOST_WEIGHT_ADJ"))
            {
              v219 = atof(v480);
              *(float *)(a2 + 8288) = v219;
            }
            if (!cstdlib_strcmp(v485, "F_JCOST_WEIGHT_SLL"))
            {
              v220 = atof(v480);
              *(float *)(a2 + 8516) = v220;
            }
            if (!cstdlib_strcmp(v485, "F_SLL_STEP"))
            {
              v221 = atof(v480);
              *(float *)(a2 + 8512) = v221;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPOS_SNT_FINAL"))
            {
              v222 = atof(v480);
              *(float *)(a2 + 8528) = v222;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPOS_SNT_FINAL"))
            {
              v223 = atof(v480);
              *(float *)(a2 + 8532) = v223;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPOS_PHR_FINAL"))
            {
              v224 = atof(v480);
              *(float *)(a2 + 8536) = v224;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPOS_PHR_FINAL"))
            {
              v225 = atof(v480);
              *(float *)(a2 + 8540) = v225;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPOS_SNT_INIT"))
            {
              v226 = atof(v480);
              *(float *)(a2 + 8544) = v226;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPOS_SNT_INIT"))
            {
              v227 = atof(v480);
              *(float *)(a2 + 8548) = v227;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPOS_PHR_INIT"))
            {
              v228 = atof(v480);
              *(float *)(a2 + 8552) = v228;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPOS_PHR_INIT"))
            {
              v229 = atof(v480);
              *(float *)(a2 + 8556) = v229;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPOS_PHR_MID"))
            {
              v230 = atof(v480);
              *(float *)(a2 + 8560) = v230;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPOS_PHR_MID"))
            {
              v231 = atof(v480);
              *(float *)(a2 + 8564) = v231;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDWRDPOSSHP_SENT_SINGLE"))
            {
              v232 = atof(v480);
              *(float *)(a2 + 8568) = v232;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDWRDPOSSHP_SENT_SINGLE"))
            {
              v233 = atof(v480);
              *(float *)(a2 + 8572) = v233;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDWRDPOSSHP_SENT_INITIAL"))
            {
              v234 = atof(v480);
              *(float *)(a2 + 8576) = v234;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDWRDPOSSHP_SENT_INITIAL"))
            {
              v235 = atof(v480);
              *(float *)(a2 + 8580) = v235;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDWRDPOSSHP_SENT_FINAL"))
            {
              v236 = atof(v480);
              *(float *)(a2 + 8584) = v236;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDWRDPOSSHP_SENT_FINAL"))
            {
              v237 = atof(v480);
              *(float *)(a2 + 8588) = v237;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDWRDPOSSHP_IP4_SINGLE"))
            {
              v238 = atof(v480);
              *(float *)(a2 + 8592) = v238;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDWRDPOSSHP_IP4_SINGLE"))
            {
              v239 = atof(v480);
              *(float *)(a2 + 8596) = v239;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDWRDPOSSHP_IP4_INITIAL"))
            {
              v240 = atof(v480);
              *(float *)(a2 + 8600) = v240;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDWRDPOSSHP_IP4_INITIAL"))
            {
              v241 = atof(v480);
              *(float *)(a2 + 8604) = v241;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDWRDPOSSHP_IP4_FINAL"))
            {
              v242 = atof(v480);
              *(float *)(a2 + 8608) = v242;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDWRDPOSSHP_IP4_FINAL"))
            {
              v243 = atof(v480);
              *(float *)(a2 + 8612) = v243;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPRM_UACC"))
            {
              v244 = atof(v480);
              *(float *)(a2 + 8616) = v244;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPRM_UACC"))
            {
              v245 = atof(v480);
              *(float *)(a2 + 8620) = v245;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPRM_DACC"))
            {
              v246 = atof(v480);
              *(float *)(a2 + 8624) = v246;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPRM_DACC"))
            {
              v247 = atof(v480);
              *(float *)(a2 + 8628) = v247;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPRM_ACC"))
            {
              v248 = atof(v480);
              *(float *)(a2 + 8632) = v248;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPRM_ACC"))
            {
              v249 = atof(v480);
              *(float *)(a2 + 8636) = v249;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPRM_EMPH"))
            {
              v250 = atof(v480);
              *(float *)(a2 + 8640) = v250;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPRM_EMPH"))
            {
              v251 = atof(v480);
              *(float *)(a2 + 8644) = v251;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPRMSHP_UACC"))
            {
              v252 = atof(v480);
              *(float *)(a2 + 8648) = v252;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPRMSHP_UACC"))
            {
              v253 = atof(v480);
              *(float *)(a2 + 8652) = v253;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPRMSHP_DACC"))
            {
              v254 = atof(v480);
              *(float *)(a2 + 8656) = v254;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPRMSHP_DACC"))
            {
              v255 = atof(v480);
              *(float *)(a2 + 8660) = v255;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPRMSHP_ACC"))
            {
              v256 = atof(v480);
              *(float *)(a2 + 8664) = v256;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPRMSHP_ACC"))
            {
              v257 = atof(v480);
              *(float *)(a2 + 8668) = v257;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPRMSHP_NUC"))
            {
              v258 = atof(v480);
              *(float *)(a2 + 8672) = v258;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPRMSHP_NUC"))
            {
              v259 = atof(v480);
              *(float *)(a2 + 8676) = v259;
            }
            if (!cstdlib_strcmp(v485, "F_Q_WRDPRMSHP_EMPH"))
            {
              v260 = atof(v480);
              *(float *)(a2 + 8680) = v260;
            }
            if (!cstdlib_strcmp(v485, "F_B_WRDPRMSHP_EMPH"))
            {
              v261 = atof(v480);
              *(float *)(a2 + 8684) = v261;
            }
            if (!cstdlib_strcmp(v485, "F_BEAM_WIDTH_UNV"))
            {
              v262 = atof(v480);
              *(float *)(a2 + 8380) = v262;
            }
            if (!cstdlib_strcmp(v485, "F_Q_UNV"))
            {
              v263 = atof(v480);
              *(float *)(a2 + 8304) = v263;
            }
            if (!cstdlib_strcmp(v485, "F_Q"))
            {
              v264 = atof(v480);
              *(float *)(a2 + 8300) = v264;
            }
            if (!cstdlib_strcmp(v485, "N_NODE_LIMIT"))
              *(_DWORD *)(a2 + 8352) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_INV_NODE_LIMIT"))
              *(_DWORD *)(a2 + 8356) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "F_PRUNE_PCT"))
            {
              v265 = atof(v480);
              *(float *)(a2 + 8360) = v265;
            }
            if (!cstdlib_strcmp(v485, "F_BEAM_WIDTH"))
            {
              v266 = atof(v480);
              *(float *)(a2 + 8376) = v266;
            }
            if (!cstdlib_strcmp(v485, "F_NODE_PRUNE_PCT"))
            {
              v267 = atof(v480);
              *(float *)(a2 + 8364) = v267;
            }
            if (!cstdlib_strcmp(v485, "N_NODE_PRUNE_MAX"))
              *(_DWORD *)(a2 + 8368) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_SILVIT"))
              *(_DWORD *)(a2 + 8384) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_PHONSUBST_PENALTY"))
              *(_DWORD *)(a2 + 8388) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "B_PITCH_SYL_TRANS"))
              *(_DWORD *)(a2 + 8392) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "B_DUR_PHON_TRANS"))
              *(_DWORD *)(a2 + 8396) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "B_DUR_PHON_TGT"))
              *(_DWORD *)(a2 + 8400) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "F_PITCH_SYL_TRANS_ABSOLUTE_PREV_DIFF_THRESH"))
            {
              v268 = atof(v480);
              *(float *)(a2 + 8412) = v268;
            }
            if (!cstdlib_strcmp(v485, "F_PITCH_SYL_TRANS_ABSOLUTE_PREV_DIFF_WEIGHT"))
            {
              v269 = atof(v480);
              *(float *)(a2 + 8416) = v269;
            }
            if (!cstdlib_strcmp(v485, "F_PITCH_SYL_TRANS_ABSOLUTE_PREVPREV_DIFF_THRESH"))
            {
              v270 = atof(v480);
              *(float *)(a2 + 8420) = v270;
            }
            if (!cstdlib_strcmp(v485, "F_PITCH_SYL_TRANS_ABSOLUTE_PREVPREV_DIFF_WEIGHT"))
            {
              v271 = atof(v480);
              *(float *)(a2 + 8424) = v271;
            }
            if (!cstdlib_strcmp(v485, "F_PITCH_SYL_TRANS_MODEL_PREV_DIFF_THRESH"))
            {
              v272 = atof(v480);
              *(float *)(a2 + 8428) = v272;
            }
            if (!cstdlib_strcmp(v485, "F_PITCH_SYL_TRANS_MODEL_PREV_DIFF_WEIGHT"))
            {
              v273 = atof(v480);
              *(float *)(a2 + 8432) = v273;
            }
            if (!cstdlib_strcmp(v485, "F_DUR_PHON_TRANS_THRESH"))
            {
              v274 = atof(v480);
              *(float *)(a2 + 8436) = v274;
            }
            if (!cstdlib_strcmp(v485, "F_DUR_PHON_TRANS_WEIGHT"))
            {
              v275 = atof(v480);
              *(float *)(a2 + 8440) = v275;
            }
            if (!cstdlib_strcmp(v485, "N_NODE_SCORE_MAX"))
              *(_DWORD *)(a2 + 8444) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_NODE_PRUNE_MIN"))
              *(_DWORD *)(a2 + 8448) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_EARLY_PRUNING"))
              *(_DWORD *)(a2 + 8452) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "B_OBERSEE"))
              *(_DWORD *)(a2 + 8456) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "N_OBERSEE_OPCL_COMPRESS"))
              *(_DWORD *)(a2 + 8464) = LH_atou(v480);
            if (!cstdlib_strcmp(v485, "N_OBERSEE_OPCL_HUFFMAN_MAXSIZE_UNCOMPRESS"))
              *(_DWORD *)(a2 + 8468) = LH_atou(v480);
            if (!cstdlib_strcmp(v485, "N_OBERSEE_ALLUNITDATA_COMPRESS"))
              *(_DWORD *)(a2 + 8460) = LH_atou(v480);
            if (!cstdlib_strcmp(v485, "N_OBERSEE_SYMDATA_COMPRESS"))
              *(_DWORD *)(a2 + 8472) = LH_atou(v480);
            if (!cstdlib_strcmp(v485, "N_TYPEOFPITCHCOST"))
              *(_DWORD *)(a2 + 9056) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "F_PITCHSLOPEWEIGHT"))
            {
              v276 = atof(v480);
              *(float *)(a2 + 9060) = v276;
            }
            if (!cstdlib_strcmp(v485, "B_BPF"))
              *(_DWORD *)(a2 + 8476) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "B_MCEP_TGTCOST_FIX"))
              *(_DWORD *)(a2 + 8480) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "F_W_CONTEXT"))
            {
              v277 = atof(v480);
              *(float *)(a2 + 8292) = v277;
            }
            if (!cstdlib_strcmp(v485, "F_W_GENERIC_CONTEXT"))
            {
              v278 = atof(v480);
              *(float *)(a2 + 8296) = v278;
            }
            if (!cstdlib_strcmp(v485, "B_EXPLICIT_PHONE_MODEL"))
              *(_DWORD *)(a2 + 8784) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "B_STATE_LM_BACKUP"))
              *(_DWORD *)(a2 + 8912) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "B_ALL_STATE_LM"))
              *(_DWORD *)(a2 + 8916) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "B_BACKOFF"))
              *(_DWORD *)(a2 + 8920) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "B_ENABLE_CCL"))
              *(_DWORD *)(a2 + 9004) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "N_LEN_CCL"))
              *(_DWORD *)(a2 + 9008) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "F_SLL_THRES"))
            {
              v279 = atof(v480);
              *(float *)(a2 + 9012) = v279;
            }
            if (!cstdlib_strcmp(v485, "B_ENABLE_SLL_THRES"))
              *(_DWORD *)(a2 + 9016) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "N_MAX_UNITBASE_UNITS"))
              *(_DWORD *)(a2 + 9068) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_MAXLOAD_UNITS"))
              *(_DWORD *)(a2 + 9072) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "B_TRIPHONE_FILLER"))
              *(_DWORD *)(a2 + 9076) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "F_SYM_QA"))
            {
              v280 = atof(v480);
              *(float *)(a2 + 8308) = v280;
            }
            if (!cstdlib_strcmp(v485, "F_GENRE_W"))
            {
              v281 = atof(v480);
              *(float *)(a2 + 9092) = v281;
            }
            if (!cstdlib_strcmp(v485, "F_VENN_W"))
            {
              v282 = atof(v480);
              *(float *)(a2 + 9100) = v282;
            }
            if (!cstdlib_strcmp(v485, "N_SEARCH_MODE"))
              *(_DWORD *)(a2 + 9096) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_GENRES"))
              *(_DWORD *)(a2 + 9084) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_GENRE_TGT"))
              *(_DWORD *)(a2 + 9088) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_VITERBI_DECODER_VARIANT"))
              v478[2177] = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_NODE_PRUNE_MAX_UNV"))
              *(_DWORD *)(a2 + 8372) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_PSOLA_MODE"))
              v478[2188] = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_PSOLA_MIN_DURATION_RATIO"))
              v478[2195] = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_PSOLA_MAX_DURATION_RATIO"))
              v478[2196] = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_COMPRESS_SYMDATA_FEATS"))
              *(_DWORD *)(a2 + 8488) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_COMPACT_SYMDATA_FEATS"))
              *(_DWORD *)(a2 + 8500) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_COMPRESS_MFS_DATA_COST_JOIN_ELEMENTS"))
              *(_DWORD *)(a2 + 8492) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "N_COMPRESS_MFS_DATA_UNIT_DATA"))
              *(_DWORD *)(a2 + 8496) = LH_atoi(v480);
            if (!cstdlib_strcmp(v485, "B_USE_KLD_TCOST"))
              v478[2214] = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "B_TONEFILTER"))
              *(_DWORD *)(a2 + 8484) = LH_atoi(v480) != 0;
            if (!cstdlib_strcmp(v485, "B_DECODE_LF0_FROM_JV"))
              *(_DWORD *)(a2 + 8408) = LH_atoi(v480) != 0;
            if ((v15 & 0x80000000) != 0)
              break;
            v207 += v208;
            v206 = v484;
          }
          while (v207 < v484);
        }
        v9 = a6;
        goto LABEL_611;
      }
      if (!cstdlib_strcmp(__src, "FEEX"))
      {
        v175 = v14;
        v176 = a2;
        v177 = a3;
        v178 = 1;
        goto LABEL_414;
      }
      if (!cstdlib_strcmp(__src, "PCT4"))
      {
        *(_QWORD *)__s2 = 0;
        if (v9)
        {
          v203 = (unsigned __int16 *)(v9 + ssftriff_reader_GetPosition(a3) - v8);
          *(_QWORD *)__s2 = v203;
        }
        else
        {
          ChunkData = ssftriff_reader_GetChunkData(a3, v484, __s2, v26, v27, v28, v29, v30);
          if ((ChunkData & 0x80000000) != 0)
            return ChunkData;
          v203 = *(unsigned __int16 **)__s2;
        }
        v307 = v484;
        v308 = v14;
        v309 = a3;
        v310 = v469;
        goto LABEL_552;
      }
      if (cstdlib_strcmp(__src, "STM3"))
      {
        if (!cstdlib_strcmp(__src, "UVC4"))
        {
          v103 = v484;
          v104 = a2;
          v105 = a3;
          v106 = 11;
          v303 = 0;
          v304 = 0;
          v305 = 1;
          goto LABEL_609;
        }
        if (!cstdlib_strcmp(__src, "UVI4"))
        {
          v336 = *(unsigned __int16 *)(v471 + 544);
          if (v336 <= 0x3F)
          {
            v337 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v336 + 66328), v460, v36, v37, v38, v39, v40);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v337;
              *(_DWORD *)(a2 + 12000) = v337;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "PKP4")
          || !cstdlib_strcmp(__src, "PKB4")
          || !cstdlib_strcmp(__src, "PKO4")
          || !cstdlib_strcmp(__src, "PKU4"))
        {
          log_OutText(*(_QWORD *)(v14 + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)"Select data file includes PSOLA data and cannot be used on this engine, PSOLA data should be included in the synth file.", v41, v42, v43, v436);
          LODWORD(v15) = -2065686503;
          goto LABEL_611;
        }
        if (!cstdlib_strcmp(__src, "CJE4"))
        {
          v393 = *(unsigned __int16 *)(v471 + 544);
          if (v393 <= 0x3F)
          {
            v394 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v393 + 66328), v450, v44, v45, v46, v47, v48);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v394;
              v478[420] = v394;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "UND4"))
        {
          if (*(_DWORD *)(a2 + 8496) == 1)
          {
            v175 = v14;
            v176 = a2;
            v177 = a3;
            v178 = 1;
            v290 = a5;
            v291 = v9;
            v292 = v8;
            goto LABEL_415;
          }
          v405 = *(unsigned __int16 *)(v471 + 544);
          if (v405 <= 0x3F)
          {
            v406 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v405 + 66328), v447, v49, v50, v51, v52, v53);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v406;
              *(_DWORD *)(a2 + 9600) = v406;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "UNR4"))
        {
          v403 = *(unsigned __int16 *)(v471 + 544);
          if (v403 <= 0x3F)
          {
            v404 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v403 + 66328), v448, v54, v55, v56, v57, v58);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v404;
              *(_DWORD *)(a2 + 9360) = v404;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "VSG4"))
        {
          v407 = *(unsigned __int16 *)(v471 + 544);
          if (v407 <= 0x3F)
          {
            v408 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v407 + 66328), v446, v59, v60, v61, v62, v63);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v408;
              v478[480] = v408;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "OVSI"))
        {
          v409 = *(unsigned __int16 *)(v471 + 544);
          if (v409 <= 0x3F)
          {
            v410 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v409 + 66328), v445, v64, v65, v66, v67, v68);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v410;
              v478[1680] = v410;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "OVSD"))
        {
          v411 = *(unsigned __int16 *)(v471 + 544);
          if (v411 <= 0x3F)
          {
            v412 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v411 + 66328), v444, v69, v70, v71, v72, v73);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v412;
              v478[1740] = v412;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "SYM4"))
        {
          v413 = *(unsigned __int16 *)(v471 + 544);
          if (v413 <= 0x3F)
          {
            v414 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v413 + 66328), v443, v74, v75, v76, v77, v78);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v414;
              *v478 = v414;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "SYD4"))
        {
          v415 = *(unsigned __int16 *)(v471 + 544);
          if (v415 <= 0x3F)
          {
            v416 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v415 + 66328), v442, v79, v80, v81, v82, v83);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v416;
              v478[120] = v416;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "SYW4"))
        {
          v417 = *(unsigned __int16 *)(v471 + 544);
          if (v417 <= 0x3F)
          {
            v418 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v417 + 66328), v441, v84, v85, v86, v87, v88);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v418;
              v478[180] = v418;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "SYB4"))
        {
          v427 = *(unsigned __int16 *)(v471 + 544);
          if (v427 <= 0x3F)
          {
            v428 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v427 + 66328), v440, v89, v90, v91, v92, v93);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v428;
              v478[60] = v428;
            }
            goto LABEL_611;
          }
          goto LABEL_510;
        }
        if (!cstdlib_strcmp(__src, "WCI4") || !cstdlib_strcmp(__src, "SCI4"))
        {
          v419 = ssftriff_reader_GetPosition(a3);
          *(_QWORD *)__s2 = 0;
          v425 = *(unsigned __int16 *)(v471 + 544);
          LODWORD(v15) = -2065686524;
          if (v425 > 0x3F)
            goto LABEL_611;
          v426 = v419;
          v348 = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v425 + 66328), __s2, v420, v421, v422, v423, v424);
          if (v348 < 0)
            goto LABEL_563;
          ++*(_WORD *)(v471 + 544);
          *(_DWORD *)(v471 + 24) += v484;
          ssftriff_reader_Seek(a3, 4u, 1);
          v370 = *(_QWORD *)__s2;
          v365 = v14;
          v366 = a2;
          v367 = a3;
          v368 = 1;
          v369 = a5;
          v371 = v426;
          goto LABEL_562;
        }
        if (!cstdlib_strcmp(__src, "IVV4"))
        {
          v429 = *(unsigned __int16 *)(v471 + 544);
          if (v429 <= 0x3F)
          {
            v434 = v484;
            LODWORD(v15) = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v429 + 66328), v439, v94, v95, v96, v97, v98);
            if ((v15 & 0x80000000) == 0)
            {
              ++*(_WORD *)(v471 + 544);
              *(_DWORD *)(v471 + 24) += v434;
              *(_DWORD *)(a2 + 14640) = v434;
            }
          }
          else
          {
            LODWORD(v15) = -2065686524;
          }
LABEL_673:
          v9 = a6;
LABEL_113:
          v14 = a1;
          goto LABEL_611;
        }
        if (!cstdlib_strcmp(a5, "KID4"))
        {
          if (cstdlib_strcmp(__src, "KID4"))
            goto LABEL_673;
          v430 = v484;
          v431 = a2;
          v432 = a3;
          v433 = 49;
          goto LABEL_679;
        }
        if (!cstdlib_strcmp(a5, "KMT4"))
        {
          if (cstdlib_strcmp(__src, "KMT4"))
            goto LABEL_673;
          v430 = v484;
          v431 = a2;
          v432 = a3;
          v433 = 50;
          goto LABEL_679;
        }
        if (!cstdlib_strcmp(a5, "KMQ4"))
        {
          if (cstdlib_strcmp(__src, "KMQ4"))
            goto LABEL_673;
          v430 = v484;
          v431 = a2;
          v432 = a3;
          v433 = 51;
          goto LABEL_679;
        }
        if (!cstdlib_strcmp(a5, "KMP4"))
        {
          if (cstdlib_strcmp(__src, "KMP4"))
            goto LABEL_673;
          v430 = v484;
          v431 = a2;
          v432 = a3;
          v433 = 52;
          goto LABEL_679;
        }
        if (!cstdlib_strcmp(a5, "OAUD"))
        {
          v430 = v484;
          v431 = a2;
          v432 = a3;
          v433 = 53;
LABEL_679:
          v9 = a6;
          LODWORD(v15) = select_bet4_LoadMfsData(v431, v432, v433, 0, v430, a6, v8, 0);
          goto LABEL_113;
        }
        if (!cstdlib_strcmp(a5, "OAUB"))
        {
          v430 = v484;
          v431 = a2;
          v432 = a3;
          v433 = 57;
          goto LABEL_679;
        }
        if (!cstdlib_strcmp(a5, "OAUF"))
        {
          v430 = v484;
          v431 = a2;
          v432 = a3;
          v433 = 58;
          goto LABEL_679;
        }
        if (!cstdlib_strcmp(a5, "OSDT"))
        {
          v430 = v484;
          v431 = a2;
          v432 = a3;
          v433 = 61;
          goto LABEL_679;
        }
        v9 = a6;
        v14 = a1;
        if (!cstdlib_strcmp(a5, "OSDO"))
        {
          v99 = v484;
          v100 = a2;
          v101 = a3;
          v102 = 62;
          goto LABEL_126;
        }
        goto LABEL_599;
      }
      *(_QWORD *)__s2 = 0;
      if (v484 >= *(_DWORD *)(v471 + 20))
      {
        v287 = 0;
        v286 = 0;
LABEL_484:
        LODWORD(v15) = select_bet4_ParseRiff(v14, a2, a3, 1, a5, v287, v286);
        ++*(_DWORD *)(a2 + 260);
        goto LABEL_611;
      }
      v284 = *(unsigned __int16 *)(v471 + 544);
      LODWORD(v15) = -2065686524;
      if (v284 <= 0x3F)
      {
        RiffStringTable = ssftriff_reader_DetachChunkData(a3, (void **)(a2 + 8 * v284 + 66328), __s2, v31, v32, v33, v34, v35);
        if (RiffStringTable < 0)
          goto LABEL_610;
        v286 = ssftriff_reader_GetPosition(a3);
        ++*(_WORD *)(v471 + 544);
        *(_DWORD *)(v471 + 24) += v484;
        v287 = *(_QWORD *)__s2;
        goto LABEL_484;
      }
    }
LABEL_611:
    v395 = ssftriff_reader_CloseChunk(a3);
    if ((int)v15 > -1 && v395 < 0)
      v15 = v395;
    else
      v15 = v15;
  }
  while ((v15 & 0x80000000) == 0);
  if ((v15 & 0x1FFF) == 0x14)
  {
    v15 = 0;
    *__dst = 0;
  }
  return v15;
}

uint64_t logAverageSizesOfClusters(uint64_t result, int *a2, unsigned int a3)
{
  BOOL v3;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  int *v14;
  uint64_t v15;
  int v16;

  if (*(_DWORD *)(*((_QWORD *)a2 + 134) + 8328))
    v3 = a3 > 2;
  else
    v3 = 1;
  if (!v3)
  {
    v6 = result;
    result = MFS__log_select_Diag(result, 1, (uint64_t)off_24D29C630[a3]);
    if (*a2 >= 1)
    {
      v7 = 2;
      do
      {
        v8 = a2 + 11;
        if (a3)
          v8 = (int *)(*(_QWORD *)&a2[2 * a3 + 12] + 4 * v7);
        v9 = *v8;
        v10 = *(_QWORD *)(*(_QWORD *)&a2[2 * a3 + 428] + 8 * v7);
        v11 = 0;
        if (v10)
          v12 = v9 == 0;
        else
          v12 = 1;
        if (!v12)
        {
          if ((v9 + 1) > 2)
            v13 = (v9 + 1);
          else
            v13 = 2;
          v14 = (int *)(v10 + 20);
          v15 = v13 - 1;
          do
          {
            v16 = *v14;
            v14 += 4;
            v11 += v16;
            --v15;
          }
          while (v15);
        }
        result = MFS__log_select_Diag(v6, 1, (uint64_t)"state %d : %d pdfs - average %d");
        v3 = v7++ <= *a2;
      }
      while (v3);
    }
  }
  return result;
}

uint64_t select_bet4_UpdateEarlyEmission(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v8;
  char *__src;

  __src = 0;
  if ((paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"bet4earlyemission", &__src) & 0x80000000) != 0
    && (paramc_ParamGetStr(*(_QWORD *)(a1 + 40), (uint64_t)"bet4earlyemissionallowed", &__src) & 0x80000000) != 0
    || !StringToBool(__src))
  {
    v5 = 0;
    v6 = "Early-emission has not been switched on";
  }
  else
  {
    v5 = 1;
    v6 = "Early-emission is switched on, from pipeline header or configuration";
  }
  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET4", 3, 0, (uint64_t)v6, v2, v3, v4, v8);
  return v5;
}

_QWORD *select_bet4_loc_VoiceClose(_QWORD *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v9;
  uint64_t *v10;
  uint64_t **v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  _WORD *v15;
  uint64_t *v16;
  int v17;
  uint64_t **v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;

  if (a2)
  {
    v3 = (uint64_t)result;
    v4 = a2 + 40352;
    v5 = *(_QWORD **)(a2 + 40352);
    if (v5 && *v5)
    {
      v6 = 0;
      v7 = 1;
      do
      {
        *(_QWORD *)(a2 + 8 * v6 + 5432) = 0;
        v6 = v7;
      }
      while (*(_QWORD *)(*(_QWORD *)v4 + 8 * v7++));
    }
    v9 = *(_QWORD *)(a2 + 41256);
    if (v9)
    {
      heap_Free((_QWORD *)result[1], v9);
      *(_QWORD *)(v4 + 904) = 0;
    }
    uselect_FreeRiffStringTable((_QWORD *)v3, *(uint64_t **)(a2 + 7744));
    *(_QWORD *)(a2 + 7744) = 0;
    uselect_FreeRiffStringTable((_QWORD *)v3, *(uint64_t **)(v4 + 968));
    uselect_FreeRiffStringTable((_QWORD *)v3, *(uint64_t **)(v4 + 960));
    v10 = *(uint64_t **)(v4 + 872);
    v11 = *(uint64_t ***)(v4 + 880);
    v12 = *(uint64_t **)(v4 + 888);
    if (v10)
    {
      v13 = *v10;
      if (*v10)
      {
        v14 = 0;
        do
        {
          heap_Free(*(_QWORD **)(v3 + 8), v13);
          v13 = v10[(unsigned __int16)++v14];
        }
        while (v13);
      }
      heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v10);
    }
    v15 = (_WORD *)(a2 + 66840);
    if (v11)
    {
      v16 = *v11;
      if (*v11)
      {
        v17 = 0;
        v18 = v11;
        do
        {
          v19 = *v16;
          if (*v16)
          {
            v20 = 0;
            do
            {
              heap_Free(*(_QWORD **)(v3 + 8), v19);
              ++v20;
              v16 = *v18;
              v19 = (*v18)[(unsigned __int16)v20];
            }
            while (v19);
          }
          heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v16);
          v18 = &v11[(unsigned __int16)++v17];
          v16 = *v18;
        }
        while (*v18);
      }
      heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v11);
    }
    if (v12)
    {
      v21 = *v12;
      if (*v12)
      {
        v22 = 0;
        do
        {
          heap_Free(*(_QWORD **)(v3 + 8), v21);
          v21 = v12[(unsigned __int16)++v22];
        }
        while (v21);
      }
      heap_Free(*(_QWORD **)(v3 + 8), (uint64_t)v12);
    }
    uselect_FreeRiffStringTable((_QWORD *)v3, *(uint64_t **)v4);
    uselect_FreeRiffStringTable((_QWORD *)v3, *(uint64_t **)(v4 + 8));
    mfs_DeInitData(v3, (_QWORD *)(a2 + 25424));
    mfs_DeInitParam(v3, (_DWORD *)(a2 + 128));
    if (*v15)
    {
      v30 = 0;
      do
        ssftriff_reader_ReleaseChunkData(*(_QWORD **)(a2 + 66328 + 8 * v30++), v23, v24, v25, v26, v27, v28, v29);
      while (v30 < (unsigned __int16)*v15);
    }
    *v15 = 0;
    *(_BYTE *)a2 = 0;
    return heap_Free(*(_QWORD **)(v3 + 8), a2);
  }
  return result;
}

uint64_t select_bet4_LoadMfsData(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  int v12;
  int Position;
  uint64_t result;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;

  v8 = a5;
  v9 = a4;
  if (a6)
  {
    v12 = a7;
    Position = ssftriff_reader_GetPosition(a2);
    result = 0;
    v16 = a1 + 240 * a3 + 24 * v9;
    *(_QWORD *)(v16 + 9112) = a6 + (Position - v12);
    *(_DWORD *)(v16 + 9120) = v8;
  }
  else if ((_DWORD)a8 && *(_DWORD *)(a1 + 66316) <= a5)
  {
    v18 = a1 + 240 * a3 + 24 * (int)a4;
    *(_DWORD *)(v18 + 9120) = a5;
    v19 = ssftriff_reader_GetPosition(a2);
    result = 0;
    *(_DWORD *)(v18 + 9124) = v19;
  }
  else
  {
    v17 = *(unsigned __int16 *)(a1 + 66840);
    if (v17 <= 0x3F)
    {
      result = ssftriff_reader_DetachChunkData(a2, (void **)(a1 + 8 * v17 + 66328), (_QWORD *)(a1 + 240 * a3 + 24 * (int)a4 + 9112), a4, a5, 0, a7, a8);
      if ((result & 0x80000000) == 0)
      {
        ++*(_WORD *)(a1 + 66840);
        *(_DWORD *)(a1 + 66320) += v8;
        *(_DWORD *)(a1 + 240 * a3 + 24 * v9 + 9120) = v8;
      }
    }
    else
    {
      return 2229280772;
    }
  }
  return result;
}

uint64_t select_bet4_LoadRiffGenericFeatureMap(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned int a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t i;
  uint64_t *v28;
  uint64_t *v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v34;
  char __dst[256];
  uint64_t v36;

  v11 = a1;
  v36 = *MEMORY[0x24BDAC8D0];
  v12 = *a3;
  v13 = heap_Calloc(*(_QWORD **)(a1 + 8), v12 + 1, 8);
  *a5 = v13;
  if (v13)
  {
    v14 = heap_Calloc(*(_QWORD **)(v11 + 8), v12 + 1, 8);
    *a6 = v14;
    if (v14)
    {
      v15 = heap_Calloc(*(_QWORD **)(v11 + 8), v12 + 1, 8);
      *a7 = v15;
      if (v15)
      {
        if (!(_DWORD)v12)
          return 0;
        v16 = 0;
        v17 = 2;
        v28 = a5;
        v29 = a7;
        v30 = v12;
        while (1)
        {
          __dst[0] = 0;
          v34 = 256;
          v18 = ssftriff_reader_ReadStringZ(a2, (uint64_t)a3, a4, v17, __dst, &v34);
          v19 = v34;
          *(_QWORD *)(*a5 + 8 * v16) = MFS__heap_StrDup(*(_QWORD **)(v11 + 8), __dst);
          if (!*(_QWORD *)(*a5 + 8 * v16))
            break;
          v20 = v16;
          v21 = v19 + v17;
          v31 = *(unsigned __int16 *)((char *)a3 + v21);
          *(_QWORD *)(*a6 + 8 * v16) = heap_Calloc(*(_QWORD **)(v11 + 8), v31 + 1, 8);
          if (!*(_QWORD *)(*a6 + 8 * v16))
            break;
          *(_QWORD *)(*a7 + 8 * v16) = heap_Calloc(*(_QWORD **)(v11 + 8), v31 + 1, 1);
          if (!*(_QWORD *)(*a7 + 8 * v16))
            break;
          v17 = v21 + 2;
          if ((_DWORD)v31)
          {
            v22 = v11;
            v23 = 0;
            while (1)
            {
              v24 = v17;
              __dst[0] = 0;
              v34 = 256;
              v18 = ssftriff_reader_ReadStringZ(a2, (uint64_t)a3, a4, v17, __dst, &v34);
              v25 = v34;
              *(_QWORD *)(*(_QWORD *)(*a6 + 8 * v20) + v23) = MFS__heap_StrDup(*(_QWORD **)(v22 + 8), __dst);
              if (!*(_QWORD *)(*(_QWORD *)(*a6 + 8 * v20) + v23))
                return 2229280778;
              v17 += v25;
              v23 += 8;
              if (8 * v31 == v23)
              {
                a5 = v28;
                a7 = v29;
                for (i = 0; i != v31; ++i)
                  *(_BYTE *)(*(_QWORD *)(*v29 + 8 * v20) + i) = *((_BYTE *)a3 + v24 + v25 + i);
                v17 = v24 + v25 + i;
                v11 = v22;
                break;
              }
            }
          }
          v16 = v20 + 1;
          if ((int)v20 + 1 >= v30)
            return v18;
        }
      }
    }
  }
  return 2229280778;
}

BOOL StringToBool(char *__src)
{
  unsigned __int8 v1;
  char *v2;
  int v3;
  char __dst[20];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  cstdlib_strncpy(__dst, __src, 0x13uLL);
  __dst[19] = 48;
  v1 = __dst[0];
  if (__dst[0])
  {
    v2 = __dst;
    do
    {
      if (cstdlib_isupper(v1))
        *v2 = cstdlib_tolower(*v2);
      v3 = *++v2;
      v1 = v3;
    }
    while (v3);
  }
  return !cstdlib_strcmp(__dst, "yes") || !cstdlib_strcmp(__dst, "1") || cstdlib_strcmp(__dst, "true") == 0;
}

uint64_t select_bet4_loc_SetSynthParams(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 56);
  result = select_bet4_loc_SetSynthParamFloat(v1, (uint64_t)"bet2voicealpha", *(float *)(v2 + 128));
  if ((result & 0x80000000) == 0)
  {
    result = select_bet4_loc_SetSynthParamFloat(v1, (uint64_t)"bet2voicebeta", *(float *)(v2 + 132));
    if ((result & 0x80000000) == 0)
    {
      result = select_bet4_loc_SetSynthParamFloat(v1, (uint64_t)"bet2voicevol", *(float *)(v2 + 164));
      if ((result & 0x80000000) == 0)
      {
        result = select_bet4_loc_SetSynthParamFloat(v1, (uint64_t)"bet2voicevuvrelamp", *(float *)(v2 + 140));
        if ((result & 0x80000000) == 0)
        {
          result = select_bet4_loc_SetSynthParamFloat(v1, (uint64_t)"bet2voicemvfboost", *(float *)(v2 + 168));
          if ((result & 0x80000000) == 0)
          {
            result = select_bet4_loc_SetSynthParamInt(v1, (uint64_t)"bet2voiceframesize", *(_DWORD *)(v2 + 152));
            if ((result & 0x80000000) == 0)
            {
              result = select_bet4_loc_SetSynthParamInt(v1, (uint64_t)"bet2voiceorder", *(_DWORD *)(v2 + 144));
              if ((result & 0x80000000) == 0)
              {
                result = select_bet4_loc_SetSynthParamFloat(v1, (uint64_t)"bet2voicef0std", *(float *)(v2 + 176));
                if ((result & 0x80000000) == 0)
                {
                  result = select_bet4_loc_SetSynthParamFloat(v1, (uint64_t)"bet2voicef0mean", *(float *)(v2 + 180));
                  if ((result & 0x80000000) == 0)
                  {
                    result = select_bet4_loc_SetSynthParamInt(v1, (uint64_t)"voicepitchavghz", *(_DWORD *)(v2 + 184));
                    if ((result & 0x80000000) == 0)
                      return select_bet4_loc_SetSynthParamString(v1, (char *)(v2 + 7800));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t select_bet4_loc_SetSynthParamInt(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = paramc_ParamSetInt(*(_QWORD *)(a1 + 40), a2, a3);
  if ((v8 & 0x80000000) != 0)
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET4", 58009, (uint64_t)"%s%s%s%d%s%x", v4, v5, v6, v7, "parameter");
  return v8;
}

uint64_t select_bet4_loc_SetSynthParamString(uint64_t a1, char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v7 = paramc_ParamSetStr(*(_QWORD *)(a1 + 40), (uint64_t)"synth_type", a2);
  if ((v7 & 0x80000000) != 0)
    log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET4", 58009, (uint64_t)"%s%s%s%s%s%x", v3, v4, v5, v6, "parameter");
  return v7;
}

_QWORD *FreeBET4TuningData(_QWORD *result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a2)
  {
    v3 = result;
    if (*(_DWORD *)(a2 + 12) || *(_DWORD *)(a2 + 16))
    {
      v4 = result[1367];
      if (!*(_DWORD *)(v4 + 8328))
      {
        v5 = result[7];
        if (v4 != v5 + 128)
        {
          heap_Free(*(_QWORD **)(result[2] + 8), v4);
          v5 = v3[7];
        }
        v3[1367] = v5 + 128;
      }
    }
    v6 = *(_QWORD *)a2;
    if (*(_QWORD *)a2)
    {
      v7 = *(unsigned int *)(a2 + 8);
      if ((_DWORD)v7)
      {
        v8 = 0;
        v9 = 8;
        do
        {
          v10 = *(_QWORD *)(*(_QWORD *)a2 + v9);
          if (v10)
          {
            heap_Free(*(_QWORD **)(v3[2] + 8), v10);
            v7 = *(unsigned int *)(a2 + 8);
          }
          ++v8;
          v9 += 48;
        }
        while (v8 < v7);
        v6 = *(_QWORD *)a2;
      }
      heap_Free(*(_QWORD **)(v3[2] + 8), v6);
    }
    return heap_Free(*(_QWORD **)(v3[2] + 8), a2);
  }
  return result;
}

uint64_t mfs_UnitSequence_SequenceEarlyEmission_Obersee(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t UnitData_Obersee;
  int MessageOffsetMsec;
  int v12;
  __int128 v14;
  __int128 v15;

  v3 = a1[72];
  v4 = *(_DWORD *)(*(_QWORD *)(v3 + 2120) + 1096);
  *(_DWORD *)(v3 + 2600) = *(_DWORD *)(v3 + 2272);
  v5 = a3 - a2;
  if (a3 <= a2)
    return 0;
  v7 = v4 - 1;
  v14 = 0u;
  v15 = 0u;
  v8 = a2;
  do
  {
    v9 = *(_DWORD *)(*(_QWORD *)(v3 + 2152) + 4 * v8);
    UnitData_Obersee = mfs_getUnitData_Obersee(*(_QWORD *)(v3 + 2120), *a1, v9, (uint64_t)&v14);
    if ((UnitData_Obersee & 0x80000000) != 0)
      break;
    MessageOffsetMsec = mfs_GetMessageOffsetMsec(*(_QWORD *)(v3 + 2120), v9);
    if (++v8 < (unint64_t)*(unsigned int *)(v3 + 2160))
    {
      v12 = v9 == v7 ? -1 : v9;
      UnitData_Obersee = mfs_SegmentList_Add(v3 + 2248, v12, SBYTE9(v15), MessageOffsetMsec, (unsigned __int16)(*(_WORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 2120) + 1072) + 24)* BYTE11(v15)));
      if ((UnitData_Obersee & 0x80000000) != 0)
        break;
    }
    --v5;
  }
  while (v5);
  return UnitData_Obersee;
}

uint64_t mfs_UnitSequence_Sequence_Obersee(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t UnitData_Obersee;
  int MessageOffsetMsec;
  unint64_t v14;
  int v15;
  __int128 v17;
  __int128 v18;
  _BYTE __b[264];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  memset(__b, 0, sizeof(__b));
  v17 = 0u;
  v18 = 0u;
  v6 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 1096);
  *(_DWORD *)(a2 + 24) = 0;
  cstdlib_memset(__b, 0, 0x108uLL);
  v7 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 16), 264 * *(unsigned int *)(a1 + 48));
  if (!v7)
    return 2229280778;
  *(_QWORD *)(a1 + 16) = v7;
  if (*(_DWORD *)(a1 + 48))
  {
    v8 = 0;
    v9 = 0;
    v10 = v6 - 1;
    while (1)
    {
      v11 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v8);
      UnitData_Obersee = mfs_getUnitData_Obersee(*(_QWORD *)(a1 + 8), a3, v11, (uint64_t)&v17);
      if ((UnitData_Obersee & 0x80000000) != 0)
        break;
      if (v8)
      {
        ++*(_DWORD *)&__b[4];
        if ((_DWORD)v17 != v9)
        {
          memcpy((void *)(*(_QWORD *)(a1 + 16) + 264 * *(unsigned int *)(a1 + 24)), __b, 0x108uLL);
          ++*(_DWORD *)(a1 + 24);
          *(_DWORD *)__b = *(_DWORD *)&__b[4];
        }
      }
      MessageOffsetMsec = mfs_GetMessageOffsetMsec(*(_QWORD *)(a1 + 8), v11);
      ++v8;
      v14 = *(unsigned int *)(a1 + 48);
      if (v8 < v14)
      {
        if (v11 == v10)
          v15 = -1;
        else
          v15 = v11;
        UnitData_Obersee = mfs_SegmentList_Add(a2, v15, SBYTE9(v18), MessageOffsetMsec, (unsigned __int16)(*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1072) + 24)* BYTE11(v18)));
        if ((UnitData_Obersee & 0x80000000) != 0)
          return UnitData_Obersee;
        v14 = *(unsigned int *)(a1 + 48);
      }
      v9 = v11;
      if (v8 >= v14)
        goto LABEL_18;
    }
  }
  else
  {
    UnitData_Obersee = 0;
LABEL_18:
    if (*(_DWORD *)&__b[4] != *(_DWORD *)__b)
    {
      ++*(_DWORD *)&__b[4];
      memcpy((void *)(*(_QWORD *)(a1 + 16) + 264 * *(unsigned int *)(a1 + 24)), __b, 0x108uLL);
      ++*(_DWORD *)(a1 + 24);
    }
  }
  return UnitData_Obersee;
}

uint64_t CandidatePhonemeDuration(unsigned __int8 *a1, unsigned int a2, int a3)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  _QWORD *v12;
  _QWORD v13[2];

  v13[0] = 0;
  v13[1] = 0;
  v12 = v13;
  mfs_getUnitDataFromMfsData(a1, a2, (uint64_t *)&v12);
  v6 = *((unsigned __int16 *)v12 + 4);
  v7 = a3 - 2;
  if (a3 > 2)
  {
    v8 = a2 - 1;
    do
    {
      mfs_getUnitDataFromMfsData(a1, v8, (uint64_t *)&v12);
      v6 = v6 + *((unsigned __int16 *)v12 + 4);
      --v8;
      --v7;
    }
    while (v7);
  }
  v9 = 2 - a3;
  if (v9 + *(_DWORD *)a1 >= 2)
  {
    v10 = 1;
    do
    {
      mfs_getUnitDataFromMfsData(a1, a2 + v10, (uint64_t *)&v12);
      v6 = v6 + *((unsigned __int16 *)v12 + 4);
      ++v10;
    }
    while (v10 < v9 + *(_DWORD *)a1);
  }
  return v6;
}

float CandidatePhonemeDurationDistanceBasic(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  unsigned int v4;
  int v5;

  v4 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 12232) + a2);
  v5 = v4 - a4;
  if ((int)(v4 - a4) < 0)
    v5 = a4 - v4;
  return (float)v5 / (float)v4;
}

uint64_t CandidatePhonemeDurationDistance(uint64_t a1, unsigned int a2, uint64_t a3, int a4, int a5)
{
  int v5;
  int v6;
  char v8;
  unsigned int v9;

  v5 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 12232) + a2);
  v6 = v5 - a4;
  if (v5 - a4 < 0)
    v6 = a4 - v5;
  v8 = v5 < a4 && v6 > a5;
  v9 = v6 << v8;
  if (v6 > 2 * a5)
    return (5 * v6);
  else
    return v9;
}

BOOL IsPhonemeDurationOutlier(uint64_t a1, unsigned int a2, float a3, uint64_t a4, int a5, int a6)
{
  int v6;

  v6 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 12232) + a2) - a5;
  if (v6 < 0)
    v6 = a5 - *(unsigned __int8 *)(*(_QWORD *)(a1 + 12232) + a2);
  return (float)((float)a6 * a3) < (float)v6;
}

BOOL IsMinimumPhonemeStateTransition(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)a1 == *(unsigned __int8 *)(*(_QWORD *)(a1 + 12232) + a2);
}

void UniformStateDuration(float a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  int v9;

  v4 = (int)(float)(a1 * 0.5);
  *(_DWORD *)(a3 + 24) = v4;
  if (*a4 >= 1)
  {
    v5 = *(_QWORD *)(a3 + 16);
    v6 = 2;
    do
      *(_DWORD *)(v5 + 4 * v6) = 0;
    while (v6++ <= *a4);
    v4 = *(_DWORD *)(a3 + 24);
  }
  if (v4)
  {
    v8 = *(_QWORD *)(a3 + 16);
    v9 = 2;
    do
    {
      ++*(_DWORD *)(v8 + 4 * v9);
      if (v9 == *a4 + 1)
        v9 = 2;
      else
        ++v9;
      --v4;
    }
    while (v4);
  }
}

void StateDuration(float a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  int v5;
  int *v6;
  int v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  *(_DWORD *)(a3 + 24) = 0;
  v4 = *a4;
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(a3 + 16) + 8);
    do
    {
      v7 = *v6++;
      v5 += v7;
      --v4;
    }
    while (v4);
    if (v5)
      v8 = a1 / (float)v5;
    else
      v8 = 0.0;
    v9 = *(_QWORD *)(a3 + 16);
    v10 = 2;
    do
    {
      v11 = (int)(float)((float)(v8 * (float)*(int *)(v9 + 4 * v10)) + 0.5);
      if (v11 <= 1)
        v11 = 1;
      *(_DWORD *)(v9 + 4 * v10) = v11;
      *(_DWORD *)(a3 + 24) += v11;
    }
    while (v10++ <= *a4);
  }
}

void MaxLLStateDuration(uint64_t a1, uint64_t a2, unsigned int *a3, float *a4, float a5)
{
  uint64_t v9;
  float *v10;
  float v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  BOOL v22;
  float v23;
  float i;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  float v29;
  uint64_t v30;
  uint64_t v31;
  float v32;
  float v33;
  float v34;
  float v35;

  v9 = *a3;
  if ((int)v9 <= 0)
  {
    v17 = *a4 + a5;
    if (v17 >= (float)(int)v9)
      v15 = v17;
    else
      v15 = (float)(int)v9;
  }
  else
  {
    v10 = (float *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a3 + 21) + 8 * *(int *)(a2 + 32)) + 8 * *(int *)(a2 + 8))
                  + 8);
    v11 = 0.0;
    v12 = *a3;
    v13 = 0.0;
    do
    {
      v13 = v13 + *v10;
      v11 = v11 + v10[v9];
      ++v10;
      --v12;
    }
    while (v12);
    v14 = *a4 + a5;
    if (v14 >= (float)(int)v9)
      v15 = v14;
    else
      v15 = (float)(int)v9;
    if (v11 != 0.0)
    {
      v16 = (float)(v15 - v13) / v11;
      goto LABEL_13;
    }
  }
  v16 = 0.0;
LABEL_13:
  MFS__log_select_Diag(a1, 10, (uint64_t)"SetMaxLLPhonemeDuration %f\n");
  *(_DWORD *)(a2 + 24) = 0;
  if ((int)*a3 < 1)
  {
    v23 = 0.0;
  }
  else
  {
    v18 = 2;
    do
    {
      MFS__log_select_Diag(a1, 10, (uint64_t)"state %d before %d");
      v19 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a3 + 21) + 8 * *(int *)(a2 + 32)) + 8 * *(int *)(a2 + 8));
      v20 = (int)(float)((float)(*(float *)(v19 + 4 * v18) + (float)(v16 * *(float *)(v19 + 4 * (int)(v18 + *a3))))
                       + 0.5);
      if (v20 <= 1)
        v20 = 1;
      *(_DWORD *)(*(_QWORD *)(a2 + 16) + 4 * v18) = v20;
      MFS__log_select_Diag(a1, 10, (uint64_t)" after %d\n");
      v21 = *(_DWORD *)(a2 + 24) + *(_DWORD *)(*(_QWORD *)(a2 + 16) + 4 * v18);
      *(_DWORD *)(a2 + 24) = v21;
      v22 = v18++ <= (int)*a3;
    }
    while (v22);
    v23 = (float)v21;
  }
  for (i = v15 - v23; fabs(i) >= 0.999989986; i = i - (float)v26)
  {
    if (i <= 0.0)
      v25 = 1;
    else
      v25 = -1;
    if (i > 0.0)
      v26 = 1;
    else
      v26 = -1;
    LODWORD(v27) = *a3;
    if ((int)*a3 < 1)
      break;
    v28 = 2;
    v29 = -1.0e10;
    v30 = 0xFFFFFFFFLL;
    do
    {
      v31 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a3 + 21) + 8 * *(int *)(a2 + 32)) + 8 * *(int *)(a2 + 8));
      v32 = (float)(*(_DWORD *)(*(_QWORD *)(a2 + 16) + 4 * v28) + v26) - *(float *)(v31 + 4 * v28);
      v33 = MFS__bet3_finv(*(float *)(v31 + 4 * ((int)v28 + (int)v27)));
      v34 = mfsLogLikelihood(v32, v33);
      if (v34 > v29 && *(_DWORD *)(*(_QWORD *)(a2 + 16) + 4 * v28) > v25)
      {
        v35 = v34;
        MFS__log_select_Diag(a1, 10, (uint64_t)"state %d LL %f dur %d incr %d t2 %f\n");
        v30 = v28;
        v29 = v35;
      }
      v27 = (int)*a3;
      v22 = v28++ <= v27;
    }
    while (v22);
    if ((int)v30 < 1)
      break;
    *(_DWORD *)(*(_QWORD *)(a2 + 16) + 4 * v30) += v26;
    *(_DWORD *)(a2 + 24) += v26;
  }
  *a4 = i;
}

uint64_t mfs_InitData(uint64_t a1, void *__b, _DWORD *a3)
{
  void *v6;

  cstdlib_memset(__b, 0, 0x30B0uLL);
  v6 = (void *)heap_Calloc(*(_QWORD **)(a1 + 8), 1, 6416);
  *((_QWORD *)__b + 1527) = v6;
  if (!v6)
    return 2229280778;
  cstdlib_memset(v6, 0, 0x1910uLL);
  return MFS__InitVData(a1, (char *)__b, a3);
}

void *mfs_DeInitData(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;

  v4 = a2[1529];
  if (v4)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v4);
    a2[1529] = 0;
  }
  v5 = a2[134];
  if (v5 && *(_DWORD *)(v5 + 8368) == 1)
    mfs_deInitUnitDataCompact((_QWORD *)a1, a2 + 138);
  v6 = a2[1555];
  if (v6)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v6);
    a2[1555] = 0;
  }
  v7 = a2[1556];
  if (v7)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v7);
    a2[1556] = 0;
  }
  v8 = a2[1530];
  if (v8)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v8);
    a2[1530] = 0;
  }
  v9 = a2[300];
  if (v9)
    heap_Free(*(_QWORD **)(a1 + 8), v9);
  v10 = 0x1FFFFFFFFFFFFFECLL;
  v11 = a2 + 194;
  do
  {
    v12 = v11[20];
    v13 = *v11;
    if (*v11)
    {
      *v11 = v13 + 16;
      heap_Free(*(_QWORD **)(a1 + 8), v13 + 16);
    }
    if (v12)
      heap_Free(*(_QWORD **)(a1 + 8), v12);
    mfs_SparseMtx_DeInit(&a2[v10 + 285]);
    ++v11;
    v10 += 2;
  }
  while (v10 * 8);
  mfs_HarchData_DeInit(a2 + 243);
  mfs_StateNGram_DeInit(a2 + 285);
  mfs_symData_DeInit(a2);
  v14 = (_DWORD *)a2[134];
  if (v14 && v14[2082])
  {
    if ((v14[2086] - 3) <= 1)
    {
      mfs_BPESymData_DeInit_Obersee((uint64_t)a2);
      v14 = (_DWORD *)a2[134];
    }
    if (v14[2083] == 1)
      mfs_AllUnitCompData_DeInit_Obersee((uint64_t)a2);
  }
  MFS__DeInitVData((void *)a1, (char *)a2);
  v15 = a2[1527];
  if (v15)
    heap_Free(*(_QWORD **)(a1 + 8), v15);
  return cstdlib_memset(a2, 0, 0x30B0uLL);
}

_QWORD *mfs_deInitUnitDataCompact(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a2)
  {
    v3 = result;
    v4 = a2[10];
    if (v4)
    {
      result = heap_Free((_QWORD *)result[1], v4);
      a2[10] = 0;
    }
    v5 = a2[11];
    if (v5)
    {
      result = heap_Free((_QWORD *)v3[1], v5);
      a2[11] = 0;
    }
    v6 = a2[12];
    if (v6)
    {
      result = heap_Free((_QWORD *)v3[1], v6);
      a2[12] = 0;
    }
  }
  return result;
}

uint64_t mfs_isUnitRemoved(uint64_t result, unsigned int a2)
{
  if (result)
    return ((1 << (a2 & 7)) & *(unsigned __int8 *)(result + ((unint64_t)a2 >> 3))) >> (a2 & 7);
  return result;
}

uint64_t mfs_initUnitDataCompact(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  _DWORD *v19;
  int v20;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  _WORD *v35;
  _WORD *v36;
  unsigned int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __int16 *v46;
  __int16 v47;

  v11 = *(_QWORD *)(a2 + 1072);
  if (a3 && v11)
  {
    v12 = *(_QWORD *)(v11 + 9704);
    v13 = *(_DWORD *)(v11 + 9952) >> 1;
    *a3 = *(_DWORD *)(v11 + 9712) >> 2;
    a3[1] = v13;
    v14 = *(_QWORD *)(v11 + 9944);
    *((_QWORD *)a3 + 2) = v12;
    *((_QWORD *)a3 + 3) = v14;
    v15 = *(_QWORD *)(v11 + 10184);
    a3[2] = *(_DWORD *)(v11 + 10192);
    v16 = *(_QWORD *)(v11 + 10424);
    *((_QWORD *)a3 + 4) = v15;
    *((_QWORD *)a3 + 5) = v16;
    a3[12] = *(_DWORD *)(v11 + 10672);
    *((_QWORD *)a3 + 7) = *(_QWORD *)(v11 + 10664);
  }
  v17 = *(unsigned int *)(v11 + 132);
  if ((int)v17 < 1)
    goto LABEL_25;
  v18 = 0;
  v19 = (_DWORD *)(v11 + 264);
  do
  {
    v20 = *(v19 - 10);
    if ((v20 != 1 || *(_DWORD *)(v11 + 25288) != 1) && v20 != 0)
      v18 += *v19;
    ++v19;
    --v17;
  }
  while (v17);
  if (!v18)
  {
LABEL_25:
    MFS__log_select_Error(a1, 0, (uint64_t)"iStrRecordLen can not be 0!\n", a4, a5, a6, a7, a8);
    a3[28] = 0;
    v34 = 2229281034;
LABEL_42:
    mfs_deInitUnitDataCompact((_QWORD *)a1, a3);
    return v34;
  }
  a3[28] = v18;
  v23 = heap_Calloc(*(_QWORD **)(a1 + 8), *a3, 2);
  if (!v23)
    goto LABEL_41;
  v29 = a3[1];
  if ((_DWORD)v29)
  {
    v30 = 0;
    v31 = 0;
    v32 = *((_QWORD *)a3 + 3);
    do
    {
      if (*(_WORD *)(v32 + 2 * v30))
      {
        v33 = 0;
        do
          *(_WORD *)(v23 + 2 * (v31 + v33++)) = v30;
        while (v33 < *(unsigned __int16 *)(v32 + 2 * v30));
        v31 += v33;
      }
      ++v30;
    }
    while (v30 != v29);
  }
  else
  {
    v29 = 0;
  }
  *((_QWORD *)a3 + 10) = v23;
  v35 = (_WORD *)heap_Calloc(*(_QWORD **)(a1 + 8), v29, 2);
  if (!v35)
    goto LABEL_41;
  v36 = (_WORD *)*((_QWORD *)a3 + 3);
  *v35 = *v36;
  v37 = a3[1];
  if (v37 >= 2)
  {
    v38 = 1;
    v39 = 1;
    do
    {
      v35[(unsigned __int16)v39] = v36[(unsigned __int16)v39] + v35[v38 - 1];
      v38 = (unsigned __int16)++v39;
    }
    while (v37 > (unsigned __int16)v39);
  }
  *((_QWORD *)a3 + 11) = v35;
  *((_QWORD *)a3 + 13) = *(_QWORD *)(v11 + 11144);
  v40 = *((_QWORD *)a3 + 10);
  v41 = *(_QWORD *)(a2 + 1072);
  v42 = heap_Calloc(*(_QWORD **)(a1 + 8), *a3, 2);
  if (!v42)
  {
LABEL_41:
    v34 = 2229280778;
    MFS__log_select_Error(a1, 0, (uint64_t)"Not enough memory\n", v24, v25, v26, v27, v28);
    goto LABEL_42;
  }
  v43 = *a3;
  if (v43 >= 2)
  {
    v44 = 0;
    v45 = *(_QWORD *)(a2 + 2384);
    do
    {
      if (*(unsigned __int16 *)(v40 + 2 * v44 + 2) == *(unsigned __int16 *)(v40 + 2 * v44))
      {
        v46 = (__int16 *)(v42 + 2 * v44);
        v47 = *v46;
        v46[1] = *v46;
        if (!v45
          || !(((1 << (v44 & 7)) & *(unsigned __int8 *)(v45 + (v44 >> 3))) >> (v44 & 7)))
        {
          v46[1] = v47 + *(_WORD *)(v41 + 24) * *(unsigned __int8 *)(*((_QWORD *)a3 + 5) + v44);
        }
      }
      else
      {
        *(_WORD *)(v42 + 2 * v44 + 2) = 0;
      }
      ++v44;
    }
    while (v43 - 1 != v44);
  }
  v34 = 0;
  *(_WORD *)(v42 + 2 * (v43 - 1)) = 0;
  *((_QWORD *)a3 + 12) = v42;
  return v34;
}

uint64_t mfs_getUnitDataFromMfsData(unsigned __int8 *a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  char v15;
  unsigned int v16;
  char *v17;
  char v18;

  v3 = *((_QWORD *)a1 + 134);
  v4 = *(_DWORD *)(v3 + 8368);
  if (v4 != 1)
  {
    if (v4)
      return 2229281034;
    v5 = 0;
    *a3 = *((_QWORD *)a1 + 136) + 16 * a2;
    return v5;
  }
  v6 = *a3;
  v7 = *((_DWORD *)a1 + 276);
  if (v7 - 1 == a2)
  {
    v5 = 0;
    *(_QWORD *)v6 = 0;
    *(_DWORD *)(v6 + 8) = -65536;
    *(_DWORD *)(v6 + 12) = 65793;
    return v5;
  }
  v8 = *a1;
  v9 = *((_QWORD *)a1 + 148);
  v10 = *(unsigned __int16 *)(v9 + 2 * a2);
  v11 = *(_DWORD *)(*((_QWORD *)a1 + 140) + 4 * a2);
  *(_WORD *)(v6 + 10) = v10;
  *(_DWORD *)v6 = v11;
  *(_WORD *)(v6 + 8) = *(unsigned __int8 *)(*((_QWORD *)a1 + 143) + a2);
  v12 = *((_QWORD *)a1 + 142);
  v13 = a2 / v8;
  *(_BYTE *)(v6 + 13) = *(_BYTE *)(v12 + a2 / v8);
  if (a2 >= v8 && (v14 = *(unsigned __int16 *)(v9 + 2 * a2), v14 <= *(unsigned __int16 *)(v9 + 2 * (a2 - v8))))
  {
    if (v7 > a2 && v7 - v8 < a2 || (v16 = v8 + a2, v16 < v7) && v14 < *(unsigned __int16 *)(v9 + 2 * v16))
    {
      v15 = 0;
      *(_BYTE *)(v6 + 12) = *(_BYTE *)(v12 + (v13 - 1));
      goto LABEL_17;
    }
    *(_BYTE *)(v6 + 12) = *(_BYTE *)(v12 + (v13 - 1));
  }
  else
  {
    *(_BYTE *)(v6 + 12) = 0;
  }
  if ((v13 + 1) < *((_DWORD *)a1 + 278))
  {
    v15 = *(_BYTE *)(v12 + (v13 + 1));
LABEL_17:
    *(_BYTE *)(v6 + 14) = v15;
  }
  *(_DWORD *)(v6 + 4) = *(unsigned __int16 *)(*((_QWORD *)a1 + 150) + 2 * a2) / *(int *)(v3 + 24)
                      + *(_DWORD *)(*((_QWORD *)a1 + 151) + 4 * v10) / *((_DWORD *)a1 + 304);
  v17 = (char *)*((_QWORD *)a1 + 145);
  v5 = 0;
  if (*((_DWORD *)a1 + 288) == 1)
    v18 = *v17;
  else
    v18 = v17[a2];
  *(_BYTE *)(v6 + 15) = v18;
  return v5;
}

uint64_t mfs_LoadData(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t VData;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _DWORD *v16;
  unsigned int v17;
  uint64_t v18;
  unsigned __int16 *v19;
  unsigned __int16 *v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  unsigned __int16 v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _WORD *v30;
  uint64_t v31;
  _WORD *v32;
  int v33;
  const char *v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int UnitDataRecordSize_Obersee;
  unsigned int v38;
  uint64_t v39;
  uint64_t inited;
  unsigned int *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unsigned int v54;
  _DWORD *v55;
  uint64_t v56;
  _BYTE *v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int *v60;
  unsigned int v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  unsigned int v66;
  uint64_t v67;
  _DWORD *v68;
  _QWORD *v69;
  uint64_t v70;
  int v72;
  uint64_t v73;
  unsigned int v74;
  _BYTE *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  unsigned __int8 *v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  _QWORD *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  _DWORD *v105;
  _QWORD *v106;
  _QWORD *v107;
  uint64_t v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  unsigned int v113;
  uint64_t i;
  unsigned __int8 *v116;
  uint64_t v117;
  unsigned int v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  _DWORD *v123;
  int v124;
  unsigned int v125;
  uint64_t v126;
  int v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  _WORD *v132;
  __int16 *v133;
  __int16 v134;
  int v135;
  unsigned int v136;
  uint64_t v137;
  int v138;
  int v139;
  uint64_t v140;
  uint64_t v141;
  _WORD *v142;
  __int16 *v143;
  __int16 v144;
  int v145;
  unsigned int v146;
  uint64_t v147;
  int v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  _WORD *v152;
  __int16 *v153;
  __int16 v154;
  unsigned int v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  _BYTE *v159;
  char *v160;
  char v161;
  char *v162;
  __int16 *v163;
  uint64_t v164;
  __int16 *__dst;
  uint64_t v166;
  uint64_t v167;

  VData = MFS__LoadVData(a1, (uint64_t)a2, a3);
  if ((VData & 0x80000000) != 0)
    return VData;
  v12 = (unsigned int *)(a3 + 16432);
  v13 = 2229280778;
  a2[115] = 1;
  *((_QWORD *)a2 + 134) = a3;
  v14 = *(_DWORD *)(a3 + 8328);
  if (v14 == 1)
  {
    if (!*(_DWORD *)(a3 + 23392))
    {
      *((_QWORD *)a2 + 135) = *(_QWORD *)(a3 + 8984);
LABEL_32:
      if (*(_DWORD *)(a3 + 8332) == 1)
      {
        mfs_AllUnitCompData_Init_Obersee((_QWORD *)a3, (uint64_t)a2);
        v35 = a2[472];
        v36 = 8 * *(_DWORD *)(a3 + 21712);
        a2[274] = v36 / v35 + 1;
        if (v36 % v35 < 9)
          goto LABEL_45;
      }
      else
      {
        UnitDataRecordSize_Obersee = mfs_getUnitDataRecordSize_Obersee();
        v38 = *(_DWORD *)(a3 + 21712);
        a2[274] = v38 / UnitDataRecordSize_Obersee + 1;
        if (!(v38 % UnitDataRecordSize_Obersee))
        {
          a2[275] = UnitDataRecordSize_Obersee;
LABEL_45:
          a2[594] = 0;
          *((_QWORD *)a2 + 298) = *(_QWORD *)(a3 + 9224);
          a2[598] = *(_DWORD *)(a3 + 9232) >> 2;
          goto LABEL_46;
        }
      }
      v34 = "MFS_DATA_OBERSEE_ALLUNITDATA block does not appear to match runtime engine!\n";
LABEL_37:
      v39 = a1;
LABEL_38:
      MFS__log_select_Error(v39, 0, (uint64_t)v34, v7, v8, v9, v10, v11);
      return 2229281034;
    }
    v24 = *(_QWORD *)(a3 + 23144);
    v25 = *(_WORD *)(a3 + 23152) - 1;
    v26 = *(unsigned __int8 *)(v24 + v25);
    v27 = heap_Calloc(*(_QWORD **)(a1 + 8), *v12 << 10, 8);
    if (!v27)
      return 2229280778;
    *((_QWORD *)a2 + 300) = v27;
    v28 = 4 * v26 * *v12;
    if ((_DWORD)v28)
    {
      v29 = 0;
      v30 = *(_WORD **)(a3 + 23384);
      do
      {
        if (*v30)
        {
          v31 = v29 % v25;
          if (*(unsigned __int8 *)(v24 + v31) * *(unsigned __int8 *)(v24 + v31) != (unsigned __int16)*v30)
            return 2229281034;
          v32 = v30 + 1;
          *(_QWORD *)(*((_QWORD *)a2 + 300) + 8 * v29) = v32;
          v30 = &v32[*(unsigned __int8 *)(v24 + v31) * *(unsigned __int8 *)(v24 + v31)];
        }
        else
        {
          v30 += 2;
        }
        ++v29;
      }
      while (v28 != v29);
    }
  }
  else
  {
    if (v14 || !*(_DWORD *)(a3 + 18352))
    {
      *((_QWORD *)a2 + 135) = *(_QWORD *)(a3 + 8984);
      goto LABEL_15;
    }
    v15 = heap_Calloc(*(_QWORD **)(a1 + 8), 1792 * *v12, 8);
    *((_QWORD *)a2 + 300) = v15;
    if (!v15)
      return 2229280778;
    v16 = *(_DWORD **)(a3 + 18344);
    v17 = *v12;
    if (*v16 == 1)
      v17 = 1792 * *v12;
    if (v17)
    {
      v18 = 0;
      v19 = (unsigned __int16 *)&v16[*v16 == 1];
      v20 = v19;
      do
      {
        v21 = *v20;
        v20 += 2;
        if (v21)
        {
          *(_QWORD *)(*((_QWORD *)a2 + 300) + v18) = v20;
          v20 = v19 + 32770;
        }
        v18 += 8;
        v19 = v20;
      }
      while (8 * v17 != v18);
    }
  }
  v33 = *(_DWORD *)(a3 + 8328);
  *((_QWORD *)a2 + 135) = *(_QWORD *)(a3 + 8984);
  if (v33 == 1)
    goto LABEL_32;
LABEL_15:
  v22 = *(_DWORD *)(a3 + 8368);
  if (v22 == 1)
  {
    *((_QWORD *)a2 + 298) = *(_QWORD *)(a3 + 10904);
    a2[598] = *(_DWORD *)(a3 + 10912);
    a2[594] = 1;
    if ((mfs_initUnitDataCompact(a1, (uint64_t)a2, (unsigned int *)a2 + 276, v7, v8, v9, v10, v11) & 0x80000000) != 0)
      return 2229281034;
    v23 = a2[276];
  }
  else
  {
    *((_QWORD *)a2 + 298) = *(_QWORD *)(a3 + 9224);
    a2[598] = *(_DWORD *)(a3 + 9232) >> 2;
    if (v22)
    {
      v34 = "Unknown UND4 compressing algorithm!\n";
      goto LABEL_37;
    }
    *((_QWORD *)a2 + 136) = *(_QWORD *)(a3 + 9464);
    v23 = *(_DWORD *)(a3 + 9472) >> 4;
  }
  a2[274] = v23;
  if (*(_DWORD *)(a3 + 8272))
  {
    VData = mfs_fastPhoneDur(a1, a2);
    if ((VData & 0x80000000) != 0)
      return VData;
  }
LABEL_46:
  v41 = *(unsigned int **)(a3 + 11624);
  if (v41 && ((v42 = *(_QWORD *)(a3 + 11864), *(_DWORD *)(a3 + 8328)) || v42))
  {
    LODWORD(v166) = 0;
    LODWORD(__dst) = 0;
    LODWORD(v164) = 0;
    LODWORD(v163) = 0;
    v50 = *v41;
    LODWORD(v166) = v50;
    *((_BYTE *)a2 + 12456) = v50;
    v51 = heap_Calloc(*(_QWORD **)(a1 + 8), v50, 24);
    if (!v51)
      return 2229280778;
    v52 = v51;
    if ((_DWORD)v50)
    {
      v53 = 0;
      v54 = 1;
      v55 = (_DWORD *)v51;
      do
      {
        *v55 = v41[v54];
        v55 += 6;
        ++v54;
        ++v53;
        v56 = v166;
      }
      while (v53 < v166);
      if ((_DWORD)v166)
      {
        v57 = (_BYTE *)(v51 + 5);
        v58 = v166;
        do
        {
          *v57 = v41[v54];
          v57 += 24;
          ++v54;
          --v58;
        }
        while (v58);
        v59 = 0;
        v60 = &v41[v54];
        do
        {
          v61 = 0;
          if (v59)
          {
            v62 = v59;
            v63 = v51;
            do
            {
              v64 = *(unsigned __int8 *)(v63 + 5);
              v65 = *(_DWORD *)v63;
              v63 += 24;
              v61 += v64 * v65;
              --v62;
            }
            while (v62);
          }
          *(_QWORD *)(v51 + 24 * v59++ + 8) = &v60[v61];
        }
        while (v59 != v56);
      }
    }
    if (*(_DWORD *)(a3 + 8328))
    {
      v66 = 0;
    }
    else
    {
      cstdlib_memcpy(&__dst, (const void *)v42, 4uLL);
      cstdlib_memcpy(&v164, (const void *)(v42 + 8), 4uLL);
      v72 = 4 * v164;
      cstdlib_memcpy(&v163, (const void *)(v42 + (4 * v164 + 16)), 4uLL);
      v66 = v163 / ((int)__dst + 1);
      cstdlib_memcpy(&v166, (const void *)(v42 + (v72 + 20)), 4uLL);
      v73 = v166;
      if ((_DWORD)v166)
      {
        v74 = v72 + 24;
        v75 = (_BYTE *)(v52 + 4);
        v76 = v166;
        do
        {
          *v75 = *(_DWORD *)(v42 + v74);
          v75 += 24;
          v74 += 4;
          --v76;
        }
        while (v76);
        v77 = 0;
        v78 = v42 + v74;
        do
        {
          v79 = 0;
          if (v77)
          {
            v80 = v77;
            v81 = (unsigned __int8 *)(v52 + 4);
            do
            {
              v82 = *v81;
              v81 += 24;
              v79 += v66 * v82;
              --v80;
            }
            while (v80);
          }
          *(_QWORD *)(v52 + 24 * v77++ + 16) = v78 + v79;
        }
        while (v77 != v73);
      }
    }
    *((_QWORD *)a2 + 1555) = v52;
    a2[386] = v66;
  }
  else
  {
    if (*(_QWORD *)(a3 + 11408))
    {
      v43 = *(unsigned int *)(a3 + 132);
      if ((int)v43 >= 1)
      {
        v44 = 0;
        v45 = a2 + 308;
        v46 = 24 * v43;
        v47 = 224;
        do
        {
          if (*(_DWORD *)(a3 + v47))
          {
            *((_QWORD *)v45 - 1) = *(_QWORD *)(a3 + v44 + 11384);
            *v45 = *(_DWORD *)(a3 + v44 + 11396);
          }
          v44 += 24;
          v45 += 8;
          v47 += 4;
        }
        while (v46 != v44);
      }
      v48 = *(unsigned int *)(a3 + 11416);
      v49 = 4 * *(unsigned int *)(a3 + 268);
    }
    else
    {
      if (!*(_QWORD *)(a3 + 12128))
        goto LABEL_87;
      v67 = *(unsigned int *)(a3 + 132);
      if ((int)v67 >= 1)
      {
        v68 = (_DWORD *)(a3 + 224);
        v69 = a2 + 312;
        v70 = a3;
        do
        {
          if (*v68++)
          {
            *(v69 - 1) = *(_QWORD *)(v70 + 12104);
            *v69 = *(_QWORD *)(v70 + 12344);
            *((_DWORD *)v69 - 4) = *(_DWORD *)(v70 + 11396);
          }
          v69 += 4;
          v70 += 24;
          --v67;
        }
        while (v67);
      }
      v48 = *(unsigned int *)(a3 + 12136);
      v49 = 2 * *(unsigned int *)(a3 + 268);
    }
    a2[386] = v48 / v49;
  }
LABEL_87:
  if (*(_DWORD *)(a3 + 8328))
  {
    v83 = *a2;
    v84 = *(_QWORD *)(a3 + 22208);
    v85 = *(_QWORD *)(a3 + 22232);
    v86 = *(_QWORD *)(a3 + 22184);
    v87 = heap_Calloc(*(_QWORD **)(a1 + 8), v83 + 2, 8);
    *((_QWORD *)a2 + 215) = v87;
    if (!v87)
      return 2229280778;
    v88 = heap_Calloc(*(_QWORD **)(a1 + 8), v83 + 2, 8);
    *((_QWORD *)a2 + 216) = v88;
    if (!v88)
      return 2229280778;
    v89 = heap_Calloc(*(_QWORD **)(a1 + 8), v83 + 2, 8);
    *((_QWORD *)a2 + 214) = v89;
    if (!v89)
      return 2229280778;
    if ((int)v83 >= 1)
    {
      v90 = 16 * a2[11];
      v91 = 2;
      do
      {
        *(_QWORD *)(*((_QWORD *)a2 + 215) + 8 * v91) = v84;
        *(_QWORD *)(*((_QWORD *)a2 + 215) + 8 * v91) -= 16;
        v84 += 16 * *(int *)(*((_QWORD *)a2 + 7) + 4 * v91);
        *(_QWORD *)(*((_QWORD *)a2 + 216) + 8 * v91) = v85;
        *(_QWORD *)(*((_QWORD *)a2 + 216) + 8 * v91) -= 16;
        v85 += 16 * *(int *)(*((_QWORD *)a2 + 8) + 4 * v91);
        *(_QWORD *)(*((_QWORD *)a2 + 214) + 8 * v91) = v86;
        *(_QWORD *)(*((_QWORD *)a2 + 214) + 8 * v91++) -= 16;
        v86 += v90;
      }
      while ((_DWORD)v83 + 2 != v91);
    }
    v92 = a2 + 448;
    *((_QWORD *)a2 + 225) = *(_QWORD *)(a3 + 22448);
    *((_QWORD *)a2 + 226) = *(_QWORD *)(a3 + 22472);
    v93 = 22424;
  }
  else
  {
    v94 = *(_QWORD *)(a3 + 12608);
    v95 = *(_QWORD *)(a3 + 12632);
    v96 = *(_QWORD *)(a3 + 12584);
    v97 = heap_Calloc(*(_QWORD **)(a1 + 8), *a2, 8);
    *((_QWORD *)a2 + 195) = v97;
    if (!v97)
      return 2229280778;
    *((_QWORD *)a2 + 195) = v97 - 16;
    v98 = heap_Calloc(*(_QWORD **)(a1 + 8), *a2, 8);
    *((_QWORD *)a2 + 196) = v98;
    if (!v98)
      return 2229280778;
    *((_QWORD *)a2 + 196) = v98 - 16;
    v99 = heap_Calloc(*(_QWORD **)(a1 + 8), *a2, 8);
    *((_QWORD *)a2 + 194) = v99;
    if (!v99)
      return 2229280778;
    *((_QWORD *)a2 + 194) = v99 - 16;
    v100 = *a2;
    if ((int)v100 >= 1)
    {
      v101 = v100 + 2;
      v102 = 8 * a2[11];
      v103 = 2;
      do
      {
        *(_QWORD *)(*((_QWORD *)a2 + 195) + 8 * v103) = v94;
        *(_QWORD *)(*((_QWORD *)a2 + 195) + 8 * v103) -= 8;
        v94 += 8 * *(int *)(*((_QWORD *)a2 + 7) + 4 * v103);
        *(_QWORD *)(*((_QWORD *)a2 + 196) + 8 * v103) = v95;
        *(_QWORD *)(*((_QWORD *)a2 + 196) + 8 * v103) -= 8;
        v95 += 8 * *(int *)(*((_QWORD *)a2 + 8) + 4 * v103);
        *(_QWORD *)(*((_QWORD *)a2 + 194) + 8 * v103) = v96;
        *(_QWORD *)(*((_QWORD *)a2 + 194) + 8 * v103++) -= 8;
        v96 += v102;
      }
      while (v101 != v103);
    }
    v92 = a2 + 408;
    *((_QWORD *)a2 + 205) = *(_QWORD *)(a3 + 12848);
    *((_QWORD *)a2 + 206) = *(_QWORD *)(a3 + 12872);
    v93 = 12824;
  }
  *v92 = *(_QWORD *)(a3 + v93);
  VData = mfs_HarchData_Load((uint64_t)(a2 + 486), a3);
  if ((VData & 0x80000000) != 0)
    return VData;
  *((_QWORD *)a2 + 251) = *(_QWORD *)(a3 + 14504);
  v104 = *(unsigned int *)(a3 + 132);
  if ((int)v104 >= 1)
  {
    v105 = (_DWORD *)(a3 + 224);
    v106 = (_QWORD *)(a3 + 14744);
    v107 = a2 + 504;
    do
    {
      if (*v105++)
        *v107 = *v106;
      v106 += 3;
      ++v107;
      --v104;
    }
    while (v104);
  }
  *((_QWORD *)a2 + 262) = *(_QWORD *)(a3 + 15248);
  VData = mfs_SparseMtx_Load((uint64_t)(a2 + 534), a3 + 15480);
  if ((VData & 0x80000000) != 0)
    return VData;
  inited = mfs_SparseMtx_Load((uint64_t)(a2 + 538), a3 + 15504);
  if ((inited & 0x80000000) != 0)
    return inited;
  if (*(_DWORD *)(a3 + 8784))
    inited = mfs_StateNGram_Load((uint64_t)(a2 + 570), *a2, a3 + 15720);
  if (!mfs_symData_Init(a3, a2, a1))
    return 2229280778;
  v109 = *((_QWORD *)a2 + 134);
  if (*(_DWORD *)(v109 + 8328))
  {
    if ((*(_DWORD *)(v109 + 8344) - 3) <= 1)
    {
      inited = mfs_BPESymData_Init_Obersee(a3, (uint64_t)a2, a1, v7, v8, v9, v10, v11);
      if ((inited & 0x80000000) != 0)
        return inited;
    }
  }
  v110 = *(_DWORD *)(a3 + 8364);
  if (v110 != 1)
  {
    if (!v110)
    {
      *((_QWORD *)a2 + 1528) = *(_QWORD *)(a3 + 18104);
LABEL_119:
      v111 = *(_QWORD *)(a3 + 20744);
      if (v111)
        *((_QWORD *)a2 + 1531) = v111;
      if (*(_QWORD *)(a3 + 20984))
      {
        mfs_loadKLDMTX(a2, a3);
        inited = 0;
      }
      if (*(_QWORD *)(a3 + 21224))
      {
        mfs_loadKLDMTX_Quant(a2, a3);
        inited = 0;
      }
      v112 = *(_QWORD *)(a3 + 21464);
      if (v112)
      {
        a2[3064] = 2;
        *((_QWORD *)a2 + 1533) = v112;
        v113 = 32;
        for (i = 8; i != 32; i += 8)
          v113 += 4 * *(_DWORD *)(v112 + i);
        inited = 0;
        *((_QWORD *)a2 + 1534) = v112 + v113;
        *((_QWORD *)a2 + 1535) = v112 + v113 + 16 * *(_DWORD *)(v112 + 4);
      }
      MFS__log_select_Diag(a1, 1, (uint64_t)"Loaded %d states from %d threshold at %d\n");
      return inited;
    }
    v34 = "Loaded MFS_DATA_COST_JOIN_ELEMENTS failed, unsupported compression setting!\n";
    v39 = 0;
    goto LABEL_38;
  }
  v116 = *(unsigned __int8 **)(a3 + 18104);
  v166 = 0;
  v167 = 0;
  v164 = 0;
  __dst = 0;
  v162 = 0;
  v163 = 0;
  MFS__log_select_Diag(a1, 1, (uint64_t)"decompressing MFS_DATA_COST_JOIN_ELEMENTS, mode=%d\n");
  cstdlib_memcpy((char *)&v167 + 4, v116, 4uLL);
  v117 = heap_Calloc(*(_QWORD **)(a1 + 8), HIDWORD(v167), 12);
  if (!v117)
    goto LABEL_164;
  v118 = 4 * HIDWORD(v167);
  cstdlib_memcpy(&v167, v116 + 4, 4uLL);
  v119 = v167;
  v120 = do_huffman_uncompress(a1, v116 + 8, &v166, v167, v118);
  v121 = v166;
  if ((v120 & 0x80000000) != 0)
  {
    v13 = v120;
    if (v166)
      heap_Free(*(_QWORD **)(a1 + 8), v166);
    goto LABEL_164;
  }
  if (HIDWORD(v167))
  {
    v122 = 0;
    v123 = (_DWORD *)v117;
    do
    {
      *v123 = *(_DWORD *)(v121 + 4 * v122);
      v123 += 3;
      ++v122;
    }
    while (v122 < HIDWORD(v167));
    goto LABEL_143;
  }
  if (v166)
  {
LABEL_143:
    heap_Free(*(_QWORD **)(a1 + 8), v121);
    v124 = HIDWORD(v167);
    goto LABEL_144;
  }
  v124 = 0;
LABEL_144:
  v125 = 2 * v124;
  cstdlib_memcpy(&v167, &v116[v119 + 8], 4uLL);
  v126 = (v119 + 12);
  v127 = v167;
  v128 = do_huffman_uncompress(a1, &v116[v126], &__dst, v167, v125);
  if ((v128 & 0x80000000) != 0)
  {
LABEL_163:
    v13 = v128;
    goto LABEL_164;
  }
  v129 = v127 + v126;
  v130 = HIDWORD(v167);
  v131 = (uint64_t)__dst;
  if (HIDWORD(v167))
  {
    v132 = (_WORD *)(v117 + 4);
    v133 = __dst;
    do
    {
      v134 = *v133++;
      *v132 = v134;
      v132 += 6;
      --v130;
    }
    while (v130);
    goto LABEL_150;
  }
  if (__dst)
  {
LABEL_150:
    heap_Free(*(_QWORD **)(a1 + 8), v131);
    __dst = 0;
    v135 = HIDWORD(v167);
    goto LABEL_151;
  }
  v135 = 0;
LABEL_151:
  v136 = 2 * v135;
  cstdlib_memcpy(&v167, &v116[v129], 4uLL);
  v137 = (v129 + 4);
  v138 = v167;
  v128 = do_huffman_uncompress(a1, &v116[v137], &v164, v167, v136);
  if ((v128 & 0x80000000) != 0)
    goto LABEL_163;
  v139 = v138 + v137;
  v140 = HIDWORD(v167);
  v141 = v164;
  if (HIDWORD(v167))
  {
    v142 = (_WORD *)(v117 + 6);
    v143 = (__int16 *)v164;
    do
    {
      v144 = *v143++;
      *v142 = v144;
      v142 += 6;
      --v140;
    }
    while (v140);
    goto LABEL_157;
  }
  if (v164)
  {
LABEL_157:
    heap_Free(*(_QWORD **)(a1 + 8), v141);
    v164 = 0;
    v145 = HIDWORD(v167);
    goto LABEL_158;
  }
  v145 = 0;
LABEL_158:
  v146 = 2 * v145;
  cstdlib_memcpy(&v167, &v116[v139], 4uLL);
  v147 = (v139 + 4);
  v148 = v167;
  v128 = do_huffman_uncompress(a1, &v116[v147], &v163, v167, v146);
  if ((v128 & 0x80000000) != 0)
    goto LABEL_163;
  v149 = v148 + v147;
  v150 = HIDWORD(v167);
  v151 = (uint64_t)v163;
  if (HIDWORD(v167))
  {
    v152 = (_WORD *)(v117 + 8);
    v153 = v163;
    do
    {
      v154 = *v153++;
      *v152 = v154;
      v152 += 6;
      --v150;
    }
    while (v150);
  }
  else if (!v163)
  {
    v155 = 0;
    goto LABEL_178;
  }
  heap_Free(*(_QWORD **)(a1 + 8), v151);
  v163 = 0;
  v155 = HIDWORD(v167);
LABEL_178:
  cstdlib_memcpy(&v167, &v116[v149], 4uLL);
  v156 = do_lzfast_uncompress(a1, &v116[v149 + 4], (uint64_t *)&v162, v167, v155);
  inited = v156;
  if ((v156 & 0x80000000) == 0)
  {
    v157 = HIDWORD(v167);
    v158 = (uint64_t)v162;
    if (HIDWORD(v167))
    {
      v159 = (_BYTE *)(v117 + 10);
      v160 = v162;
      do
      {
        v161 = *v160++;
        *v159 = v161;
        v159 += 12;
        --v157;
      }
      while (v157);
    }
    else if (!v162)
    {
LABEL_187:
      *((_QWORD *)a2 + 1528) = v117;
      *((_QWORD *)a2 + 1530) = v117;
      MFS__log_select_Diag(a1, 1, (uint64_t)"decompressing MFS_DATA_COST_JOIN_ELEMENTS, mode=%d done!\n");
      goto LABEL_119;
    }
    heap_Free(*(_QWORD **)(a1 + 8), v158);
    goto LABEL_187;
  }
  v13 = v156;
LABEL_164:
  if (__dst)
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)__dst);
  if (v164)
    heap_Free(*(_QWORD **)(a1 + 8), v164);
  if (v163)
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v163);
  if (v162)
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v162);
  if (v117)
    heap_Free(*(_QWORD **)(a1 + 8), v117);
  return v13;
}

uint64_t mfs_fastPhoneDur(uint64_t a1, int *a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  signed int v6;
  signed int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v13;
  _QWORD *v14;
  _QWORD v15[2];

  v3 = a2[274];
  v4 = *a2;
  v15[0] = 0;
  v15[1] = 0;
  v14 = v15;
  v5 = heap_Calloc(*(_QWORD **)(a1 + 8), v3, 1);
  *((_QWORD *)a2 + 1529) = v5;
  if (!v5)
    return 2229280778;
  v6 = v3 / v4 * v4;
  if (v6 < 1)
  {
    v8 = 0;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    LODWORD(v9) = *a2;
    do
    {
      if ((int)v9 >= 1)
      {
        v10 = 0;
        do
        {
          v11 = v10 + 2;
          *(_BYTE *)(*((_QWORD *)a2 + 1529) + (v7 + v10)) = CandidatePhonemeDuration((unsigned __int8 *)a2, v7 + (int)v10, (int)v10 + 2);
          v9 = *a2;
          ++v10;
        }
        while (v11 <= v9);
        v8 = v7 + v10 - 1;
      }
      v7 += v9;
    }
    while (v7 < v6);
  }
  if (v8 < a2[274])
  {
    v13 = v8;
    do
    {
      mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v13, (uint64_t *)&v14);
      *(_BYTE *)(*((_QWORD *)a2 + 1529) + v13++) = *((_BYTE *)v14 + 8);
    }
    while (v13 < a2[274]);
  }
  return 0;
}

uint64_t do_huffman_uncompress(uint64_t a1, unsigned __int8 *a2, _QWORD *a3, int a4, unsigned int a5)
{
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t result;

  v10 = (_BYTE *)heap_Calloc(*(_QWORD **)(a1 + 8), a5, 1);
  if (v10)
  {
    v16 = v10;
    Huffman_Uncompress(a2, v10, a4, a5);
    MFS__log_select_Diag(a1, 0, (uint64_t)"Huffman decoding, from: %d Bytes, to: %d Bytes, rate: %f%%\n");
    result = 0;
    *a3 = v16;
  }
  else
  {
    MFS__log_select_Error(a1, 0, (uint64_t)"Not enough memory\n", v11, v12, v13, v14, v15);
    return 2229280778;
  }
  return result;
}

uint64_t do_lzfast_uncompress(uint64_t a1, unsigned __int8 *a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;

  v9 = heap_Calloc(*(_QWORD **)(a1 + 8), a5, 1);
  if (v9)
  {
    v15 = v9;
    LZ_Uncompress(a2, v9, a4);
    MFS__log_select_Diag(a1, 0, (uint64_t)"Lz_fast decoding, from: %d Bytes, to: %d Bytes\n, rate: %f%%\n");
    result = 0;
    *a3 = v15;
  }
  else
  {
    MFS__log_select_Error(a1, 0, (uint64_t)"Not enough memory\n", v10, v11, v12, v13, v14);
    return 2229280778;
  }
  return result;
}

int *mfs_loadKLDMTX(int *result, uint64_t a2)
{
  char *v2;
  int *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  _QWORD v12[4];

  v12[3] = *MEMORY[0x24BDAC8D0];
  v2 = *(char **)(a2 + 20984);
  result[3064] = 0;
  if (*result >= 1)
  {
    v3 = result;
    v4 = v12;
    v5 = 2;
    do
    {
      result = (int *)cstdlib_memcpy(v4, v2, 4uLL);
      v2 += 4;
      ++v5;
      v6 = *v3;
      v4 = (_QWORD *)((char *)v4 + 4);
    }
    while (v5 < v6 + 2);
    if ((int)v6 >= 1)
    {
      v7 = (v6 + 2);
      v8 = (int *)v12;
      v9 = v3 + 3070;
      v10 = v7 - 2;
      do
      {
        *v9++ = v2;
        v11 = *v8++;
        v2 += 4 * (((v11 - 1) * v11) >> 1);
        --v10;
      }
      while (v10);
    }
  }
  return result;
}

float mfs_loadKLDMTX_Quant(int *a1, uint64_t a2)
{
  char *v3;
  _QWORD *v4;
  uint64_t v5;
  float result;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  int *v10;
  int *v11;
  uint64_t v12;
  char *v13;
  int __dst;
  _QWORD v15[4];

  v15[3] = *MEMORY[0x24BDAC8D0];
  __dst = 0;
  a1[3064] = 1;
  v3 = *(char **)(a2 + 21224);
  if (*a1 >= 1)
  {
    v4 = v15;
    v5 = 1;
    do
    {
      cstdlib_memcpy(v4, v3, 4uLL);
      v3 += 4;
      ++v5;
      v4 = (_QWORD *)((char *)v4 + 4);
    }
    while (v5 <= *a1);
  }
  cstdlib_memcpy(&__dst, v3, 4uLL);
  *((_BYTE *)a1 + 12264) = __dst;
  v7 = *a1;
  if ((int)v7 >= 1)
  {
    v8 = 0;
    v9 = (float *)(v3 + 4);
    v10 = a1 + 3072;
    do
    {
      v11 = &v10[v8];
      v11[18] = *(_DWORD *)v9;
      result = v9[1];
      *((float *)v11 + 28) = result;
      v12 = *((int *)v9 + 2);
      v13 = (char *)(v9 + 3);
      *(_QWORD *)&v10[2 * v8] = v13;
      v9 = (float *)&v13[v12];
      ++v8;
    }
    while (v7 != v8);
  }
  return result;
}

void *mfs_GetMsgName(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;

  if (!a1)
    return &mfs_GetMsgName_szEmpty;
  v2 = *(_QWORD *)(a1 + 1080);
  if (!v2)
    return &mfs_GetMsgName_szEmpty;
  v3 = v2 + 30 * a2;
  if (*(_DWORD *)(a1 + 1096) - 1 > a2)
    return (void *)v3;
  else
    return &mfs_GetMsgName_szEmpty;
}

uint64_t mfs_GetMessageOffsetMsec(uint64_t a1, signed int a2)
{
  signed int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  _QWORD *v10;
  _QWORD v11[2];
  _QWORD *v12;
  _QWORD __dst[2];

  v2 = a2;
  v4 = *(_QWORD *)(a1 + 1072);
  if (*(_DWORD *)(v4 + 8328))
  {
    LOWORD(__dst[0]) = 0;
    v5 = *(_QWORD *)(a1 + 1080);
    if (v5)
    {
      cstdlib_memcpy(__dst, (const void *)(v5 + 30 * a2 + 23), 2uLL);
      return LOWORD(__dst[0]);
    }
    else
    {
      return 0;
    }
  }
  else if (*(_DWORD *)(v4 + 8368) == 1)
  {
    return *(unsigned __int16 *)(*(_QWORD *)(a1 + 1200) + 2 * a2);
  }
  else
  {
    __dst[0] = 0;
    __dst[1] = 0;
    v11[1] = 0;
    v12 = __dst;
    v10 = v11;
    v11[0] = 0;
    mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, a2, (uint64_t *)&v12);
    v7 = (uint64_t)v12;
    do
    {
      v8 = v2;
      v9 = __OFSUB__(v2--, 1);
    }
    while (v2 < 0 == v9
         && (mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, v2, (uint64_t *)&v10) & 0x80000000) == 0
         && *((unsigned __int16 *)v10 + 5) == *(unsigned __int16 *)(v7 + 10));
    mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, v8, (uint64_t *)&v10);
    return (*(_DWORD *)(*(_QWORD *)(a1 + 1072) + 24) * (*(_DWORD *)(v7 + 4) - *((_DWORD *)v10 + 1)));
  }
}

uint64_t mfs_uselect_Init_Obersee(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;

  v6 = *(_QWORD *)(a2 + 1928);
  *a1 = v6;
  a1[72] = a2;
  a1[73] = a3;
  a1[74] = a4;
  fastallo_Init((_WORD *)a1 + 4, *(_QWORD *)(v6 + 8), 4096);
  *((_DWORD *)a1 + 142) = 0;
  v7 = 75;
  while (1)
  {
    result = mfs_CandidateList_Init_Obersee((uint64_t)&a1[v7], *(_QWORD *)(*a1 + 8));
    if ((_DWORD)result)
      break;
    v7 += 10;
    if (v7 == 105)
    {
      *((_DWORD *)a1 + 210) = -1;
      a1[2251] = 0;
      v14 = (_DWORD *)a1[74];
      if (v14[2084] == 2)
      {
        v15 = heap_Alloc(*(_QWORD *)(*a1 + 8), v14[2085]);
        a1[2251] = v15;
        if (!v15)
          return 2229280778;
        v14 = (_DWORD *)a1[74];
      }
      if ((v14[2086] - 3) > 1)
        return 0;
      result = mfs_BPESymDataCache_Init_Obersee((uint64_t)(a1 + 2253), a3, *a1, v9, v10, v11, v12, v13);
      if (!(_DWORD)result)
        return 0;
      return result;
    }
  }
  return result;
}

uint64_t mfs_uselect_Finalize_Obersee(uint64_t *a1)
{
  uint64_t i;
  uint64_t v3;

  if (a1[72])
  {
    fastallo_Terminate(a1 + 1);
    for (i = 75; i != 105; i += 10)
      mfs_CandidateList_DeInit_Obersee(&a1[i], *(_QWORD **)(*a1 + 8));
    v3 = a1[2251];
    if (v3)
      heap_Free(*(_QWORD **)(*a1 + 8), v3);
    if ((*(_DWORD *)(a1[74] + 8344) - 3) <= 1)
      mfs_BPESymDataCache_DeInit_Obersee(a1 + 2253, *a1);
    mfs_Viterbi_DeInit_Obersee((uint64_t)(a1 + 106));
    a1[72] = 0;
  }
  return 0;
}

uint64_t mfs_Viterbi_Init(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *__b)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  cstdlib_memset(__b, 0, 0x88uLL);
  *((_QWORD *)__b + 16) = 0;
  v8 = *(_QWORD *)(a2 + 1928);
  *((_QWORD *)__b + 2) = a3;
  *((_QWORD *)__b + 3) = a2;
  *(_QWORD *)__b = v8;
  *((_QWORD *)__b + 1) = a1;
  *((_QWORD *)__b + 4) = 0;
  v9 = *(_DWORD *)(a2 + 2064);
  v10 = 2229280778;
  if (v9 != 2)
  {
    v21 = heap_Calloc(*(_QWORD **)(v8 + 8), 1024, 32);
    *((_QWORD *)__b + 6) = v21;
    if (!v21)
      return v10;
    v22 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), 1024, 32);
    *((_QWORD *)__b + 7) = v22;
    if (!v22)
      return v10;
    v23 = 0;
    v24 = *((_QWORD *)__b + 6) + 24;
    do
    {
      *(_QWORD *)(v22 + 24 + v23) = 0;
      *(_QWORD *)(v24 + v23) = 0;
      v23 += 32;
    }
    while (v23 != 0x8000);
    *((_QWORD *)__b + 9) = 0x40000000400;
LABEL_17:
    v10 = 0;
    __b[10] = 0;
    return v10;
  }
  v11 = *(unsigned int *)(a3 + 8240);
  v12 = heap_Calloc(*(_QWORD **)(v8 + 8), v11, 32);
  *((_QWORD *)__b + 6) = v12;
  if (v12)
  {
    v13 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), v11, 32);
    *((_QWORD *)__b + 7) = v13;
    if (v13)
    {
      if ((_DWORD)v11)
      {
        v14 = (_QWORD *)(v13 + 24);
        v15 = (_QWORD *)(*((_QWORD *)__b + 6) + 24);
        v16 = v11;
        do
        {
          *v14 = 0;
          v14 += 4;
          *v15 = 0;
          v15 += 4;
          --v16;
        }
        while (v16);
      }
      __b[18] = v11;
      __b[19] = v11;
      __b[26] = v11;
      v17 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), v11, 4);
      *((_QWORD *)__b + 12) = v17;
      if (v17)
      {
        v18 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), __b[26], 1);
        *((_QWORD *)__b + 11) = v18;
        if (v18)
        {
          v19 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), __b[26], 4);
          *((_QWORD *)__b + 14) = v19;
          if (v19)
          {
            v20 = heap_Calloc(*(_QWORD **)(*(_QWORD *)__b + 8), __b[26], 4);
            *((_QWORD *)__b + 15) = v20;
            if (v20)
              goto LABEL_17;
          }
        }
      }
    }
  }
  return v10;
}

uint64_t mfs_Viterbi_Reset(uint64_t a1, int a2, int a3)
{
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;

  v6 = *(_DWORD *)(a1 + 40);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 24) + 2064) != 2)
  {
    v7 = a3 - a2 + 1;
    if (v7 > v6)
    {
      if (*(_DWORD *)(a1 + 72))
      {
        v18 = 0;
        v19 = *(_QWORD *)(a1 + 48);
        v20 = 24;
        do
        {
          v21 = *(_QWORD *)(v19 + v20);
          if (v21)
          {
            heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v21);
            *(_QWORD *)(*(_QWORD *)(a1 + 48) + v20) = 0;
          }
          v22 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), (a3 - a2 + 1), 4);
          v19 = *(_QWORD *)(a1 + 48);
          *(_QWORD *)(v19 + v20) = v22;
          if (!v22)
            return 2229280778;
          ++v18;
          v20 += 32;
        }
        while (v18 < *(unsigned int *)(a1 + 72));
      }
      if (*(_DWORD *)(a1 + 76))
      {
        v23 = 0;
        v24 = *(_QWORD *)(a1 + 56);
        v25 = 24;
        while (1)
        {
          v26 = *(_QWORD *)(v24 + v25);
          if (v26)
          {
            heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v26);
            *(_QWORD *)(*(_QWORD *)(a1 + 56) + v25) = 0;
          }
          v27 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), (a3 - a2 + 1), 4);
          v24 = *(_QWORD *)(a1 + 56);
          *(_QWORD *)(v24 + v25) = v27;
          if (!v27)
            return 2229280778;
          ++v23;
          v25 += 32;
          if (v23 >= *(unsigned int *)(a1 + 76))
            goto LABEL_29;
        }
      }
    }
    goto LABEL_29;
  }
  v7 = a3 - a2 + 1;
  if (v7 <= v6)
    goto LABEL_29;
  if (*(_DWORD *)(a1 + 72))
  {
    v8 = 0;
    v9 = *(_QWORD *)(a1 + 48);
    v10 = 24;
    do
    {
      v11 = *(_QWORD *)(v9 + v10);
      if (v11)
      {
        heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v11);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + v10) = 0;
      }
      v12 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), (a3 - a2 + 1), 4);
      v9 = *(_QWORD *)(a1 + 48);
      *(_QWORD *)(v9 + v10) = v12;
      if (!v12)
        return 2229280778;
      ++v8;
      v10 += 32;
    }
    while (v8 < *(unsigned int *)(a1 + 72));
  }
  if (!*(_DWORD *)(a1 + 76))
  {
LABEL_29:
    result = 0;
    *(_DWORD *)(a1 + 36) = a3;
    *(_DWORD *)(a1 + 40) = v7;
    *(_DWORD *)(a1 + 32) = a2;
    return result;
  }
  v13 = 0;
  v14 = *(_QWORD *)(a1 + 56);
  v15 = 24;
  while (1)
  {
    v16 = *(_QWORD *)(v14 + v15);
    if (v16)
    {
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v16);
      *(_QWORD *)(*(_QWORD *)(a1 + 56) + v15) = 0;
    }
    v17 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), (a3 - a2 + 1), 4);
    v14 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(v14 + v15) = v17;
    if (!v17)
      return 2229280778;
    ++v13;
    v15 += 32;
    if (v13 >= *(unsigned int *)(a1 + 76))
      goto LABEL_29;
  }
}

uint64_t mfs_Viterbi_DeInit(_QWORD *a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;

  v2 = a1[6];
  if (*(_DWORD *)(a1[3] + 2064) == 2)
  {
    if (v2)
    {
      v3 = *((unsigned int *)a1 + 18);
      if ((_DWORD)v3)
      {
        v4 = 0;
        v5 = 24;
        do
        {
          if (*(_QWORD *)(v2 + v5))
          {
            heap_Free(*(_QWORD **)(*a1 + 8), *(_QWORD *)(v2 + v5));
            v2 = a1[6];
            *(_QWORD *)(v2 + v5) = 0;
            v3 = *((unsigned int *)a1 + 18);
          }
          ++v4;
          v5 += 32;
        }
        while (v4 < v3);
      }
      heap_Free(*(_QWORD **)(*a1 + 8), v2);
      a1[6] = 0;
      v6 = *((unsigned int *)a1 + 19);
      v7 = a1[7];
      if ((_DWORD)v6)
      {
        v8 = 0;
        v9 = 24;
        do
        {
          if (*(_QWORD *)(v7 + v9))
          {
            heap_Free(*(_QWORD **)(*a1 + 8), *(_QWORD *)(v7 + v9));
            v7 = a1[7];
            *(_QWORD *)(v7 + v9) = 0;
            v6 = *((unsigned int *)a1 + 19);
          }
          ++v8;
          v9 += 32;
        }
        while (v8 < v6);
      }
      heap_Free(*(_QWORD **)(*a1 + 8), v7);
      a1[7] = 0;
    }
    *((_DWORD *)a1 + 26) = 0;
    v10 = a1[12];
    if (v10)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v10);
      a1[12] = 0;
    }
    v11 = a1[11];
    if (v11)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v11);
      a1[11] = 0;
    }
    v12 = a1[14];
    if (v12)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v12);
      a1[14] = 0;
    }
    v13 = a1[15];
    if (v13)
    {
      heap_Free(*(_QWORD **)(*a1 + 8), v13);
      v14 = a1 + 15;
LABEL_31:
      *v14 = 0;
    }
  }
  else if (v2)
  {
    if (*((_DWORD *)a1 + 18))
    {
      v15 = 0;
      v16 = 24;
      do
      {
        heap_Free(*(_QWORD **)(*a1 + 8), *(_QWORD *)(a1[6] + v16));
        ++v15;
        v16 += 32;
      }
      while (v15 < *((unsigned int *)a1 + 18));
      v2 = a1[6];
    }
    heap_Free(*(_QWORD **)(*a1 + 8), v2);
    a1[6] = 0;
    if (*((_DWORD *)a1 + 19))
    {
      v17 = 0;
      v18 = 24;
      do
      {
        heap_Free(*(_QWORD **)(*a1 + 8), *(_QWORD *)(a1[7] + v18));
        ++v17;
        v18 += 32;
      }
      while (v17 < *((unsigned int *)a1 + 19));
    }
    v19 = *(_QWORD **)(*a1 + 8);
    v20 = a1[7];
    v14 = a1 + 7;
    heap_Free(v19, v20);
    goto LABEL_31;
  }
  return 0;
}

uint64_t mfs_Viterbi_Decode(uint64_t a1)
{
  float v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  float v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  float v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float *v31;
  float v32;
  uint64_t v34;
  float *v35;
  float v36;
  _DWORD *v37;
  unint64_t v38;
  uint64_t v39;
  float v40;
  uint64_t v41;
  float v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;
  _QWORD *v46;
  _DWORD *v47;
  _DWORD *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  float v53;
  float v54;
  float v55;
  float *v56;
  int v57;
  _QWORD *v58;
  _DWORD *v59;
  _DWORD *v60;
  int v61;
  unsigned int v62;
  unsigned int v63;
  float *v64;
  float v65;
  uint64_t v66;
  int v67;
  uint64_t result;
  uint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  uint64_t v76;

  v2 = *(float *)(*(_QWORD *)(a1 + 16) + 8172);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(v3 + 2152);
  v75 = *(_DWORD *)(v3 + 2164);
  v76 = *(_QWORD *)(v3 + 2136);
  v5 = *(_DWORD *)(v3 + 2148);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 2072);
  MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Default Viterbi Decoder Variant 0 has been selected\n");
  v7 = *(_QWORD *)(a1 + 24);
  v8 = *(_DWORD *)(v7 + 2592);
  if (v8 == 2)
  {
    LODWORD(v11) = *(_DWORD *)(a1 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi regular search and emission, from=%d, to=%d\n");
    *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2612) = mfs_GetTimeStamp();
    v13 = 0.0;
  }
  else if (v8 == 1)
  {
    LODWORD(v11) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 8568) + *(_DWORD *)(v7 + 2596);
    v12 = *(_DWORD *)(a1 + 36);
    v13 = *(float *)(a1 + 84);
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Completing Viterbi decomposition after successful early emission, from=%d, to=%d\n");
  }
  else
  {
    if (v8)
    {
      v18 = 0;
      v20 = 0;
      v15 = 0;
      v13 = 0.0;
      goto LABEL_70;
    }
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Final output state for early emission is %d\n");
    v9 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2596);
    if (!v9 || (v10 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 8568), (v9 + 2 * v10) > *(_DWORD *)(a1 + 36)))
    {
      MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi early emission will not take place - regular emission instead, from=%d, to=%d\n");
      result = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2592) = 2;
      return result;
    }
    LODWORD(v11) = *(_DWORD *)(a1 + 32);
    v12 = v10 + v9;
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi early emission will go ahead, from=%d, to=%d\n");
    *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2612) = mfs_GetTimeStamp();
    v13 = 0.0;
  }
  if (v11 >= v12)
  {
    v18 = 0;
    v20 = 0;
    v15 = 0;
LABEL_70:
    *(_DWORD *)(a1 + 80) = v18;
    *(float *)(a1 + 84) = v13;
    v67 = v15 + v20;
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Pruning: total paths is %d\n");
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Winning Path is %d , with score %f\n");
    if (v67)
      MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Pruning percentage is %.2f\n");
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Number of join costs calculated is %d\n");
    return 0;
  }
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 1.0 - v2;
  v11 = v11;
  v70 = v12;
  v20 = 0;
  v69 = v4;
  while (1)
  {
    v21 = *(unsigned int *)(a1 + 32);
    v22 = *(_DWORD *)(a1 + 76);
    if (v11 != v21)
    {
      *(int8x16_t *)(a1 + 48) = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
      *(int32x2_t *)(a1 + 64) = vrev64_s32(*(int32x2_t *)(a1 + 64));
      v23 = *(_DWORD *)(a1 + 72);
      *(_DWORD *)(a1 + 72) = v22;
      *(_DWORD *)(a1 + 76) = v23;
      v22 = v23;
    }
    v25 = *(_QWORD *)(a1 + 24);
    v24 = *(_DWORD *)(*(_QWORD *)(v25 + 1952) + 32 * v11 + 16);
    LODWORD(v25) = *(_DWORD *)(*(_QWORD *)(v25 + 2016) + 4 * v11);
    if (v24 < v25)
      LODWORD(v25) = v24;
    *(_DWORD *)(a1 + 68) = v25;
    if (v25 <= v22)
      goto LABEL_23;
    v73 = v15;
    v26 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 56), 32 * v25);
    *(_QWORD *)(a1 + 56) = v26;
    if (!v26)
      return 2229280778;
    v71 = v20;
    v27 = *(unsigned int *)(a1 + 76);
    LODWORD(v25) = *(_DWORD *)(a1 + 68);
    if (v27 < v25)
      break;
LABEL_22:
    *(_DWORD *)(a1 + 76) = v25;
    v21 = *(unsigned int *)(a1 + 32);
    v20 = v71;
    v15 = v73;
LABEL_23:
    if (v11 == v21)
    {
      if ((_DWORD)v25)
      {
        v30 = *(_QWORD *)(a1 + 56);
        v25 = v25;
        v31 = (float *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 1952) + 32 * v11) + 4);
        do
        {
          *(float *)v30 = v19 * *v31;
          **(float **)(v30 + 24) = *(v31 - 1);
          v30 += 32;
          v31 += 2;
          --v25;
        }
        while (v25);
      }
    }
    else
    {
      v32 = *(float *)(*(_QWORD *)(a1 + 16) + 8248);
      if (v11 != (_DWORD)v21 + 1 && v32 <= 4.0)
      {
        v34 = *(unsigned int *)(a1 + 64);
        if ((_DWORD)v34)
        {
          v35 = *(float **)(a1 + 48);
          v36 = v13 + v32;
          do
          {
            if (*v35 <= v36)
            {
              ++v15;
            }
            else
            {
              *v35 = 10000000.0;
              ++v20;
            }
            v35 += 8;
            --v34;
          }
          while (v34);
        }
      }
      v74 = v15;
      if ((_DWORD)v25)
      {
        v37 = *(_DWORD **)(a1 + 56);
        v25 = v25;
        do
        {
          *v37 = 1259902592;
          v37 += 8;
          --v25;
        }
        while (v25);
      }
      ssft_qsort(*(_QWORD *)(a1 + 48), *(unsigned int *)(a1 + 64), 32, (uint64_t (*)(unint64_t, unint64_t))mfs_Sort_By_PathScore);
      if (*(_DWORD *)(a1 + 68))
      {
        v72 = v20;
        v38 = 0;
        v13 = 10000000.0;
        do
        {
          v39 = *(_QWORD *)(a1 + 24);
          v40 = *(float *)(*(_QWORD *)(a1 + 16) + 8172);
          v41 = *(_QWORD *)(*(_QWORD *)(v39 + 1952) + 32 * v11) + 8 * v38;
          v42 = *(float *)(v41 + 4);
          v43 = *(_QWORD *)(v39 + 2032);
          v44 = *(_DWORD *)v41;
          v45 = *(_DWORD *)(v39 + 2060);
          v46 = (_QWORD *)(v43 + 8 * (v45 & v44));
          do
          {
            v47 = (_DWORD *)*v46;
            v48 = (_DWORD *)*v46;
            v49 = *v48;
            v46 = v48 + 4;
          }
          while (v49 != v44);
          v50 = *(unsigned int *)(a1 + 64);
          v51 = *(_QWORD *)(a1 + 48);
          if ((int)v50 >= 1)
          {
            v52 = 0;
            v53 = (float)(1.0 - v40) * v42;
            do
            {
              v54 = *(float *)(v51 + 32 * v52);
              if (v54 != 10000000.0)
              {
                v55 = v53 + v54;
                v56 = (float *)(*(_QWORD *)(a1 + 56) + 32 * v38);
                if ((float)(v53 + v54) > *v56)
                  break;
                v57 = *(_DWORD *)(*(_QWORD *)(v51 + 32 * v52 + 24) + 4 * (v11 + ~*(_DWORD *)(a1 + 32)));
                if (v44 - v57 != 1)
                {
                  v58 = (_QWORD *)(v43 + 8 * (v57 & v45));
                  do
                  {
                    v59 = (_DWORD *)*v58;
                    v60 = (_DWORD *)*v58;
                    v61 = *v60;
                    v58 = v60 + 4;
                  }
                  while (v61 != v57);
                  v62 = v59[2];
                  if ((v62 & 2) != 0)
                  {
                    v64 = *(float **)(v6 + 8 * v11);
                    v63 = v47[1];
                    v65 = 0.0;
                  }
                  else
                  {
                    v63 = v47[1];
                    v64 = *(float **)(v6 + 8 * v11);
                    v65 = 0.0;
                    if ((v63 & 2) == 0)
                      v65 = v64[2] * *(float *)(v4 + 4 * (((v62 >> 14) & 0x1FF) + ((v63 >> 14) & 0x1FF) * v75));
                  }
                  v55 = v54
                      + (float)(v53
                              + (float)(v40
                                      * (float)((float)(v65 + *v64)
                                              + (float)(v64[1]
                                                      * *(float *)(v76
                                                                 + 4
                                                                 * (((v62 >> 2) & 0xFFF) + ((v63 >> 2) & 0xFFF) * v5))))));
                }
                ++v14;
                if (v55 < *v56)
                {
                  *v56 = v55;
                  v17 = v52;
                  v16 = v44;
                }
              }
              ++v52;
            }
            while (v52 != v50);
          }
          cstdlib_memcpy(*(void **)(*(_QWORD *)(a1 + 56) + 32 * v38 + 24), *(const void **)(v51 + 32 * v17 + 24), 4 * (v11 - *(_DWORD *)(a1 + 32)));
          v66 = *(_QWORD *)(a1 + 56) + 32 * v38;
          *(_DWORD *)(*(_QWORD *)(v66 + 24) + 4 * (v11 - *(_DWORD *)(a1 + 32))) = v16;
          if (*(float *)v66 < v13)
          {
            v18 = v38;
            v13 = *(float *)v66;
          }
          ++v38;
        }
        while (v38 < *(unsigned int *)(a1 + 68));
        v20 = v72;
      }
      else
      {
        v13 = 10000000.0;
      }
      v15 = v74;
    }
    if (++v11 == v70)
      goto LABEL_70;
  }
  v28 = (32 * v27) | 0x18;
  while (1)
  {
    v29 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), *(unsigned int *)(a1 + 40), 4);
    *(_QWORD *)(*(_QWORD *)(a1 + 56) + v28) = v29;
    if (!v29)
      return 2229280778;
    ++v27;
    v25 = *(unsigned int *)(a1 + 68);
    v28 += 32;
    if (v27 >= v25)
    {
      v4 = v69;
      goto LABEL_22;
    }
  }
}

uint64_t mfs_Sort_By_PathScore(float *a1, float *a2)
{
  unsigned int v2;

  if (*a1 >= *a2)
    v2 = 0;
  else
    v2 = -1;
  if (*a1 > *a2)
    return 1;
  else
    return v2;
}

uint64_t mfs_Viterbi_Decode_MCP_S9_LF0_S8_X2B(uint64_t a1)
{
  uint64_t v2;
  float *v3;
  uint64_t v4;
  float v5;
  float v6;
  uint64_t v7;
  uint64_t v8;
  float v10;
  uint64_t v11;
  int v12;
  float v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int TimeStamp;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  float *v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  float v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  unsigned int v36;
  uint64_t v37;
  char *v38;
  int v39;
  float v40;
  float v41;
  float *v42;
  float v43;
  float v44;
  float v45;
  int v46;
  _DWORD *v47;
  int32x4_t v48;
  uint64_t v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  float *v54;
  _DWORD *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t v61;
  unint64_t v62;
  float v63;
  _DWORD *v64;
  uint64_t v65;
  float v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  float *v70;
  float v71;
  float v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  float v76;
  int v77;
  uint64_t v78;
  _DWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  float v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  float *v87;
  float v88;
  float v89;
  float v90;
  float v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  float *v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  _DWORD *v109;
  float *v110;
  unsigned int *v111;
  unsigned int *v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  unsigned int v122;
  float v123;
  float v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  float v139;
  float v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  float v147;
  float v148;
  float v149;
  float v150;
  uint64_t v151;
  int v152;
  uint64_t v153;
  float v154;
  uint64_t v155;
  uint64_t v156;
  _DWORD *v157;
  unsigned int *v158;
  unsigned int *v159;
  float v160;
  float v161;
  int v162;
  BOOL v163;
  unsigned int v164;
  float v165;
  float v166;
  int v167;
  float v168;
  float v169;
  int v170;
  float v171;
  float v172;
  float v173;
  int v174;
  uint64_t v175;
  float *v176;
  float v177;
  uint64_t v178;
  uint64_t v179;
  float *v180;
  uint64_t v181;
  _DWORD *v182;
  unsigned int *v183;
  unsigned int *v184;
  uint64_t v185;
  float v186;
  float v187;
  BOOL v188;
  int v189;
  unsigned int v190;
  float v191;
  float v192;
  float v193;
  float v194;
  BOOL v195;
  unsigned int v196;
  float v197;
  int v198;
  float v199;
  float v200;
  float v201;
  uint64_t v202;
  void **v203;
  float *v204;
  uint64_t v205;
  int v206;
  float *v207;
  float v208;
  uint64_t v209;
  int v210;
  int v211;
  uint64_t v213;
  uint64_t v214;
  int v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  float v221;
  uint64_t v222;
  int v223;
  float v224;
  uint64_t v225;
  _DWORD *v226;
  float *v227;
  float v228;
  float v229;
  int v230;
  uint64_t v231;
  int v232;
  int v233;
  __int128 v234;
  __int128 v235;
  __int128 v236;
  __int128 v237;
  __int128 v238;
  _DWORD v239[3];
  _DWORD v240[3];
  _DWORD v241[3];
  uint64_t v242;

  v242 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 96);
  v3 = *(float **)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  v5 = v3[2097];
  v6 = v3[2043];
  v7 = *(_QWORD *)a1;
  v8 = *(_QWORD *)(a1 + 8);
  v219 = *(_QWORD *)(v8 + 2136);
  v220 = *(_QWORD *)(v8 + 2152);
  v214 = *(_QWORD *)(v4 + 2072);
  v10 = v3[2096];
  v241[0] = 1065353216;
  *(float *)&v241[1] = v10 + 1.0;
  *(float *)&v241[2] = v10 + 1.0;
  v240[0] = 0;
  *(float *)&v240[1] = v10;
  *(float *)&v240[2] = v10;
  v239[0] = 1065353216;
  *(float *)&v239[1] = v10 + 1.0;
  *(float *)&v239[2] = v10 + 1.0;
  MFS__log_select_Diag(v7, 1, (uint64_t)"S8_X2B Viterbi Decoder Variant 2 has been selected\n");
  v11 = *(_QWORD *)(a1 + 24);
  v12 = *(_DWORD *)(v11 + 2592);
  v13 = 0.0;
  if (v12 == 2)
  {
    v16 = *(_DWORD *)(a1 + 32);
    v17 = *(_DWORD *)(a1 + 36);
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi regular search and emission, from=%d, to=%d\n");
    TimeStamp = mfs_GetTimeStamp();
    v11 = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(v11 + 2612) = TimeStamp;
  }
  else if (v12 == 1)
  {
    v16 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 8568) + *(_DWORD *)(v11 + 2596);
    v17 = *(_DWORD *)(a1 + 36);
    v13 = *(float *)(a1 + 84);
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Completing Viterbi decomposition after successful early emission, from=%d, to=%d\n");
    v11 = *(_QWORD *)(a1 + 24);
  }
  else if (v12)
  {
    v16 = 0;
    v17 = 0;
  }
  else
  {
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Final output state for early emission is %d\n");
    v14 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2596);
    if (!v14
      || (v15 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 8568), (v14 + 2 * v15) > *(_DWORD *)(a1 + 36)))
    {
      MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi early emission will not take place - regular emission instead, from=%d, to=%d\n");
      *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2592) = 2;
      return 0;
    }
    v16 = *(_DWORD *)(a1 + 32);
    v17 = v15 + v14;
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi early emission will go ahead, from=%d, to=%d\n");
    v18 = mfs_GetTimeStamp();
    v11 = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(v11 + 2612) = v18;
  }
  v20 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 12224);
  v21 = *(_QWORD *)(v11 + 1952);
  if (v16 == *(_DWORD *)(a1 + 32))
  {
    v22 = *(_DWORD *)(*(_QWORD *)(v11 + 2016) + 4 * v16);
    if (*(_DWORD *)(v21 + 32 * v16 + 16) >= v22)
      v23 = v22;
    else
      v23 = *(_DWORD *)(v21 + 32 * v16 + 16);
    *(_DWORD *)(a1 + 68) = v23;
    if (v23)
    {
      v24 = 0;
      v25 = *(_QWORD *)(a1 + 56);
      v26 = (float *)(*(_QWORD *)(v21 + 32 * v16) + 4);
      v27 = 32 * v23;
      do
      {
        v28 = v25 + v24;
        *(float *)v28 = (float)(1.0 - v6) * *v26;
        *(_DWORD *)(v28 + 4) = 0;
        *(_DWORD *)(v28 + 8) = 0;
        *(_DWORD *)(v28 + 16) = 0;
        **(float **)(v25 + v24 + 24) = *(v26 - 1);
        v24 += 32;
        v26 += 2;
      }
      while (v27 != v24);
    }
    ++v16;
  }
  if (v16 >= v17)
  {
    v230 = 0;
  }
  else
  {
    v230 = 0;
    v29 = 0;
    v215 = 0;
    v232 = 0;
    v30 = v16;
    v217 = v2 + 8;
    v31 = 0.0;
    v213 = v21;
    do
    {
      v32 = *(_QWORD *)(a1 + 16);
      if (*(_DWORD *)(v32 + 8264))
      {
        v31 = 0.0;
        if (v30 % 3 == 1)
        {
          if (mfs_Ling_IsVowel(v32, *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8), v30 / 3))
          {
            v33 = *(unsigned int *)(a1 + 132);
            if (v33 <= 0xC7)
              *(_DWORD *)(a1 + 132) = v33 + 1;
            v31 = *(float *)(*(_QWORD *)(a1 + 24) + 4 * v33 + 2664);
          }
        }
      }
      v224 = v31;
      v34 = *(_QWORD *)(a1 + 16);
      if (*(_DWORD *)(v34 + 8268))
      {
        v35 = *(uint64_t **)(a1 + 24);
        if (v30 % 3 == 2
          && (v36 = mfs_Ling_IsSilence(v34, v35[1], v30 / 3),
              v35 = *(uint64_t **)(a1 + 24),
              !v36))
        {
          v37 = *(unsigned int *)(a1 + 128);
          v38 = (char *)v35 + 4 * v37;
          v232 = *((_DWORD *)v38 + 867);
          if (v37 <= 0x18F)
            *(_DWORD *)(a1 + 128) = v37 + 1;
          v215 = *((_DWORD *)v38 + 1268);
        }
        else
        {
          v232 = 0;
          v215 = 0;
        }
      }
      else
      {
        v35 = *(uint64_t **)(a1 + 24);
      }
      v39 = v30;
      v40 = *(float *)(v35[261] + 4 * v30);
      v41 = *(float *)(v35[262] + 4 * v30);
      v42 = *(float **)(v214 + 8 * v30);
      v43 = v40 * *v42;
      v44 = v40 * v42[2];
      v45 = v40 * v42[1];
      MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Join cost %d\n");
      MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Normalized ADJ weight %f\n");
      MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Normalized LF0 weight %f\n");
      MFS__log_select_Diag(*(_QWORD *)a1, 20, (uint64_t)"Normalized MCP weight %f\n");
      v46 = *(_DWORD *)(a1 + 32);
      v47 = *(_DWORD **)(a1 + 48);
      v231 = *(_QWORD *)(a1 + 56);
      *(_QWORD *)(a1 + 48) = v231;
      *(_QWORD *)(a1 + 56) = v47;
      v48 = *(int32x4_t *)(a1 + 64);
      *(int32x4_t *)(a1 + 64) = vrev64q_s32(v48);
      v225 = v21 + 32 * v30;
      LODWORD(v49) = *(_DWORD *)(v225 + 16);
      v50 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2016) + 4 * v30);
      if (v49 >= v50)
        v49 = v50;
      else
        v49 = v49;
      *(_DWORD *)(a1 + 68) = v49;
      v216 = v30;
      if (v41 <= 4.0)
      {
        v52 = v30;
        v51 = 0;
        if (v52 != v46 + 1 && v48.i32[1])
        {
          v51 = 0;
          v53 = v48.u32[1];
          v54 = (float *)v231;
          do
          {
            if (*v54 > (float)(v13 + v41))
            {
              *v54 = 10000000.0;
              ++v51;
            }
            v54 += 8;
            --v53;
          }
          while (v53);
        }
      }
      else
      {
        v51 = 0;
      }
      if ((_DWORD)v49)
      {
        v55 = v47;
        do
        {
          *v55 = 1259902592;
          v55 += 8;
          --v49;
        }
        while (v49);
      }
      v226 = v47;
      v222 = (v39 - v46);
      ssft_qsort(v231, v48.u32[1], 32, (uint64_t (*)(unint64_t, unint64_t))mfs_Sort_By_PathScore_faster);
      v56 = (*(_DWORD *)(a1 + 64) - v51);
      *(_DWORD *)(a1 + 64) = v56;
      v31 = v224;
      if ((int)v56 >= 1)
      {
        v57 = 0;
        v58 = (uint64_t *)(v231 + 24);
        do
        {
          v59 = *v58;
          v58 += 4;
          v60 = *(_DWORD *)(v59 + 4 * (v222 - 1));
          v61 = *(_QWORD *)(a1 + 96);
          *(_DWORD *)(v61 + 4 * v57) = v60;
          *(_DWORD *)(*(_QWORD *)(a1 + 112) + 4 * v57) = *(_DWORD *)(v20 + 12 * v60);
          *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4 * v57) = *(unsigned __int16 *)(v20
                                                                             + 12 * *(unsigned int *)(v61 + 4 * v57)
                                                                             + 4);
          *(_BYTE *)(*(_QWORD *)(a1 + 88) + v57) = *(_BYTE *)(v20 + 12 * *(unsigned int *)(v61 + 4 * v57) + 10);
          ++v57;
        }
        while (v56 != v57);
      }
      if (*(_DWORD *)(a1 + 68))
      {
        v62 = 0;
        v221 = 1.0 - v40;
        v63 = (float)v232;
        v218 = v231 + 64;
        v13 = 10000000.0;
        v64 = v226;
        do
        {
          v229 = v13;
          if (v31 == 0.0 && (v65 = *(_QWORD *)(a1 + 16), !*(_DWORD *)(v65 + 8268)))
          {
            v67 = 0;
            v66 = 0.0;
          }
          else
          {
            v233 = 0;
            v237 = 0u;
            v238 = 0u;
            v235 = 0u;
            v236 = 0u;
            v234 = 0u;
            mfs_ParamMap_GetAcousticVector(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 24), *(unsigned int *)(*(_QWORD *)v225 + 8 * v62), (uint64_t)&v234, &v233);
            if (v31 == 0.0)
            {
              v66 = 0.0;
            }
            else if (*(float *)v235 >= 0.0)
            {
              v66 = *(float *)v235;
            }
            else
            {
              v66 = 0.0;
            }
            v64 = v226;
            v65 = *(_QWORD *)(a1 + 16);
            if (*(_DWORD *)(v65 + 8268))
              v67 = v233;
            else
              v67 = 0;
          }
          v68 = *(_QWORD *)(a1 + 112);
          v69 = *(_QWORD *)(a1 + 120);
          v70 = (float *)(*(_QWORD *)v225 + 8 * v62);
          v71 = v70[1];
          v72 = *v70;
          v73 = *(_DWORD *)(a1 + 64);
          v74 = *(unsigned __int8 *)(v20 + 12 * *(unsigned int *)v70 + 10);
          if (v74 <= 2)
          {
            v75 = v74;
            do
            {
              *(float *)&v239[v75] = (float)(v5 * *(float *)&v240[v75]) + (float)(v43 * *(float *)&v241[v75]);
              ++v75;
            }
            while (v75 != 3);
          }
          v76 = v221 * v71;
          v77 = LODWORD(v72) - 1;
          v78 = v73;
          v79 = &v239[v74];
          v80 = v20 + 12 * LODWORD(v72);
          v81 = v219 + ((unint64_t)*(unsigned __int16 *)(v80 + 8) << 11);
          v82 = v220 + ((unint64_t)*(unsigned __int16 *)(v80 + 6) << 10);
          v83 = *(float *)&v64[8 * v62] - v76;
          v223 = v67;
          v227 = (float *)&v64[8 * v62];
          v228 = v72;
          if (v232)
          {
            v84 = *(_QWORD *)(a1 + 88);
            v85 = v73 & 3;
            if ((v73 & 3) != 0)
            {
              v86 = 0;
              v87 = (float *)(v231 + 16);
              v88 = (float)v215;
              while (1)
              {
                v89 = *(v87 - 4);
                if (v89 > v83)
                  break;
                v90 = (float)(*(float *)&v79[*(unsigned __int8 *)(v84 + v86)]
                            + (float)(v44 * *(float *)(v82 + 4 * *(unsigned int *)(v68 + 4 * v86))))
                    + (float)(v45 * *(float *)(v81 + 4 * *(unsigned int *)(v69 + 4 * v86)));
                if (v77 == *(_DWORD *)(v2 + 4 * v86))
                  v90 = 0.0;
                v91 = v89 + v90;
                v92 = v67 - v232 + *(_DWORD *)v87;
                if (v92 < 0)
                  v92 = -v92;
                if ((float)(*(float *)(v65 + 8308) * (float)v215) <= (float)v92)
                  v91 = v91 + (float)((float)(*(float *)(v65 + 8312) * (float)v92) / v63);
                if (v91 < v83)
                {
                  v83 = v91;
                  v29 = v86;
                }
                ++v86;
                v87 += 8;
                if (v85 == v86)
                {
                  v68 += 4 * (v85 - 1) + 4;
                  v69 += 4 * (v85 - 1) + 4;
                  goto LABEL_194;
                }
              }
            }
            else
            {
              v88 = (float)v215;
LABEL_194:
              if (v73 >= 4)
              {
                v151 = 0;
                v152 = v67 - v232;
                v153 = v85;
                v154 = *(float *)(v65 + 8308) * v88;
                v155 = v218 + 32 * v85;
                v156 = v84 + v85 + 1;
                v157 = (_DWORD *)(v217 + 4 * v85);
                do
                {
                  v158 = (unsigned int *)(v69 + 4 * v151);
                  v159 = (unsigned int *)(v68 + 4 * v151);
                  v160 = (float)(*(float *)&v79[*(unsigned __int8 *)(v156 + v151 - 1)]
                               + (float)(v44 * *(float *)(v82 + 4 * *v159)))
                       + (float)(v45 * *(float *)(v81 + 4 * *v158));
                  if (v77 == *(v157 - 2))
                    v160 = 0.0;
                  v161 = *(float *)(v155 - 64) + v160;
                  v162 = v152 + *(_DWORD *)(v155 - 48);
                  if (v162 < 0)
                    v162 = -v162;
                  if (v154 <= (float)v162)
                    v161 = v161 + (float)((float)(*(float *)(v65 + 8312) * (float)v162) / v63);
                  v163 = v161 < v83;
                  if (v161 < v83)
                    v83 = v161;
                  v164 = v153 + v151;
                  if (!v163)
                    v164 = v29;
                  v165 = (float)(*(float *)&v79[*(unsigned __int8 *)(v156 + v151)]
                               + (float)(v44 * *(float *)(v82 + 4 * v159[1])))
                       + (float)(v45 * *(float *)(v81 + 4 * v158[1]));
                  if (v77 == *(v157 - 1))
                    v165 = 0.0;
                  v166 = *(float *)(v155 - 32) + v165;
                  v167 = v152 + *(_DWORD *)(v155 - 16);
                  if (v167 < 0)
                    v167 = -v167;
                  if (v154 <= (float)v167)
                    v166 = v166 + (float)((float)(*(float *)(v65 + 8312) * (float)v167) / v63);
                  if (v166 < v83)
                  {
                    v83 = v166;
                    v164 = v153 + v151 + 1;
                  }
                  v168 = (float)(*(float *)&v79[*(unsigned __int8 *)(v156 + v151 + 1)]
                               + (float)(v44 * *(float *)(v82 + 4 * v159[2])))
                       + (float)(v45 * *(float *)(v81 + 4 * v158[2]));
                  if (v77 == *v157)
                    v168 = 0.0;
                  v169 = *(float *)v155 + v168;
                  v170 = v152 + *(_DWORD *)(v155 + 16);
                  if (v170 < 0)
                    v170 = -v170;
                  if (v154 <= (float)v170)
                    v169 = v169 + (float)((float)(*(float *)(v65 + 8312) * (float)v170) / v63);
                  if (v169 >= v83)
                  {
                    v29 = v164;
                  }
                  else
                  {
                    v83 = v169;
                    v29 = v153 + v151 + 2;
                  }
                  v171 = *(float *)(v155 + 32);
                  if (v171 > v83)
                    break;
                  v172 = (float)(*(float *)&v79[*(unsigned __int8 *)(v156 + v151 + 2)]
                               + (float)(v44 * *(float *)(v82 + 4 * v159[3])))
                       + (float)(v45 * *(float *)(v81 + 4 * v158[3]));
                  if (v77 == v157[1])
                    v172 = 0.0;
                  v173 = v171 + v172;
                  v174 = v152 + *(_DWORD *)(v155 + 48);
                  if (v174 < 0)
                    v174 = -v174;
                  if (v154 <= (float)v174)
                    v173 = v173 + (float)((float)(*(float *)(v65 + 8312) * (float)v174) / v63);
                  if (v173 < v83)
                  {
                    v83 = v173;
                    v29 = v153 + v151 + 3;
                  }
                  v151 += 4;
                  v155 += 128;
                  v157 += 4;
                }
                while (v153 + v151 < v78);
              }
            }
          }
          else
          {
            v93 = v73 & 3;
            v94 = *(_QWORD *)(a1 + 88);
            if (v66 == 0.0)
            {
              if ((v73 & 3) != 0)
              {
                v175 = 0;
                v176 = (float *)v231;
                while (*v176 <= v83)
                {
                  v177 = (float)(*(float *)&v79[*(unsigned __int8 *)(v94 + v175)]
                               + (float)(v44 * *(float *)(v82 + 4 * *(unsigned int *)(v68 + 4 * v175))))
                       + (float)(v45 * *(float *)(v81 + 4 * *(unsigned int *)(v69 + 4 * v175)));
                  if (v77 == *(_DWORD *)(v2 + 4 * v175))
                    v177 = 0.0;
                  if ((float)(*v176 + v177) < v83)
                  {
                    v83 = *v176 + v177;
                    v29 = v175;
                  }
                  ++v175;
                  v176 += 8;
                  if ((v73 & 3) == v175)
                  {
                    v68 += 4 * (v93 - 1) + 4;
                    v69 += 4 * (v93 - 1) + 4;
                    goto LABEL_244;
                  }
                }
              }
              else
              {
LABEL_244:
                if (v73 >= 4)
                {
                  v178 = 0;
                  v179 = v73 & 3;
                  v180 = (float *)(v218 + 32 * v93);
                  v181 = v94 + v93 + 1;
                  v182 = (_DWORD *)(v217 + 4 * v93);
                  do
                  {
                    v183 = (unsigned int *)(v69 + 4 * v178);
                    v184 = (unsigned int *)(v68 + 4 * v178);
                    v185 = v181 + v178;
                    v186 = (float)(*(float *)&v79[*(unsigned __int8 *)(v181 + v178 - 1)]
                                 + (float)(v44 * *(float *)(v82 + 4 * *v184)))
                         + (float)(v45 * *(float *)(v81 + 4 * *v183));
                    if (v77 == *(v182 - 2))
                      v186 = 0.0;
                    v187 = *(v180 - 16) + v186;
                    v188 = v187 < v83;
                    if (v187 < v83)
                      v83 = v187;
                    v189 = v179 + v178;
                    if (v188)
                      v190 = v179 + v178;
                    else
                      v190 = v29;
                    v191 = (float)(*(float *)&v79[*(unsigned __int8 *)(v181 + v178)]
                                 + (float)(v44 * *(float *)(v82 + 4 * v184[1])))
                         + (float)(v45 * *(float *)(v81 + 4 * v183[1]));
                    if (v77 == *(v182 - 1))
                      v191 = 0.0;
                    v192 = *(v180 - 8) + v191;
                    if (v192 < v83)
                    {
                      v83 = v192;
                      v190 = v189 + 1;
                    }
                    v193 = (float)(*(float *)&v79[*(unsigned __int8 *)(v185 + 1)]
                                 + (float)(v44 * *(float *)(v82 + 4 * v184[2])))
                         + (float)(v45 * *(float *)(v81 + 4 * v183[2]));
                    if (v77 == *v182)
                      v193 = 0.0;
                    v194 = *v180 + v193;
                    v195 = v194 < v83;
                    if (v194 < v83)
                      v83 = v194;
                    v196 = v189 + 2;
                    if (v195)
                      v29 = v196;
                    else
                      v29 = v190;
                    v197 = v180[8];
                    if (v197 > v83)
                      break;
                    v198 = v182[1];
                    v182 += 4;
                    v199 = (float)(*(float *)&v79[*(unsigned __int8 *)(v185 + 2)]
                                 + (float)(v44 * *(float *)(v82 + 4 * v184[3])))
                         + (float)(v45 * *(float *)(v81 + 4 * v183[3]));
                    if (v77 == v198)
                      v199 = 0.0;
                    v200 = v197 + v199;
                    if (v200 < v83)
                    {
                      v83 = v200;
                      v29 = v179 + v178 + 3;
                    }
                    v178 += 4;
                    v180 += 32;
                  }
                  while (v179 + v178 < v78);
                }
              }
            }
            else if ((v73 & 3) != 0)
            {
              v95 = 0;
              v96 = (float *)(v231 + 8);
              while (1)
              {
                v97 = *(v96 - 2);
                if (v97 > v83)
                  break;
                v98 = (float)(*(float *)&v79[*(unsigned __int8 *)(v94 + v95)]
                            + (float)(v44 * *(float *)(v82 + 4 * *(unsigned int *)(v68 + 4 * v95))))
                    + (float)(v45 * *(float *)(v81 + 4 * *(unsigned int *)(v69 + 4 * v95)));
                if (v77 == *(_DWORD *)(v2 + 4 * v95))
                  v98 = 0.0;
                v99 = v97 + v98;
                if (*v96 != 0.0)
                {
                  v100 = *v96 - v66;
                  v101 = -v100;
                  if (v100 >= 0.0)
                    v101 = *v96 - v66;
                  v102 = v100 - (float)(*(v96 - 1) - v31);
                  if (v102 < 0.0)
                    v102 = -v102;
                  v103 = v96[1];
                  v104 = v103 - v66;
                  if ((float)(v103 - v66) < 0.0)
                    v104 = -(float)(v103 - v66);
                  if (v103 == 0.0)
                    v105 = 0.0;
                  else
                    v105 = v104;
                  if (v101 > *(float *)(v65 + 8284))
                    v99 = v99 + (float)(*(float *)(v65 + 8288) * v101);
                  if (v105 > *(float *)(v65 + 8292))
                    v99 = v99 + (float)(*(float *)(v65 + 8296) * v105);
                  if (v102 > *(float *)(v65 + 8300))
                    v99 = v99 + (float)(*(float *)(v65 + 8304) * v102);
                }
                if (v99 < v83)
                {
                  v83 = v99;
                  v29 = v95;
                }
                ++v95;
                v96 += 8;
                if (v93 == v95)
                {
                  v68 += 4 * (v93 - 1) + 4;
                  v69 += 4 * (v93 - 1) + 4;
                  goto LABEL_106;
                }
              }
            }
            else
            {
LABEL_106:
              if (v73 >= 4)
              {
                v106 = 0;
                v107 = v93;
                v108 = v94 + v93 + 1;
                v109 = (_DWORD *)(v217 + 4 * v93);
                v110 = (float *)(v218 + 32 * v107);
                do
                {
                  v111 = (unsigned int *)(v69 + 4 * v106);
                  v112 = (unsigned int *)(v68 + 4 * v106);
                  v113 = (float)(*(float *)&v79[*(unsigned __int8 *)(v108 + v106 - 1)]
                               + (float)(v44 * *(float *)(v82 + 4 * *v112)))
                       + (float)(v45 * *(float *)(v81 + 4 * *v111));
                  if (v77 == *(v109 - 2))
                    v113 = 0.0;
                  v114 = *(v110 - 16) + v113;
                  v115 = *(v110 - 14);
                  if (v115 != 0.0)
                  {
                    v116 = v115 - v66;
                    v117 = -v116;
                    if (v116 >= 0.0)
                      v117 = v116;
                    v118 = v116 - (float)(*(v110 - 15) - v31);
                    if (v118 < 0.0)
                      v118 = -v118;
                    v119 = *(v110 - 13);
                    v120 = v119 - v66;
                    if ((float)(v119 - v66) < 0.0)
                      v120 = -(float)(v119 - v66);
                    if (v119 == 0.0)
                      v121 = 0.0;
                    else
                      v121 = v120;
                    if (v117 > *(float *)(v65 + 8284))
                      v114 = v114 + (float)(*(float *)(v65 + 8288) * v117);
                    if (v121 > *(float *)(v65 + 8292))
                      v114 = v114 + (float)(*(float *)(v65 + 8296) * v121);
                    if (v118 > *(float *)(v65 + 8300))
                      v114 = v114 + (float)(*(float *)(v65 + 8304) * v118);
                  }
                  v122 = v107 + v106;
                  if (v114 < v83)
                    v83 = v114;
                  else
                    v122 = v29;
                  v123 = (float)(*(float *)&v79[*(unsigned __int8 *)(v108 + v106)]
                               + (float)(v44 * *(float *)(v82 + 4 * v112[1])))
                       + (float)(v45 * *(float *)(v81 + 4 * v111[1]));
                  if (v77 == *(v109 - 1))
                    v123 = 0.0;
                  v124 = *(v110 - 8) + v123;
                  v125 = *(v110 - 6);
                  if (v125 != 0.0)
                  {
                    v126 = v125 - v66;
                    v127 = -v126;
                    if (v126 >= 0.0)
                      v127 = v126;
                    v128 = v126 - (float)(*(v110 - 7) - v31);
                    if (v128 < 0.0)
                      v128 = -v128;
                    v129 = *(v110 - 5);
                    v130 = v129 - v66;
                    if ((float)(v129 - v66) < 0.0)
                      v130 = -(float)(v129 - v66);
                    if (v129 == 0.0)
                      v131 = 0.0;
                    else
                      v131 = v130;
                    if (v127 > *(float *)(v65 + 8284))
                      v124 = v124 + (float)(*(float *)(v65 + 8288) * v127);
                    if (v131 > *(float *)(v65 + 8292))
                      v124 = v124 + (float)(*(float *)(v65 + 8296) * v131);
                    if (v128 > *(float *)(v65 + 8300))
                      v124 = v124 + (float)(*(float *)(v65 + 8304) * v128);
                  }
                  if (v124 < v83)
                  {
                    v83 = v124;
                    v122 = v107 + v106 + 1;
                  }
                  v132 = (float)(*(float *)&v79[*(unsigned __int8 *)(v108 + v106 + 1)]
                               + (float)(v44 * *(float *)(v82 + 4 * v112[2])))
                       + (float)(v45 * *(float *)(v81 + 4 * v111[2]));
                  if (v77 == *v109)
                    v132 = 0.0;
                  v133 = *v110 + v132;
                  v134 = v110[2];
                  if (v134 != 0.0)
                  {
                    v135 = v134 - v66;
                    v136 = -v135;
                    if (v135 >= 0.0)
                      v136 = v135;
                    v137 = v135 - (float)(v110[1] - v31);
                    if (v137 < 0.0)
                      v137 = -v137;
                    v138 = v110[3];
                    v139 = v138 - v66;
                    if ((float)(v138 - v66) < 0.0)
                      v139 = -(float)(v138 - v66);
                    if (v138 == 0.0)
                      v140 = 0.0;
                    else
                      v140 = v139;
                    if (v136 > *(float *)(v65 + 8284))
                      v133 = v133 + (float)(*(float *)(v65 + 8288) * v136);
                    if (v140 > *(float *)(v65 + 8292))
                      v133 = v133 + (float)(*(float *)(v65 + 8296) * v140);
                    if (v137 > *(float *)(v65 + 8300))
                      v133 = v133 + (float)(*(float *)(v65 + 8304) * v137);
                  }
                  if (v133 >= v83)
                  {
                    v29 = v122;
                  }
                  else
                  {
                    v83 = v133;
                    v29 = v107 + v106 + 2;
                  }
                  v141 = v110[8];
                  if (v141 > v83)
                    break;
                  v142 = (float)(*(float *)&v79[*(unsigned __int8 *)(v108 + v106 + 2)]
                               + (float)(v44 * *(float *)(v82 + 4 * v112[3])))
                       + (float)(v45 * *(float *)(v81 + 4 * v111[3]));
                  if (v77 == v109[1])
                    v142 = 0.0;
                  v143 = v141 + v142;
                  v144 = v110[10];
                  if (v144 != 0.0)
                  {
                    v145 = v144 - v66;
                    v146 = -v145;
                    if (v145 >= 0.0)
                      v146 = v145;
                    v147 = v145 - (float)(v110[9] - v31);
                    if (v147 < 0.0)
                      v147 = -v147;
                    v148 = v110[11];
                    v149 = v148 - v66;
                    if ((float)(v148 - v66) < 0.0)
                      v149 = -(float)(v148 - v66);
                    if (v148 == 0.0)
                      v150 = 0.0;
                    else
                      v150 = v149;
                    if (v146 > *(float *)(v65 + 8284))
                      v143 = v143 + (float)(*(float *)(v65 + 8288) * v146);
                    if (v150 > *(float *)(v65 + 8292))
                      v143 = v143 + (float)(*(float *)(v65 + 8296) * v150);
                    if (v147 > *(float *)(v65 + 8300))
                      v143 = v143 + (float)(*(float *)(v65 + 8304) * v147);
                  }
                  if (v143 < v83)
                  {
                    v83 = v143;
                    v29 = v107 + v106 + 3;
                  }
                  v106 += 4;
                  v109 += 4;
                  v110 += 32;
                }
                while (v107 + v106 < v78);
              }
            }
          }
          v201 = v76 + v83;
          v202 = v20;
          v203 = (void **)&v64[8 * v62];
          cstdlib_memcpy(v203[3], *(const void **)(v231 + 32 * v29 + 24), 4 * v222);
          v64 = v226;
          *v227 = v201;
          v204 = (float *)v203[3];
          v20 = v202;
          v204[v222] = v228;
          v205 = *(_QWORD *)(a1 + 16);
          if (*(_DWORD *)(v205 + 8264))
          {
            if (v66 == 0.0)
            {
              v209 = v231 + 32 * v29;
              *(_QWORD *)&v226[8 * v62 + 2] = *(_QWORD *)(v209 + 8);
              v208 = *(float *)(v209 + 4);
            }
            else
            {
              v206 = *(_DWORD *)(v231 + 32 * v29 + 8);
              v207 = (float *)&v226[8 * v62];
              v207[2] = v66;
              *((_DWORD *)v207 + 3) = v206;
              v208 = v224;
            }
            *(float *)&v226[8 * v62 + 1] = v208;
          }
          v13 = v229;
          if (*(_DWORD *)(v205 + 8268))
          {
            if (v232)
              v210 = 0;
            else
              v210 = *(_DWORD *)(v231 + 32 * v29 + 16) + v223;
            v226[8 * v62 + 4] = v210;
          }
          if (v201 < v229)
            v13 = v201;
          v211 = v230;
          if (v201 < v229)
            v211 = v62;
          v230 = v211;
          ++v62;
          v31 = v224;
        }
        while (v62 < *(unsigned int *)(a1 + 68));
      }
      else
      {
        v13 = 10000000.0;
      }
      v30 = v216 + 1;
      v21 = v213;
    }
    while (v216 + 1 != v17);
  }
  *(_DWORD *)(a1 + 80) = v230;
  *(float *)(a1 + 84) = v13;
  return 0;
}

uint64_t mfs_Sort_By_PathScore_faster(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2;

  if (*a1 >= *a2)
    v2 = 0;
  else
    v2 = -1;
  if (*a1 > *a2)
    return 1;
  else
    return v2;
}

uint64_t mfs_Viterbi_Decode_MCP_S9_LF0_S8(uint64_t a1)
{
  uint64_t v2;
  float v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  float v13;
  unsigned int v14;
  int v15;
  float v16;
  uint64_t v17;
  float *v18;
  float v19;
  float v20;
  float v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  float *v34;
  float v35;
  uint64_t v36;
  int v37;
  float v38;
  float *v39;
  _DWORD *v40;
  int v41;
  int v42;
  unint64_t v43;
  float v44;
  float v45;
  uint64_t v46;
  uint64_t v47;
  float *v48;
  float v49;
  uint64_t v50;
  uint64_t v51;
  float v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  float v56;
  float v57;
  int v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  float v63;
  uint64_t v64;
  uint64_t v65;
  float v66;
  uint64_t v67;
  uint64_t result;
  float v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  float v75;
  uint64_t __n;
  uint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  uint64_t v81;
  _BYTE *v82;
  _QWORD *v83;
  _QWORD v84[3];

  v2 = *(_QWORD *)(a1 + 24);
  v3 = *(float *)(*(_QWORD *)(a1 + 16) + 8172);
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(a1 + 8);
  v73 = *(_QWORD *)(v5 + 2136);
  v74 = *(_QWORD *)(v5 + 2152);
  v71 = *(_QWORD *)(v2 + 2072);
  v84[0] = 0;
  v84[1] = 0;
  v83 = v84;
  MFS__log_select_Diag(v4, 1, (uint64_t)"S8 Viterbi Decoder Variant 1 has been selected\n");
  v7 = *(_QWORD *)(a1 + 24);
  v8 = *(_DWORD *)(v7 + 2592);
  if (v8 == 2)
  {
    v11 = *(_DWORD *)(a1 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi regular search and emission, from=%d, to=%d\n");
    *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2612) = mfs_GetTimeStamp();
    v13 = 0.0;
  }
  else if (v8 == 1)
  {
    v11 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 8568) + *(_DWORD *)(v7 + 2596);
    v12 = *(_DWORD *)(a1 + 36);
    v13 = *(float *)(a1 + 84);
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Completing Viterbi decomposition after successful early emission, from=%d, to=%d\n");
  }
  else
  {
    if (v8)
    {
      v15 = 0;
      v13 = 0.0;
      goto LABEL_63;
    }
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Final output state for early emission is %d\n");
    v9 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2596);
    if (!v9 || (v10 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 8568), (v9 + 2 * v10) > *(_DWORD *)(a1 + 36)))
    {
      MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi early emission will not take place - regular emission instead, from=%d, to=%d\n");
      result = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2592) = 2;
      return result;
    }
    v11 = *(_DWORD *)(a1 + 32);
    v12 = v10 + v9;
    MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"Viterbi early emission will go ahead, from=%d, to=%d\n");
    *(_DWORD *)(*(_QWORD *)(a1 + 24) + 2612) = mfs_GetTimeStamp();
    v13 = 0.0;
  }
  if (v11 >= v12)
  {
    v15 = 0;
LABEL_63:
    result = 0;
    *(_DWORD *)(a1 + 80) = v15;
    *(float *)(a1 + 84) = v13;
    return result;
  }
  v14 = 0;
  v15 = 0;
  v69 = v3;
  v16 = 1.0 - v3;
  v17 = v11;
  v70 = v12;
  while (1)
  {
    v18 = *(float **)(v71 + 8 * v17);
    v20 = v18[1];
    v19 = v18[2];
    v21 = *v18;
    v22 = *(unsigned int *)(a1 + 32);
    v23 = *(_DWORD *)(a1 + 76);
    if (v17 != v22)
    {
      *(int8x16_t *)(a1 + 48) = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
      *(int32x2_t *)(a1 + 64) = vrev64_s32(*(int32x2_t *)(a1 + 64));
      v24 = *(_DWORD *)(a1 + 72);
      *(_DWORD *)(a1 + 72) = v23;
      *(_DWORD *)(a1 + 76) = v24;
      v23 = v24;
    }
    v26 = *(_QWORD *)(a1 + 24);
    v25 = *(_DWORD *)(*(_QWORD *)(v26 + 1952) + 32 * v17 + 16);
    LODWORD(v26) = *(_DWORD *)(*(_QWORD *)(v26 + 2016) + 4 * v17);
    if (v25 < v26)
      LODWORD(v26) = v25;
    *(_DWORD *)(a1 + 68) = v26;
    if (v26 > v23)
      break;
    v31 = v22;
    v32 = v22;
LABEL_23:
    v78 = 32 * v17;
    v72 = v17;
    if (v17 != v31)
    {
      v35 = *(float *)(*(_QWORD *)(a1 + 16) + 8248);
      if (v35 > 4.0 || v17 == v32 + 1 || (v36 = *(unsigned int *)(a1 + 64), !(_DWORD)v36))
      {
        v37 = 0;
        if (!(_DWORD)v26)
          goto LABEL_40;
      }
      else
      {
        v37 = 0;
        v38 = v13 + v35;
        v39 = *(float **)(a1 + 48);
        do
        {
          if (*v39 > v38)
          {
            *v39 = 10000000.0;
            ++v37;
          }
          v39 += 8;
          --v36;
        }
        while (v36);
        if (!(_DWORD)v26)
          goto LABEL_40;
      }
      v40 = *(_DWORD **)(a1 + 56);
      v26 = v26;
      do
      {
        *v40 = 1259902592;
        v40 += 8;
        --v26;
      }
      while (v26);
LABEL_40:
      ssft_qsort(*(_QWORD *)(a1 + 48), *(unsigned int *)(a1 + 64), 32, (uint64_t (*)(unint64_t, unint64_t))mfs_Sort_By_PathScore);
      v41 = *(_DWORD *)(a1 + 68);
      *(_DWORD *)(a1 + 64) -= v37;
      if (v41)
      {
        v42 = v17;
        v43 = 0;
        v13 = 10000000.0;
        v75 = v69 * v19;
        v44 = v69 * v20;
        v45 = v69 * v21;
        v46 = (v42 - v22);
        v47 = (v46 - 1);
        v77 = v46;
        __n = 4 * v46;
        do
        {
          v48 = (float *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 1952) + v78) + 8 * v43);
          v49 = v48[1];
          v50 = *(unsigned int *)v48;
          mfs_getUnitDataFromMfsData(*(unsigned __int8 **)(a1 + 8), *(_DWORD *)v48, (uint64_t *)&v83);
          v51 = *(_QWORD *)(a1 + 56);
          v52 = *(float *)(v51 + 32 * v43);
          v53 = *(_DWORD *)(a1 + 64);
          if (v53 >= 1)
          {
            v80 = v15;
            v54 = 0;
            v55 = 0;
            v56 = v16;
            v57 = v16 * v49;
            v58 = v50 - 1;
            v59 = (char *)&unk_214FC0900 + 4 * *((unsigned __int8 *)v83 + 15);
            v79 = v50;
            v60 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2048) + 8 * v50);
            v61 = v73 + ((unint64_t)*(unsigned __int16 *)(v60 + 4) << 11);
            v81 = v74 + ((unint64_t)*(unsigned __int8 *)(v60 + 2) << 10);
            v82 = (_BYTE *)v60;
            do
            {
              v62 = *(_QWORD *)(a1 + 48);
              v63 = v57 + *(float *)(v62 + v54);
              if (v63 > v52)
                break;
              v64 = *(unsigned int *)(*(_QWORD *)(v62 + v54 + 24) + 4 * v47);
              if (v58 != (_DWORD)v64)
              {
                v65 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 2048) + 8 * v64);
                v66 = 0.0;
                if (!*(_BYTE *)(v65 + 1) && !*v82)
                  v66 = v75 * *(float *)(v81 + 4 * *(unsigned __int8 *)(v65 + 3));
                mfs_getUnitDataFromMfsData(*(unsigned __int8 **)(a1 + 8), v64, (uint64_t *)&v83);
                v63 = v63
                    + (float)((float)(v66 + (float)(v45 * *(float *)&v59[4 * *((unsigned __int8 *)v83 + 15)]))
                            + (float)(v44 * *(float *)(v61 + 4 * *(unsigned __int16 *)(v65 + 6))));
                v53 = *(_DWORD *)(a1 + 64);
              }
              if (v63 < v52)
              {
                v14 = v55;
                v52 = v63;
              }
              ++v55;
              v54 += 32;
            }
            while (v55 < v53);
            v51 = *(_QWORD *)(a1 + 56);
            v15 = v80;
            v16 = v56;
            LODWORD(v50) = v79;
          }
          cstdlib_memcpy(*(void **)(v51 + 32 * v43 + 24), *(const void **)(*(_QWORD *)(a1 + 48) + 32 * v14 + 24), __n);
          v67 = *(_QWORD *)(a1 + 56) + 32 * v43;
          *(float *)v67 = v52;
          *(_DWORD *)(*(_QWORD *)(v67 + 24) + 4 * v77) = v50;
          if (v52 < v13)
          {
            v15 = v43;
            v13 = v52;
          }
          ++v43;
        }
        while (v43 < *(unsigned int *)(a1 + 68));
      }
      else
      {
        v13 = 10000000.0;
      }
      goto LABEL_59;
    }
    if ((_DWORD)v26)
    {
      v33 = *(_QWORD *)(a1 + 56);
      v26 = v26;
      v34 = (float *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 1952) + 32 * v17) + 4);
      do
      {
        *(float *)v33 = v16 * *v34;
        **(float **)(v33 + 24) = *(v34 - 1);
        v33 += 32;
        v34 += 2;
        --v26;
      }
      while (v26);
    }
LABEL_59:
    v17 = v72 + 1;
    if (v72 + 1 == v70)
      goto LABEL_63;
  }
  v27 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 56), 32 * v26);
  *(_QWORD *)(a1 + 56) = v27;
  if (!v27)
    return 2229280778;
  v28 = *(unsigned int *)(a1 + 76);
  LODWORD(v26) = *(_DWORD *)(a1 + 68);
  if (v28 >= v26)
  {
LABEL_21:
    *(_DWORD *)(a1 + 76) = v26;
    v31 = *(unsigned int *)(a1 + 32);
    v32 = *(_DWORD *)(a1 + 32);
    goto LABEL_23;
  }
  v29 = (32 * v28) | 0x18;
  while (1)
  {
    v30 = heap_Calloc(*(_QWORD **)(*(_QWORD *)a1 + 8), *(unsigned int *)(a1 + 40), 4);
    *(_QWORD *)(*(_QWORD *)(a1 + 56) + v29) = v30;
    if (!v30)
      return 2229280778;
    ++v28;
    v26 = *(unsigned int *)(a1 + 68);
    v29 += 32;
    if (v28 >= v26)
      goto LABEL_21;
  }
}

uint64_t mfs_Viterbi_ResultScore(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *(_QWORD *)(a1 + 24);
  if (*(_DWORD *)(v3 + 2592))
    v4 = *(_DWORD *)(a1 + 36);
  else
    v4 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 8568) + *(_DWORD *)(v3 + 2596);
  v5 = *(unsigned int *)(a1 + 32);
  if (v5 < v4)
  {
    v6 = *(_QWORD *)(a1 + 56);
    v7 = *(_QWORD *)(a2 + 8);
    v8 = *(_QWORD *)(a3 + 8);
    do
    {
      *(_DWORD *)(v7 + 4 * v5) = *(_DWORD *)(*(_QWORD *)(v6 + 32 * *(unsigned int *)(a1 + 80) + 24)
                                           + 4 * (v5 - *(_DWORD *)(a1 + 32)));
      *(_DWORD *)(v8 + 4 * v5++) = 0;
    }
    while (v4 != v5);
  }
  return 0;
}

uint64_t mfs_Ling_GetPhonCtxt(uint64_t result, int a2, _BYTE *a3)
{
  char v3;
  uint64_t v4;
  char v5;

  if (a2 < 1)
    v3 = 0;
  else
    v3 = *(_BYTE *)(*(_QWORD *)(result + 32) + (a2 - 1));
  *a3 = v3;
  v4 = a2 + 1;
  if ((int)v4 >= *(__int16 *)(result + 10))
    v5 = 0;
  else
    v5 = *(_BYTE *)(*(_QWORD *)(result + 32) + v4);
  a3[2] = v5;
  a3[1] = *(_BYTE *)(*(_QWORD *)(result + 32) + a2);
  return result;
}

uint64_t mfs_Ling_LogPhonCtxt(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t i;
  uint64_t j;
  uint64_t v12;
  uint64_t v13;
  int v14;

  result = MFS__log_select_GetLogLevel(*(_QWORD *)(a1 + 32));
  if (result >= 3)
  {
    v9 = *(_QWORD *)(a3 + 32);
    if (a4 >= 1)
    {
      for (i = 0; i != 256; ++i)
      {
        if (*(unsigned __int8 *)(a2 + 7356 + i) == *(unsigned __int8 *)(v9 + (a4 - 1)))
          break;
      }
    }
    for (j = 0; j != 256; ++j)
    {
      if (*(unsigned __int8 *)(a2 + 7356 + j) == *(unsigned __int8 *)(v9 + a4))
        break;
    }
    v12 = a4 + 1;
    if ((int)v12 < *(__int16 *)(a3 + 10))
    {
      v13 = 0;
      v14 = *(unsigned __int8 *)(v9 + v12);
      do
      {
        if (*(unsigned __int8 *)(a2 + 7356 + v13) == v14)
          break;
        ++v13;
      }
      while (v13 != 256);
    }
    return MFS__log_select_Diag(a1, 3, (uint64_t)"[%c-%c+%c]");
  }
  return result;
}

uint64_t mfs_Ling_HmmPhonemeToLhTts(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = 0;
  while (*(unsigned __int8 *)(a1 + 7356 + v2) != a2)
  {
    if (++v2 == 256)
    {
      LOBYTE(v2) = 0;
      return v2;
    }
  }
  return v2;
}

uint64_t mfs_Ling_CenterPhoneme(uint64_t a1, int a2)
{
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) + a2);
}

uint64_t mfs_Ling_SylPos(uint64_t a1, int a2)
{
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 152) + a2);
}

uint64_t mfs_Ling_WrdPosShpInPhrs(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 1496);
  if (v2)
    return *(unsigned __int8 *)(v2 + a2);
  else
    return 6;
}

uint64_t mfs_Ling_WrdPosInPhrs(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
    return *(unsigned __int8 *)(v2 + a2);
  else
    return 0;
}

uint64_t mfs_Ling_WrdProminence(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 536);
  if (v2)
    return *(unsigned __int8 *)(v2 + a2);
  else
    return 5;
}

uint64_t mfs_Ling_WrdShpProminence(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 1424);
  if (v2)
    return *(unsigned __int8 *)(v2 + a2);
  else
    return 5;
}

BOOL mfs_Ling_IsSyllableBegin(uint64_t a1, int a2)
{
  return *(_BYTE *)(*(_QWORD *)(a1 + 112) + a2) != 0;
}

BOOL mfs_Ling_IsWordBegin(uint64_t a1, int a2)
{
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 112) + a2) > 1u;
}

const char *mfs_Ling_IsVowel(uint64_t a1, uint64_t a2, int a3)
{
  const char *result;

  result = *(const char **)(*(_QWORD *)(a1 + 7616) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + a3));
  if (result)
    return (const char *)(cstdlib_strcmp(result, "VV") == 0);
  return result;
}

const char *mfs_Ling_IsSilence(uint64_t a1, uint64_t a2, int a3)
{
  const char *result;

  result = *(const char **)(*(_QWORD *)(a1 + 7616) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + a3));
  if (result)
    return (const char *)(cstdlib_strcmp(result, "SIL") == 0);
  return result;
}

const char *mfs_Ling_IsVowelVowelTrans(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  const char *result;

  if (a3 < 1)
    v6 = 0;
  else
    v6 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + (a3 - 1));
  result = *(const char **)(*(_QWORD *)(a1 + 7616) + 8 * v6);
  if (result)
  {
    if (cstdlib_strcmp(result, "VV"))
    {
      return 0;
    }
    else
    {
      result = *(const char **)(*(_QWORD *)(a1 + 7616) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + a3));
      if (result)
        return (const char *)(cstdlib_strcmp(result, "VV") == 0);
    }
  }
  return result;
}

uint64_t mfs_Ling_IsInvariantPhoneme(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;

  result = *(_QWORD *)(*(_QWORD *)(a1 + 7616) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + a3));
  if (result)
  {
    if (!cstdlib_strcmp((const char *)result, "SIL"))
      return 1;
    result = *(_QWORD *)(*(_QWORD *)(a1 + 7616) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + a3));
    if (!result)
      return result;
    if (cstdlib_strcmp((const char *)result, "UC"))
    {
      result = *(_QWORD *)(*(_QWORD *)(a1 + 7616) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + a3));
      if (result)
        return !cstdlib_strcmp((const char *)result, "MC") && *(unsigned __int8 *)(*(_QWORD *)(a2 + 184) + a3) != 2;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

BOOL mfs_Ling_IsVoiced(uint64_t a1, uint64_t a2, int a3)
{
  const char *v4;
  const char *v7;
  _BOOL8 result;

  v4 = *(const char **)(*(_QWORD *)(a1 + 7616) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + a3));
  result = 0;
  if (v4)
  {
    if (!cstdlib_strcmp(v4, "VC"))
      return 1;
    v7 = *(const char **)(*(_QWORD *)(a1 + 7616) + 8 * *(unsigned __int8 *)(*(_QWORD *)(a2 + 32) + a3));
    if (v7)
    {
      if (!cstdlib_strcmp(v7, "VV"))
        return 1;
    }
  }
  return result;
}

float mfs_Ling_TransWeightsDiphADJ(_QWORD *a1, int a2)
{
  uint64_t v2;
  float result;
  uint64_t v4;
  int *v5;
  int v6;

  v2 = *(unsigned __int16 *)(*a1 + 3360);
  result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    v4 = 0;
    v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      v6 = *v5;
      v5 += 3;
      if (v6 == 1)
        break;
      if (-v2 == --v4)
        return result;
    }
    if ((int)v4 <= 0)
      return (float)*(unsigned int *)(a1[448] + 4 * ((int)v2 * a2 - (int)v4)) / 100000.0;
  }
  return result;
}

float mfs_Ling_TransWeightsDiphMCP(_QWORD *a1, int a2)
{
  uint64_t v2;
  float result;
  uint64_t v4;
  int *v5;
  int v6;

  v2 = *(unsigned __int16 *)(*a1 + 3360);
  result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    v4 = 0;
    v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      v6 = *v5;
      v5 += 3;
      if (v6 == 3)
        break;
      if (-v2 == --v4)
        return result;
    }
    if ((int)v4 <= 0)
      return (float)*(unsigned int *)(a1[448] + 4 * ((int)v2 * a2 - (int)v4)) / 1000.0;
  }
  return result;
}

float mfs_Ling_TransWeightsDiphLF0(_QWORD *a1, int a2)
{
  uint64_t v2;
  float result;
  uint64_t v4;
  int *v5;
  int v6;

  v2 = *(unsigned __int16 *)(*a1 + 3360);
  result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    v4 = 0;
    v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      v6 = *v5;
      v5 += 3;
      if (v6 == 2)
        break;
      if (-v2 == --v4)
        return result;
    }
    if ((int)v4 <= 0)
      return (float)*(unsigned int *)(a1[448] + 4 * ((int)v2 * a2 - (int)v4)) / 1000.0;
  }
  return result;
}

float mfs_Ling_TransWeightsPhonADJ(_QWORD *a1, int a2)
{
  uint64_t v2;
  float result;
  uint64_t v4;
  int *v5;
  int v6;

  v2 = *(unsigned __int16 *)(*a1 + 3360);
  result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    v4 = 0;
    v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      v6 = *v5;
      v5 += 3;
      if (v6 == 1)
        break;
      if (-v2 == --v4)
        return result;
    }
    if ((int)v4 <= 0)
      return (float)*(unsigned int *)(a1[449] + 4 * ((int)v2 * a2 - (int)v4)) / 100000.0;
  }
  return result;
}

float mfs_Ling_TransWeightsPhonMCP(_QWORD *a1, int a2)
{
  uint64_t v2;
  float result;
  uint64_t v4;
  int *v5;
  int v6;

  v2 = *(unsigned __int16 *)(*a1 + 3360);
  result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    v4 = 0;
    v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      v6 = *v5;
      v5 += 3;
      if (v6 == 3)
        break;
      if (-v2 == --v4)
        return result;
    }
    if ((int)v4 <= 0)
      return (float)*(unsigned int *)(a1[449] + 4 * ((int)v2 * a2 - (int)v4)) / 1000.0;
  }
  return result;
}

float mfs_Ling_TransWeightsPhonLF0(_QWORD *a1, int a2)
{
  uint64_t v2;
  float result;
  uint64_t v4;
  int *v5;
  int v6;

  v2 = *(unsigned __int16 *)(*a1 + 3360);
  result = 0.0;
  if (*(_WORD *)(*a1 + 3360))
  {
    v4 = 0;
    v5 = *(int **)(*a1 + 3368);
    while (1)
    {
      v6 = *v5;
      v5 += 3;
      if (v6 == 2)
        break;
      if (-v2 == --v4)
        return result;
    }
    if ((int)v4 <= 0)
      return (float)*(unsigned int *)(a1[449] + 4 * ((int)v2 * a2 - (int)v4)) / 1000.0;
  }
  return result;
}

uint64_t mfs_Ling_DisplayFeatureValue(uint64_t a1)
{
  return MFS__log_select_Diag(a1, 1, (uint64_t)"Phoneme: %d, FeatureId: %d, Value: %d \n");
}

uint64_t mfs_Ling_SetFeatureValue(uint64_t result, unsigned int a2, int a3, char a4)
{
  *(_BYTE *)(*(_QWORD *)(result + 8 * a2 + 16) + a3) = a4;
  return result;
}

uint64_t mfs_ParamGenStart(uint64_t a1, int *a2, _DWORD *a3)
{
  char *v6;
  uint64_t v7;
  char *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v17;
  uint64_t v18;
  int v19;
  float v20;
  float v21;
  uint64_t v22;
  _DWORD *v23;
  _DWORD *v24;
  int v25;
  uint64_t v26;
  int *v27;
  const char **v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  uint64_t v45;
  float *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  char *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  uint64_t v64;
  unsigned int LF0PDF_PerStateRho;
  uint64_t *v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  unsigned int v77;
  _DWORD *v78;
  unsigned int v79;
  int *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  float v84;
  BOOL v85;
  int v86;
  int v87;
  float v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  int32x2_t *v92;
  unsigned int DurPDF;
  uint64_t v94;
  uint64_t v95;
  uint64_t v97;
  _DWORD *v98;
  uint64_t v99;
  uint64_t v100;
  int *v101;
  int32x2_t *v102;
  unsigned __int16 *v103;
  int *v104;
  _QWORD *v105;
  int *v106;
  uint64_t v107;
  uint64_t v108;
  unsigned int inited;
  uint64_t v110;
  __int16 v111;
  char v112;
  __int16 v113;
  char v114;

  v6 = (char *)(a1 + 56);
  v7 = *(_QWORD *)a1;
  MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"-%s\n");
  v8 = v6;
  v9 = a2;
  inited = MFS__InitUttModel(v7, v8, a2, *(__int16 *)(*(_QWORD *)(a1 + 8) + 10));
  if ((inited & 0x80000000) != 0)
    return inited;
  *(_DWORD *)(a1 + 16) = a3[8];
  *(_QWORD *)(a1 + 1928) = v7;
  *(_QWORD *)(a1 + 2192) = 0;
  *(_DWORD *)(a1 + 2200) = 0;
  v15 = a3[7];
  if (v15 >= 1 && v15 < *(_DWORD *)(a1 + 620))
  {
    MFS__log_select_Error(v7, 55018, (uint64_t)"Specified length of generated speech is too short (this sentence is composed from %d states), specify more than %d milliseconds\n", v10, v11, v12, v13, v14);
    return -2065686521;
  }
  LODWORD(v17) = *(_DWORD *)(a1 + 608);
  if ((int)v17 < 1)
  {
    v21 = 0.0;
    v20 = 0.0;
    goto LABEL_87;
  }
  v18 = 0;
  v99 = 0;
  v100 = 0;
  v107 = (uint64_t)(a2 + 116);
  v19 = *(_DWORD *)(a1 + 32);
  v97 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 1784);
  v20 = 0.0;
  v21 = 0.0;
  v108 = v7;
  v104 = a2;
  while (1)
  {
    v110 = *(_QWORD *)(a1 + 600);
    if (v19 >= 1)
    {
      v22 = 0;
      v23 = a3 + 326;
      do
      {
        v24 = &a3[v22];
        v25 = v24[86];
        if (v25 >= 1)
        {
          v26 = 0;
          v27 = v24 + 86;
          v28 = (const char **)&a3[2 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 248) + v18) + 1326];
          do
          {
            v29 = *(const char **)&v23[2 * v26];
            if (v29 && *v28)
            {
              if (!cstdlib_strcmp(v29, *v28))
                goto LABEL_18;
              v25 = *v27;
            }
            ++v26;
          }
          while (v26 < v25);
        }
        LODWORD(v26) = 0;
LABEL_18:
        *(_DWORD *)(v110 + 528 * v18 + 4 * v22++ + 32) = v26;
        v23 += 10;
      }
      while (v22 < *(int *)(a1 + 32));
    }
    v102 = (int32x2_t *)(v110 + 528 * v18);
    MFS__log_select_Diag(v7, 21, (uint64_t)"[phoneme %d]\n");
    v9 = v104;
    if (!v97)
      break;
    if (a3[29])
    {
      v35 = v7;
      v36 = 58016;
      v37 = "Phoneme level segmentation is not currently supported\n";
    }
    else
    {
      if (!a3[28])
        break;
      v35 = v7;
      v36 = 58017;
      v37 = "State level segmentation is not currently supported\n";
    }
    MFS__log_select_Error(v35, v36, (uint64_t)v37, v30, v31, v32, v33, v34);
LABEL_29:
    if (a3[2198])
    {
      inited = -2065686527;
      v95 = v7;
LABEL_96:
      MFS__log_select_Error(v95, 58011, (uint64_t)"bBackoff is not currently supported at %s:%d\n", v38, v39, v40, v41, v42);
      return inited;
    }
    v19 = *(_DWORD *)(a1 + 32);
    if (v19 >= 1)
    {
      v48 = 0;
      while (1)
      {
        v49 = *(_QWORD *)(a1 + 24);
        if (!*(_DWORD *)(v49 + 1528 * v48 + 1480))
        {
          if (*(_DWORD *)(v49 + 1528 * v48 + 1488))
          {
            v50 = a1 + 8 * v48;
            v51 = *v9 * v18;
            v99 = *(_QWORD *)(*(_QWORD *)(v50 + 304) + 8 * v51);
            v100 = *(_QWORD *)(*(_QWORD *)(v50 + 224) + 8 * v51);
          }
          v52 = (char *)v9 + 2 * v48;
          if (*((_WORD *)v52 + 324))
            break;
        }
LABEL_33:
        if (++v48 >= v19)
          goto LABEL_50;
      }
      v53 = 0;
      v54 = 0;
      v55 = v110 + 528 * v18;
      v56 = (_QWORD *)(v55 + 8 * v48);
      v103 = (unsigned __int16 *)(v52 + 648);
      v105 = v56 + 9;
      v106 = &v9[2 * v48 + 142];
      v57 = (uint64_t)&v9[v48 + 1];
      v58 = v56 + 19;
      v59 = v56 + 29;
      v98 = (_DWORD *)v57;
      v101 = (int *)(v55 + 4 * v48 + 32);
      while (2)
      {
        v60 = *(unsigned __int16 *)(*(_QWORD *)v106 + v53);
        *(_DWORD *)(*v105 + 4 * v60) = MFS__TreeSearch(*(_QWORD *)(a1 + 8), v18, v107, v48, v54);
        MFS__log_select_Diag(v108, 6, (uint64_t)"%s pdf state %d id %d\n");
        if (a3[2198])
        {
          inited = -2065686527;
          v95 = v108;
          goto LABEL_96;
        }
        v61 = *(_QWORD *)(a1 + 24);
        if (*(_DWORD *)(v61 + 1528 * v48 + 1488))
        {
          v62 = v60 - 2;
          v63 = v62 + v62 * *v98;
          *(_QWORD *)(*v58 + 8 * v60) = v100 + 4 * v63;
          *(_QWORD *)(*v58 + 8 * v60) -= 4;
          *(_QWORD *)(*v59 + 8 * v60) = v99 + 4 * v63;
          *(_QWORD *)(*v59 + 8 * v60) -= 4;
          v64 = *(_QWORD *)(a1 + 2640);
          if (v64 && a3[v48 + 56] == 2)
            LF0PDF_PerStateRho = MFS__FindLF0PDF_PerStateRho(v48, v60, (uint64_t)v102, (uint64_t)v104, (uint64_t)a3, *v101, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 1528 * v48 + 1492), *(float *)(*(_QWORD *)v64+ 48 * (*(_DWORD *)(v64 + 20) + v62 + *v104 * v18)+ 20));
          else
            LF0PDF_PerStateRho = MFS__FindMsdPDF(v48, v60, (uint64_t)v102, (uint64_t)v104, (uint64_t)a3, *v101);
          goto LABEL_47;
        }
        if (*(_DWORD *)(v61 + 1528 * v48 + 1484))
        {
          LF0PDF_PerStateRho = MFS__FindContPDF(v48, v60, (uint64_t)v102, (uint64_t)v104, *v101);
LABEL_47:
          inited = LF0PDF_PerStateRho;
          if ((LF0PDF_PerStateRho & 0x80000000) != 0)
            return inited;
        }
        ++v54;
        v53 += 16;
        if (v54 >= *v103)
        {
          v19 = *(_DWORD *)(a1 + 32);
          v7 = v108;
          v9 = v104;
          goto LABEL_33;
        }
        continue;
      }
    }
LABEL_50:
    ++v18;
    v17 = *(int *)(a1 + 608);
    if (v18 >= v17)
    {
      v15 = a3[7];
LABEL_87:
      if (v15 < 1 || (*(float *)(a1 + 16) = (float)((float)v15 - v21) / v20, (int)v17 < 1))
      {
LABEL_92:
        MFS__log_select_Diag(v7, 2, (uint64_t)">> tree search done\n");
        AddBreakMarks_2(a1, v9, (uint64_t)a3);
        if (MFS__log_select_GetLogLevel(*(_QWORD *)(v7 + 32)) >= 0x15)
          OutLabel_3(a1);
        inited = ParamGenLT_2(a1, v9, 0);
        v94 = *(_QWORD *)(*(_QWORD *)(a1 + 600) + 528 * *(int *)(a1 + 608) - 512);
        *(_DWORD *)(v94 + 4 * *v9) = *(_DWORD *)(v94 + 4 * *v9 + 4) + *(_DWORD *)(v94 + 4 * *v9) - 1;
        *(_DWORD *)(v94 + 4 * *v9 + 4) = 1;
        MFS__log_select_Diag(v7, 1, (uint64_t)"+%s\n");
      }
      else
      {
        v90 = 0;
        v91 = 0;
        while (1)
        {
          v92 = (int32x2_t *)(*(_QWORD *)(a1 + 600) + v90);
          DurPDF = MFS__FindDurPDF(v92, v9, 0, v92[4].i32[0], *(_DWORD *)(*(_QWORD *)(a1 + 24) + 1492), *(float *)(a1 + 16));
          if ((DurPDF & 0x80000000) != 0)
            return DurPDF;
          SetSilenceDuration_2(a1, v9, (uint64_t)a3, (int *)v92);
          *(_DWORD *)(a1 + 624) += v92[3].i32[0];
          ++v91;
          v90 += 528;
          if (v91 >= *(int *)(a1 + 608))
            goto LABEL_92;
        }
      }
      return inited;
    }
  }
  v43 = v110 + 528 * v18;
  *(_DWORD *)(v43 + 8) = MFS__TreeSearch(*(_QWORD *)(a1 + 8), v18, v107, 0, 0);
  v44 = (int *)(v43 + 8);
  MFS__log_select_Diag(v7, 6, (uint64_t)"DUR pdf id %d\n");
  if (a3[7])
  {
    v45 = *v104;
    if ((int)v45 >= 1)
    {
      v46 = (float *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v104 + 21) + 8 * *(int *)(v110 + 528 * v18 + 32))
                                + 8 * *v44)
                    + 8);
      v47 = (v45 + 2) - 2;
      do
      {
        v21 = v21 + *v46;
        v20 = v20 + v46[v45];
        ++v46;
        --v47;
      }
      while (v47);
    }
    goto LABEL_29;
  }
  v112 = 0;
  v111 = 0;
  mfs_Ling_GetPhonCtxt(*(_QWORD *)(a1 + 8), v102->i32[0], &v111);
  if (HIBYTE(v111) == 1 && (_BYTE)v111 && v112)
    goto LABEL_67;
  v66 = *(uint64_t **)(a1 + 2640);
  if (!v66)
    goto LABEL_67;
  v67 = *v104;
  if (!(_DWORD)v67)
    goto LABEL_67;
  v68 = 0;
  v69 = (int)v67;
  v70 = *v66;
  v71 = *((_DWORD *)v66 + 5) + v67 * v18;
  do
  {
    if (*(float *)(v70 + 48 * v71 + 16) != 0.0)
      v68 = 1;
    ++v71;
    --v67;
  }
  while (v67);
  if (!v68)
  {
LABEL_67:
    v79 = MFS__FindDurPDF(v102, v104, 0, *(_DWORD *)(v110 + 528 * v18 + 32), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 1492), 0.0);
LABEL_68:
    inited = v79;
    if ((v79 & 0x80000000) != 0)
      return inited;
    SetSilenceDuration_2(a1, v104, (uint64_t)a3, (int *)v102);
    v114 = 0;
    v113 = 0;
    mfs_Ling_GetPhonCtxt(*(_QWORD *)(a1 + 8), v102->i32[0], &v113);
    v80 = (int *)(v110 + 528 * v18 + 24);
    if (HIBYTE(v113) == 1 && (_BYTE)v113 && v114)
    {
      *v80 = 0;
      LODWORD(v81) = *v104;
      if (*v104 < 1)
      {
        v89 = 0;
      }
      else
      {
        v82 = *(_QWORD *)(v110 + 528 * v18 + 16);
        v83 = 2;
        do
        {
          v84 = (float)*(int *)(v82 + 4 * v83) * 0.8;
          v86 = v81 + 4;
          v85 = (int)v81 < -4;
          v87 = v81 + 5;
          if (!v85)
            v87 = v86;
          if (v83 == v87 >> 1)
            v84 = v84 * 0.8;
          if (v84 >= 1.0)
            v88 = v84 + 0.5;
          else
            v88 = 1.5;
          *(_DWORD *)(v82 + 4 * v83) = (int)v88;
          v89 = *v80 + (int)v88;
          *v80 = v89;
          v81 = *v104;
          v85 = v83++ <= v81;
        }
        while (v85);
      }
    }
    else
    {
      v89 = *v80;
    }
    *(_DWORD *)(a1 + 624) += v89;
    goto LABEL_29;
  }
  v72 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 1928) + 8), v69, 4);
  if (v72)
  {
    v73 = v72;
    v74 = *v104;
    if ((_DWORD)v74)
    {
      v75 = *(uint64_t **)(a1 + 2640);
      v76 = *v75;
      v77 = *((_DWORD *)v75 + 5) + v74 * v18;
      v78 = (_DWORD *)v72;
      do
      {
        *v78++ = *(_DWORD *)(v76 + 48 * v77++ + 16);
        --v74;
      }
      while (v74);
    }
    MFS__FindDurPDF_PerStateRho((uint64_t)v102, v104, v72, 0, *(_DWORD *)(v110 + 528 * v18 + 32), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 1492));
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 1928) + 8), v73);
    v79 = inited;
    goto LABEL_68;
  }
  return -2065686518;
}

uint64_t SetSilenceDuration_2(uint64_t result, int *a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  int v18;
  float v19;
  uint64_t v20;
  uint64_t v21;
  int v22;

  v4 = *(_QWORD *)(result + 8);
  v5 = *a4;
  if (*(_BYTE *)(*(_QWORD *)(v4 + 32) + v5) == 1)
  {
    v6 = *(unsigned __int16 *)(*(_QWORD *)(v4 + 1784) + 2 * v5) / *(int *)(a3 + 24);
    LODWORD(v5) = *a2;
    if (v6 <= *a2)
    {
      if ((int)v5 >= 1)
      {
        v12 = *((_QWORD *)a4 + 2);
        v13 = 2;
        do
        {
          *(_DWORD *)(v12 + 4 * v13) = 1;
          v9 = v13++ <= *a2;
        }
        while (v9);
        LODWORD(v5) = *a2;
      }
      a4[6] = v5;
    }
    else
    {
      if (v6 >= a4[6])
      {
        if ((int)v5 <= 0)
        {
          a4[6] = 0;
          return result;
        }
        v11 = 0;
        v10 = 0;
        v14 = *((_QWORD *)a4 + 2);
        v15 = 2;
        do
        {
          v16 = *(_DWORD *)(v14 + 4 * v15);
          if (v16 <= 0)
          {
            v16 = 1;
            *(_DWORD *)(v14 + 4 * v15) = 1;
            LODWORD(v5) = *a2;
          }
          v17 = v15 == 2 || v15 == (_DWORD)v5 + 1;
          if (v17)
            v18 = 0;
          else
            v18 = v16;
          v10 += v18;
          if (!v17)
            v16 = 0;
          v11 += v16;
          v9 = v15++ <= (int)v5;
        }
        while (v9);
      }
      else
      {
        if ((int)v5 >= 1)
        {
          v7 = *((_QWORD *)a4 + 2);
          v8 = 2;
          do
          {
            *(_DWORD *)(v7 + 4 * v8) = 1;
            v9 = v8++ <= *a2;
          }
          while (v9);
          LODWORD(v5) = *a2;
        }
        v10 = v5 - 2;
        v11 = 2;
      }
      a4[6] = v11;
      if ((int)v5 >= 3)
      {
        v19 = (float)(v6 - v11) / (float)v10;
        v20 = *((_QWORD *)a4 + 2);
        v21 = 3;
        do
        {
          if (v21 >= (int)v5)
            v22 = v6 - v11;
          else
            v22 = (int)(float)(v19 * (float)*(int *)(v20 + 4 * v21));
          *(_DWORD *)(v20 + 4 * v21) = v22;
          if (v22 <= 0)
          {
            v22 = 1;
            *(_DWORD *)(v20 + 4 * v21) = 1;
          }
          v11 = a4[6] + v22;
          a4[6] = v11;
          v5 = *a2;
          v9 = v21++ < v5;
        }
        while (v9);
      }
    }
  }
  return result;
}

uint64_t AddBreakMarks_2(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;

  result = cstdlib_strcmp(*(const char **)(a3 + 80), "PHRASE");
  if ((_DWORD)result)
  {
    result = cstdlib_strcmp(*(const char **)(a3 + 80), "WORD");
    if ((_DWORD)result)
    {
      result = cstdlib_strcmp(*(const char **)(a3 + 80), "SYLLABLE");
      if ((_DWORD)result)
      {
        result = cstdlib_strcmp(*(const char **)(a3 + 80), "TIME");
        if ((_DWORD)result)
        {
          result = cstdlib_strcmp(*(const char **)(a3 + 80), "NONE");
          if ((_DWORD)result)
            return MFS__log_select_Error(*(_QWORD *)a1, 58019, (uint64_t)"valid breaker is required\n", v7, v8, v9, v10, v11);
        }
        else
        {
          v24 = *(unsigned int *)(a1 + 608);
          if ((int)v24 >= 1)
          {
            v25 = 0;
            v26 = 0;
            v27 = *(_DWORD *)(a3 + 88);
            v28 = *a2;
            v29 = *(_QWORD *)(a1 + 600);
            v30 = v27;
            v31 = 0;
            do
            {
              if (v28 >= 1)
              {
                result = *(_QWORD *)(v29 + 528 * v25 + 16) + 8;
                v32 = (v28 + 2) - 2;
                v31 = v26;
                do
                {
                  v33 = *(_DWORD *)result;
                  result += 4;
                  v31 += v33;
                  --v32;
                }
                while (v32);
              }
              if (v31 > v30)
              {
                v30 = v26 + v27;
                v34 = v29 + 528 * v25;
                result = *(_DWORD *)(v34 + 4) | 2u;
                *(_DWORD *)(v34 + 4) = result;
              }
              ++v25;
              v26 = v31;
            }
            while (v25 != v24);
          }
        }
      }
      else
      {
        v20 = *(_DWORD *)(a1 + 608);
        if (v20 >= 3)
        {
          v21 = (v20 - 2);
          v22 = *(int **)(a1 + 600);
          v23 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
          do
          {
            if (*(_BYTE *)(v23 + *v22))
              v22[133] |= 2u;
            v22 += 132;
            --v21;
          }
          while (v21);
        }
      }
    }
    else
    {
      v16 = *(_DWORD *)(a1 + 608);
      if (v16 >= 3)
      {
        v17 = (v16 - 2);
        v18 = *(int **)(a1 + 600);
        v19 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
        do
        {
          if ((*(_BYTE *)(v19 + *v18) & 0xFE) == 2)
            v18[133] |= 2u;
          v18 += 132;
          --v17;
        }
        while (v17);
      }
    }
  }
  else
  {
    v12 = *(_DWORD *)(a1 + 608);
    if (v12 >= 3)
    {
      v13 = (v12 - 2);
      v14 = *(int **)(a1 + 600);
      v15 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
      do
      {
        if (*(_BYTE *)(v15 + *v14) == 3)
          v14[133] |= 2u;
        v14 += 132;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

uint64_t OutLabel_3(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  if (*(int *)(result + 608) >= 1)
  {
    v1 = result;
    v2 = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(v1 + 600) + v2;
      result = MFS__log_select_Diag(*(_QWORD *)v1, 21, (uint64_t)"%d %d %d [%d]\n");
      v4 += *(_DWORD *)(v5 + 24);
      ++v3;
      v2 += 528;
    }
    while (v3 < *(int *)(v1 + 608));
  }
  return result;
}

uint64_t ParamGenLT_2(uint64_t a1, int *a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  _DWORD *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  unsigned int inited;
  uint64_t v31;
  int *v32;
  int v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  int **v37;
  _DWORD *v38;
  _DWORD *v39;
  _DWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  _DWORD *v45;
  _DWORD *v46;
  uint64_t v47;
  uint64_t v48;
  _BYTE *v49;
  uint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  uint64_t v53;
  int v54;
  int v55;
  unsigned int *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _DWORD *v60;
  uint64_t v61;
  _DWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _DWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _DWORD *v72;
  int v73;
  int v74;
  BOOL v75;
  BOOL v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  float v84;
  uint64_t v85;
  uint64_t v86;
  int **v87;
  uint64_t *v88;
  int *v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  int **v93;
  uint64_t *v94;
  int *v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t *v105;
  uint64_t v106;
  uint64_t v107;
  _BYTE *v108;
  uint64_t v109;
  _QWORD *v110;
  _QWORD *v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  int *v124;
  int v125;
  int v126;
  int v127;
  unsigned int v128;
  uint64_t v129;
  uint64_t v130;
  float v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  BOOL v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  float v139;
  uint64_t v140;
  void (***v141)(uint64_t *, _QWORD);
  void (***v142)(uint64_t *, _QWORD);
  uint64_t *v144;
  uint64_t **v145;
  int ***v146;
  int *v147;
  uint64_t v148;
  unsigned int *v149;
  uint64_t v150;
  unsigned int v151;
  _QWORD *v152;
  uint64_t v153;
  int v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  unsigned int v161;
  _QWORD *v162;
  _QWORD *v163;
  uint64_t v164;
  uint64_t v165;
  int v166;
  _QWORD *v167;
  uint64_t v168;
  _QWORD *v169;
  uint64_t v170;
  int *v171;
  uint64_t v172;
  _OWORD v173[4];
  _OWORD v174[4];
  _OWORD __b[46];

  v6 = *(_QWORD *)a1;
  memset(__b, 0, 512);
  memset(v174, 0, sizeof(v174));
  memset(v173, 0, sizeof(v173));
  MFS__log_select_Diag(v6, 1, (uint64_t)"-%s\n");
  cstdlib_memset(__b, 0, 0x2D8uLL);
  MFS__InitSMatrices(v6, v174);
  MFS__InitSMatrices(v6, v173);
  if (a3)
  {
    heap_Free(*(_QWORD **)(v6 + 8), *(_QWORD *)(a1 + 48));
    *(_QWORD *)(a1 + 48) = 0;
    heap_Free(*(_QWORD **)(v6 + 8), *(_QWORD *)(a1 + 40));
    *(_QWORD *)(a1 + 40) = 0;
    v7 = *(unsigned int *)(a1 + 32);
    if ((int)v7 >= 1)
    {
      v8 = *(_QWORD *)(a1 + 24);
      do
      {
        if (!*(_DWORD *)(v8 + 1480))
          *(_DWORD *)(v8 + 44) = 0;
        v8 += 1528;
        --v7;
      }
      while (v7);
    }
  }
  v151 = -2065686518;
  v9 = heap_Calloc(*(_QWORD **)(v6 + 8), (*(_DWORD *)(a1 + 624) + 1), 1);
  *(_QWORD *)(a1 + 48) = v9;
  if (v9)
  {
    v10 = heap_Calloc(*(_QWORD **)(v6 + 8), (*(_DWORD *)(a1 + 624) + 1), 4);
    *(_QWORD *)(a1 + 40) = v10;
    if (v10)
    {
      v11 = *(_DWORD *)(a1 + 608);
      if (v11 < 1)
      {
        v13 = 0;
      }
      else
      {
        v12 = 0;
        v13 = 0;
        v14 = *a2;
        do
        {
          if (v14 >= 1)
          {
            v15 = *(_QWORD *)(a1 + 600) + 528 * v12;
            v18 = *(_QWORD *)(v15 + 16);
            v16 = (uint64_t *)(v15 + 16);
            v17 = v18;
            v19 = v16 + 37;
            v20 = 2;
            do
            {
              if (*(int *)(v17 + 4 * v20) >= 1)
              {
                v13 = (int)v13;
                v21 = 1;
                do
                {
                  *(_BYTE *)(*(_QWORD *)(a1 + 48) + v13) = *(_BYTE *)(*v19 + v20);
                  *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v13) = *(_DWORD *)(v16[38] + 4 * v20);
                  v22 = *(unsigned int *)(a1 + 32);
                  if ((int)v22 >= 1)
                  {
                    v23 = *(_DWORD **)(a1 + 24);
                    do
                    {
                      if (v23[372] && ((1 << v23[3]) & (unint64_t)*(unsigned __int8 *)(*v19 + v20)) >> v23[3])
                        ++v23[11];
                      v23 += 382;
                      --v22;
                    }
                    while (v22);
                  }
                  ++v13;
                  v17 = *v16;
                  v76 = v21++ < *(_DWORD *)(*v16 + 4 * v20);
                }
                while (v76);
                v14 = *a2;
              }
              v76 = v20++ <= v14;
            }
            while (v76);
            v11 = *(_DWORD *)(a1 + 608);
          }
          ++v12;
        }
        while (v12 < v11);
      }
      if (*(int *)(a1 + 32) < 1)
      {
        v151 = 0;
        goto LABEL_136;
      }
      v147 = a2;
      v24 = 0;
      v25 = 0;
      v151 = 0;
      v161 = a3;
      while (1)
      {
        v26 = *(_QWORD *)(a1 + 24);
        v27 = v26 + 1528 * v24;
        v28 = (uint64_t *)(v27 + 24);
        v156 = v24;
        v144 = (uint64_t *)(v27 + 24);
        v148 = v26;
        v150 = v13;
        if (!*(_DWORD *)(v27 + 1484))
          goto LABEL_79;
        v29 = v26 + 1528 * v24;
        *(_DWORD *)(v29 + 44) = v13;
        v149 = (unsigned int *)(v29 + 44);
        *(_DWORD *)(v29 + 772) = v13;
        inited = MFS__InitPStreamParam(v28, 0);
        if ((inited & 0x80000000) != 0)
        {
LABEL_135:
          v151 = inited;
          goto LABEL_136;
        }
        v151 = MFS__InitPStreamSM(v28, 0);
        if ((v151 & 0x80000000) != 0)
          goto LABEL_136;
        v31 = v26 + 1528 * v24;
        v33 = *(_DWORD *)(v31 + 40);
        v32 = (int *)(v31 + 40);
        if (v33 < 1)
          goto LABEL_79;
        v34 = 0;
        v35 = (uint64_t *)(v149 + 177);
        v36 = v26 + 1528 * v156;
        v37 = (int **)(v36 + 784);
        v163 = (_QWORD *)(v36 + 96);
        v165 = 0;
        v162 = (_QWORD *)(v36 + 824);
        v167 = (_QWORD *)(v36 + 832);
        v169 = (_QWORD *)(v36 + 104);
        v38 = (_DWORD *)(v36 + 872);
        v39 = (_DWORD *)(v36 + 1072);
        v40 = (_DWORD *)(v36 + 1272);
        v145 = (uint64_t **)(v36 + 64);
        v146 = (int ***)(v36 + 792);
        v152 = v149 + 177;
        v171 = v32;
        do
        {
          v158 = v34;
          inited = MFS__InitPStreamParam(v35, (uint64_t)__b);
          if ((inited & 0x80000000) != 0)
            goto LABEL_135;
          v151 = MFS__InitPStreamSM(v35, (uint64_t)v173);
          if ((v151 & 0x80000000) != 0)
            goto LABEL_136;
          v155 = *(unsigned int *)(a1 + 608);
          if ((int)v155 < 1)
          {
            v150 = 0;
LABEL_69:
            v79 = v158;
            goto LABEL_70;
          }
          v41 = 0;
          v42 = 0;
          v153 = *(_QWORD *)(a1 + 600);
          v43 = v148 + 1528 * v156 + 4 * v158;
          v44 = (_DWORD *)(v43 + 144);
          v45 = (_DWORD *)(v43 + 344);
          v46 = (_DWORD *)(v43 + 544);
          v154 = *v147;
          v159 = (*v147 + 2);
          do
          {
            v157 = v41;
            if (v154 >= 1)
            {
              v47 = v153 + 528 * v41;
              v48 = *(_QWORD *)(v47 + 16);
              v49 = (_BYTE *)(v47 + 4);
              v50 = v47 + 8 * v156;
              v51 = (_QWORD *)(v50 + 152);
              v52 = (_QWORD *)(v50 + 232);
              v53 = 2;
              while (1)
              {
                v54 = *(_DWORD *)(v48 + 4 * v53);
                if (v54 >= 1)
                  break;
LABEL_55:
                if (++v53 == v159)
                  goto LABEL_56;
              }
              v42 = (int)v42;
              v55 = 1;
              while (1)
              {
                if (a3 > 1)
                {
                  v56 = (unsigned int *)*v37;
                  if ((*v49 & 4) == 0)
                  {
                    v57 = *v56;
                    if ((int)v57 >= 1)
                    {
                      v58 = v165;
                      v59 = *(_QWORD *)(*v163 + 8 * v42);
                      v60 = *(_DWORD **)(*v162 + 8 * v42);
                      v61 = *(_QWORD *)(*v169 + 8 * v42);
                      v62 = *(_DWORD **)(*v167 + 8 * v42);
                      v63 = 4 * *v171;
                      do
                      {
                        *(_DWORD *)(v59 + v58) = 0;
                        *v60++ = 0;
                        *(_DWORD *)(v61 + v58) = 1065353216;
                        v58 += v63;
                        *v62++ = 1065353216;
                        --v57;
                      }
                      while (v57);
                    }
                    goto LABEL_53;
                  }
                }
                else
                {
                  v56 = (unsigned int *)*v37;
                }
                v64 = *v56;
                if ((int)v64 >= 1)
                {
                  v65 = *(_QWORD *)(*v51 + 8 * v53);
                  v66 = *(_QWORD *)(*v163 + 8 * v42);
                  v67 = *(_DWORD **)(*v162 + 8 * v42);
                  v68 = *(_QWORD *)(*v52 + 8 * v53);
                  v69 = *(_QWORD *)(*v169 + 8 * v42);
                  v70 = 4 * *v171;
                  v71 = v165;
                  v72 = *(_DWORD **)(*v167 + 8 * v42);
                  do
                  {
                    v73 = *(_DWORD *)(v65 + v71);
                    *(_DWORD *)(v66 + v71) = v73;
                    *v67++ = v73;
                    v74 = *(_DWORD *)(v68 + v71);
                    *(_DWORD *)(v69 + v71) = v74;
                    *v72++ = v74;
                    *v38 = *v44;
                    *v39 = *v45;
                    *v40 = *v46;
                    v71 += v70;
                    --v64;
                  }
                  while (v64);
                }
LABEL_53:
                ++v42;
                v75 = v55++ == v54;
                if (v75)
                  goto LABEL_55;
              }
            }
LABEL_56:
            v41 = v157 + 1;
          }
          while (v157 + 1 != v155);
          if (*(_DWORD *)(*(_QWORD *)(a1 + 24) + 1528 * v156 + 1492))
            v76 = 1;
          else
            v76 = (int)v42 < 1;
          v150 = v42;
          if (v76)
            goto LABEL_69;
          v77 = 0;
          v160 = v42;
          LODWORD(v78) = **v37;
          v79 = v158;
          v80 = v169;
          do
          {
            if ((int)v78 >= 1)
            {
              v81 = 0;
              v82 = *(_QWORD *)(*v80 + 8 * v77);
              do
              {
                v83 = v79 + *v171 * (uint64_t)(int)v81;
                v84 = MFS__bet3_finv(*(float *)(v82 + 4 * v83));
                v80 = v169;
                v79 = v158;
                v82 = *(_QWORD *)(*v169 + 8 * v77);
                *(float *)(v82 + 4 * v83) = v84;
                *(float *)(*(_QWORD *)(*v167 + 8 * v77) + 4 * v81++) = v84;
                v78 = **v37;
              }
              while (v81 < v78);
              a3 = v161;
            }
            ++v77;
          }
          while (v77 != v160);
LABEL_70:
          v85 = *(_QWORD *)(a1 + 24);
          if (a3)
          {
            (*(void (**)(_QWORD *, _QWORD))(*(_QWORD *)(v85 + 1528 * v156 + 1512) + 8 * v79))(v152, 0);
            v86 = *v149;
            if ((int)v86 >= 1)
            {
              v87 = *v146;
              v88 = *v145;
              do
              {
                v89 = *v87++;
                v90 = *v89;
                v91 = *v88++;
                *(_DWORD *)(v91 + 4 * v158) = v90;
                --v86;
              }
              while (v86);
            }
          }
          else
          {
            (*(void (**)(_QWORD *, _QWORD))(*(_QWORD *)(v85 + 1528 * v156 + 1504) + 8 * v79))(v152, 0);
            v92 = *v149;
            if ((int)v92 >= 1)
            {
              v93 = *v146;
              v94 = *v145;
              do
              {
                v95 = *v93++;
                v96 = *v95;
                v97 = *v94++;
                *(_DWORD *)(v97 + 4 * v158) = v96;
                --v92;
              }
              while (v92);
            }
          }
          MFS__FreePStreamSM((uint64_t)v152);
          MFS__FreePStreamParam(v152);
          v35 = (uint64_t *)(v149 + 177);
          v34 = v158 + 1;
          v165 += 4;
        }
        while (v158 + 1 < *v171);
LABEL_79:
        v98 = v156;
        if (!*(_DWORD *)(*(_QWORD *)(a1 + 24) + 1528 * v156 + 1488) || !*(_DWORD *)(v148 + 1528 * v156 + 44))
        {
          v101 = v150;
          goto LABEL_130;
        }
        inited = MFS__InitPStreamParam(v144, 0);
        if ((inited & 0x80000000) != 0)
          goto LABEL_135;
        v151 = MFS__InitPStreamSM(v144, 0);
        if ((v151 & 0x80000000) != 0)
          goto LABEL_136;
        v168 = *(unsigned int *)(a1 + 608);
        if ((int)v168 < 1)
        {
          v101 = 0;
          goto LABEL_130;
        }
        v99 = 0;
        v100 = 0;
        v101 = 0;
        v164 = *(_QWORD *)(a1 + 600);
        v102 = v148 + 1528 * v156;
        v103 = v102 + 56;
        v104 = (uint64_t *)(v102 + 96);
        v105 = (uint64_t *)(v102 + 104);
        v166 = *v147;
        v172 = (*v147 + 2);
LABEL_85:
        v170 = v99;
        if (v166 < 1)
          goto LABEL_115;
        v106 = v164 + 528 * v99;
        v107 = *(_QWORD *)(v106 + 16);
        v108 = (_BYTE *)(v106 + 4);
        v109 = v106 + 8 * v98;
        v110 = (_QWORD *)(v109 + 152);
        v111 = (_QWORD *)(v109 + 232);
        v112 = 2;
LABEL_87:
        v113 = *(_DWORD *)(v107 + 4 * v112);
        if (v113 < 1)
          goto LABEL_114;
        v114 = *(_QWORD *)(a1 + 24) + 1528 * v98;
        v115 = *(unsigned int *)(v114 + 36);
        v116 = *(_QWORD *)(a1 + 48);
        v117 = *(_DWORD *)(v114 + 12);
        v118 = 1;
        v119 = 1 << v117;
        v120 = (int)v101;
        v121 = (1 << v117);
LABEL_89:
        if ((int)v115 >= 1)
          break;
LABEL_109:
        if ((unint64_t)(v119 & *(_BYTE *)(v116 + v120)) >> v117)
          ++v100;
        ++v120;
        LODWORD(v101) = v101 + 1;
        v75 = v118++ == v113;
        if (!v75)
          goto LABEL_89;
        v101 = v120;
        v98 = v156;
LABEL_114:
        if (++v112 != v172)
          goto LABEL_87;
LABEL_115:
        ++v99;
        if (v170 + 1 != v168)
          goto LABEL_85;
        v134 = *(_QWORD *)(a1 + 24);
        if (*(_DWORD *)(v134 + 1528 * v98 + 1492))
          v135 = 1;
        else
          v135 = v100 < 1;
        if (!v135)
        {
          v136 = 0;
          do
          {
            if (*(int *)(v134 + 1528 * v156 + 36) >= 1)
            {
              v137 = 0;
              v138 = *(_QWORD *)(*v105 + 8 * v136);
              do
              {
                v139 = MFS__bet3_finv(*(float *)(v138 + 4 * v137));
                v138 = *(_QWORD *)(*v105 + 8 * v136);
                *(float *)(v138 + 4 * v137++) = v139;
                v134 = *(_QWORD *)(a1 + 24);
              }
              while (v137 < *(int *)(v134 + 1528 * v156 + 36));
            }
            ++v136;
          }
          while (v136 != v100);
        }
        if (v100 < 1)
        {
          a3 = v161;
          v98 = v156;
        }
        else
        {
          v98 = v156;
          v140 = v134 + 1528 * v156;
          v141 = (void (***)(uint64_t *, _QWORD))(v140 + 1504);
          v142 = (void (***)(uint64_t *, _QWORD))(v140 + 1512);
          a3 = v161;
          if (!v161)
            v142 = v141;
          (**v142)(v144, 0);
        }
LABEL_130:
        v24 = v98 + 1;
        v13 = v101;
        if (v24 >= *(int *)(a1 + 32))
        {
LABEL_136:
          MFS__FreePStreamParam(__b);
          MFS__FreeSMatrices((uint64_t)v174);
          MFS__FreeSMatrices((uint64_t)v173);
          MFS__log_select_Diag(v6, 1, (uint64_t)"+%s\n");
          return v151;
        }
      }
      v122 = 0;
      v123 = *(_QWORD *)(*(_QWORD *)v103 + 8);
      while (1)
      {
        v25 |= v121;
        v124 = *(int **)(v123 + 8 * v122);
        v125 = *v124;
        v126 = v124[1];
        if (v125 <= v126)
        {
          v127 = v126 - v125 + 1;
          v128 = v101 + v125;
          do
          {
            v129 = v121 ^ 0xFF;
            if ((v128 & 0x80000000) == 0)
            {
              v129 = v121 ^ 0xFF;
              if (*(_DWORD *)(a1 + 624) >= (signed int)v128)
                v129 = *(unsigned __int8 *)(v116 + v128);
            }
            v25 &= v129;
            ++v128;
            --v127;
          }
          while (v127);
        }
        if (!((unint64_t)(v119 & *(_BYTE *)(v116 + v120)) >> v117))
          goto LABEL_108;
        if (!v122 || (v119 & v25) >> v117)
        {
          if (v161 <= 1)
          {
            v132 = *v104;
            v130 = *v105;
LABEL_106:
            v133 = 4 * v122 + 4;
            *(_DWORD *)(*(_QWORD *)(v132 + 8 * v100) + 4 * v122) = *(_DWORD *)(*(_QWORD *)(*v110 + 8 * v112) + v133);
            v131 = *(float *)(*(_QWORD *)(*v111 + 8 * v112) + v133);
            goto LABEL_107;
          }
          v132 = *v104;
          v130 = *v105;
          if ((*v108 & 4) != 0)
            goto LABEL_106;
          *(_DWORD *)(*(_QWORD *)(v132 + 8 * v100) + 4 * v122) = 0;
        }
        else
        {
          *(_DWORD *)(*(_QWORD *)(*v104 + 8 * v100) + 4 * v122) = 0;
          v130 = *v105;
        }
        v131 = 1.0;
LABEL_107:
        *(float *)(*(_QWORD *)(v130 + 8 * v100) + 4 * v122) = v131;
LABEL_108:
        if (++v122 == v115)
          goto LABEL_109;
      }
    }
  }
  return v151;
}

uint64_t mfs_ParamGen(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  float v21;
  float v22;
  float v23;
  uint64_t v24;
  _DWORD *v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  uint64_t i;
  float v39;
  float v40;
  uint64_t v41;
  uint64_t j;
  float v43;
  uint64_t v44;
  uint64_t v45;
  float v46;
  float v47;
  uint64_t v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  int v54;
  unsigned int v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  uint64_t v63;
  _QWORD *v64;
  _DWORD *v65;
  uint64_t v66;
  int v67;
  int TemplateDur;
  unsigned int v69;
  BOOL v70;
  int v71;
  uint64_t v72;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  int v79;
  uint64_t v80;
  int *v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  int *v93;
  int v94;
  uint64_t v95;
  uint64_t *v96;
  _DWORD *v97;
  uint64_t v98;
  int v99;
  uint64_t v100;
  int v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  float v107;
  uint64_t v108;
  int v109;
  int v110;
  _DWORD *v111;
  int v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  float v129;
  float v130;
  uint64_t v131;
  int v132;
  uint64_t v133;
  int v134;
  uint64_t v135;
  _QWORD *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  _DWORD *v140;
  _DWORD *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;

  v7 = *(_QWORD *)a1;
  v8 = *(_QWORD *)(a1 + 48);
  MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"mfs_ParamGen {\n");
  v147 = a3;
  if (*(_DWORD *)(a3 + 8328) && *(_DWORD *)(a3 + 8564))
  {
    v140 = a4;
    v142 = v7;
    if (!*(_DWORD *)(a1 + 2588))
      BackupDurations(a1, a2);
    if (!*(_DWORD *)(a1 + 2200))
    {
      MFS__log_select_Diag(v7, 1, (uint64_t)"mfs_ParamGen:: Not skipping second pass (early emission mode)\n");
      v145 = *(_QWORD *)(a1 + 1928);
      v9 = *(_DWORD *)(a1 + 2232);
      if (v9)
      {
        v10 = *(_QWORD *)(a1 + 2224) + 28 * (v9 - 1);
        v11 = *(_DWORD *)(v10 + 12) + *(_DWORD *)(v10 + 8);
      }
      else
      {
        v11 = 0;
      }
      MFS__log_select_Diag(v145, 1, (uint64_t)"  -> UpdateStateDurations (early emission mode)\n");
      v55 = *(_DWORD *)(a1 + 2588);
      v56 = v55 / *a2;
      if (v56 < *(_DWORD *)(a1 + 608))
      {
        v57 = v55 % *a2 + 2;
        v58 = v56;
        while (1)
        {
          v139 = v58;
          v59 = *(_QWORD *)(a1 + 600);
          LODWORD(v60) = *a2;
          v61 = *a2 + 2;
          if (v57 >= v61)
          {
            v62 = 0;
            v67 = v57;
          }
          else
          {
            v62 = 0;
            v138 = *(_QWORD *)(a1 + 600);
            v63 = v59 + 528 * v139;
            v64 = (_QWORD *)(v63 + 16);
            v65 = (_DWORD *)(v63 + 4);
            v66 = v57;
            v67 = v57;
            do
            {
              TemplateDur = mfs_UnitSequence_GetTemplateDur(a1 + 2112, *(_QWORD *)(a1 + 1928), v55);
              if (TemplateDur)
              {
                *(_DWORD *)(*v64 + 4 * v66) = TemplateDur;
              }
              else
              {
                *v65 |= 4u;
                v62 = 1;
              }
              v69 = *(_DWORD *)(a1 + 2588);
              if (v69 < *(_DWORD *)(a1 + 2584))
              {
                *(_DWORD *)(a1 + 2588) = v69 + 1;
                ++v67;
              }
              ++v66;
              v60 = *a2;
              v61 = v60 + 2;
              ++v55;
            }
            while (v66 < v60 + 2);
            v59 = v138;
          }
          if (v57 == 2)
          {
            if (*(_DWORD *)(v147 + 8256))
              v70 = v62 == 0;
            else
              v70 = 1;
            if (!v70)
            {
              if (v61 < 3)
              {
                v71 = 0;
              }
              else
              {
                v71 = 0;
                v72 = v59 + 528 * v139;
                v73 = (_QWORD *)(v72 + 328);
                v74 = (_QWORD *)(v72 + 16);
                v75 = 4 * v61;
                v76 = 8;
                do
                {
                  if (v76 != 12)
                    v71 = *(_DWORD *)(*v73 + v76) + v71 - *(_DWORD *)(*v74 + v76);
                  v76 += 4;
                }
                while (v75 != v76);
              }
              v77 = *(_QWORD *)(v59 + 528 * v139 + 16);
              v78 = *(_DWORD *)(v77 + 12);
              if (v78 + v71 < 0 != __OFADD__(v78, v71))
                v71 = 1 - v78;
              *(_DWORD *)(v77 + 12) = v71 + v78;
              LODWORD(v60) = *a2;
            }
            if ((int)v60 < 1)
            {
              v79 = 0;
            }
            else
            {
              v79 = 0;
              v80 = (v60 + 2) - 2;
              v81 = (int *)(*(_QWORD *)(v59 + 528 * v139 + 16) + 8);
              do
              {
                v82 = *v81++;
                v79 += v82;
                --v80;
              }
              while (v80);
            }
            v83 = v59 + 528 * v139;
            *(_DWORD *)(a1 + 624) += v79 - *(_DWORD *)(v83 + 24);
            *(_DWORD *)(v83 + 24) = v79;
            MFS__log_select_Diag(v145, 5, (uint64_t)"syntheval:Phoneme %d has duration %d\n");
            MFS__log_select_Diag(v145, 5, (uint64_t)"At phoneme %d output we have totalframe %d\n");
          }
          if (v57 < v67)
            break;
          v84 = v139;
LABEL_90:
          if (*(_DWORD *)(a1 + 2588) != *(_DWORD *)(a1 + 2584))
          {
            v58 = v84 + 1;
            v57 = 2;
            if (v58 < *(int *)(a1 + 608))
              continue;
          }
          goto LABEL_92;
        }
        v84 = v139;
        v85 = (_QWORD *)(v59 + 528 * v139 + 16);
        v86 = v147;
        v87 = 4 * v57;
        while (1)
        {
          MFS__log_select_Diag(v145, 5, (uint64_t)"Adding parametric segment %d (uttph%d,st%d) unitid %d  offset %d  dur %d\n");
          if ((mfs_SegmentList_Add(a1 + 2208, -1, *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) + v139), v11, *(_DWORD *)(v86 + 24) * *(_DWORD *)(*v85 + v87)) & 0x80000000) != 0)break;
          v86 = v147;
          v11 += *(_DWORD *)(v147 + 24) * *(_DWORD *)(*v85 + v87);
          ++v57;
          v87 += 4;
          if (v67 == v57)
            goto LABEL_90;
        }
      }
    }
LABEL_92:
    v7 = v142;
    *v140 = 1;
    a3 = v147;
    goto LABEL_93;
  }
  v12 = 2229280775;
  v13 = *(unsigned int *)(a1 + 32);
  if ((int)v13 >= 1)
  {
    v14 = 0;
    v15 = *(_QWORD *)(a1 + 24);
    v16 = -1;
    do
    {
      v17 = *(_DWORD *)(v15 + 12);
      if (v17 == 2)
      {
        v14 = v15;
      }
      else if (v17 == 1)
      {
        v16 = *(_DWORD *)(v15 + 44);
      }
      v15 += 1528;
      --v13;
    }
    while (v13);
    if (v16 != -1 && v14)
    {
      MFS__log_select_Diag(v7, 1, (uint64_t)"s32NumFrames as measured in mfsengine.c is %d\n");
      v18 = heap_Calloc(*(_QWORD **)(v7 + 8), v16, 4);
      *(_QWORD *)(a1 + 2648) = v18;
      if (!v18)
        return 2229280778;
      v141 = a4;
      if (v16 >= 1)
      {
        v19 = 0;
        v20 = 0;
        do
        {
          v21 = 0.0;
          if ((*(_BYTE *)(v8 + v19) & 4) != 0)
          {
            v22 = *(float *)(a3 + 48);
            v23 = exp(**(float **)(*(_QWORD *)(v14 + 64) + 8 * v20));
            v21 = *(float *)(a3 + 52) + (float)(v22 * v23);
            ++v20;
          }
          MFS__log_select_Diag(v7, 10, (uint64_t)"At frame %d, model trajectory F0 is %.6f\n");
          *(float *)(*(_QWORD *)(a1 + 2648) + 4 * v19++) = v21;
        }
        while (v16 != v19);
      }
      MFS__FreePStreamParam((_QWORD *)(v14 + 24));
      *v141 = 1;
      v24 = *(unsigned int *)(a1 + 32);
      if ((int)v24 >= 1)
      {
        v25 = *(_DWORD **)(a1 + 24);
        do
        {
          if (!v25[370])
            *v25 = 0;
          v25 += 382;
          --v24;
        }
        while (v24);
      }
      BackupDurations(a1, a2);
      if (!*(_DWORD *)(a1 + 2200))
      {
        v143 = v7;
        MFS__log_select_Diag(v7, 1, (uint64_t)"mfs_ParamGen:: Not skipping second pass\n");
        v146 = *(_QWORD *)(a1 + 1928);
        MFS__log_select_Diag(v146, 1, (uint64_t)"  -> UpdateStateDurations\n");
        *(_DWORD *)(a1 + 624) = 0;
        if (*(int *)(a1 + 608) >= 1)
        {
          v89 = 0;
          v90 = 0;
          do
          {
            v91 = *(_QWORD *)(a1 + 600);
            v92 = v91 + 528 * v89;
            *(_DWORD *)(v92 + 24) = 0;
            v93 = (int *)(v92 + 24);
            if (*a2 < 1)
            {
              v101 = 0;
            }
            else
            {
              v94 = 0;
              v95 = v91 + 528 * v89;
              v96 = (uint64_t *)(v95 + 16);
              v97 = (_DWORD *)(v95 + 4);
              v98 = 2;
              do
              {
                v99 = mfs_UnitSequence_GetTemplateDur(a1 + 2112, *(_QWORD *)(a1 + 1928), v90 + (int)v98 - 2);
                if (v99)
                {
                  v100 = *v96;
                  *(_DWORD *)(*v96 + 4 * v98) = v99;
                }
                else
                {
                  *v97 |= 4u;
                  v100 = *v96;
                  v99 = *(_DWORD *)(*v96 + 4 * v98);
                  v94 = 1;
                }
                v101 = *v93 + v99;
                *v93 = v101;
                ++v98;
                v102 = *a2;
              }
              while (v98 < v102 + 2);
              a3 = v147;
              if (*(_DWORD *)(v147 + 8256) && v94)
              {
                v103 = 0;
                if ((int)v102 >= 1)
                {
                  v104 = 8;
                  do
                  {
                    if (v104 != 12)
                      v103 = *(_DWORD *)(*(_QWORD *)(v91 + 528 * v89 + 328) + v104) + v103 - *(_DWORD *)(v100 + v104);
                    v104 += 4;
                  }
                  while (4 * (v102 + 2) != v104);
                }
                v105 = *(_DWORD *)(v100 + 12);
                if (v105 + v103 < 0 != __OFADD__(v105, v103))
                  v103 = 1 - v105;
                *(_DWORD *)(v100 + 12) = v103 + v105;
                v101 = v103 + *v93;
                *v93 = v101;
                v90 = v90 + v98 - 2;
              }
              else
              {
                v90 = v90 + v98 - 2;
              }
            }
            *(_DWORD *)(a1 + 624) += v101;
            MFS__log_select_Diag(v146, 5, (uint64_t)"syntheval:Phoneme %d has duration %d\n");
            MFS__log_select_Diag(v146, 5, (uint64_t)"At phoneme %d output we have totalframe %d\n");
            ++v89;
          }
          while (v89 < *(int *)(a1 + 608));
        }
        v106 = *(unsigned int *)(a1 + 2272);
        v107 = 0.0;
        if ((int)v106 >= 1)
        {
          v108 = 0;
          v109 = 0;
          v110 = 0;
          v111 = *(_DWORD **)(a1 + 2264);
          do
          {
            if (*v111 == -1)
            {
              v112 = *(_DWORD *)(a3 + 24)
                   * *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 600) + 528 * ((int)v108 / *a2) + 16)
                               + 4 * ((int)v108 % *a2 + 2));
              v110 += v112;
            }
            else
            {
              v112 = v111[3];
            }
            v109 += v112;
            ++v108;
            v111 += 7;
          }
          while (v106 != v108);
          if (v109)
          {
            v107 = (float)v110 / (float)v109;
            if (v107 > 0.89)
              v107 = 1.0;
          }
        }
        v113 = *(unsigned int *)(a1 + 32);
        v7 = v143;
        if ((int)v113 >= 1)
        {
          v114 = 0;
          v115 = *(_QWORD *)(a1 + 24);
          v116 = v115;
          do
          {
            if (!*(_DWORD *)(v115 + 1528 * v114 + 1480))
            {
              v117 = *(unsigned int *)(v115 + 1528 * v114 + 40);
              if ((int)v117 >= 1)
              {
                v118 = v116;
                do
                {
                  *(float *)(v118 + 144) = (float)((float)(1.0 - v107) * *(float *)(v118 + 544))
                                         + (float)(*(float *)(v118 + 144) * v107);
                  v118 += 4;
                  --v117;
                }
                while (v117);
              }
            }
            ++v114;
            v116 += 1528;
          }
          while (v114 != v113);
        }
        if ((*(_DWORD *)(a3 + 8968) - 7) >= 5 && !*(_DWORD *)(a3 + 8328))
        {
          if ((int)v113 >= 1)
          {
            v119 = *(_QWORD *)(a1 + 24);
            do
            {
              *(_DWORD *)(v119 + 16) = *(_DWORD *)(v119 + 1480) == 0;
              v119 += 1528;
              --v113;
            }
            while (v113);
          }
          UpdateStreamDurations((uint64_t *)a1, a2);
          v120 = FetchAndFillInTemplateParameters((unsigned __int8 *)a2, a3, a1, 1);
          if ((v120 & 0x80000000) != 0)
            return v120;
        }
        FreeRemainingStreams(a1);
        if (*(int *)(a1 + 32) >= 1)
        {
          v121 = 0;
          v122 = 24;
          do
          {
            MFS__FreePStreamParam((_QWORD *)(*(_QWORD *)(a1 + 24) + v122));
            ++v121;
            v122 += 1528;
          }
          while (v121 < *(int *)(a1 + 32));
        }
        v120 = ParamGenLT_2(a1, a2, 1u);
        if ((v120 & 0x80000000) != 0)
          return v120;
        if ((*(_DWORD *)(a3 + 8968) - 7) < 5 || *(_DWORD *)(a3 + 8328))
          goto LABEL_29;
        v120 = FetchAndFillInTemplateParameters((unsigned __int8 *)a2, a3, a1, 0);
        if ((v120 & 0x80000000) != 0)
          return v120;
        if (*(int *)(a1 + 32) >= 1)
        {
          v123 = 0;
          v124 = *(_QWORD *)(a1 + 24);
          v125 = 1480;
          do
          {
            if (!*(_DWORD *)(v124 + v125))
            {
              v126 = v125 == 3008 ? v124 + 1552 : v124 + v125 - 1456;
              mlpg_cpy(v126);
              v124 = *(_QWORD *)(a1 + 24);
              v127 = *(_QWORD *)(v124 + v125 - 1344);
              if (v127)
              {
                heap_Free(*(_QWORD **)(v143 + 8), v127);
                v124 = *(_QWORD *)(a1 + 24);
                *(_QWORD *)(v124 + v125 - 1344) = 0;
              }
            }
            ++v123;
            v125 += 1528;
          }
          while (v123 < *(int *)(a1 + 32));
        }
      }
LABEL_29:
      v26 = *(float *)(a3 + 8840);
      v27 = *(_QWORD *)(a1 + 24);
      if (v26 != 1.0)
      {
        v28 = *(unsigned int *)(v27 + 1572);
        v29 = v26 == 0.0 || (int)v28 < 1;
        if (!v29)
        {
          v30 = 0;
          v31 = *(_QWORD *)(v27 + 1592);
          v32 = *(unsigned int *)(v27 + 1568);
          v33 = (float)(v32 - 1);
          v34 = 0.0;
          v35 = 0.0;
          v36 = 0.0;
          v37 = 0.0;
          do
          {
            if ((int)v32 >= 2)
            {
              for (i = 1; i != v32; ++i)
              {
                v37 = v37 + (float)(int)i;
                v39 = *(float *)(*(_QWORD *)(v31 + 8 * v30) + 4 * i);
                v36 = v36 + v39;
                v35 = v35 + (float)(i * i);
                v34 = v34 + (float)((float)(int)i * v39);
              }
            }
            if ((int)v32 >= 2)
            {
              v41 = *(_QWORD *)(v31 + 8 * v30);
              for (j = 1; j != v32; ++j)
              {
                v40 = (float)((float)(v33 * v34) - (float)(v37 * v36))
                    / (float)((float)(v33 * v35) - (float)(v37 * v37));
                *(float *)(v41 + 4 * j) = (float)((float)((float)(v36 - (float)(v40 * v37)) / v33)
                                                + (float)((float)(int)j * v40))
                                        + (float)(v26
                                                * (float)(*(float *)(v41 + 4 * j)
                                                        - (float)((float)((float)(v36 - (float)(v40 * v37)) / v33)
                                                                + (float)((float)(int)j * v40))));
              }
            }
            ++v30;
          }
          while (v30 != v28);
        }
      }
      v43 = *(float *)(a3 + 8844);
      v44 = *(_QWORD *)(v27 + 3120);
      v45 = *(unsigned int *)(v27 + 3100);
      if ((_DWORD)v45)
      {
        if (v43 != 1.0 && v43 != 0.0)
        {
          v46 = (float)(int)v45;
          v47 = 1.0 / (float)(int)v45;
          if ((int)v45 >= 1)
          {
            v48 = 0;
            v49 = 0.0;
            v50 = 0.0;
            v51 = 0.0;
            v52 = 0.0;
            do
            {
              v52 = v52 + (float)(int)v48;
              v53 = **(float **)(v44 + 8 * v48);
              v51 = v51 + v53;
              v50 = v50 + (float)(v48 * v48);
              v49 = v49 + (float)((float)(int)v48++ * v53);
            }
            while (v45 != v48);
            v54 = 1;
LABEL_162:
            if (v54)
            {
              v128 = 0;
              v129 = (float)((float)(v46 * v49) - (float)(v52 * v51)) / (float)((float)(v46 * v50) - (float)(v52 * v52));
              v130 = v47 * (float)(v51 - (float)(v129 * v52));
              do
              {
                **(float **)(v44 + 8 * v128) = (float)(v130 + (float)((float)(int)v128 * v129))
                                             + (float)(v43
                                                     * (float)(**(float **)(v44 + 8 * v128)
                                                             - (float)(v130 + (float)((float)(int)v128 * v129))));
                ++v128;
              }
              while (v45 != v128);
            }
            goto LABEL_165;
          }
          v54 = 0;
LABEL_161:
          v52 = 0.0;
          v51 = 0.0;
          v50 = 0.0;
          v49 = 0.0;
          goto LABEL_162;
        }
      }
      else if (v43 != 1.0 && v43 != 0.0)
      {
        v54 = 0;
        v46 = 0.0;
        v47 = 3.4028e38;
        goto LABEL_161;
      }
LABEL_165:
      FreeRemainingStreams(a1);
      if (*(_QWORD *)(a1 + 2224)
        || (v131 = *(_QWORD *)a1,
            MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"  -> GetParametricSegments\n"),
            v132 = *(_DWORD *)(a1 + 608),
            v132 < 1))
      {
LABEL_93:
        v12 = mfs_SegmentList_Merge((uint64_t *)(a1 + 2248), a1 + 2208, *(_DWORD *)(a3 + 25184), (uint64_t)a2, *(_QWORD *)(a1 + 1928));
        if ((v12 & 0x80000000) == 0)
          MFS__log_select_Diag(v7, 1, (uint64_t)"}\n");
        return v12;
      }
      v133 = 0;
      v134 = 0;
      v12 = 0;
      LODWORD(v135) = *a2;
      v144 = v7;
      do
      {
        if ((int)v135 >= 1)
        {
          v136 = (_QWORD *)(*(_QWORD *)(a1 + 600) + 528 * v133 + 16);
          v137 = 2;
          while (1)
          {
            MFS__log_select_Diag(v131, 5, (uint64_t)"Adding parametric segment %d (uttph%d,st%d) unitid %d  offset %d  dur %d\n");
            v12 = mfs_SegmentList_Add(a1 + 2208, -1, *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) + v133), v134, *(_DWORD *)(a3 + 24) * *(_DWORD *)(*v136 + 4 * v137));
            if ((v12 & 0x80000000) != 0)
              return v12;
            v134 += *(_DWORD *)(a3 + 24) * *(_DWORD *)(*v136 + 4 * v137);
            v135 = *a2;
            v29 = v137++ <= v135;
            if (!v29)
            {
              v132 = *(_DWORD *)(a1 + 608);
              v7 = v144;
              break;
            }
          }
        }
        ++v133;
      }
      while (v133 < v132);
      if ((v12 & 0x80000000) == 0)
        goto LABEL_93;
    }
  }
  return v12;
}

uint64_t BackupDurations(uint64_t result, int *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v2 = *(unsigned int *)(result + 608);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = *(_QWORD *)(result + 600);
    v5 = *a2;
    do
    {
      if ((v5 - 1) <= 0xFFFFFFFC)
      {
        v6 = v4 + 528 * v3;
        v7 = *(_QWORD *)(v6 + 16);
        v8 = *(_QWORD *)(v6 + 328);
        v9 = 2;
        do
        {
          *(_DWORD *)(v8 + 4 * v9) = *(_DWORD *)(v7 + 4 * v9);
          ++v9;
          v5 = *a2;
        }
        while (v9 < (*a2 + 2));
        v2 = *(unsigned int *)(result + 608);
      }
      ++v3;
    }
    while (v3 < v2);
  }
  return result;
}

uint64_t UpdateStreamDurations(uint64_t *a1, int *a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _DWORD *v20;
  BOOL v21;

  v4 = *a1;
  heap_Free(*(_QWORD **)(*a1 + 8), a1[6]);
  a1[6] = 0;
  heap_Free(*(_QWORD **)(v4 + 8), a1[5]);
  a1[5] = 0;
  result = heap_Calloc(*(_QWORD **)(v4 + 8), (*((_DWORD *)a1 + 156) + 1), 1);
  a1[6] = result;
  if (result)
  {
    result = heap_Calloc(*(_QWORD **)(v4 + 8), (*((_DWORD *)a1 + 156) + 1), 4);
    a1[5] = result;
    if (result)
    {
      v6 = *((unsigned int *)a1 + 8);
      if ((int)v6 >= 1)
      {
        v7 = (_DWORD *)(a1[3] + 44);
        do
        {
          if (*(v7 - 7))
            *v7 = 0;
          v7 += 382;
          --v6;
        }
        while (v6);
      }
      v8 = *((_DWORD *)a1 + 152);
      if (v8 >= 1)
      {
        v9 = 0;
        LODWORD(v10) = 0;
        v11 = *a2;
        do
        {
          if (v11 >= 1)
          {
            v12 = a1[75] + 528 * v9;
            v15 = *(_QWORD *)(v12 + 16);
            v13 = (uint64_t *)(v12 + 16);
            v14 = v15;
            v16 = v13 + 37;
            v17 = 2;
            do
            {
              result = *(unsigned int *)(v14 + 4 * v17);
              if ((int)result >= 1)
              {
                v10 = (int)v10;
                v18 = 1;
                do
                {
                  *(_BYTE *)(a1[6] + v10) = *(_BYTE *)(*v16 + v17);
                  *(_DWORD *)(a1[5] + 4 * v10) = *(_DWORD *)(v13[38] + 4 * v17);
                  v19 = *((unsigned int *)a1 + 8);
                  if ((int)v19 >= 1)
                  {
                    v20 = (_DWORD *)a1[3];
                    do
                    {
                      if (v20[4]
                        && (!v20[372] || ((1 << v20[3]) & (unint64_t)*(unsigned __int8 *)(*v16 + v17)) >> v20[3]))
                      {
                        ++v20[11];
                      }
                      v20 += 382;
                      --v19;
                    }
                    while (v19);
                  }
                  ++v10;
                  result = (v18 + 1);
                  v14 = *v13;
                  v21 = v18++ < *(_DWORD *)(*v13 + 4 * v17);
                }
                while (v21);
                v11 = *a2;
              }
              v21 = v17++ <= v11;
            }
            while (v21);
            v8 = *((_DWORD *)a1 + 152);
          }
          ++v9;
        }
        while (v9 < v8);
      }
    }
  }
  return result;
}

uint64_t FetchAndFillInTemplateParameters(unsigned __int8 *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned int TemplateId;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  int *v43;
  uint64_t v44;
  _QWORD *v45;
  int *v46;
  _QWORD *v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t v50;
  float v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  float v55;
  uint64_t v56;
  uint64_t v57;
  float v58;
  uint64_t v59;
  _QWORD *v60;
  float *v61;
  float v62;
  int v64;
  uint64_t i;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int *v69;
  int *v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  float v76;
  uint64_t v77;
  uint64_t v78;
  float v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  unsigned int v88;
  unsigned __int8 *v89;
  unsigned int v90;
  _QWORD *v91;
  _QWORD v92[2];
  int v93;
  _OWORD v94[5];
  _OWORD v95[5];
  _OWORD v96[5];
  uint64_t v97;

  v97 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(a3 + 1928);
  v93 = 0;
  memset(v95, 0, sizeof(v95));
  memset(v94, 0, sizeof(v94));
  MFS__log_select_Diag(v8, 1, (uint64_t)"  -> FetchAndFillInTemplateParameters\n");
  if (*(_DWORD *)(a2 + 8328))
    return 2229280769;
  v10 = a2;
  v89 = a1;
  memset(v96, 0, sizeof(v96));
  v11 = *(unsigned int *)(a3 + 32);
  v85 = a2;
  if ((int)v11 >= 1)
  {
    bzero(v95, 8 * v11);
    bzero(v94, 8 * v11);
    v10 = a2;
    v12 = 0;
    v13 = a2 + 264;
    v14 = 1480;
    do
    {
      v15 = *(_QWORD *)(a3 + 24);
      if (!*(_DWORD *)(v15 + v14))
      {
        if (a4 == 1)
        {
          cstdlib_memset((void *)(v15 + v14 - 936), 0, 0xC8uLL);
          v16 = (unsigned int *)(v15 + v14 - 1436);
          *((_QWORD *)v95 + v12) = MFS__int32_ccalloc(*(_QWORD **)(v8 + 8), *v16, *(_DWORD *)(v13 + 4 * v12));
          v17 = MFS__int32_ccalloc(*(_QWORD **)(v8 + 8), *v16, *(_DWORD *)(v13 + 4 * v12));
          v10 = a2;
          *((_QWORD *)v94 + v12) = v17;
        }
        v18 = v15 + v14;
        v19 = (uint64_t *)(v18 - 1344);
        v20 = *(_QWORD *)(v18 - 1344);
        if (v20)
        {
          heap_Free(*(_QWORD **)(v8 + 8), v20);
          v10 = a2;
          *v19 = 0;
        }
        v21 = (_DWORD *)(v18 - 1436);
        v22 = *v21;
        if ((int)v22 >= 1)
        {
          v23 = heap_Calloc(*(_QWORD **)(v8 + 8), v22, 1);
          v10 = a2;
          *v19 = v23;
        }
        *v21 = 0;
        LODWORD(v11) = *(_DWORD *)(a3 + 32);
      }
      ++v12;
      v14 += 1528;
    }
    while (v12 < (int)v11);
  }
  v83 = v8;
  v24 = *(_DWORD *)(a3 + 608);
  if (v24 < 1)
  {
    v82 = 0;
  }
  else
  {
    v25 = 0;
    v82 = 0;
    v26 = 0;
    LODWORD(v27) = *(_DWORD *)v89;
    do
    {
      if ((int)v27 >= 1)
      {
        v81 = v25;
        v28 = *(_QWORD *)(a3 + 600) + 528 * v25;
        v86 = (_QWORD *)(v28 + 16);
        v87 = v28;
        v29 = (_QWORD *)(v28 + 312);
        v30 = 2;
        do
        {
          v90 = v26;
          TemplateId = mfs_UnitSequence_GetTemplateId(a3 + 2112, v26);
          if (TemplateId
            && (v92[0] = 0,
                v92[1] = 0,
                v91 = v92,
                v88 = TemplateId,
                mfs_getUnitDataFromMfsData(v89, TemplateId, (uint64_t *)&v91),
                *(_DWORD *)(*v86 + 4 * v30) == *((unsigned __int16 *)v91 + 4)))
          {
            result = mfs_ParamMap_MapSection(v8, (uint64_t)v89, a3, v88, (uint64_t)v91, (uint64_t)v96, &v93, v32);
            if ((result & 0x80000000) != 0)
              return result;
            v82 = result;
            v84 = *(_QWORD *)a3;
            mfs_GetMsgName((uint64_t)v89, v88);
            MFS__log_select_Diag(v84, 3, (uint64_t)"%d mapping %s msg, offset %u dur %hu %d\n");
            v33 = v93;
            if (v93 >= 1)
            {
              v34 = 0;
              LODWORD(v35) = *(_DWORD *)(a3 + 32);
              do
              {
                if ((int)v35 >= 1)
                {
                  v36 = 0;
                  v37 = 544;
                  do
                  {
                    v38 = *(_QWORD *)(a3 + 24);
                    if (*(_DWORD *)(v38 + 1528 * v36 + 1484))
                    {
                      v39 = v85 + 4 * v36;
                      v40 = *(_DWORD *)(v39 + 264);
                      v41 = *(_QWORD *)(a3 + 24);
                      if (v40 >= 1)
                      {
                        v42 = 0;
                        v43 = (int *)(v39 + 264);
                        v44 = v38 + 1528 * v36;
                        v45 = (_QWORD *)(v44 + 96);
                        v46 = (int *)(v44 + 44);
                        v47 = (_QWORD *)(v44 + 64);
                        v48 = (_QWORD *)(v44 + 104);
                        v49 = (_QWORD *)(v44 + 136);
                        v50 = 4 * v34 * v40;
                        do
                        {
                          if (a4 == 1)
                          {
                            v51 = *(float *)(*((_QWORD *)v96 + v36) + v50 + 4 * v42);
                            v52 = *v46;
                            *(float *)(*(_QWORD *)(*((_QWORD *)v94 + v36) + 8 * v52) + 4 * v42) = v51;
                            *(float *)(v38 + v37 + 4 * v42) = v51 + *(float *)(v38 + v37 + 4 * v42);
                            *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v95 + v36) + 8 * v52) + 4 * v42) = 1065353216;
                          }
                          else
                          {
                            v53 = *v46;
                            v54 = *(_QWORD *)(*v45 + 8 * v53);
                            *(_DWORD *)(v54 + 4 * v42) = 0;
                            v55 = *(float *)(*((_QWORD *)v96 + v36) + v50 + 4 * v42) + 0.0;
                            *(float *)(v54 + 4 * v42) = v55;
                            *(float *)(v54 + 4 * v42) = v55
                                                      + (float)(*(float *)(*(_QWORD *)(*v47 + 8 * v53) + 4 * v42) * 0.0);
                            *(float *)(*(_QWORD *)(*v48 + 8 * v53) + 4 * v42) = *(float *)(*(_QWORD *)(*v48 + 8 * v53)
                                                                                         + 4 * v42)
                                                                              * 100000.0;
                            *(_BYTE *)(*v49 + v53) = 1;
                            v40 = *v43;
                          }
                          ++v42;
                        }
                        while (v42 < v40);
                        v41 = *(_QWORD *)(a3 + 24);
                      }
                      ++*(_DWORD *)(v38 + 1528 * v36 + 44);
                    }
                    else
                    {
                      v41 = *(_QWORD *)(a3 + 24);
                    }
                    if (*(_DWORD *)(v41 + 1528 * v36 + 1488)
                      && ((1 << v36) & (unint64_t)*(unsigned __int8 *)(*v29 + v30)) >> v36)
                    {
                      v56 = *(int *)(v85 + 4 * v36 + 264) * (uint64_t)v34;
                      v57 = *((_QWORD *)v96 + v36);
                      v58 = *(float *)(v57 + 4 * v56);
                      if (v58 != -1.0e10)
                      {
                        v59 = *(int *)(v38 + 1528 * v36 + 44);
                        if (a4 == 1)
                        {
                          **(float **)(*((_QWORD *)v94 + v36) + 8 * v59) = v58;
                          *(float *)(v38 + 1528 * v36 + 544) = v58 + *(float *)(v38 + 1528 * v36 + 544);
                          **(_DWORD **)(*((_QWORD *)v95 + v36) + 8 * v59) = 1065353216;
                        }
                        else
                        {
                          v60 = (_QWORD *)(v38 + 1528 * v36);
                          v61 = *(float **)(v60[12] + 8 * v59);
                          *v61 = 0.0;
                          v62 = (float)(**(float **)(v60[8] + 8 * v59) * 0.0) + 0.0;
                          *v61 = v62;
                          *v61 = v62 + *(float *)(v57 + 4 * v56);
                          *(_BYTE *)(v60[17] + v59) = 1;
                        }
                      }
                      ++*(_DWORD *)(v38 + 1528 * v36 + 44);
                    }
                    ++v36;
                    v35 = *(int *)(a3 + 32);
                    v37 += 1528;
                  }
                  while (v36 < v35);
                  v33 = v93;
                }
                ++v34;
              }
              while (v34 < v33);
            }
            mfs_ParamMap_UnMapSection(a3);
          }
          else
          {
            FillInDuration(a3, v87, v30);
          }
          v26 = v90 + 1;
          v27 = *(int *)v89;
        }
        while (v30++ <= v27);
        v24 = *(_DWORD *)(a3 + 608);
        v10 = v85;
        v25 = v81;
      }
      ++v25;
    }
    while (v25 < v24);
  }
  if (a4 == 1)
  {
    v64 = *(_DWORD *)(a3 + 32);
    if (v64 >= 1)
    {
      for (i = 0; i < v64; ++i)
      {
        v66 = *(_QWORD *)(a3 + 24);
        if (!*(_DWORD *)(v66 + 1528 * i + 1480))
        {
          v67 = v10 + 4 * i;
          if (*(int *)(v67 + 264) >= 1)
          {
            v68 = 0;
            v69 = (int *)(v67 + 264);
            v70 = (int *)(v66 + 1528 * i + 44);
            do
            {
              v93 = 0;
              v71 = *v70;
              if (*v70 < 1)
              {
                v76 = 0.0;
              }
              else
              {
                v72 = 0;
                v73 = 0;
                v74 = *((_QWORD *)v95 + i);
                do
                {
                  if (*(float *)(*(_QWORD *)(v74 + 8 * v73) + 4 * v68) == 1.0)
                  {
                    v93 = ++v72;
                    v71 = *v70;
                  }
                  ++v73;
                }
                while (v73 < v71);
                if (v72)
                {
                  *(float *)(v66 + 1528 * i + 4 * v68 + 544) = *(float *)(v66 + 1528 * i + 4 * v68 + 544) / (float)v72;
                  v75 = v72;
                }
                else
                {
                  v75 = 0;
                }
                if (v71 < 1)
                {
                  v76 = 0.0;
                  if (!v72)
                    goto LABEL_74;
                }
                else
                {
                  v77 = 0;
                  v78 = 8 * v71;
                  v76 = 0.0;
                  do
                  {
                    if (*(float *)(*(_QWORD *)(*((_QWORD *)v95 + i) + v77) + 4 * v68) == 1.0)
                    {
                      v79 = *(float *)(*(_QWORD *)(*((_QWORD *)v94 + i) + v77) + 4 * v68)
                          - *(float *)(v66 + 1528 * i + 4 * v68 + 544);
                      v76 = v76 + (float)(v79 * v79);
                    }
                    v77 += 8;
                  }
                  while (v78 != v77);
                  if (!v72)
                    goto LABEL_74;
                }
                v76 = v76 / (float)v75;
              }
LABEL_74:
              v80 = v66 + 1528 * i + 4 * v68;
              *(float *)(v80 + 544) = v76;
              MFS__log_select_Diag(*(_QWORD *)a3, 2, (uint64_t)"Mod(%d) dim(%d) frames(%d) gv_m(%f) <- gv_t(%f)\n");
              *(_DWORD *)(v80 + 144) = *(_DWORD *)(v80 + 544);
              *(float *)(v80 + 344) = *(float *)(v80 + 344) * 0.001;
              ++v68;
            }
            while (v68 < *v69);
          }
          MFS__int32_free(*(_QWORD **)(v83 + 8), *((uint64_t **)v95 + i));
          MFS__int32_free(*(_QWORD **)(v83 + 8), *((uint64_t **)v94 + i));
          v64 = *(_DWORD *)(a3 + 32);
          v10 = v85;
        }
      }
    }
  }
  return v82;
}

uint64_t FreeRemainingStreams(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"--- FreeRemainingStreams -\n");
  if (*(int *)(a1 + 32) >= 1)
  {
    v2 = 0;
    v3 = 24;
    do
    {
      MFS__FreePStreamSM(*(_QWORD *)(a1 + 24) + v3);
      ++v2;
      v3 += 1528;
    }
    while (v2 < *(int *)(a1 + 32));
  }
  return MFS__log_select_Diag(*(_QWORD *)a1, 1, (uint64_t)"--- FreeRemainingStreams +\n");
}

uint64_t FillInDuration(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;

  v3 = *(unsigned int *)(result + 32);
  if ((int)v3 >= 1)
  {
    v4 = 0;
    v5 = *(_DWORD **)(result + 24);
    do
    {
      if (v5[371]
        || v5[372] && ((1 << v4) & (unint64_t)*(unsigned __int8 *)(*(_QWORD *)(a2 + 312) + a3)) >> v4)
      {
        v5[11] += *(_DWORD *)(*(_QWORD *)(a2 + 16) + 4 * a3);
      }
      ++v4;
      v5 += 382;
    }
    while (v3 != v4);
  }
  return result;
}

uint64_t MFS__InitTreeSet(int a1, void *__b)
{
  cstdlib_memset(__b, 0, 0xD0uLL);
  return 0;
}

void *MFS__DeInitTreeSet(void *result, char *__b)
{
  uint64_t v3;
  uint64_t i;
  uint64_t v5;

  if (__b)
  {
    v3 = (uint64_t)result;
    for (i = 104; i != 184; i += 8)
    {
      v5 = *(_QWORD *)&__b[i];
      if (v5)
        heap_Free(*(_QWORD **)(v3 + 8), v5);
    }
    return cstdlib_memset(__b, 0, 0xD0uLL);
  }
  return result;
}

uint64_t MFS__LoadTreesFile(uint64_t a1, uint64_t a2, int a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v12;
  _WORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  unsigned __int16 v30;

  v8 = a1;
  v30 = 0;
  v9 = *a4;
  if (a4[4] - v9 >= 8 && *(_BYTE *)(*((_QWORD *)a4 + 1) + v9) == 48)
  {
    *a4 = v9 + 2;
    v12 = a3;
    v13 = (_WORD *)(a2 + 2 * a3 + 184);
    if (MFS__xfread_BET3(v13, 2u, 1, a4) == 1
      && MFS__xfread_BET3(&v30, 2u, 1, a4) == 1
      && MFS__xfread_BET3((void *)(a2 + 2 * v12), 2u, 1, a4) == 1)
    {
      v14 = MFS__xfread2ptr_BET3((_QWORD *)(a2 + 8 * v12 + 24), 1u, v30, a4);
      if (v14 == v30)
      {
        if ((*a4 & 1) != 0)
          ++*a4;
        v15 = heap_Calloc(*(_QWORD **)(v8 + 8), 16, (unsigned __int16)*v13);
        v21 = a2 + 8 * v12;
        *(_QWORD *)(v21 + 104) = v15;
        v22 = (uint64_t *)(v21 + 104);
        if (!v15)
        {
          MFS__log_select_Error(v8, 55000, (uint64_t)"LoadTreesFile : out of memory for type %s\n", v16, v17, v18, v19, v20);
          return 2229280778;
        }
        if (!*v13)
          return 0;
        v23 = 0;
        v24 = 0;
        while (MFS__xfread_BET3((void *)(v15 + v23), 2u, 1, a4) == 1)
        {
          if (MFS__xfread_BET3((void *)(*v22 + v23 + 2), 2u, 1, a4) != 1)
            break;
          v25 = MFS__xfread2ptr_BET3((_QWORD *)(*v22 + v23 + 8), 2u, 3 * *(unsigned __int16 *)(*v22 + v23 + 2), a4);
          v15 = *v22;
          if (v25 != 3 * *(unsigned __int16 *)(*v22 + v23 + 2))
            break;
          v26 = 0;
          ++v24;
          v23 += 16;
          if (v24 >= (unsigned __int16)*v13)
            return v26;
        }
        v26 = 2229280772;
        v27 = "LoadTreesFile : corrupt tree nodes for type %s, state %u\n";
        a1 = v8;
        v28 = 55015;
      }
      else
      {
        v26 = 2229280772;
        v27 = "LoadTreesFile : corrupt tree questions for type %s\n";
        a1 = v8;
        v28 = 55013;
      }
    }
    else
    {
      v26 = 2229280772;
      v27 = "LoadTreesFile : corrupt tree header for type %s\n";
      a1 = v8;
      v28 = 55012;
    }
  }
  else
  {
    v26 = 2229280772;
    v27 = "LoadTreesFile : invalid tree data version for type %s\n";
    v28 = 55011;
  }
  MFS__log_select_Error(a1, v28, (uint64_t)v27, (uint64_t)a4, a5, a6, a7, a8);
  return v26;
}

uint64_t MFS__TreeSearch(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  int v15;
  unsigned __int8 v16;
  unsigned int v17;
  BOOL v18;
  uint64_t v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;

  LOWORD(v5) = 0;
  v6 = a3 + 8 * a4;
  v7 = *(_QWORD *)(v6 + 24);
  v8 = *(_QWORD *)(*(_QWORD *)(v6 + 104) + 16 * a5 + 8);
  v9 = a2 + 2;
  v10 = a2 + 1;
  while (2)
  {
    v11 = -(uint64_t)(__int16)v5;
    v12 = (unsigned __int16 *)(v8 + 6 * (int)v11);
    v13 = (unsigned __int8 *)(v7 + *v12);
    v14 = *v13;
    v15 = v13[1];
    v5 = v12[1];
    switch(*v13)
    {
      case 0xFCu:
        if (a2 < 2)
          goto LABEL_20;
        v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + (a2 - 2));
        if (v13[1])
          goto LABEL_24;
        goto LABEL_39;
      case 0xFDu:
        if (a2 < 1)
          goto LABEL_20;
        v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + (a2 - 1));
        if (v13[1])
          goto LABEL_24;
        goto LABEL_39;
      case 0xFEu:
        if ((int)v10 >= *(__int16 *)(a1 + 10))
          goto LABEL_20;
        v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v10);
        if (v13[1])
          goto LABEL_24;
        goto LABEL_39;
      case 0xFFu:
        if ((int)v9 >= *(__int16 *)(a1 + 10))
        {
LABEL_20:
          v16 = -1;
          if (v13[1])
            goto LABEL_24;
        }
        else
        {
          v16 = *(_BYTE *)(*(_QWORD *)(a1 + 32) + v9);
          if (v13[1])
            goto LABEL_24;
        }
        goto LABEL_39;
      default:
        if ((_DWORD)v14 == 3)
        {
          v17 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 1784) + 2 * a2);
          v18 = v17 > 0x19;
          v16 = 10 * v17;
          if (v18)
            v16 = -1;
          if (!v13[1])
            goto LABEL_39;
        }
        else
        {
          v19 = *(_QWORD *)(a1 + 8 * v14 + 16);
          if (!v19)
            goto LABEL_39;
          v16 = *(_BYTE *)(v19 + a2);
          if (!v13[1])
            goto LABEL_39;
        }
LABEL_24:
        v20 = v13 + 2;
        if (v15 == 255)
        {
          if (*v20 <= v16 && v20[1] >= v16)
            goto LABEL_30;
        }
        else
        {
          v21 = v15 - 1;
          if (v21)
          {
            v22 = 0;
            while (1)
            {
              v23 = v21 + v22;
              if (v21 + v22 < 0 != __OFADD__(v21, v22))
                ++v23;
              v24 = v23 >> 1;
              v25 = v20[v24];
              if (v25 == v16)
                break;
              if (v16 < v25)
                v21 = v24 - 1;
              else
                v22 = v24 + 1;
              if (v22 > v21)
                goto LABEL_39;
            }
LABEL_30:
            v5 = *(unsigned __int16 *)(v8 + 6 * (int)v11 + 4);
            goto LABEL_39;
          }
          if (*v20 == v16)
            goto LABEL_30;
        }
LABEL_39:
        if ((v5 & 0x8000) != 0)
          continue;
        return v5;
    }
  }
}

uint64_t mlpg_cpy(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *(unsigned int *)(result + 16);
  if ((int)v1 >= 1)
  {
    v2 = 0;
    v3 = *(unsigned int *)(result + 20);
    do
    {
      if ((int)v3 >= 1)
      {
        v4 = 0;
        v5 = *(_QWORD *)(result + 112);
        do
        {
          if (v5)
          {
            if (*(_BYTE *)(v5 + v4) == 1)
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8 * v4) + 4 * v2) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 72) + 8 * v4)
                                                                                               + 4 * v2);
          }
          ++v4;
        }
        while (v3 != v4);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

float mlpg(uint64_t a1, int a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  float **v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  uint64_t v16;
  uint64_t i;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  int v25;
  uint64_t v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  float v31;
  float *v32;
  float v33;
  uint64_t v34;
  float *v35;
  uint64_t v36;
  uint64_t v37;
  float **v38;
  uint64_t v39;
  uint64_t v40;
  float v41;
  float *v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  float **v48;
  uint64_t v49;
  uint64_t v50;
  float *v51;
  float v52;
  float *v53;
  uint64_t j;
  float v55;
  uint64_t v56;
  uint64_t v57;
  float v58;
  float result;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  float v63;
  uint64_t v64;
  float v65;
  uint64_t v66;
  uint64_t v67;
  float **v68;

  v4 = *(unsigned int *)(a1 + 20);
  if ((int)v4 <= 0)
  {
    v9 = *(float ***)(a1 + 96);
    LODWORD(v11) = *(_DWORD *)(a1 + 24);
  }
  else
  {
    v5 = 0;
    v6 = a2;
    v8 = *(_QWORD *)(a1 + 72);
    v7 = *(_QWORD *)(a1 + 80);
    v9 = *(float ***)(a1 + 96);
    v10 = *(_QWORD *)(a1 + 104);
    v11 = *(unsigned int *)(a1 + 24);
    v12 = *(unsigned int **)(a1 + 32);
    v13 = *v12;
    v66 = v13;
    v67 = a2;
    v68 = v9;
    do
    {
      v14 = *(_QWORD *)(v7 + 8 * v5);
      *(float *)(v10 + 4 * v5) = *(float *)(v14 + 4 * v6) * *(float *)(*(_QWORD *)(v8 + 8 * v5) + 4 * v6);
      v15 = v9[v5];
      *v15 = *(float *)(v14 + 4 * v6);
      if ((int)v11 >= 2)
      {
        bzero(v15 + 1, 4 * (v11 - 1));
        v13 = v66;
        v6 = v67;
        v9 = v68;
      }
      if ((int)v13 >= 2)
      {
        v16 = *((_QWORD *)v12 + 1);
        for (i = 1; i != v13; ++i)
        {
          v18 = *(int **)(v16 + 8 * i);
          v19 = *v18;
          v20 = v18[1];
          if ((int)v19 <= (int)v20)
          {
            v21 = -4 * v19;
            v22 = -v19;
            do
            {
              if (v19 + v5 < v4)
              {
                v23 = *(_QWORD *)(*((_QWORD *)v12 + 2) + 8 * i);
                v24 = *(float *)(v23 - 4 * v19);
                if (v24 != 0.0)
                {
                  v25 = a2 + *(_DWORD *)(a1 + 16) * i;
                  v26 = 8 * (v19 + v5);
                  v27 = v24 * *(float *)(*(_QWORD *)(v7 + v26) + 4 * v25);
                  *(float *)(v10 + 4 * v5) = *(float *)(v10 + 4 * v5)
                                           + (float)(v27 * *(float *)(*(_QWORD *)(v8 + v26) + 4 * v25));
                  if ((int)v11 >= 1)
                  {
                    v28 = 0;
                    v29 = v23 + v21;
                    do
                    {
                      v30 = v22 + v28 <= v20 && v28 < (uint64_t)(v4 - v5);
                      if (v30)
                      {
                        v31 = *(float *)(v29 + 4 * v28);
                        if (v31 != 0.0)
                          v15[v28] = v15[v28] + (float)(v27 * v31);
                      }
                      ++v28;
                    }
                    while (v11 != v28);
                  }
                }
              }
              ++v19;
              v21 -= 4;
              --v22;
            }
            while ((_DWORD)v20 + 1 != (_DWORD)v19);
          }
        }
      }
      ++v5;
    }
    while (v5 != v4);
  }
  v32 = *v9;
  v33 = sqrtf(**v9);
  **v9 = v33;
  if ((int)v11 >= 2)
  {
    v34 = v11 - 1;
    v35 = v32 + 1;
    do
    {
      *v35 = *v35 / v33;
      ++v35;
      --v34;
    }
    while (v34);
  }
  if ((int)v4 <= 1)
  {
    v53 = *(float **)(a1 + 88);
    *v53 = **(float **)(a1 + 104) / v33;
  }
  else
  {
    v36 = 0;
    v37 = 1;
    v38 = v9;
    do
    {
      if ((int)v11 < 2)
      {
        *v9[v37] = sqrtf(*v9[v37]);
      }
      else
      {
        v39 = v36;
        v40 = 1;
        do
        {
          if ((v39 & 0x8000000000000000) == 0)
          {
            v41 = v9[v39][v40];
            *v9[v37] = *v9[v37] - (float)(v41 * v41);
          }
          ++v40;
          --v39;
        }
        while (v11 != v40);
        v42 = v9[v37];
        v43 = sqrtf(*v42);
        *v42 = v43;
        v44 = *(unsigned int *)(*(_QWORD *)(a1 + 32) + 32);
        v45 = 1;
        do
        {
          v46 = v45 + 1;
          if ((int)v44 > 0)
          {
            v47 = v45;
            v48 = v38;
            v49 = v44;
            do
            {
              if (v45 != (_DWORD)v11 - 1)
                v42[v45] = v42[v45] - (float)((*v48)[v47] * (*v48)[v46]);
              --v47;
              --v48;
              --v49;
            }
            while (v49);
          }
          v42[v45] = v42[v45] / v43;
          ++v45;
        }
        while (v46 != v11);
      }
      ++v37;
      ++v36;
      ++v38;
    }
    while (v37 != v4);
    v50 = 0;
    v51 = *(float **)(a1 + 104);
    v52 = *v51 / *v32;
    v53 = *(float **)(a1 + 88);
    *v53 = v52;
    for (j = 1; j != v4; ++j)
    {
      v55 = 0.0;
      if ((int)v11 >= 2)
      {
        v56 = v50;
        v57 = 1;
        do
        {
          if ((v56 & 0x8000000000000000) == 0)
          {
            v58 = v9[v56][v57];
            if (v58 != 0.0)
              v55 = v55 + (float)(v58 * v53[v56]);
          }
          ++v57;
          --v56;
        }
        while (v11 != v57);
      }
      v53[j] = (float)(v51[j] - v55) / *v9[j];
      ++v50;
    }
  }
  result = v53[(int)v4 - 1] / *v9[(int)v4 - 1];
  v60 = *(_QWORD *)(a1 + 40);
  *(float *)(*(_QWORD *)(v60 + 8 * ((int)v4 - 1)) + 4 * a2) = result;
  if ((int)v4 >= 2)
  {
    v61 = (v4 - 2);
    v62 = v60 + 8 * v61;
    do
    {
      v63 = 0.0;
      if ((int)v11 >= 2)
      {
        v64 = 1;
        do
        {
          if (v61 + v64 < (uint64_t)v4)
          {
            v65 = v9[v61][v64];
            if (v65 != 0.0)
              v63 = v63 + (float)(v65 * *(float *)(*(_QWORD *)(v62 + 8 * v64) + 4 * a2));
          }
          ++v64;
        }
        while (v11 != v64);
      }
      result = (float)(v53[v61] - v63) / *v9[v61];
      *(float *)(*(_QWORD *)(v60 + 8 * v61) + 4 * a2) = result;
      v62 -= 8;
      v30 = v61-- <= 0;
    }
    while (!v30);
  }
  return result;
}

uint64_t dummy_solver(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(unsigned int *)(result + 16);
  if ((int)v1 >= 1)
  {
    v2 = 0;
    v3 = *(unsigned int *)(result + 20);
    do
    {
      if ((int)v3 >= 1)
      {
        v4 = *(uint64_t **)(result + 40);
        v5 = v3;
        do
        {
          v6 = *v4++;
          *(_DWORD *)(v6 + 4 * v2) = 0;
          --v5;
        }
        while (v5);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

void mlpg_c(uint64_t a1, int a2)
{
  double v4;

  if (*(int *)(a1 + 20) < 2)
  {
    MFS__meancpy(a1);
  }
  else
  {
    *(float *)&v4 = MFS__ConstW_Calc_R_and_r(a1, a2);
    MFS__ConstW_Cholesky(a1, v4);
    MFS__ConstW_Cholesky_forward(a1);
    MFS__ConstW_Cholesky_backward(a1, a2);
  }
}

uint64_t MFS__select_bet3_FeatureExtractObjOpen(_WORD *a1, int a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t inited;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v15;
  uint64_t v16;

  v16 = 0;
  *a5 = 0;
  inited = InitRsrcFunction(a1, a2, &v16);
  if ((inited & 0x80000000) == 0)
  {
    v9 = (_QWORD *)heap_Calloc(*(_QWORD **)(v16 + 8), 1, 24);
    if (v9)
    {
      *v9 = v16;
      v9[1] = a3;
      v9[2] = a4;
      *a5 = v9;
    }
    else
    {
      log_OutPublic(*(_QWORD *)(v16 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v10, v11, v12, v13, v15);
      return 2229280778;
    }
  }
  return inited;
}

uint64_t MFS__select_bet3_FeatureExtractObjClose(uint64_t a1)
{
  if (a1)
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), a1);
  return 0;
}

uint64_t MFS__select_bet3_FeatureExtractProcessStart(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *__b, _DWORD *a6)
{
  char *__s1;

  __s1 = 0;
  cstdlib_memset(__b, 0, 0xE48uLL);
  *__b = a2;
  if ((paramc_ParamGetStr(*(_QWORD *)(*a1 + 40), (uint64_t)"voicemodel", &__s1) & 0x80000000) == 0
    && !cstdlib_strcmp(__s1, "bet3"))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(a1[2] + 272))(a3, a4, 128, 3, 0, 0);
  }
  return usextract_ProcessStart(*a1, (uint64_t)"SELECT_BET3", a1[2], a3, a4, (uint64_t)__b, a6);
}

uint64_t MFS__select_bet3_FeatureExtractProcess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, uint64_t a10, uint64_t *a11, _DWORD *a12)
{
  uint64_t v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t i;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  unsigned int v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int GenericFeatureLayers;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  const char **v58;
  size_t v59;
  unsigned int Index;
  unsigned int v61;
  uint64_t v62;
  const char *v63;
  int v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t j;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unsigned int v80;
  unint64_t v81;
  uint64_t v82;
  _OWORD *v83;
  _OWORD *v84;
  __int128 v85;
  _DWORD *v86;
  _OWORD *v87;
  _OWORD *v88;
  __int128 v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  char v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  uint64_t result;
  unsigned int v101;
  int v102;
  int v103;
  unsigned int v104;
  int v105;
  uint64_t v107;
  uint64_t v108;
  char v109;
  char v110;
  unsigned int v111[4];
  uint64_t v112;

  v112 = *MEMORY[0x24BDAC8D0];
  v15 = *a1;
  if (a11)
    v16 = a12 == 0;
  else
    v16 = 1;
  v17 = !v16;
  if (!v16)
  {
    *a11 = 0;
    *a12 = 0;
  }
  v18 = 0;
  v19 = 0;
  v20 = *(__int16 *)(a10 + 10);
  do
  {
    if (*(_BYTE *)(*(_QWORD *)a10 + 2748 + v18) == 1)
      ++v19;
    ++v18;
  }
  while (v18 != 218);
  v21 = heap_Calloc(*(_QWORD **)(v15 + 8), (v19 * v20), 1);
  if (!v21)
    goto LABEL_119;
  v26 = v21;
  v105 = v17;
  v107 = a4;
  v108 = a3;
  for (i = 0; i != 218; ++i)
  {
    v28 = *(_QWORD *)a10;
    v29 = *(unsigned __int8 *)(*(_QWORD *)a10 + i + 2748);
    if (*(_BYTE *)(*(_QWORD *)a10 + i + 2748))
    {
      if (v29 == 2)
      {
        v30 = heap_Calloc(*(_QWORD **)(v15 + 8), v20, 2);
        *(_QWORD *)(a10 + 8 * i + 1760) = v30;
        if (!v30)
          goto LABEL_43;
      }
      else if (v29 == 1)
      {
        *(_QWORD *)(a10 + 8 * i + 16) = v26;
        v26 += v20;
      }
      else
      {
        switch((int)i)
        {
          case '.':
            v31 = heap_Calloc(*(_QWORD **)(v15 + 8), v20, 9);
            *(_QWORD *)(a10 + 3560) = v31;
            if (!v31)
              goto LABEL_43;
            continue;
          case '/':
          case '0':
          case '1':
          case '2':
          case '7':
            goto LABEL_28;
          case '3':
            v33 = *(unsigned __int16 *)(v28 + 2966);
            if (v33)
            {
              v34 = heap_Calloc(*(_QWORD **)(v15 + 8), (v33 * v20), 4);
              *(_QWORD *)(a10 + 3568) = v34;
              if (!v34)
                goto LABEL_43;
            }
            continue;
          case '4':
            v35 = *(unsigned __int16 *)(v28 + 2966);
            if (v35)
            {
              v36 = heap_Calloc(*(_QWORD **)(v15 + 8), (v35 * v20), 4);
              *(_QWORD *)(a10 + 3576) = v36;
              if (!v36)
                goto LABEL_43;
            }
            continue;
          case '5':
            v37 = *(unsigned __int16 *)(v28 + 3360);
            if (v37)
            {
              v38 = heap_Calloc(*(_QWORD **)(v15 + 8), (v37 * v20), 4);
              *(_QWORD *)(a10 + 3584) = v38;
              if (!v38)
                goto LABEL_43;
            }
            continue;
          case '6':
            v39 = *(unsigned __int16 *)(v28 + 3360);
            if (v39)
            {
              v40 = heap_Calloc(*(_QWORD **)(v15 + 8), (v39 * v20), 4);
              *(_QWORD *)(a10 + 3592) = v40;
              if (!v40)
                goto LABEL_43;
            }
            continue;
          case '8':
            v41 = *(unsigned __int16 *)(v28 + 2966);
            if (v41)
            {
              v42 = heap_Calloc(*(_QWORD **)(v15 + 8), (v41 * v20), 1);
              *(_QWORD *)(a10 + 3600) = v42;
              if (!v42)
                goto LABEL_43;
            }
            continue;
          default:
            if ((_DWORD)i == 24)
            {
              v32 = heap_Calloc(*(_QWORD **)(v15 + 8), v20, 8);
              *(_QWORD *)(a10 + 3552) = v32;
              if (!v32)
              {
LABEL_43:
                v43 = -2065686518;
                log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v22, v23, v24, v25, v101);
                goto LABEL_44;
              }
            }
            else
            {
LABEL_28:
              log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"SELECT_BET3", 55007, (uint64_t)"%s%u", v22, v23, v24, v25, "feature");
            }
            break;
        }
      }
    }
  }
  v44 = *(unsigned __int16 *)(*(_QWORD *)a10 + 3578);
  if (v44 >= 4)
  {
    log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, (uint64_t)"Invalid number of states per phoneme", v22, v23, v24, v25, "%s%u");
    v43 = -2065686513;
    goto LABEL_122;
  }
  v45 = (void *)heap_Calloc(*(_QWORD **)(v15 + 8), v44 * v20, 4);
  *(_QWORD *)(a10 + 3608) = v45;
  if (!v45)
  {
    v43 = -2065686518;
    log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v46, v47, v48, v49, v101);
LABEL_122:
    if (!a12)
      goto LABEL_127;
    goto LABEL_123;
  }
  if (*(unsigned __int16 *)(*(_QWORD *)a10 + 3578) * (_DWORD)v20)
    memset(v45, 255, 4 * *(unsigned __int16 *)(*(_QWORD *)a10 + 3578) * v20);
  GenericFeatureLayers = usextract_allocateGenericFeatureLayers(*a1, (uint64_t)"SELECT_BET3", (_QWORD *)a10, v20);
  if (GenericFeatureLayers < 0)
  {
    v43 = GenericFeatureLayers;
    if (!a12)
      goto LABEL_127;
    goto LABEL_123;
  }
  v43 = usextract_Process(*a1, (uint64_t)"SELECT_BET3", a1[2], a3, a4, a10, v51, v52);
  if (v43 < 0)
    goto LABEL_122;
  if (*(_QWORD *)(a10 + 3504))
  {
    v53 = **(const char ***)(*(_QWORD *)a10 + 3336);
    if (v53)
    {
      v54 = 0;
      v55 = 1;
      do
      {
        v56 = cstdlib_strncmp(v53, "INNO_", 5uLL);
        v57 = *(_QWORD *)a10;
        if (v56)
        {
          v58 = *(const char ***)(*(_QWORD *)(v57 + 3344) + 8 * v54);
          v59 = cstdlib_strlen("FEATIDX");
          Index = usextract_getIndex(v58, "FEATIDX", (unint64_t)&aFeatidx[v59]);
          if (Index == -1)
          {
            if (cstdlib_strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)a10 + 3336) + 8 * v54), "POS"))
            {
              if (!cstdlib_strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)a10 + 3336) + 8 * v54), "PHR"))
                *(_QWORD *)(a10 + 512) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
            }
            else
            {
              *(_QWORD *)(a10 + 504) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
            }
          }
          else
          {
            *(_QWORD *)(a10
                      + 8 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a10 + 3352) + 8 * v54) + Index)
                      + 16) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
          }
        }
        else
        {
          v61 = cstdlib_atoi((unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v57 + 3336) + 8 * v54) + 5)) + 79;
          if (v61 <= 0x5E)
            *(_QWORD *)(a10 + 8 * v61 + 16) = *(_QWORD *)(*(_QWORD *)(a10 + 3504) + 8 * v54);
        }
        v54 = v55;
        v53 = *(const char **)(*(_QWORD *)(*(_QWORD *)a10 + 3336) + 8 * v55++);
      }
      while (v53);
    }
  }
  v102 = *(__int16 *)(a10 + 10);
  v104 = v102 & ~(v102 >> 31);
  if (MFS__log_select_GetLogLevel(*(_QWORD *)(v15 + 32)) >= 6)
  {
    LH_itoa(0x4Eu, (char *)v111, 0xAu);
    v62 = 0;
    v103 = v43;
    do
    {
      v63 = "application/x-realspeak-usplosives;version=4.0";
      switch((int)v62)
      {
        case 2:
          v110 = 5;
          v109 = 0;
          log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
            (uint64_t)&v110,
            1u,
            0);
          log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
            *(_QWORD *)(a10 + 8 * v62 + 16),
            v104,
            0);
          v43 = v103;
          log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)"text/x-realspeak-usphonemes;charset=tts",
            (uint64_t)&v109,
            1u,
            0);
          break;
        case 3:
          v63 = "application/x-realspeak-usdurs;version=4.0";
          goto LABEL_72;
        case 4:
          goto LABEL_72;
        case 5:
          v63 = "application/x-realspeak-usmarkers-u16;version=4.0";
LABEL_72:
          v64 = *(unsigned __int8 *)(*(_QWORD *)a10 + v62 + 2748);
          if (v64 == 2)
          {
            log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)v63, *(_QWORD *)(a10 + 8 * v62 + 1760), 2 * v104, 0);
          }
          else if (v64 == 1)
          {
            log_OutBinary(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 99, 0, (uint64_t)v111, (uint64_t)v63, *(_QWORD *)(a10 + 8 * v62 + 16), v104, 0);
          }
          break;
        default:
          break;
      }
      ++v62;
    }
    while (v62 != 218);
  }
  v65 = *(unsigned int *)(a10 + 3520);
  if ((_DWORD)v65)
  {
    v66 = 0;
    for (j = 0; j < v65; ++j)
    {
      if (*(_DWORD *)(*(_QWORD *)(a10 + 3512) + v66) == 25)
      {
        v111[0] = 0;
        paramc_ParamGetUInt(*(_QWORD *)(v15 + 40), (uint64_t)"finalsentencefound", v111);
        v68 = *(_DWORD *)(*(_QWORD *)(a10 + 3512) + v66 + 24);
        *a9 = v68;
        v43 = paramc_ParamSetInt(*(_QWORD *)(v15 + 40), (uint64_t)"waitfactor", v68);
        if (v43 < 0)
        {
          log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55009, (uint64_t)"%s%s%s%d%s%x", v69, v70, v71, v72, "parameter");
          goto LABEL_44;
        }
        v65 = *(unsigned int *)(a10 + 3520);
      }
      v66 += 32;
    }
  }
  featextract_adjustSilAudioOrder(a10);
  a4 = v107;
  a3 = v108;
  if (v105)
  {
    v73 = *(_DWORD *)(a10 + 3520);
    v74 = v73 + v104;
    *a12 = v74;
    if (v73 + v104)
    {
      v75 = heap_Calloc(*(_QWORD **)(v15 + 8), v74, 32);
      *a11 = v75;
      if (v75)
      {
        v76 = (void *)heap_Calloc(*(_QWORD **)(v15 + 8), *(__int16 *)(a10 + 10), 2);
        if (v76)
        {
          v77 = (uint64_t)v76;
          cstdlib_memcpy(v76, *(const void **)(a10 + 1800), 2 * *(__int16 *)(a10 + 10));
          if (*a12)
          {
            v78 = 0;
            v79 = 0;
            v80 = 0;
            v81 = 0;
            while (v81 < *(unsigned int *)(a10 + 3520))
            {
              if (v80 >= v104)
              {
                v87 = (_OWORD *)(*a11 + v78);
                v88 = (_OWORD *)(*(_QWORD *)(a10 + 3512) + 32 * v81);
                v89 = v88[1];
                *v87 = *v88;
                v87[1] = v89;
                ++v81;
                goto LABEL_96;
              }
              v82 = v80;
              if (!*(_WORD *)(v77 + 2 * v80))
                goto LABEL_94;
              v83 = (_OWORD *)(*a11 + v78);
              v84 = (_OWORD *)(*(_QWORD *)(a10 + 3512) + 32 * v81);
              v85 = v84[1];
              *v83 = *v84;
              v83[1] = v85;
              ++v81;
              --*(_WORD *)(v77 + 2 * v80);
LABEL_96:
              ++v79;
              v78 += 32;
              if (v79 >= *a12)
                goto LABEL_97;
            }
            v82 = v80;
LABEL_94:
            v86 = (_DWORD *)(*a11 + v78);
            *v86 = 33;
            v86[6] = *(unsigned __int8 *)(*(_QWORD *)(a10 + 32) + v82);
            ++v80;
            goto LABEL_96;
          }
LABEL_97:
          heap_Free(*(_QWORD **)(v15 + 8), v77);
          goto LABEL_98;
        }
      }
LABEL_119:
      v43 = -2065686518;
      log_OutPublic(*(_QWORD *)(v15 + 32), (uint64_t)"SELECT_BET3", 55000, 0, v22, v23, v24, v25, v101);
      if (!a12)
        goto LABEL_127;
      goto LABEL_123;
    }
  }
LABEL_98:
  if (v102 < 1)
    goto LABEL_122;
  v90 = 0;
  if (v104 <= 1)
    v91 = 1;
  else
    v91 = v104;
  v92 = a2;
  do
  {
    v93 = *(_QWORD *)(a10 + 248);
    if (!*(_BYTE *)(v93 + v90))
      *(_BYTE *)(v93 + v90) = -1;
    v94 = *(_QWORD *)(a10 + 192);
    if (*(_BYTE *)(*(_QWORD *)(a10 + 32) + v90) == 35)
      v95 = 1;
    else
      v95 = 2 * *(_BYTE *)(v94 + v90);
    *(_BYTE *)(v94 + v90) = v95;
    v96 = *(_QWORD *)(a10 + 32);
    if ((unsigned __int16)(v102 & ~(unsigned __int16)(v102 >> 31)) - 1 == v90 && *(_BYTE *)(v96 + v90) == 35)
    {
      v111[0] = 0;
      paramc_ParamGetUInt(*(_QWORD *)(v15 + 40), (uint64_t)"finalsentencefound", v111);
      v97 = 0;
      v98 = *(_QWORD *)(a10 + 1784);
      if (v111[0] != 1)
        v97 = *(unsigned __int16 *)(v98 + 2 * v90) + 200 * *a9;
      if (v97 <= 1)
        v97 = 1;
      if (v97 >= 0xFFFF)
        LOWORD(v97) = -1;
      *(_WORD *)(v98 + 2 * v90) = v97;
      v96 = *(_QWORD *)(a10 + 32);
      v92 = a2;
    }
    *(_BYTE *)(v96 + v90) = *(_BYTE *)(v92 + *(unsigned __int8 *)(v96 + v90) + 7356);
    ++v90;
  }
  while (v91 != v90);
LABEL_44:
  a4 = v107;
  a3 = v108;
  if (a12)
  {
LABEL_123:
    if (a11 && v43 < 0 && *a11)
    {
      heap_Free(*(_QWORD **)(v15 + 8), *a11);
      *a11 = 0;
      *a12 = 0;
    }
  }
LABEL_127:
  LODWORD(result) = (*(uint64_t (**)(uint64_t, uint64_t))(a1[2] + 64))(a3, a4);
  if ((int)result >= 0 || v43 <= -1)
    return v43;
  else
    return result;
}

uint64_t MFS__select_bet3_FeatureExtractProcessEnd(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!*a2)
    return 0;
  v4 = *a1;
  v5 = usextract_ProcessEnd(*a1, (uint64_t)"SELECT_BET3", (uint64_t)a2);
  usextract_freeGenericFeatureLayers((_QWORD *)*a1, (uint64_t)"SELECT_BET3", a2);
  v10 = 0;
  v11 = 1;
  do
  {
    v12 = *(unsigned __int8 *)(*a2 + v10 + 2748);
    if (*(_BYTE *)(*a2 + v10 + 2748))
    {
      if (v12 == 2)
      {
        v14 = a2[v10 + 220];
        if (v14)
LABEL_11:
          heap_Free(*(_QWORD **)(v4 + 8), v14);
      }
      else if (v12 == 1)
      {
        if (v11)
        {
          v13 = a2[v10 + 2];
          if (v13)
            heap_Free(*(_QWORD **)(v4 + 8), v13);
          v11 = 0;
        }
      }
      else
      {
        switch((int)v10)
        {
          case '.':
            v14 = a2[445];
            if (v14)
              goto LABEL_11;
            break;
          case '/':
          case '0':
          case '1':
          case '2':
          case '7':
            goto LABEL_20;
          case '3':
            v14 = a2[446];
            if (v14)
              goto LABEL_11;
            break;
          case '4':
            v14 = a2[447];
            if (v14)
              goto LABEL_11;
            break;
          case '5':
            v14 = a2[448];
            if (v14)
              goto LABEL_11;
            break;
          case '6':
            v14 = a2[449];
            if (v14)
              goto LABEL_11;
            break;
          case '8':
            v14 = a2[450];
            if (v14)
              goto LABEL_11;
            break;
          default:
            if ((_DWORD)v10 == 24)
            {
              v14 = a2[444];
              if (v14)
                goto LABEL_11;
            }
            else
            {
LABEL_20:
              log_OutPublic(*(_QWORD *)(*a1 + 32), (uint64_t)"SELECT_BET3", 55010, (uint64_t)"%s%u", v6, v7, v8, v9, "feature");
            }
            break;
        }
      }
    }
    ++v10;
  }
  while (v10 != 218);
  v15 = a2[451];
  if (v15)
    heap_Free(*(_QWORD **)(v4 + 8), v15);
  cstdlib_memset(a2, 0, 8uLL);
  return v5;
}

float MFS__mul_int32_Q8_24_to_int32(float a1, float a2)
{
  return a1 * a2;
}

float MFS__mul_int32_Q8_24_to_Q8_24(float a1, float a2)
{
  return a1 * a2;
}

float MFS__mul_Q18_14_Q1_15_to_Q18_14(float a1, float a2)
{
  return a1 * a2;
}

float MFS__div_int32_int32_to_Q8_24(float a1, float a2)
{
  return a1 / a2;
}

float MFS__div_Q8_24_Q12_20_to_Q8_24(float a1, float a2)
{
  return a1 / a2;
}

float MFS__div_Q18_14_Q18_14_to_Q18_14(float a1, float a2)
{
  return a1 / a2;
}

uint64_t MFS__LoadModelFile(uint64_t a1, unsigned int *a2, int a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  int *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unsigned int *v28;
  int *v29;
  uint64_t v30;
  unsigned int *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  BOOL v46;
  unsigned int *v47;
  int *v48;
  unsigned int v49;
  uint64_t v50;
  unsigned int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  unsigned int *v56;
  unsigned int *v57;
  unsigned int *v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;

  v5 = a1;
  v6 = a3;
  if (a2[a3 + 84])
  {
    v7 = &a2[a3];
    v9 = v7[32];
    v8 = (int *)(v7 + 32);
    v10 = heap_Calloc(*(_QWORD **)(a1 + 8), v9, 8);
    *((_QWORD *)a2 + 21) = v10;
    if (!v10)
      return 2229280778;
    if (*v8 >= 1)
    {
      v11 = 0;
      v12 = 0;
      v13 = (int *)(a2 + 11);
      while (1)
      {
        v14 = (unsigned int *)(a4 + 24 * v11);
        if (MFS__xfread_BET3(a2, 4u, 1, v14) != 1 || (*a2 & 0x80000000) != 0)
        {
          v67 = "LoadModelFile: the number of HMM states is illegal for %s %d\n";
          v68 = v5;
          v69 = 55020;
          goto LABEL_67;
        }
        if (MFS__xfread_BET3(a2 + 11, 4u, 1, v14) != 1 || (v20 = *v13, *v13 < 0))
        {
          v67 = "LoadModelFile: the number of PDFs is illegal for %s %d\n";
          v68 = v5;
          v69 = 55021;
          goto LABEL_67;
        }
        if (!v12)
        {
          v21 = heap_Calloc(*(_QWORD **)(v5 + 8), (*v8 * v20), 8);
          if (!v21)
            return 2229280778;
          v12 = v21;
          v20 = *v13;
        }
        v22 = v6;
        *(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v11) = v12 + 8 * v20 * (int)v11;
        *(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v11) -= 8;
        if (v20 >= 1)
          break;
LABEL_16:
        ++v11;
        v6 = v22;
        if (v11 >= *v8)
          goto LABEL_17;
      }
      v23 = 0;
      v24 = *a2;
      v25 = 8;
      while (1)
      {
        v26 = MFS__xfread2ptr_BET3((_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v11) + v25), 4u, (2 * v24), v14);
        v24 = *a2;
        if (v26 != 2 * *a2)
          break;
        v27 = *(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v11) + 8 * v23;
        *(_QWORD *)(v27 + 8) -= 8;
        ++v23;
        v25 += 8;
        if (v23 >= (int)a2[11])
          goto LABEL_16;
      }
      v67 = "LoadModelFile: PDF read failed for %s %d\n";
      v68 = v5;
      v69 = 55022;
      goto LABEL_67;
    }
  }
LABEL_17:
  v28 = &a2[v6];
  if (v28[94])
  {
    v29 = (int *)(v28 + 32);
    v30 = heap_Calloc(*(_QWORD **)(v5 + 8), v28[32], 8);
    v31 = &a2[2 * v6];
    *((_QWORD *)v31 + 22) = v30;
    v32 = v31 + 44;
    v33 = 2229280778;
    if (!v30)
      return v33;
    v73 = heap_Calloc(*(_QWORD **)(v5 + 8), *a2 * *v29, 8);
    if (!v73)
      return v33;
    if (*v29 >= 1)
    {
      v34 = 0;
      v35 = &a2[v6 + 1];
      v36 = &a2[2 * v6 + 12];
      v71 = v5;
      v74 = v6;
      while (1)
      {
        v37 = (unsigned int *)(a4 + 24 * v34);
        if (MFS__xfread_BET3(v35, 4u, 1, v37) != 1 || (*v35 & 0x80000000) != 0)
        {
          v67 = "LoadModelFile: the vector size is illegal for %s %d\n";
          v68 = v5;
          v69 = 55023;
          goto LABEL_67;
        }
        v38 = MFS__xfread2ptr_BET3(v36, 4u, *a2, v37);
        if (v38 != *a2)
        {
          v67 = "LoadModelFile: reading the number of PDFs failed for %s %d\n";
          v68 = v5;
          v69 = 55024;
          goto LABEL_67;
        }
        v39 = *(_QWORD *)v36;
        *(_QWORD *)v36 -= 8;
        if (v38 > 0)
          break;
        *(_QWORD *)(*v32 + 8 * v34) = v73 + 8 * v38 * (int)v34;
        *(_QWORD *)(*v32 + 8 * v34) -= 16;
LABEL_34:
        ++v34;
        v5 = v71;
        v6 = v74;
        if (v34 >= *v29)
          goto LABEL_35;
      }
      v40 = 0;
      do
      {
        if ((*(_DWORD *)(v39 + 4 * v40) & 0x80000000) != 0)
        {
          v67 = "LoadModelFile: the number of PDFs for %s at state %d is illegal\n";
          v68 = v5;
          v69 = 55025;
          goto LABEL_67;
        }
        ++v40;
      }
      while ((v38 + 2) - 2 != v40);
      *(_QWORD *)(*v32 + 8 * v34) = v73 + 8 * v38 * (int)v34;
      *(_QWORD *)(*v32 + 8 * v34) -= 16;
      v41 = *(_QWORD *)v36;
      v42 = *v35;
      v43 = 16;
      v44 = 2;
      while (1)
      {
        v45 = MFS__xfread2ptr_BET3((_QWORD *)(*(_QWORD *)(*v32 + 8 * v34) + v43), 4u, 2 * *(_DWORD *)(v41 + 4 * v44) * v42, v37);
        v41 = *(_QWORD *)v36;
        v42 = *v35;
        if (v45 != 2 * *(_DWORD *)(*(_QWORD *)v36 + 4 * v44) * *v35)
          break;
        v43 += 8;
        v46 = v44++ <= (int)*a2;
        if (!v46)
          goto LABEL_34;
      }
      v67 = "LoadModelFile: PDF read failed for %s %d\n";
      v68 = v71;
      v69 = 55026;
      goto LABEL_67;
    }
  }
LABEL_35:
  if (!v28[104])
    return 0;
  v47 = &a2[v6];
  v49 = v47[32];
  v48 = (int *)(v47 + 32);
  v50 = heap_Calloc(*(_QWORD **)(v5 + 8), v49, 8);
  v75 = v6;
  v51 = &a2[2 * v6];
  *((_QWORD *)v51 + 32) = v50;
  v33 = 2229280778;
  if (v50)
  {
    v52 = heap_Calloc(*(_QWORD **)(v5 + 8), *a2 * *v48, 8);
    if (v52)
    {
      if (*v48 >= 1)
      {
        v53 = v52;
        v54 = 0;
        v55 = v51 + 64;
        v56 = &a2[v75 + 1];
        v57 = &a2[2 * v75 + 12];
        v72 = v5;
        while (1)
        {
          v58 = (unsigned int *)(a4 + 24 * v54);
          if (MFS__xfread_BET3(v56, 4u, 1, v58) != 1 || (*v56 & 0x80000000) != 0)
          {
            v67 = "LoadModelFile: the vector size is illegal for %s %d\n";
            v68 = v5;
            v69 = 55027;
            goto LABEL_67;
          }
          v59 = MFS__xfread2ptr_BET3(v57, 4u, *a2, v58);
          if (v59 != *a2)
          {
            v67 = "LoadModelFile: reading the number of PDFs failed for %s %d\n";
            v68 = v5;
            v69 = 55028;
            goto LABEL_67;
          }
          v60 = *(_QWORD *)v57;
          *(_QWORD *)v57 -= 8;
          if (v59 > 0)
            break;
          *(_QWORD *)(*v55 + 8 * v54) = v53 + 8 * v59 * (int)v54;
          *(_QWORD *)(*v55 + 8 * v54) -= 16;
LABEL_52:
          v33 = 0;
          ++v54;
          v5 = v72;
          if (v54 >= *v48)
            return v33;
        }
        v61 = 0;
        do
        {
          if ((*(_DWORD *)(v60 + 4 * v61) & 0x80000000) != 0)
          {
            v67 = "LoadModelFile: the number of PDFs for %s at state %d is illegal\n";
            v68 = v5;
            v69 = 55029;
            goto LABEL_67;
          }
          ++v61;
        }
        while ((v59 + 2) - 2 != v61);
        *(_QWORD *)(*v55 + 8 * v54) = v53 + 8 * v59 * (int)v54;
        *(_QWORD *)(*v55 + 8 * v54) -= 16;
        v62 = *(_QWORD *)v57;
        v63 = *v56;
        v64 = 16;
        v65 = 2;
        while (1)
        {
          v66 = MFS__xfread2ptr_BET3((_QWORD *)(*(_QWORD *)(*v55 + 8 * v54) + v64), 4u, 4 * *(_DWORD *)(v62 + 4 * v65) * v63, v58);
          v62 = *(_QWORD *)v57;
          v63 = *v56;
          if (v66 != 4 * *(_DWORD *)(*(_QWORD *)v57 + 4 * v65) * *v56)
            break;
          v64 += 8;
          v46 = v65++ <= (int)*a2;
          if (!v46)
            goto LABEL_52;
        }
        v67 = "LoadModelFile: PDF read failed for %s %d\n";
        v68 = v72;
        v69 = 55030;
LABEL_67:
        MFS__log_select_Error(v68, v69, (uint64_t)v67, v15, v16, v17, v18, v19);
        return 2229280772;
      }
      return 0;
    }
  }
  return v33;
}

uint64_t MFS__FindDurPDF(int32x2_t *a1, int *a2, int a3, int a4, int a5, float a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v13;
  uint64_t v14;
  float v20;
  uint64_t v21;
  float v22;
  float v23;
  float v24;
  float64x2_t v25;
  int32x2_t v26;
  int32x2_t v27;
  float64x2_t v30;

  v6 = a1[1].i32[0];
  a1[3] = 0;
  LODWORD(v7) = *a2;
  if (*a2 >= 1)
  {
    v13 = a4;
    v14 = 2;
    __asm { FMOV            V0.2D, #0.5 }
    v30 = _Q0;
    v20 = 0.0;
    do
    {
      v21 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v13) + 8 * v6);
      v22 = *(float *)(v21 + 4 * v14);
      v23 = *(float *)(v21 + 4 * ((int)v14 + (int)v7));
      if (a5)
        v23 = MFS__bet3_finv(v23);
      v24 = v22 + (float)(v23 * a6);
      if (v24 < 0.0)
        v24 = 0.0;
      if (a2[115])
      {
        if (v24 > 4000.0)
          v24 = 4000.0;
      }
      else if (v24 > 4000.0)
      {
        v24 = v20 * 0.5;
      }
      v25.f64[0] = (float)(v24 + (float)a3);
      v26 = a1[2];
      v25.f64[1] = sqrt(v23);
      v27 = vmovn_s64(vcvtq_s64_f64(vaddq_f64(v25, v30)));
      *(_DWORD *)(*(_QWORD *)&v26 + 4 * v14) = v27.i32[0];
      a1[3] = vadd_s32(a1[3], v27);
      a3 += (int)(float)(v24 - (float)*(int *)(*(_QWORD *)&v26 + 4 * v14));
      v7 = *a2;
      v20 = v24;
    }
    while (v14++ <= v7);
  }
  return 0;
}

uint64_t MFS__FindContPDF(int a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v5 = (_QWORD *)(a3 + 8 * a1);
  v6 = *(int *)(a4 + 4 * a1 + 4);
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 8 * a1 + 176) + 8 * a5) + 8 * a2)
     + 4 * (2 * *(_DWORD *)(v5[9] + 4 * a2) - 2) * (int)v6;
  *(_QWORD *)(v5[19] + 8 * a2) = v7;
  *(_QWORD *)(v5[29] + 8 * a2) = v7 + 4 * v6;
  return 0;
}

uint64_t MFS__FindMsdPDF(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6;
  int *v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  int *v17;
  float *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  float v23;
  int v24;
  float v25;
  uint64_t v26;
  uint64_t v27;
  char v28;

  v6 = a4 + 4 * a1;
  v9 = *(_DWORD *)(v6 + 4);
  v7 = (int *)(v6 + 4);
  v8 = v9;
  if (v9 >= 1)
  {
    v10 = 0;
    v11 = a2;
    v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 8 * a1 + 256) + 8 * a6) + 8 * a2)
        + 4 * (4 * *(_DWORD *)(*(_QWORD *)(a3 + 8 * a1 + 72) + 4 * a2) - 4) * v8;
    v13 = a3 + 8 * a1;
    v14 = a5 + 4 * a1;
    v15 = (_QWORD *)(v13 + 152);
    v16 = (_QWORD *)(v13 + 232);
    v17 = (int *)(v14 + 224);
    v18 = (float *)(v14 + 2104);
    v19 = 1;
    do
    {
      v20 = v12 + 4 * v10;
      v21 = *(_QWORD *)(*v15 + 8 * v11);
      *(_DWORD *)(v21 + 4 * v19) = *(_DWORD *)v20;
      v22 = *(float *)(v20 + 4);
      *(float *)(*(_QWORD *)(*v16 + 8 * v11) + 4 * v19) = v22;
      v23 = *(float *)(a5 + 44);
      if (v23 != 0.0 && *v17 == 2)
        *(float *)(v21 + 4 * v19) = *(float *)(v21 + 4 * v19) + (float)(v22 * v23);
      if (v19 == 1)
      {
        v24 = *v17;
        if (*v17 == 2)
          *(_DWORD *)(*(_QWORD *)(a3 + 320) + 4 * v11) = *(_DWORD *)(v20 + 8);
        v25 = *(float *)(v20 + 8);
        v26 = 1 << v24;
        v27 = *(_QWORD *)(a3 + 312);
        if (v25 <= *v18)
          v28 = *(_BYTE *)(v27 + v11) & ~(_BYTE)v26;
        else
          v28 = *(_BYTE *)(v27 + v11) | v26;
        *(_BYTE *)(v27 + v11) = v28;
      }
      v10 += 4;
    }
    while (v19++ < *v7);
  }
  return 0;
}

uint64_t MFS__FindDurPDF_PerStateRho(uint64_t a1, int *a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v13;
  uint64_t v14;
  float v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  double v20;
  float v21;
  float v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;

  v6 = *(int *)(a1 + 8);
  *(_QWORD *)(a1 + 24) = 0;
  LODWORD(v7) = *a2;
  if (*a2 >= 1)
  {
    v13 = 0;
    v14 = a5;
    v15 = 0.0;
    do
    {
      v16 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a2 + 21) + 8 * v14) + 8 * v6);
      v17 = *(float *)(v16 + 4 * v13 + 8);
      v18 = *(float *)(a3 + 4 * v13);
      v19 = *(float *)(v16 + 4 * (v13 + (int)v7) + 8);
      if (a6)
        v19 = MFS__bet3_finv(v19);
      v20 = sqrt(v19);
      v21 = v20;
      v22 = v17 + (float)(v18 * v21);
      if (v22 < 0.0)
        v22 = 0.0;
      if (a2[115])
      {
        if (v22 > 4000.0)
          v22 = 4000.0;
      }
      else if (v22 > 4000.0)
      {
        v22 = v15 * 0.5;
      }
      v23 = (int)((float)(v22 + (float)a4) + 0.5);
      v24 = *(_QWORD *)(a1 + 16) + 4 * v13;
      if (v23 <= 1)
        v23 = 1;
      *(_DWORD *)(v24 + 8) = v23;
      v25 = *(_DWORD *)(a1 + 28) + (int)(v20 + 0.5);
      *(_DWORD *)(a1 + 24) += v23;
      *(_DWORD *)(a1 + 28) = v25;
      a4 += (int)(float)(v22 - (float)*(int *)(v24 + 8));
      v7 = *a2;
      v26 = v13 + 2;
      ++v13;
      v15 = v22;
    }
    while (v26 <= v7);
  }
  return 0;
}

uint64_t MFS__FindLF0PDF_PerStateRho(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, float a8)
{
  uint64_t v8;
  int v9;
  int *v10;
  int v11;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  double v20;
  float *v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  float v26;
  double v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  char v31;

  v8 = a4 + 4 * a1;
  v11 = *(_DWORD *)(v8 + 4);
  v10 = (int *)(v8 + 4);
  v9 = v11;
  if (v11 >= 1)
  {
    v14 = a2;
    v15 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a4 + 8 * a1 + 256) + 8 * a6) + 8 * a2)
        + 4 * (4 * *(_DWORD *)(*(_QWORD *)(a3 + 8 * a1 + 72) + 4 * a2) - 4) * v9;
    v16 = a3 + 8 * a1;
    v17 = (_QWORD *)(v16 + 152);
    v18 = (_QWORD *)(v16 + 232);
    v19 = a5 + 4 * a1;
    v20 = a8;
    v21 = (float *)(v19 + 2104);
    v22 = (_DWORD *)(v19 + 224);
    v23 = 1;
    do
    {
      v24 = v15 + 4 * (4 * (int)v23 - 4);
      v25 = (float *)(*(_QWORD *)(*v17 + 8 * v14) + 4 * v23);
      *v25 = *(float *)v24;
      v26 = *(float *)(v24 + 4);
      *(float *)(*(_QWORD *)(*v18 + 8 * v14) + 4 * v23) = v26;
      if (a8 != 0.0)
      {
        if (a7)
        {
          v27 = sqrt(MFS__bet3_finv(v26));
          v25 = (float *)(*(_QWORD *)(*v17 + 8 * v14) + 4 * v23);
        }
        else
        {
          v27 = sqrt(v26);
        }
        v28 = v27 * v20;
        *v25 = *v25 + v28;
      }
      if (v23 == 1)
      {
        *(_DWORD *)(*(_QWORD *)(a3 + 320) + 4 * v14) = *(_DWORD *)(v24 + 8);
        v29 = 1 << *v22;
        v30 = *(_QWORD *)(a3 + 312);
        if (*(float *)(v24 + 8) <= *v21)
          v31 = *(_BYTE *)(v30 + v14) & ~(_BYTE)v29;
        else
          v31 = *(_BYTE *)(v30 + v14) | v29;
        *(_BYTE *)(v30 + v14) = v31;
      }
    }
    while (v23++ < *v10);
  }
  return 0;
}

void *MFS__DeInitModelSet(uint64_t a1, char *__b)
{
  uint64_t v4;
  uint64_t **v5;
  _DWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t *v9;

  if (*((int *)__b + 114) >= 1)
  {
    v4 = 0;
    v5 = (uint64_t **)(__b + 256);
    v6 = __b + 416;
    do
    {
      if (*(v6 - 20))
      {
        v7 = (_QWORD *)*((_QWORD *)__b + 21);
        if (v7)
        {
          if (*v7)
          {
            *v7 += 8;
            heap_Free(*(_QWORD **)(a1 + 8), **((_QWORD **)__b + 21));
            v7 = (_QWORD *)*((_QWORD *)__b + 21);
          }
          heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v7);
          *((_QWORD *)__b + 21) = 0;
        }
      }
      if (*(v6 - 10))
      {
        v8 = *(v5 - 10);
        if (v8)
        {
          if (*v8)
          {
            *v8 += 16;
            heap_Free(*(_QWORD **)(a1 + 8), **(v5 - 10));
            v8 = *(v5 - 10);
          }
          heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v8);
        }
      }
      if (*v6)
      {
        v9 = *v5;
        if (*v5)
        {
          if (*v9)
          {
            *v9 += 16;
            heap_Free(*(_QWORD **)(a1 + 8), **v5);
            v9 = *v5;
          }
          heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v9);
        }
      }
      ++v4;
      ++v5;
      ++v6;
    }
    while (v4 < *((int *)__b + 114));
  }
  return cstdlib_memset(__b, 0, 0x1D0uLL);
}

uint64_t MFS__InitUttModel(uint64_t a1, char *__b, int *a3, unsigned int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  _DWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  int v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  _QWORD *v33;
  uint64_t v34;
  _DWORD *v35;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v8 = 2229280778;
  cstdlib_memset(__b, 0, 0x240uLL);
  *(_QWORD *)__b = a1;
  *((_QWORD *)__b + 1) = a3;
  *((_DWORD *)__b + 138) = a4;
  *((_DWORD *)__b + 141) = *a3 * a4;
  v9 = heap_Calloc(*(_QWORD **)(a1 + 8), a4, 528);
  *((_QWORD *)__b + 68) = v9;
  if (v9)
  {
    v10 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 4);
    *((_QWORD *)__b + 4) = v10;
    if (v10)
    {
      v11 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 4);
      *((_QWORD *)__b + 43) = v11;
      if (v11)
      {
        v12 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 1);
        *((_QWORD *)__b + 41) = v12;
        if (v12)
        {
          v13 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 4);
          *((_QWORD *)__b + 42) = v13;
          if (v13)
          {
            v14 = a3[114];
            if (v14 >= 1)
            {
              v15 = 0;
              v16 = __b + 168;
              v17 = a3;
              do
              {
                if (!v17[84])
                {
                  v18 = heap_Calloc(*(_QWORD **)(a1 + 8), (*a3 * *((_DWORD *)__b + 138)), 4);
                  *(v16 - 10) = v18;
                  if (!v18)
                    return v8;
                  v19 = *(_QWORD **)(a1 + 8);
                  v20 = *((_DWORD *)__b + 138);
                  v21 = v17[104]
                      ? MFS__int32_ccalloc(v19, 2 * v20 * *a3, v17[1] + 1)
                      : (_QWORD *)heap_Calloc(v19, (2 * v20 * *a3), 8);
                  *v16 = v21;
                  if (!v21)
                    return v8;
                  v16[10] = &v21[*a3 * *((_DWORD *)__b + 138)];
                  v14 = a3[114];
                }
                ++v15;
                ++v17;
                ++v16;
              }
              while (v15 < v14);
            }
            v22 = *((unsigned int *)__b + 138);
            if ((int)v22 >= 1)
            {
              v23 = 0;
              v24 = *a3;
              v25 = 152;
              do
              {
                v26 = *((_QWORD *)__b + 68);
                v27 = v26 + 528 * v23;
                *(_DWORD *)v27 = v23;
                v28 = v23 * v24;
                v29 = *((_QWORD *)__b + 43) + 4 * v23 * v24;
                v30 = *((_QWORD *)__b + 41) + v23 * v24;
                v31 = *((_QWORD *)__b + 42) + 4 * v23 * v24;
                *(_QWORD *)(v27 + 16) = *((_QWORD *)__b + 4) + 4 * v23 * v24 - 8;
                *(_QWORD *)(v27 + 312) = v30 - 2;
                *(_QWORD *)(v27 + 320) = v31 - 8;
                *(_QWORD *)(v27 + 328) = v29 - 8;
                if (v14 >= 1)
                {
                  v32 = (uint64_t *)(v26 + v25);
                  v33 = __b + 168;
                  v34 = v14;
                  v35 = a3 + 84;
                  do
                  {
                    if (!*v35++)
                    {
                      v37 = *(v33 - 10) + 4 * v28;
                      *(v32 - 10) = v37;
                      v38 = *v33 + 8 * v28;
                      *v32 = v38;
                      v39 = v33[10] + 8 * v28;
                      *(v32 - 10) = v37 - 8;
                      *v32 = v38 - 16;
                      v32[10] = v39 - 16;
                    }
                    ++v32;
                    ++v33;
                    --v34;
                  }
                  while (v34);
                }
                ++v23;
                v25 += 528;
              }
              while (v23 != v22);
            }
            return 0;
          }
        }
      }
    }
  }
  return v8;
}

_QWORD *MFS__DeInitUttModel(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;

  v1 = result;
  if (*result && result[68])
  {
    v2 = result[1];
    v3 = result[4];
    if (v3)
    {
      heap_Free(*(_QWORD **)(*result + 8), v3);
      v1[4] = 0;
    }
    v4 = v1[43];
    if (v4)
    {
      heap_Free(*(_QWORD **)(*v1 + 8), v4);
      v1[43] = 0;
    }
    v5 = v1[41];
    if (v5)
    {
      heap_Free(*(_QWORD **)(*v1 + 8), v5);
      v1[41] = 0;
    }
    v6 = v1[42];
    if (v6)
    {
      heap_Free(*(_QWORD **)(*v1 + 8), v6);
      v1[42] = 0;
    }
    if (*(int *)(v2 + 456) >= 1)
    {
      v7 = 0;
      do
      {
        if (!*(_DWORD *)(v2 + 336 + 4 * v7))
        {
          v8 = &v1[v7];
          v9 = v8[11];
          if (v9)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v9);
            v8[11] = 0;
          }
          v10 = v8[21];
          if (v10)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v10);
            v8[21] = 0;
          }
        }
        ++v7;
      }
      while (v7 < *(int *)(v2 + 456));
    }
    result = heap_Free(*(_QWORD **)(*v1 + 8), v1[68]);
  }
  v1[68] = 0;
  *((_DWORD *)v1 + 138) = 0;
  *v1 = 0;
  return result;
}

_QWORD *MFS__DeInitMSDUttModel(_QWORD *result, int a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t **v8;
  _QWORD *v9;

  v2 = result[1];
  if (!*(_DWORD *)(v2 + 4 * a2 + 336))
  {
    v3 = result;
    v4 = a2;
    v5 = &result[a2];
    v6 = v5[11];
    if (v6)
    {
      result = heap_Free(*(_QWORD **)(*result + 8), v6);
      v5[11] = 0;
    }
    v9 = (_QWORD *)v5[21];
    v8 = (uint64_t **)(v5 + 21);
    v7 = v9;
    if (v9)
    {
      if (*(_DWORD *)(v2 + 4 * v4 + 416))
      {
        *v7 += 4;
        result = MFS__int32_free(*(_QWORD **)(*v3 + 8), *v8);
      }
      else
      {
        result = heap_Free(*(_QWORD **)(*v3 + 8), (uint64_t)v7);
      }
      *v8 = 0;
    }
  }
  return result;
}

uint64_t MFS__InitModelSet(int a1, char *__b, _DWORD *a3)
{
  int v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;

  cstdlib_memset(__b, 0, 0x1D0uLL);
  v5 = a3[33];
  *((_DWORD *)__b + 114) = v5;
  if (v5 >= 1)
  {
    v6 = 0;
    v7 = __b + 376;
    v8 = 536;
    do
    {
      *((_DWORD *)v7 - 62) = a3[86];
      v9 = __b + 336;
      if (v8 != 536)
      {
        if (a3[536])
          v9 = &__b[4 * v6 + 416];
        else
          v9 = v7;
      }
      ++a3;
      *(_DWORD *)v9 = 1;
      ++v6;
      v10 = v8 - 535;
      ++v8;
      v7 += 4;
    }
    while (v10 < *((int *)__b + 114));
  }
  return 0;
}

uint64_t MFS__meancpy(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  v1 = *(unsigned int *)(result + 16);
  if ((int)v1 >= 1)
  {
    v2 = 0;
    v3 = *(unsigned int *)(result + 20);
    do
    {
      if ((int)v3 >= 1)
      {
        v4 = *(uint64_t **)(result + 72);
        v5 = *(uint64_t **)(result + 40);
        v6 = v3;
        do
        {
          v7 = *v4++;
          v8 = *(_DWORD *)(v7 + 4 * v2);
          v9 = *v5++;
          *(_DWORD *)(v9 + 4 * v2) = v8;
          --v6;
        }
        while (v6);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

float MFS__ConstW_Calc_R_and_r(uint64_t a1, int a2)
{
  float *v2;
  float **v3;
  uint64_t *v4;
  uint64_t *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  float v19;
  float v20;
  float v21;
  float *v22;
  uint64_t v23;
  float **v24;
  float *v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  float v29;
  float v30;
  uint64_t v31;
  float v32;
  uint64_t v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float *v46;
  float v47;
  float v48;
  uint64_t v49;
  float v50;
  uint64_t v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float *v56;
  float result;

  v3 = *(float ***)(a1 + 96);
  v2 = *(float **)(a1 + 104);
  v4 = *(uint64_t **)(a1 + 72);
  v5 = *(uint64_t **)(a1 + 80);
  v6 = *(_DWORD *)(a1 + 16);
  v7 = *(_DWORD *)(a1 + 20);
  v8 = a2;
  v9 = *v5;
  v10 = v5[1];
  v11 = *(float *)(*v5 + 4 * a2);
  v12 = *v4;
  v13 = v4[1];
  v14 = v11 * *(float *)(*v4 + 4 * a2);
  *v2 = v14;
  v15 = *(float *)(v10 + 4 * (v6 + a2));
  v16 = v6 + a2;
  v17 = v14 + (float)((float)(v15 * -0.5) * *(float *)(v13 + 4 * v16));
  *v2 = v17;
  v18 = a2 + 2 * v6;
  v19 = *(float *)(v9 + 4 * v18);
  v20 = v17 + (float)((float)(v19 * -2.0) * *(float *)(v12 + 4 * v18));
  *v2 = v20;
  v21 = *(float *)(v10 + 4 * v18);
  *v2 = v20 + (float)(v21 * *(float *)(v13 + 4 * v18));
  v22 = *v3;
  *v22 = v11 + (float)((float)((float)(v19 * 4.0) + (float)(v15 * 0.25)) + v21);
  v22[1] = (float)(v19 * -2.0) + (float)(v21 * -2.0);
  v22[2] = v21 + (float)(v15 * -0.25);
  if (v7 < 3)
  {
    LODWORD(v23) = 1;
  }
  else
  {
    v23 = (v7 - 1);
    v24 = v3 + 1;
    v25 = v2 + 1;
    v26 = v5 + 2;
    v27 = v4 + 2;
    v28 = v23 - 1;
    do
    {
      v29 = *(float *)(v10 + 4 * v8);
      v30 = v29 * *(float *)(v13 + 4 * v8);
      *v25 = v30;
      v31 = *(v26 - 2);
      v32 = *(float *)(v31 + 4 * v16);
      v33 = *(v27 - 2);
      v34 = v30 + (float)((float)(v32 * 0.5) * *(float *)(v33 + 4 * v16));
      *v25 = v34;
      v36 = *v26++;
      v35 = v36;
      v37 = *(float *)(v36 + 4 * v16);
      v39 = *v27++;
      v38 = v39;
      v40 = v34 + (float)((float)(v37 * -0.5) * *(float *)(v39 + 4 * v16));
      *v25 = v40;
      v41 = *(float *)(v31 + 4 * v18);
      v42 = v40 + (float)(v41 * *(float *)(v33 + 4 * v18));
      *v25 = v42;
      v43 = *(float *)(v10 + 4 * v18);
      v44 = v42 + (float)((float)(v43 * -2.0) * *(float *)(v13 + 4 * v18));
      *v25 = v44;
      v45 = *(float *)(v35 + 4 * v18);
      *v25++ = v44 + (float)(v45 * *(float *)(v39 + 4 * v18));
      v46 = *v24++;
      *v46 = (float)((float)((float)((float)(v29 + (float)(v32 * 0.25)) + (float)(v37 * 0.25)) + v41) + v45)
           + (float)(v43 * 4.0);
      v46[1] = (float)(v45 * -2.0) + (float)(v43 * -2.0);
      v46[2] = v45 + (float)(v37 * -0.25);
      v13 = v38;
      v10 = v35;
      --v28;
    }
    while (v28);
    v10 = v5[v23];
    v13 = v4[v23];
  }
  v47 = *(float *)(v10 + 4 * v8);
  v48 = v47 * *(float *)(v13 + 4 * v8);
  v2[v23] = v48;
  v49 = v5[(int)v23 - 1];
  v50 = *(float *)(v49 + 4 * v16);
  v51 = v4[(int)v23 - 1];
  v52 = v48 + (float)((float)(v50 * 0.5) * *(float *)(v51 + 4 * v16));
  v2[v23] = v52;
  v53 = *(float *)(v49 + 4 * v18);
  v54 = v52 + (float)(v53 * *(float *)(v51 + 4 * v18));
  v2[v23] = v54;
  v55 = *(float *)(v10 + 4 * v18);
  v2[v23] = v54 + (float)((float)(v55 * -2.0) * *(float *)(v13 + 4 * v18));
  v56 = v3[v23];
  result = v47 + (float)((float)(v53 + (float)(v50 * 0.25)) + (float)(v55 * 4.0));
  *v56 = result;
  v56[1] = 0.0;
  v56[2] = 0.0;
  return result;
}

float MFS__ConstW_Cholesky(uint64_t a1, double a2)
{
  uint64_t v2;
  float *v3;
  _DWORD *v4;
  float32x2_t v5;
  float v6;
  float v7;
  float v8;
  uint64_t v9;
  float **v10;
  uint64_t v11;
  float *v12;
  float v13;
  float v14;
  float v15;

  v2 = *(_QWORD *)(a1 + 96);
  v4 = *(_DWORD **)v2;
  v3 = *(float **)(v2 + 8);
  LODWORD(a2) = **(_DWORD **)v2;
  v5 = vdiv_f32(*(float32x2_t *)(*(_QWORD *)v2 + 4), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a2, 0));
  *(float32x2_t *)(v4 + 1) = v5;
  v6 = v3[1];
  *(float *)&a2 = *v3 + (float)((float)((float)-v5.f32[0] * v5.f32[0]) * *(float *)&a2);
  *v3 = *(float *)&a2;
  v7 = (float)(v6 + (float)((float)-(float)(*((float *)v4 + 1) * *((float *)v4 + 2)) * *(float *)v4)) / *(float *)&a2;
  v8 = v3[2] / *(float *)&a2;
  v3[1] = v7;
  v3[2] = v8;
  v9 = *(unsigned int *)(a1 + 20);
  if ((int)v9 >= 3)
  {
    v10 = (float **)(v2 + 16);
    v11 = v9 - 2;
    do
    {
      v12 = *v10;
      v13 = (*v10)[1];
      v14 = **v10 + (float)((float)-(float)(v7 * v7) * *(float *)&a2);
      *v12 = v14;
      *(float *)&a2 = v14 + (float)((float)-(float)((*(v10 - 2))[2] * (*(v10 - 2))[2]) * **(v10 - 2));
      *v12 = *(float *)&a2;
      v7 = (float)(v13 + (float)((float)-(float)(v3[1] * v3[2]) * *v3)) / *(float *)&a2;
      v15 = v12[2] / *(float *)&a2;
      v12[1] = v7;
      v12[2] = v15;
      ++v10;
      v3 = v12;
      --v11;
    }
    while (v11);
  }
  return *(float *)&a2;
}

float MFS__ConstW_Cholesky_forward(uint64_t a1)
{
  float *v1;
  uint64_t *v2;
  float *v3;
  float v4;
  uint64_t v5;
  float result;
  uint64_t v7;
  float *v8;
  float *v9;
  uint64_t *v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  uint64_t v15;

  v2 = *(uint64_t **)(a1 + 96);
  v1 = *(float **)(a1 + 104);
  v3 = *(float **)(a1 + 88);
  v4 = *v1;
  *v3 = *v1;
  v5 = *v2;
  result = v1[1] - (float)(*(float *)(*v2 + 4) * v4);
  v3[1] = result;
  v7 = *(unsigned int *)(a1 + 20);
  if ((int)v7 >= 3)
  {
    v8 = v3 + 2;
    v9 = v1 + 2;
    v10 = v2 + 1;
    v11 = v7 - 2;
    do
    {
      v12 = *v9++;
      v13 = v12;
      v14 = *(float *)(v5 + 8);
      v15 = *v10++;
      v5 = v15;
      result = v13 - (float)((float)(v14 * *(v8 - 2)) + (float)(*(float *)(v15 + 4) * result));
      *v8++ = result;
      --v11;
    }
    while (v11);
  }
  return result;
}

float MFS__ConstW_Cholesky_backward(uint64_t a1, int a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  float *v7;
  float result;
  BOOL v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;

  v2 = *(_DWORD *)(a1 + 20);
  v3 = *(_QWORD *)(a1 + 88);
  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 40);
  v6 = *(float *)(v3 + 4 * (v2 - 1)) / **(float **)(v4 + 8 * (v2 - 1));
  *(float *)(*(_QWORD *)(v5 + 8 * (v2 - 1)) + 4 * a2) = v6;
  v7 = *(float **)(v4 + 8 * (v2 - 2));
  result = (float)(*(float *)(v3 + 4 * (v2 - 2)) / *v7) - (float)(v7[1] * v6);
  *(float *)(*(_QWORD *)(v5 + 8 * (v2 - 2)) + 4 * a2) = result;
  v9 = __OFSUB__(v2, 3);
  v10 = (v2 - 3);
  if ((int)v10 < 0 == v9)
  {
    v11 = (_QWORD *)(v5 + 8 * v10 + 16);
    v12 = v11;
    do
    {
      v13 = *--v12;
      result = (float)((float)(*(float *)(v3 + 4 * v10) / **(float **)(v4 + 8 * v10))
                     - (float)(*(float *)(*(_QWORD *)(v4 + 8 * v10) + 4) * *(float *)(v13 + 4 * a2)))
             - (float)(*(float *)(*(_QWORD *)(v4 + 8 * v10) + 8) * *(float *)(*v11 + 4 * a2));
      *(float *)(*(v11 - 2) + 4 * a2) = result;
      --v10;
      v11 = v12;
    }
    while (v10 != -1);
  }
  return result;
}

void MFS__mlpg2(uint64_t a1, int a2)
{
  double v4;

  if (*(int *)(a1 + 20) < 2)
  {
    MFS__meancpy(a1);
  }
  else
  {
    *(float *)&v4 = MFS__ConstW_Calc_R_and_r(a1, a2);
    MFS__ConstW_Cholesky(a1, v4);
    MFS__ConstW_Cholesky_forward(a1);
    MFS__ConstW_Cholesky_backward(a1, a2);
  }
}

char *MFS__heap_StrDup(_QWORD *a1, char *__s)
{
  int v4;
  char *v5;
  char *v6;

  if (!__s)
    return 0;
  v4 = cstdlib_strlen(__s);
  v5 = (char *)heap_Calloc(a1, (v4 + 1), 1);
  v6 = v5;
  if (v5)
    cstdlib_strcpy(v5, __s);
  return v6;
}

uint64_t MFS__xfread_BET3(void *a1, unsigned int a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  size_t v8;

  v5 = a3;
  v6 = *a4;
  v7 = a4[4];
  if (v6 + (_DWORD)a3 * a2 > v7)
    v5 = (v7 - v6) / a2;
  if ((_DWORD)v5)
  {
    v8 = v5 * a2;
    cstdlib_memcpy(a1, (const void *)(*((_QWORD *)a4 + 1) + v6), v8);
    *a4 += v8;
  }
  return v5;
}

uint64_t MFS__xfread2ptr_BET3(_QWORD *a1, unsigned int a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v4;
  unsigned int v5;

  v4 = *a4;
  if (a2 >= 2 && v4 % a2)
    return 0;
  v5 = a4[4];
  if (v4 + (_DWORD)a3 * a2 > v5)
    a3 = (v5 - v4) / a2;
  if ((_DWORD)a3)
  {
    *a1 = *((_QWORD *)a4 + 1) + v4;
    *a4 = v4 + a3 * a2;
  }
  return a3;
}

uint64_t MFS__log_out_Event(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v9;
  int v10;

  v9 = a3 - 1;
  do
    v10 = *(unsigned __int8 *)++v9;
  while (v10 == 10);
  return log_VOutEvent(*(uint64_t ***)(a1 + 32), a2, v9, &a9);
}

uint64_t MFS__log_select_Diag(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  int v4;

  v3 = a3 - 1;
  do
    v4 = *(unsigned __int8 *)++v3;
  while (v4 == 10);
  return log_VOutText(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", (a2 + 2), 0, v3);
}

uint64_t MFS__log_select_Error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;

  return log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SELECT_BET3", a2, 0, a5, a6, a7, a8, v9);
}

uint64_t MFS__log_select_GetLogLevel(uint64_t a1)
{
  unsigned int LogLevel;

  LogLevel = log_GetLogLevel(a1);
  if (LogLevel >= 3)
    return LogLevel - 2;
  else
    return 0;
}

float MFS__bet3_finv(float a1)
{
  float v1;

  v1 = 0.0;
  if (a1 < 1.0e19 && a1 > -1.0e19)
  {
    if (a1 > 1.0e-19 || a1 < 0.0)
    {
      if (a1 < -1.0e-19 || a1 >= 0.0)
        return 1.0 / a1;
      else
        return -1.0e38;
    }
    else
    {
      return 1.0e38;
    }
  }
  return v1;
}

_QWORD *MFS__ddcalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *MFS__ddcalloc_64(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *MFS__dd_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *MFS__dd_free_64(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *MFS__ffcalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *MFS__ff_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *MFS__int32_ccalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *MFS__int32_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

_QWORD *MFS__iicalloc(_QWORD *a1, unsigned int a2, int a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = 0;
  if ((int)a2 >= 1 && a3 >= 1)
  {
    v7 = a2;
    v3 = (_QWORD *)heap_Calloc(a1, a2, 8);
    if (v3)
    {
      v8 = heap_Calloc(a1, a3 * a2, 4);
      *v3 = v8;
      if (v8)
      {
        if (a2 >= 2)
        {
          v9 = 1;
          v10 = v8 + 4 * a3;
          do
          {
            v3[v9] = v10;
            v10 += 4 * a3;
            ++v9;
          }
          while (v7 != v9);
        }
      }
      else
      {
        heap_Free(a1, (uint64_t)v3);
        return 0;
      }
    }
  }
  return v3;
}

_QWORD *MFS__ii_free(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;

  if (a2)
  {
    v3 = result;
    heap_Free(result, *a2);
    return heap_Free(v3, (uint64_t)a2);
  }
  return result;
}

uint64_t MFS__InitDWinSet(int a1, void *__b, uint64_t a3)
{
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  int v8;
  int v9;
  int *v10;

  cstdlib_memset(__b, 0, 0x190uLL);
  v5 = *(unsigned int *)(a3 + 132);
  if ((int)v5 >= 1)
  {
    for (i = 0; i != v5; ++i)
    {
      v7 = a3 + 4 * i;
      v8 = *(_DWORD *)(v7 + 304);
      if (v8 >= 1)
      {
        v9 = 0;
        v10 = (int *)(v7 + 304);
        do
        {
          *((_DWORD *)__b + 10 * i) = v8 + 1;
          ++v9;
          v8 = *v10;
        }
        while (v9 < *v10);
      }
    }
  }
  return 0;
}

_QWORD **MFS__DeInitDWinSet(_QWORD **result, char *a2)
{
  _QWORD **v3;
  uint64_t i;
  char *v5;
  uint64_t *v6;

  if (a2)
  {
    v3 = result;
    for (i = 0; i != 400; i += 40)
    {
      v5 = &a2[i];
      MFS__ii_free(v3[1], *(uint64_t **)&a2[i + 8]);
      v6 = *(uint64_t **)&a2[i + 16];
      if (v6)
      {
        if (!*v6 || (heap_Free(v3[1], *v6), **((_QWORD **)v5 + 2) = 0, (v6 = (uint64_t *)*((_QWORD *)v5 + 2)) != 0))
        {
          heap_Free(v3[1], (uint64_t)v6);
          *((_QWORD *)v5 + 2) = 0;
        }
      }
    }
    return (_QWORD **)cstdlib_memset(a2, 0, 0x190uLL);
  }
  return result;
}

uint64_t MFS__LoadDWinFile(uint64_t a1, uint64_t a2, int a3, unsigned int *a4)
{
  unsigned int *v5;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  int ***v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t **v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  _DWORD *v28;
  int v29;
  int v30;
  int **v31;
  int *v32;
  int v33;
  int v34;

  v5 = (unsigned int *)(a2 + 40 * a3);
  if (!*v5)
    return 0;
  v9 = 2229280778;
  v10 = MFS__iicalloc(*(_QWORD **)(a1 + 8), *v5, 2);
  v11 = a2 + 40 * a3;
  *(_QWORD *)(v11 + 8) = v10;
  v12 = (int ***)(v11 + 8);
  if (v10)
  {
    v13 = heap_Calloc(*(_QWORD **)(a1 + 8), *v5, 8);
    v14 = a2 + 40 * a3;
    *(_QWORD *)(v14 + 16) = v13;
    v15 = (uint64_t **)(v14 + 16);
    if (v13)
    {
      *(_QWORD *)**v12 = 0;
      **v15 = heap_Calloc(*(_QWORD **)(a1 + 8), 1, 4);
      v16 = (_DWORD *)**v15;
      if (v16)
      {
        *v16 = 1065353216;
        LODWORD(v17) = *v5;
        if ((int)*v5 <= 1)
        {
LABEL_9:
          v27 = a2 + 40 * a3;
          *(_DWORD *)(v27 + 24) = 0;
          v28 = (_DWORD *)(v27 + 24);
          v28[1] = 0;
          if ((int)v17 < 1)
          {
            v30 = 0;
          }
          else
          {
            v29 = 0;
            v30 = 0;
            v31 = *v12;
            v17 = v17;
            do
            {
              v32 = *v31;
              v33 = **v31;
              if (v30 > v33)
              {
                *v28 = v33;
                v30 = v33;
              }
              v34 = v32[1];
              if (v29 < v34)
              {
                v28[1] = v34;
                v29 = v34;
              }
              ++v31;
              --v17;
            }
            while (v17);
            if (v30 < v29)
            {
              v9 = 0;
              *(_DWORD *)(a2 + 40 * a3 + 32) = v29;
              return v9;
            }
          }
          v9 = 0;
          *(_DWORD *)(a2 + 40 * a3 + 32) = v30;
          return v9;
        }
        v18 = 1;
        v19 = 1;
        while (1)
        {
          v20 = MFS__xfread2ptr_BET3(&(*v15)[v19], 4u, 0xFFFFFFFFLL, a4);
          if (!v20)
            break;
          (*v15)[v19] += 4 * (v20 >> 1);
          v26 = (*v12)[v19];
          *v26 = -(v20 >> 1);
          v26[1] = (v20 & 1) + (v20 >> 1) - 1;
          ++v18;
          v17 = (int)*v5;
          ++v19;
          a4 += 6;
          if (v18 >= v17)
            goto LABEL_9;
        }
        MFS__log_select_Error(a1, 55019, (uint64_t)"InitDWin: illegal data\n", v21, v22, v23, v24, v25);
        return 2229280772;
      }
    }
  }
  return v9;
}

void *MFS__InitSMatrices(uint64_t a1, _QWORD *__b)
{
  void *result;

  result = cstdlib_memset(__b, 0, 0x40uLL);
  *__b = a1;
  return result;
}

double MFS__FreeSMatrices(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  double result;

  if (a1)
  {
    if (*(_QWORD *)a1)
    {
      v2 = *(uint64_t **)(a1 + 24);
      if (v2)
      {
        if (!*(_DWORD *)(a1 + 8))
        {
          MFS__dd_free(*(_QWORD **)(*(_QWORD *)a1 + 8), v2);
          MFS__dd_free_64(*(_QWORD **)(*(_QWORD *)a1 + 8), *(uint64_t **)(a1 + 48));
          v3 = *(_QWORD *)(a1 + 40);
          if (v3)
            heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), v3);
        }
        *(_DWORD *)(a1 + 60) = 0;
        result = 0.0;
        *(_OWORD *)(a1 + 44) = 0u;
        *(_OWORD *)(a1 + 28) = 0u;
        *(_OWORD *)(a1 + 12) = 0u;
      }
    }
  }
  return result;
}

uint64_t MFS__InitPStreamSM(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 *v9;
  int v10;
  uint64_t v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  v4 = *a1;
  if (a2
    && *(_QWORD *)(a2 + 24)
    && *((_DWORD *)a1 + 3) == *(_DWORD *)(a2 + 12)
    && *((_DWORD *)a1 + 5) == *(_DWORD *)(a2 + 16)
    && *((_DWORD *)a1 + 6) == *(_DWORD *)(a2 + 20))
  {
    result = 0;
    v6 = *(_OWORD *)(a2 + 48);
    v8 = *(_OWORD *)a2;
    v7 = *(_OWORD *)(a2 + 16);
    *((_OWORD *)a1 + 5) = *(_OWORD *)(a2 + 32);
    *((_OWORD *)a1 + 6) = v6;
    *((_OWORD *)a1 + 3) = v8;
    *((_OWORD *)a1 + 4) = v7;
LABEL_12:
    *((_DWORD *)a1 + 14) = 1;
    return result;
  }
  a1[6] = v4;
  v9 = (__int128 *)(a1 + 6);
  v10 = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 14) = 0;
  *((_DWORD *)a1 + 15) = v10;
  v11 = *(uint64_t *)((char *)a1 + 20);
  a1[8] = v11;
  v12 = MFS__ddcalloc(*(_QWORD **)(v4 + 8), 2 * (int)v11, v10);
  a1[9] = (uint64_t)v12;
  if (v12
    && (v13 = *((_DWORD *)a1 + 6),
        v14 = *((int *)a1 + 5),
        a1[10] = (uint64_t)&v12[v14],
        v15 = MFS__ddcalloc_64(*(_QWORD **)(v4 + 8), v14, v13),
        (a1[12] = (uint64_t)v15) != 0)
    && (v16 = heap_Calloc(*(_QWORD **)(v4 + 8), (2 * *((_DWORD *)a1 + 5)), 4), (a1[11] = v16) != 0))
  {
    a1[13] = v16 + 4 * *((int *)a1 + 5);
    if (a2)
    {
      MFS__FreeSMatrices(a2);
      result = 0;
      v17 = *v9;
      v18 = *((_OWORD *)a1 + 4);
      v19 = *((_OWORD *)a1 + 6);
      *(_OWORD *)(a2 + 32) = *((_OWORD *)a1 + 5);
      *(_OWORD *)(a2 + 48) = v19;
      *(_OWORD *)a2 = v17;
      *(_OWORD *)(a2 + 16) = v18;
      goto LABEL_12;
    }
    return 0;
  }
  else
  {
    MFS__FreeSMatrices((uint64_t)(a1 + 6));
    return 2229280778;
  }
}

double MFS__FreePStreamSM(uint64_t a1)
{
  return MFS__FreeSMatrices(a1 + 48);
}

uint64_t MFS__InitPStreamParam(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _QWORD *v7;
  uint64_t result;

  v4 = *(_QWORD *)a1;
  a1[6] = (2 * *(_DWORD *)(*((_QWORD *)a1 + 4) + 32)) | 1;
  if (a2)
  {
    v5 = *(_QWORD *)(a2 + 40);
    if (v5)
    {
      if (a1[5] == *(_DWORD *)(a2 + 20) && a1[4] == *(_DWORD *)(a2 + 16))
      {
        *((_QWORD *)a1 + 5) = v5;
        v6 = a1 + 2;
LABEL_12:
        result = 0;
        *v6 = 1;
        return result;
      }
    }
  }
  a1[2] = 0;
  v6 = a1 + 2;
  v7 = MFS__int32_ccalloc(*(_QWORD **)(v4 + 8), a1[5], a1[4]);
  *((_QWORD *)a1 + 5) = v7;
  if (v7)
    result = 0;
  else
    result = 2229280778;
  if (a2 && v7)
  {
    MFS__FreePStreamParam((_QWORD *)a2);
    memcpy((void *)a2, a1, 0x2D8uLL);
    goto LABEL_12;
  }
  return result;
}

_QWORD *MFS__FreePStreamParam(_QWORD *result)
{
  _QWORD *v1;
  uint64_t *v2;

  if (*result)
  {
    v1 = result;
    v2 = (uint64_t *)result[5];
    if (v2)
    {
      if (!*((_DWORD *)result + 2))
        result = MFS__int32_free(*(_QWORD **)(*result + 8), v2);
      v1[5] = 0;
      *((_DWORD *)v1 + 2) = 0;
    }
  }
  return result;
}

uint64_t MFS__ParamGenStart(uint64_t a1, int *a2, int *a3)
{
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  int32x2_t *v20;
  uint64_t v21;
  int *v22;
  int *v23;
  int v24;
  uint64_t v25;
  int *v26;
  const char **v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  float v36;
  float v37;
  float v38;
  float v39;
  uint64_t v40;
  BOOL v41;
  float v42;
  float v43;
  uint64_t v44;
  _DWORD *v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  float v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  int *v57;
  uint64_t v58;
  float *v59;
  uint64_t v60;
  uint64_t i;
  uint64_t v62;
  uint64_t v63;
  int v64;
  char *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  _QWORD *v69;
  _QWORD *v70;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  float v76;
  float v77;
  uint64_t v78;
  uint64_t v79;
  int32x2_t *v80;
  int *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int *v88;
  uint64_t v89;
  unsigned __int16 *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int32x2_t *v94;

  v4 = a2;
  v5 = a1;
  v6 = *(_QWORD *)a1;
  result = MFS__InitUttModel(*(_QWORD *)a1, (char *)(a1 + 56), a2, *(__int16 *)(*(_QWORD *)(a1 + 8) + 10));
  if ((result & 0x80000000) == 0)
  {
    *(_DWORD *)(v5 + 16) = a3[8];
    v13 = a3[7];
    if (v13 >= 1 && v13 < *(_DWORD *)(v5 + 620))
    {
      MFS__log_select_Error(v6, 55018, (uint64_t)"Specified length of generated speech is too short (this sentence is composed from %d states), specify more than %d milliseconds\n", v8, v9, v10, v11, v12);
      return 2229280775;
    }
    if (*(int *)(v5 + 608) >= 1)
    {
      v14 = 0;
      v85 = 0;
      v86 = 0;
      v92 = v5;
      v93 = (uint64_t)(v4 + 116);
      v15 = *(_DWORD *)(v5 + 32);
      v81 = a3 + 326;
      v82 = *(_QWORD *)(*(_QWORD *)(v5 + 8) + 1784);
      v16 = -0.5;
      v17 = 0.0;
      v18 = 0.0;
      v84 = (uint64_t)a3;
      v89 = (uint64_t)v4;
      v91 = v6;
      while (1)
      {
        v19 = *(_QWORD *)(v5 + 600);
        v20 = (int32x2_t *)(v19 + 528 * v14);
        v87 = v19;
        v94 = v20;
        if (v15 >= 1)
        {
          v21 = 0;
          v22 = v81;
          do
          {
            v23 = &a3[v21];
            v24 = v23[86];
            if (v24 < 1)
            {
              LODWORD(v25) = 0;
            }
            else
            {
              v25 = 0;
              v26 = v23 + 86;
              v27 = (const char **)&a3[2 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v5 + 8) + 248) + v20->i32[0])
                                     + 1326];
              do
              {
                v28 = *(const char **)&v22[2 * v25];
                if (v28 && *v27)
                {
                  if (!cstdlib_strcmp(v28, *v27))
                    goto LABEL_18;
                  v24 = *v26;
                }
                ++v25;
              }
              while (v25 < v24);
              LODWORD(v25) = 0;
LABEL_18:
              v19 = v87;
              v20 = v94;
            }
            *(_DWORD *)(v19 + 528 * v14 + 4 * v21++ + 32) = v25;
            v22 += 10;
          }
          while (v21 < *(int *)(v5 + 32));
        }
        MFS__log_select_Diag(v6, 21, (uint64_t)"[phoneme %d]\n");
        if (!v82)
          break;
        if (a3[29])
        {
          v34 = v19 + 528 * v14;
          *(_DWORD *)(v34 + 8) = MFS__TreeSearch(*(_QWORD *)(v5 + 8), v14, v93, 0, 0);
          MFS__log_select_Diag(v6, 6, (uint64_t)"DUR pdf id %d\n");
          result = MFS__FindDurPDF(v94, v4, 0, *(_DWORD *)(v34 + 32), 0, *(float *)(v5 + 16));
          if ((result & 0x80000000) != 0)
            return result;
          LOWORD(v35) = *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 8) + 1784) + 2 * v94->i32[0]);
          v36 = MFS__div_int32_int32_to_Q8_24((float)v35, (float)a3[6]);
          if (v36 != 0.0)
          {
            v37 = v36;
            v38 = 0.0;
            v39 = 0.0;
            if (*v4 >= 1)
            {
              v40 = 2;
              do
              {
                v39 = v39 + MFS__int32_to_Q12_20((float)*(int *)(*(_QWORD *)(v19 + 528 * v14 + 16) + 4 * v40));
                v41 = v40++ <= *v4;
              }
              while (v41);
            }
            v42 = v16 + v37;
            v43 = MFS__div_Q8_24_Q12_20_to_Q8_24(v42, v39);
            v44 = v19 + 528 * v14;
            *(_DWORD *)(v44 + 24) = 0;
            v45 = (_DWORD *)(v44 + 24);
            if (*v4 >= 1)
            {
              v46 = v43;
              v47 = v19 + 528 * v14;
              v50 = *(_QWORD *)(v47 + 16);
              v49 = (uint64_t *)(v47 + 16);
              v48 = v50;
              v51 = 2;
              do
              {
                v52 = MFS__mul_int32_Q8_24_to_Q8_24((float)*(int *)(v48 + 4 * v51), v46);
                v53 = (int)MFS__Q8_24_to_int32(v52 + 0.5);
                if (v53 <= 1)
                  v54 = 1;
                else
                  v54 = v53;
                v48 = *v49;
                *(_DWORD *)(*v49 + 4 * v51) = v54;
                v55 = *v45 + v54;
                *v45 = v55;
                v41 = v51++ <= *v4;
              }
              while (v41);
              v38 = (float)v55;
            }
            v16 = v42 - MFS__int32_to_Q8_24(v38);
          }
LABEL_45:
          *(_DWORD *)(v5 + 624) += *(_DWORD *)(v19 + 528 * v14 + 24);
          goto LABEL_46;
        }
        if (!a3[28])
          break;
        result = MFS__log_select_Error(v6, 55017, (uint64_t)"State level segmentation is not currently supported\n", v29, v30, v31, v32, v33);
LABEL_46:
        v83 = v14;
        v15 = *(_DWORD *)(v5 + 32);
        if (v15 >= 1)
        {
          for (i = 0; i < v15; ++i)
          {
            v62 = *(_QWORD *)(v5 + 24);
            if (!*(_DWORD *)(v62 + 1528 * i + 1480))
            {
              if (*(_DWORD *)(v62 + 1528 * i + 1488))
              {
                v63 = v5 + 8 * i;
                v64 = *v4 * v83;
                v85 = *(_QWORD *)(*(_QWORD *)(v63 + 304) + 8 * v64);
                v86 = *(_QWORD *)(*(_QWORD *)(v63 + 224) + 8 * v64);
              }
              v65 = (char *)v4 + 2 * i;
              if (*((_WORD *)v65 + 324))
              {
                v66 = 0;
                v67 = 0;
                v90 = (unsigned __int16 *)(v65 + 648);
                v68 = v19 + 528 * v83;
                v69 = (_QWORD *)(v68 + 8 * i);
                v70 = v69 + 9;
                v71 = v69 + 19;
                v72 = v69 + 29;
                v88 = (int *)(v68 + 4 * i + 32);
                do
                {
                  v73 = *(unsigned __int16 *)(*(_QWORD *)&v4[2 * i + 142] + v66);
                  *(_DWORD *)(*v70 + 4 * v73) = MFS__TreeSearch(*(_QWORD *)(v92 + 8), v94->i32[0], v93, i, v67);
                  result = MFS__log_select_Diag(v91, 6, (uint64_t)"%s pdf state %d id %d\n");
                  v74 = *(_QWORD *)(v92 + 24);
                  if (*(_DWORD *)(v74 + 1528 * i + 1488))
                  {
                    v75 = v73 - 2 + (v73 - 2) * v4[i + 1];
                    *(_QWORD *)(*v71 + 8 * v73) = v86 + 4 * v75;
                    *(_QWORD *)(*v71 + 8 * v73) -= 4;
                    *(_QWORD *)(*v72 + 8 * v73) = v85 + 4 * v75;
                    *(_QWORD *)(*v72 + 8 * v73) -= 4;
                    result = MFS__FindMsdPDF(i, v73, (uint64_t)v94, v89, v84, *v88);
                    if ((result & 0x80000000) != 0)
                      return result;
                  }
                  else if (*(_DWORD *)(v74 + 1528 * i + 1484))
                  {
                    result = MFS__FindContPDF(i, v73, (uint64_t)v94, v89, *v88);
                    if ((result & 0x80000000) != 0)
                      return result;
                  }
                  ++v67;
                  v66 += 16;
                }
                while (v67 < *v90);
                v5 = v92;
                v15 = *(_DWORD *)(v92 + 32);
                a3 = (int *)v84;
                v4 = (int *)v89;
                v19 = v87;
              }
            }
          }
        }
        v14 = v83 + 1;
        v6 = v91;
        if (v83 + 1 >= *(int *)(v5 + 608))
        {
          v13 = a3[7];
          goto LABEL_65;
        }
      }
      v56 = v19 + 528 * v14;
      *(_DWORD *)(v56 + 8) = MFS__TreeSearch(*(_QWORD *)(v5 + 8), v14, v93, 0, 0);
      v57 = (int *)(v56 + 8);
      result = MFS__log_select_Diag(v6, 6, (uint64_t)"DUR pdf id %d\n");
      if (a3[7])
      {
        v58 = *v4;
        if ((int)v58 >= 1)
        {
          v59 = (float *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v4 + 21) + 8 * *(int *)(v19 + 528 * v14 + 32))
                                    + 8 * *v57)
                        + 8);
          v60 = (v58 + 2) - 2;
          do
          {
            v18 = v18 + *v59;
            v17 = v17 + v59[v58];
            ++v59;
            --v60;
          }
          while (v60);
        }
        goto LABEL_46;
      }
      result = MFS__FindDurPDF(v94, v4, 0, *(_DWORD *)(v19 + 528 * v14 + 32), 0, *(float *)(v5 + 16));
      if ((result & 0x80000000) != 0)
        return result;
      SetSilenceDuration_3(v5, v4, (uint64_t)a3, (int *)v94);
      goto LABEL_45;
    }
    v18 = 0.0;
    v17 = 0.0;
LABEL_65:
    if (v13 < 1
      || (v76 = MFS__int32_to_Q18_14(result, (float)v13),
          v77 = MFS__div_Q18_14_Q18_14_to_Q18_14(v76 - v18, v17),
          *(float *)(v5 + 16) = MFS__Q18_14_to_Q1_15(v77),
          *(int *)(v5 + 608) < 1))
    {
LABEL_70:
      if (MFS__log_select_GetLogLevel(*(_QWORD *)(v6 + 32)) >= 0x15)
        OutLabel_4(v5);
      MFS__log_select_Diag(v6, 2, (uint64_t)">> tree search done\n");
      AddBreakMarks_3(v5, v4, (uint64_t)a3);
      return ParamGenLT_3(v5, v4);
    }
    else
    {
      v78 = 0;
      v79 = 0;
      while (1)
      {
        v80 = (int32x2_t *)(*(_QWORD *)(v5 + 600) + v78);
        result = MFS__FindDurPDF(v80, v4, 0, v80[4].i32[0], 0, *(float *)(v5 + 16));
        if ((result & 0x80000000) != 0)
          break;
        SetSilenceDuration_3(v5, v4, (uint64_t)a3, (int *)v80);
        *(_DWORD *)(v5 + 624) += v80[3].i32[0];
        ++v79;
        v78 += 528;
        if (v79 >= *(int *)(v5 + 608))
          goto LABEL_70;
      }
    }
  }
  return result;
}

void SetSilenceDuration_3(uint64_t a1, int *a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  int v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  int v20;
  float v21;
  uint64_t v22;
  float v23;
  uint64_t v24;
  int v25;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *a4;
  if (*(_BYTE *)(*(_QWORD *)(v4 + 32) + v5) == 1)
  {
    v8 = *(unsigned __int16 *)(*(_QWORD *)(v4 + 1784) + 2 * v5) / *(int *)(a3 + 24);
    LODWORD(v4) = *a2;
    if (v8 <= *a2)
    {
      if ((int)v4 >= 1)
      {
        v14 = *((_QWORD *)a4 + 2);
        v15 = 2;
        do
        {
          *(_DWORD *)(v14 + 4 * v15) = 1;
          v11 = v15++ <= *a2;
        }
        while (v11);
        LODWORD(v4) = *a2;
      }
      a4[6] = v4;
    }
    else
    {
      if (v8 >= a4[6])
      {
        if ((int)v4 < 1)
        {
          v12 = 0;
          v13 = 0;
        }
        else
        {
          v13 = 0;
          v12 = 0;
          v16 = *((_QWORD *)a4 + 2);
          v17 = 2;
          do
          {
            v18 = *(_DWORD *)(v16 + 4 * v17);
            if (v18 <= 0)
            {
              v18 = 1;
              *(_DWORD *)(v16 + 4 * v17) = 1;
              LODWORD(v4) = *a2;
            }
            v19 = v17 == 2 || v17 == (_DWORD)v4 + 1;
            if (v19)
              v20 = 0;
            else
              v20 = v18;
            v12 += v20;
            if (!v19)
              v18 = 0;
            v13 += v18;
            v11 = v17++ <= (int)v4;
          }
          while (v11);
        }
      }
      else
      {
        if ((int)v4 >= 1)
        {
          v9 = *((_QWORD *)a4 + 2);
          v10 = 2;
          do
          {
            *(_DWORD *)(v9 + 4 * v10) = 1;
            v4 = *a2;
            v11 = v10++ <= v4;
          }
          while (v11);
        }
        v12 = v4 - 2;
        v13 = 2;
      }
      v21 = MFS__div_int32_int32_to_Q8_24((float)(v8 - v13), (float)v12);
      a4[6] = v13;
      LODWORD(v22) = *a2;
      if (*a2 >= 3)
      {
        v23 = v21;
        v24 = 3;
        do
        {
          if (v24 >= (int)v22)
            v25 = v8 - v13;
          else
            v25 = (int)MFS__mul_int32_Q8_24_to_int32((float)*(int *)(*((_QWORD *)a4 + 2) + 4 * v24), v23);
          if (v25 <= 1)
            v25 = 1;
          *(_DWORD *)(*((_QWORD *)a4 + 2) + 4 * v24) = v25;
          v13 = a4[6] + v25;
          a4[6] = v13;
          v22 = *a2;
          v11 = v24++ < v22;
        }
        while (v11);
      }
    }
  }
}

uint64_t OutLabel_4(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  if (*(int *)(result + 608) >= 1)
  {
    v1 = result;
    v2 = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(v1 + 600) + v2;
      result = MFS__log_select_Diag(*(_QWORD *)v1, 21, (uint64_t)"%d %d %d [%d]\n");
      v4 += *(_DWORD *)(v5 + 24);
      ++v3;
      v2 += 528;
    }
    while (v3 < *(int *)(v1 + 608));
  }
  return result;
}

uint64_t AddBreakMarks_3(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int *v22;
  uint64_t v23;
  int v24;
  int v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;

  result = cstdlib_strcmp(*(const char **)(a3 + 80), "PHRASE_TIME");
  if ((_DWORD)result)
  {
    result = cstdlib_strcmp(*(const char **)(a3 + 80), "PHRASE");
    if ((_DWORD)result)
    {
      result = cstdlib_strcmp(*(const char **)(a3 + 80), "WORD");
      if ((_DWORD)result)
      {
        result = cstdlib_strcmp(*(const char **)(a3 + 80), "SYLLABLE");
        if ((_DWORD)result)
        {
          result = cstdlib_strcmp(*(const char **)(a3 + 80), "TIME");
          if ((_DWORD)result)
          {
            result = cstdlib_strcmp(*(const char **)(a3 + 80), "NONE");
            if ((_DWORD)result)
              return MFS__log_select_Error(*(_QWORD *)a1, 55036, (uint64_t)"valid breaker is required\n", v7, v8, v9, v10, v11);
          }
          else
          {
            v38 = *(unsigned int *)(a1 + 608);
            if ((int)v38 >= 1)
            {
              v39 = 0;
              v40 = 0;
              v41 = *(_DWORD *)(a3 + 88);
              v42 = *a2;
              v43 = *(_QWORD *)(a1 + 600);
              v44 = v41;
              v45 = 0;
              do
              {
                if (v42 >= 1)
                {
                  result = *(_QWORD *)(v43 + 528 * v39 + 16) + 8;
                  v46 = (v42 + 2) - 2;
                  v45 = v40;
                  do
                  {
                    v47 = *(_DWORD *)result;
                    result += 4;
                    v45 += v47;
                    --v46;
                  }
                  while (v46);
                }
                if (v45 > v44)
                {
                  v44 = v40 + v41;
                  v48 = v43 + 528 * v39;
                  result = *(_DWORD *)(v48 + 4) | 2u;
                  *(_DWORD *)(v48 + 4) = result;
                }
                ++v39;
                v40 = v45;
              }
              while (v39 != v38);
            }
          }
        }
        else
        {
          v34 = *(_DWORD *)(a1 + 608);
          if (v34 >= 3)
          {
            v35 = (v34 - 2);
            v36 = *(int **)(a1 + 600);
            v37 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
            do
            {
              if (*(_BYTE *)(v37 + *v36))
                v36[133] |= 2u;
              v36 += 132;
              --v35;
            }
            while (v35);
          }
        }
      }
      else
      {
        v30 = *(_DWORD *)(a1 + 608);
        if (v30 >= 3)
        {
          v31 = (v30 - 2);
          v32 = *(int **)(a1 + 600);
          v33 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
          do
          {
            if ((*(_BYTE *)(v33 + *v32) & 0xFE) == 2)
              v32[133] |= 2u;
            v32 += 132;
            --v31;
          }
          while (v31);
        }
      }
    }
    else
    {
      v26 = *(_DWORD *)(a1 + 608);
      if (v26 >= 3)
      {
        v27 = (v26 - 2);
        v28 = *(int **)(a1 + 600);
        v29 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
        do
        {
          if (*(_BYTE *)(v29 + *v28) == 3)
            v28[133] |= 2u;
          v28 += 132;
          --v27;
        }
        while (v27);
      }
    }
  }
  else
  {
    v12 = *(int *)(a1 + 608);
    if ((int)v12 >= 1)
    {
      v13 = 0;
      v14 = 0;
      v15 = *(_QWORD *)(a1 + 600);
      v16 = *a2;
      v17 = *(_DWORD *)(a3 + 88);
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112);
      v19 = v12 - 2;
      v20 = *(unsigned int *)(a1 + 608);
      do
      {
        if (v16 < 1)
        {
          v21 = 0;
        }
        else
        {
          v21 = 0;
          v22 = (int *)(*(_QWORD *)(v15 + 528 * v13 + 16) + 8);
          v23 = (v16 + 2) - 2;
          do
          {
            v24 = *v22++;
            v21 += v24;
            --v23;
          }
          while (v23);
        }
        v14 += v21;
        if (v14 > v17)
        {
          *(_DWORD *)(v15 + 528 * v13 + 4) |= 2u;
          v14 = v21;
        }
        result = v15 + 528 * v13;
        if (*(_BYTE *)(v18 + *(int *)result) == 3 && v13 < v19)
        {
          v14 = 0;
          *(_DWORD *)(result + 532) |= 2u;
        }
        ++v13;
      }
      while (v13 != v20);
    }
  }
  return result;
}

uint64_t ParamGenLT_3(uint64_t a1, int *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  BOOL v21;
  uint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t inited;
  uint64_t v29;
  _QWORD *v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int *v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  float v61;
  _QWORD *v62;
  uint64_t v63;
  _QWORD *v64;
  float v65;
  uint64_t *v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t *v71;
  int v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _OWORD v77[4];
  _OWORD v78[4];
  _OWORD __b[46];

  v3 = *(_QWORD *)a1;
  v4 = 2229280778;
  memset(__b, 0, 512);
  memset(v78, 0, sizeof(v78));
  memset(v77, 0, sizeof(v77));
  cstdlib_memset(__b, 0, 0x2D8uLL);
  MFS__InitSMatrices(v3, v78);
  MFS__InitSMatrices(v3, v77);
  v5 = heap_Calloc(*(_QWORD **)(v3 + 8), (*(_DWORD *)(a1 + 624) + 1), 1);
  *(_QWORD *)(a1 + 48) = v5;
  if (!v5)
    return v4;
  v6 = heap_Calloc(*(_QWORD **)(v3 + 8), (*(_DWORD *)(a1 + 624) + 1), 4);
  *(_QWORD *)(a1 + 40) = v6;
  if (!v6)
    return v4;
  v7 = *(_DWORD *)(a1 + 608);
  if (v7 >= 1)
  {
    v8 = 0;
    v9 = 0;
    LODWORD(v10) = *a2;
    do
    {
      if ((int)v10 >= 1)
      {
        v11 = *(_QWORD *)(a1 + 600) + 528 * v8;
        v14 = *(_QWORD *)(v11 + 16);
        v12 = (uint64_t *)(v11 + 16);
        v13 = v14;
        v15 = v12 + 37;
        v16 = 2;
        do
        {
          if (*(int *)(v13 + 4 * v16) >= 1)
          {
            v17 = 0;
            v18 = v9;
            do
            {
              *(_BYTE *)(*(_QWORD *)(a1 + 48) + v18) = *(_BYTE *)(*v15 + v16);
              *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v18++) = *(_DWORD *)(v12[38] + 4 * v16);
              v13 = *v12;
              ++v17;
            }
            while (v17 < *(_DWORD *)(*v12 + 4 * v16));
            v9 += v17;
          }
          v19 = *(unsigned int *)(a1 + 32);
          if ((int)v19 >= 1)
          {
            v20 = *(_DWORD **)(a1 + 24);
            do
            {
              if (v20[372] && ((1 << v20[3]) & (unint64_t)*(unsigned __int8 *)(*v15 + v16)) >> v20[3])
                v20[11] += *(_DWORD *)(v13 + 4 * v16);
              v20 += 382;
              --v19;
            }
            while (v19);
          }
          v10 = *a2;
          v21 = v16++ <= v10;
        }
        while (v21);
        v7 = *(_DWORD *)(a1 + 608);
      }
      ++v8;
    }
    while (v8 < v7);
  }
  if (*(int *)(a1 + 32) < 1)
  {
    v4 = 0;
    goto LABEL_65;
  }
  v22 = 0;
  v23 = 0;
  v4 = 0;
  v24 = (_QWORD *)(a1 + 56);
  while (1)
  {
    v25 = *(_QWORD *)(a1 + 24);
    v26 = v25 + 1528 * v22;
    if (*(_DWORD *)(v26 + 1488))
      break;
LABEL_61:
    if (++v22 >= *(int *)(a1 + 32))
      goto LABEL_65;
  }
  if (!*(_DWORD *)(v25 + 1528 * v22 + 44))
  {
LABEL_60:
    MFS__DeInitMSDUttModel(v24, v22);
    goto LABEL_61;
  }
  v27 = (uint64_t *)(v26 + 24);
  inited = MFS__InitPStreamParam((_DWORD *)(v26 + 24), 0);
  if ((inited & 0x80000000) == 0)
  {
    v29 = MFS__InitPStreamSM(v27, (uint64_t)v78);
    v4 = v29;
    if ((v29 & 0x80000000) != 0)
      goto LABEL_65;
    v31 = *(_DWORD *)(a1 + 608);
    if (v31 >= 1)
    {
      v67 = v27;
      v68 = v29;
      v32 = 0;
      v33 = 0;
      v34 = 0;
      v35 = v25 + 1528 * v22;
      v36 = v35 + 56;
      v37 = (_QWORD *)(v35 + 96);
      v38 = (_QWORD *)(v35 + 104);
      v39 = *a2;
      v74 = v22;
      do
      {
        if (v39 >= 1)
        {
          v69 = v32;
          v40 = *(_QWORD *)(a1 + 600) + 528 * v32;
          v41 = v40 + 8 * v22;
          v42 = *(_QWORD *)(v40 + 16);
          v71 = (uint64_t *)(v40 + 16);
          v30 = (_QWORD *)(v41 + 152);
          v43 = (_QWORD *)(v41 + 232);
          v44 = 2;
          do
          {
            if (*(int *)(v42 + 4 * v44) >= 1)
            {
              v45 = v34;
              v46 = *(_QWORD *)(a1 + 24);
              v47 = 1;
              v75 = v44;
              do
              {
                if (*(int *)(v46 + 1528 * v22 + 36) >= 1)
                {
                  v72 = v47;
                  v48 = 0;
                  v73 = v33;
                  v49 = v33;
                  v76 = v33;
                  do
                  {
                    v50 = *(_DWORD *)(v46 + 1528 * v22 + 12);
                    v51 = 1 << v50;
                    v52 = (1 << v50);
                    v23 |= v52;
                    v53 = *(int **)(*(_QWORD *)(*(_QWORD *)v36 + 8) + 8 * v48);
                    v55 = *v53;
                    v54 = v53[1];
                    if (v55 <= v54)
                    {
                      v56 = v52 ^ 0xFF;
                      v57 = v54 - v55 + 1;
                      v58 = v34 + v55;
                      do
                      {
                        v59 = v56;
                        if ((v58 & 0x80000000) == 0)
                        {
                          v59 = v56;
                          if (*(_DWORD *)(a1 + 624) >= (signed int)v58)
                            v59 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + v58);
                        }
                        v23 &= v59;
                        ++v58;
                        --v57;
                      }
                      while (v57);
                    }
                    if ((unint64_t)(v51 & *(_BYTE *)(*(_QWORD *)(a1 + 48) + v45)) >> v50)
                    {
                      if (!v48 || (v51 & v23) >> v50)
                      {
                        v60 = 4 * v48 + 4;
                        *(_DWORD *)(*(_QWORD *)(*v37 + 8 * v49) + 4 * v48) = *(_DWORD *)(*(_QWORD *)(*v30 + 8 * v44)
                                                                                       + v60);
                        v61 = *(float *)(*(_QWORD *)(*v43 + 8 * v44) + v60);
                        if (*(_DWORD *)(v46 + 1528 * v22 + 1492))
                        {
                          *(float *)(*(_QWORD *)(*v38 + 8 * v49) + 4 * v48) = v61;
                        }
                        else
                        {
                          v62 = v38;
                          v63 = v36;
                          v64 = v30;
                          v65 = MFS__bet3_finv(v61);
                          v30 = v64;
                          v44 = v75;
                          v49 = v76;
                          v36 = v63;
                          v22 = v74;
                          v38 = v62;
                          *(float *)(*(_QWORD *)(*v62 + 8 * v76) + 4 * v48) = v65;
                          v46 = *(_QWORD *)(a1 + 24);
                        }
                      }
                      else
                      {
                        *(_DWORD *)(*(_QWORD *)(*v37 + 8 * v49) + 4 * v48) = 0;
                        *(_DWORD *)(*(_QWORD *)(*v38 + 8 * v49) + 4 * v48) = 0;
                      }
                    }
                    ++v48;
                  }
                  while (v48 < *(int *)(v46 + 1528 * v22 + 36));
                  v42 = *v71;
                  v33 = v73;
                  v47 = v72;
                }
                if (((1 << *(_DWORD *)(v46 + 1528 * v22 + 12)) & (unint64_t)*(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + v45)) >> *(_DWORD *)(v46 + 1528 * v22 + 12))
                  ++v33;
                ++v45;
                ++v34;
                v21 = v47++ < *(_DWORD *)(v42 + 4 * v44);
              }
              while (v21);
              v39 = *a2;
              v34 = v45;
            }
            v21 = v44++ <= v39;
          }
          while (v21);
          v31 = *(_DWORD *)(a1 + 608);
          v32 = v69;
        }
        ++v32;
      }
      while (v32 < v31);
      v24 = (_QWORD *)(a1 + 56);
      if (v33 < 1)
      {
        v4 = v68;
        v27 = v67;
      }
      else
      {
        v27 = v67;
        (**(void (***)(uint64_t *, _QWORD, uint64_t, _QWORD *))(*(_QWORD *)(a1 + 24) + 1528 * v22 + 1504))(v67, 0, v36, v30);
        v4 = v68;
      }
    }
    MFS__FreePStreamSM((uint64_t)v27);
    goto LABEL_60;
  }
  v4 = inited;
LABEL_65:
  MFS__FreePStreamParam(__b);
  MFS__FreeSMatrices((uint64_t)v78);
  MFS__FreeSMatrices((uint64_t)v77);
  return v4;
}

uint64_t MFS__ParamGenFrames(uint64_t *a1, int *a2, _DWORD *a3)
{
  uint64_t *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  BOOL v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  int v31;
  uint64_t v33;
  int v34;
  int *v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD **v45;
  _QWORD *v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  _DWORD *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  _DWORD *v73;
  uint64_t v74;
  _DWORD *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  float v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  _DWORD *v88;
  _DWORD *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t *v93;
  int **v94;
  int *v95;
  int v96;
  uint64_t v97;
  signed int v98;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  _QWORD *v105;
  int *v106;
  _QWORD **v107;
  uint64_t v108;
  unsigned int *v109;
  unsigned int inited;
  uint64_t v111;
  int *v112;
  uint64_t v113;
  uint64_t *v114;
  uint64_t *v115;
  uint64_t v116;
  _DWORD *v117;
  uint64_t v118;
  int v119;
  _OWORD v120[4];
  _OWORD v121[4];
  _OWORD __b[46];

  v4 = a1;
  v5 = *a1;
  memset(__b, 0, 512);
  memset(v121, 0, sizeof(v121));
  memset(v120, 0, sizeof(v120));
  *a3 = 0;
  cstdlib_memset(__b, 0, 0x2D8uLL);
  MFS__InitSMatrices(v5, v121);
  v103 = v5;
  MFS__InitSMatrices(v5, v120);
  v6 = *((_DWORD *)v4 + 153);
  v7 = v4[75] + 528 * v6;
  *(_DWORD *)(v7 + 4) &= ~2u;
  v8 = *((_DWORD *)v4 + 152);
  v9 = __OFSUB__(v8, v6);
  v10 = v8 - v6;
  if ((v10 < 0) ^ v9 | (v10 == 0))
  {
    LODWORD(v12) = 0;
    v11 = 0;
  }
  else
  {
    v11 = 0;
    LODWORD(v12) = 0;
    while ((*(_BYTE *)(v7 + 4) & 2) == 0)
    {
      v13 = *a2;
      if ((int)v13 >= 1)
      {
        v14 = (int *)(*(_QWORD *)(v7 + 16) + 8);
        do
        {
          v15 = *v14++;
          LODWORD(v12) = v15 + v12;
          --v13;
        }
        while (v13);
      }
      v7 += 528;
      if (++v11 == v10)
      {
        v11 = v10;
        break;
      }
    }
  }
  MFS__log_select_Diag(v5, 2, (uint64_t)"| processing %d models %d frames <=> ");
  if (*((int *)v4 + 8) >= 1)
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v119 = 0;
    v19 = 0;
    inited = 0;
    v101 = -(uint64_t)v11;
    v102 = v11;
    v115 = v4;
    v106 = a2;
    while (1)
    {
      v20 = v4[3];
      if (*(_DWORD *)(v20 + 1528 * v16 + 1484))
      {
        v21 = v20 + 1528 * v16;
        v107 = (_QWORD **)(v21 + 64);
        v116 = v16;
        v117 = (_DWORD *)(v21 + 24);
        if (*(_QWORD *)(v21 + 64))
        {
          MFS__FreePStreamParam((_QWORD *)(v21 + 24));
          v16 = v116;
        }
        v22 = v4[3] + 1528 * v16;
        v23 = *(_DWORD *)(v22 + 1496);
        v111 = *(unsigned int *)(v22 + 1500);
        v24 = *((_DWORD *)v4 + 153);
        v25 = *((_DWORD *)v4 + 152);
        if ((int)(v17 + v11 + v24) < v25 && v18 < v23)
        {
          v27 = *a2;
          v28 = v7;
          do
          {
            if (v27 >= 1)
            {
              v29 = (int *)(*(_QWORD *)(v28 + 16) + 8);
              v30 = (v27 + 2) - 2;
              do
              {
                v31 = *v29++;
                v18 += v31;
                --v30;
              }
              while (v30);
            }
            v28 += 528;
            v17 = (v17 + 1);
          }
          while ((int)(v17 + v11 + v24) < v25 && v18 < v23);
        }
        if (v24 > v119 && v19 < v23)
        {
          v33 = v7 + 528 * v101;
          v34 = *a2;
          do
          {
            if (v34 >= 1)
            {
              v35 = (int *)(*(_QWORD *)(v33 - 512) + 8);
              v36 = (v34 + 2) - 2;
              do
              {
                v37 = *v35++;
                v19 += v37;
                --v36;
              }
              while (v36);
            }
            if (v24 <= ++v119)
              break;
            v33 -= 528;
          }
          while (v19 < v23);
        }
        v108 = v7;
        v104 = v17;
        MFS__log_select_Diag(v103, 3, (uint64_t)"L: %d %d  R: %d %d\n");
        v38 = v20 + 1528 * v116;
        *(_DWORD *)(v38 + 44) = v12;
        v109 = (unsigned int *)(v38 + 44);
        *(_DWORD *)(v38 + 772) = v111 + v12 + v18 + v19 + v111;
        inited = MFS__InitPStreamParam(v117, 0);
        if ((inited & 0x80000000) != 0)
          goto LABEL_96;
        v39 = v20 + 1528 * v116;
        v42 = *(_DWORD *)(v39 + 40);
        v41 = (int *)(v39 + 40);
        v40 = v42;
        v16 = v116;
        if (v42 >= 1)
        {
          v43 = 0;
          v114 = (uint64_t *)(v107 + 86);
          v112 = (int *)(v109 + 182);
          v44 = v20 + 1528 * v116;
          v45 = (_DWORD **)(v44 + 784);
          v46 = (_QWORD *)(v44 + 824);
          v47 = (_QWORD *)(v44 + 832);
          v118 = v17 + v102 + v119;
          v105 = (_QWORD *)(v44 + 792);
          v48 = 0;
          while (1)
          {
            if (*(_DWORD *)(*(_QWORD *)(v115[3] + 1528 * v116 + 1520) + 4 * v48) == 1)
            {
              v49 = MFS__InitPStreamParam(v114, (uint64_t)__b);
              if ((v49 & 0x80000000) != 0)
              {
                v51 = v49;
                goto LABEL_98;
              }
              v50 = MFS__InitPStreamSM(v114, (uint64_t)v120);
              v51 = v50;
              if ((v50 & 0x80000000) != 0)
                goto LABEL_98;
              inited = v50;
              v113 = v48;
              if ((int)v111 < 1)
              {
                LODWORD(v52) = 0;
              }
              else
              {
                v52 = 0;
                v53 = *v112 & ~(*v112 >> 31);
                do
                {
                  if (v52 == v53)
                    break;
                  v54 = **v45;
                  if ((int)v54 >= 1)
                  {
                    v55 = *(_DWORD **)(*v46 + 8 * v52);
                    v56 = *(_DWORD **)(*v47 + 8 * v52);
                    do
                    {
                      *v55++ = 0;
                      *v56++ = 1065353216;
                      --v54;
                    }
                    while (v54);
                  }
                  ++v52;
                }
                while (v52 != v111);
              }
              LODWORD(v12) = v52;
              if ((int)v118 >= 1)
              {
                v57 = 0;
                v58 = v115[75];
                v59 = *((_DWORD *)v115 + 153);
                v60 = *v106;
                v61 = (*v106 + 2);
                LODWORD(v12) = v52;
                do
                {
                  v62 = v57 - v119 + v59;
                  if (v60 >= 1)
                  {
                    v63 = v58 + 528 * v62;
                    v64 = *(_QWORD *)(v63 + 16);
                    v65 = v63 + 8 * v116;
                    v66 = (_QWORD *)(v65 + 152);
                    v67 = (_QWORD *)(v65 + 232);
                    v68 = 2;
                    do
                    {
                      v69 = *(_DWORD *)(v64 + 4 * v68);
                      if (v69 >= 1)
                      {
                        v70 = **v45;
                        v12 = (int)v12;
                        v71 = 1;
                        do
                        {
                          if ((int)v70 >= 1)
                          {
                            v72 = *(_QWORD *)(*v66 + 8 * v68);
                            v73 = *(_DWORD **)(*v46 + 8 * v12);
                            v74 = *(_QWORD *)(*v67 + 8 * v68);
                            v75 = *(_DWORD **)(*v47 + 8 * v12);
                            v76 = 4 * *v41;
                            v77 = v70;
                            v78 = v43;
                            do
                            {
                              *v73++ = *(_DWORD *)(v72 + v78);
                              *v75++ = *(_DWORD *)(v74 + v78);
                              v78 += v76;
                              --v77;
                            }
                            while (v77);
                          }
                          ++v12;
                        }
                        while (v71++ != v69);
                      }
                      ++v68;
                    }
                    while (v68 != v61);
                  }
                  ++v57;
                }
                while (v57 != v118);
                v108 = v58 + 528 * v62;
              }
              if (*(_DWORD *)(v115[3] + 1528 * v116 + 1492))
                v80 = 0;
              else
                v80 = (int)v52 < (int)v12;
              if (v80)
              {
                v81 = v52;
                LODWORD(v52) = **v45;
                do
                {
                  if ((int)v52 >= 1)
                  {
                    v82 = 0;
                    v83 = *(_QWORD *)(*v47 + 8 * v81);
                    do
                    {
                      v84 = MFS__bet3_finv(*(float *)(v83 + 4 * v82));
                      v83 = *(_QWORD *)(*v47 + 8 * v81);
                      *(float *)(v83 + 4 * v82++) = v84;
                      v52 = (int)**v45;
                    }
                    while (v82 < v52);
                  }
                  ++v81;
                }
                while (v81 != v12);
              }
              v85 = *v112;
              if ((int)v12 >= *v112)
              {
                v91 = v116;
                v48 = v113;
              }
              else
              {
                v86 = **v45;
                v87 = (int)v12;
                v48 = v113;
                do
                {
                  if ((int)v86 >= 1)
                  {
                    v88 = *(_DWORD **)(*v46 + 8 * v87);
                    v89 = *(_DWORD **)(*v47 + 8 * v87);
                    v90 = v86;
                    do
                    {
                      *v88++ = 0;
                      *v89++ = 1065353216;
                      --v90;
                    }
                    while (v90);
                  }
                  ++v87;
                }
                while (v87 != v85);
                LODWORD(v12) = v85;
                v91 = v116;
              }
              (*(void (**)(uint64_t *, _QWORD))(*(_QWORD *)(v115[3] + 1528 * v91 + 1504) + 8 * v48))(v114, 0);
              v92 = *v109;
              if ((int)v92 >= 1)
              {
                v93 = *v107;
                v94 = (int **)(*v105 + 8 * (v19 + (int)v111));
                do
                {
                  v95 = *v94++;
                  v96 = *v95;
                  v97 = *v93++;
                  *(_DWORD *)(v97 + 4 * v48) = v96;
                  --v92;
                }
                while (v92);
              }
              MFS__FreePStreamSM((uint64_t)v114);
              MFS__FreePStreamParam(v114);
              v40 = *v41;
            }
            ++v48;
            v43 += 4;
            if (v48 >= v40)
            {
              v4 = v115;
              a2 = v106;
              v11 = v102;
              v16 = v116;
              goto LABEL_90;
            }
          }
        }
        v11 = v102;
LABEL_90:
        v17 = v104;
        v7 = v108;
      }
      if (++v16 >= *((int *)v4 + 8))
        goto LABEL_94;
    }
  }
  inited = 0;
LABEL_94:
  v98 = *((_DWORD *)v4 + 153) + v11;
  *((_DWORD *)v4 + 153) = v98;
  if (v98 >= *((_DWORD *)v4 + 152))
    *a3 = 1;
LABEL_96:
  v51 = inited;
LABEL_98:
  MFS__FreePStreamParam(__b);
  MFS__FreeSMatrices((uint64_t)v121);
  MFS__FreeSMatrices((uint64_t)v120);
  return v51;
}

uint64_t MFS__InitVData(int a1, char *__b, _DWORD *a3)
{
  uint64_t result;

  cstdlib_memset(__b, 0, 0x430uLL);
  result = MFS__InitModelSet(a1, __b, a3);
  if ((result & 0x80000000) == 0)
  {
    result = MFS__InitTreeSet(a1, __b + 464);
    if ((result & 0x80000000) == 0)
      return MFS__InitDWinSet(a1, __b + 672, (uint64_t)a3);
  }
  return result;
}

void *MFS__DeInitVData(void *a1, char *a2)
{
  MFS__DeInitModelSet((uint64_t)a1, a2);
  MFS__DeInitTreeSet(a1, a2 + 464);
  MFS__DeInitDWinSet((_QWORD **)a1, a2 + 672);
  return cstdlib_memset(a2, 0, 0x430uLL);
}

uint64_t MFS__LoadVData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  uint64_t ModelFile;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  char v30;
  uint64_t v31;
  const char *v33;
  uint64_t v34;
  uint64_t v35;

  if (*(int *)(a2 + 456) < 1)
    return 0;
  v6 = 0;
  v7 = a2 + 464;
  v8 = a2 + 672;
  v9 = a3 + 2664;
  v10 = (unsigned int *)(a3 + 2424);
  do
  {
    ModelFile = MFS__LoadModelFile(a1, (unsigned int *)a2, v6, v9);
    if ((ModelFile & 0x80000000) != 0)
      return ModelFile;
    ModelFile = MFS__LoadTreesFile(a1, v7, v6, v10, a3, v12, v13, v14);
    if ((ModelFile & 0x80000000) != 0)
      return ModelFile;
    ModelFile = MFS__LoadDWinFile(a1, v8, v6, (unsigned int *)(v9 + 1200));
    if ((ModelFile & 0x80000000) != 0)
      return ModelFile;
    ++v6;
    v20 = *(int *)(a2 + 456);
    v9 += 120;
    v10 += 6;
  }
  while (v6 < v20);
  if ((int)v20 < 1)
    return 0;
  v21 = 0;
  while (1)
  {
    if (!*(_QWORD *)(a2 + 8 * v21 + 568))
    {
      v31 = 2229280775;
      v33 = "%s tree is required\n";
      v34 = a1;
      v35 = 55032;
      goto LABEL_37;
    }
    v22 = a2 + 4 * v21;
    if (*(_DWORD *)(v22 + 336) && !*(_QWORD *)(a2 + 168))
    {
LABEL_38:
      v31 = 2229280775;
      v33 = "%s PDF is required\n";
      v34 = a1;
      v35 = 55033;
      goto LABEL_37;
    }
    v23 = *(_DWORD *)(v22 + 376);
    if (v23)
    {
      if (!*(_QWORD *)(a2 + 8 * v21 + 176))
        goto LABEL_38;
      if (!*(_DWORD *)(a2 + 4 * v21 + 416))
      {
        v24 = 1;
        goto LABEL_19;
      }
    }
    else if (!*(_DWORD *)(a2 + 4 * v21 + 416))
    {
      goto LABEL_31;
    }
    if (!*(_QWORD *)(a2 + 8 * v21 + 256))
      goto LABEL_38;
    v24 = 0;
LABEL_19:
    v25 = *(unsigned int *)(a2 + 4 * v21 + 128);
    if ((int)v25 >= 1)
      break;
LABEL_26:
    if (v23)
      v30 = 0;
    else
      v30 = v24;
    if ((v30 & 1) == 0 && *(_DWORD *)(a2 + 4 * v21 + 4) % *(_DWORD *)(v8 + 40 * v21))
    {
      v31 = 2229280775;
      v33 = "The number of dynamic windows for %s is not correct %d %d\n";
      v34 = a1;
      v35 = 55035;
      goto LABEL_37;
    }
LABEL_31:
    v31 = 0;
    if (++v21 == *(_DWORD *)(a2 + 456))
      return v31;
  }
  v26 = 0;
  v27 = a2 + 8 * v21;
  v28 = (_QWORD *)(v27 + 176);
  v29 = (_QWORD *)(v27 + 256);
  while ((!v23 || *(_QWORD *)(*v28 + 8 * v26)) && ((v24 & 1) != 0 || *(_QWORD *)(*v29 + 8 * v26)))
  {
    if (v25 == ++v26)
      goto LABEL_26;
  }
  v31 = 2229280775;
  v33 = "%s PDF layer %d is required\n";
  v34 = a1;
  v35 = 55034;
LABEL_37:
  MFS__log_select_Error(v34, v35, (uint64_t)v33, v15, v16, v17, v18, v19);
  return v31;
}

uint64_t MFS__InitVStream(uint64_t a1, char *__b, _DWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;

  cstdlib_memset(__b, 0, 0x788uLL);
  *(_QWORD *)__b = a1;
  v6 = a3[33];
  *((_DWORD *)__b + 8) = v6;
  v7 = heap_Calloc(*(_QWORD **)(a1 + 8), v6, 1528);
  *((_QWORD *)__b + 3) = v7;
  if (!v7)
    return 2229280778;
  if (*((int *)__b + 8) >= 1)
  {
    v8 = 0;
    v9 = __b + 648;
    v10 = a3 + 36;
    do
    {
      cstdlib_strcpy(v9, "");
      if (cstdlib_strlen(*(const char **)&v10[2 * v8]))
        cstdlib_strcpy(v9, *(const char **)&v10[2 * v8]);
      ++v8;
      v11 = *((int *)__b + 8);
      v9 += 128;
    }
    while (v8 < v11);
    if ((int)v11 >= 1)
    {
      v12 = 0;
      v13 = *((_QWORD *)__b + 3);
      v14 = a3[18];
      v15 = 1528 * *((unsigned int *)__b + 8);
      do
      {
        v16 = v13 + v12;
        *(_DWORD *)(v16 + 12) = a3[56];
        *(_QWORD *)(v16 + 24) = a1;
        *(_QWORD *)(v16 + 752) = a1;
        if (v12)
        {
          if (a3[536])
            *(_DWORD *)(v13 + v12 + 1488) = 1;
          else
            *(_DWORD *)(v13 + v12 + 1484) = 1;
        }
        else
        {
          *(_DWORD *)(v13 + 1480) = 1;
        }
        if (v14 == 1)
          *(_DWORD *)(v13 + v12 + 1492) = 1;
        ++a3;
        v12 += 1528;
      }
      while (v15 != v12);
    }
  }
  return 0;
}

uint64_t MFS__LoadVStream(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t (*v30)();
  const char *v31;
  uint64_t (*v32)();
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  int v37;
  uint64_t v38;
  uint64_t v40;
  const char *v41;
  uint64_t v43;

  if (*((int *)a1 + 8) < 1)
    return 0;
  v3 = a3;
  v4 = a2;
  v6 = 0;
  v7 = a2 + 672;
  v8 = a1[3];
  v43 = a2 + 672;
  while (1)
  {
    v9 = (_DWORD *)(v7 + 40 * v6);
    v10 = v8 + 1528 * v6;
    *(_QWORD *)(v10 + 56) = v9;
    v11 = *(_DWORD *)(v10 + 1484);
    if (v11)
      *(_QWORD *)(v8 + 1528 * v6 + 784) = v9;
    if (!*(_DWORD *)(v8 + 1528 * v6 + 1480))
      break;
    if (v11)
    {
LABEL_7:
      v12 = v8 + 1528 * v6;
      *(_DWORD *)(v12 + 764) = *(_DWORD *)(v4 + 4 * v6 + 4);
      *(_DWORD *)(v12 + 768) = 1;
    }
LABEL_8:
    if (++v6 >= *((int *)a1 + 8))
      return 0;
  }
  v13 = v4 + 4 * v6;
  v14 = v8 + 1528 * v6;
  *(_DWORD *)(v14 + 36) = *(_DWORD *)(v13 + 4);
  v15 = *(_DWORD *)(v13 + 4) / *v9;
  *(_DWORD *)(v14 + 40) = v15;
  *(_QWORD *)(v14 + 1496) = *(_QWORD *)(v3 + 92);
  v16 = heap_Calloc(*(_QWORD **)(*a1 + 8), (2 * v15), 8);
  v17 = a1[3];
  *(_QWORD *)(v17 + 1528 * v6 + 1504) = v16;
  if (!v16)
    return 2229280778;
  v18 = v17 + 1528 * v6;
  v19 = *(int *)(v18 + 40);
  *(_QWORD *)(v18 + 1512) = v16 + 8 * v19;
  if ((int)v19 < 1)
    goto LABEL_52;
  v20 = 0;
  v21 = v3 + 8 * v6;
  v22 = (_QWORD *)(v21 + 2184);
  v23 = (_QWORD *)(v21 + 2264);
  do
  {
    if (cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "MLPG"))
    {
      if (cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "MLPG2"))
      {
        if (cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "MLPG_GV"))
        {
          if (cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "MLPG_OPT"))
          {
            if (cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "MLPG_C"))
            {
              if (cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "MLPG_GVC"))
              {
                if (cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "MLPG_GVNORM"))
                {
                  v24 = cstdlib_strcmp(*(const char **)(*v22 + 8 * v20), "DUMMY_SOLVER");
                  v30 = (uint64_t (*)())dummy_solver;
                  if (v24)
                  {
                    v40 = *a1;
                    v41 = "invalid solver for stream %d: %s\n";
                    goto LABEL_65;
                  }
                }
                else
                {
                  v30 = (uint64_t (*)())mlpg_gvnorm;
                }
              }
              else
              {
                v30 = (uint64_t (*)())mlpg_gvc;
              }
            }
            else
            {
              v30 = (uint64_t (*)())mlpg_c;
            }
          }
          else
          {
            v30 = mlpg_opt;
          }
        }
        else
        {
          v30 = (uint64_t (*)())mlpg_gv;
        }
      }
      else
      {
        v30 = (uint64_t (*)())MFS__mlpg2;
      }
    }
    else
    {
      v30 = (uint64_t (*)())mlpg;
    }
    *(_QWORD *)(*(_QWORD *)(a1[3] + 1528 * v6 + 1504) + 8 * v20) = v30;
    if (!*v23)
      goto LABEL_50;
    v31 = *(const char **)(*v23 + 8 * v20);
    if (!v31)
      goto LABEL_50;
    if (!cstdlib_strcmp(v31, "MLPG"))
    {
      v32 = (uint64_t (*)())mlpg;
LABEL_49:
      *(_QWORD *)(*(_QWORD *)(a1[3] + 1528 * v6 + 1512) + 8 * v20) = v32;
      goto LABEL_50;
    }
    if (!cstdlib_strcmp(*(const char **)(*v23 + 8 * v20), "MLPG2"))
    {
      v32 = (uint64_t (*)())MFS__mlpg2;
      goto LABEL_49;
    }
    if (!cstdlib_strcmp(*(const char **)(*v23 + 8 * v20), "MLPG_GV"))
    {
      v32 = (uint64_t (*)())mlpg_gv;
      goto LABEL_49;
    }
    if (!cstdlib_strcmp(*(const char **)(*v23 + 8 * v20), "MLPG_OPT"))
    {
      v32 = mlpg_opt;
      goto LABEL_49;
    }
    if (!cstdlib_strcmp(*(const char **)(*v23 + 8 * v20), "MLPG_C"))
    {
      v32 = (uint64_t (*)())mlpg_c;
      goto LABEL_49;
    }
    if (!cstdlib_strcmp(*(const char **)(*v23 + 8 * v20), "MLPG_GVC"))
    {
      v32 = (uint64_t (*)())mlpg_gvc;
      goto LABEL_49;
    }
    if (!cstdlib_strcmp(*(const char **)(*v23 + 8 * v20), "MLPG_GVNORM"))
    {
      v32 = (uint64_t (*)())mlpg_gvnorm;
      goto LABEL_49;
    }
    if (!cstdlib_strcmp(*(const char **)(*v23 + 8 * v20), "DUMMY_SOLVER"))
    {
      v32 = (uint64_t (*)())dummy_solver;
      goto LABEL_49;
    }
    if (**(_BYTE **)(*v23 + 8 * v20))
    {
      v40 = *a1;
      v41 = "invalid solver 2 for stream %d: %s\n";
      goto LABEL_65;
    }
LABEL_50:
    ++v20;
    v19 = *(int *)(a1[3] + 1528 * v6 + 40);
  }
  while (v20 < v19);
  v3 = a3;
  v4 = a2;
LABEL_52:
  v33 = heap_Calloc(*(_QWORD **)(*a1 + 8), v19, 4);
  v34 = a1[3];
  *(_QWORD *)(v34 + 1528 * v6 + 1520) = v33;
  if (!v33)
    return 2229280778;
  if (*(int *)(v34 + 1528 * v6 + 40) < 1)
  {
LABEL_61:
    MFS__log_select_Diag(*a1, 1, (uint64_t)"%s: vSize = %d, order = %d, nLayer = %d\n");
    v8 = a1[3];
    v7 = v43;
    if (*(_DWORD *)(v8 + 1528 * v6 + 1484))
      goto LABEL_7;
    goto LABEL_8;
  }
  v35 = 0;
  v36 = (_QWORD *)(v3 + 8 * v6 + 2344);
  while (2)
  {
    if (!cstdlib_strcmp(*(const char **)(*v36 + 8 * v35), "OFF"))
    {
      v37 = 0;
LABEL_59:
      v38 = a1[3] + 1528 * v6;
      *(_DWORD *)(*(_QWORD *)(v38 + 1520) + 4 * v35++) = v37;
      if (v35 >= *(int *)(v38 + 40))
      {
        v3 = a3;
        goto LABEL_61;
      }
      continue;
    }
    break;
  }
  if (!cstdlib_strcmp(*(const char **)(*v36 + 8 * v35), "ON"))
  {
    v37 = 1;
    goto LABEL_59;
  }
  v40 = *a1;
  v41 = "valid breaker setting is required for stream %d\n";
LABEL_65:
  MFS__log_select_Error(v40, 55036, (uint64_t)v41, v25, v26, v27, v28, v29);
  return 2229280775;
}

_QWORD *MFS__DeInitVStream(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result)
  {
    v1 = result;
    if (*result)
    {
      if (*((int *)result + 8) >= 1)
      {
        v2 = 0;
        v3 = result[3];
        v4 = 1520;
        do
        {
          if (!v3)
            break;
          MFS__FreePStreamSM(v3 + v4 - 1496);
          MFS__FreePStreamParam((_QWORD *)(v1[3] + v4 - 1496));
          MFS__FreePStreamSM(v1[3] + v4 - 768);
          MFS__FreePStreamParam((_QWORD *)(v1[3] + v4 - 768));
          v3 = v1[3];
          v5 = *(_QWORD *)(v3 + v4 - 16);
          if (v5)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v5);
            v3 = v1[3];
            *(_QWORD *)(v3 + v4 - 16) = 0;
          }
          v6 = *(_QWORD *)(v3 + v4);
          if (v6)
          {
            heap_Free(*(_QWORD **)(*v1 + 8), v6);
            v3 = v1[3];
            *(_QWORD *)(v3 + v4) = 0;
          }
          ++v2;
          v4 += 1528;
        }
        while (v2 < *((int *)v1 + 8));
      }
      v7 = v1[6];
      if (v7)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v7);
        v1[6] = 0;
      }
      v8 = v1[5];
      if (v8)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v8);
        v1[5] = 0;
      }
      v9 = v1[3];
      if (v9)
      {
        heap_Free(*(_QWORD **)(*v1 + 8), v9);
        v1[3] = 0;
      }
      MFS__DeInitUttModel(v1 + 7);
      return cstdlib_memset(v1, 0, 0x788uLL);
    }
  }
  return result;
}

void *MFS__InitVParam(_DWORD *a1)
{
  void *result;

  result = cstdlib_memset(a1, 0, 0x1F38uLL);
  a1[32] = 1;
  return result;
}

void *MFS__DeInitVParam(uint64_t a1, _QWORD *__b)
{
  uint64_t i;
  uint64_t j;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t k;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t m;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  unsigned int *v29;
  char *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t n;
  uint64_t v44;
  uint64_t ii;
  uint64_t v46;

  if (__b[955])
  {
    for (i = 0; i != 20; ++i)
    {
      if (*(_QWORD *)(__b[955] + 8 * i))
      {
        for (j = 0; j != 800; j += 8)
        {
          v6 = *(_QWORD *)(*(_QWORD *)(__b[955] + 8 * i) + j);
          if (v6)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v6);
            *(_QWORD *)(*(_QWORD *)(__b[955] + 8 * i) + j) = 0;
          }
        }
        v7 = *(_QWORD *)(__b[955] + 8 * i);
        if (v7)
        {
          heap_Free(*(_QWORD **)(a1 + 8), v7);
          *(_QWORD *)(__b[955] + 8 * i) = 0;
        }
      }
      v8 = *(_QWORD *)(__b[956] + 8 * i);
      if (v8)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v8);
        *(_QWORD *)(__b[956] + 8 * i) = 0;
      }
      v9 = *(_QWORD *)(__b[954] + 8 * i);
      if (v9)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v9);
        *(_QWORD *)(__b[954] + 8 * i) = 0;
      }
    }
    v10 = __b[955];
    if (v10)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v10);
      __b[955] = 0;
    }
    v11 = __b[956];
    if (v11)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v11);
      __b[956] = 0;
    }
    v12 = __b[954];
    if (v12)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v12);
      __b[954] = 0;
    }
  }
  v13 = __b[10];
  if (v13)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v13);
    __b[10] = 0;
  }
  v14 = __b[15];
  if (v14)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v14);
    __b[15] = 0;
  }
  v15 = __b[957];
  if (v15)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v15);
    __b[957] = 0;
  }
  v16 = 0;
  v17 = __b;
  do
  {
    v18 = (char *)&__b[v16];
    v19 = *((_QWORD *)v18 + 18);
    if (v19)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v19);
      *((_QWORD *)v18 + 18) = 0;
    }
    v20 = *((_QWORD *)v18 + 53);
    if (v20)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v20);
      *((_QWORD *)v18 + 53) = 0;
    }
    for (k = 0; k != 5; ++k)
    {
      v22 = &v17[k];
      v23 = v17[k + 63];
      if (v23)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v23);
        v22[63] = 0;
      }
      v24 = v22[163];
      if (v24)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v24);
        v22[163] = 0;
      }
    }
    for (m = 213; m != 218; ++m)
    {
      v26 = v17[m];
      if (v26)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v26);
        v17[m] = 0;
      }
    }
    v27 = (char *)__b + 4 * v16;
    if (*((_DWORD *)v27 + 66))
    {
      v28 = 0;
      v29 = (unsigned int *)(v27 + 264);
      v30 = (char *)&__b[v16];
      v31 = v30 + 2344;
      v32 = v30 + 2184;
      v33 = v30 + 2264;
      do
      {
        if (*v31)
        {
          v34 = *(_QWORD *)(*v31 + 8 * v28);
          if (v34)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v34);
            *(_QWORD *)(*v31 + 8 * v28) = 0;
          }
        }
        if (*v32)
        {
          v35 = *(_QWORD *)(*v32 + 8 * v28);
          if (v35)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v35);
            *(_QWORD *)(*v32 + 8 * v28) = 0;
          }
        }
        if (*v33)
        {
          v36 = *(_QWORD *)(*v33 + 8 * v28);
          if (v36)
          {
            heap_Free(*(_QWORD **)(a1 + 8), v36);
            *(_QWORD *)(*v33 + 8 * v28) = 0;
          }
        }
        ++v28;
      }
      while (v28 < *v29);
    }
    v37 = (char *)&__b[v16];
    v38 = *((_QWORD *)v37 + 293);
    if (v38)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v38);
      *((_QWORD *)v37 + 293) = 0;
    }
    v39 = *((_QWORD *)v37 + 273);
    if (v39)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v39);
      *((_QWORD *)v37 + 273) = 0;
    }
    v40 = (char *)&__b[v16];
    v41 = *((_QWORD *)v40 + 283);
    if (v41)
    {
      v42 = v40 + 2264;
      heap_Free(*(_QWORD **)(a1 + 8), v41);
      *v42 = 0;
    }
    ++v16;
    v17 += 5;
  }
  while (v16 != 10);
  for (n = 663; n != 919; ++n)
  {
    v44 = __b[n];
    if (v44)
    {
      heap_Free(*(_QWORD **)(a1 + 8), v44);
      __b[n] = 0;
    }
  }
  if (__b[952])
  {
    for (ii = 0; ii != 2048; ii += 8)
    {
      v46 = *(_QWORD *)(__b[952] + ii);
      if (v46)
      {
        heap_Free(*(_QWORD **)(a1 + 8), v46);
        *(_QWORD *)(__b[952] + ii) = 0;
      }
    }
    heap_Free(*(_QWORD **)(a1 + 8), __b[952]);
  }
  return cstdlib_memset(__b, 0, 0x1F38uLL);
}

uint64_t LZ_Compress(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v6;
  unsigned __int8 *v7;
  int v8;
  unsigned __int8 v9;
  uint64_t i;
  unint64_t v11;
  uint64_t result;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unint64_t v29;
  unsigned int v30;
  _DWORD v31[256];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if (!a3)
    return 0;
  bzero(v31, 0x400uLL);
  v6 = a3;
  v29 = a3;
  v7 = a1;
  do
  {
    v8 = *v7++;
    ++v31[v8];
    --v6;
  }
  while (v6);
  v9 = 0;
  for (i = 1; i != 256; ++i)
  {
    if (v31[i] < v31[v9])
      v9 = i;
  }
  LODWORD(v11) = 0;
  *a2 = v9;
  LODWORD(result) = 1;
  v30 = a3;
  v13 = a3;
  do
  {
    if (v11 >= 0x186A0)
      v14 = 100000;
    else
      v14 = v11;
    v15 = v11;
    v16 = &a1[v11];
    if (v14 >= 3)
    {
      v20 = 0;
      v21 = v14 + 1;
      v22 = &a1[v15 - 3];
      v23 = 3;
      v19 = 3;
      do
      {
        if (v23 >= v13)
          v24 = v13;
        else
          v24 = v23;
        if (*v16 == v16[-v23] && v16[v19] == v16[v19 - v23])
        {
          if (v13 >= v23)
            v25 = v23;
          else
            v25 = v13;
          if (v25)
          {
            v26 = 0;
            while (v16[v26] == v22[v26])
            {
              if (v24 == ++v26)
                goto LABEL_31;
            }
            v25 = v26;
          }
LABEL_31:
          if (v25 > v19)
          {
            v20 = v23;
            v19 = v25;
          }
        }
        ++v23;
        --v22;
      }
      while (v23 != v21);
      if (v19 > 7)
        goto LABEL_47;
      if (v19 == 4 && v20 < 0x80)
      {
        v19 = 4;
LABEL_47:
        a2[result] = v9;
        v27 = _LZ_WriteVarSize(v19, &a2[(result + 1)]) + (_DWORD)result + 1;
        result = v27 + _LZ_WriteVarSize(v20, &a2[v27]);
        v13 -= v19;
        goto LABEL_48;
      }
      if (v19 == 5 && v20 < 0x4000)
      {
        v19 = 5;
        goto LABEL_47;
      }
      if (v19 == 6 && v20 < 0x200000)
      {
        v19 = 6;
        goto LABEL_47;
      }
      if (v19 == 7 && !(v20 >> 28))
      {
        v19 = 7;
        goto LABEL_47;
      }
    }
    v17 = *v16;
    v18 = (result + 1);
    a2[result] = v17;
    if (v17 == v9)
    {
      a2[v18] = 0;
      v18 = (result + 2);
    }
    --v13;
    v19 = 1;
    result = v18;
LABEL_48:
    v11 = v19 + v15;
  }
  while (v13 > 3);
  if (v11 < v30)
  {
    do
    {
      v28 = a1[v11];
      if (v28 == v9)
      {
        LOBYTE(v28) = 0;
        a2[result] = v9;
        LODWORD(result) = result + 1;
      }
      a2[result] = v28;
      result = (result + 1);
      ++v11;
    }
    while (v11 < v29);
  }
  return result;
}

uint64_t _LZ_WriteVarSize(unsigned int a1, _BYTE *a2)
{
  unsigned int v2;
  int v3;
  BOOL v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  int v8;

  if (a1 >> 28)
  {
    v5 = 5;
  }
  else
  {
    v2 = a1 >> 3;
    v3 = 6;
    do
    {
      if (--v3 < 3)
        break;
      v4 = v2 >= 0x40000;
      v2 <<= 7;
    }
    while (!v4);
    v5 = (v3 - 1);
    if (v3 < 2)
      return v5;
  }
  v6 = v5 + 1;
  v7 = 7 * v5 - 7;
  do
  {
    v8 = (a1 >> v7) | 0x80;
    if (!v7)
      LOBYTE(v8) = a1 & 0x7F;
    *a2++ = v8;
    --v6;
    v7 -= 7;
  }
  while (v6 > 1);
  return v5;
}

uint64_t LZ_CompressFast(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3, char *__b)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t result;
  uint64_t v14;
  unsigned __int8 *v15;
  int v16;
  unsigned __int8 v17;
  uint64_t i;
  unint64_t v19;
  unsigned int v20;
  unsigned __int8 *v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  BOOL v27;
  int v28;
  uint64_t v29;
  unsigned __int8 *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  int v35;
  unsigned int v36;
  _DWORD v37[256];
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  if (!a3)
    return 0;
  memset(__b, 255, 0x40000uLL);
  v8 = __b + 0x40000;
  v9 = a3 - 1;
  if (a3 == 1)
  {
    v9 = 0;
  }
  else
  {
    v10 = 0;
    do
    {
      v11 = (4 * a1[v10 + 1]) | ((unint64_t)a1[v10] << 10);
      v12 = *(_DWORD *)&__b[v11];
      *(_DWORD *)&__b[v11] = v10;
      *(_DWORD *)&v8[4 * v10++] = v12;
    }
    while (v9 != v10);
  }
  *(_DWORD *)&v8[4 * v9] = -1;
  bzero(v37, 0x400uLL);
  if (a3 <= 1)
    v14 = 1;
  else
    v14 = a3;
  v15 = a1;
  do
  {
    v16 = *v15++;
    ++v37[v16];
    --v14;
  }
  while (v14);
  v17 = 0;
  for (i = 1; i != 256; ++i)
  {
    if (v37[i] < v37[v17])
      v17 = i;
  }
  LODWORD(v19) = 0;
  *a2 = v17;
  LODWORD(result) = 1;
  v36 = a3;
  v20 = a3;
  do
  {
    v21 = &a1[v19];
    v22 = *(_DWORD *)&v8[4 * v19];
    v23 = v19 - v22;
    v24 = 0;
    v25 = 3;
    if (v22 != -1 && v23 < 0x186A0)
    {
      do
      {
        v30 = &a1[v22];
        if (v30[v25] == v21[v25])
        {
          if (v20 >= v23)
            v31 = v23;
          else
            v31 = v20;
          if (v31 < 3)
          {
            LODWORD(v31) = 2;
          }
          else
          {
            v32 = 2;
            while (v21[v32] == v30[v32])
            {
              if (v31 == ++v32)
                goto LABEL_42;
            }
            LODWORD(v31) = v32;
          }
LABEL_42:
          if (v31 > v25)
          {
            v24 = v23;
            v25 = v31;
          }
        }
        v22 = *(_DWORD *)&v8[4 * v22];
        v23 = v19 - v22;
      }
      while (v22 != -1 && v23 < 0x186A0);
      if (v25 > 7)
        goto LABEL_53;
      if (v25 == 4 && v24 < 0x80)
      {
        v25 = 4;
LABEL_53:
        a2[result] = v17;
        v34 = _LZ_WriteVarSize(v25, &a2[(result + 1)]) + (_DWORD)result + 1;
        result = v34 + _LZ_WriteVarSize(v24, &a2[v34]);
        v20 -= v25;
        goto LABEL_54;
      }
    }
    v27 = v24 < 0x4000 && v25 == 5;
    if (v27 || (v25 & 0xFFFFFFFE) == 6)
      goto LABEL_53;
    v28 = *v21;
    v29 = (result + 1);
    a2[result] = v28;
    if (v28 == v17)
    {
      a2[v29] = 0;
      v29 = (result + 2);
    }
    --v20;
    v25 = 1;
    result = v29;
LABEL_54:
    v19 = v25 + v19;
  }
  while (v20 > 3);
  if (v19 < v36)
  {
    do
    {
      v35 = a1[v19];
      if (v35 == v17)
      {
        LOBYTE(v35) = 0;
        a2[result] = v17;
        LODWORD(result) = result + 1;
      }
      a2[result] = v35;
      result = (result + 1);
      ++v19;
    }
    while (v19 < v36);
  }
  return result;
}

unsigned __int8 *LZ_Uncompress(unsigned __int8 *result, uint64_t a2, unsigned int a3)
{
  unsigned int v3;
  int v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  unsigned __int8 v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  char v14;
  char v15;
  unsigned int v16;
  int v17;

  if (a3)
  {
    v3 = 0;
    v4 = *result;
    v5 = 1;
    do
    {
      v6 = v5 + 1;
      v7 = result[v5];
      if (v7 == v4)
      {
        if (result[v6])
        {
          v8 = result[v6] & 0x7F;
          if ((result[v6] & 0x80) != 0)
          {
            v9 = 1;
            do
            {
              v10 = result[v6 + v9];
              v8 = v10 & 0x7F | (v8 << 7);
              ++v9;
            }
            while ((v10 & 0x80) != 0);
          }
          else
          {
            LODWORD(v9) = 1;
          }
          v11 = 0;
          v6 = (v9 + v6);
          v12 = &result[v6];
          do
          {
            v13 = v11;
            v15 = *v12++;
            v14 = v15;
            v11 = v15 & 0x7F | (v11 << 7);
            LODWORD(v6) = v6 + 1;
          }
          while (v15 < 0);
          if (v8)
          {
            v16 = v8 + v3;
            v17 = -(v14 & 0x7F | (v13 << 7));
            do
            {
              *(_BYTE *)(a2 + v3) = *(_BYTE *)(a2 + v17 + v3);
              ++v3;
              --v8;
            }
            while (v8);
            v3 = v16;
          }
        }
        else
        {
          *(_BYTE *)(a2 + v3++) = v4;
          LODWORD(v6) = v5 + 2;
        }
      }
      else
      {
        *(_BYTE *)(a2 + v3++) = v7;
      }
      v5 = v6;
    }
    while (v6 < a3);
  }
  return result;
}

uint64_t Huffman_Compress(unsigned __int8 *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  int v4;
  unsigned __int8 *v5;
  uint64_t v6;
  int32x4_t v7;
  __int128 v8;
  int32x4_t v9;
  float *v10;
  __int128 v11;
  __int128 v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  int v19;
  char *v20;
  int v21;
  _OWORD *v22;
  _OWORD *v23;
  uint64_t v24;
  _OWORD *v25;
  uint64_t v26;
  _OWORD *v27;
  int v28;
  char *v29;
  int v30;
  uint64_t v32;
  int v33;
  int *v34;
  int *v35;
  int v36;
  __int128 v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  int v42[1024];
  _OWORD v43[766];
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a3)
    return 0;
  LODWORD(v3) = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0;
  v40 = a2;
  v7 = (int32x4_t)xmmword_214F03640;
  v8 = 0uLL;
  v9.i64[0] = 0x400000004;
  v9.i64[1] = 0x400000004;
  do
  {
    v10 = (float *)&v42[v6];
    v11 = 0uLL;
    v12 = 0uLL;
    vst4q_f32(v10, *(float32x4x4_t *)v7.i8);
    v7 = vaddq_s32(v7, v9);
    v6 += 16;
  }
  while (v6 != 1024);
  v13 = a3;
  v14 = a1;
  do
  {
    v15 = *v14++;
    ++v42[4 * v15 + 1];
    --v13;
  }
  while (v13);
  bzero(v43, 0x2FE8uLL);
  v16 = 0;
  v17 = 0;
  do
  {
    v18 = v42[v16 + 1];
    if (v18)
    {
      v19 = v42[v16];
      v20 = (char *)v43 + 24 * v17;
      *((_DWORD *)v20 + 4) = v18;
      *((_DWORD *)v20 + 5) = v19;
      ++v17;
      *(_QWORD *)v20 = 0;
      *((_QWORD *)v20 + 1) = 0;
    }
    v16 += 4;
  }
  while (v16 != 1024);
  v41 = 0;
  if (v17 < 2)
  {
    v29 = (char *)v43;
    v30 = 1;
    goto LABEL_27;
  }
  v21 = 2 * v17 - 2;
  do
  {
    v22 = 0;
    v23 = 0;
    v24 = v17;
    v25 = v43;
    v26 = v24;
    do
    {
      v27 = v23;
      v28 = *((_DWORD *)v25 + 4);
      if (v28 < 1)
      {
LABEL_18:
        v23 = v27;
        goto LABEL_22;
      }
      if (v27)
      {
        if (v28 <= *((_DWORD *)v27 + 4))
        {
          v23 = v25;
          v22 = v27;
        }
        else
        {
          if (v22 && v28 > *((_DWORD *)v22 + 4))
            goto LABEL_18;
          v23 = v27;
          v22 = v25;
        }
      }
      else
      {
        v22 = 0;
        v23 = v25;
      }
LABEL_22:
      v25 = (_OWORD *)((char *)v25 + 24);
      --v26;
    }
    while (v26);
    v29 = (char *)v43 + 24 * v24;
    *(_QWORD *)v29 = v23;
    *((_QWORD *)v29 + 1) = v22;
    *((_DWORD *)v29 + 4) = *((_DWORD *)v22 + 4) + *((_DWORD *)v23 + 4);
    *((_DWORD *)v29 + 5) = -1;
    *((_DWORD *)v23 + 4) = 0;
    *((_DWORD *)v22 + 4) = 0;
    v17 = v24 + 1;
  }
  while ((_DWORD)v24 != v21);
  v30 = 0;
LABEL_27:
  _Huffman_StoreTree((uint64_t)v29, v42, (uint64_t)&v40, 0, v30);
  v32 = 0;
  v33 = 0;
  while (1)
  {
    v34 = &v42[4 * v32++];
    v35 = &v42[4 * v32];
    v36 = v33;
    if (*v34 > *v35)
    {
      v43[0] = *(_OWORD *)v34;
      v37 = v43[0];
      *(_OWORD *)v34 = *(_OWORD *)v35;
      *(_OWORD *)v35 = v37;
      v36 = 1;
      v33 = 1;
    }
    if (v32 == 255)
    {
      v32 = 0;
      v33 = 0;
      if (!v36)
        break;
    }
  }
  if (v3 <= 1)
    v3 = 1;
  else
    v3 = v3;
  do
  {
    v38 = *v5++;
    _Huffman_WriteBits((uint64_t)&v40, v42[4 * v38 + 2], v42[4 * v38 + 3]);
    --v3;
  }
  while (v3);
  v39 = v40 - v4;
  if ((_DWORD)v41)
    return v39 + 1;
  else
    return v39;
}

uint64_t _Huffman_WriteBits(uint64_t result, unsigned int a2, int a3)
{
  _BYTE *v3;
  int v4;
  char v5;

  v3 = *(_BYTE **)result;
  v4 = *(_DWORD *)(result + 8);
  if (a3)
  {
    v5 = a3 - 1;
    do
    {
      *v3 = (*v3 & ~(1 << (7 - v4))) + (((a2 >> v5) & 1) << (7 - v4));
      a2 *= 2;
      v4 = ((_BYTE)v4 + 1) & 7;
      if (!v4)
        ++v3;
      --a3;
    }
    while (a3);
  }
  *(_QWORD *)result = v3;
  *(_DWORD *)(result + 8) = v4;
  return result;
}

unsigned __int8 *Huffman_Uncompress(unsigned __int8 *result, _BYTE *a2, int a3, int a4)
{
  int v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  unsigned __int8 *v10;
  unsigned int v11;
  char v12;
  unsigned int v13;
  unsigned __int8 *v14;
  uint64_t v15;
  _BYTE v16[12264];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v14 = result;
    v15 = 0;
    v13 = 0;
    result = (unsigned __int8 *)_Huffman_RecoverTree((uint64_t)v16, &v14, &v13);
    if (a4)
    {
      v6 = 0;
      v7 = v14;
      LOBYTE(v8) = v15;
      do
      {
        v9 = *((_DWORD *)result + 4);
        if (v9 < 0)
        {
          v10 = result;
          do
          {
            v11 = *v7;
            v12 = 7 - v8;
            v8 = ((_BYTE)v8 + 1) & 7;
            if (!v8)
              ++v7;
            LODWORD(v15) = v8;
            v14 = v7;
            if (((v11 >> v12) & 1) != 0)
              v10 += 8;
            v10 = *(unsigned __int8 **)v10;
            v9 = *((_DWORD *)v10 + 4);
          }
          while (v9 < 0);
        }
        *a2++ = v9;
        ++v6;
      }
      while (v6 != a4);
    }
  }
  return result;
}

_QWORD *_Huffman_RecoverTree(uint64_t a1, unsigned __int8 **a2, unsigned int *a3)
{
  unsigned int v4;
  _QWORD *v5;
  uint64_t v6;
  int *v7;
  unsigned __int8 *v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v16;

  v4 = *a3;
  v5 = (_QWORD *)(a1 + 24 * (*a3)++);
  v6 = a1 + 24 * v4;
  *(_DWORD *)(v6 + 16) = -1;
  v7 = (int *)(v6 + 16);
  *v5 = 0;
  v5[1] = 0;
  v8 = *a2;
  v9 = *((_DWORD *)a2 + 2);
  v10 = **a2;
  v11 = ((_BYTE)v9 + 1) & 7;
  if ((((_BYTE)v9 + 1) & 7) == 0)
    v8 = *a2 + 1;
  *((_DWORD *)a2 + 2) = v11;
  *a2 = v8;
  if (((v10 >> (7 - v9)) & 1) != 0)
  {
    v12 = *v8 << v11;
    v13 = v8[1];
    *a2 = v8 + 1;
    *v7 = (v13 >> (8 - v11)) | v12;
  }
  else
  {
    v16 = a1 + 24 * v4;
    *v5 = ((uint64_t (*)(void))_Huffman_RecoverTree)();
    *(_QWORD *)(v16 + 8) = _Huffman_RecoverTree(a1, a2, a3);
  }
  return v5;
}

uint64_t _Huffman_StoreTree(uint64_t a1, int *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  int v6;
  uint64_t v9;
  int v10;
  uint64_t result;
  uint64_t v12;
  int *v13;
  int v14;
  int *v15;

  LODWORD(v5) = a5;
  v6 = a4;
  v9 = a1;
  if ((*(_DWORD *)(a1 + 20) & 0x80000000) != 0)
  {
    do
    {
      _Huffman_WriteBits(a3, 0, 1);
      v5 = (v5 + 1);
      _Huffman_StoreTree(*(_QWORD *)v9, a2, a3, (2 * v6), v5);
      v9 = *(_QWORD *)(v9 + 8);
      v10 = (2 * v6) | 1;
      v6 = v10;
    }
    while ((*(_DWORD *)(v9 + 20) & 0x80000000) != 0);
  }
  else
  {
    v10 = a4;
  }
  _Huffman_WriteBits(a3, 1u, 1);
  result = _Huffman_WriteBits(a3, *(_DWORD *)(v9 + 20), 8);
  v12 = 0;
  v13 = a2;
  do
  {
    v14 = *v13;
    v13 += 4;
    if (v14 == *(_DWORD *)(v9 + 20))
      break;
    ++v12;
  }
  while (v12 != 256);
  v15 = &a2[4 * v12];
  v15[2] = v10;
  v15[3] = v5;
  return result;
}

uint64_t Rice_Compress(uint64_t a1, _BYTE *a2, unsigned int a3, int a4)
{
  int v4;
  unsigned int v6;
  unsigned int v7;
  unsigned int v12;
  int v13;
  unsigned int i;
  int Word;
  int v16;
  BOOL v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  signed int v21;
  unsigned int v22;
  uint64_t v23;
  int32x4_t v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  unint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  int v35;
  unint64_t v36;
  unint64_t v37;
  int v38;
  unint64_t v39;
  unsigned int v40;
  unint64_t v41;
  int v42;
  BOOL v43;
  unsigned int v44;
  int v45;
  unsigned int v46;
  int v47;
  unint64_t v48;
  unsigned int v49;
  unsigned int v50;
  _OWORD v51[4];
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  memset(v51, 0, sizeof(v51));
  v4 = a4 - 1;
  if ((a4 - 1) > 7)
    return 0;
  if (((0xCFu >> v4) & 1) == 0)
    return 0;
  v6 = dword_214FC0984[v4];
  v7 = v6 >> 3;
  if (v6 >> 3 > a3)
    return 0;
  v49 = v6;
  v50 = a3 / v7;
  if (a3 / v7 >= 0x10)
    v12 = 16;
  else
    v12 = a3 / v7;
  if (v12)
  {
    v13 = 0;
    for (i = 0; i != v12; ++i)
    {
      Word = _Rice_ReadWord(a1, i, a4);
      v16 = 32;
      if ((Word & 0x80000000) == 0)
      {
        do
        {
          Word *= 2;
          v17 = v16-- != 0;
        }
        while ((Word & 0x80000000) == 0 && v16 != 0 && v17);
      }
      v13 += v16;
    }
    v18 = (v13 + (v12 >> 1)) / v12;
  }
  else
  {
    v18 = 0;
  }
  v19 = 0;
  v20 = a3 + 1;
  if (v18 <= 1)
    v21 = 1;
  else
    v21 = v18;
  *a2 = v21;
  v22 = 8;
  do
  {
    if (v19 >= 0x10)
    {
      v23 = 0;
      v24 = 0uLL;
      do
        v24 = vaddq_s32((int32x4_t)v51[v23++], v24);
      while (v23 != 4);
      v21 = (vaddvq_s32(v24) + 8) >> 4;
    }
    v25 = _Rice_ReadWord(a1, v19, a4);
    v26 = v25 >> v21;
    if (v25 >> v21 >= 9)
    {
      v27 = 8;
      do
      {
        v28 = (unint64_t)v22 >> 3;
        if (v28 < v20)
          a2[v28] |= 1 << (~(_BYTE)v22++ & 7);
        --v27;
      }
      while (v27);
      v29 = v26 - 8;
      if (v29 < 0)
      {
        v32 = 32;
      }
      else
      {
        v30 = 33;
        v31 = v29;
        do
        {
          --v30;
          v31 *= 2;
        }
        while ((v31 & 0x80000000) == 0 && v30 > 1);
        v32 = v30 - 1;
        if (v30 < 2)
        {
LABEL_46:
          v37 = (unint64_t)v22 >> 3;
          if (v37 < v20)
            a2[v37] &= ~(1 << (~(_BYTE)v22++ & 7));
          if (v32 > 1)
          {
            v38 = v32 - 2;
            do
            {
              v39 = (unint64_t)v22 >> 3;
              if (v39 < v20)
              {
                a2[v39] = a2[v39] & ~(1 << (~(_BYTE)v22 & 7)) | (((v29 >> v38) & 1) << (~(_BYTE)v22 & 7));
                ++v22;
              }
              --v38;
            }
            while (v38 != -1);
          }
          goto LABEL_53;
        }
      }
      v35 = v32;
      do
      {
        v36 = (unint64_t)v22 >> 3;
        if (v36 < v20)
          a2[v36] |= 1 << (~(_BYTE)v22++ & 7);
        --v35;
      }
      while (v35);
      goto LABEL_46;
    }
    for (; v26; --v26)
    {
      v33 = (unint64_t)v22 >> 3;
      if (v33 < v20)
        a2[v33] |= 1 << (~(_BYTE)v22++ & 7);
    }
    v34 = (unint64_t)v22 >> 3;
    if (v34 < v20)
      a2[v34] &= ~(1 << (~(_BYTE)v22++ & 7));
LABEL_53:
    if (v21 >= 1)
    {
      v40 = v21 + 1;
      do
      {
        v41 = (unint64_t)v22 >> 3;
        if (v41 < v20)
        {
          a2[v41] = a2[v41] & ~(1 << (~(_BYTE)v22 & 7)) | (((v25 >> (v40 - 2)) & 1) << (~(_BYTE)v22 & 7));
          ++v22;
        }
        --v40;
      }
      while (v40 > 1);
    }
    v42 = 32;
    if ((v25 & 0x80000000) == 0)
    {
      do
      {
        v25 *= 2;
        v43 = v42-- != 0;
      }
      while ((v25 & 0x80000000) == 0 && v42 != 0 && v43);
    }
    *((_DWORD *)v51 + (v19++ & 0xF)) = v42;
  }
  while (v19 < v50 && v22 >> 3 <= a3);
  if (v19 < v50)
  {
    v44 = 0;
    *a2 = 0;
    if (v50 <= 1)
      v45 = 1;
    else
      v45 = v50;
    v22 = 8;
    do
    {
      v46 = _Rice_ReadWord(a1, v44, a4);
      v47 = v49 + 1;
      do
      {
        v48 = (unint64_t)v22 >> 3;
        if (v48 < v20)
        {
          a2[v48] = a2[v48] & ~(1 << (~(_BYTE)v22 & 7)) | (((v46 >> (v47 - 2)) & 1) << (~(_BYTE)v22 & 7));
          ++v22;
        }
        --v47;
      }
      while (v47 > 1);
      ++v44;
    }
    while (v44 != v45);
  }
  return (v22 + 7) >> 3;
}

uint64_t _Rice_ReadWord(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result;
  int v5;

  result = 0;
  switch(a3)
  {
    case 1:
      result = (2 * *(char *)(a1 + a2)) ^ (*(char *)(a1 + a2) >> 7);
      break;
    case 2:
      result = *(unsigned __int8 *)(a1 + a2);
      break;
    case 3:
      v5 = *(__int16 *)(a1 + 2 * a2);
      result = (2 * v5) ^ (v5 >> 15);
      break;
    case 4:
      result = *(unsigned __int16 *)(a1 + 2 * a2);
      break;
    case 7:
      result = (2 * *(_DWORD *)(a1 + 4 * a2)) ^ (*(int *)(a1 + 4 * a2) >> 31);
      break;
    case 8:
      result = *(unsigned int *)(a1 + 4 * a2);
      break;
    default:
      return result;
  }
  return result;
}

_BYTE *Rice_Uncompress(_BYTE *result, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  int v5;
  unsigned int v6;
  _BYTE *v10;
  signed int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  int32x4_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  unint64_t v23;
  int v24;
  unsigned int v25;
  unint64_t v26;
  int v27;
  int v28;
  BOOL v29;
  int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  unint64_t v35;
  int v36;
  int v37;
  _OWORD v38[4];
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  memset(v38, 0, sizeof(v38));
  v5 = a5 - 1;
  if ((a5 - 1) <= 7 && ((0xCFu >> v5) & 1) != 0)
  {
    v6 = dword_214FC0984[v5];
    if (v6 >> 3 <= a4)
    {
      v10 = result;
      v11 = *result;
      v12 = a4 / (v6 >> 3);
      v13 = 0;
      if (*result)
      {
        if (v12 <= 1)
          v14 = 1;
        else
          v14 = a4 / (v6 >> 3);
        v37 = v14;
        v15 = 8;
        do
        {
          if (v13 >= 0x10)
          {
            v16 = 0;
            v17 = 0uLL;
            do
              v17 = vaddq_s32((int32x4_t)v38[v16++], v17);
            while (v16 != 4);
            v11 = (vaddvq_s32(v17) + 8) >> 4;
          }
          v18 = v15 >> 3;
          if (v15 >> 3 >= a3)
          {
            v19 = 0;
          }
          else
          {
            v19 = 0;
            do
            {
              v20 = v15 + v19 + 1;
              if (((v10[v18] >> (~(v15 + v19) & 7)) & 1) == 0)
                break;
              ++v19;
              v18 = v20 >> 3;
            }
            while (v20 >> 3 < a3);
            v21 = v19 - 9;
            if (v19 >= 9)
            {
              if (v21 < 1)
              {
                v19 = 9;
              }
              else
              {
                v22 = 1;
                do
                {
                  v23 = (unint64_t)v20 >> 3;
                  if (v23 >= a3)
                    v24 = 0;
                  else
                    v24 = (v10[v23] >> (~(_BYTE)v20++ & 7)) & 1;
                  v22 = v24 | (2 * v22);
                  --v21;
                }
                while (v21);
                v19 = v22 + 8;
              }
            }
            v15 = v20;
          }
          if (v11 >= 1)
          {
            v25 = v11 + 1;
            do
            {
              v26 = (unint64_t)v15 >> 3;
              if (v26 >= a3)
                v27 = 0;
              else
                v27 = (v10[v26] >> (~(_BYTE)v15++ & 7)) & 1;
              v19 = v27 | (2 * v19);
              --v25;
            }
            while (v25 > 1);
          }
          result = (_BYTE *)_Rice_WriteWord(a2, v13, a5, v19);
          v28 = 32;
          if ((v19 & 0x80000000) == 0)
          {
            do
            {
              v19 *= 2;
              v29 = v28-- != 0;
            }
            while ((v19 & 0x80000000) == 0 && v28 != 0 && v29);
          }
          *((_DWORD *)v38 + (v13++ & 0xF)) = v28;
        }
        while (v13 != v37);
      }
      else
      {
        if (v12 <= 1)
          v30 = 1;
        else
          v30 = a4 / (v6 >> 3);
        v31 = v6 + 1;
        v32 = 8;
        do
        {
          v33 = 0;
          v34 = v31;
          do
          {
            v35 = (unint64_t)v32 >> 3;
            if (v35 >= a3)
              v36 = 0;
            else
              v36 = (v10[v35] >> (~(_BYTE)v32++ & 7)) & 1;
            v33 = v36 | (2 * v33);
            --v34;
          }
          while (v34 > 1);
          result = (_BYTE *)_Rice_WriteWord(a2, v13++, a5, v33);
        }
        while (v13 != v30);
      }
    }
  }
  return result;
}

uint64_t _Rice_WriteWord(uint64_t result, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;

  switch(a3)
  {
    case 1:
      if ((a4 & 1) != 0)
        v4 = -((a4 + 1) >> 1);
      else
        LOBYTE(v4) = a4 >> 1;
      *(_BYTE *)(result + a2) = v4;
      break;
    case 2:
      *(_BYTE *)(result + a2) = a4;
      break;
    case 3:
      if ((a4 & 1) != 0)
        v5 = -((a4 + 1) >> 1);
      else
        LOWORD(v5) = a4 >> 1;
      *(_WORD *)(result + 2 * a2) = v5;
      break;
    case 4:
      *(_WORD *)(result + 2 * a2) = a4;
      break;
    case 7:
      if ((a4 & 1) != 0)
        v6 = -((a4 + 1) >> 1);
      else
        v6 = a4 >> 1;
      *(_DWORD *)(result + 4 * a2) = v6;
      break;
    case 8:
      *(_DWORD *)(result + 4 * a2) = a4;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t RLE_Compress(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t i;
  uint64_t result;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned int j;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  _DWORD v21[256];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (!a3)
    return 0;
  bzero(v21, 0x400uLL);
  v6 = 0;
  do
    ++v21[a1[v6++]];
  while (a3 != v6);
  v7 = 0;
  for (i = 1; i != 256; ++i)
  {
    if (v21[i] < v21[v7])
      v7 = i;
  }
  *a2 = v7;
  LODWORD(result) = 1;
  v20 = 1;
  v10 = *a1;
  if (a3 < 2)
  {
LABEL_30:
    if (v10 == v7)
    {
      LOBYTE(v10) = 0;
      a2[result] = v7;
      LODWORD(result) = result + 1;
    }
    a2[result] = v10;
    return (result + 1);
  }
  v11 = a1 + 1;
  for (j = 2; ; ++j)
  {
    v13 = *v11;
    if ((_DWORD)v13 == v10)
    {
      if (j >= a3)
      {
        v16 = 2;
        v17 = v10;
LABEL_21:
        if (v10 == v17)
        {
          _RLE_WriteRep((uint64_t)a2, &v20, v7, v10, v16);
          v19 = 0;
          goto LABEL_26;
        }
      }
      else
      {
        v14 = 0;
        v15 = j;
        v16 = a3 + 2 - j;
        v17 = v10;
        while (v10 == v17 && !((v14 + 2) >> 15))
        {
          v17 = a1[j + v14++];
          if (!(j - (unint64_t)a3 + v14))
          {
            j = a3;
            goto LABEL_21;
          }
        }
        j += v14;
        v16 = v14 + 2;
        if (v10 == v17)
        {
          _RLE_WriteRep((uint64_t)a2, &v20, v7, v10, v16);
          v10 = a1[j];
          v19 = 1;
          j = v15 + v14 + 1;
          goto LABEL_26;
        }
      }
      _RLE_WriteRep((uint64_t)a2, &v20, v7, v10, v16 - 1);
      v19 = 1;
      v10 = v17;
    }
    else
    {
      v18 = v20;
      if (v10 == v7)
      {
        LOBYTE(v10) = 0;
        a2[v20] = v7;
        ++v18;
      }
      a2[v18] = v10;
      v20 = v18 + 1;
      v19 = 1;
      v10 = v13;
    }
LABEL_26:
    if (j >= a3)
      break;
    v11 = &a1[j];
  }
  result = v20;
  if (v19)
    goto LABEL_30;
  return result;
}

uint64_t _RLE_WriteRep(uint64_t result, unsigned int *a2, int a3, int a4, unsigned int a5)
{
  uint64_t v5;
  unsigned int v6;
  __int16 v7;
  unsigned int v8;

  v5 = *a2;
  if (a5 > 3)
  {
    v6 = v5 + 1;
    *(_BYTE *)(result + v5) = a3;
    v7 = a5 - 1;
    if (a5 - 1 >= 0x80)
    {
      *(_BYTE *)(result + v6) = HIBYTE(v7) | 0x80;
      v6 = v5 + 2;
    }
    *(_BYTE *)(result + v6) = v7;
    LODWORD(v5) = v6;
    goto LABEL_7;
  }
  if (a4 == a3)
  {
    *(_BYTE *)(result + v5) = a4;
    LOBYTE(a4) = a5 - 1;
LABEL_7:
    v8 = v5 + 2;
    *(_BYTE *)(result + (v5 + 1)) = a4;
    goto LABEL_8;
  }
  if (a5)
  {
    do
    {
      v8 = v5 + 1;
      *(_BYTE *)(result + v5) = a4;
      LODWORD(v5) = v5 + 1;
      --a5;
    }
    while (a5);
  }
  else
  {
    v8 = *a2;
  }
LABEL_8:
  *a2 = v8;
  return result;
}

unsigned __int8 *RLE_Uncompress(unsigned __int8 *result, uint64_t a2, unsigned int a3)
{
  unsigned int v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned __int8 v12;
  unsigned int v13;

  if (a3)
  {
    v3 = 0;
    v4 = *result;
    v5 = 1;
    do
    {
      v6 = result[v5];
      if (v6 == v4)
      {
        v7 = v5 + 2;
        v8 = result[v5 + 1];
        if (v8 > 2)
        {
          if ((v8 & 0x80) != 0)
          {
            v11 = result[v7];
            v7 = v5 + 3;
            v8 = v11 & 0xFFFF80FF | ((v8 & 0x7F) << 8);
          }
          v12 = result[v7];
          v13 = v8 + 1;
          v10 = v8 + 1 + v3;
          do
          {
            *(_BYTE *)(a2 + v3++) = v12;
            --v13;
          }
          while (v13);
          ++v7;
        }
        else
        {
          v9 = v8 + 1;
          v10 = v8 + 1 + v3;
          do
          {
            *(_BYTE *)(a2 + v3++) = v4;
            --v9;
          }
          while (v9);
        }
      }
      else
      {
        v10 = v3 + 1;
        *(_BYTE *)(a2 + v3) = v6;
        v7 = v5 + 1;
      }
      v5 = v7;
      v3 = v10;
    }
    while (v7 < a3);
  }
  return result;
}

uint64_t SF_Compress(unsigned __int8 *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  int v4;
  unsigned __int8 *v5;
  uint64_t v6;
  int32x4_t v7;
  __int128 v8;
  int32x4_t v9;
  float *v10;
  __int128 v11;
  __int128 v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  __int128 *v25;
  __int128 *v26;
  int v27;
  __int128 v28;
  int v29;
  unsigned int v30;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  _OWORD v35[256];
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  if (!a3)
    return 0;
  LODWORD(v3) = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0;
  v32 = a2;
  v7 = (int32x4_t)xmmword_214F03640;
  v8 = 0uLL;
  v9.i64[0] = 0x400000004;
  v9.i64[1] = 0x400000004;
  do
  {
    v10 = (float *)&v35[v6];
    v11 = 0uLL;
    v12 = 0uLL;
    vst4q_f32(v10, *(float32x4x4_t *)v7.i8);
    v7 = vaddq_s32(v7, v9);
    v6 += 4;
  }
  while (v6 != 256);
  v13 = a3;
  v14 = a1;
  do
  {
    v15 = *v14++;
    ++DWORD1(v35[v15]);
    --v13;
  }
  while (v13);
  v16 = 0;
  v17 = 0;
  while (1)
  {
    v18 = v16 + 1;
    v19 = v17;
    if (DWORD1(v35[v16]) < DWORD1(v35[v16 + 1]))
    {
      v34 = v35[v16];
      v20 = v34;
      v35[v16] = v35[v18];
      v35[v18] = v20;
      v19 = 1;
      v17 = 1;
    }
    ++v16;
    if (v18 == 255)
    {
      v16 = 0;
      v17 = 0;
      if (!v19)
        break;
    }
  }
  v21 = 256;
  do
    --v21;
  while (!DWORD1(v35[v21]));
  v33 = 0;
  if (v21 <= 1)
    v22 = 1;
  else
    v22 = v21;
  _SF_MakeTree((uint64_t)v35, (uint64_t)&v32, 0, 0, 0, v22);
  v23 = 0;
  v24 = 0;
  while (1)
  {
    v25 = &v35[v23++];
    v26 = &v35[v23];
    v27 = v24;
    if (*(_DWORD *)v25 > *(_DWORD *)v26)
    {
      v34 = *v25;
      v28 = v34;
      *v25 = *v26;
      *v26 = v28;
      v27 = 1;
      v24 = 1;
    }
    if (v23 == 255)
    {
      v23 = 0;
      v24 = 0;
      if (!v27)
        break;
    }
  }
  v3 = v3;
  do
  {
    v29 = *v5++;
    _Huffman_WriteBits((uint64_t)&v32, DWORD2(v35[v29]), HIDWORD(v35[v29]));
    --v3;
  }
  while (v3);
  v30 = v32 - v4;
  if ((_DWORD)v33)
    return v30 + 1;
  else
    return v30;
}

uint64_t _SF_MakeTree(uint64_t a1, uint64_t a2, int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6;
  uint64_t v9;
  unint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v23;
  uint64_t v24;
  unsigned int *v25;
  uint64_t result;

  v6 = a5;
  v9 = a2;
  if (a5 == a6)
  {
LABEL_24:
    _Huffman_WriteBits(v9, 1u, 1);
    v24 = v9;
    v25 = (unsigned int *)(a1 + 16 * v6);
    result = _Huffman_WriteBits(v24, *v25, 8);
    v25[2] = a3;
    v25[3] = a4;
    return result;
  }
  v12 = a6;
  while (1)
  {
    _Huffman_WriteBits(v9, 0, 1);
    if (v6 <= a6)
    {
      v13 = 0;
      v14 = v6;
      v15 = v6;
      do
        v13 += *(_DWORD *)(a1 + 16 * v15++ + 4);
      while (v15 <= a6);
      if ((v13 + 1) >= 2 && v6 < a6)
      {
        v17 = v9;
        v18 = 0;
        v19 = 1;
        v20 = (16 * v6) | 4;
        do
        {
          v18 += *(_DWORD *)(a1 + v20);
          v21 = v6 + v19;
          v20 += 16;
          ++v19;
        }
        while (v18 < (v13 + 1) >> 1 && v21 < v12);
        v6 = v6 + v19 - 1;
        if (v18)
        {
          _Huffman_WriteBits(v17, 1u, 1);
          v23 = v14 + v19;
          v9 = a2;
          _SF_MakeTree(a1, a2, (2 * a3), a4 + 1, v14, (v23 - 2));
          goto LABEL_21;
        }
        v9 = v17;
      }
    }
    else
    {
      v13 = 0;
    }
    _Huffman_WriteBits(v9, 0, 1);
    v18 = 0;
LABEL_21:
    if (v13 == v18)
      return _Huffman_WriteBits(v9, 0, 1);
    _Huffman_WriteBits(v9, 1u, 1);
    a3 = (2 * a3) | 1;
    ++a4;
    if (v6 == a6)
    {
      v6 = a6;
      goto LABEL_24;
    }
  }
}

uint64_t SF_Uncompress(uint64_t result, _BYTE *a2, int a3, int a4)
{
  int v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  char v12;
  int v13;
  unsigned __int8 *v14;
  uint64_t v15;
  _BYTE v16[12264];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v14 = (unsigned __int8 *)result;
    v15 = 0;
    v13 = 0;
    result = _SF_RecoverTree((uint64_t)v16, &v14, &v13);
    if (a4)
    {
      v6 = 0;
      v7 = v14;
      LOBYTE(v8) = v15;
      do
      {
        v9 = *(_DWORD *)(result + 16);
        if (v9 < 0)
        {
          v10 = result;
          do
          {
            v11 = *v7;
            v12 = 7 - v8;
            v8 = ((_BYTE)v8 + 1) & 7;
            if (!v8)
              ++v7;
            LODWORD(v15) = v8;
            v14 = v7;
            if (((v11 >> v12) & 1) != 0)
              v10 += 8;
            v10 = *(_QWORD *)v10;
            v9 = *(_DWORD *)(v10 + 16);
          }
          while (v9 < 0);
        }
        *a2++ = v9;
        ++v6;
      }
      while (v6 != a4);
    }
  }
  return result;
}

uint64_t _SF_RecoverTree(uint64_t a1, unsigned __int8 **a2, _DWORD *a3)
{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  int v13;
  unsigned int v14;

  v4 = a1 + 24 * (*a3)++;
  *(_DWORD *)(v4 + 16) = -1;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)v4 = 0;
  v5 = *a2;
  v6 = *((_DWORD *)a2 + 2);
  v7 = **a2;
  v8 = ((_BYTE)v6 + 1) & 7;
  if ((((_BYTE)v6 + 1) & 7) == 0)
    v5 = *a2 + 1;
  *((_DWORD *)a2 + 2) = v8;
  *a2 = v5;
  v9 = *v5;
  if (((v7 >> (7 - v6)) & 1) != 0)
  {
    v10 = v5[1];
    *a2 = v5 + 1;
    *(_DWORD *)(v4 + 16) = (v10 >> (8 - v8)) | (v9 << v8);
  }
  else
  {
    v13 = ((_BYTE)v6 + 2) & 7;
    if ((((_BYTE)v6 + 2) & 7) == 0)
      ++v5;
    *((_DWORD *)a2 + 2) = v13;
    *a2 = v5;
    if (((v9 >> (v8 ^ 7)) & 1) != 0)
    {
      *(_QWORD *)v4 = _SF_RecoverTree(a1, a2, a3);
      v5 = *a2;
      v13 = *((_DWORD *)a2 + 2);
    }
    v14 = *v5;
    if ((((_BYTE)v13 + 1) & 7) == 0)
      ++v5;
    *((_DWORD *)a2 + 2) = ((_BYTE)v13 + 1) & 7;
    *a2 = v5;
    if (((v14 >> (7 - v13)) & 1) != 0)
      *(_QWORD *)(v4 + 8) = _SF_RecoverTree(a1, a2, a3);
  }
  return v4;
}

uint64_t writeToPeriVec_0(uint64_t a1, unsigned int a2, __int16 a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;

  v6 = *(_DWORD *)(a1 + 16);
  if (v6 <= a2)
  {
    v7 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a1 + 8), 2 * (v6 + 150));
    if (!v7)
      return 2164269066;
    *(_QWORD *)(a1 + 8) = v7;
    *(_DWORD *)(a1 + 16) += 150;
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 8);
  }
  v8 = 0;
  *(_WORD *)(v7 + 2 * a2) = a3;
  return v8;
}

_QWORD *freePeriDescDyna(uint64_t a1, uint64_t *a2)
{
  heap_Free(*(_QWORD **)(a1 + 8), a2[2]);
  heap_Free(*(_QWORD **)(a1 + 8), a2[5]);
  heap_Free(*(_QWORD **)(a1 + 8), a2[8]);
  return heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)a2);
}

uint64_t Psola_GetDecodedUnitData(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, int a6, int a7, unsigned int a8, _WORD *a9, int *a10, _DWORD *a11, _DWORD *a12)
{
  uint64_t UnitData;
  uint64_t Segment;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  char *v26;
  double v27;
  uint64_t v28;
  float *v29;
  float v30;
  uint64_t v32;
  float *v33;
  float v34;
  int v35;
  _QWORD v37[2];
  uint64_t v38;
  uint64_t v39;
  char *v40;

  if (!a3)
    return 0;
  v38 = 0;
  v39 = 0;
  v37[0] = 0;
  v37[1] = 0;
  UnitData = Lookup_GetUnitData(*(_QWORD **)(a1 + 24), a4, (uint64_t)v37);
  if ((UnitData & 0x80000000) != 0)
    return UnitData;
  if (a6 + a5 + a7 <= a8)
  {
    v20 = HIDWORD(v37[0]);
    if (HIDWORD(v37[0]) >= a5)
      v21 = a5;
    else
      v21 = HIDWORD(v37[0]);
    *a10 = v21;
    *a11 = a6;
    *a12 = a7;
    v22 = *a10;
    v23 = *a10 + a7 + *a11;
    v40 = 0;
    if (*(_DWORD *)(a1 + 76))
      v24 = *(_DWORD *)(a1 + 21304);
    else
      v24 = 0;
    Segment = concat_getSegment(a1, a4, v20 - v22, v23, (uint64_t)&v38, v24);
    v25 = HIDWORD(v39);
    v26 = v40;
    if (HIDWORD(v39))
    {
      v27 = *(double *)(a1 + 21336);
      v28 = HIDWORD(v39);
      v29 = (float *)v40;
      do
      {
        v30 = v27 * *v29;
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
    if (*(_DWORD *)(a1 + 21316) == 1)
    {
      concat_applyBPF(*(_QWORD *)a1, v26, v25);
      v25 = HIDWORD(v39);
      v26 = v40;
    }
    if (v25)
    {
      v32 = v25;
      v33 = (float *)v26;
      do
      {
        v34 = *v33;
        if (*v33 <= 32767.0)
        {
          if (v34 >= -32768.0)
            v35 = (int)v34;
          else
            LOWORD(v35) = 0x8000;
        }
        else
        {
          LOWORD(v35) = 0x7FFF;
        }
        *a9++ = v35;
        ++v33;
        --v32;
      }
      while (v32);
    }
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v26);
  }
  else
  {
    *a10 = 0;
    *a11 = 0;
    Segment = 2164269065;
    *a12 = 0;
  }
  return Segment;
}

uint64_t concat_getSegment(uint64_t a1, unsigned int a2, unsigned int a3, int a4, uint64_t a5, int a6)
{
  unsigned int v6;
  int *v9;
  uint64_t *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int16 *v22;
  unsigned int v23;
  _QWORD *v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  float v29;

  v6 = a4;
  *(_DWORD *)(a5 + 12) = a4;
  v9 = (int *)(a5 + 12);
  *(_DWORD *)(a5 + 8) = a4;
  if (a4 <= 0)
  {
    *v9 = 0;
    log_wsola_Diag(*(_QWORD *)a1, 1, (uint64_t)"WARNING: Segment in unit %d has a duration of %d\n");
    return 2164269063;
  }
  v11 = *(uint64_t **)(*(_QWORD *)a1 + 8);
  if (!a6)
  {
    v16 = heap_Calloc(v11, a4, 2);
    if (!v16)
    {
      v14 = 2164269066;
      goto LABEL_32;
    }
    v22 = (__int16 *)v16;
    if (a2 <= 0xFFFFFFFD)
    {
      Lookup_Init(*(_QWORD *)(a1 + 24), a3, *v9);
      Lookup_Decode(*(_QWORD *)(a1 + 24), v9, (uint64_t)v22);
      v6 = *v9;
    }
    if (a2 == -2)
    {
      v25 = *(_DWORD *)(a1 + 72);
      if (v25 <= a3)
      {
        log_wsola_Error(*(_QWORD *)a1, 59012, 0, v17, v18, v19, v20, v21);
        return 2164269071;
      }
      if (*v9 + a3 > v25)
        v6 = v25 - a3;
      v24 = (_QWORD *)(a1 + 64);
    }
    else
    {
      if (a2 != -1)
        goto LABEL_23;
      v23 = *(_DWORD *)(a1 + 56);
      if (v23 <= a3)
        goto LABEL_23;
      if (*v9 + a3 > v23)
        v6 = v23 - a3;
      v24 = (_QWORD *)(a1 + 48);
    }
    cstdlib_memcpy(v22, (const void *)(*v24 + 2 * a3), 2 * v6);
LABEL_23:
    v26 = heap_Realloc(*(uint64_t **)(*(_QWORD *)a1 + 8), *(_QWORD *)(a5 + 16), 4 * *(unsigned int *)(a5 + 12));
    *(_QWORD *)(a5 + 16) = v26;
    if (v26)
    {
      v27 = *v9;
      if ((_DWORD)v27)
      {
        for (i = 0; i != v27; ++i)
        {
          v29 = 0.0;
          if (i < v6)
            v29 = (float)v22[i];
          *(float *)(v26 + 4 * i) = v29;
        }
      }
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v22);
      return 0;
    }
    v14 = 2164269066;
    heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)v22);
LABEL_32:
    log_wsola_Error(*(_QWORD *)a1, 59000, 0, v17, v18, v19, v20, v21);
    return v14;
  }
  v12 = (void *)heap_Realloc(v11, *(_QWORD *)(a5 + 16), 4 * a4);
  *(_QWORD *)(a5 + 16) = v12;
  if (v12)
  {
    v13 = *v9;
    if ((_DWORD)v13)
      bzero(v12, 4 * v13);
    return 0;
  }
  v14 = 2164269066;
  log_wsola_Diag(*(_QWORD *)a1, 1, (uint64_t)"ERROR: Out of memory\n");
  heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), 0);
  return v14;
}

uint64_t Psola_SynthSilence_0(uint64_t *a1, int *a2, int a3, int *a4)
{
  int v7;
  int v8;
  _BYTE v10[2];

  v7 = (1000 * a3 + 500) / 1000;
  Psola_FlushOlaBufPart_1(a1, a2, *a4);
  v8 = *a4 + v7;
  *a4 = v8;
  if (*a2 <= v8)
    Psola_AddToOlaBufAux_1(a1, a2, (uint64_t)v10, 0, 0, v8);
  return 0;
}

void Psola_FlushOlaBufPart_1(uint64_t *a1, _DWORD *a2, int a3)
{
  int v3;
  int v6;
  int v7;
  signed int v8;
  signed int v9;
  signed int v10;
  int v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  _OWORD v15[12];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v3 = a3 - *a2;
  if (v3 >= 1)
  {
    v6 = a2[1];
    v7 = a2[2];
    if (v3 >= v7)
      v8 = a2[2];
    else
      v8 = v3;
    if (v8 >= 2400 - v6)
      v9 = 2400 - v6;
    else
      v9 = v8;
    if (v3 >= v7)
      v10 = v7 - v9;
    else
      v10 = v3 - v9;
    if (v9 >= 1)
    {
      Wsola__write_audioX(a1, (uint64_t)(a2 + 3), v6, v9);
      bzero((char *)a2 + 2 * a2[1] + 12, 2 * v9);
    }
    if (v10 >= 1)
    {
      Wsola__write_audioX(a1, (uint64_t)(a2 + 3), 0, v10);
      bzero(a2 + 3, 2 * v10);
    }
    v11 = v3 - v9 - v10;
    if (v11 >= 1)
    {
      v16 = 0;
      memset(v15, 0, sizeof(v15));
      do
      {
        if (v11 >= 100)
          v12 = 100;
        else
          v12 = v11;
        Wsola__write_audioX(a1, (uint64_t)v15, 0, v12);
        v13 = __OFSUB__(v11, v12);
        v11 -= v12;
      }
      while (!((v11 < 0) ^ v13 | (v11 == 0)));
    }
    v14 = a2[1] + v3;
    *a2 += v3;
    a2[1] = v14 % 2400;
    a2[2] -= v10 + v9;
  }
}

uint64_t Psola_Initialise(uint64_t *a1, uint64_t a2, int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v10 = 2164269066;
  v11 = heap_Calloc(*(_QWORD **)(a2 + 8), 1, 136);
  *a1 = v11;
  if (v11)
  {
    v12 = v11;
    *(_BYTE *)(v11 + 112) = 1;
    v13 = heap_Alloc(*(_QWORD *)(a2 + 8), 4812);
    *(_QWORD *)(v12 + 16) = v13;
    if (v13)
    {
      v14 = heap_Alloc(*(_QWORD *)(a2 + 8), 48000);
      *(_QWORD *)(v12 + 24) = v14;
      if (v14)
      {
        v15 = heap_Alloc(*(_QWORD *)(a2 + 8), 48);
        *(_QWORD *)(v12 + 32) = v15;
        if (v15)
        {
          *(_QWORD *)(v15 + 8) = 961;
          v16 = heap_Alloc(*(_QWORD *)(a2 + 8), 1922);
          v17 = *(uint64_t **)(v12 + 32);
          *v17 = v16;
          if (v16)
          {
            v17[3] = 961;
            v18 = heap_Alloc(*(_QWORD *)(a2 + 8), 1922);
            v19 = *(_QWORD **)(v12 + 32);
            v19[2] = v18;
            if (*v19)
            {
              v19[5] = 961;
              v20 = heap_Alloc(*(_QWORD *)(a2 + 8), 1922);
              *(_QWORD *)(*(_QWORD *)(v12 + 32) + 32) = v20;
              if (v20)
              {
                v21 = newModPeriDesc(a2);
                *(_QWORD *)(v12 + 64) = v21;
                if (v21)
                {
                  v22 = newModPeriDesc(a2);
                  *(_QWORD *)(v12 + 72) = v22;
                  if (v22)
                  {
                    bzero(*(void **)(v12 + 16), 0x12CCuLL);
                    *(_QWORD *)(v12 + 88) = 0;
                    v23 = *(_QWORD *)(v12 + 72);
                    *(_WORD *)v23 = 0;
                    *(_DWORD *)(v23 + 2) = 0;
                    v24 = *(_QWORD *)(v12 + 64);
                    *(_WORD *)v24 = 0;
                    *(_DWORD *)(v24 + 2) = 0;
                    v25 = Psola_SetUpCrossFading_1(a3, 100, 100, (unsigned __int16 *)v23, (unsigned __int16 *)v24, (_DWORD *)(v12 + 8), (int *)(v12 + 12));
                    if ((v25 & 0x80000000) != 0)
                    {
                      return v25;
                    }
                    else
                    {
                      v10 = 0;
                      *(_QWORD *)v12 = 0x100000000;
                      *(_DWORD *)(v12 + 96) = 0;
                      *(_DWORD *)(v12 + 100) = a3;
                      *(_DWORD *)(v12 + 40) = 0;
                      *(float *)(v12 + 116) = (float)a4;
                      *(float *)(v12 + 120) = (float)a5;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v10;
}

uint64_t Psola_SetUpCrossFading_1(int a1, int a2, int a3, unsigned __int16 *a4, unsigned __int16 *a5, _DWORD *a6, int *a7)
{
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v20;
  int v21;
  unint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  int v27;
  int v28;
  BOOL v29;
  int v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  __int16 v42;
  unint64_t v43;
  int v44;
  int v45;
  int v46;

  v11 = a2 * a1;
  v12 = 274877907 * a2 * a1;
  v13 = (unint64_t)v12 >> 63;
  v14 = v12 >> 38;
  v15 = a3 * a1 / 1000;
  v16 = a4[1] + *a4;
  *a7 = 0;
  if (a4[2])
  {
    v43 = (unint64_t)v12 >> 63;
    v45 = a2 * a1;
    v17 = 0;
    v18 = 0;
    do
    {
      if (v17 >= a5[1] >> 1 || v18 >= v15)
        break;
      v20 = *((_QWORD *)a5 + 8);
      v21 = *(__int16 *)(v20 + 2 * (v17 + *a5));
      writeToPeriVec_0((uint64_t)(a4 + 28), v16 + v17, *(_WORD *)(v20 + 2 * (v17 + *a5)));
      v18 = *a7 + v21;
      *a7 = v18;
      ++v17;
    }
    while (v17 < a4[2]);
    v11 = v45;
    LODWORD(v13) = v43;
  }
  else
  {
    LOWORD(v17) = 0;
  }
  v46 = v14 + v13;
  a4[2] = v17;
  *a6 = 0;
  LODWORD(v22) = *a5;
  if (*a5)
  {
    v23 = 0;
    if (a4[1] && v11 >= 1000)
    {
      v24 = 2 * v16 - 2;
      v25 = -1;
      v26 = 1;
      do
      {
        v27 = v25;
        v28 = *(__int16 *)(*((_QWORD *)a4 + 8) + v24);
        writeToPeriVec_0((uint64_t)(a5 + 28), v22 + v25, *(_WORD *)(*((_QWORD *)a4 + 8) + v24));
        v23 = *a6 + v28;
        *a6 = v23;
        v22 = *a5;
        if (v26 >= v22)
          break;
        v25 = v27 - 1;
        v29 = v26++ >= ((unint64_t)a4[1] + 1) >> 1;
        v24 -= 2;
      }
      while (!v29 && v23 < v46);
      v31 = -v27;
    }
    else
    {
      v31 = 0;
    }
    v32 = v22;
  }
  else
  {
    v23 = 0;
    v31 = 0;
    v32 = 0;
  }
  v33 = v32 - v31;
  if ((int)(v32 - v31) >= 1)
  {
    v34 = a5[1];
    v35 = a5[2];
    if (v33 < v32 + v34 + v35)
    {
      v42 = v32 - v31;
      v44 = v15;
      v36 = 0;
      v37 = 2 * -v31 + 2 * v32;
      v38 = v35 + v34 - -v31;
      do
      {
        writeToPeriVec_0((uint64_t)(a5 + 4), v36, *(_WORD *)(*((_QWORD *)a5 + 2) + v37 + 2 * v36));
        writeToPeriVec_0((uint64_t)(a5 + 16), v36, *(_WORD *)(*((_QWORD *)a5 + 5) + v37 + 2 * v36));
        writeToPeriVec_0((uint64_t)(a5 + 28), v36, *(_WORD *)(*((_QWORD *)a5 + 8) + v37 + 2 * v36));
        ++v36;
      }
      while (v38 != v36);
      LOWORD(v22) = *a5;
      v23 = *a6;
      LOWORD(v33) = v42;
      v15 = v44;
    }
    *a5 = v22 - v33;
  }
  v39 = v46;
  if (v23 < v46)
    v39 = v23;
  *a6 = v39;
  v40 = *a7;
  if (*a7 >= v15)
    v40 = v15;
  *a7 = v40;
  if (!((*a6 + v40 < 0) ^ __OFADD__(*a6, v40) | (*a6 + v40 == 0)) || !a4[1])
    return 0;
  if (a5[1])
    return 2164269071;
  return 0;
}

uint64_t Psola_Synthesis(uint64_t a1, uint64_t a2)
{
  int *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  float v11;
  void *MsgName;
  void *v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  __int16 v18;
  double v19;
  _DWORD *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  unsigned __int16 v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  _WORD *v33;
  uint64_t result;
  uint64_t i;
  _WORD **v36;
  uint64_t v37;
  int v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  uint64_t v43;
  int v44;
  unsigned __int16 *v45;
  _WORD *v46;
  __int16 *v47;
  int v48;
  unsigned int v49;
  uint64_t v50;
  int v51;
  int v52;
  unsigned __int16 *v53;
  uint64_t v54;
  int v55;
  __int16 *v56;
  int v57;
  int v58;
  __int16 *v59;
  unsigned __int16 *v60;
  int v61;
  unsigned __int16 v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  unsigned int v67;
  unsigned int v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  BOOL v73;
  _BOOL4 v74;
  BOOL v75;
  __int16 v76;
  int v77;
  uint64_t v78;
  int v79;
  int v80;
  unsigned int v81;
  int v82;
  unsigned int v83;
  unsigned int v84;
  int v85;
  _WORD *v86;
  uint64_t v87;
  unsigned int v88;
  uint64_t v89;
  uint64_t v90;
  __int16 v91;
  BOOL v93;
  int v94;
  int v95;
  int v96;
  int v97;
  __int16 *v98;
  int v99;
  uint64_t v100;
  int v101;
  int v102;
  unsigned int v103;
  unsigned int v104;
  int v105;
  uint64_t v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  int v113;
  __int16 *v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  int v121;
  __int16 *v122;
  _WORD *v123;
  int v124;
  __int16 v125;
  unsigned __int16 *v126;
  int v127;
  __int16 *v128;
  _WORD *v129;
  int v130;
  __int16 v131;
  __int16 *v132;
  int v133;
  int v134;
  int v136;
  int v137;
  int v138;
  uint64_t v139;
  unsigned __int16 v140;
  uint64_t v141;
  __int16 v142;
  __int16 v143;
  void *v144;
  void *v145;
  unsigned int v146;
  uint64_t *v147;
  int *v148;
  int *v149;
  int v150;
  uint64_t v151;
  int v152;
  int v153;
  uint64_t v154;
  uint64_t *v155;
  __int16 v156;
  __int16 v157;
  _WORD **v158;
  uint64_t v159;
  int *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  int v164;
  uint64_t v165;
  int v166;
  int v167;
  int v168;
  unsigned int v169;
  int v170;
  int v171;
  int *v172;
  int v173;
  uint64_t v174;
  int v175;
  unsigned __int16 *v176;
  int v177;
  uint64_t v178;
  int v179;
  int v180;
  int v181;
  uint64_t v182;
  int v183;
  _QWORD v184[2];

  v2 = (int *)a2;
  v3 = a1;
  v4 = a1 + 21280;
  v5 = *(_QWORD *)(a2 + 104);
  v6 = *(int *)(a2 + 96);
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(_DWORD *)(v5 + 40 * (int)v6);
  if ((_DWORD)v6)
    v9 = *(_DWORD *)(v5 + 40 * (int)(v6 - *(unsigned __int8 *)(a2 + 112)));
  else
    v9 = -1;
  v10 = v5 + 40 * (int)v6;
  v11 = (float)*(unsigned int *)(v3 + 40) / 1000.0;
  *(_DWORD *)v4 = v8;
  *(int32x2_t *)(v3 + 21288) = vcvt_s32_f32(vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)(v10 + 4)), v11));
  *(_DWORD *)(v4 + 16) = 0;
  *(_BYTE *)(v4 + 20) = 34;
  *(_DWORD *)(v4 + 24) = v8 == -1;
  *(_DWORD *)(v4 + 28) = 0;
  *(_DWORD *)(v4 + 32) = 0;
  MsgName = mfs_GetMsgName(v7, v8);
  v13 = MsgName;
  v15 = *(_DWORD *)(v10 + 4);
  v14 = *(_DWORD *)(v10 + 8);
  v16 = *((_QWORD *)v2 + 16);
  v17 = *(_QWORD *)(v16 + 8 * v6);
  *((_QWORD *)v2 + 7) = v17;
  if (!(_DWORD)v6)
  {
    *((_QWORD *)v2 + 6) = 0;
    v36 = (_WORD **)(v2 + 12);
LABEL_30:
    v37 = *((_QWORD *)v2 + 9);
    *(_DWORD *)v37 = 0;
    *(_WORD *)(v37 + 4) = 0;
LABEL_31:
    v38 = v2[25];
    v39 = *(_DWORD *)(v5 + 40 * (int)v6 + 24);
    v40 = v14;
    if ((int)v6 < 1)
      v41 = 100;
    else
      v41 = *(_DWORD *)(v5 + 40 * (v6 - 1) + 28);
    v182 = 0;
    result = Psola_SetUpCrossFading_1(v38, v39, v41, *((unsigned __int16 **)v2 + 8), *((unsigned __int16 **)v2 + 9), (_DWORD *)&v182 + 1, (int *)&v182);
    if ((result & 0x80000000) != 0)
      return result;
    if ((_DWORD)v6)
    {
      v42 = v15;
      if (v9 == -1)
      {
        v15 = v2[25] * *((unsigned __int16 *)v2 + 41) / 0x3E8;
        log_wsola_Diag(*(_QWORD *)v3, 3, (uint64_t)"Parametric silence for s32i = %d\n");
      }
      else
      {
        log_wsola_Diag(*(_QWORD *)v3, 3, (uint64_t)"Non silence unit %d for s32i = %d\n");
        if (**v36)
          v15 = -1;
        else
          v15 = (int)((double)(v2[25] * *((unsigned __int16 *)v2 + 41)) / 1000.0);
      }
      log_wsola_Diag(*(_QWORD *)v3, 3, (uint64_t)"SynthSilence debugging, s32i=%d, s32SilLen %d\n");
      log_wsola_Diag(*(_QWORD *)v3, 3, (uint64_t)"SynthSilence - next unit is going to be %d\n");
      if ((v15 & 0x80000000) != 0)
      {
        v45 = (unsigned __int16 *)*((_QWORD *)v2 + 6);
        v46 = (_WORD *)*((_QWORD *)v2 + 3);
        v184[0] = 0;
        v183 = 0;
        v47 = (__int16 *)*((_QWORD *)v45 + 2);
        v48 = *v47;
        if (v48 <= 0)
          v49 = -v48;
        else
          v49 = 0;
        v50 = (unsigned __int16)(v45[1] + v45[2] + v45[3] - 1);
        v51 = *(__int16 *)(*((_QWORD *)v45 + 5) + 2 * v50) + v47[v50];
        result = Psola_GetDecodedUnitData(v3, v43, (uint64_t)(v2 + 20), v9, v49, *v45, (v51 - *v45) & ~((v51 - *v45) >> 31), 0x5DC0u, v46, (int *)v184 + 1, &v183, v184);
        if ((result & 0x80000000) != 0)
          return result;
        result = 2164269065;
        v52 = HIDWORD(v184[0]);
        if (HIDWORD(v184[0]) + **((__int16 **)v45 + 2) < 0
          || HIDWORD(v184[0]) + v51 > v183 + HIDWORD(v184[0]) + LODWORD(v184[0]))
        {
          return result;
        }
        log_wsola_Diag(*(_QWORD *)v3, 3, (uint64_t)"About to call synthesis for unitID %d\n");
        v53 = (unsigned __int16 *)*((_QWORD *)v2 + 8);
        v54 = *v53;
        v55 = v53[1];
        v176 = v53;
        v56 = (__int16 *)*((_QWORD *)v53 + 8);
        v57 = 0;
        if ((_DWORD)v54)
        {
          v58 = v54;
          v59 = v56;
          LOWORD(v15) = v42;
          v60 = (unsigned __int16 *)*((_QWORD *)v2 + 8);
          do
          {
            v61 = *v59++;
            v57 += v61;
            --v58;
          }
          while (v58);
        }
        else
        {
          LOWORD(v15) = v42;
          v60 = (unsigned __int16 *)*((_QWORD *)v2 + 8);
        }
        v94 = v55 + v54;
        v95 = v2[2];
        v96 = v2[3];
        v97 = 0;
        if (v55)
        {
          v98 = &v56[v54];
          do
          {
            v99 = *v98++;
            v97 += v99;
            --v55;
          }
          while (v55);
        }
        v100 = v94 + v60[2];
        v101 = HIDWORD(v182);
        v102 = *v2;
        v170 = v96 + v95;
        if ((v170 < 0) ^ __OFADD__(v96, v95) | (v170 == 0))
        {
          v103 = (unsigned __int16)v56[v54];
          v170 = (int)((v103 + (v103 >> 15)) << 16) >> 17;
          v166 = *v2;
        }
        else
        {
          v166 = v102 - v95;
        }
        v168 = v182 + HIDWORD(v182);
        if (((int)v182 + HIDWORD(v182) < 0) ^ __OFADD__((_DWORD)v182, HIDWORD(v182)) | ((_DWORD)v182 + HIDWORD(v182) == 0))
        {
          v104 = (unsigned __int16)v56[v94 - 1];
          v101 = (__int16)(v104 + (v104 >> 15)) >> 1;
          v168 = v101;
        }
        v105 = v102 + v97;
        if ((_DWORD)v100)
        {
          v143 = v15;
          v145 = v13;
          v106 = 0;
          v107 = 0;
          v108 = *((_QWORD *)v2 + 3);
          v109 = *((_QWORD *)v2 + 4);
          v160 = v2 + 10;
          v172 = (int *)*((_QWORD *)v2 + 2);
          v153 = v105 - v101;
          v149 = v2;
          v174 = *((_QWORD *)v2 + 6);
          v181 = v102 - v57;
          v147 = (uint64_t *)(v109 + 16);
          v141 = (v100 - 1);
          v151 = (v100 + 1);
          v164 = v52;
          v162 = v100;
          v159 = v108;
          v155 = (uint64_t *)v3;
          v157 = v40;
          do
          {
            v179 = v107;
            if (v106)
            {
              if (v106 == v100)
              {
                v110 = *(__int16 *)(*((_QWORD *)v60 + 2) + 2 * v141);
                LODWORD(v111) = *(__int16 *)(*(_QWORD *)(v174 + 40) + 2 * v110);
                result = Psola_CopyDataPart(*(uint64_t **)(*(_QWORD *)v3 + 8), v108, v52 + *(__int16 *)(*(_QWORD *)(v174 + 16) + 2 * v110), v111, (uint64_t *)v109);
                if ((result & 0x80000000) != 0)
                  return result;
                LODWORD(v112) = 0;
                v113 = 0;
                v114 = (__int16 *)(*((_QWORD *)v60 + 8) + 2 * v141);
              }
              else
              {
                v116 = *(unsigned __int16 *)(*((_QWORD *)v60 + 5) + 2 * v106);
                v117 = *(__int16 *)(*((_QWORD *)v60 + 2) + 2 * v106);
                v118 = v117 - 1;
                v119 = *(_QWORD *)(v174 + 40);
                v120 = *(_QWORD *)(v174 + 16);
                if (v116)
                {
                  v111 = *(__int16 *)(v119 + 2 * v117);
                  v112 = *(__int16 *)(v119 + 2 * v118);
                  v121 = *(__int16 *)(v120 + 2 * v117);
                  result = Psola_ReallocIfNeeded(*(uint64_t **)(*(_QWORD *)v3 + 8), (uint64_t *)v109, v111);
                  if ((int)v111 >= 1 && (result & 0x80000000) == 0)
                  {
                    v122 = (__int16 *)(v108 + 2 * (v52 + v121));
                    v123 = (_WORD *)(*(_QWORD *)v109 + 2 * v111 - 2);
                    v124 = v111;
                    do
                    {
                      v125 = *v122++;
                      *v123-- = v125;
                      --v124;
                    }
                    while (v124);
                  }
                  v126 = v176;
                  if ((result & 0x80000000) != 0)
                    return result;
                  v127 = *(__int16 *)(*(_QWORD *)(v174 + 16) + 2 * v118);
                  result = Psola_ReallocIfNeeded(*(uint64_t **)(*(_QWORD *)v3 + 8), v147, v112);
                  if ((int)v112 >= 1 && (result & 0x80000000) == 0)
                  {
                    v128 = (__int16 *)(v108 + 2 * (v52 + v127));
                    v129 = (_WORD *)(*v147 + 2 * v112 - 2);
                    v130 = v112;
                    do
                    {
                      v131 = *v128++;
                      *v129-- = v131;
                      --v130;
                    }
                    while (v130);
                  }
                }
                else
                {
                  LODWORD(v111) = *(__int16 *)(v119 + 2 * v118);
                  LODWORD(v112) = *(__int16 *)(v119 + 2 * v117);
                  result = Psola_CopyDataPart(*(uint64_t **)(*(_QWORD *)v3 + 8), v108, v52 + *(__int16 *)(v120 + 2 * v118), v111, (uint64_t *)v109);
                  if ((result & 0x80000000) != 0)
                    return result;
                  result = Psola_CopyDataPart(*(uint64_t **)(*(_QWORD *)v3 + 8), v108, v52 + *(__int16 *)(*(_QWORD *)(v174 + 16) + 2 * v117), v112, v147);
                  v126 = v176;
                }
                if ((result & 0x80000000) != 0)
                  return result;
                v132 = (__int16 *)(*((_QWORD *)v126 + 8) + 2 * v106);
                v133 = *v132;
                v114 = v132 - 1;
                v113 = v133;
              }
              v134 = *v114;
              if ((int)v111 > v134)
              {
                cstdlib_memmove(*(void **)v109, (const void *)(*(_QWORD *)v109 + 2 * ((int)v111 - *v114)), 2 * *v114);
                LODWORD(v111) = v134;
              }
            }
            else
            {
              v115 = **((__int16 **)v60 + 2);
              LODWORD(v112) = *(__int16 *)(*(_QWORD *)(v174 + 40) + 2 * v115);
              result = Psola_CopyDataPart(*(uint64_t **)(*(_QWORD *)v3 + 8), v108, v52 + *(__int16 *)(*(_QWORD *)(v174 + 16) + 2 * v115), v112, v147);
              if ((result & 0x80000000) != 0)
                return result;
              LODWORD(v111) = 0;
              v113 = **((__int16 **)v60 + 8);
            }
            if ((int)v112 >= v113)
              LODWORD(v112) = v113;
            Psola_ApplyHanning_1(*(__int16 **)(v109 + 32), v160, *(__int16 **)v109, v111, 1);
            Psola_ApplyHanning_1(*(__int16 **)(v109 + 32), v160, *(__int16 **)(v109 + 16), v112, 0);
            Psola_ApplyFadingPart(*(__int16 **)v109, v111, v181 - v111, v166, v170, 1);
            Psola_ApplyFadingPart(*(__int16 **)(v109 + 16), v112, v181, v166, v170, 1);
            Psola_ApplyFadingPart(*(__int16 **)v109, v111, v181 - v111, v153, v168, 0);
            Psola_ApplyFadingPart(*(__int16 **)(v109 + 16), v112, v181, v153, v168, 0);
            v3 = (uint64_t)v155;
            Psola_AddToOlaBuf_1(v155, v172, *(_QWORD *)v109, v111, v181 - v111);
            Psola_AddToOlaBuf_1(v155, v172, *(_QWORD *)(v109 + 16), v112, v181);
            v107 = 1;
            v181 += v113;
            v40 = v157;
            v52 = v164;
            v100 = v162;
            v108 = v159;
            if (!v179)
            {
              if (v181 >= *v149 + 961 || v106 == v162)
              {
                Psola_FlushOlaBufPart_1(v155, v172, *v149);
                v107 = 1;
              }
              else
              {
                v107 = 0;
              }
            }
            ++v106;
            v60 = v176;
          }
          while (v106 != v151);
          v2 = v149;
          v105 = *v149 + v97;
          v13 = v145;
          LOWORD(v15) = v143;
        }
        *v2 = v105;
      }
      else
      {
        Psola_SynthSilence_0((uint64_t *)v3, *((int **)v2 + 2), v15, v2);
        LOWORD(v15) = v42;
      }
    }
    log_wsola_Diag(*(_QWORD *)v3, 3, (uint64_t)"BANANA: Synthesis of unit %d has just been completed\n\n");
    *((_WORD *)v2 + 40) = v15;
    *((_WORD *)v2 + 41) = v40;
    v2[21] = 0;
    *((_QWORD *)v2 + 11) = v13;
    *((int8x16_t *)v2 + 4) = vextq_s8(*((int8x16_t *)v2 + 4), *((int8x16_t *)v2 + 4), 8uLL);
    v44 = v182;
    v2[2] = HIDWORD(v182);
    v2[3] = v44;
    v2[1] = 3 - v2[1];
LABEL_45:
    ++v2[24];
    return Lookup_DeInit(*(uint64_t **)(v3 + 24));
  }
  *((_QWORD *)v2 + 6) = *(_QWORD *)(v16 + 8 * ((int)v6 - 1));
  v158 = (_WORD **)(v2 + 12);
  if (v8 == -1)
  {
    v36 = (_WORD **)(v2 + 12);
    goto LABEL_30;
  }
  v18 = *(_WORD *)(v17 + 4);
  if (!v18)
  {
    ++*((_BYTE *)v2 + 112);
    goto LABEL_45;
  }
  v156 = v14;
  *((_BYTE *)v2 + 112) = 1;
  v19 = *(double *)(v3 + 21352) * 0.5 + 100.0;
  v139 = v5;
  v20 = (_DWORD *)(v5 + 40 * (int)v6);
  v21 = v20[3] * (int)v19;
  v22 = (v21 + 50) / 100;
  v23 = v20[4] * (int)v19;
  v24 = (v23 + 50) / 100;
  v20[3] = v22;
  v20[4] = v24;
  v25 = v20[5];
  v26 = *(unsigned __int16 *)(v17 + 2);
  v140 = v26 + v18;
  v27 = v26 + v18 - 1;
  v28 = 0;
  if (v26 <= v27)
  {
    v29 = *(unsigned __int16 *)(v17 + 2);
    do
      v28 += *(__int16 *)(*(_QWORD *)(v17 + 40) + 2 * (unsigned __int16)v29++);
    while ((unsigned __int16)v29 <= v27);
  }
  v150 = v2[25];
  if (v25 < 0)
  {
    if (v150 >= 0)
      v30 = v2[25];
    else
      v30 = v150 + 1;
    v31 = (1000 * v28 + (v30 >> 1)) / v150;
    if (v31 >= 0)
      v32 = (1000 * v28 + (v30 >> 1)) / v150;
    else
      v32 = v31 + 1;
    v25 = (-1000 * v25 + (v32 >> 1)) / v31;
  }
  v142 = v15;
  v144 = MsgName;
  v146 = v9;
  v180 = v28;
  if (v25)
    v180 = (v25 * v28 + 500) / 1000;
  v148 = v2;
  v33 = (_WORD *)*((_QWORD *)v2 + 9);
  result = 2164269074;
  if (v21 >= 50 && v23 < 50 || v21 <= 49 && v23 > 49)
    return result;
  *v33 = 0;
  v154 = v3;
  v175 = (v21 + 50) / 100;
  v173 = v25;
  if ((_DWORD)v26)
  {
    v177 = (v23 + 50) / 100;
    for (i = 0; i != v26; ++i)
    {
      writeToPeriVec_0((uint64_t)(v33 + 4), i, i);
      writeToPeriVec_0((uint64_t)(v33 + 16), i, 0);
      writeToPeriVec_0((uint64_t)(v33 + 28), i, *(_WORD *)(*(_QWORD *)(v17 + 40) + 2 * i));
      ++*v33;
    }
    v22 = v175;
    v25 = v173;
    v24 = v177;
  }
  else
  {
    LODWORD(i) = 0;
  }
  v33[1] = 0;
  if (v26 <= v27)
  {
    v66 = 0;
    v67 = 0;
    v68 = 0;
    v152 = v24 - v22;
    if (v28 >= 0)
      v69 = v28;
    else
      v69 = v28 + 1;
    v136 = v69 >> 1;
    v165 = (uint64_t)(v33 + 4);
    v161 = (uint64_t)(v33 + 16);
    v163 = (uint64_t)(v33 + 28);
    v178 = v17;
    v167 = v6;
    while (1)
    {
      v70 = (unsigned __int16)v26;
      v71 = *(unsigned __int16 *)(*(_QWORD *)(v17 + 40) + 2 * (unsigned __int16)v26);
      if (v25)
        v68 += (v25 * (int)v71 + 500) / 1000;
      else
        v68 = v67 + v71;
      v72 = i <= 0x2710 ? 10000 : i;
      v73 = (unsigned __int16)v26 == v27 && v67 == 0;
      v74 = v73;
      v75 = v67 + (v71 >> 1) > v68 && !v74;
      v137 = v66;
      if (!v75)
        break;
LABEL_121:
      v66 = v137 + v71;
      LOWORD(v26) = v70 + 1;
      v3 = v154;
      v17 = v178;
      if ((unsigned __int16)(v70 + 1) > v27)
        goto LABEL_58;
    }
    v76 = 0;
    v169 = v71 >> 1;
    v171 = v72;
    v138 = v136 + v66 * v152;
    while (1)
    {
      v77 = v22;
      if (v25)
      {
        v78 = v178;
        v79 = v171;
        if (!v180)
          goto LABEL_93;
        v80 = (int)(v180 / 2 + v67 * v152) / v180;
      }
      else
      {
        v78 = v178;
        v79 = v171;
        if (!v28)
          goto LABEL_93;
        v80 = v138 / v28;
      }
      v77 = v80 + v22;
LABEL_93:
      v81 = v71;
      if (*(_WORD *)(*(_QWORD *)(v78 + 64) + 2 * v70) == 1)
      {
        if (v77 < 1)
        {
          v81 = v71;
          if ((v77 & 0x80000000) == 0)
            goto LABEL_98;
          v77 = -v77;
          v82 = v77 >> 1;
          v83 = v150;
        }
        else
        {
          v82 = 1000 * *(__int16 *)(*(_QWORD *)(v78 + 40) + 2 * v70);
          v83 = v77 >> 1;
        }
        v81 = (int)(v82 + v83) / v77;
      }
LABEL_98:
      if (v79 == (_DWORD)i)
        return 2164269065;
      if (v81 <= 0x10)
        v84 = 16;
      else
        v84 = v81;
      if (v84 >= 0x3C1)
        v85 = 961;
      else
        v85 = v84;
      v86 = v33;
      v87 = v78;
      v88 = v68;
      v89 = v70;
      v6 = v71;
      writeToPeriVec_0(v165, i, v70);
      writeToPeriVec_0(v163, i, v85);
      v90 = *(_QWORD *)(v87 + 64);
      v33 = v86;
      if (*(_WORD *)(v90 + 2 * v89))
        v91 = 0;
      else
        v91 = v76;
      writeToPeriVec_0(v161, i, v91);
      v71 = v6;
      v70 = v89;
      v25 = v173;
      v27 = v140 - 1;
      LODWORD(v6) = v167;
      v22 = v175;
      v76 = 1 - v76;
      v67 += v85;
      if (v173)
        v68 = v88;
      else
        v68 = v67;
      LODWORD(i) = i + 1;
      ++v86[1];
      v93 = (_DWORD)v70 == (unsigned __int16)(v140 - 1) && v67 == 0;
      if (v67 + v169 > v68 && !v93)
        goto LABEL_121;
    }
  }
LABEL_58:
  v62 = *(_WORD *)(v17 + 4) + *(_WORD *)(v17 + 2) + *(_WORD *)(v17 + 6);
  v33[2] = 0;
  if (v140 >= v62)
  {
LABEL_65:
    v2 = v148;
    v13 = v144;
    v9 = v146;
    LOWORD(v15) = v142;
    LOWORD(v14) = v156;
    v5 = v139;
    v36 = v158;
    goto LABEL_31;
  }
  v63 = v140;
  v64 = v62;
  if (i <= 0x2710)
    v65 = 10000;
  else
    v65 = i;
  while (v65 != (_DWORD)i)
  {
    writeToPeriVec_0((uint64_t)(v33 + 4), i, v63);
    writeToPeriVec_0((uint64_t)(v33 + 16), i, 0);
    writeToPeriVec_0((uint64_t)(v33 + 28), i, *(_WORD *)(*(_QWORD *)(v17 + 40) + 2 * v63));
    LODWORD(i) = i + 1;
    ++v33[2];
    if (v64 == ++v63)
    {
      v3 = v154;
      goto LABEL_65;
    }
  }
  return 2164269065;
}

uint64_t concat_initUnit(uint64_t a1, int a2, int a3, int a4)
{
  *(_DWORD *)(a1 + 21280) = a2;
  *(_DWORD *)(a1 + 21288) = a3;
  *(_DWORD *)(a1 + 21292) = a4;
  *(_DWORD *)(a1 + 21296) = 0;
  *(_BYTE *)(a1 + 21300) = 34;
  *(_DWORD *)(a1 + 21308) = 0;
  *(_DWORD *)(a1 + 21312) = 0;
  *(_DWORD *)(a1 + 21304) = a2 == -1;
  return 0;
}

uint64_t concat_Dur2Sample(unsigned int a1, int a2)
{
  return (int)(float)((float)((float)a1 / 1000.0) * (float)a2);
}

uint64_t Psola_OutputFinalSilence(uint64_t *a1, uint64_t a2)
{
  int v4;

  v4 = (int)((double)(*(_DWORD *)(a2 + 100)
                                  * *(_DWORD *)(*(_QWORD *)(a2 + 104) + 40 * *(int *)(a2 + 96) - 32))
           / 1000.0);
  if (v4 >= 1)
    Psola_SynthSilence_0(a1, *(int **)(a2 + 16), v4, (int *)a2);
  Psola_FlushOlaBufPart_1(a1, *(_DWORD **)(a2 + 16), *(_DWORD *)(*(_QWORD *)(a2 + 16) + 8) + **(_DWORD **)(a2 + 16));
  return 0;
}

_QWORD *Psola_Deinitialise(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;

  v4 = a2[2];
  if (v4)
    heap_Free(*(_QWORD **)(a1 + 8), v4);
  v5 = a2[3];
  if (v5)
    heap_Free(*(_QWORD **)(a1 + 8), v5);
  v6 = (uint64_t *)a2[4];
  if (v6)
  {
    if (*v6)
    {
      heap_Free(*(_QWORD **)(a1 + 8), *v6);
      v6 = (uint64_t *)a2[4];
    }
    if (v6[2])
    {
      heap_Free(*(_QWORD **)(a1 + 8), v6[2]);
      v6 = (uint64_t *)a2[4];
    }
    if (v6[4])
    {
      heap_Free(*(_QWORD **)(a1 + 8), v6[4]);
      v6 = (uint64_t *)a2[4];
    }
    heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)v6);
  }
  v7 = (uint64_t *)a2[8];
  if (v7)
    freeModPeriDesc(a1, v7);
  v8 = (uint64_t *)a2[9];
  if (v8)
    freeModPeriDesc(a1, v8);
  v9 = a2[13];
  if (v9)
  {
    heap_Free(*(_QWORD **)(a1 + 8), v9);
    a2[13] = 0;
  }
  return heap_Free(*(_QWORD **)(a1 + 8), (uint64_t)a2);
}

uint64_t Psola_ProcessX(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  v12 = 0;
  v5 = Psola_Initialise(&v12, *(_QWORD *)(a2 + 1928), *(_DWORD *)(*(_QWORD *)(a3 + 1072) + 8), *(_DWORD *)(*(_QWORD *)(a3 + 1072) + 25192), *(_DWORD *)(*(_QWORD *)(a3 + 1072) + 25196));
  v6 = v12;
  if ((v5 & 0x80000000) != 0)
  {
    v10 = v5;
    if (!v12)
      return v10;
  }
  else
  {
    *(_QWORD *)(v12 + 104) = *(_QWORD *)(a2 + 2656);
    v7 = a2 + 2248;
    while (1)
    {
      v8 = *(_DWORD *)(v6 + 96);
      if (v8 >= (int)mfs_SegmentList_Length(v7))
        break;
      v9 = Psola_Synthesis(a1, v6);
      if ((v9 & 0x80000000) != 0)
      {
        v10 = v9;
        goto LABEL_9;
      }
    }
    Psola_OutputFinalSilence((uint64_t *)a1, v6);
    v10 = 0;
    *(_BYTE *)(a1 + 21384) = 0;
    *(_DWORD *)(a1 + 21328) = 0;
  }
LABEL_9:
  Psola_Deinitialise(*(_QWORD *)a1, (_QWORD *)v6);
  return v10;
}

uint64_t concat_Sample2Dur(unsigned int a1, int a2)
{
  return (int)(float)((float)a2 / (float)((float)a1 / 1000.0));
}

float concat_Dur2SampleF32(float a1, float a2)
{
  return (float)(a1 / 1000.0) * a2;
}

float concat_Sample2DurF32(float a1, float a2)
{
  return a2 / (float)(a1 / 1000.0);
}

float mfs_Wsola__fade_out(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  unsigned int v4;
  float *v5;
  uint64_t v6;
  uint64_t v7;
  float result;

  if (a3)
  {
    v4 = *(_DWORD *)(a1 + 8);
    v5 = *(float **)(a2 + 16);
    v6 = a3;
    v7 = *(_QWORD *)(a4 + 16);
    do
    {
      result = *v5 * *(float *)(v7 + 4 * v4);
      *v5++ = result;
      v4 += 2;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t Wsola__write_audioX(uint64_t *a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(uint64_t, uint64_t, uint64_t);

  v8 = a4;
  v9 = heap_Calloc(*(_QWORD **)(*a1 + 8), a4, 2);
  if (v9)
  {
    v15 = v9;
    if (a4)
    {
      v16 = 0;
      do
      {
        *(_WORD *)(v9 + 2 * v16) = *(_WORD *)(a2 + 2 * (a3 + v16));
        ++v16;
      }
      while (v8 != v16);
      v17 = (void (*)(uint64_t, uint64_t, uint64_t))a1[4];
      if (v17)
        v17(a1[2], v9, v8);
    }
    heap_Free(*(_QWORD **)(*a1 + 8), v15);
    return 0;
  }
  else
  {
    log_wsola_Error(*a1, 59000, 0, v10, v11, v12, v13, v14);
    return 2164269066;
  }
}

uint64_t Wsola__write_audio(uint64_t *a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(uint64_t, uint64_t, uint64_t);

  if (*((_DWORD *)a1 + 5348) == 1)
    return 0;
  v8 = a4;
  v9 = heap_Calloc(*(_QWORD **)(*a1 + 8), a4, 2);
  if (v9)
  {
    v15 = v9;
    if (a4)
    {
      v16 = 0;
      v17 = *(_QWORD *)(a2 + 16);
      do
      {
        *(_WORD *)(v9 + 2 * v16) = (int)*(float *)(v17 + 4 * (a3 + v16));
        ++v16;
      }
      while (v8 != v16);
      v18 = (void (*)(uint64_t, uint64_t, uint64_t))a1[4];
      if (v18)
        v18(a1[2], v9, v8);
    }
    heap_Free(*(_QWORD **)(*a1 + 8), v15);
    return 0;
  }
  log_wsola_Error(*a1, 59000, 0, v10, v11, v12, v13, v14);
  return 2164269066;
}

uint64_t Wsola__silence_output(uint64_t *a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;

  if (!a2)
    return 0;
  v4 = Vector__Create(*(_QWORD **)(*a1 + 8), a2);
  v7 = v4;
  *(_DWORD *)(v4 + 8) = a2;
  *(_DWORD *)(v4 + 12) = a2;
  v5 = Wsola__write_audio(a1, v4, 0, a2);
  Window__Remove(&v7);
  return v5;
}

void Wsola__windowinit(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;

  v2 = *(unsigned int *)(a1 + 8);
  v3 = (float)v2;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_DWORD *)(a1 + 21192);
  if ((v5 - 1) >= 2)
  {
    if (!v5 && (_DWORD)v2)
    {
      v13 = 0;
      v14 = 1.0;
      v15 = 0.0;
      v16 = 1.0 / v3;
      do
      {
        *(float *)(v4 + 4 * v2 + v13) = v14;
        *(float *)(v4 + v13) = v15;
        v14 = v14 - v16;
        v15 = v16 + v15;
        v13 += 4;
      }
      while (4 * v2 != v13);
    }
  }
  else if ((_DWORD)v2)
  {
    v6 = 0;
    v7 = v3 + v3;
    v8 = v4 + 4 * v2;
    do
    {
      v9 = cos(((float)v6 + (float)v6) * 3.14159265 / v7);
      v10 = v9 * -0.5 + 0.5;
      *(float *)(v4 + 4 * v6) = v10;
      v11 = cos(((float)v2 + (float)v2) * 3.14159265 / v7);
      v12 = v11 * -0.5 + 0.5;
      *(float *)(v8 + 4 * v6++) = v12;
      --v2;
    }
    while (v2);
  }
}

uint64_t concat_initW(uint64_t a1, double a2)
{
  uint64_t v3;
  int v4;
  double v6;
  char v7;
  double v8;
  unint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;

  *(_DWORD *)(a1 + 80) = 0;
  v3 = a1 + 80;
  v4 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 21392) = 0;
  *(_DWORD *)(a1 + 21272) = *(_DWORD *)(a1 + 21320) != 0;
  if (v4 <= 15999)
  {
    if (v4 != 8000 && v4 != 8018)
    {
      if (v4 == 11025)
      {
        LODWORD(a2) = *(_DWORD *)(a1 + 21324);
        v6 = (double)*(unint64_t *)&a2;
        v7 = 2;
        v8 = 11.025;
        goto LABEL_13;
      }
LABEL_19:
      log_wsola_Diag(*(_QWORD *)a1, 1, (uint64_t)"ERROR: Unsupported sampling rate = %d\n");
      return 2164269063;
    }
    goto LABEL_11;
  }
  if (v4 == 16000)
  {
LABEL_11:
    HIDWORD(v9) = 1083129856;
    v6 = (float)v4 / 1000.0;
    LODWORD(v9) = *(_DWORD *)(a1 + 21324);
    v8 = (double)v9;
    v7 = 1;
    goto LABEL_13;
  }
  if (v4 != 22050)
  {
    if (v4 != 16036)
      goto LABEL_19;
    goto LABEL_11;
  }
  LODWORD(a2) = *(_DWORD *)(a1 + 21324);
  v6 = (double)*(unint64_t *)&a2;
  v7 = 4;
  v8 = 22.05;
LABEL_13:
  v10 = (int)(v6 * v8) & 0xFFFFFFFC;
  *(_BYTE *)(a1 + 104) = v7;
  *(_DWORD *)(a1 + 88) = v10;
  *(_DWORD *)(a1 + 92) = v10 >> 1;
  *(_DWORD *)(a1 + 96) = 2 * v10;
  *(_DWORD *)(a1 + 100) = 3 * v10;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 116) = 0;
  *(_QWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  if (!*(_QWORD *)(a1 + 128))
  {
    v11 = Vector__Create(*(_QWORD **)(*(_QWORD *)a1 + 8), 3 * v10);
    *(_QWORD *)(a1 + 128) = v11;
    if (!v11)
      return 2164269066;
  }
  v12 = *(_QWORD *)(a1 + 136);
  if (!v12)
  {
    v12 = Vector__Create(*(_QWORD **)(*(_QWORD *)a1 + 8), *(_DWORD *)(a1 + 96));
    *(_QWORD *)(a1 + 136) = v12;
    if (!v12)
      return 2164269066;
  }
  Wsola__windowinit(v3, v12);
  return 0;
}

uint64_t concat_deinitW(uint64_t a1)
{
  Window__Remove((uint64_t *)(a1 + 144));
  Window__Remove((uint64_t *)(a1 + 136));
  return 0;
}

uint64_t concat_final_deinitW(uint64_t *a1)
{
  Window__Remove(a1 + 18);
  Window__Remove(a1 + 17);
  Window__Remove(a1 + 16);
  return 0;
}

uint64_t concat_volume(uint64_t a1, int a2, int a3)
{
  double v3;
  uint64_t v5;
  float *v6;
  float v7;
  int v8;

  v3 = *(double *)(a1 + 21336);
  if (v3 != 1.0 && a3 >= 1)
  {
    v5 = a3;
    v6 = (float *)(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 16) + 4 * a2);
    do
    {
      v7 = v3 * *v6;
      *v6 = v7;
      v8 = -956301312;
      if (v7 < -32768.0 || (v8 = 1191181824, v7 > 32767.0))
        *(_DWORD *)v6 = v8;
      ++v6;
      --v5;
    }
    while (v5);
  }
  return 0;
}

uint64_t concat_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9, int a10, int a11)
{
  *(_QWORD *)a9 = a1;
  *(_QWORD *)(a9 + 8) = a2;
  *(_DWORD *)(a9 + 21320) = a11 != 0;
  *(_DWORD *)(a9 + 76) = a10;
  *(_QWORD *)(a9 + 32) = a5;
  *(_QWORD *)(a9 + 16) = a6;
  *(_QWORD *)(a9 + 48) = a7;
  *(_DWORD *)(a9 + 56) = a8;
  return 0;
}

uint64_t concat_startSynthesis(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  int v4;

  v2 = Wsola__newunit_0(a1, a1 + 21280);
  if ((v2 & 0x80000000) == 0)
  {
    v3 = *(_DWORD *)(a1 + 92);
    if (v3)
    {
      Wsola__write_audio((uint64_t *)a1, *(_QWORD *)(a1 + 144), *(_DWORD *)(a1 + 120), v3);
      v4 = *(_DWORD *)(a1 + 92);
    }
    else
    {
      v4 = 0;
    }
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 120) + v4;
    Wsola__middle_0(a1);
    Wsola__tail_0(a1);
    *(_DWORD *)(a1 + 21328) = 1;
  }
  return v2;
}

uint64_t Wsola__newunit_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  char v7;
  unsigned int v8;
  BOOL v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  void *__src;
  _QWORD v17[2];

  v4 = *(_DWORD *)(a2 + 8);
  v17[0] = 0;
  v17[1] = 0;
  v5 = *(_DWORD *)a2;
  if ((v5 & 0x80000000) == 0)
  {
    Lookup_GetUnitData(*(_QWORD **)(a1 + 24), v5, (uint64_t)v17);
    v4 = HIDWORD(v17[0]);
  }
  v6 = *(_DWORD *)(a2 + 12);
  *(_QWORD *)(a1 + 116) = v6;
  v7 = *(_BYTE *)(a2 + 20);
  if ((v7 & 2) != 0)
  {
    v8 = *(_DWORD *)(a1 + 88);
    v9 = v4 >= v8;
    v10 = v4 - v8;
    if (v4 < v8)
      v8 = v4;
    v6 += v8;
    if (v9)
      v4 = v10;
    else
      v4 = 0;
    *(_DWORD *)(a1 + 116) = v6;
    *(_DWORD *)(a1 + 120) = v8;
  }
  if ((v7 & 0x20) != 0)
  {
    v6 += *(_DWORD *)(a1 + 96);
    *(_DWORD *)(a1 + 116) = v6;
  }
  if (v6 > *(_DWORD *)(a1 + 108))
  {
    Window__Remove((uint64_t *)(a1 + 144));
    v11 = Vector__Create(*(_QWORD **)(*(_QWORD *)a1 + 8), *(_DWORD *)(a1 + 116));
    *(_QWORD *)(a1 + 144) = v11;
    if (!v11)
      return 2164269066;
    v6 = *(_DWORD *)(a1 + 116);
    *(_DWORD *)(a1 + 108) = v6;
  }
  v14 = 0;
  v15 = 0;
  __src = 0;
  if (*(_DWORD *)(a1 + 76))
    v12 = *(_DWORD *)(a2 + 24);
  else
    v12 = 0;
  result = concat_getSegment(a1, *(_DWORD *)a2, v4, v6, (uint64_t)&v14, v12);
  if ((result & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 116) = HIDWORD(v15);
    cstdlib_memset(*(void **)(*(_QWORD *)(a1 + 144) + 16), 0, 4 * *(unsigned int *)(*(_QWORD *)(a1 + 144) + 8));
    if (__src)
      cstdlib_memcpy(*(void **)(*(_QWORD *)(a1 + 144) + 16), __src, 4 * *(int *)(a1 + 116));
    concat_volume(a1, 0, *(_DWORD *)(a1 + 116));
    if (*(_DWORD *)(a1 + 21316) == 1)
      concat_applyBPF(*(_QWORD *)a1, *(char **)(*(_QWORD *)(a1 + 144) + 16), *(_DWORD *)(a1 + 116));
    if (__src)
      heap_Free(*(_QWORD **)(*(_QWORD *)a1 + 8), (uint64_t)__src);
    result = 0;
    *(_DWORD *)(a1 + 124) = *(_DWORD *)(a2 + 12) + *(_DWORD *)(a1 + 120);
    *(_DWORD *)(a1 + 112) = 0;
  }
  return result;
}

uint64_t Wsola__middle_0(uint64_t result)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;

  if ((*(_BYTE *)(result + 21300) & 0x20) != 0)
  {
    v1 = result;
    v2 = *(_DWORD *)(result + 124);
    v3 = *(_DWORD *)(result + 112);
    v4 = *(_DWORD *)(result + 92) + v3;
    v5 = v2 - v4;
    if (v2 - v4 >= 1)
    {
      result = Wsola__write_audio((uint64_t *)result, *(_QWORD *)(result + 144), v3, v2 - v4);
      *(_DWORD *)(v1 + 112) += v5;
    }
  }
  return result;
}

uint64_t Wsola__tail_0(uint64_t a1)
{
  int v1;
  uint64_t v2;
  unsigned int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  v1 = *(_DWORD *)(a1 + 92);
  v2 = *(int *)(a1 + 112);
  v3 = v1 + v2;
  v4 = *(_DWORD *)(a1 + 124);
  if ((int)v2 <= v4)
    v1 = v1 + v2 - v4;
  if (v3 <= v4)
    v5 = 0;
  else
    v5 = v1;
  v6 = *(int *)(a1 + 116) - v2;
  *(_DWORD *)(a1 + 21312) = v5;
  if (*(_DWORD *)(a1 + 21272))
    *(_DWORD *)(*(_QWORD *)(a1 + 128) + 12) = v6;
  v7 = *(unsigned int *)(a1 + 100);
  if ((int)v7 >= 1)
  {
    v8 = 0;
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 16);
    v10 = 4 * v2;
    do
    {
      v11 = 0;
      if (v8 < v6)
        v11 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 16) + v10 + 4 * v8);
      *(_DWORD *)(v9 + 4 * v8++) = v11;
    }
    while (v7 != v8);
  }
  return Lookup_DeInit(*(uint64_t **)(a1 + 24));
}

uint64_t concat_midSynthesis(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  float v10;
  float *v11;
  float *v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  float v26;
  float v27;
  float v28;
  double v29;
  unsigned int v30;
  unint64_t v31;
  float v32;
  double v33;
  float v34;
  unsigned int v35;
  uint64_t v36;
  float *v37;
  uint64_t v38;
  float v39;
  uint64_t v40;
  float v41;
  uint64_t v42;
  float v43;
  float v44;
  float v45;
  unsigned int v46;
  uint64_t v47;
  double v48;
  unsigned int v49;
  float v50;
  double v51;
  BOOL v52;
  BOOL v53;
  uint64_t v54;
  float *v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float *v60;
  unint64_t v61;
  unsigned int v62;
  int v63;
  unsigned int v64;
  float *v65;
  float *v66;
  float *v67;
  unint64_t v68;
  float v69;
  float v70;
  float v71;
  uint64_t v72;
  _DWORD *v73;
  uint64_t v74;
  uint64_t v75;
  float v76;
  uint64_t v77;
  float *v78;
  unsigned int v79;
  float v80;
  unsigned int v81;
  float v82;
  float v83;
  unsigned int v84;
  unsigned int v85;
  int v86;
  double v87;
  float *v88;
  float *v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float *v94;
  float *v95;
  unint64_t v96;
  float *v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float *v107;
  unsigned int v108;
  unsigned int v109;
  float v110;
  float v111;
  float v112;
  unsigned int v113;
  unsigned int v114;
  _DWORD *v115;
  uint64_t v116;
  float v117;
  float v118;
  float v119;
  float v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  float v125;
  float v126;
  unsigned int v127;
  int v128;
  int v129;
  unsigned int v130;
  BOOL v131;
  int v132;
  uint64_t v134;
  float *v135;
  int v136;
  int v137;
  unint64_t v138;
  uint64_t v139;
  unsigned int v140;
  float __dst[1];
  int v142;
  _DWORD v143[2640];
  uint64_t v144;

  v144 = *MEMORY[0x24BDAC8D0];
  v2 = Wsola__newunit_0(a1, a1 + 21280);
  v3 = v2;
  if ((v2 & 0x80000000) != 0)
    return v3;
  v4 = *(_DWORD *)(a1 + 21272);
  if ((v4 - 1) >= 2)
  {
    if (v4)
    {
      v30 = 0;
      v19 = *(_QWORD *)(a1 + 128);
      LODWORD(v31) = *(_DWORD *)(a1 + 88);
    }
    else
    {
      v19 = *(_QWORD *)(a1 + 128);
      v20 = *(_QWORD *)(a1 + 144);
      v21 = *(unsigned int *)(a1 + 96);
      if ((_DWORD)v21)
      {
        v22 = *(const void **)(v20 + 16);
        memcpy(__dst, *(const void **)(v19 + 16), 4 * v21);
        memcpy(v143, v22, 4 * v21);
      }
      v23 = *(_DWORD *)(a1 + 100);
      if (v21 < v23)
        memcpy(&v143[v21], (const void *)(*(_QWORD *)(v20 + 16) + 4 * v21), 4 * (v23 + ~(_DWORD)v21) + 4);
      v24 = *(unsigned __int8 *)(a1 + 104);
      if ((_DWORD)v21)
      {
        v25 = 0;
        v26 = 0.0;
        v27 = 0.0;
        do
        {
          v28 = *(float *)&v143[v25];
          v26 = v26 + (float)(v28 * v28);
          v27 = v27 + (float)(v28 * __dst[v25]);
          v25 += v24;
        }
        while (v25 < v21);
        v29 = v27;
      }
      else
      {
        v26 = 0.0;
        v29 = 0.0;
      }
      v105 = 250.0;
      if (v26 >= 250.0)
        v105 = v26;
      v106 = v29 / sqrt(v105);
      v31 = *(unsigned int *)(a1 + 88);
      if (v31 >= v24)
      {
        v30 = 0;
        v107 = (float *)v143;
        v108 = *(unsigned __int8 *)(a1 + 104);
        do
        {
          if ((_DWORD)v21)
          {
            v109 = 0;
            v110 = 0.0;
            do
            {
              v110 = v110 + (float)(v107[v24 + v109] * __dst[v109]);
              v109 += v24;
            }
            while (v109 < v21);
          }
          else
          {
            v110 = 0.0;
          }
          v26 = (float)(v26 - (float)(*v107 * *v107)) + (float)(v107[v21] * v107[v21]);
          v111 = 250.0;
          if (v26 >= 250.0)
            v111 = v26;
          v112 = v110 / sqrt(v111);
          if (v106 < v112)
          {
            v30 = v108;
            v106 = v112;
          }
          v108 += v24;
          v107 += v24;
        }
        while (v108 <= v31);
      }
      else
      {
        v30 = 0;
      }
      if ((_DWORD)v24 != 1)
      {
        v113 = (v30 - (v24 >> 1)) & ~((int)(v30 - (v24 >> 1)) >> 31);
        v114 = v30 + (v24 >> 1);
        if (v114 >= v31)
          v114 = *(_DWORD *)(a1 + 88);
        if (v113 <= v114)
        {
          v115 = &v143[v113];
          do
          {
            if ((_DWORD)v21)
            {
              v116 = 0;
              v117 = 0.0;
              v118 = 0.0;
              do
              {
                v119 = *(float *)&v115[v116];
                v117 = v117 + (float)(v119 * v119);
                v118 = v118 + (float)(v119 * __dst[v116++]);
              }
              while (v21 != v116);
            }
            else
            {
              v118 = 0.0;
              v117 = 0.0;
            }
            if (v117 < 250.0)
              v117 = 250.0;
            v120 = v118 / sqrt(v117);
            if (v106 < v120)
            {
              v30 = v113;
              v106 = v120;
            }
            ++v115;
            ++v113;
          }
          while (v113 <= v114);
        }
      }
      if ((_DWORD)v31)
      {
        v121 = 0;
        v122 = *(_QWORD *)(v19 + 16);
        v123 = *(_QWORD *)(v20 + 16) + 4 * v30;
        v124 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 16);
        do
        {
          v125 = (float)(*(float *)(v124 + v121) * *(float *)(v123 + v121))
               + (float)(*(float *)(v124 + 4 * v31 + v121) * *(float *)(v122 + v121));
          if (v125 >= 0.0)
            v126 = 0.5;
          else
            v126 = -0.5;
          *(float *)(v122 + v121) = v125 + v126;
          v121 += 4;
        }
        while (4 * v31 != v121);
      }
    }
    goto LABEL_154;
  }
  v140 = v2;
  v5 = *(_QWORD *)(a1 + 128);
  v6 = *(_QWORD *)(a1 + 144);
  v7 = *(unsigned int *)(a1 + 100);
  if ((_DWORD)v7)
    bzero((void *)(a1 + 152), 4 * v7);
  v8 = *(unsigned int *)(a1 + 96);
  if ((_DWORD)v8)
  {
    v9 = *(const void **)(v6 + 16);
    memcpy(__dst, *(const void **)(v5 + 16), 4 * v8);
    memcpy(v143, v9, 4 * v8);
  }
  if (v8 < v7)
    memcpy(&v143[v8], (const void *)(*(_QWORD *)(v6 + 16) + 4 * v8), 4 * (v7 + ~(_DWORD)v8) + 4);
  v10 = 0.0;
  if ((_DWORD)v8)
  {
    v11 = __dst;
    v12 = (float *)v143;
    v13 = v8;
    v14 = 0.0;
    do
    {
      v15 = *v12++;
      v16 = v15;
      v10 = v10 + (float)(v16 * v16);
      v17 = *v11++;
      v14 = v14 + (float)(v16 * v17);
      --v13;
    }
    while (v13);
    v18 = v14;
  }
  else
  {
    v18 = 0.0;
  }
  v32 = 250.0;
  if (v10 >= 250.0)
    v32 = v10;
  v33 = v18 / sqrt(v32);
  v34 = v33;
  *(float *)(a1 + 152) = v34;
  if (v4)
  {
    v35 = *(_DWORD *)(v5 + 12);
    if (v8 < v35)
      v35 = v8;
  }
  else
  {
    v35 = 0;
  }
  v31 = *(unsigned int *)(a1 + 88);
  if (!(_DWORD)v31)
  {
    v30 = 0;
    v39 = v33;
    goto LABEL_58;
  }
  v30 = 0;
  if ((v31 + 1) > 2)
    v36 = (v31 + 1);
  else
    v36 = 2;
  v37 = (float *)v143;
  v38 = 1;
  v39 = v33;
  do
  {
    if (v4)
    {
      if (!v35)
        goto LABEL_45;
      v40 = 0;
      v41 = 0.0;
      do
      {
        v41 = v41 + (float)(v37[v40 + 1] * __dst[v40]);
        ++v40;
      }
      while (v35 != v40);
    }
    else
    {
      if (!(_DWORD)v8)
      {
LABEL_45:
        v41 = 0.0;
        goto LABEL_46;
      }
      v42 = 0;
      v41 = 0.0;
      do
      {
        v41 = v41 + (float)(v37[v42 + 1] * __dst[v42]);
        ++v42;
      }
      while (v8 != v42);
    }
LABEL_46:
    v10 = (float)(v10 - (float)(*v37 * *v37)) + (float)(v37[v8] * v37[v8]);
    ++v37;
    v43 = 250.0;
    if (v10 >= 250.0)
      v43 = v10;
    v44 = v41 / sqrt(v43);
    *(float *)(a1 + 4 * v38 + 152) = v44;
    if (v39 < v44)
    {
      v30 = v38;
      v39 = v44;
    }
    ++v38;
  }
  while (v38 != v36);
  if (v31 >= 3
    && v30 > (int)v31 - 2
    && (v45 = *(float *)(a1 + 152 + 4 * v31), v45 >= *(float *)(a1 + 152 + 4 * (v31 - 1)))
    && v45 >= *(float *)(a1 + 4 * (v31 - 2) + 152))
  {
    if ((int)v31 >= 2)
      v46 = 2;
    else
      v46 = v31;
    if ((int)v31 >= 2)
      v136 = 2;
    else
      v136 = v31;
    v137 = 24;
    v138 = v31;
    while (v136 != (_DWORD)v138)
    {
      if (*(float *)(a1 + 152 + 4 * v138) < *(float *)(a1 + 4 * (v138 - 1) + 152))
      {
        LODWORD(v47) = 1;
        v46 = v138;
        goto LABEL_62;
      }
      --v138;
      LODWORD(v47) = 1;
      v137 -= 4;
      if (!v137)
      {
        v46 = v31 - 6;
        goto LABEL_62;
      }
    }
LABEL_61:
    LODWORD(v47) = 1;
  }
  else
  {
    if ((int)v30 > 1)
      goto LABEL_60;
LABEL_58:
    if (*(float *)(a1 + 156) > v34 || *(float *)(a1 + 160) > v34)
    {
LABEL_60:
      v46 = v31 - 1;
      goto LABEL_61;
    }
    v134 = 0;
    v46 = v31 - 1;
    v47 = ((_DWORD)v31 - 2) & ~(((int)v31 - 2) >> 31);
    v135 = (float *)(a1 + 156);
    while (v47 != v134)
    {
      if (*(v135 - 1) < *v135)
      {
        LODWORD(v47) = v134;
        break;
      }
      ++v134;
      ++v135;
      if (v134 == 6)
      {
        LODWORD(v47) = 6;
        break;
      }
    }
  }
LABEL_62:
  if (v47 <= v46)
  {
    v48 = -1.0;
    v49 = v30;
    do
    {
      if ((_DWORD)v47)
      {
        v50 = *(float *)(a1 + 152 + 4 * v47);
        if (v50 >= *(float *)(a1 + 152 + 4 * (v47 - 1)))
        {
          v52 = v50 < *(float *)(a1 + 4 * (v47 + 1) + 152);
          v51 = v50;
          v52 = !v52 && v48 < v51;
          if (v52)
          {
            v48 = v51;
            v49 = v47;
          }
        }
      }
      LODWORD(v47) = v47 + 1;
    }
    while (v47 <= v46);
    v53 = v48 <= 0.0 || v30 == v49;
    if (!v53 && v48 * 1.4 >= v39)
      v30 = v49;
  }
  if ((v31 + 1) > 1)
    v54 = (v31 + 1);
  else
    v54 = 1;
  v55 = (float *)(a1 + 152);
  v56 = 0.0;
  do
  {
    v57 = *v55++;
    v58 = v57;
    if (v56 < v57)
      v56 = v58;
    --v54;
  }
  while (v54);
  v59 = v56 * 1.2;
  *(float *)(a1 + 4 * v30 + 152) = v59;
  v60 = *(float **)(v5 + 16);
  v61 = v31 >> 1;
  v62 = -(v31 >> 2);
  v63 = (int)v31 >> 1;
  v64 = ((int)v31 >> 1) - (v31 >> 2);
  v139 = *(_QWORD *)(v6 + 16);
  if (v31 >= 2 && v63 >= (int)(v31 >> 2))
  {
    v65 = (float *)((char *)v60 + 4 * v63 - (v31 & 0xFFFFFFFC));
    v66 = (float *)(*(_QWORD *)(v6 + 16) + 4 * v30 + 4 * v63 - (v31 & 0xFFFFFFFC));
    v67 = (float *)v143;
    v68 = v31 >> 1;
    do
    {
      v69 = *v66++;
      v70 = v69;
      v71 = *v65++;
      *v67++ = (float)(v71 * v71) + (float)(v70 * v70);
      --v68;
    }
    while (v68);
    v72 = (v61 - 1);
    __dst[v72] = 1.0e31;
    if (v31 >= 6)
    {
      v73 = v143;
      v74 = 1;
      do
      {
        v75 = 0;
        v76 = 0.0;
        do
          v76 = v76 + *(float *)&v73[v75++];
        while (v75 != 3);
        __dst[v74++] = v76;
        ++v73;
      }
      while (v74 != v72);
      v77 = v72 - 1;
      v78 = (float *)&v142;
      v79 = 1 - (v31 >> 2);
      v80 = 1.0e31;
      v81 = -(v31 >> 2);
      do
      {
        v82 = *v78++;
        v83 = v82;
        if (v82 < v80)
        {
          v81 = v79;
          v80 = v83;
        }
        ++v79;
        --v77;
      }
      while (v77);
      if (v80 < 1.0e31)
        v62 = v81;
    }
  }
  if ((v64 & 0x80000000) == 0)
  {
    v84 = v62 + v64;
    if ((int)(v62 + v64) < 1)
    {
      v85 = 0;
    }
    else
    {
      bzero(v143, 4 * (v62 + v64));
      memset_pattern16(__dst, &unk_214FBF630, 4 * v84);
      v85 = v84;
    }
    if ((int)v85 < (int)v31)
    {
      bzero(&__dst[v85], 4 * (v31 - v85));
      memset_pattern16(&v143[v85], &unk_214FBF630, 4 * (v31 - v85));
    }
    if (v31 >= 2)
    {
      v86 = 0;
      v87 = (float)(int)v61 + (float)(int)v61;
      v88 = &__dst[v84];
      v89 = (float *)&v143[v84];
      do
      {
        v90 = cos(((float)v86 + (float)v86) * 3.14159265 / v87);
        v91 = v90 * -0.5 + 0.5;
        *v89++ = v91;
        v92 = cos(((float)(int)v61 + (float)(int)v61) * 3.14159265 / v87);
        v93 = v92 * -0.5 + 0.5;
        *v88++ = v93;
        ++v86;
        LODWORD(v61) = v61 - 1;
      }
      while ((_DWORD)v61);
    }
  }
  if ((_DWORD)v31)
  {
    v94 = (float *)v143;
    v95 = __dst;
    v96 = v31;
    v97 = (float *)(v139 + 4 * v30);
    do
    {
      v98 = *v95++;
      v99 = v98;
      v100 = *v94++;
      v101 = v100;
      v102 = *v97++;
      v103 = (float)(v101 * v102) + (float)(v99 * *v60);
      if (v103 >= 0.0)
        v104 = 0.5;
      else
        v104 = -0.5;
      *v60++ = v103 + v104;
      --v96;
    }
    while (v96);
  }
  v19 = v5;
  v3 = v140;
LABEL_154:
  Wsola__write_audio((uint64_t *)a1, v19, 0, v31);
  v127 = *(_DWORD *)(a1 + 92) - v30;
  v128 = *(_DWORD *)(a1 + 21292) + v127;
  *(_DWORD *)(a1 + 21292) = v128;
  *(_DWORD *)(a1 + 21296) = v127;
  if (v128 < 0)
    *(_DWORD *)(a1 + 21292) = 0;
  v129 = *(_DWORD *)(a1 + 124);
  v130 = *(_DWORD *)(a1 + 120) + v30;
  *(_DWORD *)(a1 + 112) = v130;
  v131 = __OFSUB__(v130, v129);
  v132 = v130 - v129;
  if ((v132 < 0) ^ v131 | (v132 == 0))
    v132 = 0;
  *(_DWORD *)(a1 + 21308) = v132;
  Wsola__middle_0(a1);
  Wsola__tail_0(a1);
  return v3;
}

uint64_t concat_endSynthesis(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = a1 + 21328;
  if (a2)
  {
    *(_BYTE *)(a1 + 21384) = 1;
    Wsola__write_audio((uint64_t *)a1, *(_QWORD *)(a1 + 128), 0, *(_DWORD *)(a1 + 92));
  }
  *(_BYTE *)(v3 + 56) = 0;
  *(_DWORD *)v3 = 0;
  Window__Remove((uint64_t *)(a1 + 128));
  return 0;
}

uint64_t Psola_AssignPeriRangesDyna(unsigned __int16 *a1)
{
  unsigned __int16 v1;
  uint64_t v2;
  uint64_t v4;
  __int16 *v5;
  __int16 v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v1 = a1[3];
  v2 = (unsigned __int16)(a1[2] + a1[1] + v1);
  if (a1[2] + a1[1] + v1)
  {
    v4 = 0;
    a1[1] = 0;
    v5 = (__int16 *)*((_QWORD *)a1 + 2);
    while (*v5 < 0)
    {
      a1[1] = ++v4;
      ++v5;
      if (v2 == v4)
      {
        a1[2] = 0;
LABEL_16:
        a1[3] = v2 - v4;
        return 0;
      }
    }
    a1[2] = 0;
    if (v4 >= v2)
      goto LABEL_16;
    v6 = 0;
    v7 = v2 - v4;
    v8 = *a1;
    do
    {
      v9 = *v5++;
      if (v9 >= v8)
        break;
      a1[2] = ++v6;
      --v7;
    }
    while (v7);
    a1[3] = v2 - (v4 + v6);
    if (!(_WORD)v4 && v6)
    {
      a1[1] = 1;
      if (v6 == 1)
      {
        v10 = (v2 - 1);
        if ((_DWORD)v2 != 1)
        {
          do
          {
            writeToPeriVec_0((uint64_t)(a1 + 4), v2, *(_WORD *)(*((_QWORD *)a1 + 2) + 2 * v10));
            writeToPeriVec_0((uint64_t)(a1 + 16), v2, *(_WORD *)(*((_QWORD *)a1 + 5) + 2 * v10));
            writeToPeriVec_0((uint64_t)(a1 + 28), v2, *(_WORD *)(*((_QWORD *)a1 + 8) + 2 * v10));
            LODWORD(v2) = v2 - 1;
            --v10;
          }
          while ((_DWORD)v10);
        }
        writeToPeriVec_0((uint64_t)(a1 + 16), 1u, **((__int16 **)a1 + 5) / 2);
        writeToPeriVec_0((uint64_t)(a1 + 16), 0, **((_WORD **)a1 + 5) - *(_WORD *)(*((_QWORD *)a1 + 5) + 2));
        writeToPeriVec_0((uint64_t)(a1 + 4), 1u, **((_WORD **)a1 + 5) + **((_WORD **)a1 + 2));
        v11 = (uint64_t)(a1 + 28);
        writeToPeriVec_0(v11, 0, 0);
        writeToPeriVec_0(v11, 1u, 0);
      }
      else
      {
        a1[2] = v6 - 1;
      }
    }
  }
  return 0;
}

_QWORD *newPeriDescDyna(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = (_QWORD *)heap_Alloc(*(_QWORD *)(a1 + 8), 80);
  v3 = v2;
  if (v2)
  {
    cstdlib_memset(v2, 0, 0x50uLL);
    v4 = heap_Alloc(*(_QWORD *)(a1 + 8), 300);
    v3[2] = v4;
    if (v4)
    {
      *((_DWORD *)v3 + 6) = 150;
      v3[1] = a1;
      v5 = heap_Alloc(*(_QWORD *)(a1 + 8), 300);
      v3[5] = v5;
      if (v5)
      {
        *((_DWORD *)v3 + 12) = 150;
        v3[4] = a1;
        v6 = heap_Alloc(*(_QWORD *)(a1 + 8), 300);
        v3[8] = v6;
        if (v6)
        {
          *((_DWORD *)v3 + 18) = 150;
          v3[7] = a1;
          return v3;
        }
      }
      v7 = v3[2];
      if (v7)
        heap_Free(*(_QWORD **)(a1 + 8), v7);
    }
    v8 = v3[5];
    if (v8)
      heap_Free(*(_QWORD **)(a1 + 8), v8);
    v9 = v3[8];
    if (v9)
      heap_Free(*(_QWORD **)(a1 + 8), v9);
    return 0;
  }
  return v3;
}

void Psola_AddToOlaBuf_1(uint64_t *a1, int *a2, uint64_t a3, int a4, int a5)
{
  int v5;
  int v6;
  int v10;
  int v11;
  BOOL v12;
  _BYTE v13[2];

  if (*a2 <= a5)
  {
    v5 = a5;
    v6 = a4;
    if (a4 < 1)
    {
      Psola_AddToOlaBufAux_1(a1, a2, (uint64_t)v13, 0, 0, a5);
    }
    else
    {
      v10 = 0;
      do
      {
        if (v6 >= 2400)
          v11 = 2400;
        else
          v11 = v6;
        Psola_AddToOlaBufAux_1(a1, a2, a3, v10, v11, v5);
        v10 += v11;
        v5 += v11;
        v12 = __OFSUB__(v6, v11);
        v6 -= v11;
      }
      while (!((v6 < 0) ^ v12 | (v6 == 0)));
    }
  }
}

void Psola_AddToOlaBufAux_1(uint64_t *a1, int *a2, uint64_t a3, int a4, int a5, int a6)
{
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  _WORD *v17;
  __int16 *v18;
  int v19;
  __int16 v20;
  int v21;
  _WORD *v22;
  __int16 *v23;
  __int16 v24;
  int v25;

  v11 = a6 + a5;
  v12 = a6 + a5 - 2400;
  v13 = *a2;
  if (v12 > *a2)
  {
    Psola_FlushOlaBufPart_1(a1, a2, v12);
    v13 = *a2;
  }
  v14 = (a6 - v13 + a2[1]) % 2400;
  if (2400 - v14 >= a5)
    v15 = a5;
  else
    v15 = 2400 - v14;
  v16 = a5 - v15;
  if (v15 >= 1)
  {
    v17 = (_WORD *)a2 + v14 + 6;
    v18 = (__int16 *)(a3 + 2 * a4);
    v19 = v15;
    do
    {
      v20 = *v18++;
      *v17++ += v20;
      --v19;
    }
    while (v19);
  }
  if (v16 >= 1)
  {
    v21 = v15 + a4;
    v22 = a2 + 3;
    v23 = (__int16 *)(a3 + 2 * v21);
    do
    {
      v24 = *v23++;
      *v22++ += v24;
      --v16;
    }
    while (v16);
  }
  v25 = v11 - v13;
  if (a2[2] > v25)
    v25 = a2[2];
  a2[2] = v25;
}

__int16 *Psola_ApplyHanning_1(__int16 *result, int *a2, __int16 *a3, int a4, int a5)
{
  uint64_t v5;
  _WORD *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;

  if (a4)
  {
    if (*a2 != a4)
    {
      if (a4 >= 1)
      {
        v5 = 0;
        v6 = result;
        do
        {
          *v6++ = HanningTab_1[(int)v5 / a4]
                + (HanningTab_1[(int)v5 / a4 + 1] - HanningTab_1[(int)v5 / a4]) * ((int)v5 % a4) / a4;
          v5 += 200;
        }
        while (200 * a4 != v5);
      }
      *a2 = a4;
    }
    if (a5)
    {
      if (a4 >= 1)
      {
        v7 = a4;
        do
        {
          v8 = *result++;
          *a3 = v8 * *a3 / 0x8000;
          ++a3;
          --v7;
        }
        while (v7);
      }
    }
    else if (a4 >= 1)
    {
      v9 = a4;
      do
      {
        v10 = *result++;
        *a3 = (0x7FFF - v10) * *a3 / 0x8000;
        ++a3;
        --v9;
      }
      while (v9);
    }
  }
  return result;
}

uint64_t synth_bet4_GetInterface(unsigned int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1 > 1)
    return 2164269057;
  result = 0;
  *a2 = &ISynth_Bet4;
  return result;
}

uint64_t synth_bet4_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  if (!a3)
    return 2164269063;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(_QWORD *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 9357;
  }
  return result;
}

uint64_t synth_bet4_ClassClose()
{
  return 0;
}

uint64_t synth_bet4_ObjOpen(uint64_t a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t Object;
  uint64_t inited;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t Int;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  unsigned int v49;
  __int128 v50;
  uint64_t (*v51)(uint64_t, char *, const char *);
  char *__s1;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;

  Object = 2164269066;
  v55 = 0;
  v54 = 0;
  v53 = 0;
  __s1 = 0;
  v50 = xmmword_24D29C6C0;
  v51 = synth_bet4_loc_ParamLearnChange;
  if (!a5)
    return 2164269063;
  inited = InitRsrcFunction(a3, a4, &v55);
  if ((inited & 0x80000000) != 0)
    return inited;
  if ((safeh_HandleCheck(a1, a2, 9357, 408) & 0x80000000) == 0)
  {
    *(_QWORD *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    log_OutText(*(_QWORD *)(v55 + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"Entering synth_bet4_ObjOpen", v12, v13, v14, v47);
    v15 = (_QWORD *)heap_Calloc(*(_QWORD **)(v55 + 8), 1, 22680);
    if (v15)
    {
      v20 = (uint64_t)v15;
      *v15 = a3;
      v15[1] = a4;
      v21 = v55;
      v15[2] = v55;
      v15[3] = a1;
      v15[15] = 0;
      Int = critsec_ObjOpen(*(_QWORD *)(v21 + 16), *(_QWORD **)(v21 + 8), v15 + 4);
      if ((Int & 0x80000000) != 0)
        goto LABEL_31;
      Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 40), (uint64_t)"rate_baseline", &v53);
      if ((Int & 0x80000000) != 0)
        goto LABEL_31;
      Int = synth_bet4_loc_ParamSet(v20, "rate_baseline", v53);
      if ((Int & 0x80000000) != 0)
        goto LABEL_31;
      Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 40), (uint64_t)"rate", &v53);
      if ((Int & 0x80000000) != 0)
        goto LABEL_31;
      Int = synth_bet4_loc_ParamSet(v20, "rate", v53);
      if ((Int & 0x80000000) != 0)
        goto LABEL_31;
      Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 40), (uint64_t)"pitch_baseline", &v53);
      if ((Int & 0x80000000) != 0)
        goto LABEL_31;
      Int = synth_bet4_loc_ParamSet(v20, "pitch_baseline", v53);
      if ((Int & 0x80000000) != 0)
        goto LABEL_31;
      Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 40), (uint64_t)"pitch", &v53);
      if ((Int & 0x80000000) != 0)
        goto LABEL_31;
      Int = synth_bet4_loc_ParamSet(v20, "pitch", v53);
      if ((Int & 0x80000000) != 0)
        goto LABEL_31;
      *(_QWORD *)&v50 = v20;
      Int = synth_bet4_loc_ParamGetListen(v20, "volume", 0, 100, 0x50u, &v50, &v53);
      if ((Int & 0x80000000) != 0)
        goto LABEL_31;
      Int = synth_bet4_loc_ParamGetListen(v20, "rate_baseline", 50, 400, 0x64u, &v50, &v53);
      if ((Int & 0x80000000) != 0
        || (Int = synth_bet4_loc_ParamGetListen(v20, "rate", 50, 400, 0x64u, &v50, &v53), (Int & 0x80000000) != 0)
        || (Int = synth_bet4_loc_ParamGetListen(v20, "waitfactor", 0, 9, 2u, &v50, &v53), (Int & 0x80000000) != 0)
        || (Int = synth_bet4_loc_ParamGetListen(v20, "pitch_baseline", 50, 200, 0x64u, &v50, &v53),
            (Int & 0x80000000) != 0)
        || (Int = synth_bet4_loc_ParamGetListen(v20, "pitch", 50, 200, 0x64u, &v50, &v53), (Int & 0x80000000) != 0)
        || (Int = synth_bet4_loc_ParamGetListen(v20, "audiooutputbufsamples", 1, 0x7FFFFFFF, 0x100u, &v50, &v53),
            (Int & 0x80000000) != 0)
        || (*(_DWORD *)(v20 + 72) = v53, Int = synth_bet4_loc_SynthInit(v20), (Int & 0x80000000) != 0))
      {
LABEL_31:
        Object = Int;
      }
      else
      {
        v23 = mfs_WSOLA__Create(*(_QWORD *)(v20 + 16), *(_WORD *)(v20 + 84));
        *(_QWORD *)(v20 + 21496) = v23;
        if (v23)
        {
          v28 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(v20 + 16) + 8), (*(_DWORD *)(v20 + 84) << 7) / 0x3E8uLL, 2);
          *(_QWORD *)(v20 + 21472) = v28;
          v29 = v55;
          if (v28)
          {
            Object = objc_GetObject(*(_QWORD *)(v55 + 48), (uint64_t)"SYNTHSTREAM", &v54);
            if ((Object & 0x80000000) == 0)
            {
              *(_QWORD *)(v20 + 40) = *(_QWORD *)(v54 + 8);
              if ((objc_GetObject(*(_QWORD *)(v55 + 48), (uint64_t)"AUDIOFETCHER", &v54) & 0x80000000) != 0)
              {
                v46 = *(_QWORD *)(v20 + 16);
              }
              else
              {
                v34 = v54;
                if (*(_BYTE *)v54 == 1)
                {
                  v35 = *(_QWORD *)(v54 + 8);
                  if (v35)
                  {
                    *(_QWORD *)(v20 + 48) = v35;
                    *(_OWORD *)(v20 + 56) = *(_OWORD *)(v34 + 16);
LABEL_44:
                    if (!Lookup_HasSupportForPsola(*(_QWORD *)(v20 + 120), (_DWORD *)(v20 + 22640), (_DWORD *)(v20 + 22644)))*(_QWORD *)(v20 + 22640) = 0;
                    if (!Lookup_HasSupportForWsola(*(_QWORD *)(v20 + 120), (_DWORD *)(v20 + 21420)))
                      *(_DWORD *)(v20 + 21420) = 0;
                    *(_DWORD *)(v20 + 22672) = 0;
                    if ((paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 40), (uint64_t)"bet4suppressbet3pcm", &__s1) & 0x80000000) == 0)
                    {
                      if (!cstdlib_strcmp(__s1, "yes"))
                        *(_DWORD *)(v20 + 22672) = 1;
                      paramc_ParamRelease(*(_QWORD *)(*(_QWORD *)(v20 + 16) + 40));
                    }
                    *(_QWORD *)a5 = v20;
                    *(_DWORD *)(a5 + 8) = 9356;
                    goto LABEL_35;
                  }
                }
                objc_ReleaseObject(*(_QWORD *)(v55 + 48), (uint64_t)"AUDIOFETCHER");
                v46 = v55;
              }
              log_OutPublic(*(_QWORD *)(v46 + 32), (uint64_t)"SYNTH_BET4", 59001, 0, v30, v31, v32, v33, v48);
              goto LABEL_44;
            }
            v29 = *(_QWORD *)(v20 + 16);
            v45 = 59001;
          }
          else
          {
            v45 = 59000;
          }
        }
        else
        {
          v45 = 59000;
          v29 = v55;
        }
        log_OutPublic(*(_QWORD *)(v29 + 32), (uint64_t)"SYNTH_BET4", v45, 0, v24, v25, v26, v27, v48);
      }
      *(_QWORD *)a5 = v20;
      *(_DWORD *)(a5 + 8) = 9356;
      synth_bet4_ObjClose((_QWORD *)v20, *(_QWORD *)(a5 + 8));
      *(_QWORD *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
    }
    else
    {
      log_OutPublic(*(_QWORD *)(v55 + 32), (uint64_t)"SYNTH_BET4", 59000, 0, v16, v17, v18, v19, v48);
    }
LABEL_35:
    log_OutText(*(_QWORD *)(v55 + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"synth_bet4_ObjOpen: %x", v36, v37, v38, Object);
    log_OutEvent(*(uint64_t ***)(v55 + 32), 24, (uint64_t)"", v39, v40, v41, v42, v43, v49);
    return Object;
  }
  return 2164269064;
}

uint64_t synth_bet4_ObjClose(_QWORD *a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  int v16;
  uint64_t v17;
  int v19;
  uint64_t v20;
  int v22;
  uint64_t v23;
  int v25;
  uint64_t v26;
  int v28;
  uint64_t v30;
  int v31;
  int v33;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v43;
  _QWORD *v44;
  __int128 v45;

  v3 = safeh_HandleCheck((uint64_t)a1, a2, 9356, 22680);
  if (v3 < 0)
    return 2164269064;
  v7 = v3;
  v8 = a1[2];
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"Entering synth_bet4_ObjClose", v4, v5, v6, v43);
  v9 = *(_QWORD *)(v8 + 40);
  v44 = a1;
  v45 = *(__int128 *)((char *)&xmmword_24D29C6C0 + 8);
  v10 = paramc_ListenerRemove(v9, "volume", (__int128 *)&v44);
  v11 = *(_QWORD *)(v8 + 40);
  if (v10 >= 0)
    v12 = v7;
  else
    v12 = v10;
  v44 = a1;
  v45 = *(__int128 *)((char *)&xmmword_24D29C6C0 + 8);
  v13 = paramc_ListenerRemove(v11, "rate", (__int128 *)&v44);
  v14 = *(_QWORD *)(v8 + 40);
  if (v13 < 0 && v12 > -1)
    v12 = v13;
  v44 = a1;
  v45 = *(__int128 *)((char *)&xmmword_24D29C6C0 + 8);
  v16 = paramc_ListenerRemove(v14, "rate_baseline", (__int128 *)&v44);
  v17 = *(_QWORD *)(v8 + 40);
  if (v16 < 0 && v12 > -1)
    v12 = v16;
  v44 = a1;
  v45 = *(__int128 *)((char *)&xmmword_24D29C6C0 + 8);
  v19 = paramc_ListenerRemove(v17, "waitfactor", (__int128 *)&v44);
  v20 = *(_QWORD *)(v8 + 40);
  if (v19 < 0 && v12 > -1)
    v12 = v19;
  v44 = a1;
  v45 = *(__int128 *)((char *)&xmmword_24D29C6C0 + 8);
  v22 = paramc_ListenerRemove(v20, "pitch", (__int128 *)&v44);
  v23 = *(_QWORD *)(v8 + 40);
  if (v22 < 0 && v12 > -1)
    v12 = v22;
  v44 = a1;
  v45 = *(__int128 *)((char *)&xmmword_24D29C6C0 + 8);
  v25 = paramc_ListenerRemove(v23, "pitch_baseline", (__int128 *)&v44);
  v26 = *(_QWORD *)(v8 + 40);
  if (v25 < 0 && v12 > -1)
    v12 = v25;
  v44 = a1;
  v45 = *(__int128 *)((char *)&xmmword_24D29C6C0 + 8);
  v28 = paramc_ListenerRemove(v26, "audiooutputbufsamples", (__int128 *)&v44);
  if (v28 >= 0 || v12 <= -1)
    v30 = v12;
  else
    v30 = v28;
  if (a1[5])
  {
    v31 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
    if ((int)v30 > -1 && v31 < 0)
      v30 = v31;
    else
      v30 = v30;
  }
  if (a1[6])
  {
    v33 = objc_ReleaseObject(*(_QWORD *)(v8 + 48), (uint64_t)"AUDIOFETCHER");
    if (v33 >= 0 || (int)v30 <= -1)
      v30 = v30;
    else
      v30 = v33;
  }
  if (a1[15])
  {
    v30 = Lookup_ObjClose(a1 + 15);
    a1[15] = 0;
  }
  if (a1[2687])
    mfs_WSOLA__Remove(a1 + 2687);
  v35 = a1[2684];
  if (v35)
    heap_Free(*(_QWORD **)(a1[2] + 8), v35);
  v36 = a1[4];
  if (v36)
  {
    v37 = critsec_ObjClose(v36);
    if ((int)v30 > -1 && v37 < 0)
      v30 = v37;
    else
      v30 = v30;
  }
  heap_Free(*(_QWORD **)(v8 + 8), (uint64_t)a1);
  log_OutText(*(_QWORD *)(v8 + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"synth_bet4_ObjClose: %x", v39, v40, v41, v30);
  return v30;
}

uint64_t synth_bet4_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;

  if ((safeh_HandleCheck(a1, a2, 9356, 22680) & 0x80000000) != 0)
    return 2164269064;
  v6 = *(_QWORD *)(a1 + 16);
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"Entering synth_bet4_ObjReopen", v3, v4, v5, v16);
  v10 = synth_bet4_loc_SynthInit(a1);
  if ((v10 & 0x80000000) == 0)
  {
    if (!Lookup_HasSupportForPsola(*(_QWORD *)(a1 + 120), (_DWORD *)(a1 + 22640), (_DWORD *)(a1 + 22644)))
      *(_QWORD *)(a1 + 22640) = 0;
    if (!Lookup_HasSupportForWsola(*(_QWORD *)(a1 + 120), (_DWORD *)(a1 + 21420)))
      *(_DWORD *)(a1 + 21420) = 0;
  }
  v11 = *(unsigned __int16 **)(a1 + 21496);
  if (v11 && *(_DWORD *)(a1 + 84) != *v11)
  {
    log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"synth_bet4_ObjReopen: Changing speaking rate", v7, v8, v9, v17);
    mfs_WSOLA__Remove((uint64_t *)(a1 + 21496));
    v12 = mfs_WSOLA__Create(*(_QWORD *)(a1 + 16), *(_WORD *)(a1 + 84));
    *(_QWORD *)(a1 + 21496) = v12;
    if (v12)
      v13 = v10;
    else
      v13 = 2164269066;
    if ((v13 & 0x80000000) != 0)
    {
      v10 = v13;
    }
    else
    {
      v14 = heap_Realloc(*(uint64_t **)(*(_QWORD *)(a1 + 16) + 8), *(_QWORD *)(a1 + 21472), ((*(_DWORD *)(a1 + 84) << 7) / 0x1F4u) & 0xFFFFFE);
      if (v14)
        *(_QWORD *)(a1 + 21472) = v14;
      else
        v10 = 2164269066;
    }
  }
  log_OutText(*(_QWORD *)(v6 + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"synth_bet4_ObjReopen: %x", v7, v8, v9, v10);
  return v10;
}

uint64_t synth_bet4_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;

  if ((safeh_HandleCheck(a1, a2, 9356, 22680) & 0x80000000) != 0)
    return 2164269064;
  synstrmaux_InitStreamOpener(a1 + 21552, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4");
  *(_BYTE *)(a1 + 21480) = 0;
  *(_DWORD *)(a1 + 22636) = 0;
  *(_OWORD *)(a1 + 22616) = 0u;
  *(_OWORD *)(a1 + 22656) = 0u;
  if (synstrmaux_BuildAudioContentType("audio/L16;rate=", *(_DWORD *)(a1 + 84), (char *)(a1 + 21504), 0x30uLL) > 0x2F)
    return 9;
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-bandpass-filter;version=4.0",
    0,
    a1 + 22456);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-psola-f0begin;version=4.0",
    0,
    a1 + 22472);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-psola-f0end;version=4.0",
    0,
    a1 + 22488);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-psola-duration;version=4.0",
    0,
    a1 + 22504);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-psola-maxfade-l;version=4.0",
    0,
    a1 + 22520);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-psola-maxfade-r;version=4.0",
    0,
    a1 + 22536);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-psola-adjacent-l;version=4.0",
    0,
    a1 + 22552);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-psola-adjacent-r;version=4.0",
    0,
    a1 + 22568);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), a1 + 21504, 0, a1 + 22376);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
    0,
    a1 + 22392);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-usids;version=4.0",
    0,
    a1 + 22408);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-usoffsets;version=5.0",
    0,
    a1 + 22424);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-usdurs-32;version=5.0",
    0,
    a1 + 22440);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 21552), a1 + 21504, a1 + 22584);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 21552), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
    a1 + 22600);
  v8 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 21552), *(_QWORD *)(a1 + 40), a3, a4);
  if ((v8 & 0x80000000) != 0)
    synth_bet4_ProcessEnd(a1, a2);
  return v8;
}

uint64_t synth_bet4_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t **v46;
  uint64_t *v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  int v68;
  unsigned int v69;
  int v70;
  int v71;
  double v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  __n128 v76;
  uint64_t v77;
  unint64_t v78;
  _DWORD *v79;
  uint64_t v80;
  _DWORD *v81;
  _DWORD *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char *v87;
  __int128 v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  char *v96;
  char *v97;
  _DWORD *v98;
  unsigned int v99;
  unsigned int v100;
  unsigned int v101;
  double v102;
  char *v103;
  int v104;
  uint64_t v105;
  unsigned int v106;
  const char *v107;
  char *v108;
  int *v109;
  BOOL v110;
  int v112;
  int *v113;
  int v114;
  int v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  unsigned int v127;
  unsigned int v128;
  unsigned int v129;
  unsigned int v130;
  char *v131;
  unsigned int *v132;
  int v133;
  unsigned int v134;
  unsigned int v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unsigned int v141;
  int v142;
  _QWORD *v143;
  unsigned int v144;
  char *v145;
  unsigned int *v146;
  int v147;
  unsigned int v148;
  unsigned int v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  unsigned __int16 v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  __int128 v163;
  uint64_t v164;
  char *v165;
  __int128 v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  int v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  int v181;
  int v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  int v188;
  int v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  int v194;
  int v195;
  int v196;
  int v197;
  int v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  int v204;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  _BYTE *v210;
  size_t v211;
  unsigned int v212;
  _DWORD *v213;
  unsigned int *v214;
  uint64_t v215;
  int *v216;
  unsigned int *v217;
  unint64_t v218;
  _DWORD *v219;
  _DWORD *v220;
  uint64_t *v221;
  _DWORD *v222;
  __int128 v223;
  __int128 v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  int v228;
  unsigned int v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  _DWORD *v239;
  char *v240;
  char *v241;
  uint64_t v242;
  int v243;
  uint64_t v244;
  uint64_t v245;
  unsigned int v246[4];

  v245 = 0;
  *(_QWORD *)v246 = 0;
  v244 = 0;
  v243 = 0;
  v241 = 0;
  v242 = 0;
  v239 = 0;
  v240 = 0;
  v237 = 0;
  v238 = 0;
  v235 = 0;
  v236 = 0;
  v233 = 0;
  v234 = 0;
  v231 = 0;
  v232 = 0;
  v230 = 0;
  v7 = safeh_HandleCheck(a1, a2, 9356, 22680);
  if ((v7 & 0x80000000) != 0)
    return 2164269064;
  *a5 = 1;
  if (!*(_QWORD *)(a1 + 48))
    return v7;
  v229 = 0;
  v228 = 0;
  v226 = 0;
  v227 = 0;
  v225 = 0;
  v8 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)(a1 + 40) + 80))(*(_QWORD *)(a1 + 22456), *(_QWORD *)(a1 + 22464), a1 + 21412, 4, &v225);
  if ((v8 & 0x80000000) != 0)
  {
    v23 = v8;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_64:
    log_OutPublic(v63, (uint64_t)"SYNTH_BET4", 59005, (uint64_t)"%s%s%s%x", v9, v10, v11, v12, "contentType");
    return v23;
  }
  v13 = v225;
  v14 = (*(uint64_t (**)(_QWORD, _QWORD, unsigned int *, int *))(*(_QWORD *)(a1 + 40) + 144))(*(_QWORD *)(a1 + 22408), *(_QWORD *)(a1 + 22416), v246, &v243);
  if ((v14 & 0x80000000) != 0)
  {
    v23 = v14;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59004, (uint64_t)"%s%x", v15, v16, v17, v18, "lhError");
    return v23;
  }
  v23 = (*(uint64_t (**)(_QWORD, _QWORD, unsigned int *, uint64_t *))(*(_QWORD *)(a1 + 40) + 144))(*(_QWORD *)(a1 + 22392), *(_QWORD *)(a1 + 22400), &v246[1], &v244);
  if ((v23 & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59004, (uint64_t)"%s%x", v19, v20, v21, v22, "lhError");
    return v23;
  }
  if (!v246[1])
  {
    if (!v243 || !(_DWORD)v244)
      goto LABEL_75;
    return synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 21552), *(_QWORD *)(a1 + 40));
  }
  v24 = (*(uint64_t (**)(_QWORD, _QWORD, _DWORD **, unsigned int *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22408), *(_QWORD *)(a1 + 22416), &v239, v246);
  if ((v24 & 0x80000000) != 0)
  {
    v23 = v24;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v25 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, uint64_t *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22424), *(_QWORD *)(a1 + 22432), &v238, &v245);
  if ((v25 & 0x80000000) != 0)
  {
    v23 = v25;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v26 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, char *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22440), *(_QWORD *)(a1 + 22448), &v237, (char *)&v244 + 4);
  if ((v26 & 0x80000000) != 0)
  {
    v23 = v26;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v27 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, unsigned int *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22472), *(_QWORD *)(a1 + 22480), &v236, &v229);
  if ((v27 & 0x80000000) != 0)
  {
    v23 = v27;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v28 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, int *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22488), *(_QWORD *)(a1 + 22496), &v235, &v228);
  if ((v28 & 0x80000000) != 0)
  {
    v23 = v28;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v29 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, char *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22504), *(_QWORD *)(a1 + 22512), &v234, (char *)&v227 + 4);
  if ((v29 & 0x80000000) != 0)
  {
    v23 = v29;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v30 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, uint64_t *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22520), *(_QWORD *)(a1 + 22528), &v233, &v227);
  if ((v30 & 0x80000000) != 0)
  {
    v23 = v30;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v31 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, char *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22536), *(_QWORD *)(a1 + 22544), &v232, (char *)&v226 + 4);
  if ((v31 & 0x80000000) != 0)
  {
    v23 = v31;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v32 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, uint64_t *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22552), *(_QWORD *)(a1 + 22560), &v231, &v226);
  if ((v32 & 0x80000000) != 0)
  {
    v23 = v32;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v33 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, char *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22568), *(_QWORD *)(a1 + 22576), &v230, (char *)&v225 + 4);
  if ((v33 & 0x80000000) != 0)
  {
    v23 = v33;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v34 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, char *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22376), *(_QWORD *)(a1 + 22384), &v242, (char *)&v245 + 4);
  if ((v34 & 0x80000000) != 0)
  {
    v23 = v34;
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  v23 = (*(uint64_t (**)(_QWORD, _QWORD, char **, unsigned int *))(*(_QWORD *)(a1 + 40) + 88))(*(_QWORD *)(a1 + 22392), *(_QWORD *)(a1 + 22400), &v241, &v246[1]);
  if ((v23 & 0x80000000) != 0)
  {
    v63 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_64;
  }
  if (!*(_DWORD *)(a1 + 22672))
  {
    v65 = v246[0];
    v66 = v245;
    if (HIDWORD(v244) < v245)
      v66 = HIDWORD(v244);
    if (v66 < v246[0])
      v65 = v66;
    v67 = v65 & 0xFFFFFFFC;
    do
    {
      if (!v67)
        goto LABEL_20;
      v68 = *(_DWORD *)((char *)v239 + v67 - 4);
      v67 -= 4;
    }
    while (v68 != -1);
    if (HIDWORD(v245) >> 1 < (*(_DWORD *)(v237 + v67) + *(_DWORD *)(v238 + v67)) * (*(_DWORD *)(a1 + 84) / 1000))
    {
LABEL_75:
      *a5 = 0;
      return v23;
    }
  }
LABEL_20:
  if (v246[1])
  {
    v35 = (*(uint64_t (**)(_QWORD, _QWORD, char **))(*(_QWORD *)(a1 + 40) + 112))(*(_QWORD *)(a1 + 22600), *(_QWORD *)(a1 + 22608), &v240);
    if ((v35 & 0x80000000) != 0)
    {
      v23 = v35;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59007, (uint64_t)"%s%s%s%x", v36, v37, v38, v39, "stream");
      return v23;
    }
  }
  v23 = critsec_Enter(*(_QWORD **)(a1 + 32));
  if ((v23 & 0x80000000) == 0)
  {
    v40 = v246[0];
    if (v246[0] >= v245)
      v40 = v245;
    if (v40 >= HIDWORD(v244))
      v40 = HIDWORD(v244);
    HIDWORD(v245) >>= 1;
    v246[0] = v40 >> 2;
    v41 = v246[1];
    v212 = v246[1] >> 5;
    v246[1] >>= 5;
    if (v41 < 0x20 || !v241 || !v240)
      goto LABEL_214;
    v221 = (uint64_t *)(a1 + 96);
    v211 = v41 & 0xFFFFFFE0;
    cstdlib_memcpy(v240, v241, v211);
    if (!v13)
      goto LABEL_79;
    v45 = (_DWORD *)(a1 + 22636);
    if (v229 > 4)
    {
      *v45 = 1;
      if (*(_DWORD *)(a1 + 22640) && *(_DWORD *)(a1 + 22644))
      {
        v46 = *(uint64_t ***)(a1 + 22648);
        if (v46)
        {
          v47 = *v46;
          if (*v46)
          {
            v48 = 0;
            v49 = 1;
            do
            {
              freePeriDescDyna(*(_QWORD *)(a1 + 16), v47);
              *(_QWORD *)(*(_QWORD *)(a1 + 22648) + 8 * v48) = 0;
              v46 = *(uint64_t ***)(a1 + 22648);
              v48 = v49;
              v47 = v46[v49++];
            }
            while (v47);
          }
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), (uint64_t)v46);
          *(_QWORD *)(a1 + 22648) = 0;
        }
        if ((Psola_Initialise((uint64_t *)(a1 + 22656), *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 84), *(_DWORD *)(a1 + 22640), *(_DWORD *)(a1 + 22644)) & 0x80000000) != 0)log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59000, 0, v50, v51, v52, v53, v206);
        v54 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), v246[0], 40);
        *(_QWORD *)(*(_QWORD *)(a1 + 22656) + 104) = v54;
        if (!v54)
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59000, 0, v55, v56, v57, v58, v206);
        if ((synth_bet4_Psola_GetPeriDescs(a1, (uint64_t)v239, v246[0]) & 0x80000000) != 0)
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59000, 0, v59, v60, v61, v62, v206);
        else
          *(_QWORD *)(*(_QWORD *)(a1 + 22656) + 128) = *(_QWORD *)(a1 + 22648);
        goto LABEL_79;
      }
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 3, 0, (uint64_t)"PMK data not available, PSOLA not possible", v42, v43, v44, v206);
    }
    *v45 = 0;
LABEL_79:
    v219 = (_DWORD *)(a1 + 22636);
    v214 = (unsigned int *)(a1 + 22624);
    v217 = (unsigned int *)(a1 + 22620);
    v69 = *(_DWORD *)(a1 + 22620);
    if (*(_DWORD *)(a1 + 22624) < v69)
      *v214 = v69;
    v70 = HIDWORD(v245);
    v213 = (_DWORD *)(a1 + 21484);
    *(_DWORD *)(a1 + 21484) = v239[v246[0] - 1] != -1;
    v71 = concat_init(*(_QWORD *)(a1 + 16), 0, 0, (uint64_t)"", (uint64_t)synth_bet4_loc_WsolaOutputCB, a1, v242, v70, (uint64_t)v221, *(_DWORD *)(a1 + 22632), 0);
    if (v71 < 0)
    {
      LODWORD(v23) = v71;
      LODWORD(v78) = 0;
      goto LABEL_195;
    }
    LODWORD(v23) = concat_initW((uint64_t)v221, v72);
    if ((v23 & 0x80000000) != 0)
    {
      LODWORD(v78) = 0;
      goto LABEL_158;
    }
    v77 = 0;
    LODWORD(v78) = 0;
    v79 = (_DWORD *)(a1 + 21464);
    v216 = (int *)(a1 + 22668);
    v220 = (_DWORD *)(a1 + 21424);
    v222 = (_DWORD *)(a1 + 22616);
    v210 = (_BYTE *)(a1 + 21480);
    if (v212 <= 1)
      v80 = 1;
    else
      v80 = v212;
    v215 = v80;
    v82 = (_DWORD *)(a1 + 21484);
    v81 = (_DWORD *)(a1 + 22624);
    while (1)
    {
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"*************************\\", v73, v74, v75, v207);
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"[%d/%d, %d/%d] => ", v83, v84, v85, v77);
      v86 = *(_QWORD *)(a1 + 16);
      v87 = &v241[32 * v77];
      v88 = *((_OWORD *)v87 + 1);
      v223 = *(_OWORD *)v87;
      v224 = v88;
      synth_bet4_loc_PrintMrkIn(v86, (unsigned int *)&v223, v89, v90, v91, v92, v93, v94);
      *v79 = 0;
      v95 = v240;
      v96 = &v240[32 * v77];
      *((_DWORD *)v96 + 3) = *v81;
      if (!*v82 && v77 == v246[1] - 1)
      {
        v97 = &v95[32 * v77];
        v100 = *((_DWORD *)v97 + 4);
        v98 = v97 + 16;
        v99 = v100;
        if (v100 >= 2)
          *v98 = v99 - 1;
      }
      v101 = concat_Dur2Sample(*(_DWORD *)(a1 + 136), *(_DWORD *)(a1 + 80) * *((_DWORD *)v96 + 4));
      v102 = *(double *)(a1 + 21440);
      v76.n128_f64[0] = (double)v101 * 100.0 / v102;
      *(_DWORD *)&v240[32 * v77 + 16] = (int)v76.n128_f64[0];
      v103 = v241;
      v104 = *(_DWORD *)&v241[32 * v77];
      switch(v104)
      {
        case 16:
          critsec_Leave(*(_QWORD **)(a1 + 32));
          v105 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
          v106 = *(_DWORD *)&v241[32 * v77 + 24];
          v107 = "pitch";
          goto LABEL_135;
        case 17:
          critsec_Leave(*(_QWORD **)(a1 + 32));
          v105 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
          v106 = *(_DWORD *)&v241[32 * v77 + 24];
          v107 = "timbre";
          goto LABEL_135;
        case 18:
          critsec_Leave(*(_QWORD **)(a1 + 32));
          v105 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
          v106 = *(_DWORD *)&v241[32 * v77 + 24];
          v107 = "rate";
          goto LABEL_135;
        case 19:
          critsec_Leave(*(_QWORD **)(a1 + 32));
          v127 = 100 * *(_DWORD *)&v241[32 * v77 + 24];
          if (v127 <= 0x13947)
          {
            v129 = v127 / 0xC8;
            if (v129 <= 0x32)
              v128 = 50;
            else
              v128 = v129;
          }
          else
          {
            v128 = 400;
          }
          paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate", v128);
          critsec_Enter(*(_QWORD **)(a1 + 32));
          goto LABEL_152;
        case 20:
        case 21:
        case 22:
        case 23:
          goto LABEL_153;
        case 24:
          critsec_Leave(*(_QWORD **)(a1 + 32));
          v105 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
          v106 = *(_DWORD *)&v241[32 * v77 + 24];
          v107 = "volume";
          goto LABEL_135;
        case 25:
          critsec_Leave(*(_QWORD **)(a1 + 32));
          v105 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
          v106 = *(_DWORD *)&v241[32 * v77 + 24];
          v107 = "waitfactor";
LABEL_135:
          paramc_ParamSetUInt(v105, (uint64_t)v107, v106);
          critsec_Enter(*(_QWORD **)(a1 + 32));
          goto LABEL_153;
        default:
          if (v104 == 8)
          {
            *(_QWORD *)(a1 + 21440) = 0x4059000000000000;
            if (*v219)
            {
              *v216 = concat_Dur2Sample(*(_DWORD *)(a1 + 136), *(_DWORD *)&v103[32 * v77 + 24]);
            }
            else
            {
              v136 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
              v137 = concat_Dur2Sample(*(_DWORD *)(a1 + 136), *(_DWORD *)&v103[32 * v77 + 24]);
              log_OutText(v136, (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"XX:MARKERS_AFTER:inserting WSOLA silence of length %d\n", v138, v139, v140, v137);
              v141 = concat_Dur2Sample(*(_DWORD *)(a1 + 136), *(_DWORD *)&v241[32 * v77 + 24]);
              Wsola__silence_output(v221, v141);
            }
            *(double *)(a1 + 21440) = v102;
            v142 = concat_Dur2Sample(*(_DWORD *)(a1 + 136), *(_DWORD *)&v241[32 * v77 + 24]);
            *(_DWORD *)&v240[32 * v77 + 16] = v142;
            *v220 = 0;
            goto LABEL_152;
          }
          if (v104 != 33)
            goto LABEL_152;
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"posCur: %d >= u32CurFrame: %d?\n", v73, v74, v75, *(unsigned int *)&v241[32 * v77 + 12]);
          v218 = v77 + 1;
          v78 = v78;
          break;
      }
      while (1)
      {
        if (v218 >= v246[1])
        {
          v109 = (int *)(a1 + 22636);
          if (v218 != v246[1])
          {
            v82 = (_DWORD *)(a1 + 21484);
            v81 = (_DWORD *)(a1 + 22624);
            v79 = (_DWORD *)(a1 + 21464);
            goto LABEL_153;
          }
        }
        else
        {
          v108 = v241;
          v109 = (int *)(a1 + 22636);
          if (*(_DWORD *)&v241[32 * v218 + 12] <= *v222)
            goto LABEL_144;
        }
        v110 = v78 >= v246[0] || v78 >= v245;
        if (v110 || v78 >= HIDWORD(v244))
          break;
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"%d >= %d\n", v73, v74, v75, *(unsigned int *)&v241[32 * v77 + 12]);
        v112 = v239[v78];
        if (*v109)
        {
          v113 = (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 22656) + 104) + 40 * *(int *)(*(_QWORD *)(a1 + 22656) + 96));
          *v113 = v112;
          v113[1] = *(_DWORD *)(v238 + 4 * v78);
          v113[2] = *(_DWORD *)(v237 + 4 * v78);
          v113[3] = *(_DWORD *)(v236 + 4 * v78);
          v113[4] = *(_DWORD *)(v235 + 4 * v78);
          v113[5] = *(_DWORD *)(v234 + 4 * v78);
          v113[6] = *(_DWORD *)(v233 + 4 * v78);
          v113[7] = *(_DWORD *)(v232 + 4 * v78);
          v113[8] = *(_DWORD *)(v231 + 4 * v78);
          v113[9] = *(_DWORD *)(v230 + 4 * v78);
        }
        else
        {
          v114 = concat_Dur2Sample(*(_DWORD *)(a1 + 136), *(_DWORD *)(v238 + 4 * v78));
          v115 = concat_Dur2Sample(*(_DWORD *)(a1 + 136), *(_DWORD *)(v237 + 4 * v78));
          concat_initUnit((uint64_t)v221, v112, v114, v115);
        }
        *(_BYTE *)(a1 + 21481) = 1;
        if (*v220)
        {
          if (*v109)
          {
            Psola_Synthesis((uint64_t)v221, *(_QWORD *)(a1 + 22656));
          }
          else
          {
            LODWORD(v23) = concat_midSynthesis((uint64_t)v221);
            if ((v23 & 0x80000000) != 0)
              goto LABEL_214;
          }
        }
        else
        {
          v116 = *v109;
          if (*v239 != -1)
          {
            if (v116)
            {
LABEL_121:
              Psola_Synthesis((uint64_t)v221, *(_QWORD *)(a1 + 22656));
            }
            else
            {
              LODWORD(v23) = concat_midSynthesis((uint64_t)v221);
              if ((v23 & 0x80000000) != 0)
                goto LABEL_214;
            }
            *v220 = 1;
            goto LABEL_123;
          }
          if (v116)
            goto LABEL_121;
          concat_startSynthesis((uint64_t)v221);
        }
LABEL_123:
        *v222 += (float)((float)((float)((float)((float)*(unsigned int *)(a1 + 136) / 1000.0)
                                                     * (float)*(int *)(v237 + 4 * v78))
                                             / (float)*(unsigned int *)(a1 + 76))
                                     + 0.5);
        if (*v216)
        {
          Psola_SynthSilence_0(v221, *(int **)(*(_QWORD *)(a1 + 22656) + 16), *v216, *(int **)(a1 + 22656));
          *v216 = 0;
        }
        if (!*v109)
          *(_DWORD *)&v240[32 * v77 + 16] += (int)((double)(*(_DWORD *)(a1 + 21408)
                                                          + *(_DWORD *)(a1 + 21404)
                                                          + *(_DWORD *)(a1 + 21392))
                                                 * 100.0
                                                 / *(double *)(a1 + 21440));
        v117 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
        concat_Dur2Sample(*(_DWORD *)(a1 + 136), *(_DWORD *)(v237 + 4 * v78));
        log_OutText(v117, (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"pUnitsIn[%d]=%d, pSynth->u32CurSample=%d, concat_Dur2Sample: %d", v118, v119, v120, v78);
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 3, 0, (uint64_t)"Synth outputting unit id %d , pSynth->u32CurSample=%d", v121, v122, v123, v239[v78]);
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"pMrkOut[%d].lenCur = %d + (%d) = %d", v124, v125, v126, v77);
        ++v78;
      }
      if (v218 < v246[1])
      {
        v108 = v241;
LABEL_144:
        if (*(_DWORD *)&v108[32 * v218] == 8 && !*v219)
        {
          mfs_Wsola__fade_out(a1 + 176, *(_QWORD *)(a1 + 224), *(_DWORD *)(a1 + 188), *(_QWORD *)(a1 + 232));
          *v210 = 1;
          Wsola__write_audio(v221, *(_QWORD *)(a1 + 224), 0, *(_DWORD *)(a1 + 188));
          *v210 = 0;
          v130 = *(_DWORD *)(a1 + 180) + *v217;
          v131 = &v240[32 * v77];
          v133 = *((_DWORD *)v131 + 4);
          v132 = (unsigned int *)(v131 + 16);
          v134 = *(v132 - 1);
          if (v130 != v133 + v134)
          {
            v110 = v130 >= v134;
            v135 = v130 - v134;
            if (v135 != 0 && v110)
              *v132 = v135;
            else
              *(_DWORD *)&v240[32 * v246[1] - 16] = 0;
          }
        }
      }
LABEL_152:
      v82 = (_DWORD *)(a1 + 21484);
      v81 = (_DWORD *)(a1 + 22624);
      v79 = (_DWORD *)(a1 + 21464);
LABEL_153:
      *v81 = *(_DWORD *)&v240[32 * v77 + 16] + *(_DWORD *)&v240[32 * v77 + 12];
      if (++v77 == v215)
      {
LABEL_158:
        if (!*v219)
          concat_deinitW((uint64_t)v221);
        if ((v23 & 0x80000000) == 0)
        {
          if (v212 < v246[1] || v78 < v246[0])
          {
            *a5 = 2;
            *v217 += *(_DWORD *)(a1 + 180);
          }
          else
          {
            *a5 = 1;
            if (!*v213)
            {
              if (*v219)
              {
                Psola_OutputFinalSilence(v221, *(_QWORD *)(a1 + 22656));
                *(_BYTE *)(a1 + 21480) = 0;
                *(_DWORD *)(a1 + 21424) = 0;
              }
              else
              {
                concat_endSynthesis((uint64_t)v221, 1);
                v76.n128_f64[0] = mfs_WSOLA__Initialise(*(_QWORD *)(a1 + 21496));
              }
            }
            v143 = *(_QWORD **)(a1 + 22656);
            if (v143)
            {
              Psola_Deinitialise(*(_QWORD *)(a1 + 16), v143);
              *(_QWORD *)(a1 + 22656) = 0;
            }
            v144 = *v217 + *(_DWORD *)(a1 + 180);
            *v217 = v144;
            if (!*v213)
            {
              ++*(_DWORD *)(a1 + 22616);
              v145 = &v240[32 * v246[1] - 32];
              v147 = *((_DWORD *)v145 + 4);
              v146 = (unsigned int *)(v145 + 16);
              v148 = *(v146 - 1);
              if (v144 != v147 + v148)
              {
                v110 = v144 >= v148;
                v149 = v144 - v148;
                if (!v110)
                  v149 = 0;
                *v146 = v149;
                *v214 = v144;
              }
            }
            if (HIDWORD(v245))
            {
              LODWORD(v23) = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, __n128))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22376), *(_QWORD *)(a1 + 22384), (2 * HIDWORD(v245)), v76);
              if ((v23 & 0x80000000) != 0)
                log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59006, (uint64_t)"%s%s%s%x", v150, v73, v74, v75, "contentType");
            }
          }
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"Written %d (pSynth->stConcat.w.samples_output)", v73, v74, v75, *(unsigned int *)(a1 + 180));
          log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"Current %d (pSynth->u32CurSample)", v151, v152, v153, *v217);
          v159 = 0;
          do
          {
            v160 = *(_QWORD *)(a1 + 16);
            v161 = v159;
            v162 = 32 * v159;
            v163 = *(_OWORD *)&v240[v162 + 16];
            v223 = *(_OWORD *)&v240[v162];
            v224 = v163;
            synth_bet4_loc_PrintMrkOut(v160, (int *)&v223, (uint64_t)"", v154, v155, v156, v157, v158, v208);
            v164 = *(_QWORD *)(a1 + 16);
            v165 = &v240[32 * v161];
            v166 = *((_OWORD *)v165 + 1);
            v223 = *(_OWORD *)v165;
            v224 = v166;
            synth_bet4_loc_PrintMrkOut(v164, (int *)&v223, (uint64_t)"markereval:", v167, v168, v169, v170, v171, v209);
            if (*(_DWORD *)&v240[v162] == 33)
              log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 3, 0, (uint64_t)"Synth outputting phoneme marker [%c], off %d, len %d", v156, v157, v158, v240[32 * v161 + 24]);
            v159 = v161 + 1;
          }
          while (v212 > (unsigned __int16)(v161 + 1));
          if ((v23 & 0x80000000) == 0
            && ((*(uint64_t (**)(_QWORD, _QWORD, size_t))(*(_QWORD *)(a1 + 40) + 120))(*(_QWORD *)(a1 + 22600), *(_QWORD *)(a1 + 22608), v211) & 0x80000000) != 0)
          {
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59007, (uint64_t)"%s%s%s%x", v172, v173, v174, v175, "stream");
          }
          v176 = (*(uint64_t (**)(_QWORD, _QWORD, size_t))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22392), *(_QWORD *)(a1 + 22400), v211);
          if (v176 < 0)
          {
            LODWORD(v23) = v176;
            v187 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
          }
          else
          {
            v181 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22408), *(_QWORD *)(a1 + 22416), (4 * v78));
            if (v181 < 0)
            {
              LODWORD(v23) = v181;
              v187 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
            }
            else
            {
              v182 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22424), *(_QWORD *)(a1 + 22432), (4 * v78));
              if ((v182 & 0x80000000) == 0)
              {
                LODWORD(v23) = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22440), *(_QWORD *)(a1 + 22448), (4 * v78));
                if ((v23 & 0x80000000) != 0)
                  log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59006, (uint64_t)"%s%s%s%x", v183, v184, v185, v186, "contentType");
                goto LABEL_195;
              }
              LODWORD(v23) = v182;
              v187 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
            }
          }
          log_OutPublic(v187, (uint64_t)"SYNTH_BET4", 59006, (uint64_t)"%s%s%s%x", v177, v178, v179, v180, "contentType");
        }
LABEL_195:
        if (*v219 == 1)
        {
          v188 = 4 * v78;
        }
        else
        {
          v188 = 4 * (*(_DWORD *)(a1 + 22664) == 0);
          *(_DWORD *)(a1 + 22664) = 1;
        }
        LODWORD(v225) = v188;
        if ((v23 & 0x80000000) == 0)
        {
          v189 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22472), *(_QWORD *)(a1 + 22480));
          if (v189 < 0)
          {
            LODWORD(v23) = v189;
            v203 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
          }
          else
          {
            v194 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22488), *(_QWORD *)(a1 + 22496), v225);
            if (v194 < 0)
            {
              LODWORD(v23) = v194;
              v203 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
            }
            else
            {
              v195 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22504), *(_QWORD *)(a1 + 22512), v225);
              if (v195 < 0)
              {
                LODWORD(v23) = v195;
                v203 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
              }
              else
              {
                v196 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22520), *(_QWORD *)(a1 + 22528), v225);
                if (v196 < 0)
                {
                  LODWORD(v23) = v196;
                  v203 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
                }
                else
                {
                  v197 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22536), *(_QWORD *)(a1 + 22544), v225);
                  if (v197 < 0)
                  {
                    LODWORD(v23) = v197;
                    v203 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
                  }
                  else
                  {
                    v198 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22552), *(_QWORD *)(a1 + 22560), v225);
                    if ((v198 & 0x80000000) == 0)
                    {
                      LODWORD(v23) = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 96))(*(_QWORD *)(a1 + 22568), *(_QWORD *)(a1 + 22576), v225);
                      if ((v23 & 0x80000000) != 0)
                        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59006, (uint64_t)"%s%s%s%x", v199, v200, v201, v202, "contentType");
                      goto LABEL_214;
                    }
                    LODWORD(v23) = v198;
                    v203 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
                  }
                }
              }
            }
          }
          log_OutPublic(v203, (uint64_t)"SYNTH_BET4", 59006, (uint64_t)"%s%s%s%x", v190, v191, v192, v193, "contentType");
        }
LABEL_214:
        v204 = critsec_Leave(*(_QWORD **)(a1 + 32));
        if (v204 >= 0 || (int)v23 <= -1)
          return v23;
        else
          return v204;
      }
    }
  }
  return v23;
}

uint64_t synth_bet4_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t **v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int v6;
  _QWORD *v7;

  if ((safeh_HandleCheck(a1, a2, 9356, 22680) & 0x80000000) != 0)
    return 2164269064;
  *(_BYTE *)(a1 + 21480) = 0;
  *(_OWORD *)(a1 + 22616) = 0u;
  Lookup_DeInit(*(uint64_t **)(a1 + 120));
  if (!*(_DWORD *)(a1 + 22636))
    concat_endSynthesis(a1 + 96, 0);
  v3 = *(uint64_t ***)(a1 + 22648);
  if (v3)
  {
    v4 = *v3;
    if (*v3)
    {
      v5 = 0;
      v6 = 1;
      do
      {
        freePeriDescDyna(*(_QWORD *)(a1 + 16), v4);
        *(_QWORD *)(*(_QWORD *)(a1 + 22648) + 8 * v5) = 0;
        v3 = *(uint64_t ***)(a1 + 22648);
        v5 = v6;
        v4 = v3[v6++];
      }
      while (v4);
    }
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), (uint64_t)v3);
    *(_QWORD *)(a1 + 22648) = 0;
  }
  v7 = *(_QWORD **)(a1 + 22656);
  if (v7)
  {
    Psola_Deinitialise(*(_QWORD *)(a1 + 16), v7);
    *(_QWORD *)(a1 + 22656) = 0;
  }
  mfs_WSOLA__Initialise(*(_QWORD *)(a1 + 21496));
  concat_final_deinitW((uint64_t *)(a1 + 96));
  return synstrmaux_CloseStreams((_WORD *)(a1 + 21552), *(_QWORD *)(a1 + 40));
}

uint64_t synth_bet4_loc_ParamCheckChange(int a1, char *__s1, const char *a3, _DWORD *a4)
{
  uint64_t result;
  BOOL v8;

  if (cstdlib_strcmp(__s1, "audiooutputbufsamples"))
  {
    if (cstdlib_strcmp(__s1, "volume"))
    {
      if (cstdlib_strcmp(__s1, "rate"))
      {
        if (!cstdlib_strcmp(__s1, "rate_baseline"))
        {
          v8 = __CFADD__(LH_atoi(a3) - 401, 351);
LABEL_25:
          if (v8)
            result = 0;
          else
            result = 2164269071;
          goto LABEL_28;
        }
        if (!cstdlib_strcmp(__s1, "ratewpm"))
        {
          result = 2164269057;
          goto LABEL_28;
        }
        if (cstdlib_strcmp(__s1, "waitfactor"))
        {
          if (cstdlib_strcmp(__s1, "pitch") && cstdlib_strcmp(__s1, "pitch_baseline"))
          {
            result = 0;
            goto LABEL_28;
          }
          v8 = __CFADD__(LH_atoi(a3) - 201, 151);
          goto LABEL_25;
        }
        if (LH_atoi(a3) <= 9)
          result = 0;
        else
          result = 2164269071;
      }
      else if (LH_atoi(a3) - 401 >= 0xFFFFFEA1)
      {
        result = 0;
      }
      else
      {
        result = 2164269071;
      }
    }
    else if (LH_atoi(a3) <= 0x64)
    {
      result = 0;
    }
    else
    {
      result = 2164269071;
    }
  }
  else if ((int)LH_atoi(a3) <= 0)
  {
    result = 2164269071;
  }
  else
  {
    result = 0;
  }
LABEL_28:
  *a4 = (int)result >= 0;
  return result;
}

uint64_t synth_bet4_loc_ParamLearnChange(uint64_t a1, char *__s1, const char *a3)
{
  const char *v7;

  if (cstdlib_strcmp(__s1, "audiooutputbufsamples")
    && cstdlib_strcmp(__s1, "volume")
    && cstdlib_strcmp(__s1, "rate")
    && cstdlib_strcmp(__s1, "rate_baseline")
    && cstdlib_strcmp(__s1, "ratewpm")
    && cstdlib_strcmp(__s1, "waitfactor")
    && cstdlib_strcmp(__s1, "pitch")
    && cstdlib_strcmp(__s1, "pitch_baseline"))
  {
    return 0;
  }
  v7 = LH_atoi(a3);
  return synth_bet4_loc_ParamSet(a1, __s1, (uint64_t)v7);
}

uint64_t synth_bet4_loc_ParamSet(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v25;
  unsigned int v26;

  if (cstdlib_strcmp(a2, "audiooutputbufsamples"))
  {
    v6 = critsec_Enter(*(_QWORD **)(a1 + 32));
    if ((v6 & 0x80000000) == 0)
    {
      if (cstdlib_strcmp(a2, "volume"))
      {
        if (cstdlib_strcmp(a2, "rate_baseline"))
        {
          if (cstdlib_strcmp(a2, "rate"))
          {
            v10 = 2164269071;
            if (cstdlib_strcmp(a2, "ratewpm"))
            {
              if (cstdlib_strcmp(a2, "waitfactor"))
              {
                if (!cstdlib_strcmp(a2, "pitch_baseline"))
                {
                  v10 = synth_bet4_handle_pitch_baseline(a1, a3);
                  goto LABEL_30;
                }
                if (cstdlib_strcmp(a2, "pitch"))
                  goto LABEL_29;
                if ((a3 - 201) >= 0xFFFFFF69)
                {
                  v14 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 88), a3);
                  v15 = (double)v14 + -100.0 + (double)v14 + -100.0;
                  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 3, 0, (uint64_t)"Set pitch %d (synth %f)", v16, v17, v18, a3);
                  *(double *)(a1 + 21448) = v15;
LABEL_29:
                  v10 = v6;
                }
              }
              else if (a3 <= 9)
              {
                log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 3, 0, (uint64_t)"Set wait factor %d (synth %f)", v11, v12, v13, a3);
                *(double *)(a1 + 21456) = (double)(int)a3;
                goto LABEL_29;
              }
            }
            else
            {
              v10 = 2164269057;
            }
LABEL_30:
            critsec_Leave(*(_QWORD **)(a1 + 32));
            return v10;
          }
          if ((a3 - 401) >= 0xFFFFFEA1)
          {
            v25 = (double)(int)MapProsodyValue_Scaling(50, 100, 400, *(_DWORD *)(a1 + 92), a3);
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 3, 0, (uint64_t)"Set rate %d (synth %f)", v21, v22, v23, a3);
            *(double *)(a1 + 21440) = v25;
            goto LABEL_29;
          }
        }
        else if ((a3 - 401) >= 0xFFFFFEA1)
        {
          v26 = 0;
          *(_DWORD *)(a1 + 92) = a3;
          paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate", &v26);
          synth_bet4_loc_ParamSet(a1, "rate", v26);
          v10 = 0;
          goto LABEL_30;
        }
      }
      else if (a3 <= 0x64)
      {
        if (a3 <= 0x50)
          v20 = (double)(int)a3 / 80.0;
        else
          v20 = ((double)(int)a3 + -80.0) / 20.0 + 1.0;
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 3, 0, (uint64_t)"Set volume %d (synth %f)", v7, v8, v9, a3);
        *(double *)(a1 + 21432) = v20;
        goto LABEL_29;
      }
      v10 = 2164269071;
      goto LABEL_30;
    }
  }
  else
  {
    v6 = 0;
    if (a3 <= 1)
      v19 = 1;
    else
      v19 = a3;
    *(_DWORD *)(a1 + 72) = v19;
  }
  return v6;
}

uint64_t synth_bet4_loc_ParamGetListen(uint64_t a1, _BYTE *a2, signed int a3, signed int a4, unsigned int a5, __int128 *a6, unsigned int *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  const char *v25;
  __int128 v26;
  uint64_t v27;

  if ((paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)a2, a7) & 0x80000000) != 0
    || (a5 = a3, (int)*a7 < a3)
    || (a5 = a4, (int)*a7 > a4))
  {
    v14 = paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)a2, a5);
    *a7 = a5;
    if ((v14 & 0x80000000) != 0)
    {
      v20 = v14;
      v21 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
      v25 = "parameter";
      v23 = "%s%s";
      v22 = 59009;
      goto LABEL_8;
    }
  }
  v19 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40);
  v26 = *a6;
  v27 = *((_QWORD *)a6 + 2);
  v20 = paramc_ListenerAdd(v19, a2, &v26);
  if ((v20 & 0x80000000) != 0)
  {
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    v22 = 59010;
    v23 = 0;
LABEL_8:
    log_OutPublic(v21, (uint64_t)"SYNTH_BET4", v22, (uint64_t)v23, v15, v16, v17, v18, v25);
  }
  return v20;
}

uint64_t synth_bet4_loc_SynthInit(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t UInt;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t Str;
  unsigned int v10;
  size_t v11;
  uint64_t Int;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v21;
  char *v22;
  char *v23;
  char *v24;
  char *__s2;
  unsigned int v26;
  char __src[8];
  char __dst[256];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 16);
  v26 = 0;
  v21 = 0;
  v22 = 0;
  v3 = (uint64_t *)(a1 + 120);
  if (*(_QWORD *)(a1 + 120))
  {
    Lookup_ObjClose((uint64_t *)(a1 + 120));
    *v3 = 0;
  }
  UInt = paramc_ParamGetUInt(*(_QWORD *)(v2 + 40), (uint64_t)"frequencyhz", (unsigned int *)(a1 + 84));
  if ((UInt & 0x80000000) != 0
    || (*(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 84),
        UInt = paramc_ParamGetUInt(*(_QWORD *)(v2 + 40), (uint64_t)"bet2voiceframesize", (unsigned int *)(a1 + 80)),
        (UInt & 0x80000000) != 0)
    || (v24 = 0,
        __s2 = 0,
        v23 = 0,
        *(_DWORD *)(a1 + 76) = *(_DWORD *)(a1 + 80) * *(_DWORD *)(a1 + 84) / 0x3E8u,
        UInt = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"voice", &__s2),
        (UInt & 0x80000000) != 0))
  {
    v14 = UInt;
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
LABEL_22:
    log_OutPublic(v19, (uint64_t)"SYNTH_BET4", 59008, (uint64_t)"%s%s", v5, v6, v7, v8, "parameter");
    return v14;
  }
  Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"coder", &v24);
  if ((Str & 0x80000000) != 0
    || (Str = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"reduction", &v23), (Str & 0x80000000) != 0))
  {
    v14 = Str;
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_22;
  }
  cstdlib_strcpy(__dst, "");
  cstdlib_strcat(__dst, "synth/");
  cstdlib_strcat(__dst, __s2);
  cstdlib_strcat(__dst, "/bet4/");
  cstdlib_strcat(__dst, v23);
  cstdlib_strcat(__dst, "/");
  cstdlib_strcat(__dst, v24);
  cstdlib_strcat(__dst, "/f");
  v10 = *(_DWORD *)(a1 + 84) / 0x3E8u;
  v11 = cstdlib_strlen(__dst);
  LH_itoa(v10, &__dst[v11], 0xAu);
  if ((paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"datapackagename", &v21) & 0x80000000) == 0 && v21 && *v21)
  {
    Int = brokeraux_ComposeBrokerString(v2, __dst, 0, 0, 0, 0, 0, __src, 0x100uLL);
    if ((Int & 0x80000000) != 0)
      return Int;
    cstdlib_strcpy(__dst, __src);
  }
  v13 = Lookup_ObjOpen(*(_WORD **)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 24), (uint64_t)__dst, v3);
  if ((v13 & 0x80000000) != 0)
  {
    v14 = v13;
    *v3 = 0;
    return v14;
  }
  Lookup_GetComponentID(*v3, &v22);
  if (!v22 || !*v22)
  {
LABEL_25:
    *(_DWORD *)(a1 + 22632) = 0;
    Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"volume", &v26);
    if ((Int & 0x80000000) == 0)
    {
      Int = synth_bet4_loc_ParamSet(a1, "volume", v26);
      if ((Int & 0x80000000) == 0)
      {
        Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate_baseline", &v26);
        if ((Int & 0x80000000) == 0)
        {
          Int = synth_bet4_loc_ParamSet(a1, "rate_baseline", v26);
          if ((Int & 0x80000000) == 0)
          {
            Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"rate", &v26);
            if ((Int & 0x80000000) == 0)
            {
              Int = synth_bet4_loc_ParamSet(a1, "rate", v26);
              if ((Int & 0x80000000) == 0)
              {
                Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"waitfactor", &v26);
                if ((Int & 0x80000000) == 0)
                {
                  Int = synth_bet4_loc_ParamSet(a1, "waitfactor", v26);
                  if ((Int & 0x80000000) == 0)
                  {
                    Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch_baseline", &v26);
                    if ((Int & 0x80000000) == 0)
                    {
                      Int = synth_bet4_loc_ParamSet(a1, "pitch_baseline", v26);
                      if ((Int & 0x80000000) == 0)
                      {
                        Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch", &v26);
                        if ((Int & 0x80000000) == 0)
                          return synth_bet4_loc_ParamSet(a1, "pitch", v26);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return Int;
  }
  *(_QWORD *)__src = 0;
  v14 = paramc_ParamGetStr(*(_QWORD *)(v2 + 40), (uint64_t)"voicecomponentid", __src);
  if ((v14 & 0x80000000) != 0)
  {
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
    goto LABEL_22;
  }
  if (!*(_QWORD *)__src || !**(_BYTE **)__src || !cstdlib_strcmp(*(const char **)__src, v22))
    goto LABEL_25;
  log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59013, (uint64_t)"%s%s", v15, v16, v17, v18, "voice");
  return v14;
}

uint64_t synth_bet4_handle_pitch_baseline(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;

  if ((a2 - 201) < 0xFFFFFF69)
    return 2164269071;
  v7 = v2;
  v8 = v3;
  v6 = 0;
  *(_DWORD *)(a1 + 88) = a2;
  paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40), (uint64_t)"pitch", &v6);
  synth_bet4_loc_ParamSet(a1, "pitch", v6);
  return 0;
}

uint64_t synth_bet4_Psola_GetPeriDescs(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  __int16 v12;

  v6 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 16) + 8), 8, (a3 + 1));
  *(_QWORD *)(a1 + 22648) = v6;
  if (!v6)
    return 2164269066;
  if (a3)
  {
    v7 = 0;
    v8 = 0;
    while (1)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 22648) + 8 * v7) = newPeriDescDyna(*(_QWORD *)(a1 + 16));
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 22648) + 8 * v7);
      if (!v9)
        return 2164269066;
      v10 = *(_DWORD *)(a2 + 4 * v7);
      if (v10 == -1)
        break;
      v11 = Lookup_UnitPeriInfo(*(_QWORD **)(a1 + 120), v10, v9);
      if ((v11 & 0x80000000) != 0)
        return v11;
      v8 = Psola_AssignPeriRangesDyna(*(unsigned __int16 **)(*(_QWORD *)(a1 + 22648) + 8 * v7));
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 22648) + 8 * v7);
      if (!*(_WORD *)(v9 + 4))
        goto LABEL_10;
LABEL_12:
      if (a3 == ++v7)
        return v8;
    }
    *(_QWORD *)v9 = 0;
LABEL_10:
    v12 = *(_WORD *)(v9 + 2);
    if (v12)
    {
      *(_WORD *)(v9 + 4) = 1;
      *(_WORD *)(v9 + 2) = v12 - 1;
    }
    goto LABEL_12;
  }
  return 0;
}

uint64_t synth_bet4_loc_WsolaOutputCB(uint64_t a1, __int16 *a2, uint64_t a3)
{
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _BOOL4 v23;
  uint64_t OutputLength;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v37;
  int v38;

  v6 = a1 + 21464;
  v38 = 0;
  *(_BYTE *)(a1 + 21482) = 0;
  v7 = (_BYTE *)(a1 + 21482);
  if (*(double *)(a1 + 21440) != 100.0)
  {
    v21 = 0;
    *(_DWORD *)(a1 + 176) += a3;
    do
    {
LABEL_16:
      v37 = 1;
      *(_DWORD *)v6 = (2 * ((274877907 * (unint64_t)*(unsigned int *)(a1 + 136)) >> 32)) & 0x3FFFFF80;
      mfs_WSOLA__TimeScaleInputBuffer(*(_QWORD *)(a1 + 21496), *(_BYTE *)(v6 + 16), a2, a3, *(_WORD **)(a1 + 21472), (int *)v6, (__int16)((int)*(double *)(a1 + 21440) - 100), &v37, v7);
      OutputLength = mfs_WSOLA__GetOutputLength(*(_QWORD *)(a1 + 21496), *(unsigned __int8 *)(v6 + 17), &v38);
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"Output: %d %d %d %d | %d\n", v25, v26, v27, a3);
      if (*(unsigned __int8 *)(v6 + 18) - 1 > 1)
        break;
      v31 = v38 ? "Length: %d/%d\n" : "Partial length: %d/%d\n";
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)v31, v28, v29, v30, OutputLength);
      if (*(_DWORD *)v6)
      {
        v21 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 104))(*(_QWORD *)(a1 + 22584), *(_QWORD *)(a1 + 22592), *(_QWORD *)(a1 + 21472), (2 * *(_DWORD *)v6));
        if ((v21 & 0x80000000) != 0)
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59007, (uint64_t)"%s%s%s%x", v32, v33, v34, v35, "stream");
        else
          *(_DWORD *)(a1 + 180) += *(_DWORD *)v6;
      }
    }
    while (!v38);
    return v21;
  }
  v8 = *(_QWORD *)(a1 + 21496);
  if (*(int *)(v8 + 112) < 1)
  {
    v21 = 0;
  }
  else
  {
    v9 = mfs_WSOLA__GetOutputLength(v8, *(unsigned __int8 *)(v6 + 17), &v38);
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"Output: %d %d %d %d | %d\n", v10, v11, v12, a3);
    if (v38)
      v16 = "Length";
    else
      v16 = "Partial length: %d/%d\n";
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)v16, v13, v14, v15, v9);
    v21 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 104))(*(_QWORD *)(a1 + 22584), *(_QWORD *)(a1 + 22592), *(_QWORD *)(a1 + 21472), (2 * *(_DWORD *)(*(_QWORD *)(a1 + 21496) + 112)));
    if ((v21 & 0x80000000) != 0)
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32), (uint64_t)"SYNTH_BET4", 59007, (uint64_t)"%s%s%s%x", v17, v18, v19, v20, "stream");
      v22 = *(_QWORD *)(a1 + 21496);
    }
    else
    {
      v22 = *(_QWORD *)(a1 + 21496);
      *(_DWORD *)(a1 + 180) += *(_DWORD *)(v22 + 112);
    }
    *(_DWORD *)(v22 + 112) = 0;
  }
  v38 = 1;
  if ((_DWORD)a3)
  {
    v21 = (*(uint64_t (**)(_QWORD, _QWORD, __int16 *, _QWORD))(*(_QWORD *)(a1 + 40) + 104))(*(_QWORD *)(a1 + 22584), *(_QWORD *)(a1 + 22592), a2, (2 * a3));
    v23 = v38 == 0;
  }
  else
  {
    v23 = 0;
  }
  *(_DWORD *)v6 = a3;
  *(int32x2_t *)(a1 + 176) = vadd_s32(*(int32x2_t *)(a1 + 176), vdup_n_s32(a3));
  if (v23)
    goto LABEL_16;
  return v21;
}

uint64_t synth_bet4_loc_PrintMrkIn(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  const char *v10;

  v8 = *a2;
  if ((int)v8 > 32)
  {
    switch((_DWORD)v8)
    {
      case 0x4000:
        v9 = *(_QWORD *)(a1 + 32);
        v8 = a2[3];
        v10 = "SYNC off %d, len %d";
        break;
      case 0x24:
        v9 = *(_QWORD *)(a1 + 32);
        v8 = a2[3];
        v10 = "LANG off %d, len %d";
        break;
      case 0x21:
        v9 = *(_QWORD *)(a1 + 32);
        v8 = *((char *)a2 + 24);
        v10 = "PHONE [%c], off %d, len %d";
        break;
      default:
LABEL_15:
        v9 = *(_QWORD *)(a1 + 32);
        v10 = "TAG %d off %d, len %d";
        break;
    }
  }
  else
  {
    switch((int)v8)
    {
      case 16:
        v9 = *(_QWORD *)(a1 + 32);
        v8 = a2[6];
        v10 = "PITCH [%d], off %d, len %d";
        return log_OutText(v9, (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)v10, a6, a7, a8, v8);
      case 17:
        v9 = *(_QWORD *)(a1 + 32);
        v8 = a2[6];
        v10 = "TIMBRE [%d], off %d, len %d";
        return log_OutText(v9, (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)v10, a6, a7, a8, v8);
      case 18:
        v9 = *(_QWORD *)(a1 + 32);
        v8 = a2[6];
        v10 = "RATE [%d], off %d, len %d";
        return log_OutText(v9, (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)v10, a6, a7, a8, v8);
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 25:
        goto LABEL_15;
      case 24:
        v9 = *(_QWORD *)(a1 + 32);
        v8 = a2[6];
        v10 = "VOLUME [%d], off %d, len %d";
        return log_OutText(v9, (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)v10, a6, a7, a8, v8);
      case 26:
        v9 = *(_QWORD *)(a1 + 32);
        v8 = a2[3];
        v10 = "AUDIO off %d, len %d";
        return log_OutText(v9, (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)v10, a6, a7, a8, v8);
      default:
        if ((_DWORD)v8 == 1)
        {
          v9 = *(_QWORD *)(a1 + 32);
          v8 = a2[3];
          v10 = "WORD off %d, len %d";
        }
        else
        {
          if ((_DWORD)v8 != 8)
            goto LABEL_15;
          v9 = *(_QWORD *)(a1 + 32);
          v8 = a2[6];
          v10 = "PAUSE [%d], off %d, len %d";
        }
        break;
    }
  }
  return log_OutText(v9, (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)v10, a6, a7, a8, v8);
}

uint64_t synth_bet4_loc_PrintMrkOut(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;

  log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)" => ", a6, a7, a8, v22);
  v15 = *a2;
  if (*a2 > 32)
  {
    switch(v15)
    {
      case 0x4000:
        v16 = *(_QWORD *)(a1 + 32);
        v17 = "%sSYNC off %d, len %d";
        break;
      case 0x24:
        v16 = *(_QWORD *)(a1 + 32);
        v17 = "%sLANG off %d, len %d";
        break;
      case 0x21:
        v16 = *(_QWORD *)(a1 + 32);
        v17 = "%sPHONE [%c], off %d, len %d";
        break;
      default:
LABEL_15:
        v16 = *(_QWORD *)(a1 + 32);
        v17 = "%sTAG %d off %d, len %d";
        break;
    }
  }
  else
  {
    switch(v15)
    {
      case 16:
        v16 = *(_QWORD *)(a1 + 32);
        v17 = "%sPITCH [%d], off %d, len %d";
        break;
      case 17:
        v16 = *(_QWORD *)(a1 + 32);
        v17 = "%sTIMBRE [%d], off %d, len %d";
        break;
      case 18:
        v16 = *(_QWORD *)(a1 + 32);
        v17 = "%sRATE [%d], off %d, len %d";
        break;
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 25:
        goto LABEL_15;
      case 24:
        v16 = *(_QWORD *)(a1 + 32);
        v17 = "%sVOLUME [%d], off %d, len %d";
        break;
      case 26:
        v16 = *(_QWORD *)(a1 + 32);
        v17 = "%sAUDIO off %d, len %d";
        break;
      default:
        if (v15 == 1)
        {
          v16 = *(_QWORD *)(a1 + 32);
          v17 = "%sWORD off %d, len %d";
        }
        else
        {
          if (v15 != 8)
            goto LABEL_15;
          v16 = *(_QWORD *)(a1 + 32);
          v17 = "%sPAUSE [%d], off %d, len %d";
        }
        break;
    }
  }
  log_OutText(v16, (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)v17, v12, v13, v14, a3);
  return log_OutText(*(_QWORD *)(a1 + 32), (uint64_t)"SYNTH_BET4", 4, 0, (uint64_t)"\\************************/", v18, v19, v20, a9);
}

uint64_t Vector__Clear(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  if (!a1)
    return 1;
  v2 = *(void **)(a1 + 16);
  if (!v2)
    return 1;
  v3 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v3)
    bzero(v2, 4 * v3);
  return 0;
}

uint64_t Vector__Create(_QWORD *a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;

  v4 = heap_Calloc(a1, 1, 24);
  v5 = v4;
  if (v4)
  {
    *(_QWORD *)v4 = a1;
    *(_DWORD *)(v4 + 8) = a2;
    *(_DWORD *)(v4 + 12) = 0;
    v6 = (void *)heap_Calloc(a1, a2, 4);
    *(_QWORD *)(v5 + 16) = v6;
    if (v6)
    {
      v7 = *(unsigned int *)(v5 + 8);
      if ((_DWORD)v7)
        bzero(v6, 4 * v7);
    }
    else
    {
      heap_Free(a1, v5);
      return 0;
    }
  }
  return v5;
}

uint64_t *Window__Remove(uint64_t *result)
{
  uint64_t *v1;

  if (result)
  {
    v1 = result;
    if (*result)
    {
      heap_Free(*(_QWORD **)*result, *(_QWORD *)(*result + 16));
      *(_QWORD *)(*v1 + 16) = 0;
      result = heap_Free(*(_QWORD **)*v1, *v1);
      *v1 = 0;
    }
  }
  return result;
}

void mfs_Vect__Clear(uint64_t a1)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 12) = 0;
    bzero(*(void **)(a1 + 24), 8 * *(unsigned int *)(a1 + 8));
  }
}

_WORD *mfs_Vect__SetSamplingRate(_WORD *result, __int16 a2)
{
  *result = a2;
  return result;
}

void mfs_Vect__Reset(uint64_t a1)
{
  if (a1)
    bzero(*(void **)(a1 + 24), 8 * *(unsigned int *)(a1 + 8));
}

uint64_t mfs_Vect__Create(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  v4 = heap_Alloc(a1, 40);
  v5 = v4;
  if (v4)
  {
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)(v4 + 8) = a2;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_WORD *)v4 = 22050;
    *(_QWORD *)(v4 + 32) = a1;
    v6 = (void *)heap_Alloc(a1, 8 * a2);
    *(_QWORD *)(v5 + 24) = v6;
    if (v6)
    {
      *(_DWORD *)(v5 + 12) = 0;
      bzero(v6, 8 * *(unsigned int *)(v5 + 8));
    }
    else
    {
      heap_Free(*(_QWORD **)(v5 + 32), v5);
      return 0;
    }
  }
  return v5;
}

uint64_t *mfs_Vect__Remove(uint64_t *result)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = *(_QWORD *)(v2 + 24);
      v4 = *(_QWORD **)(v2 + 32);
      if (v3)
      {
        heap_Free(*(_QWORD **)(v2 + 32), v3);
        v2 = *v1;
      }
      *(_QWORD *)(v2 + 24) = 0;
      result = heap_Free(v4, *v1);
      *v1 = 0;
    }
  }
  return result;
}

uint64_t mfs_Vect__Resize(uint64_t result, unsigned int a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v2 = result;
    if (*(_DWORD *)(result + 8) >= a2)
    {
      return 1;
    }
    else
    {
      *(_DWORD *)(result + 8) = a2;
      v3 = *(uint64_t **)(result + 32);
      v4 = heap_Realloc(v3, *(_QWORD *)(result + 24), 8 * a2);
      if (v4)
      {
        v5 = v4;
        result = 1;
      }
      else
      {
        *(_QWORD *)(v2 + 8) = 0;
        v6 = *(_QWORD *)(v2 + 24);
        if (v6)
          heap_Free(v3, v6);
        v5 = 0;
        result = 0;
      }
      *(_QWORD *)(v2 + 24) = v5;
    }
  }
  return result;
}

uint64_t mfs_Vect__GetSlice(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  unsigned int v7;
  uint64_t v9;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  _QWORD *v16;
  unsigned int v17;
  _QWORD *v18;
  int v19;
  uint64_t *v20;
  int v21;
  uint64_t v22;

  if (!a4)
    return 0;
  v7 = *(_DWORD *)(a1 + 12);
  if (v7 <= a2 || v7 <= a3)
    return 0;
  v12 = a3 - a2;
  if (a4 >= 0)
    v13 = a4;
  else
    v13 = -a4;
  v14 = v12 / v13;
  v15 = v12 / v13 + 1;
  v9 = mfs_Vect__Create(*(_QWORD *)(a1 + 32), v15);
  *(_DWORD *)(v9 + 12) = v15;
  v16 = *(_QWORD **)(v9 + 24);
  *(_WORD *)v9 = *(_WORD *)a1;
  if (a4 == 1)
  {
    cstdlib_memmove(v16, (const void *)(*(_QWORD *)(a1 + 24) + 8 * a2), 8 * v15);
  }
  else
  {
    if (a4 >= 0)
      v17 = a4;
    else
      v17 = -a4;
    if (v17 < 2)
    {
      if (a4 == -1 && v15)
      {
        v20 = (uint64_t *)(*(_QWORD *)(a1 + 24) + 8 * a3);
        v21 = v14 + 1;
        do
        {
          v22 = *v20--;
          *v16++ = v22;
          --v21;
        }
        while (v21);
      }
    }
    else if (v15)
    {
      v18 = (_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * a2);
      v19 = v14 + 1;
      do
      {
        *v16++ = *v18;
        v18 += a4;
        --v19;
      }
      while (v19);
    }
  }
  return v9;
}

double mfs_Downsample__Create(uint64_t a1)
{
  uint64_t v2;
  double result;

  v2 = heap_Alloc(a1, 56);
  if (v2)
  {
    result = 0.0;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)v2 = 0u;
    *(_QWORD *)(v2 + 48) = a1;
  }
  return result;
}

uint64_t mfs_Downsample__Resize(uint64_t result, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (result)
  {
    v2 = result;
    if (*(_DWORD *)(result + 32) == a2)
      return 1;
    LODWORD(v3) = *(_DWORD *)(result + 36);
    if (v3 >= a2)
    {
      *(_DWORD *)(result + 32) = a2;
      if ((v3 & 0x80000000) == 0)
      {
        v13 = 0;
        v14 = *(_QWORD *)(result + 16);
        do
        {
          *(_DWORD *)(v14 + 4 * v13) = ((int)v13 + 1) % (*(_DWORD *)(result + 32) + 1);
          v3 = *(int *)(result + 36);
          v7 = v13++ < v3;
        }
        while (v7);
      }
      if ((v3 & 0x40000000) == 0)
      {
        v15 = 0;
        v16 = *(_QWORD *)(result + 24);
        do
        {
          *(_DWORD *)(v16 + 4 * v15) = (int)v15 % (*(_DWORD *)(result + 32) + 1);
          v7 = v15++ < ((2 * *(_DWORD *)(result + 36)) | 1);
        }
        while (v7);
      }
      v12 = *(_DWORD *)(result + 32) + 1;
      goto LABEL_25;
    }
    *(_DWORD *)(result + 36) = a2;
    result = heap_Realloc(*(uint64_t **)(result + 48), *(_QWORD *)result, 4 * a2 + 4);
    if (result)
    {
      *(_QWORD *)v2 = result;
      result = heap_Realloc(*(uint64_t **)(v2 + 48), *(_QWORD *)(v2 + 8), (4 * *(_DWORD *)(v2 + 36) + 4));
      if (result)
      {
        *(_QWORD *)(v2 + 8) = result;
        result = heap_Realloc(*(uint64_t **)(v2 + 48), *(_QWORD *)(v2 + 16), (4 * *(_DWORD *)(v2 + 36) + 4));
        if (result)
        {
          *(_QWORD *)(v2 + 16) = result;
          result = heap_Realloc(*(uint64_t **)(v2 + 48), *(_QWORD *)(v2 + 24), (8 * *(_DWORD *)(v2 + 36) + 8));
          if (result)
          {
            *(_QWORD *)(v2 + 24) = result;
            LODWORD(v4) = *(_DWORD *)(v2 + 36);
            if ((v4 & 0x80000000) == 0)
            {
              v5 = 0;
              v6 = *(_QWORD *)(v2 + 16);
              do
              {
                *(_DWORD *)(v6 + 4 * v5) = ((int)v5 + 1) % (*(_DWORD *)(v2 + 32) + 1);
                v4 = *(int *)(v2 + 36);
                v7 = v5++ < v4;
              }
              while (v7);
            }
            if ((v4 & 0x40000000) == 0)
            {
              v8 = 0;
              do
              {
                *(_DWORD *)(result + 4 * v8) = (int)v8 % (*(_DWORD *)(v2 + 32) + 1);
                LODWORD(v4) = *(_DWORD *)(v2 + 36);
                v7 = v8++ < (int)((2 * v4) | 1);
              }
              while (v7);
            }
            v9 = *(_DWORD *)(v2 + 32) + 1;
            if (v9 <= v4)
            {
              v10 = *(_QWORD *)v2;
              v11 = *(_QWORD *)(v2 + 8);
              do
              {
                *(_DWORD *)(v10 + 4 * v9) = 0;
                *(_DWORD *)(v11 + 4 * v9++) = 0;
              }
              while (v9 <= v4);
            }
            *(_DWORD *)(v2 + 32) = v4;
            v12 = v4 + 1;
LABEL_25:
            *(_DWORD *)(v2 + 44) = v12 >> 1;
            return 1;
          }
        }
      }
    }
    *(_DWORD *)(v2 + 32) = 0;
  }
  return result;
}

uint64_t mfs_Downsample__Copy(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t result;
  int v6;
  _DWORD *v7;
  int *v8;
  int *v9;
  uint64_t v10;
  int v11;
  int v12;

  v4 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 32) = v4;
  result = heap_Realloc(*(uint64_t **)(a1 + 48), *(_QWORD *)a1, 4 * (v4 + 1));
  if (result)
  {
    *(_QWORD *)a1 = result;
    result = heap_Realloc(*(uint64_t **)(a1 + 48), *(_QWORD *)(a1 + 8), 4 * (*(_DWORD *)(a1 + 32) + 1));
    if (result)
    {
      *(_QWORD *)(a1 + 8) = result;
      v6 = *(_DWORD *)(a1 + 32);
      v7 = *(_DWORD **)a1;
      v8 = *(int **)a2;
      v9 = *(int **)(a2 + 8);
      if ((v6 + 1) > 1)
        v10 = (v6 + 1);
      else
        v10 = 1;
      do
      {
        v11 = *v8++;
        *v7++ = v11;
        v12 = *v9++;
        *(_DWORD *)result = v12;
        result += 4;
        --v10;
      }
      while (v10);
      return 1;
    }
  }
  return result;
}

uint64_t *mfs_Downsample__Remove(uint64_t *result)
{
  uint64_t *v1;
  _QWORD *v2;

  if (result)
  {
    v1 = result;
    result = (uint64_t *)*result;
    if (result)
    {
      v2 = (_QWORD *)result[6];
      mfs_Downsample__Empty(result);
      result = heap_Free(v2, *v1);
      *v1 = 0;
    }
  }
  return result;
}

uint64_t *mfs_Downsample__Empty(uint64_t *result)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    if (*result)
      result = heap_Free((_QWORD *)result[6], *result);
    *v1 = 0;
    v2 = v1[1];
    if (v2)
      result = heap_Free((_QWORD *)v1[6], v2);
    v1[1] = 0;
    v3 = v1[2];
    if (v3)
      result = heap_Free((_QWORD *)v1[6], v3);
    v4 = v1[3];
    v1[2] = 0;
    if (v4)
      result = heap_Free((_QWORD *)v1[6], v4);
    v1[3] = 0;
    v1[4] = 0;
    v1[5] = 0;
  }
  return result;
}

uint64_t *mfs_Downsample__Generate(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;

  if (a2 > 3)
    return 0;
  v4 = heap_Alloc(a1, 56);
  v5 = (uint64_t *)v4;
  if (v4)
  {
    *(_OWORD *)(v4 + 16) = 0u;
    *(_OWORD *)(v4 + 32) = 0u;
    *(_OWORD *)v4 = 0u;
    *(_QWORD *)(v4 + 48) = a1;
    v14 = v4;
    switch(a2)
    {
      case 0u:
        if (!mfs_Downsample__Resize(v4, 7u))
          goto LABEL_18;
        v6 = 0;
        v7 = *v5;
        do
        {
          *(_DWORD *)(v7 + v6 * 4) = mfs_CoeffCorrFast2[v6];
          ++v6;
        }
        while (v6 != 8);
        break;
      case 1u:
        if (!mfs_Downsample__Resize(v4, 0x19u))
          goto LABEL_18;
        v8 = 0;
        v9 = *v5;
        do
        {
          *(_DWORD *)(v9 + v8 * 4) = mfs_CoeffStage1Fast[v8];
          ++v8;
        }
        while (v8 != 26);
        break;
      case 2u:
        if (!mfs_Downsample__Resize(v4, 5u))
          goto LABEL_18;
        v10 = 0;
        v11 = *v5;
        do
        {
          *(_DWORD *)(v11 + v10 * 4) = mfs_CoeffStage2[v10];
          ++v10;
        }
        while (v10 != 5);
        break;
      case 3u:
        if (!mfs_Downsample__Resize(v4, 3u))
        {
LABEL_18:
          mfs_Downsample__Remove(&v14);
          return 0;
        }
        v12 = *v5;
        *(_QWORD *)v12 = 0x3F11D5D3BD8FDCAALL;
        *(_DWORD *)(v12 + 8) = 1058133459;
        break;
      default:
        return v5;
    }
  }
  return v5;
}

uint64_t mfs_Downsample__VectorNC(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  int *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  int v38;
  int *v39;
  unsigned int v40;

  if (!a1 || !a2 || !a3 || a5 < a4)
    return 1;
  v9 = *(_DWORD *)(a2 + 12) - 1;
  if (v9 < a4 || v9 < a5)
    return 1;
  v12 = a5 - a4 + 1;
  if (*(_DWORD *)(*a3 + 12) < v12 >> 1)
    mfs_Vect__Resize(*a3, v12 >> 1);
  v13 = *(_DWORD *)(a1 + 44);
  v14 = 2 * v13;
  if (v13 >= 1)
  {
    v15 = a4 - v14 + 1;
    v16 = *(_QWORD *)(a1 + 8);
    v17 = *(_QWORD *)(a1 + 16);
    v18 = *(unsigned int *)(a1 + 40);
    v19 = v14 + 1;
    do
    {
      if ((v15 & 0x80000000) != 0)
        v20 = 0;
      else
        v20 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8 * v15);
      *(float *)(v16 + 4 * v18) = (float)v20;
      v15 += 2;
      v18 = *(unsigned int *)(v17 + 4 * v18);
      *(_DWORD *)(a1 + 40) = v18;
      --v19;
    }
    while (v19 > 2);
  }
  v21 = *(_QWORD *)(a2 + 24);
  v22 = (_QWORD *)(v21 + 8 * a4);
  v23 = *(_QWORD **)(*a3 + 24);
  v24 = (int *)(v21 + 8 * (a4 + v14 - 1));
  v25 = *(_DWORD *)(*a3 + 12) - v13;
  if (v25 >= 1)
  {
    v26 = v25 + 1;
    while (1)
    {
      *v23 = *v22;
      v27 = *(_DWORD *)v23 + mfs_Downsample__InterpolateBetweenTwoSamples(a1, *v24);
      *(_DWORD *)v23 = v27;
      v28 = 65534;
      if (v27 > 65534)
        goto LABEL_23;
      if (v27 <= -65537)
        break;
LABEL_24:
      ++v23;
      v22 += 2;
      v24 += 4;
      if (--v26 <= 1)
      {
        v13 = *(_DWORD *)(a1 + 44);
        v14 = 2 * v13;
        goto LABEL_26;
      }
    }
    v28 = -65536;
LABEL_23:
    *(_DWORD *)v23 = v28;
    goto LABEL_24;
  }
LABEL_26:
  v29 = v14 + a5;
  v30 = *(_DWORD *)(a2 + 12);
  if (v29 <= v30)
  {
    if (v13 >= 1)
    {
      v36 = v13 + 1;
      do
      {
        v37 = *v22;
        v22 += 2;
        *v23 = v37;
        LODWORD(v37) = *v24;
        v24 += 4;
        *(_DWORD *)v23++ += mfs_Downsample__InterpolateBetweenTwoSamples(a1, v37);
        --v36;
      }
      while (v36 > 1);
    }
  }
  else
  {
    if ((int)(v30 + ~a5) >= 1)
    {
      v31 = v30 - a5;
      do
      {
        v32 = *v22;
        v22 += 2;
        *v23 = v32;
        LODWORD(v32) = *v24;
        v24 += 4;
        *(_DWORD *)v23++ += mfs_Downsample__InterpolateBetweenTwoSamples(a1, v32);
        --v31;
      }
      while (v31 > 1);
      v13 = *(_DWORD *)(a1 + 44);
      v30 = *(_DWORD *)(a2 + 12);
    }
    v33 = v13 + a5 - v30;
    if (v33 >= 1)
    {
      v34 = v33 + 1;
      do
      {
        v35 = *v22;
        v22 += 2;
        *v23 = v35;
        *(_DWORD *)v23++ += mfs_Downsample__InterpolateBetweenTwoSamples(a1, 0);
        --v34;
      }
      while (v34 > 1);
    }
  }
  v38 = *(_DWORD *)(*a3 + 12);
  if (v38 >= 1)
  {
    v39 = *(int **)(*a3 + 24);
    v40 = v38 + 1;
    do
    {
      *v39 /= 2;
      v39 += 2;
      --v40;
    }
    while (v40 > 1);
  }
  return 1;
}

uint64_t mfs_Downsample__InterpolateBetweenTwoSamples(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  _DWORD *v7;
  int *v8;
  float v9;
  uint64_t v10;
  float v11;
  double v12;
  BOOL v13;
  double v14;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(unsigned int *)(a1 + 40);
  v4 = *(unsigned int *)(a1 + 44);
  *(float *)(v2 + 4 * v3) = (float)a2;
  if ((int)v4 < 1)
  {
    v9 = 0.0;
  }
  else
  {
    v5 = v3 + 1;
    v6 = *(_QWORD *)(a1 + 24);
    v7 = *(_DWORD **)a1;
    v8 = (int *)(v6 + 4 * ((int)v3 + 1 + *(_DWORD *)(a1 + 32)));
    v9 = 0.0;
    do
    {
      v10 = *v8--;
      v11 = *(float *)(v2 + 4 * v10) + *(float *)(v2 + 4 * *(int *)(v6 + 4 * v5));
      LODWORD(v10) = *v7++;
      v9 = v9 + (float)(v11 * *(float *)&v10);
      ++v5;
      --v4;
    }
    while (v4);
  }
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 4 * v3);
  v12 = v9;
  v13 = v9 < 0.0;
  v14 = 0.5;
  if (v13)
    v14 = -0.5;
  return (int)(v14 + v12);
}

uint64_t log_wsola_Diag(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  int v4;

  v3 = a3 - 1;
  do
    v4 = *(unsigned __int8 *)++v3;
  while (v4 == 10);
  return log_VOutText(*(_QWORD *)(a1 + 32), (uint64_t)"SYNTH_BET4", (a2 + 2), 0, v3);
}

uint64_t log_wsola_Error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;

  return log_OutPublic(*(_QWORD *)(a1 + 32), (uint64_t)"SYNTH_BET4", a2, 0, a5, a6, a7, a8, v9);
}

uint64_t mfs_WSOLA__SetWindowOverlap(unsigned __int16 *a1, int a2)
{
  unint64_t v3;
  int v4;
  int v5;
  signed __int16 v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  uint64x2_t v18;
  uint64_t v19;
  int64x2_t v20;
  int32x2_t v21;
  double v22;
  float v23;
  float v24;
  float64x2_t v26;
  int64x2_t v27;
  float64x2_t v28;
  uint64x2_t v29;
  float64x2_t __x;
  double v31;
  int32x2_t v32;
  int64x2_t v33;

  a1[1] = a2;
  v3 = 274877907 * *a1 * a2;
  v4 = (v3 >> 63) + (SHIDWORD(v3) >> 6);
  a1[2] = v4;
  a1[8] = 2 * v4;
  a1[9] = v4;
  v5 = (__int16)a1[6];
  v6 = 2 * v5 - v4;
  if (v5 < (__int16)v4)
    v6 = a1[6];
  a1[16] = v6;
  v7 = 2 * (v5 + (__int16)(2 * v4)) - (__int16)v4 + v6;
  *((_DWORD *)a1 + 7) = v7;
  v8 = *((_QWORD *)a1 + 7);
  if (!v8
    || v7 <= *(_DWORD *)(v8 + 12)
    || (v9 = 2164269066, mfs_Vect__Resize(v8, v7) == 1)
    && mfs_Vect__Resize(*((_QWORD *)a1 + 8), *((_DWORD *)a1 + 7)) == 1
    && mfs_Vect__Resize(*((_QWORD *)a1 + 9), *((_DWORD *)a1 + 7) >> 1) == 1
    && mfs_Vect__Resize(*((_QWORD *)a1 + 10), *((_DWORD *)a1 + 7) >> 1) == 1
    && mfs_Vect__Resize(*((_QWORD *)a1 + 11), *((_DWORD *)a1 + 7) >> 2) == 1
    && mfs_Vect__Resize(*((_QWORD *)a1 + 12), *((_DWORD *)a1 + 7) >> 2) == 1)
  {
    v10 = *((_QWORD *)a1 + 5);
    if (v10)
    {
      v11 = (__int16)a1[2];
      v12 = 2 * v11;
      v13 = heap_Realloc(*((uint64_t **)a1 + 41), v10, (2 * v11));
      if (!v13)
        return 2164269066;
      v14 = v13;
      *((_QWORD *)a1 + 5) = v13;
      if (v11 >= 1)
      {
        v15 = 0;
        v16 = (double)(__int16)a1[2];
        if (v12 <= 1)
          v17 = 1;
        else
          v17 = v12;
        v29 = (uint64x2_t)vdupq_n_s64(v17 - 1);
        v18 = (uint64x2_t)xmmword_214F962F0;
        v27 = vdupq_n_s64(2uLL);
        v28 = (float64x2_t)vdupq_n_s64(0x400921FB54442D11uLL);
        v19 = ((int)v17 + 1) & 0x1FFFELL;
        v26 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v16, 0);
        do
        {
          v33 = (int64x2_t)v18;
          v20 = (int64x2_t)vcgeq_u64(v29, v18);
          v21.i32[0] = v15;
          v21.i32[1] = v15 + 1;
          v32 = vmovn_s64(v20);
          __x = vdivq_f64(vmulq_f64(vcvtq_f64_f32(vcvt_f32_s32(v21)), v28), v26);
          v31 = cos(__x.f64[1]);
          v22 = cos(__x.f64[0]);
          if ((v32.i8[0] & 1) != 0)
          {
            v23 = (1.0 - v22) * 0.5;
            *(float *)(v14 + 4 * v15) = v23;
          }
          if ((v32.i8[4] & 1) != 0)
          {
            v24 = (1.0 - v31) * 0.5;
            *(float *)(v14 + 4 * v15 + 4) = v24;
          }
          v15 += 2;
          v18 = (uint64x2_t)vaddq_s64(v33, v27);
        }
        while (v19 != v15);
      }
    }
    return 0;
  }
  return v9;
}

_WORD *mfs_WSOLA__SetTimeScaleFactor(_WORD *result, int a2)
{
  int v2;
  int v3;

  if (a2 >= 1)
  {
    v2 = (__int16)result[9];
    v3 = v2 * (unsigned __int16)a2 / 100;
    result[10] = v3;
    result[7] = (__int16)v3 / v2;
    result[17] = result[14] - v3;
  }
  return result;
}

uint64_t mfs_WSOLA__Create(uint64_t a1, __int16 a2)
{
  _QWORD *v4;
  uint64_t v5;
  unsigned __int16 *v6;
  unsigned int v7;
  unsigned int v8;
  signed int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unsigned __int16 v24;
  uint64_t v26;

  v4 = *(_QWORD **)(a1 + 8);
  v5 = heap_Calloc(v4, 336, 1);
  v6 = (unsigned __int16 *)v5;
  v26 = v5;
  if (v5)
  {
    *(_QWORD *)(v5 + 320) = a1;
    *(_QWORD *)(v5 + 328) = v4;
    *(_WORD *)v5 = a2;
    *(_DWORD *)(v5 + 312) = 0;
    if ((mfs_WSOLA__SetWindowOverlap((unsigned __int16 *)v5, 10) & 0x80000000) == 0)
    {
      *((_DWORD *)v6 + 2) = 4;
      v7 = 33555 * (*v6 >> 1);
      v8 = v7 >> 22;
      v6[6] = *v6 / 0xFAu;
      v9 = (__int16)v6[9];
      if ((int)(v7 >> 22) >= v9)
        LOWORD(v8) = 2 * (v7 >> 22) - v9;
      v6[16] = v8;
      v10 = 2 * ((__int16)v6[8] + (v7 >> 22)) - (__int16)v6[2] + (__int16)v8;
      *((_DWORD *)v6 + 7) = v10;
      v11 = *((_QWORD *)v6 + 7);
      if (v11 && v10 > *(_DWORD *)(v11 + 12))
      {
        if (mfs_Vect__Resize(v11, v10) != 1
          || mfs_Vect__Resize(*((_QWORD *)v6 + 8), *((_DWORD *)v6 + 7)) != 1
          || mfs_Vect__Resize(*((_QWORD *)v6 + 9), *((_DWORD *)v6 + 7) >> 1) != 1
          || mfs_Vect__Resize(*((_QWORD *)v6 + 10), *((_DWORD *)v6 + 7) >> 1) != 1
          || mfs_Vect__Resize(*((_QWORD *)v6 + 11), *((_DWORD *)v6 + 7) >> 2) != 1
          || mfs_Vect__Resize(*((_QWORD *)v6 + 12), *((_DWORD *)v6 + 7) >> 2) != 1)
        {
          goto LABEL_24;
        }
        v10 = *((_DWORD *)v6 + 7);
      }
      v12 = mfs_Vect__Create((uint64_t)v4, v10);
      *((_QWORD *)v6 + 7) = v12;
      if (v12)
      {
        v13 = mfs_Vect__Create((uint64_t)v4, *((_DWORD *)v6 + 7));
        *((_QWORD *)v6 + 8) = v13;
        if (v13)
        {
          v14 = mfs_Vect__Create((uint64_t)v4, *((_DWORD *)v6 + 7) >> 1);
          *((_QWORD *)v6 + 9) = v14;
          if (v14)
          {
            v15 = mfs_Vect__Create((uint64_t)v4, *((_DWORD *)v6 + 7) >> 1);
            *((_QWORD *)v6 + 10) = v15;
            if (v15)
            {
              v16 = mfs_Vect__Create((uint64_t)v4, *((_DWORD *)v6 + 7) >> 2);
              *((_QWORD *)v6 + 11) = v16;
              if (v16)
              {
                v17 = mfs_Vect__Create((uint64_t)v4, *((_DWORD *)v6 + 7) >> 2);
                *((_QWORD *)v6 + 12) = v17;
                if (v17)
                {
                  mfs_Vect__Clear(*((_QWORD *)v6 + 7));
                  mfs_Vect__Clear(*((_QWORD *)v6 + 8));
                  mfs_Vect__Clear(*((_QWORD *)v6 + 9));
                  mfs_Vect__Clear(*((_QWORD *)v6 + 10));
                  mfs_Vect__Clear(*((_QWORD *)v6 + 11));
                  mfs_Vect__Clear(*((_QWORD *)v6 + 12));
                  v18 = *((_DWORD *)v6 + 7);
                  v19 = *((_QWORD *)v6 + 8);
                  *(_DWORD *)(*((_QWORD *)v6 + 7) + 12) = v18;
                  *(_DWORD *)(v19 + 12) = v18;
                  v20 = *((_QWORD *)v6 + 10);
                  *(_DWORD *)(*((_QWORD *)v6 + 9) + 12) = v18 >> 1;
                  *(_DWORD *)(v20 + 12) = v18 >> 1;
                  v18 >>= 2;
                  v21 = *((_QWORD *)v6 + 12);
                  *(_DWORD *)(*((_QWORD *)v6 + 11) + 12) = v18;
                  *(_DWORD *)(v21 + 12) = v18;
                  v22 = mfs_Downsample__Generate((uint64_t)v4, 0);
                  *((_QWORD *)v6 + 15) = v22;
                  if (v22)
                  {
                    v23 = heap_Calloc(v4, 128, 4);
                    *((_QWORD *)v6 + 18) = v23;
                    if (v23)
                    {
                      if ((WSOLA__CreateOLAWindow_0((uint64_t)v6) & 0x80000000) == 0)
                      {
                        v24 = v6[9];
                        v6[10] = v24;
                        v6[7] = 1;
                        v6[17] = v6[14] - v24;
                        mfs_WSOLA__Initialise((uint64_t)v6);
                        return (uint64_t)v6;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_24:
    mfs_WSOLA__Remove(&v26);
    return v26;
  }
  return (uint64_t)v6;
}

_QWORD *mfs_WSOLA__Remove(uint64_t *a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *result;

  v2 = *(_QWORD **)(*a1 + 328);
  mfs_Vect__Remove((uint64_t *)(*a1 + 56));
  mfs_Vect__Remove((uint64_t *)(*a1 + 64));
  mfs_Vect__Remove((uint64_t *)(*a1 + 72));
  mfs_Vect__Remove((uint64_t *)(*a1 + 80));
  mfs_Vect__Remove((uint64_t *)(*a1 + 88));
  mfs_Vect__Remove((uint64_t *)(*a1 + 96));
  v3 = *a1;
  if (*(_QWORD *)(*a1 + 40))
  {
    heap_Free(v2, *(_QWORD *)(*a1 + 40));
    v3 = *a1;
  }
  if (*(_QWORD *)(v3 + 120))
  {
    mfs_Downsample__Remove((uint64_t *)(v3 + 120));
    v3 = *a1;
  }
  if (*(_QWORD *)(v3 + 144))
  {
    heap_Free(v2, *(_QWORD *)(v3 + 144));
    v3 = *a1;
  }
  result = heap_Free(v2, v3);
  *a1 = 0;
  return result;
}

uint64_t WSOLA__CreateOLAWindow_0(uint64_t a1)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64x2_t v9;
  uint64_t v10;
  int64x2_t v11;
  int32x2_t v12;
  double v13;
  float v14;
  float v15;
  float64x2_t v17;
  int64x2_t v18;
  float64x2_t v19;
  uint64x2_t v20;
  float64x2_t __x;
  double v22;
  int32x2_t v23;
  int64x2_t v24;

  v2 = *(__int16 *)(a1 + 4);
  v3 = 2 * v2;
  v4 = heap_Alloc(*(_QWORD *)(a1 + 328), 4 * (2 * v2));
  *(_QWORD *)(a1 + 40) = v4;
  if (!v4)
    return 2164269066;
  if (v2 >= 1)
  {
    v5 = v4;
    v6 = 0;
    v7 = (double)*(__int16 *)(a1 + 4);
    if (v3 <= 1)
      v8 = 1;
    else
      v8 = v3;
    v20 = (uint64x2_t)vdupq_n_s64(v8 - 1);
    v9 = (uint64x2_t)xmmword_214F962F0;
    v18 = vdupq_n_s64(2uLL);
    v19 = (float64x2_t)vdupq_n_s64(0x400921FB54442D11uLL);
    v10 = ((int)v8 + 1) & 0x1FFFELL;
    v17 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v7, 0);
    do
    {
      v24 = (int64x2_t)v9;
      v11 = (int64x2_t)vcgeq_u64(v20, v9);
      v12.i32[0] = v6;
      v12.i32[1] = v6 + 1;
      v23 = vmovn_s64(v11);
      __x = vdivq_f64(vmulq_f64(vcvtq_f64_f32(vcvt_f32_s32(v12)), v19), v17);
      v22 = cos(__x.f64[1]);
      v13 = cos(__x.f64[0]);
      if ((v23.i8[0] & 1) != 0)
      {
        v14 = (1.0 - v13) * 0.5;
        *(float *)(v5 + 4 * v6) = v14;
      }
      if ((v23.i8[4] & 1) != 0)
      {
        v15 = (1.0 - v22) * 0.5;
        *(float *)(v5 + 4 * v6 + 4) = v15;
      }
      v6 += 2;
      v9 = (uint64x2_t)vaddq_s64(v24, v18);
    }
    while (v10 != v6);
  }
  return 0;
}

double mfs_WSOLA__Initialise(uint64_t a1)
{
  uint64_t v1;
  double result;

  v1 = a1;
  mfs_Vect__Reset(*(_QWORD *)(a1 + 56));
  mfs_Vect__Reset(*(_QWORD *)(v1 + 64));
  mfs_Vect__Reset(*(_QWORD *)(v1 + 72));
  mfs_Vect__Reset(*(_QWORD *)(v1 + 80));
  mfs_Vect__Reset(*(_QWORD *)(v1 + 88));
  mfs_Vect__Reset(*(_QWORD *)(v1 + 96));
  *(_QWORD *)(v1 + 304) = -1;
  *(_DWORD *)(v1 + 312) = 1;
  *(_DWORD *)(v1 + 112) = 0;
  *(_QWORD *)(v1 + 104) = 0;
  *(_BYTE *)(v1 + 281) = 0;
  cstdlib_memset(*(void **)(v1 + 144), 0, 0x200uLL);
  result = 0.0;
  *(_OWORD *)(v1 + 152) = 0u;
  v1 += 152;
  *(_OWORD *)(v1 + 16) = 0u;
  *(_OWORD *)(v1 + 32) = 0u;
  *(_OWORD *)(v1 + 48) = 0u;
  *(_OWORD *)(v1 + 64) = 0u;
  *(_OWORD *)(v1 + 80) = 0u;
  *(_OWORD *)(v1 + 96) = 0u;
  *(_OWORD *)(v1 + 112) = 0u;
  *(_DWORD *)(v1 - 130) = 0;
  *(_WORD *)(v1 - 100) = 0;
  return result;
}

uint64_t mfs_WSOLA__GetBestPositionRelToWindowOffset(__int16 *a1)
{
  int v1;
  int v2;
  __int16 v3;
  __int16 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  float v12;
  float v13;
  int *v14;
  int v15;
  int *v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;

  v1 = a1[6];
  if (v1 < 1)
  {
    v4 = 0;
  }
  else
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    v5 = a1[25];
    v6 = a1[9] + (uint64_t)a1[v5 + 11];
    v7 = *(_QWORD *)&a1[4 * v5 + 28];
    v8 = *(_QWORD *)(*(_QWORD *)&a1[4 * a1[24] + 28] + 24);
    v9 = *(_QWORD *)(v7 + 24) + 8 * v6;
    v10 = a1[16];
    v11 = a1[8];
    v12 = 0.0;
    do
    {
      v13 = 0.0;
      if (v11 >= 1)
      {
        v14 = (int *)(v8 + 8 * (v2 - v1 + v10));
        v15 = v11;
        v16 = (int *)v9;
        do
        {
          v18 = *v14;
          v14 += 2;
          v17 = v18;
          v19 = *v16;
          v16 += 2;
          v13 = v13 + (float)(v19 * v17);
          v20 = (unsigned __int16)v15--;
        }
        while (v20 > 1);
      }
      if (v13 > v12)
      {
        v12 = v13;
        v4 = v3;
      }
      v2 = ++v3;
    }
    while (2 * v1 > v3);
  }
  return (__int16)(v4 - v1);
}

uint64_t mfs_WSOLA__GetOutputLength(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v3;
  _BYTE *v4;
  int v5;

  if ((a2 & 0x80) != 0)
    return 0;
  v3 = a1 + a2;
  v5 = *(unsigned __int8 *)(v3 + 152);
  v4 = (_BYTE *)(v3 + 152);
  *a3 = v5 == 2;
  if (v5 == 2)
    *v4 = 0;
  return *(unsigned int *)(*(_QWORD *)(a1 + 144) + 4 * a2);
}

uint64_t mfs_WSOLA__TimeScaleInputBuffer(uint64_t a1, char a2, __int16 *a3, uint64_t a4, _WORD *a5, int *a6, int a7, char *a8, _BYTE *a9)
{
  uint64_t v9;
  _WORD *v10;
  __int16 *v12;
  char v14;
  int v15;
  _DWORD *v16;
  uint64_t *v17;
  int v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  int v27;
  int v28;
  int v29;
  __int16 v30;
  __int16 v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  __int16 v54;
  unsigned __int16 v55;
  int v56;
  uint64_t v57;
  int v58;
  BOOL v59;
  int v60;
  uint64_t v61;
  int v62;
  float v63;
  float v64;
  int *v65;
  int v66;
  int *v67;
  int v68;
  int v69;
  int v70;
  int v71;
  __int16 v72;
  int v73;
  unsigned __int16 v74;
  int v75;
  int v76;
  unsigned __int16 v77;
  unsigned __int16 v78;
  int v79;
  uint64_t v80;
  int v81;
  int v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  float v86;
  float v87;
  int *v88;
  int v89;
  int *v90;
  int v91;
  int v92;
  int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t *v97;
  _DWORD *v98;
  __int16 v99;
  int v100;
  unsigned __int16 v101;
  int v102;
  int v103;
  unsigned __int16 v104;
  uint64_t v105;
  float v106;
  float v107;
  int *v108;
  int v109;
  int *v110;
  int v111;
  int v112;
  int v113;
  unsigned int v114;
  __int16 v115;
  char v116;
  uint64_t v117;
  unsigned int v118;
  int v119;
  int v120;
  int v121;
  int v123;
  int v124;
  const char *v125;
  int *v126;
  uint64_t v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  unsigned int v134;
  int v135;
  int v136;
  int *v137;
  int v138;
  int v139;
  unsigned __int8 *v140;
  int v141;
  int v142;
  int v143;
  const char *v144;
  uint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  int v149;
  int v150;
  uint64_t v151;
  int v152;
  uint64_t v153;
  int *v154;
  int v155;
  float v156;
  int v157;
  float v158;
  double v159;
  double v160;
  int v161;
  uint64_t v162;
  int v163;
  int v164;
  uint64_t v165;
  unsigned __int8 *v166;
  int v167;
  int v168;
  unsigned int v169;
  int v170;
  unsigned int v171;
  int v174;
  uint64_t *v177;
  uint64_t *v178;
  uint64_t *v179;
  __int16 v181;

  v10 = a5;
  v12 = a3;
  v14 = *a8;
  v15 = *(_DWORD *)(a1 + 312);
  if (v15)
  {
    v12 = &a3[*(int *)(a1 + 108)];
    v10 = &a5[*(int *)(a1 + 112)];
  }
  v16 = (_DWORD *)(a1 + 308);
  v17 = (uint64_t *)(a1 + 72);
  v178 = (uint64_t *)(a1 + 88);
  v179 = (uint64_t *)(a1 + 80);
  v177 = (uint64_t *)(a1 + 96);
  v174 = (unsigned __int16)(a7 + 100);
LABEL_4:
  while (2)
  {
    switch(v15)
    {
      case 0:
        mfs_WSOLA__Initialise(a1);
        *(_DWORD *)(a1 + 312) = 1;
        goto LABEL_6;
      case 1:
LABEL_6:
        if (*(unsigned __int16 *)(a1 + 128) == (unsigned __int16)a7)
        {
          v18 = *(_DWORD *)(a1 + 28);
          goto LABEL_28;
        }
        *(_WORD *)(a1 + 128) = a7;
        if (a7)
        {
          v18 = *(_DWORD *)(a1 + 28);
          if ((__int16)v174 < 1)
            goto LABEL_28;
          v28 = *(__int16 *)(a1 + 18);
          v29 = v28 * v174 / 100;
          *(_WORD *)(a1 + 20) = v29;
          *(_WORD *)(a1 + 14) = (__int16)v29 / v28;
          v30 = v18 - v29;
        }
        else
        {
          v31 = *(_WORD *)(a1 + 18);
          *(_WORD *)(a1 + 20) = v31;
          *(_WORD *)(a1 + 14) = 1;
          v18 = *(_DWORD *)(a1 + 28);
          v30 = v18 - v31;
        }
        *(_WORD *)(a1 + 34) = v30;
LABEL_28:
        v32 = *(__int16 *)(a1 + 52);
        *(_WORD *)(a1 + 52) = 1 - v32;
        *(_WORD *)(a1 + 48) = 1 - v32;
        *(_WORD *)(a1 + 50) = v32;
        v33 = *(void **)(*(_QWORD *)(a1 + 56 + 8 * (__int16)(1 - v32)) + 24);
        *(_QWORD *)(a1 + 136) = v33;
        v34 = *(_QWORD *)(a1 + 56 + 8 * v32);
        *(_DWORD *)(a1 + 304) = 0;
        cstdlib_memmove(v33, (const void *)(*(_QWORD *)(v34 + 24) + 8 * (v18 - *(__int16 *)(a1 + 34))), 8 * *(__int16 *)(a1 + 34));
        *(_QWORD *)(a1 + 136) += 8 * *(__int16 *)(a1 + 34);
        *(_DWORD *)(a1 + 312) = 2;
LABEL_29:
        v35 = *v16;
        if (*v16 == -1)
          v35 = *(__int16 *)(a1 + 34);
        v36 = *(_DWORD *)(a1 + 108);
        v37 = *(_DWORD *)(a1 + 28);
        v38 = v37 + v36 - v35;
        if (v38 >= (int)a4)
          v39 = a4;
        else
          v39 = v37 + v36 - v35;
        v40 = v39 - v36 + v35;
        *(_DWORD *)(a1 + 308) = v40;
        if (v39 - v36 >= 1)
        {
          v41 = *(_QWORD *)(a1 + 136);
          v42 = v39 - v36 + 1;
          do
          {
            *(_BYTE *)(v41 + 4) = v14;
            v43 = *v12++;
            *(_DWORD *)v41 = v43;
            v41 += 8;
            --v42;
          }
          while (v42 > 1);
          *(_QWORD *)(a1 + 136) = v41;
        }
        *(_DWORD *)(a1 + 108) = v39;
        if (v38 < (int)a4)
          goto LABEL_44;
        if ((a2 & 1) != 0)
        {
          if (v40 < v37)
          {
            v44 = *(_QWORD *)(a1 + 136);
            v45 = v36 + v37 - v35 - v39;
            do
            {
              *(_BYTE *)(v44 + 4) = v14 | 0x80;
              *(_DWORD *)v44 = 0;
              v44 += 8;
              --v45;
            }
            while (v45);
            *(_QWORD *)(a1 + 136) = v44;
          }
LABEL_44:
          *(_BYTE *)(a1 + 280) = v14;
          *(_QWORD *)v16 = 0x3FFFFFFFFLL;
LABEL_45:
          if (*(_WORD *)(a1 + 128))
          {
            v181 = *(_WORD *)(a1 + 32);
            mfs_Downsample__VectorNC(*(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 56), v17, 0, *(_DWORD *)(*(_QWORD *)(a1 + 56) + 12) - 1);
            mfs_Downsample__VectorNC(*(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 64), v179, 0, *(_DWORD *)(*(_QWORD *)(a1 + 64) + 12) - 1);
            mfs_Downsample__VectorNC(*(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 72), v178, 0, *(_DWORD *)(*(_QWORD *)(a1 + 72) + 12) - 1);
            mfs_Downsample__VectorNC(*(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 80), v177, 0, *(_DWORD *)(*(_QWORD *)(a1 + 80) + 12) - 1);
            v46 = *(__int16 *)(a1 + 32);
            v47 = *(__int16 *)(a1 + 12);
            v48 = v46 - v47 + 3;
            if (v46 >= v47)
              v48 = v46 - v47;
            v49 = v48 >> 2;
            LODWORD(v50) = (__int16)(v48 >> 2) & ~((__int16)(v48 >> 2) >> 31);
            v51 = v50 + ((__int16)(v47 + ((unsigned __int16)(v47 & 0x8000) >> 15)) >> 1);
            v52 = *(_DWORD *)(*(_QWORD *)(a1 + 88) + 12);
            v53 = (__int16)v52;
            v54 = v52 - 1;
            if (v53 <= (__int16)v51)
              LOWORD(v51) = v54;
            if ((int)v50 < (__int16)v51)
            {
              v55 = v51;
              v56 = *(__int16 *)(a1 + 18);
              v57 = *(__int16 *)(a1 + 50);
              v58 = *(__int16 *)(a1 + 2 * v57 + 22);
              v59 = __OFADD__(v58, v56);
              v60 = v58 + v56;
              if (v60 < 0 != v59)
                v60 += 3;
              v61 = *(_QWORD *)(*(_QWORD *)(a1 + 88 + 8 * v57) + 24) + 8 * (v60 >> 2);
              v62 = *(__int16 *)(a1 + 16);
              v50 = (unsigned __int16)v50;
              v63 = 0.0;
              do
              {
                v64 = 0.0;
                if (v62 >= 4)
                {
                  v65 = (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 88 + 8 * *(__int16 *)(a1 + 48)) + 24) + 8 * v50);
                  v66 = (int)((v62 + ((v62 >> 29) & 3)) << 16) >> 18;
                  v67 = (int *)v61;
                  do
                  {
                    v69 = *v65;
                    v65 += 2;
                    v68 = v69;
                    v70 = *v67;
                    v67 += 2;
                    v64 = v64 + (float)(v70 * v68);
                    v71 = (__int16)v66--;
                  }
                  while (v71 > 1);
                }
                if (v64 > v63)
                {
                  v63 = v64;
                  LOWORD(v49) = v50;
                }
                ++v50;
              }
              while (v50 != v55);
            }
            v72 = 2 * v49;
            v73 = (__int16)(2 * v49 - 3) & ~((__int16)(2 * v49 - 3) >> 31);
            v74 = v72 + 3;
            v75 = *(_DWORD *)(*v17 + 12);
            v76 = (__int16)v75;
            v77 = v75 - 1;
            if (v76 <= (__int16)v74)
              v74 = v77;
            if (v73 < (__int16)v74)
            {
              v78 = v74;
              v79 = *(__int16 *)(a1 + 18);
              v80 = *(__int16 *)(a1 + 50);
              v81 = *(__int16 *)(a1 + 2 * v80 + 22);
              v59 = __OFADD__(v81, v79);
              v82 = v81 + v79;
              if (v82 < 0 != v59)
                ++v82;
              v83 = *(_QWORD *)(*(_QWORD *)(a1 + 72 + 8 * v80) + 24) + 8 * (v82 >> 1);
              v84 = *(__int16 *)(a1 + 16);
              v85 = (unsigned __int16)v73;
              v86 = 0.0;
              do
              {
                v87 = 0.0;
                if (v84 >= 2)
                {
                  v88 = (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 72 + 8 * *(__int16 *)(a1 + 48)) + 24) + 8 * v85);
                  v89 = (v84 + ((unsigned __int16)(v84 & 0x8000) >> 15)) << 16 >> 17;
                  v90 = (int *)v83;
                  do
                  {
                    v92 = *v88;
                    v88 += 2;
                    v91 = v92;
                    v93 = *v90;
                    v90 += 2;
                    v87 = v87 + (float)(v93 * v91);
                    v94 = (__int16)v89--;
                  }
                  while (v94 > 1);
                }
                if (v87 > v86)
                {
                  v86 = v87;
                  LOWORD(v73) = v85;
                }
                ++v85;
              }
              while (v85 != v78);
            }
            v95 = a4;
            v96 = v9;
            v97 = v17;
            v98 = v16;
            v99 = 2 * v73;
            v100 = (__int16)(v99 - 3) & ~((__int16)(v99 - 3) >> 31);
            v101 = v99 + 3;
            v102 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 12);
            v103 = (__int16)v102;
            v104 = v102 - 1;
            if (v103 <= (__int16)v101)
              v101 = v104;
            if (v100 < (__int16)v101)
            {
              v105 = (unsigned __int16)v100;
              v106 = 0.0;
              do
              {
                v107 = 0.0;
                if (*(__int16 *)(a1 + 16) >= 1)
                {
                  v108 = (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 56 + 8 * *(__int16 *)(a1 + 48)) + 24) + 8 * v105);
                  v109 = *(__int16 *)(a1 + 16);
                  v110 = (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 56 + 8 * *(__int16 *)(a1 + 50)) + 24)
                               + 8
                               * (*(__int16 *)(a1 + 2 * *(__int16 *)(a1 + 50) + 22) + (uint64_t)*(__int16 *)(a1 + 18)));
                  do
                  {
                    v112 = *v108;
                    v108 += 2;
                    v111 = v112;
                    v113 = *v110;
                    v110 += 2;
                    v107 = v107 + (float)(v113 * v111);
                    v114 = (unsigned __int16)v109--;
                  }
                  while (v114 > 1);
                }
                if (v107 > v106)
                {
                  v106 = v107;
                  LOWORD(v100) = v105;
                }
                ++v105;
              }
              while (v105 != v101);
            }
            log_wsola_Diag(*(_QWORD *)(a1 + 320), 4, (uint64_t)"Best: %d\t%d");
            v115 = v100 + v181 - *(_WORD *)(a1 + 32);
            v16 = v98;
            v17 = v97;
            v9 = v96;
            a4 = v95;
          }
          else
          {
            v115 = *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 50) + 22);
          }
          *(_WORD *)(a1 + 22 + 2 * *(__int16 *)(a1 + 48)) = v115;
          v19 = *(_QWORD *)(*(_QWORD *)(a1 + 56 + 8 * *(__int16 *)(a1 + 50)) + 24)
              + 8 * (*(__int16 *)(a1 + 18) + (uint64_t)*(__int16 *)(a1 + 22 + 2 * *(__int16 *)(a1 + 50)));
          *(_QWORD *)(a1 + 288) = v19;
          *(_QWORD *)(a1 + 296) = *(_QWORD *)(*(_QWORD *)(a1 + 56 + 8 * *(__int16 *)(a1 + 48)) + 24)
                                + 8 * *(__int16 *)(a1 + 22 + 2 * *(__int16 *)(a1 + 48));
          if (*(_WORD *)(a1 + 128))
          {
            v15 = 5;
            *(_DWORD *)(a1 + 312) = 5;
          }
          else
          {
            *(_DWORD *)(a1 + 312) = 4;
LABEL_87:
            v116 = *(_BYTE *)(v19 + 4);
            if (*(_DWORD *)(a1 + 304) == -1)
              *(_DWORD *)(a1 + 304) = 0;
            v117 = v116 & 0x7F;
            v118 = *(unsigned __int8 *)(a1 + 281);
            if (v118 != (_DWORD)v117)
            {
              if ((_DWORD)v117 == 127)
                v119 = 0;
              else
                v119 = v117;
              v120 = v119 + 1;
              v121 = v119 + 2;
              if (v120 == v118 || v121 == v118)
                goto LABEL_100;
              v123 = v117 - 126;
              if (v117 < 0x7E)
                v123 = v117 + 1;
              if (v123 + 1 == v118)
              {
LABEL_100:
                log_wsola_Diag(*(_QWORD *)(a1 + 320), 1, (uint64_t)"WARNING: switch back from PhonID %u to previous PhonID %u");
                v117 = *(unsigned __int8 *)(a1 + 281);
                *(_BYTE *)(*(_QWORD *)(a1 + 288) + 4) = *(_BYTE *)(*(_QWORD *)(a1 + 288) + 4) & 0x80 | v117;
              }
              else
              {
                if (!*(_BYTE *)(a1 + v117 + 152))
                  *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * v117) = 0;
                do
                {
                  *(_BYTE *)(a1 + (unsigned __int16)v118 + 152) = 2;
                  v118 = v118
                       - 127
                       * ((((unsigned __int16)(v118 - ((517 * (unsigned __int16)v118) >> 16)) >> 1)
                         + ((517 * (unsigned __int16)v118) >> 16)) >> 6)
                       + 1;
                }
                while ((_DWORD)v117 != (unsigned __int16)v118);
                *(_BYTE *)(a1 + 281) = v117;
              }
              *(_BYTE *)(a1 + v117 + 152) = 1;
              if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * *(unsigned __int8 *)(a1 + 281)))
              {
                v124 = 1;
                v125 = "ERROR: PhonID %u, restart at length %d";
              }
              else
              {
                v124 = 3;
                v125 = "start output phonID: %d";
              }
              log_wsola_Diag(*(_QWORD *)(a1 + 320), v124, (uint64_t)v125);
            }
            *(_DWORD *)(a1 + 312) = 1;
            v126 = *(int **)(a1 + 288);
            if ((char)v126[1] < 0)
            {
              *a9 = 2;
              *a6 = *(_DWORD *)(a1 + 112);
              v169 = *(unsigned __int8 *)(a1 + 281);
              if (v169 != *(unsigned __int8 *)(a1 + 280))
              {
                do
                {
                  *(_BYTE *)(a1 + (unsigned __int16)v169 + 152) = 2;
                  v169 = v169
                       - 127
                       * ((((unsigned __int16)(v169 - ((517 * (unsigned __int16)v169) >> 16)) >> 1)
                         + ((517 * (unsigned __int16)v169) >> 16)) >> 6)
                       + 1;
                }
                while (*(unsigned __int8 *)(a1 + 280) != (unsigned __int16)v169);
                v169 = *(unsigned __int8 *)(a1 + 280);
              }
              *(_BYTE *)(a1 + v169 + 152) = 2;
              *a8 = *(_BYTE *)(a1 + 281);
LABEL_179:
              *(_DWORD *)(a1 + 112) = 0;
              *(_DWORD *)(a1 + 312) = 0;
              return 0;
            }
            v127 = *(unsigned __int8 *)(a1 + 281);
            if (*(_BYTE *)(a1 + 281))
            {
              v128 = *a6;
              v129 = *(_DWORD *)(a1 + 112);
              v130 = *(_DWORD *)(a1 + 304);
              if (*a6 >= v129 + *(__int16 *)(a1 + 4) - v130)
                v128 = v129 + *(__int16 *)(a1 + 4) - v130;
              v131 = v128 - v129;
              if (v128 - v129 > 1 && LOBYTE(v126[2 * (v128 - v129 - 1) + 1]) != (_DWORD)v127)
              {
                v140 = (unsigned __int8 *)(v126 + 1);
                v141 = 1;
                while (v131 + v141 - 1 >= 1)
                {
                  v142 = *v140;
                  v140 += 8;
                  --v141;
                  if (v142 != (_DWORD)v127)
                  {
                    v132 = 0;
                    v128 = v129 - v141;
                    v15 = 4;
                    *(_DWORD *)(a1 + 312) = 4;
                    v131 = -v141;
                    goto LABEL_116;
                  }
                }
              }
              v132 = 1;
              v15 = 1;
LABEL_116:
              *(_DWORD *)(a1 + 304) = v131 + v130;
              *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * v127) += v131;
              v133 = v128 - *(_DWORD *)(a1 + 112);
              if (v133 >= 1)
              {
                v134 = v133 + 1;
                do
                {
                  v135 = *v126;
                  v126 += 2;
                  *v10++ = v135;
                  --v134;
                }
                while (v134 > 1);
              }
              *(_QWORD *)(a1 + 288) = v126;
              if (v128 >= *a6)
              {
                *a9 = 1;
                *a6 = v128;
                *a8 = *(_BYTE *)(a1 + 281);
                *(_DWORD *)(a1 + 112) = 0;
                if (*(_DWORD *)(a1 + 304) == *(__int16 *)(a1 + 4))
                  goto LABEL_181;
                v170 = 4;
                goto LABEL_183;
              }
              *(_DWORD *)(a1 + 112) = v128;
              if (v132)
                goto LABEL_157;
            }
            else
            {
              v136 = *(__int16 *)(a1 + 4);
              v15 = 1;
              if (*(_WORD *)(a1 + 4))
              {
                v15 = 1;
                if (LOBYTE(v126[2 * v136 - 1]))
                {
                  v137 = v126 - 2;
                  v138 = 1;
                  while (v136 + v138 - 1 >= 1)
                  {
                    v139 = *((unsigned __int8 *)v137 + 12);
                    v137 += 2;
                    --v138;
                    if (v139)
                    {
                      v15 = 4;
                      *(_DWORD *)(a1 + 312) = 4;
                      *(_QWORD *)(a1 + 288) = v137;
                      *(_DWORD *)(a1 + 304) -= v138;
                      goto LABEL_4;
                    }
                  }
                  goto LABEL_158;
                }
              }
            }
          }
          continue;
        }
        *(_DWORD *)(a1 + 108) = 0;
        *a9 = 0;
        *(_BYTE *)(a1 + 280) = v14;
        return 0;
      case 2:
        goto LABEL_29;
      case 3:
        goto LABEL_45;
      case 4:
        v19 = *(_QWORD *)(a1 + 288);
        goto LABEL_87;
      case 5:
        v20 = *(_BYTE *)(*(_QWORD *)(a1 + 288) + 4);
        if (*(_DWORD *)(a1 + 304) == -1)
          *(_DWORD *)(a1 + 304) = 0;
        v21 = v20 & 0x7F;
        v22 = *(unsigned __int8 *)(a1 + 281);
        if (v22 != (_DWORD)v21)
        {
          if ((_DWORD)v21 == 127)
            v23 = 0;
          else
            v23 = v21;
          v24 = v23 + 1;
          v25 = v23 + 2;
          if (v24 == v22 || v25 == v22)
            goto LABEL_22;
          v27 = v21 - 126;
          if (v21 < 0x7E)
            v27 = v21 + 1;
          if (v27 + 1 == v22)
          {
LABEL_22:
            log_wsola_Diag(*(_QWORD *)(a1 + 320), 1, (uint64_t)"ERROR: switch back from PhonID %u to previous PhonID %u");
            v21 = *(unsigned __int8 *)(a1 + 281);
            *(_BYTE *)(*(_QWORD *)(a1 + 288) + 4) = *(_BYTE *)(*(_QWORD *)(a1 + 288) + 4) & 0x80 | v21;
          }
          else
          {
            if (!*(_BYTE *)(a1 + v21 + 152))
              *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * v21) = 0;
            do
            {
              *(_BYTE *)(a1 + (unsigned __int16)v22 + 152) = 2;
              v22 = v22
                  - 127
                  * ((((unsigned __int16)(v22 - ((517 * (unsigned __int16)v22) >> 16)) >> 1)
                    + ((517 * (unsigned __int16)v22) >> 16)) >> 6)
                  + 1;
            }
            while ((_DWORD)v21 != (unsigned __int16)v22);
            *(_BYTE *)(a1 + 281) = v21;
          }
          *(_BYTE *)(a1 + v21 + 152) = 1;
          if (*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * *(unsigned __int8 *)(a1 + 281)))
          {
            v143 = 1;
            v144 = "WARNING: PhonID %u, restart at length %d";
          }
          else
          {
            v143 = 3;
            v144 = "start output phonID: %d";
          }
          log_wsola_Diag(*(_QWORD *)(a1 + 320), v143, (uint64_t)v144);
        }
        *(_DWORD *)(a1 + 312) = 1;
        v145 = *(_QWORD *)(a1 + 288);
        if (*(char *)(v145 + 4) < 0)
        {
          *a9 = 2;
          *a6 = *(_DWORD *)(a1 + 112);
          v171 = *(unsigned __int8 *)(a1 + 281);
          if (v171 != *(unsigned __int8 *)(a1 + 280))
          {
            do
            {
              *(_BYTE *)(a1 + (unsigned __int16)v171 + 152) = 2;
              v171 = v171
                   - 127
                   * ((((unsigned __int16)(v171 - ((517 * (unsigned __int16)v171) >> 16)) >> 1)
                     + ((517 * (unsigned __int16)v171) >> 16)) >> 6)
                   + 1;
            }
            while (*(unsigned __int8 *)(a1 + 280) != (unsigned __int16)v171);
            v171 = *(unsigned __int8 *)(a1 + 280);
          }
          *(_BYTE *)(a1 + v171 + 152) = 2;
          *a8 = *(_BYTE *)(a1 + 281);
          goto LABEL_179;
        }
        v146 = *(unsigned __int8 *)(a1 + 281);
        if (*(_BYTE *)(a1 + 281))
        {
          v147 = *(_DWORD *)(a1 + 304);
          if (*a6 - *(_DWORD *)(a1 + 112) >= *(__int16 *)(a1 + 4) - v147)
            v148 = *(__int16 *)(a1 + 4) - v147;
          else
            v148 = *a6 - *(_DWORD *)(a1 + 112);
          if (v148 >= 2 && *(unsigned __int8 *)(v145 + 8 * (v148 - 1) + 4) != (_DWORD)v146)
          {
            v166 = (unsigned __int8 *)(v145 + 4);
            v167 = 1;
            while (v148 + v167 - 1 >= 1)
            {
              v168 = *v166;
              v166 += 8;
              --v167;
              if (v168 != (_DWORD)v146)
              {
                v149 = 0;
                v148 = -v167;
                v15 = 5;
                *(_DWORD *)(a1 + 312) = 5;
                goto LABEL_148;
              }
            }
          }
          v149 = 1;
          v15 = 1;
LABEL_148:
          *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * v146) += v148;
          v150 = v148 + v147;
          v151 = *(int *)(a1 + 304);
          v152 = *(_DWORD *)(a1 + 112) + v150 - v151;
          *(_DWORD *)(a1 + 112) = v152;
          if (v150 > (int)v151)
          {
            v153 = *(_QWORD *)(a1 + 40);
            v154 = *(int **)(a1 + 296);
            do
            {
              v155 = *(_DWORD *)v145;
              v145 += 8;
              v156 = (float)v155;
              v157 = *v154;
              v154 += 2;
              v158 = (float)(*(float *)(v153 + 4 * v151) * (float)v157)
                   + (float)(*(float *)(v153 + 4 * (v151 + *(__int16 *)(a1 + 4))) * v156);
              v159 = v158;
              if (v158 >= 0.0)
                v160 = 0.5;
              else
                v160 = -0.5;
              *v10++ = (int)(v160 + v159);
              ++v151;
            }
            while (v150 != v151);
            *(_QWORD *)(a1 + 296) = v154;
          }
          *(_QWORD *)(a1 + 288) = v145;
          *(_DWORD *)(a1 + 304) = v150;
          if (v152 >= *a6)
          {
            *a9 = 1;
            *a6 = *(_DWORD *)(a1 + 112);
            *a8 = *(_BYTE *)(a1 + 281);
            *(_DWORD *)(a1 + 112) = 0;
            if (*(_DWORD *)(a1 + 304) == *(__int16 *)(a1 + 4))
            {
LABEL_181:
              *(_DWORD *)(a1 + 304) = 0;
              return 0;
            }
            v170 = 5;
LABEL_183:
            *(_DWORD *)(a1 + 312) = v170;
            return 0;
          }
          if (v149)
          {
LABEL_157:
            *(_DWORD *)(a1 + 304) = 0;
            goto LABEL_158;
          }
        }
        else
        {
          v161 = *(__int16 *)(a1 + 4);
          v15 = 1;
          if (*(_BYTE *)(v145 + 8 * (v161 - 1) + 4))
          {
            v162 = 0;
            v163 = 1;
            while (v161 + v163 - 1 >= 1)
            {
              v164 = *(unsigned __int8 *)(v145 + v162 + 4);
              v162 += 8;
              --v163;
              if (v164)
              {
                v15 = 5;
                *(_DWORD *)(a1 + 312) = 5;
                v165 = *(_QWORD *)(a1 + 296) + v162 - 8;
                *(_QWORD *)(a1 + 288) = v145 + v162 - 8;
                *(_QWORD *)(a1 + 296) = v165;
                *(_DWORD *)(a1 + 304) -= v163;
                goto LABEL_4;
              }
            }
LABEL_158:
            v15 = 1;
          }
        }
        continue;
      default:
        continue;
    }
  }
}

uint64_t ssft_MapTtsegErrToAPI(int a1)
{
  uint64_t result;
  unsigned __int16 v2;

  if ((a1 & 0x80000000) == 0)
    return 0;
  result = a1 & 0x80001FFF;
  if ((int)result <= -2147483393)
  {
    if ((int)result >= -2147483620)
      return 0x80000000;
  }
  else
  {
    if ((int)result > -2147482625)
    {
      if ((result + 2147481600) < 0xD
        || (result + 2147482624) <= 0x16 && ((1 << result) & 0x404001) != 0)
      {
        return result;
      }
      v2 = 2176;
    }
    else
    {
      if ((result + 2147483392) < 0x14 || (_DWORD)result == -2147483136)
        return result;
      v2 = 768;
    }
    if ((_DWORD)result != (v2 | 0x80000000))
      return 0x80000000;
  }
  return result;
}

uint64_t lipsync_ObjOpen(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = 2281070598;
  if (a2)
  {
    v5 = heap_Alloc(a1, 16);
    if (v5)
    {
      v2 = 0;
      *(_QWORD *)(v5 + 8) = a1;
      *(_DWORD *)v5 = 0;
      *a2 = v5;
    }
    else
    {
      return 2281070602;
    }
  }
  return v2;
}

uint64_t lipsync_ObjClose(uint64_t a1)
{
  heap_Free(*(_QWORD **)(a1 + 8), a1);
  return 0;
}

uint64_t lipsync_GetSyncInfo(_WORD *a1, __int16 a2, char *a3, int8x8_t *a4)
{
  uint64_t result;
  int v8;
  unsigned __int16 v9;
  unsigned __int8 *v10;
  int8x8_t v11;
  int v12;
  unsigned __int8 *PhonemeTableByIndex;
  unsigned int v14;
  int NbrOfLhp;
  int v16;

  result = 2281070598;
  if (!a1 || !a3)
    return result;
  a1[1] = 1;
  *a1 = a2;
  if ((int)lipsyncinfo_GetNbrOfLhp() < 2)
  {
LABEL_7:
    if ((int)lipsyncinfo_GetNbrOfLhp() < 2)
      return 2281070607;
    v12 = 1;
    v9 = 1;
    while (1)
    {
      PhonemeTableByIndex = (unsigned __int8 *)lipsyncinfo_GetPhonemeTableByIndex(v12);
      if (lipsyncinfo_HeadsMatchLooselyDiphtongs(a3, PhonemeTableByIndex) == 1)
        break;
      v12 = ++v9;
      if ((int)lipsyncinfo_GetNbrOfLhp() <= v9)
        return 2281070607;
    }
  }
  else
  {
    v8 = 1;
    v9 = 1;
    while (1)
    {
      v10 = (unsigned __int8 *)lipsyncinfo_GetPhonemeTableByIndex(v8);
      if (lipsyncinfo_HeadsMatch(a3, v10) == 1)
        break;
      v8 = ++v9;
      if ((int)lipsyncinfo_GetNbrOfLhp() <= v9)
        goto LABEL_7;
    }
  }
  if (!v9)
    return 2281070607;
  if (v9 == 0xFFFF)
  {
LABEL_14:
    result = 0;
    *a4 = v11;
    return result;
  }
  v14 = (unsigned __int16)a1[1];
  NbrOfLhp = lipsyncinfo_GetNbrOfLhp();
  if (v14 > 3 || NbrOfLhp < v9 || (int)lipsyncinfo_GetNbrOfLhp() <= v9)
    return 2281070607;
  v16 = *(__int16 *)lipsyncinfo_GetMouthPosByIndex(v9);
  result = 2281070607;
  if (v9 == v16)
  {
    v11 = vmovn_s16(*(int16x8_t *)(lipsyncinfo_GetMouthPosByIndex(v9) + 2));
    goto LABEL_14;
  }
  return result;
}

uint64_t TextMime2ve(char *__s1, int *a2, int *a3, _DWORD *a4)
{
  int v8;
  int v10;

  if (a4)
    *a4 = 1;
  if (!__s1)
    goto LABEL_9;
  v8 = *__s1;
  if (!*__s1)
    goto LABEL_10;
  if (!cstdlib_strcmp(__s1, "text/plain;charset=utf-8"))
  {
    v8 = 0;
    v10 = 2;
    if (!a3)
      goto LABEL_12;
    goto LABEL_11;
  }
  if (cstdlib_strcmp(__s1, "text/plain;charset=utf-16"))
  {
    if (cstdlib_strcmp(__s1, "application/synthesis+ssml"))
      return 0;
    if (a4)
      *a4 = 0;
    v8 = 1;
  }
  else
  {
LABEL_9:
    v8 = 0;
  }
LABEL_10:
  v10 = 1;
  if (a3)
LABEL_11:
    *a3 = v10;
LABEL_12:
  if (a2)
    *a2 = v8;
  return 1;
}

uint64_t ve_ttsInitialize(uint64_t a1, uint64_t *__b)
{
  int v3;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  _OWORD *v8;
  _OWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  _OWORD *v14;
  _OWORD *v15;
  uint64_t v16;
  int Interface;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t (*v25)(uint64_t);
  uint64_t NullHandle;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  const void *v30;
  _OWORD __ba[2];
  __int128 v32;
  uint64_t *v33;
  uint64_t v34;
  _QWORD *v35;

  v34 = 0;
  v35 = 0;
  v3 = -2147483638;
  v33 = 0;
  v30 = 0;
  result = 2147483654;
  if (a1 && __b)
  {
    if (*(_WORD *)a1 != 8963 || !*(_QWORD *)(a1 + 16) || !*(_QWORD *)(a1 + 48))
      return ssft_MapTtsegErrToAPI(-2147474688);
    v32 = 0u;
    memset(__ba, 0, sizeof(__ba));
    cstdlib_memset(__b, 0, 0x10uLL);
    cstdlib_memset(__ba, 0, 0x30uLL);
    v6 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(a1 + 16) + 8))(*(_QWORD *)(a1 + 24), 1, 552);
    v7 = v6;
    if (!v6)
      goto LABEL_60;
    *(_DWORD *)v6 = 1933790291;
    v8 = *(_OWORD **)(a1 + 16);
    *(_OWORD *)(v6 + 8) = *v8;
    *(_OWORD *)(v6 + 24) = v8[1];
    v9 = *(_OWORD **)(a1 + 32);
    if (v9)
    {
      *(_OWORD *)(v6 + 72) = *v9;
      *(_OWORD *)(v6 + 88) = v9[1];
    }
    v10 = *(_QWORD *)(a1 + 48);
    *(_OWORD *)(v6 + 104) = *(_OWORD *)v10;
    *(_OWORD *)(v6 + 120) = *(_OWORD *)(v10 + 16);
    *(_QWORD *)(v6 + 136) = *(_QWORD *)(v10 + 32);
    *(_QWORD *)(v6 + 152) = *(_QWORD *)(v10 + 48);
    v11 = *(_QWORD *)(a1 + 56);
    if (v11)
    {
      *(_QWORD *)(v6 + 184) = *(_QWORD *)v11;
      *(_OWORD *)(v6 + 200) = *(_OWORD *)(v11 + 8);
      *(_OWORD *)(v6 + 216) = *(_OWORD *)(v11 + 24);
    }
    v12 = *(_QWORD *)(a1 + 64);
    if (v12)
    {
      *(_OWORD *)(v6 + 280) = *(_OWORD *)v12;
      *(_QWORD *)(v6 + 296) = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(v6 + 304) = 0;
    }
    v13 = *(const void **)(a1 + 80);
    if (v13)
    {
      cstdlib_memcpy((void *)(v6 + 328), v13, 0x18uLL);
      *(_QWORD *)(v7 + 352) = *(_QWORD *)(a1 + 88);
    }
    v14 = *(_OWORD **)(a1 + 112);
    if (v14)
    {
      *(_OWORD *)(v7 + 360) = *v14;
      *(_OWORD *)(v7 + 376) = v14[1];
      *(_OWORD *)(v7 + 392) = v14[2];
    }
    v15 = *(_OWORD **)(a1 + 120);
    if (v15)
    {
      *(_OWORD *)(v7 + 408) = *v15;
      *(_OWORD *)(v7 + 424) = v15[1];
    }
    v16 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(v7 + 64) = v16;
    Interface = heap_cb_Open(v7 + 8, v16, (uint64_t)&v35);
    if ((Interface & 0x80000000) == 0)
    {
      Interface = critsec_cb_ClassOpen(v35, *(_QWORD *)(v7 + 64), v7 + 72, *(_QWORD *)(a1 + 40), (uint64_t)&v34);
      if ((Interface & 0x80000000) == 0)
      {
        Interface = osspi_cb_cache_ClassOpen(v35, *(_QWORD *)(v7 + 64), v34, v7 + 104, *(_QWORD *)(a1 + 72), &v33);
        if ((Interface & 0x80000000) == 0)
        {
          Interface = rsrc_Open(v35, v34, 0, 0, v7 + 440);
          if ((Interface & 0x80000000) == 0)
          {
            InitRsrcFunction(*(_WORD **)(v7 + 440), *(_QWORD *)(v7 + 448), (_QWORD *)(v7 + 456));
            v18 = *(_QWORD *)(v7 + 456);
            *(_QWORD *)(v18 + 64) = v33;
            v19 = *(_QWORD *)(a1 + 8);
            if (!v19)
            {
              v3 = -2147483630;
LABEL_58:
              if (*(_QWORD *)(v7 + 456))
              {
                ve_ttsUnInitialize(v7, 1749240915);
                return ssft_MapTtsegErrToAPI(v3);
              }
LABEL_60:
              if (v33)
                osspi_cb_cache_ClassClose((_QWORD **)v33);
              if (v34)
                critsec_cb_ClassClose(&v34);
              if (v35)
                heap_cb_Close(v35);
              if (v7)
                (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 16) + 24))(*(_QWORD *)(a1 + 24), v7);
              return ssft_MapTtsegErrToAPI(v3);
            }
            LOWORD(__ba[0]) = 3;
            *((_QWORD *)&v32 + 1) = v19;
            Interface = engbrk_GetInterface(0, &v30);
            if ((Interface & 0x80000000) == 0)
            {
              Interface = brk_ClassOpen(*(_WORD **)(v7 + 440), *(_QWORD *)(v7 + 448), v30, (uint64_t)__ba, 0, v7 + 472);
              if ((Interface & 0x80000000) == 0)
              {
                Interface = brk_ObjOpen(0, *(_QWORD *)(v7 + 472));
                if ((Interface & 0x80000000) == 0)
                {
                  Interface = objc_ObjOpen(0, *(_WORD **)(v7 + 440), *(_QWORD *)(v7 + 448), (uint64_t *)(v18 + 48));
                  if ((Interface & 0x80000000) == 0)
                  {
                    cstdlib_memset((void *)(v18 + 384), 0, 0x10uLL);
                    v20 = *(_QWORD **)(a1 + 96);
                    if (v20 && *v20 && *(_QWORD *)(a1 + 104))
                    {
                      v21 = (_QWORD *)heap_Calloc(*(_QWORD **)(v18 + 8), 1, 8);
                      *(_QWORD *)(v18 + 384) = v21;
                      if (!v21)
                        goto LABEL_58;
                      *v21 = **(_QWORD **)(a1 + 96);
                      *(_QWORD *)(v18 + 392) = *(_QWORD *)(a1 + 104);
                    }
                    if (*(_QWORD *)(a1 + 112))
                      v22 = v7 + 360;
                    else
                      v22 = 0;
                    if (*(_QWORD *)(a1 + 120))
                      v23 = v7 + 408;
                    else
                      v23 = 0;
                    thread_cb_ClassOpen((uint64_t)v35, *(_QWORD *)(v7 + 64), v22, v23, *(_QWORD *)(a1 + 128), v18 + 400);
                    Interface = paramc_ObjOpen(0, *(_QWORD *)(v7 + 440), *(_QWORD *)(v7 + 448), v18 + 40);
                    if ((Interface & 0x80000000) == 0)
                    {
                      Interface = log_ClassOpen(*(_WORD **)(v7 + 440), *(_QWORD *)(v7 + 448), 0, (uint64_t *)(v7 + 464));
                      if ((Interface & 0x80000000) == 0)
                      {
                        v24 = (uint64_t *)(v18 + 32);
                        Interface = log_ObjOpen(*(_QWORD *)(v7 + 464), (uint64_t *)(v18 + 32));
                        if ((Interface & 0x80000000) == 0)
                        {
                          v29 = 0;
                          if (*(_QWORD *)(v7 + 328) || *(_QWORD *)(v7 + 336) || *(_QWORD *)(v7 + 344))
                          {
                            v27 = 0;
                            v28 = 0;
                            cstdlib_memset(&v27, 0, 0x10uLL);
                            v27 = v7 + 328;
                            v28 = &VAutoLogSub;
                            log_SubscriberAdd(*v24, v7 + 328, (uint64_t)&VAutoLogSub);
                          }
                          if ((log_GetInterface(1u, &v29) & 0x80000000) == 0)
                          {
                            heap_SetLog(v35);
                            osspi_cb_cache_SetLog((uint64_t)v33, v29, *v24);
                          }
                          Interface = compquery_GetInterface(1u, (_QWORD *)(v7 + 504));
                          if ((Interface & 0x80000000) == 0)
                          {
                            v25 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v7 + 504) + 32);
                            NullHandle = safeh_GetNullHandle();
                            Interface = v25(NullHandle);
                            if ((Interface & 0x80000000) == 0)
                            {
                              Interface = ttseg_GetInterface(3, (_QWORD *)(v7 + 480));
                              if ((Interface & 0x80000000) == 0)
                              {
                                Interface = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(v7 + 480)
                                                                                               + 16))(*(_QWORD *)(v7 + 440), *(_QWORD *)(v7 + 448), v7 + 488);
                                if ((Interface & 0x80000000) == 0)
                                {
                                  Interface = synthstream_GetInterface(1u, (_QWORD *)(v7 + 528));
                                  if ((Interface & 0x80000000) == 0)
                                  {
                                    Interface = lingdb_GetInterface(1u, (_QWORD *)(v7 + 536));
                                    if ((Interface & 0x80000000) == 0)
                                    {
                                      v3 = bet7_parse_multicore_hdr(*(_QWORD *)(v7 + 456));
                                      if ((v3 & 0x80000000) == 0)
                                      {
                                        *__b = v7;
                                        *((_DWORD *)__b + 2) = 1749240915;
                                        return ssft_MapTtsegErrToAPI(v3);
                                      }
                                      goto LABEL_58;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v3 = Interface;
    goto LABEL_58;
  }
  return result;
}

uint64_t ve_ttsUnInitialize(uint64_t a1, int a2)
{
  uint64_t v2;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD **v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _WORD *v20;
  uint64_t v21;
  _QWORD *v23;
  uint64_t v24;

  v2 = 2147483656;
  v23 = 0;
  if (a2 == 1749240915 && *(_DWORD *)a1 == 1933790291)
  {
    if (*(_DWORD *)(a1 + 544))
      return 2147483665;
    if ((InitRsrcFunction(*(_WORD **)(a1 + 440), *(_QWORD *)(a1 + 448), &v23) & 0x80000000) != 0)
      return v2;
    v4 = *(_QWORD **)(a1 + 456);
    v5 = (_QWORD *)v4[1];
    v24 = v4[2];
    v6 = (_QWORD **)v4[8];
    v7 = *(_QWORD *)(a1 + 64);
    *(_DWORD *)a1 = -1933790292;
    v8 = *(_QWORD *)(a1 + 488);
    if (v8)
    {
      v9 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 480) + 24))(v8, *(_QWORD *)(a1 + 496));
      if (v9 < 0)
        goto LABEL_48;
      *(_QWORD *)(a1 + 488) = safeh_GetNullHandle();
      *(_QWORD *)(a1 + 496) = v10;
    }
    else
    {
      v9 = 0;
    }
    v11 = *(_QWORD *)(a1 + 512);
    if (v11)
    {
      v9 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 504) + 40))(v11, *(_QWORD *)(a1 + 520));
      if (v9 < 0)
        goto LABEL_48;
      *(_QWORD *)(a1 + 512) = safeh_GetNullHandle();
      *(_QWORD *)(a1 + 520) = v12;
    }
    v13 = v23;
    if (v23[4])
    {
      heap_SetLog(v5);
      if (v6)
        osspi_cb_cache_SetLog((uint64_t)v6, 0, 0);
      v9 = log_ObjClose(v23[4]);
      if (v9 < 0)
        goto LABEL_48;
      v13 = v23;
      v23[4] = 0;
    }
    v14 = *(_QWORD *)(a1 + 464);
    if (v14)
    {
      v9 = log_ClassClose(v14);
      if (v9 < 0)
        goto LABEL_48;
      *(_QWORD *)(a1 + 464) = 0;
      v13 = v23;
    }
    v15 = v13[6];
    if (v15)
    {
      v9 = objc_ObjClose(v15);
      if (v9 < 0)
        goto LABEL_48;
      v13 = v23;
      v23[6] = 0;
    }
    v16 = v13[5];
    if (v16)
    {
      v9 = paramc_ObjClose(v16);
      if (v9 < 0)
        goto LABEL_48;
      v13 = v23;
      v23[5] = 0;
    }
    v17 = v13[3];
    if (v17)
    {
      v9 = brk_ObjClose(v17);
      if (v9 < 0)
        goto LABEL_48;
      v13 = v23;
      v23[3] = 0;
    }
    v18 = *(_QWORD *)(a1 + 472);
    if (v18)
    {
      v9 = brk_ClassClose(v18);
      if (v9 < 0)
        goto LABEL_48;
      *(_QWORD *)(a1 + 472) = 0;
      v13 = v23;
    }
    if (v13[50])
    {
      v9 = thread_cb_ClassClose(v13 + 50);
      if (v9 < 0)
        goto LABEL_48;
      v13 = v23;
      v23[50] = 0;
    }
    v19 = v13[48];
    if (v19)
    {
      heap_Free((_QWORD *)v13[1], v19);
      v23[48] = 0;
    }
    v20 = *(_WORD **)(a1 + 440);
    if (v20)
    {
      v9 = rsrc_Close(v20, *(_QWORD *)(a1 + 448));
      if (v9 < 0)
        goto LABEL_48;
      *(_QWORD *)(a1 + 440) = safeh_GetNullHandle();
      *(_QWORD *)(a1 + 448) = v21;
    }
    if (!v6 || (v9 = osspi_cb_cache_ClassClose(v6), (v9 & 0x80000000) == 0))
    {
      if (!v24 || (v9 = critsec_cb_ClassClose(&v24), (v9 & 0x80000000) == 0))
      {
        if (!v5 || (v9 = heap_cb_Close(v5), (v9 & 0x80000000) == 0))
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 32))(v7, a1);
          return ssft_MapTtsegErrToAPI(v9);
        }
      }
    }
LABEL_48:
    *(_DWORD *)a1 = 1933790291;
    return ssft_MapTtsegErrToAPI(v9);
  }
  return v2;
}

uint64_t ve_ttsOpen(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int inited;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  void *v98;
  __int128 v99;
  __int128 v100;
  uint64_t v101;
  _OWORD __b[2];
  __int128 v103;
  uint64_t v104;
  _QWORD *v105;

  v8 = 2147483656;
  v104 = 0;
  v105 = 0;
  if (a2 != 1749240915)
    return v8;
  v103 = 0u;
  memset(__b, 0, sizeof(__b));
  v99 = 0u;
  v100 = 0u;
  v101 = 0;
  if (*(_DWORD *)a1 != 1933790291)
    return v8;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"Open : Begin", a6, a7, a8, v95);
  cstdlib_memset(__b, 0, 0x30uLL);
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 16))(a3, 1, 624);
  if (!v13)
    return 2147483658;
  v14 = v13;
  *(_QWORD *)(v13 + 40) = a3;
  v15 = (_QWORD *)(v13 + 48);
  cstdlib_memcpy((void *)(v13 + 48), (const void *)(a1 + 328), 0x18uLL);
  *(_QWORD *)(v14 + 72) = a4;
  ++*(_DWORD *)(a1 + 544);
  v16 = heap_cb_Open(a1 + 8, a3, (uint64_t)&v105);
  if (v16 < 0)
  {
    v87 = v16;
  }
  else
  {
    *(_QWORD *)(v14 + 8) = a1;
    *(_DWORD *)(v14 + 544) = 0;
    *(_QWORD *)(v14 + 552) = 0;
    *(_QWORD *)(v14 + 608) = 0;
    *(_DWORD *)v14 = 1934574154;
    *(_QWORD *)(v14 + 112) = 0x10000000CLL;
    SetSavedMimeTypeforPlainText(v14, 0);
    v23 = brk_ObjOpen((uint64_t)"eng/vocalizerautomotive", *(_QWORD *)(a1 + 472));
    v28 = *(_QWORD *)(a1 + 456);
    if (v23 < 0)
    {
      v87 = v23;
      log_OutPublic(*(_QWORD *)(v28 + 32), (uint64_t)"VEAPI", 18002, (uint64_t)"%s%x", v24, v25, v26, v27, "lhError");
    }
    else
    {
      v29 = critsec_ObjOpen(*(_QWORD *)(v28 + 16), v105, (uint64_t *)(v14 + 80));
      if (v29 < 0)
      {
        v87 = v29;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 18035, (uint64_t)"%s%x", v30, v31, v32, v33, "lherror");
        brk_ObjClose(v104);
      }
      else
      {
        inited = rsrc_Open(v105, *(_QWORD *)(*(_QWORD *)(a1 + 456) + 16), v104, 0, v14 + 16);
        if (inited < 0
          || (v39 = v14 + 32,
              inited = InitRsrcFunction(*(_WORD **)(v14 + 16), *(_QWORD *)(v14 + 24), (_QWORD *)(v14 + 32)),
              inited < 0))
        {
          v87 = inited;
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 18003, (uint64_t)"%s%x", v35, v36, v37, v38, "lhError");
          brk_ObjClose(v104);
          critsec_ObjClose(*(_QWORD *)(v14 + 80));
        }
        else
        {
          v40 = *(_QWORD *)(v14 + 32);
          v41 = *(_QWORD *)(a1 + 456);
          *(_QWORD *)(v40 + 64) = *(_QWORD *)(v41 + 64);
          *(_OWORD *)(v40 + 384) = *(_OWORD *)(v41 + 384);
          *(_QWORD *)(v40 + 400) = *(_QWORD *)(*(_QWORD *)(a1 + 456) + 400);
          *(_DWORD *)(v14 + 88) = 1;
          v42 = *(_QWORD *)(a1 + 464);
          if (v42)
          {
            log_ObjOpen(v42, (uint64_t *)(v40 + 32));
            if (*v15 || *(_QWORD *)(v14 + 56) || *(_QWORD *)(a1 + 344))
            {
              v97 = 0;
              v98 = 0;
              cstdlib_memset(&v97, 0, 0x10uLL);
              v97 = v15;
              v98 = &VAutoLogSub;
              log_SubscriberAdd(*(_QWORD *)(v40 + 32), (uint64_t)v15, (uint64_t)&VAutoLogSub);
            }
          }
          v43 = (uint64_t *)(v40 + 40);
          v44 = paramc_ObjOpen(0, *(_QWORD *)(v14 + 16), *(_QWORD *)(v14 + 24), v40 + 40);
          if (v44 < 0)
          {
            v93 = v44;
            log_OutPublic(*(_QWORD *)(*(_QWORD *)v39 + 32), (uint64_t)"VEAPI", 18004, (uint64_t)"%s%x", v45, v46, v47, v48, "lhError");
            v87 = v93;
          }
          else
          {
            v49 = (uint64_t *)(v40 + 48);
            v50 = objc_ObjOpen(0, *(_WORD **)(v14 + 16), *(_QWORD *)(v14 + 24), (uint64_t *)(v40 + 48));
            if (v50 < 0)
            {
              v94 = v50;
              log_OutPublic(*(_QWORD *)(*(_QWORD *)v39 + 32), (uint64_t)"VEAPI", 18005, (uint64_t)"%s%x", v51, v52, v53, v54, "lhError");
            }
            else
            {
              v55 = paramc_ParamSetUInt(*v43, (uint64_t)"waitfactor", 1u);
              if ((v55 & 0x80000000) == 0)
              {
                v55 = paramc_ParamSetUInt(*v43, (uint64_t)"maxinputlength", 0xFAu);
                if ((v55 & 0x80000000) == 0)
                {
                  v55 = paramc_ParamSetStr(*v43, (uint64_t)"inputmimetype", "text/plain;charset=utf-16");
                  if ((v55 & 0x80000000) == 0)
                  {
                    v55 = paramc_ParamSetStr(*v43, (uint64_t)"lidvoiceswitch", "no");
                    if ((v55 & 0x80000000) == 0)
                    {
                      v60 = paramc_ParamSetInt(*v43, (uint64_t)"phonmapmrkenabled", 0);
                      if (v60 < 0)
                      {
                        v87 = v60;
                        log_OutPublic(*(_QWORD *)(*(_QWORD *)v39 + 32), (uint64_t)"VEAPI", 51020, (uint64_t)"%s%x", v61, v62, v63, v64, "lhError");
                      }
                      else
                      {
                        cstdlib_memset(&v99, 0, 0x28uLL);
                        LOBYTE(v99) = 1;
                        *((_QWORD *)&v99 + 1) = *(_QWORD *)(*(_QWORD *)(v14 + 8) + 528);
                        *(_QWORD *)&v100 = safeh_GetNullHandle();
                        *((_QWORD *)&v100 + 1) = v65;
                        v101 = 0;
                        v66 = objc_RegisterObject(*v49, (uint64_t)"SYNTHSTREAM", &v99);
                        if (v66 < 0)
                        {
                          v87 = v66;
                          log_OutPublic(*(_QWORD *)(*(_QWORD *)v39 + 32), (uint64_t)"VEAPI", 18006, (uint64_t)"%s%x", v67, v68, v69, v70, "lhError");
                        }
                        else
                        {
                          cstdlib_memset(&v99, 0, 0x28uLL);
                          LOBYTE(v99) = 1;
                          *((_QWORD *)&v99 + 1) = *(_QWORD *)(*(_QWORD *)(v14 + 8) + 536);
                          *(_QWORD *)&v100 = safeh_GetNullHandle();
                          *((_QWORD *)&v100 + 1) = v71;
                          v101 = 0;
                          v72 = objc_RegisterObject(*v49, (uint64_t)"LINGDB", &v99);
                          if (v72 < 0)
                          {
                            v87 = v72;
                            log_OutPublic(*(_QWORD *)(*(_QWORD *)v39 + 32), (uint64_t)"VEAPI", 18007, (uint64_t)"%s%x", v73, v74, v75, v76, "lhError");
                          }
                          else
                          {
                            *((_QWORD *)&__b[0] + 1) = ssft_hlp_ProcessPcmStream;
                            *(_QWORD *)&v103 = ssft_hlp_ProcessTaInfoStream;
                            v77 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _OWORD *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a1 + 480) + 32))(*(_QWORD *)(a1 + 488), *(_QWORD *)(a1 + 496), *(_QWORD *)(v14 + 16), *(_QWORD *)(v14 + 24), __b, v14, 0, v14 + 96);
                            if (v77 < 0)
                            {
                              v87 = v77;
                              log_OutPublic(*(_QWORD *)(*(_QWORD *)v39 + 32), (uint64_t)"VEAPI", 18008, (uint64_t)"%s%x", v78, v79, v80, v81, "lhError");
                            }
                            else
                            {
                              v82 = lipsync_ObjOpen((uint64_t)v105, (uint64_t *)(v14 + 608));
                              if ((v82 & 0x80000000) == 0)
                              {
                                *(_QWORD *)a5 = v14;
                                *(_DWORD *)(a5 + 8) = 1750024778;
                                log_OutText(*(_QWORD *)(*(_QWORD *)(v14 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"Open : End", v84, v85, v86, v96);
                                return 0;
                              }
                              v87 = v82;
                              log_OutPublic(*(_QWORD *)(*(_QWORD *)v39 + 32), (uint64_t)"VEAPI", 18011, (uint64_t)"%s%x", v83, v84, v85, v86, "lhError");
                            }
                          }
                        }
                      }
                      goto LABEL_32;
                    }
                  }
                }
              }
              v94 = v55;
              log_OutPublic(*(_QWORD *)(*(_QWORD *)v39 + 32), (uint64_t)"VEAPI", 51020, (uint64_t)"%s%x", v56, v57, v58, v59, "lhError");
            }
            v87 = v94;
          }
        }
      }
    }
  }
LABEL_32:
  if (*(_QWORD *)(v14 + 32))
  {
    ve_ttsClose(v14, 1750024778, v17, v18, v19, v20, v21, v22);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 32))(a3, v14);
    --*(_DWORD *)(a1 + 544);
    if (v105)
      heap_cb_Close(v105);
  }
  log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 18012, 0, v88, v89, v90, v91, v96);
  return ssft_MapTtsegErrToAPI(v87);
}

uint64_t SetSavedMimeTypeforPlainText(uint64_t a1, char *__s1)
{
  uint64_t v4;
  _BOOL4 v5;
  uint64_t result;
  uint64_t v7;
  int v8;
  int v9;

  v9 = 0;
  TextMime2ve(__s1, 0, 0, &v9);
  if (!v9)
    return 1;
  v4 = *(_QWORD *)(a1 + 616);
  if (v4)
  {
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), v4);
    v5 = v9 != 0;
  }
  else
  {
    v5 = 1;
  }
  *(_QWORD *)(a1 + 616) = 0;
  result = 1;
  if (__s1)
  {
    if (v5)
    {
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v8 = cstdlib_strlen(__s1);
      result = heap_Alloc(v7, (v8 + 1));
      *(_QWORD *)(a1 + 616) = result;
      if (result)
      {
        cstdlib_strcpy((char *)result, __s1);
        return 1;
      }
    }
  }
  return result;
}

uint64_t ssft_hlp_ProcessPcmStream(uint64_t a1, char a2, _QWORD *a3, _DWORD *a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  uint64_t *v32;
  int v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint64_t *v38;

  v37 = 0;
  v38 = 0;
  v34 = 0;
  v33 = 0;
  v35 = 0u;
  v36 = 0u;
  if (!*(_QWORD *)(a1 + 480))
  {
    if (*a3)
    {
      v16 = *(_QWORD *)(a1 + 552);
      *((_QWORD *)&v35 + 1) = *a3;
      *((_QWORD *)&v36 + 1) = v16;
      v17 = ssft_hlp_ReadStopFlag(a1, &v33);
      if ((v17 & 0x80000000) != 0)
        return v17;
      if (v33 == 1)
      {
        *(_QWORD *)&v35 = 0;
        *(_QWORD *)&v36 = 0;
      }
      else
      {
        v18 = *a6;
        *(_QWORD *)&v35 = (2 * *a4);
        *(_QWORD *)&v36 = v18;
        ssft_hlp_convertAndCopyInternalMrkRcrdsToApiMrk(a1, (uint64_t)&v34, a5, v18);
      }
      LODWORD(v37) = 16;
      v38 = &v34;
      if ((a2 & 2) != 0)
      {
        v19 = 0xFFFF;
        *(_DWORD *)(a1 + 452) = 0xFFFF;
      }
      else
      {
        v19 = *(_DWORD *)(a1 + 452);
      }
      HIDWORD(v37) = v19;
      v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t *))(a1 + 504))(a1, 1750024778, *(_QWORD *)(a1 + 496), &v37);
      *(_DWORD *)(a1 + 452) = 2;
      if (v20)
      {
        if ((v20 & 0x1FFF) != 0x807)
          return v20 & 0x1FFF | 0x80002000;
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 128))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104));
        ssft_hlp_SetStateInterrupted(a1);
        *a3 = 0;
        *a4 = 0;
        *(_QWORD *)(a1 + 552) = 0;
        v14 = 2147493895;
LABEL_49:
        *a6 = 0;
        return v14;
      }
    }
    if ((a2 & 2) != 0)
    {
      v14 = 0;
      *a3 = 0;
      *a4 = 0;
      return v14;
    }
    v14 = ssft_hlp_ReadStopFlag(a1, &v33);
    if ((v14 & 0x80000000) != 0)
      return v14;
    if (v33 == 1)
    {
      *a3 = 0;
      *a4 = 0;
      *(_QWORD *)(a1 + 552) = 0;
      *(_DWORD *)(a1 + 544) = 0;
      goto LABEL_49;
    }
    v38 = &v34;
    v37 = 8;
    v21 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t *))(a1 + 504))(a1, 1750024778, *(_QWORD *)(a1 + 496), &v37);
    v22 = v21;
    v14 = v21 & 0x1FFF | 0x80002000;
    v23 = v38;
    v24 = v38[2];
    *a3 = v24;
    v25 = (unint64_t)v23[1] >> 1;
    *a4 = v25;
    if (v24 && (_DWORD)v25)
    {
      if (!v21)
      {
        v14 = 0;
        goto LABEL_52;
      }
      if ((v21 & 0x1FFF) != 0x807)
      {
LABEL_48:
        *a3 = 0;
        *a4 = 0;
        *(_QWORD *)(a1 + 552) = 0;
        goto LABEL_49;
      }
    }
    v26 = ssft_hlp_ReadStopFlag(a1, &v33);
    if (v22)
      v27 = v14;
    else
      v27 = v26;
    if (v26 | v33)
    {
      v14 = v27;
    }
    else
    {
      v28 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 128))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104));
      if (!v22)
        LODWORD(v14) = v28;
      v29 = ssft_hlp_SetStateInterrupted(a1);
      if ((int)v14 <= -1 || v29 == 0)
        v14 = v14;
      else
        v14 = v29;
    }
    if ((v14 & 0x80000000) != 0 || !*a3)
      goto LABEL_48;
LABEL_52:
    v32 = v38;
    *(_QWORD *)(a1 + 552) = v38[4];
    v15 = v32[3] / 0x38uLL;
    goto LABEL_7;
  }
  if (*a4 || *a6)
  {
    **(_DWORD **)(a1 + 472) = 16;
    v12 = *(_QWORD *)(a1 + 480);
    *(_QWORD *)(v12 + 8) = (2 * *a4);
    v13 = *a6;
    *(_QWORD *)(v12 + 24) = v13;
    v14 = ssft_hlp_convertAndCopyInternalMrkRcrdsToApiMrk(a1, v12, a5, v13);
    if ((a2 & 2) != 0)
      return v14;
    goto LABEL_5;
  }
  v14 = 0;
  if ((a2 & 2) != 0)
  {
    **(_DWORD **)(a1 + 472) = 2;
    *a3 = 0;
    *a4 = 0;
    goto LABEL_49;
  }
LABEL_5:
  if ((v14 & 0x80000000) == 0)
  {
    *a3 = *(_QWORD *)(*(_QWORD *)(a1 + 480) + 16);
    *a4 = *(_DWORD *)(a1 + 488) >> 1;
    *(_QWORD *)(a1 + 552) = *(_QWORD *)(*(_QWORD *)(a1 + 480) + 32);
    LODWORD(v15) = *(_DWORD *)(a1 + 492) / 0x38u;
LABEL_7:
    *(_DWORD *)(a1 + 544) = v15;
    *a6 = v15;
  }
  return v14;
}

uint64_t ssft_hlp_ProcessTaInfoStream(uint64_t a1, int a2, int a3, const void **a4, unsigned int *a5, void *__src, unsigned int *a7)
{
  uint64_t v10;
  int v11;
  uint64_t result;
  size_t v14;
  uint64_t v15;
  void *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  __int128 *v23;

  v22 = 0;
  v23 = 0;
  v20 = 0u;
  v21 = 0u;
  if (a2 == 8)
  {
    v14 = *a5;
    v15 = *a7;
    *(_QWORD *)&v20 = v14;
    *(_QWORD *)&v21 = v15;
    if ((_DWORD)v14 && *a4)
    {
      cstdlib_memmove(*(void **)(a1 + 520), *a4, v14);
      v15 = *a7;
    }
    v16 = *(void **)(a1 + 536);
    *((_QWORD *)&v20 + 1) = *(_QWORD *)(a1 + 520);
    *((_QWORD *)&v21 + 1) = v16;
    cstdlib_memmove(v16, __src, 40 * v15);
    LODWORD(v22) = 2048;
    v23 = &v20;
    v17 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t *))(a1 + 504))(a1, 1750024778, *(_QWORD *)(a1 + 496), &v22);
    if (v17)
      return v17 & 0x1FFF | 0x80002000;
    else
      return 0;
  }
  else if (a2 == 4)
  {
    v10 = *a7;
    *(_QWORD *)&v20 = *a5;
    *(_QWORD *)&v21 = v10;
    LODWORD(v22) = 1024;
    v23 = &v20;
    v11 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t *, unsigned int *, void *))(a1 + 504))(a1, 1750024778, *(_QWORD *)(a1 + 496), &v22, a5, __src);
    if (v11)
    {
      return v11 & 0x1FFF | 0x80002000;
    }
    else
    {
      v18 = *((_QWORD *)&v20 + 1);
      result = 2147492110;
      if (*((_QWORD *)&v20 + 1))
      {
        v19 = *((_QWORD *)&v21 + 1);
        if (*((_QWORD *)&v21 + 1))
        {
          result = 0;
          *(_QWORD *)(a1 + 512) = *a5;
          *(_QWORD *)(a1 + 528) = *a7;
          *(_QWORD *)(a1 + 520) = v18;
          *(_QWORD *)(a1 + 536) = v19;
        }
      }
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t ve_ttsClose(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  BOOL v9;
  int State;
  int inited;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  int v25;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v31;
  int v33;
  uint64_t v35;
  int v36;
  uint64_t v38;
  int v39;
  uint64_t v41;
  int v42;
  _WORD *v44;
  int v45;
  uint64_t v48;
  _QWORD *v49;

  v8 = 2147483656;
  v49 = 0;
  v9 = a2 != 1750024778 || a1 == 0;
  if (!v9 && *(_DWORD *)a1 == 1934574154)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"Close : Begin", a6, a7, a8, v48);
    HIDWORD(v48) = 0;
    State = ssft_hlp_GetState(a1, (_DWORD *)&v48 + 1);
    if (State < 0)
      return ssft_MapTtsegErrToAPI(State);
    if (HIDWORD(v48) == 1)
    {
      *(_DWORD *)a1 = -1934574155;
      inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v49);
      if ((inited & 0x80000000) == 0)
      {
        v13 = (_QWORD *)v49[1];
        v14 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 456) + 32);
        SetSavedMimeTypeforPlainText(a1, 0);
        if (*(_QWORD *)(a1 + 592))
        {
          v18 = objc_ReleaseObject(v49[6], (uint64_t)"PHONMAP");
          if (v18 < 0)
            inited = v18;
        }
        v19 = *(_QWORD *)(a1 + 608);
        if (v19)
        {
          v20 = lipsync_ObjClose(v19);
          if (v20 < 0 && inited > -1)
            inited = v20;
        }
        v22 = *(_QWORD *)(a1 + 96);
        if (v22)
          inited = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 40))(v22, *(_QWORD *)(a1 + 104));
        v23 = v49;
        v24 = v49[4];
        if (v24)
        {
          v25 = log_ObjClose(v24);
          if (v25 < 0 && inited > -1)
            inited = v25;
          v23 = v49;
          v49[4] = 0;
        }
        v27 = v23[6];
        if (v27)
        {
          v28 = *(_QWORD *)(a1 + 8);
          if (*(_QWORD *)(v28 + 536))
          {
            v29 = objc_UnregisterObject(v27, (uint64_t)"LINGDB");
            if (v29 < 0 && inited > -1)
              inited = v29;
            v28 = *(_QWORD *)(a1 + 8);
            v23 = v49;
          }
          if (*(_QWORD *)(v28 + 528))
          {
            v31 = objc_UnregisterObject(v23[6], (uint64_t)"SYNTHSTREAM");
            if (v31 < 0 && inited > -1)
              inited = v31;
            v23 = v49;
          }
          v33 = objc_ObjClose(v23[6]);
          if (v33 < 0 && inited > -1)
            inited = v33;
          v23 = v49;
          v49[6] = 0;
        }
        v35 = v23[5];
        if (v35)
        {
          v36 = paramc_ObjClose(v35);
          if (v36 < 0 && inited > -1)
            inited = v36;
          v23 = v49;
          v49[5] = 0;
        }
        v38 = v23[3];
        if (v38)
        {
          v39 = brk_ObjClose(v38);
          if (v39 < 0 && inited > -1)
            inited = v39;
          v49[3] = 0;
        }
        v41 = *(_QWORD *)(a1 + 80);
        if (v41)
        {
          v42 = critsec_ObjClose(v41);
          if (v42 < 0 && inited > -1)
            inited = v42;
          *(_QWORD *)(a1 + 80) = 0;
        }
        v44 = *(_WORD **)(a1 + 16);
        if (v44)
        {
          v45 = rsrc_Close(v44, *(_QWORD *)(a1 + 24));
          if (v45 < 0 && inited > -1)
            inited = v45;
          v49 = 0;
        }
        log_OutText(v14, (uint64_t)"VEAPI", 4, 0, (uint64_t)"Close : End", v15, v16, v17, v48);
        --*(_DWORD *)(*(_QWORD *)(a1 + 8) + 544);
        heap_cb_Close(v13);
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 8) + 32))(*(_QWORD *)(a1 + 40), a1);
      }
      return ssft_MapTtsegErrToAPI(inited);
    }
    else
    {
      return 2147483665;
    }
  }
  return v8;
}

uint64_t ssft_hlp_GetState(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  v4 = critsec_Enter(*(_QWORD **)(a1 + 80));
  if ((v4 & 0x80000000) != 0)
  {
    v10 = v4;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18033, (uint64_t)"%s%x", v5, v6, v7, v8, "lhError");
    return v10;
  }
  else
  {
    *a2 = *(_DWORD *)(a1 + 88);
    return critsec_Leave(*(_QWORD **)(a1 + 80));
  }
}

uint64_t ve_ttsSetOutDevice(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  BOOL v9;
  int inited;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  int v19;

  v8 = 2147483656;
  v19 = 0;
  v18 = 0;
  v9 = a2 != 1750024778 || a1 == 0;
  if (!v9 && *(_DWORD *)a1 == 1934574154)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"SetOutDevice : Begin", a6, a7, a8, v18);
    inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v18);
    if (inited < 0)
    {
      v13 = inited;
    }
    else
    {
      if (!a3)
        return 2147483654;
      if (!*(_QWORD *)(a3 + 8))
        return 2147483666;
      v13 = ssft_hlp_LockFromIdle(a1, (uint64_t)"ve_ttsSetOutDevice", 2, &v19);
      if ((v13 & 0x80000000) == 0)
      {
        *(_OWORD *)(a1 + 496) = *(_OWORD *)a3;
        ssft_hlp_Unlock(a1, v19);
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"SetOutDevice : End", v14, v15, v16, v18);
      }
    }
    return ssft_MapTtsegErrToAPI(v13);
  }
  return v8;
}

uint64_t ssft_hlp_LockFromIdle(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  v11 = critsec_Enter(*(_QWORD **)(a1 + 80));
  if ((v11 & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18033, (uint64_t)"%s%s%s%x", v7, v8, v9, v10, "function");
  }
  else
  {
    if (*(_DWORD *)(a1 + 88) == 1)
    {
      *a4 = 1;
      *(_DWORD *)(a1 + 88) = a3;
    }
    else
    {
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18032, (uint64_t)"%s%s", v7, v8, v9, v10, "function");
      LODWORD(v11) = -2147475439;
    }
    v12 = critsec_Leave(*(_QWORD **)(a1 + 80));
    if (v12 >= 0 || (int)v11 <= -1)
      return v11;
    else
      return v12;
  }
  return v11;
}

uint64_t ssft_hlp_Unlock(uint64_t result, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a2)
  {
    v3 = result;
    if ((critsec_Enter(*(_QWORD **)(result + 80)) & 0x80000000) != 0)
    {
      return log_OutPublic(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 32), (uint64_t)"VEAPI", 18033, (uint64_t)"%s%x", v4, v5, v6, v7, "lhError");
    }
    else
    {
      *(_DWORD *)(v3 + 88) = a2;
      return critsec_Leave(*(_QWORD **)(v3 + 80));
    }
  }
  return result;
}

uint64_t ve_ttsProcessPhon2Speech(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int inited;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t (*v22)(uint64_t);
  uint64_t v23;
  int v24;
  unsigned __int16 v25;
  int v26;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t NullHandle;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v8 = 2147483656;
  v30 = 0;
  v29 = 0;
  if (a2 == 1750024778 && a1 != 0)
  {
    v31 = 0;
    v32 = 0;
    if (*(_DWORD *)a1 == 1934574154)
    {
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ProcessPhon2Speech : Begin", a6, a7, a8, v29);
      inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v29);
      if (inited < 0)
        return ssft_MapTtsegErrToAPI(inited);
      inited = ssft_hlp_LockFromIdle(a1, (uint64_t)"ve_ttsProcessPhon2Speech", 3, &v30);
      if (inited < 0)
        return ssft_MapTtsegErrToAPI(inited);
      v16 = -2147475449;
      if (a3)
      {
        v17 = *(_BYTE **)(a3 + 16);
        if (v17)
        {
          v18 = *(_QWORD *)(a3 + 8);
          if (v18)
          {
            if (*(_DWORD *)a3 > 1u)
            {
              v16 = -2147474688;
            }
            else
            {
              if (!*(_QWORD *)(a1 + 504))
              {
                ssft_hlp_Unlock(a1, v30);
                return 2147485824;
              }
              v35 = 0;
              v36 = 0;
              NullHandle = safeh_GetNullHandle();
              v34 = v19;
              v31 = safeh_GetNullHandle();
              v32 = v20;
              if (*v17 == 35 && v17[(v18 - 1)] == 35)
              {
                v21 = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v36);
                if ((v21 & 0x80000000) == 0)
                {
                  v22 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 32);
                  v23 = safeh_GetNullHandle();
                  v24 = v22(v23);
                  if ((v24 & 0x80000000) == 0)
                  {
                    v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t *))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 64))(v31, v32, 192, "text/x-realspeak-phonemes;charset=tts",
                            0,
                            2,
                            &NullHandle);
                    if ((v24 & 0x80000000) == 0)
                    {
                      v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528)
                                                                                            + 112))(NullHandle, v34, &v35, v18);
                      if ((v24 & 0x80000000) == 0)
                      {
                        if ((_DWORD)v18)
                        {
                          v25 = 0;
                          do
                          {
                            v26 = (char)v17[v25];
                            if (v26 < 0)
                              LOBYTE(v26) = ssft_AnsiToOemTable[v17[v25] ^ 0x80];
                            *(_BYTE *)(v35 + v25++) = v26;
                          }
                          while (v18 > v25);
                        }
                        v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8)
                                                                                               + 528)
                                                                                   + 120))(NullHandle, v34, v18);
                      }
                    }
                  }
                  v16 = v24;
                  if (NullHandle)
                    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 72))(NullHandle, v34);
                  if (v16 < 0)
                  {
                    if (v31)
                    {
                      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 40))(v31, v32);
                      v31 = safeh_GetNullHandle();
                      v32 = v28;
                    }
                    goto LABEL_32;
                  }
                  v21 = ssft_hlp_ProcessMessage2Speech(a1, 1, v31, v32);
                }
                v16 = v21;
              }
              else
              {
                v16 = -2147483641;
              }
            }
          }
        }
      }
LABEL_32:
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ProcessPhon2Speech : End", v13, v14, v15, v29);
      if (v30)
        ssft_hlp_Unlock(a1, v30);
      inited = v16;
      return ssft_MapTtsegErrToAPI(inited);
    }
  }
  return v8;
}

uint64_t ssft_hlp_ProcessMessage2Speech(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t (*v14)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t NullHandle;
  uint64_t v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v26;
  int v27;

  v8 = *(_DWORD *)(a1 + 440);
  if ((_DWORD)a2 == 2 || v8 != (_DWORD)a2)
  {
    *(_DWORD *)(a1 + 440) = a2;
    v9 = ssft_hlp_PipelineName(a1, 1, a1 + 120);
    if (v9 < 0)
    {
      v13 = v9;
      v17 = 0;
      *(_DWORD *)(a1 + 440) = v8;
      goto LABEL_16;
    }
  }
  else if ((~*(_DWORD *)(a1 + 112) & 0xC) == 0)
  {
    goto LABEL_7;
  }
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 192))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), a1 + 310, a2);
  if (v10 < 0)
  {
LABEL_14:
    v13 = v10;
    v17 = 0;
    goto LABEL_16;
  }
LABEL_7:
  *(_QWORD *)(a1 + 456) = safeh_GetNullHandle();
  *(_QWORD *)(a1 + 464) = v11;
  *(_QWORD *)(a1 + 480) = 0;
  *(_QWORD *)(a1 + 488) = 0;
  *(_QWORD *)(a1 + 472) = 0;
  if ((_DWORD)a2 == 2)
    v12 = 256;
  else
    v12 = 1;
  *(_DWORD *)(a1 + 452) = 1;
  v10 = ssft_hlp_PcmNotify(a1, v12);
  if (v10 < 0)
    goto LABEL_14;
  v27 = 0;
  v13 = ssft_hlp_ReadStopFlag(a1, &v27);
  if (!(v13 | v27))
  {
    v14 = *(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480)
                                                                                       + 104);
    NullHandle = safeh_GetNullHandle();
    v13 = v14(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), a3, a4, NullHandle, v16);
  }
  v17 = 1;
LABEL_16:
  v18 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 40))(a3, a4);
  if (v13 >= 0)
    v19 = v18;
  else
    v19 = v13;
  if (v17)
  {
    if ((_DWORD)a2 == 2)
      v20 = 512;
    else
      v20 = 2;
    v21 = ssft_hlp_PcmNotify(a1, v20);
    if ((int)v19 >= 0)
      v19 = v21;
    else
      v19 = v19;
  }
  if ((~*(_DWORD *)(a1 + 112) & 0xC) != 0)
  {
    v22 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 192))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), 0, a2);
    if ((int)v19 >= 0)
      v19 = v22;
    else
      v19 = v19;
  }
  if ((v19 & 0x80000000) == 0)
  {
    v26 = 0;
    v23 = ssft_hlp_ReadStopFlag(a1, &v26);
    if (v26 != 1 || v23 <= -1)
      return v23;
    else
      return 2147493895;
  }
  return v19;
}

uint64_t ve_ttsProcessText2Speech(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t NullHandle;
  uint64_t v22;

  v6 = 2147483656;
  NullHandle = safeh_GetNullHandle();
  v22 = v7;
  v20 = 0;
  if (a2 == 1750024778 && a1 && *(_DWORD *)a1 == 1934574154)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ProcessText2Speech : Begin", v8, v9, v10, v18);
    v11 = ssft_hlp_LockFromIdle(a1, (uint64_t)"ve_ttsProcessText2Speech", 3, &v20);
    if (v11 < 0)
      return ssft_MapTtsegErrToAPI(v11);
    v15 = -2147475449;
    if (!a3 || !*(_QWORD *)(a3 + 16) || !*(_QWORD *)(a3 + 8))
      goto LABEL_16;
    if (*(_DWORD *)a3 > 1u)
    {
      v15 = -2147474688;
      goto LABEL_16;
    }
    v16 = SetMimeTypeAccordingToTextFormat(a1, *(_DWORD *)a3);
    if (v16 < 0)
    {
LABEL_13:
      v15 = v16;
LABEL_16:
      log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ProcessText2Speech : End", v12, v13, v14, v19);
      if (v20)
        ssft_hlp_Unlock(a1, v20);
      return ssft_MapTtsegErrToAPI(v15);
    }
    if (*(_QWORD *)(a1 + 504))
    {
      v16 = ssft_hlp_CreateMessageWithText(a1, a3, 0, &NullHandle);
      if ((v16 & 0x80000000) == 0)
        v16 = ssft_hlp_ProcessMessage2Speech(a1, 0, NullHandle, v22);
      goto LABEL_13;
    }
    ssft_hlp_Unlock(a1, v20);
    return 2147485824;
  }
  return v6;
}

uint64_t SetMimeTypeAccordingToTextFormat(uint64_t a1, int a2)
{
  uint64_t Str;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *__s1;

  if (a2 == 1)
  {
    __s1 = 0;
    Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"inputmimetype", &__s1);
    if ((Str & 0x80000000) != 0)
    {
      v18 = Str;
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 51023, (uint64_t)"%s%x", v4, v5, v6, v7, "lhError");
    }
    else
    {
      v8 = SetSavedMimeTypeforPlainText(a1, __s1);
      v13 = *(_QWORD *)(a1 + 32);
      if (v8)
      {
        v18 = paramc_ParamSetStr(*(_QWORD *)(v13 + 40), (uint64_t)"inputmimetype", "application/synthesis+ssml");
        if ((v18 & 0x80000000) != 0)
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 51020, (uint64_t)"%s%x", v14, v15, v16, v17, "lhError");
      }
      else
      {
        v18 = 2147491850;
        log_OutPublic(*(_QWORD *)(v13 + 32), (uint64_t)"VEAPI", 51024, (uint64_t)"%s%x", v9, v10, v11, v12, "lhError");
      }
    }
  }
  else
  {
    v19 = *(char **)(a1 + 616);
    if (v19)
    {
      v18 = paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"inputmimetype", v19);
      if ((v18 & 0x80000000) != 0)
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 51021, (uint64_t)"%s%x", v20, v21, v22, v23, "lhError");
      else
        SetSavedMimeTypeforPlainText(a1, 0);
    }
    else
    {
      return 0;
    }
  }
  return v18;
}

uint64_t ssft_hlp_CreateMessageWithText(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t inited;
  uint64_t (*v12)(uint64_t);
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  const void *v17;
  char *v18;
  uint64_t v19;
  BOOL v20;
  BOOL v21;
  unsigned int v22;
  uint64_t v23;
  char *__s1;
  uint64_t NullHandle;
  uint64_t v27;
  void *__dst;
  uint64_t v29;

  v8 = *(_QWORD *)(a2 + 8);
  v7 = *(const void **)(a2 + 16);
  __dst = 0;
  v29 = 0;
  NullHandle = safeh_GetNullHandle();
  v27 = v9;
  __s1 = 0;
  if (!a4)
    return 2147483655;
  *a4 = safeh_GetNullHandle();
  a4[1] = v10;
  inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v29);
  if ((inited & 0x80000000) != 0)
    return inited;
  v12 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 32);
  v13 = safeh_GetNullHandle();
  v14 = v12(v13);
  if ((v14 & 0x80000000) == 0)
  {
    if ((paramc_ParamGetStr(*(_QWORD *)(v29 + 40), (uint64_t)"inputmimetype", &__s1) & 0x80000000) != 0)
    {
      v18 = "text/plain;charset=utf-16";
      __s1 = "text/plain;charset=utf-16";
      v17 = &aSMS_UTF16;
      v16 = 20;
    }
    else
    {
      v15 = cstdlib_strcmp(__s1, "text/plain;charset=utf-8");
      v16 = v15 ? 20 : 10;
      v17 = v15 ? &aSMS_UTF16 : &aSMS_UTF8;
      v18 = __s1;
    }
    v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *, _QWORD, uint64_t, uint64_t *))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 64))(*a4, a4[1], 192, v18, 0, 2, &NullHandle);
    v20 = a3 != 2 && *(_DWORD *)(a1 + 116) == 2;
    v21 = !v20;
    v22 = v20 ? v16 : 0;
    if ((v14 & 0x80000000) == 0)
    {
      v14 = (*(uint64_t (**)(uint64_t, uint64_t, void **, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528)
                                                                         + 112))(NullHandle, v27, &__dst, v22 + v8);
      if ((v14 & 0x80000000) == 0)
      {
        if (!v21)
          cstdlib_memcpy(__dst, v17, v16);
        cstdlib_memcpy((char *)__dst + v22, v7, v8);
        *(_DWORD *)(a1 + 448) = v22;
        v14 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 120))(NullHandle, v27, v22 + v8);
      }
    }
  }
  v19 = v14;
  if (NullHandle)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 72))(NullHandle, v27);
  if ((v19 & 0x80000000) != 0 && *a4)
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 40))(*a4, a4[1]);
    *a4 = safeh_GetNullHandle();
    a4[1] = v23;
  }
  return v19;
}

uint64_t ve_ttsAnalyzeText(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int Str;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  void *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  char *__s1;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  int v32;
  uint64_t NullHandle;
  uint64_t v34;

  NullHandle = safeh_GetNullHandle();
  v34 = v6;
  v32 = 0;
  v29 = 0;
  v30 = 0;
  __s1 = 0;
  LODWORD(v29) = *(_DWORD *)a3;
  v31 = 0;
  result = 2147483656;
  if (a2 != 1750024778 || !a1 || *(_DWORD *)a1 != 1934574154)
    return result;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ProcessText2Speech : Begin", v7, v8, v9, v26);
  v11 = ssft_hlp_LockFromIdle(a1, (uint64_t)"ve_ttsAnalyzeText", 3, &v32);
  if (v11 < 0)
    return ssft_MapTtsegErrToAPI(v11);
  v15 = -2147475449;
  if (!*(_QWORD *)(a3 + 16) || !*(_QWORD *)(a3 + 8))
    goto LABEL_17;
  if (*(_DWORD *)a3 > 1u)
  {
    v21 = 0;
    v15 = -2147474688;
    goto LABEL_18;
  }
  Str = SetMimeTypeAccordingToTextFormat(a1, *(_DWORD *)a3);
  if (Str < 0
    || (Str = paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"inputmimetype", &__s1), Str < 0))
  {
    v15 = Str;
LABEL_17:
    v21 = 0;
    goto LABEL_18;
  }
  if (!cstdlib_strcmp(__s1, "text/plain;charset=utf-16"))
  {
    v30 = *(_QWORD *)(a3 + 8);
    v22 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
    v23 = v30 + 2;
    goto LABEL_26;
  }
  if (!cstdlib_strcmp(__s1, "text/plain;charset=utf-8") || !cstdlib_strcmp(__s1, "application/synthesis+ssml"))
  {
    v30 = *(_QWORD *)(a3 + 8);
    v22 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
    v23 = v30 + 1;
LABEL_26:
    v24 = (void *)heap_Calloc(v22, 1, v23);
    v21 = (uint64_t)v24;
    v31 = v24;
    if (v24)
    {
      cstdlib_memcpy(v24, *(const void **)(a3 + 16), *(_QWORD *)(a3 + 8));
      if (*(_QWORD *)(a1 + 504))
      {
        v25 = ssft_hlp_CreateMessageWithText(a1, (uint64_t)&v29, 2, &NullHandle);
        if ((v25 & 0x80000000) == 0)
          v25 = ssft_hlp_ProcessMessage2Speech(a1, 2, NullHandle, v34);
        v15 = v25;
      }
      else
      {
        v15 = -2147481472;
      }
    }
    else
    {
      v15 = -2147483638;
    }
    goto LABEL_18;
  }
  log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18023, (uint64_t)"%s%s", v17, v18, v19, v20, "typeOfChar");
  v21 = 0;
  v15 = -2147483641;
LABEL_18:
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsAnalyzeText : End", v12, v13, v14, v27);
  if (v21)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), v21);
  if (v32)
    ssft_hlp_Unlock(a1, v32);
  return ssft_MapTtsegErrToAPI(v15);
}

uint64_t ve_ttsProcessText2SpeechStartingAt(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int Int;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  BOOL v23;
  unint64_t v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  char *v38;
  int v39;
  uint64_t v40;
  char *__src;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t NullHandle;
  uint64_t v49;
  char __s2[8];
  char __dst[64];
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v10 = 2147483656;
  NullHandle = safeh_GetNullHandle();
  v49 = v11;
  v47 = 0;
  v45 = -1;
  v46 = -1;
  v43 = -1;
  v44 = -1;
  v42 = -1;
  __src = 0;
  strcpy(__s2, "unknown");
  HIBYTE(v40) = 0;
  if (a2 == 1750024778 && a1 && *(_DWORD *)a1 == 1934574154)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsProcessText2SpeechStartingAt : Begin", v12, v13, v14, v40);
    v15 = ssft_hlp_LockFromIdle(a1, (uint64_t)"ve_ttsProcessText2SpeechStartingAt", 3, (_DWORD *)&v47 + 1);
    if (v15 < 0)
      return ssft_MapTtsegErrToAPI(v15);
    v16 = -2147475449;
    if (!a3 || !*(_QWORD *)(a3 + 16) || !*(_QWORD *)(a3 + 8))
      goto LABEL_16;
    if (*(_DWORD *)a3 > 1u)
    {
      v16 = -2147474688;
      goto LABEL_16;
    }
    if (*(_QWORD *)(a1 + 504))
    {
      Int = paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"enablerett", &v47);
      if (Int < 0)
      {
        v16 = Int;
        goto LABEL_16;
      }
      v16 = paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"enablerett", 0);
      if (v16 < 0)
      {
LABEL_16:
        paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"enablerett", v47);
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsProcessText2SpeechStartingAt : End", v26, v27, v28, v40);
        if (HIDWORD(v47))
          ssft_hlp_Unlock(a1, SHIDWORD(v47));
        return ssft_MapTtsegErrToAPI(v16);
      }
      v21 = *(unsigned int *)(a4 + 40 * a5 + 8);
      v22 = *(_QWORD *)(a3 + 8);
      v23 = v22 >= v21;
      v24 = v22 - v21;
      if (!v23)
      {
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsProcessText2SpeechStartingAt : TA Index is out of boundary", v18, v19, v20, v40);
        goto LABEL_16;
      }
      *(_DWORD *)(a1 + 560) = *(_DWORD *)a3;
      *(_QWORD *)(a1 + 568) = v24;
      *(_QWORD *)(a1 + 576) = *(_QWORD *)(a3 + 16) + v21;
      v29 = a4 + 40 * a5;
      v30 = *(_QWORD *)(v29 + 16);
      paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"volume", &v46);
      paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"waitfactor", &v45);
      paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"rate", &v44);
      paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"pitch", &v43);
      paramc_ParamGetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"readmode", &v42);
      paramc_ParamGetStr(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"inputmimetype", &__src);
      cstdlib_strcpy(__dst, __src);
      paramc_ParamSetStrPermanent(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"inputmimetype", "text/plain;charset=utf-8");
      paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"lidon", (char *)&v40 + 7);
      if (!*(_QWORD *)(v29 + 16)
        || (*(unsigned int (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 184))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), v30) != 1)
      {
LABEL_42:
        v39 = ssft_hlp_CreateMessageWithText(a1, a1 + 560, 0, &NullHandle);
        if ((v39 & 0x80000000) == 0)
          v39 = ssft_hlp_ProcessMessage2Speech(a1, 0, NullHandle, v49);
        v16 = v39;
        paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"lidon", (char *)&v40 + 7);
        paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"volume", v46);
        paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"audioinsertervolume", v46);
        paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"waitfactor", v45);
        paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"rate", v44);
        paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"audioinserterrate", v44);
        paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"pitch", v43);
        paramc_ParamSetInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"readmode", v42);
        paramc_ParamSetStrPermanent(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"inputmimetype", __dst);
        goto LABEL_16;
      }
      v31 = (char *)(v30 + 64);
      if (cstdlib_strcmp((const char *)(v30 + 64), __s2) && cstdlib_strlen((const char *)(v30 + 64)) != 7)
      {
        if (cstdlib_strlen((const char *)(v30 + 64)) != 3)
          goto LABEL_28;
      }
      else
      {
        v31 = __s2;
      }
      paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"lidon", v31);
LABEL_28:
      v32 = *(_DWORD *)(v30 + 4);
      if (v32 != 9999)
      {
        paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"volume", v32);
        paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"audioinsertervolume", *(_DWORD *)(v30 + 4));
      }
      v33 = *(_DWORD *)(v30 + 20);
      if (v33 != 9999)
        paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"waitfactor", v33);
      v34 = *(_DWORD *)(v30 + 8);
      if (v34 != 9999)
      {
        paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"rate", v34);
        paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"audioinserterrate", *(_DWORD *)(v30 + 8));
      }
      v35 = *(_DWORD *)(v30 + 12);
      if (v35 != 9999)
        paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"pitch", v35);
      v36 = *(_DWORD *)(v30 + 24);
      if (v36 != 9999)
        paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"readmode", v36);
      v37 = *(_DWORD *)(v30 + 28);
      if (v37)
        paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"initcommonbiasvalue", v37);
      v38 = (char *)(v30 + 32);
      if (cstdlib_strlen(v38) == 3)
        paramc_ParamSetStr(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"initcommonbiaslanguage", v38);
      goto LABEL_42;
    }
    ssft_hlp_Unlock(a1, SHIDWORD(v47));
    return 2147485824;
  }
  return v10;
}

uint64_t ve_ttsProcessText2SpeechCooperatively(uint64_t a1, int a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  BOOL v10;
  int inited;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int MessageWithText;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t (*v30)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, __int16 *);
  uint64_t NullHandle;
  uint64_t v32;
  int v33;
  uint64_t (*v34)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, __int16 *);
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;

  result = 2147483656;
  v43 = 0;
  v42 = 0;
  v10 = a2 != 1750024778 || a1 == 0;
  if (!v10 && *(_DWORD *)a1 == 1934574154)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ProcessText2SpeechCooperatively : Begin", a6, a7, a8, v40);
    inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v43);
    if (inited < 0)
    {
      MessageWithText = inited;
    }
    else
    {
      MessageWithText = critsec_Enter(*(_QWORD **)(a1 + 80));
      if ((MessageWithText & 0x80000000) == 0)
      {
        v20 = *(_DWORD *)(a1 + 88);
        if ((v20 - 4) >= 2)
        {
          if (v20 == 1)
          {
            *(_DWORD *)(a1 + 88) = 4;
LABEL_17:
            v21 = critsec_Leave(*(_QWORD **)(a1 + 80));
            if (v21 < 0 && MessageWithText > -1)
              MessageWithText = v21;
            if (MessageWithText < 0)
              return ssft_MapTtsegErrToAPI(MessageWithText);
            if (v20 == 1)
            {
              *a4 = 1;
              *(_DWORD *)a5 = 0;
              *(_QWORD *)(a5 + 8) = 0;
              *(_QWORD *)(a5 + 24) = 0;
              if (!a3 || !*(_QWORD *)(a3 + 16))
              {
                MessageWithText = -2147475449;
                goto LABEL_50;
              }
              MessageWithText = -2147475449;
              if (!*(_QWORD *)(a3 + 8))
                goto LABEL_50;
              if (*(_DWORD *)a3 > 1u)
              {
                MessageWithText = -2147474688;
                goto LABEL_50;
              }
              v26 = SetMimeTypeAccordingToTextFormat(a1, *(_DWORD *)a3);
              if ((v26 & 0x80000000) == 0)
              {
                MessageWithText = ssft_hlp_CreateMessageWithText(a1, a3, 0, (uint64_t *)(a1 + 456));
                if ((MessageWithText & 0x80000000) == 0)
                {
                  v27 = *(_DWORD *)(a1 + 440);
                  if (v27)
                  {
                    *(_DWORD *)(a1 + 440) = 0;
                    v28 = ssft_hlp_PipelineName(a1, 1, a1 + 120);
                    if (v28 < 0)
                    {
                      MessageWithText = v28;
                      *(_DWORD *)(a1 + 440) = v27;
                      goto LABEL_50;
                    }
                  }
                  else if ((~*(_DWORD *)(a1 + 112) & 0xC) == 0)
                  {
                    goto LABEL_51;
                  }
                  v37 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8)
                                                                                               + 480)
                                                                                   + 192))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), a1 + 310, 0);
                  goto LABEL_45;
                }
LABEL_50:
                v42 = 2;
                goto LABEL_51;
              }
LABEL_48:
              MessageWithText = v26;
              goto LABEL_50;
            }
            if (*(_QWORD *)(a5 + 16) && v20 != 6 && (v29 = *(_QWORD *)(a5 + 8)) != 0)
            {
              *(_QWORD *)(a1 + 472) = a4;
              *(_QWORD *)(a1 + 480) = a5;
              *(_DWORD *)(a1 + 488) = v29;
              *(_DWORD *)(a1 + 492) = *(_QWORD *)(a5 + 24);
              paramc_ParamSetUInt(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), (uint64_t)"audiooutputbufsamples", v29 >> 1);
              *a4 = 4;
              *(_DWORD *)a5 = 0;
              *(_QWORD *)(a5 + 8) = 0;
              *(_QWORD *)(a5 + 24) = 0;
              v30 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, __int16 *))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 176);
              NullHandle = safeh_GetNullHandle();
              v33 = v30(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 456), *(_QWORD *)(a1 + 464), NullHandle, v32, &v42);
              MessageWithText = v33;
              if ((v33 & 0x80000000) == 0)
                goto LABEL_51;
              *(_QWORD *)(a5 + 8) = 0;
              *(_QWORD *)(a5 + 24) = 0;
              if ((v33 & 0x1FFF) != 0x807)
                goto LABEL_50;
            }
            else
            {
              *a4 = 32;
              *(_DWORD *)a5 = 0;
              *(_QWORD *)(a5 + 8) = 0;
              *(_QWORD *)(a5 + 24) = 0;
              if (v20 == 6)
              {
                *(_QWORD *)(a1 + 472) = a4;
                *(_QWORD *)(a1 + 480) = a5;
                *(_QWORD *)(a1 + 488) = 0;
                v34 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, __int16 *))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 176);
                v35 = safeh_GetNullHandle();
                MessageWithText = v34(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 456), *(_QWORD *)(a1 + 464), v35, v36, &v42);
                if ((MessageWithText & 0x1FFF) != 0x807)
                {
LABEL_46:
                  if (MessageWithText < 0)
                    goto LABEL_50;
LABEL_51:
                  if ((v42 & 2) != 0)
                  {
                    *a4 = 2;
                    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 528) + 40))(*(_QWORD *)(a1 + 456), *(_QWORD *)(a1 + 464));
                    *(_QWORD *)(a1 + 456) = safeh_GetNullHandle();
                    *(_QWORD *)(a1 + 464) = v38;
                    if ((~*(_DWORD *)(a1 + 112) & 0xC) != 0)
                      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480)
                                                                             + 192))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), 0, 0);
                    if (MessageWithText > -1 && v20 == 6)
                      MessageWithText = -2147473401;
                    ssft_hlp_Unlock(a1, 1);
                  }
                  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ProcessText2SpeechCooperatively : End", v22, v23, v24, v41);
                  return ssft_MapTtsegErrToAPI(MessageWithText);
                }
              }
              else
              {
                v26 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 128))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104));
                if (v26 < 0)
                  goto LABEL_48;
              }
            }
            v37 = ssft_hlp_SetStateInterrupted(a1);
LABEL_45:
            MessageWithText = v37;
            goto LABEL_46;
          }
          if (!a3 && v20 == 6)
            goto LABEL_17;
        }
        else if (!a3)
        {
          goto LABEL_17;
        }
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18032, (uint64_t)"%s%s", v15, v16, v17, v18, "function");
        MessageWithText = -2147475439;
        goto LABEL_17;
      }
      log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18033, (uint64_t)"%s%s%s%x", v15, v16, v17, v18, "function");
    }
    return ssft_MapTtsegErrToAPI(MessageWithText);
  }
  return result;
}

uint64_t ssft_hlp_PipelineName(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t inited;
  int v7;
  int v8;
  int v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  int v13;
  const char *v14;
  uint64_t v16;
  uint64_t v17;
  _OWORD __b[20];
  __int128 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v16 = 0;
  v17 = 0;
  inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v17);
  if ((inited & 0x80000000) != 0)
    return inited;
  if (!a2)
  {
    v20 = 0;
    v19 = 0u;
    memset(__b, 0, sizeof(__b));
    cstdlib_memset(__b, 0, 0x154uLL);
    cstdlib_strcpy((char *)__b, (const char *)a3);
    cstdlib_strcpy((char *)&__b[8] + 8, (const char *)(a3 + 64));
    v7 = *(unsigned __int16 *)(a3 + 96);
    if (v7 == 11)
    {
      v8 = 11025;
    }
    else if (v7 == 22)
    {
      v8 = 22050;
    }
    else
    {
      v8 = 1000 * v7;
    }
    DWORD2(__b[11]) = v8;
    cstdlib_strcpy((char *)&__b[11] + 12, (const char *)(a3 + 98));
    cstdlib_strcpy((char *)&__b[13] + 12, (const char *)(a3 + 130));
    cstdlib_strcpy((char *)&v19 + 8, (const char *)(a3 + 162));
    cstdlib_strcpy((char *)&__b[17] + 4, (const char *)(a3 + 174));
    cstdlib_strcpy((char *)&__b[18] + 4, "pcm");
    inited = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _OWORD *))(*(_QWORD *)(*(_QWORD *)(a1 + 8)
                                                                                             + 504)
                                                                                 + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 512), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 520), *(_QWORD *)(v17 + 24), *(_QWORD *)(v17 + 40), __b);
    if ((inited & 0x80000000) == 0)
    {
      cstdlib_strcpy((char *)a3, (const char *)__b);
      cstdlib_strcpy((char *)(a3 + 64), (const char *)&__b[8] + 8);
      *(_WORD *)(a3 + 96) = DWORD2(__b[11]) / 0x3E8;
      cstdlib_strcpy((char *)(a3 + 98), (const char *)&__b[11] + 12);
      cstdlib_strcpy((char *)(a3 + 130), (const char *)&__b[13] + 12);
      cstdlib_strcpy((char *)(a3 + 162), (const char *)&v19 + 8);
      cstdlib_strcpy((char *)(a3 + 174), (const char *)&__b[17] + 4);
      goto LABEL_10;
    }
    return inited;
  }
LABEL_10:
  LH_utoa(*(unsigned __int16 *)(a3 + 96), (char *)__b, 0xAu);
  cstdlib_strcpy((char *)(a3 + 190), "pipeline/");
  cstdlib_strcat((char *)(a3 + 190), (const char *)a3);
  cstdlib_strcat((char *)(a3 + 190), "/");
  cstdlib_strcat((char *)(a3 + 190), (const char *)(a3 + 64));
  cstdlib_strcat((char *)(a3 + 190), "/");
  cstdlib_strcat((char *)(a3 + 190), (const char *)__b);
  v10 = (const char *)(a3 + 98);
  v9 = *(unsigned __int8 *)(a3 + 98);
  if (*(_BYTE *)(a3 + 98)
    && (v9 != 102 && v9 != 70
     || (*(unsigned __int8 *)(a3 + 99) | 0x20) != 0x75
     || (*(unsigned __int8 *)(a3 + 100) | 0x20) != 0x6C
     || (*(unsigned __int8 *)(a3 + 101) | 0x20) != 0x6C
     || *(_BYTE *)(a3 + 102)))
  {
    cstdlib_strcat((char *)(a3 + 190), "/");
    if (*(_BYTE *)(a3 + 130) && cstdlib_strlen((const char *)(a3 + 130)))
      v10 = (const char *)(a3 + 130);
    cstdlib_strcat((char *)(a3 + 190), v10);
    v11 = (const char *)(a3 + 162);
    if (*(_BYTE *)(a3 + 162)
      && cstdlib_strlen((const char *)(a3 + 162))
      && cstdlib_strcmp((const char *)(a3 + 162), "0.0.0"))
    {
      cstdlib_strcat((char *)(a3 + 190), "/");
    }
    else
    {
      v11 = "";
    }
    cstdlib_strcat((char *)(a3 + 190), v11);
  }
  v13 = *(_DWORD *)(a3 + 320);
  if (v13 == 2)
  {
LABEL_30:
    cstdlib_strcat((char *)(a3 + 190), "/");
    cstdlib_strcat((char *)(a3 + 190), (const char *)(a3 + 174));
    v14 = "/pcm";
    goto LABEL_32;
  }
  if (v13 != 1)
  {
    if (v13)
      return 2147491841;
    goto LABEL_30;
  }
  v14 = "/phon2speech/pcm";
LABEL_32:
  cstdlib_strcat((char *)(a3 + 190), v14);
  v12 = brk_TagQueryEx(*(_QWORD *)(v17 + 24), a3 + 190, (uint64_t)"BROKERSTRING", 1, (uint64_t)&v16);
  if ((v12 & 0x80000000) == 0)
    brk_TagRelease(*(_QWORD *)(v17 + 24), v16);
  return v12;
}

uint64_t ssft_hlp_SetStateInterrupted(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  unsigned int v10;

  v6 = critsec_Enter(*(_QWORD **)(a1 + 80));
  if ((v6 & 0x80000000) != 0)
  {
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18033, (uint64_t)"%s%x", v2, v3, v4, v5, "lhError");
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 88);
    if (v7 > 6)
    {
      v6 = 2147491857;
    }
    else
    {
      v8 = 1 << v7;
      if ((v8 & 7) != 0)
      {
        v6 = 2147491857;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18032, 0, v2, v3, v4, v5, v10);
      }
      else if ((v8 & 0x18) != 0)
      {
        *(_DWORD *)(a1 + 88) = 6;
      }
    }
    critsec_Leave(*(_QWORD **)(a1 + 80));
  }
  return v6;
}

uint64_t ve_ttsSetParamList(uint64_t a1, int a2, _DWORD *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  int inited;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  int *v21;
  int v22;
  int v23;
  const char *v25;
  unsigned int v26;
  int v27;
  const char *v28;
  char *v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  const char *v33;
  uint64_t v34;
  const char *v35;
  char *v36;
  int v37;
  const char *v39;
  uint64_t v40;
  int *v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  int v55;
  char *__src;
  __int16 v57;
  uint64_t v58;
  char v59[128];
  char __dst[64];
  char v61[32];
  __int128 v62;
  __int128 v63;
  char v64[192];
  int v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  v8 = 2147483656;
  v58 = 0;
  v57 = 0;
  __src = 0;
  v55 = 0;
  if (a2 != 1750024778)
    return v8;
  if (!a1)
    return v8;
  v65 = 0;
  memset(v64, 0, sizeof(v64));
  v62 = 0u;
  v63 = 0u;
  memset(v61, 0, sizeof(v61));
  memset(__dst, 0, sizeof(__dst));
  if (*(_DWORD *)a1 != 1934574154)
    return v8;
  LODWORD(v10) = a4;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsSetParamList : Begin", a6, a7, a8, v49);
  if (!a3)
    return 2147483654;
  inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v58);
  if (inited < 0)
    return ssft_MapTtsegErrToAPI(inited);
  cstdlib_memcpy(__dst, (const void *)(a1 + 120), 0x144uLL);
  v17 = *(_DWORD *)(a1 + 112);
  v18 = *(_DWORD *)(a1 + 116);
  if ((~v17 & 0xC) != 0 && (v10 > 1 || *a3 != 20))
    goto LABEL_122;
  if (v64[62])
  {
    v19 = 0;
    if (!(_DWORD)v10)
    {
      v53 = 0;
      v43 = 0;
      v44 = 0;
LABEL_125:
      if (v19)
      {
        if (v44)
          BYTE2(v62) = 0;
        if (!(_DWORD)v10)
          v64[34] = 0;
        inited = ssft_hlp_PipelineName(a1, 0, (uint64_t)__dst);
        if (inited < 0)
        {
          if (!(__dst[0] | v61[0]))
            goto LABEL_139;
          if (!v43)
            LOWORD(v62) = 0;
          BYTE2(v62) = 0;
          if (!v44)
            v64[2] = 0;
          if (!(_DWORD)v10)
            v64[34] = 0;
          inited = ssft_hlp_PipelineName(a1, 0, (uint64_t)__dst);
          if (inited < 0)
          {
LABEL_139:
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18020, (uint64_t)"%s%x", v45, v14, v15, v16, "lhError");
            goto LABEL_161;
          }
        }
      }
      else if (inited < 0)
      {
        goto LABEL_161;
      }
      if (((*(_DWORD *)(a1 + 112) >> 2) & (*(_DWORD *)(a1 + 112) << 28 >> 31)) != ((v17 & 0xC) == 12))
      {
        if ((v17 & 0xC) == 0xC)
        {
LABEL_147:
          *(_DWORD *)(a1 + 440) = 0;
          v65 = 0;
          inited = (*(uint64_t (**)(_QWORD, _QWORD, char *, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480)
                                                                             + 192))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), &v64[62], 0);
          if ((inited & 0x80000000) == 0)
          {
            *(_DWORD *)(a1 + 112) = v17;
            *(_DWORD *)(a1 + 116) = v18;
LABEL_150:
            cstdlib_memcpy((void *)(a1 + 120), __dst, 0x144uLL);
            goto LABEL_161;
          }
LABEL_151:
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18022, (uint64_t)"%s%x", v46, v14, v15, v16, "lhError");
          goto LABEL_161;
        }
        inited = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480)
                                                                           + 192))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), 0, 0);
        if (inited < 0)
          goto LABEL_151;
      }
      if (v19 != 1 || (v17 & 8) == 0 || (v17 & 4) == 0)
      {
        *(_DWORD *)(a1 + 112) = v17;
        *(_DWORD *)(a1 + 116) = v18;
        if (!v19)
          goto LABEL_161;
        goto LABEL_150;
      }
      goto LABEL_147;
    }
    goto LABEL_11;
  }
  if (!(_DWORD)v10)
  {
LABEL_122:
    inited = -2147475439;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18019, (uint64_t)"%s%x", v13, v14, v15, v16, "lhError");
    goto LABEL_164;
  }
  v40 = v10;
  v41 = a3;
  while (1)
  {
    v42 = *v41;
    v41 += 33;
    if ((v42 - 1) < 4)
      break;
    if (!--v40)
      goto LABEL_122;
  }
  v19 = 1;
LABEL_11:
  v10 = v10;
  v20 = v10;
  v21 = a3;
  v54 = v19;
  while (1)
  {
    v23 = *v21;
    v21 += 33;
    v22 = v23;
    if ((v23 - 8) >= 4 && v22 != 24)
      break;
    if (!--v20)
    {
      v53 = 0;
      goto LABEL_19;
    }
  }
  v47 = ssft_hlp_LockFromIdle(a1, (uint64_t)"ve_ttsSetParamList", 2, &v55);
  inited = v47;
  if (v47 < 0)
  {
    v55 = 0;
    v53 = 1;
    goto LABEL_161;
  }
  v53 = 1;
LABEL_19:
  v52 = 0;
  v51 = 0;
  v25 = (const char *)(a3 + 1);
  while (2)
  {
    switch(*((_DWORD *)v25 - 1))
    {
      case 1:
        if (cstdlib_strlen(v25) < 0x40)
          cstdlib_strcpy(__dst, v25);
        else
          __dst[0] = 0;
        v57 = 0;
        if (cstdlib_strlen(__dst) == 3
          && (ssft_loc_ConvertToLanguageTLW(*(_QWORD *)(a1 + 32), &__src, &v57, __dst) & 0x80000000) == 0)
        {
          cstdlib_strcpy(__dst, __src);
          heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), (uint64_t)__src);
          __src = 0;
        }
        goto LABEL_85;
      case 2:
        if (cstdlib_strlen(v25) < 0x20)
          cstdlib_strcpy(v61, v25);
        else
          v61[0] = 0;
LABEL_85:
        v54 = 1;
        if (inited < 0)
          goto LABEL_160;
        goto LABEL_111;
      case 3:
        if (cstdlib_strlen(v25) < 0x20)
          cstdlib_strcpy(&v64[2], v25);
        else
          v64[2] = 0;
        v54 = 1;
        v52 = 1;
        if (inited < 0)
          goto LABEL_160;
        goto LABEL_111;
      case 4:
        v26 = *(unsigned __int16 *)v25;
        if (v26 <= 0xF)
        {
          if (v26 != 8 && v26 != 11)
            goto LABEL_168;
          goto LABEL_92;
        }
        if (v26 == 16 || v26 == 22)
        {
LABEL_92:
          LOWORD(v62) = v26;
          v54 = 1;
          LODWORD(v51) = 1;
          if (inited < 0)
            goto LABEL_160;
LABEL_111:
          v25 += 132;
          if (!--v10)
          {
            v19 = v54;
            v43 = v51;
            LODWORD(v10) = HIDWORD(v51);
            v44 = v52;
            goto LABEL_125;
          }
          continue;
        }
LABEL_168:
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18013, (uint64_t)"%s%u", v13, v14, v15, v16, "frequency");
LABEL_169:
        inited = -2147475449;
LABEL_161:
        if (v53 && v55)
          ssft_hlp_Unlock(a1, v55);
LABEL_164:
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsSetParamList : End", v14, v15, v16, v50);
        return ssft_MapTtsegErrToAPI(inited);
      case 5:
        if (cstdlib_strlen(v25) < 0x80)
          cstdlib_strcpy(v59, v25);
        else
          v59[0] = 0;
        v34 = *(_QWORD *)(v58 + 40);
        v36 = v59;
        v35 = "extraesclang";
        goto LABEL_103;
      case 6:
        if (cstdlib_strlen(v25) < 0x80)
          cstdlib_strcpy(v59, v25);
        else
          v59[0] = 0;
        v34 = *(_QWORD *)(v58 + 40);
        v36 = v59;
        v35 = "extraesctn";
        goto LABEL_103;
      case 7:
        v27 = *(unsigned __int16 *)v25;
        v28 = "text/plain;charset=utf-16";
        if (v27 != 1)
          v28 = 0;
        if (v27 == 2)
          v29 = "text/plain;charset=utf-8";
        else
          v29 = (char *)v28;
        if (!v29)
        {
          inited = -2147475441;
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18017, (uint64_t)"%s%u", v13, v14, v15, v16, "typeOfChar");
          goto LABEL_161;
        }
        inited = paramc_ParamSetStrPermanent(*(_QWORD *)(v58 + 40), (uint64_t)"inputmimetype", v29);
        SetSavedMimeTypeforPlainText(a1, v29);
        if (inited < 0)
          goto LABEL_160;
        goto LABEL_111;
      case 8:
        v30 = paramc_ParamSetUIntPermanent(*(_QWORD *)(v58 + 40), (uint64_t)"volume", *(unsigned __int16 *)v25);
        if (v30 < 0)
          goto LABEL_155;
        v31 = *(_QWORD *)(v58 + 40);
        v32 = *(unsigned __int16 *)v25;
        v33 = "audioinsertervolume";
        goto LABEL_109;
      case 9:
        v30 = paramc_ParamSetUIntPermanent(*(_QWORD *)(v58 + 40), (uint64_t)"rate", *(unsigned __int16 *)v25);
        if ((v30 & 0x80000000) == 0)
        {
          v31 = *(_QWORD *)(v58 + 40);
          v32 = *(unsigned __int16 *)v25;
          v33 = "audioinserterrate";
LABEL_109:
          inited = paramc_ParamSetUIntPermanent(v31, (uint64_t)v33, v32);
LABEL_110:
          if (inited < 0)
            goto LABEL_160;
          goto LABEL_111;
        }
LABEL_155:
        inited = v30;
        goto LABEL_160;
      case 0xA:
        v31 = *(_QWORD *)(v58 + 40);
        v32 = *(unsigned __int16 *)v25;
        v33 = "pitch";
        goto LABEL_109;
      case 0xB:
        inited = paramc_ParamSetUIntPermanent(*(_QWORD *)(v58 + 40), (uint64_t)"waitfactor", *(unsigned __int16 *)v25);
        paramc_ParamSetUIntPermanent(*(_QWORD *)(v58 + 40), (uint64_t)"waitfactorsetbyapi", 1u);
        if (inited < 0)
          goto LABEL_160;
        goto LABEL_111;
      case 0xC:
        v31 = *(_QWORD *)(v58 + 40);
        v32 = *(unsigned __int16 *)v25;
        v33 = "readmode";
        goto LABEL_109;
      case 0xD:
        v18 = *(unsigned __int16 *)v25;
        if ((v18 - 1) < 2)
          goto LABEL_110;
        inited = -2147475441;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18016, (uint64_t)"%s%u", v13, v14, v15, v16, "textMode");
        goto LABEL_161;
      case 0xE:
        v32 = *(unsigned __int16 *)v25;
        if (v32 - 2501 >= 0xFFFFF654)
        {
          v31 = *(_QWORD *)(v58 + 40);
          v33 = "maxinputlength";
          goto LABEL_109;
        }
        inited = -2147475441;
LABEL_160:
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18019, (uint64_t)"%s%d%s%x", v13, v14, v15, v16, "parameterID");
        goto LABEL_161;
      case 0xF:
        if (*(_WORD *)v25 == 1)
        {
          v34 = *(_QWORD *)(v58 + 40);
          v35 = "lidscope";
          v36 = "user-defined";
        }
        else
        {
          if (*(_WORD *)v25)
            goto LABEL_156;
          v34 = *(_QWORD *)(v58 + 40);
          v35 = "lidscope";
          v36 = "none";
        }
        goto LABEL_103;
      case 0x10:
        if (*(_WORD *)v25 == 1)
        {
          v34 = *(_QWORD *)(v58 + 40);
          v35 = "lidvoiceswitch";
          v36 = "yes";
        }
        else
        {
          if (*(_WORD *)v25)
            goto LABEL_156;
          v34 = *(_QWORD *)(v58 + 40);
          v35 = "lidvoiceswitch";
          v36 = "no";
        }
        goto LABEL_103;
      case 0x11:
        if (*(_WORD *)v25 == 1)
        {
          v34 = *(_QWORD *)(v58 + 40);
          v35 = "lidmode";
          v36 = "forced-choice";
        }
        else
        {
          if (*(_WORD *)v25)
          {
LABEL_156:
            inited = -2147475441;
            goto LABEL_161;
          }
          v34 = *(_QWORD *)(v58 + 40);
          v35 = "lidmode";
          v36 = "memory-bias";
        }
LABEL_103:
        inited = paramc_ParamSetStrPermanent(v34, (uint64_t)v35, v36);
        if (inited < 0)
          goto LABEL_160;
        goto LABEL_111;
      case 0x12:
        if (cstdlib_strlen(v25) < 0x80)
          cstdlib_strcpy(v59, v25);
        else
          v59[0] = 0;
        v34 = *(_QWORD *)(v58 + 40);
        v36 = v59;
        v35 = "lidlanguages";
        goto LABEL_103;
      case 0x13:
        v37 = *(unsigned __int16 *)v25;
        if (v37 == 10007)
        {
          v31 = *(_QWORD *)(v58 + 40);
          v33 = "markermode";
          v32 = -1;
        }
        else if (v37 == 1)
        {
          v31 = *(_QWORD *)(v58 + 40);
          v33 = "markermode";
          v32 = 1199;
        }
        else
        {
          if (*(_WORD *)v25)
          {
            log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18014, (uint64_t)"%s%u", v13, v14, v15, v16, "markerMode");
            goto LABEL_169;
          }
          v31 = *(_QWORD *)(v58 + 40);
          v33 = "markermode";
          v32 = 0;
        }
        goto LABEL_109;
      case 0x14:
        v17 = *(unsigned __int16 *)v25;
        if (v17 == 12 || v17 == 3)
          goto LABEL_110;
        inited = -2147475441;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18015, (uint64_t)"%s%x", v13, v14, v15, v16, "initMode");
        goto LABEL_161;
      case 0x15:
        if (*v25)
        {
          if (cstdlib_strlen(v25) >= 0xC)
            goto LABEL_106;
          v39 = v25;
        }
        else
        {
          if (cstdlib_strlen("0.0.0") >= 0xC)
          {
LABEL_106:
            v64[34] = 0;
            goto LABEL_115;
          }
          v39 = "0.0.0";
        }
        cstdlib_strcpy(&v64[34], v39);
LABEL_115:
        v54 = 1;
        HIDWORD(v51) = 1;
        v52 = 1;
        if (inited < 0)
          goto LABEL_160;
        goto LABEL_111;
      case 0x16:
        v31 = *(_QWORD *)(v58 + 40);
        v32 = *(unsigned __int16 *)v25;
        v33 = "disablefinalsentencesilence";
        goto LABEL_109;
      case 0x18:
        v31 = *(_QWORD *)(v58 + 40);
        v32 = *(unsigned __int16 *)v25;
        v33 = "timbre";
        goto LABEL_109;
      default:
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18018, (uint64_t)"%s%d", v13, v14, v15, v16, "parameterID");
        goto LABEL_169;
    }
  }
}

uint64_t ssft_loc_strncpy(const char *a1, char *a2, __int16 a3)
{
  uint64_t result;

  if (a1)
  {
    if (cstdlib_strlen(a1) <= (unsigned __int16)(a3 - 1))
    {
      cstdlib_strcpy(a2, a1);
      return 0;
    }
    else
    {
      *a2 = 0;
      return 2147483657;
    }
  }
  else
  {
    result = 2147483654;
    *a2 = 0;
  }
  return result;
}

uint64_t ssft_loc_ConvertToLanguageTLW(uint64_t a1, char **a2, _WORD *a3, char *a4)
{
  uint64_t v5;
  uint64_t result;
  char *v10;
  char *v11;
  int v12;
  char *v13;
  const char *v14;
  uint64_t v15;
  int v16;
  char *v17;
  uint64_t v18;
  int v19;
  _WORD *v20;
  char *v21;
  char *__s1;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;

  v24 = 0;
  v25 = 0;
  v5 = 2147483658;
  v23 = 0;
  result = 2147483654;
  if (!a2)
    return result;
  if (!a3)
    return result;
  result = brk_ComponentTableIteratorOpen(*(_QWORD *)(a1 + 24), (uint64_t)"pipeline/*", (uint64_t)&v25);
  if ((result & 0x80000000) != 0)
    return result;
  if ((brk_ComponentTableIteratorNext(v25) & 0x80000000) != 0)
  {
LABEL_32:
    v5 = 2147483668;
    goto LABEL_33;
  }
  v20 = a3;
  while (1)
  {
    if ((brk_TagIteratorOpen(*(_QWORD *)(a1 + 24), v24, "PARAMETERS/*", 1, &v23) & 0x80000000) != 0)
      goto LABEL_31;
    v21 = 0;
    __s1 = 0;
    if ((brk_TagIteratorNext(v23, (uint64_t)&__s1, (uint64_t)&v21) & 0x80000000) != 0)
    {
      v12 = 0;
      v11 = 0;
      v10 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = 0;
      do
      {
        if (__s1)
        {
          if (cstdlib_strcmp(__s1, "language"))
          {
            if (cstdlib_strcmp(__s1, "langcode"))
            {
              if (!cstdlib_strcmp(__s1, "langid"))
                v12 = (unsigned __int16)LH_atou(v21);
            }
            else
            {
              v10 = v21;
            }
          }
          else
          {
            v11 = v21;
          }
        }
      }
      while ((brk_TagIteratorNext(v23, (uint64_t)&__s1, (uint64_t)&v21) & 0x80000000) == 0);
    }
    brk_TagIteratorClose(v23);
    v23 = 0;
    if (!v11 || !v10)
      goto LABEL_31;
    if (!v12)
      v12 = (unsigned __int16)LH_atou(v11);
    if (*a2)
    {
      if (!LH_stricmp(v11, *a2))
      {
        v13 = a4;
        v14 = v10;
LABEL_35:
        cstdlib_strcpy(v13, v14);
        v5 = 0;
        *v20 = v12;
        goto LABEL_33;
      }
      goto LABEL_31;
    }
    if (!*v20 && *a4)
      break;
    if (v12 == (unsigned __int16)*v20)
    {
      cstdlib_strcpy(a4, v10);
      v15 = *(_QWORD *)(a1 + 8);
      v16 = cstdlib_strlen(v11);
      v17 = (char *)heap_Alloc(v15, (v16 + 1));
      *a2 = v17;
      if (v17)
      {
        cstdlib_strcpy(v17, v11);
        v5 = 0;
      }
      goto LABEL_33;
    }
LABEL_31:
    if ((brk_ComponentTableIteratorNext(v25) & 0x80000000) != 0)
      goto LABEL_32;
  }
  if (LH_stricmp(v10, a4))
    goto LABEL_31;
  v18 = *(_QWORD *)(a1 + 8);
  v19 = cstdlib_strlen(v11);
  v13 = (char *)heap_Alloc(v18, (v19 + 1));
  *a2 = v13;
  if (v13)
  {
    v14 = v11;
    goto LABEL_35;
  }
LABEL_33:
  brk_ComponentTableIteratorClose(v25);
  return v5;
}

uint64_t ve_ttsGetParamList(uint64_t a1, int a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  BOOL v10;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int inited;
  char *v18;
  unint64_t v19;
  char *v20;
  const char *v21;
  int v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  char *v27;
  const char *v28;
  uint64_t v29;
  int v30;
  int Str;
  uint64_t v33;
  uint64_t v34;
  char *__s1;
  uint64_t v36;
  int v37;

  __s1 = 0;
  v36 = 0;
  result = 2147483656;
  v10 = a2 != 1750024778 || a1 == 0;
  if (v10 || *(_DWORD *)a1 != 1934574154)
    return result;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsGetParamList : Begin", a6, a7, a8, v33);
  if (!a3)
    return 2147483654;
  inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v36);
  if (inited < 0)
    return ssft_MapTtsegErrToAPI(inited);
  if (!a4)
    goto LABEL_70;
  v18 = (char *)(a3 + 4);
  v19 = 1;
  while (2)
  {
    switch(*((_DWORD *)v18 - 1))
    {
      case 1:
        if (cstdlib_strlen((const char *)(a1 + 120)) >= 0x80)
          goto LABEL_66;
        v20 = v18;
        v21 = (const char *)(a1 + 120);
        goto LABEL_48;
      case 2:
        if (cstdlib_strlen((const char *)(a1 + 184)) >= 0x80)
          goto LABEL_66;
        v20 = v18;
        v21 = (const char *)(a1 + 184);
        goto LABEL_48;
      case 3:
        if (cstdlib_strlen((const char *)(a1 + 250)) >= 0x80)
          goto LABEL_66;
        v20 = v18;
        v21 = (const char *)(a1 + 250);
        goto LABEL_48;
      case 4:
        LOWORD(v22) = *(_WORD *)(a1 + 216);
        goto LABEL_57;
      case 5:
        v23 = *(_QWORD *)(v36 + 40);
        v24 = "extraesclang";
        goto LABEL_51;
      case 6:
        v23 = *(_QWORD *)(v36 + 40);
        v24 = "extraesctn";
        goto LABEL_51;
      case 7:
        inited = paramc_ParamGetStr(*(_QWORD *)(v36 + 40), (uint64_t)"inputmimetype", &__s1);
        if (inited < 0)
          goto LABEL_70;
        v37 = 0;
        if (TextMime2ve(__s1, 0, &v37, 0))
          goto LABEL_56;
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18023, (uint64_t)"%s%s", v13, v14, v15, v16, "typeOfChar");
        inited = -2147483641;
        goto LABEL_70;
      case 8:
        v25 = *(_QWORD *)(v36 + 40);
        v37 = 0;
        v26 = "volume";
        goto LABEL_55;
      case 9:
        v25 = *(_QWORD *)(v36 + 40);
        v37 = 0;
        v26 = "rate";
        goto LABEL_55;
      case 0xA:
        v25 = *(_QWORD *)(v36 + 40);
        v37 = 0;
        v26 = "pitch";
        goto LABEL_55;
      case 0xB:
        v25 = *(_QWORD *)(v36 + 40);
        v37 = 0;
        v26 = "waitfactor";
        goto LABEL_55;
      case 0xC:
        v25 = *(_QWORD *)(v36 + 40);
        v37 = 0;
        v26 = "readmode";
        goto LABEL_55;
      case 0xD:
        v22 = *(_DWORD *)(a1 + 116);
        goto LABEL_57;
      case 0xE:
        v25 = *(_QWORD *)(v36 + 40);
        v37 = 0;
        v26 = "maxinputlength";
        goto LABEL_55;
      case 0xF:
        inited = paramc_ParamGetStr(*(_QWORD *)(v36 + 40), (uint64_t)"lidscope", &__s1);
        if (inited < 0)
          goto LABEL_70;
        if (!cstdlib_strcmp(__s1, "none"))
          goto LABEL_63;
        v27 = __s1;
        v28 = "user-defined";
        goto LABEL_39;
      case 0x10:
        inited = paramc_ParamGetStr(*(_QWORD *)(v36 + 40), (uint64_t)"lidvoiceswitch", &__s1);
        if (inited < 0)
          goto LABEL_70;
        if (!cstdlib_strcmp(__s1, "no"))
          goto LABEL_63;
        v27 = __s1;
        v28 = "yes";
        goto LABEL_39;
      case 0x11:
        inited = paramc_ParamGetStr(*(_QWORD *)(v36 + 40), (uint64_t)"lidmode", &__s1);
        if (inited < 0)
          goto LABEL_70;
        if (!cstdlib_strcmp(__s1, "memory-bias"))
          goto LABEL_63;
        v27 = __s1;
        v28 = "forced-choice";
LABEL_39:
        if (cstdlib_strcmp(v27, v28))
          goto LABEL_69;
        goto LABEL_43;
      case 0x13:
        v29 = *(_QWORD *)(v36 + 40);
        v37 = 0;
        inited = paramc_ParamGetUInt(v29, (uint64_t)"markermode", (unsigned int *)&v37);
        if (inited < 0)
        {
          if (*(_WORD *)v18)
          {
LABEL_43:
            *(_WORD *)v18 = 1;
            if (inited < 0)
              goto LABEL_70;
            goto LABEL_59;
          }
        }
        else
        {
          v30 = (unsigned __int16)v37;
          *(_WORD *)v18 = v37;
          if (v30)
            goto LABEL_43;
        }
LABEL_63:
        *(_WORD *)v18 = 0;
        if (inited < 0)
          goto LABEL_70;
        goto LABEL_59;
      case 0x14:
        v22 = *(_DWORD *)(a1 + 112);
        goto LABEL_57;
      case 0x15:
        if (cstdlib_strlen((const char *)(a1 + 282)) >= 0x80)
        {
LABEL_66:
          *v18 = 0;
          inited = -2147483639;
          goto LABEL_70;
        }
        v20 = v18;
        v21 = (const char *)(a1 + 282);
LABEL_48:
        cstdlib_strcpy(v20, v21);
        inited = 0;
        goto LABEL_59;
      case 0x16:
        v25 = *(_QWORD *)(v36 + 40);
        v37 = 0;
        v26 = "disablefinalsentencesilence";
        goto LABEL_55;
      case 0x17:
        v23 = *(_QWORD *)(v36 + 40);
        v24 = "noclmset";
LABEL_51:
        Str = paramc_ParamGetStr(v23, (uint64_t)v24, &__s1);
        if ((Str & 0x80000000) == 0)
        {
          inited = ssft_loc_strncpy(__s1, v18, 128);
          if (inited < 0)
            goto LABEL_70;
LABEL_59:
          v18 += 132;
          if (v19++ >= a4)
            goto LABEL_70;
          continue;
        }
        inited = Str;
LABEL_70:
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsGetParamList : End", v14, v15, v16, v34);
        return ssft_MapTtsegErrToAPI(inited);
      case 0x18:
        v25 = *(_QWORD *)(v36 + 40);
        v37 = 0;
        v26 = "timbre";
LABEL_55:
        inited = paramc_ParamGetUInt(v25, (uint64_t)v26, (unsigned int *)&v37);
        if ((inited & 0x80000000) == 0)
        {
LABEL_56:
          LOWORD(v22) = v37;
LABEL_57:
          *(_WORD *)v18 = v22;
        }
        if ((inited & 0x80000000) == 0)
          goto LABEL_59;
        goto LABEL_70;
      default:
        log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18018, (uint64_t)"%s%d", v13, v14, v15, v16, "parameterID");
LABEL_69:
        inited = -2147483641;
        goto LABEL_70;
    }
  }
}

uint64_t ve_ttsResourceLoad(uint64_t a1, int a2, const char *a3, uint64_t a4, char *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char *v20;
  char *v21;
  uint64_t v22;
  int v23;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  const char **v29;
  size_t v30;
  size_t v31;
  char *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  _OWORD __b[129];
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v8 = 2147483656;
  v40 = 0;
  if (a2 == 1750024778 && a1 != 0 && *(_DWORD *)a1 == 1934574154)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsResourceLoad : Begin", (uint64_t)a6, a7, a8, v38);
    v8 = 2147483654;
    if (a3)
    {
      if (a5 && a6)
      {
        if (a4)
        {
          v15 = ssft_hlp_LockFromIdle(a1, (uint64_t)"ve_ttsResourceLoad", 2, &v40);
          if (v15 < 0)
            return ssft_MapTtsegErrToAPI(v15);
          v8 = 2147491850;
          v16 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), 1, 16);
          if (v16)
          {
            v17 = v16;
            if (cstdlib_strcmp(a3, "application/x-vocalizer-resources"))
            {
              v18 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), 1, 16);
              *(_QWORD *)v17 = v18;
              if (v18)
              {
                v19 = IsThisUrlOrRealPath(a5, a4, 0);
                if (v19)
                  v20 = a5;
                else
                  v20 = 0;
                if (v19)
                  v21 = 0;
                else
                  v21 = a5;
                if (v19)
                  v22 = 0;
                else
                  v22 = a4;
                v23 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, char *, char *, uint64_t, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 72))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), a3, v20, v21, v22, *(_QWORD *)v17);
                *(_DWORD *)(v17 + 8) = 0;
                goto LABEL_40;
              }
            }
            else
            {
              memset(__b, 0, 512);
              cstdlib_memset(__b, 0, 0x810uLL);
              v23 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, char *, uint64_t, _OWORD *))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480)
                                                                                                 + 240))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), 0, a5, a4, __b);
              if (v23 < 0)
              {
LABEL_40:
                if (v23 < 0)
                {
                  if (*(_QWORD *)v17)
                    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), *(_QWORD *)v17);
                  heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), v17);
                  v17 = 0;
                }
                *a6 = v17;
                ssft_hlp_Unlock(a1, v40);
                log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsResourceLoad : End", v35, v36, v37, v39);
                return ssft_MapTtsegErrToAPI(v23);
              }
              v25 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), WORD6(__b[0]), 16);
              *(_QWORD *)v17 = v25;
              if (v25)
              {
                if (WORD6(__b[0]))
                {
                  v26 = 0;
                  v27 = 0;
                  while (1)
                  {
                    v28 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
                    v29 = (const char **)__b + v27;
                    v30 = cstdlib_strlen(v29[2]);
                    v31 = cstdlib_strlen(";loader=broker");
                    v32 = (char *)heap_Calloc(v28, v30 + v31 + 1, 1);
                    if (!v32)
                    {
                      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), *(_QWORD *)v17);
                      goto LABEL_35;
                    }
                    v33 = v32;
                    cstdlib_strcat(v32, v29[2]);
                    cstdlib_strcat(v33, ";loader=broker");
                    v23 = (*(uint64_t (**)(_QWORD, _QWORD, char *, const char *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 72))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), v33, v29[130], 0, 0, *(_QWORD *)v17 + v26);
                    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), (uint64_t)v33);
                    if (v23 < 0)
                      break;
                    ++v27;
                    v26 += 16;
                    if (v27 >= WORD6(__b[0]))
                      goto LABEL_39;
                  }
                  if (v27)
                  {
                    v34 = 0;
                    do
                    {
                      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480)
                                                                             + 80))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(*(_QWORD *)v17 + v34), *(_QWORD *)(*(_QWORD *)v17 + v34 + 8));
                      v34 += 16;
                      --v27;
                    }
                    while (v27);
                  }
                }
LABEL_39:
                *(_DWORD *)(v17 + 8) = WORD6(__b[0]);
                (*(void (**)(_QWORD, _QWORD, _OWORD *))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 248))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), __b);
                goto LABEL_40;
              }
            }
LABEL_35:
            heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), v17);
          }
        }
        else
        {
          return 2147483655;
        }
      }
    }
  }
  return v8;
}

uint64_t ve_ttsResourceUnload(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;

  v20 = 0;
  v8 = a2 != 1750024778 || a1 == 0;
  if (v8 || *(_DWORD *)a1 != 1934574154)
    return 2147483656;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsResourceUnload : Begin", a6, a7, a8, v18);
  v11 = ssft_hlp_LockFromIdle(a1, (uint64_t)"ve_ttsResourceUnload", 2, &v20);
  if ((v11 & 0x80000000) == 0)
  {
    if (a3)
    {
      if (*((_DWORD *)a3 + 2))
      {
        v12 = 0;
        v13 = 0;
        do
        {
          v11 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480)
                                                                          + 80))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(*a3 + v12), *(_QWORD *)(*a3 + v12 + 8));
          if (v11 < 0)
            break;
          ++v13;
          v12 += 16;
        }
        while (v13 < *((unsigned int *)a3 + 2));
      }
      else
      {
        v11 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 80))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)*a3, *(_QWORD *)(*a3 + 8));
      }
      if (*a3)
        heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), *a3);
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 8), (uint64_t)a3);
    }
    ssft_hlp_Unlock(a1, v20);
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsResourceUnload : End", v15, v16, v17, v19);
  }
  return ssft_MapTtsegErrToAPI(v11);
}

uint64_t ve_ttsStop(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  BOOL v9;
  int State;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;

  v8 = 2147483656;
  v9 = a2 != 1750024778 || a1 == 0;
  if (v9 || *(_DWORD *)a1 != 1934574154)
    return v8;
  v23 = 0;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsStop : Begin", a6, a7, a8, v21);
  State = ssft_hlp_GetState(a1, &v23);
  if (State < 0)
    goto LABEL_21;
  if ((v23 - 5) < 0xFFFFFFFE)
    return 2147483665;
  State = ssft_hlp_PcmNotify(a1, 32);
  if (State < 0)
  {
LABEL_21:
    v20 = State;
  }
  else
  {
    v13 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 480) + 128))(*(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104));
    if ((v13 & 0x1FFF) == 0x11)
      v14 = 0;
    else
      v14 = v13;
    v15 = ssft_hlp_SetStateInterrupted(a1);
    if (v14)
      v19 = 0;
    else
      v19 = v15 < 0;
    if (v19)
      v20 = v15;
    else
      v20 = v14;
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"ve_ttsStop : End", v16, v17, v18, v22);
  }
  return ssft_MapTtsegErrToAPI(v20);
}

uint64_t ssft_hlp_PcmNotify(uint64_t a1, int a2)
{
  uint64_t (*v2)(uint64_t, uint64_t, _QWORD, _DWORD *);
  int v3;
  _DWORD v5[2];
  uint64_t v6;

  v5[0] = a2;
  v5[1] = 0;
  v6 = 0;
  v2 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _DWORD *))(a1 + 504);
  if (v2 && (v3 = v2(a1, 1750024778, *(_QWORD *)(a1 + 496), v5)) != 0)
    return v3 & 0x1FFF | 0x80002000;
  else
    return 0;
}

uint64_t ve_ttsPause(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  BOOL v9;
  int State;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;

  v8 = 2147483656;
  v9 = a2 != 1750024778 || a1 == 0;
  if (v9 || *(_DWORD *)a1 != 1934574154)
    return v8;
  v19 = 0;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"Pause : Begin", a6, a7, a8, v17);
  State = ssft_hlp_GetState(a1, &v19);
  if (State < 0)
    return ssft_MapTtsegErrToAPI(State);
  if ((v19 - 5) < 0xFFFFFFFE)
    return 2147483665;
  v13 = ssft_hlp_PcmNotify(a1, 64);
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"Pause : End", v14, v15, v16, v18);
  return ssft_MapTtsegErrToAPI(v13);
}

uint64_t ve_ttsResume(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  BOOL v9;
  int State;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;

  v8 = 2147483656;
  v9 = a2 != 1750024778 || a1 == 0;
  if (v9 || *(_DWORD *)a1 != 1934574154)
    return v8;
  v19 = 0;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"Resume : Begin", a6, a7, a8, v17);
  State = ssft_hlp_GetState(a1, &v19);
  if (State < 0)
    return ssft_MapTtsegErrToAPI(State);
  if ((v19 - 5) < 0xFFFFFFFE)
    return 2147483665;
  v13 = ssft_hlp_PcmNotify(a1, 128);
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"Resume : End", v14, v15, v16, v18);
  return ssft_MapTtsegErrToAPI(v13);
}

uint64_t ve_ttsGetLanguageList(uint64_t a1, int a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  __int16 v20;
  unint64_t v22;
  char *v23;
  const char *v24;
  int v25;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;

  v8 = 2147483656;
  v29 = 0;
  if (a2 == 1749240915 && *(_DWORD *)a1 == 1933790291)
  {
    log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetLanguageList : Begin", a6, a7, a8, v27);
    if (a4)
    {
      v12 = 0;
      v13 = (unsigned __int16)*a4;
      if (a3 && *a4)
      {
        v14 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), v13, 86);
        if (!v14)
        {
          v19 = -2147483638;
          goto LABEL_34;
        }
        v12 = v14;
        LODWORD(v13) = (unsigned __int16)*a4;
      }
      v29 = v13;
      v18 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, uint64_t, unsigned int *))(*(_QWORD *)(a1 + 504)
                                                                                             + 64))(*(_QWORD *)(a1 + 512), *(_QWORD *)(a1 + 520), "eng/vocalizerautomotive", v12, &v29);
      v19 = v18;
      if (v18 < 0)
      {
        v20 = v29;
        if (!v12)
          goto LABEL_26;
        if ((v18 & 0x1FFF) != 9 || v29 == 0)
          goto LABEL_26;
      }
      else
      {
        v20 = v29;
        if (!v12)
        {
          *a4 = v29;
          goto LABEL_34;
        }
        if (!v29)
        {
          *a4 = 0;
          goto LABEL_27;
        }
      }
      if (*a4)
      {
        v22 = 0;
        v23 = (char *)(a3 + 132);
        v24 = (const char *)v12;
        while (1)
        {
          v25 = ssft_loc_strncpy(v24, v23 - 132, 128);
          if (v25 < 0)
          {
            v19 = v25;
            goto LABEL_34;
          }
          if (cstdlib_strlen(v24 + 64) >= 4)
          {
            *(v23 - 4) = 0;
            goto LABEL_33;
          }
          cstdlib_strcpy(v23 - 4, v24 + 64);
          if (cstdlib_strlen(v24 + 72) >= 0x80)
            break;
          cstdlib_strcpy(v23, v24 + 72);
          ++v22;
          v20 = v29;
          if (v22 < v29)
          {
            v24 += 86;
            v23 += 260;
            if (v22 < (unsigned __int16)*a4)
              continue;
          }
          v19 = 0;
          goto LABEL_26;
        }
        *v23 = 0;
LABEL_33:
        v19 = -2147483639;
        goto LABEL_34;
      }
LABEL_26:
      *a4 = v20;
      if (!v12)
      {
LABEL_34:
        log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetLanguageList : End", v15, v16, v17, v28);
        return ssft_MapTtsegErrToAPI(v19);
      }
LABEL_27:
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), v12);
      goto LABEL_34;
    }
    return 2147483654;
  }
  return v8;
}

uint64_t ve_ttsGetNtsInfo(uint64_t a1, int a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned __int16 v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v26;
  uint64_t v27;
  __int16 v28;
  char *__src;
  uint64_t v30;
  _OWORD __b[4];
  char v32[32];
  char __s[16];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v8 = 2147483656;
  __src = 0;
  v30 = 0;
  v28 = 0;
  if (a2 != 1749240915)
    return v8;
  v35 = 0u;
  v36 = 0u;
  v34 = 0u;
  *(_OWORD *)__s = 0u;
  memset(__b, 0, sizeof(__b));
  memset(v32, 0, 22);
  if (*(_DWORD *)a1 != 1933790291)
    return v8;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetNtsInfo : Begin", a6, a7, a8, v26);
  if (a3)
  {
    v12 = cstdlib_strlen(a3) + 1;
    v13 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 8), v12);
    __src = v13;
    if (!v13)
    {
      v23 = -2147483638;
      goto LABEL_20;
    }
    ssft_loc_strncpy(a3, v13, v12);
  }
  v17 = brk_ObjOpen((uint64_t)"eng/vocalizerautomotive", *(_QWORD *)(a1 + 472));
  if (v17 < 0)
  {
    v23 = v17;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 18024, (uint64_t)"%s%x", v18, v19, v20, v21, "lhError");
    goto LABEL_20;
  }
  cstdlib_memset(__b, 0, 0x56uLL);
  v22 = ssft_loc_ConvertToLanguageTLW(*(_QWORD *)(a1 + 456), &__src, &v28, v32);
  if (v22 < 0)
  {
    v23 = v22;
    goto LABEL_20;
  }
  cstdlib_strcpy((char *)__b, __src);
  v23 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _OWORD *, char *))(*(_QWORD *)(a1 + 504) + 120))(*(_QWORD *)(a1 + 512), *(_QWORD *)(a1 + 520), "eng/vocalizerautomotive", __b, __s);
  v24 = v23 & 0x1FFF;
  if (v23 < 0 || v24 == 20)
  {
    if (!cstdlib_strlen(""))
    {
      if (v24 == 20)
        v23 = -2147483628;
      cstdlib_strcpy(a4, "");
      goto LABEL_20;
    }
    goto LABEL_16;
  }
  if (cstdlib_strlen(__s) >= 0x80)
  {
LABEL_16:
    *a4 = 0;
    v23 = -2147483639;
    goto LABEL_20;
  }
  cstdlib_strcpy(a4, __s);
  v23 = 0;
LABEL_20:
  if (v30)
    brk_ObjClose(v30);
  if (__src)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), (uint64_t)__src);
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetNtsInfo : End", v14, v15, v16, v27);
  return ssft_MapTtsegErrToAPI(v23);
}

uint64_t ve_ttsGetClmInfo(uint64_t a1, int a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned __int16 v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  char *v26;
  uint64_t v28;
  uint64_t v29;
  __int16 v30;
  char *__src;
  uint64_t v32;
  _OWORD __b[4];
  _WORD v34[16];
  char __s[16];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  char v39[2048];
  char v40[2056];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v8 = 2147483656;
  __src = 0;
  v32 = 0;
  v30 = 0;
  if (a2 != 1749240915)
    return v8;
  memset(v39, 0, 448);
  v37 = 0u;
  v38 = 0u;
  v36 = 0u;
  *(_OWORD *)__s = 0u;
  memset(v34, 0, 22);
  memset(__b, 0, sizeof(__b));
  if (*(_DWORD *)a1 != 1933790291)
    return v8;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetClmInfo: Begin", a6, a7, a8, v28);
  if (a3)
  {
    v12 = cstdlib_strlen(a3) + 1;
    v13 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 8), v12);
    __src = v13;
    if (!v13)
    {
      v25 = -2147483638;
      goto LABEL_33;
    }
    ssft_loc_strncpy(a3, v13, v12);
  }
  v17 = brk_ObjOpen((uint64_t)"eng/vocalizerautomotive", *(_QWORD *)(a1 + 472));
  if (v17 < 0)
  {
    v25 = v17;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 18024, (uint64_t)"%s%x", v18, v19, v20, v21, "lhError");
  }
  else
  {
    cstdlib_memset(__b, 0, 0x56uLL);
    v22 = ssft_loc_ConvertToLanguageTLW(*(_QWORD *)(a1 + 456), &__src, &v30, (char *)v34);
    if ((v22 & 0x80000000) == 0)
    {
      cstdlib_strcpy((char *)__b, __src);
      v23 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _OWORD *, char *))(*(_QWORD *)(a1 + 504) + 128))(*(_QWORD *)(a1 + 512), *(_QWORD *)(a1 + 520), "eng/vocalizerautomotive", __b, __s);
      v24 = v23 & 0x1FFF;
      if (v23 < 0 || v24 == 20)
      {
        if (v24 == 20)
          v25 = -2147483628;
        else
          v25 = v23;
        if (cstdlib_strlen(""))
          *a4 = 0;
        else
          cstdlib_strcpy(a4, "");
        if (cstdlib_strlen(""))
          a4[128] = 0;
        else
          cstdlib_strcpy(a4 + 128, "");
        v26 = a4 + 1152;
        if (!cstdlib_strlen(""))
        {
          cstdlib_strcpy(v26, "");
          goto LABEL_33;
        }
      }
      else
      {
        if (cstdlib_strlen(__s) < 0x80)
          cstdlib_strcpy(a4, __s);
        else
          *a4 = 0;
        if (cstdlib_strlen(v39) < 0x400)
          cstdlib_strcpy(a4 + 128, v39);
        else
          a4[128] = 0;
        v26 = a4 + 1152;
        if (cstdlib_strlen(v40) < 0x400)
        {
          cstdlib_strcpy(v26, v40);
          v25 = 0;
          goto LABEL_33;
        }
      }
      *v26 = 0;
      v25 = -2147483639;
      goto LABEL_33;
    }
    v25 = v22;
  }
LABEL_33:
  if (v32)
    brk_ObjClose(v32);
  if (__src)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), (uint64_t)__src);
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetClmInfo : End", v14, v15, v16, v29);
  return ssft_MapTtsegErrToAPI(v25);
}

uint64_t ve_ttsGetVoiceList(uint64_t a1, int a2, const char *a3, uint64_t a4, _WORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unsigned __int16 v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  __int16 v29;
  unint64_t v30;
  const char *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  __int16 v35;
  unsigned int v36;
  char *__src;
  uint64_t v38;
  _OWORD __b[4];
  _WORD v40[12];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  __src = 0;
  v38 = 0;
  v36 = 0;
  v35 = 0;
  result = 2147483656;
  if (a2 != 1749240915)
    return result;
  memset(v40, 0, 22);
  memset(__b, 0, sizeof(__b));
  if (*(_DWORD *)a1 != 1933790291)
    return result;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetVoiceList : Begin", a6, a7, a8, v33);
  if (!a5)
    return 2147483654;
  if (a3)
  {
    v13 = cstdlib_strlen(a3) + 1;
    v14 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 8), v13);
    __src = v14;
    if (!v14)
      goto LABEL_18;
    ssft_loc_strncpy(a3, v14, v13);
  }
  v18 = brk_ObjOpen((uint64_t)"eng/vocalizerautomotive", *(_QWORD *)(a1 + 472));
  if (v18 < 0)
  {
    v28 = v18;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 18024, (uint64_t)"%s%x", v19, v20, v21, v22, "lhError");
    goto LABEL_44;
  }
  cstdlib_memset(__b, 0, 0x56uLL);
  v23 = ssft_loc_ConvertToLanguageTLW(*(_QWORD *)(a1 + 456), &__src, &v35, (char *)v40);
  if (v23 < 0)
  {
LABEL_36:
    v28 = v23;
    goto LABEL_44;
  }
  cstdlib_strcpy((char *)__b, __src);
  v24 = 0;
  v25 = (unsigned __int16)*a5;
  if (a4 && *a5)
  {
    v26 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), v25, 200);
    if (v26)
    {
      v24 = v26;
      LODWORD(v25) = (unsigned __int16)*a5;
      goto LABEL_13;
    }
LABEL_18:
    v28 = -2147483638;
    goto LABEL_44;
  }
LABEL_13:
  v36 = v25;
  v27 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _OWORD *, uint64_t, unsigned int *))(*(_QWORD *)(a1 + 504) + 72))(*(_QWORD *)(a1 + 512), *(_QWORD *)(a1 + 520), "eng/vocalizerautomotive", __b, v24, &v36);
  v28 = v27;
  if (v27 < 0)
  {
    v29 = v36;
    if (!v24 || (v27 & 0x1FFF) != 9 || !v36)
      goto LABEL_34;
  }
  else
  {
    v29 = v36;
    if (!v24)
    {
      *a5 = v36;
      goto LABEL_44;
    }
    if (!v36)
    {
      *a5 = 0;
LABEL_35:
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), v24);
      goto LABEL_44;
    }
  }
  if (*a5)
  {
    v30 = 0;
    v31 = (const char *)(v24 + 136);
    v32 = (char *)(a4 + 640);
    while (1)
    {
      v23 = ssft_loc_strncpy(v31 - 136, v32 - 384, 128);
      if (v23 < 0)
        goto LABEL_36;
      if (cstdlib_strlen(v31 - 104) >= 0x80)
        break;
      cstdlib_strcpy(v32 - 512, v31 - 104);
      if (cstdlib_strlen(v31 - 12) >= 0x80)
      {
        *(v32 - 640) = 0;
        goto LABEL_43;
      }
      cstdlib_strcpy(v32 - 640, v31 - 12);
      if (cstdlib_strlen(v31 - 40) >= 0x80)
      {
        *(v32 - 256) = 0;
        goto LABEL_43;
      }
      cstdlib_strcpy(v32 - 256, v31 - 40);
      if (cstdlib_strlen(v31 - 28) >= 0x80)
      {
        *(v32 - 128) = 0;
        goto LABEL_43;
      }
      cstdlib_strcpy(v32 - 128, v31 - 28);
      if (cstdlib_strlen(v31) >= 0x80)
      {
        *v32 = 0;
        goto LABEL_43;
      }
      cstdlib_strcpy(v32, v31);
      ++v30;
      v29 = v36;
      if (v30 < v36)
      {
        v31 += 200;
        v32 += 768;
        if (v30 < (unsigned __int16)*a5)
          continue;
      }
      v28 = 0;
      goto LABEL_34;
    }
    *(v32 - 512) = 0;
LABEL_43:
    v28 = -2147483639;
    goto LABEL_44;
  }
LABEL_34:
  *a5 = v29;
  if (v24)
    goto LABEL_35;
LABEL_44:
  if (v38)
    brk_ObjClose(v38);
  if (__src)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), (uint64_t)__src);
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetVoiceList : End", v15, v16, v17, v34);
  return ssft_MapTtsegErrToAPI(v28);
}

uint64_t ve_ttsGetSpeechDBList(uint64_t a1, int a2, const char *a3, const char *a4, uint64_t a5, _WORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unsigned __int16 v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int16 v19;
  char *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  __int16 v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int16 v37;
  unsigned int v38;
  char *__src;
  uint64_t v40;
  _OWORD __b[4];
  _WORD v42[12];
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  __src = 0;
  v40 = 0;
  v38 = 0;
  v37 = 0;
  result = 2147483656;
  if (a2 != 1749240915)
    return result;
  memset(v42, 0, 22);
  memset(__b, 0, sizeof(__b));
  if (*(_DWORD *)a1 != 1933790291)
    return result;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetSpeechDBList : Begin", (uint64_t)a6, a7, a8, v35);
  result = 2147483654;
  if (!a4 || !a6)
    return result;
  if (a3)
  {
    v14 = cstdlib_strlen(a3) + 1;
    v15 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 8), v14);
    __src = v15;
    if (!v15)
    {
      v20 = 0;
      goto LABEL_19;
    }
    ssft_loc_strncpy(a3, v15, v14);
  }
  v19 = cstdlib_strlen(a4) + 1;
  v20 = (char *)heap_Alloc(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 8), v19);
  if (!v20)
  {
LABEL_19:
    v31 = -2147483638;
    goto LABEL_37;
  }
  ssft_loc_strncpy(a4, v20, v19);
  v21 = brk_ObjOpen((uint64_t)"eng/vocalizerautomotive", *(_QWORD *)(a1 + 472));
  if (v21 < 0)
  {
    v31 = v21;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 18024, (uint64_t)"%s%x", v22, v23, v24, v25, "lhError");
    goto LABEL_37;
  }
  cstdlib_memset(__b, 0, 0x56uLL);
  v26 = ssft_loc_ConvertToLanguageTLW(*(_QWORD *)(a1 + 456), &__src, &v37, (char *)v42);
  if (v26 < 0)
  {
LABEL_34:
    v31 = v26;
    goto LABEL_37;
  }
  cstdlib_strcpy((char *)__b, __src);
  v27 = 0;
  v28 = (unsigned __int16)*a6;
  if (a5 && *a6)
  {
    v29 = heap_Calloc(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), v28, 174);
    if (v29)
    {
      v27 = v29;
      LODWORD(v28) = (unsigned __int16)*a6;
      goto LABEL_15;
    }
    goto LABEL_19;
  }
LABEL_15:
  v38 = v28;
  v30 = (*(uint64_t (**)(_QWORD, _QWORD, const char *, _OWORD *, char *, uint64_t, unsigned int *))(*(_QWORD *)(a1 + 504) + 88))(*(_QWORD *)(a1 + 512), *(_QWORD *)(a1 + 520), "eng/vocalizerautomotive", __b, v20, v27, &v38);
  v31 = v30;
  if (v30 < 0)
  {
    if (!v27 || (v30 & 0x1FFF) != 9)
    {
      *a6 = v38;
      if (!v27)
        goto LABEL_37;
LABEL_36:
      heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), v27);
      goto LABEL_37;
    }
LABEL_23:
    v32 = v38;
    if (v38 && *a6)
    {
      v33 = 0;
      v34 = v27 + 96;
      while (1)
      {
        if (cstdlib_strlen((const char *)(v34 - 32)) >= 0x80)
        {
          *(_BYTE *)(a5 + 256) = 0;
          goto LABEL_48;
        }
        cstdlib_strcpy((char *)(a5 + 256), (const char *)(v34 - 32));
        v26 = ssft_loc_strncpy((const char *)(v34 - 96), (char *)(a5 + 128), 128);
        if (v26 < 0)
          goto LABEL_34;
        if (cstdlib_strlen((const char *)v34) >= 0x80)
        {
          *(_BYTE *)a5 = 0;
          goto LABEL_48;
        }
        cstdlib_strcpy((char *)a5, (const char *)v34);
        if (cstdlib_strlen((const char *)(v34 + 44)) >= 0x80)
          break;
        cstdlib_strcpy((char *)(a5 + 384), (const char *)(v34 + 44));
        *(_WORD *)(a5 + 512) = *(_WORD *)(v34 + 76);
        ++v33;
        v32 = v38;
        if (v33 < v38)
        {
          a5 += 514;
          v34 += 174;
          if (v33 < (unsigned __int16)*a6)
            continue;
        }
        v31 = 0;
        goto LABEL_33;
      }
      *(_BYTE *)(a5 + 384) = 0;
LABEL_48:
      v31 = -2147483639;
      goto LABEL_37;
    }
LABEL_33:
    *a6 = v32;
    goto LABEL_36;
  }
  if (v27)
    goto LABEL_23;
  *a6 = v38;
LABEL_37:
  if (v40)
    brk_ObjClose(v40);
  if (__src)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), (uint64_t)__src);
  if (v20)
    heap_Free(*(_QWORD **)(*(_QWORD *)(a1 + 456) + 8), (uint64_t)v20);
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 456) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetSpeechDBList : End", v16, v17, v18, v36);
  return ssft_MapTtsegErrToAPI(v31);
}

uint64_t ve_ttsSetTsoLog(uint64_t a1, int a2, const char *a3, const char *a4)
{
  uint64_t result;
  BOOL v6;
  int inited;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  char __dst[512];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  result = 2147483656;
  v14 = 0;
  v13 = 0;
  v6 = a2 != 1750024778 || a1 == 0;
  if (!v6 && *(_DWORD *)a1 == 1934574154)
  {
    inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v14);
    if (inited < 0 || (inited = ssft_hlp_LockFromIdle(a1, (uint64_t)"ve_ttsSetOutDevice", 2, &v13), inited < 0))
    {
      v10 = inited;
    }
    else
    {
      __dst[0] = 0;
      if (a4 && *a4)
      {
        if (cstdlib_strlen(a4) < 0x200)
          cstdlib_strcpy(__dst, a4);
        else
          __dst[0] = 0;
        v11 = cstdlib_strlen(__dst);
        if (__dst[v11 - 1] != 47)
          cstdlib_strcpy(&__dst[v11], "/");
      }
      if (a3)
      {
        if (*a3)
        {
          v12 = cstdlib_strlen(__dst);
          ssft_loc_strncpy(a3, &__dst[v12], 512 - v12);
        }
      }
      v10 = paramc_ParamSetStr(*(_QWORD *)(v14 + 40), (uint64_t)"logtso.filename", __dst);
      ssft_hlp_Unlock(a1, v13);
    }
    return ssft_MapTtsegErrToAPI(v10);
  }
  return result;
}

uint64_t ve_ttsSetFileLog(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  char *v7;
  int v8;
  char v9[1024];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  result = 2147483656;
  if (a2 == 1749240915)
  {
    if (*(_DWORD *)a1 != 1933790291)
      a1 = 0;
    if (a3 && a1)
    {
      v6 = *(_QWORD *)(a1 + 456);
      paramc_ParamSetInt(*(_QWORD *)(v6 + 40), (uint64_t)"logfile.max_size", *(_DWORD *)(a3 + 8));
      v7 = ".";
      if (*(_QWORD *)a3)
      {
        if (**(_BYTE **)a3)
          v7 = *(char **)a3;
      }
      v8 = paramc_ParamSetStr(*(_QWORD *)(v6 + 40), (uint64_t)"logfile.filename.1", v7);
      paramc_ParamSetInt(*(_QWORD *)(v6 + 40), (uint64_t)"logfile.enabled", *(_DWORD *)(a3 + 16) != 0);
      paramc_ParamSetInt(*(_QWORD *)(v6 + 40), (uint64_t)"logfile.filter.level", *(_DWORD *)(a3 + 16));
      LH_MapModuleNamesToIds(*(char **)(a3 + 24), v9, 0x400u);
      paramc_ParamSetStr(*(_QWORD *)(v6 + 40), (uint64_t)"logfile.filter.modules", v9);
      return ssft_MapTtsegErrToAPI(v8);
    }
  }
  return result;
}

uint64_t ve_ttsGetLipSyncInfo(uint64_t a1, int a2, int a3, int8x8_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int inited;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char *v20;
  int SyncInfo;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v32;
  uint64_t v33;
  char *__s1;
  uint64_t v35;
  char *v36;
  __int16 v37;
  __int16 v38;
  _BYTE v39[2];
  uint64_t v40;
  char v41[1024];
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v40 = 0;
  v8 = 2147483656;
  v38 = 0;
  v35 = 0;
  v36 = 0;
  __s1 = 0;
  if (a2 != 1750024778 || !a1 || *(_DWORD *)a1 != 1934574154)
    return v8;
  log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetLipSyncInfo : Begin", a6, a7, a8, v32);
  if (!a4)
    return 2147483654;
  inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v40);
  if (inited < 0)
    return ssft_MapTtsegErrToAPI(inited);
  v13 = *(_QWORD *)(a1 + 584);
  if (!v13)
  {
    inited = objc_GetObject(*(_QWORD *)(v40 + 48), (uint64_t)"PHONMAP", &v35);
    if ((inited & 0x80000000) == 0)
    {
      v14 = v35;
      v13 = *(_QWORD *)(v35 + 8);
      *(_QWORD *)(a1 + 584) = v13;
      *(_OWORD *)(a1 + 592) = *(_OWORD *)(v14 + 16);
      goto LABEL_9;
    }
    return ssft_MapTtsegErrToAPI(inited);
  }
LABEL_9:
  v39[0] = a3;
  v39[1] = 0;
  if (((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _BYTE *, char **, _QWORD))(v13 + 64))(*(_QWORD *)(a1 + 592), *(_QWORD *)(a1 + 600), 0, v39, &v36, 0) & 0x80000000) == 0)
  {
    v37 = 1024;
    inited = (*(uint64_t (**)(_QWORD, _QWORD, __int16 *, __int16 *, _QWORD))(*(_QWORD *)(a1 + 584) + 144))(*(_QWORD *)(a1 + 592), *(_QWORD *)(a1 + 600), &v38, &v37, 0);
    if ((inited & 0x80000000) == 0)
    {
      inited = (*(uint64_t (**)(_QWORD, _QWORD, __int16 *, __int16 *, char *))(*(_QWORD *)(a1 + 584) + 144))(*(_QWORD *)(a1 + 592), *(_QWORD *)(a1 + 600), &v38, &v37, v41);
      if ((inited & 0x80000000) == 0)
      {
        if ((paramc_ParamGet(*(_QWORD *)(v40 + 40), (uint64_t)"voiceml", &__s1, 0) & 0x80000000) != 0)
        {
          v20 = v36;
        }
        else
        {
          v19 = cstdlib_strcmp(__s1, "yes");
          v20 = v36;
          if (a3 != 35 && !v19 && v38 == 1)
            v20 = ++v36;
        }
        SyncInfo = lipsync_GetSyncInfo(*(_WORD **)(a1 + 608), a3, v20, a4);
        if (SyncInfo < 0)
        {
          v30 = SyncInfo;
          log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18031, (uint64_t)"%s%x", v22, v23, v24, v25, "lhError");
          inited = v30;
        }
        else
        {
          v29 = ssft_loc_strncpy(v36, (char *)&a4[1], 8);
          if ((v29 & 0x80000000) == 0)
            log_OutText(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 4, 0, (uint64_t)"GetLipSyncInfo : End", v26, v27, v28, v33);
          inited = v29;
        }
      }
    }
    return ssft_MapTtsegErrToAPI(inited);
  }
  log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18030, (uint64_t)"%s%x", v15, v16, v17, v18, "lhError");
  return 2147483919;
}

uint64_t ve_ttsGetProductVersion(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    return 2147483654;
  result = 0;
  *(_WORD *)a1 = 2327;
  *(_BYTE *)(a1 + 2) = 0;
  return result;
}

uint64_t ve_ttsGetAdditionalProductInfo(uint64_t a1)
{
  if (!a1)
    return 2147483654;
  *(_DWORD *)a1 = 50857960;
  cstdlib_strcpy((char *)(a1 + 4), "");
  return 0;
}

uint64_t ve_ttsGetRsrc(uint64_t a1, int a2, _QWORD *a3)
{
  uint64_t result;
  BOOL v5;
  int inited;
  uint64_t v8;

  result = 2147483656;
  v8 = 0;
  v5 = a2 != 1750024778 || a1 == 0;
  if (!v5 && *(_DWORD *)a1 == 1934574154)
  {
    inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v8);
    if (inited < 0)
    {
      return ssft_MapTtsegErrToAPI(inited);
    }
    else
    {
      result = 0;
      *a3 = v8;
    }
  }
  return result;
}

const char *ve_ttsGetErrorString(int a1)
{
  uint64_t v2;
  const char *result;

  v2 = 0;
  result = "Unknown error code";
  while (errStringCodes[v2] != a1)
  {
    v2 += 4;
    if (v2 == 296)
      return result;
  }
  return *(const char **)&errStringCodes[v2 + 2];
}

uint64_t ssft_LogOutText(uint64_t a1, int a2, uint64_t a3, int a4, char *__format, va_list a6)
{
  char __str[2048];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 8))
  {
    if (vsnprintf(__str, 0x800uLL, __format, a6) >= 0x7FF)
      __str[2047] = 0;
    if ((int)a3 <= 1)
      (*(void (**)(_QWORD, uint64_t, char *))(a1 + 8))(*(_QWORD *)(a1 + 24), a3, __str);
  }
  return 0;
}

uint64_t ssft_LogOutPublic(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  if (*(_QWORD *)a1)
    (*(void (**)(_QWORD, uint64_t, _QWORD, uint64_t, uint64_t))a1)(*(_QWORD *)(a1 + 24), a3, a4, a5, a6);
  return 0;
}

uint64_t ssft_LogOutEvent(uint64_t a1, unsigned int a2)
{
  void (*v2)(_QWORD);

  v2 = *(void (**)(_QWORD))(a1 + 16);
  if (v2 && (a2 > 0x1A || ((1 << a2) & 0x7E3FCE1) == 0))
    v2(*(_QWORD *)(a1 + 24));
  return 0;
}

uint64_t ssft_LogGetLogLevel()
{
  return 0;
}

uint64_t ssft_hlp_convertAndCopyInternalMrkRcrdsToApiMrk(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t inited;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  _QWORD *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  unint64_t *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  int v30;
  uint64_t v32;
  unsigned int v33;

  v33 = 0;
  v32 = 0;
  inited = InitRsrcFunction(*(_WORD **)(a1 + 16), *(_QWORD *)(a1 + 24), &v32);
  if ((inited & 0x80000000) == 0)
  {
    if ((paramc_ParamGetUInt(*(_QWORD *)(v32 + 40), (uint64_t)"markermode", &v33) & 0x80000000) != 0)
      v33 = 0;
    v9 = 0;
    if (a4)
    {
      v10 = a4;
      v11 = *(_QWORD *)(a2 + 32);
      v12 = (_DWORD *)(a3 + 24);
      do
      {
        v13 = v11 + 56 * v9;
        *(_WORD *)(v13 + 40) = 0;
        v14 = v13 + 40;
        *(_DWORD *)(v14 + 4) = 0;
        v15 = (_DWORD *)(v14 + 4);
        *(_QWORD *)(v14 + 8) = 0;
        v16 = (_QWORD *)(v14 + 8);
        v17 = *(v12 - 6);
        if (v17 > 32)
        {
          if (v17 == 33)
          {
            v18 = 0;
            *(_WORD *)v14 = *v12;
            v19 = 4;
            goto LABEL_19;
          }
          if (v17 != 0x4000)
          {
            if (v17 == 40)
            {
              v18 = 0;
              *v16 = *(_QWORD *)v12;
              v19 = 16;
              goto LABEL_19;
            }
            goto LABEL_32;
          }
          if (*(v12 - 4))
          {
            v18 = 1;
            v19 = 1;
            goto LABEL_19;
          }
        }
        else
        {
          if (v17 == 1)
          {
            v18 = 0;
            v19 = 2;
            goto LABEL_19;
          }
          if (v17 != 26)
          {
            if (v17 == 29)
            {
              v18 = 0;
              *v16 = *(_QWORD *)v12;
              v19 = 8;
LABEL_19:
              v20 = v11 + 56 * v9;
              *(_DWORD *)v20 = v19;
              v21 = *(v12 - 5);
              v22 = *(v12 - 4);
              *(_QWORD *)(v20 + 8) = v21;
              v23 = (_QWORD *)(v20 + 8);
              *(_QWORD *)(v20 + 16) = v22;
              v24 = (unint64_t *)(v20 + 16);
              if (*(_DWORD *)(a1 + 116) == 2)
              {
                v25 = *(unsigned int *)(a1 + 448);
                if (v21 >= v25)
                  v18 = 0;
                if (v18 == 1)
                {
                  v26 = v22 - (v25 - v21);
                  if (v22 < v25 - v21)
                    v26 = 0;
                  *v24 = v26;
                }
                v27 = v21 - v25;
                if (v21 <= v25)
                  v27 = 0;
                *v23 = v27;
              }
              v28 = *(_QWORD *)(v12 - 3);
              *(_QWORD *)&v29 = v28;
              *((_QWORD *)&v29 + 1) = HIDWORD(v28);
              *(_OWORD *)(v11 + 56 * v9++ + 24) = v29;
              goto LABEL_30;
            }
LABEL_32:
            if (v33 == -1)
            {
              if (v17 <= 997)
              {
                v30 = v17 - 2;
                v18 = 0;
                v19 = 589824;
                switch(v30)
                {
                  case 0:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 0x40000;
                    goto LABEL_19;
                  case 1:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 327680;
                    goto LABEL_19;
                  case 2:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 393216;
                    goto LABEL_19;
                  case 3:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 196608;
                    goto LABEL_19;
                  case 4:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 458752;
                    goto LABEL_19;
                  case 5:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 0x80000;
                    goto LABEL_19;
                  case 6:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 1024;
                    goto LABEL_19;
                  case 7:
                    goto LABEL_19;
                  case 8:
                    v18 = 0;
                    v19 = 655360;
                    goto LABEL_19;
                  case 9:
                    v18 = 0;
                    v19 = 720896;
                    goto LABEL_19;
                  case 10:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 786432;
                    goto LABEL_19;
                  case 11:
                    v18 = 0;
                    v19 = 851968;
                    goto LABEL_19;
                  case 12:
                    v18 = 0;
                    v19 = 917504;
                    goto LABEL_19;
                  case 14:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 983040;
                    goto LABEL_19;
                  case 15:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 2555904;
                    goto LABEL_19;
                  case 16:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 0x100000;
                    goto LABEL_19;
                  case 17:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 1114112;
                    goto LABEL_19;
                  case 18:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 1179648;
                    goto LABEL_19;
                  case 19:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 1310720;
                    goto LABEL_19;
                  case 20:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 1376256;
                    goto LABEL_19;
                  case 22:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 1441792;
                    goto LABEL_19;
                  case 23:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 2048;
                    goto LABEL_19;
                  case 29:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 1245184;
                    goto LABEL_19;
                  case 30:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 0x20000;
                    goto LABEL_19;
                  case 32:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 1507328;
                    goto LABEL_19;
                  case 34:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 1572864;
                    goto LABEL_19;
                  case 35:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 1638400;
                    goto LABEL_19;
                  case 36:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 0x10000;
                    goto LABEL_19;
                  case 37:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 1703936;
                    goto LABEL_19;
                  case 39:
                    v18 = 0;
                    v19 = 1769472;
                    goto LABEL_19;
                  case 48:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 1835008;
                    goto LABEL_19;
                  case 49:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 1900544;
                    goto LABEL_19;
                  case 50:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 1966080;
                    goto LABEL_19;
                  case 51:
                    v18 = 0;
                    *v15 = *v12;
                    v19 = 2031616;
                    goto LABEL_19;
                  case 52:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 0x200000;
                    goto LABEL_19;
                  case 53:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 2162688;
                    goto LABEL_19;
                  case 54:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 2228224;
                    goto LABEL_19;
                  case 55:
                    v18 = 0;
                    *v16 = *(_QWORD *)v12;
                    v19 = 2293760;
                    goto LABEL_19;
                  default:
                    goto LABEL_30;
                }
                goto LABEL_30;
              }
              if (v17 == 998)
              {
                v18 = 0;
                v19 = 2359296;
                goto LABEL_19;
              }
              if (v17 == 999)
              {
                v18 = 0;
                v19 = 2424832;
                goto LABEL_19;
              }
            }
          }
        }
LABEL_30:
        v12 += 8;
        --v10;
      }
      while (v10);
    }
    *(_QWORD *)(a2 + 24) = v9;
  }
  return inited;
}

uint64_t ssft_hlp_ReadStopFlag(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  v4 = critsec_Enter(*(_QWORD **)(a1 + 80));
  if ((v4 & 0x80000000) != 0)
  {
    v10 = v4;
    log_OutPublic(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)"VEAPI", 18033, (uint64_t)"%s%x", v5, v6, v7, v8, "lhError");
    return v10;
  }
  else
  {
    *a2 = *(_DWORD *)(a1 + 88) == 6;
    return critsec_Leave(*(_QWORD **)(a1 + 80));
  }
}

uint64_t bet7_parse_multicore_hdr(uint64_t a1)
{
  BOOL v2;
  BOOL v3;
  unsigned int v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  unsigned int v9;
  char *v11;
  char *__s1;
  uint64_t v13;

  __s1 = 0;
  v13 = 0;
  v11 = 0;
  if (brk_TagIteratorOpen(*(_QWORD *)(a1 + 24), "multicore", "PARAMETERS/*", 1, &v13))
    v2 = 1;
  else
    v2 = v13 == 0;
  if (!v2)
  {
    while ((brk_TagIteratorNext(v13, (uint64_t)&__s1, (uint64_t)&v11) & 0x80000000) == 0)
    {
      if (cstdlib_strcmp(__s1, "affinitylist"))
        v3 = 1;
      else
        v3 = v11 == 0;
      if (!v3 && (paramc_ParamSetStr(*(_QWORD *)(a1 + 40), (uint64_t)__s1, v11) & 0x1FFF) == 0xA)
        break;
      if (!cstdlib_strcmp(__s1, "forceaffinity") && v11 != 0)
      {
        v5 = *v11 - 48;
        v6 = v5 > 0x3E;
        v7 = (1 << v5) & 0x4040000040400001;
        v8 = v6 || v7 == 0;
        v9 = v8;
        if ((paramc_ParamSetInt(*(_QWORD *)(a1 + 40), (uint64_t)"forceaffinity", v9) & 0x1FFF) == 0xA)
          break;
      }
    }
    brk_TagIteratorClose(v13);
  }
  return 0;
}

uint64_t XLIT_strUnicodeWideToWin1252(int *a1, unsigned int *a2, _BYTE *a3, int32x4_t *a4)
{
  BOOL v7;
  int v8;
  int v9;
  unsigned int v11;
  int v12;
  int *v13;
  int v14;
  int32x4_t *v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  char v21;

  v21 = 0;
  if (a3)
    v7 = *a2 == 0;
  else
    v7 = 1;
  v8 = !v7;
  v9 = *a1;
  if (v9)
  {
    v11 = 0;
    v12 = 0;
    v13 = a1 + 1;
    v14 = v8;
    v15 = a4;
    do
    {
      v16 = XLIT_chUnicodeWideToWin1252(v9, &v21);
      if (v16)
      {
        if (a4)
          *v15++ = vdupq_n_s32(v11);
      }
      else
      {
        if (a4)
        {
          v15->i64[0] = -1;
          v15->i64[1] = -1;
          ++v15;
        }
        v12 = 1;
      }
      v17 = 0;
      v18 = v11 + v16;
      if (v14 && v18 < *a2)
      {
        a3[v11] = v21;
        v17 = 1;
      }
      v19 = *v13++;
      v9 = v19;
      v11 = v18;
      v14 = v17;
    }
    while (v19);
    if (v17)
      goto LABEL_20;
  }
  else
  {
    v12 = 0;
    v18 = 0;
    if (v8)
    {
LABEL_20:
      a3[v18] = 0;
      *a2 = v18 + 1;
      if (v12)
        return 52453380;
      else
        return 0;
    }
  }
  if (a3)
    cstdlib_memset(a3, 0, *a2);
  *a2 = v18 + 1;
  return 2199937033;
}

uint64_t XLIT_chUnicodeWideToWin1252(int a1, char *a2)
{
  uint64_t result;
  char v5;

  if ((a1 - 65534) < 2 || a1 == 65279)
    return 0;
  if (a1 <= 127 || (a1 - 160) <= 0x5F)
  {
    v5 = a1;
LABEL_10:
    *a2 = v5;
    return 1;
  }
  result = 0;
  v5 = 0x80;
  if (a1 > 8202)
  {
    if (a1 <= 8248)
    {
      switch(a1)
      {
        case 8211:
          v5 = -106;
          goto LABEL_10;
        case 8212:
          v5 = -105;
          goto LABEL_10;
        case 8213:
        case 8214:
        case 8215:
        case 8219:
        case 8223:
        case 8227:
        case 8228:
        case 8229:
        case 8231:
        case 8232:
        case 8233:
        case 8234:
        case 8235:
        case 8236:
        case 8237:
        case 8238:
        case 8239:
          return result;
        case 8216:
          v5 = -111;
          goto LABEL_10;
        case 8217:
          v5 = -110;
          goto LABEL_10;
        case 8218:
          v5 = -126;
          goto LABEL_10;
        case 8220:
          v5 = -109;
          goto LABEL_10;
        case 8221:
          v5 = -108;
          goto LABEL_10;
        case 8222:
          v5 = -124;
          goto LABEL_10;
        case 8224:
          v5 = -122;
          goto LABEL_10;
        case 8225:
          v5 = -121;
          goto LABEL_10;
        case 8226:
          v5 = -107;
          goto LABEL_10;
        case 8230:
          v5 = -123;
          goto LABEL_10;
        case 8240:
          v5 = -119;
          goto LABEL_10;
        default:
          if (a1 != 8203)
            return result;
          v5 = 32;
          break;
      }
      goto LABEL_10;
    }
    if (a1 <= 8351)
    {
      if (a1 == 8249)
      {
        v5 = -117;
        goto LABEL_10;
      }
      if (a1 == 8250)
      {
        v5 = -101;
        goto LABEL_10;
      }
    }
    else
    {
      if (a1 == 8352 || a1 == 8364)
        goto LABEL_10;
      if (a1 == 8482)
      {
        v5 = -103;
        goto LABEL_10;
      }
    }
  }
  else if (a1 > 338)
  {
    if (a1 <= 380)
    {
      if (a1 > 352)
      {
        if (a1 == 353)
        {
          v5 = -102;
          goto LABEL_10;
        }
        if (a1 == 376)
        {
          v5 = -97;
          goto LABEL_10;
        }
      }
      else
      {
        if (a1 == 339)
        {
          v5 = -100;
          goto LABEL_10;
        }
        if (a1 == 352)
        {
          v5 = -118;
          goto LABEL_10;
        }
      }
    }
    else if (a1 <= 401)
    {
      if (a1 == 381)
      {
LABEL_54:
        v5 = -114;
        goto LABEL_10;
      }
      if (a1 == 382)
        goto LABEL_44;
    }
    else
    {
      switch(a1)
      {
        case 402:
          v5 = -125;
          goto LABEL_10;
        case 710:
          v5 = -120;
          goto LABEL_10;
        case 732:
          v5 = -104;
          goto LABEL_10;
      }
    }
  }
  else
  {
    if (a1 <= 156)
    {
      switch(a1)
      {
        case 141:
          v5 = -115;
          goto LABEL_10;
        case 142:
          goto LABEL_54;
        case 143:
          v5 = -113;
          goto LABEL_10;
        case 144:
          v5 = -112;
          goto LABEL_10;
        default:
          if (a1 == 128)
            goto LABEL_10;
          if (a1 != 129)
            return result;
          v5 = -127;
          break;
      }
      goto LABEL_10;
    }
    if (a1 <= 159)
    {
      if (a1 == 157)
      {
        v5 = -99;
        goto LABEL_10;
      }
      if (a1 != 158)
        return result;
LABEL_44:
      v5 = -98;
      goto LABEL_10;
    }
    if (a1 == 160)
    {
      v5 = -96;
      goto LABEL_10;
    }
    if (a1 == 338)
    {
      v5 = -116;
      goto LABEL_10;
    }
  }
  return result;
}

uint64_t XLIT_strWin1252ToUnicodeWide(char *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  BOOL v6;
  int v7;
  char *v9;
  int v10;
  int v11;
  _DWORD *v12;
  unsigned int v13;
  uint64_t v15;
  int v17;

  v17 = 0;
  if (a3)
    v6 = *a2 == 0;
  else
    v6 = 1;
  v7 = !v6;
  if (*a1)
  {
    v9 = a1;
    v10 = 0;
    v11 = 0;
    v12 = a4;
    do
    {
      v13 = XLIT_chWin1252ToUnicodeWide(v9, &v17);
      if (v13)
      {
        if (a4)
          *v12++ = v10;
        if (*a2 <= (4 * (v10 + 1)) || v7 == 0)
        {
          v7 = 0;
        }
        else
        {
          a3[v10] = v17;
          v7 = 1;
        }
        ++v10;
      }
      else
      {
        if (a4)
          *v12++ = -1;
        v11 = 1;
      }
      if (v13 <= 1)
        v15 = 1;
      else
        v15 = v13;
      v9 += v15;
    }
    while (*v9);
    if (v7)
      goto LABEL_27;
  }
  else
  {
    v11 = 0;
    v10 = 0;
    if (v7)
    {
LABEL_27:
      a3[v10] = 0;
      *a2 = 4 * v10 + 4;
      if (v11)
        return 52469764;
      else
        return 0;
    }
  }
  if (a3)
    cstdlib_memset(a3, 0, *a2);
  *a2 = 4 * v10 + 4;
  return 2199953417;
}

uint64_t XLIT_chWin1252ToUnicodeWide(char *a1, _DWORD *a2)
{
  int v2;
  unint64_t v3;

  v2 = *a1;
  if (*a1 >= -96)
    goto LABEL_4;
  v3 = (char)v2 ^ 0xFFFFFFFFFFFFFF80;
  if (v3 <= 0x1F)
  {
    v2 = dword_214FC1194[v3];
LABEL_4:
    *a2 = v2;
    return 1;
  }
  return 0;
}

void TTSVocalizerDataClassCreate_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1_0(&dword_214A39000, a2, a3, "Error finding gender data: %@", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_2_0();
}

void TTSVocalizerDataClassCreate_cold_2(uint64_t a1, NSObject *a2)
{
  int *v4;
  char *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v4 = __error();
  v5 = strerror(*v4);
  v7 = 136315394;
  v8 = a1;
  v9 = 2080;
  v10 = v5;
  OUTLINED_FUNCTION_3(&dword_214A39000, a2, v6, "couldn't map data at path %s error: %s", (uint8_t *)&v7);
}

void TTSVocalizerDataClassCreate_cold_3(uint64_t *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v3 = *a1;
  v4 = 138412546;
  v5 = v3;
  v6 = 2112;
  v7 = 0;
  OUTLINED_FUNCTION_3(&dword_214A39000, a2, a3, "Error, %@ voice does not have broker file info %@", (uint8_t *)&v4);
  OUTLINED_FUNCTION_2_0();
}

void TTSVocalizerDataClassCreate_cold_4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1_0(&dword_214A39000, a2, a3, "Error attempting to find maui broker file: %@", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_2_0();
}

void TTSVocalizerDataClassCopyResourceURL_cold_1(uint64_t a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 104);
  v4 = *(_QWORD *)(a1 + 80);
  v5 = 138412546;
  v6 = v3;
  v7 = 2048;
  v8 = v4;
  OUTLINED_FUNCTION_3(&dword_214A39000, a2, a3, "Unable to find resource path for voice name: %@, type: %lu", (uint8_t *)&v5);
  OUTLINED_FUNCTION_2_0();
}

void _TTSVocalizerDataStreamImplOpen_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_0(&dword_214A39000, a2, a3, "Found data at path %s", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_2_0();
}

void _TTSVocalizerDataStreamImplOpen_cold_2(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_0(&dword_214A39000, a2, a3, "Looking for data %s", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_2_0();
}

void _TTSVocalizerDataMappingImplMap_cold_1(int a1, NSObject *a2, double a3)
{
  uint64_t v4;
  _DWORD v5[2];
  __int16 v6;
  double v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v5[0] = 67109376;
  v5[1] = a1;
  v6 = 2048;
  v7 = CFAbsoluteTimeGetCurrent() - a3;
  OUTLINED_FUNCTION_2_1(&dword_214A39000, a2, v4, "-----------> done preheating %u bytes (%g seconds)\n", (uint8_t *)v5);
}

void _TTSVocalizerDataMappingImplMap_cold_2()
{
  __assert_rtn("_TTSVocalizerDataMappingImplMap", "TTSVocalizerPlatform.m", 552, "info->mappedData == NULL");
}

void _TTSVocalizerLogError_cold_1(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  v2 = 136315138;
  v3 = a1;
  _os_log_error_impl(&dword_214A39000, a2, OS_LOG_TYPE_ERROR, "%s\n", (uint8_t *)&v2, 0xCu);
  OUTLINED_FUNCTION_2_0();
}

void _TTSVocalizerLogDiagnostic_cold_1(uint64_t a1, int a2, NSObject *a3)
{
  _DWORD v3[2];
  __int16 v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v3[0] = 67109378;
  v3[1] = a2;
  v4 = 2080;
  v5 = a1;
  OUTLINED_FUNCTION_2_1(&dword_214A39000, a3, (uint64_t)a3, "%d: %s\n", (uint8_t *)v3);
  OUTLINED_FUNCTION_2_0();
}

void _TTSMauiVocalizerDataMappingImplMap_cold_1()
{
  __assert_rtn("_TTSMauiVocalizerDataMappingImplMap", "TTSMauiVocalizerPlatform.m", 796, "info->mappedData == NULL");
}

void _TTSMauiVocalizerLogError_cold_1()
{
  os_log_t v0;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x24BDAC8D0];
  OUTLINED_FUNCTION_0_1();
  _os_log_error_impl(&dword_214A39000, v0, OS_LOG_TYPE_ERROR, "Unknown Vocalizer Error: %d: %s\n", v1, 0x12u);
  OUTLINED_FUNCTION_2_0();
}

void _TTSMauiVocalizerLogDiagnostic_cold_1()
{
  os_log_t v0;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x24BDAC8D0];
  OUTLINED_FUNCTION_0_1();
  _os_log_debug_impl(&dword_214A39000, v0, OS_LOG_TYPE_DEBUG, "Log Diagnostic: %d: %s\n", v1, 0x12u);
  OUTLINED_FUNCTION_2_0();
}

uint64_t sub_214EF8D6C()
{
  return MEMORY[0x24BDCC6D8]();
}

uint64_t sub_214EF8D78()
{
  return MEMORY[0x24BDCD2F0]();
}

uint64_t sub_214EF8D84()
{
  return MEMORY[0x24BDCD2F8]();
}

uint64_t sub_214EF8D90()
{
  return MEMORY[0x24BDCD9C0]();
}

uint64_t sub_214EF8D9C()
{
  return MEMORY[0x24BDCDAC0]();
}

uint64_t sub_214EF8DA8()
{
  return MEMORY[0x24BDCDCA0]();
}

uint64_t sub_214EF8DB4()
{
  return MEMORY[0x24BDCDCE0]();
}

uint64_t sub_214EF8DC0()
{
  return MEMORY[0x24BDCE8B0]();
}

uint64_t sub_214EF8DCC()
{
  return MEMORY[0x24BDCE8F8]();
}

uint64_t sub_214EF8DD8()
{
  return MEMORY[0x24BDCE900]();
}

uint64_t sub_214EF8DE4()
{
  return MEMORY[0x24BDCEA40]();
}

uint64_t sub_214EF8DF0()
{
  return MEMORY[0x24BDCEA58]();
}

uint64_t sub_214EF8DFC()
{
  return MEMORY[0x24BDCEEA8]();
}

uint64_t sub_214EF8E08()
{
  return MEMORY[0x24BEB5CD8]();
}

uint64_t sub_214EF8E14()
{
  return MEMORY[0x24BEB5CE8]();
}

uint64_t sub_214EF8E20()
{
  return MEMORY[0x24BEB5CF0]();
}

uint64_t sub_214EF8E2C()
{
  return MEMORY[0x24BEB5D00]();
}

uint64_t sub_214EF8E38()
{
  return MEMORY[0x24BEB5D08]();
}

uint64_t sub_214EF8E44()
{
  return MEMORY[0x24BEB5D10]();
}

uint64_t sub_214EF8E50()
{
  return MEMORY[0x24BEB5E80]();
}

uint64_t sub_214EF8E5C()
{
  return MEMORY[0x24BEB60A0]();
}

uint64_t sub_214EF8E68()
{
  return MEMORY[0x24BEB60A8]();
}

uint64_t sub_214EF8E74()
{
  return MEMORY[0x24BEB60B0]();
}

uint64_t sub_214EF8E80()
{
  return MEMORY[0x24BEB60B8]();
}

uint64_t sub_214EF8E8C()
{
  return MEMORY[0x24BEB60D8]();
}

uint64_t sub_214EF8E98()
{
  return MEMORY[0x24BEB60E0]();
}

uint64_t sub_214EF8EA4()
{
  return MEMORY[0x24BEB6110]();
}

uint64_t sub_214EF8EB0()
{
  return MEMORY[0x24BEB6118]();
}

uint64_t sub_214EF8EBC()
{
  return MEMORY[0x24BEB6120]();
}

uint64_t sub_214EF8EC8()
{
  return MEMORY[0x24BEB6128]();
}

uint64_t sub_214EF8ED4()
{
  return MEMORY[0x24BEB6198]();
}

uint64_t sub_214EF8EE0()
{
  return MEMORY[0x24BEB61A0]();
}

uint64_t sub_214EF8EEC()
{
  return MEMORY[0x24BEE73C0]();
}

uint64_t sub_214EF8EF8()
{
  return MEMORY[0x24BEE76E8]();
}

uint64_t sub_214EF8F04()
{
  return MEMORY[0x24BEE5370]();
}

uint64_t sub_214EF8F10()
{
  return MEMORY[0x24BEE5438]();
}

uint64_t sub_214EF8F1C()
{
  return MEMORY[0x24BEE5458]();
}

uint64_t sub_214EF8F28()
{
  return MEMORY[0x24BEE54C8]();
}

uint64_t sub_214EF8F34()
{
  return MEMORY[0x24BEE5500]();
}

uint64_t sub_214EF8F40()
{
  return MEMORY[0x24BEE5570]();
}

uint64_t sub_214EF8F4C()
{
  return MEMORY[0x24BEE5590]();
}

uint64_t sub_214EF8F58()
{
  return MEMORY[0x24BEE5628]();
}

uint64_t sub_214EF8F64()
{
  return MEMORY[0x24BEE5068]();
}

uint64_t sub_214EF8F70()
{
  return MEMORY[0x24BEE5070]();
}

uint64_t sub_214EF8F7C()
{
  return MEMORY[0x24BEE5080]();
}

uint64_t sub_214EF8F88()
{
  return MEMORY[0x24BEE5090]();
}

uint64_t sub_214EF8F94()
{
  return MEMORY[0x24BEE51B8]();
}

uint64_t sub_214EF8FA0()
{
  return MEMORY[0x24BEE75E8]();
}

uint64_t sub_214EF8FAC()
{
  return MEMORY[0x24BEE0980]();
}

uint64_t sub_214EF8FB8()
{
  return MEMORY[0x24BDCF9E0]();
}

uint64_t sub_214EF8FC4()
{
  return MEMORY[0x24BDCFA28]();
}

uint64_t sub_214EF8FD0()
{
  return MEMORY[0x24BEE09F0]();
}

uint64_t sub_214EF8FDC()
{
  return MEMORY[0x24BEE0A50]();
}

uint64_t sub_214EF8FE8()
{
  return MEMORY[0x24BEE0A70]();
}

uint64_t sub_214EF8FF4()
{
  return MEMORY[0x24BEB62E0]();
}

uint64_t sub_214EF9000()
{
  return MEMORY[0x24BEE0B20]();
}

uint64_t sub_214EF900C()
{
  return MEMORY[0x24BEE0B38]();
}

uint64_t sub_214EF9018()
{
  return MEMORY[0x24BEE0B68]();
}

uint64_t sub_214EF9024()
{
  return MEMORY[0x24BEE0B88]();
}

uint64_t sub_214EF9030()
{
  return MEMORY[0x24BEE0BB0]();
}

uint64_t sub_214EF903C()
{
  return MEMORY[0x24BEE0BC0]();
}

uint64_t sub_214EF9048()
{
  return MEMORY[0x24BEE0C10]();
}

uint64_t sub_214EF9054()
{
  return MEMORY[0x24BEE0C30]();
}

uint64_t sub_214EF9060()
{
  return MEMORY[0x24BEE0C38]();
}

uint64_t sub_214EF906C()
{
  return MEMORY[0x24BEE0C90]();
}

uint64_t sub_214EF9078()
{
  return MEMORY[0x24BEE0CA0]();
}

uint64_t sub_214EF9084()
{
  return MEMORY[0x24BEE0CA8]();
}

uint64_t sub_214EF9090()
{
  return MEMORY[0x24BEE0DE0]();
}

uint64_t sub_214EF909C()
{
  return MEMORY[0x24BEE1110]();
}

uint64_t sub_214EF90A8()
{
  return MEMORY[0x24BDCFBA8]();
}

uint64_t sub_214EF90B4()
{
  return MEMORY[0x24BDCFBC8]();
}

uint64_t sub_214EF90C0()
{
  return MEMORY[0x24BEE1128]();
}

uint64_t sub_214EF90CC()
{
  return MEMORY[0x24BEE1160]();
}

uint64_t sub_214EF90D8()
{
  return MEMORY[0x24BEE1190]();
}

uint64_t sub_214EF90E4()
{
  return MEMORY[0x24BEE11B8]();
}

uint64_t sub_214EF90F0()
{
  return MEMORY[0x24BDCFD70]();
}

uint64_t sub_214EF90FC()
{
  return MEMORY[0x24BEE78F0]();
}

uint64_t sub_214EF9108()
{
  return MEMORY[0x24BEE7908]();
}

uint64_t sub_214EF9114()
{
  return MEMORY[0x24BEE7910]();
}

uint64_t sub_214EF9120()
{
  return MEMORY[0x24BEE5688]();
}

uint64_t sub_214EF912C()
{
  return MEMORY[0x24BEE5760]();
}

uint64_t sub_214EF9138()
{
  return MEMORY[0x24BEE5790]();
}

uint64_t sub_214EF9144()
{
  return MEMORY[0x24BEE57A0]();
}

uint64_t sub_214EF9150()
{
  return MEMORY[0x24BEE5918]();
}

uint64_t sub_214EF915C()
{
  return MEMORY[0x24BEE5928]();
}

uint64_t sub_214EF9168()
{
  return MEMORY[0x24BEE5298]();
}

uint64_t sub_214EF9174()
{
  return MEMORY[0x24BDD01E0]();
}

uint64_t sub_214EF9180()
{
  return MEMORY[0x24BEE1C68]();
}

uint64_t sub_214EF918C()
{
  return MEMORY[0x24BEE1E68]();
}

uint64_t sub_214EF9198()
{
  return MEMORY[0x24BDD0568]();
}

uint64_t sub_214EF91A4()
{
  return MEMORY[0x24BDD0600]();
}

uint64_t sub_214EF91B0()
{
  return MEMORY[0x24BDD0630]();
}

uint64_t sub_214EF91BC()
{
  return MEMORY[0x24BEE22C0]();
}

uint64_t sub_214EF91C8()
{
  return MEMORY[0x24BEE2658]();
}

uint64_t sub_214EF91D4()
{
  return MEMORY[0x24BEE2660]();
}

uint64_t sub_214EF91E0()
{
  return MEMORY[0x24BEE2908]();
}

uint64_t sub_214EF91EC()
{
  return MEMORY[0x24BEE2938]();
}

uint64_t sub_214EF91F8()
{
  return MEMORY[0x24BEE2958]();
}

uint64_t sub_214EF9204()
{
  return MEMORY[0x24BEE2980]();
}

uint64_t sub_214EF9210()
{
  return MEMORY[0x24BEE2988]();
}

uint64_t sub_214EF921C()
{
  return MEMORY[0x24BEE3068]();
}

uint64_t sub_214EF9228()
{
  return MEMORY[0x24BEE3098]();
}

uint64_t sub_214EF9234()
{
  return MEMORY[0x24BEE3540]();
}

uint64_t sub_214EF9240()
{
  return MEMORY[0x24BEE3548]();
}

uint64_t sub_214EF924C()
{
  return MEMORY[0x24BEE3A30]();
}

uint64_t sub_214EF9258()
{
  return MEMORY[0x24BDD0708]();
}

uint64_t sub_214EF9264()
{
  return MEMORY[0x24BEE42E0]();
}

uint64_t sub_214EF9270()
{
  return MEMORY[0x24BEE4318]();
}

uint64_t sub_214EF927C()
{
  return MEMORY[0x24BEE4328]();
}

uint64_t AXRuntimeCheck_MauiSSE()
{
  return MEMORY[0x24BDFE308]();
}

uint64_t AXTTSLogCommon()
{
  return MEMORY[0x24BDFE3C0]();
}

uint64_t AX_PERFORM_WITH_LOCK()
{
  return MEMORY[0x24BDFE3F8]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x24BDBB780]();
  return result;
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x24BDBBA80](bundle, resourceName, resourceType, subDirName);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return (CFBundleRef)MEMORY[0x24BDBBA98](allocator, bundleURL);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x24BDBBE48](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x24BDBC520](alloc, theString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x24BDBC568](alloc, cStr, *(_QWORD *)&encoding);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x24BDBC640](string, buffer, maxBufLen);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC660](length, *(_QWORD *)&encoding);
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  return MEMORY[0x24BDBC668](string);
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x24BDBC6A8](theString, prefix);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x24BDBC798](anURL, pathStyle);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x24BDBC7F8](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x24BDBC858](allocator, filePath, pathStyle, isDirectory);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x24BDBC898](url, resolveAgainstBase, buffer, maxBufLen);
}

uint64_t TTSChoseong_JongseongToHangul()
{
  return MEMORY[0x24BEB6288]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x24BDAC720](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x24BDAC738](aBlock);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

BOOL std::locale::has_facet(const std::locale *this, std::locale::id *a2)
{
  return MEMORY[0x24BEDAA58](this, a2);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x24BEDAA60](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x24BEDAA70](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::nested_exception *__cdecl std::nested_exception::nested_exception(std::nested_exception *this)
{
  return (std::nested_exception *)MEMORY[0x24BEDAB98](this);
}

void std::nested_exception::~nested_exception(std::nested_exception *this)
{
  MEMORY[0x24BEDABA0](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x24BEDABE8](__n);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x24BEDAD00](this, __str);
}

uint64_t std::istream::read()
{
  return MEMORY[0x24BEDAE18]();
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x24BEDAE50]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x24BEDAE70]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x24BEDAEE0]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x24BEDAEE8]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x24BEDAEF0]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x24BEDAEF8]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x24BEDAF00]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x24BEDAF10]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x24BEDAF48]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x24BEDB010]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x24BEDB048]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x24BEDB050]();
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
  MEMORY[0x24BEDB0F8](this);
}

void std::condition_variable::notify_one(std::condition_variable *this)
{
  MEMORY[0x24BEDB100](this);
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
  MEMORY[0x24BEDB110](this, __lk);
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
  MEMORY[0x24BEDB118](this);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB180](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB190](this);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x24BEDB368](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x24BEDB370](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x24BEDB380](this);
}

uint64_t std::__sort<std::__less<double,double> &,double *>()
{
  return MEMORY[0x24BEDB3A0]();
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x24BEDB3E0]();
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x24BEDB438](this, a2);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x24BEDB448](this);
}

const std::locale *__cdecl std::locale::operator=(std::locale *this, const std::locale *a2)
{
  return (const std::locale *)MEMORY[0x24BEDB450](this, a2);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x24BEDB500](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x24BEDB518](this, __sb);
}

void std::ios_base::swap(std::ios_base *this, std::ios_base *a2)
{
  MEMORY[0x24BEDB528](this, a2);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x24BEDB530](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x24BEDB5E8]();
}

std::bad_cast *__cdecl std::bad_cast::bad_cast(std::bad_cast *this)
{
  return (std::bad_cast *)MEMORY[0x24BEDB640](this);
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x24BEDB680](this);
}

{
  MEMORY[0x24BEDB688](this);
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

void operator delete[](void *__p)
{
  off_24D27C348(__p);
}

void operator delete(void *__p)
{
  off_24D27C350(__p);
}

void *__cdecl operator new[](size_t __sz)
{
  return (void *)off_24D27C358(__sz);
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24D27C360(__sz);
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x24BEDB928]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void *__cxa_get_exception_ptr(void *a1)
{
  return (void *)MEMORY[0x24BEDB938](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x24BEDB958]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

float __exp10f(float a1)
{
  float result;

  MEMORY[0x24BDAC7E0](a1);
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x24BDAC838](*(_QWORD *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x24BDAC848]();
}

__float2 __sincosf_stret(float a1)
{
  float v1;
  float v2;
  __float2 result;

  MEMORY[0x24BDAC898](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  return MEMORY[0x24BDAC8B8](a1, *(_QWORD *)&a2, a3, a4);
}

uint64_t __strcat_chk()
{
  return MEMORY[0x24BDAC8F8]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x24BDAC930](*(_QWORD *)&a1);
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB68](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
  MEMORY[0x24BDAD160](__buf, __nbytes);
}

double atof(const char *a1)
{
  double result;

  MEMORY[0x24BDAD250](a1);
  return result;
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

int close(int a1)
{
  return MEMORY[0x24BDAD9D8](*(_QWORD *)&a1);
}

long double cos(long double __x)
{
  long double result;

  MEMORY[0x24BDADBE0](__x);
  return result;
}

float cosf(float a1)
{
  float result;

  MEMORY[0x24BDADBE8](a1);
  return result;
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x24BDADEB8](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x24BDADEC8](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x24BDADF28](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x24BDADF30](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADF38](dsema, timeout);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

int dlclose(void *__handle)
{
  return MEMORY[0x24BDAE060](__handle);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x24BDAE070](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x24BDAE088](__handle, __symbol);
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x24BDAE270](__x);
  return result;
}

float expf(float a1)
{
  float result;

  MEMORY[0x24BDAE288](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x24BDAE2E0](a1);
}

int feof(FILE *a1)
{
  return MEMORY[0x24BDAE328](a1);
}

int ferror(FILE *a1)
{
  return MEMORY[0x24BDAE330](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x24BDAE350](a1);
}

int fileno(FILE *a1)
{
  return MEMORY[0x24BDAE390](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x24BDAE410](__filename, __mode);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x24BDAE440](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE448](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x24BDAE4D8](a1, a2, *(_QWORD *)&a3);
}

int fseeko(FILE *__stream, off_t a2, int __whence)
{
  return MEMORY[0x24BDAE4E0](__stream, a2, *(_QWORD *)&__whence);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x24BDAE508](*(_QWORD *)&a1, a2);
}

off_t ftello(FILE *__stream)
{
  return MEMORY[0x24BDAE538](__stream);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE590](__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x24BDAE5F0](a1);
}

int getpagesize(void)
{
  return MEMORY[0x24BDAE6B8]();
}

long double ldexp(long double __x, int __e)
{
  long double result;

  MEMORY[0x24BDAEA30](*(_QWORD *)&__e, __x);
  return result;
}

long double log(long double __x)
{
  long double result;

  MEMORY[0x24BDAEAA8](__x);
  return result;
}

float log10f(float a1)
{
  float result;

  MEMORY[0x24BDAEAB8](a1);
  return result;
}

float logf(float a1)
{
  float result;

  MEMORY[0x24BDAEAF8](a1);
  return result;
}

void longjmp(jmp_buf a1, int a2)
{
  MEMORY[0x24BDAEB00](a1, *(_QWORD *)&a2);
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x24BDAED08](__size);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x24BDAED60](ptr);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED88](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE70](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x24BDAEEB0](__b, __pattern16, __len);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x24BDAEFA8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x24BDAEFF0](a1, a2);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

id objc_allocWithZone(Class a1)
{
  return (id)MEMORY[0x24BEDCF78](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x24BEDCF88]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x24BEDCFA8](a1);
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x24BEDD030](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x24BEDD038](location);
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x24BEDD068](obj);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x24BEDD0B0](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x24BEDD0C0](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x24BEDD0E8](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD108](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x24BEDD138]();
}

uint64_t objc_opt_self()
{
  return MEMORY[0x24BEDD168]();
}

void objc_release(id a1)
{
  MEMORY[0x24BEDD188](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B8](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x24BEDD3D0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x24BEDD410](location, obj);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x24BDAF228](a1, *(_QWORD *)&a2);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAF688](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAF690](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x24BDAF6A8](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x24BDAF790](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x24BDAF798](__attr, *(_QWORD *)&__qos_class, *(_QWORD *)&__relative_priority);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x24BDAF7A0](a1, *(_QWORD *)&a2);
}

int pthread_attr_setstacksize(pthread_attr_t *a1, size_t a2)
{
  return MEMORY[0x24BDAF7C0](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x24BDAF818](a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x24BDAF880](a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8C0](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x24BDAF8C8](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8D0](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8E0](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x24BDAF8E8](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x24BDAF8F0](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x24BDAF908](a1, *(_QWORD *)&a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x24BDAF978]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x24BDAFA18](__base, __nel, __width, __compar);
}

void *__cdecl realloc(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x24BDAFAB0](__ptr, __size);
}

int setjmp(jmp_buf a1)
{
  return MEMORY[0x24BDAFD30](a1);
}

long double sin(long double __x)
{
  long double result;

  MEMORY[0x24BDAFE18](__x);
  return result;
}

float sinf(float a1)
{
  float result;

  MEMORY[0x24BDAFE20](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int sprintf(char *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAFE60](a1, a2);
}

void srand(unsigned int a1)
{
  MEMORY[0x24BDAFE80](*(_QWORD *)&a1);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAFEA0](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x24BDAFEA8](a1, a2);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x24BDAFEE0](__s1, __s2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFEE8](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x24BDAFF00](__dst, __src);
}

size_t strcspn(const char *__s, const char *__charset)
{
  return MEMORY[0x24BDAFF08](__s, __charset);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x24BDAFF18](*(_QWORD *)&__errnum);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x24BDAFF38](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x24BDAFF60](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x24BDAFF68](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x24BDAFF70](__dst, __src, __n);
}

char *__cdecl strpbrk(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x24BDAFF90](__s1, __s2);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFFA8](__s, *(_QWORD *)&__c);
}

size_t strspn(const char *__s, const char *__charset)
{
  return MEMORY[0x24BDAFFC0](__s, __charset);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x24BDAFFC8](__s1, __s2);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0000](__str, __endptr, *(_QWORD *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0030](__str, __endptr, *(_QWORD *)&__base);
}

uint64_t swift_allocObject()
{
  return MEMORY[0x24BEE4B70]();
}

uint64_t swift_arrayInitWithCopy()
{
  return MEMORY[0x24BEE4BA0]();
}

uint64_t swift_beginAccess()
{
  return MEMORY[0x24BEE4BB8]();
}

uint64_t swift_bridgeObjectRelease()
{
  return MEMORY[0x24BEE4BC0]();
}

uint64_t swift_bridgeObjectRelease_n()
{
  return MEMORY[0x24BEE4BC8]();
}

uint64_t swift_bridgeObjectRetain()
{
  return MEMORY[0x24BEE4BD0]();
}

uint64_t swift_deallocObject()
{
  return MEMORY[0x24BEE4C10]();
}

uint64_t swift_deallocPartialClassInstance()
{
  return MEMORY[0x24BEE4C18]();
}

uint64_t swift_dynamicCastObjCClass()
{
  return MEMORY[0x24BEE4C60]();
}

uint64_t swift_dynamicCastObjCClassUnconditional()
{
  return MEMORY[0x24BEE4C68]();
}

uint64_t swift_endAccess()
{
  return MEMORY[0x24BEE4C98]();
}

uint64_t swift_errorRelease()
{
  return MEMORY[0x24BEE4CA0]();
}

uint64_t swift_getErrorValue()
{
  return MEMORY[0x24BEE4D18]();
}

uint64_t swift_getForeignTypeMetadata()
{
  return MEMORY[0x24BEE4D40]();
}

uint64_t swift_getObjCClassFromMetadata()
{
  return MEMORY[0x24BEE4DA0]();
}

uint64_t swift_getObjCClassMetadata()
{
  return MEMORY[0x24BEE4DB0]();
}

uint64_t swift_getSingletonMetadata()
{
  return MEMORY[0x24BEE4DD0]();
}

uint64_t swift_getTypeByMangledNameInContext2()
{
  return MEMORY[0x24BEE4E10]();
}

uint64_t swift_getTypeByMangledNameInContextInMetadataState2()
{
  return MEMORY[0x24BEE4E18]();
}

uint64_t swift_getWitnessTable()
{
  return MEMORY[0x24BEE4E20]();
}

uint64_t swift_initClassMetadata2()
{
  return MEMORY[0x24BEE4E28]();
}

uint64_t swift_isEscapingClosureAtFileLocation()
{
  return MEMORY[0x24BEE4E68]();
}

uint64_t swift_isUniquelyReferenced_nonNull_bridgeObject()
{
  return MEMORY[0x24BEE4E90]();
}

uint64_t swift_isUniquelyReferenced_nonNull_native()
{
  return MEMORY[0x24BEE4E98]();
}

uint64_t swift_once()
{
  return MEMORY[0x24BEE4EC8]();
}

uint64_t swift_release()
{
  return MEMORY[0x24BEE4EF8]();
}

uint64_t swift_retain()
{
  return MEMORY[0x24BEE4F08]();
}

uint64_t swift_slowAlloc()
{
  return MEMORY[0x24BEE4F38]();
}

uint64_t swift_unexpectedError()
{
  return MEMORY[0x24BEE4F68]();
}

uint64_t swift_unknownObjectRelease()
{
  return MEMORY[0x24BEE4F70]();
}

uint64_t swift_unknownObjectRetain()
{
  return MEMORY[0x24BEE4F80]();
}

uint64_t swift_unknownObjectWeakDestroy()
{
  return MEMORY[0x24BEE4FC8]();
}

uint64_t swift_unknownObjectWeakInit()
{
  return MEMORY[0x24BEE4FD0]();
}

uint64_t swift_unknownObjectWeakLoadStrong()
{
  return MEMORY[0x24BEE4FD8]();
}

uint64_t swift_willThrow()
{
  return MEMORY[0x24BEE5050]();
}

uint64_t sysconf(int a1)
{
  return MEMORY[0x24BDB00F0](*(_QWORD *)&a1);
}

long double tan(long double __x)
{
  long double result;

  MEMORY[0x24BDB0138](__x);
  return result;
}

float tanhf(float a1)
{
  float result;

  MEMORY[0x24BDB0150](a1);
  return result;
}

int usleep(useconds_t a1)
{
  return MEMORY[0x24BDB02E8](*(_QWORD *)&a1);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x24BDB0448](__str, __size, __format, a4);
}

size_t wcslen(const __int32 *a1)
{
  return MEMORY[0x24BDB04D0](a1);
}

