void ___ZN2KB20UserDictionaryLoader15create_and_loadERKNS_6StringE_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  void *v5;
  KB::UserDictionaryLoader *v6;
  void *v7;
  id v8;
  _BYTE v9[8];
  void *v10;
  uint8_t buf[4];
  void *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  TIUserDictionaryOSLogFacility();
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Queuing UserDictionary trie load/reload..."), "create_and_load_block_invoke");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    v12 = v5;
    _os_log_impl(&dword_1DA6F2000, v4, OS_LOG_TYPE_INFO, "%@", buf, 0xCu);

  }
  KB::UserDictionaryLoader::dispatch_queue(v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  KB::String::String((KB::String *)v9, (const KB::String *)(a1 + 40));
  v8 = v3;
  TIDispatchAsync();

  if (v10)
  {
    if (v9[6] == 1)
      free(v10);
  }
}

id KB::UserDictionaryLoader::dispatch_queue(KB::UserDictionaryLoader *this)
{
  if (KB::UserDictionaryLoader::dispatch_queue(void)::once_token != -1)
    dispatch_once(&KB::UserDictionaryLoader::dispatch_queue(void)::once_token, &__block_literal_global_17563);
  return (id)KB::UserDictionaryLoader::dispatch_queue(void)::queue;
}

void ___ZN33TIInlineCompletionEventDispatcher19did_update_metadataERKNSt3__18optionalI35TIInlineCompletionAnalyticsMetadataEE_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  KB::String *v6;
  KB::String *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        v6 = (KB::String *)(a1 + 48);
        v7 = (KB::String *)(v5 + 144);
        if (*(unsigned __int8 *)(v5 + 472) == *(unsigned __int8 *)(a1 + 376))
        {
          if (*(_BYTE *)(v5 + 472))
          {
            KB::String::operator=(v7, v6);
            KB::String::operator=((KB::String *)(v5 + 176), (KB::String *)(a1 + 80));
            KB::String::operator=((KB::String *)(v5 + 208), (KB::String *)(a1 + 112));
            KB::String::operator=((KB::String *)(v5 + 240), (KB::String *)(a1 + 144));
            KB::String::operator=((KB::String *)(v5 + 272), (KB::String *)(a1 + 176));
            KB::String::operator=((KB::String *)(v5 + 304), (KB::String *)(a1 + 208));
            *(_BYTE *)(v5 + 336) = *(_BYTE *)(a1 + 240);
            KB::String::operator=((KB::String *)(v5 + 344), (KB::String *)(a1 + 248));
            KB::String::operator=((KB::String *)(v5 + 376), (KB::String *)(a1 + 280));
            KB::String::operator=((KB::String *)(v5 + 408), (KB::String *)(a1 + 312));
            KB::String::operator=((KB::String *)(v5 + 440), (KB::String *)(a1 + 344));
          }
        }
        else if (*(_BYTE *)(v5 + 472))
        {
          v8 = *(void **)(v5 + 448);
          if (v8 && *(_BYTE *)(v5 + 446) == 1)
            free(v8);
          v9 = *(void **)(v5 + 416);
          if (v9 && *(_BYTE *)(v5 + 414) == 1)
            free(v9);
          v10 = *(void **)(v5 + 384);
          if (v10 && *(_BYTE *)(v5 + 382) == 1)
            free(v10);
          v11 = *(void **)(v5 + 352);
          if (v11 && *(_BYTE *)(v5 + 350) == 1)
            free(v11);
          v12 = *(void **)(v5 + 312);
          if (v12 && *(_BYTE *)(v5 + 310) == 1)
            free(v12);
          v13 = *(void **)(v5 + 280);
          if (v13 && *(_BYTE *)(v5 + 278) == 1)
            free(v13);
          v14 = *(void **)(v5 + 248);
          if (v14 && *(_BYTE *)(v5 + 246) == 1)
            free(v14);
          v15 = *(void **)(v5 + 216);
          if (v15 && *(_BYTE *)(v5 + 214) == 1)
            free(v15);
          v16 = *(void **)(v5 + 184);
          if (v16 && *(_BYTE *)(v5 + 182) == 1)
            free(v16);
          v17 = *(void **)(v5 + 152);
          if (v17 && *(_BYTE *)(v5 + 150) == 1)
            free(v17);
          *(_BYTE *)(v5 + 472) = 0;
        }
        else
        {
          std::construct_at[abi:nn180100]<TIInlineCompletionAnalyticsMetadata,TIInlineCompletionAnalyticsMetadata const&,TIInlineCompletionAnalyticsMetadata*>(v7, v6);
          *(_BYTE *)(v5 + 472) = 1;
        }
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v19 = __ldaxr(p_shared_owners);
      while (__stlxr(v19 - 1, p_shared_owners));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

uint64_t WTF::RefCounted<TI::Favonius::Key>::deref(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t v3;
  void *v4;
  unsigned int v5;

  v1 = result;
  v2 = atomic_load((unsigned int *)result);
  if (v2 == 1)
  {
    if (*(unsigned __int16 *)(result + 40) >= 0xFu)
    {
      v3 = *(_QWORD *)(result + 48);
      if (v3)
        MEMORY[0x1DF0A212C](v3, 0x1000C8077774924);
    }
    v4 = *(void **)(v1 + 16);
    if (v4)
    {
      if (*(_BYTE *)(v1 + 14) == 1)
        free(v4);
    }
    JUMPOUT(0x1DF0A2144);
  }
  do
    v5 = __ldaxr((unsigned int *)result);
  while (__stlxr(v5 - 1, (unsigned int *)result));
  return result;
}

void KB::LanguageModelStr::set_inline_completion_analytics_metadata(KB::LanguageModelStr *this, const TIInlineCompletionAnalyticsMetadata *a2)
{
  TIInlineCompletionGeneratorImpl *v2;
  TIInlineCompletionAnalyticsMetadata v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = (TIInlineCompletionGeneratorImpl *)*((_QWORD *)this + 23);
  if (v2)
  {
    KB::String::String((KB::String *)&v4, (const KB::String *)a2);
    KB::String::String((KB::String *)&v4.var1, (const KB::String *)&a2->var1);
    KB::String::String((KB::String *)&v4.var2, (const KB::String *)&a2->var2);
    KB::String::String((KB::String *)&v4.var3, (const KB::String *)&a2->var3);
    KB::String::String((KB::String *)&v4.var4, (const KB::String *)&a2->var4);
    KB::String::String((KB::String *)&v4.var5, (const KB::String *)&a2->var5);
    v4.var6 = a2->var6;
    KB::String::String((KB::String *)&v4.var7, (const KB::String *)&a2->var7);
    KB::String::String((KB::String *)&v4.var8, (const KB::String *)&a2->var8);
    KB::String::String((KB::String *)&v4.var9, (const KB::String *)&a2->var9);
    KB::String::String((KB::String *)&v4.var10, (const KB::String *)&a2->var10);
    TIInlineCompletionGeneratorImpl::setAnalyticsMetaData(v2, &v4);
    if (v4.var10.var4 && v4.var10.var3 == 1)
      free(v4.var10.var4);
    if (v4.var9.var4 && v4.var9.var3 == 1)
      free(v4.var9.var4);
    if (v4.var8.var4 && v4.var8.var3 == 1)
      free(v4.var8.var4);
    if (v4.var7.var4 && v4.var7.var3 == 1)
      free(v4.var7.var4);
    if (v4.var5.var4 && v4.var5.var3 == 1)
      free(v4.var5.var4);
    if (v4.var4.var4 && v4.var4.var3 == 1)
      free(v4.var4.var4);
    if (v4.var3.var4 && v4.var3.var3 == 1)
      free(v4.var3.var4);
    if (v4.var2.var4 && v4.var2.var3 == 1)
      free(v4.var2.var4);
    if (v4.var1.var4 && v4.var1.var3 == 1)
      free(v4.var1.var4);
    if (v4.var0.var4)
    {
      if (v4.var0.var3 == 1)
        free(v4.var0.var4);
    }
  }
}

void TIInlineCompletionEventDispatcher::did_update_metadata(uint64_t a1, _BYTE *a2)
{
  std::__shared_weak_count *v3;
  uint64_t v4;
  uint64_t *p_shared_weak_owners;
  unint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  void *v9;
  unint64_t *v10;
  unint64_t v11;
  int v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  _BYTE v18[328];
  unsigned __int8 v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t);
  void *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  _BYTE v26[328];
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(&v16, *(_QWORD *)a1, *(std::__shared_weak_count **)(a1 + 8));
  v4 = v16;
  v3 = v17;
  if (v17)
  {
    p_shared_weak_owners = &v17->__shared_weak_owners_;
    do
      v6 = __ldxr((unint64_t *)p_shared_weak_owners);
    while (__stxr(v6 + 1, (unint64_t *)p_shared_weak_owners));
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  analytics_queue();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = MEMORY[0x1E0C809B0];
  v21 = 3321888768;
  v22 = ___ZN33TIInlineCompletionEventDispatcher19did_update_metadataERKNSt3__18optionalI35TIInlineCompletionAnalyticsMetadataEE_block_invoke;
  v23 = &__block_descriptor_384_a8_32c127_ZTSKZN33TIInlineCompletionEventDispatcher19did_update_metadataERKNSt3__18optionalI35TIInlineCompletionAnalyticsMetadataEEE3__0_e5_v8__0l;
  v16 = v4;
  v17 = v3;
  if (v3)
  {
    v10 = (unint64_t *)&v3->__shared_weak_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v18[0] = 0;
  v19 = 0;
  v12 = a2[328];
  if (a2[328])
  {
    std::construct_at[abi:nn180100]<TIInlineCompletionAnalyticsMetadata,TIInlineCompletionAnalyticsMetadata const&,TIInlineCompletionAnalyticsMetadata*>(v18, a2);
    v12 = 1;
    v19 = 1;
    v4 = v16;
    v13 = v17;
  }
  else
  {
    v13 = v3;
  }
  v24 = v4;
  v25 = v13;
  if (v13)
  {
    v14 = (unint64_t *)&v13->__shared_weak_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    v12 = v19;
  }
  v26[0] = 0;
  v27 = 0;
  if (v12)
  {
    std::construct_at[abi:nn180100]<TIInlineCompletionAnalyticsMetadata,TIInlineCompletionAnalyticsMetadata const&,TIInlineCompletionAnalyticsMetadata*>(v26, v18);
    v27 = 1;
  }
  TIDispatchAsync();
  std::__optional_destruct_base<TIInlineCompletionAnalyticsMetadata,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v18);
  if (v17)
    std::__shared_weak_count::__release_weak(v17);

  std::__optional_destruct_base<TIInlineCompletionAnalyticsMetadata,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v26);
  if (v25)
    std::__shared_weak_count::__release_weak(v25);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

void TIInlineCompletionGeneratorImpl::setAnalyticsMetaData(TIInlineCompletionGeneratorImpl *this, TIInlineCompletionAnalyticsMetadata *a2)
{
  KB::String *v4;
  String *p_var1;
  KB::String *v6;
  String *p_var2;
  String *p_var3;
  String *p_var4;
  uint64_t v10;
  KB::String *v11;
  String *p_var5;
  KB::String *v13;
  KB::String *p_var7;
  String *p_var8;
  KB::String *v16;
  String *p_var9;
  KB::String *v18;
  String *p_var10;
  KB::String *v20;
  KB::String *v21;

  v4 = (TIInlineCompletionGeneratorImpl *)((char *)this + 400);
  p_var1 = &a2->var1;
  v6 = (TIInlineCompletionGeneratorImpl *)((char *)this + 464);
  p_var2 = &a2->var2;
  p_var3 = &a2->var3;
  p_var4 = &a2->var4;
  p_var5 = &a2->var5;
  v13 = (TIInlineCompletionGeneratorImpl *)((char *)this + 560);
  v16 = (TIInlineCompletionGeneratorImpl *)((char *)this + 632);
  p_var7 = (KB::String *)&a2->var7;
  p_var8 = &a2->var8;
  p_var9 = &a2->var9;
  v18 = (TIInlineCompletionGeneratorImpl *)((char *)this + 664);
  v20 = (TIInlineCompletionGeneratorImpl *)((char *)this + 696);
  v21 = (TIInlineCompletionGeneratorImpl *)((char *)this + 600);
  p_var10 = &a2->var10;
  v11 = v4;
  if (*((_BYTE *)this + 728))
  {
    KB::String::operator=(v4, (KB::String *)a2);
    KB::String::operator=((TIInlineCompletionGeneratorImpl *)((char *)this + 432), (KB::String *)p_var1);
    KB::String::operator=((TIInlineCompletionGeneratorImpl *)((char *)this + 464), (KB::String *)p_var2);
    KB::String::operator=((TIInlineCompletionGeneratorImpl *)((char *)this + 496), (KB::String *)p_var3);
    KB::String::operator=((TIInlineCompletionGeneratorImpl *)((char *)this + 528), (KB::String *)p_var4);
    KB::String::operator=(v13, (KB::String *)p_var5);
    *((_BYTE *)this + 592) = a2->var6;
    v6 = (TIInlineCompletionGeneratorImpl *)((char *)this + 600);
    KB::String::operator=(v21, p_var7);
    KB::String::operator=(v16, (KB::String *)p_var8);
    KB::String::operator=(v18, (KB::String *)p_var9);
    KB::String::operator=(v20, (KB::String *)p_var10);
    if (*((_BYTE *)this + 728))
      goto LABEL_5;
    v4 = (KB::String *)std::__throw_bad_optional_access[abi:nn180100]();
  }
  KB::String::String(v4, (const KB::String *)a2);
  KB::String::String((TIInlineCompletionGeneratorImpl *)((char *)this + 432), (const KB::String *)p_var1);
  KB::String::String(v6, (const KB::String *)p_var2);
  KB::String::String((TIInlineCompletionGeneratorImpl *)((char *)this + 496), (const KB::String *)p_var3);
  KB::String::String((TIInlineCompletionGeneratorImpl *)((char *)this + 528), (const KB::String *)p_var4);
  KB::String::String(v13, (const KB::String *)p_var5);
  *((_BYTE *)this + 592) = a2->var6;
  v6 = (TIInlineCompletionGeneratorImpl *)((char *)this + 600);
  KB::String::String(v21, p_var7);
  KB::String::String(v16, (const KB::String *)p_var8);
  KB::String::String(v18, (const KB::String *)p_var9);
  KB::String::String(v20, (const KB::String *)p_var10);
  *((_BYTE *)this + 728) = 1;
LABEL_5:
  TIInlineCompletionGeneratorImpl::setInlineCompletionPersonalization((CFMutableDictionaryRef *)this, v6);
  v10 = *((_QWORD *)this + 92);
  if (v10)
    TIInlineCompletionEventDispatcher::did_update_metadata(v10, v11);
}

void TIInlineCompletionGeneratorImpl::setInlineCompletionPersonalization(CFMutableDictionaryRef *this, const KB::String *a2)
{
  _BOOL4 v3;
  BOOL v4;
  const void **v5;
  _BYTE v6[8];
  void *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  KB::String::String((KB::String *)v6, a2);
  v3 = isInlineCompletionDefaultAllowlistedApp((KB::String *)v6);
  if (v7)
    v4 = v6[6] == 1;
  else
    v4 = 0;
  if (v4)
    free(v7);
  v5 = (const void **)MEMORY[0x1E0C9AE40];
  if (v3)
    v5 = (const void **)MEMORY[0x1E0C9AE50];
  CFDictionarySetValue(this[6], (const void *)*MEMORY[0x1E0D43118], *v5);
}

BOOL isInlineCompletionDefaultAllowlistedApp(KB::String *a1)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unsigned __int8 v7;

  if ((v2 & 1) == 0
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobileSMS, "com.apple.MobileSMS");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::mobileSMS, &dword_1DA6F2000);
  }
  if ((v3 & 1) == 0
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilemail, "com.apple.mobilemail");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilemail, &dword_1DA6F2000);
  }
  if ((v4 & 1) == 0
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::reminders, "com.apple.reminders");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::reminders, &dword_1DA6F2000);
  }
  if ((v5 & 1) == 0
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilenotes, "com.apple.mobilenotes");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilenotes, &dword_1DA6F2000);
  }
  if ((v6 & 1) == 0
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilecal, "com.apple.mobilecal");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilecal, &dword_1DA6F2000);
  }
  if ((v7 & 1) == 0
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::typist, "com.apple.Typist");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::typist, &dword_1DA6F2000);
  }
  return KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobileSMS, 1)
      || KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilemail, 1)
      || KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::reminders, 1)
      || KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilenotes, 1)
      || KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilecal, 1)
      || KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::typist, 1);
}

id analytics_queue(void)
{
  if (analytics_queue(void)::onceToken != -1)
    dispatch_once(&analytics_queue(void)::onceToken, &__block_literal_global_2314);
  return (id)analytics_queue(void)::queue;
}

id KB::ns_string(KB *this, const KB::String *a2)
{
  id v3;

  KB::cf_string_impl<KB::String>((CFStringRef *)&v3, (unsigned __int16 *)this);
  return v3;
}

uint64_t *KB::compose_diacritics@<X0>(KB *this@<X0>, const KB::String *a2@<X1>, uint64_t a3@<X8>)
{
  char *v6;
  int v7;
  uint64_t *result;
  int i;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  char *v13;
  int v14;
  int v15;
  int v16;
  char *v17;
  int v18;
  int v19;
  unsigned int v20;

  *(_DWORD *)a3 = 0x100000;
  *(_WORD *)(a3 + 4) = 0;
  *(_BYTE *)(a3 + 6) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 16) = 0;
  if (*((_QWORD *)this + 1))
    v6 = (char *)*((_QWORD *)this + 1);
  else
    v6 = (char *)this + 16;
  v17 = v6;
  v7 = *(unsigned __int16 *)this;
  v18 = 0;
  v19 = v7;
  v20 = 0;
  KB::String::iterator::initialize((uint64_t *)&v17);
  v13 = v6;
  v14 = v7;
  v15 = v7;
  v16 = 0;
  result = KB::String::iterator::initialize((uint64_t *)&v13);
  for (i = v14; v18 != i; result = KB::String::iterator::operator++((uint64_t *)&v17))
  {
    v10 = v20;
    v11 = combine_with_accent();
    if ((_DWORD)v11)
    {
      v12 = v11;
      if (!a2 || MEMORY[0x1DF0A2DEC](a2, v11))
      {
        KB::String::pop_last((KB::String *)a3);
        v10 = v12;
      }
    }
    KB::String::append((KB::String *)a3, v10);
  }
  return result;
}

KB::String *KB::String::String(KB::String *this, const char *__s)
{
  __int16 v4;
  unsigned __int16 v5;
  char *v6;

  *(_DWORD *)this = 0x100000;
  *((_WORD *)this + 2) = 0;
  *((_BYTE *)this + 6) = 1;
  *((_QWORD *)this + 1) = 0;
  if (__s)
  {
    v4 = strlen(__s);
    v5 = v4;
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = 0;
    if (v4)
    {
      KB::String::ensure_capacity(this, v4);
      if (*((_QWORD *)this + 1))
        v6 = (char *)*((_QWORD *)this + 1);
      else
        v6 = (char *)this + 16;
      memcpy(v6, __s, v5);
      *(_WORD *)this = v5;
    }
  }
  else
  {
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = 0;
  }
  return this;
}

void TIInputManager::register_key_area(TIInputManager *this, _LXLexicon *a2, CGRect a3, __int16 a4)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  uint64_t v11;
  unint64_t *v12;
  TI::Favonius::LayoutKey *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const void *v18;
  uint64_t v19;
  CGRect v20;

  if (!*(_WORD *)a2)
    return;
  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  v11 = *((_QWORD *)this + 40);
  *((_QWORD *)this + 40) = 0;
  if (v11)
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v11);
  KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*((_QWORD *)this + 28) + 8) + 72), a2, &v18);
  v12 = (unint64_t *)((char *)this + 256);
  v13 = (TI::Favonius::LayoutKey *)operator new();
  v20.origin.x = x;
  v20.origin.y = y;
  v20.size.width = width;
  v20.size.height = height;
  TI::Favonius::LayoutKey::LayoutKey(v13, (const KB::String *)a2, &v18, v20, a4);
  v14 = *((_QWORD *)this + 32);
  if (v14 != *((_QWORD *)this + 34))
  {
    v17 = *((_QWORD *)this + 33);
    goto LABEL_13;
  }
  v15 = v14 + (v14 >> 1);
  if (v14 < 0x100)
    v15 = 2 * v14;
  if (v15 <= v14 + 1)
    v16 = v14 + 1;
  else
    v16 = v15;
  WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity((_QWORD *)this + 32, v16);
  v17 = *((_QWORD *)this + 33);
  if (v17)
  {
    v14 = *v12;
LABEL_13:
    *(_QWORD *)(v17 + 8 * v14) = v13;
    *v12 = v14 + 1;
    goto LABEL_15;
  }
  WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v13);
LABEL_15:
  if ((unsigned __int16)v18 >= 0xFu)
  {
    if (v19)
      MEMORY[0x1DF0A212C](v19, 0x1000C8077774924);
  }
}

void KB::CollatorWrapper::_sortkey_for_string(_LXLexicon *a1@<X1>, _WORD *a2@<X8>)
{
  CFTypeRef cf;
  void *v6;
  uint64_t v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  KB::cf_string_impl<KB::String>((CFStringRef *)&cf, (unsigned __int16 *)a1);
  v6 = 0;
  v7 = 32;
  v8 = 0;
  if (LXLexiconGetSortkeyBytes())
    *a2 = 0;
  else
    *a2 = 0;
  free(v6);
  if (cf)
    CFRelease(cf);
}

void KB::cf_string_impl<KB::String>(CFStringRef *a1, unsigned __int16 *a2)
{
  CFIndex v4;
  const UInt8 *v5;
  unsigned __int16 *v6;
  const UInt8 *v7;
  CFStringRef v8;
  NSObject *v9;
  const char *v10;
  const char *v11;
  int v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  v5 = (const UInt8 *)*((_QWORD *)a2 + 1);
  v6 = a2 + 8;
  if (!v5)
    v5 = (const UInt8 *)(a2 + 8);
  if (*a2)
    v7 = v5;
  else
    v7 = (const UInt8 *)"";
  v8 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7, v4, 0x8000100u, 1u);
  if (!v8)
  {
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    if (TICanLogMessageAtLevel_logLevel)
    {
      v9 = TIOSLogFacility();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v10 = (const char *)*((_QWORD *)a2 + 1);
        if (!v10)
          v10 = (const char *)v6;
        if (*a2)
          v11 = v10;
        else
          v11 = "";
        v12 = 136315394;
        v13 = "cf_string_impl";
        v14 = 2080;
        v15 = v11;
        _os_log_debug_impl(&dword_1DA6F2000, v9, OS_LOG_TYPE_DEBUG, "%s warning: bytes do not represent UTF8 string: %s", (uint8_t *)&v12, 0x16u);
      }
    }
  }
  *a1 = v8;
}

TI::Favonius::LayoutKey *TI::Favonius::LayoutKey::LayoutKey(TI::Favonius::LayoutKey *this, const KB::String *a2, const void **a3, CGRect a4, __int16 a5)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  TI::Favonius::Key *v11;
  CGFloat MidX;
  CGFloat MidY;
  CGRect v15;
  CGRect v16;

  height = a4.size.height;
  width = a4.size.width;
  y = a4.origin.y;
  x = a4.origin.x;
  v11 = TI::Favonius::Key::Key(this, a2, a3);
  *((_WORD *)v11 + 31) = a5;
  *((CGFloat *)v11 + 8) = x;
  *((CGFloat *)v11 + 9) = y;
  *((CGFloat *)v11 + 10) = width;
  *((CGFloat *)v11 + 11) = height;
  v15.origin.x = x;
  v15.origin.y = y;
  v15.size.width = width;
  v15.size.height = height;
  MidX = CGRectGetMidX(v15);
  v16.origin.x = x;
  v16.origin.y = y;
  v16.size.width = width;
  v16.size.height = height;
  MidY = CGRectGetMidY(v16);
  *((CGFloat *)this + 12) = MidX;
  *((CGFloat *)this + 13) = MidY;
  return this;
}

void KB::CollatorWrapper::sortkey_for_string(KB::CollatorWrapper *this@<X0>, _LXLexicon *a2@<X1>, _WORD *a3@<X8>)
{
  uint64_t v5;

  if (*(_QWORD *)this)
  {
    KB::CollatorWrapper::_sortkey_for_string(a2, a3);
  }
  else
  {
    v5 = _icu_root_collator();
    _sortkey_for_string_with_collator((uint64_t)a3, (KB::String *)a2, v5);
  }
}

TI::Favonius::Key *TI::Favonius::Key::Key(TI::Favonius::Key *this, const KB::String *a2, const void **a3)
{
  _OWORD *v5;
  _WORD *v6;
  unint64_t v7;
  void *v8;
  int v9;
  char *v10;
  UChar32 v11;
  char *v13;
  int v14;
  int v15;
  UChar32 v16;

  *(_DWORD *)this = 1;
  v5 = (_OWORD *)((char *)this + 40);
  v6 = (_WORD *)((char *)this + 8);
  TI::Favonius::Key::string_for_represented_string(a2, (uint64_t)this + 8);
  v7 = *(unsigned __int16 *)a3;
  if (v7 < 0xF)
  {
    *v5 = *(_OWORD *)a3;
  }
  else
  {
    *((_WORD *)this + 20) = v7;
    v8 = (void *)operator new[]();
    *((_QWORD *)this + 6) = v8;
    memcpy(v8, a3[1], *((unsigned __int16 *)this + 20));
  }
  v9 = (unsigned __int16)*v6;
  if (*v6)
  {
    v10 = (char *)*((_QWORD *)this + 2);
    if (!v10)
      v10 = (char *)this + 24;
    v13 = v10;
    v14 = 0;
    v15 = v9;
    v16 = 0;
    KB::String::iterator::initialize((uint64_t *)&v13);
    v11 = v16;
  }
  else
  {
    v11 = 0;
  }
  *((_DWORD *)this + 14) = v11;
  TI::Favonius::KeyClassification::KeyClassification((TI::Favonius::Key *)((char *)this + 60), v11);
  return this;
}

uint64_t *KB::String::iterator::initialize(uint64_t *this)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;

  v1 = *((_DWORD *)this + 3);
  v2 = *((int *)this + 2);
  if ((int)v2 >= v1)
  {
    *((_DWORD *)this + 2) = v1 + 1;
    *((_DWORD *)this + 4) = 0;
  }
  else
  {
    v3 = *this;
    v4 = v2 + 1;
    *((_DWORD *)this + 2) = v2 + 1;
    v5 = *(char *)(v3 + v2);
    *((_DWORD *)this + 4) = v5;
    if ((v5 + 64) > 0x34)
      return this;
    v6 = kb_utf8_countTrailBytes[v5];
    v7 = v5 & ~(-1 << (6 - v6));
    *((_DWORD *)this + 4) = v7;
    if (v6 != 1)
    {
      if (v6 != 2)
      {
        if (v6 != 3)
          return this;
        v8 = v2 + 2;
        *((_DWORD *)this + 2) = v8;
        v9 = *(_BYTE *)(v3 + v4) & 0x3F | (v7 << 6);
        *((_DWORD *)this + 4) = v9;
        LODWORD(v4) = v8;
        v7 = v9;
      }
      *((_DWORD *)this + 2) = v4 + 1;
      v10 = *(_BYTE *)(v3 + (int)v4) & 0x3F | (v7 << 6);
      *((_DWORD *)this + 4) = v10;
      LODWORD(v4) = v4 + 1;
      v7 = v10;
    }
    *((_DWORD *)this + 2) = v4 + 1;
    *((_DWORD *)this + 4) = *(_BYTE *)(v3 + (int)v4) & 0x3F | (v7 << 6);
  }
  return this;
}

KB::String *TI::Favonius::Key::string_for_represented_string@<X0>(TI::Favonius::Key *this@<X0>, uint64_t a2@<X8>)
{
  const char *v5;
  const char *v6;
  KB::String *result;
  char v8;

  v5 = (const char *)*((_QWORD *)this + 1);
  if (!v5)
    v5 = (char *)this + 16;
  if (*(_WORD *)this)
    v6 = v5;
  else
    v6 = "";
  result = (KB::String *)strcmp(v6, "delete");
  if (!(_DWORD)result)
  {
    *(_WORD *)(a2 + 4) = 0;
    *(_BYTE *)(a2 + 6) = 1;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    v8 = 8;
LABEL_18:
    *(_BYTE *)(a2 + 16) = v8;
    *(_DWORD *)a2 = 1048577;
    return result;
  }
  result = (KB::String *)strcmp(v6, "shift");
  if (!(_DWORD)result)
  {
    *(_WORD *)(a2 + 4) = 0;
    *(_BYTE *)(a2 + 6) = 1;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    v8 = 14;
    goto LABEL_18;
  }
  result = (KB::String *)strcmp(v6, "more");
  if (!(_DWORD)result)
  {
    *(_WORD *)(a2 + 4) = 0;
    *(_BYTE *)(a2 + 6) = 1;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    v8 = 16;
    goto LABEL_18;
  }
  result = (KB::String *)strcmp(v6, "international");
  if (!(_DWORD)result)
  {
    *(_WORD *)(a2 + 4) = 0;
    *(_BYTE *)(a2 + 6) = 1;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    v8 = 15;
    goto LABEL_18;
  }
  result = (KB::String *)strcmp(v6, "dismiss");
  if (!(_DWORD)result)
  {
    *(_WORD *)(a2 + 4) = 0;
    *(_BYTE *)(a2 + 6) = 1;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    v8 = 4;
    goto LABEL_18;
  }
  result = (KB::String *)strcmp(v6, "undo");
  if ((_DWORD)result)
    return KB::String::String((KB::String *)a2, this);
  *(_WORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 6) = 1;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_WORD *)(a2 + 16) = -28958;
  *(_DWORD *)a2 = 1048579;
  *(_BYTE *)(a2 + 18) = -116;
  return result;
}

TI::Favonius::KeyClassification *TI::Favonius::KeyClassification::KeyClassification(TI::Favonius::KeyClassification *this, UChar32 c)
{
  __int16 v4;
  __int16 v5;
  __int16 v6;
  uint64_t v8;
  uint64_t v9;

  v4 = 0;
  *(_WORD *)this = 0;
  if (c <= 729)
  {
    if ((c - 168) <= 0xC && ((1 << (c + 88)) & 0x1081) != 0)
      goto LABEL_16;
    if (!c)
    {
      v5 = 1;
      goto LABEL_23;
    }
    if (c != 699)
      goto LABEL_14;
LABEL_11:
    v5 = 2;
LABEL_23:
    *(_WORD *)this = v5;
    return this;
  }
  if (c <= 900)
  {
    if (c == 730 || c == 732)
      goto LABEL_16;
    goto LABEL_14;
  }
  if (c == 901)
    goto LABEL_16;
  if (c == 8204 || c == 3654)
    goto LABEL_11;
LABEL_14:
  if (u_charType(c) != 4)
  {
    if (((1 << u_charType(c)) & 0x16E) != 0)
    {
      v4 = *(_WORD *)this;
      *(_WORD *)this |= 2u;
      if (c > 2491)
      {
        if (c > 2747)
        {
          if (c <= 3020)
          {
            if (c != 2748 && c != 2765 && c != 2946)
              return this;
          }
          else if (c > 3148)
          {
            if (c != 8204 && c != 3149)
              return this;
          }
          else if (c != 3021 && c != 3075)
          {
            return this;
          }
        }
        else
        {
          if (c > 2636)
          {
            if ((c - 2637) > 0x36)
              return this;
            v8 = 1 << (c - 77);
            v9 = 0x70001800000011;
LABEL_40:
            if ((v8 & v9) == 0)
              return this;
            goto LABEL_51;
          }
          if (((c - 2561) > 0x3B || ((1 << (c - 1)) & 0x800000000000007) == 0)
            && c != 2492
            && c != 2509)
          {
            return this;
          }
        }
      }
      else if (((c - 1600) > 0x30 || ((1 << (c - 64)) & 0x1000000FFF801) == 0)
             && ((c - 2305) > 0x3B || ((1 << (c - 1)) & 0x800000000000007) == 0))
      {
        if ((c - 2381) > 0x36)
          return this;
        v8 = 1 << (c - 77);
        v9 = 0x50000000000001;
        goto LABEL_40;
      }
LABEL_51:
      v6 = 4098;
      goto LABEL_22;
    }
    if (u_isspace(c))
    {
      v5 = *(_WORD *)this | 0x20;
      goto LABEL_23;
    }
    if (u_isdigit(c))
    {
      v5 = *(_WORD *)this | 4;
      goto LABEL_23;
    }
    if (u_ispunct(c))
    {
      *(_WORD *)this |= 0x10u;
      if (!is_nonstop(c))
        return this;
      v5 = *(_WORD *)this | 8;
      goto LABEL_23;
    }
    if (c > 14)
    {
      if ((c - 15) >= 2)
      {
        if (c == 9100)
        {
          v5 = *(_WORD *)this | 0x800;
          goto LABEL_23;
        }
        goto LABEL_75;
      }
    }
    else if (c != 4)
    {
      if (c == 8)
      {
        v5 = *(_WORD *)this | 0x80;
        goto LABEL_23;
      }
      if (c == 14)
      {
        v5 = *(_WORD *)this | 0x100;
        goto LABEL_23;
      }
LABEL_75:
      v5 = *(_WORD *)this | 0x8000;
      goto LABEL_23;
    }
    v5 = *(_WORD *)this | 0x200;
    goto LABEL_23;
  }
  v4 = *(_WORD *)this;
LABEL_16:
  *(_WORD *)this = v4 | 0x40;
  if ((c - 710) <= 0x16 && ((1 << (c + 58)) & 0x400033) != 0
    || (c - 168) <= 0xC && ((1 << (c + 88)) & 0x1081) != 0
    || c == 901)
  {
    v6 = 1088;
LABEL_22:
    v5 = v4 | v6;
    goto LABEL_23;
  }
  return this;
}

_QWORD *std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::find<KB::String>(_QWORD *a1, _QWORD *a2)
{
  KB::String *v4;
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  uint8x8_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;

  if (a2[1])
    v4 = (KB::String *)a2[1];
  else
    v4 = (KB::String *)(a2 + 2);
  v5 = KB::String::hash(v4, (const char *)*(unsigned __int16 *)a2);
  v6 = a1[1];
  if (!v6)
    return 0;
  v7 = v5;
  v8 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v8.i16[0] = vaddlv_u8(v8);
  v9 = v8.u32[0];
  if (v8.u32[0] > 1uLL)
  {
    v10 = v5;
    if (v6 <= v5)
      v10 = v5 % v6;
  }
  else
  {
    v10 = ((_DWORD)v6 - 1) & v5;
  }
  v11 = *(_QWORD **)(*a1 + 8 * v10);
  if (!v11)
    return 0;
  v12 = (_QWORD *)*v11;
  if (*v11)
  {
    do
    {
      v13 = v12[1];
      if (v13 == v7)
      {
        if (v12 + 2 == a2 || KB::String::equal((KB::String *)(v12 + 2), (const KB::String *)a2, 1))
          return v12;
      }
      else
      {
        if (v9 > 1)
        {
          if (v13 >= v6)
            v13 %= v6;
        }
        else
        {
          v13 &= v6 - 1;
        }
        if (v13 != v10)
          return 0;
      }
      v12 = (_QWORD *)*v12;
    }
    while (v12);
  }
  return v12;
}

BOOL KB::String::equal(KB::String *this, const KB::String *a2, int a3)
{
  const char *v5;
  const char *v6;
  _BOOL8 v7;
  const char *v8;
  const char *v9;
  void *v10;
  const char *v11;
  const char *v12;
  void *v13;
  const char *v14;
  const char *v15;
  _WORD v17[3];
  char v18;
  void *v19;
  uint64_t v20;
  _WORD v21[3];
  char v22;
  void *v23;
  _QWORD v24[3];

  v24[2] = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if (*((unsigned __int8 *)this + 6) | *((unsigned __int8 *)a2 + 6) || *((_QWORD *)this + 1) != *((_QWORD *)a2 + 1))
    {
      if (*(unsigned __int16 *)this != *(unsigned __int16 *)a2)
        return 0;
      if (*(_WORD *)this)
      {
        if (*((_QWORD *)this + 1))
          v5 = (const char *)*((_QWORD *)this + 1);
        else
          v5 = (char *)this + 16;
        if (*((_QWORD *)a2 + 1))
          v6 = (const char *)*((_QWORD *)a2 + 1);
        else
          v6 = (char *)a2 + 16;
        return strcmp(v5, v6) == 0;
      }
    }
    return 1;
  }
  if (*(unsigned __int16 *)this == *(unsigned __int16 *)a2)
  {
    if (!*(_WORD *)this)
      return 1;
    v8 = *((_QWORD *)this + 1) ? (const char *)*((_QWORD *)this + 1) : (char *)this + 16;
    v9 = *((_QWORD *)a2 + 1) ? (const char *)*((_QWORD *)a2 + 1) : (char *)a2 + 16;
    if (!strcasecmp(v8, v9))
      return 1;
  }
  KB::lower_string(this, 0, (KB::String *)v21);
  KB::lower_string(a2, 0, (KB::String *)v17);
  v10 = v23;
  v11 = (const char *)v24;
  if (v23)
    v11 = (const char *)v23;
  if (v21[0])
    v12 = v11;
  else
    v12 = "";
  v13 = v19;
  v14 = (const char *)&v20;
  if (v19)
    v14 = (const char *)v19;
  if (v17[0])
    v15 = v14;
  else
    v15 = "";
  v7 = strcmp(v12, v15) == 0;
  if (v13 && v18 == 1)
  {
    free(v13);
    v10 = v23;
  }
  if (v10 && v22 == 1)
    free(v10);
  return v7;
}

uint64_t KB::String::hash(KB::String *this, const char *a2)
{
  unsigned int v2;
  unsigned int v3;
  KB::String *v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;

  v2 = -1640531527;
  if (a2 >= 2)
  {
    v3 = a2 >> 1;
    v4 = this;
    do
    {
      v5 = v2 + *(unsigned __int8 *)v4;
      v6 = (v5 << 16) ^ (*((unsigned __int8 *)v4 + 1) << 11);
      v4 = (KB::String *)((char *)v4 + 2);
      v2 = (v6 ^ v5) + ((v6 ^ v5) >> 11);
      --v3;
    }
    while (v3);
    this = (KB::String *)((char *)this + 2 * (a2 >> 1));
  }
  if ((a2 & 1) != 0)
    v2 = ((v2 + *(unsigned __int8 *)this) ^ ((v2 + *(unsigned __int8 *)this) << 11))
       + (((v2 + *(unsigned __int8 *)this) ^ ((v2 + *(unsigned __int8 *)this) << 11)) >> 17);
  v7 = (v2 ^ (8 * v2)) + ((v2 ^ (8 * v2)) >> 5);
  v8 = (v7 ^ (4 * v7)) + ((v7 ^ (4 * v7)) >> 15);
  return v8 ^ (v8 << 10);
}

void WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(_QWORD *a1, unint64_t a2)
{
  void *v2;
  void **v3;
  uint64_t v4;
  void *v5;
  void *v6;

  if (a1[2] < a2)
  {
    v3 = (void **)(a1 + 1);
    v2 = (void *)a1[1];
    v4 = *a1;
    a1[2] = a2;
    v5 = malloc_type_malloc(8 * a2, 0x2004093837F09uLL);
    *v3 = v5;
    if (v5)
    {
      memcpy(v5, v2, 8 * v4);
      v6 = *v3;
    }
    else
    {
      v6 = 0;
    }
    if (v6 == v2)
    {
      *v3 = 0;
      v3[1] = 0;
    }
    free(v2);
  }
}

KB::String *KB::String::String(KB::String *this, const KB::String *a2)
{
  int v4;
  __int16 v5;
  char *v6;
  size_t v7;
  char *v8;
  char *v9;

  *(_DWORD *)this = 0x100000;
  *((_WORD *)this + 2) = 0;
  v4 = *((unsigned __int8 *)a2 + 6);
  *((_BYTE *)this + 6) = v4;
  *((_QWORD *)this + 1) = 0;
  if (v4 == 1)
  {
    v6 = (char *)*((_QWORD *)a2 + 1);
    v7 = *(unsigned __int16 *)a2;
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = 0;
    if (v7)
    {
      if (v6)
        v8 = v6;
      else
        v8 = (char *)a2 + 16;
      KB::String::ensure_capacity(this, v7);
      if (*((_QWORD *)this + 1))
        v9 = (char *)*((_QWORD *)this + 1);
      else
        v9 = (char *)this + 16;
      memcpy(v9, v8, v7);
      *(_WORD *)this = v7;
    }
  }
  else if (!v4)
  {
    *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
    *(_WORD *)this = *(_WORD *)a2;
    v5 = *((_WORD *)a2 + 2);
    if (!v5)
    {
      KB::String::compute_length((unsigned __int16 *)a2);
      v5 = *((_WORD *)a2 + 2);
    }
    *((_WORD *)this + 2) = v5;
    *((_BYTE *)this + 17) = 0;
  }
  return this;
}

void KB::String::ensure_capacity(KB::String *this, __int16 a2)
{
  unsigned __int16 v2;
  unsigned int v3;
  unsigned int v5;
  unsigned __int16 v6;
  void *v7;
  uint64_t v8;
  char *v9;
  void *v10;

  v2 = a2 + 1;
  v3 = *((unsigned __int16 *)this + 1);
  if (v3 <= (unsigned __int16)(a2 + 1))
  {
    if (!*((_BYTE *)this + 6))
    {
      KB::String::internalize_buffer((unsigned __int16 *)this);
      v3 = *((unsigned __int16 *)this + 1);
    }
    if (v2 >= 0x7FF8u)
      v5 = 32760;
    else
      v5 = v2;
    v6 = v3;
    if (v3 < v5)
    {
      v6 = v3;
      do
        v6 = 2 * v6 + 16;
      while ((v6 & 0xFFFEu) < v5);
      *((_WORD *)this + 1) = v6;
    }
    if (v6 >= 0x11u)
    {
      if (*((_BYTE *)this + 6) == 1 && (v7 = (void *)*((_QWORD *)this + 1)) != 0)
      {
        v8 = v3;
        v9 = (char *)malloc_type_realloc(v7, v6 + 1, 0x2B419C0FuLL);
        *((_QWORD *)this + 1) = v9;
        bzero(&v9[v8], *((unsigned __int16 *)this + 1) - v8 + 1);
      }
      else
      {
        v10 = malloc_type_malloc(v6 + 1, 0x1F39E810uLL);
        *((_QWORD *)this + 1) = v10;
        bzero(v10, *((unsigned __int16 *)this + 1) + 1);
        if (*(_WORD *)this)
        {
          strlcpy(*((char **)this + 1), (const char *)this + 16, *((unsigned __int16 *)this + 1) + 1);
          *((_QWORD *)this + 2) = 0;
          *((_QWORD *)this + 3) = 0;
        }
      }
    }
  }
}

KB::String *KB::String::operator=(KB::String *this, KB::String *a2)
{
  void *v4;
  __int16 v5;
  char *v6;
  const char *v7;
  __int16 v8;

  if (this != a2)
  {
    if (*((_BYTE *)a2 + 6) == 1)
    {
      KB::String::clear(this);
      if (*(_WORD *)a2)
      {
        KB::String::ensure_capacity(this, *(_WORD *)a2);
        if (*((_QWORD *)this + 1))
          v6 = (char *)*((_QWORD *)this + 1);
        else
          v6 = (char *)this + 16;
        if (*((_QWORD *)a2 + 1))
          v7 = (const char *)*((_QWORD *)a2 + 1);
        else
          v7 = (char *)a2 + 16;
        strlcpy(v6, v7, *(unsigned __int16 *)a2 + 1);
        *(_WORD *)this = *(_WORD *)a2;
        v8 = *((_WORD *)a2 + 2);
        if (!v8)
        {
          KB::String::compute_length((unsigned __int16 *)a2);
          v8 = *((_WORD *)a2 + 2);
        }
        *((_WORD *)this + 2) = v8;
      }
    }
    else if (!*((_BYTE *)a2 + 6))
    {
      v4 = (void *)*((_QWORD *)this + 1);
      if (v4 && *((_BYTE *)this + 6) == 1)
        free(v4);
      *((_WORD *)this + 1) = 16;
      *((_BYTE *)this + 16) = 0;
      *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
      *(_WORD *)this = *(_WORD *)a2;
      v5 = *((_WORD *)a2 + 2);
      if (!v5)
      {
        KB::String::compute_length((unsigned __int16 *)a2);
        v5 = *((_WORD *)a2 + 2);
      }
      *((_WORD *)this + 2) = v5;
      *((_BYTE *)this + 6) = 0;
    }
  }
  return this;
}

unsigned __int16 *KB::String::compute_length(unsigned __int16 *this)
{
  unsigned int v1;
  int v2;
  int v3;
  unsigned __int16 *v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;

  this[2] = 0;
  v1 = *this;
  if (*this)
  {
    v2 = 0;
    v3 = 0;
    v4 = (unsigned __int16 *)*((_QWORD *)this + 1);
    if (!v4)
      v4 = this + 8;
    do
    {
      v5 = v2 + 1;
      v6 = *((unsigned __int8 *)v4 + (unsigned __int16)v2);
      if ((v6 + 64) <= 0x3Du)
      {
        v7 = kb_utf8_countTrailBytes[v6];
        if (v7 + (unsigned __int16)v5 > v1)
          v7 = v1 - v5;
        if ((_BYTE)v7)
        {
          v8 = v2 + (v7 - 1) + 2;
          while ((*((_BYTE *)v4 + (unsigned __int16)v5) & 0xC0) == 0x80)
          {
            ++v5;
            if (!(_BYTE)--v7)
            {
              v5 = v8;
              break;
            }
          }
        }
      }
      this[2] = ++v3;
      v2 = v5;
    }
    while (v1 > (unsigned __int16)v5);
  }
  return this;
}

void KB::String::clear(KB::String *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 1);
  if (v2 && *((_BYTE *)this + 6) == 1)
    free(v2);
  *((_QWORD *)this + 1) = 0;
  *((_BYTE *)this + 6) = 1;
  *((_BYTE *)this + 16) = 0;
  *(_DWORD *)this = 0x100000;
  *((_WORD *)this + 2) = 0;
}

void KB::utf8_string(KB *this@<X0>, uint64_t a2@<X8>)
{
  KB *v4;
  _NSRange v5;

  v4 = this;
  v5.location = -[KB length](v4, "length");
  KB::utf8_substring(v4, 0, v5, a2);

}

void KB::utf8_substring(KB *this@<X0>, NSString *a2@<X1>, _NSRange a3@<0:X2, 8:X3>, uint64_t a4@<X8>)
{
  NSUInteger location;
  KB *v7;
  size_t v8;
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  __int128 v22;
  unsigned __int16 v23[4];
  uint8_t buf[4];
  void *v25;
  _BYTE v26[1024];
  void *v27;
  size_t v28;
  BOOL v29;
  uint64_t v30;
  NSRange v31;
  NSRange v32;

  location = a3.location;
  v30 = *MEMORY[0x1E0C80C00];
  v7 = this;
  if (!v7)
  {
    *(_DWORD *)a4 = 0x100000;
    *(_WORD *)(a4 + 4) = 0;
    *(_BYTE *)(a4 + 6) = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_BYTE *)(a4 + 16) = 0;
    goto LABEL_33;
  }
  if (((4 * location) | 1) >= 0xFFF0)
    v8 = 65520;
  else
    v8 = (4 * location) | 1;
  v27 = 0;
  v28 = v8;
  v29 = v8 > 0x400;
  if (v8 <= 0x400)
  {
    *(_QWORD *)v23 = 0;
    v22 = xmmword_1DA910F40;
    v10 = v26;
LABEL_10:
    v9 = v8 - 1;
    goto LABEL_11;
  }
  v10 = malloc_type_malloc(v8, 0xBD7CD695uLL);
  v27 = v10;
  *(_QWORD *)v23 = 0;
  v22 = xmmword_1DA910F40;
  if (v10)
    goto LABEL_10;
  v9 = -1;
LABEL_11:
  if ((-[KB getBytes:maxLength:usedLength:encoding:options:range:remainingRange:](v7, "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:", v10, v9, v23, 4, 0, a2, location, &v22) & 1) != 0)
  {
    if (v29)
      v11 = v27;
    else
      v11 = v26;
    v11[*(_QWORD *)v23] = 0;
    if (*((_QWORD *)&v22 + 1))
    {
      if (TICanLogMessageAtLevel_onceToken != -1)
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
      TIOSLogFacility();
      v12 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        v15 = (void *)MEMORY[0x1E0CB3940];
        v31.location = (NSUInteger)a2;
        v31.length = location;
        NSStringFromRange(v31);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        NSStringFromRange((NSRange)v22);
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v15, "stringWithFormat:", CFSTR("%s warning: attempt to convert range [%@] is incomplete, with remaining range [%@]"), "utf8_substring", v16, v17);
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412290;
        v25 = v18;
        _os_log_debug_impl(&dword_1DA6F2000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);

      }
    }
    if (v29)
      v13 = (const char *)v27;
    else
      v13 = v26;
    KB::String::String((KB::String *)a4, v13, v23[0]);
  }
  else
  {
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    if (TICanLogMessageAtLevel_logLevel)
    {
      TIOSLogFacility();
      v14 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        v19 = (void *)MEMORY[0x1E0CB3940];
        v32.location = (NSUInteger)a2;
        v32.length = location;
        NSStringFromRange(v32);
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v19, "stringWithFormat:", CFSTR("%s warning: cannot get UTF8 substring from [%@] in range [%@]"), "utf8_substring", v7, v20);
        v21 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412290;
        v25 = v21;
        _os_log_debug_impl(&dword_1DA6F2000, v14, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);

      }
    }
    *(_DWORD *)a4 = 0x100000;
    *(_WORD *)(a4 + 4) = 0;
    *(_BYTE *)(a4 + 6) = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_BYTE *)(a4 + 16) = 0;
  }
  free(v27);
LABEL_33:

}

KB::String *KB::String::String(KB::String *this, const char *a2, unsigned int a3)
{
  char *v6;

  *(_DWORD *)this = 0x100000;
  *((_WORD *)this + 2) = 0;
  *((_BYTE *)this + 6) = 1;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 1) = 0;
  if (a2 && a3)
  {
    KB::String::ensure_capacity(this, a3);
    if (*((_QWORD *)this + 1))
      v6 = (char *)*((_QWORD *)this + 1);
    else
      v6 = (char *)this + 16;
    memcpy(v6, a2, a3);
    *(_WORD *)this = a3;
  }
  return this;
}

void KB::LanguageModelStr::updateAdditionalLexicons(const _LXLexicon **this)
{
  _BYTE v2[24];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (((*((uint64_t (**)(const _LXLexicon **))*this + 2))(this) & 1) != 0)
  {
    *(_QWORD *)v2 = TITransientLexiconManagerGetActiveSupplementalLexiconWords();
    KB::LanguageModelStr::checkAndUpdateLexicon((KB::LanguageModelStr *)this, this + 29, (const _LXLexicon **)v2, (char *)*MEMORY[0x1E0D43078]);
    *(_QWORD *)v2 = TITransientLexiconManagerGetActiveSupplementalLexiconPhrases();
    KB::LanguageModelStr::checkAndUpdateLexicon((KB::LanguageModelStr *)this, this + 30, (const _LXLexicon **)v2, (char *)*MEMORY[0x1E0D430C8]);
    *(_QWORD *)v2 = KB::LanguageModel::get_word_lexicon((KB::LanguageModel *)this);
    KB::LanguageModelStr::checkAndUpdateLexicon((KB::LanguageModelStr *)this, this + 31, (const _LXLexicon **)v2, (char *)*MEMORY[0x1E0D43060]);
    *(_QWORD *)v2 = KB::LanguageModel::get_phrase_lexicon((KB::LanguageModel *)this);
    KB::LanguageModelStr::checkAndUpdateLexicon((KB::LanguageModelStr *)this, this + 32, (const _LXLexicon **)v2, (char *)*MEMORY[0x1E0D430A8]);
    *(_QWORD *)v2 = KB::LanguageModel::get_contacts_lexicon((KB::LanguageModel *)this);
    KB::LanguageModelStr::checkAndUpdateLexicon((KB::LanguageModelStr *)this, this + 33, (const _LXLexicon **)v2, (char *)*MEMORY[0x1E0D43068]);
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v2 = 136315138;
    *(_QWORD *)&v2[4] = "updateAdditionalLexicons";
    _os_log_error_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s  LM model is not valid yet", v2, 0xCu);
  }
}

void KB::LanguageModelStr::checkAndUpdateLexicon(KB::LanguageModelStr *this, const _LXLexicon **a2, const _LXLexicon **a3, char *a4)
{
  const _LXLexicon *v7;
  _BYTE __p[12];
  __int16 v9;
  char *v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*a2 != *a3)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__p = 136315394;
      *(_QWORD *)&__p[4] = "checkAndUpdateLexicon";
      v9 = 2080;
      v10 = a4;
      _os_log_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s  Removing lexicon for %s in Language Model", __p, 0x16u);
    }
    std::string::basic_string[abi:nn180100]<0>(__p, a4);
    language_modeling::v1::LanguageModel::removeLexicon();
    if (v11 < 0)
      operator delete(*(void **)__p);
    if (*a3)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "checkAndUpdateLexicon";
        v9 = 2080;
        v10 = a4;
        _os_log_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s  Setting lexicon for %s in Language Model", __p, 0x16u);
      }
      std::string::basic_string[abi:nn180100]<0>(__p, a4);
      language_modeling::v1::LanguageModel::addLexicon();
      if (v11 < 0)
        operator delete(*(void **)__p);
      v7 = *a3;
    }
    else
    {
      v7 = 0;
    }
    *a2 = v7;
  }
}

uint64_t KB::LanguageModel::get_contacts_lexicon(KB::LanguageModel *this)
{
  void *v2;
  int v3;
  uint64_t v4;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (*(uint64_t (**)(KB::LanguageModel *))(*(_QWORD *)this + 40))(this);
  v4 = objc_msgSend(v2, "addressBookLexiconForLocale:", TILocaleIdentifierForLexiconID(v3));

  return v4;
}

uint64_t KB::LanguageModelImplBase::lexicon_id(KB::LanguageModelImplBase *this)
{
  return **((unsigned int **)this + 13);
}

unint64_t TILocaleIdentifierForLexiconID(int a1)
{
  unint64_t result;

  _TISharedLexiconIDManager();
  result = atomic_load((unint64_t *)&_TISharedLexiconIDManager(void)::lexicon_id_manager);
  if (result)
  {
    while (*(_DWORD *)(result + 24) != a1)
    {
      result = *(_QWORD *)(result + 32);
      if (!result)
        return result;
    }
    if (*(char *)(result + 23) < 0)
      return *(_QWORD *)result;
  }
  return result;
}

uint64_t *_TISharedLexiconIDManager(void)
{
  unsigned __int8 v0;

  {
    _TISharedLexiconIDManager(void)::lexicon_id_manager = 0;
    atomic_store(0, (unint64_t *)&_TISharedLexiconIDManager(void)::lexicon_id_manager);
    __cxa_atexit((void (*)(void *))KB::LexiconIDManager::~LexiconIDManager, &_TISharedLexiconIDManager(void)::lexicon_id_manager, &dword_1DA6F2000);
  }
  return &_TISharedLexiconIDManager(void)::lexicon_id_manager;
}

uint64_t AddressBookTrieLoaderImpl::handle@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 32);
  *a2 = *(_QWORD *)(this + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t KB::LanguageModelContainer::is_valid(KB::LanguageModelContainer *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  BOOL v5;

  v1 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 4);
  if (v1 == v2)
    return 1;
  v3 = v1 + 56;
  do
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 - 56) + 16))(*(_QWORD *)(v3 - 56));
    if ((_DWORD)result)
      v5 = v3 == v2;
    else
      v5 = 1;
    v3 += 56;
  }
  while (!v5);
  return result;
}

BOOL KB::LanguageModelStr::is_valid(KB::LanguageModelStr *this)
{
  unsigned __int8 v1;
  unsigned __int8 v3;

  v1 = atomic_load((unsigned __int8 *)this + 216);
  if ((v1 & 1) == 0)
    return 0;
  v3 = atomic_load((unsigned __int8 *)this + 217);
  return (v3 & 1) == 0;
}

uint64_t KB::LanguageModel::get_phrase_lexicon(KB::LanguageModel *this)
{
  void *v2;
  int v3;
  uint64_t v4;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (*(uint64_t (**)(KB::LanguageModel *))(*(_QWORD *)this + 40))(this);
  v4 = objc_msgSend(v2, "namedEntityPhraseLexiconForLocale:", TILocaleIdentifierForLexiconID(v3));

  return v4;
}

uint64_t KB::LanguageModel::get_word_lexicon(KB::LanguageModel *this)
{
  void *v2;
  int v3;
  uint64_t v4;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (*(uint64_t (**)(KB::LanguageModel *))(*(_QWORD *)this + 40))(this);
  v4 = objc_msgSend(v2, "namedEntityLexiconForLocale:", TILocaleIdentifierForLexiconID(v3));

  return v4;
}

uint64_t TITransientLexiconManagerGetActiveSupplementalLexiconPhrases()
{
  void *v0;
  int v1;
  void *v2;
  void *v3;
  uint64_t v4;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = objc_msgSend(v0, "isSupplementalLexiconSearchEnabled");

  if (!v1)
    return 0;
  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "supplementalLexicons");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(v3, "activePhraseLexicon");

  return v4;
}

uint64_t TITransientLexiconManagerGetActiveSupplementalLexiconWords()
{
  void *v0;
  int v1;
  void *v2;
  void *v3;
  uint64_t v4;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = objc_msgSend(v0, "isSupplementalLexiconSearchEnabled");

  if (!v1)
    return 0;
  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "supplementalLexicons");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(v3, "activeWordLexicon");

  return v4;
}

id _deepCopyOfStringDictionary(void *a1)
{
  objc_class *v1;
  id v2;
  id v3;
  id v4;
  void *v5;

  v1 = (objc_class *)MEMORY[0x1E0C99D80];
  v2 = a1;
  v3 = [v1 alloc];
  if (v2)
    v4 = v2;
  else
    v4 = (id)MEMORY[0x1E0C9AA70];
  v5 = (void *)objc_msgSend(v3, "initWithDictionary:copyItems:", v4, 1);

  return v5;
}

uint64_t TI::Favonius::FavoniusStrokeBuildManager::set_mltt_bundle_url(uint64_t result, const std::string *a2)
{
  const std::string *v2;
  uint64_t v3;
  std::string *v4;
  int v5;
  int v6;
  BOOL v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  std::string::size_type size;
  int v12;
  uint64_t v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  BOOL v20;
  __int128 v21;
  int v22;
  const char *v23;
  uint64_t v24;

  v2 = a2;
  v3 = result;
  v24 = *MEMORY[0x1E0C80C00];
  v4 = (std::string *)(result + 736);
  v5 = *(unsigned __int8 *)(result + 760);
  v6 = a2[1].__r_.__value_.__s.__data_[0];
  if (*(_BYTE *)(result + 760))
    v7 = v6 == 0;
  else
    v7 = 1;
  if (v7)
  {
    v8 = (*(_BYTE *)(result + 760) != 0) == (a2[1].__r_.__value_.__s.__data_[0] != 0);
    goto LABEL_7;
  }
  v9 = *(unsigned __int8 *)(result + 759);
  if ((v9 & 0x80u) == 0)
    v10 = *(unsigned __int8 *)(result + 759);
  else
    v10 = *(_QWORD *)(result + 744);
  size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  v12 = (char)size;
  if ((size & 0x80u) != 0)
    size = a2->__r_.__value_.__l.__size_;
  if (v10 == size)
  {
    if (v12 < 0)
      a2 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    if ((v9 & 0x80) == 0)
    {
      if (!*(_BYTE *)(result + 759))
        return result;
      v13 = v9 - 1;
      v14 = (unsigned __int8 *)(result + 736);
      do
      {
        v16 = *v14++;
        v15 = v16;
        v18 = a2->__r_.__value_.__s.__data_[0];
        a2 = (const std::string *)((char *)a2 + 1);
        v17 = v18;
        v20 = v13-- != 0;
        v8 = v15 == v17;
      }
      while (v8 && v20);
LABEL_7:
      if (v8)
        return result;
      goto LABEL_28;
    }
    result = memcmp(v4->__r_.__value_.__l.__data_, a2, *(_QWORD *)(result + 744));
    if (!(_DWORD)result)
      return result;
  }
LABEL_28:
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
  {
    v22 = 136315138;
    v23 = "set_mltt_bundle_url";
    _os_log_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO, "%s  Resetting ml tap typing recognizer", (uint8_t *)&v22, 0xCu);
    v5 = *(unsigned __int8 *)(v3 + 760);
    v6 = v2[1].__r_.__value_.__s.__data_[0];
  }
  if (v5 == v6)
  {
    if (v5)
      std::string::operator=(v4, v2);
  }
  else if (v5)
  {
    if (*(char *)(v3 + 759) < 0)
      operator delete(v4->__r_.__value_.__l.__data_);
    *(_BYTE *)(v3 + 760) = 0;
  }
  else
  {
    if (SHIBYTE(v2->__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v4, v2->__r_.__value_.__l.__data_, v2->__r_.__value_.__l.__size_);
    }
    else
    {
      v21 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
      v4->__r_.__value_.__r.__words[2] = v2->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v21;
    }
    *(_BYTE *)(v3 + 760) = 1;
  }
  result = *(_QWORD *)(v3 + 720);
  *(_QWORD *)(v3 + 720) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t KB::LanguageModelContainer::updateAdditionalLexicons(uint64_t this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;

  v1 = *(uint64_t **)(this + 24);
  v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 552))(v3);
  }
  return this;
}

BOOL KB::DynamicDictionaryContainer::get_valid(KB::DynamicDictionaryContainer *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BOOL8 result;
  BOOL v6;

  v2 = *((_QWORD *)this + 14);
  v1 = *((_QWORD *)this + 15);
  if (v2 == v1)
    return 0;
  v3 = v2 + 8;
  do
  {
    v4 = *(_QWORD *)(v3 - 8);
    result = v4 != 0;
    if (v4)
      v6 = 1;
    else
      v6 = v3 == v1;
    v3 += 8;
  }
  while (!v6);
  return result;
}

void KB::DynamicDictionary::load_user_dictionary(KB::DynamicDictionary *this)
{
  KB::String *v2;
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11[3];
  int v12;
  __int16 v13;
  char v14;
  void *v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 3))
  {
    v12 = 0x100000;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    if ((*(unsigned int (**)(KB::DynamicDictionary *))(*(_QWORD *)this + 32))(this))
    {
      v2 = (KB::String *)(*(uint64_t (**)(KB::DynamicDictionary *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
      KB::String::operator=((KB::String *)&v12, v2);
    }
    KB::UserDictionaryLoader::create_and_load((KB::UserDictionaryLoader *)&v12, v11);
    v3 = *(_OWORD *)v11;
    *(_OWORD *)v11 = 0uLL;
    v4 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
    *(_OWORD *)((char *)this + 24) = v3;
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    v7 = (std::__shared_weak_count *)v11[1];
    if (v11[1])
    {
      v8 = (unint64_t *)(v11[1] + 8);
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    if (v15)
      v10 = v14 == 1;
    else
      v10 = 0;
    if (v10)
      free(v15);
  }
}

void TIInputManager::clear_key_areas(TIInputManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void *v6;

  v2 = *((_QWORD *)this + 40);
  *((_QWORD *)this + 40) = 0;
  if (v2)
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v2);
  if (*((_QWORD *)this + 34))
  {
    v3 = *((_QWORD *)this + 32);
    if (v3)
    {
      v4 = (uint64_t *)*((_QWORD *)this + 33);
      v5 = 8 * v3;
      do
      {
        if (*v4)
          WTF::RefCounted<TI::Favonius::Key>::deref(*v4);
        ++v4;
        v5 -= 8;
      }
      while (v5);
      *((_QWORD *)this + 32) = 0;
    }
    v6 = (void *)*((_QWORD *)this + 33);
    *((_QWORD *)this + 33) = 0;
    *((_QWORD *)this + 34) = 0;
    free(v6);
  }
}

unsigned __int16 *TIInputManager::input_substring@<X0>(unsigned __int16 *result@<X0>, unsigned int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  int v5;
  unsigned __int16 *v6;
  uint64_t v7;

  *(_DWORD *)a4 = 0x100000;
  *(_WORD *)(a4 + 4) = 0;
  *(_BYTE *)(a4 + 6) = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_BYTE *)(a4 + 16) = 0;
  if (a3 + a2 > a2)
  {
    v5 = a3;
    v6 = result;
    v7 = 40 * a2;
    do
    {
      result = KB::String::append((unsigned __int16 *)a4, (const KB::String *)(*(_QWORD *)v6 + v7));
      v7 += 40;
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t KB::DynamicDictionaryContainer::get_lexicon_info(KB::DynamicDictionaryContainer *this, uint64_t a2)
{
  return *((_QWORD *)this + 11) + 176 * a2;
}

uint64_t KB::LanguageModelStr::wire_memory(language_modeling::v1::LanguageModel **this)
{
  uint64_t result;

  result = (*((uint64_t (**)(language_modeling::v1::LanguageModel **))*this + 2))(this);
  if ((_DWORD)result)
    return language_modeling::v1::LanguageModel::wireMemory(this[21]);
  return result;
}

KB::String *TIInputManager::set_layout_name(TIInputManager *this, const KB::String *a2)
{
  KB::String *result;
  uint64_t v5;

  result = KB::String::operator=((TIInputManager *)((char *)this + 288), a2);
  v5 = *((_QWORD *)this + 40);
  if (v5)
    return KB::String::operator=((KB::String *)(v5 + 208), a2);
  return result;
}

KB::String *__copy_helper_block_a8_48c17_ZTSKN2KB6StringE(uint64_t a1, uint64_t a2)
{
  return KB::String::String((KB::String *)(a1 + 48), (const KB::String *)(a2 + 48));
}

KB::String *__copy_helper_block_a8_40c17_ZTSKN2KB6StringE(uint64_t a1, uint64_t a2)
{
  return KB::String::String((KB::String *)(a1 + 40), (const KB::String *)(a2 + 40));
}

uint64_t __destroy_helper_block_a8_40c47_ZTSNSt3__110shared_ptrIN2KB14UserDictionaryEEE(uint64_t a1)
{
  return std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](a1 + 40);
}

void KB::LanguageModelContainer::set_current_recipient_names(uint64_t a1, const KB::String **a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v5;
  _QWORD v6[3];
  void **v7;

  v2 = *(uint64_t **)(a1 + 24);
  v3 = *(uint64_t **)(a1 + 32);
  while (v2 != v3)
  {
    v5 = *v2;
    v2 += 7;
    memset(v6, 0, sizeof(v6));
    std::vector<KB::String>::__init_with_size[abi:nn180100]<KB::String*,KB::String*>((KB::String *)v6, *a2, a2[1], (a2[1] - *a2) >> 5);
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v5 + 216))(v5, v6);
    v7 = (void **)v6;
    std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v7);
  }
}

void KB::LanguageModelStr::set_current_recipient_names(uint64_t a1, const KB::String **a2)
{
  uint64_t v2;
  _QWORD v3[3];
  void **v4;

  v2 = *(_QWORD *)(a1 + 184);
  if (v2)
  {
    memset(v3, 0, sizeof(v3));
    std::vector<KB::String>::__init_with_size[abi:nn180100]<KB::String*,KB::String*>((KB::String *)v3, *a2, a2[1], (a2[1] - *a2) >> 5);
    TIInlineCompletionGeneratorImpl::setCurrentRecipientNames(v2, (uint64_t)v3);
    v4 = (void **)v3;
    std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v4);
  }
}

void TIInlineCompletionGeneratorImpl::setCurrentRecipientNames(uint64_t a1, uint64_t a2)
{
  KB::String *v4;
  KB::String *v5;
  KB::String *v6;
  const KB::String *v7;
  int64x2_t *v8;
  int v9;
  int64x2_t v10;
  uint64_t v11;
  unsigned __int8 v12;
  int64x2_t *v13;

  v4 = (KB::String *)(a1 + 320);
  if (!*(_BYTE *)(a1 + 344)
    || (v5 = *(KB::String **)(a1 + 320),
        v6 = *(KB::String **)(a1 + 328),
        v7 = *(const KB::String **)a2,
        v6 - v5 != *(_QWORD *)(a2 + 8) - *(_QWORD *)a2))
  {
LABEL_7:
    validFirstNames((_QWORD *)a2, *(_QWORD *)(a1 + 352), &v10);
    v8 = (int64x2_t *)(a1 + 360);
    v9 = v12;
    if (*(unsigned __int8 *)(a1 + 384) == v12)
    {
      if (*(_BYTE *)(a1 + 384))
      {
        std::vector<KB::String>::__vdeallocate((void **)(a1 + 360));
        *v8 = v10;
        *(_QWORD *)(a1 + 376) = v11;
        v11 = 0;
        v10 = 0uLL;
        if (!v9)
          goto LABEL_15;
        goto LABEL_14;
      }
    }
    else
    {
      if (!*(_BYTE *)(a1 + 384))
      {
        *v8 = v10;
        *(_QWORD *)(a1 + 376) = v11;
        v11 = 0;
        v10 = 0uLL;
        *(_BYTE *)(a1 + 384) = 1;
        if (!v9)
          goto LABEL_15;
LABEL_14:
        v13 = &v10;
        std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v13);
        goto LABEL_15;
      }
      v13 = (int64x2_t *)(a1 + 360);
      std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v13);
      *(_BYTE *)(a1 + 384) = 0;
    }
    if (!v9)
      goto LABEL_15;
    goto LABEL_14;
  }
  while (v5 != v6)
  {
    if (v5 != v7 && !KB::String::equal(v5, v7, 1))
      goto LABEL_7;
    v5 = (KB::String *)((char *)v5 + 32);
    v7 = (const KB::String *)((char *)v7 + 32);
  }
LABEL_15:
  if (*(_BYTE *)(a1 + 344))
  {
    if (v4 != (KB::String *)a2)
      std::vector<KB::String>::__assign_with_size[abi:nn180100]<KB::String*,KB::String*>((uint64_t)v4, *(KB::String **)a2, *(KB::String **)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 5);
  }
  else
  {
    *(_QWORD *)v4 = 0;
    *((_QWORD *)v4 + 1) = 0;
    *((_QWORD *)v4 + 2) = 0;
    std::vector<KB::String>::__init_with_size[abi:nn180100]<KB::String*,KB::String*>(v4, *(const KB::String **)a2, *(const KB::String **)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 5);
    *(_BYTE *)(a1 + 344) = 1;
  }
}

id TITypologyDiagnosticExtensionOSLogFacility()
{
  if (TITypologyDiagnosticExtensionOSLogFacility_onceToken != -1)
    dispatch_once(&TITypologyDiagnosticExtensionOSLogFacility_onceToken, &__block_literal_global_52);
  return (id)TITypologyDiagnosticExtensionOSLogFacility_logFacility;
}

id TI_DEVICE_UNLOCKED_SINCE_BOOT()
{
  void *v0;
  void *v1;
  TIKeyboardInputManager *v3;
  SEL v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  void *v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = getMKBDeviceUnlockedSinceBootSymbolLoc(void)::ptr;
  v8 = getMKBDeviceUnlockedSinceBootSymbolLoc(void)::ptr;
  if (!getMKBDeviceUnlockedSinceBootSymbolLoc(void)::ptr)
  {
    v1 = (void *)MobileKeyBagLibrary();
    v0 = dlsym(v1, "MKBDeviceUnlockedSinceBoot");
    v6[3] = (uint64_t)v0;
    getMKBDeviceUnlockedSinceBootSymbolLoc(void)::ptr = v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
    return (id)(((unsigned int (*)(void))v0)() == 1);
  dlerror();
  v3 = (TIKeyboardInputManager *)abort_report_np();
  return -[TIKeyboardInputManager getTestingStateObject](v3, v4);
}

id TIKeyboardActivityOSLogFacility()
{
  if (TIKeyboardActivityOSLogFacility_onceToken != -1)
    dispatch_once(&TIKeyboardActivityOSLogFacility_onceToken, &__block_literal_global_40);
  return (id)TIKeyboardActivityOSLogFacility_logFacility;
}

uint64_t KB::StaticDictionary::lexicon_index(KB::StaticDictionary *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  unint64_t v5;

  if (a2 == -1 && *(_QWORD *)this != *((_QWORD *)this + 1))
    return 0;
  v2 = *((_QWORD *)this + 6);
  v3 = *((_QWORD *)this + 7) - v2;
  if (!v3)
    return -1;
  result = 0;
  v5 = v3 >> 2;
  if (v5 <= 1)
    v5 = 1;
  while (*(_DWORD *)(v2 + 4 * result) != a2)
  {
    if (v5 == ++result)
      return -1;
  }
  return result;
}

id TIInputManagerOSLogFacility()
{
  if (TIInputManagerOSLogFacility_onceToken != -1)
    dispatch_once(&TIInputManagerOSLogFacility_onceToken, &__block_literal_global_38);
  return (id)TIInputManagerOSLogFacility_logFacility;
}

uint64_t TI::Favonius::FavoniusStrokeBuildManager::set_favonius_language_weight(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 332) = a2;
  *(_BYTE *)(result + 336) = BYTE4(a2);
  return result;
}

uint64_t KB::LanguageModelContainer::set_inline_completion_analytics_metadata(uint64_t this, const TIInlineCompletionAnalyticsMetadata *a2)
{
  uint64_t *v2;
  uint64_t *i;
  uint64_t v5;

  v2 = *(uint64_t **)(this + 24);
  for (i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const TIInlineCompletionAnalyticsMetadata *))(*(_QWORD *)v5 + 232))(v5, a2))
  {
    v5 = *v2;
    v2 += 7;
  }
  return this;
}

unsigned int *KB::LanguageModelContainer::set_dictionaries(unsigned int *result, unsigned int **a2)
{
  uint64_t *v2;
  uint64_t *i;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int *v8;

  v2 = (uint64_t *)*((_QWORD *)result + 3);
  for (i = (uint64_t *)*((_QWORD *)result + 4); v2 != i; v2 += 7)
  {
    v5 = *v2;
    v6 = *a2;
    v8 = v6;
    if (v6)
    {
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 + 1, v6));
    }
    (*(void (**)(uint64_t, unsigned int **))(*(_QWORD *)v5 + 224))(v5, &v8);
    result = v8;
    if (v8)
      result = WTF::RefCounted<KB::DictionaryContainer>::deref(v8);
  }
  return result;
}

unsigned int *WTF::RefCounted<KB::DictionaryContainer>::deref(unsigned int *result)
{
  unsigned int v1;
  unsigned int v2;

  v1 = atomic_load(result);
  if (v1 == 1)
  {
    KB::DictionaryContainer::~DictionaryContainer((KB::DictionaryContainer *)result);
    JUMPOUT(0x1DF0A2144);
  }
  do
    v2 = __ldaxr(result);
  while (__stlxr(v2 - 1, result));
  return result;
}

unsigned int *KB::LanguageModelStr::set_dictionaries(unsigned int *result, unsigned int **a2)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *((_QWORD *)result + 23);
  if (v2)
  {
    v3 = *a2;
    if (*a2)
    {
      do
        v4 = __ldaxr(v3);
      while (__stlxr(v4 + 1, v3));
      do
        v5 = __ldaxr(v3);
      while (__stlxr(v5 + 1, v3));
    }
    result = *(unsigned int **)(v2 + 392);
    *(_QWORD *)(v2 + 392) = v3;
    if (result)
      result = WTF::RefCounted<KB::DictionaryContainer>::deref(result);
    if (v3)
      return WTF::RefCounted<KB::DictionaryContainer>::deref(v3);
  }
  return result;
}

void TIRestoreAdaptationAutocorrectionRejectionV2Trial()
{
  int v0;
  const char *v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
  {
    v0 = 136315138;
    v1 = "TIRestoreAdaptationAutocorrectionRejectionV2Trial";
    _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  Trial: removing override of adaptation_autocorrection_rejection_v2", (uint8_t *)&v0, 0xCu);
  }
  if (HIBYTE(adaptation_autocorrection_rejection_v2_override_for_trial))
    HIBYTE(adaptation_autocorrection_rejection_v2_override_for_trial) = 0;
}

uint64_t getExcessMemoryInBytes()
{
  uint64_t v0;
  uint64_t v1;
  NSObject *v2;
  void *v3;
  uint64_t v4;
  int *v5;
  void *v6;
  uint8_t buf[4];
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  getpid();
  v0 = memorystatus_control();
  if ((_DWORD)v0)
  {
    v1 = v0;
    TIKeyboardActivityOSLogFacility();
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3 = (void *)MEMORY[0x1E0CB3940];
      v4 = *__error();
      v5 = __error();
      objc_msgSend(v3, "stringWithFormat:", CFSTR("%s memorystatus_control returned error: %d, errno: %d, error-string: %s"), "getExcessMemoryInBytes", v1, v4, strerror(*v5));
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      v9 = v6;
      _os_log_impl(&dword_1DA6F2000, v2, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);

    }
  }
  return 0;
}

uint64_t __copy_helper_block_a8_40c47_ZTSNSt3__110shared_ptrIN2KB14UserDictionaryEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_a8_48c17_ZTSKN2KB6StringE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 56);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 54) == 1)
      free(v2);
  }
}

KB::LanguageModelContext *KB::LanguageModelContext::LanguageModelContext(KB::LanguageModelContext *this, const KB::LanguageModelContext *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  v4 = *((_QWORD *)a2 + 1);
  *(_QWORD *)this = *(_QWORD *)a2;
  *((_QWORD *)this + 1) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  std::vector<TITokenID>::vector((_QWORD *)this + 2, (uint64_t)a2 + 16);
  v7 = *(_OWORD *)((char *)a2 + 40);
  *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
  *(_OWORD *)((char *)this + 40) = v7;
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::LanguageModelContext *)((char *)this + 64), (const KB::LanguageModelContext *)((char *)a2 + 64));
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::LanguageModelContext *)((char *)this + 72), (const KB::LanguageModelContext *)((char *)a2 + 72));
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)((char *)this + 80), *((__int128 **)a2 + 10), *((__int128 **)a2 + 11), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)a2 + 11) - *((_QWORD *)a2 + 10)) >> 3));
  return this;
}

_QWORD *std::vector<TITokenID>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<TITokenID>::__vallocate[abi:nn180100](a1, v5 >> 3);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

void KB::LanguageModelContext::append(KB::LanguageModelContext *this, unint64_t a2, uint64_t a3, int a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  char *v21;
  char *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  __int128 v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  std::string *v35;
  std::string *v36;
  __int128 v37;
  unint64_t v38;
  uint64_t v39;
  std::string *v40;
  __int128 v41;
  int64x2_t v42;
  std::string *v43;
  void *__p;
  char v45;
  unint64_t v46;
  std::__split_buffer<std::string> v47;

  v46 = a2;
  if (HIDWORD(a2) == 1)
  {
    v8 = *((_QWORD *)this + 6) + 1;
    *((_QWORD *)this + 6) = v8;
    if (v8 >= 4)
    {
      KB::LanguageModelContext::pop_first_sentence(this);
      v9 = (uint64_t)(*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3;
      *((_QWORD *)this + 5) = v9;
      *((_QWORD *)this + 7) = v9;
      language_modeling::v1::LinguisticContext::clear((KB::LanguageModelContext *)((char *)this + 72));
    }
  }
  else if (*((_QWORD *)this + 3) == *((_QWORD *)this + 2))
  {
    ++*((_QWORD *)this + 6);
  }
  KB::LanguageModelContext::linguistic_token(a3, (TITokenID)&v46, (uint64_t)&__p);
  if (language_modeling::v1::LinguisticContext::try_push_back())
  {
    v11 = (unint64_t *)*((_QWORD *)this + 3);
    v10 = *((_QWORD *)this + 4);
    if ((unint64_t)v11 >= v10)
    {
      v13 = *((_QWORD *)this + 2);
      v14 = ((uint64_t)v11 - v13) >> 3;
      if ((unint64_t)(v14 + 1) >> 61)
        goto LABEL_52;
      v15 = v10 - v13;
      v16 = v15 >> 2;
      if (v15 >> 2 <= (unint64_t)(v14 + 1))
        v16 = v14 + 1;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
        v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v17);
      else
        v18 = 0;
      v19 = (unint64_t *)(v17 + 8 * v14);
      v20 = v17 + 8 * v18;
      *v19 = a2;
      v12 = v19 + 1;
      v22 = (char *)*((_QWORD *)this + 2);
      v21 = (char *)*((_QWORD *)this + 3);
      if (v21 != v22)
      {
        do
        {
          v23 = *((_QWORD *)v21 - 1);
          v21 -= 8;
          *--v19 = v23;
        }
        while (v21 != v22);
        v21 = (char *)*((_QWORD *)this + 2);
      }
      *((_QWORD *)this + 2) = v19;
      *((_QWORD *)this + 3) = v12;
      *((_QWORD *)this + 4) = v20;
      if (v21)
        operator delete(v21);
    }
    else
    {
      *v11 = a2;
      v12 = v11 + 1;
    }
    v24 = *((_QWORD *)this + 12);
    *((_QWORD *)this + 3) = v12;
    v25 = *((_QWORD *)this + 11);
    if (v25 < v24)
    {
      if (*(char *)(a3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(*((std::string **)this + 11), *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
      }
      else
      {
        v26 = *(_OWORD *)a3;
        *(_QWORD *)(v25 + 16) = *(_QWORD *)(a3 + 16);
        *(_OWORD *)v25 = v26;
      }
      v35 = (std::string *)(v25 + 24);
LABEL_46:
      *((_QWORD *)this + 11) = v35;
      if (a4)
      {
        *((_QWORD *)this + 7) = (uint64_t)(*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3;
        language_modeling::v1::LinguisticContext::clear((KB::LanguageModelContext *)((char *)this + 72));
      }
      else
      {
        language_modeling::v1::LinguisticContext::try_push_back();
      }
      goto LABEL_49;
    }
    v27 = *((_QWORD *)this + 10);
    v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - v27) >> 3);
    if (v28 + 1 <= 0xAAAAAAAAAAAAAAALL)
    {
      v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - v27) >> 3);
      v30 = 2 * v29;
      if (2 * v29 <= v28 + 1)
        v30 = v28 + 1;
      if (v29 >= 0x555555555555555)
        v31 = 0xAAAAAAAAAAAAAAALL;
      else
        v31 = v30;
      v47.__end_cap_.__value_ = (std::allocator<std::string> *)((char *)this + 96);
      if (v31)
      {
        v32 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v31);
        v34 = v33;
      }
      else
      {
        v32 = 0;
        v34 = 0;
      }
      v36 = (std::string *)&v32[24 * v28];
      if (*(char *)(a3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v36, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
      }
      else
      {
        v37 = *(_OWORD *)a3;
        v36->__r_.__value_.__r.__words[2] = *(_QWORD *)(a3 + 16);
        *(_OWORD *)&v36->__r_.__value_.__l.__data_ = v37;
      }
      v39 = *((_QWORD *)this + 10);
      v38 = *((_QWORD *)this + 11);
      if (v38 == v39)
      {
        v42 = vdupq_n_s64(v38);
        v40 = v36;
      }
      else
      {
        v40 = v36;
        do
        {
          v41 = *(_OWORD *)(v38 - 24);
          v40[-1].__r_.__value_.__r.__words[2] = *(_QWORD *)(v38 - 8);
          *(_OWORD *)&v40[-1].__r_.__value_.__l.__data_ = v41;
          --v40;
          *(_QWORD *)(v38 - 16) = 0;
          *(_QWORD *)(v38 - 8) = 0;
          *(_QWORD *)(v38 - 24) = 0;
          v38 -= 24;
        }
        while (v38 != v39);
        v42 = *((int64x2_t *)this + 5);
      }
      v35 = v36 + 1;
      *((_QWORD *)this + 10) = v40;
      *((_QWORD *)this + 11) = v36 + 1;
      *(int64x2_t *)&v47.__begin_ = v42;
      v43 = (std::string *)*((_QWORD *)this + 12);
      *((_QWORD *)this + 12) = &v32[24 * v34];
      v47.__end_cap_.__value_ = v43;
      v47.__first_ = (std::__split_buffer<std::string>::pointer)v42.i64[0];
      std::__split_buffer<std::string>::~__split_buffer(&v47);
      goto LABEL_46;
    }
LABEL_52:
    abort();
  }
LABEL_49:
  if (v45 < 0)
    operator delete(__p);
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::pointer end;
  std::__split_buffer<std::string>::pointer begin;
  std::__split_buffer<std::string>::pointer v4;

  begin = this->__begin_;
  end = this->__end_;
  if (end != begin)
  {
    do
    {
      v4 = end - 1;
      this->__end_ = end - 1;
      if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v4->__r_.__value_.__l.__data_);
        v4 = this->__end_;
      }
      end = v4;
    }
    while (v4 != begin);
  }
  if (this->__first_)
    operator delete(this->__first_);
}

void KB::LanguageModelContext::linguistic_token(uint64_t a1@<X0>, TITokenID a2@<X1>, uint64_t a3@<X8>)
{
  KB *v5;
  TITokenID v6;
  int v7;
  int v8;
  std::string __p;

  v5 = **(KB ***)&a2;
  v7 = KB::LanguageModelContext::linguistic_token_type(**(_QWORD **)&a2, a2);
  if (v7 == 3)
  {
    KB::class_token_text(v5, v6, &__p);
  }
  else if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  }
  else
  {
    __p = *(std::string *)a1;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)a3, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    v8 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    *(_DWORD *)(a3 + 24) = v7;
    if (v8 < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    *(std::string *)a3 = __p;
    *(_DWORD *)(a3 + 24) = v7;
  }
}

unint64_t KB::LanguageModelContext::linguistic_token_type(unint64_t this, TITokenID a2)
{
  unint64_t result;

  result = HIDWORD(this);
  if ((int)result > 62)
  {
    if ((result - 63) < 2 || (result - 130) < 2 || (_DWORD)result == 499)
      return 3;
    else
      return 0;
  }
  else
  {
    switch((int)result)
    {
      case 1:
        return result;
      case 2:
        result = 2;
        break;
      case 3:
      case 5:
      case 6:
      case 7:
        return 3;
      default:
        return 0;
    }
  }
  return result;
}

uint64_t KB::LanguageModelContext::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  char *v11;
  char *v12;
  _BYTE *v13;
  size_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _BYTE *v19;
  unint64_t v20;
  char *v21;
  void *v22;
  char *v23;
  __int128 v24;

  v5 = *a2;
  v4 = a2[1];
  if (v4)
  {
    v6 = (unint64_t *)(v4 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = *(std::__shared_weak_count **)(a1 + 8);
  *(_QWORD *)a1 = v5;
  *(_QWORD *)(a1 + 8) = v4;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if ((uint64_t *)a1 != a2)
  {
    v11 = *(char **)(a1 + 16);
    v12 = (char *)a2[2];
    v13 = (_BYTE *)a2[3];
    v14 = v13 - v12;
    v15 = (v13 - v12) >> 3;
    v16 = *(_QWORD *)(a1 + 32);
    if (v15 <= (v16 - (uint64_t)v11) >> 3)
    {
      v19 = *(_BYTE **)(a1 + 24);
      v20 = (v19 - v11) >> 3;
      if (v20 < v15)
      {
        v21 = &v12[8 * v20];
        if (v19 != v11)
        {
          memmove(*(void **)(a1 + 16), (const void *)a2[2], v19 - v11);
          v11 = *(char **)(a1 + 24);
        }
        v14 = v13 - v21;
        if (v13 == v21)
          goto LABEL_29;
        v22 = v11;
        v23 = v21;
        goto LABEL_28;
      }
    }
    else
    {
      if (v11)
      {
        *(_QWORD *)(a1 + 24) = v11;
        operator delete(v11);
        v16 = 0;
        *(_QWORD *)(a1 + 16) = 0;
        *(_QWORD *)(a1 + 24) = 0;
        *(_QWORD *)(a1 + 32) = 0;
      }
      if ((v14 & 0x8000000000000000) != 0)
        abort();
      v17 = v16 >> 2;
      if (v16 >> 2 <= v15)
        v17 = (v13 - v12) >> 3;
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
        v18 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v18 = v17;
      std::vector<TITokenID>::__vallocate[abi:nn180100]((_QWORD *)(a1 + 16), v18);
      v11 = *(char **)(a1 + 24);
    }
    if (v13 == v12)
    {
LABEL_29:
      *(_QWORD *)(a1 + 24) = &v11[v14];
      v24 = *(_OWORD *)(a2 + 5);
      *(_QWORD *)(a1 + 56) = a2[7];
      *(_OWORD *)(a1 + 40) = v24;
      language_modeling::v1::LinguisticContext::operator=();
      language_modeling::v1::LinguisticContext::operator=();
      std::vector<std::string>::__assign_with_size[abi:nn180100]<std::string*,std::string*>((std::vector<std::string> *)(a1 + 80), (std::string *)a2[10], (std::string *)a2[11], 0xAAAAAAAAAAAAAAABLL * ((a2[11] - a2[10]) >> 3));
      return a1;
    }
    v22 = v11;
    v23 = v12;
LABEL_28:
    memmove(v22, v23, v14);
    goto LABEL_29;
  }
  language_modeling::v1::LinguisticContext::operator=();
  language_modeling::v1::LinguisticContext::operator=();
  return a1;
}

BOOL KB::LanguageModelContainer::supports_multilingual(KB::LanguageModelContainer *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 4) - v1;
  return (unint64_t)(0x6DB6DB6DB6DB6DB7 * (v2 >> 3)) > 1 || v2 == 56 && *(int *)(v1 + 40) > 1;
}

uint64_t TIInputManager::clear_input(TIInputManager *this)
{
  BOOL v2;
  uint64_t v3;
  uint64_t i;
  void *v5;
  int v7;
  __int16 v8;
  char v9;
  void *v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v7 = 0x100000;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  KB::String::operator=((TIInputManager *)((char *)this + 32), (KB::String *)&v7);
  if (v10)
    v2 = v9 == 1;
  else
    v2 = 0;
  if (v2)
    free(v10);
  v3 = *((_QWORD *)this + 1);
  for (i = *((_QWORD *)this + 2); i != v3; i -= 40)
  {
    v5 = *(void **)(i - 32);
    if (v5)
    {
      if (*(_BYTE *)(i - 34) == 1)
        free(v5);
    }
  }
  *((_QWORD *)this + 2) = v3;
  *((_DWORD *)this + 24) = 0;
  *((_DWORD *)this + 134) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_DWORD *)this + 44) = 0;
  KB::String::clear((TIInputManager *)((char *)this + 64));
  *((_BYTE *)this + 680) = 0;
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 23) + 136))(*((_QWORD *)this + 23));
}

void TI::Favonius::FavoniusStrokeBuildManager::input_disruption_from_UI(TI::Favonius::FavoniusStrokeBuildManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  TI::TIInputRecognizer *v6;

  *((_BYTE *)this + 209) = 1;
  if (*((_QWORD *)this + 9))
  {
    v2 = operator new();
    *(_OWORD *)v2 = *(_OWORD *)((char *)this + 72);
    v3 = *((_QWORD *)this + 11);
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 11) = 0;
    *((_QWORD *)this + 9) = 0;
    *(_QWORD *)(v2 + 16) = v3;
    if (*((_BYTE *)this + 211))
    {
      v4 = WTF::Vector<WTF::RefPtr<TI::Favonius::Search>,0ul>::~Vector(v2);
      MEMORY[0x1DF0A2144](v4, 0x1020C40FBFA920DLL);
    }
    else
    {
      _TIQueueBackground();
      TIDispatchAsync();
    }
  }
  v5 = *((_QWORD *)this + 3);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 104))(v5);
  v6 = (TI::TIInputRecognizer *)*((_QWORD *)this + 90);
  if (v6)
    TI::TIInputRecognizer::reset_session(v6);
}

uint64_t KB::LanguageModelContainer::clear_prediction_cache(uint64_t this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;

  v1 = *(uint64_t **)(this + 24);
  v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 448))(v3);
  }
  return this;
}

uint64_t KB::NgramCandidateRefinery::clear_cache(KB::NgramCandidateRefinery *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
    if ((_DWORD)result)
      return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 448))(*((_QWORD *)this + 4));
  }
  return result;
}

void KB::LanguageModelStr::clear_prediction_cache(KB::LanguageModelStr *this)
{
  char *v2;

  v2 = (char *)this + 336;
  std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>>>::destroy(*((_QWORD **)this + 42));
  *((_QWORD *)this + 42) = 0;
  *((_QWORD *)this + 43) = 0;
  *((_QWORD *)this + 40) = 0;
  *((_QWORD *)this + 41) = v2;
  *((_QWORD *)this + 39) = 0;
}

void std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>>>::destroy(*a1);
    std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t *KB::decompose_diacritics@<X0>(unsigned __int16 *a1@<X0>, unsigned int **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  int v8;
  uint64_t *result;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  unsigned int v24;

  *(_DWORD *)a4 = 0x100000;
  *(_WORD *)(a4 + 4) = 0;
  *(_BYTE *)(a4 + 6) = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_BYTE *)(a4 + 16) = 0;
  if (*((_QWORD *)a1 + 1))
    v7 = *((_QWORD *)a1 + 1);
  else
    v7 = (uint64_t)(a1 + 8);
  v21 = v7;
  v8 = *a1;
  v22 = 0;
  v23 = v8;
  v24 = 0;
  KB::String::iterator::initialize(&v21);
  v17 = v7;
  v18 = v8;
  v19 = v8;
  v20 = 0;
  result = KB::String::iterator::initialize(&v17);
  v10 = v22;
  v11 = v18;
  while (v10 != v11)
  {
    v12 = v24;
    if (!a3 || MEMORY[0x1DF0A2DEC](a3, v24))
    {
      v13 = *a2;
      v14 = a2[1];
      while (v13 != v14)
      {
        v15 = *v13;
        v16 = strip_accent();
        if (v16)
        {
          KB::String::append((KB::String *)a4, v16);
          v12 = v15;
          break;
        }
        ++v13;
      }
    }
    KB::String::append((KB::String *)a4, v12);
    result = KB::String::iterator::operator++(&v21);
    v10 = v22;
  }
  return result;
}

uint64_t KB::LanguageModelContext::LanguageModelContext(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;

  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 64));
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 72));
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  for (*(_QWORD *)(a1 + 96) = 0; a3; --a3)
  {
    v8 = *a2++;
    KB::LanguageModelContext::append((KB::LanguageModelContext *)a1, v8, a4, 0);
    a4 += 24;
  }
  return a1;
}

uint64_t KB::LanguageModelContainer::advanced_models_loaded(KB::LanguageModelContainer *this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v1 = (uint64_t *)*((_QWORD *)this + 3);
  v2 = (uint64_t *)*((_QWORD *)this + 4);
  if (v1 == v2)
    return 0;
  v3 = 0;
  do
  {
    v4 = *v1;
    v1 += 7;
    v3 += (*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 144))(v4);
  }
  while (v1 != v2);
  return v3;
}

uint64_t KB::LanguageModelStr::does_provide_inline_completions(KB::LanguageModelStr *this)
{
  uint64_t result;
  uint64_t v3;
  unsigned __int8 v4;

  result = (*(uint64_t (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 16))(this);
  if ((_DWORD)result)
  {
    v3 = *((_QWORD *)this + 23);
    if (v3)
    {
      v4 = atomic_load((unsigned __int8 *)(v3 + 16));
      return v4 & 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void KB::LanguageModelContainer::reset_state_cache(uint64_t a1, uint64_t a2)
{
  KB::LanguageModelLexiconGroup *v4;
  KB::LanguageModelLexiconGroup *v5;
  NSObject *v6;
  void **v7;
  uint64_t *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  _BOOL4 v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  void *__p[2];
  char v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  void **v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!(_DWORD)a2 || (_DWORD)a2 == 2)
  {
    v18 = *(uint64_t **)(a1 + 24);
    v17 = *(uint64_t **)(a1 + 32);
    while (v18 != v17)
    {
      v19 = *v18;
      v18 += 7;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v19 + 120))(v19, a2);
    }
  }
  else if ((_DWORD)a2 == 1)
  {
    v4 = *(KB::LanguageModelLexiconGroup **)(a1 + 24);
    v5 = *(KB::LanguageModelLexiconGroup **)(a1 + 32);
    if (v4 != v5)
    {
      v6 = MEMORY[0x1E0C81028];
      do
      {
        KB::LanguageModelLexiconGroup::lexicon_group_identifier(v4, (uint64_t)__p);
        if (v21 >= 0)
          v7 = __p;
        else
          v7 = (void **)__p[0];
        v8 = *(uint64_t **)(a1 + 24);
        if (v8 == *(uint64_t **)(a1 + 32))
        {
          v9 = 0;
        }
        else
        {
          v9 = *v8;
          v10 = (std::__shared_weak_count *)v8[1];
          if (v10)
          {
            p_shared_owners = (unint64_t *)&v10->__shared_owners_;
            do
              v12 = __ldxr(p_shared_owners);
            while (__stxr(v12 + 1, p_shared_owners));
            v13 = *(_QWORD *)v4 == v9;
            do
              v14 = __ldaxr(p_shared_owners);
            while (__stlxr(v14 - 1, p_shared_owners));
            if (!v14)
            {
              ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
              std::__shared_weak_count::__release_weak(v10);
            }
            goto LABEL_19;
          }
        }
        v13 = *(_QWORD *)v4 == v9;
LABEL_19:
        if (v13)
          v15 = 1;
        else
          v15 = 2;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          v16 = off_1EA104728[v15];
          *(_DWORD *)buf = 136315650;
          v23 = "reset_state_cache";
          v24 = 2080;
          v25 = v7;
          v26 = 2080;
          v27 = v16;
          _os_log_impl(&dword_1DA6F2000, v6, OS_LOG_TYPE_DEFAULT, "%s  Resetting state cache for %s model with %s", buf, 0x20u);
        }
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)v4 + 120))(*(_QWORD *)v4, v15);
        if (v21 < 0)
          operator delete(__p[0]);
        v4 = (KB::LanguageModelLexiconGroup *)((char *)v4 + 56);
      }
      while (v4 != v5);
    }
  }
}

void KB::LanguageModelStr::reset_state_cache(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  const char *v5;
  int v6;
  NSObject *v7;
  _BOOL4 v8;
  const char *v9;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
    return;
  v4 = TILanguageModelLogFacility();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2)
      v5 = "cache-strategy: unknown";
    else
      v5 = off_1EA104728[a2];
    v15 = 136315394;
    v16 = "reset_state_cache";
    v17 = 2080;
    v18 = v5;
    _os_log_impl(&dword_1DA6F2000, v4, OS_LOG_TYPE_DEFAULT, "%s Handling %s reset request", (uint8_t *)&v15, 0x16u);
  }
  if (a2 != 2)
  {
    if (a2 == 1)
    {
      v12 = TILanguageModelLogFacility();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        return;
      v15 = 136315138;
      v16 = "reset_state_cache";
      v9 = "%s Not resetting the cache";
      v10 = v12;
      goto LABEL_17;
    }
    if (a2)
      return;
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1);
    v7 = TILanguageModelLogFacility();
    v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (!v8)
        return;
      v15 = 136315138;
      v16 = "reset_state_cache";
      v9 = "%s Model provides completions, not resetting the cache";
      v10 = v7;
LABEL_17:
      _os_log_impl(&dword_1DA6F2000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v15, 0xCu);
      return;
    }
    if (!v8)
      goto LABEL_21;
    v15 = 136315138;
    v16 = "reset_state_cache";
    v11 = "%s Resetting the state cache in Language Model";
    goto LABEL_20;
  }
  v7 = TILanguageModelLogFacility();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v15 = 136315138;
    v16 = "reset_state_cache";
    v11 = "%s Resetting the cache";
LABEL_20:
    _os_log_impl(&dword_1DA6F2000, v7, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v15, 0xCu);
  }
LABEL_21:
  v13 = *(_QWORD *)(a1 + 184);
  if (v13)
    atomic_store(1u, (unsigned __int8 *)(v13 + 752));
  std::mutex::lock(*(std::mutex **)(a1 + 136));
  v14 = *(_QWORD *)(a1 + 184);
  if (v14)
    atomic_store(0, (unsigned __int8 *)(v14 + 752));
  language_modeling::v1::LanguageModel::deallocateInternalBuffers(*(language_modeling::v1::LanguageModel **)(a1 + 168));
  std::mutex::unlock(*(std::mutex **)(a1 + 136));
}

id TILanguageModelLogFacility()
{
  if (TILanguageModelLogFacility_onceToken != -1)
    dispatch_once(&TILanguageModelLogFacility_onceToken, &__block_literal_global_46);
  return (id)TILanguageModelLogFacility_logFacility;
}

void KB::LanguageModelStr::start_session(_DWORD *a1, int a2)
{
  if (((*(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 16))(a1) & 1) != 0)
    KB::LanguageModelStr::__start_session((uint64_t)a1, a2);
  else
    a1[16] = a2;
}

void KB::LanguageModelImplBase::set_recipient_context(KB::LanguageModelImplBase *this, const __CFDictionary *a2)
{
  std::mutex *v4;

  v4 = (std::mutex *)*((_QWORD *)this + 17);
  std::mutex::lock(v4);
  KB::retain_ptr<__CFDictionary const*>::operator=((const void **)this + 7, a2);
  std::mutex::unlock(v4);
}

const void **KB::retain_ptr<__CFDictionary const*>::operator=(const void **a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *a1;
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      v3 = *a1;
    }
    if (v3)
      CFRelease(v3);
    *a1 = cf;
  }
  return a1;
}

uint64_t TILexiconIDForLocaleIdentifier(char *__s)
{
  uint64_t v1;
  void *__p[2];
  char v4;

  std::string::basic_string[abi:nn180100]<0>(__p, __s);
  _TISharedLexiconIDManager();
  v1 = KB::LexiconIDManager::id_for_locale((unint64_t *)&_TISharedLexiconIDManager(void)::lexicon_id_manager, (uint64_t)__p);
  if (v4 < 0)
    operator delete(__p[0]);
  return v1;
}

uint64_t KB::LexiconIDManager::id_for_locale(unint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  char v5;
  uint64_t v6;
  const std::string::value_type *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  std::string *v13;
  unint64_t v14;

  do
  {
    v4 = atomic_load(a1);
    if (v4)
    {
      v5 = *(_BYTE *)(a2 + 23);
      if (v5 >= 0)
        v6 = *(unsigned __int8 *)(a2 + 23);
      else
        v6 = *(_QWORD *)(a2 + 8);
      if (v5 >= 0)
        v7 = (const std::string::value_type *)a2;
      else
        v7 = *(const std::string::value_type **)a2;
      v8 = v4;
      do
      {
        v9 = *(unsigned __int8 *)(v8 + 23);
        if ((v9 & 0x80u) == 0)
          v10 = *(unsigned __int8 *)(v8 + 23);
        else
          v10 = *(_QWORD *)(v8 + 8);
        if (v10 == v6)
        {
          if ((v9 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)v8, v7, *(_QWORD *)(v8 + 8)))
              return *(unsigned int *)(v8 + 24);
          }
          else
          {
            if (!*(_BYTE *)(v8 + 23))
              return *(unsigned int *)(v8 + 24);
            v11 = 0;
            while (*(unsigned __int8 *)(v8 + v11) == v7[v11])
            {
              if (v9 == ++v11)
                goto LABEL_33;
            }
          }
        }
        v8 = *(_QWORD *)(v8 + 32);
      }
      while (v8);
      v12 = *(_DWORD *)(v4 + 24) + 1;
    }
    else
    {
      v12 = 2;
    }
    v13 = (std::string *)operator new();
    v8 = (unint64_t)v13;
    if (*(char *)(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
      v13->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 16);
    }
    *(_DWORD *)(v8 + 24) = v12;
    *(_QWORD *)(v8 + 32) = v4;
    while (1)
    {
      v14 = __ldxr(a1);
      if (v14 != v4)
        break;
      if (!__stlxr(v8, a1))
        return *(unsigned int *)(v8 + 24);
    }
    __clrex();
    if (*(char *)(v8 + 23) < 0)
      operator delete(*(void **)v8);
    MEMORY[0x1DF0A2144](v8, 0x1072C400435926ELL);
    v8 = 0;
LABEL_33:
    ;
  }
  while (!v8);
  return *(unsigned int *)(v8 + 24);
}

void KB::LanguageModelStr::__start_session(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  char *size;
  char *v7;
  _BOOL4 v8;
  uint64_t **v9;
  uint64_t **v10;
  uint64_t v11;
  _BOOL4 *v12;
  uint64_t **v13;
  uint64_t **v14;
  void **v15;
  uint64_t v16;
  std::string::size_type v17;
  _QWORD *v18;
  std::string::size_type v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  language_modeling::v1::LanguageModelSession *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36[2];
  uint64_t v37;
  std::__shared_weak_count *v38;
  void *__p[2];
  char v40;
  std::string v41;
  uint64_t *v42;
  _QWORD *v43[2];
  char v44;
  std::string v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v43[0] = 0;
  v43[1] = 0;
  v42 = (uint64_t *)v43;
  v4 = *(_QWORD *)(a1 + 184);
  if (v4)
    atomic_store(1u, (unsigned __int8 *)(v4 + 752));
  std::mutex::lock(*(std::mutex **)(a1 + 136));
  v5 = *(_QWORD *)(a1 + 184);
  if (v5)
    atomic_store(0, (unsigned __int8 *)(v5 + 752));
  KB::utf8_string(*(const __CFString **)(a1 + 48), (uint64_t)&v45);
  size = (char *)v45.__r_.__value_.__l.__size_;
  if (!v45.__r_.__value_.__l.__size_)
    size = &v45.__r_.__value_.__s.__data_[16];
  if (LOWORD(v45.__r_.__value_.__l.__data_))
    v7 = size;
  else
    v7 = "";
  std::string::basic_string[abi:nn180100]<0>(&v41, v7);
  if (v45.__r_.__value_.__l.__size_ && v45.__r_.__value_.__s.__data_[6] == 1)
    free((void *)v45.__r_.__value_.__l.__size_);
  v8 = a2 != 0;
  std::string::basic_string[abi:nn180100]<0>(&v45, (char *)*MEMORY[0x1E0D430B8]);
  v9 = std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(&v42, &v45, (uint64_t)&v45);
  v10 = v9;
  v11 = *((unsigned int *)v9 + 20);
  if ((_DWORD)v11 != -1)
  {
    v12 = (_BOOL4 *)(v9 + 7);
    if (!(_DWORD)v11)
    {
      *v12 = v8;
      goto LABEL_18;
    }
    ((void (*)(void **, _BOOL4 *))off_1EA0FA808[v11])(__p, v12);
  }
  *((_DWORD *)v10 + 14) = v8;
  *((_DWORD *)v10 + 20) = 0;
LABEL_18:
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v45.__r_.__value_.__l.__data_);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v45, v41.__r_.__value_.__l.__data_, v41.__r_.__value_.__l.__size_);
  else
    v45 = v41;
  std::string::basic_string[abi:nn180100]<0>(__p, (char *)*MEMORY[0x1E0D430F0]);
  v13 = std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(&v42, __p, (uint64_t)__p);
  v14 = v13;
  v15 = (void **)(v13 + 7);
  v16 = *((unsigned int *)v13 + 20);
  if ((_DWORD)v16 == -1)
    goto LABEL_29;
  if ((_DWORD)v16 != 1)
  {
    ((void (*)(char *, void **))off_1EA0FA808[v16])(&v44, v15);
LABEL_29:
    *(std::string *)v15 = v45;
    memset(&v45, 0, sizeof(v45));
    *((_DWORD *)v14 + 20) = 1;
    goto LABEL_30;
  }
  if (*((char *)v13 + 79) < 0)
    operator delete(*v15);
  *(std::string *)v15 = v45;
  *((_BYTE *)&v45.__r_.__value_.__s + 23) = 0;
  v45.__r_.__value_.__s.__data_[0] = 0;
LABEL_30:
  if (v40 < 0)
    operator delete(__p[0]);
  language_modeling::v1::LanguageModel::makeSession();
  v17 = v45.__r_.__value_.__r.__words[0];
  if (v45.__r_.__value_.__r.__words[0])
  {
    v18 = (_QWORD *)operator new();
    v19 = v45.__r_.__value_.__r.__words[0];
    *v18 = &off_1EA0FA828;
    v18[1] = 0;
    v18[2] = 0;
    v18[3] = v19;
  }
  else
  {
    v18 = 0;
  }
  v45.__r_.__value_.__r.__words[0] = 0;
  v20 = *(std::__shared_weak_count **)(a1 + 208);
  *(_QWORD *)(a1 + 200) = v17;
  *(_QWORD *)(a1 + 208) = v18;
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = (language_modeling::v1::LanguageModelSession *)v45.__r_.__value_.__r.__words[0];
  v45.__r_.__value_.__r.__words[0] = 0;
  if (v23)
  {
    language_modeling::v1::LanguageModelSession::~LanguageModelSession(v23);
    MEMORY[0x1DF0A2144]();
  }
  std::mutex::unlock(*(std::mutex **)(a1 + 136));
  v24 = *(_QWORD *)(a1 + 184);
  if (v24)
  {
    v25 = *(std::__shared_weak_count **)(a1 + 144);
    v37 = *(_QWORD *)(a1 + 136);
    v38 = v25;
    if (v25)
    {
      v26 = (unint64_t *)&v25->__shared_owners_;
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    v28 = *(_QWORD *)(a1 + 200);
    v29 = *(std::__shared_weak_count **)(a1 + 208);
    v36[0] = v28;
    v36[1] = (uint64_t)v29;
    if (v29)
    {
      v30 = (unint64_t *)&v29->__shared_owners_;
      do
        v31 = __ldxr(v30);
      while (__stxr(v31 + 1, v30));
      TIInlineCompletionGeneratorImpl::initialize(v24, &v37, v36);
      do
        v32 = __ldaxr(v30);
      while (__stlxr(v32 - 1, v30));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    else
    {
      TIInlineCompletionGeneratorImpl::initialize(v24, &v37, v36);
    }
    v33 = v38;
    if (v38)
    {
      v34 = (unint64_t *)&v38->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v41.__r_.__value_.__l.__data_);
  std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::destroy(v43[0]);
}

void std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::variant<language_modeling::v1::SessionType,std::string>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t **std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, _QWORD *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  _QWORD *v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    do
    {
      while (1)
      {
        v6 = (uint64_t **)v5;
        v8 = v5 + 4;
        if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) == 0)
          break;
        v5 = *v6;
        v9 = v6;
        if (!*v6)
          goto LABEL_9;
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a2) & 0x80) == 0)
        return v6;
      v9 = v6 + 1;
      v5 = v6[1];
    }
    while (v5);
  }
  else
  {
    v9 = a1 + 1;
  }
LABEL_9:
  v10 = (uint64_t *)v6;
  v6 = (uint64_t **)operator new(0x58uLL);
  *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
  v6[6] = *(uint64_t **)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 20) = 0;
  *v6 = 0;
  v6[1] = 0;
  v6[2] = v10;
  *v9 = (uint64_t *)v6;
  v11 = (uint64_t *)**a1;
  v12 = (uint64_t *)v6;
  if (v11)
  {
    *a1 = v11;
    v12 = *v9;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v12);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v6;
}

_QWORD *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = v4 + 4;
        if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v4 + 4) & 0x80) == 0)
          break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a3) & 0x80) == 0)
        break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

const __CFString *KB::utf8_string@<X0>(const __CFString *this@<X0>, uint64_t a2@<X8>)
{
  const __CFString *v4;
  CFIndex Length;
  CFIndex v6;
  char *v7;

  if (this)
  {
    v4 = this;
    Length = CFStringGetLength(this);
    v6 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    v7 = (char *)operator new[]();
    if (CFStringGetCString(v4, v7, v6, 0x8000100u))
    {
      KB::String::String((KB::String *)a2, v7);
    }
    else
    {
      *(_DWORD *)a2 = 0x100000;
      *(_WORD *)(a2 + 4) = 0;
      *(_BYTE *)(a2 + 6) = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_BYTE *)(a2 + 16) = 0;
    }
    JUMPOUT(0x1DF0A212CLL);
  }
  *(_DWORD *)a2 = 0x100000;
  *(_WORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 6) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  return this;
}

void KB::UserDictionaryLoader::create_and_load(KB::UserDictionaryLoader *this@<X0>, uint64_t *a2@<X8>)
{
  NSObject *v5;
  void *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  void *v11;
  void *v12;
  id *v13;
  id location;
  id from;
  _QWORD v16[5];
  _BYTE v17[8];
  void *v18;
  __int128 buf;
  uint64_t v20;
  __n128 (*v21)(__n128 *, __n128 *);
  void (*v22)(uint64_t);
  const char *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  _BYTE v26[8];
  void *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  TIUserDictionaryOSLogFacility();
  v5 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Creating UserDictionaryLoader"), "create_and_load");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(buf) = 138412290;
    *(_QWORD *)((char *)&buf + 4) = v6;
    _os_log_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_INFO, "%@", (uint8_t *)&buf, 0xCu);

  }
  v7 = operator new();
  *(_QWORD *)(v7 + 8) = 0;
  *(_QWORD *)(v7 + 16) = 0;
  *(_QWORD *)v7 = 0;
  *a2 = v7;
  v8 = (std::__shared_weak_count *)operator new();
  v8->__shared_weak_owners_ = 0;
  p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105F80;
  v8->__shared_owners_ = 0;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
  a2[1] = (uint64_t)v8;
  KB::String::String((KB::String *)v26, this);
  *(_QWORD *)&buf = 0;
  *((_QWORD *)&buf + 1) = &buf;
  v20 = 0x4012000000;
  v21 = __Block_byref_object_copy__17569;
  v22 = __Block_byref_object_dispose__17570;
  v23 = "";
  v24 = v7;
  v25 = v8;
  do
    v10 = __ldxr(p_shared_weak_owners);
  while (__stxr(v10 + 1, p_shared_weak_owners));
  +[TIUserDictionaryServer sharedInstance](TIUserDictionaryServer, "sharedInstance");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3321888768;
  v16[2] = ___ZN2KB20UserDictionaryLoader15create_and_loadERKNS_6StringE_block_invoke;
  v16[3] = &unk_1EA105F40;
  KB::String::String((KB::String *)v17, (const KB::String *)v26);
  v16[4] = &buf;
  objc_msgSend(v11, "addObserver:", v16);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = (id *)operator new();
  objc_initWeak(&location, v12);
  objc_initWeak(&from, location);
  objc_copyWeak(v13, &from);
  objc_destroyWeak(&from);
  objc_destroyWeak(&location);
  std::unique_ptr<KB::WeakHolder>::reset[abi:nn180100]((id **)(v7 + 16), v13);

  if (v18 && v17[6] == 1)
    free(v18);
  _Block_object_dispose(&buf, 8);
  if (v25)
    std::__shared_weak_count::__release_weak(v25);
  if (v27)
  {
    if (v26[6] == 1)
      free(v27);
  }
}

id TIUserDictionaryOSLogFacility()
{
  if (TIUserDictionaryOSLogFacility_onceToken != -1)
    dispatch_once(&TIUserDictionaryOSLogFacility_onceToken, &__block_literal_global_42);
  return (id)TIUserDictionaryOSLogFacility_logFacility;
}

KB::UserDictionary *KB::UserDictionary::UserDictionary(KB::UserDictionary *this, const KB::String *a2, const __CFArray *a3)
{
  const __CFArray *v5;
  __CFDictionary *Mutable;
  const void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t Transient;
  uint64_t v14;
  unint64_t v15;
  unint64_t i;
  KB *v17;
  unint64_t v18;
  KB *v19;
  unsigned int v20;
  unsigned int v21;
  _BYTE v23[8];
  void *v24;
  unsigned __int16 v25[2];
  unsigned __int16 v26;
  char v27;
  void *v28;
  void *value;
  void *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 1065353216;
  *((_DWORD *)this + 22) = 0;
  v5 = a3;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = (const void *)*MEMORY[0x1E0D437B8];
  KB::cf_string_impl<KB::String>((CFStringRef *)&value, (unsigned __int16 *)a2);
  v8 = value;
  CFDictionarySetValue(Mutable, v7, value);
  if (v8)
    CFRelease(v8);
  v9 = (void *)MEMORY[0x1E0CB3940];
  objc_msgSend(MEMORY[0x1E0CB3A28], "UUID");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "UUIDString");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "stringWithFormat:", CFSTR("TextInput-TextReplacement-%@"), v11);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0D437C8], v12);
  Transient = LXLexiconCreateTransient();
  if (*(_QWORD *)this)
    CFRelease(*(CFTypeRef *)this);
  *(_QWORD *)this = Transient;
  v14 = -[__CFArray count](v5, "count");
  if (v14)
  {
    v15 = v14;
    for (i = 0; i < v15; i = v18 + 1)
    {
      -[__CFArray objectAtIndex:](v5, "objectAtIndex:", i);
      v17 = (KB *)objc_claimAutoreleasedReturnValue();
      v18 = i + 1;
      -[__CFArray objectAtIndex:](v5, "objectAtIndex:", v18);
      v19 = (KB *)objc_claimAutoreleasedReturnValue();
      if (-[KB length](v17, "length")
        && (unint64_t)-[KB length](v17, "length") <= 0x3FFC
        && (unint64_t)-[KB length](v19, "length") <= 0x40)
      {
        KB::utf8_string(v17, (uint64_t)&value);
        v20 = WORD2(value);
        if (!WORD2(value))
        {
          KB::String::compute_length((unsigned __int16 *)&value);
          v20 = WORD2(value);
        }
        if (v20 <= 0x80 && LXLexiconAdd())
          LXLexiconIncrementUsageCount();
        if (-[KB length](v19, "length") && (-[KB isEqualToString:](v19, "isEqualToString:", v17) & 1) == 0)
        {
          KB::utf8_string(v19, (uint64_t)v23);
          KB::lower_string((KB *)v23, 0, (KB::String *)v25);
          if (v24 && v23[6] == 1)
            free(v24);
          v21 = v26;
          if (!v26)
          {
            KB::String::compute_length(v25);
            v21 = v26;
          }
          if (*((_DWORD *)this + 22) < v21)
          {
            if (!v21)
            {
              KB::String::compute_length(v25);
              v21 = v26;
            }
            *((_DWORD *)this + 22) = v21;
          }
          if (LXLexiconAdd())
            LXLexiconIncrementUsageCount();
          KB::UserDictionary::set_conversion_for_shortcut(this, (const KB::String *)v25, (const KB::String *)&value);
          if (v28 && v27 == 1)
            free(v28);
        }
        if (v30 && BYTE6(value) == 1)
          free(v30);
      }

    }
  }

  if (Mutable)
    CFRelease(Mutable);

  return this;
}

void KB::lower_string(KB *this@<X0>, const KB::String *a2@<X1>, KB::String *a3@<X8>)
{
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t i;
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const __CFString *v17;
  CFMutableStringRef v18[2];

  v18[1] = *(CFMutableStringRef *)MEMORY[0x1E0C80C00];
  v7 = *(unsigned __int16 *)this;
  v8 = *((unsigned __int16 *)this + 2);
  if (*((_WORD *)this + 2))
  {
    if (a2)
    {
LABEL_21:
      KB::cf_mutable_string((KB *)v18, this);
      v17 = v18[0];
      CFStringLowercase(v18[0], a2);
      KB::utf8_string(v17, (uint64_t)a3);
      if (v17)
        CFRelease(v17);
      return;
    }
  }
  else
  {
    KB::String::compute_length((unsigned __int16 *)this);
    v8 = *((unsigned __int16 *)this + 2);
    if (a2)
      goto LABEL_21;
  }
  if (v7 != v8)
    goto LABEL_21;
  v9 = *(unsigned __int16 *)this;
  MEMORY[0x1E0C80A78]();
  v11 = (char *)v18 - v10;
  if (v9)
  {
    for (i = 0; i != v9; ++i)
    {
      v13 = (const char *)*((_QWORD *)this + 1);
      if (!v13)
        v13 = (char *)this + 16;
      if (*(_WORD *)this)
        v14 = v13;
      else
        v14 = "";
      v11[i] = __tolower(v14[i]);
    }
  }
  v11[v9] = 0;
  v15 = (const char *)*((_QWORD *)this + 1);
  if (!v15)
    v15 = (char *)this + 16;
  if (*(_WORD *)this)
    v16 = v15;
  else
    v16 = "";
  if (!strcmp(v16, v11))
    KB::String::String(a3, this);
  else
    KB::String::String(a3, v11);
}

void KB::UserDictionary::set_conversion_for_shortcut(KB::UserDictionary *this, const KB::String *a2, const KB::String *a3)
{
  unint64_t v3;
  KB::String *v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  unint64_t v14;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  int8x8_t prime;
  void *v22;
  void *v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  uint8x8_t v27;
  unint64_t v28;
  uint8x8_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t v37;
  KB::String *v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  int v47;
  unint64_t v48;
  KB::String *v49;
  unsigned int v50;
  unint64_t v51;
  unint64_t v52;
  uint8x8_t v53;
  unint64_t v54;
  void **v55;
  _QWORD *v56;
  unint64_t v57;
  _QWORD *v58;
  float v59;
  float v60;
  _BOOL8 v61;
  unint64_t v62;
  unint64_t v63;
  int8x8_t v64;
  void *v65;
  void *v66;
  uint64_t v67;
  _QWORD *v68;
  unint64_t v69;
  uint8x8_t v70;
  unint64_t v71;
  uint8x8_t v72;
  uint64_t v73;
  _QWORD *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  unint64_t v79;
  int v80;
  char *v81;
  int v82;
  uint64_t v83;
  unsigned int v84;
  int v85;
  int v86;
  int v88;
  char *v89;
  void *v90;
  void *v91;
  uint64_t v92;
  int v93;
  int v94;
  int v95;
  __int128 v96;
  uint64_t v97;
  __int128 v98;
  uint64_t v99;
  __int128 v100;
  uint64_t v101;
  _WORD v102[3];
  char v103;
  void *v104;
  _BYTE v105[16];
  char *v106[2];
  _QWORD v107[5];

  v107[3] = *MEMORY[0x1E0C80C00];
  KB::lower_string(a2, 0, (KB::String *)v102);
  if (v104)
    v6 = (KB::String *)v104;
  else
    v6 = (KB::String *)v105;
  v7 = KB::String::hash(v6, (const char *)v102[0]);
  v8 = v7;
  v9 = *((_QWORD *)this + 2);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v9 <= v7)
        v3 = v7 % v9;
    }
    else
    {
      v3 = ((_DWORD)v9 - 1) & v7;
    }
    v12 = *(void ***)(*((_QWORD *)this + 1) + 8 * v3);
    if (v12)
    {
      v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          v14 = *((_QWORD *)v13 + 1);
          if (v14 == v8)
          {
            if (v13 + 16 == (char *)v102 || KB::String::equal((KB::String *)(v13 + 16), (const KB::String *)v102, 1))
              goto LABEL_78;
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9)
                v14 %= v9;
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3)
              break;
          }
          v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  v15 = (_QWORD *)((char *)this + 24);
  v13 = (char *)operator new(0x48uLL);
  *(_QWORD *)v13 = 0;
  *((_QWORD *)v13 + 1) = v8;
  KB::String::String((KB::String *)(v13 + 16), (const KB::String *)v102);
  *((_QWORD *)v13 + 6) = 0;
  *((_QWORD *)v13 + 7) = 0;
  *((_QWORD *)v13 + 8) = 0;
  v16 = (float)(unint64_t)(*((_QWORD *)this + 4) + 1);
  v17 = *((float *)this + 10);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      prime = (int8x8_t)v20;
    else
      prime = (int8x8_t)v19;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v9 = *((_QWORD *)this + 2);
    if (*(_QWORD *)&prime > v9)
      goto LABEL_34;
    if (*(_QWORD *)&prime < v9)
    {
      v28 = vcvtps_u32_f32((float)*((unint64_t *)this + 4) / *((float *)this + 10));
      if (v9 < 3 || (v29 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
      {
        v28 = std::__next_prime(v28);
      }
      else
      {
        v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2)
          v28 = v30;
      }
      if (*(_QWORD *)&prime <= v28)
        prime = (int8x8_t)v28;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = *((_QWORD *)this + 2);
      }
      else
      {
        if (prime)
        {
LABEL_34:
          if (*(_QWORD *)&prime >> 61)
            goto LABEL_210;
          v22 = operator new(8 * *(_QWORD *)&prime);
          v23 = (void *)*((_QWORD *)this + 1);
          *((_QWORD *)this + 1) = v22;
          if (v23)
            operator delete(v23);
          v24 = 0;
          *((int8x8_t *)this + 2) = prime;
          do
            *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v24++) = 0;
          while (*(_QWORD *)&prime != v24);
          v25 = (_QWORD *)*v15;
          if (*v15)
          {
            v26 = v25[1];
            v27 = (uint8x8_t)vcnt_s8(prime);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= *(_QWORD *)&prime)
                v26 %= *(_QWORD *)&prime;
            }
            else
            {
              v26 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v26) = v15;
            v31 = (_QWORD *)*v25;
            if (*v25)
            {
              do
              {
                v32 = v31[1];
                if (v27.u32[0] > 1uLL)
                {
                  if (v32 >= *(_QWORD *)&prime)
                    v32 %= *(_QWORD *)&prime;
                }
                else
                {
                  v32 &= *(_QWORD *)&prime - 1;
                }
                if (v32 != v26)
                {
                  v33 = *((_QWORD *)this + 1);
                  if (!*(_QWORD *)(v33 + 8 * v32))
                  {
                    *(_QWORD *)(v33 + 8 * v32) = v25;
                    goto LABEL_59;
                  }
                  *v25 = *v31;
                  *v31 = **(_QWORD **)(*((_QWORD *)this + 1) + 8 * v32);
                  **(_QWORD **)(*((_QWORD *)this + 1) + 8 * v32) = v31;
                  v31 = v25;
                }
                v32 = v26;
LABEL_59:
                v25 = v31;
                v31 = (_QWORD *)*v31;
                v26 = v32;
              }
              while (v31);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_63;
        }
        v90 = (void *)*((_QWORD *)this + 1);
        *((_QWORD *)this + 1) = 0;
        if (v90)
          operator delete(v90);
        v9 = 0;
        *((_QWORD *)this + 2) = 0;
      }
    }
LABEL_63:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v8)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = ((_DWORD)v9 - 1) & v8;
    }
  }
  v34 = *((_QWORD *)this + 1);
  v35 = *(_QWORD **)(v34 + 8 * v3);
  if (v35)
  {
    *(_QWORD *)v13 = *v35;
LABEL_76:
    *v35 = v13;
    goto LABEL_77;
  }
  *(_QWORD *)v13 = *v15;
  *v15 = v13;
  *(_QWORD *)(v34 + 8 * v3) = v15;
  if (*(_QWORD *)v13)
  {
    v36 = *(_QWORD *)(*(_QWORD *)v13 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v36 >= v9)
        v36 %= v9;
    }
    else
    {
      v36 &= v9 - 1;
    }
    v35 = (_QWORD *)(*((_QWORD *)this + 1) + 8 * v36);
    goto LABEL_76;
  }
LABEL_77:
  ++*((_QWORD *)this + 4);
LABEL_78:
  v37 = *((_QWORD *)v13 + 8);
  v38 = (KB::String *)*((_QWORD *)v13 + 7);
  if ((unint64_t)v38 >= v37)
  {
    v40 = *((_QWORD *)v13 + 6);
    v41 = ((uint64_t)v38 - v40) >> 5;
    if ((unint64_t)(v41 + 1) >> 59)
      abort();
    v42 = v37 - v40;
    v43 = v42 >> 4;
    if (v42 >> 4 <= (unint64_t)(v41 + 1))
      v43 = v41 + 1;
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFE0)
      v44 = 0x7FFFFFFFFFFFFFFLL;
    else
      v44 = v43;
    v107[2] = v13 + 64;
    if (v44)
      v44 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v44);
    else
      v45 = 0;
    v46 = (char *)(v44 + 32 * v41);
    v106[0] = (char *)v44;
    v106[1] = v46;
    v107[1] = v44 + 32 * v45;
    KB::String::String((KB::String *)v46, a3);
    v107[0] = v46 + 32;
    std::vector<KB::String>::__swap_out_circular_buffer((uint64_t)(v13 + 48), v106);
    v39 = (char *)*((_QWORD *)v13 + 7);
    std::__split_buffer<KB::String>::~__split_buffer((uint64_t)v106);
  }
  else
  {
    v39 = (char *)KB::String::String(v38, a3) + 32;
  }
  *((_QWORD *)v13 + 7) = v39;
  v47 = v102[0];
  if (v104)
    v48 = (unint64_t)v104;
  else
    v48 = (unint64_t)v105;
  v106[0] = (char *)v48;
  LODWORD(v106[1]) = v102[0];
  HIDWORD(v106[1]) = v102[0];
  LODWORD(v107[0]) = 0;
  KB::String::iterator::initialize((uint64_t *)v106);
  v98 = *(_OWORD *)v106;
  v99 = v107[0];
  KB::String::iterator::operator--((KB::String::iterator *)&v98);
  *(_QWORD *)&v100 = v48;
  DWORD2(v100) = 0;
  HIDWORD(v100) = v47;
  LODWORD(v101) = 0;
  KB::String::iterator::initialize((uint64_t *)&v100);
  KB::String::String((KB::String *)v106, (const KB::String::iterator *)&v100, (const KB::String::iterator *)&v98);
  if (v106[1])
    v49 = (KB::String *)v106[1];
  else
    v49 = (KB::String *)v107;
  v50 = KB::String::hash(v49, (const char *)LOWORD(v106[0]));
  v51 = v50;
  v52 = *((_QWORD *)this + 7);
  if (v52)
  {
    v53 = (uint8x8_t)vcnt_s8((int8x8_t)v52);
    v53.i16[0] = vaddlv_u8(v53);
    v54 = v53.u32[0];
    if (v53.u32[0] > 1uLL)
    {
      v48 = v50;
      if (v52 <= v50)
        v48 = v50 % v52;
    }
    else
    {
      v48 = ((_DWORD)v52 - 1) & v50;
    }
    v55 = *(void ***)(*((_QWORD *)this + 6) + 8 * v48);
    if (v55)
    {
      v56 = *v55;
      if (*v55)
      {
        do
        {
          v57 = v56[1];
          if (v57 == v51)
          {
            if (v56 + 2 == v106 || KB::String::equal((KB::String *)(v56 + 2), (const KB::String *)v106, 1))
              goto LABEL_170;
          }
          else
          {
            if (v54 > 1)
            {
              if (v57 >= v52)
                v57 %= v52;
            }
            else
            {
              v57 &= v52 - 1;
            }
            if (v57 != v48)
              break;
          }
          v56 = (_QWORD *)*v56;
        }
        while (v56);
      }
    }
  }
  v58 = (_QWORD *)((char *)this + 64);
  v56 = operator new(0x50uLL);
  *v56 = 0;
  v56[1] = v51;
  KB::String::String((KB::String *)(v56 + 2), (const KB::String *)v106);
  *((_DWORD *)v56 + 12) = 0x100000;
  *((_WORD *)v56 + 26) = 0;
  *((_BYTE *)v56 + 54) = 0;
  v56[7] = 0;
  *((_BYTE *)v56 + 64) = 0;
  v59 = (float)(unint64_t)(*((_QWORD *)this + 9) + 1);
  v60 = *((float *)this + 20);
  if (!v52 || (float)(v60 * (float)v52) < v59)
  {
    v61 = 1;
    if (v52 >= 3)
      v61 = (v52 & (v52 - 1)) != 0;
    v62 = v61 | (2 * v52);
    v63 = vcvtps_u32_f32(v59 / v60);
    if (v62 <= v63)
      v64 = (int8x8_t)v63;
    else
      v64 = (int8x8_t)v62;
    if (*(_QWORD *)&v64 == 1)
    {
      v64 = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&v64 & (*(_QWORD *)&v64 - 1)) != 0)
    {
      v64 = (int8x8_t)std::__next_prime(*(_QWORD *)&v64);
    }
    v52 = *((_QWORD *)this + 7);
    if (*(_QWORD *)&v64 > v52)
    {
LABEL_126:
      if (!(*(_QWORD *)&v64 >> 61))
      {
        v65 = operator new(8 * *(_QWORD *)&v64);
        v66 = (void *)*((_QWORD *)this + 6);
        *((_QWORD *)this + 6) = v65;
        if (v66)
          operator delete(v66);
        v67 = 0;
        *((int8x8_t *)this + 7) = v64;
        do
          *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v67++) = 0;
        while (*(_QWORD *)&v64 != v67);
        v68 = (_QWORD *)*v58;
        if (*v58)
        {
          v69 = v68[1];
          v70 = (uint8x8_t)vcnt_s8(v64);
          v70.i16[0] = vaddlv_u8(v70);
          if (v70.u32[0] > 1uLL)
          {
            if (v69 >= *(_QWORD *)&v64)
              v69 %= *(_QWORD *)&v64;
          }
          else
          {
            v69 &= *(_QWORD *)&v64 - 1;
          }
          *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v69) = v58;
          v74 = (_QWORD *)*v68;
          if (*v68)
          {
            do
            {
              v75 = v74[1];
              if (v70.u32[0] > 1uLL)
              {
                if (v75 >= *(_QWORD *)&v64)
                  v75 %= *(_QWORD *)&v64;
              }
              else
              {
                v75 &= *(_QWORD *)&v64 - 1;
              }
              if (v75 != v69)
              {
                v76 = *((_QWORD *)this + 6);
                if (!*(_QWORD *)(v76 + 8 * v75))
                {
                  *(_QWORD *)(v76 + 8 * v75) = v68;
                  goto LABEL_151;
                }
                *v68 = *v74;
                *v74 = **(_QWORD **)(*((_QWORD *)this + 6) + 8 * v75);
                **(_QWORD **)(*((_QWORD *)this + 6) + 8 * v75) = v74;
                v74 = v68;
              }
              v75 = v69;
LABEL_151:
              v68 = v74;
              v74 = (_QWORD *)*v74;
              v69 = v75;
            }
            while (v74);
          }
        }
        v52 = (unint64_t)v64;
        goto LABEL_155;
      }
LABEL_210:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    if (*(_QWORD *)&v64 < v52)
    {
      v71 = vcvtps_u32_f32((float)*((unint64_t *)this + 9) / *((float *)this + 20));
      if (v52 < 3 || (v72 = (uint8x8_t)vcnt_s8((int8x8_t)v52), v72.i16[0] = vaddlv_u8(v72), v72.u32[0] > 1uLL))
      {
        v71 = std::__next_prime(v71);
      }
      else
      {
        v73 = 1 << -(char)__clz(v71 - 1);
        if (v71 >= 2)
          v71 = v73;
      }
      if (*(_QWORD *)&v64 <= v71)
        v64 = (int8x8_t)v71;
      if (*(_QWORD *)&v64 >= v52)
      {
        v52 = *((_QWORD *)this + 7);
      }
      else
      {
        if (v64)
          goto LABEL_126;
        v91 = (void *)*((_QWORD *)this + 6);
        *((_QWORD *)this + 6) = 0;
        if (v91)
          operator delete(v91);
        v52 = 0;
        *((_QWORD *)this + 7) = 0;
      }
    }
LABEL_155:
    if ((v52 & (v52 - 1)) != 0)
    {
      if (v52 <= v51)
        v48 = v51 % v52;
      else
        v48 = v51;
    }
    else
    {
      v48 = ((_DWORD)v52 - 1) & v51;
    }
  }
  v77 = *((_QWORD *)this + 6);
  v78 = *(_QWORD **)(v77 + 8 * v48);
  if (v78)
  {
    *v56 = *v78;
LABEL_168:
    *v78 = v56;
    goto LABEL_169;
  }
  *v56 = *v58;
  *v58 = v56;
  *(_QWORD *)(v77 + 8 * v48) = v58;
  if (*v56)
  {
    v79 = *(_QWORD *)(*v56 + 8);
    if ((v52 & (v52 - 1)) != 0)
    {
      if (v79 >= v52)
        v79 %= v52;
    }
    else
    {
      v79 &= v52 - 1;
    }
    v78 = (_QWORD *)(*((_QWORD *)this + 6) + 8 * v79);
    goto LABEL_168;
  }
LABEL_169:
  ++*((_QWORD *)this + 9);
LABEL_170:
  v80 = *((unsigned __int16 *)v56 + 24);
  v81 = (char *)v56[7];
  if (!v81)
    v81 = (char *)(v56 + 8);
  *(_QWORD *)&v96 = v81;
  DWORD2(v96) = 0;
  HIDWORD(v96) = v80;
  LODWORD(v97) = 0;
  KB::String::iterator::initialize((uint64_t *)&v96);
  v82 = *((unsigned __int16 *)v56 + 24);
  v83 = v56[7];
  if (!v83)
    v83 = (uint64_t)(v56 + 8);
  v92 = v83;
  v93 = v82;
  v94 = v82;
  v95 = 0;
  KB::String::iterator::initialize(&v92);
  v84 = v99;
  v100 = v96;
  v101 = v97;
  v85 = v93;
  v86 = DWORD2(v96);
  if (DWORD2(v96) != v93 && (_DWORD)v101 != (_DWORD)v99)
  {
    do
    {
      KB::String::iterator::operator++((uint64_t *)&v100);
      v86 = DWORD2(v100);
    }
    while (DWORD2(v100) != v85 && (_DWORD)v101 != v84);
  }
  v88 = *((unsigned __int16 *)v56 + 24);
  v89 = (char *)v56[7];
  if (!v89)
    v89 = (char *)(v56 + 8);
  *(_QWORD *)&v100 = v89;
  DWORD2(v100) = v88;
  HIDWORD(v100) = v88;
  LODWORD(v101) = 0;
  KB::String::iterator::initialize((uint64_t *)&v100);
  if (v86 == DWORD2(v100))
    KB::String::append((KB::String *)(v56 + 6), v84);
  if (v106[1] && BYTE6(v106[0]) == 1)
    free(v106[1]);
  if (v104)
  {
    if (v103 == 1)
      free(v104);
  }
}

uint64_t std::vector<KB::String>::__swap_out_circular_buffer(uint64_t result, _QWORD *a2)
{
  uint64_t *v3;
  KB::String *v4;
  KB::String *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = (uint64_t *)result;
  v5 = *(KB::String **)result;
  v4 = *(KB::String **)(result + 8);
  v6 = a2[1];
  if (v4 != *(KB::String **)result)
  {
    result = v6 - 32;
    do
    {
      v4 = (KB::String *)((char *)v4 - 32);
      *(_DWORD *)result = 0x100000;
      *(_WORD *)(result + 4) = 0;
      *(_BYTE *)(result + 6) = 0;
      *(_QWORD *)(result + 8) = 0;
      result = KB::String::operator=(result, v4) - 32;
    }
    while (v4 != v5);
    v6 = result + 32;
  }
  a2[1] = v6;
  v7 = *v3;
  *v3 = v6;
  a2[1] = v7;
  v8 = v3[1];
  v3[1] = a2[2];
  a2[2] = v8;
  v9 = v3[2];
  v3[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<KB::String>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      v4 = v2 - 32;
      *(_QWORD *)(a1 + 16) = v2 - 32;
      v5 = *(void **)(v2 - 24);
      if (v5 && *(_BYTE *)(v2 - 26) == 1)
      {
        free(v5);
        v4 = *(_QWORD *)(a1 + 16);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  uint8x8_t v10;
  unint64_t v11;
  uint8x8_t v12;
  uint64_t v13;
  _QWORD *v14;
  size_t v15;
  void *v16;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(_QWORD *)&v4)
  {
    if (prime >= *(_QWORD *)&v4)
      return;
    v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      v11 = std::__next_prime(v11);
    }
    else
    {
      v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2)
        v11 = v13;
    }
    if (prime <= v11)
      prime = v11;
    if (prime >= *(_QWORD *)&v4)
      return;
    if (!prime)
    {
      v16 = *(void **)a1;
      *(_QWORD *)a1 = 0;
      if (v16)
        operator delete(v16);
      *(_QWORD *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v5 = operator new(8 * prime);
  v6 = *(void **)a1;
  *(_QWORD *)a1 = v5;
  if (v6)
    operator delete(v6);
  v7 = 0;
  *(_QWORD *)(a1 + 8) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  v8 = *(_QWORD **)(a1 + 16);
  if (v8)
  {
    v9 = v8[1];
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime)
        v9 %= prime;
    }
    else
    {
      v9 &= prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v9) = a1 + 16;
    v14 = (_QWORD *)*v8;
    if (*v8)
    {
      do
      {
        v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime)
            v15 %= prime;
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v15))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *v8 = *v14;
          *v14 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v15);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v15) = v14;
          v14 = v8;
        }
        v15 = v9;
LABEL_31:
        v8 = v14;
        v14 = (_QWORD *)*v14;
        v9 = v15;
      }
      while (v14);
    }
  }
}

KB::String *KB::String::String(KB::String *this, const KB::String::iterator *a2, const KB::String::iterator *a3)
{
  uint64_t v5;
  unsigned int v6;
  unsigned __int16 v7;
  BOOL v8;
  const void *v9;
  char *v10;

  *(_DWORD *)this = 0x100000;
  *((_WORD *)this + 2) = 0;
  *((_BYTE *)this + 6) = 1;
  *((_QWORD *)this + 1) = 0;
  v5 = *(_QWORD *)a2;
  v6 = KB::String::iterator::offset(a2);
  v7 = KB::String::iterator::offset(a3) - v6;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  if (v5)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (!v8)
  {
    v9 = (const void *)(v5 + v6);
    KB::String::ensure_capacity(this, v7);
    if (*((_QWORD *)this + 1))
      v10 = (char *)*((_QWORD *)this + 1);
    else
      v10 = (char *)this + 16;
    memcpy(v10, v9, v7);
    *(_WORD *)this = v7;
  }
  return this;
}

uint64_t KB::String::iterator::offset(KB::String::iterator *this)
{
  uint64_t result;
  int v3;
  unsigned int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;

  v3 = *((_DWORD *)this + 2);
  result = *((unsigned int *)this + 3);
  if (v3 <= (int)result)
  {
    v4 = *((_DWORD *)this + 4);
    if (v4 >= 0x10000)
      v5 = -4;
    else
      v5 = -3;
    if (v4 - 1114112 >= 0xFFEFE000)
      v6 = v5;
    else
      v6 = 0;
    if (v4 >> 11 >= 0x1B)
      v7 = v6;
    else
      v7 = -3;
    if (v4 >= 0x800)
      v8 = v7;
    else
      v8 = -2;
    if (v4 >= 0x80)
      v9 = v8;
    else
      v9 = -1;
    return (v9 + v3);
  }
  return result;
}

KB::String::iterator *KB::String::iterator::operator--(KB::String::iterator *a1)
{
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  char v7;
  char v8;
  unsigned int v9;
  char v10;
  char v11;

  v2 = KB::String::iterator::offset(a1);
  if (v2)
  {
    *((_DWORD *)a1 + 2) = v2;
    v3 = *(_QWORD *)a1;
    v4 = *(char *)(*(_QWORD *)a1 + (v2 - 1));
    *((_DWORD *)a1 + 4) = v4;
    if ((v4 & 0xC0) == 0x80)
    {
      v5 = v4 & 0x3F;
      *((_DWORD *)a1 + 4) = v5;
      v6 = *(unsigned __int8 *)(v3 + (v2 - 2));
      if (v6 <= 0xBF)
      {
        v9 = v2 - 3;
        v10 = 1;
        v11 = 6;
        do
        {
          v5 |= (v6 & 0x3F) << v11;
          *((_DWORD *)a1 + 4) = v5;
          ++v10;
          v11 += 6;
          v6 = *(unsigned __int8 *)(v3 + v9--);
        }
        while (v6 <= 0xBF);
        v8 = 6 - v10;
        v7 = v11;
      }
      else
      {
        v7 = 6;
        v8 = 5;
      }
      *((_DWORD *)a1 + 4) = v5 | ((v6 & ~(-1 << v8)) << v7);
    }
  }
  return a1;
}

void KB::String::append(KB::String *this, unsigned int a2)
{
  unsigned __int16 v4;
  unsigned __int16 v5;
  char *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!*((_BYTE *)this + 6))
    KB::String::internalize_buffer((unsigned __int16 *)this);
  v4 = *(_WORD *)this;
  if (a2 > 0x7F)
  {
    KB::String::ensure_capacity(this, v4 + 4);
    v6 = (char *)*((_QWORD *)this + 1);
    if (!v6)
      v6 = (char *)this + 16;
    if (a2 > 0x7FF)
    {
      v8 = *(unsigned __int16 *)this;
      *(_WORD *)this = v8 + 1;
      if (HIWORD(a2))
      {
        v6[v8] = (a2 >> 18) | 0xF0;
        v9 = *(unsigned __int16 *)this;
        *(_WORD *)this = v9 + 1;
        v6[v9] = (a2 >> 12) & 0x3F | 0x80;
      }
      else
      {
        v6[v8] = (a2 >> 12) | 0xE0;
      }
      v7 = (a2 >> 6) & 0x3F | 0xFFFFFF80;
    }
    else
    {
      v7 = (a2 >> 6) | 0xFFFFFFC0;
    }
    v10 = *(unsigned __int16 *)this;
    *(_WORD *)this = v10 + 1;
    v6[v10] = v7;
    v11 = *(unsigned __int16 *)this;
    *(_WORD *)this = v11 + 1;
    v6[v11] = a2 & 0x3F | 0x80;
  }
  else
  {
    v5 = v4 + 1;
    KB::String::ensure_capacity(this, v4 + 1);
    v6 = (char *)*((_QWORD *)this + 1);
    if (!v6)
      v6 = (char *)this + 16;
    *(_WORD *)this = v5;
    v6[v5 - 1] = a2;
  }
  v6[*(unsigned __int16 *)this] = 0;
  *((_WORD *)this + 2) = 0;
}

unsigned __int16 *KB::String::internalize_buffer(unsigned __int16 *this)
{
  const void *v1;
  size_t v2;
  unsigned __int16 *v3;
  BOOL v4;
  unsigned __int16 *v5;
  unsigned __int16 *v6;

  *((_BYTE *)this + 6) = 1;
  v1 = (const void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  v2 = *this;
  *((_QWORD *)this + 2) = 0;
  v3 = this + 8;
  *((_QWORD *)this + 3) = 0;
  if (v1)
    v4 = (_DWORD)v2 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v5 = this;
    KB::String::ensure_capacity((KB::String *)this, v2);
    if (*((_QWORD *)v5 + 1))
      v6 = (unsigned __int16 *)*((_QWORD *)v5 + 1);
    else
      v6 = v3;
    this = (unsigned __int16 *)memcpy(v6, v1, v2);
    *v5 = v2;
  }
  return this;
}

id TIAssetsOSLogFacility()
{
  if (TIAssetsOSLogFacility_onceToken != -1)
    dispatch_once(&TIAssetsOSLogFacility_onceToken, &__block_literal_global_44);
  return (id)TIAssetsOSLogFacility_logFacility;
}

uint64_t getInlineCompletionPrecision()
{
  if (byte_1F0283360)
    return inline_completion_precision_point_override;
  if ((_os_feature_enabled_impl() & 1) != 0)
    return 80;
  if (_os_feature_enabled_impl())
    return 70;
  return 90;
}

id TITypingEngineAllowedValues()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  _QWORD v4[7];

  v4[6] = *MEMORY[0x1E0C80C00];
  v0 = *MEMORY[0x1E0DBE218];
  v4[0] = *MEMORY[0x1E0DBE238];
  v4[1] = v0;
  v1 = *MEMORY[0x1E0DBE220];
  v4[2] = *MEMORY[0x1E0DBE210];
  v4[3] = v1;
  v2 = *MEMORY[0x1E0DBE230];
  v4[4] = *MEMORY[0x1E0DBE228];
  v4[5] = v2;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v4, 6);
  return (id)objc_claimAutoreleasedReturnValue();
}

id TIACCorrectionTypeValues()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  _QWORD v6[7];

  v6[6] = *MEMORY[0x1E0C80C00];
  v6[0] = kTIACCorrectionTypeNone;
  v6[1] = kTIACSingleWordCountType;
  objc_msgSend(kTIACSingleWordCountType, "stringByAppendingString:", kTIACMessageBeginsWithAsterisk);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v6[2] = v0;
  objc_msgSend(kTIACSingleWordCountType, "stringByAppendingString:", kTIACMessageEndsWithAsterisk);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v6[3] = v1;
  objc_msgSend(kTIACMultiWordCountType, "stringByAppendingString:", kTIACMessageBeginsWithAsterisk);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v6[4] = v2;
  objc_msgSend(kTIACMultiWordCountType, "stringByAppendingString:", kTIACMessageEndsWithAsterisk);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v6[5] = v3;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v6, 6);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id fieldSpecWithSuffices(void *a1)
{
  id v1;
  uint64_t i;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  id obj;
  uint64_t v26;
  id v27;
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  _QWORD v47[11];
  _BYTE v48[128];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (id)objc_claimAutoreleasedReturnValue();
  v43 = 0u;
  v44 = 0u;
  v45 = 0u;
  v46 = 0u;
  obj = v1;
  v28 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v43, v48, 16);
  if (v28)
  {
    v26 = *(_QWORD *)v44;
    do
    {
      for (i = 0; i != v28; ++i)
      {
        if (*(_QWORD *)v44 != v26)
          objc_enumerationMutation(obj);
        v3 = *(_QWORD *)(*((_QWORD *)&v43 + 1) + 8 * i);
        v4 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("sourceBitset"), "stringByAppendingString:", v3);
        v42 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v4, "integerFieldSpecWithName:minValue:maxValue:significantDigits:", v42, &unk_1EA140330, 0, 0);
        v41 = (void *)objc_claimAutoreleasedReturnValue();
        v47[0] = v41;
        v5 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("length"), "stringByAppendingString:", v3);
        v40 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v5, "integerFieldSpecWithName:minValue:maxValue:significantDigits:", v40, &unk_1EA140330, 0, 0);
        v39 = (void *)objc_claimAutoreleasedReturnValue();
        v47[1] = v39;
        v6 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("capitalization"), "stringByAppendingString:", v3);
        v38 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v6, "stringFieldSpecWithName:", v38);
        v37 = (void *)objc_claimAutoreleasedReturnValue();
        v47[2] = v37;
        v7 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("diacritics"), "stringByAppendingString:", v3);
        v36 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v7, "BOOLeanFieldSpecWithName:", v36);
        v35 = (void *)objc_claimAutoreleasedReturnValue();
        v47[3] = v35;
        v8 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("punctuation"), "stringByAppendingString:", v3);
        v34 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v8, "BOOLeanFieldSpecWithName:", v34);
        v33 = (void *)objc_claimAutoreleasedReturnValue();
        v47[4] = v33;
        v9 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("multiword"), "stringByAppendingString:", v3);
        v32 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v9, "BOOLeanFieldSpecWithName:", v32);
        v31 = (void *)objc_claimAutoreleasedReturnValue();
        v47[5] = v31;
        v10 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("geometryScore"), "stringByAppendingString:", v3);
        v30 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v10, "integerFieldSpecWithName:minValue:maxValue:significantDigits:", v30, 0, 0, 0);
        v29 = (void *)objc_claimAutoreleasedReturnValue();
        v47[6] = v29;
        v11 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("languageModelScore"), "stringByAppendingString:", v3);
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v11, "integerFieldSpecWithName:minValue:maxValue:significantDigits:", v12, 0, 0, 0);
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        v47[7] = v13;
        v14 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("language"), "stringByAppendingString:", v3);
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v14, "stringFieldSpecWithName:", v15);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        v47[8] = v16;
        v17 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("localUsageCount"), "stringByAppendingString:", v3);
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v17, "integerFieldSpecWithName:minValue:maxValue:significantDigits:", v18, 0, 0, 0);
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        v47[9] = v19;
        v20 = (void *)MEMORY[0x1E0DBDB20];
        objc_msgSend(CFSTR("localPenaltyCount"), "stringByAppendingString:", v3);
        v21 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v20, "integerFieldSpecWithName:minValue:maxValue:significantDigits:", v21, 0, 0, 0);
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        v47[10] = v22;
        objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v47, 11);
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v27, "addObjectsFromArray:", v23);

      }
      v28 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v43, v48, 16);
    }
    while (v28);
  }

  return v27;
}

id concatArrays(void *a1)
{
  id v1;
  void *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v3 = v1;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v11;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v11 != v6)
          objc_enumerationMutation(v3);
        objc_msgSend(v2, "addObjectsFromArray:", *(_QWORD *)(*((_QWORD *)&v10 + 1) + 8 * v7++), (_QWORD)v10);
      }
      while (v5 != v7);
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
    }
    while (v5);
  }

  v8 = (void *)objc_msgSend(v2, "copy");
  return v8;
}

id TIAssetAvailabilityStatusAllowedValues()
{
  _QWORD v1[3];

  v1[2] = *MEMORY[0x1E0C80C00];
  v1[0] = CFSTR("Unavailable");
  v1[1] = CFSTR("Installed");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v1, 2);
  return (id)objc_claimAutoreleasedReturnValue();
}

id TITypingSpeedAllowedValues()
{
  _QWORD v1[8];

  v1[7] = *MEMORY[0x1E0C80C00];
  v1[0] = kFeatureStringTypingSpeedInsufficientData;
  v1[1] = kFeatureStringTypingSpeedVerySlow;
  v1[2] = kFeatureStringTypingSpeedSlow;
  v1[3] = kFeatureStringTypingSpeedMedium;
  v1[4] = kFeatureStringTypingSpeedFast;
  v1[5] = kFeatureStringTypingSpeedVeryFast;
  v1[6] = kFeatureStringTypingSpeedUnusual;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v1, 7);
  return (id)objc_claimAutoreleasedReturnValue();
}

unsigned int *TIInputManager::commit_key_layout(TIInputManager *this)
{
  unsigned int *result;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int *v15;

  result = (unsigned int *)*((_QWORD *)this + 23);
  if (result)
  {
    result = (unsigned int *)(*(_QWORD *(**)(unsigned int **__return_ptr))(*(_QWORD *)result + 168))(&v15);
    v3 = v15;
    if (v15)
    {
      v4 = v15 + 2;
      v5 = atomic_load(v15 + 2);
      if (v5 == 1)
      {
        result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v15 + 40))(v15);
      }
      else
      {
        do
          v6 = __ldaxr(v4);
        while (__stlxr(v6 - 1, v4));
      }
      v7 = *((_QWORD *)this + 68);
      if (v7)
      {
        v8 = (unsigned int *)*TIInputManager::favonius_layout(this);
        v13 = v8;
        if (v8)
        {
          do
            v9 = __ldaxr(v8);
          while (__stlxr(v9 + 1, v8));
        }
        (*(void (**)(unsigned int **__return_ptr, uint64_t, unsigned int **))(*(_QWORD *)v7 + 16))(&v14, v7, &v13);
        (*(void (**)(unsigned int *, unsigned int **))(*(_QWORD *)v3 + 24))(v3, &v14);
        if (v14)
        {
          v10 = v14 + 2;
          v11 = atomic_load(v14 + 2);
          if (v11 == 1)
          {
            (*(void (**)(void))(*(_QWORD *)v14 + 8))();
          }
          else
          {
            do
              v12 = __ldaxr(v10);
            while (__stlxr(v12 - 1, v10));
          }
        }
        result = v13;
        if (v13)
          return (unsigned int *)WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref((uint64_t)v13);
      }
    }
  }
  return result;
}

uint64_t TI::Favonius::FavoniusStrokeBuildManager::typing_model@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;

  v2 = *(_QWORD *)(this + 8);
  *a2 = v2;
  if (v2)
  {
    v3 = (unsigned int *)(v2 + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 + 1, v3));
  }
  return this;
}

id fieldNameSuffices()
{
  _QWORD v1[4];

  v1[3] = *MEMORY[0x1E0C80C00];
  v1[0] = CFSTR("_input");
  v1[1] = CFSTR("_autocorrection");
  v1[2] = CFSTR("_alternate");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v1, 3);
  return (id)objc_claimAutoreleasedReturnValue();
}

BOOL _isSessionAlignedConfidently(void *a1)
{
  void *v1;
  void *v2;
  _BOOL8 v3;

  objc_msgSend(a1, "alignedEntries");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "lastObject");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  v3 = objc_msgSend(v2, "inSessionAlignmentConfidence") == 3;
  return v3;
}

uint64_t _doesSessionContainValidStrings(void *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  objc_msgSend(a1, "alignedEntries", 0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v2)
  {
    v3 = v2;
    v4 = *(_QWORD *)v12;
LABEL_3:
    v5 = 0;
    while (1)
    {
      if (*(_QWORD *)v12 != v4)
        objc_enumerationMutation(v1);
      v6 = *(void **)(*((_QWORD *)&v11 + 1) + 8 * v5);
      objc_msgSend(v6, "originalWord");
      v7 = objc_claimAutoreleasedReturnValue();
      if (!v7)
        break;
      objc_msgSend(v6, "originalWord");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "acceptedString");
      v9 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v9)
      {
        v7 = 0;
        break;
      }
      if (v3 == ++v5)
      {
        v3 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
        v7 = 1;
        if (v3)
          goto LABEL_3;
        break;
      }
    }
  }
  else
  {
    v7 = 1;
  }

  return v7;
}

id _analyzeNonEditEvents(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  void *v12;
  _QWORD v14[4];
  id v15;
  id v16;
  id v17;
  id v18;
  _QWORD *v19;
  _QWORD v20[5];
  id v21;

  v3 = a1;
  v4 = a2;
  v20[0] = 0;
  v20[1] = v20;
  v20[2] = 0x3032000000;
  v20[3] = __Block_byref_object_copy__19480;
  v20[4] = __Block_byref_object_dispose__19481;
  v21 = 0;
  objc_msgSend(v3, "userActionHistory");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  _allNonEditEventIndexesForSession(v3);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3221225472;
  v14[2] = ___analyzeNonEditEvents_block_invoke;
  v14[3] = &unk_1EA106C80;
  v18 = v7;
  v19 = v20;
  v15 = v5;
  v16 = v3;
  v17 = v4;
  v8 = v7;
  v9 = v4;
  v10 = v3;
  v11 = v5;
  objc_msgSend(v6, "enumerateIndexesUsingBlock:", v14);
  v12 = (void *)objc_msgSend(v8, "copy");

  _Block_object_dispose(v20, 8);
  return v12;
}

id _analyzeEditEvents(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  void *v12;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(uint64_t, uint64_t);
  void *v17;
  id v18;
  id v19;
  id v20;
  id v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD v24[5];
  id v25;
  _QWORD v26[5];
  id v27;

  v3 = a1;
  v4 = a2;
  v26[0] = 0;
  v26[1] = v26;
  v26[2] = 0x3032000000;
  v26[3] = __Block_byref_object_copy__19480;
  v26[4] = __Block_byref_object_dispose__19481;
  v27 = 0;
  v24[0] = 0;
  v24[1] = v24;
  v24[2] = 0x3032000000;
  v24[3] = __Block_byref_object_copy__19480;
  v24[4] = __Block_byref_object_dispose__19481;
  v25 = 0;
  objc_msgSend(v3, "userActionHistory");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  _allUserEditEventIndexesForSession(v3);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v14 = MEMORY[0x1E0C809B0];
  v15 = 3221225472;
  v16 = ___analyzeEditEvents_block_invoke;
  v17 = &unk_1EA106C58;
  v22 = v26;
  v23 = v24;
  v18 = v5;
  v19 = v3;
  v20 = v4;
  v21 = v7;
  v8 = v7;
  v9 = v4;
  v10 = v3;
  v11 = v5;
  objc_msgSend(v6, "enumerateIndexesUsingBlock:", &v14);
  v12 = (void *)objc_msgSend(v8, "copy", v14, v15, v16, v17);

  _Block_object_dispose(v24, 8);
  _Block_object_dispose(v26, 8);

  return v12;
}

id _analyzeDeletedOriginalWordEvents(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _BYTE v21[128];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  objc_msgSend(v3, "originalWords", 0);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v18;
    do
    {
      for (i = 0; i != v8; ++i)
      {
        if (*(_QWORD *)v18 != v9)
          objc_enumerationMutation(v6);
        v11 = *(void **)(*((_QWORD *)&v17 + 1) + 8 * i);
        if (objc_msgSend(v11, "deleted"))
        {
          objc_msgSend(v11, "allEdits");
          v12 = (void *)objc_claimAutoreleasedReturnValue();
          v13 = objc_msgSend(v12, "count");

          if (!v13)
          {
            _revisionMetricPayloadFromOriginalAndRevisedWordEntries(v11, 0);
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            _addGenericMetadataToPayloadFromKeyboardSession(v14, v3);
            objc_claimAutoreleasedReturnValue();

            objc_msgSend(v14, "addEntriesFromDictionary:", v4);
            objc_msgSend(v5, "addObject:", v14);

          }
        }
      }
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
    }
    while (v8);
  }

  v15 = (void *)objc_msgSend(v5, "copy");
  return v15;
}

id _allUserEditEventIndexesForSession(void *a1)
{
  void *v1;
  id v2;
  unint64_t v3;
  void *v4;
  void *v5;
  void *v6;

  objc_msgSend(a1, "userActionHistory");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = objc_alloc_init(MEMORY[0x1E0CB3788]);
  if (objc_msgSend(v1, "count"))
  {
    v3 = 0;
    do
    {
      objc_msgSend(v1, "objectAtIndexedSubscript:", v3);
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        objc_msgSend(v4, "editedEntry");
        v5 = (void *)objc_claimAutoreleasedReturnValue();

        if (v5)
          objc_msgSend(v2, "addIndex:", v3);
      }

      ++v3;
    }
    while (v3 < objc_msgSend(v1, "count"));
  }
  v6 = (void *)objc_msgSend(v2, "copy");

  return v6;
}

id _allNonEditEventIndexesForSession(void *a1)
{
  id v1;
  id v2;
  void *v3;
  id v4;
  unint64_t v5;
  void *v6;
  id v7;
  void *v8;
  void *v9;
  char v10;
  _BOOL4 v11;
  void *v12;

  v1 = a1;
  v2 = objc_alloc_init(MEMORY[0x1E0C99E20]);
  objc_msgSend(v1, "userActionHistory");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_alloc_init(MEMORY[0x1E0CB3788]);
  if (objc_msgSend(v3, "count"))
  {
    v5 = 0;
    do
    {
      objc_msgSend(v3, "objectAtIndexedSubscript:", v5);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v7 = v6;
        objc_msgSend(v7, "editedEntry");
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        if (v8)
        {
          objc_msgSend(v7, "allEdits");
          v9 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v2, "addObjectsFromArray:", v9);

        }
        else if ((objc_msgSend(v2, "containsObject:", v7) & 1) == 0)
        {
          v10 = _wordEntryInputStringContainsOnlyWordSeparatorFromSession(v7, v1);
          v11 = _wordEntryAcceptedStringWasEmpty(v7);
          if ((v10 & 1) == 0
            && (!v11 || objc_msgSend(v7, "cancelled"))
            && objc_msgSend(v7, "origin") != 2)
          {
            objc_msgSend(v4, "addIndex:", v5);
          }
        }

      }
      ++v5;
    }
    while (v5 < objc_msgSend(v3, "count"));
  }
  v12 = (void *)objc_msgSend(v4, "copy");

  return v12;
}

KB::UserDictionaryLoader *std::__shared_ptr_pointer<KB::UserDictionaryLoader *,std::shared_ptr<KB::UserDictionaryLoader>::__shared_ptr_default_delete<KB::UserDictionaryLoader,KB::UserDictionaryLoader>,std::allocator<KB::UserDictionaryLoader>>::__on_zero_shared(uint64_t a1)
{
  KB::UserDictionaryLoader *result;

  result = *(KB::UserDictionaryLoader **)(a1 + 24);
  if (result)
  {
    KB::UserDictionaryLoader::~UserDictionaryLoader(result);
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

uint64_t TI::Favonius::FavoniusStrokeBuildManager::continuous_path_usage_count(TI::Favonius::FavoniusStrokeBuildManager *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 88);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 136))(result);
  return result;
}

uint64_t KB::LanguageModelStr::does_provide_completions(language_modeling::v1::LanguageModelSession **this)
{
  uint64_t result;

  result = (*((uint64_t (**)(language_modeling::v1::LanguageModelSession **))*this + 2))(this);
  if ((_DWORD)result)
    return language_modeling::v1::LanguageModelSession::supportsPrefixCompletions(this[25]);
  return result;
}

uint64_t TI::Favonius::FavoniusStrokeBuildManager::keyboard_did_suspend(TI::Favonius::FavoniusStrokeBuildManager *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 88);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 104))(result);
  return result;
}

void KB::UserDictionaryLoader::~UserDictionaryLoader(KB::UserDictionaryLoader *this)
{
  NSObject *v2;
  void *v3;
  id *v4;
  id WeakRetained;
  void *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint8_t buf[4];
  void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  TIUserDictionaryOSLogFacility();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Destructing UserDictionaryLoader"), "~UserDictionaryLoader");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    v11 = v3;
    _os_log_impl(&dword_1DA6F2000, v2, OS_LOG_TYPE_INFO, "%@", buf, 0xCu);

  }
  v4 = (id *)*((_QWORD *)this + 2);
  if (v4)
  {
    WeakRetained = objc_loadWeakRetained(v4);
    if (WeakRetained)
    {
      +[TIUserDictionaryServer sharedInstance](TIUserDictionaryServer, "sharedInstance");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "removeObserver:", WeakRetained);

    }
  }
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  std::unique_ptr<KB::WeakHolder>::reset[abi:nn180100]((id **)this + 2, 0);
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this);
}

void TIStatisticsReportCPStats(unsigned int a1, int a2, void *a3)
{
  void *v5;
  id v6;
  unsigned int v7;
  BOOL v8;
  char v9;
  uint64_t v10;
  void *v11;
  void *v12;
  id v13;
  _QWORD block[4];
  id v15;

  v13 = a3;
  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99EA0]), "initWithSuiteName:", CFSTR("com.apple.keyboard"));
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __TIStatisticsReportCPStats_block_invoke;
  block[3] = &unk_1EA106A98;
  v6 = v5;
  v15 = v6;
  if (TIStatisticsReportCPStats_onceToken != -1)
    dispatch_once(&TIStatisticsReportCPStats_onceToken, block);
  v7 = TIStatisticsReportCPStats_usageCountDefaults;
  if (a1)
    v7 = a1;
  if (TIStatisticsReportCPStats_didDiscover)
    v8 = 1;
  else
    v8 = v7 > 3;
  v9 = v8;
  TIStatisticsReportCPStats_didDiscover = v9;
  if (a2)
  {
    v10 = *MEMORY[0x1E0DBE950];
    TIStatisticGetKeyForInputMode();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    TIStatisticScalarSetBoolean();

    objc_msgSend(v6, "setBool:forKey:", TIStatisticsReportCPStats_didDiscover, v10);
  }
  TIStatisticGetKeyForInputMode();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  TIStatisticScalarSetBoolean();

}

Class ___ZL22getSRSensorWriterClassv_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!SensorKitLibraryCore(char **)::frameworkLibrary)
  {
    SensorKitLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
    if (!SensorKitLibraryCore(char **)::frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("SRSensorWriter");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getSRSensorWriterClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(unint64_t a1)
{
  if (a1 >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(8 * a1);
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
  abort();
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

Class __getLAContextClass_block_invoke(uint64_t a1)
{
  Class result;

  LocalAuthenticationLibrary();
  result = objc_getClass("LAContext");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getLAContextClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    return (Class)deviceClassString();
  }
  return result;
}

id deviceClassString()
{
  return (id)MGCopyAnswer();
}

Class __getLARatchetManagerClass_block_invoke(uint64_t a1)
{
  Class result;
  uint64_t v3;

  LocalAuthenticationLibrary();
  result = objc_getClass("LARatchetManager");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getLARatchetManagerClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v3 = abort_report_np();
    return (Class)__68__TIAppAutofillManager_shouldAcceptAutofill_withPayload_completion___block_invoke_290(v3);
  }
  return result;
}

void LocalAuthenticationLibrary()
{
  void *v0;

  if (!LocalAuthenticationLibraryCore_frameworkLibrary)
  {
    LocalAuthenticationLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!LocalAuthenticationLibraryCore_frameworkLibrary)
    {
      v0 = (void *)abort_report_np();
      free(v0);
    }
  }
}

Class __getMCProfileConnectionClass_block_invoke(uint64_t a1)
{
  Class result;

  ManagedConfigurationLibrary();
  result = objc_getClass("MCProfileConnection");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getMCProfileConnectionClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    return (Class)ManagedConfigurationLibrary();
  }
  return result;
}

uint64_t ManagedConfigurationLibrary()
{
  uint64_t v0;
  void *v2;

  if (ManagedConfigurationLibraryCore_frameworkLibrary)
    return ManagedConfigurationLibraryCore_frameworkLibrary;
  ManagedConfigurationLibraryCore_frameworkLibrary = _sl_dlopen();
  v0 = ManagedConfigurationLibraryCore_frameworkLibrary;
  if (!ManagedConfigurationLibraryCore_frameworkLibrary)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

uint64_t __Block_byref_object_copy__77(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__78(uint64_t a1)
{

}

Class __getCoreTelephonyClientClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!CoreTelephonyLibraryCore_frameworkLibrary)
  {
    CoreTelephonyLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!CoreTelephonyLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("CoreTelephonyClient");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getCoreTelephonyClientClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void __getSFAutoFillPasskeyClass_block_invoke(uint64_t a1)
{
  SafariFoundationLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("SFAutoFillPasskey");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getSFAutoFillPasskeyClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    SafariFoundationLibrary();
  }
}

void SafariFoundationLibrary()
{
  void *v0;

  if (!SafariFoundationLibraryCore_frameworkLibrary)
  {
    SafariFoundationLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!SafariFoundationLibraryCore_frameworkLibrary)
    {
      v0 = (void *)abort_report_np();
      free(v0);
    }
  }
}

Class __getSFAppAutoFillPasskeyProviderClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;
  SEL v4;

  SafariFoundationLibrary();
  result = objc_getClass("SFAppAutoFillPasskeyProvider");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getSFAppAutoFillPasskeyProviderClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v3 = (void *)abort_report_np();
    return (Class)+[TIAppAutofillManager _simulatesAutofillCandidates](v3, v4);
  }
  return result;
}

void KB::FilterContactWordsConflictingWithValidInput::~FilterContactWordsConflictingWithValidInput(KB::FilterContactWordsConflictingWithValidInput *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterContactWordsConflictingWithValidInput::filter_description(KB::FilterContactWordsConflictingWithValidInput *this)
{
  return "CandidateFilterContactWordsConflictingWithValidInput";
}

_QWORD *KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::FilterContactWordsConflictingWithValidInput *this, unint64_t **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  _QWORD *result;
  unint64_t *v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD v17[3];
  _QWORD *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v7 = *((_QWORD *)a4 + 2);
  if (v7)
  {
    do
      v8 = __ldaxr((unsigned int *)v7);
    while (__stlxr(v8 + 1, (unsigned int *)v7));
  }
  v9 = *(_QWORD *)(v7 + 8);
  result = WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v7);
  v11 = *a2;
  v12 = a2[1];
  if (*a2 != v12)
  {
    v13 = v9 + 144;
    while (1)
    {
      if ((*(_BYTE *)(v11[1] + 240 * *v11 - 134) & 0x80) == 0)
      {
        result = (_QWORD *)KB::CandidateFilter::candidate_matches_input((uint64_t)v11, (uint64_t)a3, v13);
        if ((_DWORD)result)
        {
          result = (_QWORD *)KB::FilterContactWordsConflictingWithValidInput::candidate_contains_non_input_contact_word(v11, (unint64_t *)a3, v13);
          if (!(_DWORD)result)
            break;
        }
      }
      v11 += 125;
      if (v11 == v12)
      {
        v11 = v12;
        break;
      }
    }
    if (v11 != a2[1])
    {
      v14 = *((_QWORD *)a4 + 7);
      v15 = operator new(0x20uLL);
      *v15 = &unk_1EA0FA178;
      v15[1] = a3;
      v15[2] = v13;
      v15[3] = a2;
      v18 = v15;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v14, (uint64_t)"CandidateFilterContactWordsConflictingWithValidInput", v17);
      result = v18;
      if (v18 == v17)
      {
        v16 = 4;
        result = v17;
      }
      else
      {
        if (!v18)
          return result;
        v16 = 5;
      }
      return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v16))();
    }
  }
  return result;
}

uint64_t KB::FilterContactWordsConflictingWithValidInput::candidate_contains_non_input_contact_word(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v4;
  BOOL v5;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  _QWORD *i;
  int v15;
  _BOOL4 v17;
  BOOL v18;

  v4 = *a1;
  if (*a1)
    v5 = *a2 == 0;
  else
    v5 = 1;
  if (v5)
  {
    v8 = 0;
  }
  else
  {
    v8 = 0;
    v9 = 1;
    do
    {
      v10 = *(_QWORD *)(a3 + 24);
      if (!v10)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        JUMPOUT(0x1DA7321A4);
      }
      v11 = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t))(*(_QWORD *)v10 + 48))(v10, a1[1] + 240 * v8, a2[1] + 240 * v8);
      v4 = *a1;
      if (!v11)
        break;
      v8 = v9;
      v12 = v4 > v9++;
      v12 = v12 && *a2 > v8;
    }
    while (v12);
  }
  if (v4 == v8)
    return 0;
  v13 = -240 * v8 + 240 * v4;
  for (i = (_QWORD *)(240 * v8 + a1[1] + 224); ; i += 30)
  {
    v15 = *((_DWORD *)i - 30);
    v17 = (v15 & 0x80020100) != 0 || *i != 0;
    v18 = (*(_DWORD *)(i - 15) & 0x2000) == 0;
    if ((v15 & 0x80) == 0)
      v18 = 0;
    if ((v15 & 0x40000) == 0)
      v18 = 1;
    if (v17 && (~v15 & 0x2002000) != 0 && v18)
      break;
    v13 -= 240;
    if (!v13)
      return 0;
  }
  return 1;
}

void std::__function::__func<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &unk_1EA0FA178;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &unk_1EA0FA178;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, unint64_t *a2, KB::String **a3)
{
  KB::String *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  const char *v9;
  const char *v10;
  uint64_t *v11;
  KB::Candidate *v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  unint64_t v23;
  void *v24;
  _QWORD v25[4];

  v25[3] = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  v6 = KB::FilterContactWordsConflictingWithValidInput::candidate_contains_non_input_contact_word(a2, *(unint64_t **)(a1 + 8), *(_QWORD *)(a1 + 16));
  v7 = v6;
  if (v5)
    v8 = (_DWORD)v6 == 0;
  else
    v8 = 1;
  if (!v8)
  {
    KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)&v23);
    v9 = (const char *)v24;
    if (!v24)
      v9 = (const char *)v25;
    if ((_WORD)v23)
      v10 = v9;
    else
      v10 = "";
    KB::String::append_format(v5, "Candidate '%s' contains a contact word suggestion in a collection with a non contact suggestion", v10);
    if (v24 && BYTE6(v23) == 1)
      free(v24);
  }
  if ((_DWORD)v7)
  {
    v11 = *(uint64_t **)(a1 + 24);
    v12 = (KB::Candidate *)v11[4];
    v13 = v11[5];
    if ((unint64_t)v12 >= v13)
    {
      v15 = v11[3];
      v16 = 0x1CAC083126E978D5 * (((uint64_t)v12 - v15) >> 3);
      if ((unint64_t)(v16 + 1) > 0x4189374BC6A7EFLL)
        abort();
      v17 = 0x1CAC083126E978D5 * ((uint64_t)(v13 - v15) >> 3);
      v18 = 2 * v17;
      if (2 * v17 <= v16 + 1)
        v18 = v16 + 1;
      if (v17 >= 0x20C49BA5E353F7)
        v19 = 0x4189374BC6A7EFLL;
      else
        v19 = v18;
      v25[2] = v11 + 5;
      if (v19)
        v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v19);
      else
        v20 = 0;
      v21 = (char *)(v19 + 1000 * v16);
      v23 = v19;
      v24 = v21;
      v25[1] = v19 + 1000 * v20;
      KB::Candidate::Candidate((KB::Candidate *)v21, (const KB::Candidate *)a2);
      v25[0] = v21 + 1000;
      std::vector<KB::Candidate>::__swap_out_circular_buffer(v11 + 3, &v23);
      v14 = (char *)v11[4];
      std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v23);
    }
    else
    {
      v14 = (char *)KB::Candidate::Candidate(v12, (const KB::Candidate *)a2) + 1000;
    }
    v11[4] = (uint64_t)v14;
  }
  return v7;
}

uint64_t std::vector<KB::Candidate>::push_back[abi:nn180100](uint64_t *a1, const KB::Candidate *a2)
{
  uint64_t *v4;
  unint64_t v5;
  KB::Candidate *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  KB::Candidate *v15;
  char *v16;
  unint64_t v17;
  uint64_t *v18;

  v4 = a1 + 2;
  v5 = a1[2];
  v6 = (KB::Candidate *)a1[1];
  if ((unint64_t)v6 >= v5)
  {
    v9 = 0x1CAC083126E978D5 * (((uint64_t)v6 - *a1) >> 3);
    if ((unint64_t)(v9 + 1) > 0x4189374BC6A7EFLL)
      abort();
    v10 = 0x1CAC083126E978D5 * ((uint64_t)(v5 - *a1) >> 3);
    v11 = 2 * v10;
    if (2 * v10 <= v9 + 1)
      v11 = v9 + 1;
    if (v10 >= 0x20C49BA5E353F7)
      v12 = 0x4189374BC6A7EFLL;
    else
      v12 = v11;
    v18 = v4;
    if (v12)
      v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v12);
    else
      v13 = 0;
    v14 = v12;
    v15 = (KB::Candidate *)(v12 + 1000 * v9);
    v17 = v12 + 1000 * v13;
    KB::Candidate::Candidate(v15, a2);
    v16 = (char *)v15 + 1000;
    std::vector<KB::Candidate>::__swap_out_circular_buffer(a1, &v14);
    v8 = a1[1];
    result = std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v14);
  }
  else
  {
    result = (uint64_t)KB::Candidate::Candidate(v6, a2);
    v8 = result + 1000;
  }
  a1[1] = v8;
  return result;
}

KB::Candidate *KB::Candidate::Candidate(KB::Candidate *this, const KB::Candidate *a2)
{
  _QWORD *v4;
  __int128 v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;
  unint64_t v9;
  void *v10;
  const void *v11;
  const void *v12;

  v4 = WTF::Vector<KB::Word,3ul>::Vector(this, a2);
  v5 = *(_OWORD *)((char *)a2 + 744);
  v6 = *(_OWORD *)((char *)a2 + 760);
  v4[97] = *((_QWORD *)a2 + 97);
  *(_OWORD *)(v4 + 93) = v5;
  *(_OWORD *)(v4 + 95) = v6;
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)(v4 + 98), (const KB::Candidate *)((char *)a2 + 784));
  KB::String::String((KB::Candidate *)((char *)this + 888), (const KB::Candidate *)((char *)a2 + 888));
  v7 = (std::string *)((char *)this + 920);
  if (*((char *)a2 + 943) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *((const std::string::value_type **)a2 + 115), *((_QWORD *)a2 + 116));
  }
  else
  {
    v8 = *(_OWORD *)((char *)a2 + 920);
    *((_QWORD *)this + 117) = *((_QWORD *)a2 + 117);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  v9 = *((unsigned __int16 *)a2 + 472);
  if (v9 < 0xF)
  {
    *((_OWORD *)this + 59) = *((_OWORD *)a2 + 59);
  }
  else
  {
    *((_WORD *)this + 472) = v9;
    v10 = (void *)operator new[]();
    *((_QWORD *)this + 119) = v10;
    memcpy(v10, *((const void **)a2 + 119), *((unsigned __int16 *)this + 472));
  }
  *((_OWORD *)this + 60) = *((_OWORD *)a2 + 60);
  v11 = (const void *)*((_QWORD *)a2 + 122);
  *((_QWORD *)this + 122) = v11;
  if (v11)
  {
    CFRetain(v11);
    *((_QWORD *)this + 122) = v11;
  }
  v12 = (const void *)*((_QWORD *)a2 + 123);
  *((_QWORD *)this + 123) = v12;
  if (v12)
  {
    CFRetain(v12);
    *((_QWORD *)this + 123) = v12;
  }
  *((_DWORD *)this + 248) = *((_DWORD *)a2 + 248);
  return this;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(unint64_t a1)
{
  if (a1 >= 0x4189374BC6A7F0)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(1000 * a1);
}

uint64_t std::vector<KB::Candidate>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 1000;
    result = KB::Candidate::Candidate(result - 1000, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<KB::Candidate>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 1000;
    KB::Candidate::~Candidate((KB::Candidate *)(i - 1000));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t KB::Candidate::Candidate(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  unsigned int v7;
  __int128 v8;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = a1 + 24;
  *(_QWORD *)(a1 + 16) = 3;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  WTF::VectorBuffer<KB::Word,3ul>::swap((_QWORD *)(a1 + 8), (_QWORD *)(a2 + 8));
  v4 = *(_OWORD *)(a2 + 744);
  v5 = *(_OWORD *)(a2 + 760);
  *(_QWORD *)(a1 + 776) = *(_QWORD *)(a2 + 776);
  *(_OWORD *)(a1 + 744) = v4;
  *(_OWORD *)(a1 + 760) = v5;
  KB::LanguageModelContext::LanguageModelContext(a1 + 784, a2 + 784);
  *(_DWORD *)(a1 + 888) = 0x100000;
  *(_WORD *)(a1 + 892) = 0;
  *(_BYTE *)(a1 + 894) = 0;
  *(_QWORD *)(a1 + 896) = 0;
  KB::String::operator=(a1 + 888, (KB::String *)(a2 + 888));
  v6 = *(_OWORD *)(a2 + 920);
  *(_QWORD *)(a1 + 936) = *(_QWORD *)(a2 + 936);
  *(_OWORD *)(a1 + 920) = v6;
  *(_OWORD *)(a2 + 920) = 0u;
  *(_QWORD *)(a2 + 936) = 0;
  v7 = *(unsigned __int16 *)(a2 + 944);
  *(_OWORD *)(a1 + 944) = *(_OWORD *)(a2 + 944);
  if (v7 >= 0xF)
    *(_WORD *)(a2 + 944) = 0;
  *(_OWORD *)(a1 + 960) = *(_OWORD *)(a2 + 960);
  v8 = *(_OWORD *)(a2 + 976);
  *(_OWORD *)(a2 + 976) = 0uLL;
  *(_OWORD *)(a1 + 976) = v8;
  *(_DWORD *)(a1 + 992) = *(_DWORD *)(a2 + 992);
  return a1;
}

_QWORD *WTF::VectorBuffer<KB::Word,3ul>::swap(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  char v9;
  uint64_t i;
  char v11;
  uint64_t v12;

  v3 = result + 2;
  v2 = (_QWORD *)*result;
  v5 = a2 + 2;
  v4 = (_QWORD *)*a2;
  if ((_QWORD *)*result == result + 2)
  {
    if (v4 == v5)
    {
      for (i = 0; i != 720; ++i)
      {
        v11 = *((_BYTE *)v2 + i);
        *((_BYTE *)v2 + i) = *((_BYTE *)v4 + i);
        *((_BYTE *)v4 + i) = v11;
      }
    }
    else
    {
      v6 = 0;
      *result = v4;
      *a2 = v5;
      do
      {
        v7 = *((_BYTE *)v2 + v6);
        *((_BYTE *)v2 + v6) = *((_BYTE *)v5 + v6);
        *((_BYTE *)v5 + v6++) = v7;
      }
      while (v6 != 720);
    }
  }
  else if (v4 == v5)
  {
    v8 = 0;
    *a2 = v2;
    *result = v3;
    do
    {
      v9 = *((_BYTE *)v3 + v8);
      *((_BYTE *)v3 + v8) = *((_BYTE *)v4 + v8);
      *((_BYTE *)v4 + v8++) = v9;
    }
    while (v8 != 720);
  }
  else
  {
    *result = v4;
    *a2 = v2;
  }
  v12 = result[1];
  result[1] = a2[1];
  a2[1] = v12;
  return result;
}

uint64_t KB::LanguageModelContext::LanguageModelContext(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  v4 = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v4;
  language_modeling::v1::LinguisticContext::LinguisticContext();
  language_modeling::v1::LinguisticContext::LinguisticContext();
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  return a1;
}

_QWORD *WTF::Vector<KB::Word,3ul>::Vector(_QWORD *a1, _QWORD *a2)
{
  unint64_t v4;
  KB::Word *v5;
  uint64_t v6;
  const KB::Word *v7;
  uint64_t v8;

  v4 = a2[2];
  v5 = (KB::Word *)(a1 + 3);
  *a1 = *a2;
  a1[1] = v5;
  a1[2] = 3;
  if (v4 < 4 || (a1[2] = v4, v5 = (KB::Word *)malloc_type_malloc(240 * v4, 0x10B2040DF775671uLL), (a1[1] = v5) != 0))
  {
    v6 = *a2;
    if (*a2)
    {
      v7 = (const KB::Word *)a2[1];
      v8 = 240 * v6;
      do
      {
        v5 = (KB::Word *)((char *)KB::Word::Word(v5, v7) + 240);
        v7 = (const KB::Word *)((char *)v7 + 240);
        v8 -= 240;
      }
      while (v8);
    }
  }
  return a1;
}

std::string *std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(std::string *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  std::string *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::string>::__vallocate[abi:nn180100](result, a4);
    result = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

char *std::vector<std::string>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

std::string *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(__int128 *a1, __int128 *a2, std::string *this)
{
  __int128 *v5;
  __int128 v6;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if (*((char *)v5 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)v5, *((_QWORD *)v5 + 1));
      }
      else
      {
        v6 = *v5;
        this->__r_.__value_.__r.__words[2] = *((_QWORD *)v5 + 2);
        *(_OWORD *)&this->__r_.__value_.__l.__data_ = v6;
      }
      v5 = (__int128 *)((char *)v5 + 24);
      ++this;
    }
    while (v5 != a2);
  }
  return this;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(24 * a1);
}

char *std::vector<TITokenID>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

KB::Word *KB::Word::Word(KB::Word *this, const KB::Word *a2)
{
  unint64_t v2;
  unint64_t v5;
  void *v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  char v11;
  uint64_t *v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  _QWORD *v18;
  _QWORD *i;
  unint64_t v20;
  _QWORD *v21;
  float v22;
  float v23;
  _BOOL8 v24;
  unint64_t v25;
  unint64_t v26;
  size_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;

  KB::String::String(this, a2);
  v5 = *((unsigned __int16 *)a2 + 16);
  if (v5 < 0xF)
  {
    *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  }
  else
  {
    *((_WORD *)this + 16) = v5;
    v6 = (void *)operator new[]();
    *((_QWORD *)this + 5) = v6;
    memcpy(v6, *((const void **)a2 + 5), *((unsigned __int16 *)this + 16));
  }
  v7 = *((_QWORD *)a2 + 6);
  *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
  *((_QWORD *)this + 6) = v7;
  KB::String::String((KB::Word *)((char *)this + 64), (const KB::Word *)((char *)a2 + 64));
  v8 = *((_OWORD *)a2 + 6);
  v9 = *((_OWORD *)a2 + 7);
  v10 = *((_OWORD *)a2 + 9);
  *((_OWORD *)this + 8) = *((_OWORD *)a2 + 8);
  *((_OWORD *)this + 9) = v10;
  *((_OWORD *)this + 6) = v8;
  *((_OWORD *)this + 7) = v9;
  KB::String::String((KB::Word *)((char *)this + 160), (const KB::Word *)((char *)a2 + 160));
  v11 = *((_BYTE *)a2 + 192);
  *(_OWORD *)((char *)this + 200) = 0u;
  v12 = (uint64_t *)((char *)this + 200);
  *((_BYTE *)this + 192) = v11;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_DWORD *)this + 58) = *((_DWORD *)a2 + 58);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)this + 200, *((_QWORD *)a2 + 26));
  v13 = (_QWORD *)*((_QWORD *)a2 + 27);
  if (v13)
  {
    v14 = (_QWORD *)((char *)this + 216);
    v15 = *((_QWORD *)this + 26);
    do
    {
      v16 = v13[2];
      if (v15)
      {
        v17 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
        v17.i16[0] = vaddlv_u8(v17);
        if (v17.u32[0] > 1uLL)
        {
          v2 = v13[2];
          if (v16 >= v15)
            v2 = v16 % v15;
        }
        else
        {
          v2 = (v15 - 1) & v16;
        }
        v18 = *(_QWORD **)(*v12 + 8 * v2);
        if (v18)
        {
          for (i = (_QWORD *)*v18; i; i = (_QWORD *)*i)
          {
            v20 = i[1];
            if (v20 == v16)
            {
              if (i[2] == v16)
                goto LABEL_44;
            }
            else
            {
              if (v17.u32[0] > 1uLL)
              {
                if (v20 >= v15)
                  v20 %= v15;
              }
              else
              {
                v20 &= v15 - 1;
              }
              if (v20 != v2)
                break;
            }
          }
        }
      }
      v21 = operator new(0x18uLL);
      *v21 = 0;
      v21[1] = v16;
      v21[2] = v13[2];
      v22 = (float)(unint64_t)(*((_QWORD *)this + 28) + 1);
      v23 = *((float *)this + 58);
      if (!v15 || (float)(v23 * (float)v15) < v22)
      {
        v24 = (v15 & (v15 - 1)) != 0;
        if (v15 < 3)
          v24 = 1;
        v25 = v24 | (2 * v15);
        v26 = vcvtps_u32_f32(v22 / v23);
        if (v25 <= v26)
          v27 = v26;
        else
          v27 = v25;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)this + 200, v27);
        v15 = *((_QWORD *)this + 26);
        if ((v15 & (v15 - 1)) != 0)
        {
          if (v16 >= v15)
            v2 = v16 % v15;
          else
            v2 = v16;
        }
        else
        {
          v2 = (v15 - 1) & v16;
        }
      }
      v28 = *v12;
      v29 = *(_QWORD **)(*v12 + 8 * v2);
      if (v29)
      {
        *v21 = *v29;
      }
      else
      {
        *v21 = *v14;
        *v14 = v21;
        *(_QWORD *)(v28 + 8 * v2) = v14;
        if (!*v21)
          goto LABEL_43;
        v30 = *(_QWORD *)(*v21 + 8);
        if ((v15 & (v15 - 1)) != 0)
        {
          if (v30 >= v15)
            v30 %= v15;
        }
        else
        {
          v30 &= v15 - 1;
        }
        v29 = (_QWORD *)(*v12 + 8 * v30);
      }
      *v29 = v21;
LABEL_43:
      ++*((_QWORD *)this + 28);
LABEL_44:
      v13 = (_QWORD *)*v13;
    }
    while (v13);
  }
  return this;
}

void std::__throw_bad_function_call[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_function_call was thrown in -fno-exceptions mode");
  JUMPOUT(0x1DA732E90);
}

void KB::FilterWordsConflictingWithValidContactNames::~FilterWordsConflictingWithValidContactNames(KB::FilterWordsConflictingWithValidContactNames *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterWordsConflictingWithValidContactNames::filter_description(KB::FilterWordsConflictingWithValidContactNames *this)
{
  return "FilterWordsConflictingWithValidContactNames";
}

void KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::FilterWordsConflictingWithValidContactNames *this, float **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  float *v11;
  float *v12;
  float *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL4 is_linguistically_void;
  _BOOL4 v26;
  __int16 v27;
  __int16 v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  __int16 v36;
  __int16 v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *p_shared_owners;
  unint64_t v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  char v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  uint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  KB::Candidate *v55;
  char *v56;
  uint64_t v57;
  char *v58;
  char *v59;
  void **v60;
  void **v61;
  int64_t v62;
  void **v63;
  char *v64;
  unint64_t *v65;
  unint64_t v66;
  float *v67;
  uint64_t v68;
  unint64_t v69;
  float v70;
  char *v71;
  int v72;
  float v73;
  float v74;
  uint64_t v75;
  _QWORD *v76;
  uint64_t v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  char *v81;
  KB::CandidateCollection *v82;
  float *v83;
  unsigned __int16 *v84;
  const KB::CandidateFilterResources *v86;
  void **v87[3];
  _QWORD v88[3];
  _QWORD v89[3];
  char v90[8];
  std::__shared_weak_count *v91;
  void *__p;
  void *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD v97[3];
  void ***v98;
  _QWORD v99[3];
  _QWORD *v100;
  void **v101;
  void *v102;
  char v103;
  uint64_t v104;

  v104 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)a3 + 2000))
    v7 = (unsigned __int16 *)((char *)a3 + 1000);
  else
    v7 = (unsigned __int16 *)a3;
  if (!v7[444])
    KB::Candidate::compute_string((KB::Candidate *)v7);
  WORD2(v101) = 0;
  BYTE6(v101) = 0;
  v102 = " \t\n";
  LODWORD(v101) = 1048579;
  v103 = 0;
  KB::sbs_string_tokenize(v7 + 444, (const KB::String *)&v101, v97);
  if (v102 && BYTE6(v101) == 1)
    free(v102);
  v84 = v7;
  v8 = *((_QWORD *)a4 + 2);
  if (v8)
  {
    do
      v9 = __ldaxr((unsigned int *)v8);
    while (__stlxr(v9 + 1, (unsigned int *)v8));
  }
  v10 = *(_QWORD *)(v8 + 8);
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v8);
  v12 = *a2;
  v11 = a2[1];
  v86 = a4;
  if (*a2 != v11)
  {
    while (1)
    {
      v13 = v12;
      if (*(_QWORD *)v12)
        break;
LABEL_22:
      v12 = v13 + 250;
      if (v13 + 250 == v11)
      {
        v12 = v11;
        goto LABEL_25;
      }
    }
    v14 = *((_QWORD *)v12 + 1);
    v15 = v14 + 240 * *(_QWORD *)v12;
    while ((*(_BYTE *)(v14 + 106) & 2) == 0)
    {
LABEL_15:
      v14 += 240;
      if (v14 == v15)
        goto LABEL_22;
    }
    v17 = v97[0];
    v16 = v97[1];
    while (1)
    {
      if (v17 == v16)
        goto LABEL_15;
      v18 = *(_QWORD *)(v10 + 168);
      if (!v18)
        break;
      if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v18 + 48))(v18, v17, v14))
      {
        v12 = v13;
        goto LABEL_25;
      }
      v17 += 32;
    }
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_123:
    abort();
  }
LABEL_25:
  if (v12 != a2[1] && v12 != *a2)
  {
    v81 = (char *)a3 + 2032;
    v82 = (KB::CandidateCollection *)a2;
    KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v90, (const KB::CandidateFilterLookupContext *)((char *)a3 + 2032));
    v83 = v12;
    if (*(_QWORD *)v12)
    {
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = *((_QWORD *)v12 + 1);
      v24 = v23 + 240 * *(_QWORD *)v12;
      do
      {
        if ((*(_BYTE *)(v23 + 106) & 2) != 0)
          *(_DWORD *)(v23 + 136) = 0;
        is_linguistically_void = KB::Word::is_linguistically_void((KB::Word *)v23);
        v26 = is_linguistically_void;
        v27 = !is_linguistically_void;
        if ((unint64_t)v21 >= v20)
        {
          v30 = v21 - v22;
          if (v21 - v22 <= -3)
            goto LABEL_123;
          v31 = v30 >> 1;
          if (v20 - (unint64_t)v22 <= (v30 >> 1) + 1)
            v32 = v31 + 1;
          else
            v32 = v20 - (_QWORD)v22;
          if (v20 - (unint64_t)v22 >= 0x7FFFFFFFFFFFFFFELL)
            v33 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v33 = v32;
          if (v33)
            v33 = (uint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(v33);
          else
            v34 = 0;
          v35 = (char *)(v33 + 2 * v31);
          if (v26)
            v36 = 256;
          else
            v36 = 0;
          *(_WORD *)v35 = v36 | v27;
          v29 = v35 + 2;
          if (v21 != v22)
          {
            do
            {
              v37 = *((_WORD *)v21 - 1);
              v21 -= 2;
              *((_WORD *)v35 - 1) = v37;
              v35 -= 2;
            }
            while (v21 != v22);
            v21 = v22;
          }
          v22 = v35;
          v20 = v33 + 2 * v34;
          if (v21)
            operator delete(v21);
        }
        else
        {
          if (is_linguistically_void)
            v28 = 256;
          else
            v28 = 0;
          *(_WORD *)v21 = v28 | v27;
          v29 = v21 + 2;
        }
        v23 += 240;
        v21 = v29;
      }
      while (v23 != v24);
    }
    else
    {
      v29 = 0;
      v22 = 0;
    }
    v38 = *((_QWORD *)v86 + 3);
    v39 = (std::__shared_weak_count *)*((_QWORD *)v86 + 4);
    if (v39)
    {
      p_shared_owners = (unint64_t *)&v39->__shared_owners_;
      do
        v41 = __ldxr(p_shared_owners);
      while (__stxr(v41 + 1, p_shared_owners));
    }
    if (v38)
    {
      v42 = *((_QWORD *)v86 + 3);
      v43 = (std::__shared_weak_count *)*((_QWORD *)v86 + 4);
      if (v43)
      {
        v44 = (unint64_t *)&v43->__shared_owners_;
        do
          v45 = __ldxr(v44);
        while (__stxr(v45 + 1, v44));
      }
      v46 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v42 + 16))(v42) ^ 1;
      if (v43)
      {
        v47 = (unint64_t *)&v43->__shared_owners_;
        do
          v48 = __ldaxr(v47);
        while (__stlxr(v48 - 1, v47));
        if (!v48)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
      }
    }
    else
    {
      v46 = 1;
    }
    if (!v39)
      goto LABEL_76;
    v49 = (unint64_t *)&v39->__shared_owners_;
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
      if ((v46 & 1) != 0)
        goto LABEL_112;
    }
    else
    {
LABEL_76:
      if ((v46 & 1) != 0)
      {
LABEL_112:
        if (v22)
          operator delete(v22);
        v101 = (void **)&v96;
        std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v101);
        language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v95);
        language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v94);
        if (__p)
        {
          v93 = __p;
          operator delete(__p);
        }
        v78 = v91;
        if (v91)
        {
          v79 = (unint64_t *)&v91->__shared_owners_;
          do
            v80 = __ldaxr(v79);
          while (__stlxr(v80 - 1, v79));
          if (!v80)
          {
            ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
            std::__shared_weak_count::__release_weak(v78);
          }
        }
        goto LABEL_121;
      }
    }
    v52 = *((_QWORD *)v86 + 3);
    v51 = (std::__shared_weak_count *)*((_QWORD *)v86 + 4);
    if (v51)
    {
      v53 = (unint64_t *)&v51->__shared_owners_;
      do
        v54 = __ldxr(v53);
      while (__stxr(v54 + 1, v53));
    }
    KB::Candidate::Candidate((KB::Candidate *)&v101, (const KB::Candidate *)v83);
    v55 = (KB::Candidate *)operator new(0x3E8uLL);
    v56 = (char *)v55 + 1000;
    v88[0] = v55;
    v88[2] = (char *)v55 + 1000;
    KB::Candidate::Candidate(v55, (const KB::Candidate *)&v101);
    v88[1] = v56;
    v57 = v29 - v22;
    if (v29 == v22)
    {
      v58 = 0;
      v59 = 0;
    }
    else
    {
      if (v29 - v22 < 0)
        goto LABEL_123;
      v58 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(v57 >> 1);
      memmove(v58, v22, v29 - v22);
      v59 = &v58[v57];
    }
    v60 = (void **)operator new(0x18uLL);
    v61 = v60 + 3;
    v87[0] = v60;
    v87[2] = v60 + 3;
    v60[1] = 0;
    v60[2] = 0;
    *v60 = 0;
    v62 = v59 - v58;
    if (v59 != v58)
    {
      v63 = v60;
      std::vector<language_modeling::v1::TokenMetadata>::__vallocate[abi:nn180100](v60, v62 >> 1);
      v64 = (char *)v63[1];
      memmove(v64, v58, v62);
      v63[1] = &v64[v62];
    }
    v87[1] = v61;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, _QWORD *, void ***, char *, _QWORD, uint64_t))(*(_QWORD *)v52 + 408))(v89, v52, v88, v87, v81, *((_QWORD *)v86 + 7), 1);
    v98 = v87;
    std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v98);
    if (v58)
      operator delete(v58);
    v87[0] = (void **)v88;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v87);
    KB::Candidate::~Candidate((KB::Candidate *)&v101);
    if (v51)
    {
      v65 = (unint64_t *)&v51->__shared_owners_;
      do
        v66 = __ldaxr(v65);
      while (__stlxr(v66 - 1, v65));
      if (!v66)
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }
    }
    if (v89[1] != v89[0])
    {
      v67 = *(float **)v89[0];
      v68 = *(_QWORD *)(v89[0] + 8) - *(_QWORD *)v89[0];
      if (v68)
      {
        v69 = v68 / 40;
        if (v69 <= 1)
          v69 = 1;
        v70 = 1.0;
        v71 = v22;
        do
        {
          v72 = *v71;
          v71 += 2;
          if (v72)
            v70 = v70 * *v67;
          v67 += 10;
          --v69;
        }
        while (v69);
      }
      else
      {
        v70 = 1.0;
      }
      v73 = v83[187];
      v74 = v83[189];
      if ((float)(v73 + (float)(*((float *)this + 2) * (float)(logf(v70) + v74))) >= (float)(*(float *)(*(_QWORD *)v82 + 748)
                                                                                            + (float)(*((float *)this + 2) * (float)(*(float *)(*(_QWORD *)v82 + 752) + *(float *)(*(_QWORD *)v82 + 756)))))
      {
        v75 = *((_QWORD *)v86 + 7);
        v99[0] = &off_1EA0FA1C0;
        v99[1] = v84;
        v99[2] = v10 + 144;
        v100 = v99;
        KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)v82, v75, (uint64_t)"FilterWordsConflictingWithValidContactNames", v99);
        v76 = v100;
        if (v100 == v99)
        {
          v77 = 4;
          v76 = v99;
          goto LABEL_110;
        }
        if (v100)
        {
          v77 = 5;
LABEL_110:
          (*(void (**)(void))(*v76 + 8 * v77))();
        }
      }
    }
    v101 = (void **)v89;
    std::vector<std::vector<KB::LikelihoodInfo>>::__destroy_vector::operator()[abi:nn180100](&v101);
    goto LABEL_112;
  }
LABEL_121:
  v101 = (void **)v97;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v101);
}

BOOL KB::Word::is_linguistically_void(KB::Word *this)
{
  const char *v1;

  if ((*((_BYTE *)this + 135) & 4) != 0)
    return 1;
  v1 = *((_QWORD *)this + 1) ? (const char *)*((_QWORD *)this + 1) : (char *)this + 16;
  return !strcmp(v1, " ") || *v1 == 0;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(uint64_t a1)
{
  if (a1 < 0)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(2 * a1);
}

char *std::vector<language_modeling::v1::TokenMetadata>::__vallocate[abi:nn180100](_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 < 0)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void *v7;
  void *v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = (char *)v1[1];
      do
      {
        v8 = (void *)*((_QWORD *)v6 - 3);
        v6 -= 24;
        v7 = v8;
        if (v8)
        {
          *((_QWORD *)v4 - 2) = v7;
          operator delete(v7);
        }
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        KB::Candidate::~Candidate((KB::Candidate *)(v4 - 1000));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::vector<KB::LikelihoodInfo>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        v6 = v4;
        std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 3);
        if (v6)
        {
          if (*(v4 - 26) == 1)
            free(v6);
        }
        v4 -= 32;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::string>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

void std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 1) < 0)
          operator delete(*(v4 - 3));
        v4 -= 5;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__function::__func<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA0FA1C0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FA1C0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t a2, KB::String **a3)
{
  uint64_t v5;
  int *v6;
  int v7;
  _BOOL4 v8;
  uint64_t v9;
  KB::String *v10;
  uint64_t v11;
  KB::Candidate *v12;
  uint64_t v13;
  _BOOL8 v14;
  const char *v15;
  const char *v16;
  __int16 v18[3];
  char v19;
  void *v20;
  _QWORD v21[3];

  v21[2] = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)a2)
  {
    v5 = 240 * *(_QWORD *)a2 - 240;
    v6 = (int *)(*(_QWORD *)(a2 + 8) + 104);
    do
    {
      v7 = *v6;
      v6 += 60;
      v8 = (v7 & 0x20000) == 0;
      if ((v7 & 0x20000) != 0)
        break;
      v9 = v5;
      v5 -= 240;
    }
    while (v9);
  }
  else
  {
    v8 = 1;
  }
  v10 = *a3;
  v11 = *(_QWORD *)(a1 + 16);
  if (!*(_WORD *)(a2 + 888))
    KB::Candidate::compute_string((KB::Candidate *)a2);
  v12 = *(KB::Candidate **)(a1 + 8);
  if (!*((_WORD *)v12 + 444))
    KB::Candidate::compute_string(v12);
  v13 = *(_QWORD *)(v11 + 24);
  if (!v13)
    std::__throw_bad_function_call[abi:nn180100]();
  if ((*(unsigned int (**)(uint64_t, uint64_t, _WORD *))(*(_QWORD *)v13 + 48))(v13, a2 + 888, (_WORD *)v12 + 444))
  {
    v14 = 0;
  }
  else
  {
    v14 = v8;
  }
  if (v10 && v14)
  {
    KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)v18);
    v15 = (const char *)v20;
    if (!v20)
      v15 = (const char *)v21;
    if (v18[0])
      v16 = v15;
    else
      v16 = "";
    KB::String::append_format(v10, "Candidate list contains a valid contact name matching input, and '%s' is not a valid contact name nor sortkey equivalent to what the user typed", v16);
    if (v20 && v19 == 1)
      free(v20);
  }
  return v14;
}

void KB::LikelihoodInfo::~LikelihoodInfo(void **this)
{
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
}

Class __getUITextCheckerClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!UIKitLibraryCore_frameworkLibrary)
  {
    UIKitLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!UIKitLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("UITextChecker");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getUITextCheckerClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

id get_KSUserWordsSynchroniserClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)get_KSUserWordsSynchroniserClass_softClass;
  v7 = get_KSUserWordsSynchroniserClass_softClass;
  if (!get_KSUserWordsSynchroniserClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __get_KSUserWordsSynchroniserClass_block_invoke;
    v3[3] = &unk_1EA107058;
    v3[4] = &v4;
    __get_KSUserWordsSynchroniserClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t KeyboardServicesLibrary()
{
  uint64_t v0;
  void *v2;

  if (KeyboardServicesLibraryCore_frameworkLibrary)
    return KeyboardServicesLibraryCore_frameworkLibrary;
  KeyboardServicesLibraryCore_frameworkLibrary = _sl_dlopen();
  v0 = KeyboardServicesLibraryCore_frameworkLibrary;
  if (!KeyboardServicesLibraryCore_frameworkLibrary)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

void KB::createLanguageModelParameters(id *a1@<X0>, uint64_t *a2@<X8>)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  id v10;

  v3 = *a1;
  if (v3)
  {
    v10 = v3;
    objc_msgSend(v3, "objectForKeyedSubscript:", *MEMORY[0x1E0D43508]);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = v4;
    if (v4 && objc_msgSend(v4, "count"))
    {
      objc_msgSend(v5, "objectAtIndexedSubscript:", 0);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      v7 = v6;
      if (v6)
      {
        objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("URL"));
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = (void *)v8;
        if (v8)
        {
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithContentsOfURL:", v8);
          v8 = objc_claimAutoreleasedReturnValue();
        }
        *a2 = v8;

      }
      else
      {
        *a2 = 0;
      }

    }
    else
    {
      *a2 = 0;
    }

    v3 = v10;
  }
  else
  {
    *a2 = 0;
  }

}

void TIInlineCompletion::TIInlineCompletion(std::string *this, __int128 *a2, int a3, double a4)
{
  __int128 v7;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v7 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v7;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  *(double *)&this[2].__r_.__value_.__l.__data_ = a4;
  LODWORD(this[2].__r_.__value_.__r.__words[1]) = a3;
  this[2].__r_.__value_.__s.__data_[16] = 0;
  this[3].__r_.__value_.__s.__data_[0] = 0;
}

uint64_t TIInlineCompletion::TIInlineCompletion(uint64_t a1, language_modeling::v1::InlineCompletion *a2)
{
  unsigned int v4;
  int v5;

  language_modeling::v1::InlineCompletion::string(a2);
  language_modeling::v1::InlineCompletion::log(a2);
  *(_QWORD *)(a1 + 48) = language_modeling::v1::InlineCompletion::probability(a2);
  v4 = language_modeling::v1::InlineCompletion::source(a2) - 4;
  if (v4 > 3)
    v5 = 4;
  else
    v5 = dword_1DA911240[v4];
  *(_DWORD *)(a1 + 56) = v5;
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  MEMORY[0x1DF0A1C10](a1 + 64, a2);
  *(_BYTE *)(a1 + 72) = 1;
  return a1;
}

uint64_t TIInlineCompletion::source(TIInlineCompletion *this)
{
  return *((unsigned int *)this + 14);
}

void TIInlineCompletion::string(TIInlineCompletion *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)this, *((_QWORD *)this + 1));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)this;
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)this + 2);
  }
}

uint64_t TIInlineCompletion::probability(TIInlineCompletion *this)
{
  if (*((_BYTE *)this + 72))
    return language_modeling::v1::InlineCompletion::probability((TIInlineCompletion *)((char *)this + 64));
  else
    return *((_QWORD *)this + 6);
}

uint64_t TIInlineCompletion::wordBoundaryAt(TIInlineCompletion *this)
{
  if (*((_BYTE *)this + 72))
    return language_modeling::v1::InlineCompletion::wordBoundaryAt((TIInlineCompletion *)((char *)this + 64));
  else
    return 0;
}

uint64_t UkLoadKeyMap(const char *a1, int *a2)
{
  uint64_t result;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  int v8;
  _BYTE v9[4];
  _BYTE v10[2052];

  *(_QWORD *)&v10[2044] = *MEMORY[0x1E0C80C00];
  v8 = 0;
  result = UkLoadKeyOrderMap(a1, (uint64_t)v9, &v8);
  if ((_DWORD)result)
  {
    memset_pattern16(a2, &unk_1DA911270, 0x400uLL);
    v4 = v8;
    if (v8 >= 1)
    {
      v5 = (int *)v10;
      do
      {
        v6 = *v5;
        v7 = *((unsigned __int8 *)v5 - 4);
        a2[v7] = *v5;
        if (v6 <= 19)
          a2[__tolower(v7)] = v6;
        v5 += 2;
        --v4;
      }
      while (v4);
    }
    return 1;
  }
  return result;
}

uint64_t UkLoadKeyOrderMap(const char *a1, uint64_t a2, _DWORD *a3)
{
  FILE *v5;
  FILE *v6;
  char *v7;
  int v8;
  int v9;
  const char *v10;
  size_t v11;
  char *v12;
  const char *i;
  const char *v14;
  const char *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  const char *v20;
  const char *v21;
  char v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v29;
  _DWORD __b[256];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v5 = fopen(a1, "r");
  if (v5)
  {
    v6 = v5;
    v29 = a2;
    memset_pattern16(__b, &unk_1DA911270, 0x400uLL);
    v7 = (char *)operator new[]();
    v8 = 0;
    v9 = 0;
    v10 = "Tone0";
    while (1)
    {
      while (1)
      {
LABEL_3:
        if (feof(v6) || !fgets(v7, 256, v6) || (v11 = strlen(v7)) == 0)
        {
          MEMORY[0x1DF0A212C](v7, 0x1000C8077774924);
          fclose(v6);
          *a3 = v9;
          return 1;
        }
        if (v7[v11 - 1] == 10)
          v7[v11 - 1] = 0;
        v12 = strchr(v7, 59);
        if (v12)
          *v12 = 0;
        ++v8;
        for (i = v7; *i == 32; ++i)
          ;
        v14 = i;
        if (*i)
        {
          while (1)
          {
            v15 = v14;
            do
            {
              v17 = *(unsigned __int8 *)++v15;
              v16 = v17;
            }
            while (v17 == 32);
            if (!v16)
              goto LABEL_3;
            if (v16 == 61)
              break;
            v14 = v15;
          }
          *((_BYTE *)v14 + 1) = 0;
          do
          {
            v19 = *(unsigned __int8 *)++v15;
            v18 = v19;
          }
          while (v19 == 32);
          if (v18)
            break;
        }
      }
      v20 = v15;
      v21 = v15;
      while (1)
      {
        if (v18 == 32)
          goto LABEL_26;
        if (!(_BYTE)v18)
          break;
        v21 = v20;
LABEL_26:
        v22 = *++v20;
        LOBYTE(v18) = v22;
      }
      *((_BYTE *)v21 + 1) = 0;
      if (strlen(i) == 1)
      {
        v23 = 0;
        v24 = v10;
        while (strcmp(v10, v15))
        {
          ++v23;
          v10 += 36;
          if (v23 == 32)
          {
            CFLog();
            v10 = v24;
            goto LABEL_3;
          }
        }
        v25 = *(unsigned __int8 *)i;
        v10 = v24;
        if (__b[v25] == 19)
        {
          v26 = *(_DWORD *)&v24[36 * v23 + 32];
          __b[v25] = v26;
          v27 = v29 + 8 * v9;
          *(_DWORD *)(v27 + 4) = v26;
          if (v23 > 0x11)
          {
            *(_BYTE *)v27 = v25;
          }
          else
          {
            *(_BYTE *)v27 = __toupper(v25);
            __b[__toupper(v25)] = v26;
          }
          ++v9;
          v10 = v24;
        }
      }
      else
      {
        CFLog();
      }
    }
  }
  CFLog();
  return 0;
}

void initKeyMap(int *a1)
{
  memset_pattern16(a1, &unk_1DA911270, 0x400uLL);
}

uint64_t UkStoreKeyOrderMap(const char *a1, uint64_t a2, int a3)
{
  FILE *v5;
  FILE *v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  int v10;
  char __str[128];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v5 = fopen(a1, "wt");
  if (v5)
  {
    v6 = v5;
    fputs("; This is UniKey user-defined key mapping file, generated from UniKey (Windows)\n\n", v5);
    if (a3 >= 1)
    {
      v7 = 0;
      do
      {
        v8 = 0;
        v9 = "\n";
        while (1)
        {
          v10 = *(_DWORD *)v9;
          v9 += 36;
          if (v10 == *(_DWORD *)(a2 + 8 * v7 + 4))
            break;
          if (++v8 == 32)
            goto LABEL_10;
        }
        if ((_DWORD)v8 != -1)
        {
          snprintf(__str, 0x80uLL, "%c = %s\n", *(unsigned __int8 *)(a2 + 8 * v7), &UkEvLabelList[36 * (int)v8]);
          fputs(__str, v6);
        }
LABEL_10:
        ++v7;
      }
      while (v7 != a3);
    }
    fclose(v6);
    return 1;
  }
  else
  {
    CFLog();
    return 0;
  }
}

uint64_t getLabelIndex(int a1)
{
  uint64_t result;
  const char *v3;
  int v4;

  result = 0;
  v3 = "\n";
  while (1)
  {
    v4 = *(_DWORD *)v3;
    v3 += 36;
    if (v4 == a1)
      break;
    if (++result == 32)
      return 0xFFFFFFFFLL;
  }
  return result;
}

Class __getLSApplicationProxyClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!CoreServicesLibraryCore_frameworkLibrary)
  {
    CoreServicesLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!CoreServicesLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("LSApplicationProxy");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getLSApplicationProxyClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __Block_byref_object_copy__447(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__448(uint64_t a1)
{

}

BOOL NSRangeInRange(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  return a1 <= a3 && a1 + a2 >= a4 + a3;
}

BOOL NSRangeIsValidAndNonZeroLength(uint64_t a1, uint64_t a2)
{
  return a1 != 0x7FFFFFFFFFFFFFFFLL && a2 != 0x7FFFFFFFFFFFFFFFLL && a2 != 0;
}

uint64_t NSRangeEndPosition(uint64_t a1, uint64_t a2)
{
  return a1 + a2;
}

id asMCNearbyKeys(_QWORD *a1)
{
  unint64_t v2;

  v2 = objc_msgSend((id)objc_opt_class(), "maxNearbyKeysCountDefault");
  return asMCNearbyKeys(a1, v2);
}

id asMCNearbyKeys(_QWORD *a1, unint64_t a2)
{
  void *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  MCNearbyKey *v9;
  uint64_t v10;
  int v11;
  double v12;
  MCNearbyKey *v13;
  uint64_t v14;
  void *v15;
  uint64_t v17;
  int v18;
  int v19;
  int v20;

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (*a1)
  {
    v5 = 0;
    v6 = a1[1];
    v7 = 8 * *a1 - 8;
    do
    {
      v8 = *(_QWORD *)(*(_QWORD *)v6 + 8);
      if (!*(_WORD *)(v8 + 12))
      {
        KB::String::compute_length((unsigned __int16 *)(v8 + 8));
        if (!*(_WORD *)(v8 + 12))
          goto LABEL_8;
      }
      v9 = [MCNearbyKey alloc];
      v10 = *(_QWORD *)(v8 + 16);
      if (!v10)
        v10 = v8 + 24;
      v17 = v10;
      v11 = *(unsigned __int16 *)(v8 + 8);
      v18 = 0;
      v19 = v11;
      v20 = 0;
      KB::String::iterator::initialize(&v17);
      LODWORD(v12) = *(_DWORD *)(*(_QWORD *)v6 + 32);
      v13 = -[MCNearbyKey initWithCharacter:logLikelihood:](v9, "initWithCharacter:logLikelihood:", (unsigned __int16)v20, v12);
      objc_msgSend(v4, "addObject:", v13);
      ++v5;

LABEL_8:
      if (v5 >= a2)
        break;
      v6 += 8;
      v14 = v7;
      v7 -= 8;
    }
    while (v14);
  }
  v15 = (void *)objc_msgSend(v4, "copy");

  return v15;
}

void TILXEntryGetSupplementalItemIdentifiers(uint64_t a1@<X8>)
{
  unint64_t v1;
  void *v3;
  void *v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t i;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint8x8_t v14;
  _QWORD *v15;
  _QWORD *j;
  unint64_t v17;
  _QWORD *v18;
  float v19;
  float v20;
  _BOOL8 v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  void *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _BYTE v33[128];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  ICLXEntryGetEntities();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v3;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (v3)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, (unint64_t)(float)(unint64_t)objc_msgSend(v3, "count"));
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v28 = v4;
    v5 = v4;
    v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v29, v33, 16);
    if (!v6)
      goto LABEL_47;
    v7 = v6;
    v8 = *(_QWORD *)v30;
    v9 = (_QWORD *)(a1 + 16);
    while (1)
    {
      for (i = 0; i != v7; ++i)
      {
        if (*(_QWORD *)v30 != v8)
          objc_enumerationMutation(v5);
        v11 = objc_msgSend(*(id *)(*((_QWORD *)&v29 + 1) + 8 * i), "data");
        v12 = v11;
        v13 = *(_QWORD *)(a1 + 8);
        if (v13)
        {
          v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
          v14.i16[0] = vaddlv_u8(v14);
          if (v14.u32[0] > 1uLL)
          {
            v1 = v11;
            if (v11 >= v13)
              v1 = v11 % v13;
          }
          else
          {
            v1 = (v13 - 1) & v11;
          }
          v15 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v1);
          if (v15)
          {
            for (j = (_QWORD *)*v15; j; j = (_QWORD *)*j)
            {
              v17 = j[1];
              if (v17 == v11)
              {
                if (j[2] == v11)
                  goto LABEL_45;
              }
              else
              {
                if (v14.u32[0] > 1uLL)
                {
                  if (v17 >= v13)
                    v17 %= v13;
                }
                else
                {
                  v17 &= v13 - 1;
                }
                if (v17 != v1)
                  break;
              }
            }
          }
        }
        v18 = operator new(0x18uLL);
        *v18 = 0;
        v18[1] = v12;
        v18[2] = v12;
        v19 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
        v20 = *(float *)(a1 + 32);
        if (!v13 || (float)(v20 * (float)v13) < v19)
        {
          v21 = (v13 & (v13 - 1)) != 0;
          if (v13 < 3)
            v21 = 1;
          v22 = v21 | (2 * v13);
          v23 = vcvtps_u32_f32(v19 / v20);
          if (v22 <= v23)
            v24 = v23;
          else
            v24 = v22;
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v24);
          v13 = *(_QWORD *)(a1 + 8);
          if ((v13 & (v13 - 1)) != 0)
          {
            if (v12 >= v13)
              v1 = v12 % v13;
            else
              v1 = v12;
          }
          else
          {
            v1 = (v13 - 1) & v12;
          }
        }
        v25 = *(_QWORD *)a1;
        v26 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v1);
        if (v26)
        {
          *v18 = *v26;
LABEL_43:
          *v26 = v18;
          goto LABEL_44;
        }
        *v18 = *v9;
        *v9 = v18;
        *(_QWORD *)(v25 + 8 * v1) = v9;
        if (*v18)
        {
          v27 = *(_QWORD *)(*v18 + 8);
          if ((v13 & (v13 - 1)) != 0)
          {
            if (v27 >= v13)
              v27 %= v13;
          }
          else
          {
            v27 &= v13 - 1;
          }
          v26 = (_QWORD *)(*(_QWORD *)a1 + 8 * v27);
          goto LABEL_43;
        }
LABEL_44:
        ++*(_QWORD *)(a1 + 24);
LABEL_45:
        ;
      }
      v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v29, v33, 16);
      if (!v7)
      {
LABEL_47:

        v4 = v28;
        break;
      }
    }
  }

}

uint64_t TILXEntryIsPartOfHyphenatedWord()
{
  void *v0;
  void *v1;
  id v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  ICLXEntryGetEntities();
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  if (v0)
  {
    ICLXEntryGetTransientLexicon();
    v1 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v2 = v0;
    v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)v11;
      while (2)
      {
        for (i = 0; i != v4; ++i)
        {
          if (*(_QWORD *)v11 != v5)
            objc_enumerationMutation(v2);
          v7 = *(_QWORD *)(*((_QWORD *)&v10 + 1) + 8 * i);
          if ((objc_opt_respondsToSelector() & 1) == 0
            || !objc_msgSend(v1, "entityIsHyphenatedWord:", v7, (_QWORD)v10))
          {
            v8 = 0;
            goto LABEL_15;
          }
        }
        v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
        v8 = 1;
        if (v4)
          continue;
        break;
      }
    }
    else
    {
      v8 = 1;
    }
LABEL_15:

  }
  else
  {
    v8 = 0;
  }

  return v8;
}

void TI::Favonius::UnigramCandidateGenerator::~UnigramCandidateGenerator(TI::Favonius::UnigramCandidateGenerator *this)
{
  unsigned int *v1;

  *(_QWORD *)this = &off_1EA0FA3C8;
  v1 = (unsigned int *)*((_QWORD *)this + 2);
  if (v1)
    WTF::RefCounted<KB::DictionaryContainer>::deref(v1);
}

{
  unsigned int *v1;

  *(_QWORD *)this = &off_1EA0FA3C8;
  v1 = (unsigned int *)*((_QWORD *)this + 2);
  if (v1)
    WTF::RefCounted<KB::DictionaryContainer>::deref(v1);
  JUMPOUT(0x1DF0A2144);
}

void TI::Favonius::UnigramCandidateGenerator::generate_candidates(uint64_t a1, uint64_t a2, uint64_t a3, KB::CandidateCollection *a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _OWORD v18[3];
  _OWORD v19[3];
  int v20;
  void **v21;
  _BYTE v22[24];
  _BYTE *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  memset(v18, 0, sizeof(v18));
  memset(v19, 0, sizeof(v19));
  v8 = operator new(0x20uLL);
  *v8 = &off_1EA0FA410;
  v8[1] = a1;
  v8[2] = v18;
  v8[3] = a3;
  v23 = v8;
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)a2 + 112))(a2, v22);
  v16 = v23;
  if (v23 == v22)
  {
    v17 = 4;
    v16 = v22;
    goto LABEL_5;
  }
  if (v23)
  {
    v17 = 5;
LABEL_5:
    (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*v16 + 8 * v17))(v16, v9, v10, v11, v12, v13, v14, v15, *(_QWORD *)&v18[0], *((_QWORD *)&v18[0] + 1), *(_QWORD *)&v18[1], *((_QWORD *)&v18[1] + 1));
  }
  KB::CandidateCollection::add(a4, (const KB::Candidate **)v18);
  v21 = (void **)&v19[1] + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v21);
  v21 = (void **)v19;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v21);
  v21 = (void **)&v18[1] + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v21);
  v21 = (void **)v18;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v21);
}

void TI::Favonius::UnigramCandidateGenerator::score_candidate(float a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  float v9;
  float v10;
  uint64_t v11;
  float *v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;

  v9 = (*(float (**)(uint64_t))(*(_QWORD *)a5 + 104))(a5);
  (*(void (**)(uint64_t))(*(_QWORD *)a5 + 80))(a5);
  if (*(_QWORD *)a4)
  {
    v11 = 240 * *(_QWORD *)a4;
    v12 = (float *)(*(_QWORD *)(a4 + 8) + 48);
    v13 = 1.0;
    do
    {
      v14 = *v12;
      v12 += 60;
      v13 = v13 * v14;
      v11 -= 240;
    }
    while (v11);
  }
  else
  {
    v13 = 1.0;
  }
  v15 = v9 + logf(v10);
  v16 = v15 + logf(v13);
  v17 = (*(float (**)(uint64_t))(*(_QWORD *)a5 + 96))(a5);
  *(float *)(a4 + 748) = a1;
  *(float *)(a4 + 752) = v16;
  *(float *)(a4 + 756) = v17;
  *(float *)(a4 + 760) = a2;
  *(_DWORD *)(a4 + 764) = -8388608;
  v18 = expf(a1 + (float)(a2 * (float)(v16 + v17)));
  *(float *)(a4 + 744) = logf(v18);
}

void TI::Favonius::UnigramCandidateGenerator::score_candidate_without_termination(float a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  float v9;
  uint64_t v10;
  float *v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;

  v9 = (*(float (**)(uint64_t))(*(_QWORD *)a5 + 104))(a5);
  if (*(_QWORD *)a4)
  {
    v10 = 240 * *(_QWORD *)a4;
    v11 = (float *)(*(_QWORD *)(a4 + 8) + 48);
    v12 = 1.0;
    do
    {
      v13 = *v11;
      v11 += 60;
      v12 = v12 * v13;
      v10 -= 240;
    }
    while (v10);
  }
  else
  {
    v12 = 1.0;
  }
  v14 = v9 + logf(v12);
  v15 = (*(float (**)(uint64_t))(*(_QWORD *)a5 + 96))(a5);
  *(float *)(a4 + 748) = a1;
  *(float *)(a4 + 752) = v14;
  *(float *)(a4 + 756) = v15;
  *(float *)(a4 + 760) = a2;
  *(_DWORD *)(a4 + 764) = -8388608;
  v16 = expf(a1 + (float)(a2 * (float)(v14 + v15)));
  *(float *)(a4 + 744) = logf(v16);
}

BOOL TI::Favonius::UnigramCandidateGenerator::should_combine_candidate_and_word(TI::Favonius::UnigramCandidateGenerator *this, const Candidate *a2, const KB::Word *a3)
{
  unsigned int v3;
  int v4;

  v3 = *(_DWORD *)(*((_QWORD *)a2 + 1) + 240 * *(_QWORD *)a2 - 108);
  if ((v3 & 0x4000000) != 0)
    return 1;
  v4 = *((_DWORD *)a3 + 33);
  return (v4 & 0x4000000) != 0 || (v4 & (v3 >> 12) & 0xFFF) != 0 || *(_BYTE *)(*((_QWORD *)this + 2) + 64) != 0;
}

uint64_t TI::Favonius::UnigramCandidateGenerator::combined_word_id(TI::Favonius::UnigramCandidateGenerator *this, const KB::Candidate *a2, TITokenID *a3)
{
  KB::DictionaryContainer *v3;
  uint64_t v4;
  uint64_t v5;
  TITokenID v6;
  TITokenID v7;

  v3 = (KB::DictionaryContainer *)*((_QWORD *)this + 2);
  if (!*((_QWORD *)v3 + 4))
    return 0;
  v4 = *((_QWORD *)a2 + 1);
  v5 = *(_QWORD *)a2 - 1;
  if ((a3[16].word_id & (*(_DWORD *)(v4 + 240 * v5 + 132) >> 12) & 0xFFF) == 0)
    return 0;
  v6 = *(TITokenID *)(v4 + 240 * v5 + 136);
  v7 = a3[17];
  return KB::DictionaryContainer::combined_word_id(v3, v6, v7);
}

uint64_t *KB::CandidateCollection::add(KB::CandidateCollection *this, const KB::Candidate **a2)
{
  std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)this, *((_QWORD *)this + 1), *a2, a2[1], 0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3));
  std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)this + 3, *((_QWORD *)this + 4), a2[3], a2[4], 0x1CAC083126E978D5 * ((a2[4] - a2[3]) >> 3));
  std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)this + 6, *((_QWORD *)this + 7), a2[6], a2[7], 0x1CAC083126E978D5 * ((a2[7] - a2[6]) >> 3));
  return std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)this + 9, *((_QWORD *)this + 10), a2[9], a2[10], 0x1CAC083126E978D5 * ((a2[10] - a2[9]) >> 3));
}

uint64_t *std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>(uint64_t *result, uint64_t a2, const KB::Candidate *a3, const KB::Candidate *a4, uint64_t a5)
{
  const KB::Candidate *v6;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  const KB::Candidate *v22;
  const KB::Candidate *v23;
  KB::Candidate *v24;
  KB::Candidate *v25;
  uint64_t v26;
  char *v27;
  _QWORD v28[5];

  if (a5 < 1)
    return result;
  v6 = a3;
  v7 = a2;
  v8 = result;
  v9 = result + 2;
  v10 = result[2];
  v11 = result[1];
  if (0x1CAC083126E978D5 * ((uint64_t)(v10 - v11) >> 3) >= a5)
  {
    v20 = v11 - a2;
    if (0x1CAC083126E978D5 * ((uint64_t)(v11 - a2) >> 3) >= a5)
    {
      v22 = (const KB::Candidate *)((char *)a3 + 1000 * a5);
    }
    else
    {
      v22 = (const KB::Candidate *)((char *)a3 + 8 * ((uint64_t)(v11 - a2) >> 3));
      if (v22 == a4)
      {
        result = (uint64_t *)result[1];
      }
      else
      {
        v23 = (const KB::Candidate *)((char *)a3 + 8 * ((uint64_t)(v11 - a2) >> 3));
        result = (uint64_t *)result[1];
        do
        {
          v24 = KB::Candidate::Candidate((KB::Candidate *)result, v23);
          v23 = (const KB::Candidate *)((char *)v23 + 1000);
          result = (uint64_t *)((char *)v24 + 1000);
        }
        while (v23 != a4);
      }
      v8[1] = (uint64_t)result;
      if (v20 < 1)
        return result;
    }
    for (result = std::vector<KB::Candidate>::__move_range((uint64_t)v8, v7, v11, v7 + 1000 * a5); v6 != v22; v7 += 1000)
    {
      result = (uint64_t *)KB::Candidate::operator=(v7, (uint64_t)v6);
      v6 = (const KB::Candidate *)((char *)v6 + 1000);
    }
  }
  else
  {
    v12 = *result;
    v13 = a5 + 0x1CAC083126E978D5 * ((uint64_t)(v11 - *result) >> 3);
    if (v13 > 0x4189374BC6A7EFLL)
      abort();
    v14 = 0x1CAC083126E978D5 * ((a2 - v12) >> 3);
    v15 = 0x1CAC083126E978D5 * ((v10 - v12) >> 3);
    v16 = 2 * v15;
    if (2 * v15 <= v13)
      v16 = v13;
    if (v15 >= 0x20C49BA5E353F7)
      v17 = 0x4189374BC6A7EFLL;
    else
      v17 = v16;
    v28[4] = v9;
    if (v17)
    {
      v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v17);
    }
    else
    {
      v19 = 0;
      v18 = 0;
    }
    v25 = (KB::Candidate *)&v19[1000 * v14];
    v28[0] = v19;
    v28[1] = v25;
    v28[3] = &v19[1000 * v18];
    v26 = 1000 * a5;
    v27 = (char *)v25 + 1000 * a5;
    do
    {
      v25 = (KB::Candidate *)((char *)KB::Candidate::Candidate(v25, v6) + 1000);
      v6 = (const KB::Candidate *)((char *)v6 + 1000);
      v26 -= 1000;
    }
    while (v26);
    v28[2] = v27;
    std::vector<KB::Candidate>::__swap_out_circular_buffer(v8, v28, v7);
    return (uint64_t *)std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)v28);
  }
  return result;
}

uint64_t *std::vector<KB::Candidate>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v7 = *(_QWORD *)(a1 + 8);
  v8 = v7 - a4;
  v9 = a2 + v7 - a4;
  if (v9 >= a3)
  {
    result = *(uint64_t **)(a1 + 8);
  }
  else
  {
    result = *(uint64_t **)(a1 + 8);
    do
    {
      v12 = KB::Candidate::Candidate((uint64_t)result, v9);
      v9 += 1000;
      result = (uint64_t *)(v12 + 1000);
    }
    while (v9 < a3);
  }
  *(_QWORD *)(a1 + 8) = result;
  if (v7 != a4)
  {
    result = (uint64_t *)(v7 - 1000);
    v13 = 8 * (v8 >> 3);
    v14 = a2 - 1000;
    do
    {
      result = KB::Candidate::operator=(result, (uint64_t *)(v14 + v13)) - 125;
      v13 -= 1000;
    }
    while (v13);
  }
  return result;
}

uint64_t std::vector<KB::Candidate>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = a3;
  v6 = a2[1];
  v7 = *a1;
  v8 = v6;
  if (v7 != a3)
  {
    v9 = a3;
    v8 = a2[1];
    do
    {
      v9 -= 1000;
      v8 = KB::Candidate::Candidate(v8 - 1000, v9);
    }
    while (v9 != v7);
  }
  a2[1] = v8;
  v10 = a1[1];
  v11 = a2[2];
  if (v10 != v3)
  {
    do
    {
      KB::Candidate::Candidate(v11, v3);
      v3 += 1000;
      v11 += 1000;
    }
    while (v3 != v10);
    v8 = a2[1];
  }
  a2[2] = v11;
  v12 = *a1;
  *a1 = v8;
  a2[1] = v12;
  v13 = a1[1];
  a1[1] = a2[2];
  a2[2] = v13;
  v14 = a1[2];
  a1[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return v6;
}

uint64_t KB::Candidate::operator=(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  KB::Word *v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  unint64_t v20;
  uint64_t v21;
  KB::Word *v22;
  const KB::Word *v23;
  uint64_t v24;
  __int128 v25;
  const void *v26;
  const void *v27;

  if (a2 != a1)
  {
    v4 = *(_QWORD *)a1;
    v5 = *(_QWORD *)a2;
    if (*(_QWORD *)a1 <= *(_QWORD *)a2)
    {
      v9 = v5 > *(_QWORD *)(a1 + 16);
      v5 = *(_QWORD *)a1;
      if (v9)
      {
        WTF::Vector<KB::Word,3ul>::shrinkCapacity((_QWORD *)a1);
        WTF::Vector<KB::Word,3ul>::reserveCapacity((_QWORD *)a1, *(_QWORD *)a2);
        if (!*(_QWORD *)(a1 + 8))
          goto LABEL_22;
        v5 = *(_QWORD *)a1;
      }
    }
    else
    {
      v6 = (KB::Word *)(*(_QWORD *)(a1 + 8) + 240 * v5);
      v7 = -240 * v5 + 240 * v4;
      do
      {
        KB::Word::~Word(v6);
        v6 = (KB::Word *)(v8 + 240);
        v7 -= 240;
      }
      while (v7);
      *(_QWORD *)a1 = v5;
    }
    v10 = *(_QWORD *)(a2 + 8);
    if (v5)
    {
      v11 = 0;
      v12 = *(_QWORD *)(a1 + 8);
      v13 = 240 * v5;
      do
      {
        v14 = v12 + v11;
        v15 = v10 + v11;
        KB::String::operator=((KB::String *)(v12 + v11), (KB::String *)(v10 + v11));
        KB::ByteString::operator=((unsigned __int16 *)(v12 + v11 + 32), (const void **)(v10 + v11 + 32));
        v16 = *(_QWORD *)(v10 + v11 + 48);
        *(_DWORD *)(v14 + 56) = *(_DWORD *)(v10 + v11 + 56);
        *(_QWORD *)(v14 + 48) = v16;
        KB::String::operator=((KB::String *)(v12 + v11 + 64), (KB::String *)(v10 + v11 + 64));
        v17 = *(_OWORD *)(v10 + v11 + 96);
        v18 = *(_OWORD *)(v10 + v11 + 112);
        v19 = *(_OWORD *)(v10 + v11 + 144);
        *(_OWORD *)(v14 + 128) = *(_OWORD *)(v10 + v11 + 128);
        *(_OWORD *)(v14 + 144) = v19;
        *(_OWORD *)(v14 + 96) = v17;
        *(_OWORD *)(v14 + 112) = v18;
        KB::String::operator=((KB::String *)(v12 + v11 + 160), (KB::String *)(v10 + v11 + 160));
        *(_BYTE *)(v14 + 192) = *(_BYTE *)(v10 + v11 + 192);
        if (v10 != v12)
        {
          *(_DWORD *)(v14 + 232) = *(_DWORD *)(v15 + 232);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((_QWORD *)(v14 + 200), *(_QWORD **)(v15 + 216));
        }
        v11 += 240;
      }
      while (v13 != v11);
      v10 = *(_QWORD *)(a2 + 8);
      v20 = *(_QWORD *)a1;
    }
    else
    {
      v20 = 0;
    }
    if (v20 != *(_QWORD *)a2)
    {
      v21 = 240 * v20;
      v22 = (KB::Word *)(*(_QWORD *)(a1 + 8) + v21);
      v23 = (const KB::Word *)(v10 + v21);
      v24 = 240 * *(_QWORD *)a2 - v21;
      do
      {
        v22 = (KB::Word *)((char *)KB::Word::Word(v22, v23) + 240);
        v23 = (const KB::Word *)((char *)v23 + 240);
        v24 -= 240;
      }
      while (v24);
      v20 = *(_QWORD *)a2;
    }
    *(_QWORD *)a1 = v20;
  }
LABEL_22:
  *(_DWORD *)(a1 + 744) = *(_DWORD *)(a2 + 744);
  v25 = *(_OWORD *)(a2 + 748);
  *(_OWORD *)(a1 + 760) = *(_OWORD *)(a2 + 760);
  *(_OWORD *)(a1 + 748) = v25;
  *(_QWORD *)(a1 + 776) = *(_QWORD *)(a2 + 776);
  KB::LanguageModelContext::operator=(a1 + 784, (uint64_t *)(a2 + 784));
  KB::String::operator=((KB::String *)(a1 + 888), (KB::String *)(a2 + 888));
  std::string::operator=((std::string *)(a1 + 920), (const std::string *)(a2 + 920));
  KB::ByteString::operator=((unsigned __int16 *)(a1 + 944), (const void **)(a2 + 944));
  *(_OWORD *)(a1 + 960) = *(_OWORD *)(a2 + 960);
  KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(a1 + 976), *(CFTypeRef *)(a2 + 976));
  v26 = *(const void **)(a2 + 984);
  v27 = *(const void **)(a1 + 984);
  if (v27 != v26)
  {
    if (v26)
    {
      CFRetain(*(CFTypeRef *)(a2 + 984));
      v27 = *(const void **)(a1 + 984);
    }
    if (v27)
      CFRelease(v27);
    *(_QWORD *)(a1 + 984) = v26;
  }
  *(_DWORD *)(a1 + 992) = *(_DWORD *)(a2 + 992);
  return a1;
}

void std::vector<std::string>::__assign_with_size[abi:nn180100]<std::string*,std::string*>(std::vector<std::string> *this, std::string *__str, std::string *a3, unint64_t a4)
{
  const std::string *v6;
  std::string *begin;
  unint64_t v9;
  unint64_t v10;
  std::string *end;
  __int128 *v12;
  __int128 *v13;
  std::vector<std::string>::pointer v14;
  __int128 *v15;
  uint64_t v16;

  v6 = __str;
  begin = this->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3) < a4)
  {
    std::vector<std::string>::__vdeallocate(this);
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v9 = 0x5555555555555556 * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3);
    if (v9 <= a4)
      v9 = a4;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3) >= 0x555555555555555)
      v10 = 0xAAAAAAAAAAAAAAALL;
    else
      v10 = v9;
    std::vector<std::string>::__vallocate[abi:nn180100](this, v10);
    end = this->__end_;
    v12 = (__int128 *)v6;
    v13 = (__int128 *)a3;
LABEL_15:
    this->__end_ = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(v12, v13, end);
    return;
  }
  v14 = this->__end_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)v14 - (char *)begin) >> 3) < a4)
  {
    v15 = (__int128 *)(&__str->__r_.__value_.__l.__data_ + (((char *)v14 - (char *)begin) >> 3));
    if (v14 != begin)
    {
      v16 = 8 * (((char *)v14 - (char *)begin) >> 3);
      do
      {
        std::string::operator=(begin++, v6++);
        v16 -= 24;
      }
      while (v16);
      begin = this->__end_;
    }
    v12 = v15;
    v13 = (__int128 *)a3;
    end = begin;
    goto LABEL_15;
  }
  if (__str != a3)
  {
    do
      std::string::operator=(begin++, v6++);
    while (v6 != a3);
    v14 = this->__end_;
  }
  while (v14 != begin)
  {
    if (SHIBYTE(v14[-1].__r_.__value_.__r.__words[2]) < 0)
      operator delete(v14[-1].__r_.__value_.__l.__data_);
    --v14;
  }
  this->__end_ = begin;
}

void std::vector<std::string>::__vdeallocate(std::vector<std::string> *this)
{
  if (this->__begin_)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)this);
    operator delete(this->__begin_);
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
  }
}

void KB::Word::~Word(KB::Word *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  void *v5;

  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)this + 200);
  v2 = (void *)*((_QWORD *)this + 21);
  if (v2 && *((_BYTE *)this + 166) == 1)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 9);
  if (v3 && *((_BYTE *)this + 70) == 1)
    free(v3);
  if (*((unsigned __int16 *)this + 16) >= 0xFu)
  {
    v4 = *((_QWORD *)this + 5);
    if (v4)
      MEMORY[0x1DF0A212C](v4, 0x1000C8077774924);
  }
  v5 = (void *)*((_QWORD *)this + 1);
  if (v5)
  {
    if (*((_BYTE *)this + 6) == 1)
      free(v5);
  }
}

_QWORD *WTF::Vector<KB::Word,3ul>::shrinkCapacity(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  KB::Word *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;

  if (result[2])
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = (KB::Word *)result[1];
      v4 = 240 * v2;
      do
      {
        KB::Word::~Word(v3);
        v3 = (KB::Word *)(v5 + 240);
        v4 -= 240;
      }
      while (v4);
      *v1 = 0;
    }
    v6 = v1 + 1;
    result = (_QWORD *)v1[1];
    if (v1 + 3 != result)
    {
      *v6 = 0;
      v1[2] = 0;
      free(result);
      result = (_QWORD *)*v6;
    }
    if (!result)
    {
      v1[1] = v1 + 3;
      v1[2] = 3;
    }
  }
  return result;
}

void WTF::Vector<KB::Word,3ul>::reserveCapacity(_QWORD *a1, unint64_t a2)
{
  const KB::Word *v3;
  void **v4;
  uint64_t v5;
  KB::Word *v6;
  uint64_t v7;
  const KB::Word *v8;

  if (a1[2] >= a2)
    return;
  v4 = (void **)(a1 + 1);
  v3 = (const KB::Word *)a1[1];
  v5 = *a1;
  if (a2 <= 3)
  {
    v6 = (KB::Word *)(a1 + 3);
    a1[1] = a1 + 3;
    a1[2] = 3;
    if (!v5)
      goto LABEL_9;
    goto LABEL_7;
  }
  a1[2] = a2;
  v6 = (KB::Word *)malloc_type_malloc(240 * a2, 0x10B2040DF775671uLL);
  a1[1] = v6;
  if (v6 && v5)
  {
LABEL_7:
    v7 = 240 * v5;
    v8 = v3;
    do
    {
      KB::Word::Word(v6, v8);
      KB::Word::~Word(v8);
      v6 = (KB::Word *)((char *)v6 + 240);
      v8 = (const KB::Word *)((char *)v8 + 240);
      v7 -= 240;
    }
    while (v7);
  }
LABEL_9:
  if (a1 + 3 != (_QWORD *)v3)
  {
    if (*v4 == v3)
    {
      *v4 = 0;
      v4[1] = 0;
    }
    free(v3);
  }
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t i;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *inserted;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;

  v4 = a1[1];
  if (!v4)
    goto LABEL_7;
  for (i = 0; i != v4; ++i)
    *(_QWORD *)(*a1 + 8 * i) = 0;
  v6 = (_QWORD *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v6)
  {
    while (a2)
    {
      v7 = a2[2];
      v6[2] = v7;
      v8 = (_QWORD *)*v6;
      v6[1] = v7;
      inserted = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_prepare((uint64_t)a1, v7, v6 + 2);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_perform(a1, v6, inserted);
      a2 = (_QWORD *)*a2;
      v6 = v8;
      if (!v8)
        goto LABEL_7;
    }
    do
    {
      v13 = (_QWORD *)*v6;
      operator delete(v6);
      v6 = v13;
    }
    while (v13);
  }
  else
  {
LABEL_7:
    while (a2)
    {
      v10 = operator new(0x18uLL);
      *v10 = 0;
      v11 = a2[2];
      v10[2] = v11;
      v10[1] = v11;
      v12 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_prepare((uint64_t)a1, v11, v10 + 2);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_perform(a1, v10, v12);
      a2 = (_QWORD *)*a2;
    }
  }
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v6;
  float v7;
  float v8;
  _BOOL8 v9;
  unint64_t v10;
  unint64_t v11;
  int8x8_t prime;
  void *v13;
  void *v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  uint8x8_t v18;
  unint64_t v19;
  uint8x8_t v20;
  uint64_t v21;
  _QWORD *i;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint8x8_t v26;
  unint64_t v27;
  _QWORD *v28;
  int v29;
  _QWORD *result;
  unint64_t v31;
  unint64_t v32;
  _BOOL4 v33;
  int v34;
  void *v35;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    v9 = 1;
    if (v6 >= 3)
      v9 = (v6 & (v6 - 1)) != 0;
    v10 = v9 | (2 * v6);
    v11 = vcvtps_u32_f32(v7 / v8);
    if (v10 <= v11)
      prime = (int8x8_t)v11;
    else
      prime = (int8x8_t)v10;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v6 = *(_QWORD *)(a1 + 8);
    }
    if (*(_QWORD *)&prime > v6)
      goto LABEL_74;
    if (*(_QWORD *)&prime >= v6)
      goto LABEL_43;
    v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v6 < 3 || (v20 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
    {
      v19 = std::__next_prime(v19);
    }
    else
    {
      v21 = 1 << -(char)__clz(v19 - 1);
      if (v19 >= 2)
        v19 = v21;
    }
    if (*(_QWORD *)&prime <= v19)
      prime = (int8x8_t)v19;
    if (*(_QWORD *)&prime >= v6)
    {
      v6 = *(_QWORD *)(a1 + 8);
      goto LABEL_43;
    }
    if (prime)
    {
LABEL_74:
      if (*(_QWORD *)&prime >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v13 = operator new(8 * *(_QWORD *)&prime);
      v14 = *(void **)a1;
      *(_QWORD *)a1 = v13;
      if (v14)
        operator delete(v14);
      v15 = 0;
      *(int8x8_t *)(a1 + 8) = prime;
      do
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v15++) = 0;
      while (*(_QWORD *)&prime != v15);
      v16 = *(_QWORD **)(a1 + 16);
      if (v16)
      {
        v17 = v16[1];
        v18 = (uint8x8_t)vcnt_s8(prime);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          if (v17 >= *(_QWORD *)&prime)
            v17 %= *(_QWORD *)&prime;
        }
        else
        {
          v17 &= *(_QWORD *)&prime - 1;
        }
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v17) = a1 + 16;
        for (i = (_QWORD *)*v16; *v16; i = (_QWORD *)*v16)
        {
          v23 = i[1];
          if (v18.u32[0] > 1uLL)
          {
            if (v23 >= *(_QWORD *)&prime)
              v23 %= *(_QWORD *)&prime;
          }
          else
          {
            v23 &= *(_QWORD *)&prime - 1;
          }
          if (v23 == v17)
          {
            v16 = i;
          }
          else
          {
            v24 = i;
            if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v23))
            {
              do
              {
                v25 = v24;
                v24 = (_QWORD *)*v24;
              }
              while (v24 && i[2] == v24[2]);
              *v16 = v24;
              *v25 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v23);
              **(_QWORD **)(*(_QWORD *)a1 + 8 * v23) = i;
            }
            else
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v16;
              v16 = i;
              v17 = v23;
            }
          }
        }
      }
      v6 = (unint64_t)prime;
    }
    else
    {
      v35 = *(void **)a1;
      *(_QWORD *)a1 = 0;
      if (v35)
        operator delete(v35);
      v6 = 0;
      *(_QWORD *)(a1 + 8) = 0;
    }
  }
LABEL_43:
  v26 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v26.i16[0] = vaddlv_u8(v26);
  if (v26.u32[0] > 1uLL)
  {
    v27 = a2;
    if (v6 <= a2)
      v27 = a2 % v6;
  }
  else
  {
    v27 = (v6 - 1) & a2;
  }
  v28 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v27);
  if (!v28)
    return 0;
  v29 = 0;
  do
  {
    result = v28;
    v28 = (_QWORD *)*v28;
    if (!v28)
      break;
    v31 = v28[1];
    if (v26.u32[0] > 1uLL)
    {
      v32 = v28[1];
      if (v31 >= v6)
        v32 = v31 % v6;
    }
    else
    {
      v32 = v31 & (v6 - 1);
    }
    if (v32 != v27)
      break;
    v33 = v31 == a2 && v28[2] == *a3;
    v34 = v29 & !v33;
    v29 |= v33;
  }
  while (v34 != 1);
  return result;
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_perform(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  unint64_t v6;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(_QWORD *)(*result + 8 * v4) = result + 2;
    if (!*a2)
      goto LABEL_19;
    v6 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v3)
        v6 %= *(_QWORD *)&v3;
    }
    else
    {
      v6 &= *(_QWORD *)&v3 - 1;
    }
LABEL_18:
    *(_QWORD *)(*result + 8 * v6) = a2;
    goto LABEL_19;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    v6 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v3)
        v6 %= *(_QWORD *)&v3;
    }
    else
    {
      v6 &= *(_QWORD *)&v3 - 1;
    }
    if (v6 != v4)
      goto LABEL_18;
  }
LABEL_19:
  ++result[3];
  return result;
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t *KB::Candidate::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  void *v7;
  __int128 v8;
  void **v9;
  __int128 v10;
  const void *v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;

  v4 = *a1;
  *a1 = *a2;
  *a2 = v4;
  WTF::VectorBuffer<KB::Word,3ul>::swap(a1 + 1, a2 + 1);
  v5 = *(_OWORD *)(a2 + 93);
  v6 = *(_OWORD *)(a2 + 95);
  a1[97] = a2[97];
  *(_OWORD *)(a1 + 93) = v5;
  *(_OWORD *)(a1 + 95) = v6;
  std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100]((uint64_t)(a1 + 98), (__int128 *)a2 + 49);
  v7 = (void *)a1[100];
  if (v7)
  {
    a1[101] = (uint64_t)v7;
    operator delete(v7);
    a1[100] = 0;
    a1[101] = 0;
    a1[102] = 0;
  }
  *((_OWORD *)a1 + 50) = *((_OWORD *)a2 + 50);
  a1[102] = a2[102];
  a2[100] = 0;
  a2[101] = 0;
  a2[102] = 0;
  v8 = *(_OWORD *)(a2 + 103);
  a1[105] = a2[105];
  *(_OWORD *)(a1 + 103) = v8;
  language_modeling::v1::LinguisticContext::operator=();
  language_modeling::v1::LinguisticContext::operator=();
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)a1 + 36);
  *((_OWORD *)a1 + 54) = *((_OWORD *)a2 + 54);
  a1[110] = a2[110];
  a2[109] = 0;
  a2[108] = 0;
  a2[110] = 0;
  KB::String::operator=((uint64_t)(a1 + 111), (KB::String *)(a2 + 111));
  v9 = (void **)(a1 + 115);
  if (*((char *)a1 + 943) < 0)
    operator delete(*v9);
  v10 = *(_OWORD *)(a2 + 115);
  a1[117] = a2[117];
  *(_OWORD *)v9 = v10;
  *((_BYTE *)a2 + 943) = 0;
  *((_BYTE *)a2 + 920) = 0;
  KB::ByteString::operator=((unsigned __int16 *)a1 + 472, (unsigned __int16 *)a2 + 472);
  *((_OWORD *)a1 + 60) = *((_OWORD *)a2 + 60);
  v11 = (const void *)a1[122];
  if (v11)
    CFRelease(v11);
  a1[122] = 0;
  v12 = a2[122];
  a2[122] = 0;
  a1[122] = v12;
  v13 = (const void *)a1[123];
  if (v13)
    CFRelease(v13);
  a1[123] = 0;
  v14 = a2[123];
  a2[123] = 0;
  a1[123] = v14;
  *((_DWORD *)a1 + 248) = *((_DWORD *)a2 + 248);
  return a1;
}

uint64_t std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void std::__function::__func<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,void ()(TI::Favonius::TypingHypothesis const*)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,void ()(TI::Favonius::TypingHypothesis const*)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1EA0FA410;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,void ()(TI::Favonius::TypingHypothesis const*)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FA410;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,void ()(TI::Favonius::TypingHypothesis const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  const KB::Word *i;
  const KB::Word *v10;
  char *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  KB::Candidate *v17;
  uint64_t v18;
  uint64_t v19;
  int64x2_t v20;
  unint64_t v21;
  uint64_t **v22;
  uint64_t *v23;
  const KB::Word *j;
  const KB::Word *v25;
  unint64_t v26;
  TITokenID v27;
  TITokenID v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  KB::Candidate *v36;
  uint64_t v37;
  uint64_t v38;
  int64x2_t v39;
  KB::Candidate *v40;
  uint64_t v41;
  uint64_t v42;
  int64x2_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  int64x2_t v49;
  unint64_t v50;
  const KB::Word *v51;
  const KB::Word *v52;
  uint64_t v53;
  unint64_t v54;
  int64x2_t v55;
  unint64_t v56;
  unint64_t *v57;
  _BYTE v58[104];
  int v59;
  unint64_t v60;
  uint64_t v61;
  int64x2_t *v62;
  int64x2_t v63;
  unint64_t v64;
  unint64_t *v65;
  int v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  int64x2_t v70;
  unint64_t v71;
  unint64_t *v72;
  int v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)*a2 + 176))(*a2);
  v6 = v5;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  TI::Favonius::UnigramCandidateGenerator::words_for_input_segment(v5, v3, v7, (uint64_t *)&v51);
  v49 = 0uLL;
  v50 = 0;
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 136))(v3);
  v48 = a1;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v8 + 144))(v8))
  {
    v10 = v51;
    for (i = v52; v10 != i; v10 = (const KB::Word *)((char *)v10 + 240))
    {
      KB::Word::Word((KB::Word *)&v62, v10);
      if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 168))(v3) & 1) != 0)
      {
        v67 = 0;
      }
      else if ((v66 & 0x80060100) == 0 && HIDWORD(v67) == 0 && v68 == 0)
      {
        v66 |= 4u;
      }
      if (v49.i64[1] >= v50)
      {
        v14 = 0x1CAC083126E978D5 * ((v49.i64[1] - v49.i64[0]) >> 3) + 1;
        if (v14 > 0x4189374BC6A7EFLL)
          goto LABEL_89;
        if (0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3) > v14)
          v14 = 0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3);
        if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(v50 - v49.i64[0]) >> 3)) >= 0x20C49BA5E353F7)
          v15 = 0x4189374BC6A7EFLL;
        else
          v15 = v14;
        v72 = &v50;
        if (v15)
          v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v15);
        else
          v16 = 0;
        v17 = (KB::Candidate *)(v15 + 8 * ((v49.i64[1] - v49.i64[0]) >> 3));
        v69 = v15;
        v70.i64[0] = (uint64_t)v17;
        v71 = v15 + 1000 * v16;
        KB::Candidate::Candidate(v17, (const KB::Word *)&v62);
        v13 = (char *)v17 + 1000;
        v70.i64[1] = (uint64_t)v17 + 1000;
        v18 = v49.i64[1];
        v19 = v70.i64[0];
        if (v49.i64[1] == v49.i64[0])
        {
          v20 = vdupq_n_s64(v49.u64[1]);
        }
        else
        {
          do
          {
            v18 -= 1000;
            v19 = KB::Candidate::Candidate(v19 - 1000, v18);
          }
          while (v18 != v49.i64[0]);
          v20 = v49;
          v13 = (char *)v70.i64[1];
        }
        v49.i64[0] = v19;
        v49.i64[1] = (uint64_t)v13;
        v70 = v20;
        v21 = v50;
        v50 = v71;
        v71 = v21;
        v69 = v20.i64[0];
        std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v69);
      }
      else
      {
        v13 = (char *)KB::Candidate::Candidate((KB::Candidate *)v49.i64[1], (const KB::Word *)&v62) + 1000;
      }
      v49.i64[1] = (uint64_t)v13;
      KB::LanguageModelContext::operator=((uint64_t)(v13 - 216), *(uint64_t **)(v48 + 24));
      if (v6)
        *(_BYTE *)(v49.i64[1] - 38) = 1;
      KB::Word::~Word((KB::Word *)&v62);
    }
  }
  else
  {
    v22 = *(uint64_t ***)(a1 + 16);
    v23 = *v22;
    v47 = v22[1];
    if (*v22 != v47)
    {
      do
      {
        v25 = v51;
        for (j = v52; v25 != j; v25 = (const KB::Word *)((char *)v25 + 240))
        {
          KB::Word::Word((KB::Word *)&v69, v25);
          if ((*(unsigned int (**)(uint64_t, uint64_t *, unint64_t *))(*(_QWORD *)v4 + 40))(v4, v23, &v69))
          {
            v26 = (*(uint64_t (**)(uint64_t, uint64_t *, unint64_t *))(*(_QWORD *)v4 + 48))(v4, v23, &v69);
            if (HIDWORD(v26))
            {
              v27 = (TITokenID)v26;
              KB::Candidate::Candidate((KB::Candidate *)&v62, (const KB::Candidate *)v23);
              KB::Word::Word((KB::Word *)v58, (const KB::Word *)(v23[1] + 240 * *v23 - 240));
              v28 = v27;
              KB::Word::append_suffix((KB::Word *)v58, v25, 0, v28);
              KB::Candidate::pop_last_word((KB::Candidate *)&v62);
              if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 168))(v3) & 1) != 0)
              {
                v60 = 0;
              }
              else if ((v59 & 0x80060100) == 0 && !HIDWORD(v60) && !v61)
              {
                v59 |= 4u;
              }
              if (v49.i64[1] >= v50)
              {
                v33 = 0x1CAC083126E978D5 * ((v49.i64[1] - v49.i64[0]) >> 3) + 1;
                if (v33 > 0x4189374BC6A7EFLL)
LABEL_89:
                  abort();
                if (0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3) > v33)
                  v33 = 0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3);
                if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(v50 - v49.i64[0]) >> 3)) >= 0x20C49BA5E353F7)
                  v34 = 0x4189374BC6A7EFLL;
                else
                  v34 = v33;
                v57 = &v50;
                if (v34)
                  v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v34);
                else
                  v35 = 0;
                v40 = (KB::Candidate *)(v34 + 8 * ((v49.i64[1] - v49.i64[0]) >> 3));
                v54 = v34;
                v55.i64[0] = (uint64_t)v40;
                v56 = v34 + 1000 * v35;
                KB::Candidate::Candidate(v40, (const KB::Candidate *)&v62, (const KB::Word *)v58);
                v29 = (char *)v40 + 1000;
                v55.i64[1] = (uint64_t)v40 + 1000;
                v41 = v49.i64[1];
                v42 = v55.i64[0];
                if (v49.i64[1] == v49.i64[0])
                {
                  v43 = vdupq_n_s64(v49.u64[1]);
                }
                else
                {
                  do
                  {
                    v41 -= 1000;
                    v42 = KB::Candidate::Candidate(v42 - 1000, v41);
                  }
                  while (v41 != v49.i64[0]);
                  v43 = v49;
                  v29 = (char *)v55.i64[1];
                }
                v49.i64[0] = v42;
                v49.i64[1] = (uint64_t)v29;
                v55 = v43;
                v45 = v50;
                v50 = v56;
                v56 = v45;
                v54 = v43.i64[0];
                std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v54);
              }
              else
              {
                v29 = (char *)KB::Candidate::Candidate((KB::Candidate *)v49.i64[1], (const KB::Candidate *)&v62, (const KB::Word *)v58)+ 1000;
              }
              v49.i64[1] = (uint64_t)v29;
              KB::Word::~Word((KB::Word *)v58);
              KB::Candidate::~Candidate((KB::Candidate *)&v62);
            }
            else
            {
              if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 168))(v3) & 1) != 0)
              {
                v74 = 0;
              }
              else if ((v73 & 0x80060100) == 0 && !HIDWORD(v74) && !v75)
              {
                v73 |= 4u;
              }
              if (v49.i64[1] >= v50)
              {
                v30 = 0x1CAC083126E978D5 * ((v49.i64[1] - v49.i64[0]) >> 3) + 1;
                if (v30 > 0x4189374BC6A7EFLL)
                  goto LABEL_89;
                if (0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3) > v30)
                  v30 = 0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3);
                if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(v50 - v49.i64[0]) >> 3)) >= 0x20C49BA5E353F7)
                  v31 = 0x4189374BC6A7EFLL;
                else
                  v31 = v30;
                v65 = &v50;
                if (v31)
                  v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v31);
                else
                  v32 = 0;
                v36 = (KB::Candidate *)(v31 + 8 * ((v49.i64[1] - v49.i64[0]) >> 3));
                v62 = (int64x2_t *)v31;
                v63.i64[0] = (uint64_t)v36;
                v64 = v31 + 1000 * v32;
                KB::Candidate::Candidate(v36, (const KB::Candidate *)v23, (const KB::Word *)&v69);
                v29 = (char *)v36 + 1000;
                v63.i64[1] = (uint64_t)v36 + 1000;
                v37 = v49.i64[1];
                v38 = v63.i64[0];
                if (v49.i64[1] == v49.i64[0])
                {
                  v39 = vdupq_n_s64(v49.u64[1]);
                }
                else
                {
                  do
                  {
                    v37 -= 1000;
                    v38 = KB::Candidate::Candidate(v38 - 1000, v37);
                  }
                  while (v37 != v49.i64[0]);
                  v39 = v49;
                  v29 = (char *)v63.i64[1];
                }
                v49.i64[0] = v38;
                v49.i64[1] = (uint64_t)v29;
                v63 = v39;
                v44 = v50;
                v50 = v64;
                v64 = v44;
                v62 = (int64x2_t *)v39.i64[0];
                std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v62);
              }
              else
              {
                v29 = (char *)KB::Candidate::Candidate((KB::Candidate *)v49.i64[1], (const KB::Candidate *)v23, (const KB::Word *)&v69)+ 1000;
              }
              v49.i64[1] = (uint64_t)v29;
            }
            KB::LanguageModelContext::operator=((uint64_t)(v29 - 216), v23 + 98);
            if (v6)
              *(_BYTE *)(v49.i64[1] - 38) = 1;
          }
          KB::Word::~Word((KB::Word *)&v69);
        }
        v23 += 125;
      }
      while (v23 != v47);
    }
  }
  v46 = *(_QWORD *)(v48 + 16);
  std::vector<KB::Candidate>::__vdeallocate((void **)v46);
  *(int64x2_t *)v46 = v49;
  *(_QWORD *)(v46 + 16) = v50;
  v49 = 0uLL;
  v50 = 0;
  v62 = &v49;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v62);
  v62 = (int64x2_t *)&v51;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v62);
}

uint64_t TI::Favonius::UnigramCandidateGenerator::words_for_input_segment(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t i;
  int v9;

  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)a2 + 128))(a2, a4);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 168))(a2);
  v7 = *a4;
  if ((result & 1) != 0)
  {
    *(_QWORD *)(v7 + 136) = 0;
  }
  else
  {
    for (i = a4[1]; v7 != i; v7 += 240)
    {
      v9 = *(_DWORD *)(v7 + 104);
      if ((v9 & 0x40000) == 0
        && (v9 & 0x80020100) == 0
        && HIDWORD(*(_QWORD *)(v7 + 136)) == 0
        && !*(_QWORD *)(v7 + 224))
      {
        *(_DWORD *)(v7 + 104) = v9 | 4;
      }
    }
  }
  return result;
}

void std::vector<KB::Candidate>::__vdeallocate(void **a1)
{
  char *v1;
  char *v3;
  void *v4;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
        KB::Candidate::~Candidate((KB::Candidate *)(v3 - 1000));
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        KB::Word::~Word((KB::Word *)(v4 - 240));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

KB::Candidate *KB::Candidate::Candidate(KB::Candidate *this, const KB::Word *a2)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = (char *)this + 24;
  *((_QWORD *)this + 2) = 3;
  *(_OWORD *)((char *)this + 744) = xmmword_1DA910F30;
  *((_QWORD *)this + 95) = 0xFF8000003F800000;
  *((_QWORD *)this + 105) = 0;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 848));
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 856));
  *((_QWORD *)this + 109) = 0;
  *((_QWORD *)this + 108) = 0;
  *((_QWORD *)this + 110) = 0;
  *((_DWORD *)this + 222) = 0x100000;
  *((_WORD *)this + 446) = 0;
  *((_BYTE *)this + 894) = 0;
  *((_QWORD *)this + 112) = 0;
  *((_BYTE *)this + 904) = 0;
  *((_QWORD *)this + 115) = 0;
  *((_OWORD *)this + 58) = 0u;
  *((_WORD *)this + 472) = 0;
  *((_DWORD *)this + 240) = 0;
  *((_BYTE *)this + 964) = 0;
  *((_OWORD *)this + 61) = 0u;
  *((_DWORD *)this + 248) = 0;
  KB::Candidate::append((unsigned __int16 *)this, a2);
  return this;
}

uint64_t TI::Favonius::UnigramCandidateGenerator::create@<X0>(unsigned int **a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result;
  unsigned int *v5;
  unsigned int v6;

  result = operator new();
  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)result = &off_1EA0FA3C8;
  v5 = *a1;
  *(_QWORD *)(result + 16) = *a1;
  if (v5)
  {
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 + 1, v5));
  }
  *a2 = result;
  return result;
}

uint64_t TI::Favonius::UnigramCandidateGenerator::UnigramCandidateGenerator(uint64_t result, unsigned int **a2)
{
  unsigned int *v2;
  unsigned int v3;

  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)result = &off_1EA0FA3C8;
  v2 = *a2;
  *(_QWORD *)(result + 16) = *a2;
  if (v2)
  {
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + 1, v2));
  }
  return result;
}

{
  unsigned int *v2;
  unsigned int v3;

  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)result = &off_1EA0FA3C8;
  v2 = *a2;
  *(_QWORD *)(result + 16) = *a2;
  if (v2)
  {
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + 1, v2));
  }
  return result;
}

BOOL TI::Favonius::UnigramCandidateGenerator::should_suggest_word_combination(TI::Favonius::UnigramCandidateGenerator *this, Candidate *a2, const KB::Word *a3)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;

  if (*(_QWORD *)this)
  {
    v4 = *((_QWORD *)this + 1);
    v5 = 240 * *(_QWORD *)this;
    while (1)
    {
      v6 = *(unsigned __int16 *)(v4 + 4);
      if (!*(_WORD *)(v4 + 4))
      {
        KB::String::compute_length((unsigned __int16 *)v4);
        v6 = *(unsigned __int16 *)(v4 + 4);
      }
      if (v6 >= 2 && *(_DWORD *)(v4 + 120))
        return 0;
      v4 += 240;
      v5 -= 240;
      if (!v5)
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    v7 = *((unsigned __int16 *)a2 + 2);
    if (!*((_WORD *)a2 + 2))
    {
      KB::String::compute_length((unsigned __int16 *)a2);
      v7 = *((unsigned __int16 *)a2 + 2);
    }
    return v7 < 2 || *((_DWORD *)a2 + 30) == 0;
  }
}

uint64_t TI::Favonius::UnigramCandidateGenerator::update_word(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v5;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 168))(a3);
  if ((result & 1) != 0)
  {
    *(_QWORD *)(a2 + 136) = 0;
  }
  else
  {
    v5 = *(_DWORD *)(a2 + 104);
    if ((v5 & 0x80060100) == 0 && HIDWORD(*(_QWORD *)(a2 + 136)) == 0 && *(_QWORD *)(a2 + 224) == 0)
      *(_DWORD *)(a2 + 104) = v5 | 4;
  }
  return result;
}

void KB::LanguageModelStr::~LanguageModelStr(KB::LanguageModelStr *this)
{
  KB::LanguageModelStr::~LanguageModelStr(this);
  JUMPOUT(0x1DF0A2144);
}

{
  unsigned __int8 v2;
  unsigned __int8 v3;
  const void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  const void *v9;
  void *v10;

  *(_QWORD *)this = &off_1EA0FA498;
  v2 = atomic_load((unsigned __int8 *)this + 216);
  if ((v2 & 1) != 0)
  {
    v3 = atomic_load((unsigned __int8 *)this + 217);
    if ((v3 & 1) == 0)
      language_modeling::v1::LanguageModel::unwireMemory(*((language_modeling::v1::LanguageModel **)this + 21));
  }
  atomic_store(0, (unsigned __int8 *)this + 216);
  atomic_store(0, (unsigned __int8 *)this + 217);
  std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>>>::destroy(*((_QWORD **)this + 42));
  std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(*((_QWORD **)this + 36));
  v4 = (const void *)*((_QWORD *)this + 34);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 34) = 0;
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 200);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 24);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 168);
  v8 = (std::__shared_weak_count *)*((_QWORD *)this + 20);
  if (v8)
    std::__shared_weak_count::__release_weak(v8);
  *(_QWORD *)this = off_1EA103830;
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 136);
  v9 = (const void *)*((_QWORD *)this + 16);
  if (v9)
    _Block_release(v9);
  *((_QWORD *)this + 16) = 0;
  v10 = (void *)*((_QWORD *)this + 13);
  if (v10)
  {
    *((_QWORD *)this + 14) = v10;
    operator delete(v10);
  }
  KB::LanguageModelConfig::~LanguageModelConfig((KB::LanguageModelStr *)((char *)this + 8));
}

uint64_t KB::LanguageModelStr::is_string_based_lm_model(KB::LanguageModelStr *this)
{
  return 1;
}

uint64_t KB::LanguageModel::supports_prediction(KB::LanguageModel *this)
{
  return 1;
}

uint64_t KB::LanguageModelStr::lexicon_id(KB::LanguageModelStr *this)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int *v4;
  unsigned int *v5;

  (*(void (**)(unsigned int **__return_ptr))(*(_QWORD *)this + 48))(&v4);
  if (v5 != v4)
  {
    v1 = *v4;
LABEL_4:
    v5 = v4;
    operator delete(v4);
    return v1;
  }
  v1 = 0;
  v2 = 0;
  if (v5)
    goto LABEL_4;
  return v2;
}

__n128 KB::LanguageModelStr::lexicon_id_vector@<Q0>(KB::LanguageModelStr *this@<X0>, std::vector<unsigned int> *a2@<X8>)
{
  const __CFArray *LanguageLocales;
  unint64_t v5;
  CFIndex v6;
  const void *ValueAtIndex;
  const __CFString *v8;
  char *v9;
  int v10;
  int v11;
  unint64_t v12;
  __n128 v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  int v21;
  __n128 result;
  __n128 *v23;
  __n128 v24;
  _DWORD *v25;
  unint64_t v26;
  void *__p[2];
  char v28;

  if (((*(uint64_t (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 16))(this) & 1) != 0)
  {
    v23 = (__n128 *)a2;
    LanguageLocales = (const __CFArray *)language_modeling::v1::LanguageModel::getLanguageLocales(*((language_modeling::v1::LanguageModel **)this
                                                                                                  + 21));
    v5 = 0;
    v6 = 0;
    v24 = 0u;
    while (CFArrayGetCount(LanguageLocales) > v6)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(LanguageLocales, v6);
      v8 = (const __CFString *)MEMORY[0x1DF0A08CC](ValueAtIndex);
      if (v8)
      {
        KB::std_string(v8, __p);
        if (v28 >= 0)
          v9 = (char *)__p;
        else
          v9 = (char *)__p[0];
        v10 = TILexiconIDForLocaleIdentifier(v9);
        v11 = v10;
        v12 = v24.n128_u64[1];
        v13.n128_u64[0] = v24.n128_u64[0];
        if (v24.n128_u64[1] >= v5)
        {
          v15 = (void *)v24.n128_u64[0];
          v16 = (uint64_t)(v24.n128_u64[1] - v24.n128_u64[0]) >> 2;
          v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 62)
            abort();
          if ((uint64_t)(v5 - v24.n128_u64[0]) >> 1 > v17)
            v17 = (uint64_t)(v5 - v24.n128_u64[0]) >> 1;
          if (v5 - v24.n128_u64[0] >= 0x7FFFFFFFFFFFFFFCLL)
            v18 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v18 = v17;
          if (v18)
            v18 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v18);
          else
            v19 = 0;
          v20 = (_DWORD *)(v18 + 4 * v16);
          *v20 = v11;
          v14 = (uint64_t)(v20 + 1);
          while (v12 != v24.n128_u64[0])
          {
            v21 = *(_DWORD *)(v12 - 4);
            v12 -= 4;
            *--v20 = v21;
          }
          v5 = v18 + 4 * v19;
          v13.n128_u64[0] = (unint64_t)v20;
          if (v24.n128_u64[0])
          {
            v25 = v20;
            operator delete(v15);
            v13.n128_u64[0] = (unint64_t)v25;
          }
        }
        else
        {
          *(_DWORD *)v24.n128_u64[1] = v10;
          v14 = v24.n128_u64[1] + 4;
        }
        if (v28 < 0)
        {
          v26 = v13.n128_u64[0];
          operator delete(__p[0]);
          v13.n128_u64[0] = v26;
        }
        v13.n128_u64[1] = v14;
      }
      else
      {
        v13 = v24;
      }
      v24 = v13;
      ++v6;
    }
    result = v24;
    *v23 = v24;
    v23[1].n128_u64[0] = v5;
  }
  else
  {
    std::vector<unsigned int>::vector(a2, (const std::vector<unsigned int> *)((char *)this + 104));
  }
  return result;
}

CFIndex KB::LanguageModelStr::active_locale_identifiers_vector@<X0>(language_modeling::v1::LanguageModel **this@<X0>, uint64_t **a2@<X8>)
{
  CFIndex result;
  const __CFArray *LanguageLocales;
  uint64_t *v6;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  result = (*((uint64_t (**)(language_modeling::v1::LanguageModel **))*this + 2))(this);
  if ((_DWORD)result)
  {
    LanguageLocales = (const __CFArray *)language_modeling::v1::LanguageModel::getLanguageLocales(this[21]);
    v6 = 0;
    for (i = 0; ; ++i)
    {
      result = CFArrayGetCount(LanguageLocales);
      if (result <= i)
        break;
      ValueAtIndex = CFArrayGetValueAtIndex(LanguageLocales, i);
      v9 = MEMORY[0x1DF0A08CC](ValueAtIndex);
      if (v9)
      {
        v10 = v9;
        v11 = (unint64_t)a2[2];
        if ((unint64_t)v6 >= v11)
        {
          v13 = *a2;
          v14 = v6 - *a2;
          v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 61)
            abort();
          v16 = v11 - (_QWORD)v13;
          if (v16 >> 2 > v15)
            v15 = v16 >> 2;
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
            v17 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v17 = v15;
          if (v17)
            v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v17);
          else
            v18 = 0;
          v19 = (uint64_t *)(v17 + 8 * v14);
          *v19 = v10;
          v12 = v19 + 1;
          if (v6 != v13)
          {
            do
            {
              v20 = *--v6;
              *--v19 = v20;
            }
            while (v6 != v13);
            v6 = *a2;
          }
          *a2 = v19;
          a2[1] = v12;
          a2[2] = (uint64_t *)(v17 + 8 * v18);
          if (v6)
            operator delete(v6);
        }
        else
        {
          *v6 = v9;
          v12 = v6 + 1;
        }
        a2[1] = v12;
        v6 = v12;
      }
    }
  }
  return result;
}

void KB::LanguageModelStr::load(KB::LanguageModelStr *this, int a2)
{
  KB::LanguageModelStr *v3;
  const __CFLocale *v4;
  _OWORD *v5;
  char v6;
  _OWORD *v7;
  _OWORD *v8;
  uint64_t v9;
  _BYTE *v10;
  _OWORD *v11;
  _OWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  _OWORD *v15;
  _OWORD *v16;
  uint64_t v17;
  _BYTE *v18;
  _OWORD *v19;
  char **v20;
  char **v21;
  int v22;
  _OWORD *v23;
  char v24;
  _OWORD *v25;
  _OWORD *v26;
  uint64_t v27;
  _BYTE *v28;
  _OWORD *v29;
  _OWORD *v30;
  uint64_t v31;
  _BYTE *v32;
  const __CFArray *v33;
  CFIndex Count;
  CFIndex v35;
  CFIndex v36;
  KB *ValueAtIndex;
  const __CFLocale *v38;
  __n128 *v39;
  __n128 v40;
  unint64_t v41;
  unint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  std::string *v46;
  std::string *v47;
  __n128 v48;
  uint64_t v49;
  uint64_t v50;
  std::string *v51;
  __int128 v52;
  int64x2_t v53;
  std::string *v54;
  __n128 *v55;
  _BOOL4 v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  std::string::size_type size;
  std::string *v61;
  int v62;
  std::__split_buffer<std::string>::pointer p_p;
  std::string *v64;
  int v65;
  const std::string::value_type *v66;
  std::string::size_type v67;
  std::string *v68;
  std::string::size_type v69;
  _OWORD *v70;
  char *v71;
  int v72;
  int v73;
  _OWORD *v74;
  _OWORD *v75;
  _OWORD *v76;
  uint64_t v77;
  _BYTE *v78;
  const __CFArray *v79;
  const __CFString *v80;
  char *begin;
  char *v82;
  _OWORD *v83;
  _OWORD *v84;
  _OWORD *v85;
  uint64_t v86;
  _BYTE *v87;
  char **v88;
  const void *v89;
  const __CFString *v90;
  const char *v91;
  char *p_end;
  char *v93;
  _OWORD *v94;
  const char *v95;
  unsigned __int16 *v96;
  char *v97;
  char *v98;
  _OWORD *v99;
  char *v100;
  char *v101;
  _OWORD *v102;
  _OWORD *v103;
  const __CFDictionary *v104;
  _OWORD *v105;
  uint64_t v106;
  _OWORD *v107;
  _OWORD *v108;
  uint64_t v109;
  int v110;
  _OWORD *v111;
  _OWORD *v112;
  int v113;
  std::string::value_type *v114;
  _OWORD *v115;
  char *v116;
  _OWORD *v117;
  uint64_t v118;
  _OWORD *v119;
  _OWORD *v120;
  uint64_t v121;
  uint64_t **v122;
  __int128 *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  _QWORD *v127;
  __int128 *v128;
  _QWORD *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t **leaf_high;
  __int128 *v133;
  BOOL v134;
  _QWORD *v135;
  _QWORD *i;
  char *v137;
  uint64_t **v138;
  __int128 *v139;
  __int128 *v140;
  language_modeling::v1::LanguageModel *v141;
  void *SharedVocabulary;
  NSObject *v143;
  const __CFLocale *v144;
  void *v145;
  void *v146;
  const void *v147;
  NSObject *v148;
  const __CFLocale *v149;
  __n128 *v150;
  __n128 *v151;
  int v152;
  KB::LanguageModelConfig *v153;
  KB::LanguageModelStr *v154;
  int v155;
  _QWORD **v156;
  _QWORD *v157[2];
  id v158;
  std::string v159;
  std::string __str;
  int64x2_t v161;
  std::string *v162;
  __int128 *v163;
  __int128 v164;
  _OWORD *v165;
  std::__split_buffer<std::string> __p;
  _BYTE buf[12];
  __int16 v168;
  __n128 *v169;
  char v170;
  __n128 v171;
  std::string *v172;
  __n128 v173;
  int64_t v174;
  char v175;
  uint64_t v176;

  v3 = this;
  v176 = *MEMORY[0x1E0C80C00];
  if (((*(uint64_t (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 16))(this) & 1) != 0)
    return;
  atomic_store(0, (unsigned __int8 *)v3 + 216);
  atomic_store(0, (unsigned __int8 *)v3 + 217);
  v164 = 0uLL;
  v163 = &v164;
  KB::string_from_locale(*((KB **)v3 + 1), v4, &__p);
  std::string::basic_string[abi:nn180100]<0>(&v173, (char *)*MEMORY[0x1E0D430C0]);
  v171.n128_u64[0] = (unint64_t)&v173;
  v5 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &v173, &v171);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v5 + 56), (uint64_t)v5 + 56, (__n128 *)&__p);
  if (SHIBYTE(v174) < 0)
    operator delete((void *)v173.n128_u64[0]);
  if (SHIBYTE(__p.__end_) < 0)
    operator delete(__p.__first_);
  v6 = *((_BYTE *)v3 + 80);
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D430F8]);
  v173.n128_u64[0] = (unint64_t)&__p;
  v7 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
  v8 = v7;
  v9 = *((unsigned int *)v7 + 20);
  if ((_DWORD)v9 != -1)
  {
    v10 = (char *)v7 + 56;
    if (!(_DWORD)v9)
    {
      *v10 = v6;
      goto LABEL_11;
    }
    ((void (*)(__n128 *, _BYTE *))off_1EA0FA7D8[v9])(&v173, v10);
  }
  *((_BYTE *)v8 + 56) = v6;
  *((_DWORD *)v8 + 20) = 0;
LABEL_11:
  if (SHIBYTE(__p.__end_) < 0)
    operator delete(__p.__first_);
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D43128]);
  v173.n128_u64[0] = (unint64_t)&__p;
  v11 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
  v12 = v11;
  v13 = *((unsigned int *)v11 + 20);
  if ((_DWORD)v13 != -1)
  {
    v14 = (char *)v11 + 56;
    if (!(_DWORD)v13)
    {
      *v14 = 1;
      goto LABEL_18;
    }
    ((void (*)(__n128 *, _BYTE *))off_1EA0FA7D8[v13])(&v173, v14);
  }
  *((_BYTE *)v12 + 56) = 1;
  *((_DWORD *)v12 + 20) = 0;
LABEL_18:
  if (SHIBYTE(__p.__end_) < 0)
    operator delete(__p.__first_);
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D43040]);
  v173.n128_u64[0] = (unint64_t)&__p;
  v15 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
  v16 = v15;
  v17 = *((unsigned int *)v15 + 20);
  if ((_DWORD)v17 != -1)
  {
    v18 = (char *)v15 + 56;
    if (!(_DWORD)v17)
    {
      *v18 = 1;
      goto LABEL_25;
    }
    ((void (*)(__n128 *, _BYTE *))off_1EA0FA7D8[v17])(&v173, v18);
  }
  *((_BYTE *)v16 + 56) = 1;
  *((_DWORD *)v16 + 20) = 0;
LABEL_25:
  if (SHIBYTE(__p.__end_) < 0)
    operator delete(__p.__first_);
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D43158]);
  v173.n128_u64[0] = (unint64_t)&__p;
  v19 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,char const*&>((uint64_t)v19 + 56, (std::string *)((char *)v19 + 56), MEMORY[0x1E0D43160]);
  if (SHIBYTE(__p.__end_) < 0)
    operator delete(__p.__first_);
  v20 = (char **)MEMORY[0x1E0D43170];
  v21 = (char **)MEMORY[0x1E0D43178];
  v22 = *((_DWORD *)v3 + 24);
  if (v22 != 80)
    v21 = (char **)MEMORY[0x1E0D43180];
  if (v22 != 70)
    v20 = v21;
  std::string::basic_string[abi:nn180100]<0>(&__p, *v20);
  std::string::basic_string[abi:nn180100]<0>(&v173, (char *)*MEMORY[0x1E0D43188]);
  v171.n128_u64[0] = (unint64_t)&v173;
  v23 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &v173, &v171);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v23 + 56), (uint64_t)v23 + 56, (__n128 *)&__p);
  if (SHIBYTE(v174) < 0)
    operator delete((void *)v173.n128_u64[0]);
  if (SHIBYTE(__p.__end_) < 0)
    operator delete(__p.__first_);
  v24 = *((_BYTE *)v3 + 81);
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D43048]);
  v173.n128_u64[0] = (unint64_t)&__p;
  v25 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
  v26 = v25;
  v27 = *((unsigned int *)v25 + 20);
  if ((_DWORD)v27 != -1)
  {
    v28 = (char *)v25 + 56;
    if (!(_DWORD)v27)
    {
      *v28 = v24;
      goto LABEL_42;
    }
    ((void (*)(__n128 *, _BYTE *))off_1EA0FA7D8[v27])(&v173, v28);
  }
  *((_BYTE *)v26 + 56) = v24;
  *((_DWORD *)v26 + 20) = 0;
LABEL_42:
  if (SHIBYTE(__p.__end_) < 0)
  {
    operator delete(__p.__first_);
    if ((a2 & 1) != 0)
      goto LABEL_53;
  }
  else if ((a2 & 1) != 0)
  {
    goto LABEL_53;
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D43058]);
  v173.n128_u64[0] = (unint64_t)&__p;
  v29 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
  v30 = v29;
  v31 = *((unsigned int *)v29 + 20);
  if ((_DWORD)v31 != -1)
  {
    v32 = (char *)v29 + 56;
    if (!(_DWORD)v31)
    {
      *v32 = 1;
      goto LABEL_51;
    }
    ((void (*)(__n128 *, _BYTE *))off_1EA0FA7D8[v31])(&v173, v32);
  }
  *((_BYTE *)v30 + 56) = 1;
  *((_DWORD *)v30 + 20) = 0;
LABEL_51:
  if (SHIBYTE(__p.__end_) < 0)
    operator delete(__p.__first_);
LABEL_53:
  v161 = 0uLL;
  v162 = 0;
  v33 = (const __CFArray *)*((_QWORD *)v3 + 2);
  v154 = v3;
  v153 = (KB::LanguageModelStr *)((char *)v3 + 8);
  v152 = a2;
  if (v33 && (Count = CFArrayGetCount(v33), Count >= 1))
  {
    v35 = Count;
    v36 = 0;
    v155 = 0;
    do
    {
      ValueAtIndex = (KB *)CFArrayGetValueAtIndex(*((CFArrayRef *)v3 + 2), v36);
      KB::string_from_locale(ValueAtIndex, v38, &v173);
      v39 = (__n128 *)v161.i64[1];
      if (v161.i64[1] >= (unint64_t)v162)
      {
        v41 = 0xAAAAAAAAAAAAAAABLL * ((v161.i64[1] - v161.i64[0]) >> 3) + 1;
        if (v41 > 0xAAAAAAAAAAAAAAALL)
          abort();
        if (0x5555555555555556 * (((uint64_t)v162 - v161.i64[0]) >> 3) > v41)
          v41 = 0x5555555555555556 * (((uint64_t)v162 - v161.i64[0]) >> 3);
        if (0xAAAAAAAAAAAAAAABLL * (((uint64_t)v162 - v161.i64[0]) >> 3) >= 0x555555555555555)
          v42 = 0xAAAAAAAAAAAAAAALL;
        else
          v42 = v41;
        __p.__end_cap_.__value_ = (std::allocator<std::string> *)&v162;
        if (v42)
        {
          v43 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v42);
          v45 = v44;
        }
        else
        {
          v43 = 0;
          v45 = 0;
        }
        v47 = (std::string *)&v43[8 * ((v161.i64[1] - v161.i64[0]) >> 3)];
        if (SHIBYTE(v174) < 0)
        {
          std::string::__init_copy_ctor_external(v47, (const std::string::value_type *)v173.n128_u64[0], v173.n128_u64[1]);
        }
        else
        {
          v48 = v173;
          v47->__r_.__value_.__r.__words[2] = v174;
          *(__n128 *)&v47->__r_.__value_.__l.__data_ = v48;
        }
        v49 = v161.i64[1];
        v50 = v161.i64[0];
        if (v161.i64[1] == v161.i64[0])
        {
          v53 = vdupq_n_s64(v161.u64[1]);
          v51 = v47;
        }
        else
        {
          v51 = v47;
          do
          {
            v52 = *(_OWORD *)(v49 - 24);
            v51[-1].__r_.__value_.__r.__words[2] = *(_QWORD *)(v49 - 8);
            *(_OWORD *)&v51[-1].__r_.__value_.__l.__data_ = v52;
            --v51;
            *(_QWORD *)(v49 - 16) = 0;
            *(_QWORD *)(v49 - 8) = 0;
            *(_QWORD *)(v49 - 24) = 0;
            v49 -= 24;
          }
          while (v49 != v50);
          v53 = v161;
        }
        v46 = v47 + 1;
        v161.i64[0] = (uint64_t)v51;
        v161.i64[1] = (uint64_t)v46;
        *(int64x2_t *)&__p.__begin_ = v53;
        v54 = v162;
        v162 = (std::string *)&v43[24 * v45];
        __p.__end_cap_.__value_ = v54;
        __p.__first_ = (std::__split_buffer<std::string>::pointer)v53.i64[0];
        std::__split_buffer<std::string>::~__split_buffer(&__p);
        v3 = v154;
      }
      else
      {
        if (SHIBYTE(v174) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)v161.i64[1], (const std::string::value_type *)v173.n128_u64[0], v173.n128_u64[1]);
        }
        else
        {
          v40 = v173;
          *(_QWORD *)(v161.i64[1] + 16) = v174;
          *v39 = v40;
        }
        v46 = (std::string *)&v39[1].n128_i8[8];
      }
      v161.i64[1] = (uint64_t)v46;
      if (v174 >= 0)
        v55 = &v173;
      else
        v55 = (__n128 *)v173.n128_u64[0];
      v56 = TIMultilingualDynamicModelEnabled((char *)v55);
      v57 = v155;
      if (v56)
        v57 = 1;
      v155 = v57;
      if (SHIBYTE(v174) < 0)
        operator delete((void *)v173.n128_u64[0]);
      ++v36;
    }
    while (v36 != v35);
  }
  else
  {
    LOBYTE(v155) = 0;
  }
  std::string::basic_string[abi:nn180100]<0>(&__str, "");
  v58 = v161.i64[1];
  if (v161.i64[1] != v161.i64[0])
  {
    v59 = v161.i64[0] + 24;
    if (*(char *)(v161.i64[0] + 23) < 0)
      std::string::__init_copy_ctor_external(&v159, *(const std::string::value_type **)v161.i64[0], *(_QWORD *)(v161.i64[0] + 8));
    else
      v159 = *(std::string *)v161.i64[0];
    if (v59 != v58)
    {
      size = HIBYTE(v159.__r_.__value_.__r.__words[2]);
      v61 = (std::string *)v159.__r_.__value_.__r.__words[0];
      while (1)
      {
        v62 = (char)size;
        if ((size & 0x80u) != 0)
          size = v159.__r_.__value_.__l.__size_;
        std::string::basic_string[abi:nn180100]((uint64_t)&__p, size + 1);
        if (SHIBYTE(__p.__end_) >= 0)
          p_p = (std::__split_buffer<std::string>::pointer)&__p;
        else
          p_p = __p.__first_;
        if (size)
        {
          if (v62 >= 0)
            v64 = &v159;
          else
            v64 = v61;
          memmove(p_p, v64, size);
        }
        *(_WORD *)((char *)&p_p->__r_.__value_.__l.__data_ + size) = 44;
        v65 = *(char *)(v59 + 23);
        if (v65 >= 0)
          v66 = (const std::string::value_type *)v59;
        else
          v66 = *(const std::string::value_type **)v59;
        if (v65 >= 0)
          v67 = *(unsigned __int8 *)(v59 + 23);
        else
          v67 = *(_QWORD *)(v59 + 8);
        v68 = std::string::append((std::string *)&__p, v66, v67);
        v69 = v68->__r_.__value_.__r.__words[0];
        v173.n128_u64[0] = v68->__r_.__value_.__l.__size_;
        *(unint64_t *)((char *)v173.n128_u64 + 7) = *(std::string::size_type *)((char *)&v68->__r_.__value_.__r.__words[1]
                                                                                     + 7);
        size = HIBYTE(v68->__r_.__value_.__r.__words[2]);
        v68->__r_.__value_.__r.__words[0] = 0;
        v68->__r_.__value_.__l.__size_ = 0;
        v68->__r_.__value_.__r.__words[2] = 0;
        if (SHIBYTE(__p.__end_) < 0)
        {
          operator delete(__p.__first_);
          if (v62 < 0)
LABEL_116:
            operator delete(v61);
        }
        else if (v62 < 0)
        {
          goto LABEL_116;
        }
        v159.__r_.__value_.__r.__words[0] = v69;
        v159.__r_.__value_.__l.__size_ = v173.n128_u64[0];
        *(std::string::size_type *)((char *)&v159.__r_.__value_.__r.__words[1] + 7) = *(unint64_t *)((char *)v173.n128_u64 + 7);
        *((_BYTE *)&v159.__r_.__value_.__s + 23) = size;
        v59 += 24;
        v61 = (std::string *)v69;
        if (v59 == v58)
          goto LABEL_118;
      }
    }
    v69 = v159.__r_.__value_.__r.__words[0];
    LOBYTE(size) = *((_BYTE *)&v159.__r_.__value_.__s + 23);
LABEL_118:
    __p.__first_ = (std::__split_buffer<std::string>::pointer)v159.__r_.__value_.__l.__size_;
    *(std::__split_buffer<std::string>::pointer *)((char *)&__p.__first_ + 7) = *(std::__split_buffer<std::string>::pointer *)((char *)&v159.__r_.__value_.__r.__words[1] + 7);
    memset(&v159, 0, sizeof(v159));
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    __str.__r_.__value_.__r.__words[0] = v69;
    __str.__r_.__value_.__l.__size_ = (std::string::size_type)__p.__first_;
    *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)&__p.__first_ + 7);
    *((_BYTE *)&__str.__r_.__value_.__s + 23) = size;
    v3 = v154;
  }
  std::string::basic_string[abi:nn180100]<0>(&v173, (char *)*MEMORY[0x1E0D43088]);
  __p.__first_ = (std::__split_buffer<std::string>::pointer)&v173;
  v70 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &v173, &__p);
  v71 = (char *)v70 + 56;
  v72 = *((_DWORD *)v70 + 20);
  if (v72 == 1)
  {
    std::string::operator=((std::string *)((char *)v70 + 56), &__str);
    v73 = v152;
  }
  else
  {
    v74 = v70;
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)&__p, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
      v72 = *((_DWORD *)v74 + 20);
    }
    else
    {
      *(_OWORD *)&__p.__first_ = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
      __p.__end_ = (std::__split_buffer<std::string>::pointer)__str.__r_.__value_.__r.__words[2];
    }
    v73 = v152;
    if (v72 != -1)
      ((void (*)(__n128 *, char *))off_1EA0FA7D8[v72])(&v171, v71);
    *(_OWORD *)v71 = *(_OWORD *)&__p.__first_;
    *((_QWORD *)v71 + 2) = __p.__end_;
    *((_DWORD *)v74 + 20) = 1;
  }
  if (SHIBYTE(v174) < 0)
    operator delete((void *)v173.n128_u64[0]);
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D43120]);
  v173.n128_u64[0] = (unint64_t)&__p;
  v75 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
  v76 = v75;
  v77 = *((unsigned int *)v75 + 20);
  if ((_DWORD)v77 != -1)
  {
    v78 = (char *)v75 + 56;
    if (!(_DWORD)v77)
    {
      *v78 = v155;
      goto LABEL_136;
    }
    ((void (*)(__n128 *, _BYTE *))off_1EA0FA7D8[v77])(&v173, v78);
  }
  *((_BYTE *)v76 + 56) = v155;
  *((_DWORD *)v76 + 20) = 0;
LABEL_136:
  if (SHIBYTE(__p.__end_) < 0)
    operator delete(__p.__first_);
  v79 = (const __CFArray *)*((_QWORD *)v3 + 4);
  if (v79 && CFArrayGetCount(*((CFArrayRef *)v3 + 4)) >= 1)
  {
    v80 = CFStringCreateByCombiningStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v79, CFSTR(","));
    KB::utf8_string(v80, (uint64_t)&__p);
    begin = (char *)__p.__begin_;
    if (!__p.__begin_)
      begin = (char *)&__p.__end_;
    if (LOWORD(__p.__first_))
      v82 = begin;
    else
      v82 = "";
    std::string::basic_string[abi:nn180100]<0>(&v173, v82);
    std::string::basic_string[abi:nn180100]<0>(&v171, (char *)*MEMORY[0x1E0D43130]);
    *(_QWORD *)buf = &v171;
    v83 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &v171, (_OWORD **)buf);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v83 + 56), (uint64_t)v83 + 56, &v173);
    if (SHIBYTE(v172) < 0)
      operator delete((void *)v171.n128_u64[0]);
    if (SHIBYTE(v174) < 0)
      operator delete((void *)v173.n128_u64[0]);
    if (__p.__begin_ && BYTE6(__p.__first_) == 1)
      free(__p.__begin_);
    std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D430D8]);
    v173.n128_u64[0] = (unint64_t)&__p;
    v84 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
    v85 = v84;
    v86 = *((unsigned int *)v84 + 20);
    if ((_DWORD)v86 != -1)
    {
      v87 = (char *)v84 + 56;
      if (!(_DWORD)v86)
      {
        *v87 = 1;
LABEL_157:
        if (SHIBYTE(__p.__end_) < 0)
          operator delete(__p.__first_);
        if (v80)
          CFRelease(v80);
        goto LABEL_161;
      }
      ((void (*)(__n128 *, _BYTE *))off_1EA0FA7D8[v86])(&v173, v87);
    }
    *((_BYTE *)v85 + 56) = 1;
    *((_DWORD *)v85 + 20) = 0;
    goto LABEL_157;
  }
LABEL_161:
  v88 = (char **)MEMORY[0x1E0D430B0];
  if (*((_QWORD *)v3 + 5))
  {
    v89 = CFArrayGetValueAtIndex(*((CFArrayRef *)v3 + 2), 0);
    v90 = (const __CFString *)MEMORY[0x1DF0A08CC](v89);
    KB::utf8_string(v90, (uint64_t)&v173);
    if (*((_BYTE *)v3 + 81))
      v91 = "Siri-TextInput-Dynamic.";
    else
      v91 = "TextInput-Dynamic.";
    KB::String::String((KB::String *)&__p, v91);
    KB::String::append((unsigned __int16 *)&__p, (const KB::String *)&v173);
    if (v173.n128_u64[1] && v173.n128_u8[6] == 1)
      free((void *)v173.n128_u64[1]);
    p_end = (char *)__p.__begin_;
    if (!__p.__begin_)
      p_end = (char *)&__p.__end_;
    if (LOWORD(__p.__first_))
      v93 = p_end;
    else
      v93 = "";
    std::string::basic_string[abi:nn180100]<0>(&v173, v93);
    std::string::basic_string[abi:nn180100]<0>(&v171, (char *)*MEMORY[0x1E0D430E8]);
    *(_QWORD *)buf = &v171;
    v94 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &v171, (_OWORD **)buf);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v94 + 56), (uint64_t)v94 + 56, &v173);
    if (SHIBYTE(v172) < 0)
      operator delete((void *)v171.n128_u64[0]);
    if (SHIBYTE(v174) < 0)
      operator delete((void *)v173.n128_u64[0]);
    if ((_BYTE)v155)
    {
      KB::String::String((KB::String *)&v171, "mul");
      if (*((_BYTE *)v3 + 81))
        v95 = "Siri-TextInput-Dynamic.";
      else
        v95 = "TextInput-Dynamic.";
      v96 = (unsigned __int16 *)KB::String::String((KB::String *)&v173, v95);
      KB::String::append(v96, (const KB::String *)&v171);
      if (v171.n128_u64[1] && v171.n128_u8[6] == 1)
        free((void *)v171.n128_u64[1]);
      v97 = (char *)v173.n128_u64[1];
      if (!v173.n128_u64[1])
        v97 = (char *)&v174;
      if (v173.n128_u16[0])
        v98 = v97;
      else
        v98 = "";
      std::string::basic_string[abi:nn180100]<0>(&v171, v98);
      std::string::basic_string[abi:nn180100]<0>(buf, (char *)*MEMORY[0x1E0D43138]);
      v165 = buf;
      v99 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, buf, &v165);
      std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v99 + 56), (uint64_t)v99 + 56, &v171);
      if (v170 < 0)
        operator delete(*(void **)buf);
      if (SHIBYTE(v172) < 0)
        operator delete((void *)v171.n128_u64[0]);
      if (v173.n128_u64[1] && v173.n128_u8[6] == 1)
        free((void *)v173.n128_u64[1]);
    }
    KB::utf8_string(*((const __CFString **)v3 + 5), (uint64_t)&v173);
    v100 = (char *)v173.n128_u64[1];
    if (!v173.n128_u64[1])
      v100 = (char *)&v174;
    if (v173.n128_u16[0])
      v101 = v100;
    else
      v101 = "";
    std::string::basic_string[abi:nn180100]<0>(&v171, v101);
    std::string::basic_string[abi:nn180100]<0>(buf, (char *)*MEMORY[0x1E0D43148]);
    v165 = buf;
    v102 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, buf, &v165);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v102 + 56), (uint64_t)v102 + 56, &v171);
    if (v170 < 0)
      operator delete(*(void **)buf);
    if (SHIBYTE(v172) < 0)
      operator delete((void *)v171.n128_u64[0]);
    if (v173.n128_u64[1] && v173.n128_u8[6] == 1)
      free((void *)v173.n128_u64[1]);
    std::string::basic_string[abi:nn180100]<0>(&v173, *v88);
    v171.n128_u64[0] = (unint64_t)&v173;
    v103 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &v173, &v171);
    v105 = v103;
    v106 = *((unsigned int *)v103 + 20);
    if ((_DWORD)v106 != -1)
    {
      v104 = (const __CFDictionary *)((char *)v103 + 56);
      if (!(_DWORD)v106)
      {
        *(_BYTE *)v104 = 1;
LABEL_216:
        if (SHIBYTE(v174) < 0)
          operator delete((void *)v173.n128_u64[0]);
        if (__p.__begin_ && BYTE6(__p.__first_) == 1)
          free(__p.__begin_);
        goto LABEL_225;
      }
      ((void (*)(__n128 *, const __CFDictionary *))off_1EA0FA7D8[v106])(&v171, v104);
    }
    *((_BYTE *)v105 + 56) = 1;
    *((_DWORD *)v105 + 20) = 0;
    goto LABEL_216;
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D430B0]);
  v173.n128_u64[0] = (unint64_t)&__p;
  v107 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
  v108 = v107;
  v109 = *((unsigned int *)v107 + 20);
  if ((_DWORD)v109 != -1)
  {
    v104 = (const __CFDictionary *)((char *)v107 + 56);
    if (!(_DWORD)v109)
    {
      *(_BYTE *)v104 = 0;
      goto LABEL_223;
    }
    ((void (*)(__n128 *, const __CFDictionary *))off_1EA0FA7D8[v109])(&v173, v104);
  }
  *((_BYTE *)v108 + 56) = 0;
  *((_DWORD *)v108 + 20) = 0;
LABEL_223:
  if (SHIBYTE(__p.__end_) < 0)
    operator delete(__p.__first_);
LABEL_225:
  if (v73 && *((_BYTE *)v3 + 92))
  {
    v110 = s_use_lm_transformer;
    if (s_use_lm_transformer)
    {
      if (*((_DWORD *)v3 + 17) == 1 || !*((_DWORD *)v3 + 18))
      {
        std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D43150]);
        v173.n128_u64[0] = (unint64_t)&__p;
        v111 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
        std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,char const*&>((uint64_t)v111 + 56, (std::string *)((char *)v111 + 56), MEMORY[0x1E0D43070]);
        if (SHIBYTE(__p.__end_) < 0)
          operator delete(__p.__first_);
        v110 = s_use_lm_transformer;
      }
      if ((v110 == 2 || v110 == -1) && (*((_DWORD *)v3 + 17) == 1 || !*((_DWORD *)v3 + 18)))
      {
        std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D43140]);
        v173.n128_u64[0] = (unint64_t)&__p;
        v112 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
        std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,char const*&>((uint64_t)v112 + 56, (std::string *)((char *)v112 + 56), MEMORY[0x1E0D43070]);
        if (SHIBYTE(__p.__end_) < 0)
          operator delete(__p.__first_);
      }
    }
    v113 = *((_DWORD *)v3 + 19);
    if (v113 != 2)
    {
      if (v113)
        v114 = "ToucanLanguageModelDisabled";
      else
        v114 = (std::string::value_type *)*MEMORY[0x1E0D43070];
      std::string::basic_string[abi:nn180100]<0>(&v173, (char *)*MEMORY[0x1E0D43168]);
      __p.__first_ = (std::__split_buffer<std::string>::pointer)&v173;
      v115 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &v173, &__p);
      v116 = (char *)v115 + 56;
      if (*((_DWORD *)v115 + 20) == 1)
      {
        std::string::__assign_external((std::string *)((char *)v115 + 56), v114);
      }
      else
      {
        v117 = v115;
        std::string::basic_string[abi:nn180100]<0>(&__p, v114);
        v118 = *((unsigned int *)v117 + 20);
        if ((_DWORD)v118 != -1)
          ((void (*)(__n128 *, char *))off_1EA0FA7D8[v118])(&v171, v116);
        *(_OWORD *)v116 = *(_OWORD *)&__p.__first_;
        *((_QWORD *)v116 + 2) = __p.__end_;
        *((_DWORD *)v117 + 20) = 1;
      }
      if (SHIBYTE(v174) < 0)
        operator delete((void *)v173.n128_u64[0]);
    }
  }
  if (*((_BYTE *)v3 + 82))
  {
    std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E0D43108]);
    v173.n128_u64[0] = (unint64_t)&__p;
    v119 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v163, &__p, &v173);
    v120 = v119;
    v121 = *((unsigned int *)v119 + 20);
    if ((_DWORD)v121 != -1)
    {
      v104 = (const __CFDictionary *)((char *)v119 + 56);
      if (!(_DWORD)v121)
      {
        *(_BYTE *)v104 = 1;
        goto LABEL_256;
      }
      ((void (*)(__n128 *, const __CFDictionary *))off_1EA0FA7D8[v121])(&v173, v104);
    }
    *((_BYTE *)v120 + 56) = 1;
    *((_DWORD *)v120 + 20) = 0;
LABEL_256:
    if (SHIBYTE(__p.__end_) < 0)
      operator delete(__p.__first_);
  }
  v122 = (uint64_t **)((char *)v3 + 280);
  if ((__int128 **)((char *)v3 + 280) != &v163)
  {
    v123 = v163;
    if (*((_QWORD *)v3 + 37))
    {
      v124 = *((_QWORD *)v3 + 35);
      v125 = *((_QWORD *)v3 + 36);
      *((_QWORD *)v3 + 35) = (char *)v3 + 288;
      *(_QWORD *)(v125 + 16) = 0;
      *((_QWORD *)v3 + 36) = 0;
      *((_QWORD *)v3 + 37) = 0;
      if (*(_QWORD *)(v124 + 8))
        v126 = *(_QWORD *)(v124 + 8);
      else
        v126 = v124;
      if (v126)
      {
        v127 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::_DetachedTreeCache::__detach_next(v126);
        if (v123 != &v164)
        {
          v128 = v123;
          while (1)
          {
            v129 = v127;
            std::string::operator=((std::string *)(v126 + 32), (const std::string *)(v128 + 2));
            v130 = *(unsigned int *)(v126 + 80);
            v131 = *((unsigned int *)v128 + 20);
            if ((_DWORD)v130 == -1)
            {
              if ((_DWORD)v131 != -1)
              {
LABEL_270:
                __p.__first_ = (std::__split_buffer<std::string>::pointer)(v126 + 56);
                ((void (*)(std::__split_buffer<std::string> *, uint64_t, char *))*(&off_1EA0FA7F8 + v131))(&__p, v126 + 56, (char *)v128 + 56);
              }
            }
            else
            {
              if ((_DWORD)v131 != -1)
                goto LABEL_270;
              ((void (*)(std::__split_buffer<std::string> *, uint64_t))off_1EA0FA7D8[v130])(&__p, v126 + 56);
              *(_DWORD *)(v126 + 80) = -1;
            }
            leaf_high = (uint64_t **)std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__find_leaf_high((uint64_t)v122, &__p, (_QWORD *)(v126 + 32));
            std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(v122, (uint64_t)__p.__first_, leaf_high, (uint64_t *)v126);
            if (v127)
              v127 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::_DetachedTreeCache::__detach_next((uint64_t)v127);
            else
              v127 = 0;
            v3 = v154;
            v133 = (__int128 *)*((_QWORD *)v128 + 1);
            if (v133)
            {
              do
              {
                v123 = v133;
                v133 = *(__int128 **)v133;
              }
              while (v133);
            }
            else
            {
              do
              {
                v123 = (__int128 *)*((_QWORD *)v128 + 2);
                v134 = *(_QWORD *)v123 == (_QWORD)v128;
                v128 = v123;
              }
              while (!v134);
            }
            if (v129)
            {
              v126 = (uint64_t)v129;
              v128 = v123;
              if (v123 != &v164)
                continue;
            }
            goto LABEL_284;
          }
        }
        v129 = (_QWORD *)v126;
        v123 = &v164;
LABEL_284:
        std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(v129);
        if (!v127)
          goto LABEL_289;
        for (i = (_QWORD *)v127[2]; i; i = (_QWORD *)i[2])
          v127 = i;
        v135 = v127;
      }
      else
      {
        v135 = 0;
      }
      std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(v135);
    }
LABEL_289:
    if (v123 != &v164)
    {
      do
      {
        v137 = (char *)operator new(0x58uLL);
        __p.__begin_ = (std::__split_buffer<std::string>::pointer)((char *)v3 + 288);
        std::pair<std::string const,std::variant<BOOL,std::string>>::pair[abi:nn180100]((std::string *)(v137 + 32), v123 + 2);
        LOBYTE(__p.__end_) = 1;
        v138 = (uint64_t **)std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__find_leaf_high((uint64_t)v122, &v173, (_QWORD *)v137 + 4);
        std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(v122, v173.n128_i64[0], v138, (uint64_t *)v137);
        __p.__first_ = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)&__p);
        v139 = (__int128 *)*((_QWORD *)v123 + 1);
        if (v139)
        {
          do
          {
            v140 = v139;
            v139 = *(__int128 **)v139;
          }
          while (v139);
        }
        else
        {
          do
          {
            v140 = (__int128 *)*((_QWORD *)v123 + 2);
            v134 = *(_QWORD *)v140 == (_QWORD)v123;
            v123 = v140;
          }
          while (!v134);
        }
        v123 = v140;
      }
      while (v140 != &v164);
    }
  }
  KB::LanguageModelConfig::trial_parameters(v153, v104, (uint64_t)&__p);
  language_modeling::v1::LanguageModel::init();
  std::__optional_destruct_base<LM::TrialParameters,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&__p);
  std::string::basic_string[abi:nn180100]<0>(&v171, "Success");
  LODWORD(__p.__first_) = 0;
  if (SHIBYTE(v172) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)&__p.__begin_, (const std::string::value_type *)v171.n128_u64[0], v171.n128_u64[1]);
    if (SHIBYTE(v172) < 0)
      operator delete((void *)v171.n128_u64[0]);
  }
  else
  {
    *(__n128 *)&__p.__begin_ = v171;
    __p.__end_cap_.__value_ = v172;
  }
  if (v173.n128_u32[0] | LODWORD(__p.__first_))
  {
    v157[0] = 0;
    v157[1] = 0;
    v156 = v157;
    std::map<std::string,std::variant<BOOL,std::string>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *> *,long>>>((uint64_t)&v156, v163, &v164);
    KB::LanguageModelStr::draft_radar_for_model_creation_failure((uint64_t)v3, (uint64_t)&v156, 0);
    std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(v157[0]);
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    v148 = TIOSLogFacility();
    if (os_log_type_enabled(v148, OS_LOG_TYPE_DEBUG))
    {
      KB::string_from_locale(*(KB **)v153, v149, &v171);
      v150 = SHIBYTE(v172) >= 0 ? &v171 : (__n128 *)v171.n128_u64[0];
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "load";
      v168 = 2080;
      v169 = v150;
      _os_log_debug_impl(&dword_1DA6F2000, v148, OS_LOG_TYPE_DEBUG, "%s Language model load for locale %s FAILED", buf, 0x16u);
      if (SHIBYTE(v172) < 0)
        operator delete((void *)v171.n128_u64[0]);
    }
  }
  else
  {
    KB::LanguageModelStr::__start_session((uint64_t)v3, *((_DWORD *)v3 + 16));
    v141 = (language_modeling::v1::LanguageModel *)*((_QWORD *)v3 + 21);
    SharedVocabulary = (void *)LMVocabularyGetSharedVocabulary();
    language_modeling::v1::LanguageModel::addVocabulary(v141, SharedVocabulary);
    language_modeling::v1::LanguageModel::wireMemory(*((language_modeling::v1::LanguageModel **)v3 + 21));
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    v143 = TIOSLogFacility();
    if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
    {
      KB::string_from_locale(*(KB **)v153, v144, &v171);
      v151 = SHIBYTE(v172) >= 0 ? &v171 : (__n128 *)v171.n128_u64[0];
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "load";
      v168 = 2080;
      v169 = v151;
      _os_log_debug_impl(&dword_1DA6F2000, v143, OS_LOG_TYPE_DEBUG, "%s Language model load for locale %s SUCCEEDED", buf, 0x16u);
      if (SHIBYTE(v172) < 0)
        operator delete((void *)v171.n128_u64[0]);
    }
    v145 = (void *)language_modeling::v1::LanguageModel::copyLinguisticDataFileInfo(*((language_modeling::v1::LanguageModel **)v3
                                                                                    + 21));
    v146 = v145;
    v158 = v145;
    if (v145)
    {
      CFRetain(v145);
      v158 = v146;
    }
    KB::createLanguageModelParameters(&v158, (uint64_t *)&v171);
    v147 = (const void *)*((_QWORD *)v3 + 34);
    if (v147)
      CFRelease(v147);
    *((_QWORD *)v3 + 34) = v171.n128_u64[0];
    if (v146)
    {
      CFRelease(v146);
      v158 = 0;
      atomic_store(1u, (unsigned __int8 *)v3 + 216);
      CFRelease(v146);
    }
    else
    {
      v158 = 0;
      atomic_store(1u, (unsigned __int8 *)v3 + 216);
    }
  }
  if (SHIBYTE(__p.__end_cap_.__value_) < 0)
    operator delete(__p.__begin_);
  if (v175 < 0)
    operator delete((void *)v173.n128_u64[1]);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  __p.__first_ = (std::__split_buffer<std::string>::pointer)&v161;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy((_QWORD *)v164);
}

void KB::LanguageModelStr::reload_with_locales(KB::LanguageModelStr *this, const __CFArray *a2)
{
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _BOOL4 v8;
  _QWORD **v9;
  _QWORD *v10[2];
  int v11;
  void *__p;
  char v13;
  uint8_t buf[4];
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if ((*(unsigned int (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 16))(this))
  {
    v4 = atomic_load((unsigned __int8 *)this + 217);
    if ((v4 & 1) == 0)
    {
      v5 = *((_QWORD *)this + 23);
      if (v5)
        atomic_store(1u, (unsigned __int8 *)(v5 + 752));
      std::mutex::lock(*((std::mutex **)this + 17));
      v6 = *((_QWORD *)this + 23);
      if (v6)
        atomic_store(0, (unsigned __int8 *)(v6 + 752));
      atomic_store(0, (unsigned __int8 *)this + 216);
      atomic_store(1u, (unsigned __int8 *)this + 217);
      language_modeling::v1::LanguageModel::reloadWithLocales(*((language_modeling::v1::LanguageModel **)this + 21), a2);
      if (TICanLogMessageAtLevel_onceToken != -1)
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
      v7 = TIOSLogFacility();
      v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG);
      if (v11)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136315138;
          v15 = "reload_with_locales";
          _os_log_debug_impl(&dword_1DA6F2000, v7, OS_LOG_TYPE_DEBUG, "%s Language model reload FAILED", buf, 0xCu);
        }
        v10[0] = 0;
        v10[1] = 0;
        v9 = v10;
        std::map<std::string,std::variant<BOOL,std::string>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *> *,long>>>((uint64_t)&v9, *((__int128 **)this + 35), (__int128 *)this + 18);
        KB::LanguageModelStr::draft_radar_for_model_creation_failure((uint64_t)this, (uint64_t)&v9, 1);
        std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(v10[0]);
      }
      else if (v8)
      {
        *(_DWORD *)buf = 136315138;
        v15 = "reload_with_locales";
        _os_log_debug_impl(&dword_1DA6F2000, v7, OS_LOG_TYPE_DEBUG, "%s Language model reload SUCCEEDED", buf, 0xCu);
      }
      atomic_store(1u, (unsigned __int8 *)this + 216);
      atomic_store(0, (unsigned __int8 *)this + 217);
      std::mutex::unlock(*((std::mutex **)this + 17));
      if (v13 < 0)
        operator delete(__p);
    }
  }
}

void KB::LanguageModelStr::clear_dynamic_learning_cache(KB::LanguageModelStr *this)
{
  uint64_t v2;
  uint64_t v3;

  if ((*(unsigned int (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 16))(this))
  {
    v2 = *((_QWORD *)this + 23);
    if (v2)
      atomic_store(1u, (unsigned __int8 *)(v2 + 752));
    std::mutex::lock(*((std::mutex **)this + 17));
    v3 = *((_QWORD *)this + 23);
    if (v3)
      atomic_store(0, (unsigned __int8 *)(v3 + 752));
    language_modeling::v1::LanguageModelSession::clearDynamicLearningCache(*((language_modeling::v1::LanguageModelSession **)this
                                                                           + 25));
    std::mutex::unlock(*((std::mutex **)this + 17));
  }
}

void KB::LanguageModelStr::clear_recent_text_cache(KB::LanguageModelStr *this)
{
  uint64_t v2;
  uint64_t v3;

  if ((*(unsigned int (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 16))(this))
  {
    v2 = *((_QWORD *)this + 23);
    if (v2)
      atomic_store(1u, (unsigned __int8 *)(v2 + 752));
    std::mutex::lock(*((std::mutex **)this + 17));
    v3 = *((_QWORD *)this + 23);
    if (v3)
      atomic_store(0, (unsigned __int8 *)(v3 + 752));
    language_modeling::v1::LanguageModelSession::clearPriorText(*((language_modeling::v1::LanguageModelSession **)this
                                                                + 25));
    std::mutex::unlock(*((std::mutex **)this + 17));
  }
}

uint64_t KB::LanguageModelStr::advanced_models_loaded(KB::LanguageModelStr *this)
{
  return (*(unsigned int (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 144))(this);
}

const __CFArray *KB::LanguageModelStr::does_provide_inline_completions_for_locale(const __CFArray **this, const KB::String *a2)
{
  const __CFArray *result;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  KB *ValueAtIndex;
  const __CFLocale *v9;
  void *v10;
  const char *v11;
  const char *v12;
  int v13;
  const __CFArray *v15;
  unsigned __int8 v16;
  _BYTE v17[8];
  _QWORD *v18;
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  result = (const __CFArray *)(*((uint64_t (**)(const __CFArray **))*this + 2))(this);
  if ((_DWORD)result)
  {
    result = this[2];
    if (result)
    {
      Count = CFArrayGetCount(result);
      if (Count < 1)
        return 0;
      v6 = Count;
      v7 = 0;
      while (1)
      {
        ValueAtIndex = (KB *)CFArrayGetValueAtIndex(this[2], v7);
        KB::kb_string_from_locale(ValueAtIndex, v9, (KB::String *)v17);
        v10 = v18;
        v11 = (const char *)(v18 ? v18 : v19);
        v12 = *((_QWORD *)a2 + 1) ? (const char *)*((_QWORD *)a2 + 1) : (char *)a2 + 16;
        v13 = strcmp(v11, v12);
        if (v10 && v17[6] == 1)
          free(v10);
        if (!v13)
          break;
        if (v6 == ++v7)
          return 0;
      }
      v15 = this[23];
      if (v15)
      {
        v16 = atomic_load((unsigned __int8 *)v15 + 16);
        return (const __CFArray *)(v16 & 1);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t KB::LanguageModelStr::supports_fragment_based_conditional_prob(language_modeling::v1::LanguageModelSession **this)
{
  uint64_t result;

  result = (*((uint64_t (**)(language_modeling::v1::LanguageModelSession **))*this + 2))(this);
  if ((_DWORD)result)
    return language_modeling::v1::LanguageModelSession::supportsFragmentsBasedConditionalProbability(this[25]);
  return result;
}

uint64_t KB::LanguageModelStr::should_score_completion_candidate(KB::LanguageModelStr *this, const Candidate *a2)
{
  if ((*(unsigned int (**)(KB::LanguageModelStr *, const Candidate *))(*(_QWORD *)this + 16))(this, a2))
    return (*(unsigned int (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 128))(this) ^ 1;
  else
    return 1;
}

uint64_t KB::LanguageModelStr::unwire_memory(language_modeling::v1::LanguageModel **this)
{
  uint64_t result;
  int v3;
  const char *v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  result = (*((uint64_t (**)(language_modeling::v1::LanguageModel **))*this + 2))(this);
  if ((_DWORD)result)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315138;
      v4 = "unwire_memory";
      _os_log_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s  Unwiring memory", (uint8_t *)&v3, 0xCu);
    }
    return language_modeling::v1::LanguageModel::unwireMemory(this[21]);
  }
  return result;
}

uint64_t KB::LanguageModelStr::get_num_candidates@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  const __CFNumber *Value;
  const __CFNumber *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t valuePtr;

  if (a2 == 5
    && (v4 = result, result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result), (_DWORD)result)
    && *(_QWORD *)(v4 + 272)
    && (result = language_modeling::v1::LanguageModelSession::supportsFragmentsBasedConditionalProbability(*(language_modeling::v1::LanguageModelSession **)(v4 + 200)),
        (result & 1) != 0)
    && (result = CFDictionaryContainsKey(*(CFDictionaryRef *)(v4 + 272), (const void *)kLMLanguageModelMaxNumQuickPathCandidatesSupported), (_DWORD)result)&& (result = CFDictionaryContainsKey(*(CFDictionaryRef *)(v4 + 272), (const void *)kLMLanguageModelMaxNumRetrocorrectionQuickPathCandidatesSupported), (_DWORD)result))
  {
    v8 = 0;
    valuePtr = 0;
    Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 272), (const void *)kLMLanguageModelMaxNumQuickPathCandidatesSupported);
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    v6 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 272), (const void *)kLMLanguageModelMaxNumRetrocorrectionQuickPathCandidatesSupported);
    result = CFNumberGetValue(v6, kCFNumberIntType, &v8);
    v7 = v8;
    *(_QWORD *)a3 = valuePtr;
    *(_QWORD *)(a3 + 8) = v7;
    *(_BYTE *)(a3 + 16) = 1;
  }
  else
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 16) = 0;
  }
  return result;
}

void KB::LanguageModelStr::copyLinguisticDataFiles(language_modeling::v1::LanguageModel **this@<X0>, _QWORD *a2@<X8>)
{
  const __CFAllocator *v4;
  void *values;

  if ((*((unsigned int (**)(language_modeling::v1::LanguageModel **))*this + 2))(this))
  {
    *a2 = language_modeling::v1::LanguageModel::copyLinguisticDataFileInfo(this[21]);
  }
  else
  {
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    values = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    *a2 = CFDictionaryCreate(v4, MEMORY[0x1E0D43508], (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (values)
      CFRelease(values);
  }
}

void KB::LanguageModelStr::set_inline_completion_personalization(KB::LanguageModelStr *this, const KB::String *a2)
{
  CFMutableDictionaryRef *v2;

  v2 = (CFMutableDictionaryRef *)*((_QWORD *)this + 23);
  if (v2)
    TIInlineCompletionGeneratorImpl::setInlineCompletionPersonalization(v2, a2);
}

uint64_t KB::LanguageModelStr::start_session_with_context(KB::LanguageModelStr *this, const __CFString *a2, const __CFDictionary *a3)
{
  (*(void (**)(KB::LanguageModelStr *, const __CFString *))(*(_QWORD *)this + 248))(this, a2);
  (*(void (**)(KB::LanguageModelStr *, const __CFDictionary *))(*(_QWORD *)this + 256))(this, a3);
  return (*(uint64_t (**)(KB::LanguageModelStr *, _QWORD))(*(_QWORD *)this + 264))(this, *((unsigned int *)this + 16));
}

uint64_t KB::LanguageModelStr::is_dynamic_word_id(KB::LanguageModelStr *this, TITokenID a2)
{
  return 0;
}

uint64_t KB::LanguageModelStr::add_dynamic_word(KB::LanguageModelStr *this, const __CFString *a2)
{
  return 0;
}

void KB::LanguageModelStr::increment_usage_count(KB::LanguageModelStr *this, const KB::String *a2, const TITokenID *a3, const KB::LanguageModelContext *a4)
{
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  void *__p[2];
  char v12;
  void *v13;
  char v14;

  if ((*(unsigned int (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 16))(this))
  {
    v7 = (char *)*((_QWORD *)a2 + 1);
    if (!v7)
      v7 = (char *)a2 + 16;
    if (*(_WORD *)a2)
      v8 = v7;
    else
      v8 = "";
    std::string::basic_string[abi:nn180100]<0>(__p, v8);
    KB::LanguageModelContext::linguistic_token((uint64_t)__p, (TITokenID)a3, (uint64_t)&v13);
    if (v12 < 0)
      operator delete(__p[0]);
    v9 = *((_QWORD *)this + 23);
    if (v9)
      atomic_store(1u, (unsigned __int8 *)(v9 + 752));
    std::mutex::lock(*((std::mutex **)this + 17));
    v10 = *((_QWORD *)this + 23);
    if (v10)
      atomic_store(0, (unsigned __int8 *)(v10 + 752));
    language_modeling::v1::LanguageModelSession::adaptToToken();
    std::mutex::unlock(*((std::mutex **)this + 17));
    if (v14 < 0)
      operator delete(v13);
  }
}

void KB::LanguageModelStr::decrement_usage_count(KB::LanguageModelStr *this, const KB::String *a2, const TITokenID *a3, const KB::LanguageModelContext *a4)
{
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  void *__p[2];
  char v12;
  void *v13;
  char v14;

  if ((*(unsigned int (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 16))(this))
  {
    v7 = (char *)*((_QWORD *)a2 + 1);
    if (!v7)
      v7 = (char *)a2 + 16;
    if (*(_WORD *)a2)
      v8 = v7;
    else
      v8 = "";
    std::string::basic_string[abi:nn180100]<0>(__p, v8);
    KB::LanguageModelContext::linguistic_token((uint64_t)__p, (TITokenID)a3, (uint64_t)&v13);
    if (v12 < 0)
      operator delete(__p[0]);
    v9 = *((_QWORD *)this + 23);
    if (v9)
      atomic_store(1u, (unsigned __int8 *)(v9 + 752));
    std::mutex::lock(*((std::mutex **)this + 17));
    v10 = *((_QWORD *)this + 23);
    if (v10)
      atomic_store(0, (unsigned __int8 *)(v10 + 752));
    language_modeling::v1::LanguageModelSession::unAdaptToToken();
    std::mutex::unlock(*((std::mutex **)this + 17));
    if (v14 < 0)
      operator delete(v13);
  }
}

void KB::LanguageModelStr::register_negative_evidence(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  void *__p;
  char v9;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
  {
    v4 = *(char **)(a2 + 8);
    if (!v4)
      v4 = (char *)(a2 + 16);
    if (*(_WORD *)a2)
      v5 = v4;
    else
      v5 = "";
    std::string::basic_string[abi:nn180100]<0>(&__p, v5);
    v6 = *(_QWORD *)(a1 + 184);
    if (v6)
      atomic_store(1u, (unsigned __int8 *)(v6 + 752));
    std::mutex::lock(*(std::mutex **)(a1 + 136));
    v7 = *(_QWORD *)(a1 + 184);
    if (v7)
      atomic_store(0, (unsigned __int8 *)(v7 + 752));
    language_modeling::v1::LanguageModelSession::registerNegativeEvidence();
    std::mutex::unlock(*(std::mutex **)(a1 + 136));
    if (v9 < 0)
      operator delete(__p);
  }
}

void KB::LanguageModelStr::record_usage_with_differential_privacy(KB::LanguageModel *a1, const __CFString *a2, int a3, char a4)
{
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  NSObject *v12;
  int v13;
  void *__p;
  char v15;
  uint8_t buf[4];
  _BYTE v17[14];
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a3 && (*(unsigned int (**)(KB::LanguageModel *))(*(_QWORD *)a1 + 16))(a1))
  {
    if (KB::LanguageModel::lexicon_id_active(a1, a3))
    {
      v8 = *((_QWORD *)a1 + 23);
      if (v8)
        atomic_store(1u, (unsigned __int8 *)(v8 + 752));
      std::mutex::lock(*((std::mutex **)a1 + 17));
      v9 = *((_QWORD *)a1 + 23);
      if (v9)
        atomic_store(0, (unsigned __int8 *)(v9 + 752));
      if ((a4 & 2) != 0)
      {
        KB::utf8_string(a2, (uint64_t)buf);
        v10 = *(char **)&v17[4];
        if (!*(_QWORD *)&v17[4])
          v10 = &v17[12];
        if (*(_WORD *)buf)
          v11 = v10;
        else
          v11 = "";
        std::string::basic_string[abi:nn180100]<0>(&__p, v11);
        language_modeling::v1::LanguageModelSession::recordWordRevision();
        if (v15 < 0)
          operator delete(__p);
        if (*(_QWORD *)&v17[4])
        {
          if (v17[2] == 1)
            free(*(void **)&v17[4]);
        }
      }
      std::mutex::unlock(*((std::mutex **)a1 + 17));
    }
    else
    {
      v12 = TILanguageModelLogFacility();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = (*(uint64_t (**)(KB::LanguageModel *))(*(_QWORD *)a1 + 40))(a1);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)v17 = "record_usage_with_differential_privacy";
        *(_WORD *)&v17[8] = 1024;
        *(_DWORD *)&v17[10] = a3;
        v18 = 1024;
        v19 = v13;
        _os_log_error_impl(&dword_1DA6F2000, v12, OS_LOG_TYPE_ERROR, "%s mismatched lexicon_id=%d for language model with lexicon_id=%d", buf, 0x18u);
      }
    }
  }
}

double KB::LanguageModelStr::last_offline_adaptation_time(KB::LanguageModelStr *this)
{
  return *((double *)this + 28);
}

uint64_t KB::LanguageModelStr::should_adapt_to_paragraph(KB::LanguageModelStr *this, const __CFString *a2)
{
  return 1;
}

void KB::LanguageModelStr::adapt_to_paragraph(uint64_t a1, uint64_t a2, double a3, uint64_t a4, const __CFString *a5, int a6)
{
  char *v11;
  char *v12;
  language_modeling::v1 *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  void *__p;
  char v20;
  uint8_t buf[4];
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
  {
    v11 = *(char **)(a2 + 8);
    if (!v11)
      v11 = (char *)(a2 + 16);
    if (*(_WORD *)a2)
      v12 = v11;
    else
      v12 = "";
    v13 = (language_modeling::v1 *)std::string::basic_string[abi:nn180100]<0>(&__p, v12);
    language_modeling::v1::convertAbsoluteTime(v13, a3);
    if (a6 == 2)
    {
      if (!a5)
      {
        v18 = TILanguageModelLogFacility();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136315138;
          v22 = "adapt_to_paragraph";
          _os_log_fault_impl(&dword_1DA6F2000, v18, OS_LOG_TYPE_FAULT, "%s Received an adapt to paragraph with NULL Sender Identifier", buf, 0xCu);
        }
        goto LABEL_23;
      }
      v16 = *(_QWORD *)(a1 + 184);
      if (v16)
        atomic_store(1u, (unsigned __int8 *)(v16 + 752));
      std::mutex::lock(*(std::mutex **)(a1 + 136));
      v17 = *(_QWORD *)(a1 + 184);
      if (v17)
        atomic_store(0, (unsigned __int8 *)(v17 + 752));
      CFStringCompare(a5, (CFStringRef)*MEMORY[0x1E0D43298], 1uLL);
      language_modeling::v1::LanguageModelSession::addPriorText();
    }
    else
    {
      if (a6 != 1)
        goto LABEL_23;
      if (!*(_DWORD *)(a1 + 64))
      {
        *(_DWORD *)(a1 + 64) = 1;
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 264))(a1, 1);
      }
      *(CFAbsoluteTime *)(a1 + 224) = CFAbsoluteTimeGetCurrent();
      v14 = *(_QWORD *)(a1 + 184);
      if (v14)
        atomic_store(1u, (unsigned __int8 *)(v14 + 752));
      std::mutex::lock(*(std::mutex **)(a1 + 136));
      v15 = *(_QWORD *)(a1 + 184);
      if (v15)
        atomic_store(0, (unsigned __int8 *)(v15 + 752));
      language_modeling::v1::LanguageModelSession::adaptToText();
    }
    std::mutex::unlock(*(std::mutex **)(a1 + 136));
LABEL_23:
    if (v20 < 0)
      operator delete(__p);
  }
}

BOOL KB::LanguageModelStr::is_swear_word_policy_enabled(language_modeling::v1::LanguageModel **this)
{
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  const void **v4;
  const __CFBoolean *Value;
  _BOOL8 v6;

  if (!(*((unsigned int (**)(language_modeling::v1::LanguageModel **))*this + 2))(this))
    return 0;
  v2 = (const __CFDictionary *)language_modeling::v1::LanguageModel::parameters(this[21]);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = (const void **)MEMORY[0x1E0D434F0];
  if (CFDictionaryContainsKey(v2, (const void *)*MEMORY[0x1E0D434F0]))
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v3, *v4);
    v6 = CFBooleanGetValue(Value) != 0;
  }
  else
  {
    v6 = 0;
  }
  CFRelease(v3);
  return v6;
}

uint64_t KB::LanguageModelStr::can_reason_about(KB::LanguageModelStr *this, const KB::String *a2, const TITokenID *a3)
{
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t canReasonAbout;
  void *__p;
  char v12;

  if (!(*(unsigned int (**)(KB::LanguageModelStr *, const KB::String *, const TITokenID *))(*(_QWORD *)this + 16))(this, a2, a3))return 0;
  v5 = (char *)*((_QWORD *)a2 + 1);
  if (!v5)
    v5 = (char *)a2 + 16;
  if (*(_WORD *)a2)
    v6 = v5;
  else
    v6 = "";
  std::string::basic_string[abi:nn180100]<0>(&__p, v6);
  v7 = *((_QWORD *)this + 23);
  if (v7)
    atomic_store(1u, (unsigned __int8 *)(v7 + 752));
  std::mutex::lock(*((std::mutex **)this + 17));
  v8 = *((_QWORD *)this + 23);
  if (v8)
    atomic_store(0, (unsigned __int8 *)(v8 + 752));
  canReasonAbout = language_modeling::v1::LanguageModelSession::canReasonAbout();
  std::mutex::unlock(*((std::mutex **)this + 17));
  if (v12 < 0)
    operator delete(__p);
  return canReasonAbout;
}

float KB::LanguageModelStr::marginal_likelihood(std::mutex **this, const KB::String *a2, const TITokenID *a3)
{
  float v6;
  _BOOL4 v7;
  char *v9;
  char *v10;
  std::mutex *v11;
  std::mutex *v12;
  double v13;
  void *__p[2];
  char v16;
  void *v17;
  char v18;

  v6 = 0.0;
  if ((*(unsigned int (**)(std::mutex **))&(*this)->__m_.__opaque[8])(this))
  {
    v7 = KB::LanguageModel::lexicon_id_active((KB::LanguageModel *)this, a3->lexicon_id);
    if (a3->word_id < 0x1F4 || v7)
    {
      v9 = (char *)*((_QWORD *)a2 + 1);
      if (!v9)
        v9 = (char *)a2 + 16;
      if (*(_WORD *)a2)
        v10 = v9;
      else
        v10 = "";
      std::string::basic_string[abi:nn180100]<0>(__p, v10);
      KB::LanguageModelContext::linguistic_token((uint64_t)__p, (TITokenID)a3, (uint64_t)&v17);
      if (v16 < 0)
        operator delete(__p[0]);
      v11 = this[23];
      if (v11)
        atomic_store(1u, (unsigned __int8 *)&v11[11].__m_.__opaque[40]);
      std::mutex::lock(this[17]);
      v12 = this[23];
      if (v12)
        atomic_store(0, (unsigned __int8 *)&v12[11].__m_.__opaque[40]);
      language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)__p);
      v13 = COERCE_DOUBLE(language_modeling::v1::LanguageModelSession::conditionalProbability());
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)__p);
      std::mutex::unlock(this[17]);
      if (v18 < 0)
        operator delete(v17);
      return v13;
    }
  }
  return v6;
}

void KB::LanguageModelStr::conditional_likelihood(unint64_t this@<X0>, const KB::String *a2@<X1>, const TITokenID *a3@<X2>, float a4@<S0>, uint64_t a5@<X8>)
{
  NSObject *log;
  const void *v12;
  os_signpost_id_t v13;
  os_signpost_id_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  double v20;
  NSObject *v21;
  os_signpost_id_t v22;
  os_signpost_id_t v23;
  std::string *v24;
  uint8_t v25[8];
  void *__p[2];
  char v27;
  uint8_t buf[8];
  char v29;

  if (((*(uint64_t (**)(unint64_t, float))(*(_QWORD *)this + 16))(this, a4) & 1) != 0)
  {
    kdebug_trace();
    log = kac_get_log();
    v12 = (const void *)(this ^ 0xC9);
    v13 = os_signpost_id_make_with_pointer(log, (const void *)(this ^ 0xC9));
    if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v14 = v13;
      if (os_signpost_enabled(log))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1DA6F2000, log, OS_SIGNPOST_INTERVAL_BEGIN, v14, "kbdManager.languageModel.conditionalLikelihood", "", buf, 2u);
      }
    }
    v15 = (char *)*((_QWORD *)a2 + 1);
    if (!v15)
      v15 = (char *)a2 + 16;
    if (*(_WORD *)a2)
      v16 = v15;
    else
      v16 = "";
    std::string::basic_string[abi:nn180100]<0>(__p, v16);
    KB::LanguageModelContext::linguistic_token((uint64_t)__p, (TITokenID)a3, (uint64_t)buf);
    if (v27 < 0)
      operator delete(__p[0]);
    *(_QWORD *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    *(_QWORD *)(a5 + 16) = 0;
    *(_QWORD *)(a5 + 24) = 0;
    *(_QWORD *)(a5 + 32) = 0;
    v17 = *(_QWORD *)(this + 184);
    if (v17)
      atomic_store(1u, (unsigned __int8 *)(v17 + 752));
    std::mutex::lock(*(std::mutex **)(this + 136));
    v18 = *(_QWORD *)(this + 184);
    if (v18)
      atomic_store(0, (unsigned __int8 *)(v18 + 752));
    language_modeling::v1::LanguageModelSession::detailedConditionalProbability();
    language_modeling::v1::Probability::probability();
    *(float *)&v19 = v19;
    *(float *)a5 = __exp10f(*(float *)&v19);
    language_modeling::v1::Probability::probability();
    *(float *)&v20 = v20;
    *(float *)(a5 + 4) = __exp10f(*(float *)&v20);
    *(_DWORD *)(a5 + 8) = language_modeling::v1::Probability::flags((language_modeling::v1::Probability *)__p) & 3;
    language_modeling::v1::Probability::log((language_modeling::v1::Probability *)__p);
    std::mutex::unlock(*(std::mutex **)(this + 136));
    kdebug_trace();
    v21 = kac_get_log();
    v22 = os_signpost_id_make_with_pointer(v21, v12);
    if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v23 = v22;
      if (os_signpost_enabled(v21))
      {
        *(_WORD *)v25 = 0;
        _os_signpost_emit_with_name_impl(&dword_1DA6F2000, v21, OS_SIGNPOST_INTERVAL_END, v23, "kbdManager.languageModel.conditionalLikelihood", "", v25, 2u);
      }
    }
    language_modeling::v1::Probability::~Probability((language_modeling::v1::Probability *)__p);
    if (v29 < 0)
      operator delete(*(void **)buf);
  }
  else
  {
    *(_QWORD *)a5 = KB::k_invalid_likelihood_value;
    *(_DWORD *)(a5 + 8) = dword_1F027F2F0;
    v24 = (std::string *)(a5 + 16);
    if (byte_1F027F30F < 0)
    {
      std::string::__init_copy_ctor_external(v24, *(const std::string::value_type **)aInvalidLikelih, *(std::string::size_type *)&aInvalidLikelih[8]);
    }
    else
    {
      *(_OWORD *)&v24->__r_.__value_.__l.__data_ = *(_OWORD *)aInvalidLikelih;
      *(_QWORD *)(a5 + 32) = *(_QWORD *)&aInvalidLikelih[16];
    }
  }
}

void KB::LanguageModelStr::conditional_likelihood_batched(uint64_t a1@<X0>, unsigned int **a2@<X1>, int a3@<W5>, _QWORD *a4@<X8>)
{
  NSObject *log;
  os_signpost_id_t v8;
  os_signpost_id_t v9;
  unsigned int *v10;
  KB::Word *v11;
  KB::Word *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  __int128 v26;
  int64x2_t v27;
  char *v28;
  void **v29;
  void **v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  _QWORD *v39;
  _QWORD *v40;
  __int128 v41;
  _QWORD *v42;
  unsigned int *v43;
  unsigned int *v44;
  _QWORD *v45;
  unint64_t v46;
  _QWORD *v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  language_modeling::v1::Probability **v57;
  language_modeling::v1::Probability *v58;
  language_modeling::v1::Probability *v59;
  double v60;
  double v61;
  _QWORD *v62;
  uint64_t v63;
  __int128 v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  __int128 v71;
  char *v72;
  char *v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  __int128 v77;
  int64x2_t v78;
  void *v79;
  char *v80;
  NSObject *v81;
  os_signpost_id_t v82;
  os_signpost_id_t v83;
  _QWORD *v84;
  _QWORD *v85;
  void *v86;
  void *ptr;
  char v88;
  uint64_t v89;
  unsigned int *v90;
  __int128 v91;
  uint64_t v93;
  void *__p[2];
  char *v95;
  __int128 v96;
  char *v97;
  void *v98;
  _QWORD *v99;
  unint64_t v100;
  uint8_t buf[24];
  char *v102;
  void **v103;
  __int128 v104;
  __int128 v105;
  uint64_t v106;
  uint64_t v107;

  v107 = *MEMORY[0x1E0C80C00];
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1)
    && (!a3
     || (language_modeling::v1::LanguageModelSession::supportsNormalizedNameTokenProbability(*(language_modeling::v1::LanguageModelSession **)(a1 + 200)) & 1) != 0))
  {
    v88 = a3;
    kdebug_trace();
    log = kac_get_log();
    v89 = a1;
    ptr = (void *)(a1 ^ 0xCA);
    v8 = os_signpost_id_make_with_pointer(log, (const void *)(a1 ^ 0xCA));
    if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v9 = v8;
      if (os_signpost_enabled(log))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1DA6F2000, log, OS_SIGNPOST_INTERVAL_BEGIN, v9, "kbdManager.languageModel.conditionalLikelihoodBatched", "", buf, 2u);
      }
    }
    v98 = 0;
    v99 = 0;
    v100 = 0;
    v10 = *a2;
    v90 = a2[1];
    if (*a2 != v90)
    {
      do
      {
        v97 = 0;
        v96 = 0uLL;
        if (*(_QWORD *)v10)
        {
          v11 = (KB::Word *)*((_QWORD *)v10 + 1);
          v12 = (KB::Word *)((char *)v11 + 240 * *(_QWORD *)v10);
          do
          {
            KB::Word::capitalized_string(v11, (uint64_t)&v104);
            v13 = (char *)*((_QWORD *)&v104 + 1);
            if (!*((_QWORD *)&v104 + 1))
              v13 = (char *)&v105;
            if ((_WORD)v104)
              v14 = v13;
            else
              v14 = "";
            std::string::basic_string[abi:nn180100]<0>(__p, v14);
            v93 = *((_QWORD *)v11 + 17);
            KB::LanguageModelContext::linguistic_token((uint64_t)__p, (TITokenID)&v93, (uint64_t)buf);
            v15 = *((_QWORD *)&v96 + 1);
            if (*((_QWORD *)&v96 + 1) >= (unint64_t)v97)
            {
              v16 = (uint64_t)(*((_QWORD *)&v96 + 1) - v96) >> 5;
              v17 = v16 + 1;
              if ((unint64_t)(v16 + 1) >> 59)
                goto LABEL_117;
              v18 = (uint64_t)&v97[-v96];
              if ((uint64_t)&v97[-v96] >> 4 > v17)
                v17 = v18 >> 4;
              if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0)
                v19 = 0x7FFFFFFFFFFFFFFLL;
              else
                v19 = v17;
              v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v19);
              v22 = &v20[32 * v16];
              *((_QWORD *)v22 + 2) = *(_QWORD *)&buf[16];
              *(_OWORD *)v22 = *(_OWORD *)buf;
              memset(buf, 0, sizeof(buf));
              *((_DWORD *)v22 + 6) = (_DWORD)v102;
              v23 = *((_QWORD *)&v96 + 1);
              v24 = v96;
              if (*((_QWORD *)&v96 + 1) == (_QWORD)v96)
              {
                v27 = vdupq_n_s64(*((unint64_t *)&v96 + 1));
                v25 = &v20[32 * v16];
              }
              else
              {
                v25 = &v20[32 * v16];
                do
                {
                  v26 = *(_OWORD *)(v23 - 32);
                  *((_QWORD *)v25 - 2) = *(_QWORD *)(v23 - 16);
                  *((_OWORD *)v25 - 2) = v26;
                  *(_QWORD *)(v23 - 24) = 0;
                  *(_QWORD *)(v23 - 16) = 0;
                  *(_QWORD *)(v23 - 32) = 0;
                  *((_DWORD *)v25 - 2) = *(_DWORD *)(v23 - 8);
                  v25 -= 32;
                  v23 -= 32;
                }
                while (v23 != v24);
                v27 = (int64x2_t)v96;
              }
              v28 = v22 + 32;
              *(_QWORD *)&v96 = v25;
              *((_QWORD *)&v96 + 1) = v22 + 32;
              v97 = &v20[32 * v21];
              v29 = (void **)v27.i64[1];
              v30 = (void **)v27.i64[0];
              while (v29 != v30)
              {
                if (*((char *)v29 - 9) < 0)
                  operator delete(*(v29 - 4));
                v29 -= 4;
              }
              if (v30)
              {
                operator delete(v30);
                *((_QWORD *)&v96 + 1) = v28;
                if ((char)buf[23] < 0)
                  operator delete(*(void **)buf);
              }
              else
              {
                *((_QWORD *)&v96 + 1) = v28;
              }
            }
            else
            {
              **((_OWORD **)&v96 + 1) = *(_OWORD *)buf;
              *(_QWORD *)(v15 + 16) = *(_QWORD *)&buf[16];
              *(_DWORD *)(v15 + 24) = (_DWORD)v102;
              *((_QWORD *)&v96 + 1) = v15 + 32;
            }
            if (SHIBYTE(v95) < 0)
              operator delete(__p[0]);
            if (*((_QWORD *)&v104 + 1) && BYTE6(v104) == 1)
              free(*((void **)&v104 + 1));
            v11 = (KB::Word *)((char *)v11 + 240);
          }
          while (v11 != v12);
        }
        v31 = v99;
        if ((unint64_t)v99 >= v100)
        {
          v33 = 0xAAAAAAAAAAAAAAABLL * (((char *)v99 - (_BYTE *)v98) >> 3);
          v34 = v33 + 1;
          if (v33 + 1 > 0xAAAAAAAAAAAAAAALL)
            goto LABEL_117;
          if (0x5555555555555556 * ((uint64_t)(v100 - (_QWORD)v98) >> 3) > v34)
            v34 = 0x5555555555555556 * ((uint64_t)(v100 - (_QWORD)v98) >> 3);
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v100 - (_QWORD)v98) >> 3) >= 0x555555555555555)
            v35 = 0xAAAAAAAAAAAAAAALL;
          else
            v35 = v34;
          if (v35)
          {
            if (v35 > 0xAAAAAAAAAAAAAAALL)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v36 = (char *)operator new(24 * v35);
          }
          else
          {
            v36 = 0;
          }
          v37 = &v36[24 * v33];
          v38 = &v36[24 * v35];
          *(_QWORD *)v37 = 0;
          *((_QWORD *)v37 + 1) = 0;
          *((_QWORD *)v37 + 2) = 0;
          std::vector<language_modeling::v1::Token>::__init_with_size[abi:nn180100]<language_modeling::v1::Token*,language_modeling::v1::Token*>(v37, v96, *((uint64_t *)&v96 + 1), (uint64_t)(*((_QWORD *)&v96 + 1) - v96) >> 5);
          v32 = v37 + 24;
          v39 = v98;
          v40 = v99;
          if (v99 == v98)
          {
            v98 = v37;
            v99 = v37 + 24;
            v100 = (unint64_t)v38;
            if (!v40)
              goto LABEL_62;
          }
          else
          {
            do
            {
              *((_QWORD *)v37 - 3) = 0;
              *((_QWORD *)v37 - 2) = 0;
              v37 -= 24;
              *((_QWORD *)v37 + 2) = 0;
              v41 = *(_OWORD *)(v40 - 3);
              v40 -= 3;
              *(_OWORD *)v37 = v41;
              *((_QWORD *)v37 + 2) = v40[2];
              *v40 = 0;
              v40[1] = 0;
              v40[2] = 0;
            }
            while (v40 != v39);
            v42 = v98;
            v40 = v99;
            v98 = v37;
            v99 = v32;
            v100 = (unint64_t)v38;
            if (v40 != v42)
            {
              do
              {
                v40 -= 3;
                *(_QWORD *)buf = v40;
                std::vector<language_modeling::v1::Token>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
              }
              while (v40 != v42);
              v40 = v42;
            }
            if (!v40)
              goto LABEL_62;
          }
          operator delete(v40);
        }
        else
        {
          *v99 = 0;
          v31[1] = 0;
          v31[2] = 0;
          std::vector<language_modeling::v1::Token>::__init_with_size[abi:nn180100]<language_modeling::v1::Token*,language_modeling::v1::Token*>(v31, v96, *((uint64_t *)&v96 + 1), (uint64_t)(*((_QWORD *)&v96 + 1) - v96) >> 5);
          v32 = v31 + 3;
        }
LABEL_62:
        v99 = v32;
        *(_QWORD *)buf = &v96;
        std::vector<language_modeling::v1::Token>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
        v10 += 250;
      }
      while (v10 != v90);
    }
    v96 = 0uLL;
    v97 = 0;
    v55 = *(_QWORD *)(a1 + 184);
    if (v55)
      atomic_store(1u, (unsigned __int8 *)(v55 + 752));
    std::mutex::lock(*(std::mutex **)(a1 + 136));
    v56 = *(_QWORD *)(a1 + 184);
    if (v56)
      atomic_store(0, (unsigned __int8 *)(v56 + 752));
    if ((v88 & 1) != 0)
      language_modeling::v1::LanguageModelSession::normalizedNameTokenConditionalProbability();
    else
      language_modeling::v1::LanguageModelSession::detailedConditionalProbability();
    std::vector<std::vector<language_modeling::v1::Probability>>::__vdeallocate((void ***)&v96);
    v91 = *(_OWORD *)buf;
    v96 = *(_OWORD *)buf;
    v97 = *(char **)&buf[16];
    memset(buf, 0, sizeof(buf));
    *(_QWORD *)&v104 = buf;
    std::vector<std::vector<language_modeling::v1::Probability>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v104);
    v57 = (language_modeling::v1::Probability **)v91;
    std::mutex::unlock(*(std::mutex **)(v89 + 136));
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    if ((_QWORD)v91 != *((_QWORD *)&v91 + 1))
    {
      do
      {
        __p[0] = 0;
        __p[1] = 0;
        v95 = 0;
        v59 = *v57;
        v58 = v57[1];
        while (v59 != v58)
        {
          language_modeling::v1::Probability::probability();
          *(float *)&v60 = v60;
          LODWORD(v104) = __exp10f(*(float *)&v60);
          language_modeling::v1::Probability::probability();
          *(float *)&v61 = v61;
          DWORD1(v104) = __exp10f(*(float *)&v61);
          BYTE8(v104) = language_modeling::v1::Probability::flags(v59) & 3;
          DWORD2(v104) = BYTE8(v104);
          language_modeling::v1::Probability::log(v59);
          v62 = __p[1];
          if (__p[1] >= v95)
          {
            v65 = 0xCCCCCCCCCCCCCCCDLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
            v66 = v65 + 1;
            if (v65 + 1 > 0x666666666666666)
              goto LABEL_117;
            if (0x999999999999999ALL * ((v95 - (char *)__p[0]) >> 3) > v66)
              v66 = 0x999999999999999ALL * ((v95 - (char *)__p[0]) >> 3);
            if (0xCCCCCCCCCCCCCCCDLL * ((v95 - (char *)__p[0]) >> 3) >= 0x333333333333333)
              v67 = 0x666666666666666;
            else
              v67 = v66;
            v103 = (void **)&v95;
            if (v67)
              v67 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v67);
            else
              v68 = 0;
            v69 = v67 + 40 * v65;
            v70 = v104;
            *(_DWORD *)(v69 + 8) = DWORD2(v104);
            *(_QWORD *)v69 = v70;
            v71 = v105;
            *(_QWORD *)(v69 + 32) = v106;
            *(_OWORD *)(v69 + 16) = v71;
            v106 = 0;
            v105 = 0uLL;
            v73 = (char *)__p[0];
            v72 = (char *)__p[1];
            if (__p[1] == __p[0])
            {
              v78 = vdupq_n_s64((unint64_t)__p[1]);
              v74 = v67 + 40 * v65;
            }
            else
            {
              v74 = v67 + 40 * v65;
              do
              {
                v75 = *((_QWORD *)v72 - 5);
                v72 -= 40;
                v76 = *((_DWORD *)v72 + 2);
                *(_QWORD *)(v74 - 40) = v75;
                v74 -= 40;
                *(_DWORD *)(v74 + 8) = v76;
                v77 = *((_OWORD *)v72 + 1);
                *(_QWORD *)(v74 + 32) = *((_QWORD *)v72 + 4);
                *(_OWORD *)(v74 + 16) = v77;
                *((_QWORD *)v72 + 3) = 0;
                *((_QWORD *)v72 + 4) = 0;
                *((_QWORD *)v72 + 2) = 0;
              }
              while (v72 != v73);
              v78 = *(int64x2_t *)__p;
            }
            v79 = (void *)(v69 + 40);
            __p[0] = (void *)v74;
            __p[1] = (void *)(v69 + 40);
            *(int64x2_t *)&buf[8] = v78;
            v80 = v95;
            v95 = (char *)(v67 + 40 * v68);
            v102 = v80;
            *(_QWORD *)buf = v78.i64[0];
            std::__split_buffer<KB::LikelihoodInfo>::~__split_buffer((uint64_t)buf);
            __p[1] = v79;
            if (SHIBYTE(v106) < 0)
              operator delete((void *)v105);
          }
          else
          {
            v63 = v104;
            *((_DWORD *)__p[1] + 2) = DWORD2(v104);
            *v62 = v63;
            v64 = v105;
            v62[4] = v106;
            *((_OWORD *)v62 + 1) = v64;
            __p[1] = v62 + 5;
          }
          v59 = (language_modeling::v1::Probability *)((char *)v59 + 8);
        }
        std::vector<std::vector<KB::LikelihoodInfo>>::emplace_back<std::vector<KB::LikelihoodInfo>&>(a4, (__int128 **)__p);
        *(_QWORD *)buf = __p;
        std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
        v57 += 3;
      }
      while (v57 != *((language_modeling::v1::Probability ***)&v91 + 1));
    }
    kdebug_trace();
    v81 = kac_get_log();
    v82 = os_signpost_id_make_with_pointer(v81, ptr);
    if (v82 - 1 < 0xFFFFFFFFFFFFFFFELL)
    {
      v83 = v82;
      if (os_signpost_enabled(v81))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1DA6F2000, v81, OS_SIGNPOST_INTERVAL_END, v83, "kbdManager.languageModel.conditionalLikelihoodBatched", "", buf, 2u);
      }
    }
    *(_QWORD *)buf = &v96;
    std::vector<std::vector<language_modeling::v1::Probability>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
    v84 = v98;
    if (v98)
    {
      v85 = v99;
      v86 = v98;
      if (v99 != v98)
      {
        do
        {
          v85 -= 3;
          *(_QWORD *)buf = v85;
          std::vector<language_modeling::v1::Token>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
        }
        while (v85 != v84);
        v86 = v98;
      }
      v99 = v84;
      operator delete(v86);
    }
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    v43 = *a2;
    v44 = a2[1];
    if (*a2 != v44)
    {
      do
      {
        std::vector<KB::LikelihoodInfo>::vector(&v104, *v43, (uint64_t)&KB::k_invalid_likelihood_value);
        v45 = (_QWORD *)a4[1];
        v46 = a4[2];
        if ((unint64_t)v45 >= v46)
        {
          v48 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v45 - *a4) >> 3);
          v49 = v48 + 1;
          if (v48 + 1 > 0xAAAAAAAAAAAAAAALL)
LABEL_117:
            abort();
          v50 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - *a4) >> 3);
          if (2 * v50 > v49)
            v49 = 2 * v50;
          if (v50 >= 0x555555555555555)
            v51 = 0xAAAAAAAAAAAAAAALL;
          else
            v51 = v49;
          v103 = (void **)(a4 + 2);
          v52 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v51);
          v53 = &v52[24 * v48];
          *(_QWORD *)buf = v52;
          *(_QWORD *)&buf[8] = v53;
          v102 = &v52[24 * v54];
          *((_QWORD *)v53 + 1) = 0;
          *((_QWORD *)v53 + 2) = 0;
          *(_QWORD *)v53 = 0;
          *(_OWORD *)v53 = v104;
          *((_QWORD *)v53 + 2) = v105;
          v104 = 0uLL;
          *(_QWORD *)&v105 = 0;
          *(_QWORD *)&buf[16] = v53 + 24;
          std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(a4, buf);
          v47 = (_QWORD *)a4[1];
          std::__split_buffer<std::vector<KB::LikelihoodInfo>>::~__split_buffer((uint64_t)buf);
        }
        else
        {
          *v45 = 0;
          v45[1] = 0;
          v45[2] = 0;
          *(_OWORD *)v45 = v104;
          v45[2] = v105;
          v104 = 0uLL;
          *(_QWORD *)&v105 = 0;
          v47 = v45 + 3;
        }
        a4[1] = v47;
        *(_QWORD *)buf = &v104;
        std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
        v43 += 250;
      }
      while (v43 != v44);
    }
  }
}

uint64_t KB::LanguageModelImplBase::most_probable_lexicon_for_context(KB::LanguageModelImplBase *this, const KB::LanguageModelContext *a2)
{
  return (*(uint64_t (**)(KB::LanguageModelImplBase *))(*(_QWORD *)this + 40))(this);
}

uint64_t KB::LanguageModelImplBase::most_probable_lexicon_for_context(KB::LanguageModelImplBase *this, const KB::LanguageModelContext *a2, float *a3)
{
  *a3 = 1.0;
  return (*(uint64_t (**)(KB::LanguageModelImplBase *))(*(_QWORD *)this + 40))(this);
}

float KB::LanguageModel::probability_of_lexicon_given_context(KB::LanguageModel *this, unsigned int a2, const KB::LanguageModelContext *a3)
{
  return 1.0;
}

void KB::LanguageModelStr::predictions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *log;
  const void *v9;
  os_signpost_id_t v10;
  os_signpost_id_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  os_signpost_id_t v16;
  os_signpost_id_t v17;
  KB::LanguageModelStr *v18;
  const KB::LanguageModelContext *v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint8_t buf[8];

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
  {
    kdebug_trace();
    log = kac_get_log();
    v9 = (const void *)(a1 ^ 0xCB);
    v10 = os_signpost_id_make_with_pointer(log, (const void *)(a1 ^ 0xCB));
    if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v11 = v10;
      if (os_signpost_enabled(log))
      {
        LOWORD(v21) = 0;
        _os_signpost_emit_with_name_impl(&dword_1DA6F2000, log, OS_SIGNPOST_INTERVAL_BEGIN, v11, "kbdManager.languageModel.tokenIDGenerateCompletionsAndPredictions", "", (uint8_t *)&v21, 2u);
      }
    }
    v21 = 0;
    v22 = 0;
    v23 = 0;
    KB::LanguageModelStr::get_predictions(a1, a2, a3, &v21);
    v12 = v21;
    v13 = v22;
    while (v12 != v13)
    {
      v14 = *(_QWORD *)(a4 + 24);
      if (!v14)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        KB::LanguageModelStr::create_prediction_enumerator(v18, v19, v20);
        return;
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 48))(v14, v12);
      v12 += 160;
    }
    kdebug_trace();
    v15 = kac_get_log();
    v16 = os_signpost_id_make_with_pointer(v15, v9);
    if (v16 - 1 < 0xFFFFFFFFFFFFFFFELL)
    {
      v17 = v16;
      if (os_signpost_enabled(v15))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1DA6F2000, v15, OS_SIGNPOST_INTERVAL_END, v17, "kbdManager.languageModel.tokenIDGenerateCompletionsAndPredictions", "", buf, 2u);
      }
    }
    *(_QWORD *)buf = &v21;
    std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  }
}

void KB::LanguageModelStr::create_prediction_enumerator(KB::LanguageModelStr *this@<X0>, const KB::LanguageModelContext *a2@<X1>, unsigned int a3@<W2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;

  v8 = operator new(0x40uLL);
  v8[1] = 0;
  v8[2] = 0;
  *v8 = &off_1EA0FA938;
  v8[3] = &off_1EA0FA720;
  *((_OWORD *)v8 + 3) = 0u;
  *((_OWORD *)v8 + 2) = 0u;
  KB::LanguageModelStr::get_predictions((uint64_t)this, (uint64_t)a2, a3, v8 + 4);
  *a4 = v8 + 3;
  a4[1] = v8;
}

BOOL KB::LanguageModelStr::is_token_blocklisted(KB::LanguageModel *a1, KB::String *a2, int a3)
{
  _BOOL8 v4;
  char *v5;
  _BOOL8 v6;
  void *__p;
  char v9;
  int v10;
  _WORD v11[3];
  char v12;
  void *v13;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v4 = KB::LanguageModel::lexicon_id_active(a1, a3);
  KB::String::space((KB::String *)v4);
  KB::String::trim(a2, (const KB::String *)&KB::String::space(void)::space, (uint64_t)v11);
  if (v11[0])
  {
    if (v13)
      v5 = (char *)v13;
    else
      v5 = (char *)v14;
    std::string::basic_string[abi:nn180100]<0>(&__p, v5);
    v10 = 0;
    v6 = language_modeling::v1::LanguageModel::blocklistStatus() != 0;
    if (v9 < 0)
      operator delete(__p);
  }
  else
  {
    v6 = 0;
  }
  if (v13 && v12 == 1)
    free(v13);
  return v6;
}

BOOL KB::LanguageModelStr::is_text_blocklisted(KB::LanguageModel *a1, int a2, int a3, const KB::LanguageModelContext *a4, uint64_t a5)
{
  _BOOL8 v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  _QWORD v13[5];
  uint64_t v14;
  std::__shared_weak_count *v15;
  void *__p;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  char v24;
  void **v25;

  KB::LanguageModel::lexicon_id_active(a1, a3);
  if (!(*(unsigned int (**)(KB::LanguageModel *))(*(_QWORD *)a1 + 16))(a1)
    || !*(_QWORD *)a5
    || **(_QWORD **)(*(_QWORD *)a5 + 8) == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a5 + 8) + 8))
  {
    return 1;
  }
  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = 0;
  v13[0] = 0;
  v13[1] = v13;
  v13[2] = 0x9002000000;
  v13[3] = __Block_byref_object_copy__757;
  v13[4] = __Block_byref_object_dispose__758;
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v14, a4);
  KB::LanguageModelImplBase::tokenize_text((uint64_t)a1);
  v8 = *((_BYTE *)v22 + 24) != 0;
  _Block_object_dispose(v13, 8);
  v25 = (void **)&v20;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v25);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v19);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v18);
  if (__p)
  {
    v17 = __p;
    operator delete(__p);
  }
  v9 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  _Block_object_dispose(&v21, 8);
  return v8;
}

BOOL KB::LanguageModelStr::predictions(uint64_t a1, uint64_t *a2, const KB::LanguageModelContext *a3, uint64_t a4, int a5)
{
  void ***v9;
  void ***v10;
  uint64_t v11;
  const KB::Candidate *v12;
  _QWORD *v13;
  uint64_t v14;
  const char *v15;
  _QWORD *v16;
  const char *v17;
  int v18;
  uint64_t *v19;
  const char *v20;
  KB::String *v21;
  KB::String *v22;
  _QWORD *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t **v27;
  const char *v28;
  _QWORD *v29;
  _QWORD *v30;
  const char *v31;
  uint64_t v32;
  uint64_t *v33;
  KB::LanguageModel *v34;
  _QWORD *v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  const char *v42;
  const char *v43;
  const char *v44;
  uint64_t *v45;
  uint64_t v46;
  const char *v47;
  uint64_t *v48;
  const char *v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t *v52;
  BOOL v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  CFIndex prediction_count;
  _QWORD *v65;
  _QWORD *v66;
  uint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  const KB::Candidate *v72;
  int64x2_t v74;
  void *__p;
  void *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80[2];
  char v81;
  _QWORD v82[3];
  void **v83;
  _BYTE v84[24];
  _BYTE *v85;
  uint64_t v86;
  void *v87;
  uint64_t v88;
  void **v89[3];
  void ***v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v81 = 0;
  v80[0] = a1;
  v80[1] = (uint64_t)a3;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1))
  {
    if (a2[1] == *a2)
      return 0;
    v74 = 0uLL;
    __p = 0;
    convert_to_lm_completion_stem(a2, &v74, a5);
    v86 = 0;
    v9 = (void ***)operator new(0x40uLL);
    *v9 = (void **)&off_1EA0FA8A8;
    v9[1] = (void **)a2;
    v9[2] = (void **)a3;
    v9[3] = (void **)v80;
    v9[4] = (void **)a4;
    v9[5] = (void **)a1;
    v9[6] = (void **)&v81;
    v9[7] = (void **)&v86;
    v90 = v9;
    (*(void (**)(uint64_t, int64x2_t *))(*(_QWORD *)a1 + 504))(a1, &v74);
    v10 = v90;
    if (v90 == v89)
    {
      v11 = 4;
      v10 = v89;
    }
    else
    {
      if (!v90)
      {
LABEL_111:
        v89[0] = (void **)&v74;
        std::vector<language_modeling::v1::CompletionStem>::__destroy_vector::operator()[abi:nn180100](v89);
        return v81 != 0;
      }
      v11 = 5;
    }
    ((void (*)(void))(*v10)[v11])();
    goto LABEL_111;
  }
  v12 = (const KB::Candidate *)*a2;
  v72 = (const KB::Candidate *)a2[1];
  if ((const KB::Candidate *)*a2 != v72)
  {
    v13 = (_QWORD *)(a1 + 336);
    while (1)
    {
      KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v74, a3);
      KB::Candidate::Candidate((KB::Candidate *)v89, v12);
      KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)const::$_0::operator()(v80, (KB::LanguageModelContext *)&v74, (uint64_t)v89[0], (KB::String *)v89[1]);
      KB::LanguageModelStr::cache_key_for_candidate(v12, (uint64_t)&v86);
      v14 = *v13;
      if (!*v13)
        goto LABEL_24;
      v15 = (const char *)(v87 ? v87 : &v88);
      v16 = v13;
      do
      {
        if (*(_QWORD *)(v14 + 40))
          v17 = *(const char **)(v14 + 40);
        else
          v17 = (const char *)(v14 + 48);
        v18 = strcmp(v17, v15);
        v19 = (uint64_t *)(v14 + 8);
        if (v18 >= 0)
        {
          v19 = (uint64_t *)v14;
          v16 = (_QWORD *)v14;
        }
        v14 = *v19;
      }
      while (*v19);
      if (v13 == v16 || (v16[5] ? (v20 = (const char *)v16[5]) : (v20 = (const char *)(v16 + 6)), strcmp(v15, v20) < 0))
LABEL_24:
        v16 = v13;
      v21 = (KB::String *)operator new();
      memset(v82, 0, sizeof(v82));
      v22 = KB::String::String(v21, (const KB::String *)&v86);
      *((_QWORD *)v22 + 8) = 0;
      *((_OWORD *)v22 + 2) = 0u;
      *((_OWORD *)v22 + 3) = 0u;
      v23 = operator new(0x48uLL);
      KB::String::String((KB::String *)(v23 + 4), (const KB::String *)&v86);
      v23[8] = v21;
      v24 = v23 + 8;
      v25 = (uint64_t *)*v13;
      v26 = v13;
      v27 = (uint64_t **)v13;
      if (!*v13)
        break;
      if (v23[5])
        v28 = (const char *)v23[5];
      else
        v28 = (const char *)(v23 + 6);
      while (1)
      {
        while (1)
        {
          v26 = v25;
          v29 = (_QWORD *)v25[5];
          v30 = v25 + 6;
          v31 = (const char *)(v29 ? v29 : v30);
          if ((strcmp(v28, v31) & 0x80000000) == 0)
            break;
          v25 = (uint64_t *)*v26;
          v27 = (uint64_t **)v26;
          if (!*v26)
            goto LABEL_37;
        }
        if ((strcmp(v31, v28) & 0x80000000) == 0)
          break;
        v27 = (uint64_t **)(v26 + 1);
        v25 = (uint64_t *)v26[1];
        if (!v25)
          goto LABEL_37;
      }
      std::__destroy_at[abi:nn180100]<std::pair<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,0>((uint64_t)(v23 + 4));
      operator delete(v23);
      v83 = (void **)v82;
      std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v83);
      v54 = v26[8];
      v24 = v26 + 8;
      v55 = *(_QWORD *)(a1 + 312);
      if (v55 == v54)
        goto LABEL_85;
      v56 = *(_QWORD *)(v54 + 56);
      v57 = *(_QWORD *)(v54 + 64);
      v13 = (_QWORD *)(a1 + 336);
      if (v56)
        *(_QWORD *)(v56 + 64) = v57;
      if (v57)
        *(_QWORD *)(v57 + 56) = v56;
      v58 = *(_QWORD *)(a1 + 320);
      if (v58 == v54)
      {
        *(_QWORD *)(a1 + 320) = v56;
        v58 = v56;
      }
      *(_QWORD *)(v54 + 56) = 0;
      *(_QWORD *)(v54 + 64) = v55;
      if (v55)
        *(_QWORD *)(v55 + 56) = v54;
      *(_QWORD *)(a1 + 312) = v54;
      if (!v58)
        *(_QWORD *)(a1 + 320) = v54;
LABEL_86:
      v59 = *v24;
      if (v13 != v16)
      {
        v61 = *(_QWORD *)(v59 + 32);
        v60 = *(_QWORD *)(v59 + 40);
        while (v61 != v60)
        {
          v62 = *(_QWORD *)(a4 + 24);
          if (!v62)
            std::__throw_bad_function_call[abi:nn180100]();
          (*(void (**)(uint64_t, uint64_t, void ***, int64x2_t *))(*(_QWORD *)v62 + 48))(v62, v61, v89, &v74);
          v61 += 160;
        }
        goto LABEL_96;
      }
      v63 = v59 + 32;
      prediction_count = KB::LanguageModel::get_prediction_count(v34);
      v65 = operator new(0x30uLL);
      *v65 = &off_1EA0FA8F0;
      v65[1] = v63;
      v65[2] = &v81;
      v65[3] = a4;
      v65[4] = v89;
      v65[5] = &v74;
      v85 = v65;
      (*(void (**)(uint64_t, int64x2_t *, CFIndex, _BYTE *))(*(_QWORD *)a1 + 440))(a1, &v74, prediction_count, v84);
      v66 = v85;
      if (v85 == v84)
      {
        v66 = v84;
        v67 = 4;
      }
      else
      {
        if (!v85)
          goto LABEL_96;
        v67 = 5;
      }
      (*(void (**)(void))(*v66 + 8 * v67))();
LABEL_96:
      if (v87 && BYTE6(v86) == 1)
        free(v87);
      KB::Candidate::~Candidate((KB::Candidate *)v89);
      v89[0] = (void **)&v79;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v89);
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v78);
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v77);
      if (__p)
      {
        v76 = __p;
        operator delete(__p);
      }
      v68 = (std::__shared_weak_count *)v74.i64[1];
      if (v74.i64[1])
      {
        v69 = (unint64_t *)(v74.i64[1] + 8);
        do
          v70 = __ldaxr(v69);
        while (__stlxr(v70 - 1, v69));
        if (!v70)
        {
          ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
          std::__shared_weak_count::__release_weak(v68);
        }
      }
      v12 = (const KB::Candidate *)((char *)v12 + 1000);
      if (v12 == v72)
        return v81 != 0;
    }
LABEL_37:
    *v23 = 0;
    v23[1] = 0;
    v23[2] = v26;
    *v27 = v23;
    v32 = **(_QWORD **)(a1 + 328);
    v33 = v23;
    if (v32)
    {
      *(_QWORD *)(a1 + 328) = v32;
      v33 = *v27;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 336), v33);
    ++*(_QWORD *)(a1 + 344);
    v83 = (void **)v82;
    std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v83);
    v35 = (_QWORD *)v23[8];
    v36 = *(_QWORD *)(a1 + 312);
    v35[7] = 0;
    v35[8] = v36;
    if (v36)
      *(_QWORD *)(v36 + 56) = v35;
    *(_QWORD *)(a1 + 312) = v35;
    v37 = *(_QWORD **)(a1 + 320);
    if (!v37)
    {
      *(_QWORD *)(a1 + 320) = v35;
      v37 = v35;
    }
    v38 = *(_QWORD *)(a1 + 344);
    if (v38 > *(_QWORD *)(a1 + 304))
    {
      v39 = v37[7];
      v40 = v37[8];
      if (v39)
        *(_QWORD *)(v39 + 64) = v40;
      if (v40)
        *(_QWORD *)(v40 + 56) = v39;
      if (v35 == v37)
        *(_QWORD *)(a1 + 312) = v40;
      *(_QWORD *)(a1 + 320) = v39;
      v41 = *(uint64_t **)(a1 + 336);
      if (v41)
      {
        v42 = (const char *)v37[1];
        v43 = (const char *)(v37 + 2);
        if (v42)
          v44 = v42;
        else
          v44 = v43;
        v45 = (uint64_t *)(a1 + 336);
        v46 = *(_QWORD *)(a1 + 336);
        do
        {
          if (*(_QWORD *)(v46 + 40))
            v47 = *(const char **)(v46 + 40);
          else
            v47 = (const char *)(v46 + 48);
          v34 = (KB::LanguageModel *)strcmp(v47, v44);
          v48 = (uint64_t *)(v46 + 8);
          if ((int)v34 >= 0)
          {
            v48 = (uint64_t *)v46;
            v45 = (uint64_t *)v46;
          }
          v46 = *v48;
        }
        while (*v48);
        if ((uint64_t *)(a1 + 336) != v45)
        {
          v49 = v45[5] ? (const char *)v45[5] : (const char *)(v45 + 6);
          v34 = (KB::LanguageModel *)strcmp(v44, v49);
          if ((v34 & 0x80000000) == 0)
          {
            v50 = (uint64_t *)v45[1];
            v51 = v45;
            if (v50)
            {
              do
              {
                v52 = v50;
                v50 = (uint64_t *)*v50;
              }
              while (v50);
            }
            else
            {
              do
              {
                v52 = (uint64_t *)v51[2];
                v53 = *v52 == (_QWORD)v51;
                v51 = v52;
              }
              while (!v53);
            }
            if (*(uint64_t **)(a1 + 328) == v45)
              *(_QWORD *)(a1 + 328) = v52;
            *(_QWORD *)(a1 + 344) = v38 - 1;
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v41, v45);
            std::__destroy_at[abi:nn180100]<std::pair<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,0>((uint64_t)(v45 + 4));
            operator delete(v45);
          }
        }
      }
    }
LABEL_85:
    v13 = (_QWORD *)(a1 + 336);
    goto LABEL_86;
  }
  return v81 != 0;
}

uint64_t KB::LanguageModelStr::completions(uint64_t a1, const KB::Candidate **a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  int v12;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  KB::Candidate *v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  const KB::Candidate *v20;
  KB::Candidate *v21;
  __n128 v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  _QWORD *v27;
  uint64_t v28;
  KB::Candidate *v30;
  KB::Candidate *v31;
  char *v32;
  KB::Candidate *v33;
  char *v34;
  uint64_t v35;
  KB::Candidate **v36;
  _BYTE v37[24];
  _BYTE *v38;
  _BYTE v39[1000];
  _QWORD v40[3];
  _QWORD *v41;
  void **v42[125];
  _BYTE v43[24];
  _BYTE *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1);
  if (a6 != 1 || !v12)
  {
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1) & 1) != 0)
      goto LABEL_8;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate *)&v33, *a2, a2[1], 0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3));
    v16 = v33;
    v17 = v34;
    v18 = 126 - 2 * __clz(0x1CAC083126E978D5 * ((v34 - (char *)v33) >> 3));
    if (v34 == (char *)v33)
      v19 = 0;
    else
      v19 = v18;
    std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,false>(v33, (uint64_t *)v34, v19, 1);
    if (v17 == (char *)v16)
    {
      v13 = 0;
LABEL_37:
      v42[0] = (void **)&v33;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v42);
      return v13 & 1;
    }
    v13 = 0;
    v20 = v16;
    while (1)
    {
      KB::Candidate::Candidate((KB::Candidate *)v42, v20);
      KB::Candidate::pop_last_word((KB::Candidate *)v42);
      if (v42[0])
        break;
LABEL_32:
      KB::Candidate::~Candidate((KB::Candidate *)v42);
      v20 = (const KB::Candidate *)((char *)v20 + 1000);
      v16 = (KB::Candidate *)((char *)v16 + 1000);
      if (v20 == (const KB::Candidate *)v17)
        goto LABEL_37;
    }
    v40[0] = &off_1EA0FA860;
    v40[1] = v16;
    v40[2] = a4;
    v41 = v40;
    KB::Candidate::Candidate((KB::Candidate *)v39, (const KB::Candidate *)v42);
    v30 = (KB::Candidate *)operator new(0x3E8uLL);
    v31 = v30;
    v21 = (KB::Candidate *)((char *)v30 + 1000);
    v32 = (char *)v30 + 1000;
    KB::Candidate::Candidate(v30, (const KB::Candidate *)v39);
    v31 = v21;
    if (v41)
    {
      if (v41 == v40)
      {
        v38 = v37;
        v22 = ((__n128 (*)(uint64_t, uint64_t))*(_QWORD *)(v40[0] + 24))((uint64_t)v40, (uint64_t)v37);
      }
      else
      {
        v38 = (_BYTE *)(*(uint64_t (**)(void))(*v41 + 16))();
      }
    }
    else
    {
      v38 = 0;
    }
    (*(void (**)(uint64_t, KB::Candidate **, uint64_t, _BYTE *, _QWORD, __n128))(*(_QWORD *)a1 + 488))(a1, &v30, a3, v37, 0, v22);
    v23 = v38;
    if (v38 == v37)
    {
      v23 = v37;
      v24 = 4;
    }
    else
    {
      if (!v38)
        goto LABEL_25;
      v24 = 5;
    }
    (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_25:
    v36 = &v30;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v36);
    KB::Candidate::~Candidate((KB::Candidate *)v39);
    v25 = *(_QWORD *)(a5 + 24);
    if (!v25)
      std::__throw_bad_function_call[abi:nn180100]();
    v26 = (*(uint64_t (**)(uint64_t, const KB::Candidate *))(*(_QWORD *)v25 + 48))(v25, v20);
    v27 = v41;
    if (v41 == v40)
    {
      v27 = v40;
      v28 = 4;
    }
    else
    {
      if (!v41)
      {
LABEL_31:
        v13 |= v26;
        goto LABEL_32;
      }
      v28 = 5;
    }
    (*(void (**)(void))(*v27 + 8 * v28))();
    goto LABEL_31;
  }
  if (a2[1] == *a2)
  {
LABEL_8:
    v13 = 0;
    return v13 & 1;
  }
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v43, a4);
  v13 = (*(uint64_t (**)(uint64_t, const KB::Candidate **, uint64_t, _BYTE *, _QWORD))(*(_QWORD *)a1 + 488))(a1, a2, a3, v43, 0);
  v14 = v44;
  if (v44 == v43)
  {
    v15 = 4;
    v14 = v43;
    goto LABEL_35;
  }
  if (v44)
  {
    v15 = 5;
LABEL_35:
    (*(void (**)(void))(*v14 + 8 * v15))();
  }
  return v13 & 1;
}

void KB::LanguageModelStr::predictions_with_stems(uint64_t a1, _QWORD *a2)
{
  NSObject *log;
  const void *v5;
  os_signpost_id_t v6;
  os_signpost_id_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  os_signpost_id_t v11;
  os_signpost_id_t v12;
  uint8_t v13[16];
  uint8_t buf[16];

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) && a2[1] != *a2)
  {
    kdebug_trace();
    log = kac_get_log();
    v5 = (const void *)(a1 ^ 0xCC);
    v6 = os_signpost_id_make_with_pointer(log, (const void *)(a1 ^ 0xCC));
    if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v7 = v6;
      if (os_signpost_enabled(log))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1DA6F2000, log, OS_SIGNPOST_INTERVAL_BEGIN, v7, "kbdManager.languageModel.toucanGenerateCompletionsAndPredictions", "", buf, 2u);
      }
    }
    v8 = *(_QWORD *)(a1 + 184);
    if (v8)
      atomic_store(1u, (unsigned __int8 *)(v8 + 752));
    std::mutex::lock(*(std::mutex **)(a1 + 136));
    v9 = *(_QWORD *)(a1 + 184);
    if (v9)
      atomic_store(0, (unsigned __int8 *)(v9 + 752));
    language_modeling::v1::LanguageModelSession::enumeratePredictions();
    std::mutex::unlock(*(std::mutex **)(a1 + 136));
    kdebug_trace();
    v10 = kac_get_log();
    v11 = os_signpost_id_make_with_pointer(v10, v5);
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v12 = v11;
      if (os_signpost_enabled(v10))
      {
        *(_WORD *)v13 = 0;
        _os_signpost_emit_with_name_impl(&dword_1DA6F2000, v10, OS_SIGNPOST_INTERVAL_END, v12, "kbdManager.languageModel.toucanGenerateCompletionsAndPredictions", "", v13, 2u);
      }
    }
  }
}

void KB::LanguageModelStr::inline_completions_with_stems(uint64_t a1@<X0>, uint64_t *a2@<X1>, const KB::LanguageModelContext *a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  _BYTE *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  language_modeling::v1::CompletionStem *v26[2];
  void *__p[2];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  void **v35;
  uint64_t v36;
  _QWORD v37[3];
  _QWORD *v38;
  _BYTE v39[1000];
  _BYTE v40[24];
  _BYTE *v41;
  void **v42[3];
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) & 1) != 0)
  {
    v26[0] = 0;
    v26[1] = 0;
    __p[0] = 0;
    convert_to_lm_completion_stem(a2, (int64x2_t *)v26, 0);
    LODWORD(v25) = *(_DWORD *)(a1 + 88);
    HIDWORD(v25) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    TIInlineCompletionGeneratorImpl::cachedCompletionsForContextAndStem(*(TIInlineCompletionGeneratorImpl **)(a1 + 184), a3, v26[0], (uint64_t)v42);
    if (v43)
    {
      KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)const::$_0::operator()((uint64_t *)&v33, (uint64_t)&v25, (const TIInlineCompletion *)v42[0], (const TIInlineCompletion *)v42[1]);
      *(_OWORD *)a6 = v33;
      *(_QWORD *)(a6 + 16) = v34;
      v34 = 0;
      v33 = 0uLL;
      *(_BYTE *)(a6 + 24) = 1;
      v35 = (void **)&v33;
      std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v35);
      *(_QWORD *)&v33 = v42;
      std::vector<TIInlineCompletion>::__destroy_vector::operator()[abi:nn180100]((void ***)&v33);
LABEL_29:
      v42[0] = (void **)v26;
      std::vector<language_modeling::v1::CompletionStem>::__destroy_vector::operator()[abi:nn180100](v42);
      return;
    }
    v16 = *(_QWORD *)(a1 + 184);
    v36 = v25;
    v17 = v37;
    std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v37, a5);
    KB::Candidate::Candidate((KB::Candidate *)v39, (const KB::Candidate *)*a2);
    v18 = operator new(0x418uLL);
    v19 = v18;
    v20 = v36;
    v21 = v38;
    *v18 = &off_1EA0FA970;
    v18[1] = v20;
    if (v21)
    {
      if (v21 == v37)
      {
        v18[5] = v18 + 2;
        (*(void (**)(_QWORD *))(v37[0] + 24))(v37);
      }
      else
      {
        v18[5] = v21;
        v38 = 0;
      }
    }
    else
    {
      v18[5] = 0;
    }
    KB::Candidate::Candidate((uint64_t)(v19 + 48), (uint64_t)v39);
    v41 = v19;
    TIInlineCompletionGeneratorImpl::enumerateInlineCompletionsWithLM(v16, a3, v26, a4, (uint64_t)v40);
    v22 = v41;
    if (v41 == v40)
    {
      v23 = 4;
      v22 = v40;
    }
    else
    {
      if (!v41)
        goto LABEL_23;
      v23 = 5;
    }
    (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_23:
    KB::Candidate::~Candidate((KB::Candidate *)v39);
    if (v38 == v37)
    {
      v24 = 4;
    }
    else
    {
      if (!v38)
      {
LABEL_28:
        *(_BYTE *)a6 = 0;
        *(_BYTE *)(a6 + 24) = 0;
        goto LABEL_29;
      }
      v24 = 5;
      v17 = v38;
    }
    (*(void (**)(_QWORD *))(*v17 + 8 * v24))(v17);
    goto LABEL_28;
  }
  v33 = 0uLL;
  v34 = 0;
  bzero(v42, 0x3E8uLL);
  KB::Candidate::Candidate((KB::Candidate *)v42);
  v32 = 0;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  *(_OWORD *)v26 = 0u;
  *(_OWORD *)__p = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v30);
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v30 + 8));
  v31 = 0uLL;
  v32 = 0;
  v12 = *(_QWORD *)(a5 + 24);
  if (v12)
  {
    (*(void (**)(uint64_t, __int128 *, void ***, language_modeling::v1::CompletionStem **))(*(_QWORD *)v12 + 48))(v12, &v33, v42, v26);
    v35 = (void **)&v31;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v35);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v30 + 8));
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v30);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v13 = (std::__shared_weak_count *)v26[1];
    if (v26[1])
    {
      v14 = (unint64_t *)((char *)v26[1] + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    KB::Candidate::~Candidate((KB::Candidate *)v42);
    *(_BYTE *)a6 = 0;
    *(_BYTE *)(a6 + 24) = 0;
    v42[0] = (void **)&v33;
    std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](v42);
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    KB::LanguageModelStr::register_inline_completion_acceptance_rejection();
  }
}

void KB::LanguageModelStr::register_inline_completion_acceptance_rejection(uint64_t a1, const KB::String *a2, const KB::String *a3, const KB::String *a4, int a5)
{
  uint64_t v5;

  v5 = *(_QWORD *)(a1 + 184);
  if (v5)
    TIInlineCompletionEventDispatcher::did_register_completion_acceptance(*(_QWORD *)(v5 + 736), a2, a3, a4, a5);
}

uint64_t KB::LanguageModelStr::background_load(KB::LanguageModelStr *this)
{
  return (*(uint64_t (**)(KB::LanguageModelStr *, uint64_t))(*(_QWORD *)this + 72))(this, 1);
}

void KB::LanguageModelStr::do_store(KB::LanguageModelStr *this, int a2)
{
  KB::LanguageModel *v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[6];
  std::__shared_weak_count *v14;

  v4 = (KB::LanguageModel *)(*(uint64_t (**)(KB::LanguageModelStr *))(*(_QWORD *)this + 16))(this);
  if ((_DWORD)v4)
  {
    if (a2)
    {
      v5 = *((_QWORD *)this + 23);
      if (v5)
        atomic_store(1u, (unsigned __int8 *)(v5 + 752));
      std::mutex::lock(*((std::mutex **)this + 17));
      v6 = *((_QWORD *)this + 23);
      if (v6)
        atomic_store(0, (unsigned __int8 *)(v6 + 752));
      language_modeling::v1::LanguageModelSession::flushCacheAndRecencyData(*((language_modeling::v1::LanguageModelSession **)this
                                                                            + 25));
      std::mutex::unlock(*((std::mutex **)this + 17));
    }
    v13[0] = 0;
    v13[1] = v13;
    v13[2] = 0x3802000000;
    v13[3] = __Block_byref_object_copy__25;
    v13[4] = __Block_byref_object_dispose__26;
    v7 = (std::__shared_weak_count *)*((_QWORD *)this + 22);
    v13[5] = *((_QWORD *)this + 21);
    v14 = v7;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    KB::LanguageModel::background_loading_queue(v4);
    TIDispatchAsync();
    _Block_object_dispose(v13, 8);
    v10 = v14;
    if (v14)
    {
      v11 = (unint64_t *)&v14->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
}

uint64_t KB::LanguageModelStr::last_set_supplemental_word_lexicon(KB::LanguageModelStr *this)
{
  return *((_QWORD *)this + 29);
}

uint64_t KB::LanguageModelStr::last_set_supplemental_phrase_lexicon(KB::LanguageModelStr *this)
{
  return *((_QWORD *)this + 30);
}

__n128 __Block_byref_object_copy__25(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__26(uint64_t a1)
{
  return std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](a1 + 40);
}

void ___ZN2KB16LanguageModelStr8do_storeEb_block_invoke(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;

  language_modeling::v1::LanguageModel::flushDynamicData(*(language_modeling::v1::LanguageModel **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)
                                                                                                  + 40));
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v3 = *(std::__shared_weak_count **)(v2 + 48);
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 0;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

uint64_t std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

_QWORD *std::string::basic_string[abi:nn180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

KB::Candidate *KB::Candidate::Candidate(KB::Candidate *this)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = (char *)this + 24;
  *((_QWORD *)this + 2) = 3;
  *(_OWORD *)((char *)this + 744) = xmmword_1DA910F30;
  *((_QWORD *)this + 95) = 0xFF8000003F800000;
  *((_QWORD *)this + 105) = 0;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 848));
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 856));
  *((_QWORD *)this + 109) = 0;
  *((_QWORD *)this + 108) = 0;
  *((_QWORD *)this + 110) = 0;
  *((_DWORD *)this + 222) = 0x100000;
  *((_WORD *)this + 446) = 0;
  *((_BYTE *)this + 894) = 0;
  *((_QWORD *)this + 112) = 0;
  *((_BYTE *)this + 904) = 0;
  *((_QWORD *)this + 115) = 0;
  *((_OWORD *)this + 58) = 0u;
  *((_WORD *)this + 472) = 0;
  *((_DWORD *)this + 240) = 0;
  *((_BYTE *)this + 964) = 0;
  *((_OWORD *)this + 61) = 0u;
  *((_DWORD *)this + 248) = 0;
  return this;
}

void std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 160;
        std::__destroy_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void convert_to_lm_completion_stem(uint64_t *a1, int64x2_t *a2, int a3)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  KB::Word *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  void **v14;
  const char *v15;
  char *v16;
  _QWORD *v17;
  uint64_t v18;
  language_modeling::v1::CompletionStem *v19;
  unint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  void *v30;
  int64x2_t v31;
  unint64_t v32;
  int64x2_t *v33;
  uint64_t v35;
  char v36[8];
  void *__p;
  void *v38;
  char v39;
  char v40;
  int v41;
  __int16 v42;
  char v43;
  void *v44;
  _BYTE v45[16];
  void *v46;
  void *v47[2];
  unint64_t v48;
  uint64_t *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (a1[1] != *a1)
  {
    v5 = 0;
    v33 = a2 + 1;
    do
    {
      language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)v36);
      v41 = 0x100000;
      v42 = 0;
      v43 = 0;
      v44 = 0;
      v45[0] = 0;
      v6 = *a1;
      if (*(_QWORD *)(*a1 + 1000 * v5))
      {
        v7 = 0;
        v8 = 0;
        do
        {
          v9 = v8;
          v10 = (KB::Word *)(*(_QWORD *)(v6 + 1000 * v5 + 8) + v7);
          if (KB::Word::is_linguistically_void(v10))
          {
            v11 = (char *)v44;
            if (!v44)
              v11 = v45;
            if ((_WORD)v41)
              v12 = v11;
            else
              v12 = "";
            std::string::basic_string[abi:nn180100]<0>(&__p, v12);
            if (v9)
              v13 = *(_QWORD *)(*(_QWORD *)(*a1 + 1000 * v5 + 8) + 240 * (v9 - 1) + 136);
            else
              v13 = 0;
            v35 = v13;
            KB::LanguageModelContext::linguistic_token((uint64_t)&__p, (TITokenID)&v35, (uint64_t)&v46);
            if (v40 < 0)
              operator delete(__p);
            language_modeling::v1::CompletionStem::try_push_back();
            LODWORD(__p) = 0x100000;
            WORD2(__p) = 0;
            BYTE6(__p) = 0;
            v38 = 0;
            v39 = 0;
            KB::String::operator=((uint64_t)&v41, (KB::String *)&__p);
            if (v38 && BYTE6(__p) == 1)
              free(v38);
            if (SHIBYTE(v47[1]) < 0)
              operator delete(v46);
          }
          else
          {
            KB::Word::capitalized_string(v10, (uint64_t)&v46);
            v14 = (void **)v47[0];
            if (!v47[0])
              v14 = &v47[1];
            if ((_WORD)v46)
              v15 = (const char *)v14;
            else
              v15 = "";
            KB::String::append((unsigned __int16 *)&v41, v15, 0xFFFFuLL);
            if (v47[0] && BYTE6(v46) == 1)
              free(v47[0]);
          }
          v8 = v9 + 1;
          v6 = *a1;
          v7 += 240;
        }
        while (*(_QWORD *)(*a1 + 1000 * v5) > (unint64_t)(v9 + 1));
        if ((_WORD)v41)
        {
          if (v44)
            v16 = (char *)v44;
          else
            v16 = v45;
          std::string::basic_string[abi:nn180100]<0>(&__p, v16);
          v17 = (_QWORD *)(*a1 + 1000 * v5);
          if (*v17 <= (unint64_t)(int)v9)
            v18 = 0;
          else
            v18 = *(_QWORD *)(v17[1] + 240 * (int)v9 + 136);
          v35 = v18;
          KB::LanguageModelContext::linguistic_token((uint64_t)&__p, (TITokenID)&v35, (uint64_t)&v46);
          if (v40 < 0)
            operator delete(__p);
          language_modeling::v1::CompletionStem::try_push_back();
          if (SHIBYTE(v47[1]) < 0)
            operator delete(v46);
        }
      }
      if (a3)
      {
        std::string::basic_string[abi:nn180100]<0>(&v46, "");
        LODWORD(v48) = 0;
        language_modeling::v1::CompletionStem::try_push_back();
        if (SHIBYTE(v47[1]) < 0)
          operator delete(v46);
      }
      language_modeling::v1::CompletionStem::set_unique_id((language_modeling::v1::CompletionStem *)v36);
      language_modeling::v1::CompletionStem::set_score((language_modeling::v1::CompletionStem *)v36, *(float *)(*a1 + 1000 * v5 + 748) / 2.30258509 / *(float *)(*a1 + 1000 * v5 + 760));
      v19 = (language_modeling::v1::CompletionStem *)a2->i64[1];
      v20 = a2[1].u64[0];
      if ((unint64_t)v19 >= v20)
      {
        v22 = ((uint64_t)v19 - a2->i64[0]) >> 3;
        if ((unint64_t)(v22 + 1) >> 61)
          abort();
        v23 = v20 - a2->i64[0];
        v24 = v23 >> 2;
        if (v23 >> 2 <= (unint64_t)(v22 + 1))
          v24 = v22 + 1;
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
          v25 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v25 = v24;
        v49 = (uint64_t *)v33;
        if (v25)
          v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v25);
        else
          v26 = 0;
        v27 = v25 + 8 * v22;
        v46 = (void *)v25;
        v47[0] = (void *)v27;
        v48 = v25 + 8 * v26;
        language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)v27, (const language_modeling::v1::CompletionStem *)v36);
        v21 = (void *)(v27 + 8);
        v47[1] = (void *)(v27 + 8);
        v29 = a2->i64[0];
        v28 = a2->u64[1];
        v30 = v47[0];
        if (v28 == a2->i64[0])
        {
          v31 = vdupq_n_s64(v28);
        }
        else
        {
          do
          {
            v28 -= 8;
            v30 = (void *)language_modeling::v1::CompletionStem::CompletionStem();
          }
          while (v28 != v29);
          v31 = *a2;
          v21 = v47[1];
        }
        a2->i64[0] = (uint64_t)v30;
        a2->i64[1] = (uint64_t)v21;
        *(int64x2_t *)v47 = v31;
        v32 = a2[1].u64[0];
        a2[1].i64[0] = v48;
        v48 = v32;
        v46 = (void *)v31.i64[0];
        std::__split_buffer<language_modeling::v1::CompletionStem>::~__split_buffer((uint64_t)&v46);
      }
      else
      {
        v21 = (void *)(language_modeling::v1::CompletionStem::CompletionStem(v19, (const language_modeling::v1::CompletionStem *)v36)+ 8);
      }
      a2->i64[1] = (uint64_t)v21;
      if (v44)
      {
        if (v43 == 1)
          free(v44);
      }
      language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)v36);
      ++v5;
    }
    while (0x1CAC083126E978D5 * ((a1[1] - *a1) >> 3) > v5);
  }
}

void KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)const::$_0::operator()(uint64_t *a1, uint64_t a2, const TIInlineCompletion *a3, const TIInlineCompletion *a4)
{
  const TIInlineCompletion *v5;
  unint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  void **v22;
  void *v24[2];
  uint64_t v25;
  __int128 v26;
  int v27;
  __int128 v28;
  uint64_t v29;
  __int128 __p;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  void **v37[6];

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3 != a4)
  {
    v5 = a3;
    v22 = (void **)(a1 + 2);
    do
    {
      KB::LanguageModel::PredictionInfo::PredictionInfo((KB::LanguageModel::PredictionInfo *)v24, v5, *(_DWORD *)(a2 + 4));
      v7 = a1[1];
      v8 = a1[2];
      if (v7 >= v8)
      {
        v13 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 5);
        v14 = v13 + 1;
        if (v13 + 1 > 0x199999999999999)
          abort();
        v15 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v8 - *a1) >> 5);
        if (2 * v15 > v14)
          v14 = 2 * v15;
        if (v15 >= 0xCCCCCCCCCCCCCCLL)
          v16 = 0x199999999999999;
        else
          v16 = v14;
        v37[4] = v22;
        if (v16)
          v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v16);
        else
          v17 = 0;
        v18 = v16 + 160 * v13;
        v37[0] = (void **)v16;
        v37[1] = (void **)v18;
        v37[3] = (void **)(v16 + 160 * v17);
        *(_QWORD *)v18 = 0;
        *(_QWORD *)(v18 + 8) = 0;
        *(_QWORD *)(v18 + 16) = 0;
        *(_OWORD *)v18 = *(_OWORD *)v24;
        *(_QWORD *)(v18 + 16) = v25;
        v24[0] = 0;
        v24[1] = 0;
        v25 = 0;
        v19 = v26;
        *(_DWORD *)(v18 + 40) = v27;
        *(_OWORD *)(v18 + 24) = v19;
        v20 = v28;
        *(_QWORD *)(v18 + 64) = v29;
        *(_OWORD *)(v18 + 48) = v20;
        v29 = 0;
        v28 = 0uLL;
        v21 = __p;
        *(_QWORD *)(v18 + 88) = v31;
        *(_OWORD *)(v18 + 72) = v21;
        v31 = 0;
        __p = 0uLL;
        *(_QWORD *)(v18 + 96) = 0;
        *(_QWORD *)(v18 + 104) = 0;
        *(_QWORD *)(v18 + 112) = 0;
        *(_OWORD *)(v18 + 96) = v32;
        *(_QWORD *)(v18 + 112) = v33;
        v32 = 0uLL;
        v33 = 0;
        *(_QWORD *)(v18 + 120) = 0;
        *(_QWORD *)(v18 + 128) = 0;
        *(_QWORD *)(v18 + 136) = 0;
        *(_OWORD *)(v18 + 120) = v34;
        *(_QWORD *)(v18 + 136) = v35;
        v34 = 0uLL;
        v35 = 0;
        *(_OWORD *)(v18 + 144) = v36;
        v37[2] = (void **)(v18 + 160);
        std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer(a1, v37);
        v12 = a1[1];
        std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)v37);
      }
      else
      {
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_QWORD *)(v7 + 16) = 0;
        *(_OWORD *)v7 = *(_OWORD *)v24;
        *(_QWORD *)(v7 + 16) = v25;
        v24[0] = 0;
        v24[1] = 0;
        v25 = 0;
        v9 = v27;
        *(_OWORD *)(v7 + 24) = v26;
        *(_DWORD *)(v7 + 40) = v9;
        v10 = v29;
        *(_OWORD *)(v7 + 48) = v28;
        *(_QWORD *)(v7 + 64) = v10;
        v29 = 0;
        v28 = 0uLL;
        v11 = __p;
        *(_QWORD *)(v7 + 88) = v31;
        *(_QWORD *)(v7 + 96) = 0;
        *(_OWORD *)(v7 + 72) = v11;
        v31 = 0;
        __p = 0uLL;
        *(_QWORD *)(v7 + 104) = 0;
        *(_QWORD *)(v7 + 112) = 0;
        *(_OWORD *)(v7 + 96) = v32;
        v32 = 0uLL;
        *(_QWORD *)(v7 + 112) = v33;
        *(_QWORD *)(v7 + 120) = 0;
        v33 = 0;
        *(_QWORD *)(v7 + 128) = 0;
        *(_QWORD *)(v7 + 136) = 0;
        *(_OWORD *)(v7 + 120) = v34;
        *(_QWORD *)(v7 + 136) = v35;
        v34 = 0uLL;
        v35 = 0;
        *(_OWORD *)(v7 + 144) = v36;
        v12 = v7 + 160;
      }
      a1[1] = v12;
      v37[0] = (void **)&v34;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v37);
      v37[0] = (void **)&v32;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v37);
      if (SHIBYTE(v31) < 0)
        operator delete((void *)__p);
      if (SHIBYTE(v29) < 0)
        operator delete((void *)v28);
      if (v24[0])
      {
        v24[1] = v24[0];
        operator delete(v24[0]);
      }
      v5 = (const TIInlineCompletion *)((char *)v5 + 80);
    }
    while (v5 != a4);
  }
}

uint64_t std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

void std::vector<TIInlineCompletion>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<TIInlineCompletion,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<language_modeling::v1::CompletionStem>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)(v4 - 8));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:nn180100]<TIInlineCompletion,0>(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 72))
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 64));
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

_QWORD *std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1EA0FA970;
  KB::Candidate::~Candidate((KB::Candidate *)(a1 + 6));
  v2 = (_QWORD *)a1[5];
  if (v2 == a1 + 2)
  {
    v3 = 4;
    v2 = a1 + 2;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

void std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1EA0FA970;
  KB::Candidate::~Candidate((KB::Candidate *)(a1 + 6));
  v2 = (_QWORD *)a1[5];
  if (v2 == a1 + 2)
  {
    v3 = 4;
    v2 = a1 + 2;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0x418uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_1EA0FA970;
  v2[1] = v3;
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)(v2 + 2), a1 + 16);
  KB::Candidate::Candidate((KB::Candidate *)(v2 + 6), (const KB::Candidate *)(a1 + 48));
  return v2;
}

KB::Candidate *std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA0FA970;
  a2[1] = *(_QWORD *)(a1 + 8);
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)(a2 + 2), a1 + 16);
  return KB::Candidate::Candidate((KB::Candidate *)(a2 + 6), (const KB::Candidate *)(a1 + 48));
}

_QWORD *std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::destroy(_QWORD *a1)
{
  _QWORD *result;
  uint64_t v3;

  KB::Candidate::~Candidate((KB::Candidate *)(a1 + 6));
  result = (_QWORD *)a1[5];
  if (result == a1 + 2)
  {
    v3 = 4;
    result = a1 + 2;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::destroy_deallocate(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  KB::Candidate::~Candidate((KB::Candidate *)(a1 + 6));
  v2 = (_QWORD *)a1[5];
  if (v2 == a1 + 2)
  {
    v3 = 4;
    v2 = a1 + 2;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  operator delete(a1);
}

double std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::operator()(uint64_t a1, const TIInlineCompletion **a2, uint64_t a3)
{
  uint64_t v5;
  double result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9[3];
  void **v10;

  KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)const::$_0::operator()(v9, a1 + 8, *a2, a2[1]);
  v5 = *(_QWORD *)(a1 + 40);
  if (v5)
  {
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v5 + 48))(v5, v9, a1 + 48, a3);
    v10 = (void **)v9;
    std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v10);
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    *(_QWORD *)&result = std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo*>(v7, v8).n128_u64[0];
  }
  return result;
}

__n128 std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo*>(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __n128 result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v2 = *(_OWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v2;
  v3 = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v3;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  v4 = *(_OWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v4;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  *(_QWORD *)(a2 + 136) = 0;
  result = *(__n128 *)(a2 + 144);
  *(__n128 *)(a1 + 144) = result;
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(unint64_t a1)
{
  if (a1 >= 0x19999999999999ALL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(160 * a1);
}

void std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  v6 = a2[1];
  while (v4 != v5)
  {
    v4 -= 160;
    std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo*>(v6 - 160, v4);
  }
  a2[1] = v6;
  v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

uint64_t std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 160;
    std::__destroy_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,0>(i - 160);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__destroy_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,0>(uint64_t a1)
{
  void *v2;
  void **v3;

  v3 = (void **)(a1 + 120);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v3);
  v3 = (void **)(a1 + 96);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v3);
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  v2 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

uint64_t std::__split_buffer<language_modeling::v1::CompletionStem>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

KB::Candidate *std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>(KB::Candidate *result, const KB::Candidate *a2, const KB::Candidate *a3, unint64_t a4)
{
  KB::Candidate *v6;
  KB::Candidate *v7;

  if (a4)
  {
    v6 = result;
    std::vector<KB::Candidate>::__vallocate[abi:nn180100](result, a4);
    result = (KB::Candidate *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v7 = KB::Candidate::Candidate(result, a2);
      a2 = (const KB::Candidate *)((char *)a2 + 1000);
      result = (KB::Candidate *)((char *)v7 + 1000);
    }
    *((_QWORD *)v6 + 1) = result;
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,false>(KB::Candidate *a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v8;
  KB::Candidate *v9;
  KB::Candidate *v10;
  KB::Candidate *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  KB::Candidate *v15;
  KB::Candidate *v16;
  KB::Candidate *v17;
  KB::Candidate *v18;
  void *v19;
  const char *v20;
  void *v21;
  const char *v22;
  int v23;
  uint64_t *v24;
  char v25;
  char v26;
  KB::Candidate *v27;
  void *v28;
  const char *v29;
  void *v30;
  const char *v31;
  int v32;
  _BYTE v33[6];
  char v34;
  void *v35;
  _BYTE v36[16];
  _BYTE v37[6];
  char v38;
  void *v39;
  _QWORD v40[3];

  v40[2] = *MEMORY[0x1E0C80C00];
  while (2)
  {
    v8 = (uint64_t)a1;
    v9 = (KB::Candidate *)((char *)a1 + 1000);
    v10 = (KB::Candidate *)((char *)a1 + 2000);
    v11 = (KB::Candidate *)((char *)a1 - 1000);
    --a3;
LABEL_3:
    v12 = (uint64_t)a2 - v8;
    v13 = 0x1CAC083126E978D5 * (((uint64_t)a2 - v8) >> 3);
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v27 = (KB::Candidate *)(a2 - 125);
        KB::Candidate::capitalized_string(v27, (uint64_t)v37);
        KB::Candidate::capitalized_string((KB::Candidate *)v8, (uint64_t)v33);
        v28 = v39;
        if (v39)
          v29 = (const char *)v39;
        else
          v29 = (const char *)v40;
        v30 = v35;
        if (v35)
          v31 = (const char *)v35;
        else
          v31 = v36;
        v32 = strcmp(v29, v31);
        if (v30 && v34 == 1)
        {
          free(v30);
          v28 = v39;
        }
        if (v28 && v38 == 1)
          free(v28);
        if (v32 < 0)
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v8, (uint64_t *)v27);
        return;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)v8, (KB::Candidate *)(v8 + 1000), (KB::Candidate *)(a2 - 125));
        return;
      case 4uLL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)v8, (KB::Candidate *)(v8 + 1000), (KB::Candidate *)(v8 + 2000), (KB::Candidate *)(a2 - 125));
        return;
      case 5uLL:
        std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,0>((KB::Candidate *)v8, (KB::Candidate *)(v8 + 1000), (KB::Candidate *)(v8 + 2000), (KB::Candidate *)(v8 + 3000), (KB::Candidate *)(a2 - 125));
        return;
      default:
        if (v12 <= 23999)
        {
          if ((a4 & 1) != 0)
            std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((uint64_t *)v8, a2);
          else
            std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((uint64_t *)v8, a2);
          return;
        }
        if (a3 == -1)
        {
          std::__partial_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,KB::Candidate*>(v8, (KB::Candidate *)a2, (KB::Candidate *)a2);
          return;
        }
        v14 = v13 >> 1;
        v15 = (KB::Candidate *)(v8 + 1000 * (v13 >> 1));
        v16 = (KB::Candidate *)(a2 - 125);
        if ((unint64_t)v12 < 0x1F401)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(v15, (KB::Candidate *)v8, v16);
          if ((a4 & 1) != 0)
            goto LABEL_23;
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)v8, v15, v16);
          v17 = (KB::Candidate *)(v8 + 1000 * v14);
          v18 = (KB::Candidate *)((char *)v17 - 1000);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(v9, (KB::Candidate *)((char *)v17 - 1000), (KB::Candidate *)(a2 - 250));
          v17 = (KB::Candidate *)((char *)v17 + 1000);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(v10, v17, (KB::Candidate *)(a2 - 375));
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(v18, v15, v17);
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v8, (uint64_t *)v15);
          if ((a4 & 1) != 0)
            goto LABEL_23;
        }
        KB::Candidate::capitalized_string(v11, (uint64_t)v37);
        KB::Candidate::capitalized_string((KB::Candidate *)v8, (uint64_t)v33);
        v19 = v39;
        if (v39)
          v20 = (const char *)v39;
        else
          v20 = (const char *)v40;
        v21 = v35;
        if (v35)
          v22 = (const char *)v35;
        else
          v22 = v36;
        v23 = strcmp(v20, v22);
        if (v21 && v34 == 1)
        {
          free(v21);
          v19 = v39;
        }
        if (v19 && v38 == 1)
          free(v19);
        if ((v23 & 0x80000000) == 0)
        {
          a1 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,KB::Candidate *,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &>((uint64_t *)v8, (KB::Candidate *)a2);
          a4 = 0;
          continue;
        }
LABEL_23:
        v24 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,KB::Candidate *,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &>(v8, (KB::Candidate *)a2);
        if ((v25 & 1) == 0)
        {
LABEL_28:
          std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,false>(v8, v24, a3, a4 & 1);
          a4 = 0;
          a1 = (KB::Candidate *)(v24 + 125);
          continue;
        }
        v26 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(v8, (KB::Candidate *)v24);
        a1 = (KB::Candidate *)(v24 + 125);
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((uint64_t)(v24 + 125), (KB::Candidate *)a2))
        {
          if ((v26 & 1) != 0)
            continue;
          goto LABEL_28;
        }
        --a3;
        a2 = v24;
        if ((v26 & 1) == 0)
          goto LABEL_3;
        return;
    }
  }
}

void std::__function::__func<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1,std::allocator<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1,std::allocator<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA0FA860;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1,std::allocator<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FA860;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1,std::allocator<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, KB::LanguageModelContext *a4)
{
  const char *v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  unsigned int v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  void *__p;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void **v29;
  _QWORD *v30;
  _QWORD v31[3];

  v31[2] = *MEMORY[0x1E0C80C00];
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v22, a4);
  v7 = *(const char **)(a2 + 120);
  if (*(const char **)(a2 + 128) != v7)
  {
    if (v7[23] < 0)
      v7 = *(const char **)v7;
    KB::String::String((KB::String *)&v29, v7);
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + 240 * **(_QWORD **)(a1 + 8);
    v11 = *(unsigned __int16 *)(v8 - 240);
    v10 = v8 - 240;
    v9 = v11;
    if (v11 <= (unsigned __int16)v29)
    {
      v12 = (const char *)(v30 ? v30 : v31);
      v13 = *(_QWORD *)(v10 + 8);
      v14 = v10 + 16;
      v15 = (const char *)(v13 ? v13 : v14);
      if (!strncasecmp(v12, v15, v9))
      {
        v19 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24);
        if (!v19)
        {
          std::__throw_bad_function_call[abi:nn180100]();
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v20, v21);
          return;
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v19 + 48))(v19, a2, a3, &v22);
      }
    }
    if (v30 && BYTE6(v29) == 1)
      free(v30);
  }
  v29 = (void **)&v28;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v29);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v27);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v26);
  if (__p)
  {
    v25 = __p;
    operator delete(__p);
  }
  v16 = v23;
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4[126];

  v4[125] = *MEMORY[0x1E0C80C00];
  KB::Candidate::Candidate((uint64_t)v4, (uint64_t)a1);
  KB::Candidate::operator=(a1, a2);
  KB::Candidate::operator=(a2, v4);
  KB::Candidate::~Candidate((KB::Candidate *)v4);
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(KB::Candidate *a1, KB::Candidate *a2, KB::Candidate *a3)
{
  void *v6;
  const char *v7;
  void *v8;
  const char *v9;
  int v10;
  BOOL v11;
  void *v12;
  const char *v13;
  void *v14;
  const char *v15;
  int v16;
  void *v17;
  const char *v18;
  void *v19;
  const char *v20;
  int v21;
  uint64_t *v22;
  uint64_t *v23;
  void *v24;
  const char *v25;
  void *v26;
  const char *v27;
  int v28;
  void *v29;
  const char *v30;
  void *v31;
  const char *v32;
  int v33;
  _BYTE v34[6];
  char v35;
  void *v36;
  _BYTE v37[16];
  _BYTE v38[6];
  char v39;
  void *v40;
  _QWORD v41[3];

  v41[2] = *MEMORY[0x1E0C80C00];
  KB::Candidate::capitalized_string(a2, (uint64_t)v38);
  KB::Candidate::capitalized_string(a1, (uint64_t)v34);
  v6 = v40;
  if (v40)
    v7 = (const char *)v40;
  else
    v7 = (const char *)v41;
  v8 = v36;
  if (v36)
    v9 = (const char *)v36;
  else
    v9 = v37;
  v10 = strcmp(v7, v9);
  if (v8)
    v11 = v35 == 1;
  else
    v11 = 0;
  if (v11)
  {
    free(v8);
    v6 = v40;
  }
  if (v6 && v39 == 1)
    free(v6);
  if (v10 < 0)
  {
    KB::Candidate::capitalized_string(a3, (uint64_t)v38);
    KB::Candidate::capitalized_string(a2, (uint64_t)v34);
    v24 = v40;
    if (v40)
      v25 = (const char *)v40;
    else
      v25 = (const char *)v41;
    v26 = v36;
    if (v36)
      v27 = (const char *)v36;
    else
      v27 = v37;
    v28 = strcmp(v25, v27);
    if (v26 && v35 == 1)
    {
      free(v26);
      v24 = v40;
    }
    if (v24 && v39 == 1)
      free(v24);
    v22 = (uint64_t *)a1;
    if ((v28 & 0x80000000) == 0)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
      KB::Candidate::capitalized_string(a3, (uint64_t)v38);
      KB::Candidate::capitalized_string(a2, (uint64_t)v34);
      v29 = v40;
      if (v40)
        v30 = (const char *)v40;
      else
        v30 = (const char *)v41;
      v31 = v36;
      if (v36)
        v32 = (const char *)v36;
      else
        v32 = v37;
      v33 = strcmp(v30, v32);
      if (v31 && v35 == 1)
      {
        free(v31);
        v29 = v40;
      }
      if (v29 && v39 == 1)
        free(v29);
      if ((v33 & 0x80000000) == 0)
        return;
      v22 = (uint64_t *)a2;
    }
    v23 = (uint64_t *)a3;
    goto LABEL_72;
  }
  KB::Candidate::capitalized_string(a3, (uint64_t)v38);
  KB::Candidate::capitalized_string(a2, (uint64_t)v34);
  v12 = v40;
  if (v40)
    v13 = (const char *)v40;
  else
    v13 = (const char *)v41;
  v14 = v36;
  if (v36)
    v15 = (const char *)v36;
  else
    v15 = v37;
  v16 = strcmp(v13, v15);
  if (v14 && v35 == 1)
  {
    free(v14);
    v12 = v40;
  }
  if (v12 && v39 == 1)
    free(v12);
  if (v16 < 0)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
    KB::Candidate::capitalized_string(a2, (uint64_t)v38);
    KB::Candidate::capitalized_string(a1, (uint64_t)v34);
    v17 = v40;
    if (v40)
      v18 = (const char *)v40;
    else
      v18 = (const char *)v41;
    v19 = v36;
    if (v36)
      v20 = (const char *)v36;
    else
      v20 = v37;
    v21 = strcmp(v18, v20);
    if (v19 && v35 == 1)
    {
      free(v19);
      v17 = v40;
    }
    if (v17)
    {
      if (v39 == 1)
        free(v17);
    }
    if (v21 < 0)
    {
      v22 = (uint64_t *)a1;
      v23 = (uint64_t *)a2;
LABEL_72:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v22, v23);
    }
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(KB::Candidate *a1, KB::Candidate *a2, KB::Candidate *a3, KB::Candidate *a4)
{
  void *v8;
  const char *v9;
  void *v10;
  const char *v11;
  int v12;
  void *v13;
  const char *v14;
  void *v15;
  const char *v16;
  int v17;
  void *v18;
  const char *v19;
  void *v20;
  const char *v21;
  int v22;
  _BYTE v23[6];
  char v24;
  void *v25;
  _BYTE v26[16];
  _BYTE v27[6];
  char v28;
  void *v29;
  _QWORD v30[3];

  v30[2] = *MEMORY[0x1E0C80C00];
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(a1, a2, a3);
  KB::Candidate::capitalized_string(a4, (uint64_t)v27);
  KB::Candidate::capitalized_string(a3, (uint64_t)v23);
  v8 = v29;
  if (v29)
    v9 = (const char *)v29;
  else
    v9 = (const char *)v30;
  v10 = v25;
  if (v25)
    v11 = (const char *)v25;
  else
    v11 = v26;
  v12 = strcmp(v9, v11);
  if (v10 && v24 == 1)
  {
    free(v10);
    v8 = v29;
  }
  if (v8 && v28 == 1)
    free(v8);
  if (v12 < 0)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
    KB::Candidate::capitalized_string(a3, (uint64_t)v27);
    KB::Candidate::capitalized_string(a2, (uint64_t)v23);
    v13 = v29;
    if (v29)
      v14 = (const char *)v29;
    else
      v14 = (const char *)v30;
    v15 = v25;
    if (v25)
      v16 = (const char *)v25;
    else
      v16 = v26;
    v17 = strcmp(v14, v16);
    if (v15 && v24 == 1)
    {
      free(v15);
      v13 = v29;
    }
    if (v13 && v28 == 1)
      free(v13);
    if (v17 < 0)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
      KB::Candidate::capitalized_string(a2, (uint64_t)v27);
      KB::Candidate::capitalized_string(a1, (uint64_t)v23);
      v18 = v29;
      if (v29)
        v19 = (const char *)v29;
      else
        v19 = (const char *)v30;
      v20 = v25;
      if (v25)
        v21 = (const char *)v25;
      else
        v21 = v26;
      v22 = strcmp(v19, v21);
      if (v20 && v24 == 1)
      {
        free(v20);
        v18 = v29;
      }
      if (v18 && v28 == 1)
        free(v18);
      if (v22 < 0)
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
    }
  }
}

void std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,0>(KB::Candidate *a1, KB::Candidate *a2, KB::Candidate *a3, KB::Candidate *a4, KB::Candidate *a5)
{
  void *v10;
  const char *v11;
  void *v12;
  const char *v13;
  int v14;
  void *v15;
  const char *v16;
  void *v17;
  const char *v18;
  int v19;
  void *v20;
  const char *v21;
  void *v22;
  const char *v23;
  int v24;
  void *v25;
  const char *v26;
  void *v27;
  const char *v28;
  int v29;
  _BYTE v30[6];
  char v31;
  void *v32;
  _BYTE v33[16];
  _BYTE v34[6];
  char v35;
  void *v36;
  _QWORD v37[3];

  v37[2] = *MEMORY[0x1E0C80C00];
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(a1, a2, a3, a4);
  KB::Candidate::capitalized_string(a5, (uint64_t)v34);
  KB::Candidate::capitalized_string(a4, (uint64_t)v30);
  v10 = v36;
  if (v36)
    v11 = (const char *)v36;
  else
    v11 = (const char *)v37;
  v12 = v32;
  if (v32)
    v13 = (const char *)v32;
  else
    v13 = v33;
  v14 = strcmp(v11, v13);
  if (v12 && v31 == 1)
  {
    free(v12);
    v10 = v36;
  }
  if (v10 && v35 == 1)
    free(v10);
  if (v14 < 0)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a4, (uint64_t *)a5);
    KB::Candidate::capitalized_string(a4, (uint64_t)v34);
    KB::Candidate::capitalized_string(a3, (uint64_t)v30);
    v15 = v36;
    if (v36)
      v16 = (const char *)v36;
    else
      v16 = (const char *)v37;
    v17 = v32;
    if (v32)
      v18 = (const char *)v32;
    else
      v18 = v33;
    v19 = strcmp(v16, v18);
    if (v17 && v31 == 1)
    {
      free(v17);
      v15 = v36;
    }
    if (v15 && v35 == 1)
      free(v15);
    if (v19 < 0)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
      KB::Candidate::capitalized_string(a3, (uint64_t)v34);
      KB::Candidate::capitalized_string(a2, (uint64_t)v30);
      v20 = v36;
      if (v36)
        v21 = (const char *)v36;
      else
        v21 = (const char *)v37;
      v22 = v32;
      if (v32)
        v23 = (const char *)v32;
      else
        v23 = v33;
      v24 = strcmp(v21, v23);
      if (v22 && v31 == 1)
      {
        free(v22);
        v20 = v36;
      }
      if (v20 && v35 == 1)
        free(v20);
      if (v24 < 0)
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
        KB::Candidate::capitalized_string(a2, (uint64_t)v34);
        KB::Candidate::capitalized_string(a1, (uint64_t)v30);
        v25 = v36;
        if (v36)
          v26 = (const char *)v36;
        else
          v26 = (const char *)v37;
        v27 = v32;
        if (v32)
          v28 = (const char *)v32;
        else
          v28 = v33;
        v29 = strcmp(v26, v28);
        if (v27 && v31 == 1)
        {
          free(v27);
          v25 = v36;
        }
        if (v25 && v35 == 1)
          free(v25);
        if (v29 < 0)
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
      }
    }
  }
}

void std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(uint64_t *a1, uint64_t *a2)
{
  uint64_t *v2;
  KB::Candidate *v4;
  uint64_t v5;
  uint64_t v6;
  KB::Candidate *v7;
  void *v8;
  const char *v9;
  void *v10;
  const char *v11;
  int v12;
  BOOL v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  void *v17;
  const char *v18;
  int v19;
  uint64_t *v20;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  _BYTE v25[8];
  void *v26;
  uint64_t v27;
  _BYTE v28[6];
  char v29;
  void *v30;
  _QWORD v31[4];

  v31[2] = *MEMORY[0x1E0C80C00];
  if (a1 != a2)
  {
    v2 = a2;
    v4 = (KB::Candidate *)(a1 + 125);
    if (a1 + 125 != a2)
    {
      v5 = 0;
      v6 = (uint64_t)a1;
      do
      {
        v7 = (KB::Candidate *)v6;
        v6 = (uint64_t)v4;
        KB::Candidate::capitalized_string(v4, (uint64_t)&v22);
        KB::Candidate::capitalized_string(v7, (uint64_t)v28);
        v8 = v23;
        if (v23)
          v9 = (const char *)v23;
        else
          v9 = (const char *)&v24;
        v10 = v30;
        if (v30)
          v11 = (const char *)v30;
        else
          v11 = (const char *)v31;
        v12 = strcmp(v9, v11);
        if (v10)
          v13 = v29 == 1;
        else
          v13 = 0;
        if (v13)
        {
          free(v10);
          v8 = v23;
        }
        if (v8 && BYTE6(v22) == 1)
          free(v8);
        if (v12 < 0)
        {
          KB::Candidate::Candidate((uint64_t)&v22, v6);
          v14 = v5;
          while (1)
          {
            KB::Candidate::operator=((uint64_t *)((char *)a1 + v14 + 1000), (uint64_t *)((char *)a1 + v14));
            if (!v14)
              break;
            KB::Candidate::capitalized_string((KB::Candidate *)&v22, (uint64_t)v28);
            KB::Candidate::capitalized_string((KB::Candidate *)((char *)a1 + v14 - 1000), (uint64_t)v25);
            v15 = v30;
            if (v30)
              v16 = (const char *)v30;
            else
              v16 = (const char *)v31;
            v17 = v26;
            if (v26)
              v18 = (const char *)v26;
            else
              v18 = (const char *)&v27;
            v19 = strcmp(v16, v18);
            if (v17 && v25[6] == 1)
            {
              free(v17);
              v15 = v30;
            }
            if (v15)
            {
              if (v29 == 1)
                free(v15);
            }
            v14 -= 1000;
            if ((v19 & 0x80000000) == 0)
            {
              v20 = (uint64_t *)((char *)a1 + v14 + 1000);
              goto LABEL_37;
            }
          }
          v20 = a1;
LABEL_37:
          KB::Candidate::operator=(v20, &v22);
          KB::Candidate::~Candidate((KB::Candidate *)&v22);
          v2 = a2;
        }
        v4 = (KB::Candidate *)(v6 + 1000);
        v5 += 1000;
      }
      while ((uint64_t *)(v6 + 1000) != v2);
    }
  }
}

void std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(uint64_t *a1, uint64_t *a2)
{
  uint64_t *v3;
  KB::Candidate *v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  void *v8;
  const char *v9;
  int v10;
  BOOL v11;
  void *v12;
  const char *v13;
  void *v14;
  const char *v15;
  int v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  _BYTE v20[8];
  void *v21;
  uint64_t v22;
  _BYTE v23[6];
  char v24;
  void *v25;
  _QWORD v26[3];

  v26[2] = *MEMORY[0x1E0C80C00];
  if (a1 != a2)
  {
    v3 = a1;
    v4 = (KB::Candidate *)(a1 + 125);
    if (a1 + 125 != a2)
    {
      do
      {
        v5 = (uint64_t)v4;
        KB::Candidate::capitalized_string(v4, (uint64_t)&v17);
        KB::Candidate::capitalized_string((KB::Candidate *)v3, (uint64_t)v23);
        v6 = v18;
        if (v18)
          v7 = (const char *)v18;
        else
          v7 = (const char *)&v19;
        v8 = v25;
        if (v25)
          v9 = (const char *)v25;
        else
          v9 = (const char *)v26;
        v10 = strcmp(v7, v9);
        if (v8)
          v11 = v24 == 1;
        else
          v11 = 0;
        if (v11)
        {
          free(v8);
          v6 = v18;
        }
        if (v6 && BYTE6(v17) == 1)
          free(v6);
        if (v10 < 0)
        {
          KB::Candidate::Candidate((uint64_t)&v17, v5);
          do
          {
            KB::Candidate::operator=(v3 + 125, v3);
            v3 -= 125;
            KB::Candidate::capitalized_string((KB::Candidate *)&v17, (uint64_t)v23);
            KB::Candidate::capitalized_string((KB::Candidate *)v3, (uint64_t)v20);
            v12 = v25;
            if (v25)
              v13 = (const char *)v25;
            else
              v13 = (const char *)v26;
            v14 = v21;
            if (v21)
              v15 = (const char *)v21;
            else
              v15 = (const char *)&v22;
            v16 = strcmp(v13, v15);
            if (v14 && v20[6] == 1)
            {
              free(v14);
              v12 = v25;
            }
            if (v12)
            {
              if (v24 == 1)
                free(v12);
            }
          }
          while (v16 < 0);
          KB::Candidate::operator=(v3 + 125, &v17);
          KB::Candidate::~Candidate((KB::Candidate *)&v17);
        }
        v4 = (KB::Candidate *)(v5 + 1000);
        v3 = (uint64_t *)v5;
      }
      while ((uint64_t *)(v5 + 1000) != a2);
    }
  }
}

void std::__partial_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,KB::Candidate*>(uint64_t a1, KB::Candidate *a2, KB::Candidate *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  KB::Candidate *v10;
  uint64_t *v11;
  KB::Candidate *v12;
  void *v13;
  const char *v14;
  void *v15;
  const char *v16;
  int v17;
  BOOL v18;
  uint64_t v19;
  uint64_t *v20;
  int64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  const char *v28;
  void *v29;
  const char *v30;
  int v31;
  uint64_t v32;
  unint64_t v33;
  KB::Candidate *v34;
  void *v35;
  const char *v36;
  void *v37;
  const char *v38;
  int v39;
  uint64_t *v40;
  void *v41;
  const char *v42;
  void *v43;
  const char *v44;
  int v45;
  uint64_t *v47;
  KB::Candidate *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  _BYTE v54[984];
  _BYTE v55[8];
  void *v56;
  uint64_t v57;
  _BYTE v58[6];
  char v59;
  void *v60;
  _QWORD v61[4];

  v61[2] = *MEMORY[0x1E0C80C00];
  if ((KB::Candidate *)a1 != a2)
  {
    v6 = (uint64_t)a2 - a1;
    v7 = ((uint64_t)a2 - a1) / 1000;
    if ((uint64_t)a2 - a1 >= 1001)
    {
      v8 = (unint64_t)(v7 - 2) >> 1;
      v9 = v8 + 1;
      v10 = (KB::Candidate *)(a1 + 1000 * v8);
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(a1, v7, v10);
        v10 = (KB::Candidate *)((char *)v10 - 1000);
        --v9;
      }
      while (v9);
    }
    v48 = (KB::Candidate *)a1;
    v11 = (uint64_t *)a2;
    if (a2 != a3)
    {
      v12 = a2;
      do
      {
        KB::Candidate::capitalized_string(v12, (uint64_t)&v52);
        KB::Candidate::capitalized_string(v48, (uint64_t)&v49);
        v13 = v53;
        if (v53)
          v14 = (const char *)v53;
        else
          v14 = v54;
        v15 = v50;
        if (v50)
          v16 = (const char *)v50;
        else
          v16 = (const char *)&v51;
        v17 = strcmp(v14, v16);
        if (v15)
          v18 = BYTE6(v49) == 1;
        else
          v18 = 0;
        if (v18)
        {
          free(v15);
          v13 = v53;
        }
        if (v13 && BYTE6(v52) == 1)
          free(v13);
        if (v17 < 0)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v12, (uint64_t *)v48);
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((uint64_t)v48, v7, v48);
        }
        v12 = (KB::Candidate *)((char *)v12 + 1000);
      }
      while (v12 != a3);
    }
    v19 = (uint64_t)v48;
    if (v6 >= 1001)
    {
      v20 = v11;
      v21 = v6 / 0x3E8uLL;
      do
      {
        v47 = v20;
        KB::Candidate::Candidate((uint64_t)&v49, v19);
        v22 = 0;
        v23 = (uint64_t *)v19;
        do
        {
          v24 = (uint64_t)&v23[125 * v22 + 125];
          v25 = (2 * v22) | 1;
          v26 = 2 * v22 + 2;
          if (v26 < v21)
          {
            KB::Candidate::capitalized_string((KB::Candidate *)v24, (uint64_t)&v52);
            KB::Candidate::capitalized_string((KB::Candidate *)(v24 + 1000), (uint64_t)v58);
            v27 = v53;
            if (v53)
              v28 = (const char *)v53;
            else
              v28 = v54;
            v29 = v60;
            if (v60)
              v30 = (const char *)v60;
            else
              v30 = (const char *)v61;
            v31 = strcmp(v28, v30);
            if (v29 && v59 == 1)
            {
              free(v29);
              v27 = v53;
            }
            if (v27 && BYTE6(v52) == 1)
              free(v27);
            if (v31 < 0)
            {
              v24 += 1000;
              v25 = v26;
            }
          }
          KB::Candidate::operator=(v23, (uint64_t *)v24);
          v23 = (uint64_t *)v24;
          v22 = v25;
        }
        while (v25 <= (uint64_t)((unint64_t)(v21 - 2) >> 1));
        v20 = v47 - 125;
        if ((uint64_t *)v24 == v47 - 125)
        {
          KB::Candidate::operator=((uint64_t *)v24, &v49);
          v19 = (uint64_t)v48;
        }
        else
        {
          KB::Candidate::operator=((uint64_t *)v24, v47 - 125);
          KB::Candidate::operator=(v20, &v49);
          v19 = (uint64_t)v48;
          v32 = v24 - (_QWORD)v48 + 1000;
          if (v32 >= 1001)
          {
            v33 = (v32 / 0x3E8uLL - 2) >> 1;
            v34 = (KB::Candidate *)((char *)v48 + 1000 * v33);
            KB::Candidate::capitalized_string(v34, (uint64_t)&v52);
            KB::Candidate::capitalized_string((KB::Candidate *)v24, (uint64_t)v58);
            v35 = v53;
            if (v53)
              v36 = (const char *)v53;
            else
              v36 = v54;
            v37 = v60;
            if (v60)
              v38 = (const char *)v60;
            else
              v38 = (const char *)v61;
            v39 = strcmp(v36, v38);
            if (v37 && v59 == 1)
            {
              free(v37);
              v35 = v53;
            }
            if (v35 && BYTE6(v52) == 1)
              free(v35);
            if (v39 < 0)
            {
              KB::Candidate::Candidate((uint64_t)&v52, v24);
              do
              {
                v40 = (uint64_t *)v34;
                KB::Candidate::operator=((uint64_t *)v24, (uint64_t *)v34);
                if (!v33)
                  break;
                v33 = (v33 - 1) >> 1;
                v34 = (KB::Candidate *)((char *)v48 + 1000 * v33);
                KB::Candidate::capitalized_string(v34, (uint64_t)v58);
                KB::Candidate::capitalized_string((KB::Candidate *)&v52, (uint64_t)v55);
                v41 = v60;
                if (v60)
                  v42 = (const char *)v60;
                else
                  v42 = (const char *)v61;
                v43 = v56;
                if (v56)
                  v44 = (const char *)v56;
                else
                  v44 = (const char *)&v57;
                v45 = strcmp(v42, v44);
                if (v43 && v55[6] == 1)
                {
                  free(v43);
                  v41 = v60;
                }
                if (v41)
                {
                  if (v59 == 1)
                    free(v41);
                }
                v24 = (uint64_t)v40;
              }
              while (v45 < 0);
              KB::Candidate::operator=(v40, &v52);
              KB::Candidate::~Candidate((KB::Candidate *)&v52);
            }
          }
        }
        KB::Candidate::~Candidate((KB::Candidate *)&v49);
      }
      while (v21-- > 2);
    }
  }
}

KB::Candidate *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,KB::Candidate *,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &>(uint64_t *a1, KB::Candidate *a2)
{
  void *v4;
  const char *v5;
  void *v6;
  const char *v7;
  int v8;
  KB::Candidate *v9;
  KB::Candidate *v10;
  void *v11;
  const char *v12;
  void *v13;
  const char *v14;
  int v15;
  void *v16;
  const char *v17;
  void *v18;
  const char *v19;
  int v20;
  BOOL v21;
  void *v22;
  const char *v23;
  void *v24;
  const char *v25;
  int v26;
  BOOL v27;
  void *v28;
  const char *v29;
  void *v30;
  const char *v31;
  int v32;
  BOOL v33;
  void *v34;
  const char *v35;
  void *v36;
  const char *v37;
  int v38;
  BOOL v39;
  uint64_t v41[125];
  _BYTE v42[6];
  char v43;
  void *v44;
  _BYTE v45[16];
  _BYTE v46[6];
  char v47;
  void *v48;
  _QWORD v49[3];

  v49[2] = *MEMORY[0x1E0C80C00];
  KB::Candidate::Candidate((uint64_t)v41, (uint64_t)a1);
  KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
  KB::Candidate::capitalized_string((KB::Candidate *)((char *)a2 - 1000), (uint64_t)v42);
  v4 = v48;
  if (v48)
    v5 = (const char *)v48;
  else
    v5 = (const char *)v49;
  v6 = v44;
  if (v44)
    v7 = (const char *)v44;
  else
    v7 = v45;
  v8 = strcmp(v5, v7);
  if (v6 && v43 == 1)
  {
    free(v6);
    v4 = v48;
  }
  if (v4 && v47 == 1)
    free(v4);
  if (v8 < 0)
  {
    v10 = (KB::Candidate *)a1;
    do
    {
      v10 = (KB::Candidate *)((char *)v10 + 1000);
      KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
      KB::Candidate::capitalized_string(v10, (uint64_t)v42);
      v16 = v48;
      if (v48)
        v17 = (const char *)v48;
      else
        v17 = (const char *)v49;
      v18 = v44;
      if (v44)
        v19 = (const char *)v44;
      else
        v19 = v45;
      v20 = strcmp(v17, v19);
      if (v18)
        v21 = v43 == 1;
      else
        v21 = 0;
      if (v21)
      {
        free(v18);
        v16 = v48;
      }
      if (v16 && v47 == 1)
        free(v16);
    }
    while ((v20 & 0x80000000) == 0);
  }
  else
  {
    v9 = (KB::Candidate *)(a1 + 125);
    do
    {
      v10 = v9;
      if (v9 >= a2)
        break;
      KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
      KB::Candidate::capitalized_string(v10, (uint64_t)v42);
      v11 = v48;
      if (v48)
        v12 = (const char *)v48;
      else
        v12 = (const char *)v49;
      v13 = v44;
      if (v44)
        v14 = (const char *)v44;
      else
        v14 = v45;
      v15 = strcmp(v12, v14);
      if (v13 && v43 == 1)
      {
        free(v13);
        v11 = v48;
      }
      if (v11 && v47 == 1)
        free(v11);
      v9 = (KB::Candidate *)((char *)v10 + 1000);
    }
    while ((v15 & 0x80000000) == 0);
  }
  if (v10 < a2)
  {
    do
    {
      a2 = (KB::Candidate *)((char *)a2 - 1000);
      KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
      KB::Candidate::capitalized_string(a2, (uint64_t)v42);
      v22 = v48;
      if (v48)
        v23 = (const char *)v48;
      else
        v23 = (const char *)v49;
      v24 = v44;
      if (v44)
        v25 = (const char *)v44;
      else
        v25 = v45;
      v26 = strcmp(v23, v25);
      if (v24)
        v27 = v43 == 1;
      else
        v27 = 0;
      if (v27)
      {
        free(v24);
        v22 = v48;
      }
      if (v22 && v47 == 1)
        free(v22);
    }
    while (v26 < 0);
  }
  while (v10 < a2)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v10, (uint64_t *)a2);
    do
    {
      v10 = (KB::Candidate *)((char *)v10 + 1000);
      KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
      KB::Candidate::capitalized_string(v10, (uint64_t)v42);
      v28 = v48;
      if (v48)
        v29 = (const char *)v48;
      else
        v29 = (const char *)v49;
      v30 = v44;
      if (v44)
        v31 = (const char *)v44;
      else
        v31 = v45;
      v32 = strcmp(v29, v31);
      if (v30)
        v33 = v43 == 1;
      else
        v33 = 0;
      if (v33)
      {
        free(v30);
        v28 = v48;
      }
      if (v28 && v47 == 1)
        free(v28);
    }
    while ((v32 & 0x80000000) == 0);
    do
    {
      a2 = (KB::Candidate *)((char *)a2 - 1000);
      KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
      KB::Candidate::capitalized_string(a2, (uint64_t)v42);
      v34 = v48;
      if (v48)
        v35 = (const char *)v48;
      else
        v35 = (const char *)v49;
      v36 = v44;
      if (v44)
        v37 = (const char *)v44;
      else
        v37 = v45;
      v38 = strcmp(v35, v37);
      if (v36)
        v39 = v43 == 1;
      else
        v39 = 0;
      if (v39)
      {
        free(v36);
        v34 = v48;
      }
      if (v34 && v47 == 1)
        free(v34);
    }
    while (v38 < 0);
  }
  if ((uint64_t *)((char *)v10 - 1000) != a1)
    KB::Candidate::operator=(a1, (uint64_t *)v10 - 125);
  KB::Candidate::operator=((uint64_t *)v10 - 125, v41);
  KB::Candidate::~Candidate((KB::Candidate *)v41);
  return v10;
}

uint64_t *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,KB::Candidate *,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &>(uint64_t a1, KB::Candidate *a2)
{
  KB::Candidate *v4;
  void *v5;
  const char *v6;
  void *v7;
  const char *v8;
  int v9;
  BOOL v10;
  uint64_t *v11;
  void *v12;
  const char *v13;
  void *v14;
  const char *v15;
  int v16;
  BOOL v17;
  void *v18;
  const char *v19;
  void *v20;
  const char *v21;
  int v22;
  uint64_t *v23;
  uint64_t *v24;
  void *v25;
  const char *v26;
  void *v27;
  const char *v28;
  int v29;
  BOOL v30;
  void *v31;
  const char *v32;
  void *v33;
  const char *v34;
  int v35;
  BOOL v36;
  uint64_t *v38;
  uint64_t v39[125];
  _BYTE v40[6];
  char v41;
  void *v42;
  _BYTE v43[16];
  _BYTE v44[6];
  char v45;
  void *v46;
  _QWORD v47[4];

  v47[2] = *MEMORY[0x1E0C80C00];
  KB::Candidate::Candidate((uint64_t)v39, a1);
  v4 = (KB::Candidate *)a1;
  do
  {
    v4 = (KB::Candidate *)((char *)v4 + 1000);
    KB::Candidate::capitalized_string(v4, (uint64_t)v44);
    KB::Candidate::capitalized_string((KB::Candidate *)v39, (uint64_t)v40);
    v5 = v46;
    if (v46)
      v6 = (const char *)v46;
    else
      v6 = (const char *)v47;
    v7 = v42;
    if (v42)
      v8 = (const char *)v42;
    else
      v8 = v43;
    v9 = strcmp(v6, v8);
    if (v7)
      v10 = v41 == 1;
    else
      v10 = 0;
    if (v10)
    {
      free(v7);
      v5 = v46;
    }
    if (v5 && v45 == 1)
      free(v5);
  }
  while (v9 < 0);
  v11 = (uint64_t *)((char *)v4 - 1000);
  v38 = (uint64_t *)a1;
  if ((KB::Candidate *)((char *)v4 - 1000) == (KB::Candidate *)a1)
  {
    do
    {
      if (v4 >= a2)
        break;
      a2 = (KB::Candidate *)((char *)a2 - 1000);
      KB::Candidate::capitalized_string(a2, (uint64_t)v44);
      KB::Candidate::capitalized_string((KB::Candidate *)v39, (uint64_t)v40);
      v18 = v46;
      if (v46)
        v19 = (const char *)v46;
      else
        v19 = (const char *)v47;
      v20 = v42;
      if (v42)
        v21 = (const char *)v42;
      else
        v21 = v43;
      v22 = strcmp(v19, v21);
      if (v20 && v41 == 1)
      {
        free(v20);
        v18 = v46;
      }
      if (v18 && v45 == 1)
        free(v18);
    }
    while ((v22 & 0x80000000) == 0);
  }
  else
  {
    do
    {
      a2 = (KB::Candidate *)((char *)a2 - 1000);
      KB::Candidate::capitalized_string(a2, (uint64_t)v44);
      KB::Candidate::capitalized_string((KB::Candidate *)v39, (uint64_t)v40);
      v12 = v46;
      if (v46)
        v13 = (const char *)v46;
      else
        v13 = (const char *)v47;
      v14 = v42;
      if (v42)
        v15 = (const char *)v42;
      else
        v15 = v43;
      v16 = strcmp(v13, v15);
      if (v14)
        v17 = v41 == 1;
      else
        v17 = 0;
      if (v17)
      {
        free(v14);
        v12 = v46;
      }
      if (v12 && v45 == 1)
        free(v12);
    }
    while ((v16 & 0x80000000) == 0);
  }
  if (v4 < a2)
  {
    v23 = (uint64_t *)v4;
    v24 = (uint64_t *)a2;
    do
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v23, v24);
      do
      {
        v23 += 125;
        KB::Candidate::capitalized_string((KB::Candidate *)v23, (uint64_t)v44);
        KB::Candidate::capitalized_string((KB::Candidate *)v39, (uint64_t)v40);
        v25 = v46;
        if (v46)
          v26 = (const char *)v46;
        else
          v26 = (const char *)v47;
        v27 = v42;
        if (v42)
          v28 = (const char *)v42;
        else
          v28 = v43;
        v29 = strcmp(v26, v28);
        if (v27)
          v30 = v41 == 1;
        else
          v30 = 0;
        if (v30)
        {
          free(v27);
          v25 = v46;
        }
        if (v25 && v45 == 1)
          free(v25);
      }
      while (v29 < 0);
      v11 = v23 - 125;
      do
      {
        v24 -= 125;
        KB::Candidate::capitalized_string((KB::Candidate *)v24, (uint64_t)v44);
        KB::Candidate::capitalized_string((KB::Candidate *)v39, (uint64_t)v40);
        v31 = v46;
        if (v46)
          v32 = (const char *)v46;
        else
          v32 = (const char *)v47;
        v33 = v42;
        if (v42)
          v34 = (const char *)v42;
        else
          v34 = v43;
        v35 = strcmp(v32, v34);
        if (v33)
          v36 = v41 == 1;
        else
          v36 = 0;
        if (v36)
        {
          free(v33);
          v31 = v46;
        }
        if (v31 && v45 == 1)
          free(v31);
      }
      while ((v35 & 0x80000000) == 0);
    }
    while (v23 < v24);
  }
  if (v11 != v38)
    KB::Candidate::operator=(v38, v11);
  KB::Candidate::operator=(v11, v39);
  KB::Candidate::~Candidate((KB::Candidate *)v39);
  return v11;
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(uint64_t a1, KB::Candidate *a2)
{
  KB::Candidate *v2;
  _BOOL8 v4;
  void *v5;
  const char *v6;
  void *v7;
  const char *v8;
  int v9;
  KB::Candidate *v10;
  KB::Candidate *v11;
  uint64_t v12;
  int v13;
  void *v14;
  const char *v15;
  void *v16;
  const char *v17;
  int v18;
  BOOL v19;
  uint64_t v20;
  void *v21;
  const char *v22;
  void *v23;
  const char *v24;
  int v25;
  uint64_t *v26;
  KB::Candidate *v28;
  uint64_t v29;
  void *v30;
  _BYTE v31[984];
  _BYTE v32[8];
  void *v33;
  uint64_t v34;
  _BYTE v35[6];
  char v36;
  void *v37;
  _QWORD v38[4];

  v2 = a2;
  v38[2] = *MEMORY[0x1E0C80C00];
  v4 = 1;
  switch(0x1CAC083126E978D5 * (((uint64_t)a2 - a1) >> 3))
  {
    case 0:
    case 1:
      return v4;
    case 2:
      KB::Candidate::capitalized_string((KB::Candidate *)((char *)a2 - 1000), (uint64_t)&v29);
      KB::Candidate::capitalized_string((KB::Candidate *)a1, (uint64_t)v35);
      v5 = v30;
      if (v30)
        v6 = (const char *)v30;
      else
        v6 = v31;
      v7 = v37;
      if (v37)
        v8 = (const char *)v37;
      else
        v8 = (const char *)v38;
      v9 = strcmp(v6, v8);
      if (v7 && v36 == 1)
      {
        free(v7);
        v5 = v30;
      }
      if (v5 && BYTE6(v29) == 1)
        free(v5);
      if (v9 < 0)
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)v2 - 125);
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)a1, (KB::Candidate *)(a1 + 1000), (KB::Candidate *)((char *)a2 - 1000));
      return v4;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)a1, (KB::Candidate *)(a1 + 1000), (KB::Candidate *)(a1 + 2000), (KB::Candidate *)((char *)a2 - 1000));
      return v4;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,0>((KB::Candidate *)a1, (KB::Candidate *)(a1 + 1000), (KB::Candidate *)(a1 + 2000), (KB::Candidate *)(a1 + 3000), (KB::Candidate *)((char *)a2 - 1000));
      return v4;
    default:
      v10 = (KB::Candidate *)(a1 + 2000);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)a1, (KB::Candidate *)(a1 + 1000), (KB::Candidate *)(a1 + 2000));
      v11 = (KB::Candidate *)(a1 + 3000);
      if ((KB::Candidate *)(a1 + 3000) == v2)
        return 1;
      v12 = 0;
      v13 = 0;
      v28 = v2;
      break;
  }
  while (1)
  {
    KB::Candidate::capitalized_string(v11, (uint64_t)&v29);
    KB::Candidate::capitalized_string(v10, (uint64_t)v35);
    v14 = v30;
    if (v30)
      v15 = (const char *)v30;
    else
      v15 = v31;
    v16 = v37;
    if (v37)
      v17 = (const char *)v37;
    else
      v17 = (const char *)v38;
    v18 = strcmp(v15, v17);
    if (v16)
      v19 = v36 == 1;
    else
      v19 = 0;
    if (v19)
    {
      free(v16);
      v14 = v30;
    }
    if (v14 && BYTE6(v29) == 1)
      free(v14);
    if ((v18 & 0x80000000) == 0)
      goto LABEL_53;
    KB::Candidate::Candidate((uint64_t)&v29, (uint64_t)v11);
    v20 = v12;
    while (1)
    {
      KB::Candidate::operator=((uint64_t *)(a1 + v20 + 3000), (uint64_t *)(a1 + v20 + 2000));
      if (v20 == -2000)
        break;
      KB::Candidate::capitalized_string((KB::Candidate *)&v29, (uint64_t)v35);
      KB::Candidate::capitalized_string((KB::Candidate *)(a1 + v20 + 1000), (uint64_t)v32);
      v21 = v37;
      if (v37)
        v22 = (const char *)v37;
      else
        v22 = (const char *)v38;
      v23 = v33;
      if (v33)
        v24 = (const char *)v33;
      else
        v24 = (const char *)&v34;
      v25 = strcmp(v22, v24);
      if (v23 && v32[6] == 1)
      {
        free(v23);
        v21 = v37;
      }
      if (v21 && v36 == 1)
        free(v21);
      v20 -= 1000;
      if ((v25 & 0x80000000) == 0)
      {
        v26 = (uint64_t *)(a1 + v20 + 3000);
        goto LABEL_51;
      }
    }
    v26 = (uint64_t *)a1;
LABEL_51:
    KB::Candidate::operator=(v26, &v29);
    ++v13;
    v2 = v28;
    if (v13 == 8)
      break;
    KB::Candidate::~Candidate((KB::Candidate *)&v29);
LABEL_53:
    v10 = v11;
    v12 += 1000;
    v11 = (KB::Candidate *)((char *)v11 + 1000);
    if (v11 == v2)
      return 1;
  }
  v4 = (KB::Candidate *)((char *)v11 + 1000) == v28;
  KB::Candidate::~Candidate((KB::Candidate *)&v29);
  return v4;
}

void std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(uint64_t a1, uint64_t a2, KB::Candidate *a3)
{
  unint64_t v3;
  KB::Candidate *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  void *v12;
  const char *v13;
  int v14;
  void *v15;
  const char *v16;
  void *v17;
  const char *v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  void *v22;
  const char *v23;
  void *v24;
  const char *v25;
  int v26;
  void *v27;
  const char *v28;
  void *v29;
  const char *v30;
  int v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  _BYTE v37[984];
  _BYTE v38[6];
  char v39;
  void *v40;
  _BYTE v41[16];
  _BYTE v42[6];
  char v43;
  void *v44;
  _QWORD v45[4];

  v45[2] = *MEMORY[0x1E0C80C00];
  v3 = a2 - 2;
  if (a2 >= 2)
  {
    v4 = a3;
    v34 = v3 >> 1;
    if ((uint64_t)(v3 >> 1) >= 0x1CAC083126E978D5 * (((uint64_t)a3 - a1) >> 3))
    {
      v6 = a2;
      v7 = (0x395810624DD2F1AALL * (((uint64_t)a3 - a1) >> 3)) | 1;
      v8 = a1 + 1000 * v7;
      v9 = 0x395810624DD2F1AALL * (((uint64_t)a3 - a1) >> 3) + 2;
      if (v9 < a2)
      {
        KB::Candidate::capitalized_string((KB::Candidate *)(a1 + 1000 * v7), (uint64_t)&v35);
        KB::Candidate::capitalized_string((KB::Candidate *)(v8 + 1000), (uint64_t)v42);
        v10 = v36;
        if (v36)
          v11 = (const char *)v36;
        else
          v11 = v37;
        v12 = v44;
        if (v44)
          v13 = (const char *)v44;
        else
          v13 = (const char *)v45;
        v14 = strcmp(v11, v13);
        if (v12 && v43 == 1)
        {
          free(v12);
          v10 = v36;
        }
        if (v10 && BYTE6(v35) == 1)
          free(v10);
        if (v14 < 0)
        {
          v8 += 1000;
          v7 = v9;
        }
        v6 = a2;
      }
      KB::Candidate::capitalized_string((KB::Candidate *)v8, (uint64_t)&v35);
      KB::Candidate::capitalized_string(v4, (uint64_t)v42);
      v15 = v36;
      if (v36)
        v16 = (const char *)v36;
      else
        v16 = v37;
      v17 = v44;
      if (v44)
        v18 = (const char *)v44;
      else
        v18 = (const char *)v45;
      v19 = strcmp(v16, v18);
      if (v17 && v43 == 1)
      {
        free(v17);
        v15 = v36;
      }
      if (v15 && BYTE6(v35) == 1)
        free(v15);
      if ((v19 & 0x80000000) == 0)
      {
        v33 = a1;
        KB::Candidate::Candidate((uint64_t)&v35, (uint64_t)v4);
        do
        {
          v20 = (uint64_t *)v8;
          KB::Candidate::operator=((uint64_t *)v4, (uint64_t *)v8);
          if (v34 < v7)
            break;
          v21 = (2 * v7) | 1;
          v8 = v33 + 1000 * v21;
          v7 = 2 * v7 + 2;
          if (v7 >= v6)
          {
            v7 = v21;
          }
          else
          {
            KB::Candidate::capitalized_string((KB::Candidate *)(v33 + 1000 * v21), (uint64_t)v42);
            KB::Candidate::capitalized_string((KB::Candidate *)(v8 + 1000), (uint64_t)v38);
            v22 = v44;
            if (v44)
              v23 = (const char *)v44;
            else
              v23 = (const char *)v45;
            v24 = v40;
            if (v40)
              v25 = (const char *)v40;
            else
              v25 = v41;
            v26 = strcmp(v23, v25);
            if (v24 && v39 == 1)
            {
              free(v24);
              v22 = v44;
            }
            if (v22 && v43 == 1)
              free(v22);
            if (v26 >= 0)
              v7 = v21;
            else
              v8 += 1000;
            v6 = a2;
          }
          KB::Candidate::capitalized_string((KB::Candidate *)v8, (uint64_t)v42);
          KB::Candidate::capitalized_string((KB::Candidate *)&v35, (uint64_t)v38);
          v27 = v44;
          if (v44)
            v28 = (const char *)v44;
          else
            v28 = (const char *)v45;
          v29 = v40;
          if (v40)
            v30 = (const char *)v40;
          else
            v30 = v41;
          v31 = strcmp(v28, v30);
          if (v29 && v39 == 1)
          {
            free(v29);
            v27 = v44;
          }
          if (v27)
          {
            if (v43 == 1)
              free(v27);
          }
          v4 = (KB::Candidate *)v20;
        }
        while ((v31 & 0x80000000) == 0);
        KB::Candidate::operator=(v20, &v35);
        KB::Candidate::~Candidate((KB::Candidate *)&v35);
      }
    }
  }
}

char *std::vector<KB::Candidate>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x4189374BC6A7F0)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[1000 * v4];
  return result;
}

void KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)const::$_0::operator()(uint64_t *a1, KB::LanguageModelContext *a2, uint64_t a3, KB::String *this)
{
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  TITokenID v10;
  TITokenID v11;
  int v12;
  __int16 v13;
  char v14;
  void *v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v7 = *a1;
    v8 = 240 * a3;
    do
    {
      if ((*((_BYTE *)this + 135) & 4) == 0)
        goto LABEL_9;
      v13 = 0;
      v14 = 0;
      v15 = " ";
      v12 = 1048577;
      v16 = 0;
      if (this != (KB::String *)&v12)
      {
        v9 = KB::String::equal(this, (const KB::String *)&v12, 1);
        if (v15 && v14 == 1)
          free(v15);
        if (!v9)
        {
LABEL_9:
          *((float *)this + 24) = (*(float (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 432))(v7, *((unsigned int *)this + 34), a1[1]);
          v10 = (TITokenID)*((_QWORD *)this + 17);
          KB::Word::capitalized_string(this, (uint64_t)&v12);
          v11 = v10;
          KB::LanguageModelContext::append(a2, v11, (const KB::String *)&v12, 0);
          if (v15)
          {
            if (v14 == 1)
              free(v15);
          }
        }
      }
      this = (KB::String *)((char *)this + 240);
      v8 -= 240;
    }
    while (v8);
  }
}

void KB::LanguageModelStr::cache_key_for_candidate(KB::LanguageModelStr *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  const char *v12;
  const char *v13;
  _WORD v14[3];
  char v15;
  void *v16;
  _QWORD v17[3];

  v17[2] = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a2 = 0x100000;
  *(_WORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 6) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  v5 = -3 * (*((_QWORD *)this + 101) - (*((_QWORD *)this + 100) + 8 * *((_QWORD *)this + 103)));
  if (v5)
  {
    v6 = *((_QWORD *)this + 109);
    do
    {
      v7 = (const char *)(v6 + v5);
      if (*(char *)(v6 + v5 + 23) < 0)
        v7 = *(const char **)v7;
      KB::String::append_format((KB::String *)a2, "%s ", v7);
      v5 += 24;
    }
    while (v5);
  }
  KB::String::append((unsigned __int16 *)a2, "| ", 0xFFFFuLL);
  v8 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v9 = *((_QWORD *)this + 1);
    v10 = 240 * v8;
    do
    {
      if (*(_WORD *)v9)
      {
        if ((*(_BYTE *)(v9 + 135) & 4) == 0
          || (*(_QWORD *)(v9 + 8) ? (v11 = *(const char **)(v9 + 8)) : (v11 = (const char *)(v9 + 16)), strcmp(v11, " ")))
        {
          KB::Word::capitalized_string((KB::Word *)v9, (uint64_t)v14);
          v12 = (const char *)v16;
          if (!v16)
            v12 = (const char *)v17;
          if (v14[0])
            v13 = v12;
          else
            v13 = "";
          KB::String::append_format((KB::String *)a2, "%s ", v13);
          if (v16)
          {
            if (v15 == 1)
              free(v16);
          }
        }
      }
      v9 += 240;
      v10 -= 240;
    }
    while (v10);
  }
}

void std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2>,void ()(KB::LanguageModel::PredictionInfo const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2>,void ()(KB::LanguageModel::PredictionInfo const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1EA0FA8F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2>,void ()(KB::LanguageModel::PredictionInfo const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1EA0FA8F0;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2>,void ()(KB::LanguageModel::PredictionInfo const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t *v19;

  v4 = *(uint64_t **)(a1 + 8);
  v5 = v4[1];
  v6 = v4[2];
  if (v5 >= v6)
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *v4) >> 5);
    if (v8 + 1 > 0x199999999999999)
      goto LABEL_16;
    v9 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - *v4) >> 5);
    v10 = 2 * v9;
    if (2 * v9 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0xCCCCCCCCCCCCCCLL)
      v11 = 0x199999999999999;
    else
      v11 = v10;
    v19 = v4 + 2;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v11);
    else
      v12 = 0;
    v15 = v11;
    v16 = v11 + 160 * v8;
    v18 = v11 + 160 * v12;
    std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo const&,KB::LanguageModel::PredictionInfo*>(v16, a2);
    v17 = v16 + 160;
    std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer(v4, &v15);
    v7 = v4[1];
    std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    v7 = std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo const&,KB::LanguageModel::PredictionInfo*>(v5, a2)+ 160;
  }
  v4[1] = v7;
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24);
  if (!v13)
  {
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_16:
    abort();
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v13 + 48))(v13, a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  **(_BYTE **)(a1 + 16) |= result;
  return result;
}

uint64_t std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo const&,KB::LanguageModel::PredictionInfo*>(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  __int128 v5;
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;

  v4 = std::vector<TITokenID>::vector((_QWORD *)a1, a2);
  v5 = *(_OWORD *)(a2 + 24);
  *((_DWORD *)v4 + 10) = *(_DWORD *)(a2 + 40);
  *(_OWORD *)(v4 + 3) = v5;
  v6 = (std::string *)(v4 + 6);
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 48), *(_QWORD *)(a2 + 56));
  }
  else
  {
    v7 = *(_OWORD *)(a2 + 48);
    v6->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 64);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  v8 = (std::string *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)(a2 + 72), *(_QWORD *)(a2 + 80));
  }
  else
  {
    v9 = *(_OWORD *)(a2 + 72);
    *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)(a1 + 96), *(__int128 **)(a2 + 96), *(__int128 **)(a2 + 104), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 104) - *(_QWORD *)(a2 + 96)) >> 3));
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)(a1 + 120), *(__int128 **)(a2 + 120), *(__int128 **)(a2 + 128), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 128) - *(_QWORD *)(a2 + 120)) >> 3));
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,0>(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void **v5;

  v2 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = 0;
  if (v2)
  {
    v5 = (void **)(v2 + 32);
    std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v5);
    v3 = *(void **)(v2 + 8);
    if (v3 && *(_BYTE *)(v2 + 6) == 1)
      free(v3);
    MEMORY[0x1DF0A2144](v2, 0x1030C4086507075);
  }
  v4 = *(void **)(a1 + 8);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 6) == 1)
      free(v4);
  }
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 != v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v18 = v7[1];
      *(_QWORD *)v12 = v18;
      if (v18)
        *(_QWORD *)(v18 + 16) = v12;
      v7[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(_QWORD *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12)
        result = v7;
      v7 = *(uint64_t **)v12;
    }
    v19 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v19 + 24))
      goto LABEL_68;
    v20 = (uint64_t *)v7[1];
    if (v20 && !*((_BYTE *)v20 + 24))
    {
      if (v19 && !*((_BYTE *)v19 + 24))
      {
LABEL_68:
        v20 = v7;
      }
      else
      {
        *((_BYTE *)v20 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v26 = *v20;
        v7[1] = *v20;
        if (v26)
          *(_QWORD *)(v26 + 16) = v7;
        v20[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
        *v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        v19 = v7;
      }
      v23 = v20[2];
      *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v19 + 24) = 1;
      v24 = *(uint64_t **)v23;
      v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
      *(_QWORD *)v23 = v27;
      if (v27)
        *(_QWORD *)(v27 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v13 = *(uint64_t **)(v12 + 8);
    v14 = *v13;
    *(_QWORD *)(v12 + 8) = *v13;
    if (v14)
      *(_QWORD *)(v14 + 16) = v12;
    v13[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
    *v13 = v12;
    *(_QWORD *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7)
      result = v7;
    v7 = *(uint64_t **)(*v7 + 8);
  }
  v15 = (_QWORD *)*v7;
  if (!*v7 || *((_BYTE *)v15 + 24))
  {
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_59;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
    goto LABEL_49;
  }
  v16 = (uint64_t *)v7[1];
  if (v16 && !*((_BYTE *)v16 + 24))
  {
LABEL_59:
    v15 = v7;
  }
  else
  {
    *((_BYTE *)v15 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v22 = v15[1];
    *v7 = v22;
    if (v22)
      *(_QWORD *)(v22 + 16) = v7;
    v15[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    v16 = v7;
  }
  v23 = v15[2];
  *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v16 + 24) = 1;
  v24 = *(uint64_t **)(v23 + 8);
  v25 = *v24;
  *(_QWORD *)(v23 + 8) = *v24;
  if (v25)
    *(_QWORD *)(v25 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  *v24 = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1>,BOOL ()(language_modeling::v1::Prediction const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1>,BOOL ()(language_modeling::v1::Prediction const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x40uLL);
  *(_QWORD *)v2 = &off_1EA0FA8A8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((_QWORD *)v2 + 7) = *(_QWORD *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1>,BOOL ()(language_modeling::v1::Prediction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a2 = &off_1EA0FA8A8;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  v4 = *(_OWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1>,BOOL ()(language_modeling::v1::Prediction const&)>::operator()(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  _BYTE v16[8];
  void *v17[8];
  char v18;
  void *__p;
  char v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE v23[8];
  std::__shared_weak_count *v24;
  void *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void **v30;
  uint64_t v31;
  KB::String *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  language_modeling::v1::Prediction::Prediction();
  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD **)(a1 + 8);
  v4 = language_modeling::v1::Prediction::unique_id((language_modeling::v1::Prediction *)v16);
  KB::Candidate::Candidate((KB::Candidate *)&v31, (const KB::Candidate *)(*v3 + 1000 * v4));
  for (i = v31; v31; i = v31)
  {
    if (KB::Word::is_linguistically_void((KB::String *)((char *)v32 + 240 * i - 240)))
      break;
    KB::Candidate::pop_last_word((KB::Candidate *)&v31);
  }
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v23, *(const KB::LanguageModelContext **)(a1 + 16));
  KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)const::$_0::operator()(*(uint64_t **)(a1 + 24), (KB::LanguageModelContext *)v23, v31, v32);
  v6 = *(_QWORD *)(a1 + 32);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
  KB::LanguageModel::PredictionInfo::PredictionInfo((KB::LanguageModel::PredictionInfo *)v17, (const language_modeling::v1::Prediction *)v16, v7);
  v8 = *(_QWORD *)(v6 + 24);
  if (!v8)
    std::__throw_bad_function_call[abi:nn180100]();
  v9 = (*(uint64_t (**)(uint64_t, void **, uint64_t *, _BYTE *))(*(_QWORD *)v8 + 48))(v8, v17, &v31, v23);
  v30 = (void **)&v22;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v30);
  v30 = (void **)&v21;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v30);
  if (v20 < 0)
    operator delete(__p);
  if (v18 < 0)
    operator delete(v17[6]);
  if (v17[0])
  {
    v17[1] = v17[0];
    operator delete(v17[0]);
  }
  **(_BYTE **)(a1 + 48) |= v9;
  v10 = *(unint64_t **)(a1 + 56);
  v11 = *v10;
  if (v9)
    *v10 = ++v11;
  v17[0] = &v29;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)v17);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v28);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v27);
  if (v25)
  {
    v26 = v25;
    operator delete(v25);
  }
  v12 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  KB::Candidate::~Candidate((KB::Candidate *)&v31);
  language_modeling::v1::Prediction::~Prediction((language_modeling::v1::Prediction *)v16);
  return v11 < 5;
}

uint64_t __Block_byref_object_copy__757(uint64_t a1, uint64_t a2)
{
  return KB::LanguageModelContext::LanguageModelContext(a1 + 40, a2 + 40);
}

uint64_t __Block_byref_object_dispose__758(uint64_t a1)
{
  void *v2;
  void **v4;

  v4 = (void **)(a1 + 120);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v4);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 112));
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 104));
  v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(_QWORD *)(a1 + 64) = v2;
    operator delete(v2);
  }
  return std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](a1 + 40);
}

void ___ZNK2KB16LanguageModelStr19is_text_blocklistedERKNS_6StringEjRKNS_20LanguageModelContextERKN3WTF6RefPtrINS_19DictionaryContainerEEE27TIBlocklistSensitivityLevel_block_invoke(uint64_t a1, unsigned __int16 *a2, TITokenID *a3)
{
  uint64_t v6;
  KB::DictionaryContainer **v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  BOOL v14;
  uint64_t v15;
  char v16;
  TITokenID v17;
  __int128 v18;
  void *__p[2];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void **v27;

  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) && a3->word_id - 500 <= 0xFFFFFE0C)
  {
    v6 = *(_QWORD *)(a1 + 48);
    v7 = *(KB::DictionaryContainer ***)(a1 + 56);
    v24 = 0;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    *(_OWORD *)__p = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v22);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v22 + 8));
    v23 = 0uLL;
    v24 = 0;
    KB::LanguageModelImplBase::static_words_for_string(v6, a2, v7, (uint64_t)&v18, 1, 1, (uint64_t)&v25);
    v27 = (void **)&v23;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v27);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v22 + 8));
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v22);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v8 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
    if (*((_QWORD *)&v18 + 1))
    {
      v9 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    if (v25 == v26)
    {
      LOBYTE(v13) = 0;
    }
    else
    {
      v11 = v25 + 240;
      do
      {
        v12 = *(_DWORD *)(v11 - 136);
        v13 = (v12 >> 1) & 1;
        if ((v12 & 2) == 0)
          break;
        v14 = v11 == v26;
        v11 += 240;
      }
      while (!v14);
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v13;
    v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_BYTE *)(v15 + 24))
    {
      v16 = 1;
    }
    else
    {
      v16 = (*(uint64_t (**)(uint64_t, unsigned __int16 *, TITokenID, uint64_t, _QWORD))(*(_QWORD *)v6 + 464))(v6, a2, *a3, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40, *(unsigned int *)(a1 + 64));
      v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    }
    *(_BYTE *)(v15 + 24) = v16;
    v17 = *a3;
    KB::LanguageModelContext::append((KB::LanguageModelContext *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), v17, (const KB::String *)a2, 0);
    *(_QWORD *)&v18 = &v25;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v18);
  }
}

void KB::LanguageModelStr::get_predictions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  const language_modeling::v1::Prediction *v10;
  const language_modeling::v1::Prediction *v11;
  int v12;
  KB::LanguageModel::PredictionInfo *v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  KB::LanguageModel::PredictionInfo *v21;
  const language_modeling::v1::Prediction *v22;
  const language_modeling::v1::Prediction *v23;
  const language_modeling::v1::Prediction *v24;
  const language_modeling::v1::Prediction *v25;
  _QWORD v26[5];

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
  {
    v8 = *(_QWORD *)(a1 + 184);
    if (v8)
      atomic_store(1u, (unsigned __int8 *)(v8 + 752));
    std::mutex::lock(*(std::mutex **)(a1 + 136));
    v9 = *(_QWORD *)(a1 + 184);
    if (v9)
      atomic_store(0, (unsigned __int8 *)(v9 + 752));
    MEMORY[0x1DF0A1E98](&v24, *(_QWORD *)(a1 + 200), a2 + 72, a3);
    std::mutex::unlock(*(std::mutex **)(a1 + 136));
    v10 = v24;
    v11 = v25;
    if (v24 != v25)
    {
      do
      {
        v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
        v13 = (KB::LanguageModel::PredictionInfo *)a4[1];
        v14 = a4[2];
        if ((unint64_t)v13 >= v14)
        {
          v16 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v13 - *a4) >> 5);
          v17 = v16 + 1;
          if (v16 + 1 > 0x199999999999999)
            abort();
          v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - *a4) >> 5);
          if (2 * v18 > v17)
            v17 = 2 * v18;
          if (v18 >= 0xCCCCCCCCCCCCCCLL)
            v19 = 0x199999999999999;
          else
            v19 = v17;
          v26[4] = a4 + 2;
          if (v19)
            v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v19);
          else
            v20 = 0;
          v21 = (KB::LanguageModel::PredictionInfo *)(v19 + 160 * v16);
          v26[0] = v19;
          v26[1] = v21;
          v26[3] = v19 + 160 * v20;
          KB::LanguageModel::PredictionInfo::PredictionInfo(v21, v10, v12);
          v26[2] = (char *)v21 + 160;
          std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer(a4, v26);
          v15 = (char *)a4[1];
          std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)v26);
        }
        else
        {
          v15 = (char *)KB::LanguageModel::PredictionInfo::PredictionInfo(v13, v10, v12) + 160;
        }
        a4[1] = (uint64_t)v15;
        v10 = (const language_modeling::v1::Prediction *)((char *)v10 + 8);
      }
      while (v10 != v11);
      v10 = v24;
    }
    if (v10)
    {
      v22 = v25;
      v23 = v10;
      if (v25 != v10)
      {
        do
          language_modeling::v1::Prediction::~Prediction((const language_modeling::v1::Prediction *)((char *)v22 - 8));
        while (v22 != v10);
        v23 = v24;
      }
      v25 = v10;
      operator delete(v23);
    }
  }
}

void KB::LanguageModelStr::PredictionEnumeratorStr::~PredictionEnumeratorStr(KB::LanguageModelStr::PredictionEnumeratorStr *this)
{
  void **v1;

  *(_QWORD *)this = &off_1EA0FA720;
  v1 = (void **)((char *)this + 8);
  std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v1);
}

{
  void **v1;

  *(_QWORD *)this = &off_1EA0FA720;
  v1 = (void **)((char *)this + 8);
  std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v1);
  JUMPOUT(0x1DF0A2144);
}

__n128 KB::LanguageModelStr::PredictionEnumeratorStr::get_prediction@<Q0>(KB::LanguageModelStr::PredictionEnumeratorStr *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  std::string *v7;
  const std::string::value_type **v8;
  __int128 v9;
  std::string *v10;
  const std::string::value_type **v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __n128 result;

  v3 = *((_QWORD *)this + 4);
  v4 = *((_QWORD *)this + 1);
  v5 = v4 + 160 * v3;
  std::vector<TITokenID>::vector((_QWORD *)a2, v5);
  v6 = *(_OWORD *)(v5 + 24);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(v5 + 40);
  *(_OWORD *)(a2 + 24) = v6;
  v7 = (std::string *)(a2 + 48);
  v8 = (const std::string::value_type **)(v5 + 48);
  if (*(char *)(v5 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *v8, *(_QWORD *)(v4 + 160 * v3 + 56));
  }
  else
  {
    v9 = *(_OWORD *)v8;
    *(_QWORD *)(a2 + 64) = *(_QWORD *)(v5 + 64);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  v10 = (std::string *)(a2 + 72);
  v11 = (const std::string::value_type **)(v4 + 160 * v3 + 72);
  if (*(char *)(v5 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *v11, *(_QWORD *)(v4 + 160 * v3 + 80));
  }
  else
  {
    v12 = *(_OWORD *)v11;
    *(_QWORD *)(a2 + 88) = *(_QWORD *)(v4 + 160 * v3 + 88);
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v12;
  }
  v13 = v4 + 160 * v3;
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)(a2 + 96), *(__int128 **)(v13 + 96), *(__int128 **)(v13 + 104), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v13 + 104) - *(_QWORD *)(v13 + 96)) >> 3));
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  v14 = a2 + 120;
  *(_QWORD *)(v14 + 16) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)v14, *(__int128 **)(v13 + 120), *(__int128 **)(v13 + 128), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v13 + 128) - *(_QWORD *)(v13 + 120)) >> 3));
  result = *(__n128 *)(v13 + 144);
  *(__n128 *)(v14 + 24) = result;
  return result;
}

BOOL KB::LanguageModelStr::PredictionEnumeratorStr::advance(KB::LanguageModelStr::PredictionEnumeratorStr *this)
{
  uint64_t v1;
  unint64_t v2;

  v1 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = v1 + 1;
  v2 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 5);
  if (v1 + 1 >= v2)
    *((_QWORD *)this + 4) = v1;
  return v1 + 1 < v2;
}

void std::__shared_ptr_emplace<KB::LanguageModelStr::PredictionEnumeratorStr>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FA938;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::LanguageModelStr::PredictionEnumeratorStr>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FA938;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::LanguageModelStr::PredictionEnumeratorStr>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *std::vector<KB::LikelihoodInfo>::vector(_QWORD *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::string *v9;
  std::string::size_type v10;
  __int128 v11;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<KB::LikelihoodInfo>::__vallocate[abi:nn180100](a1, a2);
    v6 = a1[1];
    v7 = v6 + 40 * a2;
    v8 = 40 * a2;
    v9 = (std::string *)(v6 + 16);
    do
    {
      v10 = *(_QWORD *)a3;
      LODWORD(v9[-1].__r_.__value_.__r.__words[2]) = *(_DWORD *)(a3 + 8);
      v9[-1].__r_.__value_.__l.__size_ = v10;
      if (*(char *)(a3 + 39) < 0)
      {
        std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)(a3 + 16), *(_QWORD *)(a3 + 24));
      }
      else
      {
        v11 = *(_OWORD *)(a3 + 16);
        v9->__r_.__value_.__r.__words[2] = *(_QWORD *)(a3 + 32);
        *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
      }
      v9 = (std::string *)((char *)v9 + 40);
      v8 -= 40;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

_QWORD *std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  __int128 v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (_QWORD *)*result;
  v2 = (_QWORD *)result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    *(_QWORD *)(v4 - 24) = 0;
    *(_QWORD *)(v4 - 16) = 0;
    v4 -= 24;
    *(_QWORD *)(v4 + 16) = 0;
    v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)v4 = v5;
    *(_QWORD *)(v4 + 16) = v2[2];
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  v6 = (_QWORD *)*result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::vector<KB::LikelihoodInfo>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void **v4;
  void **v6;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = (void **)(i - 24);
    *(_QWORD *)(a1 + 16) = v4;
    v6 = v4;
    std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100](&v6);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<language_modeling::v1::Token>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 9) < 0)
          operator delete(*(v4 - 4));
        v4 -= 4;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(unint64_t a1)
{
  if (a1 >> 59)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(32 * a1);
}

void std::vector<std::vector<language_modeling::v1::Probability>>::__vdeallocate(void ***a1)
{
  void **v1;
  void **v3;
  void **v4;
  void **v5;

  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        v5 = v3;
        std::vector<language_modeling::v1::Probability>::__destroy_vector::operator()[abi:nn180100](&v5);
      }
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::vector<language_modeling::v1::Probability>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        v6 = v4;
        std::vector<language_modeling::v1::Probability>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::vector<KB::LikelihoodInfo>>::emplace_back<std::vector<KB::LikelihoodInfo>&>(_QWORD *a1, __int128 **a2)
{
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD v14[5];

  v4 = a1 + 2;
  v5 = a1[2];
  v6 = (_QWORD *)a1[1];
  if ((unint64_t)v6 >= v5)
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v6 - *a1) >> 3);
    if (v8 + 1 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    v10 = 2 * v9;
    if (2 * v9 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v10;
    v14[4] = v4;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v11);
    else
      v12 = 0;
    v13 = (_QWORD *)(v11 + 24 * v8);
    v14[0] = v11;
    v14[1] = v13;
    v14[3] = v11 + 24 * v12;
    *v13 = 0;
    v13[1] = 0;
    v13[2] = 0;
    std::vector<KB::LikelihoodInfo>::__init_with_size[abi:nn180100]<KB::LikelihoodInfo*,KB::LikelihoodInfo*>(v13, *a2, a2[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a2[1] - (char *)*a2) >> 3));
    v14[2] = v13 + 3;
    std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(a1, v14);
    v7 = (_QWORD *)a1[1];
    std::__split_buffer<std::vector<KB::LikelihoodInfo>>::~__split_buffer((uint64_t)v14);
  }
  else
  {
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    std::vector<KB::LikelihoodInfo>::__init_with_size[abi:nn180100]<KB::LikelihoodInfo*,KB::LikelihoodInfo*>(v6, *a2, a2[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a2[1] - (char *)*a2) >> 3));
    v7 = v6 + 3;
  }
  a1[1] = v7;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(unint64_t a1)
{
  if (a1 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(40 * a1);
}

uint64_t std::__split_buffer<KB::LikelihoodInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      v4 = v2 - 40;
      *(_QWORD *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        v4 = *(_QWORD *)(a1 + 16);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<KB::LikelihoodInfo>::__init_with_size[abi:nn180100]<KB::LikelihoodInfo*,KB::LikelihoodInfo*>(_QWORD *a1, __int128 *a2, __int128 *a3, unint64_t a4)
{
  std::string::value_type *v7;
  __int128 *v8;
  std::string *v9;
  std::string::size_type v10;
  __int128 *v11;
  __int128 v12;

  if (a4)
  {
    std::vector<KB::LikelihoodInfo>::__vallocate[abi:nn180100](a1, a4);
    v7 = (std::string::value_type *)a1[1];
    if (a2 != a3)
    {
      v8 = a2 + 1;
      v9 = (std::string *)(v7 + 16);
      do
      {
        v11 = v8 - 1;
        v10 = *((_QWORD *)v8 - 2);
        LODWORD(v9[-1].__r_.__value_.__r.__words[2]) = *((_DWORD *)v8 - 2);
        v9[-1].__r_.__value_.__l.__size_ = v10;
        if (*((char *)v8 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
        }
        else
        {
          v12 = *v8;
          v9->__r_.__value_.__r.__words[2] = *((_QWORD *)v8 + 2);
          *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v12;
        }
        v8 = (__int128 *)((char *)v8 + 40);
        v9 = (std::string *)((char *)v9 + 40);
      }
      while ((__int128 *)((char *)v11 + 40) != a3);
      v7 = &v9[-1].__r_.__value_.__s.__data_[8];
    }
    a1[1] = v7;
  }
}

char *std::vector<KB::LikelihoodInfo>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x666666666666667)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[40 * v4];
  return result;
}

void std::vector<language_modeling::v1::Probability>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        language_modeling::v1::Probability::~Probability((language_modeling::v1::Probability *)(v4 - 8));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<language_modeling::v1::Token>::__init_with_size[abi:nn180100]<language_modeling::v1::Token*,language_modeling::v1::Token*>(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 *v10;
  std::string *v11;
  __int128 v12;

  if (a4)
  {
    if (a4 >> 59)
      abort();
    v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(a4);
    *a1 = v7;
    a1[1] = v7;
    a1[2] = &v7[32 * v8];
    if (a2 != a3)
    {
      v9 = 0;
      do
      {
        v10 = (__int128 *)(a2 + v9);
        v11 = (std::string *)&v7[v9];
        if (*(char *)(a2 + v9 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
        }
        else
        {
          v12 = *v10;
          v11->__r_.__value_.__r.__words[2] = *((_QWORD *)v10 + 2);
          *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
        }
        *(_DWORD *)&v7[v9 + 24] = *(_DWORD *)(a2 + v9 + 24);
        v9 += 32;
      }
      while (a2 + v9 != a3);
      v7 += v9;
    }
    a1[1] = v7;
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::variant<language_modeling::v1::SessionType,std::string>>,0>(uint64_t a1)
{
  uint64_t v2;
  char v3;

  v2 = *(unsigned int *)(a1 + 48);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_1EA0FA808[v2])(&v3, a1 + 24);
  *(_DWORD *)(a1 + 48) = -1;
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::__shared_ptr_pointer<language_modeling::v1::LanguageModelSession  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

language_modeling::v1::LanguageModelSession *std::__shared_ptr_pointer<language_modeling::v1::LanguageModelSession  *>::__on_zero_shared(uint64_t a1)
{
  language_modeling::v1::LanguageModelSession *result;

  result = *(language_modeling::v1::LanguageModelSession **)(a1 + 24);
  if (result)
  {
    language_modeling::v1::LanguageModelSession::~LanguageModelSession(result);
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN17language_modeling2v111SessionTypeENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSI_1EJSA_SG_EEEEEEDcSK_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

uint64_t std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, _QWORD *a2)
{
  size_t v2;
  size_t v3;
  size_t v4;
  size_t v5;
  size_t v6;
  int v7;

  v2 = a1[1];
  if (*((char *)a1 + 23) >= 0)
  {
    v3 = *((unsigned __int8 *)a1 + 23);
  }
  else
  {
    a1 = (_QWORD *)*a1;
    v3 = v2;
  }
  v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    v5 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (_QWORD *)*a2;
    v5 = v4;
  }
  if (v5 >= v3)
    v6 = v3;
  else
    v6 = v5;
  v7 = memcmp(a1, a2, v6);
  if (v7)
  {
    if ((v7 & 0x80000000) == 0)
      return 1;
  }
  else
  {
    if (v3 == v5)
      return 0;
    if (v3 >= v5)
      return 1;
  }
  return 255;
}

KB::String *std::vector<KB::String>::__init_with_size[abi:nn180100]<KB::String*,KB::String*>(KB::String *result, const KB::String *a2, const KB::String *a3, unint64_t a4)
{
  KB::String *v6;
  KB::String *v7;

  if (a4)
  {
    v6 = result;
    std::vector<KB::String>::__vallocate[abi:nn180100](result, a4);
    result = (KB::String *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v7 = KB::String::String(result, a2);
      a2 = (const KB::String *)((char *)a2 + 32);
      result = (KB::String *)((char *)v7 + 32);
    }
    *((_QWORD *)v6 + 1) = result;
  }
  return result;
}

char *std::vector<KB::String>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void std::map<std::string,std::variant<BOOL,std::string>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *> *,long>>>(uint64_t a1, __int128 *a2, __int128 *a3)
{
  uint64_t v3;
  uint64_t v4;
  __int128 *v6;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  BOOL v13;
  uint64_t **v14;
  uint64_t v15;
  char *v16;
  __int128 *v17;
  __int128 *v18;
  _QWORD v19[2];
  char v20;
  _QWORD v21[13];

  if (a2 != a3)
  {
    v21[11] = v3;
    v21[12] = v4;
    v6 = a2;
    v8 = (_QWORD *)(a1 + 8);
    do
    {
      v9 = *(_QWORD *)(a1 + 8);
      v10 = v8;
      if (*(_QWORD **)a1 == v8)
        goto LABEL_10;
      v11 = *(_QWORD **)(a1 + 8);
      v12 = v8;
      if (v9)
      {
        do
        {
          v10 = v11;
          v11 = (_QWORD *)v11[1];
        }
        while (v11);
      }
      else
      {
        do
        {
          v10 = (_QWORD *)v12[2];
          v13 = *v10 == (_QWORD)v12;
          v12 = v10;
        }
        while (v13);
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v10 + 4, (_QWORD *)v6 + 4) & 0x80) != 0)
      {
LABEL_10:
        v15 = (uint64_t)v8;
        v14 = (uint64_t **)v8;
        if (!v9)
          goto LABEL_14;
        v21[0] = v10;
        v14 = (uint64_t **)(v10 + 1);
      }
      else
      {
        v14 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(a1, v21, (_QWORD *)v6 + 4);
      }
      if (!*v14)
      {
        v15 = v21[0];
LABEL_14:
        v16 = (char *)operator new(0x58uLL);
        v19[1] = v8;
        std::pair<std::string const,std::variant<BOOL,std::string>>::pair[abi:nn180100]((std::string *)(v16 + 32), v6 + 2);
        v20 = 1;
        std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at((uint64_t **)a1, v15, v14, (uint64_t *)v16);
        v19[0] = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)v19);
      }
      v17 = (__int128 *)*((_QWORD *)v6 + 1);
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = *(__int128 **)v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          v18 = (__int128 *)*((_QWORD *)v6 + 2);
          v13 = *(_QWORD *)v18 == (_QWORD)v6;
          v6 = v18;
        }
        while (!v13);
      }
      v6 = v18;
    }
    while (v18 != a3);
  }
}

void KB::LanguageModelStr::draft_radar_for_model_creation_failure(uint64_t a1, uint64_t a2, int a3)
{
  KB::LanguageModelConfig *v5;
  void **v6;
  CFStringRef v7;
  CFStringRef v8;
  __CFString *Mutable;
  __CFString *v10;
  void **v11;
  _QWORD **v12;
  uint64_t v13;
  int v14;
  const std::string *v15;
  uint64_t *v16;
  uint64_t *v17;
  char *v18;
  _QWORD *v19;
  _QWORD **v20;
  BOOL v21;
  __int128 *v22;
  const __CFDictionary *v23;
  __int128 *v24;
  __int128 *v25;
  __int128 *v26;
  std::string *v27;
  CFStringRef v28;
  CFStringRef appendedString;
  std::string v30;
  uint64_t *v31;
  _QWORD *v32[2];
  std::string v33;
  __int128 *v34;
  _BYTE v35[24];
  _QWORD **v36;
  _QWORD *v37[2];
  void *v38[2];
  char v39;
  std::string *v40;

  v5 = (KB::LanguageModelConfig *)(a1 + 8);
  KB::string_from_locale(*(KB **)(a1 + 8), (const __CFLocale *)a2, v38);
  if (v39 >= 0)
    v6 = v38;
  else
    v6 = (void **)v38[0];
  if (a3)
    v7 = CFStringCreateWithFormat(0, 0, CFSTR("it could not reload resources for locale %s"), v6);
  else
    v7 = CFStringCreateWithFormat(0, 0, CFSTR("it could not load resources for locale %s"), v6);
  v8 = v7;
  Mutable = CFStringCreateMutable(0, 0);
  v10 = Mutable;
  if (v39 >= 0)
    v11 = v38;
  else
    v11 = (void **)v38[0];
  CFStringAppendFormat(Mutable, 0, CFSTR("Locale: %s\n\n"), v11);
  CFStringAppend(v10, CFSTR("Options: \n"));
  v37[0] = 0;
  v37[1] = 0;
  v36 = v37;
  std::map<std::string,std::variant<BOOL,std::string>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *> *,long>>>((uint64_t)&v36, *(__int128 **)a2, (__int128 *)(a2 + 8));
  *(_OWORD *)&v30.__r_.__value_.__r.__words[1] = 0uLL;
  v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30.__r_.__value_.__l.__size_;
  v12 = v36;
  if (v36 != v37)
  {
    do
    {
      if (*((char *)v12 + 55) < 0)
        std::string::__init_copy_ctor_external(&v33, (const std::string::value_type *)v12[4], (std::string::size_type)v12[5]);
      else
        v33 = *(std::string *)(v12 + 4);
      v13 = *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)&v36, &v40, &v33);
      if (!v13)
        abort();
      v14 = *(_DWORD *)(v13 + 80);
      if (v14)
      {
        if (v14 == 1)
        {
          v15 = (const std::string *)(v13 + 56);
          v40 = &v33;
          v16 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)&v30, &v33, (__int128 **)&v40);
          std::string::operator=((std::string *)(v16 + 7), v15);
        }
      }
      else
      {
        v40 = &v33;
        v17 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)&v30, &v33, (__int128 **)&v40);
        if (*((char *)v17 + 79) < 0)
        {
          v17[8] = 4;
          v18 = (char *)v17[7];
        }
        else
        {
          v18 = (char *)(v17 + 7);
          *((_BYTE *)v17 + 79) = 4;
        }
        strcpy(v18, "true");
      }
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v33.__r_.__value_.__l.__data_);
      v19 = v12[1];
      if (v19)
      {
        do
        {
          v20 = (_QWORD **)v19;
          v19 = (_QWORD *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = (_QWORD **)v12[2];
          v21 = *v20 == v12;
          v12 = v20;
        }
        while (!v21);
      }
      v12 = v20;
    }
    while (v20 != v37);
  }
  debugStringFromMap((CFStringRef *)&v40, &v30);
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((_QWORD *)v30.__r_.__value_.__l.__size_);
  std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(v37[0]);
  v22 = (__int128 *)v40;
  CFStringAppend(v10, (CFStringRef)v40);
  CFStringAppend(v10, CFSTR("\nTrial Parameters: \n"));
  KB::LanguageModelConfig::trial_parameters(v5, v23, (uint64_t)&v33);
  if (v35[16])
  {
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v30, v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
    else
      v30 = v33;
    v32[0] = 0;
    v32[1] = 0;
    v31 = (uint64_t *)v32;
    v24 = v34;
    if (v34 != (__int128 *)v35)
    {
      do
      {
        std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::string> const&>(&v31, (uint64_t *)v32, (_QWORD *)v24 + 4, v24 + 2);
        v25 = (__int128 *)*((_QWORD *)v24 + 1);
        if (v25)
        {
          do
          {
            v26 = v25;
            v25 = *(__int128 **)v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            v26 = (__int128 *)*((_QWORD *)v24 + 2);
            v21 = *(_QWORD *)v26 == (_QWORD)v24;
            v24 = v26;
          }
          while (!v21);
        }
        v24 = v26;
      }
      while (v26 != (__int128 *)v35);
    }
    if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v27 = &v30;
    else
      v27 = (std::string *)v30.__r_.__value_.__r.__words[0];
    CFStringAppendFormat(v10, 0, CFSTR("languageModelBundlePath: %s\n"), v27);
    debugStringFromMap(&appendedString, &v31);
    v28 = appendedString;
    CFStringAppend(v10, appendedString);
    if (v28)
      CFRelease(v28);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(v32[0]);
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v30.__r_.__value_.__l.__data_);
  }
  else
  {
    CFStringAppend(v10, CFSTR("<no trial parameters>\n"));
  }
  createTapToRadarDraft((uint64_t)v8, (uint64_t)v10);
  CFRelease(v8);
  CFRelease(v10);
  std::__optional_destruct_base<LM::TrialParameters,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v33);
  if (v22)
    CFRelease(v22);
  if (v39 < 0)
    operator delete(v38[0]);
}

void std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::variant<BOOL,std::string>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::variant<BOOL,std::string>>,0>(uint64_t a1)
{
  uint64_t v2;
  char v3;

  v2 = *(unsigned int *)(a1 + 48);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_1EA0FA7D8[v2])(&v3, a1 + 24);
  *(_DWORD *)(a1 + 48) = -1;
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJbNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSF_1EJbSD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, _QWORD *a2, __int128 **a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  std::string *v8;
  __int128 *v9;
  __int128 v10;
  _QWORD v12[2];
  char v13;
  uint64_t v14;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v14, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    v6 = (uint64_t *)operator new(0x50uLL);
    v12[1] = a1 + 1;
    v8 = (std::string *)(v6 + 4);
    v9 = *a3;
    if (*((char *)*a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)v9, *((_QWORD *)v9 + 1));
    }
    else
    {
      v10 = *v9;
      v6[6] = *((_QWORD *)v9 + 2);
      *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v10;
    }
    v6[7] = 0;
    v6[8] = 0;
    v6[9] = 0;
    v13 = 1;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v14, v7, v6);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v12);
  }
  return v6;
}

void debugStringFromMap(CFStringRef *a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  size_t v5;
  std::string *v6;
  const void *v7;
  int v8;
  const std::string::value_type *v9;
  std::string::size_type v10;
  std::string *v11;
  std::string::size_type v12;
  std::string *v13;
  std::string::size_type v14;
  void **v15;
  std::string::size_type v16;
  _QWORD *v17;
  _QWORD *v18;
  BOOL v19;
  std::string *v20;
  std::string v21;
  std::string v22;
  void *__p[2];
  uint64_t v24;
  std::string v25;

  memset(&v25, 0, sizeof(v25));
  v3 = a2 + 1;
  v4 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 == a2 + 1)
  {
    v20 = &v25;
  }
  else
  {
    do
    {
      if (*((char *)v4 + 55) >= 0)
        v5 = *((unsigned __int8 *)v4 + 55);
      else
        v5 = v4[5];
      std::string::basic_string[abi:nn180100]((uint64_t)&v21, v5 + 4);
      if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v6 = &v21;
      else
        v6 = (std::string *)v21.__r_.__value_.__r.__words[0];
      if (v5)
      {
        if (*((char *)v4 + 55) >= 0)
          v7 = v4 + 4;
        else
          v7 = (const void *)v4[4];
        memmove(v6, v7, v5);
      }
      strcpy((char *)v6 + v5, ":\n\t ");
      v8 = *((char *)v4 + 79);
      if (v8 >= 0)
        v9 = (const std::string::value_type *)(v4 + 7);
      else
        v9 = (const std::string::value_type *)v4[7];
      if (v8 >= 0)
        v10 = *((unsigned __int8 *)v4 + 79);
      else
        v10 = v4[8];
      v11 = std::string::append(&v21, v9, v10);
      v12 = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v22.__r_.__value_.__l.__data_ = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      v22.__r_.__value_.__r.__words[2] = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      v13 = std::string::append(&v22, "\n", 1uLL);
      v14 = v13->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
      v24 = v14;
      v13->__r_.__value_.__l.__size_ = 0;
      v13->__r_.__value_.__r.__words[2] = 0;
      v13->__r_.__value_.__r.__words[0] = 0;
      if (v24 >= 0)
        v15 = __p;
      else
        v15 = (void **)__p[0];
      if (v24 >= 0)
        v16 = HIBYTE(v24);
      else
        v16 = (std::string::size_type)__p[1];
      std::string::append(&v25, (const std::string::value_type *)v15, v16);
      if (SHIBYTE(v24) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v22.__r_.__value_.__l.__data_);
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v21.__r_.__value_.__l.__data_);
      v17 = (_QWORD *)v4[1];
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = (_QWORD *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          v18 = (_QWORD *)v4[2];
          v19 = *v18 == (_QWORD)v4;
          v4 = v18;
        }
        while (!v19);
      }
      v4 = v18;
    }
    while (v18 != v3);
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v20 = &v25;
    else
      v20 = (std::string *)v25.__r_.__value_.__r.__words[0];
  }
  *a1 = CFStringCreateWithCString(0, (const char *)v20, 0x8000100u);
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v25.__r_.__value_.__l.__data_);
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t std::__optional_destruct_base<LM::TrialParameters,false>::~__optional_destruct_base[abi:nn180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 48))
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(_QWORD **)(a1 + 32));
    if (*(char *)(a1 + 23) < 0)
      operator delete(*(void **)a1);
  }
  return a1;
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::string> const&>(uint64_t **a1, uint64_t *a2, _QWORD *a3, __int128 *a4)
{
  uint64_t *v6;
  uint64_t **v8;
  uint64_t **v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  BOOL v16;
  char *v17;
  uint64_t **v18;
  _QWORD v19[2];
  char v20;
  uint64_t *v21;
  uint64_t *v22;

  v6 = a2;
  v8 = a1 + 1;
  if (a1 + 1 == (uint64_t **)a2
    || (std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, a2 + 4) & 0x80) != 0)
  {
    v10 = *v6;
    if (*a1 == v6)
    {
      v12 = v6;
    }
    else
    {
      if (v10)
      {
        v11 = (uint64_t *)*v6;
        do
        {
          v12 = v11;
          v11 = (uint64_t *)v11[1];
        }
        while (v11);
      }
      else
      {
        v15 = v6;
        do
        {
          v12 = (uint64_t *)v15[2];
          v16 = *v12 == (_QWORD)v15;
          v15 = v12;
        }
        while (v16);
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v12 + 4, a3) & 0x80) == 0)
        goto LABEL_19;
    }
    if (!v10)
    {
      v22 = v6;
      v9 = (uint64_t **)v6;
      goto LABEL_25;
    }
    v22 = v12;
    v9 = (uint64_t **)(v12 + 1);
    goto LABEL_22;
  }
  if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v6 + 4, a3) & 0x80) != 0)
  {
    v13 = v6[1];
    if (v13)
    {
      v14 = (uint64_t *)v6[1];
      do
      {
        v9 = (uint64_t **)v14;
        v14 = (uint64_t *)*v14;
      }
      while (v14);
    }
    else
    {
      v18 = (uint64_t **)v6;
      do
      {
        v9 = (uint64_t **)v18[2];
        v16 = *v9 == (uint64_t *)v18;
        v18 = v9;
      }
      while (!v16);
    }
    if (v9 == v8
      || (std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v9 + 4) & 0x80) != 0)
    {
      if (v13)
      {
        v22 = (uint64_t *)v9;
      }
      else
      {
        v22 = v6;
        v9 = (uint64_t **)(v6 + 1);
      }
LABEL_22:
      if (*v9)
        return;
      goto LABEL_23;
    }
LABEL_19:
    v9 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v22, a3);
    goto LABEL_22;
  }
  v21 = v6;
  v22 = v6;
  v9 = &v21;
  if (v6)
    return;
LABEL_23:
  v6 = v22;
LABEL_25:
  v17 = (char *)operator new(0x50uLL);
  v19[1] = v8;
  std::pair<std::string const,std::string>::pair[abi:nn180100]((std::string *)(v17 + 32), a4);
  v20 = 1;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v6, v9, (uint64_t *)v17);
  v19[0] = 0;
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v19);
}

std::string *std::pair<std::string const,std::string>::pair[abi:nn180100](std::string *this, __int128 *a2)
{
  __int128 v4;
  std::string *v5;
  __int128 v6;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  v5 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v6 = *(__int128 *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  return this;
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::string::basic_string[abi:nn180100](uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

std::string *std::pair<std::string const,std::variant<BOOL,std::string>>::pair[abi:nn180100](std::string *this, __int128 *a2)
{
  __int128 v4;
  uint64_t v5;
  char v7;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  this[1].__r_.__value_.__s.__data_[0] = 0;
  LODWORD(this[2].__r_.__value_.__l.__data_) = -1;
  v5 = *((unsigned int *)a2 + 12);
  if ((_DWORD)v5 != -1)
  {
    ((void (*)(char *))*(&off_1EA0FA7E8 + v5))(&v7);
    LODWORD(this[2].__r_.__value_.__l.__data_) = v5;
  }
  return this;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::variant<BOOL,std::string>>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJbNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSN_OT0_E_JRNS0_6__baseILSI_1EJbSD_EEERKSV_EEEDcSN_DpT0_(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJbNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSN_OT0_E_JRNS0_6__baseILSI_1EJbSD_EEERKSV_EEEDcSN_DpT0_(int a1, std::string *this, __int128 *a3)
{
  __int128 v3;

  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v3 = *a3;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
  }
}

_OWORD *std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, _QWORD *a2, _OWORD **a3)
{
  void **v5;
  _OWORD *v6;
  uint64_t **v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD v11[2];
  char v12;
  uint64_t v13;

  v5 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v13, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = operator new(0x58uLL);
    v11[1] = a1 + 1;
    v8 = *a3;
    v9 = *((_QWORD *)*a3 + 2);
    v6[2] = **a3;
    *((_QWORD *)v6 + 6) = v9;
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    *((_BYTE *)v6 + 56) = 0;
    *((_DWORD *)v6 + 20) = 0;
    v12 = 1;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v13, v7, (uint64_t *)v6);
    v11[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)v11);
  }
  return v6;
}

__n128 std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>(__n128 *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v5;
  __n128 result;
  char v8;

  v5 = a1[1].n128_u32[2];
  if ((_DWORD)v5 == -1)
    goto LABEL_7;
  if ((_DWORD)v5 != 1)
  {
    ((void (*)(char *, __n128 *))off_1EA0FA7D8[v5])(&v8, a1);
LABEL_7:
    a1[1].n128_u32[2] = -1;
    result = *a3;
    a1[1].n128_u64[0] = a3[1].n128_u64[0];
    *a1 = result;
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    a3->n128_u64[0] = 0;
    a1[1].n128_u32[2] = 1;
    return result;
  }
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  result = *a3;
  *(_QWORD *)(a2 + 16) = a3[1].n128_u64[0];
  *(__n128 *)a2 = result;
  a3[1].n128_u8[7] = 0;
  a3->n128_u8[0] = 0;
  return result;
}

double std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,char const*&>(uint64_t a1, std::string *this, const std::string::value_type **a3)
{
  double result;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  char v8;

  if (*(_DWORD *)(a1 + 24) == 1)
  {
    std::string::__assign_external(this, *a3);
  }
  else
  {
    std::string::basic_string[abi:nn180100]<0>(&v6, (char *)*a3);
    v5 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v5 != -1)
      ((void (*)(char *, uint64_t))off_1EA0FA7D8[v5])(&v8, a1);
    result = *(double *)&v6;
    *(_OWORD *)a1 = v6;
    *(_QWORD *)(a1 + 16) = v7;
    *(_DWORD *)(a1 + 24) = 1;
  }
  return result;
}

_QWORD *std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  _QWORD *result;
  _QWORD *v3;
  _QWORD *v4;

  result = *(_QWORD **)(a1 + 16);
  if (result)
  {
    v3 = (_QWORD *)*result;
    if (*result == a1)
    {
      *result = 0;
      while (1)
      {
        v4 = (_QWORD *)result[1];
        if (!v4)
          break;
        do
        {
          result = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; v3 = (_QWORD *)result[1])
      {
        do
        {
          result = v3;
          v3 = (_QWORD *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

_QWORD *std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__find_leaf_high(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *result;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v5 = v4;
        if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v4 + 4) & 0x80) == 0)
          break;
        v4 = (_QWORD *)*v5;
        result = v5;
        if (!*v5)
          goto LABEL_8;
      }
      v4 = (_QWORD *)v5[1];
    }
    while (v4);
    result = v5 + 1;
  }
  else
  {
    result = (_QWORD *)(a1 + 8);
  }
LABEL_8:
  *a2 = v5;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJbNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJbSD_EEERKSU_EEEDcSM_DpT0_(uint64_t result, _BYTE *a2, _BYTE *a3)
{
  uint64_t v4;
  uint64_t v5;
  char v6;

  v4 = *(_QWORD *)result;
  v5 = *(unsigned int *)(*(_QWORD *)result + 24);
  if ((_DWORD)v5 != -1)
  {
    if (!(_DWORD)v5)
    {
      *a2 = *a3;
      return result;
    }
    result = ((uint64_t (*)(char *, uint64_t))off_1EA0FA7D8[v5])(&v6, v4);
  }
  *(_BYTE *)v4 = *a3;
  *(_DWORD *)(v4 + 24) = 0;
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJbNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJbSD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v3;
  int v4;
  double result;
  std::string v6;
  char v7;

  v3 = *a1;
  v4 = *(_DWORD *)(*a1 + 24);
  if (v4 == 1)
  {
    std::string::operator=(this, __str);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v6, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
      v4 = *(_DWORD *)(v3 + 24);
    }
    else
    {
      v6 = *__str;
    }
    if (v4 != -1)
      ((void (*)(char *, uint64_t))off_1EA0FA7D8[v4])(&v7, v3);
    result = *(double *)&v6.__r_.__value_.__l.__data_;
    *(std::string *)v3 = v6;
    *(_DWORD *)(v3 + 24) = 1;
  }
  return result;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  std::string::size_type v4;

  v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  unint64_t v6;
  std::string *v7;
  std::string::size_type size;
  unint64_t v9;
  unint64_t v10;

  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    v10 = this->__r_.__value_.__r.__words[2];
    v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    v6 = HIBYTE(v10);
    v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    v7 = this;
    if (__n > 0x16)
    {
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0)
    this->__r_.__value_.__l.__size_ = __n;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, const std::vector<unsigned int> *__x)
{
  unsigned int *end;
  std::vector<unsigned int>::pointer begin;
  int64_t v5;
  std::vector<unsigned int>::pointer v6;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  begin = __x->__begin_;
  end = __x->__end_;
  v5 = (char *)end - (char *)__x->__begin_;
  if (end != __x->__begin_)
  {
    std::vector<unsigned int>::__vallocate[abi:nn180100](this, v5 >> 2);
    v6 = this->__end_;
    memmove(v6, begin, v5);
    this->__end_ = (std::vector<unsigned int>::pointer)((char *)v6 + v5);
  }
  return this;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(unint64_t a1)
{
  if (a1 >> 62)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(4 * a1);
}

char *std::vector<unsigned int>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void KB::LanguageModelConfig::~LanguageModelConfig(KB::LanguageModelConfig *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;

  v2 = (const void *)*((_QWORD *)this + 6);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 6) = 0;
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 5) = 0;
  v4 = (const void *)*((_QWORD *)this + 4);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 4) = 0;
  v5 = (const void *)*((_QWORD *)this + 3);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 3) = 0;
  v6 = (const void *)*((_QWORD *)this + 2);
  if (v6)
    CFRelease(v6);
  *((_QWORD *)this + 2) = 0;
  v7 = (const void *)*((_QWORD *)this + 1);
  if (v7)
    CFRelease(v7);
  *((_QWORD *)this + 1) = 0;
  if (*(_QWORD *)this)
    CFRelease(*(CFTypeRef *)this);
  *(_QWORD *)this = 0;
}

uint64_t KB::LanguageModelStr::LanguageModelStr(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  const void *v6;
  __int128 v7;
  __int128 v8;
  _QWORD *v9;
  const __CFLocale *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  uint64_t v13;
  std::__shared_weak_count *shared_owners;
  unint64_t v15;
  unint64_t *p_shared_weak_owners;
  unint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  CFTypeRef v23;
  CFTypeRef v24;
  CFTypeRef v25;
  CFTypeRef v26[2];
  CFTypeRef cf[2];
  __int128 v28;
  __int128 v29;
  int v30;

  v4 = *(const void **)a2;
  v23 = v4;
  if (v4)
  {
    CFRetain(v4);
    v23 = v4;
  }
  v5 = *(const void **)(a2 + 8);
  v24 = v5;
  if (v5)
  {
    CFRetain(v5);
    v24 = v5;
  }
  v6 = *(const void **)(a2 + 16);
  v25 = v6;
  if (v6)
  {
    CFRetain(v6);
    v25 = v6;
  }
  v7 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)v26 = v7;
  v8 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)cf = v8;
  v28 = *(_OWORD *)(a2 + 56);
  v29 = *(_OWORD *)(a2 + 72);
  v30 = *(_DWORD *)(a2 + 88);
  KB::LanguageModelImplBase::LanguageModelImplBase(a1, (uint64_t)&v23);
  if (cf[1])
    CFRelease(cf[1]);
  cf[1] = 0;
  if (cf[0])
    CFRelease(cf[0]);
  cf[0] = 0;
  if (v26[1])
    CFRelease(v26[1]);
  v26[1] = 0;
  if (v26[0])
    CFRelease(v26[0]);
  v26[0] = 0;
  if (v25)
    CFRelease(v25);
  v25 = 0;
  if (v24)
    CFRelease(v24);
  v24 = 0;
  if (v23)
    CFRelease(v23);
  v23 = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)a1 = &off_1EA0FA498;
  v9 = operator new(0x20uLL);
  v9[1] = 0;
  v9[2] = 0;
  *v9 = &off_1EA0FA778;
  *(_QWORD *)(a1 + 168) = language_modeling::v1::LanguageModel::LanguageModel((language_modeling::v1::LanguageModel *)(v9 + 3));
  *(_QWORD *)(a1 + 176) = v9;
  if (!*(_BYTE *)(a1 + 94) || !*(_BYTE *)(a1 + 93))
  {
    *(_QWORD *)(a1 + 184) = 0;
    *(_QWORD *)(a1 + 192) = 0;
    goto LABEL_37;
  }
  v10 = *(const __CFLocale **)(a1 + 8);
  v11 = (std::__shared_weak_count *)operator new(0x310uLL);
  v11->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v11->__shared_owners_;
  v11->__shared_weak_owners_ = 0;
  v11->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FA7B0;
  TIInlineCompletionGeneratorImpl::TIInlineCompletionGeneratorImpl((TIInlineCompletionGeneratorImpl *)&v11[1], v10, 1, 3, 1);
  *(_QWORD *)(a1 + 184) = v13;
  *(_QWORD *)(a1 + 192) = v11;
  shared_owners = (std::__shared_weak_count *)v11[1].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1)
      goto LABEL_37;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v11->__shared_weak_owners_;
    do
      v17 = __ldxr(p_shared_weak_owners);
    while (__stxr(v17 + 1, p_shared_weak_owners));
    v11[1].__vftable = (std::__shared_weak_count_vtbl *)&v11[1];
    v11[1].__shared_owners_ = (uint64_t)v11;
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  else
  {
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
    v19 = (unint64_t *)&v11->__shared_weak_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
    v11[1].__vftable = (std::__shared_weak_count_vtbl *)&v11[1];
    v11[1].__shared_owners_ = (uint64_t)v11;
  }
  do
    v21 = __ldaxr(p_shared_owners);
  while (__stlxr(v21 - 1, p_shared_owners));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
LABEL_37:
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_WORD *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = a1 + 288;
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 304) = 32;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = a1 + 336;
  return a1;
}

void std::__shared_ptr_emplace<TIInlineCompletionGeneratorImpl>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FA7B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TIInlineCompletionGeneratorImpl>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FA7B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

void std::__shared_ptr_emplace<TIInlineCompletionGeneratorImpl>::__on_zero_shared(uint64_t a1)
{
  TIInlineCompletionGeneratorImpl::~TIInlineCompletionGeneratorImpl((TIInlineCompletionGeneratorImpl *)(a1 + 24));
}

void std::__shared_ptr_emplace<language_modeling::v1::LanguageModel>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FA778;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<language_modeling::v1::LanguageModel>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FA778;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

void std::__shared_ptr_emplace<language_modeling::v1::LanguageModel>::__on_zero_shared(uint64_t a1)
{
  language_modeling::v1::LanguageModel::~LanguageModel((language_modeling::v1::LanguageModel *)(a1 + 24));
}

void KB::LanguageModelStr::lock_language_model(KB::LanguageModelStr *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 23);
  if (v2)
    atomic_store(1u, (unsigned __int8 *)(v2 + 752));
  std::mutex::lock(*((std::mutex **)this + 17));
  v3 = *((_QWORD *)this + 23);
  if (v3)
    atomic_store(0, (unsigned __int8 *)(v3 + 752));
}

void KB::LanguageModelStr::unlock_language_model(std::mutex **this)
{
  std::mutex::unlock(this[17]);
}

BOOL convertBlocklistSensitivityLevel(int a1)
{
  return a1 == 1;
}

KB::LanguageModelStr::PredictionEnumeratorStr *KB::LanguageModelStr::PredictionEnumeratorStr::PredictionEnumeratorStr(KB::LanguageModelStr::PredictionEnumeratorStr *this, const KB::LanguageModelStr *a2, const KB::LanguageModelContext *a3, unsigned int a4)
{
  *(_QWORD *)this = &off_1EA0FA720;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  KB::LanguageModelStr::get_predictions((uint64_t)a2, (uint64_t)a3, a4, (uint64_t *)this + 1);
  return this;
}

{
  *(_QWORD *)this = &off_1EA0FA720;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  KB::LanguageModelStr::get_predictions((uint64_t)a2, (uint64_t)a3, a4, (uint64_t *)this + 1);
  return this;
}

id TICreateNameReadingPairsFromContactCollection(void *a1)
{
  id v1;
  void *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 6 * objc_msgSend(v1, "count"));
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v3 = v1;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v11;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v11 != v6)
          objc_enumerationMutation(v3);
        objc_msgSend(v3, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v10 + 1) + 8 * v7), (_QWORD)v10);
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        TICreateNameReadingPairFromContactAndAppendToArray(v8, 0, 0, v2);

        ++v7;
      }
      while (v5 != v7);
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
    }
    while (v5);
  }

  return v2;
}

void TICreateNameReadingPairFromContactAndAppendToArray(void *a1, int a2, void *a3, void *a4)
{
  id v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  id v26;

  v26 = a1;
  v7 = a3;
  v8 = a4;
  objc_msgSend(v26, "firstName");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v26, "lastName");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  if (a2 == 2)
  {
    objc_msgSend(v7, "contactNameWubiCodePairsForFirstName:lastName:", v9, v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "addObjectsFromArray:", v11);
  }
  else
  {
    objc_msgSend(v26, "nickname");
    v12 = objc_claimAutoreleasedReturnValue();
    v11 = (void *)v12;
    if (v9 || v10 || v12)
    {
      objc_msgSend(v26, "phoneticFirstName");
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v13, "lowercaseString");
      v14 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v26, "phoneticLastName");
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "lowercaseString");
      v16 = (void *)objc_claimAutoreleasedReturnValue();

      TIGenerateReading(v14, v9, a2, v7);
      v17 = (void *)objc_claimAutoreleasedReturnValue();

      TIGenerateReading(v16, v10, a2, v7);
      v18 = (void *)objc_claimAutoreleasedReturnValue();

      TIGenerateReading(0, v11, a2, v7);
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      if (v9
        && v10
        && ((objc_msgSend(v9, "_containsIdeographicCharacters") & 1) != 0
         || (objc_msgSend(v9, "_containsHiraganaOrKatakana") & 1) != 0
         || objc_msgSend(v9, "_containsKorean"))
        && ((objc_msgSend(v10, "_containsIdeographicCharacters") & 1) != 0
         || (objc_msgSend(v10, "_containsHiraganaOrKatakana") & 1) != 0
         || objc_msgSend(v10, "_containsKorean")))
      {
        objc_msgSend(v10, "stringByAppendingString:", v9);
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        if (objc_msgSend(v17, "length") && objc_msgSend(v18, "length"))
        {
          objc_msgSend(v18, "stringByAppendingString:", v17);
          v21 = objc_claimAutoreleasedReturnValue();
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0C99E38], "null");
          v21 = objc_claimAutoreleasedReturnValue();
        }
        v22 = (void *)v21;
        objc_msgSend(v8, "addObject:", v20);
        objc_msgSend(v8, "addObject:", v22);

      }
      if (objc_msgSend(v10, "length"))
      {
        objc_msgSend(v8, "addObject:", v10);
        if (objc_msgSend(v18, "length"))
        {
          objc_msgSend(v8, "addObject:", v18);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0C99E38], "null");
          v23 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v8, "addObject:", v23);

        }
      }
      if (objc_msgSend(v9, "length"))
      {
        objc_msgSend(v8, "addObject:", v9);
        if (objc_msgSend(v17, "length"))
        {
          objc_msgSend(v8, "addObject:", v17);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0C99E38], "null");
          v24 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v8, "addObject:", v24);

        }
      }
      if (objc_msgSend(v11, "length"))
      {
        objc_msgSend(v8, "addObject:", v11);
        if (objc_msgSend(v19, "length"))
        {
          objc_msgSend(v8, "addObject:", v19);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0C99E38], "null");
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v8, "addObject:", v25);

        }
      }

    }
  }

}

id TIGenerateReading(void *a1, void *a2, int a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v14;
  void *v15;
  id v16;

  v7 = a1;
  v8 = a2;
  v9 = a4;
  v10 = v9;
  if (a3 == 3)
  {
    if (objc_msgSend(v7, "length") && (objc_msgSend(v7, "_containsBopomofoOnly") & 1) != 0
      || !objc_msgSend(v8, "_containsIdeographicCharacters"))
    {
      goto LABEL_17;
    }
    objc_msgSend(v8, "_stringByTransliteratingToZhuyin");
    v12 = objc_claimAutoreleasedReturnValue();
LABEL_14:
    v11 = v7;
    goto LABEL_15;
  }
  if (a3 == 2)
  {
    if (!v9)
      goto LABEL_17;
    objc_msgSend(v9, "readingForWubiWord:", v8);
    v12 = objc_claimAutoreleasedReturnValue();
    goto LABEL_14;
  }
  if (a3 == 1 && !objc_msgSend(v7, "length"))
  {
    if (!objc_msgSend(v8, "_containsIdeographicCharacters"))
    {
      objc_msgSend(v8, "stringByFoldingWithOptions:locale:", 129, 0);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0CB3500], "pinyinInputCharacterSet");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "invertedSet");
      v15 = (void *)objc_claimAutoreleasedReturnValue();

      if (objc_msgSend(v11, "rangeOfCharacterFromSet:", v15) == 0x7FFFFFFFFFFFFFFFLL)
      {
        v16 = v11;

        v7 = v16;
      }

      goto LABEL_16;
    }
    objc_msgSend(v8, "_stringByTransliteratingToPinyin");
    v11 = (void *)objc_claimAutoreleasedReturnValue();

    if (!objc_msgSend(v11, "length"))
    {
      v7 = v11;
      goto LABEL_17;
    }
    objc_msgSend(v11, "stringByFoldingWithOptions:locale:", 129, 0);
    v12 = objc_claimAutoreleasedReturnValue();
LABEL_15:
    v7 = (id)v12;
LABEL_16:

  }
LABEL_17:

  return v7;
}

void KB::FilterLearnedTypo::~FilterLearnedTypo(KB::FilterLearnedTypo *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterLearnedTypo::filter_description(KB::FilterLearnedTypo *this)
{
  return "FilterLearnedTypo";
}

void KB::FilterLearnedTypo::filter_candidates(KB::FilterLearnedTypo *this, uint64_t **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unint64_t v8;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  unsigned __int16 *v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  BOOL v21;
  __CFString *v22;
  const char *v23;
  const char *v24;
  const char *v25;
  const char *v26;
  const char *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  void *v41;
  int v42;
  uint64_t v43;
  void *v44;
  int v45;
  _QWORD v46[3];
  _QWORD *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  if ((unint64_t)(0x1CAC083126E978D5 * (a2[1] - *a2)) >= 2)
  {
    v5 = v4[1];
    v6 = *v4 - 1;
    v7 = (unsigned __int16 *)(v5 + 240 * v6);
    if ((*((_DWORD *)v7 + 26) & 0x2040000) == 0x2000000 && *(_DWORD *)(v5 + 240 * v6 + 124) <= 1u)
    {
      v8 = v4[125];
      if (*v4 < v8)
      {
        v46[0] = &off_1EA0FAA40;
        v47 = v46;
        if (*((_QWORD *)v7 + 1))
          v11 = *((_QWORD *)v7 + 1);
        else
          v11 = (uint64_t)(v7 + 8);
        v36 = v11;
        v12 = *v7;
        v37 = 0;
        v38 = v12;
        v39 = 0;
        KB::String::iterator::initialize(&v36);
        v32 = v11;
        v33 = v12;
        v34 = v12;
        v35 = 0;
        KB::String::iterator::initialize(&v32);
        v13 = v37;
        v14 = (v8 - 1);
        if ((int)v14 >= 0)
        {
          while (v13 < v33)
          {
            v15 = (unsigned __int16 *)(v4[126] + 240 * v14);
            if ((*((_BYTE *)v15 + 135) & 4) != 0)
            {
              KB::String::iterator::operator--((KB::String::iterator *)&v32);
              v19 = *((_QWORD *)v15 + 1);
              if (!v19)
                v19 = (uint64_t)(v15 + 8);
              v43 = v19;
              LODWORD(v44) = 0;
              HIDWORD(v44) = *v15;
              v45 = 0;
              KB::String::iterator::initialize(&v43);
              LODWORD(v43) = v45;
              LODWORD(v40) = v35;
              if (!v47)
              {
                std::__throw_bad_function_call[abi:nn180100]();
                std::vector<KB::Candidate>::erase[abi:nn180100](v30, v31);
                return;
              }
              if (((*(uint64_t (**)(_QWORD *, uint64_t *, uint64_t *))(*v47 + 48))(v47, &v43, &v40) & 1) == 0)
                goto LABEL_50;
            }
            else
            {
              if (*((_QWORD *)v15 + 1))
                v16 = *((_QWORD *)v15 + 1);
              else
                v16 = (uint64_t)(v15 + 8);
              v43 = v16;
              LODWORD(v44) = 0;
              v17 = *v15;
              HIDWORD(v44) = v17;
              v45 = 0;
              KB::String::iterator::initialize(&v43);
              v40 = v16;
              LODWORD(v41) = v17;
              HIDWORD(v41) = v17;
              v42 = 0;
              KB::String::iterator::initialize(&v40);
              v18 = (int)v44;
              while (v18 < (int)v41)
              {
                KB::String::iterator::operator--((KB::String::iterator *)&v32);
                KB::String::iterator::operator--((KB::String::iterator *)&v40);
                if (v33 < v13 || v42 != v35)
                  goto LABEL_50;
              }
            }
            if (v14-- <= 0)
            {
              LODWORD(v14) = -1;
              break;
            }
          }
        }
        if (v13 >= v33 && *v4 - 2 == (int)v14)
        {
          if ((v14 & 0x80000000) != 0)
          {
LABEL_32:
            v22 = (__CFString *)*((_QWORD *)a4 + 7);
            if (v22)
            {
              KB::Candidate::capitalized_string((KB::Candidate *)v4, (uint64_t)&v43);
              v23 = (const char *)v44;
              if (!v44)
                v23 = (const char *)&v45;
              if ((_WORD)v43)
                v24 = v23;
              else
                v24 = "";
              KB::Candidate::capitalized_string((KB::Candidate *)(v4 + 125), (uint64_t)&v40);
              v26 = (const char *)v41;
              if (!v41)
                v26 = (const char *)&v42;
              if ((_WORD)v40)
                v27 = v26;
              else
                v27 = "";
              KB::append_format(v22, (__CFString *)"Removing top candidate [%s] who appears to be a typo of a second candidate [%s]\n", v25, v24, v27);
              if (v41 && BYTE6(v40) == 1)
                free(v41);
              if (v44 && BYTE6(v43) == 1)
                free(v44);
            }
            std::vector<KB::Candidate>::erase[abi:nn180100]((uint64_t)a2, *a2);
          }
          else
          {
            while (*(_QWORD *)(v4[1] + 240 * v14 + 136) == *(_QWORD *)(v4[126]
                                                                                      + 240 * v14
                                                                                      + 136))
            {
              v21 = __OFSUB__((_DWORD)v14, 1);
              LODWORD(v14) = v14 - 1;
              if ((int)v14 < 0 != v21)
                goto LABEL_32;
            }
          }
        }
LABEL_50:
        v28 = v47;
        if (v47 == v46)
        {
          v29 = 4;
          v28 = v46;
        }
        else
        {
          if (!v47)
            return;
          v29 = 5;
        }
        (*(void (**)(void))(*v28 + 8 * v29))();
      }
    }
  }
}

void std::vector<KB::Candidate>::erase[abi:nn180100](uint64_t a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;

  v2 = a2;
  v4 = a2 + 125;
  v5 = *(uint64_t **)(a1 + 8);
  if (a2 + 125 != v5)
  {
    do
    {
      v6 = v2;
      v2 += 125;
    }
    while (KB::Candidate::operator=(v6, v2) + 250 != v5);
    v4 = *(uint64_t **)(a1 + 8);
  }
  while (v4 != v2)
    KB::Candidate::~Candidate((KB::Candidate *)(v4 - 125));
  *(_QWORD *)(a1 + 8) = v2;
}

void std::__function::__func<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(unsigned int,unsigned int)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(unsigned int,unsigned int)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA0FAA40;
  return result;
}

void std::__function::__func<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(unsigned int,unsigned int)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA0FAA40;
}

uint64_t std::__function::__func<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(unsigned int,unsigned int)>::operator()(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  if (*a2 != 32)
    return 0;
  v3 = *a3 - 98;
  v4 = v3 > 0x16;
  v5 = (0x501003u >> v3) & 1;
  if (v4)
    return 0;
  else
    return v5;
}

void KB::FilterTopDynamicWordsWithStaticVariant::~FilterTopDynamicWordsWithStaticVariant(KB::FilterTopDynamicWordsWithStaticVariant *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterTopDynamicWordsWithStaticVariant::filter_description(KB::FilterTopDynamicWordsWithStaticVariant *this)
{
  return "FilterTopDynamicWordsWithStaticVariant";
}

void KB::FilterTopDynamicWordsWithStaticVariant::filter_candidates(KB::FilterTopDynamicWordsWithStaticVariant *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  _QWORD *v11;
  unsigned int v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  BOOL v18;
  KB::Candidate *v19;
  unint64_t v20;
  int v21;
  __CFString *v22;
  const char *v23;
  const char *v24;
  const char *v25;
  _WORD v26[3];
  char v27;
  void *v28;
  _QWORD v29[3];

  v29[2] = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 3)) >= 2)
  {
    v8 = *((_QWORD *)a4 + 2);
    if (v8)
    {
      do
        v9 = __ldaxr((unsigned int *)v8);
      while (__stlxr(v9 + 1, (unsigned int *)v8));
    }
    v10 = *(_QWORD *)(v8 + 8) + 144;
    WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v8);
    v11 = *(_QWORD **)a2;
    while (1)
    {
      v12 = KB::Candidate::num_words_preserving_input(v11, a3, v10);
      v13 = *v11;
      v14 = *v11 == v12 && *(_QWORD *)a3 == v12;
      if (v14 || v13 == v12)
        break;
      v15 = v11[1] + 240 * v12 + 104;
      v16 = 240 * v13 - 240 * v12;
      while (1)
      {
        v17 = (*(_DWORD *)v15 & 0x70000) != 0 || *(_WORD *)(v15 - 104) == 0;
        v18 = !v17 && (*(_BYTE *)(v15 + 31) & 4) == 0;
        if (v18 || (*(_DWORD *)v15 & 0x80000000) != 0)
          break;
        v15 += 240;
        v16 -= 240;
        if (!v16)
          goto LABEL_34;
      }
      v19 = (KB::Candidate *)(v11 + 125);
      v20 = 0x1CAC083126E978D5 * ((uint64_t)(*((_QWORD *)a2 + 1) - (_QWORD)(v11 + 125)) >> 3);
      if (v20 >= 0xA)
        v20 = 10;
      KB::FilterTopDynamicWordsWithStaticVariant::should_remove_dynamic_variant_given_alternates((uint64_t)this, (KB::Candidate *)v11, (KB::Candidate *)(v11 + 125), (KB::Candidate *)((char *)v19 + 1000 * v20), (unint64_t *)a3, v10);
      if (!v21)
        break;
      v22 = (__CFString *)*((_QWORD *)a4 + 7);
      if (v22)
      {
        KB::Candidate::capitalized_string((KB::Candidate *)v11, (uint64_t)v26);
        v24 = (const char *)v28;
        if (!v28)
          v24 = (const char *)v29;
        v25 = "";
        if (v26[0])
          v25 = v24;
        KB::append_format(v22, (__CFString *)"Candidate '%s' has dynamic case variants while there exists a suitable lower-ranked candidate with static case-variants\n", v23, v25);
        if (v28)
        {
          if (v27 == 1)
            free(v28);
        }
      }
      v11 += 125;
      if (v19 == *((KB::Candidate **)a2 + 1))
        goto LABEL_35;
    }
LABEL_34:
    v19 = (KB::Candidate *)v11;
LABEL_35:
    std::vector<KB::Candidate>::erase((uint64_t)a2, *(uint64_t **)a2, v19);
  }
}

void KB::FilterTopDynamicWordsWithStaticVariant::should_remove_dynamic_variant_given_alternates(uint64_t a1, KB::Candidate *a2, KB::Candidate *a3, KB::Candidate *a4, unint64_t *a5, uint64_t a6)
{
  KB::Candidate *v9;
  _WORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  KB::Candidate *v16;

  if (a3 != a4)
  {
    v9 = a3;
    v12 = (_WORD *)((char *)a2 + 888);
    do
    {
      if (*(_QWORD *)a2 == *(_QWORD *)v9)
      {
        if (!*v12)
          KB::Candidate::compute_string(a2);
        if (!*((_WORD *)v9 + 444))
          KB::Candidate::compute_string(v9);
        v13 = *(_QWORD *)(a6 + 24);
        if (!v13)
        {
          std::__throw_bad_function_call[abi:nn180100]();
          std::vector<KB::Candidate>::erase(v14, v15, v16);
          return;
        }
        if ((*(unsigned int (**)(uint64_t, _WORD *, _WORD *))(*(_QWORD *)v13 + 48))(v13, v12, (_WORD *)v9 + 444)&& *(_QWORD *)a2 == KB::Candidate::num_words_matching_input(a2, v9, a6)&& *(_QWORD *)v9 == KB::Candidate::num_words_matching_input(v9, a2, a6)&& (KB::FilterTopDynamicWordsWithStaticVariant::prefer_candidate_over_dynamic_variant(a1, (uint64_t)v9, (uint64_t)a2, a5, a6) & 1) != 0)
        {
          return;
        }
      }
      v9 = (KB::Candidate *)((char *)v9 + 1000);
    }
    while (v9 != a4);
  }
}

void std::vector<KB::Candidate>::erase(uint64_t a1, uint64_t *a2, KB::Candidate *a3)
{
  KB::Candidate *v3;
  uint64_t *v4;
  uint64_t *v6;
  uint64_t v7;

  if (a2 != (uint64_t *)a3)
  {
    v3 = a3;
    v4 = a2;
    v6 = *(uint64_t **)(a1 + 8);
    if (a3 != (KB::Candidate *)v6)
    {
      v7 = (a3 - (KB::Candidate *)a2) >> 3;
      do
      {
        KB::Candidate::operator=(v4, &v4[v7]);
        v4 += 125;
      }
      while (&v4[v7] != v6);
      v3 = *(KB::Candidate **)(a1 + 8);
    }
    while (v3 != (KB::Candidate *)v4)
    {
      v3 = (KB::Candidate *)((char *)v3 - 1000);
      KB::Candidate::~Candidate(v3);
    }
    *(_QWORD *)(a1 + 8) = v4;
  }
}

uint64_t KB::FilterTopDynamicWordsWithStaticVariant::prefer_candidate_over_dynamic_variant(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  BOOL v5;
  uint64_t v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  char v16;
  char v17;
  float v19;
  _WORD v21[52];
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned __int8 v25;
  _WORD v26[52];
  int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned __int8 v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)a3)
    v5 = *(_QWORD *)a2 == 0;
  else
    v5 = 1;
  if (v5)
    return 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 1;
  do
  {
    KB::Word::Word((KB::Word *)v26, (const KB::Word *)(*(_QWORD *)(a3 + 8) + v11));
    KB::Word::Word((KB::Word *)v21, (const KB::Word *)(*(_QWORD *)(a2 + 8) + v11));
    v15 = *a4;
    if (v14 - 1 >= *a4)
    {
      v16 = 0;
    }
    else
    {
      v16 = KB::Word::preserves_input((KB::String *)v26, (KB::String *)(a4[1] + v11), a5);
      v15 = *a4;
    }
    if (v14 - 1 >= v15)
      v17 = 0;
    else
      v17 = KB::Word::preserves_input((KB::String *)v21, (KB::String *)(a4[1] + v11), a5);
    if (!(((v26[0] == 0) | (v30 >> 2) | ((v27 & 0x70000) != 0)) & (v27 >= 0) | v16 & 1) && (v22 & 0x40002) == 0x40000)
    {
      ++v12;
      v13 -= (uint64_t)(v28 - (unint64_t)v29) < *(unsigned int *)(a1 + 8);
    }
    if (!(((v21[0] == 0) | (v25 >> 2) | ((v22 & 0x70000) != 0)) & (v22 >= 0) | v17 & 1) && (v27 & 0x40002) == 0x40000)
    {
      --v12;
      if ((uint64_t)(v23 - (unint64_t)v24) < *(unsigned int *)(a1 + 8))
        ++v13;
    }
    KB::Word::~Word((KB::Word *)v21);
    KB::Word::~Word((KB::Word *)v26);
    if (v14 >= *(_QWORD *)a3)
      break;
    v11 += 240;
  }
  while (v14++ < *(_QWORD *)a2);
  if (v13 < 0)
    return 1;
  if (v12 >= 1
    && ((v19 = expf(*(float *)(a3 + 744)), v19 == 0.0) || (float)(v19 / expf(*(float *)(a2 + 744))) < *(float *)(a1 + 12)))
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

void KB::FilterInvalidTextReplacement::~FilterInvalidTextReplacement(KB::FilterInvalidTextReplacement *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterInvalidTextReplacement::filter_description(KB::FilterInvalidTextReplacement *this)
{
  return "FilterInvalidTextReplacement";
}

void KB::FilterInvalidTextReplacement::filter_candidates(KB::FilterInvalidTextReplacement *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  _BYTE v11[8];
  void *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  KB::Candidate::capitalized_string(a3, (uint64_t)v11);
  v6 = *((_QWORD *)a4 + 7);
  v9[0] = &off_1EA0FAA88;
  v9[1] = v11;
  v10 = v9;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v6, (uint64_t)"FilterInvalidTextReplacement", v9);
  v7 = v10;
  if (v10 == v9)
  {
    v8 = 4;
    v7 = v9;
  }
  else
  {
    if (!v10)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  if (v12)
  {
    if (v11[6] == 1)
      free(v12);
  }
}

void std::__function::__func<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA0FAA88;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA0FAA88;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, const KB::String *a3)
{
  KB::String *v4;
  const KB::String *v5;
  KB *v6;
  uint64_t v7;
  const char *v9;
  const char *v10;
  _WORD v11[3];
  char v12;
  void *v13;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)a2)
    return 0;
  v4 = *(KB::String **)a3;
  v5 = (const KB::String *)*((_QWORD *)a2 + 1);
  v6 = *(KB **)(a1 + 8);
  v7 = 240 * *(_QWORD *)a2;
  while ((*((_BYTE *)v5 + 106) & 1) == 0 || KB::should_match_input_with_shortcut(v6, v5, a3))
  {
    v5 = (const KB::String *)((char *)v5 + 240);
    v7 -= 240;
    if (!v7)
      return 0;
  }
  if (v4)
  {
    KB::Candidate::capitalized_string(a2, (uint64_t)v11);
    v9 = (const char *)v13;
    if (!v13)
      v9 = (const char *)v14;
    if (v11[0])
      v10 = v9;
    else
      v10 = "";
    KB::String::append_format(v4, "Candidate '%s' contains invalid text replacement", v10);
    if (v13)
    {
      if (v12 == 1)
        free(v13);
    }
  }
  return 1;
}

void KB::FilterWithoutSupplementalWords::~FilterWithoutSupplementalWords(KB::FilterWithoutSupplementalWords *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterWithoutSupplementalWords::filter_description(KB::FilterWithoutSupplementalWords *this)
{
  return "FilterWithoutSupplementalWords";
}

_QWORD *KB::FilterWithoutSupplementalWords::filter_candidates(KB::FilterWithoutSupplementalWords *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v5;
  _QWORD *result;
  uint64_t v7;
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v5 = *((_QWORD *)a4 + 7);
  v8[0] = &off_1EA0FAAD0;
  v9 = v8;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v5, (uint64_t)"FilterWithoutSupplementalWords", v8);
  result = v9;
  if (v9 == v8)
  {
    v7 = 4;
    result = v8;
  }
  else
  {
    if (!v9)
      return result;
    v7 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

void std::__function::__func<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA0FAAD0;
  return result;
}

void std::__function::__func<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA0FAAD0;
}

BOOL std::__function::__func<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  KB::String *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  _BOOL4 v7;
  BOOL v8;
  const char *v9;
  const char *v10;
  _WORD v12[3];
  char v13;
  void *v14;
  _QWORD v15[3];

  v15[2] = *MEMORY[0x1E0C80C00];
  v3 = *a3;
  if (*(_QWORD *)a2)
  {
    v4 = 240 * *(_QWORD *)a2 - 240;
    v5 = (uint64_t *)(*((_QWORD *)a2 + 1) + 224);
    do
    {
      v6 = *v5;
      v5 += 30;
      v7 = v6 != 0;
      if (v6)
        v8 = 1;
      else
        v8 = v4 == 0;
      v4 -= 240;
    }
    while (!v8);
    if (!v3)
      return !v7;
  }
  else
  {
    v7 = 0;
    if (!v3)
      return !v7;
  }
  if (!v7)
  {
    KB::Candidate::capitalized_string(a2, (uint64_t)v12);
    v9 = (const char *)v14;
    if (!v14)
      v9 = (const char *)v15;
    if (v12[0])
      v10 = v9;
    else
      v10 = "";
    KB::String::append_format(v3, "Candidate '%s' does not contain supplemental lexicons", v10);
    if (v14 && v13 == 1)
      free(v14);
  }
  return !v7;
}

void KB::FilterPartOfHyphenatedWord::~FilterPartOfHyphenatedWord(KB::FilterPartOfHyphenatedWord *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterPartOfHyphenatedWord::filter_description(KB::FilterPartOfHyphenatedWord *this)
{
  return "FilterPartOfHyphenatedWord";
}

void KB::FilterPartOfHyphenatedWord::filter_candidates(KB::FilterPartOfHyphenatedWord *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)a3 + 3173))
  {
    v4 = *((_QWORD *)a4 + 7);
    v7[0] = &off_1EA0FAB18;
    v8 = v7;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v4, (uint64_t)"FilterPartOfHyphenatedWord", v7);
    v5 = v8;
    if (v8 == v7)
    {
      v6 = 4;
      v5 = v7;
    }
    else
    {
      if (!v8)
        return;
      v6 = 5;
    }
    (*(void (**)(void))(*v5 + 8 * v6))();
  }
}

void std::__function::__func<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA0FAB18;
  return result;
}

void std::__function::__func<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA0FAB18;
}

uint64_t std::__function::__func<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  KB::String *v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t result;
  const char *v10;
  const char *v11;
  _WORD v12[3];
  char v13;
  void *v14;
  _QWORD v15[3];

  v15[2] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)a2)
    return 0;
  v3 = *a3;
  v4 = 240 * *(_QWORD *)a2 - 240;
  v5 = (unsigned int *)(*((_QWORD *)a2 + 1) + 104);
  do
  {
    v7 = *v5;
    v5 += 60;
    v6 = v7;
    if ((v7 & 0x10) != 0)
      break;
    v8 = v4;
    v4 -= 240;
  }
  while (v8);
  result = (v6 >> 4) & 1;
  if (v3 && (v6 & 0x10) != 0)
  {
    KB::Candidate::capitalized_string(a2, (uint64_t)v12);
    v10 = (const char *)v14;
    if (!v14)
      v10 = (const char *)v15;
    if (v12[0])
      v11 = v10;
    else
      v11 = "";
    KB::String::append_format(v3, "Candidate '%s' is an incomplete hyphenated word", v11);
    if (v14)
    {
      if (v13 == 1)
        free(v14);
    }
    return 1;
  }
  return result;
}

void KB::FilterCommonLearnedTypos::~FilterCommonLearnedTypos(KB::FilterCommonLearnedTypos *this)
{
  std::__shared_weak_count *v2;

  *(_QWORD *)this = &off_1EA0FD220;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table((uint64_t)this + 16);
}

{
  std::__shared_weak_count *v2;

  *(_QWORD *)this = &off_1EA0FD220;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table((uint64_t)this + 16);
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterCommonLearnedTypos::filter_description(KB::FilterCommonLearnedTypos *this)
{
  return "FilterCommonLearnedTypos";
}

void KB::FilterCommonLearnedTypos::filter_candidates(KB::FilterCommonLearnedTypos *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  int v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *p_shared_weak_owners;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  KB::Word *v32;
  KB::Word *v33;
  _QWORD *v34;
  char *size;
  char *v36;
  BOOL v37;
  unsigned __int8 *v38;
  uint64_t *i;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  void *__p[2];
  char v46;
  __int128 v47;
  __int128 v48;
  int v49;
  _QWORD v50[3];
  _QWORD *v51;
  std::string v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v8 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (v8)
  {
    v9 = std::__shared_weak_count::lock(v8);
    if (v9 && *((_QWORD *)this + 7))
      goto LABEL_39;
  }
  else
  {
    v9 = 0;
  }
  v10 = *((_QWORD *)a4 + 3);
  v11 = (std::__shared_weak_count *)*((_QWORD *)a4 + 4);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  if (!v10)
  {
    v18 = 0;
    goto LABEL_19;
  }
  v14 = *((_QWORD *)a4 + 3);
  v15 = (std::__shared_weak_count *)*((_QWORD *)a4 + 4);
  if (!v15)
  {
    v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 16))(v14);
    if (!v11)
      goto LABEL_25;
LABEL_20:
    v21 = (unint64_t *)&v11->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    goto LABEL_25;
  }
  v16 = (unint64_t *)&v15->__shared_owners_;
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + 1, v16));
  v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 16))(v14);
  v19 = (unint64_t *)&v15->__shared_owners_;
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (v20)
  {
LABEL_19:
    if (!v11)
      goto LABEL_25;
    goto LABEL_20;
  }
  ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
  std::__shared_weak_count::__release_weak(v15);
  if (v11)
    goto LABEL_20;
LABEL_25:
  if (v18)
  {
    v23 = *((_QWORD *)a4 + 3);
    v24 = (std::__shared_weak_count *)*((_QWORD *)a4 + 4);
    if (v24)
    {
      v25 = (unint64_t *)&v24->__shared_owners_;
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
      p_shared_weak_owners = (unint64_t *)&v24->__shared_weak_owners_;
      do
        v28 = __ldxr(p_shared_weak_owners);
      while (__stxr(v28 + 1, p_shared_weak_owners));
    }
    v29 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
    *((_QWORD *)this + 7) = v23;
    *((_QWORD *)this + 8) = v24;
    if (v29)
      std::__shared_weak_count::__release_weak(v29);
    if (v24)
    {
      v30 = (unint64_t *)&v24->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    KB::FilterCommonLearnedTypos::update_common_typos_dict(this);
  }
LABEL_39:
  v47 = 0u;
  v48 = 0u;
  v49 = 1065353216;
  if (*(_QWORD *)a3)
  {
    v32 = (KB::Word *)*((_QWORD *)a3 + 1);
    v33 = (KB::Word *)((char *)v32 + 240 * *(_QWORD *)a3);
    v34 = (_QWORD *)((char *)this + 16);
    do
    {
      KB::Word::capitalized_string(v32, (uint64_t)&v52);
      size = (char *)v52.__r_.__value_.__l.__size_;
      if (!v52.__r_.__value_.__l.__size_)
        size = &v52.__r_.__value_.__s.__data_[16];
      if (LOWORD(v52.__r_.__value_.__l.__data_))
        v36 = size;
      else
        v36 = "";
      std::string::basic_string[abi:nn180100]<0>(__p, v36);
      if (v52.__r_.__value_.__l.__size_)
        v37 = v52.__r_.__value_.__s.__data_[6] == 1;
      else
        v37 = 0;
      if (v37)
        free((void *)v52.__r_.__value_.__l.__size_);
      v38 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::find<std::string>(v34, (uint64_t)__p);
      if (v38)
      {
        for (i = (uint64_t *)*((_QWORD *)v38 + 7); i; i = (uint64_t *)*i)
        {
          if (*((char *)i + 39) < 0)
            std::string::__init_copy_ctor_external(&v52, (const std::string::value_type *)i[2], i[3]);
          else
            v52 = *(std::string *)(i + 2);
          std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v47, (uint64_t)&v52, (uint64_t)&v52);
          if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v52.__r_.__value_.__l.__data_);
        }
      }
      if (v46 < 0)
        operator delete(__p[0]);
      v32 = (KB::Word *)((char *)v32 + 240);
    }
    while (v32 != v33);
    if (*((_QWORD *)&v48 + 1))
    {
      v40 = *((_QWORD *)a4 + 7);
      v50[0] = &off_1EA0FAB60;
      v50[1] = &v47;
      v50[2] = a3;
      v51 = v50;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v40, (uint64_t)"FilterCommonLearnedTypos", v50);
      v41 = v51;
      if (v51 == v50)
      {
        v42 = 4;
        v41 = v50;
      }
      else
      {
        if (!v51)
          goto LABEL_69;
        v42 = 5;
      }
      (*(void (**)(void))(*v41 + 8 * v42))();
    }
  }
LABEL_69:
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v47);
  if (v9)
  {
    v43 = (unint64_t *)&v9->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void KB::FilterCommonLearnedTypos::update_common_typos_dict(KB::FilterCommonLearnedTypos *this)
{
  unint64_t v1;
  uint64_t v3;
  uint64_t i;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  char isKindOfClass;
  id v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t j;
  _QWORD *k;
  int v27;
  void *v28;
  const std::string::value_type *v29;
  uint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint8x8_t v35;
  unint64_t v36;
  unsigned __int8 **v37;
  unsigned __int8 *m;
  unint64_t v39;
  char *v40;
  std::string *v41;
  __int128 v42;
  __int128 v43;
  float v44;
  float v45;
  _BOOL8 v46;
  unint64_t v47;
  unint64_t v48;
  int8x8_t prime;
  void *v50;
  void *v51;
  uint64_t v52;
  _QWORD *v53;
  unint64_t v54;
  uint8x8_t v55;
  unint64_t v56;
  uint8x8_t v57;
  uint64_t v58;
  _QWORD *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  unint64_t v64;
  void *v65;
  uint64_t v66;
  unint64_t *p_shared_owners;
  unint64_t v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  std::__shared_weak_count *v73;
  _QWORD *v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  void *__p[2];
  uint64_t v80;
  __int128 v81;
  __int128 v82;
  int v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  size_t __n[2];
  __int128 v89;
  int v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  _BYTE v95[128];
  _BYTE v96[128];
  uint64_t v97;

  v97 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 5))
  {
    std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__deallocate_node(*((_QWORD **)this + 4));
    *((_QWORD *)this + 4) = 0;
    v3 = *((_QWORD *)this + 3);
    if (v3)
    {
      for (i = 0; i != v3; ++i)
        *(_QWORD *)(*((_QWORD *)this + 2) + 8 * i) = 0;
    }
    *((_QWORD *)this + 5) = 0;
  }
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 8);
  if (v5)
  {
    v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      v7 = v6;
      v8 = *((_QWORD *)this + 7);
      if (v8)
      {
        (*(void (**)(void **__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v8 + 208))(__p, v8, *((unsigned int *)this + 2));
        v9 = __p[0];
        v10 = v9;
        if (v9)
        {
          objc_msgSend(v9, "objectForKeyedSubscript:", *MEMORY[0x1E0D43508]);
          v11 = (void *)objc_claimAutoreleasedReturnValue();
          v12 = v11;
          if (v11)
          {
            if (objc_msgSend(v11, "count"))
            {
              objc_msgSend(v12, "objectAtIndexedSubscript:", 0);
              v13 = (void *)objc_claimAutoreleasedReturnValue();
              if (v13)
              {
                v14 = v13;
                objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("URL"));
                v15 = (void *)objc_claimAutoreleasedReturnValue();
                if (v15)
                {
                  v70 = v14;
                  v71 = v12;
                  v72 = v10;
                  v73 = v7;
                  v69 = v15;
                  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithContentsOfURL:", v15);
                  v16 = (void *)objc_claimAutoreleasedReturnValue();
                  v91 = 0u;
                  v92 = 0u;
                  v93 = 0u;
                  v94 = 0u;
                  v77 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v91, v96, 16);
                  if (v77)
                  {
                    v75 = v16;
                    v76 = *(_QWORD *)v92;
                    v74 = (_QWORD *)((char *)this + 32);
                    do
                    {
                      v17 = 0;
                      do
                      {
                        if (*(_QWORD *)v92 != v76)
                          objc_enumerationMutation(v16);
                        v18 = *(void **)(*((_QWORD *)&v91 + 1) + 8 * v17);
                        *(_OWORD *)__n = 0u;
                        v89 = 0u;
                        v90 = 1065353216;
                        objc_msgSend(v16, "objectForKeyedSubscript:", v18);
                        v19 = (void *)objc_claimAutoreleasedReturnValue();
                        objc_opt_class();
                        isKindOfClass = objc_opt_isKindOfClass();

                        v78 = v17;
                        if ((isKindOfClass & 1) != 0)
                        {
                          objc_msgSend(v16, "objectForKeyedSubscript:", v18);
                          v21 = (id)objc_claimAutoreleasedReturnValue();
                          v84 = 0u;
                          v85 = 0u;
                          v86 = 0u;
                          v87 = 0u;
                          v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v84, v95, 16);
                          if (v22)
                          {
                            v23 = v22;
                            v24 = *(_QWORD *)v85;
                            do
                            {
                              for (j = 0; j != v23; ++j)
                              {
                                if (*(_QWORD *)v85 != v24)
                                  objc_enumerationMutation(v21);
                                std::string::basic_string[abi:nn180100]<0>(__p, (char *)objc_msgSend(objc_retainAutorelease(*(id *)(*((_QWORD *)&v84 + 1) + 8 * j)), "UTF8String"));
                                std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)__n, (uint64_t)__p, (uint64_t)__p);
                                if (SHIBYTE(v80) < 0)
                                  operator delete(__p[0]);
                              }
                              v23 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v84, v95, 16);
                            }
                            while (v23);
                          }
                        }
                        else
                        {
                          objc_msgSend(v16, "objectForKeyedSubscript:", v18);
                          v21 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                          std::string::basic_string[abi:nn180100]<0>(__p, (char *)objc_msgSend(v21, "UTF8String"));
                          std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)__n, (uint64_t)__p, (uint64_t)__p);
                          if (SHIBYTE(v80) < 0)
                            operator delete(__p[0]);
                        }

                        std::string::basic_string[abi:nn180100]<0>(__p, (char *)objc_msgSend(objc_retainAutorelease(v18), "UTF8String"));
                        v81 = 0u;
                        v82 = 0u;
                        v83 = v90;
                        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)&v81, __n[1]);
                        for (k = (_QWORD *)v89; k; k = (_QWORD *)*k)
                          std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v81, (uint64_t)(k + 2), (uint64_t)(k + 2));
                        v27 = SHIBYTE(v80);
                        v29 = (const std::string::value_type *)__p[0];
                        v28 = __p[1];
                        if (v80 >= 0)
                          v30 = (uint64_t *)__p;
                        else
                          v30 = (uint64_t *)__p[0];
                        if (v80 >= 0)
                          v31 = HIBYTE(v80);
                        else
                          v31 = (unint64_t)__p[1];
                        v32 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v30, v31);
                        v33 = v32;
                        v34 = *((_QWORD *)this + 3);
                        if (v34)
                        {
                          v35 = (uint8x8_t)vcnt_s8((int8x8_t)v34);
                          v35.i16[0] = vaddlv_u8(v35);
                          v36 = v35.u32[0];
                          if (v35.u32[0] > 1uLL)
                          {
                            v1 = v32;
                            if (v32 >= v34)
                              v1 = v32 % v34;
                          }
                          else
                          {
                            v1 = (v34 - 1) & v32;
                          }
                          v37 = *(unsigned __int8 ***)(*((_QWORD *)this + 2) + 8 * v1);
                          if (v37)
                          {
                            for (m = *v37; m; m = *(unsigned __int8 **)m)
                            {
                              v39 = *((_QWORD *)m + 1);
                              if (v39 == v33)
                              {
                                if (std::equal_to<std::string>::operator()[abi:nn180100](m + 16, (unsigned __int8 *)__p))
                                {
                                  goto LABEL_117;
                                }
                              }
                              else
                              {
                                if (v36 > 1)
                                {
                                  if (v39 >= v34)
                                    v39 %= v34;
                                }
                                else
                                {
                                  v39 &= v34 - 1;
                                }
                                if (v39 != v1)
                                  break;
                              }
                            }
                          }
                        }
                        v40 = (char *)operator new(0x50uLL);
                        *(_QWORD *)v40 = 0;
                        *((_QWORD *)v40 + 1) = v33;
                        v41 = (std::string *)(v40 + 16);
                        if (v27 < 0)
                        {
                          std::string::__init_copy_ctor_external(v41, v29, (std::string::size_type)v28);
                        }
                        else
                        {
                          *(_OWORD *)&v41->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
                          *((_QWORD *)v40 + 4) = v80;
                        }
                        v42 = v81;
                        v43 = v82;
                        *((_QWORD *)v40 + 7) = v82;
                        v81 = 0uLL;
                        *(_OWORD *)(v40 + 40) = v42;
                        *((_QWORD *)v40 + 8) = *((_QWORD *)&v43 + 1);
                        *((_DWORD *)v40 + 18) = v83;
                        if (*((_QWORD *)&v43 + 1))
                        {
                          *(_QWORD *)(v42 + 8 * *((_QWORD *)&v42 + 1)) = v40 + 56;
                          v82 = 0uLL;
                        }
                        v44 = (float)(unint64_t)(*((_QWORD *)this + 5) + 1);
                        v45 = *((float *)this + 12);
                        if (!v34 || (float)(v45 * (float)v34) < v44)
                        {
                          v46 = (v34 & (v34 - 1)) != 0;
                          if (v34 < 3)
                            v46 = 1;
                          v47 = v46 | (2 * v34);
                          v48 = vcvtps_u32_f32(v44 / v45);
                          if (v47 <= v48)
                            prime = (int8x8_t)v48;
                          else
                            prime = (int8x8_t)v47;
                          if (*(_QWORD *)&prime == 1)
                          {
                            prime = (int8x8_t)2;
                          }
                          else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
                          {
                            prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
                          }
                          v34 = *((_QWORD *)this + 3);
                          if (*(_QWORD *)&prime <= v34)
                          {
                            if (*(_QWORD *)&prime < v34)
                            {
                              v56 = vcvtps_u32_f32((float)*((unint64_t *)this + 5) / *((float *)this + 12));
                              if (v34 < 3
                                || (v57 = (uint8x8_t)vcnt_s8((int8x8_t)v34),
                                    v57.i16[0] = vaddlv_u8(v57),
                                    v57.u32[0] > 1uLL))
                              {
                                v56 = std::__next_prime(v56);
                              }
                              else
                              {
                                v58 = 1 << -(char)__clz(v56 - 1);
                                if (v56 >= 2)
                                  v56 = v58;
                              }
                              if (*(_QWORD *)&prime <= v56)
                                prime = (int8x8_t)v56;
                              if (*(_QWORD *)&prime >= v34)
                              {
                                v34 = *((_QWORD *)this + 3);
                              }
                              else
                              {
                                if (prime)
                                  goto LABEL_73;
                                v65 = (void *)*((_QWORD *)this + 2);
                                *((_QWORD *)this + 2) = 0;
                                if (v65)
                                  operator delete(v65);
                                v34 = 0;
                                *((_QWORD *)this + 3) = 0;
                              }
                            }
                          }
                          else
                          {
LABEL_73:
                            if (*(_QWORD *)&prime >> 61)
                              std::__throw_bad_array_new_length[abi:nn180100]();
                            v50 = operator new(8 * *(_QWORD *)&prime);
                            v51 = (void *)*((_QWORD *)this + 2);
                            *((_QWORD *)this + 2) = v50;
                            if (v51)
                              operator delete(v51);
                            v52 = 0;
                            *((int8x8_t *)this + 3) = prime;
                            do
                              *(_QWORD *)(*((_QWORD *)this + 2) + 8 * v52++) = 0;
                            while (*(_QWORD *)&prime != v52);
                            v53 = (_QWORD *)*v74;
                            if (*v74)
                            {
                              v54 = v53[1];
                              v55 = (uint8x8_t)vcnt_s8(prime);
                              v55.i16[0] = vaddlv_u8(v55);
                              if (v55.u32[0] > 1uLL)
                              {
                                if (v54 >= *(_QWORD *)&prime)
                                  v54 %= *(_QWORD *)&prime;
                              }
                              else
                              {
                                v54 &= *(_QWORD *)&prime - 1;
                              }
                              *(_QWORD *)(*((_QWORD *)this + 2) + 8 * v54) = v74;
                              v59 = (_QWORD *)*v53;
                              if (*v53)
                              {
                                do
                                {
                                  v60 = v59[1];
                                  if (v55.u32[0] > 1uLL)
                                  {
                                    if (v60 >= *(_QWORD *)&prime)
                                      v60 %= *(_QWORD *)&prime;
                                  }
                                  else
                                  {
                                    v60 &= *(_QWORD *)&prime - 1;
                                  }
                                  if (v60 != v54)
                                  {
                                    v61 = *((_QWORD *)this + 2);
                                    if (!*(_QWORD *)(v61 + 8 * v60))
                                    {
                                      *(_QWORD *)(v61 + 8 * v60) = v53;
                                      goto LABEL_98;
                                    }
                                    *v53 = *v59;
                                    *v59 = **(_QWORD **)(*((_QWORD *)this + 2) + 8 * v60);
                                    **(_QWORD **)(*((_QWORD *)this + 2) + 8 * v60) = v59;
                                    v59 = v53;
                                  }
                                  v60 = v54;
LABEL_98:
                                  v53 = v59;
                                  v59 = (_QWORD *)*v59;
                                  v54 = v60;
                                }
                                while (v59);
                              }
                            }
                            v34 = (unint64_t)prime;
                          }
                          if ((v34 & (v34 - 1)) != 0)
                          {
                            if (v33 >= v34)
                              v1 = v33 % v34;
                            else
                              v1 = v33;
                          }
                          else
                          {
                            v1 = (v34 - 1) & v33;
                          }
                        }
                        v62 = *((_QWORD *)this + 2);
                        v63 = *(_QWORD **)(v62 + 8 * v1);
                        if (v63)
                        {
                          *(_QWORD *)v40 = *v63;
LABEL_115:
                          *v63 = v40;
                          goto LABEL_116;
                        }
                        *(_QWORD *)v40 = *v74;
                        *v74 = v40;
                        *(_QWORD *)(v62 + 8 * v1) = v74;
                        if (*(_QWORD *)v40)
                        {
                          v64 = *(_QWORD *)(*(_QWORD *)v40 + 8);
                          if ((v34 & (v34 - 1)) != 0)
                          {
                            if (v64 >= v34)
                              v64 %= v34;
                          }
                          else
                          {
                            v64 &= v34 - 1;
                          }
                          v63 = (_QWORD *)(*((_QWORD *)this + 2) + 8 * v64);
                          goto LABEL_115;
                        }
LABEL_116:
                        ++*((_QWORD *)this + 5);
LABEL_117:
                        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v81);
                        if (SHIBYTE(v80) < 0)
                          operator delete(__p[0]);
                        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)__n);
                        v17 = v78 + 1;
                        v16 = v75;
                      }
                      while (v78 + 1 != v77);
                      v66 = objc_msgSend(v75, "countByEnumeratingWithState:objects:count:", &v91, v96, 16);
                      v77 = v66;
                    }
                    while (v66);
                  }

                  v10 = v72;
                  v7 = v73;
                  v14 = v70;
                  v12 = v71;
                  v15 = v69;
                }

              }
            }
          }

        }
      }
      else
      {
        v10 = 0;
      }
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v68 = __ldaxr(p_shared_owners);
      while (__stlxr(v68 - 1, p_shared_owners));
      if (!v68)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }

      if (v10)
        CFRelease(v10);
    }
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::find<std::string>(_QWORD *a1, uint64_t a2)
{
  int v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  int8x8_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;

  v4 = *(char *)(a2 + 23);
  if (v4 >= 0)
    v5 = (uint64_t *)a2;
  else
    v5 = *(uint64_t **)a2;
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_QWORD *)(a2 + 8);
  v7 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v5, v6);
  v8 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v8)
    return 0;
  v9 = v7;
  v10 = (uint8x8_t)vcnt_s8(v8);
  v10.i16[0] = vaddlv_u8(v10);
  v11 = v10.u32[0];
  if (v10.u32[0] > 1uLL)
  {
    v12 = v7;
    if (v7 >= *(_QWORD *)&v8)
      v12 = v7 % *(_QWORD *)&v8;
  }
  else
  {
    v12 = (*(_QWORD *)&v8 - 1) & v7;
  }
  v13 = *(unsigned __int8 ***)(*a1 + 8 * v12);
  if (!v13)
    return 0;
  for (i = *v13; i; i = *(unsigned __int8 **)i)
  {
    v15 = *((_QWORD *)i + 1);
    if (v15 == v9)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
        return i;
    }
    else
    {
      if (v11 > 1)
      {
        if (v15 >= *(_QWORD *)&v8)
          v15 %= *(_QWORD *)&v8;
      }
      else
      {
        v15 &= *(_QWORD *)&v8 - 1;
      }
      if (v15 != v12)
        return 0;
    }
  }
  return i;
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  _QWORD *v18;
  std::string *v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  size_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
            return;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3)
            break;
        }
      }
    }
  }
  v18 = operator new(0x28uLL);
  v18[1] = v11;
  v19 = (std::string *)(v18 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v18[4] = *(_QWORD *)(a3 + 16);
  }
  v20 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    v22 = 1;
    if (v12 >= 3)
      v22 = (v12 & (v12 - 1)) != 0;
    v23 = v22 | (2 * v12);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      v25 = v24;
    else
      v25 = v23;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v25);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v26 = *(_QWORD *)a1;
  v27 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v27)
  {
    *v18 = *v27;
LABEL_47:
    *v27 = v18;
    goto LABEL_48;
  }
  v28 = *(_QWORD *)(a1 + 16);
  *v18 = v28;
  *(_QWORD *)(a1 + 16) = v18;
  *(_QWORD *)(v26 + 8 * v3) = a1 + 16;
  if (v28)
  {
    v29 = *(_QWORD *)(v28 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v29 >= v12)
        v29 %= v12;
    }
    else
    {
      v29 &= v12 - 1;
    }
    v27 = (_QWORD *)(*(_QWORD *)a1 + 8 * v29);
    goto LABEL_47;
  }
LABEL_48:
  ++*(_QWORD *)(a1 + 24);
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(uint64_t a1)
{
  void **v2;
  void **v3;
  void *v4;

  v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0)
        operator delete(v2[2]);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::__function::__func<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA0FAB60;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FAB60;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  KB::String *v5;
  KB::Word *v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  unsigned __int8 *v11;
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  void *__p;
  void *v18;
  _BYTE v19[16];
  _WORD v20[3];
  char v21;
  void *v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)a2)
    return 0;
  v5 = *a3;
  v6 = (KB::Word *)*((_QWORD *)a2 + 1);
  v7 = *(_QWORD **)(a1 + 8);
  v8 = 240 * *(_QWORD *)a2;
  while (1)
  {
    KB::Word::capitalized_string(v6, (uint64_t)v20);
    v9 = (char *)v22;
    if (!v22)
      v9 = (char *)v23;
    if (v20[0])
      v10 = v9;
    else
      v10 = "";
    std::string::basic_string[abi:nn180100]<0>(&__p, v10);
    v11 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::find<std::string>(v7, (uint64_t)&__p);
    if ((v19[7] & 0x80000000) != 0)
      operator delete(__p);
    if (v22 && v21 == 1)
      free(v22);
    if (v11)
      break;
    v6 = (KB::Word *)((char *)v6 + 240);
    v8 -= 240;
    if (!v8)
      return 0;
  }
  if (v5)
  {
    KB::Candidate::capitalized_string(a2, (uint64_t)v20);
    v13 = (const char *)v22;
    if (!v22)
      v13 = (const char *)v23;
    if (v20[0])
      v14 = v13;
    else
      v14 = "";
    KB::Candidate::capitalized_string(*(KB::Candidate **)(a1 + 16), (uint64_t)&__p);
    v15 = (const char *)v18;
    if (!v18)
      v15 = v19;
    if ((_WORD)__p)
      v16 = v15;
    else
      v16 = "";
    KB::String::append_format(v5, "Candidate '%s' & user input '%s' is/has a known pair of autocorrection candidates to avoid", v14, v16);
    if (v18 && BYTE6(__p) == 1)
      free(v18);
    if (v22)
    {
      if (v21 == 1)
        free(v22);
    }
  }
  return 1;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t *a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v72;
  unint64_t v73;

  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      v6 = *a1 - 0x3C5A37A36834CED9 * (v5 + a2);
      v8 = a1[2];
      v7 = a1[3];
      v9 = __ROR8__(v6 + v7, 52);
      v10 = v6 + a1[1];
      v11 = __ROR8__(v10, 7);
      v12 = v10 + v8;
      v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      v15 = __ROR8__(v14 + v13, 52);
      v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v5 + a2), 37) + v9;
      v17 = __ROR8__(v13, 37);
      v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      v19 = __ROR8__(v18, 7);
      v20 = v16 + __ROR8__(v12, 31);
      v21 = v18 + v5;
      v22 = v21 + v14;
      v23 = 0x9AE16A3B2F90404FLL;
      v24 = 0xC3A5C85C97CB3127 * (v22 + v20) - 0x651E95C4D06FBFB1 * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      v25 = v20 - 0x3C5A37A36834CED9 * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }
    v4 = 0x9DDFEA08EB382D69;
    v32 = *(uint64_t *)((char *)a1 + a2 - 48);
    v33 = *(uint64_t *)((char *)a1 + a2 - 40);
    v34 = *(uint64_t *)((char *)a1 + a2 - 24);
    v36 = *(uint64_t *)((char *)a1 + a2 - 64);
    v35 = *(uint64_t *)((char *)a1 + a2 - 56);
    v37 = *(uint64_t *)((char *)a1 + a2 - 16);
    v38 = *(uint64_t *)((char *)a1 + a2 - 8);
    v39 = v35 + v37;
    v40 = 0x9DDFEA08EB382D69
        * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))));
    v41 = 0x9DDFEA08EB382D69 * (v40 ^ (v40 >> 47));
    v42 = v36 + a2 + v35 + v32;
    v43 = v42 + v33;
    v44 = __ROR8__(v42, 44) + v36 + a2 + __ROR8__(v33 + v36 + a2 - 0x622015F714C7D297 * (v40 ^ (v40 >> 47)), 21);
    v45 = v35 + v37 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    v46 = v45 + v34 + v37;
    v47 = __ROR8__(v46, 44);
    v48 = v46 + v38;
    v49 = v47 + v45 + __ROR8__(v45 + v33 + v38, 21);
    v51 = *a1;
    v50 = a1 + 4;
    v52 = v51 - 0x4B6D499041670D8DLL * v33;
    v53 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      v54 = *(v50 - 3);
      v55 = v52 + v43 + v39 + v54;
      v56 = v50[2];
      v57 = v50[3];
      v58 = v50[1];
      v39 = v58 + v43 - 0x4B6D499041670D8DLL * __ROR8__(v39 + v44 + v56, 42);
      v59 = v41 + v48;
      v60 = *(v50 - 2);
      v61 = *(v50 - 1);
      v62 = *(v50 - 4) - 0x4B6D499041670D8DLL * v44;
      v63 = v62 + v48 + v61;
      v64 = v62 + v54 + v60;
      v43 = v64 + v61;
      v65 = __ROR8__(v64, 44) + v62;
      v66 = (0xB492B66FBE98F273 * __ROR8__(v55, 37)) ^ v49;
      v52 = 0xB492B66FBE98F273 * __ROR8__(v59, 33);
      v44 = v65 + __ROR8__(v63 + v66, 21);
      v67 = v52 + v49 + *v50;
      v48 = v67 + v58 + v56 + v57;
      v49 = __ROR8__(v67 + v58 + v56, 44) + v67 + __ROR8__(v39 + v60 + v67 + v57, 21);
      v50 += 8;
      v41 = v66;
      v53 += 64;
    }
    while (v53);
    v68 = v52
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) >> 47));
    v69 = 0x9DDFEA08EB382D69
        * (v68 ^ (v66
                - 0x4B6D499041670D8DLL * (v39 ^ (v39 >> 47))
                - 0x622015F714C7D297
                * ((0x9DDFEA08EB382D69
                  * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) ^ ((0x9DDFEA08EB382D69 * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) >> 47))));
    v70 = 0x9DDFEA08EB382D69 * (v68 ^ (v69 >> 47) ^ v69);
    goto LABEL_13;
  }
  if (a2 > 0x10)
  {
    v26 = a1[1];
    v27 = 0xB492B66FBE98F273 * *a1;
    v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    v23 = 0x9DDFEA08EB382D69;
    v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v28 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a1 + a2 - 16)));
    v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    v25 = 0x9DDFEA08EB382D69 * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }
  if (a2 < 9)
  {
    if (a2 >= 4)
    {
      v72 = *(unsigned int *)((char *)a1 + a2 - 4);
      v23 = 0x9DDFEA08EB382D69;
      v73 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a1) + a2) ^ v72);
      v31 = v72 ^ (v73 >> 47) ^ v73;
      goto LABEL_8;
    }
    v4 = 0x9AE16A3B2F90404FLL;
    if (!a2)
      return v4;
    v70 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v4 *= v70 ^ (v70 >> 47);
    return v4;
  }
  v2 = *(uint64_t *)((char *)a1 + a2 - 8);
  v3 = __ROR8__(v2 + a2, a2);
  return (0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) >> 47))) ^ v2;
}

BOOL std::equal_to<std::string>::operator()[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  BOOL v12;
  BOOL v13;
  _BOOL8 v14;

  v2 = a1[23];
  if ((v2 & 0x80u) == 0)
    v3 = a1[23];
  else
    v3 = *((_QWORD *)a1 + 1);
  v4 = a2[23];
  v5 = (char)v4;
  if ((v4 & 0x80u) != 0)
    v4 = *((_QWORD *)a2 + 1);
  if (v3 != v4)
    return 0;
  if (v5 < 0)
    a2 = *(unsigned __int8 **)a2;
  if ((v2 & 0x80) != 0)
    return memcmp(*(const void **)a1, a2, *((_QWORD *)a1 + 1)) == 0;
  if (!a1[23])
    return 1;
  v6 = v2 - 1;
  do
  {
    v8 = *a1++;
    v7 = v8;
    v10 = *a2++;
    v9 = v10;
    v12 = v6-- != 0;
    v13 = v7 == v9;
    v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  _QWORD *v18;
  float v19;
  float v20;
  _BOOL8 v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
            return;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3)
            break;
        }
      }
    }
  }
  v18 = operator new(0x28uLL);
  v18[1] = v11;
  *((_OWORD *)v18 + 1) = *(_OWORD *)a3;
  v18[4] = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v19 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v20 = *(float *)(a1 + 32);
  if (!v12 || (float)(v20 * (float)v12) < v19)
  {
    v21 = 1;
    if (v12 >= 3)
      v21 = (v12 & (v12 - 1)) != 0;
    v22 = v21 | (2 * v12);
    v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23)
      v24 = v23;
    else
      v24 = v22;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v24);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v25 = *(_QWORD *)a1;
  v26 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v26)
  {
    *v18 = *v26;
LABEL_44:
    *v26 = v18;
    goto LABEL_45;
  }
  v27 = *(_QWORD *)(a1 + 16);
  *v18 = v27;
  *(_QWORD *)(a1 + 16) = v18;
  *(_QWORD *)(v25 + 8 * v3) = a1 + 16;
  if (v27)
  {
    v28 = *(_QWORD *)(v27 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12)
        v28 %= v12;
    }
    else
    {
      v28 &= v12 - 1;
    }
    v26 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_set<std::string>>,0>(uint64_t a1)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__deallocate_node(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = (_QWORD *)*v1;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_set<std::string>>,0>((uint64_t)(v1 + 2));
      operator delete(v1);
      v1 = v2;
    }
    while (v2);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__deallocate_node(*(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void KB::FilterAppNames::~FilterAppNames(KB::FilterAppNames *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterAppNames::filter_description(KB::FilterAppNames *this)
{
  return "FilterAppNames";
}

_QWORD *KB::FilterAppNames::filter_candidates(KB::FilterAppNames *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _QWORD v13[3];
  _QWORD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v7 = *((_QWORD *)a4 + 2);
  if (v7)
  {
    do
      v8 = __ldaxr((unsigned int *)v7);
    while (__stlxr(v8 + 1, (unsigned int *)v7));
  }
  v9 = *(_QWORD *)(v7 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v7);
  v10 = *((_QWORD *)a4 + 7);
  v13[0] = &off_1EA0FABA8;
  v13[1] = v9;
  v13[2] = a3;
  v14 = v13;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v10, (uint64_t)"FilterAppNames", v13);
  result = v14;
  if (v14 == v13)
  {
    v12 = 4;
    result = v13;
  }
  else
  {
    if (!v14)
      return result;
    v12 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
}

void std::__function::__func<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA0FABA8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FABA8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  KB::String *v4;
  unsigned int v5;
  int *v6;
  uint64_t v7;
  int v8;
  const char *v10;
  const char *v11;
  _WORD v12[3];
  char v13;
  void *v14;
  _QWORD v15[3];

  v15[2] = *MEMORY[0x1E0C80C00];
  v4 = *a3;
  v5 = KB::Candidate::num_words_matching_input(a2, *(_QWORD **)(a1 + 16), *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a2 == v5)
    return 0;
  v6 = (int *)(240 * v5 + *((_QWORD *)a2 + 1) + 104);
  v7 = -240 * v5 + 240 * *(_QWORD *)a2;
  while (1)
  {
    v8 = *v6;
    v6 += 60;
    if (v8 < 0)
      break;
    v7 -= 240;
    if (!v7)
      return 0;
  }
  if (v4)
  {
    KB::Candidate::capitalized_string(a2, (uint64_t)v12);
    v10 = (const char *)v14;
    if (!v14)
      v10 = (const char *)v15;
    if (v12[0])
      v11 = v10;
    else
      v11 = "";
    KB::String::append_format(v4, "Candidate '%s' is a completion for an app name", v11);
    if (v14)
    {
      if (v13 == 1)
        free(v14);
    }
  }
  return 1;
}

void *TIACAllowedAppIds()
{
  return &unk_1EA13FF28;
}

uint64_t KB::LanguageModelContext::pop_first_sentence(KB::LanguageModelContext *this)
{
  char *v2;
  char *v3;
  char *v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  __int128 v14;
  uint64_t result;
  uint64_t *v16;
  uint64_t i;
  uint64_t v18;

  v3 = (char *)*((_QWORD *)this + 2);
  v2 = (char *)*((_QWORD *)this + 3);
  v4 = v3 + 8;
  if (v3 + 8 == v2)
    goto LABEL_6;
  while (*((_DWORD *)v4 + 1) != 1)
  {
    v4 += 8;
    if (v4 == v2)
    {
      v4 = (char *)*((_QWORD *)this + 3);
      break;
    }
  }
  if (v3 == v4)
  {
    v6 = *((_QWORD *)this + 2);
  }
  else
  {
LABEL_6:
    v5 = v2 - v4;
    if (v2 == v4)
    {
      v6 = *((_QWORD *)this + 2);
    }
    else
    {
      memmove(*((void **)this + 2), v4, v2 - v4);
      v6 = *((_QWORD *)this + 2);
    }
    *((_QWORD *)this + 3) = &v3[v5];
  }
  v7 = (uint64_t)&v4[-v6];
  v8 = v7 >> 3;
  if (v7)
  {
    v9 = *((_QWORD *)this + 10);
    v10 = *((_QWORD *)this + 11);
    v11 = v9 + 24 * v8;
    if (v11 != v10)
    {
      v12 = 24 * v8;
      do
      {
        if (*(char *)(v9 + 23) < 0)
          operator delete(*(void **)v9);
        v13 = (_BYTE *)(v9 + v12);
        v14 = *(_OWORD *)(v9 + 24 * v8);
        *(_QWORD *)(v9 + 16) = *(_QWORD *)(v9 + v12 + 16);
        *(_OWORD *)v9 = v14;
        v9 += 24;
        v13[23] = 0;
        *v13 = 0;
      }
      while (v9 + v12 != v10);
      v11 = *((_QWORD *)this + 11);
    }
    while (v11 != v9)
    {
      if (*(char *)(v11 - 1) < 0)
        operator delete(*(void **)(v11 - 24));
      v11 -= 24;
    }
    *((_QWORD *)this + 11) = v9;
  }
  result = language_modeling::v1::LinguisticContext::remove_first((KB::LanguageModelContext *)((char *)this + 64));
  --*((_QWORD *)this + 6);
  v16 = *(uint64_t **)this;
  if (*(_QWORD *)this)
  {
    v18 = *v16;
    for (i = v16[1]; i != v18; result = std::__destroy_at[abi:nn180100]<KB::LanguageModelContext,0>(i))
      i -= 104;
    v16[1] = v18;
  }
  return result;
}

_QWORD *KB::class_token_text@<X0>(KB *this@<X0>, TITokenID a2@<0:X1>, _QWORD *a3@<X8>)
{
  char **v3;
  char *v4;

  if (SHIDWORD(this) <= 63)
  {
    switch(HIDWORD(this))
    {
      case 3:
        v3 = (char **)MEMORY[0x1E0D42FB0];
        goto LABEL_19;
      case 4:
        goto LABEL_13;
      case 5:
        v3 = (char **)MEMORY[0x1E0D42F20];
        goto LABEL_19;
      case 6:
        v3 = (char **)MEMORY[0x1E0D430E0];
        goto LABEL_19;
      case 7:
        v3 = (char **)MEMORY[0x1E0D42F48];
        goto LABEL_19;
      default:
        if (HIDWORD(this) != 63)
          goto LABEL_13;
        v3 = (char **)MEMORY[0x1E0D42FB8];
        break;
    }
    goto LABEL_19;
  }
  if (SHIDWORD(this) > 130)
  {
    if (HIDWORD(this) == 131)
    {
      v3 = (char **)MEMORY[0x1E0D43050];
      goto LABEL_19;
    }
    if (HIDWORD(this) == 499)
    {
      v3 = (char **)MEMORY[0x1E0D43100];
      goto LABEL_19;
    }
  }
  else
  {
    if (HIDWORD(this) == 64)
    {
      v3 = (char **)MEMORY[0x1E0D42FC8];
      goto LABEL_19;
    }
    if (HIDWORD(this) == 130)
    {
      v3 = (char **)MEMORY[0x1E0D43080];
LABEL_19:
      v4 = *v3;
      return std::string::basic_string[abi:nn180100]<0>(a3, v4);
    }
  }
LABEL_13:
  v4 = "";
  return std::string::basic_string[abi:nn180100]<0>(a3, v4);
}

uint64_t std::__destroy_at[abi:nn180100]<KB::LanguageModelContext,0>(uint64_t a1)
{
  void *v2;
  void **v4;

  v4 = (void **)(a1 + 80);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v4);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 72));
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 64));
  v2 = *(void **)(a1 + 16);
  if (v2)
  {
    *(_QWORD *)(a1 + 24) = v2;
    operator delete(v2);
  }
  return std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](a1);
}

BOOL KB::LanguageModelContext::is_beginning_of_sentence(KB::LanguageModelContext *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = language_modeling::v1::LinguisticContext::tokenSpan((KB::LanguageModelContext *)((char *)this + 64));
  return v2 && *(_DWORD *)(v1 + 32 * v2 - 8) == 1;
}

uint64_t KB::LanguageModelContext::is_linguistically_void(KB::LanguageModelContext *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  KB::LanguageModelContext **v4;
  KB::LanguageModelContext *v5;
  KB::LanguageModelContext *v6;
  uint64_t result;

  v1 = *((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 3) - v1;
  if (v2)
  {
    v3 = 8 * (v2 >> 3);
    while ((*(_DWORD *)(v1 + 4) - 1) < 0x1F3)
    {
      v1 += 8;
      v3 -= 8;
      if (!v3)
        goto LABEL_5;
    }
    return 0;
  }
  else
  {
LABEL_5:
    v4 = *(KB::LanguageModelContext ***)this;
    if (!*(_QWORD *)this)
      return 1;
    v5 = *v4;
    v6 = v4[1];
    if (*v4 == v6)
    {
      return 1;
    }
    else
    {
      do
      {
        result = KB::LanguageModelContext::is_linguistically_void(v5);
        if (!(_DWORD)result)
          break;
        v5 = (KB::LanguageModelContext *)((char *)v5 + 104);
      }
      while (v5 != v6);
    }
  }
  return result;
}

void KB::LanguageModelContext::debug_string_for_token(uint64_t a1@<X1>, uint64_t a2@<X2>, KB::String *a3@<X8>)
{
  const __CFString *StringForSpecialTokenID;
  const char *v5;

  if (HIDWORD(a1) > 0x1F3)
  {
    if (*(char *)(a2 + 23) >= 0)
      v5 = (const char *)a2;
    else
      v5 = *(const char **)a2;
    KB::String::String(a3, v5);
  }
  else
  {
    StringForSpecialTokenID = (const __CFString *)LMLanguageModelCreateStringForSpecialTokenID();
    KB::utf8_string(StringForSpecialTokenID, (uint64_t)a3);
    if (StringForSpecialTokenID)
      CFRelease(StringForSpecialTokenID);
  }
}

void KB::LanguageModelContext::description(int **this@<X0>, KB::String *a2@<X8>)
{
  int *v4;
  int *v5;
  uint64_t v6;
  int *v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int16 *v10;
  int *v11;
  int *v12;
  uint64_t v13;
  unint64_t v14;
  const char *v15;
  unsigned int v16;
  uint64_t v17;
  int *v18;
  unint64_t v19;
  const char *v20;
  const char *v22;
  const char *v23;
  _QWORD v24[2];
  void (*v25)(uint64_t, uint64_t, uint64_t);
  void *v26;
  uint64_t *v27;
  KB::LanguageModelContext *v28;
  int v29;
  __int16 v30;
  char v31;
  void *v32;
  _BYTE v33[16];
  uint64_t v34;
  unsigned __int16 *v35;
  uint64_t v36;
  uint64_t (*v37)(uint64_t, uint64_t);
  void (*v38)(uint64_t);
  int v39;
  __int16 v40;
  char v41;
  void *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  v35 = (unsigned __int16 *)&v34;
  v36 = 0x4802000000;
  v37 = __Block_byref_object_copy__1465;
  v38 = __Block_byref_object_dispose__1466;
  v39 = 0x100000;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 0x40000000;
  v25 = ___ZNK2KB20LanguageModelContext11descriptionEv_block_invoke;
  v26 = &unk_1EA0FAD28;
  v27 = &v34;
  v28 = (KB::LanguageModelContext *)this;
  v4 = this[7];
  v5 = this[5];
  if (v4 != v5)
    KB::String::append((unsigned __int16 *)&v39, "<blocklisted> ", 0xFFFFuLL);
  v6 = (uint64_t)this[10];
  v7 = this[11];
  if ((int *)v6 != v7)
  {
    v8 = (uint64_t *)this[2];
    do
    {
      if (v4 != v5 && v8 == (uint64_t *)&this[2][2 * (_QWORD)this[7]])
        KB::String::append(v35 + 20, "</blocklisted> ", 0xFFFFuLL);
      v9 = *v8++;
      v25((uint64_t)v24, v9, v6);
      v6 += 24;
    }
    while ((int *)v6 != v7);
  }
  v10 = v35;
  v12 = this[2];
  v11 = this[3];
  v13 = (char *)v11 - (char *)v12;
  if (v11 == v12)
  {
    v30 = 0;
    v31 = 0;
    v32 = "(empty)";
    v29 = 1048583;
    v33[1] = 0;
  }
  else
  {
    v29 = 0x100000;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33[0] = 0;
    v14 = TILocaleIdentifierForLexiconID(*v12);
    if (v14)
      v15 = (const char *)v14;
    else
      v15 = "";
    KB::String::append_format((KB::String *)&v29, "[%s]%u", v15, v12[1]);
    if (v13 != 8)
    {
      v16 = 2;
      v17 = 1;
      do
      {
        v18 = &v12[2 * v17];
        v19 = TILocaleIdentifierForLexiconID(*(_QWORD *)v18);
        if (v19)
          v20 = (const char *)v19;
        else
          v20 = "";
        KB::String::append_format((KB::String *)&v29, " [%s]%u", v20, v18[1]);
        v17 = v16;
      }
      while (v13 >> 3 > (unint64_t)v16++);
    }
  }
  v22 = (const char *)v32;
  if (!v32)
    v22 = v33;
  if ((_WORD)v29)
    v23 = v22;
  else
    v23 = "";
  KB::String::append_format((KB::String *)(v10 + 20), "(%s)", v23);
  if (v32 && v31 == 1)
    free(v32);
  KB::String::String(a2, (const KB::String *)(v35 + 20));
  _Block_object_dispose(&v34, 8);
  if (v42)
  {
    if (v41 == 1)
      free(v42);
  }
}

uint64_t __Block_byref_object_copy__1465(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 40) = 0x100000;
  v2 = a1 + 40;
  *(_WORD *)(v2 + 4) = 0;
  *(_BYTE *)(v2 + 6) = 0;
  *(_QWORD *)(v2 + 8) = 0;
  return KB::String::operator=(v2, (KB::String *)(a2 + 40));
}

void __Block_byref_object_dispose__1466(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 46) == 1)
      free(v2);
  }
}

void ___ZNK2KB20LanguageModelContext11descriptionEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const char *v4;
  const char *v5;
  _WORD v6[3];
  char v7;
  void *v8;
  _QWORD v9[3];

  v9[2] = *MEMORY[0x1E0C80C00];
  KB::LanguageModelContext::debug_string_for_token(a2, a3, (KB::String *)v6);
  v4 = (const char *)v8;
  if (!v8)
    v4 = (const char *)v9;
  if (v6[0])
    v5 = v4;
  else
    v5 = "";
  KB::String::append_format((KB::String *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "%s ", v5);
  if (v8)
  {
    if (v7 == 1)
      free(v8);
  }
}

uint64_t KB::LanguageModelContext::clear(KB::LanguageModelContext *this)
{
  uint64_t result;

  *((_QWORD *)this + 3) = *((_QWORD *)this + 2);
  std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)this + 10);
  language_modeling::v1::LinguisticContext::clear((KB::LanguageModelContext *)((char *)this + 64));
  result = language_modeling::v1::LinguisticContext::clear((KB::LanguageModelContext *)((char *)this + 72));
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  return result;
}

void KB::LanguageModelContext::append(KB::LanguageModelContext *this, TITokenID a2, const KB::String *a3, int a4)
{
  char *v7;
  char *v8;
  void *__p[2];
  char v10;

  v7 = (char *)*((_QWORD *)a3 + 1);
  if (!v7)
    v7 = (char *)a3 + 16;
  if (*(_WORD *)a3)
    v8 = v7;
  else
    v8 = "";
  std::string::basic_string[abi:nn180100]<0>(__p, v8);
  KB::LanguageModelContext::append(this, *(_QWORD *)&a2, (uint64_t)__p, a4);
  if (v10 < 0)
    operator delete(__p[0]);
}

_QWORD *KB::LanguageModelContext::pop_back(_QWORD *this)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  void **v4;
  uint64_t v5;
  language_modeling::v1::LinguisticContext *v6;
  uint64_t v7;

  v1 = this[3];
  if (v1 != this[2] && *(_DWORD *)(v1 - 4) != 1)
  {
    v2 = this;
    this[3] = v1 - 8;
    v3 = this[11];
    v4 = (void **)(v3 - 24);
    if (*(char *)(v3 - 1) < 0)
      operator delete(*v4);
    v2[11] = v4;
    language_modeling::v1::LinguisticContext::pop_back((language_modeling::v1::LinguisticContext *)(v2 + 8));
    v5 = v2[3] - v2[2];
    if (v2[7] > (unint64_t)(v5 >> 3))
      v2[7] = v5 >> 3;
    v6 = (language_modeling::v1::LinguisticContext *)(v2 + 9);
    this = (_QWORD *)language_modeling::v1::LinguisticContext::tokenSpan(v6);
    if (v7)
      return (_QWORD *)language_modeling::v1::LinguisticContext::pop_back(v6);
  }
  return this;
}

unint64_t KB::LanguageModelContext::suffix_len_from_lexicon(KB::LanguageModelContext *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t result;
  uint64_t v5;
  unint64_t v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;

  v2 = *((_QWORD *)this + 2);
  v3 = *((_QWORD *)this + 3) - v2;
  result = v3 >> 3;
  if (v3)
  {
    v5 = 0;
    if (result <= 1)
      v6 = 1;
    else
      v6 = result;
    v7 = (uint64_t *)(v2 + 8 * result - 8);
    while (1)
    {
      v9 = *v7--;
      v8 = HIDWORD(v9);
      if ((_DWORD)v9 != a2 && v8 > 0x1F3)
        break;
      if (v6 == ++v5)
        return result;
    }
    return v5;
  }
  return result;
}

uint64_t KB::LanguageModelContext::most_recent_lexicon_id(KB::LanguageModelContext *this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t result;

  v1 = *((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 3) - v1;
  if (!v2)
    return 0;
  v3 = (v2 & 0xFFFFFFFFFFFFFFF8) - 8;
  do
  {
    if (*(_DWORD *)(v1 + v3 + 4) >= 0x1F4u)
      result = *(unsigned int *)(v1 + v3);
    else
      result = 0;
    if (!v3)
      break;
    v3 -= 8;
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t KB::LanguageModelContext::most_recent_token_with_predicate(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v5;
  uint64_t v6;

  for (i = *(_QWORD *)(a1 + 24); i != *(_QWORD *)(a1 + 16); i -= 8)
  {
    v6 = *(_QWORD *)(i - 8);
    v5 = v6;
    if ((*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, v6))
      return v5;
  }
  return 0;
}

void KB::LanguageModelContext::set_predominant_locale(uint64_t a1, uint64_t a2)
{
  std::string __p;
  std::string v4;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v4, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v4 = *(std::string *)a2;
  language_modeling::v1::LinguisticContext::set_predominant_locale();
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v4.__r_.__value_.__l.__data_);
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  language_modeling::v1::LinguisticContext::set_predominant_locale();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

uint64_t WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  void *v3;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  void *v10;
  unsigned int v11;
  void **v12;

  v1 = result;
  v2 = atomic_load((unsigned int *)result);
  if (v2 == 1)
  {
    v3 = *(void **)(result + 216);
    if (v3 && *(_BYTE *)(v1 + 214) == 1)
      free(v3);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)(v1 + 184));
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)(v1 + 160));
    v4 = *(unsigned __int16 **)(v1 + 88);
    if (v4)
    {
      do
      {
        v5 = *(unsigned __int16 **)v4;
        std::__destroy_at[abi:nn180100]<std::pair<KB::ByteString const,WTF::RefPtr<TI::Favonius::LayoutKey>>,0>(v4 + 8);
        operator delete(v4);
        v4 = v5;
      }
      while (v5);
    }
    v6 = *(void **)(v1 + 72);
    *(_QWORD *)(v1 + 72) = 0;
    if (v6)
      operator delete(v6);
    v7 = *(_QWORD **)(v1 + 48);
    if (v7)
    {
      do
      {
        v8 = (_QWORD *)*v7;
        v9 = v7[3];
        if (v9)
          WTF::RefCounted<TI::Favonius::Key>::deref(v9);
        operator delete(v7);
        v7 = v8;
      }
      while (v8);
    }
    v10 = *(void **)(v1 + 32);
    *(_QWORD *)(v1 + 32) = 0;
    if (v10)
      operator delete(v10);
    v12 = (void **)(v1 + 8);
    std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>::__destroy_vector::operator()[abi:nn180100](&v12);
    JUMPOUT(0x1DF0A2144);
  }
  do
    v11 = __ldaxr((unsigned int *)result);
  while (__stlxr(v11 - 1, (unsigned int *)result));
  return result;
}

void std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*a1);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

void std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *((_QWORD *)v4 - 1);
        v4 -= 8;
        v6 = v7;
        if (v7)
          WTF::RefCounted<TI::Favonius::Key>::deref(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__destroy_at[abi:nn180100]<std::pair<KB::ByteString const,WTF::RefPtr<TI::Favonius::LayoutKey>>,0>(unsigned __int16 *a1)
{
  uint64_t result;

  result = *((_QWORD *)a1 + 2);
  if (result)
    result = WTF::RefCounted<TI::Favonius::Key>::deref(result);
  if (*a1 >= 0xFu)
  {
    result = *((_QWORD *)a1 + 1);
    if (result)
      JUMPOUT(0x1DF0A212CLL);
  }
  return result;
}

uint64_t __Block_byref_object_copy__217(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__218(uint64_t a1)
{

}

id chineseJapaneseResponseKitBackgroundQueue(void)
{
  if (chineseJapaneseResponseKitBackgroundQueue(void)::onceToken != -1)
    dispatch_once(&chineseJapaneseResponseKitBackgroundQueue(void)::onceToken, &__block_literal_global_1718);
  return (id)chineseJapaneseResponseKitBackgroundQueue(void)::_instance;
}

void ___Z41chineseJapaneseResponseKitBackgroundQueuev_block_invoke()
{
  dispatch_queue_t v0;
  void *v1;
  NSObject *v2;

  dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  v2 = objc_claimAutoreleasedReturnValue();
  v0 = dispatch_queue_create("com.apple.TextInput.ResponseKit.chineseJapaneseResponseKitBackgroundQueue", v2);
  v1 = (void *)chineseJapaneseResponseKitBackgroundQueue(void)::_instance;
  chineseJapaneseResponseKitBackgroundQueue(void)::_instance = (uint64_t)v0;

}

_QWORD *WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::Vector(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v5;
  unsigned int **v6;
  unsigned int **v7;
  unsigned int *v8;
  unsigned int v9;

  v3 = a2[2];
  *a1 = *a2;
  a1[1] = 0;
  a1[2] = 0;
  if (v3)
  {
    a1[2] = v3;
    v5 = malloc_type_malloc(8 * v3, 0x2004093837F09uLL);
    a1[1] = v5;
    if (v5)
    {
      if (*a2)
      {
        v6 = (unsigned int **)a2[1];
        v7 = &v6[*a2];
        do
        {
          v8 = *v6;
          *v5 = *v6;
          if (v8)
          {
            do
              v9 = __ldaxr(v8);
            while (__stlxr(v9 + 1, v8));
          }
          ++v5;
          ++v6;
        }
        while (v6 != v7);
      }
    }
  }
  return a1;
}

_QWORD *WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::~Vector(_QWORD *a1)
{
  uint64_t *v2;
  uint64_t v3;
  void *v4;

  if (*a1)
  {
    v2 = (uint64_t *)a1[1];
    v3 = 8 * *a1;
    do
    {
      if (*v2)
        WTF::RefCounted<TI::Favonius::KeyMatch>::deref(*v2);
      ++v2;
      v3 -= 8;
    }
    while (v3);
    *a1 = 0;
  }
  v4 = (void *)a1[1];
  a1[1] = 0;
  a1[2] = 0;
  free(v4);
  return a1;
}

uint64_t WTF::RefCounted<TI::Favonius::KeyMatch>::deref(uint64_t result)
{
  unsigned int v1;
  uint64_t v2;
  unsigned int v3;

  v1 = atomic_load((unsigned int *)result);
  if (v1 == 1)
  {
    v2 = *(_QWORD *)(result + 8);
    if (v2)
      WTF::RefCounted<TI::Favonius::Key>::deref(v2);
    JUMPOUT(0x1DF0A2144);
  }
  do
    v3 = __ldaxr((unsigned int *)result);
  while (__stlxr(v3 - 1, (unsigned int *)result));
  return result;
}

_QWORD *__Block_byref_object_copy__1746(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  a2[6] = 0;
  a2[7] = 0;
  v3 = result[8];
  result[8] = a2[8];
  a2[8] = v3;
  return result;
}

_QWORD *__Block_byref_object_dispose__1747(uint64_t a1)
{
  return WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::~Vector((_QWORD *)(a1 + 48));
}

_QWORD *WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::~Vector(_QWORD *a1)
{
  uint64_t *v2;
  uint64_t v3;
  void *v4;

  if (*a1)
  {
    v2 = (uint64_t *)a1[1];
    v3 = 8 * *a1;
    do
    {
      if (*v2)
        WTF::RefCounted<TI::Favonius::Key>::deref(*v2);
      ++v2;
      v3 -= 8;
    }
    while (v3);
    *a1 = 0;
  }
  v4 = (void *)a1[1];
  a1[1] = 0;
  a1[2] = 0;
  free(v4);
  return a1;
}

unint64_t WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::expandCapacity(_QWORD *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v3 = a3;
  v5 = a1[1];
  if (v5 > a3 || v5 + 8 * *a1 <= a3)
  {
    v9 = a1[2];
    if (v9 >= 0x100)
      v10 = v9 + (v9 >> 1);
    else
      v10 = 2 * v9;
    if (v10 > a2)
      a2 = v10;
    WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(a1, a2);
  }
  else
  {
    v6 = a3 - v5;
    v7 = a1[2];
    if (v7 >= 0x100)
      v8 = v7 + (v7 >> 1);
    else
      v8 = 2 * v7;
    if (v8 > a2)
      a2 = v8;
    WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(a1, a2);
    return a1[1] + v6;
  }
  return v3;
}

double TI::CP::PathSample::lerp@<D0>(float64x2_t *this@<X0>, float a2@<S0>, float64x2_t *a3@<X1>, float64x2_t *a4@<X8>)
{
  double result;
  float64x2_t v5;

  result = a2;
  v5 = vmlaq_n_f64(this[1], vsubq_f64(a3[1], this[1]), result);
  *a4 = vmlaq_n_f64(*this, vsubq_f64(*a3, *this), result);
  a4[1] = v5;
  a4[2] = vmlaq_n_f64(this[2], vsubq_f64(a3[2], this[2]), result);
  return result;
}

BOOL TI::CP::operator==(double *a1, double *a2)
{
  BOOL v2;

  v2 = *a1 == *a2 && a1[1] == a2[1];
  return v2 && a1[3] == a2[3] && a1[2] == a2[2] && a1[5] == a2[5];
}

BOOL TI::CP::operator!=(double *a1, double *a2)
{
  return !TI::CP::operator==(a1, a2);
}

BOOL TI::CP::Path::operator==(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double v9;
  double v10;
  uint64_t v12;
  unsigned int v13;
  const void *v15;
  size_t v16;
  const void *v17;

  v3 = *a1;
  v2 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v2 - *a1) >> 4);
  v6 = *a2;
  v5 = a2[1];
  if (v4 != 0xAAAAAAAAAAAAAAABLL * ((v5 - *a2) >> 4))
    return 0;
  v9 = 0.0;
  v10 = 0.0;
  if (v3 != v2)
    v10 = *(double *)(v2 - 16);
  if (v6 != v5)
    v9 = *(double *)(v5 - 16);
  if (v10 != v9)
    return 0;
  if (v3 != v2)
  {
    v12 = 0;
    v13 = 1;
    while (TI::CP::operator==((double *)(v3 + 48 * v12), (double *)(v6 + 48 * v12)))
    {
      v12 = v13;
      if (v4 <= v13++)
        goto LABEL_12;
    }
    return 0;
  }
LABEL_12:
  v15 = (const void *)a1[3];
  v16 = a1[4] - (_QWORD)v15;
  v17 = (const void *)a2[3];
  if (v16 != a2[4] - (_QWORD)v17)
    return 0;
  return memcmp(v15, v17, v16) == 0;
}

double TI::CP::Path::subpath_length(TI::CP::Path *this, unsigned int a2, unsigned int a3)
{
  return *(double *)(*(_QWORD *)this + 48 * a3 + 32) - *(double *)(*(_QWORD *)this + 48 * a2 + 32);
}

long double TI::CP::Path::subpath_excess_length(TI::CP::Path *this, unsigned int a2, unsigned int a3)
{
  double *v3;
  double *v4;
  double v5;

  v3 = (double *)(*(_QWORD *)this + 48 * a2);
  v4 = (double *)(*(_QWORD *)this + 48 * a3);
  v5 = v4[4] - v3[4];
  return v5 - hypot(*v4 - *v3, v4[1] - v3[1]);
}

uint64_t TI::CP::Path::inflection_point_count(TI::CP::Path *this)
{
  return (*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) >> 2;
}

unint64_t TI::CP::Path::inflection_point_count(TI::CP::Path *this, unsigned int a2, unsigned int a3)
{
  char *v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  unsigned int *v7;
  char *v8;
  unsigned int v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  unsigned int *v13;
  char *v14;
  unsigned int v15;

  v3 = (char *)*((_QWORD *)this + 3);
  v4 = (char *)*((_QWORD *)this + 4);
  if (v4 == v3)
  {
    v11 = (char *)*((_QWORD *)this + 4);
  }
  else
  {
    v5 = (v4 - v3) >> 2;
    do
    {
      v6 = v5 >> 1;
      v7 = (unsigned int *)&v3[4 * (v5 >> 1)];
      v9 = *v7;
      v8 = (char *)(v7 + 1);
      v5 += ~(v5 >> 1);
      if (v9 < a2)
        v3 = v8;
      else
        v5 = v6;
    }
    while (v5);
    if (v4 == v3)
    {
      v11 = (char *)*((_QWORD *)this + 4);
    }
    else
    {
      v10 = (v4 - v3) >> 2;
      v11 = v3;
      do
      {
        v12 = v10 >> 1;
        v13 = (unsigned int *)&v11[4 * (v10 >> 1)];
        v15 = *v13;
        v14 = (char *)(v13 + 1);
        v10 += ~(v10 >> 1);
        if (v15 > a3)
          v10 = v12;
        else
          v11 = v14;
      }
      while (v10);
    }
    v4 = v3;
  }
  return (unint64_t)(v11 - v4) >> 2;
}

BOOL TI::CP::Path::is_inflection_point(TI::CP::Path *this, unsigned int a2)
{
  return TI::CP::Path::inflection_point_count(this, a2, a2) != 0;
}

double TI::CP::Path::turn_angle(TI::CP::Path *this, unsigned int a2)
{
  double v2;
  uint64_t v4;
  uint64_t v5;
  double *v6;
  double v7;
  double v8;
  double *v9;
  double v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  double v16;
  long double v17;
  double v18;
  double v19;

  v2 = 0.0;
  if (a2)
  {
    v4 = a2 + 1;
    v5 = *(_QWORD *)this;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 4) != v4)
    {
      v6 = (double *)(v5 + 48 * a2);
      v7 = *v6;
      v8 = v6[1];
      v9 = (double *)(v5 + 48 * v4);
      v10 = *v9 - *v6;
      v11 = v9[1] - v8;
      if (hypot(v10, v11) >= 0.00001)
      {
        v12 = 48 * a2;
        while (1)
        {
          v13 = v12 - 48;
          if (!v12)
            break;
          v14 = v5 + v12;
          v15 = v7 - *(double *)(v14 - 48);
          v16 = v8 - *(double *)(v14 - 40);
          v17 = hypot(v15, v16);
          v12 = v13;
          if (v17 >= 0.00001)
          {
            v18 = atan2(v16, v15);
            v2 = atan2(v11, v10) - v18;
            if (v2 >= -3.14159265)
            {
              if (v2 <= 3.14159265)
                return v2;
              v19 = -6.28318531;
            }
            else
            {
              v19 = 6.28318531;
            }
            return v2 + v19;
          }
        }
      }
    }
  }
  return v2;
}

double TI::CP::Path::subpath_duration(TI::CP::Path *this, unsigned int a2, unsigned int a3)
{
  return *(double *)(*(_QWORD *)this + 48 * a3 + 16) - *(double *)(*(_QWORD *)this + 48 * a2 + 16);
}

_QWORD *TI::CP::Path::clear(_QWORD *this)
{
  this[1] = *this;
  this[4] = this[3];
  return this;
}

void TI::CP::Path::resize(TI::CP::Path *this, unsigned int a2)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;
  char *v22;
  size_t v23;
  _DWORD *v24;
  _DWORD *v25;
  unint64_t v26;
  unint64_t v27;
  unsigned int *v28;
  _DWORD *v29;
  unsigned int v30;

  v2 = a2;
  v3 = *(char **)this;
  v4 = *((_QWORD *)this + 1);
  v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *(_QWORD *)this) >> 4);
  v6 = a2 - v5;
  if (a2 == v5)
    return;
  if (a2 > v5)
  {
    v9 = *((_QWORD *)this + 2);
    if (0xAAAAAAAAAAAAAAABLL * ((v9 - v4) >> 4) < v6)
    {
      v10 = 0xAAAAAAAAAAAAAAABLL * ((v9 - (uint64_t)v3) >> 4);
      if (2 * v10 > a2)
        v2 = 2 * v10;
      if (v10 >= 0x2AAAAAAAAAAAAAALL)
        v11 = 0x555555555555555;
      else
        v11 = v2;
      v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TI::CP::PathSample>>(v11);
      v13 = &v12[48 * v5];
      v15 = &v12[48 * v14];
      v16 = 48 * ((48 * v6 - 48) / 0x30) + 48;
      bzero(v13, v16);
      v17 = &v13[v16];
      v19 = *(char **)this;
      v18 = (char *)*((_QWORD *)this + 1);
      if (v18 != *(char **)this)
      {
        do
        {
          v20 = *((_OWORD *)v18 - 3);
          v21 = *((_OWORD *)v18 - 1);
          *((_OWORD *)v13 - 2) = *((_OWORD *)v18 - 2);
          *((_OWORD *)v13 - 1) = v21;
          *((_OWORD *)v13 - 3) = v20;
          v13 -= 48;
          v18 -= 48;
        }
        while (v18 != v19);
        v18 = *(char **)this;
      }
      *(_QWORD *)this = v13;
      *((_QWORD *)this + 1) = v17;
      *((_QWORD *)this + 2) = v15;
      if (v18)
        operator delete(v18);
      goto LABEL_18;
    }
    v23 = 48 * ((48 * v6 - 48) / 0x30) + 48;
    bzero(*((void **)this + 1), v23);
    v22 = (char *)(v4 + v23);
    goto LABEL_17;
  }
  if (a2 < v5)
  {
    v22 = &v3[48 * a2];
LABEL_17:
    *((_QWORD *)this + 1) = v22;
  }
LABEL_18:
  v25 = (_DWORD *)*((_QWORD *)this + 3);
  v24 = (_DWORD *)*((_QWORD *)this + 4);
  if (v24 == v25)
  {
    v25 = (_DWORD *)*((_QWORD *)this + 4);
  }
  else
  {
    v26 = v24 - v25;
    do
    {
      v27 = v26 >> 1;
      v28 = &v25[v26 >> 1];
      v30 = *v28;
      v29 = v28 + 1;
      v26 += ~(v26 >> 1);
      if (v30 < a2)
        v25 = v29;
      else
        v26 = v27;
    }
    while (v26);
  }
  if (v24 != v25)
    *((_QWORD *)this + 4) = v25;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<TI::CP::PathSample>>(unint64_t a1)
{
  if (a1 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(48 * a1);
}

void TI::CP::Path::append(TI::CP::Path *this, CGPoint a2, CGFloat a3, CGFloat a4, double a5, CGFloat a6)
{
  CGFloat y;
  CGFloat x;
  CGFloat *v12;
  CGFloat *v13;
  double v14;
  double v15;
  unint64_t v16;
  CGFloat *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  CGFloat *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  __int128 v28;
  __int128 v29;

  y = a2.y;
  x = a2.x;
  if (a5 >= 0.0)
  {
    v15 = a5;
    v12 = (CGFloat *)*((_QWORD *)this + 1);
  }
  else
  {
    v12 = *(CGFloat **)this;
    v13 = (CGFloat *)*((_QWORD *)this + 1);
    if (*(CGFloat **)this == v13)
    {
      v15 = 0.0;
    }
    else
    {
      v14 = *(v13 - 2);
      v15 = v14 + hypot(a2.x - *(v13 - 6), a2.y - *(v13 - 5));
      v12 = v13;
    }
  }
  v16 = *((_QWORD *)this + 2);
  if ((unint64_t)v12 >= v16)
  {
    v18 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v12 - *(_QWORD *)this) >> 4);
    v19 = v18 + 1;
    if (v18 + 1 > 0x555555555555555)
      abort();
    v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - *(_QWORD *)this) >> 4);
    if (2 * v20 > v19)
      v19 = 2 * v20;
    if (v20 >= 0x2AAAAAAAAAAAAAALL)
      v21 = 0x555555555555555;
    else
      v21 = v19;
    v22 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TI::CP::PathSample>>(v21);
    v23 = (CGFloat *)&v22[48 * v18];
    v25 = &v22[48 * v24];
    *v23 = x;
    v23[1] = y;
    v23[2] = a3;
    v23[3] = a4;
    v23[4] = v15;
    v23[5] = a6;
    v17 = v23 + 6;
    v27 = *(char **)this;
    v26 = (char *)*((_QWORD *)this + 1);
    if (v26 != *(char **)this)
    {
      do
      {
        v28 = *((_OWORD *)v26 - 3);
        v29 = *((_OWORD *)v26 - 1);
        *((_OWORD *)v23 - 2) = *((_OWORD *)v26 - 2);
        *((_OWORD *)v23 - 1) = v29;
        *((_OWORD *)v23 - 3) = v28;
        v23 -= 6;
        v26 -= 48;
      }
      while (v26 != v27);
      v26 = *(char **)this;
    }
    *(_QWORD *)this = v23;
    *((_QWORD *)this + 1) = v17;
    *((_QWORD *)this + 2) = v25;
    if (v26)
      operator delete(v26);
  }
  else
  {
    *v12 = x;
    v12[1] = y;
    v12[2] = a3;
    v12[3] = a4;
    v17 = v12 + 6;
    v12[4] = v15;
    v12[5] = a6;
  }
  *((_QWORD *)this + 1) = v17;
}

void TI::CP::Path::append(TI::CP::Path *this, const TI::CP::PathSample *a2)
{
  _OWORD *v4;
  unint64_t v5;
  __int128 v6;
  __int128 v7;
  _OWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _OWORD *v14;
  unint64_t v15;
  __int128 v16;
  __int128 v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;

  v4 = (_OWORD *)*((_QWORD *)this + 1);
  v5 = *((_QWORD *)this + 2);
  if ((unint64_t)v4 >= v5)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *(_QWORD *)this) >> 4);
    v10 = v9 + 1;
    if (v9 + 1 > 0x555555555555555)
      abort();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *(_QWORD *)this) >> 4);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x2AAAAAAAAAAAAAALL)
      v12 = 0x555555555555555;
    else
      v12 = v10;
    if (v12)
      v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<TI::CP::PathSample>>(v12);
    else
      v13 = 0;
    v14 = (_OWORD *)(v12 + 48 * v9);
    v15 = v12 + 48 * v13;
    v16 = *(_OWORD *)a2;
    v17 = *((_OWORD *)a2 + 2);
    v14[1] = *((_OWORD *)a2 + 1);
    v14[2] = v17;
    *v14 = v16;
    v8 = v14 + 3;
    v19 = *(char **)this;
    v18 = (char *)*((_QWORD *)this + 1);
    if (v18 != *(char **)this)
    {
      do
      {
        v20 = *((_OWORD *)v18 - 3);
        v21 = *((_OWORD *)v18 - 1);
        *(v14 - 2) = *((_OWORD *)v18 - 2);
        *(v14 - 1) = v21;
        *(v14 - 3) = v20;
        v14 -= 3;
        v18 -= 48;
      }
      while (v18 != v19);
      v18 = *(char **)this;
    }
    *(_QWORD *)this = v14;
    *((_QWORD *)this + 1) = v8;
    *((_QWORD *)this + 2) = v15;
    if (v18)
      operator delete(v18);
  }
  else
  {
    v6 = *(_OWORD *)a2;
    v7 = *((_OWORD *)a2 + 2);
    v4[1] = *((_OWORD *)a2 + 1);
    v4[2] = v7;
    *v4 = v6;
    v8 = v4 + 3;
  }
  *((_QWORD *)this + 1) = v8;
}

void TI::CP::Path::set_sample_is_inflection_point(TI::CP::Path *this, unsigned int a2)
{
  unsigned int *v3;
  std::vector<unsigned int> *v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  std::allocator<unsigned int> *v10;
  unint64_t v11;
  unsigned int *v12;
  unsigned int *i;
  unsigned int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int *v24;
  unint64_t v25;
  unint64_t v26;
  unsigned int *v27;
  uint64_t v28;
  unsigned int v29;
  std::__split_buffer<unsigned int> __v;

  v29 = a2;
  v5 = (unsigned int *)*((_QWORD *)this + 3);
  v3 = (unsigned int *)*((_QWORD *)this + 4);
  v4 = (std::vector<unsigned int> *)((char *)this + 24);
  v6 = v3;
  v7 = v5;
  v8 = v3;
  while (v8 != v5)
  {
    v9 = *--v8;
    if (v9 <= a2)
    {
      v7 = v8 + 1;
      break;
    }
  }
  if (v7 == v3 || *v7 != a2)
  {
    v10 = (std::allocator<unsigned int> *)((char *)this + 40);
    v11 = *((_QWORD *)this + 5);
    if ((unint64_t)v3 >= v11)
    {
      v15 = v3 - v5 + 1;
      if (v15 >> 62)
        abort();
      v16 = (char *)v7 - (char *)v5;
      v17 = v7 - v5;
      v18 = v11 - (_QWORD)v5;
      v19 = (uint64_t)(v11 - (_QWORD)v5) >> 1;
      if (v19 > v15)
        v15 = v19;
      if (v18 >= 0x7FFFFFFFFFFFFFFCLL)
        v20 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v20 = v15;
      __v.__end_cap_.__value_ = v10;
      if (v20)
      {
        v22 = (unsigned int *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v20);
      }
      else
      {
        v22 = 0;
        v21 = 0;
      }
      v24 = &v22[v17];
      __v.__first_ = v22;
      __v.__begin_ = v24;
      __v.__end_cap_.__value_ = &v22[v21];
      if (v17 == v21)
      {
        if (v16 < 1)
        {
          if (v5 == v7)
            v26 = 1;
          else
            v26 = v16 >> 1;
          v27 = (unsigned int *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v26);
          v24 = (unsigned int *)((char *)v27 + (v26 & 0xFFFFFFFFFFFFFFFCLL));
          __v.__first_ = v27;
          __v.__begin_ = v24;
          __v.__end_cap_.__value_ = &v27[v28];
          if (v22)
            operator delete(v22);
        }
        else
        {
          v25 = v17 + 2;
          if (v17 >= -1)
            v25 = v17 + 1;
          v24 -= v25 >> 1;
          __v.__begin_ = v24;
        }
      }
      *v24 = a2;
      __v.__end_ = v24 + 1;
      std::vector<unsigned int>::__swap_out_circular_buffer(v4, &__v, v7);
      if (__v.__first_)
        operator delete(__v.__first_);
    }
    else if (v7 == v3)
    {
      *v3 = a2;
      *((_QWORD *)this + 4) = v3 + 1;
    }
    else
    {
      v12 = v7 + 1;
      for (i = v3 - 1; i < v3; ++i)
      {
        v14 = *i;
        *v6++ = v14;
      }
      *((_QWORD *)this + 4) = v6;
      if (v3 != v12)
        memmove(&v3[-(v3 - v12)], v7, (char *)v3 - (char *)v12);
      v23 = v29;
      if (v7 > &v29)
        v23 = a2;
      *v7 = v23;
    }
  }
}

std::vector<unsigned int>::pointer std::vector<unsigned int>::__swap_out_circular_buffer(std::vector<unsigned int> *this, std::__split_buffer<unsigned int> *__v, std::vector<unsigned int>::pointer __p)
{
  unsigned int *begin;
  std::vector<unsigned int>::pointer v6;
  unsigned int *v7;
  std::vector<unsigned int>::pointer v8;
  unsigned int v9;
  unsigned int *end;
  std::__split_buffer<unsigned int>::pointer v11;
  int64_t v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int *value;

  begin = __v->__begin_;
  v6 = this->__begin_;
  v7 = begin;
  if (this->__begin_ != __p)
  {
    v8 = __p;
    v7 = __v->__begin_;
    do
    {
      v9 = *--v8;
      *--v7 = v9;
    }
    while (v8 != v6);
  }
  __v->__begin_ = v7;
  end = this->__end_;
  v11 = __v->__end_;
  v12 = (char *)end - (char *)__p;
  if (end != __p)
  {
    memmove(__v->__end_, __p, (char *)end - (char *)__p);
    v7 = __v->__begin_;
  }
  __v->__end_ = (std::__split_buffer<unsigned int>::pointer)((char *)v11 + v12);
  v13 = this->__begin_;
  this->__begin_ = v7;
  __v->__begin_ = v13;
  v14 = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = v14;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
  return begin;
}

void TI::CP::Path::set_last_sample_is_inflection_point(TI::CP::Path *this)
{
  TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((_QWORD *)this + 1) - *(_QWORD *)this) >> 4) - 1);
}

void TI::CP::Path::resample(CGPoint **this@<X0>, double a2@<D0>, _QWORD *a3@<X8>)
{
  CGPoint *v4;
  CGPoint *v5;
  const void *v6;
  int64_t v7;
  char *v8;
  const void *v9;
  int64_t v10;
  char *v11;
  _QWORD v12[2];
  char v13;
  uint64_t v14;
  char v15;
  void *v16[2];
  void *v17[2];
  __int128 v18;
  void *v19[2];
  void *__p[2];
  __int128 v21;
  char v22;
  int v23;
  int v24;

  *(double *)v12 = a2;
  v12[1] = 1;
  v13 = 1;
  v14 = 0x3FD3333333333333;
  v15 = 0;
  v23 = 0;
  v24 = 0;
  *(_OWORD *)v16 = 0u;
  *(_OWORD *)v17 = 0u;
  v18 = 0u;
  *(_OWORD *)v19 = 0u;
  *(_OWORD *)__p = 0u;
  v21 = 0u;
  v22 = 0;
  v4 = *this;
  v5 = this[1];
  while (v4 != v5)
  {
    TI::CP::PathResampler::append_and_resample((TI::CP::PathResampler *)v12, *v4, v4[1].x, v4[1].y, v4[2].y);
    v4 += 3;
  }
  TI::CP::PathResampler::finalize((TI::CP::PathResampler *)v12);
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  v6 = v16[0];
  v7 = (char *)v16[1] - (char *)v16[0];
  if (v16[1] != v16[0])
  {
    std::vector<TI::CP::PathSample>::__vallocate[abi:nn180100](a3, 0xAAAAAAAAAAAAAAABLL * (v7 >> 4));
    v8 = (char *)a3[1];
    memmove(v8, v6, v7);
    a3[1] = &v8[v7];
  }
  a3[3] = 0;
  a3[4] = 0;
  a3[5] = 0;
  v9 = v17[1];
  v10 = v18 - (unint64_t)v17[1];
  if ((void *)v18 != v17[1])
  {
    std::vector<unsigned int>::__vallocate[abi:nn180100](a3 + 3, v10 >> 2);
    v11 = (char *)a3[4];
    memmove(v11, v9, v10);
    a3[4] = &v11[v10];
  }
  if (__p[1])
  {
    *(void **)&v21 = __p[1];
    operator delete(__p[1]);
  }
  if (v19[0])
  {
    v19[1] = v19[0];
    operator delete(v19[0]);
  }
  if (v17[1])
  {
    *(void **)&v18 = v17[1];
    operator delete(v17[1]);
  }
  if (v16[0])
  {
    v16[1] = v16[0];
    operator delete(v16[0]);
  }
}

char *std::vector<TI::CP::PathSample>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x555555555555556)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TI::CP::PathSample>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

uint64_t TI::CP::Path::is_local_max(_QWORD *a1, unsigned int a2, uint64_t a3, double a4)
{
  uint64_t v5;
  unsigned int v8;
  double v9;
  double v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  double v14;
  uint64_t v15;
  TI::CP::Path *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;

  v19 = a2;
  v5 = *(_QWORD *)(a3 + 24);
  if (v5)
  {
    v8 = a2;
    v9 = (*(double (**)(uint64_t, unsigned int *))(*(_QWORD *)v5 + 48))(v5, &v19);
    v10 = *(double *)(*a1 + 48 * v8 + 32);
    v11 = 48 * v8 + 32;
    v12 = v8 - 1;
    while (v11 != 32 && *(double *)(*a1 + v11) > v10 - a4)
    {
      v20 = v12;
      v13 = *(_QWORD *)(a3 + 24);
      if (!v13)
        goto LABEL_15;
      v11 -= 48;
      --v12;
      if ((*(double (**)(uint64_t, unsigned int *))(*(_QWORD *)v13 + 48))(v13, &v20) >= v9)
        return 0;
    }
    v14 = v10 + a4;
    while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 4) > v8 + 1 && *(double *)(*a1 + 48 * v8 + 32) < v14)
    {
      v21 = v8 + 1;
      v15 = *(_QWORD *)(a3 + 24);
      if (!v15)
        goto LABEL_15;
      ++v8;
      if ((*(double (**)(uint64_t, unsigned int *))(*(_QWORD *)v15 + 48))(v15, &v21) > v9)
        return 0;
    }
    return 1;
  }
  else
  {
LABEL_15:
    std::__throw_bad_function_call[abi:nn180100]();
    return TI::CP::Path::curvature(v17, v18);
  }
}

void TI::CP::Path::curvature(TI::CP::Path *this, unsigned int a2)
{
  float v2;

  if (a2 && 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 4) - 1 != a2)
  {
    v2 = (*(double *)(*(_QWORD *)this + 48 * (a2 + 1) + 32) - *(double *)(*(_QWORD *)this + 48 * (a2 - 1) + 32))
       * 0.5;
    if (v2 != 0.0)
      TI::CP::Path::turn_angle(this, a2);
  }
}

uint64_t TI::CP::Path::is_curvature_local_max(TI::CP::Path *this, unsigned int a2, double a3)
{
  double v6;
  uint64_t is_local_max;
  _QWORD *v8;
  uint64_t v9;
  _QWORD v11[3];
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  TI::CP::Path::curvature(this, a2);
  if (fabs(v6) <= 0.02)
    return 0;
  v11[0] = &off_1EA0FB048;
  v11[1] = this;
  v12 = v11;
  is_local_max = TI::CP::Path::is_local_max(this, a2, (uint64_t)v11, a3);
  v8 = v12;
  if (v12 == v11)
  {
    v9 = 4;
    v8 = v11;
    goto LABEL_7;
  }
  if (v12)
  {
    v9 = 5;
LABEL_7:
    (*(void (**)(void))(*v8 + 8 * v9))();
  }
  return is_local_max;
}

void std::__function::__func<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0,std::allocator<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0>,double ()(unsigned int)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0,std::allocator<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0>,double ()(unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA0FB048;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0,std::allocator<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0>,double ()(unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA0FB048;
  a2[1] = v2;
  return result;
}

double std::__function::__func<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0,std::allocator<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0>,double ()(unsigned int)>::operator()(uint64_t a1, unsigned int *a2)
{
  double v2;

  TI::CP::Path::curvature(*(TI::CP::Path **)(a1 + 8), *a2);
  return fabs(v2);
}

double TI::CP::Path::speed(TI::CP::Path *this, unsigned int a2)
{
  unint64_t v2;
  double result;
  unsigned int v4;
  unsigned int v5;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 4);
  result = 0.0;
  if (v2 >= 2)
  {
    v4 = a2 - 1;
    if (!a2)
      v4 = 0;
    if (v2 - 1 == a2)
      v5 = a2;
    else
      v5 = a2 + 1;
    return (*(double *)(*(_QWORD *)this + 48 * v5 + 32) - *(double *)(*(_QWORD *)this + 48 * v4 + 32))
         / (*(double *)(*(_QWORD *)this + 48 * v5 + 16) - *(double *)(*(_QWORD *)this + 48 * v4 + 16));
  }
  return result;
}

double KB::DataFile::DataFile(KB::DataFile *this)
{
  double result;

  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = 0;
  result = NAN;
  *(_QWORD *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((_QWORD *)this + 3) = 0;
  return result;
}

{
  double result;

  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = 0;
  result = NAN;
  *(_QWORD *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((_QWORD *)this + 3) = 0;
  return result;
}

KB::DataFile *KB::DataFile::DataFile(KB::DataFile *this, const char *__s1, int a3, uint64_t a4)
{
  char *v7;
  int v8;
  NSObject *v9;
  uint64_t v11;
  int *v12;
  char *v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)this = a3;
  *((_DWORD *)this + 1) = a4;
  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)((char *)this + 12) = 0xFFFFFFFF00000000;
  v7 = strdup(__s1);
  *((_QWORD *)this + 3) = v7;
  v8 = open_dprotected_np(v7, a3, 3, 0, a4);
  *((_DWORD *)this + 4) = v8;
  if (v8 < 0)
  {
    *((_DWORD *)this + 3) = *__error();
    if (*__error() != 2)
    {
      if (TICanLogMessageAtLevel_onceToken != -1)
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
      v9 = TIOSLogFacility();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v11 = *((_QWORD *)this + 3);
        v12 = __error();
        v13 = strerror(*v12);
        *(_DWORD *)buf = 136315650;
        v15 = "DataFile";
        v16 = 2082;
        v17 = v11;
        v18 = 2082;
        v19 = v13;
        _os_log_debug_impl(&dword_1DA6F2000, v9, OS_LOG_TYPE_DEBUG, "%s DataFile: file open error: %{public}s, (%{public}s)", buf, 0x20u);
      }
    }
  }
  else
  {
    *((_BYTE *)this + 8) = 1;
  }
  return this;
}

void KB::DataFile::~DataFile(KB::DataFile *this)
{
  int v2;

  v2 = *((_DWORD *)this + 4);
  if (v2 != -1)
    close(v2);
  free(*((void **)this + 3));
  *((_BYTE *)this + 8) = 0;
}

double KB::MappedDataFile::MappedDataFile(KB::MappedDataFile *this)
{
  double result;

  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = 0;
  result = NAN;
  *(_QWORD *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 12) = 0;
  return result;
}

{
  double result;

  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = 0;
  result = NAN;
  *(_QWORD *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 12) = 0;
  return result;
}

KB::MappedDataFile *KB::MappedDataFile::MappedDataFile(KB::MappedDataFile *this, const char *a2, int a3, uint64_t a4, int a5)
{
  KB::DataFile *v8;
  off_t *v9;
  NSObject *v10;
  int *v11;
  char *v12;
  const char *v13;
  stat *v14;
  NSObject *v15;
  uint32_t v16;
  NSObject *v17;
  unint64_t st_size;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  int v24;
  int v25;
  const char *v26;
  __int16 v27;
  char *v28;
  stat v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v8 = KB::DataFile::DataFile(this, a2, a3, a4);
  *((_QWORD *)v8 + 4) = 0;
  *((_QWORD *)v8 + 5) = 0;
  v9 = (off_t *)((char *)v8 + 32);
  *((_DWORD *)v8 + 12) = a5;
  *((_QWORD *)v8 + 7) = 0;
  if (*((_BYTE *)v8 + 8))
  {
    if (!a5)
    {
      if (TICanLogMessageAtLevel_onceToken != -1)
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
      v17 = TIOSLogFacility();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        goto LABEL_11;
      v24 = *((_DWORD *)this + 12);
      v29.st_dev = 136315394;
      *(_QWORD *)&v29.st_mode = "MappedDataFile";
      WORD2(v29.st_ino) = 1024;
      *(_DWORD *)((char *)&v29.st_ino + 6) = v24;
      v13 = "%s MappedDataFile: illegal protection mode: %d";
      v14 = &v29;
      v15 = v17;
      v16 = 18;
LABEL_24:
      _os_log_debug_impl(&dword_1DA6F2000, v15, OS_LOG_TYPE_DEBUG, v13, (uint8_t *)v14, v16);
      goto LABEL_11;
    }
    if (stat(a2, &v29))
    {
      if (TICanLogMessageAtLevel_onceToken != -1)
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
      v10 = TIOSLogFacility();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        goto LABEL_11;
      v11 = __error();
      v12 = strerror(*v11);
      v25 = 136315394;
      v26 = "MappedDataFile";
      v27 = 2082;
      v28 = v12;
      v13 = "%s MappedDataFile: stat error: %{public}s";
      v14 = (stat *)&v25;
      v15 = v10;
      v16 = 22;
      goto LABEL_24;
    }
    st_size = v29.st_size;
    *v9 = v29.st_size;
    if (st_size)
    {
      v20 = getpagesize();
      v21 = st_size / v20;
      if (st_size == v21 * v20)
      {
LABEL_21:
        *((_QWORD *)this + 5) = st_size;
        KB::MappedDataFile::map(this, 0);
        return this;
      }
      v22 = v20 + v20 * v21;
    }
    else
    {
      if ((*((_BYTE *)this + 48) & 2) == 0)
      {
LABEL_11:
        *((_BYTE *)this + 8) = 0;
        return this;
      }
      v22 = getpagesize();
    }
    if (v22 != st_size)
    {
      if ((*((_BYTE *)this + 48) & 2) != 0)
      {
        v23 = getpagesize();
        KB::MappedDataFile::resize(this, (int)v22 / v23);
        return this;
      }
      st_size = v22;
    }
    goto LABEL_21;
  }
  return this;
}

BOOL KB::MappedDataFile::resize(KB::MappedDataFile *this, int a2)
{
  void *v4;
  int v5;
  off_t v6;
  _BOOL8 result;
  NSObject *v8;
  int *v9;
  char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 1;
  KB::MappedDataFile::sync((uint64_t)this);
  v4 = (void *)*((_QWORD *)this + 7);
  if (v4)
  {
    munmap(*((void **)this + 7), *((_QWORD *)this + 5));
    *((_QWORD *)this + 7) = 0;
  }
  v5 = getpagesize();
  v6 = (v5 * a2) & ~((v5 * a2) >> 31);
  if (ftruncate(*((_DWORD *)this + 4), v6) < 0)
  {
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    v8 = TIOSLogFacility();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v9 = __error();
      v10 = strerror(*v9);
      v11 = 136315394;
      v12 = "resize";
      v13 = 2082;
      v14 = v10;
      _os_log_debug_impl(&dword_1DA6F2000, v8, OS_LOG_TYPE_DEBUG, "%s MappedDataFile: error in resize: %{public}s", (uint8_t *)&v11, 0x16u);
    }
    result = 0;
    *((_BYTE *)this + 8) = 0;
  }
  else
  {
    *((_QWORD *)this + 4) = v6;
    *((_QWORD *)this + 5) = v6;
    KB::MappedDataFile::map(this, v4);
    return *((_BYTE *)this + 8) != 0;
  }
  return result;
}

void KB::MappedDataFile::map(KB::MappedDataFile *this, void *a2)
{
  void *v3;
  NSObject *v4;
  int *v5;
  char *v6;
  int v7;
  const char *v8;
  __int16 v9;
  char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = mmap(a2, *((_QWORD *)this + 5), *((_DWORD *)this + 12), 1, *((_DWORD *)this + 4), 0);
  *((_QWORD *)this + 7) = v3;
  if (v3 == (void *)-1)
  {
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    v4 = TIOSLogFacility();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v5 = __error();
      v6 = strerror(*v5);
      v7 = 136315394;
      v8 = "map";
      v9 = 2082;
      v10 = v6;
      _os_log_debug_impl(&dword_1DA6F2000, v4, OS_LOG_TYPE_DEBUG, "%s MappedDataFile: mmap error: %{public}s", (uint8_t *)&v7, 0x16u);
    }
    *((_BYTE *)this + 8) = 0;
  }
}

uint64_t KB::MappedDataFile::sync(uint64_t this)
{
  uint64_t v1;

  if (*(_BYTE *)(this + 8))
  {
    v1 = this;
    if (*(_BYTE *)(this + 52))
    {
      if ((*(_BYTE *)(this + 48) & 2) != 0)
      {
        this = msync(*(void **)(this + 56), *(_QWORD *)(this + 40), 16);
        *(_BYTE *)(v1 + 52) = 0;
      }
    }
  }
  return this;
}

void KB::MappedDataFile::~MappedDataFile(KB::MappedDataFile *this)
{
  if (*((_BYTE *)this + 8))
  {
    KB::MappedDataFile::sync((uint64_t)this);
    munmap(*((void **)this + 7), *((_QWORD *)this + 5));
  }
  KB::DataFile::~DataFile(this);
}

KB::MappedDataFile *KB::ReadOnlyDataFile::ReadOnlyDataFile(KB::ReadOnlyDataFile *this, const char *a2, int a3)
{
  int v3;

  if (a3)
    v3 = 16;
  else
    v3 = 0;
  return KB::MappedDataFile::MappedDataFile(this, a2, v3, 256, 1);
}

{
  int v3;

  if (a3)
    v3 = 16;
  else
    v3 = 0;
  return KB::MappedDataFile::MappedDataFile(this, a2, v3, 256, 1);
}

_QWORD *KB::InputStream::InputStream(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 32);
  *result = *(_QWORD *)(a2 + 56);
  result[1] = v3;
  result[2] = a3;
  return result;
}

{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 32);
  *result = *(_QWORD *)(a2 + 56);
  result[1] = v3;
  result[2] = a3;
  return result;
}

_QWORD *KB::InputStream::InputStream(_QWORD *this, const void *a2, uint64_t a3)
{
  *this = a2;
  this[1] = a3;
  this[2] = 0;
  return this;
}

{
  *this = a2;
  this[1] = a3;
  this[2] = 0;
  return this;
}

uint64_t KB::InputStream::read_null_terminated_string(KB::InputStream *this, KB::String *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  const char *v7;
  unsigned int v8;
  unint64_t v9;
  _BYTE v11[8];
  void *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)this;
  v5 = *((_QWORD *)this + 1);
  v6 = *((_QWORD *)this + 2);
  v7 = (const char *)(*(_QWORD *)this + v6);
  if (v5)
    v8 = strnlen((const char *)(*(_QWORD *)this + v6), v5 - v6);
  else
    v8 = strlen((const char *)(*(_QWORD *)this + v6));
  if (v6 + (unint64_t)v8 + 1 > v5)
    return 0;
  v9 = v8 + 1 + v6;
  if (v5)
  {
    if (v9 > v5)
      return 0;
  }
  *((_QWORD *)this + 2) = v9;
  if (!v4)
    return 0;
  KB::String::String((KB::String *)v11, v7, (unsigned __int16)v8);
  KB::String::operator=((uint64_t)a2, (KB::String *)v11);
  if (v12)
  {
    if (v11[6] == 1)
      free(v12);
  }
  return 1;
}

uint64_t KB::InputStream::step(KB::InputStream *this, unsigned int a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  v4 = v2 + a2;
  if (v3)
    v5 = v4 > v3;
  else
    v5 = 0;
  if (v5)
    return 0;
  v6 = *(_QWORD *)this + v2;
  *((_QWORD *)this + 2) = v4;
  return v6;
}

uint64_t KB::InputStream::read_unsigned_int(KB::InputStream *this, unsigned int *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  v4 = v2 + 4;
  if (v3)
    v5 = v4 > v3;
  else
    v5 = 0;
  if (v5)
    return 0;
  v6 = *(_QWORD *)this;
  *((_QWORD *)this + 2) = v4;
  if (!v6)
    return 0;
  *a2 = bswap32(*(_DWORD *)(v6 + v2));
  return 1;
}

uint64_t KB::InputStream::read_uint24(KB::InputStream *this, unsigned int *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  v4 = v2 + 3;
  if (v3)
    v5 = v4 > v3;
  else
    v5 = 0;
  if (v5)
    return 0;
  v6 = *(_QWORD *)this;
  *((_QWORD *)this + 2) = v4;
  if (!v6)
    return 0;
  *a2 = (*(unsigned __int8 *)(v6 + v2) << 16) | (*(unsigned __int8 *)(v6 + v2 + 1) << 8) | *(unsigned __int8 *)(v6 + v2 + 2);
  return 1;
}

uint64_t KB::InputStream::read_data(KB::InputStream *this, void *__dst, size_t a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;

  v4 = *((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2);
  v5 = v3 + a3;
  if (v4)
    v6 = v5 > v4;
  else
    v6 = 0;
  if (v6)
    return 0;
  v7 = *(_QWORD *)this;
  *((_QWORD *)this + 2) = v5;
  if (!v7)
    return 0;
  memcpy(__dst, (const void *)(v7 + v3), a3);
  return 1;
}

uint64_t KB::InputStream::read_unsigned_short(KB::InputStream *this, unsigned __int16 *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  v4 = v2 + 2;
  if (v3)
    v5 = v4 > v3;
  else
    v5 = 0;
  if (v5)
    return 0;
  v6 = *(_QWORD *)this;
  *((_QWORD *)this + 2) = v4;
  if (!v6)
    return 0;
  *a2 = bswap32(*(unsigned __int16 *)(v6 + v2)) >> 16;
  return 1;
}

uint64_t KB::InputStream::read_short(KB::InputStream *this, __int16 *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  v4 = v2 + 2;
  if (v3)
    v5 = v4 > v3;
  else
    v5 = 0;
  if (v5)
    return 0;
  v6 = *(_QWORD *)this;
  *((_QWORD *)this + 2) = v4;
  if (!v6)
    return 0;
  *a2 = bswap32(*(unsigned __int16 *)(v6 + v2)) >> 16;
  return 1;
}

uint64_t KB::InputStream::read_unsigned_char(KB::InputStream *this, unsigned __int8 *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  v4 = v2 + 1;
  if (v3)
    v5 = v4 > v3;
  else
    v5 = 0;
  if (v5)
    return 0;
  v6 = *(_QWORD *)this;
  *((_QWORD *)this + 2) = v4;
  if (!v6)
    return 0;
  *a2 = *(_BYTE *)(v6 + v2);
  return 1;
}

uint64_t KB::InputStream::read_unsigned_int_compressed(KB::InputStream *this, unsigned int *a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  int v10;
  unint64_t v11;
  int v12;
  int v13;
  unint64_t v14;

  v2 = *((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2);
  v4 = v3 + 1;
  if (v2)
    v5 = v4 > v2;
  else
    v5 = 0;
  if (!v5)
  {
    v6 = *(_QWORD *)this;
    *((_QWORD *)this + 2) = v4;
    if (v6)
    {
      v7 = *(char *)(v6 + v3);
      v8 = *(unsigned __int8 *)(v6 + v3);
      *a2 = v8;
      if ((v7 & 0x80000000) == 0)
        return 1;
      v10 = (v8 & 0x7F) << 8;
      *a2 = v10;
      v11 = v3 + 2;
      if (!v2 || v11 <= v2)
      {
        *((_QWORD *)this + 2) = v11;
        v12 = v10 | *(unsigned __int8 *)(v6 + v4);
        *a2 = v12;
        if ((v8 & 0x40) == 0)
          return 1;
        v13 = (v12 & 0x3FFF) << 16;
        *a2 = v13;
        v14 = v3 + 4;
        if (!v2 || v14 <= v2)
        {
          *((_QWORD *)this + 2) = v14;
          *a2 = v13 | (bswap32(*(unsigned __int16 *)(v6 + v11)) >> 16);
          return 1;
        }
      }
    }
  }
  return 0;
}

uint64_t KB::InputStream::read_float(KB::InputStream *this, float *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  v4 = v2 + 4;
  if (v3)
    v5 = v4 > v3;
  else
    v5 = 0;
  if (v5)
    return 0;
  v6 = *(_QWORD *)this;
  *((_QWORD *)this + 2) = v4;
  if (!v6)
    return 0;
  *(_DWORD *)a2 = bswap32(*(_DWORD *)(v6 + v2));
  return 1;
}

uint64_t KB::InputStream::read_uversioninfo(KB::InputStream *this, unsigned __int8 (*a2)[4])
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  v4 = v2 + 4;
  if (v3)
    v5 = v4 > v3;
  else
    v5 = 0;
  if (v5)
    return 0;
  v6 = *(_QWORD *)this;
  *((_QWORD *)this + 2) = v4;
  if (!v6)
    return 0;
  *(_DWORD *)a2 = *(_DWORD *)(v6 + v2);
  return 1;
}

double KB::WritableDataFile::WritableDataFile(KB::WritableDataFile *this)
{
  double result;

  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = 0;
  result = NAN;
  *(_QWORD *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((_QWORD *)this + 3) = 0;
  return result;
}

{
  double result;

  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = 0;
  result = NAN;
  *(_QWORD *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((_QWORD *)this + 3) = 0;
  return result;
}

KB::DataFile *KB::WritableDataFile::WritableDataFile(KB::DataFile *a1, const char *a2, int a3)
{
  return KB::DataFile::DataFile(a1, a2, a3, 384);
}

{
  return KB::DataFile::DataFile(a1, a2, a3, 384);
}

void KB::WritableDataFile::write_data(KB::WritableDataFile *this, char *a2, uint64_t a3)
{
  int v6;
  ssize_t v7;
  NSObject *v8;
  uint64_t v9;
  int *v10;
  char *v11;
  int v12;
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 8))
  {
    v6 = 0;
    while (1)
    {
      v7 = write(*((_DWORD *)this + 4), &a2[v6], a3 - v6);
      if (!v7)
        break;
      v6 += v7;
      if (v7 < 0)
      {
        if (TICanLogMessageAtLevel_onceToken != -1)
          dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
        v8 = TIOSLogFacility();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = *((_QWORD *)this + 3);
          v10 = __error();
          v11 = strerror(*v10);
          v12 = 136315650;
          v13 = "write_data";
          v14 = 2082;
          v15 = v9;
          v16 = 2082;
          v17 = v11;
          _os_log_debug_impl(&dword_1DA6F2000, v8, OS_LOG_TYPE_DEBUG, "%s cannot write to file: %{public}s (%{public}s)", (uint8_t *)&v12, 0x20u);
        }
        *((_BYTE *)this + 8) = 0;
        return;
      }
    }
  }
}

void KB::WritableDataFile::write_string(KB::WritableDataFile *this, char *__s)
{
  size_t v4;
  char v5;

  v4 = strlen(__s);
  KB::WritableDataFile::write_data(this, __s, v4);
  v5 = 0;
  KB::WritableDataFile::write_data(this, &v5, 1);
}

void KB::WritableDataFile::write_unsigned_char(KB::WritableDataFile *this, char a2)
{
  char v2;

  v2 = a2;
  KB::WritableDataFile::write_data(this, &v2, 1);
}

void KB::WritableDataFile::write_string(KB::WritableDataFile *this, const KB::String *a2)
{
  uint64_t v3;
  char *v4;
  char *v5;
  char v6;

  v3 = *(unsigned __int16 *)a2;
  v4 = (char *)*((_QWORD *)a2 + 1);
  if (!v4)
    v4 = (char *)a2 + 16;
  if (*(_WORD *)a2)
    v5 = v4;
  else
    v5 = "";
  KB::WritableDataFile::write_data(this, v5, v3);
  v6 = 0;
  KB::WritableDataFile::write_data(this, &v6, 1);
}

void KB::WritableDataFile::write_unsigned_int(KB::WritableDataFile *this, unsigned int a2)
{
  unsigned int v2;

  v2 = bswap32(a2);
  KB::WritableDataFile::write_data(this, (char *)&v2, 4);
}

void KB::WritableDataFile::write_uint24(KB::WritableDataFile *this, int a2)
{
  char v2[3];

  v2[0] = BYTE2(a2);
  v2[1] = BYTE1(a2);
  v2[2] = a2;
  KB::WritableDataFile::write_data(this, v2, 3);
}

void KB::WritableDataFile::write_unsigned_float(KB::WritableDataFile *this, float a2)
{
  unsigned int v2;

  v2 = bswap32(LODWORD(a2));
  KB::WritableDataFile::write_data(this, (char *)&v2, 4);
}

void KB::WritableDataFile::write_unsigned_short(KB::WritableDataFile *this, unsigned int a2)
{
  __int16 v2;

  v2 = __rev16(a2);
  KB::WritableDataFile::write_data(this, (char *)&v2, 2);
}

uint64_t KB::WritableDataFile::size_of_unsigned_int_compressed(KB::WritableDataFile *this)
{
  unsigned int v1;

  if (this >= 0x3FFF)
    v1 = 4;
  else
    v1 = 2;
  if (this < 0x7F)
    return 1;
  else
    return v1;
}

void KB::WritableDataFile::write_unsigned_int_compressed(KB::WritableDataFile *this, unsigned int a2)
{
  KB::WritableDataFile *v3;
  char *v4;
  uint64_t v5;
  char v6;
  char v7;
  char v8;
  char v9;
  char v10;
  __int16 v11;
  int v12;

  v3 = this;
  if (a2 <= 0x7E)
  {
    v6 = a2;
    v4 = &v6;
LABEL_5:
    this = v3;
    v5 = 1;
    goto LABEL_6;
  }
  if (a2 <= 0x3FFE)
  {
    v7 = BYTE1(a2) | 0x80;
    KB::WritableDataFile::write_data(this, &v7, 1);
    v8 = a2;
    v4 = &v8;
    goto LABEL_5;
  }
  if (a2 > 0x3FFFFFFE)
  {
    v12 = -1;
    v4 = (char *)&v12;
    v5 = 4;
  }
  else
  {
    v9 = HIBYTE(a2) | 0xC0;
    KB::WritableDataFile::write_data(this, &v9, 1);
    v10 = BYTE2(a2);
    KB::WritableDataFile::write_data(v3, &v10, 1);
    v11 = bswap32(a2) >> 16;
    v4 = (char *)&v11;
    this = v3;
    v5 = 2;
  }
LABEL_6:
  KB::WritableDataFile::write_data(this, v4, v5);
}

off_t KB::WritableDataFile::tell(KB::WritableDataFile *this)
{
  return lseek(*((_DWORD *)this + 4), 0, 1);
}

off_t KB::WritableDataFile::seek(KB::WritableDataFile *this)
{
  return lseek(*((_DWORD *)this + 4), 0, 1);
}

off_t KB::WritableDataFile::seek_to_end(KB::WritableDataFile *this)
{
  return lseek(*((_DWORD *)this + 4), 0, 2);
}

void UnikeySetInputMethod(unsigned int a1)
{
  uint64_t v1;
  _DWORD *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a1 < 3)
  {
LABEL_4:
    v1 = pShMem;
    *(_DWORD *)(pShMem + 48) = a1;
    v2 = (_DWORD *)(v1 + 48);
    if (a1 >= 4)
    {
      *v2 = 0;
      v3 = "Z";
    }
    else
    {
      v3 = (&off_1EA0FEF08)[a1];
    }
    UkInputProcessor::useBuiltIn((uint64_t)v2, v3);
    goto LABEL_8;
  }
  if (a1 != 4)
  {
    if (a1 != 5)
      return;
    goto LABEL_4;
  }
  v5 = pShMem;
  if (*(_DWORD *)(pShMem + 1076))
  {
    v6 = 0;
    *(_DWORD *)(pShMem + 48) = 4;
    do
    {
      *(_OWORD *)(v5 + v6 + 52) = *(_OWORD *)(v5 + v6 + 1080);
      v6 += 16;
    }
    while (v6 != 1024);
LABEL_8:
    v4 = MyKbEngine;
    *(_DWORD *)(MyKbEngine + 3112) = -1;
    *(_QWORD *)(v4 + 28) = 0xFFFFFFFFLL;
    *(_BYTE *)(v4 + 3116) = 0;
  }
}

uint64_t UnikeySetCapsState(uint64_t result, int a2)
{
  UnikeyCapsLockOn = a2;
  UnikeyShiftPressed = result;
  return result;
}

uint64_t UnikeySetOutputCharset(int a1)
{
  uint64_t v1;

  *(_DWORD *)(pShMem + 2104) = a1;
  v1 = MyKbEngine;
  *(_DWORD *)(MyKbEngine + 3112) = -1;
  *(_QWORD *)(v1 + 28) = 0xFFFFFFFFLL;
  *(_BYTE *)(v1 + 3116) = 0;
  return 1;
}

double UnikeySetOptions(uint64_t a1)
{
  uint64_t v1;
  double result;

  v1 = pShMem;
  *(_OWORD *)(pShMem + 12) = *(_OWORD *)a1;
  *(_DWORD *)(v1 + 28) = *(_DWORD *)(a1 + 16);
  result = *(double *)(a1 + 28);
  *(double *)(v1 + 40) = result;
  return result;
}

__n128 UnikeyGetOptions(uint64_t a1)
{
  int v1;
  __n128 result;

  v1 = *(_DWORD *)(pShMem + 44);
  result = *(__n128 *)(pShMem + 28);
  *(_OWORD *)a1 = *(_OWORD *)(pShMem + 12);
  *(__n128 *)(a1 + 16) = result;
  *(_DWORD *)(a1 + 32) = v1;
  return result;
}

double CreateDefaultUnikeyOptions(uint64_t a1)
{
  double result;

  *(_DWORD *)a1 = 1;
  *(_QWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 4) = 0;
  *(_QWORD *)&result = 1;
  *(_QWORD *)(a1 + 28) = 1;
  return result;
}

double UnikeySetup()
{
  UkEngine *v0;
  uint64_t v1;
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double result;

  if (!MyKbEngine)
  {
    v0 = (UkEngine *)operator new();
    UkEngine::UkEngine(v0);
    MyKbEngine = v1;
  }
  SetupUnikeyEngine();
  pShMem = operator new();
  UkInputProcessor::init((UkInputProcessor *)(pShMem + 48));
  v2 = (_DWORD *)pShMem;
  *(_QWORD *)(pShMem + 141372) = 0x2000000000000;
  v2[35345] = 0;
  v2[1] = 1;
  v2[269] = 0;
  v3 = MyKbEngine;
  *(_QWORD *)MyKbEngine = UnikeyCheckKbCase;
  *(_QWORD *)(v3 + 8) = v2;
  v4 = pShMem;
  *(_DWORD *)(pShMem + 48) = 0;
  UkInputProcessor::useBuiltIn(v4 + 48, "Z");
  v5 = MyKbEngine;
  v6 = pShMem;
  *(_DWORD *)(pShMem + 2104) = 12;
  *(_DWORD *)(v5 + 3112) = -1;
  *(_QWORD *)(v5 + 28) = 0xFFFFFFFFLL;
  *(_BYTE *)(v5 + 3116) = 0;
  *(_DWORD *)v6 = 1;
  *(_DWORD *)(v6 + 12) = 1;
  *(_QWORD *)(v6 + 16) = 0;
  *(_QWORD *)(v6 + 24) = 0;
  *(_QWORD *)&result = 1;
  *(_QWORD *)(v6 + 40) = 1;
  return result;
}

_DWORD *UnikeyCheckKbCase(_DWORD *result, int *a2)
{
  *result = UnikeyShiftPressed;
  *a2 = UnikeyCapsLockOn;
  return result;
}

uint64_t UnikeyCleanup()
{
  uint64_t result;

  if (MyKbEngine)
    MEMORY[0x1DF0A2144](MyKbEngine, 0x10B0C407BB03D36);
  result = pShMem;
  if (pShMem)
    result = MEMORY[0x1DF0A2144](pShMem, 0x1000C401C44D41ELL);
  MyKbEngine = 0;
  pShMem = 0;
  return result;
}

uint64_t UnikeyFilter(unsigned int a1)
{
  UnikeyBufChars = 1024;
  return UkEngine::process(MyKbEngine, a1, &UnikeyBackspaces, UnikeyBuf, &UnikeyBufChars, &UnikeyOutput);
}

uint64_t UnikeyPutChar(unsigned int a1)
{
  UkEngine *v1;
  uint64_t result;
  _DWORD v3[5];

  v1 = (UkEngine *)MyKbEngine;
  UkInputProcessor::keyCodeToEvent(*(_QWORD *)(MyKbEngine + 8) + 48, a1, v3);
  result = UkEngine::processAppend(v1, v3);
  UnikeyBufChars = 0;
  UnikeyBackspaces = 0;
  return result;
}

double UnikeyResetBuf()
{
  uint64_t v0;
  double result;

  v0 = MyKbEngine;
  *(_DWORD *)(MyKbEngine + 3112) = -1;
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  *(_QWORD *)(v0 + 28) = 0xFFFFFFFFLL;
  *(_BYTE *)(v0 + 3116) = 0;
  return result;
}

void UnikeySetSingleMode()
{
  *(_DWORD *)(MyKbEngine + 32) = 1;
}

BOOL UnikeyBackspacePress()
{
  UnikeyBufChars = 1024;
  return UkEngine::processBackspace((UkEngine *)MyKbEngine, &UnikeyBackspaces, UnikeyBuf, &UnikeyBufChars, &UnikeyOutput);
}

uint64_t UnikeyRestoreKeyStrokes()
{
  UnikeyBufChars = 1024;
  return UkEngine::restoreKeyStrokes(MyKbEngine, &UnikeyBackspaces, (uint64_t)UnikeyBuf, &UnikeyBufChars, &UnikeyOutput);
}

id rangesOfStringInString(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  void *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;

  v7 = a1;
  v8 = a2;
  v9 = a4;
  if (objc_msgSend(v8, "length"))
  {
    v10 = (void *)objc_opt_new();
    v11 = objc_msgSend(v8, "length");
    v12 = 0;
    v13 = v11;
    do
    {
      v14 = objc_msgSend(v8, "rangeOfString:options:range:locale:", v7, a3, v12, v13, v9);
      if (!v15)
        break;
      v16 = v14;
      v17 = v15;
      objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithRange:", v14, v15);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v10, "addObject:", v18);

      v12 = v16 + v17;
      v13 = v11 - (v16 + v17);
    }
    while (v11 > v16 + v17);
  }
  else
  {
    v10 = (void *)MEMORY[0x1E0C9AA60];
  }

  return v10;
}

id TICreateNamedEntityStore(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint8_t v40[128];
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  void *v44;
  _BYTE v45[128];
  _BYTE v46[128];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  objc_msgSend(a2, "items");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", objc_msgSend(v4, "count"));
  v36 = 0u;
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  v6 = v4;
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v36, v46, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v37;
    do
    {
      v10 = 0;
      do
      {
        if (*(_QWORD *)v37 != v9)
          objc_enumerationMutation(v6);
        objc_msgSend(*(id *)(*((_QWORD *)&v36 + 1) + 8 * v10++), "core_appendEntitiesToArray:", v5);
      }
      while (v8 != v10);
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v36, v46, 16);
    }
    while (v8);
  }

  objc_msgSend(MEMORY[0x1E0DBDBA8], "sharedInputModeController");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "enabledInputModeIdentifiers");
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x1E0C99E20], "set");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  v14 = v12;
  v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v32, v45, 16);
  if (v15)
  {
    v16 = v15;
    v17 = *(_QWORD *)v33;
    do
    {
      v18 = 0;
      do
      {
        if (*(_QWORD *)v33 != v17)
          objc_enumerationMutation(v14);
        TIInputModeGetLanguageWithRegion();
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        if (v19)
          objc_msgSend(v13, "addObject:", v19);

        ++v18;
      }
      while (v16 != v18);
      v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v32, v45, 16);
    }
    while (v16);
  }

  v20 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0D3AB88]), "initWithName:", v3);
  objc_msgSend(v20, "setMinimumWordLength:", 1);
  if ((objc_opt_respondsToSelector() & 1) != 0)
    objc_msgSend(v20, "setTreatHyphenatedWordAsPhrase:", 1);
  v21 = (void *)objc_msgSend(v13, "copy");
  objc_msgSend(v20, "setAcceptedLanguages:", v21);

  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    v42 = "TICreateNamedEntityStore";
    v43 = 2112;
    v44 = v13;
    _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  Setting the accepted languages as : %@", buf, 0x16u);
  }
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v22 = v5;
  v23 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v28, v40, 16);
  if (v23)
  {
    v24 = v23;
    v25 = *(_QWORD *)v29;
    do
    {
      v26 = 0;
      do
      {
        if (*(_QWORD *)v29 != v25)
          objc_enumerationMutation(v22);
        objc_msgSend(v20, "addEntity:isDurable:", *(_QWORD *)(*((_QWORD *)&v28 + 1) + 8 * v26++), 1, (_QWORD)v28);
      }
      while (v24 != v26);
      v24 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v28, v40, 16);
    }
    while (v24);
  }

  return v20;
}

uint64_t __Block_byref_object_copy__1898(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__1899(uint64_t a1)
{

}

void TIOSLogLines(const __CFString *a1)
{
  const __CFLocale *v2;
  const __CFAllocator *v3;
  __CFStringTokenizer *v4;
  NSObject *v5;
  CFStringRef v6;
  CFStringTokenizerTokenType Token;
  uint8_t buf[4];
  CFStringRef v9;
  uint64_t v10;
  CFRange v11;
  CFRange CurrentTokenRange;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = CFLocaleCopyCurrent();
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v11.length = CFStringGetLength(a1);
  v11.location = 0;
  v4 = CFStringTokenizerCreate(v3, a1, v11, 2uLL, v2);
  if (CFStringTokenizerAdvanceToNextToken(v4))
  {
    v5 = MEMORY[0x1E0C81028];
    do
    {
      CurrentTokenRange = CFStringTokenizerGetCurrentTokenRange(v4);
      v6 = CFStringCreateWithSubstring(v3, a1, CurrentTokenRange);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v9 = v6;
        _os_log_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
      }
      Token = CFStringTokenizerAdvanceToNextToken(v4);
      if (v6)
        CFRelease(v6);
    }
    while (Token);
  }
  if (v4)
    CFRelease(v4);
  if (v2)
    CFRelease(v2);
}

void createTapToRadarDraft(uint64_t a1, uint64_t a2)
{
  id v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  uint64_t v10;
  id v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  getTapToRadarServiceClass();
  if (objc_opt_class())
  {
    v4 = objc_alloc_init((Class)getRadarDraftClass());
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("TextInput fault: %@"), a1);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "setTitle:", v5);

    v6 = (void *)objc_msgSend(objc_alloc((Class)getRadarComponentClass()), "initWithName:version:identifier:", CFSTR("TextInput"), CFSTR("All"), 1139080);
    objc_msgSend(v4, "setComponent:", v6);

    objc_msgSend(v4, "setClassification:", 2);
    objc_msgSend(v4, "setReproducibility:", 5);
    if (a2)
      objc_msgSend(v4, "setProblemDescription:", a2);
    objc_msgSend((id)getTapToRadarServiceClass(), "shared");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = 0;
    objc_msgSend(v7, "createDraft:forProcessNamed:withDisplayReason:error:", v4, CFSTR("Keyboard"), a1, &v11);
    v8 = v11;

    if (v8)
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Tap-to-Radar Error: %@"), v8);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        v10 = objc_msgSend(objc_retainAutorelease(v9), "cStringUsingEncoding:", 4);
        *(_DWORD *)buf = 136315394;
        v13 = "createTapToRadarDraft";
        v14 = 2080;
        v15 = v10;
        _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  Tap-to-radar error %s", buf, 0x16u);
      }

    }
  }
}

Class initTapToRadarService(void)
{
  Class result;

  if (TapToRadarKitLibrary(void)::sOnce != -1)
    dispatch_once(&TapToRadarKitLibrary(void)::sOnce, &__block_literal_global_2011);
  result = objc_getClass("TapToRadarService");
  classTapToRadarService = (uint64_t)result;
  getTapToRadarServiceClass = (uint64_t (*)(void))TapToRadarServiceFunction;
  return result;
}

id TapToRadarServiceFunction(void)
{
  return (id)classTapToRadarService;
}

Class initRadarDraft(void)
{
  Class result;

  if (TapToRadarKitLibrary(void)::sOnce != -1)
    dispatch_once(&TapToRadarKitLibrary(void)::sOnce, &__block_literal_global_2011);
  result = objc_getClass("RadarDraft");
  classRadarDraft = (uint64_t)result;
  getRadarDraftClass = (uint64_t (*)(void))RadarDraftFunction;
  return result;
}

id RadarDraftFunction(void)
{
  return (id)classRadarDraft;
}

Class initRadarComponent(void)
{
  Class result;

  if (TapToRadarKitLibrary(void)::sOnce != -1)
    dispatch_once(&TapToRadarKitLibrary(void)::sOnce, &__block_literal_global_2011);
  result = objc_getClass("RadarComponent");
  classRadarComponent = (uint64_t)result;
  getRadarComponentClass = (uint64_t (*)(void))RadarComponentFunction;
  return result;
}

id RadarComponentFunction(void)
{
  return (id)classRadarComponent;
}

void ___typologyProfileOptInManager_block_invoke()
{
  TITypologyProfileOptInManager *v0;
  void *v1;

  v0 = objc_alloc_init(TITypologyProfileOptInManager);
  v1 = (void *)_typologyProfileOptInManager_optInManager;
  _typologyProfileOptInManager_optInManager = (uint64_t)v0;

}

KB::DictionaryCursors *KB::DictionaryCursors::DictionaryCursors(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2)
{
  const KB::StaticDictionary *v4;
  unsigned int v5;

  v4 = (const KB::StaticDictionary *)*((_QWORD *)a2 + 1);
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 0;
  KB::StaticDictionaryCursor::reset(this, v4);
  (*(void (**)(_QWORD))(**((_QWORD **)a2 + 3) + 16))(*((_QWORD *)a2 + 3));
  v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 3) + 72))(*((_QWORD *)a2 + 3), 0xFFFFFFFFLL);
  *((_DWORD *)this + 16) = v5;
  *((float *)this + 17) = 65536.0 / (float)((float)v5 + 65536.0);
  *((_DWORD *)this + 18) = 0;
  return this;
}

float KB::DictionaryCursors::prior_probability_of_static_trie(KB::DictionaryCursors *this, unsigned int a2)
{
  return 65536.0 / (float)((float)a2 + 65536.0);
}

uint64_t KB::DictionaryCursors::DictionaryCursors(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t i;
  const void *v7;
  __int128 v8;

  for (i = 0; i != 24; i += 8)
  {
    v7 = *(const void **)(a2 + i);
    *(_QWORD *)(a1 + i) = v7;
    if (v7)
    {
      CFRetain(v7);
      *(_QWORD *)(a1 + i) = v7;
    }
  }
  v8 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
  *(_OWORD *)(a1 + 24) = v8;
  (**(void (***)(_QWORD))*a3)(*a3);
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 48);
  return a1;
}

uint64_t KB::DictionaryCursors::DictionaryCursors(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t i;
  const void *v7;
  __int128 v8;
  uint64_t v9;

  for (i = 0; i != 24; i += 8)
  {
    v7 = *(const void **)(a2 + i);
    *(_QWORD *)(a1 + i) = v7;
    if (v7)
    {
      CFRetain(v7);
      *(_QWORD *)(a1 + i) = v7;
    }
  }
  v8 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
  *(_OWORD *)(a1 + 24) = v8;
  v9 = *a3;
  *a3 = 0;
  *(_QWORD *)(a1 + 56) = v9;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 48);
  return a1;
}

KB::DictionaryCursors *KB::DictionaryCursors::DictionaryCursors(KB::DictionaryCursors *this, const KB::DictionaryCursors *a2)
{
  uint64_t i;
  const void *v5;
  __int128 v6;

  for (i = 0; i != 24; i += 8)
  {
    v5 = *(const void **)((char *)a2 + i);
    *(_QWORD *)((char *)this + i) = v5;
    if (v5)
    {
      CFRetain(v5);
      *(_QWORD *)((char *)this + i) = v5;
    }
  }
  v6 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 36) = *(_OWORD *)((char *)a2 + 36);
  *(_OWORD *)((char *)this + 24) = v6;
  (***((void (****)(_QWORD))a2 + 7))(*((_QWORD *)a2 + 7));
  *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
  *((_DWORD *)this + 17) = *((_DWORD *)a2 + 17);
  *((_DWORD *)this + 18) = *((_DWORD *)a2 + 18);
  return this;
}

uint64_t KB::DictionaryCursors::DictionaryCursors(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  const void *v5;
  __int128 v6;
  uint64_t v7;

  for (i = 0; i != 24; i += 8)
  {
    v5 = *(const void **)(a2 + i);
    *(_QWORD *)(a1 + i) = v5;
    if (v5)
    {
      CFRetain(v5);
      *(_QWORD *)(a1 + i) = v5;
    }
  }
  v6 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
  *(_OWORD *)(a1 + 24) = v6;
  v7 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a1 + 56) = v7;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  return a1;
}

uint64_t KB::DictionaryCursors::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  if (a1 != a2)
  {
    v4 = 0;
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
    do
    {
      KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(a1 + v4), *(CFTypeRef *)(a2 + v4));
      v4 += 8;
    }
    while (v4 != 24);
    v5 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
    *(_OWORD *)(a1 + 24) = v5;
    (***(void (****)(uint64_t *__return_ptr))(a2 + 56))(&v10);
    v6 = v10;
    v10 = 0;
    v7 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 56) = v6;
    if (v7)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
      v8 = v10;
      v10 = 0;
      if (v8)
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
    }
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  }
  return a1;
}

{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;

  if (a1 != a2)
  {
    v4 = 0;
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
    do
    {
      KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(a1 + v4), *(CFTypeRef *)(a2 + v4));
      v4 += 8;
    }
    while (v4 != 24);
    v5 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
    *(_OWORD *)(a1 + 24) = v5;
    v6 = *(_QWORD *)(a2 + 56);
    *(_QWORD *)(a2 + 56) = 0;
    v7 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 56) = v6;
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  }
  return a1;
}

uint64_t KB::DictionaryCursors::clear_dynamic_cursors(KB::DictionaryCursors *this)
{
  return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 7) + 48))(*((_QWORD *)this + 7), &__block_literal_global_15828);
}

uint64_t KB::DictionaryCursors::finishes_dynamic_words(KB::DynamicDictionaryCursor **this)
{
  return KB::DynamicDictionaryCursor::has_entries(this[7]);
}

uint64_t KB::DictionaryCursors::dynamic_has_children(KB::DynamicDictionaryCursor **this)
{
  return KB::DynamicDictionaryCursor::has_children(this[7]);
}

void KB::DictionaryCursors::probability_of_static_trie(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2)
{
  KB::StaticDictionaryCursor::conditional_probability(this);
  if (*((_DWORD *)this + 16))
    (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 7) + 80))(*((_QWORD *)this + 7), *((_QWORD *)a2 + 3));
}

float KB::DictionaryCursors::dynamic_partial_probability(KB::DictionaryCursors *this, const DictionaryContainer *a2)
{
  if (*((_DWORD *)this + 16))
    return (float)(*(unsigned int (**)(_QWORD, _QWORD))(**((_QWORD **)this + 7) + 80))(*((_QWORD *)this + 7), *((_QWORD *)a2 + 3))/ (float)*((unsigned int *)this + 16);
  else
    return 0.0;
}

void KB::DictionaryCursors::probability_of_static_trie_given_termination(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2)
{
  KB::DictionaryCursors::probability_of_static_trie(this, a2);
  KB::StaticDictionaryCursor::termination_probability(this);
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 7) + 72))(*((_QWORD *)this + 7), *((_QWORD *)a2 + 3));
}

uint64_t KB::DictionaryCursors::dynamic_termination_probability(KB::DictionaryCursors *this, const DictionaryContainer *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 7) + 72))(*((_QWORD *)this + 7), *((_QWORD *)a2 + 3));
}

uint64_t KB::DictionaryCursors::dynamic_subtree_usage_count(KB::DictionaryCursors *this, const DictionaryContainer *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 7) + 80))(*((_QWORD *)this + 7), *((_QWORD *)a2 + 3));
}

float KB::DictionaryCursors::termination_probability(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2)
{
  float v4;
  float v5;
  float v6;

  KB::DictionaryCursors::probability_of_static_trie(this, a2);
  v5 = v4;
  v6 = KB::StaticDictionaryCursor::termination_probability(this);
  return (float)((float)(1.0 - v5)
               * (*(float (**)(_QWORD, _QWORD))(**((_QWORD **)this + 7) + 72))(*((_QWORD *)this + 7), *((_QWORD *)a2 + 3)))+ (float)(v5 * v6);
}

uint64_t KB::DictionaryCursors::for_each_dynamic_trie_node(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56));
}

uint64_t KB::DictionaryCursors::dynamic_entry_count(KB::DictionaryCursors *this, const DictionaryContainer *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 7) + 88))(*((_QWORD *)this + 7), *((_QWORD *)a2 + 3));
}

float KB::DictionaryCursors::advance(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2, const KB::String *a3)
{
  char *v5;
  int v6;
  int v7;
  int v8;
  float v9;
  char *v11;
  int v12;
  int v13;
  int v14;
  char *v15;
  int v16;
  int v17;
  unsigned int v18;

  if (*((_QWORD *)a3 + 1))
    v5 = (char *)*((_QWORD *)a3 + 1);
  else
    v5 = (char *)a3 + 16;
  v15 = v5;
  v6 = *(unsigned __int16 *)a3;
  v16 = 0;
  v17 = v6;
  v18 = 0;
  KB::String::iterator::initialize((uint64_t *)&v15);
  v11 = v5;
  v12 = v6;
  v13 = v6;
  v14 = 0;
  KB::String::iterator::initialize((uint64_t *)&v11);
  v7 = v16;
  v8 = v12;
  v9 = 1.0;
  while (v7 != v8)
  {
    v9 = v9 * KB::DictionaryCursors::advance(this, a2, v18);
    KB::String::iterator::operator++((uint64_t *)&v15);
    v7 = v16;
  }
  return v9;
}

float KB::DictionaryCursors::advance(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2, unsigned int a3)
{
  int IsRoot;
  uint64_t v7;
  uint64_t v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  _BYTE v18[8];
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  IsRoot = LXCursorIsRoot();
  v7 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 3) + 72))(*((_QWORD *)a2 + 3), 0xFFFFFFFFLL);
  if (IsRoot)
  {
    v8 = v7;
    v9 = 65536.0 / (float)((float)v7 + 65536.0);
  }
  else
  {
    v8 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 7) + 80))(*((_QWORD *)this + 7), *((_QWORD *)a2 + 3));
    KB::DictionaryCursors::probability_of_static_trie(this, a2);
    v9 = v10;
  }
  v11 = KB::StaticDictionaryCursor::advance(this, a3);
  v12 = *((_QWORD *)this + 7);
  v13 = *((_QWORD *)a2 + 3);
  KB::String::String((uint64_t)v18, a3);
  v14 = (*(float (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)v12 + 56))(v12, v13, v18, v8);
  if (v19 && v18[6] == 1)
    free(v19);
  if ((KB::StaticDictionaryCursor::valid(this) & 1) == 0
    && !KB::DynamicDictionaryCursor::valid(*((KB::DynamicDictionaryCursor **)this + 7)))
  {
    a3 = 0;
  }
  v15 = 1.0;
  if (IsRoot)
    v15 = 1.0 / v9;
  *((_DWORD *)this + 18) = a3;
  *((float *)this + 17) = v9;
  *((_DWORD *)this + 16) = v8;
  v16 = (1.0 - v9) * v14;
  return v15 * (float)((float)(v9 * v11) + v16);
}

void KB::DictionaryCursors::fill_vector_with_static_trie_children(KB::StaticDictionaryCursor *this, uint64_t *a2, uint64_t a3)
{
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void **v26;
  char *v27;
  char *v28;
  void **v29;
  uint64_t *v30;

  v7 = *a2;
  for (i = a2[1]; i != v7; std::__destroy_at[abi:nn180100]<KB::DictionaryCursors,0>(i))
    i -= 80;
  a2[1] = v7;
  KB::StaticDictionaryCursor::children(this, &v24);
  v8 = v24;
  v9 = v25;
  v10 = 0x6DB6DB6DB6DB6DB7 * ((v25 - v24) >> 3);
  if (0xCCCCCCCCCCCCCCCDLL * ((a2[2] - *a2) >> 4) < v10)
  {
    if (v10 > 0x333333333333333)
LABEL_24:
      abort();
    v11 = a2[1] - *a2;
    v30 = a2 + 2;
    v26 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::DictionaryCursors>>(v10);
    v27 = (char *)v26 + v11;
    v28 = (char *)v26 + v11;
    v29 = &v26[10 * v12];
    std::vector<KB::DictionaryCursors>::__swap_out_circular_buffer(a2, &v26);
    std::__split_buffer<KB::DictionaryCursors>::~__split_buffer((uint64_t)&v26);
  }
  for (; v8 != v9; v8 += 56)
  {
    (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a3 + 24) + 24))(&v23);
    v13 = a2[1];
    v14 = a2[2];
    if (v13 >= v14)
    {
      v16 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v13 - *a2) >> 4);
      v17 = v16 + 1;
      if (v16 + 1 > 0x333333333333333)
        goto LABEL_24;
      v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - *a2) >> 4);
      if (2 * v18 > v17)
        v17 = 2 * v18;
      if (v18 >= 0x199999999999999)
        v19 = 0x333333333333333;
      else
        v19 = v17;
      v30 = a2 + 2;
      if (v19)
        v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::DictionaryCursors>>(v19);
      else
        v20 = 0;
      v21 = v19 + 80 * v16;
      v26 = (void **)v19;
      v27 = (char *)v21;
      v29 = (void **)(v19 + 80 * v20);
      KB::DictionaryCursors::DictionaryCursors(v21, v8, &v23);
      v28 = (char *)(v21 + 80);
      std::vector<KB::DictionaryCursors>::__swap_out_circular_buffer(a2, &v26);
      v15 = a2[1];
      std::__split_buffer<KB::DictionaryCursors>::~__split_buffer((uint64_t)&v26);
    }
    else
    {
      v15 = KB::DictionaryCursors::DictionaryCursors(v13, v8, &v23) + 80;
    }
    a2[1] = v15;
    v22 = v23;
    v23 = 0;
    if (v22)
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 16))(v22);
  }
  v26 = (void **)&v24;
  std::vector<KB::StaticDictionaryCursor>::__destroy_vector::operator()[abi:nn180100](&v26);
}

void std::__destroy_at[abi:nn180100]<KB::DictionaryCursors,0>(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  for (i = 16; i != -8; i -= 8)
  {
    v4 = *(const void **)(a1 + i);
    if (v4)
      CFRelease(v4);
    *(_QWORD *)(a1 + i) = 0;
  }
}

void std::vector<KB::StaticDictionaryCursor>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  uint64_t i;
  const void *v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4;
        v4 -= 56;
        for (i = -40; i != -64; i -= 8)
        {
          v8 = *(const void **)&v6[i];
          if (v8)
            CFRelease(v8);
          *(_QWORD *)&v6[i] = 0;
        }
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::DictionaryCursors>>(unint64_t a1)
{
  if (a1 >= 0x333333333333334)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(80 * a1);
}

uint64_t std::vector<KB::DictionaryCursors>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 80;
    result = KB::DictionaryCursors::DictionaryCursors(result - 80, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<KB::DictionaryCursors>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 80;
    std::__destroy_at[abi:nn180100]<KB::DictionaryCursors,0>(i - 80);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void KB::DictionaryCursors::derive_static_words(KB::StaticDictionaryCursor *this, uint64_t a2)
{
  KB::StaticDictionaryCursor::derive_words(this, a2);
}

void KB::DictionaryCursors::merge_dynamic_children_with_static_siblings(KB::DictionaryCursors *a1, _QWORD *a2, const KB::DictionaryContainer *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  _DWORD *v13;
  unsigned int v14;
  _QWORD v16[7];

  v6 = *((_QWORD *)a1 + 7);
  v7 = *((_QWORD *)a3 + 1);
  v8 = *((_QWORD *)a3 + 3);
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = ___ZNK2KB23DynamicDictionaryCursor35merge_children_with_static_siblingsERNSt3__16vectorINS_17DictionaryCursorsENS1_9allocatorIS3_EEEERKNS_16StaticDictionaryERKNS_17DynamicDictionaryE_block_invoke;
  v16[3] = &__block_descriptor_tmp_9_15842;
  v16[4] = a2;
  v16[5] = v7;
  v16[6] = v8;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 40))(v6, v16);
  v9 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)a1 + 7) + 80))(*((_QWORD *)a1 + 7), *((_QWORD *)a3 + 3));
  KB::DictionaryCursors::probability_of_static_trie(a1, a3);
  v11 = a2[1] - *a2;
  if (v11)
  {
    v12 = 0xCCCCCCCCCCCCCCCDLL * (v11 >> 4);
    v13 = (_DWORD *)(*a2 + 68);
    v14 = 1;
    do
    {
      *(v13 - 1) = v9;
      *v13 = v10;
      v13 += 20;
    }
    while (v12 > v14++);
  }
}

void KB::DynamicDictionaryContainer::~DynamicDictionaryContainer(KB::DynamicDictionaryContainer *this)
{
  KB::DynamicDictionaryContainer::~DynamicDictionaryContainer(this);
  JUMPOUT(0x1DF0A2144);
}

{
  uint64_t v2;
  uint64_t i;
  void *v4;
  void *v5;
  void *v6;
  void **v7;

  *(_QWORD *)this = &off_1EA0FB258;
  if (*((_QWORD *)this + 27))
  {
    std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::__deallocate_node(*((_QWORD **)this + 26));
    *((_QWORD *)this + 26) = 0;
    v2 = *((_QWORD *)this + 25);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*((_QWORD *)this + 24) + 8 * i) = 0;
    }
    *((_QWORD *)this + 27) = 0;
  }
  std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::__deallocate_node(*((_QWORD **)this + 26));
  v4 = (void *)*((_QWORD *)this + 24);
  *((_QWORD *)this + 24) = 0;
  if (v4)
    operator delete(v4);
  v5 = (void *)*((_QWORD *)this + 21);
  if (v5)
  {
    *((_QWORD *)this + 22) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 18);
  if (v6 && *((_BYTE *)this + 142) == 1)
    free(v6);
  v7 = (void **)((char *)this + 112);
  std::vector<KB::retain_ptr<_LXLexicon const*>>::__destroy_vector::operator()[abi:nn180100](&v7);
  v7 = (void **)((char *)this + 88);
  std::vector<KB::LexiconInfo>::__destroy_vector::operator()[abi:nn180100](&v7);
  KB::DynamicDictionary::~DynamicDictionary(this);
}

void KB::DynamicDictionaryContainer::do_create_root_cursor(KB::DynamicDictionaryContainer *this@<X0>, KB::DynamicDictionaryContainerCursor **a2@<X8>)
{
  KB::DynamicDictionaryContainerCursor::create_root_cursor(this, a2);
}

KB::DynamicDictionaryContainerCursor *KB::DynamicDictionaryContainer::do_create_invalid_cursor@<X0>(KB::DynamicDictionaryContainer *this@<X0>, KB::DynamicDictionaryContainerCursor **a2@<X8>)
{
  KB::DynamicDictionaryContainerCursor *v4;
  KB::DynamicDictionaryContainerCursor *result;

  v4 = (KB::DynamicDictionaryContainerCursor *)operator new();
  result = KB::DynamicDictionaryContainerCursor::DynamicDictionaryContainerCursor(v4, this);
  *a2 = result;
  return result;
}

uint64_t KB::DynamicDictionaryContainer::do_load(uint64_t a1, unsigned __int16 **a2, int a3)
{
  unint64_t v3;
  KB::String **v5;
  const char *v7;
  CFStringRef v8;
  const void *View;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  int64x2_t v24;
  char *v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  const __CFString *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  _DWORD *v37;
  char *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  BOOL v42;
  unint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  KB::String *v49;
  unsigned int v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint8x8_t v54;
  unint64_t v55;
  _QWORD **v56;
  _QWORD *i;
  unint64_t v58;
  float v59;
  float v60;
  _BOOL8 v61;
  unint64_t v62;
  unint64_t v63;
  int8x8_t prime;
  void *v65;
  void *v66;
  uint64_t v67;
  _QWORD *v68;
  unint64_t v69;
  uint8x8_t v70;
  unint64_t v71;
  uint8x8_t v72;
  uint64_t v73;
  const void *v74;
  _QWORD *v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _QWORD *v79;
  unint64_t v80;
  void *v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD *v84;
  uint64_t *v85;
  char *__s;
  unsigned __int16 *v87;
  CFTypeRef cf;
  CFStringRef v89;
  int64x2_t v90;
  char *v91;
  uint64_t v92;
  unsigned __int16 v93[3];
  char v94;
  void *v95;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 112) == *(_QWORD *)(a1 + 120))
  {
    v5 = (KB::String **)*a2;
    v87 = a2[1];
    if (*a2 != v87)
    {
      if (a3)
        v7 = "Siri-TextInput-Dynamic.";
      else
        v7 = "TextInput-Dynamic.";
      v85 = (uint64_t *)(a1 + 88);
      __s = (char *)v7;
      v82 = a1 + 104;
      v83 = a1 + 128;
      v84 = (_QWORD *)(a1 + 208);
      while (1)
      {
        KB::String::String((KB::String *)v93, __s);
        KB::String::append(v93, (const KB::String *)v5);
        KB::cf_string_impl<KB::String>(&v89, v93);
        v8 = v89;
        View = (const void *)LXLexiconRepositoryCreateView();
        if (v8)
          CFRelease(v8);
        v11 = *(_QWORD **)(a1 + 120);
        v10 = *(_QWORD *)(a1 + 128);
        if ((unint64_t)v11 >= v10)
        {
          v13 = *(_QWORD *)(a1 + 112);
          v14 = ((uint64_t)v11 - v13) >> 3;
          if ((unint64_t)(v14 + 1) >> 61)
            goto LABEL_151;
          v15 = v10 - v13;
          v16 = v15 >> 2;
          if (v15 >> 2 <= (unint64_t)(v14 + 1))
            v16 = v14 + 1;
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
            v17 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v17 = v16;
          v92 = v83;
          if (v17)
            v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v17);
          else
            v18 = 0;
          v19 = (_QWORD *)(v17 + 8 * v14);
          v20 = v17 + 8 * v18;
          v91 = (char *)v20;
          *v19 = View;
          if (View)
          {
            CFRetain(View);
            *v19 = View;
          }
          v12 = v19 + 1;
          v90.i64[1] = (uint64_t)(v19 + 1);
          v22 = *(_QWORD **)(a1 + 112);
          v21 = *(_QWORD **)(a1 + 120);
          if (v21 == v22)
          {
            v24 = vdupq_n_s64((unint64_t)v21);
          }
          else
          {
            do
            {
              v23 = *--v21;
              *v21 = 0;
              *--v19 = v23;
            }
            while (v21 != v22);
            v24 = *(int64x2_t *)(a1 + 112);
            v12 = (_QWORD *)v90.i64[1];
            v20 = (unint64_t)v91;
          }
          *(_QWORD *)(a1 + 112) = v19;
          *(_QWORD *)(a1 + 120) = v12;
          v90 = v24;
          v25 = *(char **)(a1 + 128);
          *(_QWORD *)(a1 + 128) = v20;
          v91 = v25;
          v89 = (CFStringRef)v24.i64[0];
          std::__split_buffer<KB::retain_ptr<_LXLexicon const*>>::~__split_buffer((uint64_t)&v89);
        }
        else
        {
          *v11 = View;
          if (View)
          {
            CFRetain(View);
            *v11 = View;
          }
          v12 = v11 + 1;
        }
        *(_QWORD *)(a1 + 120) = v12;
        v26 = *(_QWORD *)(a1 + 96);
        v27 = *(_QWORD *)(a1 + 104);
        if (v26 >= v27)
        {
          v29 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v26 - *v85) >> 4);
          v30 = v29 + 1;
          if ((unint64_t)(v29 + 1) > 0x1745D1745D1745DLL)
            goto LABEL_151;
          v31 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v27 - *v85) >> 4);
          if (2 * v31 > v30)
            v30 = 2 * v31;
          v32 = (const __CFString *)(v31 >= 0xBA2E8BA2E8BA2ELL ? 0x1745D1745D1745DLL : v30);
          v92 = v82;
          if (v32)
            v32 = (const __CFString *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LexiconInfo>>((unint64_t)v32);
          else
            v33 = 0;
          v34 = (uint64_t)v32 + 176 * v29;
          v89 = v32;
          v90.i64[0] = v34;
          v91 = (char *)v32 + 176 * v33;
          std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo const&,KB::LexiconInfo*>(v34, (uint64_t)v5);
          v90.i64[1] = v34 + 176;
          std::vector<KB::LexiconInfo>::__swap_out_circular_buffer(v85, &v89);
          v28 = *(_QWORD *)(a1 + 96);
          std::__split_buffer<KB::LexiconInfo>::~__split_buffer((uint64_t)&v89);
        }
        else
        {
          v28 = std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo const&,KB::LexiconInfo*>(v26, (uint64_t)v5)+ 176;
        }
        *(_QWORD *)(a1 + 96) = v28;
        v36 = *(char **)(a1 + 176);
        v35 = *(_QWORD *)(a1 + 184);
        cf = View;
        if ((unint64_t)v36 >= v35)
        {
          v38 = *(char **)(a1 + 168);
          v39 = (v36 - v38) >> 2;
          v40 = v39 + 1;
          if ((unint64_t)(v39 + 1) >> 62)
LABEL_151:
            abort();
          v41 = v35 - (_QWORD)v38;
          if (v41 >> 1 > v40)
            v40 = v41 >> 1;
          v42 = (unint64_t)v41 >= 0x7FFFFFFFFFFFFFFCLL;
          v43 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v42)
            v43 = v40;
          if (v43)
          {
            v43 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v43);
            v38 = *(char **)(a1 + 168);
            v36 = *(char **)(a1 + 176);
          }
          else
          {
            v44 = 0;
          }
          v45 = (_DWORD *)(v43 + 4 * v39);
          *v45 = *((_DWORD *)v5 + 42);
          v37 = v45 + 1;
          while (v36 != v38)
          {
            v46 = *((_DWORD *)v36 - 1);
            v36 -= 4;
            *--v45 = v46;
          }
          *(_QWORD *)(a1 + 168) = v45;
          *(_QWORD *)(a1 + 176) = v37;
          *(_QWORD *)(a1 + 184) = v43 + 4 * v44;
          if (v38)
            operator delete(v38);
        }
        else
        {
          *(_DWORD *)v36 = *((_DWORD *)v5 + 42);
          v37 = v36 + 4;
        }
        *(_QWORD *)(a1 + 176) = v37;
        v47 = *(_QWORD *)(a1 + 112);
        v48 = *(_QWORD *)(a1 + 120);
        if (v5[1])
          v49 = v5[1];
        else
          v49 = (KB::String *)(v5 + 2);
        v50 = KB::String::hash(v49, (const char *)*(unsigned __int16 *)v5);
        v51 = v50;
        v52 = *(_QWORD *)(a1 + 200);
        if (v52)
        {
          v53 = v48;
          v54 = (uint8x8_t)vcnt_s8((int8x8_t)v52);
          v54.i16[0] = vaddlv_u8(v54);
          v55 = v54.u32[0];
          if (v54.u32[0] > 1uLL)
          {
            v3 = v50;
            if (v52 <= v50)
              v3 = v50 % v52;
          }
          else
          {
            v3 = ((_DWORD)v52 - 1) & v50;
          }
          v56 = *(_QWORD ***)(*(_QWORD *)(a1 + 192) + 8 * v3);
          if (v56)
          {
            for (i = *v56; i; i = (_QWORD *)*i)
            {
              v58 = i[1];
              if (v58 == v51)
              {
                if (i + 2 == v5 || KB::String::equal((KB::String *)(i + 2), (const KB::String *)v5, 1))
                {
                  v48 = v53;
                  v74 = cf;
                  goto LABEL_135;
                }
              }
              else
              {
                if (v55 > 1)
                {
                  if (v58 >= v52)
                    v58 %= v52;
                }
                else
                {
                  v58 &= v52 - 1;
                }
                if (v58 != v3)
                  break;
              }
            }
          }
          v48 = v53;
        }
        i = operator new(0x38uLL);
        *i = 0;
        i[1] = v51;
        KB::String::String((KB::String *)(i + 2), (const KB::String *)v5);
        i[6] = 0;
        v59 = (float)(unint64_t)(*(_QWORD *)(a1 + 216) + 1);
        v60 = *(float *)(a1 + 224);
        if (!v52 || (float)(v60 * (float)v52) < v59)
          break;
LABEL_125:
        v78 = *(_QWORD *)(a1 + 192);
        v79 = *(_QWORD **)(v78 + 8 * v3);
        if (v79)
        {
          *i = *v79;
          v74 = cf;
        }
        else
        {
          *i = *v84;
          *v84 = i;
          *(_QWORD *)(v78 + 8 * v3) = v84;
          v74 = cf;
          if (!*i)
            goto LABEL_134;
          v80 = *(_QWORD *)(*i + 8);
          if ((v52 & (v52 - 1)) != 0)
          {
            if (v80 >= v52)
              v80 %= v52;
          }
          else
          {
            v80 &= v52 - 1;
          }
          v79 = (_QWORD *)(*(_QWORD *)(a1 + 192) + 8 * v80);
        }
        *v79 = i;
LABEL_134:
        ++*(_QWORD *)(a1 + 216);
LABEL_135:
        i[6] = ((v48 - v47) >> 3) - 1;
        if (v74)
          CFRelease(v74);
        if (v95 && v94 == 1)
          free(v95);
        v5 += 22;
        if (v5 == (KB::String **)v87)
          return 1;
      }
      v61 = (v52 & (v52 - 1)) != 0;
      if (v52 < 3)
        v61 = 1;
      v62 = v61 | (2 * v52);
      v63 = vcvtps_u32_f32(v59 / v60);
      if (v62 <= v63)
        prime = (int8x8_t)v63;
      else
        prime = (int8x8_t)v62;
      if (*(_QWORD *)&prime == 1)
      {
        prime = (int8x8_t)2;
      }
      else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
      {
        prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      }
      v52 = *(_QWORD *)(a1 + 200);
      if (*(_QWORD *)&prime > v52)
        goto LABEL_90;
      if (*(_QWORD *)&prime < v52)
      {
        v71 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 216) / *(float *)(a1 + 224));
        if (v52 < 3 || (v72 = (uint8x8_t)vcnt_s8((int8x8_t)v52), v72.i16[0] = vaddlv_u8(v72), v72.u32[0] > 1uLL))
        {
          v71 = std::__next_prime(v71);
        }
        else
        {
          v73 = 1 << -(char)__clz(v71 - 1);
          if (v71 >= 2)
            v71 = v73;
        }
        if (*(_QWORD *)&prime <= v71)
          prime = (int8x8_t)v71;
        if (*(_QWORD *)&prime >= v52)
        {
          v52 = *(_QWORD *)(a1 + 200);
        }
        else
        {
          if (prime)
          {
LABEL_90:
            if (*(_QWORD *)&prime >> 61)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v65 = operator new(8 * *(_QWORD *)&prime);
            v66 = *(void **)(a1 + 192);
            *(_QWORD *)(a1 + 192) = v65;
            if (v66)
              operator delete(v66);
            v67 = 0;
            *(int8x8_t *)(a1 + 200) = prime;
            do
              *(_QWORD *)(*(_QWORD *)(a1 + 192) + 8 * v67++) = 0;
            while (*(_QWORD *)&prime != v67);
            v68 = (_QWORD *)*v84;
            if (*v84)
            {
              v69 = v68[1];
              v70 = (uint8x8_t)vcnt_s8(prime);
              v70.i16[0] = vaddlv_u8(v70);
              if (v70.u32[0] > 1uLL)
              {
                if (v69 >= *(_QWORD *)&prime)
                  v69 %= *(_QWORD *)&prime;
              }
              else
              {
                v69 &= *(_QWORD *)&prime - 1;
              }
              *(_QWORD *)(*(_QWORD *)(a1 + 192) + 8 * v69) = v84;
              v75 = (_QWORD *)*v68;
              if (*v68)
              {
                do
                {
                  v76 = v75[1];
                  if (v70.u32[0] > 1uLL)
                  {
                    if (v76 >= *(_QWORD *)&prime)
                      v76 %= *(_QWORD *)&prime;
                  }
                  else
                  {
                    v76 &= *(_QWORD *)&prime - 1;
                  }
                  if (v76 != v69)
                  {
                    v77 = *(_QWORD *)(a1 + 192);
                    if (!*(_QWORD *)(v77 + 8 * v76))
                    {
                      *(_QWORD *)(v77 + 8 * v76) = v68;
                      goto LABEL_116;
                    }
                    *v68 = *v75;
                    *v75 = **(_QWORD **)(*(_QWORD *)(a1 + 192) + 8 * v76);
                    **(_QWORD **)(*(_QWORD *)(a1 + 192) + 8 * v76) = v75;
                    v75 = v68;
                  }
                  v76 = v69;
LABEL_116:
                  v68 = v75;
                  v75 = (_QWORD *)*v75;
                  v69 = v76;
                }
                while (v75);
              }
            }
            v52 = (unint64_t)prime;
            goto LABEL_120;
          }
          v81 = *(void **)(a1 + 192);
          *(_QWORD *)(a1 + 192) = 0;
          if (v81)
            operator delete(v81);
          v52 = 0;
          *(_QWORD *)(a1 + 200) = 0;
        }
      }
LABEL_120:
      if ((v52 & (v52 - 1)) != 0)
      {
        if (v52 <= v51)
          v3 = v51 % v52;
        else
          v3 = v51;
      }
      else
      {
        v3 = ((_DWORD)v52 - 1) & v51;
      }
      goto LABEL_125;
    }
  }
  return 1;
}

void KB::DynamicDictionaryContainer::get_word_with_string(KB::DynamicDictionaryContainer *this@<X0>, const KB::String *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v9;
  unsigned int v10;
  int v11;
  const void *v12;
  _WORD *v13;
  const void *v15;
  _OWORD v16[2];
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD v20[2];
  __int128 v21;
  _OWORD v22[2];
  __int128 v23;
  _WORD v24[16];
  uint64_t v25;
  __int128 v26;
  _BYTE v27[24];
  _WORD v28[16];
  __int128 v29;
  __int128 v30;
  _WORD v31[16];
  __int128 v32;
  _OWORD v33[2];
  __int128 v34;
  _WORD v35[16];
  uint64_t v36;
  __int128 v37;
  _BYTE v38[24];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  memset(v28, 0, sizeof(v28));
  memset(v31, 0, sizeof(v31));
  *(_OWORD *)&v38[8] = 0u;
  v36 = 0;
  v34 = 0uLL;
  memset(v35, 0, sizeof(v35));
  v32 = 0u;
  memset(v33, 0, sizeof(v33));
  v29 = 0u;
  v30 = 0u;
  v28[1] = 16;
  LOBYTE(v28[3]) = 0;
  *(_QWORD *)&v30 = 0x3F80000000000000;
  DWORD2(v30) = 1065353216;
  v31[1] = 16;
  LOBYTE(v31[3]) = 0;
  __asm { FMOV            V9.2S, #1.0 }
  *(_QWORD *)&v32 = _D9;
  v35[1] = 16;
  LOBYTE(v35[3]) = 0;
  v37 = 0u;
  *(_OWORD *)v38 = 0u;
  *(_DWORD *)&v38[16] = 1065353216;
  if (*((_QWORD *)this + 15) != *((_QWORD *)this + 14))
  {
    v9 = 0;
    v10 = 1;
    do
    {
      v11 = *(_DWORD *)(*((_QWORD *)this + 11) + 176 * v9 + 160);
      KB::entry_from_lexicon(&v15);
      v12 = v15;
      if (v15)
      {
        KB::Word::Word((uint64_t)v16, (uint64_t)v15, v11);
        CFRelease(v12);
        if (LOWORD(v16[0]))
        {
          if (v28[0])
          {
            *(int32x2_t *)((char *)v33 + 12) = vadd_s32(*(int32x2_t *)((char *)v22 + 12), *(int32x2_t *)((char *)v33 + 12));
          }
          else
          {
            KB::String::operator=((KB::String *)v28, (KB::String *)v16);
            KB::ByteString::operator=((unsigned __int16 *)&v29, (const void **)&v17);
            *(_QWORD *)&v30 = v18;
            DWORD2(v30) = v19;
            KB::String::operator=((KB::String *)v31, (KB::String *)v20);
            v32 = v21;
            v33[0] = v22[0];
            v33[1] = v22[1];
            v34 = v23;
            KB::String::operator=((KB::String *)v35, (KB::String *)v24);
            LOBYTE(v36) = v25;
            *(_DWORD *)&v38[16] = *(_DWORD *)&v27[16];
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(&v37, *(_QWORD **)v27);
            DWORD2(v32) |= 0x2000000u;
          }
        }
      }
      else
      {
        memset(v16, 0, sizeof(v16));
        memset(v20, 0, sizeof(v20));
        *(_OWORD *)&v27[8] = 0u;
        v25 = 0;
        v23 = 0uLL;
        memset(v24, 0, sizeof(v24));
        v17 = 0u;
        WORD1(v16[0]) = 16;
        BYTE6(v16[0]) = 0;
        v18 = 0x3F80000000000000;
        v19 = 1065353216;
        WORD1(v20[0]) = 16;
        BYTE6(v20[0]) = 0;
        v21 = _D9;
        memset(v22, 0, sizeof(v22));
        v24[1] = 16;
        LOBYTE(v24[3]) = 0;
        v26 = 0u;
        *(_OWORD *)v27 = 0u;
        *(_DWORD *)&v27[16] = 1065353216;
      }
      KB::Word::~Word((KB::Word *)v16);
      v9 = v10++;
    }
    while (v9 < (uint64_t)(*((_QWORD *)this + 15) - *((_QWORD *)this + 14)) >> 3);
  }
  v13 = v16;
  KB::DynamicDictionary::word_from_transient_lexicon_with_string(this, (uint64_t)v16);
  if (v28[0])
  {
    if (LOWORD(v16[0]))
    {
      DWORD2(v32) = DWORD2(v32) & 0x7FFCFEFF | DWORD2(v21) & 0x80030100;
      *(_DWORD *)&v38[16] = *(_DWORD *)&v27[16];
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(&v37, *(_QWORD **)v27);
    }
    v13 = v28;
  }
  KB::Word::Word(a3, (uint64_t)v13);
  KB::Word::~Word((KB::Word *)v16);
  KB::Word::~Word((KB::Word *)v28);
}

uint64_t KB::DynamicDictionaryContainer::get_user_frequency(KB::DynamicDictionaryContainer *this, _LXLexicon *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int *v10;
  int v11;
  const void *v12;
  unsigned int UsageCount;
  uint64_t v14;
  unint64_t v15;
  float v16;
  float v17;
  const void *v18;
  uint64_t v19;
  const void *v21;

  if (a3 == -1)
  {
    if (*((_QWORD *)this + 15) == *((_QWORD *)this + 14))
    {
      v16 = 0.0;
    }
    else
    {
      v15 = 0;
      v16 = 0.0;
      do
      {
        KB::DynamicDictionary::entry_matching_string(a2, &v21);
        v17 = *(float *)(*((_QWORD *)this + 21) + 4 * v15);
        v18 = v21;
        if (v21)
        {
          v16 = v16 + (float)(v17 * (float)LXEntryGetUsageCount());
          CFRelease(v18);
        }
        else
        {
          v16 = v16 + (float)(v17 * 0.0);
        }
        ++v15;
      }
      while (v15 < (uint64_t)(*((_QWORD *)this + 15) - *((_QWORD *)this + 14)) >> 3);
    }
    v19 = llroundf(ceilf(v16));
    if (v19 >= 0x7FFFFFFF)
      return 0x7FFFFFFFLL;
    else
      return v19;
  }
  else
  {
    v6 = *((_QWORD *)this + 11);
    v5 = *((_QWORD *)this + 12);
    v7 = v5 - v6;
    if (v5 != v6)
    {
      v8 = 0;
      v9 = v7 / 176;
      if (v9 <= 1)
        v9 = 1;
      v10 = (int *)(v6 + 160);
      do
      {
        v11 = *v10;
        v10 += 44;
        if (v11 == a3)
          break;
        ++v8;
      }
      while (v9 != v8);
    }
    KB::DynamicDictionary::entry_matching_string(a2, &v21);
    v12 = v21;
    if (v21)
    {
      UsageCount = LXEntryGetUsageCount();
      if (UsageCount >= 0x7FFFFFFF)
        v14 = 0x7FFFFFFFLL;
      else
        v14 = UsageCount;
      CFRelease(v12);
    }
    else
    {
      return 0;
    }
  }
  return v14;
}

unint64_t KB::DynamicDictionaryContainer::get_total_usage_count(KB::DynamicDictionaryContainer *this, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int *v8;
  int v9;
  float v10;
  uint64_t v11;
  const void *v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  float v19;
  uint64_t RootCursor;
  const void *v21;
  int v22;
  unsigned int v23;
  float v24;
  float v25;
  uint64_t v26;
  const void *v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  const void *v31;
  int v32;
  unsigned int v33;
  _QWORD **v34;
  float v35;
  float v36;
  _QWORD *v37;
  uint64_t v38;
  const void *v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  const void *v43;
  int v44;
  unsigned int v45;
  float v46;
  uint64_t v47;
  const void *v48;
  int v49;
  unsigned int v50;

  if (a2 == -1)
  {
    v15 = *((_QWORD *)this + 15) - *((_QWORD *)this + 14);
    if (v15)
    {
      v16 = 0;
      v17 = v15 >> 3;
      if (v17 <= 1)
        v18 = 1;
      else
        v18 = v17;
      v10 = 0.0;
      do
      {
        v19 = *(float *)(*((_QWORD *)this + 21) + 4 * v16);
        if (*(_QWORD *)(*((_QWORD *)this + 14) + 8 * v16) && (RootCursor = LXLexiconCreateRootCursor()) != 0)
        {
          v21 = (const void *)RootCursor;
          v22 = LXCursorUsageCountRecursive();
          v23 = v22 & ~(v22 >> 31);
          CFRelease(v21);
        }
        else
        {
          v23 = 0;
        }
        v10 = v10 + (float)(v19 * (float)v23);
        ++v16;
      }
      while (v18 != v16);
    }
    else
    {
      v10 = 0.0;
    }
  }
  else
  {
    v4 = *((_QWORD *)this + 11);
    v3 = *((_QWORD *)this + 12);
    v5 = v3 - v4;
    if (v3 == v4)
    {
LABEL_8:
      v6 = -1;
    }
    else
    {
      v6 = 0;
      v7 = v5 / 176;
      if (v7 <= 1)
        v7 = 1;
      v8 = (int *)(v4 + 160);
      while (1)
      {
        v9 = *v8;
        v8 += 44;
        if (v9 == a2)
          break;
        if (v7 == ++v6)
          goto LABEL_8;
      }
    }
    v10 = 0.0;
    if (*(_QWORD *)(*((_QWORD *)this + 14) + 8 * v6))
    {
      v11 = LXLexiconCreateRootCursor();
      if (v11)
      {
        v12 = (const void *)v11;
        v13 = LXCursorUsageCountRecursive();
        v14 = v13 & ~(v13 >> 31);
        CFRelease(v12);
        v10 = (float)v14;
      }
    }
  }
  v24 = 0.0;
  v25 = 0.0;
  if (*((_QWORD *)this + 1))
  {
    v26 = LXLexiconCreateRootCursor();
    if (v26)
    {
      v27 = (const void *)v26;
      v28 = LXCursorUsageCountRecursive();
      v29 = v28 & ~(v28 >> 31);
      CFRelease(v27);
      v25 = (float)v29;
    }
  }
  if (*((_QWORD *)this + 2))
  {
    v30 = LXLexiconCreateRootCursor();
    if (v30)
    {
      v31 = (const void *)v30;
      v32 = LXCursorUsageCountRecursive();
      v33 = v32 & ~(v32 >> 31);
      CFRelease(v31);
      v24 = (float)v33;
    }
  }
  v34 = (_QWORD **)*((_QWORD *)this + 3);
  v35 = 0.0;
  v36 = 0.0;
  if (v34)
  {
    v37 = *v34;
    if (v37)
    {
      if (*v37)
      {
        v38 = LXLexiconCreateRootCursor();
        if (v38)
        {
          v39 = (const void *)v38;
          v40 = LXCursorUsageCountRecursive();
          v41 = v40 & ~(v40 >> 31);
          CFRelease(v39);
          v36 = (float)v41;
        }
      }
    }
  }
  if (KB::DynamicDictionary::named_entity_lexicon(this))
  {
    v42 = LXLexiconCreateRootCursor();
    if (v42)
    {
      v43 = (const void *)v42;
      v44 = LXCursorUsageCountRecursive();
      v45 = v44 & ~(v44 >> 31);
      CFRelease(v43);
      v35 = (float)v45;
    }
  }
  v46 = 0.0;
  if (TITransientLexiconManagerGetActiveSupplementalLexiconWords())
  {
    v47 = LXLexiconCreateRootCursor();
    if (v47)
    {
      v48 = (const void *)v47;
      v49 = LXCursorUsageCountRecursive();
      v50 = v49 & ~(v49 >> 31);
      CFRelease(v48);
      v46 = (float)v50;
    }
  }
  return llroundf(ceilf((float)((float)((float)((float)(v10 + v25) + v24) + v36) + v35) + v46));
}

uint64_t KB::DynamicDictionaryContainer::get_persistent_custom_trie_count(KB::DynamicDictionaryContainer *this)
{
  return (uint64_t)(*((_QWORD *)this + 15) - *((_QWORD *)this + 14)) >> 3;
}

uint64_t KB::DynamicDictionaryContainer::get_persistent_custom_trie(KB::DynamicDictionaryContainer *this, unint64_t a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 14);
  if (a2 >= (*((_QWORD *)this + 15) - v2) >> 3)
    return 0;
  else
    return *(_QWORD *)(v2 + 8 * a2);
}

_QWORD *KB::DynamicDictionaryContainer::get_persistent_custom_trie_for_locale(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *result;
  _QWORD *v6;

  v4 = a1 + 24;
  result = std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::find<KB::String>(a1 + 24, a2);
  if (result)
  {
    v6 = std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::find<KB::String>(v4, a2);
    if (!v6)
      abort();
    return (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD))(*a1 + 88))(a1, v6[6]);
  }
  return result;
}

void KB::DynamicDictionaryContainer::do_enumerate_entries(KB::DynamicDictionary *a1, uint64_t a2)
{
  uint64_t ActiveSupplementalLexiconWords;
  uint64_t v4;
  const void *RootCursor;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  const void *v10;
  const void *v12;
  const void *v13;
  _QWORD **v14;
  _QWORD *v15;
  const void *v16;
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, uint64_t);
  void *v22;
  uint64_t *v23;
  int v24;

  v18 = a2;
  ActiveSupplementalLexiconWords = TITransientLexiconManagerGetActiveSupplementalLexiconWords();
  v4 = MEMORY[0x1E0C809B0];
  if (ActiveSupplementalLexiconWords)
  {
    RootCursor = (const void *)LXLexiconCreateRootCursor();
    v19 = v4;
    v20 = 0x40000000;
    v21 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    v22 = &__block_descriptor_tmp_13;
    v23 = &v18;
    v24 = 5;
    LXCursorEnumerateEntriesRecursively();
    if (RootCursor)
      CFRelease(RootCursor);
  }
  v6 = *((_QWORD *)a1 + 15) - *((_QWORD *)a1 + 14);
  if (v6)
  {
    v7 = 0;
    v8 = v6 >> 3;
    v9 = 1;
    do
    {
      if ((*(uint64_t (**)(KB::DynamicDictionary *, uint64_t))(*(_QWORD *)a1 + 88))(a1, v7))
      {
        v10 = (const void *)LXLexiconCreateRootCursor();
        v19 = v4;
        v20 = 0x40000000;
        v21 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
        v22 = &__block_descriptor_tmp_13;
        v23 = &v18;
        v24 = 0;
        LXCursorEnumerateEntriesRecursively();
        if (v10)
          CFRelease(v10);
      }
      v7 = v9;
    }
    while (v8 > v9++);
  }
  if (*((_QWORD *)a1 + 1))
  {
    v12 = (const void *)LXLexiconCreateRootCursor();
    v19 = v4;
    v20 = 0x40000000;
    v21 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    v22 = &__block_descriptor_tmp_13;
    v23 = &v18;
    v24 = 1;
    LXCursorEnumerateEntriesRecursively();
    if (v12)
      CFRelease(v12);
  }
  if (*((_QWORD *)a1 + 2))
  {
    v13 = (const void *)LXLexiconCreateRootCursor();
    v19 = v4;
    v20 = 0x40000000;
    v21 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    v22 = &__block_descriptor_tmp_13;
    v23 = &v18;
    v24 = 2;
    LXCursorEnumerateEntriesRecursively();
    if (v13)
      CFRelease(v13);
  }
  v14 = (_QWORD **)*((_QWORD *)a1 + 3);
  if (v14)
  {
    v15 = *v14;
    if (v15)
    {
      if (*v15)
      {
        v16 = (const void *)LXLexiconCreateRootCursor();
        v19 = v4;
        v20 = 0x40000000;
        v21 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
        v22 = &__block_descriptor_tmp_13;
        v23 = &v18;
        v24 = 3;
        LXCursorEnumerateEntriesRecursively();
        if (v16)
          CFRelease(v16);
      }
    }
  }
  if (KB::DynamicDictionary::named_entity_lexicon(a1))
  {
    v17 = (const void *)LXLexiconCreateRootCursor();
    v19 = v4;
    v20 = 0x40000000;
    v21 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    v22 = &__block_descriptor_tmp_13;
    v23 = &v18;
    v24 = 4;
    LXCursorEnumerateEntriesRecursively();
    if (v17)
      CFRelease(v17);
  }
}

uint64_t ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 32) + 16))(**(_QWORD **)(a1 + 32), a2, *(unsigned int *)(a1 + 40));
}

uint64_t KB::DynamicDictionary::named_entity_lexicon(KB::DynamicDictionary *this)
{
  uint64_t v2;
  const char *v3;

  if ((*(unsigned int (**)(KB::DynamicDictionary *))(*(_QWORD *)this + 32))(this))
  {
    v2 = (*(uint64_t (**)(KB::DynamicDictionary *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
    if (*(_WORD *)v2)
    {
      if (*(_QWORD *)(v2 + 8))
        v3 = *(const char **)(v2 + 8);
      else
        v3 = (const char *)(v2 + 16);
    }
    else
    {
      v3 = "";
    }
  }
  else
  {
    v3 = 0;
  }
  return TITransientLexiconManagerGetNamedEntitiesForLocale((uint64_t)v3);
}

void KB::DynamicDictionary::entry_matching_string(_LXLexicon *a1@<X1>, _QWORD *a2@<X8>)
{
  CFStringRef v5;
  const void *v6;
  CFStringRef v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t);
  void (*v12)(uint64_t);
  CFTypeRef cf;

  v8 = 0;
  v9 = &v8;
  v10 = 0x3002000000;
  v11 = __Block_byref_object_copy__2213;
  v12 = __Block_byref_object_dispose__2214;
  cf = 0;
  KB::cf_string_impl<KB::String>(&v7, (unsigned __int16 *)a1);
  v5 = v7;
  LXLexiconEnumerateEntriesForString();
  if (v5)
    CFRelease(v5);
  v6 = (const void *)v9[5];
  *a2 = v6;
  if (v6)
  {
    CFRetain(v6);
    *a2 = v6;
  }
  _Block_object_dispose(&v8, 8);
  if (cf)
    CFRelease(cf);
}

uint64_t __Block_byref_object_copy__2213(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(result + 40) = v2;
  return result;
}

void __Block_byref_object_dispose__2214(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 40);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)(a1 + 40) = 0;
}

void ___ZN2KB17DynamicDictionary21entry_matching_stringEPK10_LXLexiconRKNS_6StringEj_block_invoke(uint64_t a1, const void *a2, _BYTE *a3)
{
  _BOOL4 v6;
  BOOL v7;
  _BYTE v8[8];
  void *v9;
  _BYTE v10[240];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  KB::Word::Word((uint64_t)v10, (uint64_t)a2, *(_DWORD *)(a1 + 48));
  KB::Word::capitalized_string((KB::Word *)v10, (uint64_t)v8);
  v6 = KB::String::equal((KB::String *)v8, *(const KB::String **)(a1 + 40), 1);
  if (v9)
    v7 = v8[6] == 1;
  else
    v7 = 0;
  if (v7)
    free(v9);
  if (v6)
  {
    KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), a2);
    *a3 = 1;
  }
  KB::Word::~Word((KB::Word *)v10);
}

double KB::Word::Word(KB::Word *this)
{
  double result;

  *(_DWORD *)this = 0x100000;
  *((_WORD *)this + 2) = 0;
  *((_BYTE *)this + 6) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_BYTE *)this + 16) = 0;
  *((_WORD *)this + 16) = 0;
  *((_QWORD *)this + 6) = 0x3F80000000000000;
  *((_DWORD *)this + 14) = 1065353216;
  *((_DWORD *)this + 16) = 0x100000;
  *((_WORD *)this + 34) = 0;
  *((_BYTE *)this + 70) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_BYTE *)this + 80) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)this + 12) = _D0;
  *((_DWORD *)this + 26) = 0;
  *((_QWORD *)this + 19) = 0;
  result = 0.0;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 40) = 0x100000;
  *((_WORD *)this + 82) = 0;
  *((_BYTE *)this + 166) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_BYTE *)this + 176) = 0;
  *((_BYTE *)this + 192) = 0;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_DWORD *)this + 58) = 1065353216;
  return result;
}

double KB::DynamicDictionary::word_from_transient_lexicon_with_string@<D0>(KB::DynamicDictionary *this@<X0>, uint64_t a2@<X8>)
{
  int v5;
  double result;
  const void *v7;
  unsigned int v8;
  const void *v9;
  _QWORD **v10;
  _QWORD *v11;
  const void *v12;
  const void *v13;
  uint64_t v14[30];
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v5 = *(_DWORD *)((*(uint64_t (**)(KB::DynamicDictionary *, _QWORD))(*(_QWORD *)this + 48))(this, 0) + 160);
  KB::DynamicDictionary::word_from_supplemental_lexicon((uint64_t)this, v14);
  if (!v15)
  {
    if (*((_QWORD *)this + 1))
    {
      KB::entry_from_lexicon(v14);
      v7 = (const void *)v14[0];
      if (v14[0])
      {
        KB::Word::Word(a2, v14[0], v5);
        CFRelease(v7);
      }
      else
      {
        *(_OWORD *)(a2 + 208) = 0u;
        *(_OWORD *)(a2 + 224) = 0u;
        *(_OWORD *)(a2 + 176) = 0u;
        *(_OWORD *)(a2 + 192) = 0u;
        *(_OWORD *)(a2 + 144) = 0u;
        *(_OWORD *)(a2 + 160) = 0u;
        *(_OWORD *)(a2 + 112) = 0u;
        *(_OWORD *)(a2 + 128) = 0u;
        *(_OWORD *)(a2 + 80) = 0u;
        *(_OWORD *)(a2 + 96) = 0u;
        *(_OWORD *)(a2 + 48) = 0u;
        *(_OWORD *)(a2 + 64) = 0u;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
        result = KB::Word::Word((KB::Word *)a2);
      }
      if (*(_WORD *)a2)
      {
        v8 = *(_DWORD *)(a2 + 104) | 0x20000;
LABEL_33:
        *(_DWORD *)(a2 + 104) = v8;
        return result;
      }
      KB::Word::~Word((KB::Word *)a2);
    }
    if (*((_QWORD *)this + 2))
    {
      KB::entry_from_lexicon(v14);
      v9 = (const void *)v14[0];
      if (v14[0])
      {
        KB::Word::Word(a2, v14[0], v5);
        CFRelease(v9);
      }
      else
      {
        *(_OWORD *)(a2 + 208) = 0u;
        *(_OWORD *)(a2 + 224) = 0u;
        *(_OWORD *)(a2 + 176) = 0u;
        *(_OWORD *)(a2 + 192) = 0u;
        *(_OWORD *)(a2 + 144) = 0u;
        *(_OWORD *)(a2 + 160) = 0u;
        *(_OWORD *)(a2 + 112) = 0u;
        *(_OWORD *)(a2 + 128) = 0u;
        *(_OWORD *)(a2 + 80) = 0u;
        *(_OWORD *)(a2 + 96) = 0u;
        *(_OWORD *)(a2 + 48) = 0u;
        *(_OWORD *)(a2 + 64) = 0u;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
        result = KB::Word::Word((KB::Word *)a2);
      }
      if (*(_WORD *)a2)
      {
        v8 = *(_DWORD *)(a2 + 104) | 0x80000000;
        goto LABEL_33;
      }
      KB::Word::~Word((KB::Word *)a2);
    }
    v10 = (_QWORD **)*((_QWORD *)this + 3);
    if (v10)
    {
      v11 = *v10;
      if (v11)
      {
        if (*v11)
        {
          KB::entry_from_lexicon(v14);
          v12 = (const void *)v14[0];
          if (v14[0])
          {
            KB::Word::Word(a2, v14[0], v5);
            CFRelease(v12);
          }
          else
          {
            *(_OWORD *)(a2 + 208) = 0u;
            *(_OWORD *)(a2 + 224) = 0u;
            *(_OWORD *)(a2 + 176) = 0u;
            *(_OWORD *)(a2 + 192) = 0u;
            *(_OWORD *)(a2 + 144) = 0u;
            *(_OWORD *)(a2 + 160) = 0u;
            *(_OWORD *)(a2 + 112) = 0u;
            *(_OWORD *)(a2 + 128) = 0u;
            *(_OWORD *)(a2 + 80) = 0u;
            *(_OWORD *)(a2 + 96) = 0u;
            *(_OWORD *)(a2 + 48) = 0u;
            *(_OWORD *)(a2 + 64) = 0u;
            *(_OWORD *)(a2 + 16) = 0u;
            *(_OWORD *)(a2 + 32) = 0u;
            *(_OWORD *)a2 = 0u;
            result = KB::Word::Word((KB::Word *)a2);
          }
          if (*(_WORD *)a2)
          {
            v8 = *(_DWORD *)(a2 + 104) | 0x10000;
            goto LABEL_33;
          }
          KB::Word::~Word((KB::Word *)a2);
        }
      }
    }
    if (KB::DynamicDictionary::named_entity_lexicon(this))
    {
      KB::entry_from_lexicon(v14);
      v13 = (const void *)v14[0];
      if (v14[0])
      {
        KB::Word::Word(a2, v14[0], v5);
        CFRelease(v13);
      }
      else
      {
        *(_OWORD *)(a2 + 208) = 0u;
        *(_OWORD *)(a2 + 224) = 0u;
        *(_OWORD *)(a2 + 176) = 0u;
        *(_OWORD *)(a2 + 192) = 0u;
        *(_OWORD *)(a2 + 144) = 0u;
        *(_OWORD *)(a2 + 160) = 0u;
        *(_OWORD *)(a2 + 112) = 0u;
        *(_OWORD *)(a2 + 128) = 0u;
        *(_OWORD *)(a2 + 80) = 0u;
        *(_OWORD *)(a2 + 96) = 0u;
        *(_OWORD *)(a2 + 48) = 0u;
        *(_OWORD *)(a2 + 64) = 0u;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
        result = KB::Word::Word((KB::Word *)a2);
      }
      if (*(_WORD *)a2)
      {
        v8 = *(_DWORD *)(a2 + 104) | 0x100;
        goto LABEL_33;
      }
      KB::Word::~Word((KB::Word *)a2);
    }
    *(_OWORD *)(a2 + 208) = 0u;
    *(_OWORD *)(a2 + 224) = 0u;
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_OWORD *)(a2 + 144) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    return KB::Word::Word((KB::Word *)a2);
  }
  KB::Word::Word((KB::Word *)a2, (const KB::Word *)v14);
  if (v15)
    KB::Word::~Word((KB::Word *)v14);
  return result;
}

void KB::entry_from_lexicon(_QWORD *a1)
{
  const void *RootCursor;
  uint64_t v3;
  const void *v4;
  const void *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  void (*v10)(uint64_t);
  CFTypeRef cf;

  RootCursor = (const void *)LXLexiconCreateRootCursor();
  v3 = LXCursorCreateByAdvancingWithUTF8();
  if (!v3)
  {
    *a1 = 0;
    if (!RootCursor)
      return;
    goto LABEL_7;
  }
  v4 = (const void *)v3;
  v6 = 0;
  v7 = &v6;
  v8 = 0x3002000000;
  v9 = __Block_byref_object_copy__2213;
  v10 = __Block_byref_object_dispose__2214;
  cf = 0;
  LXCursorEnumerateEntries();
  v5 = (const void *)v7[5];
  *a1 = v5;
  if (v5)
  {
    CFRetain(v5);
    *a1 = v5;
  }
  _Block_object_dispose(&v6, 8);
  if (cf)
    CFRelease(cf);
  CFRelease(v4);
  if (RootCursor)
LABEL_7:
    CFRelease(RootCursor);
}

uint64_t KB::Word::Word(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 6) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v4 = KB::String::operator=(a1, (KB::String *)a2);
  v5 = *(unsigned __int16 *)(a2 + 32);
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(a2 + 32);
  if (v5 >= 0xF)
    *(_WORD *)(a2 + 32) = 0;
  v6 = *(_QWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = v6;
  *(_DWORD *)(a1 + 64) = 0x100000;
  *(_WORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 70) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  KB::String::operator=(a1 + 64, (KB::String *)(a2 + 64));
  v7 = *(_OWORD *)(a2 + 96);
  v8 = *(_OWORD *)(a2 + 112);
  v9 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 144) = v9;
  *(_OWORD *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 112) = v8;
  *(_DWORD *)(a1 + 160) = 0x100000;
  *(_WORD *)(a1 + 164) = 0;
  *(_BYTE *)(a1 + 166) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  KB::String::operator=(a1 + 160, (KB::String *)(a2 + 160));
  *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
  v10 = *(_QWORD *)(a2 + 200);
  *(_QWORD *)(a2 + 200) = 0;
  *(_QWORD *)(a1 + 200) = v10;
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  *(_QWORD *)(a2 + 208) = 0;
  v13 = *(_QWORD *)(a2 + 216);
  v12 = a2 + 216;
  v11 = v13;
  *(_QWORD *)(a1 + 216) = v13;
  v14 = *(_QWORD *)(v12 + 8);
  *(_QWORD *)(a1 + 224) = v14;
  *(_DWORD *)(a1 + 232) = *(_DWORD *)(v12 + 16);
  if (v14)
  {
    v15 = *(_QWORD *)(v11 + 8);
    v16 = *(_QWORD *)(a1 + 208);
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v15 >= v16)
        v15 %= v16;
    }
    else
    {
      v15 &= v16 - 1;
    }
    *(_QWORD *)(v10 + 8 * v15) = a1 + 216;
    *(_QWORD *)v12 = 0;
    *(_QWORD *)(v12 + 8) = 0;
  }
  return a1;
}

void ___ZN2KBL18entry_from_lexiconERKNS_6StringEPK10_LXLexiconU13block_pointerFbS2_S2_E_block_invoke(_QWORD *a1, const void *a2, _BYTE *a3)
{
  const __CFString *v6;
  uint64_t v7;
  const KB::String *v8;
  _BYTE v9[8];
  void *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v6 = (const __CFString *)LXEntryCopyString();
  KB::utf8_string(v6, (uint64_t)v9);
  v7 = a1[4];
  if (v7)
  {
    if (((*(uint64_t (**)(uint64_t, _BYTE *, _QWORD))(v7 + 16))(v7, v9, a1[6]) & 1) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
  v8 = (const KB::String *)a1[6];
  if (v9 == (_BYTE *)v8 || KB::String::equal((KB::String *)v9, v8, 1))
  {
LABEL_6:
    KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(*(_QWORD *)(a1[5] + 8) + 40), a2);
    *a3 = 1;
  }
LABEL_7:
  if (v10 && v9[6] == 1)
    free(v10);
  if (v6)
    CFRelease(v6);
}

void KB::DynamicDictionary::word_from_supplemental_lexicon(uint64_t a1@<X0>, _BYTE *a2@<X8>)
{
  const void *v4;
  uint64_t v5;
  int v6;
  _BYTE v7[16];
  _QWORD *v8;
  int v9;
  const void *v10;
  _BYTE v11[104];
  unsigned int v12;
  _QWORD v13[4];
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (TITransientLexiconManagerGetActiveSupplementalLexiconWords() && (KB::entry_from_lexicon(&v10), (v4 = v10) != 0))
  {
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 48))(a1, 0);
    KB::Word::Word((uint64_t)v11, (uint64_t)v4, *(_DWORD *)(v5 + 160));
    TILXEntryGetSupplementalItemIdentifiers((uint64_t)v7);
    v14 = v9;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(v13, v8);
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)v7);
    if (TILXEntryIsPartOfHyphenatedWord())
      v6 = 16;
    else
      v6 = 0;
    v12 = v12 & 0xFFFFFFEF | v6;
    KB::Word::Word((uint64_t)a2, (uint64_t)v11);
    a2[240] = 1;
    KB::Word::~Word((KB::Word *)v11);
    CFRelease(v4);
  }
  else
  {
    *a2 = 0;
    a2[240] = 0;
  }
}

uint64_t std::__split_buffer<KB::retain_ptr<_LXLexicon const*>>::~__split_buffer(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  const void *v4;
  _QWORD *v5;
  const void *v6;
  _QWORD *v7;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 16);
  if (v3 != v2)
  {
    do
    {
      v6 = (const void *)*(v3 - 1);
      v5 = v3 - 1;
      v4 = v6;
      *(_QWORD *)(a1 + 16) = v5;
      v7 = v5;
      if (v6)
      {
        CFRelease(v4);
        v7 = *(_QWORD **)(a1 + 16);
      }
      *v5 = 0;
      v3 = v7;
    }
    while (v7 != v2);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo const&,KB::LexiconInfo*>(uint64_t a1, uint64_t a2)
{
  KB::String *v4;
  uint64_t v5;

  v4 = KB::String::String((KB::String *)a1, (const KB::String *)a2);
  KB::String::String((KB::String *)((char *)v4 + 32), (const KB::String *)(a2 + 32));
  KB::String::String((KB::String *)(a1 + 64), (const KB::String *)(a2 + 64));
  KB::String::String((KB::String *)(a1 + 96), (const KB::String *)(a2 + 96));
  KB::String::String((KB::String *)(a1 + 128), (const KB::String *)(a2 + 128));
  v5 = *(_QWORD *)(a2 + 160);
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 160) = v5;
  return a1;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LexiconInfo>>(unint64_t a1)
{
  if (a1 >= 0x1745D1745D1745ELL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(176 * a1);
}

uint64_t std::vector<KB::LexiconInfo>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 176;
    result = std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo,KB::LexiconInfo*>(result - 176, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<KB::LexiconInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 176;
    std::__destroy_at[abi:nn180100]<KB::LexiconInfo,0>(i - 176);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__destroy_at[abi:nn180100]<KB::LexiconInfo,0>(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v2 = *(void **)(a1 + 136);
  if (v2 && *(_BYTE *)(a1 + 134) == 1)
    free(v2);
  v3 = *(void **)(a1 + 104);
  if (v3 && *(_BYTE *)(a1 + 102) == 1)
    free(v3);
  v4 = *(void **)(a1 + 72);
  if (v4 && *(_BYTE *)(a1 + 70) == 1)
    free(v4);
  v5 = *(void **)(a1 + 40);
  if (v5 && *(_BYTE *)(a1 + 38) == 1)
    free(v5);
  v6 = *(void **)(a1 + 8);
  if (v6)
  {
    if (*(_BYTE *)(a1 + 6) == 1)
      free(v6);
  }
}

uint64_t std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo,KB::LexiconInfo*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 6) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v4 = KB::String::operator=(a1, (KB::String *)a2);
  *(_DWORD *)(v4 + 32) = 0x100000;
  *(_WORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 38) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  KB::String::operator=(v4 + 32, (KB::String *)(a2 + 32));
  *(_DWORD *)(a1 + 64) = 0x100000;
  *(_WORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 70) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  KB::String::operator=(a1 + 64, (KB::String *)(a2 + 64));
  *(_DWORD *)(a1 + 96) = 0x100000;
  *(_WORD *)(a1 + 100) = 0;
  *(_BYTE *)(a1 + 102) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  KB::String::operator=(a1 + 96, (KB::String *)(a2 + 96));
  *(_DWORD *)(a1 + 128) = 0x100000;
  *(_WORD *)(a1 + 132) = 0;
  *(_BYTE *)(a1 + 134) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  KB::String::operator=(a1 + 128, (KB::String *)(a2 + 128));
  v5 = *(_QWORD *)(a2 + 160);
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 160) = v5;
  return a1;
}

void std::vector<KB::retain_ptr<_LXLexicon const*>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<KB::retain_ptr<_LXLexicon const*>>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<KB::LexiconInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 176;
        std::__destroy_at[abi:nn180100]<KB::LexiconInfo,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void KB::DynamicDictionary::~DynamicDictionary(KB::DynamicDictionary *this)
{
  void *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;

  *(_QWORD *)this = off_1EA0FB380;
  v2 = (void *)*((_QWORD *)this + 8);
  if (v2 && *((_BYTE *)this + 62) == 1)
    free(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  if (v6)
  {
    v7 = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void std::vector<KB::retain_ptr<_LXLexicon const*>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  const void *v6;

  v2 = *a1;
  v3 = a1[1];
  if (v3 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(const void **)(v4 - 8);
      v4 -= 8;
      v5 = v6;
      if (v6)
        CFRelease(v5);
      *(_QWORD *)(v3 - 8) = 0;
      v3 = v4;
    }
    while (v4 != v2);
  }
  a1[1] = v2;
}

void std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::__deallocate_node(_QWORD *__p)
{
  _QWORD *v1;
  _QWORD *v2;
  void *v3;

  if (__p)
  {
    v1 = __p;
    do
    {
      v2 = v1;
      v1 = (_QWORD *)*v1;
      v3 = (void *)v2[3];
      if (v3)
      {
        if (*((_BYTE *)v2 + 22) == 1)
          free(v3);
      }
      operator delete(v2);
    }
    while (v1);
  }
}

void KB::DynamicDictionarySingle::~DynamicDictionarySingle(KB::DynamicDictionarySingle *this)
{
  KB::DynamicDictionarySingle::~DynamicDictionarySingle(this);
  JUMPOUT(0x1DF0A2144);
}

{
  void *v2;
  const void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  *(_QWORD *)this = &off_1EA0FB2D8;
  v2 = (void *)*((_QWORD *)this + 35);
  if (v2 && *((_BYTE *)this + 278) == 1)
    free(v2);
  v3 = (const void *)*((_QWORD *)this + 33);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 33) = 0;
  v4 = (void *)*((_QWORD *)this + 28);
  if (v4 && *((_BYTE *)this + 222) == 1)
    free(v4);
  v5 = (void *)*((_QWORD *)this + 24);
  if (v5 && *((_BYTE *)this + 190) == 1)
    free(v5);
  v6 = (void *)*((_QWORD *)this + 20);
  if (v6 && *((_BYTE *)this + 158) == 1)
    free(v6);
  v7 = (void *)*((_QWORD *)this + 16);
  if (v7 && *((_BYTE *)this + 126) == 1)
    free(v7);
  v8 = (void *)*((_QWORD *)this + 12);
  if (v8 && *((_BYTE *)this + 94) == 1)
    free(v8);
  KB::DynamicDictionary::~DynamicDictionary(this);
}

void KB::DynamicDictionarySingle::do_create_root_cursor(KB::DynamicDictionarySingle *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;

  v4 = operator new();
  *(_OWORD *)(v4 + 8) = 0u;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_QWORD *)(v4 + 40) = 0;
  *(_QWORD *)(v4 + 48) = 0;
  *(_QWORD *)v4 = &off_1EA105288;
  KB::DynamicDictionarySingleCursor::set_to_root((KB::DynamicDictionarySingleCursor *)v4, this);
  *a2 = v4;
}

double KB::DynamicDictionarySingle::do_create_invalid_cursor@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v3;
  double result;

  v3 = operator new();
  result = 0.0;
  *(_OWORD *)(v3 + 8) = 0u;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)v3 = &off_1EA105288;
  *a1 = v3;
  return result;
}

BOOL KB::DynamicDictionarySingle::get_valid(KB::DynamicDictionarySingle *this)
{
  const void *v1;

  v1 = (const void *)*((_QWORD *)this + 33);
  if (v1)
  {
    CFRetain(*((CFTypeRef *)this + 33));
    CFRelease(v1);
  }
  return v1 != 0;
}

uint64_t KB::DynamicDictionarySingle::do_load(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v4;
  const char *v5;
  CFStringRef v6;
  uint64_t View;
  const void *v8;
  uint64_t v9;
  const void *v10;
  uint64_t result;
  void *v12;
  const void *v13;
  CFStringRef v14;
  int v15;
  __int16 v16;
  char v17;
  void *v18;
  char v19;
  int v20;
  __int16 v21;
  char v22;
  void *v23;
  char v24;
  int v25;
  __int16 v26;
  char v27;
  void *v28;
  char v29;
  int v30;
  __int16 v31;
  char v32;
  void *v33;
  char v34;
  int v35;
  __int16 v36;
  char v37;
  void *v38;
  char v39;
  uint64_t v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  if (*a2 == a2[1])
  {
    v15 = 0x100000;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0x100000;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0x100000;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0x100000;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0x100000;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    LODWORD(v40) = 0;
    BYTE4(v40) = 0;
    v41 = 0;
    KB::String::operator=(a1 + 88, (KB::String *)&v15);
    KB::String::operator=(a1 + 120, (KB::String *)&v20);
    KB::String::operator=(a1 + 152, (KB::String *)&v25);
    KB::String::operator=(a1 + 184, (KB::String *)&v30);
    KB::String::operator=(a1 + 216, (KB::String *)&v35);
    v12 = v38;
    *(_QWORD *)(a1 + 248) = v40;
    *(_DWORD *)(a1 + 256) = v41;
    if (v12 && v37 == 1)
      free(v12);
    if (v33 && v32 == 1)
      free(v33);
    if (v28 && v27 == 1)
      free(v28);
    if (v23 && v22 == 1)
      free(v23);
    if (v18 && v17 == 1)
      free(v18);
    v13 = *(const void **)(a1 + 264);
    if (v13)
      CFRelease(v13);
    result = 0;
    *(_QWORD *)(a1 + 264) = 0;
  }
  else
  {
    if (a3)
      v5 = "Siri-TextInput-Dynamic.";
    else
      v5 = "TextInput-Dynamic.";
    KB::String::String((KB::String *)&v15, v5);
    KB::String::append((unsigned __int16 *)&v15, (const KB::String *)v4);
    KB::cf_string_impl<KB::String>(&v14, (unsigned __int16 *)&v15);
    v6 = v14;
    View = LXLexiconRepositoryCreateView();
    v8 = *(const void **)(a1 + 264);
    if (v8)
      CFRelease(v8);
    *(_QWORD *)(a1 + 264) = View;
    if (v6)
      CFRelease(v6);
    KB::String::operator=((KB::String *)(a1 + 88), (KB::String *)v4);
    KB::String::operator=((KB::String *)(a1 + 120), (KB::String *)(v4 + 32));
    KB::String::operator=((KB::String *)(a1 + 152), (KB::String *)(v4 + 64));
    KB::String::operator=((KB::String *)(a1 + 184), (KB::String *)(v4 + 96));
    KB::String::operator=((KB::String *)(a1 + 216), (KB::String *)(v4 + 128));
    v9 = *(_QWORD *)(v4 + 160);
    *(_DWORD *)(a1 + 256) = *(_DWORD *)(v4 + 168);
    *(_QWORD *)(a1 + 248) = v9;
    if (v18 && v17 == 1)
      free(v18);
    v10 = *(const void **)(a1 + 264);
    if (v10)
    {
      CFRetain(v10);
      CFRelease(v10);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t KB::DynamicDictionarySingle::get_lexicon_info(KB::DynamicDictionarySingle *this)
{
  return (uint64_t)this + 88;
}

void KB::DynamicDictionarySingle::get_word_with_string(KB::DynamicDictionarySingle *this@<X0>, const KB::String *a2@<X1>, KB::Word *a3@<X8>)
{
  int v5;
  const void *v6;
  const void *v12;
  _OWORD v13[3];
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  _BYTE v27[24];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  (*(void (**)(KB::DynamicDictionarySingle *, _QWORD))(*(_QWORD *)this + 88))(this, 0);
  v5 = *(_DWORD *)((*(uint64_t (**)(KB::DynamicDictionarySingle *, _QWORD))(*(_QWORD *)this + 48))(this, 0)+ 160);
  KB::entry_from_lexicon(&v12);
  v6 = v12;
  if (!v12)
  {
    memset(v13, 0, sizeof(v13));
    v16 = 0u;
    v17 = 0u;
    v21 = 0;
    v23 = 0u;
    v24 = 0u;
    v25 = 0;
    *(_OWORD *)&v27[8] = 0u;
    WORD1(v13[0]) = 16;
    BYTE6(v13[0]) = 0;
    v14 = 0x3F80000000000000;
    v15 = 1065353216;
    WORD1(v16) = 16;
    BYTE6(v16) = 0;
    __asm { FMOV            V1.2S, #1.0 }
    v18 = _D1;
    v22 = 0;
    v20 = 0u;
    v19 = 0u;
    WORD1(v23) = 16;
    BYTE6(v23) = 0;
    v26 = 0u;
    *(_OWORD *)v27 = 0u;
    *(_DWORD *)&v27[16] = 1065353216;
    goto LABEL_5;
  }
  KB::Word::Word((uint64_t)v13, (uint64_t)v12, v5);
  CFRelease(v6);
  if (!LOWORD(v13[0]))
  {
LABEL_5:
    KB::DynamicDictionary::word_from_transient_lexicon_with_string(this, (uint64_t)a3);
    goto LABEL_6;
  }
  KB::Word::Word(a3, (const KB::Word *)v13);
LABEL_6:
  KB::Word::~Word((KB::Word *)v13);
}

uint64_t KB::DynamicDictionarySingle::get_user_frequency(KB::DynamicDictionarySingle *this, _LXLexicon *a2)
{
  const void *v3;
  unsigned int UsageCount;
  uint64_t v5;
  const void *v7;

  (*(void (**)(KB::DynamicDictionarySingle *, _QWORD))(*(_QWORD *)this + 88))(this, 0);
  KB::DynamicDictionary::entry_matching_string(a2, &v7);
  v3 = v7;
  if (!v7)
    return 0;
  UsageCount = LXEntryGetUsageCount();
  if (UsageCount >= 0x7FFFFFFF)
    v5 = 0x7FFFFFFFLL;
  else
    v5 = UsageCount;
  CFRelease(v3);
  return v5;
}

uint64_t KB::DynamicDictionarySingle::get_total_usage_count(KB::DynamicDictionarySingle *this)
{
  uint64_t RootCursor;
  const void *v3;
  int v4;
  int v5;
  uint64_t v6;
  const void *v7;
  int v8;
  int v9;
  uint64_t v10;
  const void *v11;
  int v12;
  int v13;
  _QWORD **v14;
  _QWORD *v15;
  uint64_t v16;
  const void *v17;
  int v18;
  int v19;
  uint64_t v20;
  const void *v21;
  int v22;
  int v23;
  uint64_t v24;
  const void *v25;
  int v26;
  int v27;

  if (*((_QWORD *)this + 33) && (RootCursor = LXLexiconCreateRootCursor()) != 0)
  {
    v3 = (const void *)RootCursor;
    v4 = LXCursorUsageCountRecursive();
    v5 = v4 & ~(v4 >> 31);
    CFRelease(v3);
  }
  else
  {
    v5 = 0;
  }
  if (*((_QWORD *)this + 1) && (v6 = LXLexiconCreateRootCursor()) != 0)
  {
    v7 = (const void *)v6;
    v8 = LXCursorUsageCountRecursive();
    v9 = v8 & ~(v8 >> 31);
    CFRelease(v7);
  }
  else
  {
    v9 = 0;
  }
  if (*((_QWORD *)this + 2) && (v10 = LXLexiconCreateRootCursor()) != 0)
  {
    v11 = (const void *)v10;
    v12 = LXCursorUsageCountRecursive();
    v13 = v12 & ~(v12 >> 31);
    CFRelease(v11);
  }
  else
  {
    v13 = 0;
  }
  v14 = (_QWORD **)*((_QWORD *)this + 3);
  if (v14 && (v15 = *v14) != 0 && *v15 && (v16 = LXLexiconCreateRootCursor()) != 0)
  {
    v17 = (const void *)v16;
    v18 = LXCursorUsageCountRecursive();
    v19 = v18 & ~(v18 >> 31);
    CFRelease(v17);
  }
  else
  {
    v19 = 0;
  }
  if (KB::DynamicDictionary::named_entity_lexicon(this) && (v20 = LXLexiconCreateRootCursor()) != 0)
  {
    v21 = (const void *)v20;
    v22 = LXCursorUsageCountRecursive();
    v23 = v22 & ~(v22 >> 31);
    CFRelease(v21);
  }
  else
  {
    v23 = 0;
  }
  if (TITransientLexiconManagerGetActiveSupplementalLexiconWords() && (v24 = LXLexiconCreateRootCursor()) != 0)
  {
    v25 = (const void *)v24;
    v26 = LXCursorUsageCountRecursive();
    v27 = v26 & ~(v26 >> 31);
    CFRelease(v25);
  }
  else
  {
    v27 = 0;
  }
  return (v9 + v5 + v13 + v19 + v23 + v27);
}

uint64_t KB::DynamicDictionarySingle::get_persistent_custom_trie_count(KB::DynamicDictionarySingle *this)
{
  return 1;
}

uint64_t KB::DynamicDictionarySingle::get_persistent_custom_trie(KB::DynamicDictionarySingle *this)
{
  return *((_QWORD *)this + 33);
}

uint64_t KB::DynamicDictionarySingle::get_persistent_custom_trie_for_locale(uint64_t a1)
{
  return *(_QWORD *)(a1 + 264);
}

void KB::DynamicDictionarySingle::do_enumerate_entries(KB::DynamicDictionary *a1, uint64_t a2)
{
  uint64_t ActiveSupplementalLexiconWords;
  uint64_t v4;
  const void *RootCursor;
  const void *v6;
  const void *v7;
  const void *v8;
  _QWORD **v9;
  _QWORD *v10;
  const void *v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(uint64_t, uint64_t);
  void *v17;
  uint64_t *v18;
  int v19;

  v13 = a2;
  ActiveSupplementalLexiconWords = TITransientLexiconManagerGetActiveSupplementalLexiconWords();
  v4 = MEMORY[0x1E0C809B0];
  if (ActiveSupplementalLexiconWords)
  {
    RootCursor = (const void *)LXLexiconCreateRootCursor();
    v14 = v4;
    v15 = 0x40000000;
    v16 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    v17 = &__block_descriptor_tmp_12;
    v18 = &v13;
    v19 = 5;
    LXCursorEnumerateEntriesRecursively();
    if (RootCursor)
      CFRelease(RootCursor);
  }
  if ((*(uint64_t (**)(KB::DynamicDictionary *, _QWORD))(*(_QWORD *)a1 + 88))(a1, 0))
  {
    v6 = (const void *)LXLexiconCreateRootCursor();
    v14 = v4;
    v15 = 0x40000000;
    v16 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    v17 = &__block_descriptor_tmp_12;
    v18 = &v13;
    v19 = 0;
    LXCursorEnumerateEntriesRecursively();
    if (v6)
      CFRelease(v6);
  }
  if (*((_QWORD *)a1 + 1))
  {
    v7 = (const void *)LXLexiconCreateRootCursor();
    v14 = v4;
    v15 = 0x40000000;
    v16 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    v17 = &__block_descriptor_tmp_12;
    v18 = &v13;
    v19 = 1;
    LXCursorEnumerateEntriesRecursively();
    if (v7)
      CFRelease(v7);
  }
  if (*((_QWORD *)a1 + 2))
  {
    v8 = (const void *)LXLexiconCreateRootCursor();
    v14 = v4;
    v15 = 0x40000000;
    v16 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    v17 = &__block_descriptor_tmp_12;
    v18 = &v13;
    v19 = 2;
    LXCursorEnumerateEntriesRecursively();
    if (v8)
      CFRelease(v8);
  }
  v9 = (_QWORD **)*((_QWORD *)a1 + 3);
  if (v9)
  {
    v10 = *v9;
    if (v10)
    {
      if (*v10)
      {
        v11 = (const void *)LXLexiconCreateRootCursor();
        v14 = v4;
        v15 = 0x40000000;
        v16 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
        v17 = &__block_descriptor_tmp_12;
        v18 = &v13;
        v19 = 3;
        LXCursorEnumerateEntriesRecursively();
        if (v11)
          CFRelease(v11);
      }
    }
  }
  if (KB::DynamicDictionary::named_entity_lexicon(a1))
  {
    v12 = (const void *)LXLexiconCreateRootCursor();
    v14 = v4;
    v15 = 0x40000000;
    v16 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    v17 = &__block_descriptor_tmp_12;
    v18 = &v13;
    v19 = 4;
    LXCursorEnumerateEntriesRecursively();
    if (v12)
      CFRelease(v12);
  }
}

uint64_t ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 32) + 16))(**(_QWORD **)(a1 + 32), a2, *(unsigned int *)(a1 + 40));
}

void KB::DynamicDictionary::create_single(_QWORD *a1@<X8>)
{
  KB::DynamicDictionarySingle *v3;
  uint64_t v4;

  v3 = (KB::DynamicDictionarySingle *)operator new();
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  KB::DynamicDictionarySingle::DynamicDictionarySingle(v3);
  *a1 = v4;
}

double KB::DynamicDictionarySingle::DynamicDictionarySingle(KB::DynamicDictionarySingle *this)
{
  double result;

  result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 14) = 0x100000;
  *((_WORD *)this + 30) = 0;
  *((_BYTE *)this + 62) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_BYTE *)this + 72) = 0;
  *(_QWORD *)this = &off_1EA0FB2D8;
  *((_DWORD *)this + 22) = 0x100000;
  *((_WORD *)this + 46) = 0;
  *((_BYTE *)this + 94) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 30) = 0x100000;
  *((_WORD *)this + 62) = 0;
  *((_BYTE *)this + 126) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_BYTE *)this + 136) = 0;
  *((_DWORD *)this + 38) = 0x100000;
  *((_WORD *)this + 78) = 0;
  *((_BYTE *)this + 158) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_BYTE *)this + 168) = 0;
  *((_DWORD *)this + 46) = 0x100000;
  *((_WORD *)this + 94) = 0;
  *((_BYTE *)this + 190) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_BYTE *)this + 200) = 0;
  *((_DWORD *)this + 54) = 0x100000;
  *((_WORD *)this + 110) = 0;
  *((_BYTE *)this + 222) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_BYTE *)this + 232) = 0;
  *((_QWORD *)this + 33) = 0;
  *((_DWORD *)this + 68) = 0x100000;
  *((_WORD *)this + 138) = 0;
  *((_BYTE *)this + 278) = 0;
  *((_QWORD *)this + 35) = 0;
  *((_BYTE *)this + 288) = 0;
  return result;
}

void KB::DynamicDictionarySingle::create(_QWORD *a1@<X8>)
{
  KB::DynamicDictionarySingle *v3;
  uint64_t v4;

  v3 = (KB::DynamicDictionarySingle *)operator new();
  *(_OWORD *)v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  KB::DynamicDictionarySingle::DynamicDictionarySingle(v3);
  *a1 = v4;
}

double KB::DynamicDictionary::create_container@<D0>(uint64_t *a1@<X8>)
{
  return KB::DynamicDictionaryContainer::create(a1);
}

double KB::DynamicDictionaryContainer::create@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v3;
  double result;

  v3 = operator new();
  result = 0.0;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 112) = 0u;
  *(_OWORD *)(v3 + 128) = 0u;
  *(_OWORD *)(v3 + 144) = 0u;
  *(_OWORD *)(v3 + 160) = 0u;
  *(_OWORD *)(v3 + 176) = 0u;
  *(_OWORD *)(v3 + 192) = 0u;
  *(_OWORD *)(v3 + 208) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_WORD *)(v3 + 56) = 0;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_WORD *)(v3 + 58) = 16;
  *(_BYTE *)(v3 + 62) = 0;
  *(_BYTE *)(v3 + 72) = 0;
  *(_QWORD *)v3 = &off_1EA0FB258;
  *(_WORD *)(v3 + 136) = 0;
  *(_OWORD *)(v3 + 120) = 0u;
  *(_OWORD *)(v3 + 104) = 0u;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_WORD *)(v3 + 138) = 16;
  *(_BYTE *)(v3 + 142) = 0;
  *(_BYTE *)(v3 + 152) = 0;
  *(_QWORD *)(v3 + 216) = 0;
  *(_QWORD *)(v3 + 224) = 0;
  *(_OWORD *)(v3 + 200) = 0u;
  *(_OWORD *)(v3 + 184) = 0u;
  *(_OWORD *)(v3 + 168) = 0u;
  *(_DWORD *)(v3 + 224) = 1065353216;
  *a1 = v3;
  return result;
}

uint64_t KB::DynamicDictionary::address_book_trie(KB::DynamicDictionary *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t KB::DynamicDictionary::app_trie(KB::DynamicDictionary *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t KB::DynamicDictionary::user_dictionary_trie(KB::DynamicDictionary *this)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = (uint64_t *)*((_QWORD *)this + 3);
  if (v1 && (v2 = *v1) != 0)
    return *(_QWORD *)v2;
  else
    return 0;
}

uint64_t KB::DynamicDictionary::user_dictionary(KB::DynamicDictionary *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 3);
  if (v1)
    return *(_QWORD *)v1;
  else
    return 0;
}

uint64_t KB::DynamicDictionary::named_entity_phrase_lexicon(KB::DynamicDictionary *this)
{
  uint64_t v2;
  const char *v3;

  if ((*(unsigned int (**)(KB::DynamicDictionary *))(*(_QWORD *)this + 32))(this))
  {
    v2 = (*(uint64_t (**)(KB::DynamicDictionary *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
    if (*(_WORD *)v2)
    {
      if (*(_QWORD *)(v2 + 8))
        v3 = *(const char **)(v2 + 8);
      else
        v3 = (const char *)(v2 + 16);
    }
    else
    {
      v3 = "";
    }
  }
  else
  {
    v3 = 0;
  }
  return TITransientLexiconManagerGetNamedEntityPhrasesForLocale((uint64_t)v3);
}

unsigned __int16 *KB::DynamicDictionary::dynamic_lexicon_name_with_siri_mode@<X0>(KB::DynamicDictionary *this@<X0>, const KB::String *a2@<X1>, KB::String *a3@<X8>)
{
  const char *v4;
  unsigned __int16 *v5;

  if ((_DWORD)a2)
    v4 = "Siri-TextInput-Dynamic.";
  else
    v4 = "TextInput-Dynamic.";
  v5 = (unsigned __int16 *)KB::String::String(a3, v4);
  return KB::String::append(v5, this);
}

unsigned __int16 *KB::DynamicDictionary::dynamic_lexicon_name@<X0>(KB::DynamicDictionary *this@<X0>, KB::String *a2@<X8>)
{
  unsigned __int16 *v4;

  v4 = (unsigned __int16 *)KB::String::String(a2, "TextInput-Dynamic.");
  return KB::String::append(v4, this);
}

void KB::DynamicDictionary::load_address_book(KB::DynamicDictionary *this)
{
  KB::String *v2;
  const char *v3;
  int v4;
  __int16 v5;
  char v6;
  void *v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v4 = 0x100000;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if (!(*(unsigned int (**)(KB::DynamicDictionary *))(*(_QWORD *)this + 32))(this)
    || ((v2 = (KB::String *)(*(uint64_t (**)(KB::DynamicDictionary *, _QWORD))(*(_QWORD *)this + 48))(this, 0), KB::String::operator=((KB::String *)&v4, v2), v7)? (v3 = (const char *)v7): (v3 = &v8), !(_WORD)v4))
  {
    v3 = "";
  }
  *((_QWORD *)this + 1) = TITransientLexiconManagerGetAddressBookLexiconForLocale((uint64_t)v3);
  if (v7)
  {
    if (v6 == 1)
      free(v7);
  }
}

void KB::DynamicDictionary::load_app_names(KB::DynamicDictionary *this)
{
  KB::String *v2;
  const char *v3;
  int v4;
  __int16 v5;
  char v6;
  void *v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v4 = 0x100000;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if (!(*(unsigned int (**)(KB::DynamicDictionary *))(*(_QWORD *)this + 32))(this)
    || ((v2 = (KB::String *)(*(uint64_t (**)(KB::DynamicDictionary *, _QWORD))(*(_QWORD *)this + 48))(this, 0), KB::String::operator=((KB::String *)&v4, v2), v7)? (v3 = (const char *)v7): (v3 = &v8), !(_WORD)v4))
  {
    v3 = "";
  }
  *((_QWORD *)this + 2) = TITransientLexiconManagerGetAppNameLexiconForLocale((uint64_t)v3);
  if (v7)
  {
    if (v6 == 1)
      free(v7);
  }
}

BOOL KB::DynamicDictionary::address_book_contains(KB::DynamicDictionary *this, const KB::String *a2)
{
  const void *RootCursor;
  const void *v3;
  _BOOL8 v4;

  if (!*((_QWORD *)this + 1))
    return 0;
  RootCursor = (const void *)LXLexiconCreateRootCursor();
  v3 = (const void *)LXCursorCreateByAdvancingWithUTF8();
  if (RootCursor)
    CFRelease(RootCursor);
  v4 = LXCursorHasEntries() != 0;
  if (v3)
    CFRelease(v3);
  return v4;
}

BOOL KB::DynamicDictionary::app_names_contains(KB::DynamicDictionary *this, const KB::String *a2)
{
  const void *RootCursor;
  const void *v3;
  _BOOL8 v4;

  if (!*((_QWORD *)this + 2))
    return 0;
  RootCursor = (const void *)LXLexiconCreateRootCursor();
  v3 = (const void *)LXCursorCreateByAdvancingWithUTF8();
  if (RootCursor)
    CFRelease(RootCursor);
  v4 = LXCursorHasEntries() != 0;
  if (v3)
    CFRelease(v3);
  return v4;
}

uint64_t KB::DynamicDictionary::filter_phrase(KB::DynamicDictionary *this, const __CFString *a2, const KB::StaticDictionary *a3, int a4)
{
  const KB::String *v6;
  BOOL v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  unsigned int v10;
  const KB::String *v11;
  char *v12;
  char *v13;
  BOOL v14;
  uint64_t v15;
  unsigned __int16 *v17;
  unsigned __int16 *v18;
  char *v19;
  void *v20;
  char v21;
  unsigned __int16 **v22;
  void *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  KB::utf8_string(a2, (uint64_t)&v22);
  WORD2(v19) = 0;
  BYTE6(v19) = 0;
  v20 = " \t\n";
  LODWORD(v19) = 1048579;
  v21 = 0;
  KB::sbs_string_tokenize((unsigned __int16 *)&v22, (const KB::String *)&v19, &v17);
  if (v20)
    v7 = BYTE6(v19) == 1;
  else
    v7 = 0;
  if (v7)
    free(v20);
  if (v23 && BYTE6(v22) == 1)
    free(v23);
  v8 = v17;
  v9 = v18;
  if (v17 == v18)
  {
LABEL_28:
    v15 = 1;
    goto LABEL_34;
  }
  v10 = 0;
  while (1)
  {
    if (!v8[2])
    {
      KB::String::compute_length(v8);
      if (!v8[2])
        goto LABEL_27;
    }
    if (KB::string_has_numbers((KB *)v8, v6))
      goto LABEL_33;
    v10 += KB::string_has_letters((KB *)v8, v11);
    if (v10 > 3)
      goto LABEL_33;
    KB::StaticDictionary::candidates_for_string(a3, (const KB::String *)v8, 0, &v19);
    v12 = v19;
    v13 = (char *)v20;
    if (v19 == v20)
      goto LABEL_32;
    if (a4)
      break;
LABEL_26:
    v22 = (unsigned __int16 **)&v19;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v22);
LABEL_27:
    v8 += 16;
    if (v8 == v9)
      goto LABEL_28;
  }
  while (1)
  {
    if (v12[104] < 0 || !*((_DWORD *)v12 + 30))
      goto LABEL_25;
    KB::Word::capitalized_string((KB::Word *)v12, (uint64_t)&v22);
    if (&v22 == (unsigned __int16 ***)v8)
      break;
    v14 = KB::String::equal((KB::String *)&v22, (const KB::String *)v8, 1);
    if (v23 && BYTE6(v22) == 1)
      free(v23);
    if (v14)
      goto LABEL_32;
LABEL_25:
    v12 += 240;
    if (v12 == v13)
      goto LABEL_26;
  }
  if (v23 && BYTE6(v22) == 1)
    free(v23);
LABEL_32:
  v22 = (unsigned __int16 **)&v19;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v22);
LABEL_33:
  v15 = 0;
LABEL_34:
  v22 = &v17;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v22);
  return v15;
}

void KB::DynamicDictionary::retrieve_phrase_candidates(KB::DynamicDictionary *a1, unsigned __int16 *a2)
{
  uint64_t v3;
  uint64_t ActiveSupplementalLexiconPhrases;
  unsigned __int16 *v5;
  _BYTE *v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  _BYTE *v10;
  NSObject *v11;
  const char *v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  const void *v16;
  unsigned int v17;
  const void *v18;
  NSObject *v19;
  const char *v20;
  const char *v21;
  _BYTE buf[12];
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = KB::DynamicDictionary::named_entity_phrase_lexicon(a1);
  ActiveSupplementalLexiconPhrases = TITransientLexiconManagerGetActiveSupplementalLexiconPhrases();
  if (!(v3 | ActiveSupplementalLexiconPhrases))
    return;
  if (*((_QWORD *)a2 + 1))
    v5 = (unsigned __int16 *)*((_QWORD *)a2 + 1);
  else
    v5 = a2 + 8;
  v6 = (_BYTE *)*a2;
  if (!*a2)
    goto LABEL_16;
  v7 = *a2;
  v8 = v5;
  while (*v8 != 32)
  {
    ++v8;
    if (!--v7)
    {
      v8 = &v6[(_QWORD)v5];
      break;
    }
  }
  if ((_BYTE *)(v8 - (_BYTE *)v5) != v6)
    goto LABEL_27;
  if (*a2)
  {
    v9 = *a2;
    v10 = v5;
    while (*v10 != 45)
    {
      ++v10;
      if (!--v9)
      {
        v10 = &v6[(_QWORD)v5];
        break;
      }
    }
  }
  else
  {
LABEL_16:
    v10 = v5;
  }
  if ((_BYTE *)(v10 - (_BYTE *)v5) == v6)
  {
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    if (TICanLogMessageAtLevel_logLevel >= 2)
    {
      v11 = TIOSLogFacility();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v12 = (const char *)*((_QWORD *)a2 + 1);
        if (!v12)
          v12 = (const char *)(a2 + 8);
        if (!*a2)
          v12 = "";
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "retrieve_phrase_candidates";
        v23 = 2080;
        v24 = v12;
        v13 = "%s \"%s\" was filtered out from the list of phrase candidate words because it does not contain a space or hyphen";
        v14 = v11;
        v15 = 22;
LABEL_47:
        _os_log_debug_impl(&dword_1DA6F2000, v14, OS_LOG_TYPE_DEBUG, v13, buf, v15);
        return;
      }
    }
    return;
  }
LABEL_27:
  if (ActiveSupplementalLexiconPhrases)
  {
    KB::cf_string_impl<KB::String>((CFStringRef *)buf, a2);
    v16 = *(const void **)buf;
    LXLexiconEnumerateEntriesForString();
    if (v16)
      CFRelease(v16);
  }
  if (v3)
  {
    v17 = a2[2];
    if (!a2[2])
    {
      KB::String::compute_length(a2);
      v17 = a2[2];
    }
    if (v17 <= 3)
    {
      if (TICanLogMessageAtLevel_onceToken != -1)
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
      if (TICanLogMessageAtLevel_logLevel >= 2)
      {
        v19 = TIOSLogFacility();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          v20 = (const char *)*((_QWORD *)a2 + 1);
          if (!v20)
            v20 = (const char *)(a2 + 8);
          if (*a2)
            v21 = v20;
          else
            v21 = "";
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "retrieve_phrase_candidates";
          v23 = 2080;
          v24 = v21;
          v25 = 1024;
          v26 = 4;
          v13 = "%s \"%s\" was filtered out from the list of phrase candidate words because it's less than %u characters long";
          v14 = v19;
          v15 = 28;
          goto LABEL_47;
        }
      }
    }
    else
    {
      KB::cf_string_impl<KB::String>((CFStringRef *)buf, a2);
      v18 = *(const void **)buf;
      LXLexiconEnumerateEntriesForString();
      if (v18)
        CFRelease(v18);
    }
  }
}

void ___ZN2KB17DynamicDictionary26retrieve_phrase_candidatesERKNS_6StringERKNS_16StaticDictionaryEbRNSt3__16vectorINS_4WordENS7_9allocatorIS9_EEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[2];
  _QWORD *v14;
  unint64_t v15;
  uint64_t *v16;
  _BYTE v17[200];
  _QWORD v18[4];
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  KB::Word::Word((uint64_t)v17, a2, 0);
  TILXEntryGetSupplementalItemIdentifiers((uint64_t)v13);
  v19 = (int)v16;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(v18, v14);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)v13);
  v3 = *(uint64_t **)(a1 + 32);
  v4 = v3[1];
  v5 = v3[2];
  if (v4 >= v5)
  {
    v7 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v4 - *v3) >> 4);
    if (v7 + 1 > 0x111111111111111)
      abort();
    v8 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v5 - *v3) >> 4);
    v9 = 2 * v8;
    if (2 * v8 <= v7 + 1)
      v9 = v7 + 1;
    if (v8 >= 0x88888888888888)
      v10 = 0x111111111111111;
    else
      v10 = v9;
    v16 = v3 + 2;
    if (v10)
      v10 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v10);
    else
      v11 = 0;
    v12 = v10 + 240 * v7;
    v13[0] = v10;
    v13[1] = v12;
    v15 = v10 + 240 * v11;
    KB::Word::Word(v12, (uint64_t)v17);
    v14 = (_QWORD *)(v12 + 240);
    std::vector<KB::Word>::__swap_out_circular_buffer(v3, v13);
    v6 = v3[1];
    std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)v13);
  }
  else
  {
    v6 = KB::Word::Word(v4, (uint64_t)v17) + 240;
  }
  v3[1] = v6;
  KB::Word::~Word((KB::Word *)v17);
}

void ___ZN2KB17DynamicDictionary26retrieve_phrase_candidatesERKNS_6StringERKNS_16StaticDictionaryEbRNSt3__16vectorINS_4WordENS7_9allocatorIS9_EEEE_block_invoke_4(uint64_t a1, uint64_t a2)
{
  __CFString *v3;
  NSObject *v4;
  const char *v5;
  uint64_t v6;
  _WORD v7[3];
  char v8;
  void *v9;
  uint64_t v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v6 = a2;
  v3 = (__CFString *)LXEntryCopyString();
  if (KB::DynamicDictionary::filter_phrase((KB::DynamicDictionary *)v3, v3, *(const KB::StaticDictionary **)(a1 + 40), *(unsigned __int8 *)(a1 + 56)))
  {
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    if (TICanLogMessageAtLevel_logLevel >= 2)
    {
      v4 = TIOSLogFacility();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        KB::utf8_string(v3, (uint64_t)v7);
        v5 = (const char *)v9;
        if (!v9)
          v5 = (const char *)&v10;
        if (!v7[0])
          v5 = "";
        *(_DWORD *)buf = 136315394;
        v12 = "retrieve_phrase_candidates_block_invoke";
        v13 = 2080;
        v14 = v5;
        _os_log_debug_impl(&dword_1DA6F2000, v4, OS_LOG_TYPE_DEBUG, "%s \"%s\" was filtered out from the list of phrase candidate words", buf, 0x16u);
        if (v9 && v8 == 1)
          free(v9);
      }
    }
  }
  else
  {
    std::vector<KB::Word>::emplace_back<_LXEntry const*&,unsigned int const&>(*(uint64_t **)(a1 + 48), &v6, &kTILexiconIDUNK);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) - 136) |= 0x100u;
  }
  if (v3)
    CFRelease(v3);
}

uint64_t std::vector<KB::Word>::emplace_back<_LXEntry const*&,unsigned int const&>(uint64_t *a1, uint64_t *a2, int *a3)
{
  uint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t result;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t *v20;

  v6 = a1 + 2;
  v7 = a1[2];
  v8 = a1[1];
  if (v8 >= v7)
  {
    v11 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v8 - *a1) >> 4);
    if (v11 + 1 > 0x111111111111111)
      abort();
    v12 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v7 - *a1) >> 4);
    v13 = 2 * v12;
    if (2 * v12 <= v11 + 1)
      v13 = v11 + 1;
    if (v12 >= 0x88888888888888)
      v14 = 0x111111111111111;
    else
      v14 = v13;
    v20 = v6;
    if (v14)
      v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v14);
    else
      v15 = 0;
    v16 = v14;
    v17 = v14 + 240 * v11;
    v19 = v14 + 240 * v15;
    KB::Word::Word(v17, *a2, *a3);
    v18 = v17 + 240;
    std::vector<KB::Word>::__swap_out_circular_buffer(a1, &v16);
    v10 = a1[1];
    result = std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v16);
  }
  else
  {
    result = KB::Word::Word(v8, *a2, *a3);
    v10 = result + 240;
  }
  a1[1] = v10;
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(unint64_t a1)
{
  if (a1 >= 0x111111111111112)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(240 * a1);
}

uint64_t std::vector<KB::Word>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 240;
    result = KB::Word::Word(result - 240, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<KB::Word>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 240;
    KB::Word::~Word((KB::Word *)(i - 240));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void KB::DynamicDictionary::unload_user_dictionary(KB::DynamicDictionary *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

double KB::DynamicDictionary::word_from_transient_lexicon_with_id@<D0>(KB::DynamicDictionary *this@<X0>, TITokenID a2@<0:X1>, uint64_t a3@<X8>)
{
  unsigned int lexicon_id;
  uint64_t v6;
  const void *v7;
  int v8;
  double result;
  uint64_t v10;
  const void *v11;
  unsigned int v12;
  uint64_t v13;
  const void *v14;
  _QWORD **v15;
  _QWORD *v16;
  uint64_t v17;
  const void *v18;
  uint64_t v19;
  const void *v20;
  KB::Word *v21;
  _BYTE v22[16];
  _QWORD *v23;
  int v24;

  lexicon_id = a2.lexicon_id;
  if (TITransientLexiconManagerGetActiveSupplementalLexiconWords() && (v6 = LXLexiconCopyEntryForTokenID()) != 0)
  {
    v7 = (const void *)v6;
    KB::Word::Word(a3, v6, lexicon_id);
    TILXEntryGetSupplementalItemIdentifiers((uint64_t)v22);
    if ((_BYTE *)(a3 + 200) != v22)
    {
      *(_DWORD *)(a3 + 232) = v24;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((_QWORD *)(a3 + 200), v23);
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)v22);
    if (TILXEntryIsPartOfHyphenatedWord())
      v8 = 16;
    else
      v8 = 0;
    *(_DWORD *)(a3 + 104) = *(_DWORD *)(a3 + 104) & 0xFFFFFFEF | v8;
    CFRelease(v7);
  }
  else
  {
    if (*((_QWORD *)this + 1) && (v10 = LXLexiconCopyEntryForTokenID()) != 0)
    {
      v11 = (const void *)v10;
      KB::Word::Word(a3, v10, lexicon_id);
      CFRelease(v11);
    }
    else
    {
      *(_OWORD *)(a3 + 208) = 0u;
      *(_OWORD *)(a3 + 224) = 0u;
      *(_OWORD *)(a3 + 176) = 0u;
      *(_OWORD *)(a3 + 192) = 0u;
      *(_OWORD *)(a3 + 144) = 0u;
      *(_OWORD *)(a3 + 160) = 0u;
      *(_OWORD *)(a3 + 112) = 0u;
      *(_OWORD *)(a3 + 128) = 0u;
      *(_OWORD *)(a3 + 80) = 0u;
      *(_OWORD *)(a3 + 96) = 0u;
      *(_OWORD *)(a3 + 48) = 0u;
      *(_OWORD *)(a3 + 64) = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      *(_OWORD *)(a3 + 32) = 0u;
      *(_OWORD *)a3 = 0u;
      result = KB::Word::Word((KB::Word *)a3);
    }
    if (*(_WORD *)a3)
    {
      v12 = *(_DWORD *)(a3 + 104) | 0x20000;
    }
    else
    {
      KB::Word::~Word((KB::Word *)a3);
      if (*((_QWORD *)this + 2) && (v13 = LXLexiconCopyEntryForTokenID()) != 0)
      {
        v14 = (const void *)v13;
        KB::Word::Word(a3, v13, lexicon_id);
        CFRelease(v14);
      }
      else
      {
        *(_OWORD *)(a3 + 208) = 0u;
        *(_OWORD *)(a3 + 224) = 0u;
        *(_OWORD *)(a3 + 176) = 0u;
        *(_OWORD *)(a3 + 192) = 0u;
        *(_OWORD *)(a3 + 144) = 0u;
        *(_OWORD *)(a3 + 160) = 0u;
        *(_OWORD *)(a3 + 112) = 0u;
        *(_OWORD *)(a3 + 128) = 0u;
        *(_OWORD *)(a3 + 80) = 0u;
        *(_OWORD *)(a3 + 96) = 0u;
        *(_OWORD *)(a3 + 48) = 0u;
        *(_OWORD *)(a3 + 64) = 0u;
        *(_OWORD *)(a3 + 16) = 0u;
        *(_OWORD *)(a3 + 32) = 0u;
        *(_OWORD *)a3 = 0u;
        result = KB::Word::Word((KB::Word *)a3);
      }
      if (*(_WORD *)a3)
      {
        v12 = *(_DWORD *)(a3 + 104) | 0x80000000;
      }
      else
      {
        KB::Word::~Word((KB::Word *)a3);
        v15 = (_QWORD **)*((_QWORD *)this + 3);
        if (v15 && (v16 = *v15) != 0 && *v16 && (v17 = LXLexiconCopyEntryForTokenID()) != 0)
        {
          v18 = (const void *)v17;
          KB::Word::Word(a3, v17, lexicon_id);
          CFRelease(v18);
        }
        else
        {
          *(_OWORD *)(a3 + 208) = 0u;
          *(_OWORD *)(a3 + 224) = 0u;
          *(_OWORD *)(a3 + 176) = 0u;
          *(_OWORD *)(a3 + 192) = 0u;
          *(_OWORD *)(a3 + 144) = 0u;
          *(_OWORD *)(a3 + 160) = 0u;
          *(_OWORD *)(a3 + 112) = 0u;
          *(_OWORD *)(a3 + 128) = 0u;
          *(_OWORD *)(a3 + 80) = 0u;
          *(_OWORD *)(a3 + 96) = 0u;
          *(_OWORD *)(a3 + 48) = 0u;
          *(_OWORD *)(a3 + 64) = 0u;
          *(_OWORD *)(a3 + 16) = 0u;
          *(_OWORD *)(a3 + 32) = 0u;
          *(_OWORD *)a3 = 0u;
          result = KB::Word::Word((KB::Word *)a3);
        }
        if (*(_WORD *)a3)
        {
          v12 = *(_DWORD *)(a3 + 104) | 0x10000;
        }
        else
        {
          KB::Word::~Word((KB::Word *)a3);
          if (KB::DynamicDictionary::named_entity_lexicon(this) && (v19 = LXLexiconCopyEntryForTokenID()) != 0)
          {
            v20 = (const void *)v19;
            KB::Word::Word(a3, v19, lexicon_id);
            CFRelease(v20);
          }
          else
          {
            *(_OWORD *)(a3 + 208) = 0u;
            *(_OWORD *)(a3 + 224) = 0u;
            *(_OWORD *)(a3 + 176) = 0u;
            *(_OWORD *)(a3 + 192) = 0u;
            *(_OWORD *)(a3 + 144) = 0u;
            *(_OWORD *)(a3 + 160) = 0u;
            *(_OWORD *)(a3 + 112) = 0u;
            *(_OWORD *)(a3 + 128) = 0u;
            *(_OWORD *)(a3 + 80) = 0u;
            *(_OWORD *)(a3 + 96) = 0u;
            *(_OWORD *)(a3 + 48) = 0u;
            *(_OWORD *)(a3 + 64) = 0u;
            *(_OWORD *)(a3 + 16) = 0u;
            *(_OWORD *)(a3 + 32) = 0u;
            *(_OWORD *)a3 = 0u;
            result = KB::Word::Word((KB::Word *)a3);
          }
          if (!*(_WORD *)a3)
          {
            KB::Word::~Word((KB::Word *)a3);
            *(_OWORD *)(a3 + 208) = 0u;
            *(_OWORD *)(a3 + 224) = 0u;
            *(_OWORD *)(a3 + 176) = 0u;
            *(_OWORD *)(a3 + 192) = 0u;
            *(_OWORD *)(a3 + 144) = 0u;
            *(_OWORD *)(a3 + 160) = 0u;
            *(_OWORD *)(a3 + 112) = 0u;
            *(_OWORD *)(a3 + 128) = 0u;
            *(_OWORD *)(a3 + 80) = 0u;
            *(_OWORD *)(a3 + 96) = 0u;
            *(_OWORD *)(a3 + 48) = 0u;
            *(_OWORD *)(a3 + 64) = 0u;
            *(_OWORD *)(a3 + 16) = 0u;
            *(_OWORD *)(a3 + 32) = 0u;
            *(_OWORD *)a3 = 0u;
            return KB::Word::Word(v21);
          }
          v12 = *(_DWORD *)(a3 + 104) | 0x100;
        }
      }
    }
    *(_DWORD *)(a3 + 104) = v12;
  }
  return result;
}

uint64_t KB::DynamicDictionary::is_word_in_supplemental_lexicon(KB::DynamicDictionary *this, const KB::String *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v11;
  _OWORD v12[3];
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int128 v25;
  _BYTE v26[24];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!TITransientLexiconManagerGetActiveSupplementalLexiconWords())
    return 0;
  v3 = *(_DWORD *)((*(uint64_t (**)(KB::DynamicDictionary *, _QWORD))(*(_QWORD *)this + 48))(this, 0) + 160);
  KB::entry_from_lexicon(&v11);
  v4 = v11;
  if (v11)
  {
    KB::Word::Word((uint64_t)v12, v11, v3);
    CFRelease((CFTypeRef)v4);
    v4 = LOWORD(v12[0]) != 0;
  }
  else
  {
    memset(v12, 0, sizeof(v12));
    v15 = 0u;
    v16 = 0u;
    v20 = 0;
    v22 = 0u;
    v23 = 0u;
    v24 = 0;
    *(_OWORD *)&v26[8] = 0u;
    WORD1(v12[0]) = 16;
    BYTE6(v12[0]) = 0;
    v13 = 0x3F80000000000000;
    WORD1(v15) = 16;
    WORD1(v22) = 16;
    v14 = 1065353216;
    BYTE6(v15) = 0;
    __asm { FMOV            V1.2S, #1.0 }
    v17 = _D1;
    v21 = 0;
    v19 = 0u;
    v18 = 0u;
    BYTE6(v22) = 0;
    v25 = 0u;
    *(_OWORD *)v26 = 0u;
    *(_DWORD *)&v26[16] = 1065353216;
  }
  KB::Word::~Word((KB::Word *)v12);
  return v4;
}

uint64_t KB::DynamicDictionaryContainer::lexicon_index(KB::DynamicDictionaryContainer *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  unint64_t v5;
  int *v6;
  int v7;

  if (a2 == -1)
    return 0;
  v2 = *((_QWORD *)this + 11);
  v3 = *((_QWORD *)this + 12) - v2;
  if (!v3)
    return -1;
  result = 0;
  v5 = v3 / 176;
  if (v5 <= 1)
    v5 = 1;
  v6 = (int *)(v2 + 160);
  while (1)
  {
    v7 = *v6;
    v6 += 44;
    if (v7 == a2)
      break;
    if (v5 == ++result)
      return -1;
  }
  return result;
}

void TIInlineCompletionEventDispatcher::TIInlineCompletionEventDispatcher(TIInlineCompletionEventDispatcher *this)
{
  *((_BYTE *)this + 48) = 0;
  *((_BYTE *)this + 56) = 0;
  *((_BYTE *)this + 88) = 0;
  *((_BYTE *)this + 96) = 0;
  *((_BYTE *)this + 128) = 0;
  *((_BYTE *)this + 136) = 0;
  *((_BYTE *)this + 140) = 0;
  *((_BYTE *)this + 144) = 0;
  *((_BYTE *)this + 472) = 0;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_BYTE *)this + 16) = 0;
}

{
  *((_BYTE *)this + 48) = 0;
  *((_BYTE *)this + 56) = 0;
  *((_BYTE *)this + 88) = 0;
  *((_BYTE *)this + 96) = 0;
  *((_BYTE *)this + 128) = 0;
  *((_BYTE *)this + 136) = 0;
  *((_BYTE *)this + 140) = 0;
  *((_BYTE *)this + 144) = 0;
  *((_BYTE *)this + 472) = 0;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_BYTE *)this + 16) = 0;
}

void TIInlineCompletionEventDispatcher::did_generate_no_completion(TIInlineCompletionEventDispatcher *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_weak_owners;
  unint64_t v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  void *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;

  std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(&v11, *(_QWORD *)this, *((std::__shared_weak_count **)this + 1));
  v1 = v12;
  if (v12)
  {
    p_shared_weak_owners = (unint64_t *)&v12->__shared_weak_owners_;
    do
      v3 = __ldxr(p_shared_weak_owners);
    while (__stxr(v3 + 1, p_shared_weak_owners));
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  analytics_queue();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  if (v1)
  {
    v7 = (unint64_t *)&v1->__shared_weak_owners_;
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v10 = v1;
    do
      v9 = __ldxr(v7);
    while (__stxr(v9 + 1, v7));
    TIDispatchAsync();
    std::__shared_weak_count::__release_weak(v1);
  }
  else
  {
    v10 = 0;
    TIDispatchAsync();
  }

  if (v10)
    std::__shared_weak_count::__release_weak(v10);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

_QWORD *std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(_QWORD *a1, uint64_t a2, std::__shared_weak_count *this)
{
  std::__shared_weak_count *v4;
  uint64_t v6;

  *a1 = a2;
  if (this)
  {
    v4 = std::__shared_weak_count::lock(this);
    a1[1] = v4;
    if (v4)
      return a1;
  }
  else
  {
    a1[1] = 0;
  }
  v6 = std::__throw_bad_weak_ptr[abi:nn180100]();
  return (_QWORD *)___ZN33TIInlineCompletionEventDispatcher26did_generate_no_completionEv_block_invoke(v6);
}

void ___ZN33TIInlineCompletionEventDispatcher26did_generate_no_completionEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  char v8;
  char v9;
  _BYTE v10[88];
  _BYTE v11[88];

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        v11[0] = 0;
        v11[80] = 0;
        v10[0] = 0;
        v10[80] = 0;
        v8 = 0;
        v9 = 0;
        TIInlineCompletionEventDispatcher::_dispatch_event(v5);
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v10);
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v11);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

uint64_t __copy_helper_block_a8_32c77_ZTSKZN33TIInlineCompletionEventDispatcher26did_generate_no_completionEvE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_a8_32c77_ZTSKZN33TIInlineCompletionEventDispatcher26did_generate_no_completionEvE3__0(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void TIInlineCompletionEventDispatcher::_dispatch_event(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  analytics_send_event_lazy();
  if (*(_BYTE *)(a1 + 48))
  {
    v2 = *(void **)(a1 + 24);
    if (v2 && *(_BYTE *)(a1 + 22) == 1)
      free(v2);
    *(_BYTE *)(a1 + 48) = 0;
  }
  if (*(_BYTE *)(a1 + 88))
  {
    v3 = *(void **)(a1 + 64);
    if (v3 && *(_BYTE *)(a1 + 62) == 1)
      free(v3);
    *(_BYTE *)(a1 + 88) = 0;
  }
  if (*(_BYTE *)(a1 + 128))
  {
    v4 = *(void **)(a1 + 104);
    if (v4 && *(_BYTE *)(a1 + 102) == 1)
      free(v4);
    *(_BYTE *)(a1 + 128) = 0;
  }
  if (*(_BYTE *)(a1 + 140))
    *(_BYTE *)(a1 + 140) = 0;
}

uint64_t std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 80))
  {
    if (*(_BYTE *)(a1 + 72))
      language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 64));
    if (*(char *)(a1 + 47) < 0)
      operator delete(*(void **)(a1 + 24));
    if (*(char *)(a1 + 23) < 0)
      operator delete(*(void **)a1);
  }
  return a1;
}

xpc_object_t ___ZN33TIInlineCompletionEventDispatcher15_dispatch_eventERKNSt3__18optionalI18TIInlineCompletionEES5_RKNS1_IN17language_modeling2v114CompletionStemEEE23TIICSuppressionModalityb_block_invoke(uint64_t a1)
{
  uint64_t v2;
  xpc_object_t v3;
  const char *v4;
  __int128 *v5;
  uint64_t v6;
  uint64_t v7;
  char **v8;
  int64_t v9;
  int64_t v10;
  uint64_t v11;
  int64_t v12;
  int64_t v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  const char *v19;
  const char *v20;
  id v21;
  const char *v22;
  const KB::String *v23;
  const char *v24;
  void *v25;
  const char *v26;
  __int128 v27;
  const char *v28;
  const char *v29;
  const char *v30;
  __int128 *v32;
  language_modeling::v1::CompletionStem *v33;
  __int128 v34;
  std::string::size_type v35;
  char *v36;
  char *v37;
  void *__p;
  std::string::size_type v39;
  unsigned __int8 v40;
  std::string v41;
  std::string __str;
  _BYTE v43[8];
  void *v44;
  _BYTE v45[8];
  void *v46;
  _BYTE v47[8];
  void *v48;
  _BYTE v49[8];
  void *v50;
  _BYTE v51[8];
  void *v52;
  char v53;
  _BYTE v54[8];
  void *v55;
  _BYTE v56[8];
  void *v57;
  _BYTE v58[8];
  void *v59;
  _BYTE v60[8];
  void *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = xpc_dictionary_create(0, 0, 0);
  v4 = (const char *)kTIICCompletionSourceNone;
  v5 = *(__int128 **)(a1 + 40);
  if (*((_BYTE *)v5 + 80) && (v6 = *(_QWORD *)(a1 + 48), *(_BYTE *)(v6 + 80)) && *(_BYTE *)(*(_QWORD *)(a1 + 56) + 8))
  {
    v7 = *(unsigned int *)(v6 + 56);
    if (v7 > 3)
      v8 = kTIICCompletionSourceUnknown;
    else
      v8 = off_1EA0FB600[v7];
    v4 = *v8;
    if (*((char *)v5 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)v5, *((_QWORD *)v5 + 1));
    }
    else
    {
      v27 = *v5;
      __str.__r_.__value_.__r.__words[2] = *((_QWORD *)v5 + 2);
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v27;
    }
    v9 = _bounded_word_count((uint64_t)&__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    v32 = *(__int128 **)(a1 + 48);
    if (!*((_BYTE *)v32 + 80))
      goto LABEL_137;
    v33 = *(language_modeling::v1::CompletionStem **)(a1 + 56);
    if (!*((_BYTE *)v33 + 8))
      goto LABEL_137;
    if (*((char *)v32 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)v32, *((_QWORD *)v32 + 1));
    }
    else
    {
      v34 = *v32;
      __str.__r_.__value_.__r.__words[2] = *((_QWORD *)v32 + 2);
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v34;
    }
    language_modeling::v1::CompletionStem::prefix(v33);
    if ((v40 & 0x80u) == 0)
      v35 = v40;
    else
      v35 = v39;
    _completion_with_stem_removed(&v41, &__str, v35);
    if ((char)v40 < 0)
      operator delete(__p);
    v10 = _bounded_word_count((uint64_t)&v41);
    if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v41.__r_.__value_.__l.__data_);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  xpc_dictionary_set_string(v3, (const char *)kTIICCompletionSourceFieldName, v4);
  xpc_dictionary_set_int64(v3, (const char *)kTIICWordsGeneratedFieldName, v9);
  xpc_dictionary_set_int64(v3, (const char *)kTIICWordsPresentedFieldName, v10);
  xpc_dictionary_set_BOOL(v3, (const char *)kTIICIsCachedFieldName, *(_BYTE *)(a1 + 68));
  xpc_dictionary_set_int64(v3, (const char *)kTIICSuppressionModality, *(unsigned int *)(a1 + 64));
  if (*(_BYTE *)(v2 + 140))
  {
    v11 = *(unsigned int *)(v2 + 136);
    v12 = v11 + 4;
    if ((v11 - 1) <= 4 && *(_BYTE *)(v2 + 48) && *(_BYTE *)(v2 + 88))
    {
      if ((_DWORD)v11 == 2)
      {
        v13 = 1;
      }
      else
      {
        v36 = *(char **)(v2 + 24);
        if (!v36)
          v36 = (char *)(v2 + 32);
        if (*(_WORD *)(v2 + 16))
          v37 = v36;
        else
          v37 = "";
        std::string::basic_string[abi:nn180100]<0>(&__str, v37);
        _completion_with_stem_removed(&v41, &__str, *(unsigned __int16 *)(v2 + 56));
        v13 = _bounded_word_count((uint64_t)&v41);
        if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v41.__r_.__value_.__l.__data_);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      v13 = 0;
    }
  }
  else
  {
    v13 = 0;
    v12 = 3;
  }
  xpc_dictionary_set_int64(v3, (const char *)kTIICWordsAcceptedFieldName, v13);
  xpc_dictionary_set_int64(v3, (const char *)kTIICRevisedModalityFieldName, v12);
  if (*(_BYTE *)(v2 + 472))
  {
    KB::String::String((KB::String *)&__str, (const KB::String *)(v2 + 144));
    KB::String::String((KB::String *)v43, (const KB::String *)(v2 + 176));
    KB::String::String((KB::String *)v45, (const KB::String *)(v2 + 208));
    KB::String::String((KB::String *)v47, (const KB::String *)(v2 + 240));
    KB::String::String((KB::String *)v49, (const KB::String *)(v2 + 272));
    KB::String::String((KB::String *)v51, (const KB::String *)(v2 + 304));
    v53 = *(_BYTE *)(v2 + 336);
    KB::String::String((KB::String *)v54, (const KB::String *)(v2 + 344));
    KB::String::String((KB::String *)v56, (const KB::String *)(v2 + 376));
    KB::String::String((KB::String *)v58, (const KB::String *)(v2 + 408));
    KB::String::String((KB::String *)v60, (const KB::String *)(v2 + 440));
    if (*(_BYTE *)(v2 + 472))
    {
      if (*(_WORD *)(v2 + 144))
        v14 = *(_QWORD *)(v2 + 152) ? *(const char **)(v2 + 152) : (const char *)(v2 + 160);
      else
        v14 = "";
      xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardLanguageFieldName, v14);
      if (*(_BYTE *)(v2 + 472))
      {
        if (*(_WORD *)(v2 + 176))
          v15 = *(_QWORD *)(v2 + 184) ? *(const char **)(v2 + 184) : (const char *)(v2 + 192);
        else
          v15 = "";
        xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardRegionFieldName, v15);
        if (*(_BYTE *)(v2 + 472))
        {
          if (*(_WORD *)(v2 + 208))
            v16 = *(_QWORD *)(v2 + 216) ? *(const char **)(v2 + 216) : (const char *)(v2 + 224);
          else
            v16 = "";
          xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardVariantFieldName, v16);
          if (*(_BYTE *)(v2 + 472))
          {
            if (*(_WORD *)(v2 + 240))
              v17 = *(_QWORD *)(v2 + 248) ? *(const char **)(v2 + 248) : (const char *)(v2 + 256);
            else
              v17 = "";
            xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardSecondaryLanguageFieldName, v17);
            if (*(_BYTE *)(v2 + 472))
            {
              if (*(_WORD *)(v2 + 272))
                v18 = *(_QWORD *)(v2 + 280) ? *(const char **)(v2 + 280) : (const char *)(v2 + 288);
              else
                v18 = "";
              xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardSecondaryRegionFieldName, v18);
              if (*(_BYTE *)(v2 + 472))
              {
                if (*(_WORD *)(v2 + 304))
                  v19 = *(_QWORD *)(v2 + 312) ? *(const char **)(v2 + 312) : (const char *)(v2 + 320);
                else
                  v19 = "";
                xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardLayoutFieldName, v19);
                if (*(_BYTE *)(v2 + 472))
                {
                  v20 = (const char *)kTIICKeyboardTypeFieldName;
                  +[TIKBAnalyticsMetricsContext keyboardTypeEnumToString:](TIKBAnalyticsMetricsContext, "keyboardTypeEnumToString:", *(unsigned __int8 *)(v2 + 336));
                  v21 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                  v22 = (const char *)objc_msgSend(v21, "UTF8String");

                  xpc_dictionary_set_string(v3, v20, v22);
                  if (*(_BYTE *)(v2 + 472))
                  {
                    v24 = (const char *)kTIICBundleIdFieldName;
                    KB::ns_string((KB *)(v2 + 344), v23);
                    v25 = (void *)objc_claimAutoreleasedReturnValue();
                    if (objc_msgSend(MEMORY[0x1E0DBDB38], "isReportableClientId:", v25))
                    {
                      if (*(_WORD *)(v2 + 344))
                        v26 = *(_QWORD *)(v2 + 352) ? *(const char **)(v2 + 352) : (const char *)(v2 + 360);
                      else
                        v26 = "";
                    }
                    else
                    {
                      v26 = "Other";
                    }

                    xpc_dictionary_set_string(v3, v24, v26);
                    if (*(_BYTE *)(v2 + 472))
                    {
                      if (!*(_WORD *)(v2 + 376)
                        || (*(_QWORD *)(v2 + 384)
                          ? (v28 = *(const char **)(v2 + 384))
                          : (v28 = (const char *)(v2 + 392)),
                            xpc_dictionary_set_string(v3, (const char *)kTIICTrialDeploymentIdFieldName, v28),
                            *(_BYTE *)(v2 + 472)))
                      {
                        if (!*(_WORD *)(v2 + 408)
                          || (*(_QWORD *)(v2 + 416)
                            ? (v29 = *(const char **)(v2 + 416))
                            : (v29 = (const char *)(v2 + 424)),
                              xpc_dictionary_set_string(v3, (const char *)kTIICTrialExperimentIdFieldName, v29),
                              *(_BYTE *)(v2 + 472)))
                        {
                          if (*(_WORD *)(v2 + 440))
                          {
                            if (*(_QWORD *)(v2 + 448))
                              v30 = *(const char **)(v2 + 448);
                            else
                              v30 = (const char *)(v2 + 456);
                            xpc_dictionary_set_string(v3, (const char *)kTIICTrialTreatmentIdFieldName, v30);
                          }
                          if (v61 && v60[6] == 1)
                            free(v61);
                          if (v59 && v58[6] == 1)
                            free(v59);
                          if (v57 && v56[6] == 1)
                            free(v57);
                          if (v55 && v54[6] == 1)
                            free(v55);
                          if (v52 && v51[6] == 1)
                            free(v52);
                          if (v50 && v49[6] == 1)
                            free(v50);
                          if (v48 && v47[6] == 1)
                            free(v48);
                          if (v46 && v45[6] == 1)
                            free(v46);
                          if (v44 && v43[6] == 1)
                            free(v44);
                          if (__str.__r_.__value_.__l.__size_ && __str.__r_.__value_.__s.__data_[6] == 1)
                            free((void *)__str.__r_.__value_.__l.__size_);
                          return v3;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_137:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return v3;
}

uint64_t std::__throw_bad_optional_access[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_optional_access was thrown in -fno-exceptions mode");
  return _bounded_word_count();
}

uint64_t _bounded_word_count(uint64_t a1)
{
  const char *v1;
  BOOL v2;
  uint64_t v3;
  _QWORD v6[3];
  void **v7;
  void *v8;
  char v9;
  _BYTE v10[8];
  void *v11;
  unsigned __int16 v12[3];
  char v13;
  void *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*(char *)(a1 + 23) >= 0)
    v1 = (const char *)a1;
  else
    v1 = *(const char **)a1;
  KB::String::String((KB::String *)v12, v1);
  KB::String::String((KB::String *)&v7, " \t\n");
  KB::String::trim((KB::String *)v12, (const KB::String *)&v7, (uint64_t)v10);
  if (v11)
    v2 = v10[6] == 1;
  else
    v2 = 0;
  if (v2)
    free(v11);
  if (v8 && BYTE6(v7) == 1)
    free(v8);
  if (v12[0])
  {
    WORD2(v7) = 0;
    BYTE6(v7) = 0;
    v8 = " \t\n";
    LODWORD(v7) = 1048579;
    v9 = 0;
    KB::sbs_string_tokenize(v12, (const KB::String *)&v7, v6);
    if (v8 && BYTE6(v7) == 1)
      free(v8);
    v3 = (v6[1] - v6[0]) >> 5;
    v7 = (void **)v6;
    std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v7);
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (v14 && v13 == 1)
    free(v14);
  if ((int)v3 >= 5)
    return 5;
  else
    return (int)v3;
}

void _completion_with_stem_removed(std::string *this, std::string *__str, std::string::size_type __pos)
{
  std::string::size_type size;
  int v7;
  std::string *v8;
  int v9;
  const char *v10;
  __int16 v11;
  std::string::size_type v12;
  __int16 v13;
  std::string *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  v7 = (char)size;
  if ((size & 0x80u) != 0)
    size = __str->__r_.__value_.__l.__size_;
  if (size >= __pos)
  {
    std::string::basic_string(this, __str, __pos, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v9);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      v8 = (std::string *)__str->__r_.__value_.__r.__words[0];
      if (v7 >= 0)
        v8 = __str;
      v9 = 136315650;
      v10 = "_completion_with_stem_removed";
      v11 = 2048;
      v12 = __pos;
      v13 = 2080;
      v14 = v8;
      _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  !!! Stem size:%zu should not be longer than completion: %s", (uint8_t *)&v9, 0x20u);
    }
    this->__r_.__value_.__r.__words[0] = 0;
    this->__r_.__value_.__l.__size_ = 0;
    this->__r_.__value_.__r.__words[2] = 0;
  }
}

void ___ZL15analytics_queuev_block_invoke()
{
  NSObject *v0;
  dispatch_queue_t v1;
  void *v2;
  NSObject *attr;

  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v0 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_UTILITY, 0);
  attr = objc_claimAutoreleasedReturnValue();

  v1 = dispatch_queue_create("com.apple.textInput.inlineCompletionEventDispatcher", attr);
  v2 = (void *)analytics_queue(void)::queue;
  analytics_queue(void)::queue = (uint64_t)v1;

}

uint64_t std::__throw_bad_weak_ptr[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_weak_ptr was thrown in -fno-exceptions mode");
  return TIInlineCompletionEventDispatcher::did_generate_new_completion();
}

void TIInlineCompletionEventDispatcher::did_generate_new_completion(uint64_t a1, uint64_t a2, const language_modeling::v1::CompletionStem *a3, int a4)
{
  std::__shared_weak_count *v7;
  uint64_t v8;
  uint64_t *p_shared_weak_owners;
  unint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  void *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  std::string v20;
  std::string __p;
  uint64_t v22;
  int v23;
  _BYTE v24[8];
  char v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(uint64_t);
  void *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  std::string v34;
  std::string v35;
  uint64_t v36;
  int v37;
  _BYTE v38[8];
  char v39;
  _DWORD v40[4];

  std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(&v18, *(_QWORD *)a1, *(std::__shared_weak_count **)(a1 + 8));
  v8 = v18;
  v7 = v19;
  if (v19)
  {
    p_shared_weak_owners = &v19->__shared_weak_owners_;
    do
      v10 = __ldxr((unint64_t *)p_shared_weak_owners);
    while (__stxr(v10 + 1, (unint64_t *)p_shared_weak_owners));
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  analytics_queue();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = MEMORY[0x1E0C809B0];
  v29 = 3321888768;
  v30 = ___ZN33TIInlineCompletionEventDispatcher27did_generate_new_completionERK18TIInlineCompletionRKN17language_modeling2v114CompletionStemE23TIICSuppressionModality_block_invoke;
  v31 = &__block_descriptor_144_a8_32c166_ZTSKZN33TIInlineCompletionEventDispatcher27did_generate_new_completionERK18TIInlineCompletionRKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0_e5_v8__0l;
  v18 = v8;
  v19 = v7;
  if (v7)
  {
    v14 = (unint64_t *)&v7->__shared_weak_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v20 = *(std::string *)a2;
  if (*(char *)(a2 + 47) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a2 + 24), *(_QWORD *)(a2 + 32));
  else
    __p = *(std::string *)(a2 + 24);
  v22 = *(_QWORD *)(a2 + 48);
  v23 = *(_DWORD *)(a2 + 56);
  v24[0] = 0;
  v25 = 0;
  if (*(_BYTE *)(a2 + 72))
  {
    MEMORY[0x1DF0A1C10](v24, a2 + 64);
    v25 = 1;
  }
  language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)&v26, a3);
  v27 = a4;
  v32 = v18;
  v33 = v19;
  if (v19)
  {
    v16 = &v19->__shared_weak_owners_;
    do
      v17 = __ldxr((unint64_t *)v16);
    while (__stxr(v17 + 1, (unint64_t *)v16));
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v34, v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
  else
    v34 = v20;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v35, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  else
    v35 = __p;
  v36 = v22;
  v37 = v23;
  v38[0] = 0;
  v39 = 0;
  if (v25)
  {
    MEMORY[0x1DF0A1C10](v38, v24);
    v39 = 1;
  }
  language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)v40, (const language_modeling::v1::CompletionStem *)&v26);
  v40[2] = v27;
  TIDispatchAsync();
  language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)&v26);
  if (v25)
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v20.__r_.__value_.__l.__data_);
  if (v19)
    std::__shared_weak_count::__release_weak(v19);

  language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)v40);
  if (v39)
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)v38);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
  if (v33)
    std::__shared_weak_count::__release_weak(v33);
  if (v7)
    std::__shared_weak_count::__release_weak(v7);
}

void ___ZN33TIInlineCompletionEventDispatcher27did_generate_new_completionERK18TIInlineCompletionRKN17language_modeling2v114CompletionStemE23TIICSuppressionModality_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  char v9;
  std::string v10;
  std::string v11;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        std::__optional_destruct_base<TIInlineCompletion,false>::__optional_destruct_base[abi:nn180100]<TIInlineCompletion const&>(&v11, (__int128 *)(a1 + 48));
        std::__optional_destruct_base<TIInlineCompletion,false>::__optional_destruct_base[abi:nn180100]<TIInlineCompletion const&>(&v10, (__int128 *)(a1 + 48));
        language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)&v8, (const language_modeling::v1::CompletionStem *)(a1 + 128));
        v9 = 1;
        TIInlineCompletionEventDispatcher::_dispatch_event(v5);
        if (v9)
          language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)&v8);
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v10);
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v11);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

uint64_t __copy_helper_block_a8_32c166_ZTSKZN33TIInlineCompletionEventDispatcher27did_generate_new_completionERK18TIInlineCompletionRKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::string *v7;
  __int128 v8;
  std::string *v9;
  __int128 v10;
  uint64_t v11;
  int v12;
  uint64_t result;

  v4 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::string *)(a1 + 48);
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 48), *(_QWORD *)(a2 + 56));
  }
  else
  {
    v8 = *(_OWORD *)(a2 + 48);
    *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  v9 = (std::string *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)(a2 + 72), *(_QWORD *)(a2 + 80));
  }
  else
  {
    v10 = *(_OWORD *)(a2 + 72);
    *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
  }
  v11 = *(_QWORD *)(a2 + 96);
  v12 = *(_DWORD *)(a2 + 104);
  *(_BYTE *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 104) = v12;
  *(_QWORD *)(a1 + 96) = v11;
  *(_BYTE *)(a1 + 120) = 0;
  if (*(_BYTE *)(a2 + 120))
  {
    MEMORY[0x1DF0A1C10]();
    *(_BYTE *)(a1 + 120) = 1;
  }
  result = language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)(a1 + 128), (const language_modeling::v1::CompletionStem *)(a2 + 128));
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  return result;
}

void __destroy_helper_block_a8_32c166_ZTSKZN33TIInlineCompletionEventDispatcher27did_generate_new_completionERK18TIInlineCompletionRKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0(uint64_t a1)
{
  std::__shared_weak_count *v2;

  language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)(a1 + 128));
  if (*(_BYTE *)(a1 + 120))
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 112));
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

std::string *std::__optional_destruct_base<TIInlineCompletion,false>::__optional_destruct_base[abi:nn180100]<TIInlineCompletion const&>(std::string *this, __int128 *a2)
{
  __int128 v4;
  std::string *v5;
  __int128 v6;
  std::string::size_type v7;
  int v8;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  v5 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v6 = *(__int128 *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  v7 = *((_QWORD *)a2 + 6);
  v8 = *((_DWORD *)a2 + 14);
  this[2].__r_.__value_.__s.__data_[16] = 0;
  LODWORD(this[2].__r_.__value_.__r.__words[1]) = v8;
  this[2].__r_.__value_.__r.__words[0] = v7;
  this[3].__r_.__value_.__s.__data_[0] = 0;
  if (*((_BYTE *)a2 + 72))
  {
    MEMORY[0x1DF0A1C10]();
    this[3].__r_.__value_.__s.__data_[0] = 1;
  }
  this[3].__r_.__value_.__s.__data_[8] = 1;
  return this;
}

void TIInlineCompletionEventDispatcher::did_generate_cached_completion(uint64_t a1, uint64_t a2, uint64_t a3, const language_modeling::v1::CompletionStem *a4, int a5)
{
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_weak_owners;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  void *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  std::string v20;
  std::string v21;
  uint64_t v22;
  int v23;
  _BYTE v24[8];
  char v25;
  std::string v26;
  std::string v27;
  uint64_t v28;
  int v29;
  _BYTE v30[8];
  char v31;
  _DWORD v32[4];
  uint64_t v33;
  uint64_t v34;
  void (*v35)(uint64_t);
  void *v36;
  _BYTE v37[192];

  std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(&v18, *(_QWORD *)a1, *(std::__shared_weak_count **)(a1 + 8));
  v10 = v18;
  v9 = v19;
  if (v19)
  {
    p_shared_weak_owners = (unint64_t *)&v19->__shared_weak_owners_;
    do
      v12 = __ldxr(p_shared_weak_owners);
    while (__stxr(v12 + 1, p_shared_weak_owners));
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  analytics_queue();
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = MEMORY[0x1E0C809B0];
  v34 = 3321888768;
  v35 = ___ZN33TIInlineCompletionEventDispatcher30did_generate_cached_completionERK18TIInlineCompletionS2_RKN17language_modeling2v114CompletionStemE23TIICSuppressionModality_block_invoke;
  v36 = &__block_descriptor_224_a8_32c172_ZTSKZN33TIInlineCompletionEventDispatcher30did_generate_cached_completionERK18TIInlineCompletionS2_RKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0_e5_v8__0l;
  v18 = v10;
  v19 = v9;
  if (v9)
  {
    v16 = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v20 = *(std::string *)a2;
  if (*(char *)(a2 + 47) < 0)
    std::string::__init_copy_ctor_external(&v21, *(const std::string::value_type **)(a2 + 24), *(_QWORD *)(a2 + 32));
  else
    v21 = *(std::string *)(a2 + 24);
  v22 = *(_QWORD *)(a2 + 48);
  v23 = *(_DWORD *)(a2 + 56);
  v24[0] = 0;
  v25 = 0;
  if (*(_BYTE *)(a2 + 72))
  {
    MEMORY[0x1DF0A1C10](v24, a2 + 64);
    v25 = 1;
  }
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v26 = *(std::string *)a3;
  if (*(char *)(a3 + 47) < 0)
    std::string::__init_copy_ctor_external(&v27, *(const std::string::value_type **)(a3 + 24), *(_QWORD *)(a3 + 32));
  else
    v27 = *(std::string *)(a3 + 24);
  v28 = *(_QWORD *)(a3 + 48);
  v29 = *(_DWORD *)(a3 + 56);
  v30[0] = 0;
  v31 = 0;
  if (*(_BYTE *)(a3 + 72))
  {
    MEMORY[0x1DF0A1C10](v30, a3 + 64);
    v31 = 1;
  }
  language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)v32, a4);
  v32[2] = a5;
  TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::$_0((uint64_t)v37, (uint64_t)&v18);
  TIDispatchAsync();
  TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::~$_0((uint64_t)&v18);

  TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::~$_0((uint64_t)v37);
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
}

void ___ZN33TIInlineCompletionEventDispatcher30did_generate_cached_completionERK18TIInlineCompletionS2_RKN17language_modeling2v114CompletionStemE23TIICSuppressionModality_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  char v9;
  std::string v10;
  std::string v11;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        std::__optional_destruct_base<TIInlineCompletion,false>::__optional_destruct_base[abi:nn180100]<TIInlineCompletion const&>(&v11, (__int128 *)(a1 + 48));
        std::__optional_destruct_base<TIInlineCompletion,false>::__optional_destruct_base[abi:nn180100]<TIInlineCompletion const&>(&v10, (__int128 *)(a1 + 128));
        language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)&v8, (const language_modeling::v1::CompletionStem *)(a1 + 208));
        v9 = 1;
        TIInlineCompletionEventDispatcher::_dispatch_event(v5);
        if (v9)
          language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)&v8);
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v10);
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v11);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

uint64_t TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::$_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::string *v7;
  __int128 v8;
  std::string *v9;
  __int128 v10;
  uint64_t v11;
  int v12;
  std::string *v13;
  __int128 v14;
  std::string *v15;
  __int128 v16;
  uint64_t v17;
  int v18;

  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::string *)(a1 + 16);
  if (*(char *)(a2 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 16), *(_QWORD *)(a2 + 24));
  }
  else
  {
    v8 = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  v9 = (std::string *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)(a2 + 40), *(_QWORD *)(a2 + 48));
  }
  else
  {
    v10 = *(_OWORD *)(a2 + 40);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
  }
  v11 = *(_QWORD *)(a2 + 64);
  v12 = *(_DWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = v12;
  *(_QWORD *)(a1 + 64) = v11;
  *(_BYTE *)(a1 + 88) = 0;
  if (*(_BYTE *)(a2 + 88))
  {
    MEMORY[0x1DF0A1C10]();
    *(_BYTE *)(a1 + 88) = 1;
  }
  v13 = (std::string *)(a1 + 96);
  if (*(char *)(a2 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)(a2 + 96), *(_QWORD *)(a2 + 104));
  }
  else
  {
    v14 = *(_OWORD *)(a2 + 96);
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
  }
  v15 = (std::string *)(a1 + 120);
  if (*(char *)(a2 + 143) < 0)
  {
    std::string::__init_copy_ctor_external(v15, *(const std::string::value_type **)(a2 + 120), *(_QWORD *)(a2 + 128));
  }
  else
  {
    v16 = *(_OWORD *)(a2 + 120);
    *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
    *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v16;
  }
  v17 = *(_QWORD *)(a2 + 144);
  v18 = *(_DWORD *)(a2 + 152);
  *(_BYTE *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 152) = v18;
  *(_QWORD *)(a1 + 144) = v17;
  *(_BYTE *)(a1 + 168) = 0;
  if (*(_BYTE *)(a2 + 168))
  {
    MEMORY[0x1DF0A1C10]();
    *(_BYTE *)(a1 + 168) = 1;
  }
  language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)(a1 + 176), (const language_modeling::v1::CompletionStem *)(a2 + 176));
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 184);
  return a1;
}

uint64_t TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::~$_0(uint64_t a1)
{
  std::__shared_weak_count *v2;

  language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)(a1 + 176));
  if (*(_BYTE *)(a1 + 168))
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 160));
  if (*(char *)(a1 + 143) < 0)
    operator delete(*(void **)(a1 + 120));
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  if (*(_BYTE *)(a1 + 88))
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 80));
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

uint64_t __copy_helper_block_a8_32c172_ZTSKZN33TIInlineCompletionEventDispatcher30did_generate_cached_completionERK18TIInlineCompletionS2_RKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0(uint64_t a1, uint64_t a2)
{
  return TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::$_0(a1 + 32, a2 + 32);
}

uint64_t __destroy_helper_block_a8_32c172_ZTSKZN33TIInlineCompletionEventDispatcher30did_generate_cached_completionERK18TIInlineCompletionS2_RKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0(uint64_t a1)
{
  return TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::~$_0(a1 + 32);
}

void TIInlineCompletionEventDispatcher::did_register_completion_acceptance(uint64_t a1, const KB::String *a2, const KB::String *a3, const KB::String *a4, int a5)
{
  std::__shared_weak_count *v9;
  uint64_t v10;
  uint64_t *p_shared_weak_owners;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  void *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  _BYTE v22[8];
  void *v23;
  _BYTE v24[8];
  void *v25;
  _BYTE v26[8];
  void *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  void (*v31)(uint64_t);
  void *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  _BYTE v35[8];
  void *v36;
  _BYTE v37[8];
  void *v38;
  _BYTE v39[8];
  void *v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(&v20, *(_QWORD *)a1, *(std::__shared_weak_count **)(a1 + 8));
  v10 = v20;
  v9 = v21;
  if (v21)
  {
    p_shared_weak_owners = &v21->__shared_weak_owners_;
    do
      v12 = __ldxr((unint64_t *)p_shared_weak_owners);
    while (__stxr(v12 + 1, (unint64_t *)p_shared_weak_owners));
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  analytics_queue();
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = MEMORY[0x1E0C809B0];
  v30 = 3321888768;
  v31 = ___ZN33TIInlineCompletionEventDispatcher34did_register_completion_acceptanceERKN2KB6StringES3_S3_41TIInlineCompletionAcceptanceRejectionType_block_invoke;
  v32 = &__block_descriptor_152_a8_32c147_ZTSKZN33TIInlineCompletionEventDispatcher34did_register_completion_acceptanceERKN2KB6StringES3_S3_41TIInlineCompletionAcceptanceRejectionTypeE3__0_e5_v8__0l;
  v20 = v10;
  v21 = v9;
  if (v9)
  {
    v16 = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  KB::String::String((KB::String *)v22, a2);
  KB::String::String((KB::String *)v24, a3);
  KB::String::String((KB::String *)v26, a4);
  v28 = a5;
  v33 = v20;
  v34 = v21;
  if (v21)
  {
    v18 = &v21->__shared_weak_owners_;
    do
      v19 = __ldxr((unint64_t *)v18);
    while (__stxr(v19 + 1, (unint64_t *)v18));
  }
  KB::String::String((KB::String *)v35, (const KB::String *)v22);
  KB::String::String((KB::String *)v37, (const KB::String *)v24);
  KB::String::String((KB::String *)v39, (const KB::String *)v26);
  v41 = v28;
  TIDispatchAsync();
  if (v27 && v26[6] == 1)
    free(v27);
  if (v25 && v24[6] == 1)
    free(v25);
  if (v23 && v22[6] == 1)
    free(v23);
  if (v21)
    std::__shared_weak_count::__release_weak(v21);

  if (v40 && v39[6] == 1)
    free(v40);
  if (v38 && v37[6] == 1)
    free(v38);
  if (v36 && v35[6] == 1)
    free(v36);
  if (v34)
    std::__shared_weak_count::__release_weak(v34);
  if (v9)
    std::__shared_weak_count::__release_weak(v9);
}

void ___ZN33TIInlineCompletionEventDispatcher34did_register_completion_acceptanceERKN2KB6StringES3_S3_41TIInlineCompletionAcceptanceRejectionType_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        std::optional<KB::String>::operator=[abi:nn180100]<KB::String const&,void>((KB::String *)(v5 + 16), (KB::String *)(a1 + 48));
        std::optional<KB::String>::operator=[abi:nn180100]<KB::String const&,void>((KB::String *)(v5 + 56), (KB::String *)(a1 + 80));
        std::optional<KB::String>::operator=[abi:nn180100]<KB::String const&,void>((KB::String *)(v5 + 96), (KB::String *)(a1 + 112));
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(a1 + 144);
        *(_BYTE *)(v5 + 140) = 1;
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

KB::String *__copy_helper_block_a8_32c147_ZTSKZN33TIInlineCompletionEventDispatcher34did_register_completion_acceptanceERKN2KB6StringES3_S3_41TIInlineCompletionAcceptanceRejectionTypeE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  KB::String *result;

  v4 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  KB::String::String((KB::String *)(a1 + 48), (const KB::String *)(a2 + 48));
  KB::String::String((KB::String *)(a1 + 80), (const KB::String *)(a2 + 80));
  result = KB::String::String((KB::String *)(a1 + 112), (const KB::String *)(a2 + 112));
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  return result;
}

void __destroy_helper_block_a8_32c147_ZTSKZN33TIInlineCompletionEventDispatcher34did_register_completion_acceptanceERKN2KB6StringES3_S3_41TIInlineCompletionAcceptanceRejectionTypeE3__0(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  std::__shared_weak_count *v5;

  v2 = *(void **)(a1 + 120);
  if (v2 && *(_BYTE *)(a1 + 118) == 1)
    free(v2);
  v3 = *(void **)(a1 + 88);
  if (v3 && *(_BYTE *)(a1 + 86) == 1)
    free(v3);
  v4 = *(void **)(a1 + 56);
  if (v4 && *(_BYTE *)(a1 + 54) == 1)
    free(v4);
  v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

KB::String *std::optional<KB::String>::operator=[abi:nn180100]<KB::String const&,void>(KB::String *a1, KB::String *a2)
{
  KB::String *result;

  if (*((_BYTE *)a1 + 32))
    return KB::String::operator=(a1, a2);
  result = KB::String::String(a1, a2);
  *((_BYTE *)result + 32) = 1;
  return result;
}

_BYTE *std::construct_at[abi:nn180100]<TIInlineCompletionAnalyticsMetadata,TIInlineCompletionAnalyticsMetadata const&,TIInlineCompletionAnalyticsMetadata*>(_BYTE *a1, _BYTE *a2)
{
  KB::String *v4;

  v4 = KB::String::String((KB::String *)a1, (const KB::String *)a2);
  KB::String::String((KB::String *)((char *)v4 + 32), (const KB::String *)(a2 + 32));
  KB::String::String((KB::String *)(a1 + 64), (const KB::String *)(a2 + 64));
  KB::String::String((KB::String *)(a1 + 96), (const KB::String *)(a2 + 96));
  KB::String::String((KB::String *)(a1 + 128), (const KB::String *)(a2 + 128));
  KB::String::String((KB::String *)(a1 + 160), (const KB::String *)(a2 + 160));
  a1[192] = a2[192];
  KB::String::String((KB::String *)(a1 + 200), (const KB::String *)(a2 + 200));
  KB::String::String((KB::String *)(a1 + 232), (const KB::String *)(a2 + 232));
  KB::String::String((KB::String *)(a1 + 264), (const KB::String *)(a2 + 264));
  KB::String::String((KB::String *)(a1 + 296), (const KB::String *)(a2 + 296));
  return a1;
}

uint64_t std::__optional_destruct_base<TIInlineCompletionAnalyticsMetadata,false>::~__optional_destruct_base[abi:nn180100](uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  if (*(_BYTE *)(a1 + 328))
  {
    v2 = *(void **)(a1 + 304);
    if (v2 && *(_BYTE *)(a1 + 302) == 1)
      free(v2);
    v3 = *(void **)(a1 + 272);
    if (v3 && *(_BYTE *)(a1 + 270) == 1)
      free(v3);
    v4 = *(void **)(a1 + 240);
    if (v4 && *(_BYTE *)(a1 + 238) == 1)
      free(v4);
    v5 = *(void **)(a1 + 208);
    if (v5 && *(_BYTE *)(a1 + 206) == 1)
      free(v5);
    v6 = *(void **)(a1 + 168);
    if (v6 && *(_BYTE *)(a1 + 166) == 1)
      free(v6);
    v7 = *(void **)(a1 + 136);
    if (v7 && *(_BYTE *)(a1 + 134) == 1)
      free(v7);
    v8 = *(void **)(a1 + 104);
    if (v8 && *(_BYTE *)(a1 + 102) == 1)
      free(v8);
    v9 = *(void **)(a1 + 72);
    if (v9 && *(_BYTE *)(a1 + 70) == 1)
      free(v9);
    v10 = *(void **)(a1 + 40);
    if (v10 && *(_BYTE *)(a1 + 38) == 1)
      free(v10);
    v11 = *(void **)(a1 + 8);
    if (v11 && *(_BYTE *)(a1 + 6) == 1)
      free(v11);
  }
  return a1;
}

_BYTE *__copy_helper_block_a8_32c127_ZTSKZN33TIInlineCompletionEventDispatcher19did_update_metadataERKNSt3__18optionalI35TIInlineCompletionAnalyticsMetadataEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  _BYTE *result;

  v3 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  *(_BYTE *)(a1 + 48) = 0;
  result = (_BYTE *)(a1 + 48);
  *(_BYTE *)(a1 + 376) = 0;
  if (*(_BYTE *)(a2 + 376))
  {
    result = std::construct_at[abi:nn180100]<TIInlineCompletionAnalyticsMetadata,TIInlineCompletionAnalyticsMetadata const&,TIInlineCompletionAnalyticsMetadata*>(result, (_BYTE *)(a2 + 48));
    *(_BYTE *)(a1 + 376) = 1;
  }
  return result;
}

void __destroy_helper_block_a8_32c127_ZTSKZN33TIInlineCompletionEventDispatcher19did_update_metadataERKNSt3__18optionalI35TIInlineCompletionAnalyticsMetadataEEE3__0(uint64_t a1)
{
  std::__shared_weak_count *v2;

  std::__optional_destruct_base<TIInlineCompletionAnalyticsMetadata,false>::~__optional_destruct_base[abi:nn180100](a1 + 48);
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

_QWORD *std::vector<KB::LexiconInfo>::__init_with_size[abi:nn180100]<KB::LexiconInfo*,KB::LexiconInfo*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  if (a4)
  {
    if (a4 >= 0x1745D1745D1745ELL)
      abort();
    v6 = result;
    result = std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LexiconInfo>>(a4);
    *v6 = result;
    v6[1] = result;
    v6[2] = &result[22 * v7];
    while (a2 != a3)
    {
      v8 = std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo const&,KB::LexiconInfo*>((uint64_t)result, a2);
      a2 += 176;
      result = (_QWORD *)(v8 + 176);
    }
    v6[1] = result;
  }
  return result;
}

uint64_t __Block_byref_object_copy__48(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = a2[6];
  a2[6] = 0;
  *(_QWORD *)(result + 48) = v2;
  *(_QWORD *)(result + 56) = a2[7];
  a2[7] = 0;
  v5 = a2[8];
  v3 = a2 + 8;
  v4 = v5;
  *(_QWORD *)(result + 64) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 64;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__49(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>>>::~__hash_table(a1 + 48);
}

uint64_t __Block_byref_object_copy__2425(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2426(uint64_t a1)
{

}

char *std::__hash_table<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  void **v15;
  char *v16;
  unint64_t v17;
  _QWORD *v18;
  std::string *v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  int8x8_t prime;
  void *v26;
  void *v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint8x8_t v31;
  unint64_t v32;
  uint8x8_t v33;
  uint64_t v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  unint64_t v39;
  void *v41;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = a1[1];
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(void ***)(*a1 + 8 * v3);
    if (v15)
    {
      v16 = (char *)*v15;
      if (*v15)
      {
        do
        {
          v17 = *((_QWORD *)v16 + 1);
          if (v17 == v11)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v16 + 16, (unsigned __int8 *)a2))
            {
              return v16;
            }
          }
          else
          {
            if (v14 > 1)
            {
              if (v17 >= v12)
                v17 %= v12;
            }
            else
            {
              v17 &= v12 - 1;
            }
            if (v17 != v3)
              break;
          }
          v16 = *(char **)v16;
        }
        while (v16);
      }
    }
  }
  v18 = a1 + 2;
  v16 = (char *)operator new(0x60uLL);
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = v11;
  v19 = (std::string *)(v16 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((_QWORD *)v16 + 4) = *(_QWORD *)(a3 + 16);
  }
  *(_OWORD *)(v16 + 40) = 0u;
  *(_OWORD *)(v16 + 56) = 0u;
  *(_OWORD *)(v16 + 72) = 0u;
  *((_DWORD *)v16 + 22) = 1065353216;
  std::shared_ptr<KB::LanguageModel>::operator=[abi:nn180100]((_QWORD *)v16 + 5, 0, 0);
  v20 = *((float *)a1 + 8);
  v21 = (float)(unint64_t)(a1[3] + 1);
  if (!v12 || (float)(v20 * (float)v12) < v21)
  {
    v22 = 1;
    if (v12 >= 3)
      v22 = (v12 & (v12 - 1)) != 0;
    v23 = v22 | (2 * v12);
    v24 = vcvtps_u32_f32(v21 / v20);
    if (v23 <= v24)
      prime = (int8x8_t)v24;
    else
      prime = (int8x8_t)v23;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v12 = a1[1];
    if (*(_QWORD *)&prime > v12)
      goto LABEL_39;
    if (*(_QWORD *)&prime < v12)
    {
      v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (v33 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        v32 = std::__next_prime(v32);
      }
      else
      {
        v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2)
          v32 = v34;
      }
      if (*(_QWORD *)&prime <= v32)
        prime = (int8x8_t)v32;
      if (*(_QWORD *)&prime >= v12)
      {
        v12 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v26 = operator new(8 * *(_QWORD *)&prime);
          v27 = (void *)*a1;
          *a1 = (uint64_t)v26;
          if (v27)
            operator delete(v27);
          v28 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v28++) = 0;
          while (*(_QWORD *)&prime != v28);
          v29 = (_QWORD *)*v18;
          if (*v18)
          {
            v30 = v29[1];
            v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(_QWORD *)&prime)
                v30 %= *(_QWORD *)&prime;
            }
            else
            {
              v30 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v30) = v18;
            v35 = (_QWORD *)*v29;
            if (*v29)
            {
              do
              {
                v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(_QWORD *)&prime)
                    v36 %= *(_QWORD *)&prime;
                }
                else
                {
                  v36 &= *(_QWORD *)&prime - 1;
                }
                if (v36 != v30)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v36))
                  {
                    *(_QWORD *)(*a1 + 8 * v36) = v29;
                    goto LABEL_64;
                  }
                  *v29 = *v35;
                  *v35 = **(_QWORD **)(*a1 + 8 * v36);
                  **(_QWORD **)(*a1 + 8 * v36) = v35;
                  v35 = v29;
                }
                v36 = v30;
LABEL_64:
                v29 = v35;
                v35 = (_QWORD *)*v35;
                v30 = v36;
              }
              while (v35);
            }
          }
          v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        v41 = (void *)*a1;
        *a1 = 0;
        if (v41)
          operator delete(v41);
        v12 = 0;
        a1[1] = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v37 = *a1;
  v38 = *(_QWORD **)(*a1 + 8 * v3);
  if (v38)
  {
    *(_QWORD *)v16 = *v38;
LABEL_81:
    *v38 = v16;
    goto LABEL_82;
  }
  *(_QWORD *)v16 = *v18;
  *v18 = v16;
  *(_QWORD *)(v37 + 8 * v3) = v18;
  if (*(_QWORD *)v16)
  {
    v39 = *(_QWORD *)(*(_QWORD *)v16 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v39 >= v12)
        v39 %= v12;
    }
    else
    {
      v39 &= v12 - 1;
    }
    v38 = (_QWORD *)(*a1 + 8 * v39);
    goto LABEL_81;
  }
LABEL_82:
  ++a1[3];
  return v16;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(unint64_t a1)
{
  if (a1 >> 60)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(16 * a1);
}

uint64_t std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](i - 16);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::shared_ptr<KB::LanguageModel>::operator=[abi:nn180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  if (a3)
  {
    v4 = (unint64_t *)(a3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (std::__shared_weak_count *)a1[1];
  *a1 = a2;
  a1[1] = a3;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return a1;
}

void std::vector<KB::LanguageModelLexiconGroup>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;
  uint64_t v6;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v6 = v4 - 56;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v4 - 40);
        std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](v6);
        v4 = v6;
      }
      while ((void *)v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,KB::LanguageModelLexiconGroup>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,KB::LanguageModelLexiconGroup>,0>(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 24;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a1 + 40);
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::__shared_ptr_emplace<KB::UnigramCandidateRefinery>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1021C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::UnigramCandidateRefinery>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1021C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::UnigramCandidateRefinery>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_pointer<KB::LanguageModelContainer *,std::shared_ptr<KB::LanguageModelContainer>::__shared_ptr_default_delete<KB::LanguageModelContainer,KB::LanguageModelContainer>,std::allocator<KB::LanguageModelContainer>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_pointer<KB::LanguageModelContainer *,std::shared_ptr<KB::LanguageModelContainer>::__shared_ptr_default_delete<KB::LanguageModelContainer,KB::LanguageModelContainer>,std::allocator<KB::LanguageModelContainer>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::unordered_map<unsigned int,float>::unordered_map(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t **v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  uint64_t **v10;
  uint64_t *i;
  unint64_t v12;
  _QWORD *v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  v5 = *(uint64_t ***)(a2 + 16);
  if (v5)
  {
    v6 = (_QWORD *)(a1 + 16);
    v7 = *(_QWORD *)(a1 + 8);
    do
    {
      v8 = *((unsigned int *)v5 + 4);
      if (v7)
      {
        v9 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
        v9.i16[0] = vaddlv_u8(v9);
        if (v9.u32[0] > 1uLL)
        {
          v2 = *((unsigned int *)v5 + 4);
          if (v7 <= v8)
            v2 = v8 % v7;
        }
        else
        {
          v2 = ((_DWORD)v7 - 1) & v8;
        }
        v10 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v2);
        if (v10)
        {
          for (i = *v10; i; i = (uint64_t *)*i)
          {
            v12 = i[1];
            if (v12 == v8)
            {
              if (*((_DWORD *)i + 4) == (_DWORD)v8)
                goto LABEL_41;
            }
            else
            {
              if (v9.u32[0] > 1uLL)
              {
                if (v12 >= v7)
                  v12 %= v7;
              }
              else
              {
                v12 &= v7 - 1;
              }
              if (v12 != v2)
                break;
            }
          }
        }
      }
      v13 = operator new(0x18uLL);
      *v13 = 0;
      v13[1] = v8;
      v13[2] = v5[2];
      v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
      v15 = *(float *)(a1 + 32);
      if (!v7 || (float)(v15 * (float)v7) < v14)
      {
        v16 = (v7 & (v7 - 1)) != 0;
        if (v7 < 3)
          v16 = 1;
        v17 = v16 | (2 * v7);
        v18 = vcvtps_u32_f32(v14 / v15);
        if (v17 <= v18)
          v19 = v18;
        else
          v19 = v17;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v19);
        v7 = *(_QWORD *)(a1 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v8)
            v2 = v8 % v7;
          else
            v2 = v8;
        }
        else
        {
          v2 = ((_DWORD)v7 - 1) & v8;
        }
      }
      v20 = *(_QWORD *)a1;
      v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v2);
      if (v21)
      {
        *v13 = *v21;
      }
      else
      {
        *v13 = *v6;
        *v6 = v13;
        *(_QWORD *)(v20 + 8 * v2) = v6;
        if (!*v13)
          goto LABEL_40;
        v22 = *(_QWORD *)(*v13 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v22 >= v7)
            v22 %= v7;
        }
        else
        {
          v22 &= v7 - 1;
        }
        v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
      }
      *v21 = v13;
LABEL_40:
      ++*(_QWORD *)(a1 + 24);
LABEL_41:
      v5 = (uint64_t **)*v5;
    }
    while (v5);
  }
  return a1;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelLexiconGroup>>(unint64_t a1)
{
  if (a1 >= 0x492492492492493)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(56 * a1);
}

__n128 __Block_byref_object_copy__41(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__42(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<KB::LexiconInfo>::__destroy_vector::operator()[abi:nn180100](&v1);
}

uint64_t __Block_byref_object_copy__2505(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2506(uint64_t a1)
{

}

id TIStatisticsCategoryToLegacyCategoryDictionary()
{
  if (TIStatisticsCategoryToLegacyCategoryDictionary_onceToken != -1)
    dispatch_once(&TIStatisticsCategoryToLegacyCategoryDictionary_onceToken, &__block_literal_global_2881);
  return (id)TIStatisticsCategoryToLegacyCategoryDictionary_dict;
}

id TIStatisticsDescriptionToLegacyDescriptionDictionary()
{
  if (TIStatisticsDescriptionToLegacyDescriptionDictionary_onceToken != -1)
    dispatch_once(&TIStatisticsDescriptionToLegacyDescriptionDictionary_onceToken, &__block_literal_global_231);
  return (id)TIStatisticsDescriptionToLegacyDescriptionDictionary_dict;
}

id TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary()
{
  if (TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary_onceToken != -1)
    dispatch_once(&TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary_onceToken, &__block_literal_global_232);
  return (id)TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary_dict;
}

id TIStatisticsLegacyCategoryForCategory(void *a1)
{
  id v1;
  void *v2;
  void *v3;

  v1 = a1;
  TIStatisticsCategoryToLegacyCategoryDictionary();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKeyedSubscript:", v1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

__CFString *TIStatisticsLegacySourceStringFromTrigger(void *a1)
{
  unsigned int v1;

  v1 = objc_msgSend(a1, "triggerSourceType");
  if (v1 > 2)
    return 0;
  else
    return off_1EA0FBC68[v1];
}

id TIStatisticsCategoriesForProactiveTrigger(void *a1)
{
  id v1;
  int v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  __CFString *v7;
  __CFString *v8;
  uint64_t v9;
  void *v10;
  __CFString *v11;
  __CFString *v12;
  uint64_t v13;
  void *v14;
  __CFString *v15;
  __CFString *v16;
  uint64_t v17;
  void *v18;
  __CFString *v19;
  __CFString *v20;
  BOOL v21;
  const __CFString *v22;

  v1 = a1;
  v2 = objc_msgSend(v1, "triggerSourceType");
  objc_msgSend(v1, "attributes");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKey:", *MEMORY[0x1E0D43428]);
  v5 = objc_claimAutoreleasedReturnValue();
  v6 = (void *)v5;
  if (v5)
    v7 = (__CFString *)v5;
  else
    v7 = &stru_1EA1081D0;
  v8 = v7;

  objc_msgSend(v3, "objectForKey:", *MEMORY[0x1E0D43400]);
  v9 = objc_claimAutoreleasedReturnValue();
  v10 = (void *)v9;
  if (v9)
    v11 = (__CFString *)v9;
  else
    v11 = &stru_1EA1081D0;
  v12 = v11;

  objc_msgSend(v3, "objectForKey:", *MEMORY[0x1E0D432C8]);
  v13 = objc_claimAutoreleasedReturnValue();
  v14 = (void *)v13;
  if (v13)
    v15 = (__CFString *)v13;
  else
    v15 = &stru_1EA1081D0;
  v16 = v15;

  objc_msgSend(v3, "objectForKey:", *MEMORY[0x1E0D433E8]);
  v17 = objc_claimAutoreleasedReturnValue();
  v18 = (void *)v17;
  if (v17)
    v19 = (__CFString *)v17;
  else
    v19 = &stru_1EA1081D0;
  v20 = v19;

  if ((-[__CFString isEqualToString:](v12, "isEqualToString:", *MEMORY[0x1E0D43320]) & 1) != 0
    || (-[__CFString isEqualToString:](v12, "isEqualToString:", *MEMORY[0x1E0D433F0])
      ? (v21 = v2 == 1)
      : (v21 = 0),
        v21))
  {
    objc_msgSend(v4, "addObject:", CFSTR("1stPerson"));
  }
  if (-[__CFString isEqualToString:](v12, "isEqualToString:", *MEMORY[0x1E0D43418]))
    objc_msgSend(v4, "addObject:", CFSTR("3rdPerson"));
  if (-[__CFString isEqualToString:](v8, "isEqualToString:", *MEMORY[0x1E0D433B8]))
  {
    if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D433C0]) & 1) != 0)
    {
      v22 = CFSTR("contactAnyPhone");
    }
    else if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43388]) & 1) != 0
           || (-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43360]) & 1) != 0
           || (-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43448]) & 1) != 0)
    {
      v22 = CFSTR("contactSpecificPhone");
    }
    else if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43318]) & 1) != 0)
    {
      v22 = CFSTR("contactFax");
    }
    else if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D432A8]) & 1) != 0
           || (-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D433C8]) & 1) != 0)
    {
      v22 = CFSTR("contactAnyAddress");
    }
    else if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43350]) & 1) != 0
           || (-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43358]) & 1) != 0)
    {
      v22 = CFSTR("contactAddressHome");
    }
    else if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43438]) & 1) != 0
           || (-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43440]) & 1) != 0)
    {
      v22 = CFSTR("contactAddressWork");
    }
    else if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D432F8]) & 1) != 0)
    {
      v22 = CFSTR("contactEmail");
    }
    else if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43308]) & 1) != 0)
    {
      v22 = CFSTR("contactFaceTime");
    }
    else if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D432B0]) & 1) != 0
           || (-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43338]) & 1) != 0
           || (-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D43408]) & 1) != 0)
    {
      v22 = CFSTR("contactBio");
    }
    else
    {
      if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D433F8]) & 1) == 0)
        goto LABEL_61;
      v22 = CFSTR("socialMedia");
    }
    goto LABEL_60;
  }
  if (-[__CFString isEqualToString:](v8, "isEqualToString:", *MEMORY[0x1E0D43378]))
  {
    if ((-[__CFString isEqualToString:](v12, "isEqualToString:", *MEMORY[0x1E0D432C0]) & 1) != 0)
    {
      v22 = CFSTR("locationAutocompleteSendCurrentButton");
LABEL_60:
      objc_msgSend(v4, "addObject:", v22);
      goto LABEL_61;
    }
    if (-[__CFString isEqualToString:](v12, "isEqualToString:", *MEMORY[0x1E0D433E0]))
    {
      if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D432A8]) & 1) != 0)
      {
        v22 = CFSTR("recentGenericAddress");
        goto LABEL_60;
      }
      if ((-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D433C0]) & 1) != 0)
      {
        v22 = CFSTR("recentPhone");
        goto LABEL_60;
      }
    }
    else if (-[__CFString isEqualToString:](v12, "isEqualToString:", *MEMORY[0x1E0D433D8])
           && (-[__CFString isEqualToString:](v16, "isEqualToString:", *MEMORY[0x1E0D432A8]) & 1) != 0)
    {
      v22 = CFSTR("recentAddress");
      goto LABEL_60;
    }
  }
  else if (-[__CFString isEqualToString:](v8, "isEqualToString:", *MEMORY[0x1E0D43300]))
  {
    if ((-[__CFString isEqualToString:](v20, "isEqualToString:", *MEMORY[0x1E0D433B0]) & 1) != 0
      || (-[__CFString isEqualToString:](v20, "isEqualToString:", *MEMORY[0x1E0D432D8]) & 1) != 0
      || (-[__CFString isEqualToString:](v20, "isEqualToString:", *MEMORY[0x1E0D43368]) & 1) != 0)
    {
      v22 = CFSTR("eventAvailability");
      goto LABEL_60;
    }
    if ((-[__CFString isEqualToString:](v20, "isEqualToString:", *MEMORY[0x1E0D433A8]) & 1) != 0
      || (-[__CFString isEqualToString:](v20, "isEqualToString:", *MEMORY[0x1E0D43420]) & 1) != 0
      || (-[__CFString isEqualToString:](v20, "isEqualToString:", *MEMORY[0x1E0D43370]) & 1) != 0)
    {
      v22 = CFSTR("eventNext");
      goto LABEL_60;
    }
  }
  else
  {
    if ((-[__CFString isEqualToString:](v8, "isEqualToString:", *MEMORY[0x1E0D87C30]) & 1) != 0)
    {
      v22 = CFSTR("money");
      goto LABEL_60;
    }
    if ((-[__CFString isEqualToString:](v8, "isEqualToString:", *MEMORY[0x1E0D43348]) & 1) != 0)
    {
      v22 = CFSTR("health");
      goto LABEL_60;
    }
    if (-[__CFString isEqualToString:](v8, "isEqualToString:", *MEMORY[0x1E0D433A0]))
    {
      v22 = CFSTR("navigation");
      goto LABEL_60;
    }
  }
LABEL_61:

  return v4;
}

void TIStatisticLogProactiveInfo(void *a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *context;
  void *v27;
  id obj;
  void *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[128];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = a4;
  context = (void *)MEMORY[0x1DF0A2708]();
  objc_msgSend(MEMORY[0x1E0CB37A0], "string");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "appendString:", CFSTR("proactive."));
  v27 = v8;
  objc_msgSend(v11, "appendString:", v8);
  objc_msgSend(v11, "appendString:", CFSTR("."));
  v12 = v11;
  v13 = (void *)objc_msgSend(v11, "mutableCopy");
  v14 = v10;
  objc_msgSend(v13, "appendString:", v10);
  objc_msgSend(v13, "appendString:", CFSTR("."));
  v29 = v7;
  objc_msgSend(v13, "appendString:", v7);
  v25 = v13;
  TIStatisticGetKey();
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  TIStatisticScalarIncrement();

  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  obj = v9;
  v16 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
  if (v16)
  {
    v17 = v16;
    v18 = *(_QWORD *)v31;
    do
    {
      v19 = 0;
      do
      {
        if (*(_QWORD *)v31 != v18)
          objc_enumerationMutation(obj);
        v20 = *(void **)(*((_QWORD *)&v30 + 1) + 8 * v19);
        v21 = (void *)MEMORY[0x1DF0A2708]();
        TIStatisticsLegacyCategoryForCategory(v20);
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        v23 = (void *)objc_msgSend(v12, "mutableCopy");
        objc_msgSend(v23, "appendString:", v22);
        objc_msgSend(v23, "appendString:", CFSTR("."));
        objc_msgSend(v23, "appendString:", v14);
        objc_msgSend(v23, "appendString:", CFSTR("."));
        objc_msgSend(v23, "appendString:", v29);
        TIStatisticGetKey();
        v24 = (void *)objc_claimAutoreleasedReturnValue();
        TIStatisticScalarIncrement();

        objc_autoreleasePoolPop(v21);
        ++v19;
      }
      while (v17 != v19);
      v17 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
    }
    while (v17);
  }

  objc_autoreleasePoolPop(context);
}

const __CFString *TIStatisticLegacyStringFromMetricType(int a1)
{
  if ((a1 - 1) > 6)
    return CFSTR("triggered");
  else
    return off_1EA0FBC30[(a1 - 1)];
}

void TIStatisticLogProactive(void *a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  id v8;
  id v9;
  id v10;
  id v11;
  void *v12;
  NSObject *v13;
  void *v14;
  NSObject *v15;
  id v16;
  id v17;
  id v18;
  uint8_t buf[4];
  void *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v8 = a1;
  v9 = a2;
  v10 = a4;
  v11 = a5;
  if (v9)
  {
    _TIQueueBackground();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = v9;
    v16 = v10;
    v17 = v8;
    v18 = v11;
    TIDispatchAsync();

    v13 = v15;
  }
  else
  {
    TIProactiveQuickTypeOSLogFacility();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s %s"), "TIStatisticLogProactive", "Unexpected nil trigger");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      v20 = v14;
      _os_log_error_impl(&dword_1DA6F2000, v13, OS_LOG_TYPE_ERROR, "%@", buf, 0xCu);

    }
  }

}

void TIStatisticLogProactiveDescription(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  id v12;
  id v13;
  void *v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  if (v10 && v11)
  {
    _TIQueueBackground();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = v10;
    v16 = v13;
    v17 = v9;
    v18 = v11;
    v19 = v12;
    TIDispatchAsync();

  }
}

void TIStatisticsLogProactiveTriggered(void *a1, void *a2, void *a3)
{
  TIStatisticLogProactive(a1, a2, 0, a3, 0);
}

void TIStatisticsLogProactiveSuggestedZeroNoResult(void *a1, void *a2, void *a3)
{
  TIStatisticLogProactive(a1, a2, 1, a3, 0);
}

void TIStatisticsLogProactiveSuggestedZeroDescription(void *a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _BYTE v22[128];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = a4;
  objc_msgSend(MEMORY[0x1E0CB3500], "whitespaceCharacterSet");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "componentsSeparatedByCharactersInSet:", v11);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v13 = v12;
  v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
  if (v14)
  {
    v15 = v14;
    v16 = *(_QWORD *)v19;
    do
    {
      v17 = 0;
      do
      {
        if (*(_QWORD *)v19 != v16)
          objc_enumerationMutation(v13);
        TIStatisticLogProactiveDescription(v7, v8, *(void **)(*((_QWORD *)&v18 + 1) + 8 * v17++), CFSTR("suggestion"), v10);
      }
      while (v15 != v17);
      v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
    }
    while (v15);
  }

}

void TIStatisticsLogProactiveSuggestedZeroError(void *a1, void *a2, void *a3)
{
  TIStatisticLogProactive(a1, a2, 2, a3, 0);
}

void TIStatisticsLogProactiveSuggestedZeroTimeout(void *a1, void *a2, void *a3)
{
  TIStatisticLogProactive(a1, a2, 3, a3, 0);
}

void TIStatisticsLogProactiveSuggestedOne(void *a1, void *a2, void *a3, void *a4)
{
  void *v7;
  id v8;
  id v9;
  id v10;
  id v11;
  void *v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v13[0] = a4;
  v7 = (void *)MEMORY[0x1E0C99D20];
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  objc_msgSend(v7, "arrayWithObjects:count:", v13, 1);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  TIStatisticLogProactive(v11, v10, 4, v9, v12);
}

void TIStatisticsLogProactiveSuggestedTwo(void *a1, void *a2, void *a3, void *a4)
{
  TIStatisticLogProactive(a1, a2, 5, a3, a4);
}

void TIStatisticsLogProactiveSelectedFirst(void *a1, void *a2, void *a3, void *a4)
{
  void *v7;
  id v8;
  id v9;
  id v10;
  id v11;
  void *v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v13[0] = a4;
  v7 = (void *)MEMORY[0x1E0C99D20];
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  objc_msgSend(v7, "arrayWithObjects:count:", v13, 1);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  TIStatisticLogProactive(v11, v10, 6, v9, v12);
}

void TIStatisticsLogProactiveSelectedSecond(void *a1, void *a2, void *a3, void *a4)
{
  void *v7;
  id v8;
  id v9;
  id v10;
  id v11;
  void *v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v13[0] = a4;
  v7 = (void *)MEMORY[0x1E0C99D20];
  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  objc_msgSend(v7, "arrayWithObjects:count:", v13, 1);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  TIStatisticLogProactive(v11, v10, 7, v9, v12);
}

void TIStatisticsLogProactiveTimeOnScreen(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  id v8;
  void *v9;
  id v10;
  id v11;
  id v12;
  void *v13;
  void *v14;

  v6 = a1;
  v7 = a2;
  v8 = a4;
  _TIQueueBackground();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = v8;
  v14 = v7;
  v10 = v6;
  v11 = v7;
  v12 = v8;
  TIDispatchAsync();

}

void TIStatisticsLogProactiveEngagementZeroDescription(void *a1, void *a2, void *a3, void *a4)
{
  TIStatisticLogProactiveDescription(a1, a2, a3, CFSTR("engagement"), a4);
}

void TIStatisticsLogOfferedCandidateList(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  void *v8;
  void *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  +[_TIStatisticsProactiveTracker sharedInstance](_TIStatisticsProactiveTracker, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setLastAutocorrectionList:", v1);
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  objc_msgSend(v1, "predictions", 0);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v11;
    while (2)
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v11 != v6)
          objc_enumerationMutation(v3);
        v8 = *(void **)(*((_QWORD *)&v10 + 1) + 8 * i);
        objc_msgSend(v8, "responseKitCategory");
        v9 = (void *)objc_claimAutoreleasedReturnValue();

        if (v9)
        {
          objc_msgSend(v2, "setResponseKitEntryOffered:", v8);
          goto LABEL_11;
        }
      }
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
      if (v5)
        continue;
      break;
    }
  }
LABEL_11:

}

void TIStatisticsLogCandidateAcceptance(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  __int16 v14;
  void *v15;
  id v16;
  id v17;
  uint64_t v18;
  void *i;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  void *v29;
  id v30;
  id v31;
  id v32;
  id v33;
  id v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(uint64_t);
  void *v42;
  id v43;
  _BYTE v44[128];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  +[_TIStatisticsProactiveTracker sharedInstance](_TIStatisticsProactiveTracker, "sharedInstance");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "lastAutocorrectionList");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  _TIQueueBackground();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v39 = MEMORY[0x1E0C809B0];
  v40 = 3221225472;
  v41 = __TIStatisticsLogCandidateAcceptance_block_invoke;
  v42 = &unk_1EA106A98;
  v8 = v5;
  v43 = v8;
  TIDispatchAsync();

  if (!v6)
    goto LABEL_28;
  objc_msgSend(v6, "corrections");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "autocorrection");
  v10 = objc_claimAutoreleasedReturnValue();
  if (!v10)
  {

LABEL_6:
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    objc_msgSend(v6, "predictions");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = (id)objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v35, v44, 16);
    if (v17)
    {
      v18 = *(_QWORD *)v36;
      while (2)
      {
        for (i = 0; i != v17; i = (char *)i + 1)
        {
          if (*(_QWORD *)v36 != v18)
            objc_enumerationMutation(v15);
          v20 = *(void **)(*((_QWORD *)&v35 + 1) + 8 * (_QWORD)i);
          if ((objc_msgSend(v20, "usageTrackingMask") & 0x2000) != 0
            && (objc_msgSend(v20, "sourceMask") & 0x8000) == 0
            && (objc_msgSend(v20, "sourceMask") & 0x20000) == 0)
          {
            v16 = v20;
            goto LABEL_18;
          }
        }
        v17 = (id)objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v35, v44, 16);
        if (v17)
          continue;
        break;
      }
    }
    goto LABEL_20;
  }
  v11 = (void *)v10;
  objc_msgSend(v6, "corrections");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "autocorrection");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = objc_msgSend(v13, "usageTrackingMask");

  if ((v14 & 0x2000) == 0)
    goto LABEL_6;
  objc_msgSend(v6, "corrections");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v15, "autocorrection");
  v16 = (id)objc_claimAutoreleasedReturnValue();
LABEL_18:
  v17 = v16;

  if (!v17)
    goto LABEL_21;
  _TIQueueBackground();
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = v8;
  v17 = v17;
  TIDispatchAsync();

  v15 = v34;
LABEL_20:

LABEL_21:
  if ((objc_msgSend(v3, "usageTrackingMask") & 0x2000) != 0)
  {
    _TIQueueBackground();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v32 = v8;
    v33 = v3;
    TIDispatchAsync();

  }
  objc_msgSend(v8, "responseKitEntryOffered");
  v23 = (void *)objc_claimAutoreleasedReturnValue();

  if (v23)
  {
    objc_msgSend(v8, "responseKitEntryOffered");
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "setResponseKitEntryOffered:", 0);
    _TIQueueBackground();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = v4;
    v27 = v24;
    TIDispatchAsync();

    objc_msgSend(v3, "responseKitCategory");
    v28 = (void *)objc_claimAutoreleasedReturnValue();

    if (v28)
    {
      _TIQueueBackground();
      v29 = (void *)objc_claimAutoreleasedReturnValue();
      v30 = v26;
      v31 = v3;
      TIDispatchAsync();

    }
  }

LABEL_28:
}

void TIStatisticsCoreEnableTestingMode()
{
  void *v0;
  void *v1;
  void *v2;
  id v3;

  +[_TIStatisticsProactiveTracker sharedInstance](_TIStatisticsProactiveTracker, "sharedInstance");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "personalizationWordAcceptanceTracker");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "enableTestingMode");

  objc_msgSend(v3, "personalizationOfferTracker");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "enableTestingMode");

  objc_msgSend(v3, "personalizationEngagementTracker");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "enableTestingMode");

}

void TIStatisticsCoreDisableTestingMode()
{
  void *v0;
  void *v1;
  void *v2;
  id v3;

  +[_TIStatisticsProactiveTracker sharedInstance](_TIStatisticsProactiveTracker, "sharedInstance");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "personalizationWordAcceptanceTracker");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "disableTestingMode");

  objc_msgSend(v3, "personalizationOfferTracker");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "disableTestingMode");

  objc_msgSend(v3, "personalizationEngagementTracker");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "disableTestingMode");

}

id TIStatisticsCoreGetKeyValueDictForPersWordAcceptance()
{
  void *v0;
  void *v1;
  void *v2;

  +[_TIStatisticsProactiveTracker sharedInstance](_TIStatisticsProactiveTracker, "sharedInstance");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "personalizationWordAcceptanceTracker");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "getKeyValueDict");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

id TIStatisticsCoreGetKeyValueDictForPersOffer()
{
  void *v0;
  void *v1;
  void *v2;

  +[_TIStatisticsProactiveTracker sharedInstance](_TIStatisticsProactiveTracker, "sharedInstance");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "personalizationOfferTracker");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "getKeyValueDict");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

id TIStatisticsCoreGetKeyValueDictForPersEngagement()
{
  void *v0;
  void *v1;
  void *v2;

  +[_TIStatisticsProactiveTracker sharedInstance](_TIStatisticsProactiveTracker, "sharedInstance");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "personalizationEngagementTracker");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "getKeyValueDict");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

const void ***std::unique_ptr<KB::StaticDictionary>::reset[abi:nn180100](const void ****a1, const void ***a2)
{
  const void ***result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    KB::StaticDictionary::~StaticDictionary(result);
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

__n128 __Block_byref_object_copy__3005(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

uint64_t nameVariationsForContactCollection(void *a1)
{
  id v1;
  __CFDictionary *Mutable;
  uint64_t Transient;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  id v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  void *v46;
  __CFDictionary *v47;
  void *v48;
  id obj;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  void *v54;
  void *v55;
  void *v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  CFErrorRef err;
  _BYTE v66[128];
  uint8_t v67[128];
  uint8_t buf[4];
  void *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0D437C8], CFSTR("TextInput-SmartSelectionContacts"));
  err = 0;
  Transient = LXLexiconCreateTransient();
  objc_msgSend(v1, "allValues");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "sortedArrayUsingComparator:", &__block_literal_global_6);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v47 = Mutable;
  v48 = v1;
  if ((unint64_t)objc_msgSend(v1, "count") > 0x1F3)
    v7 = 500;
  else
    v7 = objc_msgSend(v1, "count");
  objc_msgSend(v6, "subarrayWithRange:", 0, v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  obj = v8;
  v51 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v61, v67, 16);
  if (v51)
  {
    v50 = *(_QWORD *)v62;
    do
    {
      v9 = 0;
      do
      {
        if (*(_QWORD *)v62 != v50)
          objc_enumerationMutation(obj);
        v53 = v9;
        v10 = *(void **)(*((_QWORD *)&v61 + 1) + 8 * v9);
        objc_msgSend(v10, "firstName");
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(v11);
        v12 = objc_claimAutoreleasedReturnValue();

        objc_msgSend(v10, "lastName");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(v13);
        v56 = (void *)objc_claimAutoreleasedReturnValue();

        objc_msgSend(v10, "nickname");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(v14);
        v15 = objc_claimAutoreleasedReturnValue();

        objc_msgSend(v10, "middleName");
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(v16);
        v17 = (void *)objc_claimAutoreleasedReturnValue();

        if (objc_msgSend(v17, "length"))
        {
          v18 = objc_msgSend(v17, "rangeOfComposedCharacterSequenceAtIndex:", 0);
          objc_msgSend(v17, "substringWithRange:", v18, v19);
          v54 = (void *)objc_claimAutoreleasedReturnValue();
        }
        else
        {
          v54 = 0;
        }
        v20 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        v21 = v20;
        v22 = v56;
        if (v12)
          objc_msgSend(v20, "addObject:", v12);
        if (v15)
          objc_msgSend(v21, "addObject:", v15);
        if (v17)
          objc_msgSend(v21, "addObject:", v17);
        v55 = (void *)v15;
        if (v56)
        {
          objc_msgSend(v21, "addObject:", v56);
          if (v12)
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@"), v12, v56);
            v23 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v23);

            v22 = v56;
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@"), v56, v12);
            v24 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v24);

            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@, %@"), v56, v12);
            v25 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v25);

          }
          if (v15)
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@"), v15, v22);
            v26 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v26);

            v22 = v56;
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@"), v56, v15);
            v27 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v27);

            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@, %@"), v56, v15);
            v28 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v28);

          }
          if (v12 && v17)
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@ %@"), v12, v17, v22);
            v29 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v29);

            v22 = v56;
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@ %@"), v56, v12, v17);
            v30 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v30);

            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@, %@ %@"), v56, v12, v17);
            v31 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v31);

          }
          if (v15 && v17)
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@ %@"), v15, v17, v22);
            v32 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v32);

            v22 = v56;
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@ %@"), v56, v15, v17);
            v33 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v33);

            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@, %@ %@"), v56, v15, v17);
            v34 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v34);

          }
          if (v12 && v54)
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@ %@"), v12, v54, v22);
            v35 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v35);

            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@. %@"), v12, v54, v22);
            v36 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v36);

          }
          if (v15 && v54)
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@ %@"), v15, v54, v22);
            v37 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v37);

            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ %@. %@"), v15, v54, v22);
            v38 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v21, "addObject:", v38);

          }
        }
        v52 = (void *)v12;
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        v39 = v21;
        v40 = objc_msgSend(v39, "countByEnumeratingWithState:objects:count:", &v57, v66, 16);
        if (v40)
        {
          v41 = v40;
          v42 = *(_QWORD *)v58;
          do
          {
            v43 = 0;
            do
            {
              if (*(_QWORD *)v58 != v42)
                objc_enumerationMutation(v39);
              v44 = *(_QWORD *)(*((_QWORD *)&v57 + 1) + 8 * v43);
              if (!LXLexiconAdd())
              {
                if (TICanLogMessageAtLevel_onceToken != -1)
                  dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
                if (TICanLogMessageAtLevel_logLevel >= 2)
                {
                  TIOSLogFacility();
                  v45 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
                  {
                    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s TISmartSelection: Failed to add \"%@\" to the contact name variations lexicon."), "nameVariationsForContactCollection", v44);
                    v46 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)buf = 138412290;
                    v69 = v46;
                    _os_log_debug_impl(&dword_1DA6F2000, v45, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);

                  }
                }
              }
              ++v43;
            }
            while (v41 != v43);
            v41 = objc_msgSend(v39, "countByEnumeratingWithState:objects:count:", &v57, v66, 16);
          }
          while (v41);
        }

        v9 = v53 + 1;
      }
      while (v53 + 1 != v51);
      v51 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v61, v67, 16);
    }
    while (v51);
  }

  if (v47)
    CFRelease(v47);

  return Transient;
}

id ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  uint64_t v4;
  id v5;

  v1 = a1;
  if (v1
    && (objc_msgSend(MEMORY[0x1E0CB3500], "whitespaceAndNewlineCharacterSet"),
        v2 = (void *)objc_claimAutoreleasedReturnValue(),
        objc_msgSend(v1, "stringByTrimmingCharactersInSet:", v2),
        v3 = (void *)objc_claimAutoreleasedReturnValue(),
        v4 = objc_msgSend(v3, "length"),
        v3,
        v2,
        v4))
  {
    v5 = v1;
  }
  else
  {
    v5 = 0;
  }

  return v5;
}

uint64_t ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  void *v4;
  id v5;
  void *v6;
  void *v7;
  double v8;
  double v9;
  void *v10;
  uint64_t v11;

  v4 = (void *)MEMORY[0x1E0CB37E8];
  v5 = a3;
  objc_msgSend(a2, "score");
  objc_msgSend(v4, "numberWithDouble:");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = (void *)MEMORY[0x1E0CB37E8];
  objc_msgSend(v5, "score");
  v9 = v8;

  objc_msgSend(v7, "numberWithDouble:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = objc_msgSend(v6, "compare:", v10);

  return v11;
}

id payloadForWordEntryAligned(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  char v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t i;
  void *v36;
  uint64_t v37;
  void *v38;
  void *v39;
  char v40;
  uint64_t v41;
  void *v42;
  void *v43;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  id v50;
  void *v51;
  void *v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  _QWORD v61[4];
  _BYTE v62[128];
  _BYTE v63[128];
  _QWORD v64[3];
  _QWORD v65[5];

  v65[3] = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  objc_msgSend(v3, "originalWord");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  outcomeFor(v5);
  v6 = objc_claimAutoreleasedReturnValue();
  v7 = (void *)v6;
  if (v6)
  {
    v65[0] = v6;
    v64[0] = CFSTR("outcome");
    v64[1] = CFSTR("alignmentConfidence");
    alignmentConfidence(objc_msgSend(v3, "inSessionAlignmentConfidence"));
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v65[1] = v8;
    v64[2] = kFeatureStringTypingEngine;
    objc_msgSend(v5, "acceptedCandidate");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "typingEngine");
    TIKeyboardCandidateTypingEngineTypeToString();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v65[2] = v10;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v65, v64, 3);
    v11 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v5, "candidatesOffered");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "lastObject");
    v13 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v13, "corrections");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v14, "autocorrection");
    v15 = (void *)objc_claimAutoreleasedReturnValue();

    if (objc_msgSend(v15, "isAutocorrection"))
    {
      v48 = v11;
      v49 = v7;
      v50 = v3;
      v51 = v4;
      v47 = v13;
      objc_msgSend(v13, "predictions");
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      v52 = v15;
      objc_msgSend(v15, "input");
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      v57 = 0u;
      v58 = 0u;
      v59 = 0u;
      v60 = 0u;
      v18 = v16;
      v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v57, v63, 16);
      if (v19)
      {
        v20 = v19;
        v21 = *(_QWORD *)v58;
LABEL_5:
        v22 = 0;
        while (1)
        {
          if (*(_QWORD *)v58 != v21)
            objc_enumerationMutation(v18);
          v23 = *(void **)(*((_QWORD *)&v57 + 1) + 8 * v22);
          objc_msgSend(v23, "candidate");
          v24 = objc_claimAutoreleasedReturnValue();
          if (v24)
          {
            v25 = (void *)v24;
            objc_msgSend(v23, "candidate");
            v26 = (void *)objc_claimAutoreleasedReturnValue();
            v27 = objc_msgSend(v26, "isEqualToString:", v17);

            if ((v27 & 1) != 0)
              break;
          }
          if (v20 == ++v22)
          {
            v20 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v57, v63, 16);
            if (v20)
              goto LABEL_5;
            goto LABEL_12;
          }
        }
        v4 = v51;
        payloadForCandidate(v23, CFSTR("_input"), v51);
        v29 = (void *)objc_claimAutoreleasedReturnValue();

        if (v29)
          goto LABEL_17;
      }
      else
      {
LABEL_12:

        v4 = v51;
      }
      payloadForText(v17, CFSTR("_input"), v4);
      v29 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_17:
      payloadForCandidate(v52, CFSTR("_autocorrection"), v4);
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      v53 = 0u;
      v54 = 0u;
      v55 = 0u;
      v56 = 0u;
      v31 = v18;
      v32 = objc_msgSend(v31, "countByEnumeratingWithState:objects:count:", &v53, v62, 16);
      if (v32)
      {
        v33 = v32;
        v45 = v30;
        v46 = v29;
        v34 = *(_QWORD *)v54;
        while (2)
        {
          for (i = 0; i != v33; ++i)
          {
            if (*(_QWORD *)v54 != v34)
              objc_enumerationMutation(v31);
            v36 = *(void **)(*((_QWORD *)&v53 + 1) + 8 * i);
            objc_msgSend(v36, "candidate", v45, v46);
            v37 = objc_claimAutoreleasedReturnValue();
            if (v37)
            {
              v38 = (void *)v37;
              objc_msgSend(v36, "candidate");
              v39 = (void *)objc_claimAutoreleasedReturnValue();
              v40 = objc_msgSend(v39, "isEqualToString:", v17);

              if ((v40 & 1) == 0)
              {
                v4 = v51;
                payloadForCandidate(v36, CFSTR("_alternate"), v51);
                v41 = objc_claimAutoreleasedReturnValue();
                v30 = v45;
                v29 = v46;
                goto LABEL_29;
              }
            }
          }
          v33 = objc_msgSend(v31, "countByEnumeratingWithState:objects:count:", &v53, v62, 16);
          if (v33)
            continue;
          break;
        }
        v4 = v51;
        v30 = v45;
        v29 = v46;
      }
      v41 = MEMORY[0x1E0C9AA70];
LABEL_29:

      v61[0] = v29;
      v61[1] = v30;
      v11 = v48;
      v61[2] = v41;
      v61[3] = v48;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v61, 4);
      v42 = (void *)v41;
      v43 = (void *)objc_claimAutoreleasedReturnValue();
      mergeDicts(v43);
      v28 = (void *)objc_claimAutoreleasedReturnValue();

      v7 = v49;
      v3 = v50;
      v13 = v47;
      v15 = v52;
    }
    else
    {
      v28 = 0;
    }

  }
  else
  {
    v28 = 0;
  }

  return v28;
}

const __CFString *outcomeFor(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  const __CFString *v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t i;
  void *v15;
  void *v16;
  char v17;
  void *v19;
  void *v20;
  id obj;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[128];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(v1, "candidatesOffered");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "lastObject");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v3, "corrections");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "autocorrection");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v5, "input");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "candidate");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "acceptedString");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "stringByReplacingOccurrencesOfString:withString:", CFSTR("’"), CFSTR("'"));
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  if ((objc_msgSend(v6, "isEqualToString:", v7) & 1) != 0)
  {
    v10 = 0;
  }
  else if (objc_msgSend(v9, "isEqualToString:", v7))
  {
    if ((objc_msgSend(v1, "wordEntryType") & 4) != 0)
    {
      v10 = CFSTR("selectedAutocorrection");
    }
    else
    {
      objc_msgSend(v1, "editedEntry");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      v12 = v11;
      if (v11)
      {
        objc_msgSend(v11, "acceptedString");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        if ((objc_msgSend(v13, "isEqualToString:", v6) & 1) != 0)
        {
          v10 = CFSTR("revisedToInput");
        }
        else if ((objc_msgSend(v13, "isEqualToString:", v9) & 1) != 0)
        {
          v10 = CFSTR("revisedBackToAutocorrection");
        }
        else
        {
          v26 = 0u;
          v27 = 0u;
          v24 = 0u;
          v25 = 0u;
          objc_msgSend(v3, "predictions");
          obj = (id)objc_claimAutoreleasedReturnValue();
          v23 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
          if (v23)
          {
            v19 = v3;
            v20 = v12;
            v22 = *(_QWORD *)v25;
            v10 = CFSTR("revisedToAlternate");
            while (2)
            {
              for (i = 0; i != v23; ++i)
              {
                if (*(_QWORD *)v25 != v22)
                  objc_enumerationMutation(obj);
                objc_msgSend(*(id *)(*((_QWORD *)&v24 + 1) + 8 * i), "candidate");
                v15 = (void *)objc_claimAutoreleasedReturnValue();
                v16 = v13;
                v17 = objc_msgSend(v13, "isEqualToString:", v15);

                if ((v17 & 1) != 0)
                {
                  v12 = v20;
                  v13 = v16;
                  goto LABEL_27;
                }
                v13 = v16;
              }
              v23 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
              if (v23)
                continue;
              break;
            }
            v10 = CFSTR("revisedToNew");
            v12 = v20;
LABEL_27:
            v3 = v19;
          }
          else
          {
            v10 = CFSTR("revisedToNew");
          }

        }
      }
      else
      {
        v10 = CFSTR("acceptedAutocorrection");
      }

    }
  }
  else if (objc_msgSend(v9, "isEqualToString:", v6))
  {
    if ((objc_msgSend(v1, "wordEntryType") & 4) != 0)
      v10 = CFSTR("selectedInput");
    else
      v10 = CFSTR("rejectedAutocorrection");
  }
  else
  {
    v10 = CFSTR("selectedAlternate");
  }

  return v10;
}

id payloadForCandidate(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  void *v13;
  void *v14;
  uint64_t v15;
  double v16;
  double v17;
  double v18;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  void *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v48;
  void *v49;
  _QWORD v50[3];
  _QWORD v51[2];
  _QWORD v52[2];
  void *v53;
  void *v54;
  _QWORD v55[2];
  _QWORD v56[2];
  void *v57;
  _QWORD v58[3];

  v58[1] = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  objc_msgSend(CFSTR("sourceBitset"), "stringByAppendingString:", v6);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v57 = v8;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", objc_msgSend(v5, "sourceMask"));
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v58[0] = v9;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v58, &v57, 1);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v48 = v10;
    v12 = v5;
    objc_msgSend(CFSTR("geometryScore"), "stringByAppendingString:", v6);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v55[0] = v13;
    v14 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend(v12, "geometryScore");
    v17 = v16 * 10.0;
    if (v16 < -10.0)
      v17 = -100.0;
    if (v16 <= 0.0)
      v18 = v17;
    else
      v18 = 0.0;
    LODWORD(v15) = vcvtmd_s64_f64(v18);
    objc_msgSend(v14, "numberWithInt:", v15, v48);
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v56[0] = v19;
    objc_msgSend(CFSTR("languageModelScore"), "stringByAppendingString:", v6);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v55[1] = v20;
    v21 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend(v12, "wordScore");
    v24 = v23 * 10.0;
    if (v23 < -10.0)
      v24 = -100.0;
    if (v23 <= 0.0)
      v25 = v24;
    else
      v25 = 0.0;
    LODWORD(v22) = vcvtmd_s64_f64(v25);
    objc_msgSend(v21, "numberWithInt:", v22);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    v56[1] = v26;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v56, v55, 2);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "addEntriesFromDictionary:", v27);

    objc_msgSend(v12, "lexiconLocale");
    v28 = (void *)objc_claimAutoreleasedReturnValue();

    if (v28)
    {
      objc_msgSend(CFSTR("language"), "stringByAppendingString:", v6);
      v29 = (void *)objc_claimAutoreleasedReturnValue();
      v53 = v29;
      objc_msgSend(v12, "lexiconLocale");
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      v54 = v30;
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v54, &v53, 1);
      v31 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "addEntriesFromDictionary:", v31);

    }
    if ((objc_msgSend(v12, "dynamicUsageCount") & 0x80000000) == 0)
    {
      objc_msgSend(CFSTR("localUsageCount"), "stringByAppendingString:", v6);
      v32 = (void *)objc_claimAutoreleasedReturnValue();
      v51[0] = v32;
      v33 = (void *)MEMORY[0x1E0CB37E8];
      v34 = objc_msgSend(v12, "dynamicUsageCount");
      if ((int)v34 > 4095)
      {
        v35 = 4096;
      }
      else
      {
        do
        {
          v35 = v34;
          v34 = ((_DWORD)v34 - 1) & v34;
        }
        while ((_DWORD)v34);
      }
      objc_msgSend(v33, "numberWithInt:", v35);
      v36 = (void *)objc_claimAutoreleasedReturnValue();
      v52[0] = v36;
      objc_msgSend(CFSTR("localPenaltyCount"), "stringByAppendingString:", v6);
      v37 = (void *)objc_claimAutoreleasedReturnValue();
      v51[1] = v37;
      v38 = (void *)MEMORY[0x1E0CB37E8];
      v39 = objc_msgSend(v12, "dynamicPenaltyCount");
      if ((int)v39 > 4095)
      {
        v40 = 4096;
      }
      else
      {
        do
        {
          v40 = v39;
          v39 = ((_DWORD)v39 - 1) & v39;
        }
        while ((_DWORD)v39);
      }
      objc_msgSend(v38, "numberWithInt:", v40);
      v41 = (void *)objc_claimAutoreleasedReturnValue();
      v52[1] = v41;
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v52, v51, 2);
      v42 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "addEntriesFromDictionary:", v42);

    }
    v10 = v49;
  }
  v50[0] = v10;
  v50[1] = v11;
  objc_msgSend(v5, "candidate");
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  payloadForText(v43, v6, v7);
  v44 = (void *)objc_claimAutoreleasedReturnValue();

  v50[2] = v44;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v50, 3);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  mergeDicts(v45);
  v46 = (void *)objc_claimAutoreleasedReturnValue();

  return v46;
}

uint64_t KB::enum_value_from_string<KB::CandidateFilter::WordEquivalenceType>(uint64_t *a1)
{
  uint64_t v1;
  int v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v1 = *((unsigned __int8 *)a1 + 23);
  v2 = (char)v1;
  if ((v1 & 0x80u) != 0)
    v1 = a1[1];
  if (v1 == 22)
  {
    if (v2 >= 0)
      v11 = a1;
    else
      v11 = (uint64_t *)*a1;
    v12 = *v11;
    v13 = v11[1];
    v14 = *(uint64_t *)((char *)v11 + 14);
    if (v12 == 0x4665636166727553 && v13 == 0x76697571456D726FLL && v14 == 0x65636E616C617669)
    {
      v10 = 0x100000000;
      v9 = 1;
      return v9 | v10;
    }
    goto LABEL_27;
  }
  if (v1 != 18
    || (v2 >= 0 ? (v3 = a1) : (v3 = (uint64_t *)*a1),
        (v4 = *v3, v5 = v3[1], v6 = *((unsigned __int16 *)v3 + 8), v4 == 0x4579656B74726F53)
      ? (v7 = v5 == 0x6E656C6176697571)
      : (v7 = 0),
        v7 ? (v8 = v6 == 25955) : (v8 = 0),
        !v8))
  {
LABEL_27:
    v10 = 0;
    v9 = 0;
    return v9 | v10;
  }
  v9 = 0;
  v10 = 0x100000000;
  return v9 | v10;
}

void KB::CandidateFilter::remove_candidates_satisfying_predicate(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  int *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  KB::Candidate *v12;
  KB::Candidate *v13;
  _QWORD *v14;
  uint64_t *i;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  _BYTE v19[24];
  _BYTE *v20;
  int *v21;
  __int128 v22;
  _QWORD v23[3];
  _QWORD *v24;
  int *v25;
  int v26;
  __int16 v27;
  char v28;
  void *v29;
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v26 = 0x100000;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  if (a2)
  {
    v8 = &v26;
    KB::String::ensure_capacity((KB::String *)&v26, 256);
  }
  else
  {
    v8 = 0;
  }
  *(_QWORD *)&v22 = a2;
  *((_QWORD *)&v22 + 1) = a3;
  v9 = v23;
  v10 = (_QWORD *)a4[3];
  if (!v10)
  {
    v24 = 0;
    v25 = v8;
    v12 = *(KB::Candidate **)a1;
    v13 = *(KB::Candidate **)(a1 + 8);
    v18 = v22;
    v14 = v19;
LABEL_12:
    v20 = 0;
    goto LABEL_13;
  }
  if (v10 == a4)
  {
    v24 = v23;
    (*(void (**)(_QWORD *, _QWORD *))(*a4 + 24))(a4, v23);
    v11 = v24;
  }
  else
  {
    v11 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v10 + 16))(v10);
    v24 = v11;
  }
  v25 = v8;
  v12 = *(KB::Candidate **)a1;
  v13 = *(KB::Candidate **)(a1 + 8);
  v18 = v22;
  v14 = v19;
  if (!v11)
    goto LABEL_12;
  if (v11 == v23)
  {
    v20 = v19;
    (*(void (**)(_QWORD *, _BYTE *))(v23[0] + 24))(v23, v19);
  }
  else
  {
    v20 = (_BYTE *)(*(uint64_t (**)(_QWORD *))(*v11 + 16))(v11);
  }
LABEL_13:
  v21 = v25;
  if (v12 != v13)
  {
    while ((KB::CandidateFilter::remove_candidates_satisfying_predicate(std::vector<KB::Candidate> &,__CFString *,char const*,std::function<BOOL ()(KB::Candidate const&,KB::String *)>)::$_0::operator()((uint64_t)&v18, v12) & 1) == 0)
    {
      v12 = (KB::Candidate *)((char *)v12 + 1000);
      if (v12 == v13)
      {
        v12 = v13;
        goto LABEL_23;
      }
    }
    if (v12 != v13)
    {
      for (i = (uint64_t *)((char *)v12 + 1000); i != (uint64_t *)v13; i += 125)
      {
        if ((KB::CandidateFilter::remove_candidates_satisfying_predicate(std::vector<KB::Candidate> &,__CFString *,char const*,std::function<BOOL ()(KB::Candidate const&,KB::String *)>)::$_0::operator()((uint64_t)&v18, (KB::Candidate *)i) & 1) == 0)
        {
          KB::Candidate::operator=((uint64_t *)v12, i);
          v12 = (KB::Candidate *)((char *)v12 + 1000);
        }
      }
    }
  }
LABEL_23:
  if (v20 == v19)
  {
    v16 = 4;
  }
  else
  {
    if (!v20)
      goto LABEL_28;
    v16 = 5;
    v14 = v20;
  }
  (*(void (**)(_QWORD *))(*v14 + 8 * v16))(v14);
LABEL_28:
  std::vector<KB::Candidate>::erase(a1, (uint64_t *)v12, *(KB::Candidate **)(a1 + 8));
  if (v24 == v23)
  {
    v17 = 4;
  }
  else
  {
    if (!v24)
      goto LABEL_33;
    v17 = 5;
    v9 = v24;
  }
  (*(void (**)(_QWORD *))(*v9 + 8 * v17))(v9);
LABEL_33:
  if (v29)
  {
    if (v28 == 1)
      free(v29);
  }
}

uint64_t KB::CandidateFilter::remove_candidates_satisfying_predicate(std::vector<KB::Candidate> &,__CFString *,char const*,std::function<BOOL ()(KB::Candidate const&,KB::String *)>)::$_0::operator()(uint64_t a1, KB::Candidate *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  __CFString *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  KB::String *v17;
  _WORD v19[3];
  char v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  _QWORD v25[3];

  v25[2] = *MEMORY[0x1E0C80C00];
  v4 = a1 + 40;
  v3 = *(_QWORD *)(a1 + 40);
  v23 = *(_QWORD *)(v4 + 8);
  if (!v3)
    std::__throw_bad_function_call[abi:nn180100]();
  v6 = (*(uint64_t (**)(uint64_t, KB::Candidate *, uint64_t *))(*(_QWORD *)v3 + 48))(v3, a2, &v23);
  if ((_DWORD)v6)
  {
    v7 = *(__CFString **)a1;
    if (*(_QWORD *)a1)
    {
      KB::Candidate::capitalized_string(a2, (uint64_t)&v23);
      v8 = (const char *)v24;
      if (!v24)
        v8 = (const char *)v25;
      v9 = "";
      if ((_WORD)v23)
        v10 = v8;
      else
        v10 = "";
      KB::Candidate::token_ids_as_string(a2, (uint64_t)v19);
      v12 = (const char *)v21;
      if (!v21)
        v12 = (const char *)&v22;
      if (v19[0])
        v13 = v12;
      else
        v13 = "";
      v14 = *(_QWORD *)(a1 + 48);
      if (v14 && *(_WORD *)v14)
      {
        v15 = *(const char **)(v14 + 8);
        v16 = (const char *)(v14 + 16);
        if (v15)
          v9 = v15;
        else
          v9 = v16;
      }
      KB::append_format(v7, (__CFString *)"[%s] {%s} removed by %s (%s)\n", v11, v10, v13, *(_QWORD *)(a1 + 8), v9);
      if (v21 && v20 == 1)
        free(v21);
      if (v24 && BYTE6(v23) == 1)
        free(v24);
    }
  }
  v17 = *(KB::String **)(a1 + 48);
  if (v17)
    KB::String::clear(v17);
  return v6;
}

_QWORD *KB::CandidateFilter::remove_candidates_with_input_mismatch(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  _QWORD *result;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[3];
  _QWORD *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v20 = a6;
  v11 = a4 + 1000;
  v12 = *(_QWORD *)(a5 + 16);
  if (v12)
  {
    do
      v13 = __ldaxr((unsigned int *)v12);
    while (__stlxr(v13 + 1, (unsigned int *)v12));
  }
  v14 = *(_QWORD *)(v12 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v12);
  v15 = *(_QWORD *)(a5 + 56);
  v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v17 = operator new(0x30uLL);
  *(_QWORD *)v17 = &off_1EA0FBFC0;
  v17[2] = a3;
  *((_QWORD *)v17 + 2) = a4;
  *((_QWORD *)v17 + 3) = v11;
  *((_QWORD *)v17 + 4) = v14;
  *((_QWORD *)v17 + 5) = &v20;
  v22 = v17;
  KB::CandidateFilter::remove_candidates_satisfying_predicate(a2, v15, v16, v21);
  result = v22;
  if (v22 == v21)
  {
    v19 = 4;
    result = v21;
  }
  else
  {
    if (!v22)
      return result;
    v19 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8 * v19))(result);
}

void std::__function::__func<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0,std::allocator<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0,std::allocator<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1EA0FBFC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0,std::allocator<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1EA0FBFC0;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0,std::allocator<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, _QWORD *a2, KB::String **a3)
{
  KB::String *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  uint64_t v12;
  BOOL v13;

  v5 = *a3;
  v6 = KB::Candidate::num_words_matching_input(a2, *(_QWORD **)(a1 + 16), *(_QWORD *)(a1 + 32));
  v7 = *(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(v7 + 1000))
    v8 = KB::Candidate::num_words_matching_input(a2, (_QWORD *)v7, *(_QWORD *)(a1 + 32));
  else
    v8 = 0;
  v9 = *(_DWORD *)(a1 + 8);
  if (v9)
    v10 = v6 >= v9;
  else
    v10 = 1;
  v12 = !v10 && v8 < v9;
  if (v5)
    v13 = (_DWORD)v12 == 0;
  else
    v13 = 1;
  if (!v13)
    KB::String::append_format(v5, "# candidates words matching input == %u, converted input == %u < %u == required words matching input (%s)", v6, v8, *(_DWORD *)(a1 + 8), **(const char ***)(a1 + 40));
  return v12;
}

uint64_t KB::CandidateFilter::_sortkey_equal_predicate(KB::CandidateFilter *this, const KB::CandidateFilterResources *a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    do
      v3 = __ldaxr((unsigned int *)v2);
    while (__stlxr(v3 + 1, (unsigned int *)v2));
  }
  v4 = *(_QWORD *)(v2 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v2);
  return v4;
}

uint64_t KB::CandidateFilter::is_suggestible_for_input(uint64_t *a1, _QWORD *a2, int a3, KB::WordSuggestionPolicy *a4, uint64_t a5, KB::String *a6)
{
  uint64_t v11;
  KB::Word *v12;
  KB::Word *v13;
  uint64_t v14;
  KB::Word *v15;
  unsigned int v16;
  KB::Word *v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  unsigned int v21;
  const KB::Word *v22;
  const char *v25;
  const char *v26;
  _QWORD v27[2];
  BOOL (*v28)(uint64_t, const KB::Word *);
  void *v29;
  KB::WordSuggestionPolicy *v30;
  KB::String *v31;
  _WORD v32[3];
  char v33;
  void *v34;
  _QWORD v35[3];

  v35[2] = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if (a3 == 1)
    {
      v11 = *a1;
      v12 = (KB::Word *)a1[1];
      v27[0] = MEMORY[0x1E0C809B0];
      v27[1] = 0x40000000;
      v28 = ___ZN2KB15CandidateFilter24is_suggestible_for_inputERKNS_9CandidateES3_NS0_19WordEquivalenceTypeERKNS_20WordSuggestionPolicyERKNSt3__18functionIFiRKNS_6StringESC_EEEPSA__block_invoke;
      v29 = &__block_descriptor_tmp_3374;
      v30 = a4;
      v31 = a6;
      if (v11)
      {
        v13 = (KB::Word *)((char *)v12 + 240 * v11);
        v14 = 240 * v11;
        while ((((uint64_t (*)(_QWORD *, KB::Word *))v28)(v27, v12) & 1) == 0)
        {
          v12 = (KB::Word *)((char *)v12 + 240);
          v14 -= 240;
          if (!v14)
          {
            v12 = v13;
            break;
          }
        }
        v15 = v12;
        v11 = *a1;
        v12 = (KB::Word *)a1[1];
      }
      else
      {
        v15 = v12;
      }
      v17 = (KB::Word *)((char *)v12 + 240 * v11);
      if (a6 && v15 != v17)
      {
        KB::Word::capitalized_string(v15, (uint64_t)v32);
        v18 = (const char *)v34;
        if (!v34)
          v18 = (const char *)v35;
        if (v32[0])
          v19 = v18;
        else
          v19 = "";
        KB::String::append_format(a6, " => '%s' is never suggestible", v19);
        if (v34 && v33 == 1)
          free(v34);
      }
      if (v15 != v17)
        return 0;
      v16 = KB::Candidate::num_words_preserving_input(a1, a2, a5);
    }
    else
    {
      v16 = 0;
    }
  }
  else
  {
    v16 = KB::Candidate::num_words_matching_input(a1, a2, a5);
  }
  if (*a1 <= (unint64_t)v16)
    return 1;
  v20 = v16;
  v21 = v16 + 1;
  while (1)
  {
    v22 = (const KB::Word *)(a1[1] + 240 * v20);
    if ((KB::WordSuggestionPolicy::is_suggestible(a4, v22, a6) & 1) == 0)
      break;
    v20 = v21;
    if (*a1 <= (unint64_t)v21++)
      return 1;
  }
  if (a6)
  {
    KB::Word::capitalized_string(v22, (uint64_t)v32);
    v25 = (const char *)v34;
    if (!v34)
      v25 = (const char *)v35;
    if (v32[0])
      v26 = v25;
    else
      v26 = "";
    KB::String::append_format(a6, " => '%s' does not preserve input and is not predictible", v26);
    if (v34)
    {
      if (v33 == 1)
        free(v34);
    }
  }
  return 0;
}

BOOL ___ZN2KB15CandidateFilter24is_suggestible_for_inputERKNS_9CandidateES3_NS0_19WordEquivalenceTypeERKNS_20WordSuggestionPolicyERKNSt3__18functionIFiRKNS_6StringESC_EEEPSA__block_invoke(uint64_t a1, const KB::Word *a2)
{
  return KB::WordSuggestionPolicy::is_never_suggestible(*(KB::WordSuggestionPolicy **)(a1 + 32), a2, *(KB::String **)(a1 + 40));
}

uint64_t KB::CandidateFilter::candidate_matches_input(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t result;
  KB::CandidateFilter *v8;
  const Candidate *v9;
  _QWORD v10[2];

  if (!*(_WORD *)(a1 + 888))
    KB::Candidate::compute_string((KB::Candidate *)a1);
  if (!*(_WORD *)(a2 + 888))
    KB::Candidate::compute_string((KB::Candidate *)a2);
  v6 = *(_QWORD *)(a3 + 24);
  if (v6)
  {
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 48))(v6, a1 + 888, a2 + 888);
    if ((_DWORD)result)
    {
      if (!*(_WORD *)(a1 + 888))
        KB::Candidate::compute_string((KB::Candidate *)a1);
      if (!*(_WORD *)(a2 + 888))
        KB::Candidate::compute_string((KB::Candidate *)a2);
      v10[0] = &off_1EA103EF8;
      v10[1] = 1;
      return KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)v10, (const KB::String *)(a1 + 888), (const KB::String *)(a2 + 888), 0, 0);
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    return KB::CandidateFilter::count_linguistic_words(v8, v9);
  }
  return result;
}

uint64_t KB::CandidateFilter::count_linguistic_words(KB::CandidateFilter *this, const Candidate *a2)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    return 0;
  result = 0;
  v5 = *((_QWORD *)this + 1);
  v6 = 240 * v2;
  v7 = v5 + 136;
  do
  {
    if ((*(_BYTE *)(v7 - 1) & 4) == 0 && (*(_DWORD *)(v7 + 4) - 500) < 0xFFFFFE0D)
      ++result;
    v7 += 240;
    v6 -= 240;
  }
  while (v6);
  return result;
}

uint64_t KB::CandidateFilter::language_id_for_context_with_confidence(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unsigned int v9;
  unint64_t *v10;
  unint64_t v11;
  float v13;

  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(std::__shared_weak_count **)(a2 + 32);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v13 = 0.0;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, float *))(*(_QWORD *)v5 + 424))(v5, a1, &v13);
  if (v6)
  {
    v10 = (unint64_t *)&v6->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (v13 >= a3)
    return v9;
  else
    return 0;
}

uint64_t KB::CandidateFilter::language_id_for_context_and_candidate_with_confidence(KB::CandidateFilter *this, const KB::LanguageModelContext *a2, const KB::Candidate *a3, float a4, const KB::CandidateFilterResources *a5)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  TITokenID v17;
  TITokenID v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  uint64_t v24;
  std::__shared_weak_count *v25;
  void *__p;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void **v31;
  void *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)a2)
  {
    v8 = 0;
    v9 = 240 * *(_QWORD *)a2;
    v10 = *((_QWORD *)a2 + 1) + 136;
    do
    {
      if ((*(_BYTE *)(v10 - 1) & 4) == 0 && (*(_DWORD *)(v10 + 4) - 500) < 0xFFFFFE0D)
        ++v8;
      v10 += 240;
      v9 -= 240;
    }
    while (v9);
  }
  else
  {
    v8 = 0;
  }
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v24, this);
  v12 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    v13 = 0;
    v14 = *((_QWORD *)a2 + 1);
    v15 = 240 * v12;
    do
    {
      v16 = v13 + 1;
      if (v13 + 1 >= v8)
        break;
      if ((*(_BYTE *)(v14 + 135) & 4) == 0)
      {
        v17 = *(TITokenID *)(v14 + 136);
        KB::Word::capitalized_string((KB::Word *)v14, (uint64_t)&v31);
        v18 = v17;
        KB::LanguageModelContext::append((KB::LanguageModelContext *)&v24, v18, (const KB::String *)&v31, 0);
        if (v32 && BYTE6(v31) == 1)
          free(v32);
        v13 = v16;
      }
      v14 += 240;
      v15 -= 240;
    }
    while (v15);
  }
  if ((KB::LanguageModelContext::is_linguistically_void((KB::LanguageModelContext *)&v24) & 1) != 0)
    v19 = 0;
  else
    v19 = KB::CandidateFilter::language_id_for_context_with_confidence((uint64_t)&v24, (uint64_t)a3, a4);
  v31 = (void **)&v30;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v31);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v29);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v28);
  if (__p)
  {
    v27 = __p;
    operator delete(__p);
  }
  v20 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  return v19;
}

uint64_t KB::CandidateFilter::candidate_static_words_from_same_language(KB::CandidateFilter *this, const Candidate *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  BOOL v6;
  _QWORD v7[2];
  BOOL (*v8)(uint64_t, uint64_t);
  void *v9;
  int v10;

  v2 = *(_QWORD *)this;
  v3 = *((_QWORD *)this + 1);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v8 = ___ZN2KB15CandidateFilter41candidate_static_words_from_same_languageERKNS_9CandidateEj_block_invoke;
  v9 = &__block_descriptor_tmp_6_3380;
  v10 = (int)a2;
  if (!v2)
    return 1;
  v4 = 240 * v2 - 240;
  do
  {
    result = ((uint64_t (*)(_QWORD *, uint64_t))v8)(v7, v3);
    v3 += 240;
    if ((_DWORD)result)
      v6 = v4 == 0;
    else
      v6 = 1;
    v4 -= 240;
  }
  while (!v6);
  return result;
}

BOOL ___ZN2KB15CandidateFilter41candidate_static_words_from_same_languageERKNS_9CandidateEj_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if ((*(_BYTE *)(a2 + 106) & 4) == 0)
    return 1;
  v2 = *(_QWORD *)(a2 + 136);
  if (*(_DWORD *)(a1 + 32) == (_DWORD)v2)
    return 1;
  if ((*(_BYTE *)(a2 + 135) & 4) != 0)
    return 1;
  return (HIDWORD(v2) - 1) < 0x1F3;
}

uint64_t KB::CandidateFilter::_sortkey_factory(KB::CandidateFilter *this, const KB::CandidateFilterResources *a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    do
      v3 = __ldaxr((unsigned int *)v2);
    while (__stlxr(v3 + 1, (unsigned int *)v2));
  }
  v4 = *(_QWORD *)(v2 + 8) + 112;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v2);
  return v4;
}

unsigned int *KB::CandidateFilter::_sortkey_for_string@<X0>(_LXLexicon *this@<X0>, const KB::String *a2@<X1>, _WORD *a3@<X8>)
{
  uint64_t v4;
  unsigned int v5;

  v4 = *((_QWORD *)a2 + 2);
  if (v4)
  {
    do
      v5 = __ldaxr((unsigned int *)v4);
    while (__stlxr(v5 + 1, (unsigned int *)v4));
  }
  KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(v4 + 8) + 72), this, a3);
  return WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v4);
}

void KB::LanguageModel::synchronized_load(KB::LanguageModel *this)
{
  NSObject *v1;
  KB::LanguageModel *v2;
  id v3;

  KB::LanguageModel::background_loading_queue(this);
  v1 = objc_claimAutoreleasedReturnValue();
  dispatch_assert_queue_not_V2(v1);

  KB::LanguageModel::background_loading_queue(v2);
  v3 = (id)objc_claimAutoreleasedReturnValue();
  TIDispatchSync();

}

uint64_t KB::LanguageModel::does_provide_completions(KB::LanguageModel *this)
{
  return 0;
}

uint64_t KB::LanguageModel::advanced_models_loaded(KB::LanguageModel *this)
{
  return 0;
}

uint64_t KB::LanguageModel::does_provide_inline_completions(KB::LanguageModel *this)
{
  return 0;
}

uint64_t KB::LanguageModel::does_provide_inline_completions_for_locale(KB::LanguageModel *this, const KB::String *a2)
{
  return 0;
}

uint64_t KB::LanguageModel::supports_multilingual(KB::LanguageModel *this)
{
  return 0;
}

uint64_t KB::LanguageModel::supports_fragment_based_conditional_prob(KB::LanguageModel *this)
{
  return 0;
}

uint64_t KB::LanguageModel::should_score_completion_candidate(KB::LanguageModel *this, const Candidate *a2)
{
  return 1;
}

void KB::LanguageModel::get_num_candidates(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[16] = 0;
}

void KB::LanguageModel::copyLinguisticDataFiles(CFDictionaryRef *a1@<X8>)
{
  const __CFAllocator *v3;
  void *values;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  *a1 = CFDictionaryCreate(v3, MEMORY[0x1E0D43508], (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (values)
    CFRelease(values);
}

uint64_t KB::LanguageModel::id_for_dynamic_word(uint64_t a1, const __CFString *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE v8[8];
  void *v9;
  _QWORD v10[31];

  v10[30] = *MEMORY[0x1E0C80C00];
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
    return 0;
  v5 = *a3;
  KB::utf8_string(a2, (uint64_t)v8);
  (*(void (**)(_QWORD *__return_ptr, _QWORD, _BYTE *))(**(_QWORD **)(v5 + 24) + 56))(v10, *(_QWORD *)(v5 + 24), v8);
  v6 = v10[17];
  KB::Word::~Word((KB::Word *)v10);
  if (v9 && v8[6] == 1)
    free(v9);
  return v6;
}

CFTypeRef KB::LanguageModel::engine_string_to_surface_form@<X0>(CFTypeRef cf@<X1>, _QWORD *a2@<X8>)
{
  CFTypeRef result;

  *a2 = cf;
  if (cf)
  {
    result = CFRetain(cf);
    *a2 = cf;
  }
  return result;
}

id KB::LanguageModel::background_loading_queue(KB::LanguageModel *this)
{
  if (KB::LanguageModel::background_loading_queue(void)::onceToken != -1)
    dispatch_once(&KB::LanguageModel::background_loading_queue(void)::onceToken, &__block_literal_global_12);
  return (id)KB::LanguageModel::background_loading_queue(void)::__queue;
}

uint64_t ___ZN2KB13LanguageModel17synchronized_loadEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 32) + 72))(*(_QWORD *)(a1 + 32), 1);
}

void ___ZN2KB13LanguageModel24background_loading_queueEv_block_invoke()
{
  dispatch_queue_t v0;
  void *v1;
  NSObject *v2;

  dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  v2 = objc_claimAutoreleasedReturnValue();
  v0 = dispatch_queue_create("com.apple.TextInput.language-model.loading", v2);
  v1 = (void *)KB::LanguageModel::background_loading_queue(void)::__queue;
  KB::LanguageModel::background_loading_queue(void)::__queue = (uint64_t)v0;

}

_QWORD *KB::LanguageModel::LanguageModel(_QWORD *this)
{
  *this = off_1EA0FC008;
  return this;
}

BOOL KB::LanguageModel::lexicon_id_active(KB::LanguageModel *this, int a2)
{
  _DWORD *v3;
  _DWORD *v4;
  _DWORD *v6;
  _DWORD *v7;

  (*(void (**)(_DWORD **__return_ptr))(*(_QWORD *)this + 48))(&v6);
  v3 = v7;
  v4 = v6;
  if (v6 != v7)
  {
    v4 = v6;
    while (*v4 != a2)
    {
      if (++v4 == v7)
      {
        v4 = v7;
        break;
      }
    }
  }
  if (v6)
  {
    v7 = v6;
    operator delete(v6);
  }
  return v4 != v3;
}

BOOL KB::LanguageModel::is_special_id(KB::LanguageModel *this, TITokenID a2)
{
  return (HIDWORD(this) - 3) < 0x1F1;
}

CFIndex KB::LanguageModel::get_prediction_count(KB::LanguageModel *this)
{
  CFIndex AppIntegerValue;
  CFIndex v2;
  Boolean keyExistsAndHasValidFormat;
  uint8_t buf[4];
  const char *v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  CFIndex v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  keyExistsAndHasValidFormat = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("LanguageModelPredictionCount"), CFSTR("com.apple.keyboard"), &keyExistsAndHasValidFormat);
  if (!keyExistsAndHasValidFormat)
    return 50;
  v2 = AppIntegerValue;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    v6 = "get_prediction_count";
    v7 = 2080;
    v8 = "get_prediction_count";
    v9 = 2048;
    v10 = v2;
    _os_log_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s  %s: prediction_count=%zu (overridden by user preferences)", buf, 0x20u);
  }
  return v2;
}

uint64_t KB::LanguageModel::id_for_static_word_with_surface_form(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6, uint64_t a7)
{
  float *v14;
  BOOL v16;
  uint64_t *v17;
  _BOOL4 v18;
  BOOL v19;
  void *v20;
  BOOL v21;
  uint64_t v22;
  float *v23;
  KB::Word *v24;
  KB::Word *v25;
  KB::Word *v26;
  _BOOL4 v27;
  BOOL v28;
  float *v29;
  unsigned int v30;
  BOOL v32;
  unsigned int v33;
  float v34;
  float *v35;
  unsigned int v36;
  void *v37;
  BOOL v38;
  float *v40;
  float *v41;
  float **v42;
  _BYTE v43[6];
  char v44;
  void *v45;
  _BYTE v46[8];
  void *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
    return 0;
  (*(void (**)(float **__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 288))(&v40, a1, a2, a3, a4, (a6 >> 5) & 1, 1);
  if ((a6 & 3) != 0)
  {
    v14 = v41;
    if (v40 != v41)
    {
      v16 = (a6 & 4) == 0 || a5 == 0;
      v17 = (uint64_t *)(v40 + 34);
      while (1)
      {
        KB::Word::capitalized_string((KB::Word *)(v17 - 17), (uint64_t)v46);
        if (v46 == (_BYTE *)a2)
          break;
        v18 = KB::String::equal((KB::String *)v46, (const KB::String *)a2, 1);
        if (v47)
          v19 = v46[6] == 1;
        else
          v19 = 0;
        if (v19)
          free(v47);
        if (v18)
          goto LABEL_26;
LABEL_28:
        v23 = (float *)(v17 + 13);
        v17 += 30;
        if (v23 == v14)
          goto LABEL_29;
      }
      v20 = *(void **)(a2 + 8);
      if (v20)
        v21 = *(_BYTE *)(a2 + 6) == 1;
      else
        v21 = 0;
      if (v21)
        free(v20);
LABEL_26:
      if (v16)
        goto LABEL_75;
      v22 = *v17;
      if (*v17 == a5)
        goto LABEL_76;
      goto LABEL_28;
    }
LABEL_29:
    if ((a6 & 4) != 0)
    {
      v24 = (KB::Word *)v40;
      v25 = (KB::Word *)v41;
      if (v40 != v41)
      {
        v26 = (KB::Word *)v40;
        while (1)
        {
          KB::Word::capitalized_string(v26, (uint64_t)v43);
          if (v43 == (_BYTE *)a2)
            break;
          v27 = KB::String::equal((KB::String *)v43, (const KB::String *)a2, 1);
          if (v45)
            v28 = v44 == 1;
          else
            v28 = 0;
          if (v28)
            free(v45);
          if (v27)
          {
            v24 = v26;
LABEL_74:
            v17 = (uint64_t *)((char *)v24 + 136);
            goto LABEL_75;
          }
          v26 = (KB::Word *)((char *)v26 + 240);
          if (v26 == v25)
            goto LABEL_41;
        }
        v37 = *(void **)(a2 + 8);
        if (v37)
          v38 = *(_BYTE *)(a2 + 6) == 1;
        else
          v38 = 0;
        if (v38)
          free(v37);
        goto LABEL_74;
      }
    }
LABEL_41:
    if ((a6 & 2) != 0)
      goto LABEL_66;
  }
  v29 = v40;
  if (v40 == v41)
  {
LABEL_66:
    v22 = 0;
    goto LABEL_76;
  }
  v30 = 0;
  v32 = (a6 & 4) == 0 || a5 == 0;
  v33 = -1;
  v34 = 0.0;
  v35 = v40;
  do
  {
    if (v32 || *((_DWORD *)v35 + 34) == a5)
    {
      if (v33 == -1)
      {
        v33 = 0;
      }
      else
      {
        if (v35[12] <= v34)
        {
LABEL_57:
          ++v30;
          goto LABEL_58;
        }
        v33 = v30;
      }
      v34 = v35[12];
      goto LABEL_57;
    }
LABEL_58:
    v35 += 60;
  }
  while (v35 != v41);
  if ((v33 & 0x80000000) != 0)
    goto LABEL_66;
  if (0xEEEEEEEEEEEEEEEFLL * (((char *)v41 - (char *)v40) >> 4) <= v33)
    abort();
  v36 = v33;
  KB::Word::capitalized_string((KB::Word *)&v40[60 * v33], (uint64_t)v43);
  KB::String::operator=(a7, (KB::String *)v43);
  if (v45 && v44 == 1)
    free(v45);
  v17 = (uint64_t *)&v29[60 * v36 + 34];
LABEL_75:
  v22 = *v17;
LABEL_76:
  v42 = &v40;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v42);
  return v22;
}

uint64_t KB::LanguageModel::id_for_static_word(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v13;
  __int16 v14;
  char v15;
  void *v16;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v13 = 0x100000;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  if (a5)
    v9 = 45;
  else
    v9 = 13;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 416))(a1, a4);
  v11 = KB::LanguageModel::id_for_static_word_with_surface_form(a1, a2, a3, a4, v10, v9, (uint64_t)&v13);
  if (v16 && v15 == 1)
    free(v16);
  return v11;
}

uint64_t KB::LanguageModel::id_for_maximum_likelihood_static_word(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *a1;
  v2 = a1[1];
  v3 = *a1 + 240;
  if (*a1 != v2 && v3 != v2)
  {
    do
    {
      if (*(float *)(v1 + 48) < *(float *)(v3 + 48))
        v1 = v3;
      v3 += 240;
    }
    while (v3 != v2);
  }
  if (v1 == v2)
    return 0;
  else
    return *(_QWORD *)(v1 + 136);
}

unint64_t KB::LanguageModel::id_for_maximum_likelihood_word(uint64_t a1, KB::Word **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  KB::Word *v9;
  KB::Word *v10;
  _QWORD *v11;
  KB::Word *i;
  unint64_t v13;
  _QWORD v15[2];
  BOOL (*v16)(uint64_t, uint64_t, uint64_t);
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int16 v20[3];
  char v21;
  void *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v9 = *a2;
  v10 = a2[1];
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v16 = ___ZN2KB13LanguageModel30id_for_maximum_likelihood_wordERKNSt3__16vectorINS_4WordENS1_9allocatorIS3_EEEERKN3WTF6RefPtrINS_19DictionaryContainerEEERKNS_20LanguageModelContextERNS_6StringE_block_invoke;
  v17 = &__block_descriptor_48_e15_B24__0r_v8r_v16l;
  v18 = a1;
  v19 = a4;
  v11 = v15;
  if (v9 != v10)
  {
    for (i = (KB::Word *)((char *)v9 + 240); i != v10; i = (KB::Word *)((char *)i + 240))
    {
      if (((unsigned int (*)(_QWORD *, KB::Word *, KB::Word *))v16)(v11, v9, i))
        v9 = i;
    }
  }

  if (v9 == a2[1])
    return 0;
  v13 = *((_QWORD *)v9 + 17);
  if (!HIDWORD(v13))
  {
    KB::Word::capitalized_string(v9, (uint64_t)v20);
    v13 = KB::LanguageModel::id_for_dynamic_engine_word(a1, v20, a3);
    if (v22)
    {
      if (v21 == 1)
        free(v22);
    }
  }
  KB::Word::capitalized_string(v9, (uint64_t)v20);
  KB::String::operator=(a5, (KB::String *)v20);
  if (v22 && v21 == 1)
    free(v22);
  return v13;
}

BOOL ___ZN2KB13LanguageModel30id_for_maximum_likelihood_wordERKNSt3__16vectorINS_4WordENS1_9allocatorIS3_EEEERKN3WTF6RefPtrINS_19DictionaryContainerEEERKNS_20LanguageModelContextERNS_6StringE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BOOL8 result;
  uint64_t v7;
  float v8;
  uint64_t v9;
  void *v10[2];
  void *__p;
  char v12;
  _BYTE v13[6];
  char v14;
  void *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  result = (*(unsigned __int8 *)(a3 + 106) >> 2) & 1;
  if (result == (*(_BYTE *)(a2 + 106) & 4) >> 2)
  {
    v7 = *(_QWORD *)(a1 + 32);
    if (*(float *)(a2 + 52) == 1.0)
    {
      KB::Word::capitalized_string((KB::Word *)a2, (uint64_t)v13);
      v9 = *(_QWORD *)(a2 + 136);
      (*(void (**)(void **__return_ptr, uint64_t, _BYTE *, uint64_t *, _QWORD, _QWORD, float))(*(_QWORD *)v7 + 400))(v10, v7, v13, &v9, *(_QWORD *)(a1 + 40), 0, *(float *)(a2 + 52));
      if (v15 && v14 == 1)
        free(v15);
      *(_DWORD *)(a2 + 52) = v10[0];
      if (v12 < 0)
        operator delete(__p);
    }
    v8 = *(float *)(a3 + 52);
    if (v8 == 1.0)
    {
      KB::Word::capitalized_string((KB::Word *)a3, (uint64_t)v13);
      v9 = *(_QWORD *)(a3 + 136);
      (*(void (**)(void **__return_ptr, uint64_t, _BYTE *, uint64_t *, _QWORD, _QWORD, float))(*(_QWORD *)v7 + 400))(v10, v7, v13, &v9, *(_QWORD *)(a1 + 40), 0, *(float *)(a3 + 52));
      if (v15 && v14 == 1)
        free(v15);
      v8 = *(float *)v10;
      *(_DWORD *)(a3 + 52) = v10[0];
      if (v12 < 0)
      {
        operator delete(__p);
        v8 = *(float *)(a3 + 52);
      }
    }
    return *(float *)(a2 + 52) < v8;
  }
  return result;
}

uint64_t KB::LanguageModel::id_for_dynamic_engine_word(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  CFStringRef v5;
  uint64_t v6;
  CFStringRef v8;
  CFTypeRef cf;

  KB::cf_string_impl<KB::String>(&v8, a2);
  v5 = v8;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, CFStringRef))(*(_QWORD *)a1 + 544))(&cf, a1, v8);
  if (v5)
    CFRelease(v5);
  if (!cf)
    return 0;
  v6 = (*(uint64_t (**)(uint64_t, CFTypeRef, uint64_t))(*(_QWORD *)a1 + 296))(a1, cf, a3);
  if (cf)
    CFRelease(cf);
  return v6;
}

uint64_t KB::LanguageModel::is_language_appropriate_vocabulary_word(KB::LanguageModel *this, __CFString *a2)
{
  if (-[__CFString hasSuffix:](a2, "hasSuffix:", CFSTR("'s")))
    return (*(uint64_t (**)(KB::LanguageModel *))(*(_QWORD *)this + 64))(this);
  else
    return 1;
}

uint64_t KB::LanguageModel::find_vocabulary_words(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, KB::Word **a5, uint64_t *a6)
{
  uint64_t result;
  KB::Word *i;
  KB::Word *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  unint64_t v23;
  void *v24;
  char *v25;
  unint64_t v26;
  uint64_t *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  result = LMVocabularyGetSharedVocabulary();
  for (i = *a5; i != a5[1]; i = (KB::Word *)((char *)i + 240))
  {
    if (!HIDWORD(*((_QWORD *)i + 17)))
    {
      KB::Word::capitalized_string(i, (uint64_t)&v23);
      KB::LanguageModel::id_for_dynamic_engine_word(a1, (unsigned __int16 *)&v23, a3);
      if (v24 && BYTE6(v23) == 1)
        free(v24);
    }
    result = LMVocabularyGetClassForTokenID();
    if ((_DWORD)result)
    {
      if (!objc_msgSend(a2, "hasSuffix:", CFSTR("'s"))
        || (result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1), (_DWORD)result))
      {
        v14 = (KB::Word *)a6[1];
        v15 = a6[2];
        if ((unint64_t)v14 >= v15)
        {
          v17 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v14 - *a6) >> 4);
          v18 = v17 + 1;
          if (v17 + 1 > 0x111111111111111)
            abort();
          v19 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v15 - *a6) >> 4);
          if (2 * v19 > v18)
            v18 = 2 * v19;
          if (v19 >= 0x88888888888888)
            v20 = 0x111111111111111;
          else
            v20 = v18;
          v27 = a6 + 2;
          if (v20)
            v20 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v20);
          else
            v21 = 0;
          v22 = (char *)(v20 + 240 * v17);
          v23 = v20;
          v24 = v22;
          v26 = v20 + 240 * v21;
          KB::Word::Word((KB::Word *)v22, i);
          v25 = v22 + 240;
          std::vector<KB::Word>::__swap_out_circular_buffer(a6, &v23);
          v16 = a6[1];
          result = std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v23);
        }
        else
        {
          result = (uint64_t)KB::Word::Word(v14, i);
          v16 = result + 240;
        }
        a6[1] = v16;
      }
    }
  }
  return result;
}

void KB::LanguageModel::find_words_for_sentence_beginning(int a1, __CFString *this, uint64_t *a3, uint64_t a4, char a5, uint64_t a6)
{
  KB *v11;
  KB *v12;
  KB::Word *v13;
  _BOOL4 v14;
  BOOL v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  KB::Word *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int64x2_t v25;
  unint64_t v26;
  _BOOL4 v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  KB::Word *v32;
  uint64_t v33;
  uint64_t v34;
  int64x2_t v35;
  unint64_t v36;
  __int128 v37;
  __int128 v38;
  _BOOL4 v39;
  uint64_t v40;
  id v41;
  id v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  _QWORD v46[5];
  _QWORD v47[5];
  __int128 v48;
  unint64_t v49;
  __int128 v50;
  unint64_t v51;
  _BYTE v52[8];
  void *v53;
  _BYTE v54[8];
  void *v55;
  _BYTE v56[8];
  void *v57;
  void **v58;
  int64x2_t v59;
  unint64_t v60;
  unint64_t *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  KB::utf8_string(this, (uint64_t)v56);
  -[__CFString lowercaseStringWithLocale:](this, "lowercaseStringWithLocale:", a4);
  v11 = (KB *)objc_claimAutoreleasedReturnValue();
  KB::utf8_string(v11, (uint64_t)v54);
  v12 = this;
  KB::utf8_string(v12, (uint64_t)v52);
  v50 = 0uLL;
  v51 = 0;
  v48 = 0uLL;
  v49 = 0;
  v13 = (KB::Word *)*a3;
  if (*a3 == a3[1])
  {
    v44 = *(_QWORD *)a6;
    v43 = *(_QWORD *)(a6 + 8);
    v39 = 1;
  }
  else
  {
    v45 = a5;
    do
    {
      KB::Word::capitalized_string(v13, (uint64_t)&v58);
      v14 = KB::String::equal((KB::String *)&v58, (const KB::String *)v54, 1);
      if (v59.i64[0])
        v15 = BYTE6(v58) == 1;
      else
        v15 = 0;
      if (v15)
        free((void *)v59.i64[0]);
      if (v14)
      {
        if (*((_QWORD *)&v50 + 1) >= v51)
        {
          v17 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((_QWORD *)&v50 + 1) - v50) >> 4);
          v18 = v17 + 1;
          if (v17 + 1 > 0x111111111111111)
            goto LABEL_77;
          if (0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v51 - v50) >> 4) > v18)
            v18 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v51 - v50) >> 4);
          if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v51 - v50) >> 4) >= 0x88888888888888)
            v19 = 0x111111111111111;
          else
            v19 = v18;
          v61 = &v51;
          if (v19)
            v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v19);
          else
            v20 = 0;
          v21 = (KB::Word *)(v19 + 240 * v17);
          v58 = (void **)v19;
          v59.i64[0] = (uint64_t)v21;
          v60 = v19 + 240 * v20;
          KB::Word::Word(v21, v13);
          v16 = (char *)v21 + 240;
          v59.i64[1] = (uint64_t)v21 + 240;
          v22 = *((_QWORD *)&v50 + 1);
          v23 = v50;
          v24 = v59.i64[0];
          if (*((_QWORD *)&v50 + 1) == (_QWORD)v50)
          {
            v25 = vdupq_n_s64(*((unint64_t *)&v50 + 1));
          }
          else
          {
            do
            {
              v22 -= 240;
              v24 = KB::Word::Word(v24 - 240, v22);
            }
            while (v22 != v23);
            v25 = (int64x2_t)v50;
            v16 = (char *)v59.i64[1];
          }
          *(_QWORD *)&v50 = v24;
          *((_QWORD *)&v50 + 1) = v16;
          v59 = v25;
          v26 = v51;
          v51 = v60;
          v60 = v26;
          v58 = (void **)v25.i64[0];
          std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v58);
        }
        else
        {
          v16 = (char *)KB::Word::Word(*((KB::Word **)&v50 + 1), v13) + 240;
        }
        *((_QWORD *)&v50 + 1) = v16;
      }
      KB::Word::capitalized_string(v13, (uint64_t)&v58);
      v27 = KB::String::equal((KB::String *)&v58, (const KB::String *)v52, 1);
      if (v59.i64[0] && BYTE6(v58) == 1)
        free((void *)v59.i64[0]);
      if (v27)
      {
        if (*((_QWORD *)&v48 + 1) >= v49)
        {
          v29 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((_QWORD *)&v48 + 1) - v48) >> 4) + 1;
          if (v29 > 0x111111111111111)
LABEL_77:
            abort();
          if (0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v49 - v48) >> 4) > v29)
            v29 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v49 - v48) >> 4);
          if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v49 - v48) >> 4) >= 0x88888888888888)
            v30 = 0x111111111111111;
          else
            v30 = v29;
          v61 = &v49;
          if (v30)
            v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v30);
          else
            v31 = 0;
          v32 = (KB::Word *)(v30 + 16 * ((uint64_t)(*((_QWORD *)&v48 + 1) - v48) >> 4));
          v58 = (void **)v30;
          v59.i64[0] = (uint64_t)v32;
          v60 = v30 + 240 * v31;
          KB::Word::Word(v32, v13);
          v28 = (char *)v32 + 240;
          v59.i64[1] = (uint64_t)v32 + 240;
          v33 = *((_QWORD *)&v48 + 1);
          v34 = v59.i64[0];
          if (*((_QWORD *)&v48 + 1) == (_QWORD)v48)
          {
            v35 = vdupq_n_s64(*((unint64_t *)&v48 + 1));
          }
          else
          {
            do
            {
              v33 -= 240;
              v34 = KB::Word::Word(v34 - 240, v33);
            }
            while (v33 != (_QWORD)v48);
            v35 = (int64x2_t)v48;
            v28 = (char *)v59.i64[1];
          }
          *(_QWORD *)&v48 = v34;
          *((_QWORD *)&v48 + 1) = v28;
          v59 = v35;
          v36 = v49;
          v49 = v60;
          v60 = v36;
          v58 = (void **)v35.i64[0];
          std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v58);
        }
        else
        {
          v28 = (char *)KB::Word::Word(*((KB::Word **)&v48 + 1), v13) + 240;
        }
        *((_QWORD *)&v48 + 1) = v28;
      }
      v13 = (KB::Word *)((char *)v13 + 240);
    }
    while (v13 != (KB::Word *)a3[1]);
    v37 = v50;
    v38 = v48;
    v39 = *((_QWORD *)&v50 + 1) == (_QWORD)v50;
    if (*((_QWORD *)&v50 + 1) != (_QWORD)v50 && *((_QWORD *)&v48 + 1) != (_QWORD)v48)
    {
      v40 = MEMORY[0x1E0C809B0];
      v47[0] = MEMORY[0x1E0C809B0];
      v47[1] = 3221225472;
      v47[2] = ___ZN2KB13LanguageModel33find_words_for_sentence_beginningEPK10__CFStringRKNSt3__16vectorINS_4WordENS4_9allocatorIS6_EEEEPK10__CFLocalejRS9__block_invoke;
      v47[3] = &__block_descriptor_40_e10_v16__0r_v8l;
      v47[4] = a6;
      v41 = std::for_each[abi:nn180100]<std::__wrap_iter<KB::Word *>,void({block_pointer} {__strong})(KB::Word const&)>(v48, *((uint64_t *)&v48 + 1), v47);
      v46[0] = v40;
      v46[1] = 3221225472;
      v46[2] = ___ZN2KB13LanguageModel33find_words_for_sentence_beginningEPK10__CFStringRKNSt3__16vectorINS_4WordENS4_9allocatorIS6_EEEEPK10__CFLocalejRS9__block_invoke_2;
      v46[3] = &__block_descriptor_40_e10_v16__0r_v8l;
      v46[4] = a6;
      v42 = std::for_each[abi:nn180100]<std::__wrap_iter<KB::Word *>,void({block_pointer} {__strong})(KB::Word const&)>(v50, *((uint64_t *)&v50 + 1), v46);
    }
    v44 = *(_QWORD *)a6;
    v43 = *(_QWORD *)(a6 + 8);
    if (*((_QWORD *)&v37 + 1) == (_QWORD)v37)
    {
      a5 = v45;
    }
    else
    {
      a5 = v45;
      if (&v50 != (__int128 *)a6 && v43 == v44)
      {
        std::vector<KB::Word>::__assign_with_size[abi:nn180100]<KB::Word*,KB::Word*>(a6, v50, *((uint64_t *)&v50 + 1), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((_QWORD *)&v50 + 1) - v50) >> 4));
        v44 = *(_QWORD *)a6;
        v43 = *(_QWORD *)(a6 + 8);
      }
    }
    if (&v48 != (__int128 *)a6 && v43 == v44 && *((_QWORD *)&v38 + 1) != (_QWORD)v38)
    {
      std::vector<KB::Word>::__assign_with_size[abi:nn180100]<KB::Word*,KB::Word*>(a6, v48, *((uint64_t *)&v48 + 1), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((_QWORD *)&v48 + 1) - v48) >> 4));
      v44 = *(_QWORD *)a6;
      v43 = *(_QWORD *)(a6 + 8);
    }
  }
  if (v39 && (uint64_t *)a6 != a3 && (a5 & 2) == 0 && v43 == v44)
    std::vector<KB::Word>::__assign_with_size[abi:nn180100]<KB::Word*,KB::Word*>(a6, *a3, a3[1], 0xEEEEEEEEEEEEEEEFLL * ((a3[1] - *a3) >> 4));
  v58 = (void **)&v48;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v58);
  v58 = (void **)&v50;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v58);
  if (v53 && v52[6] == 1)
    free(v53);

  if (v55 && v54[6] == 1)
    free(v55);

  if (v57)
  {
    if (v56[6] == 1)
      free(v57);
  }
}

uint64_t ___ZN2KB13LanguageModel33find_words_for_sentence_beginningEPK10__CFStringRKNSt3__16vectorINS_4WordENS4_9allocatorIS6_EEEEPK10__CFLocalejRS9__block_invoke(uint64_t result, KB::Word *a2)
{
  uint64_t *v3;
  KB::Word *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  KB::Word *v13;
  char *v14;
  unint64_t v15;
  uint64_t *v16;

  if ((*((_DWORD *)a2 + 26) & 0x2080) != 0x80)
  {
    v3 = *(uint64_t **)(result + 32);
    v4 = (KB::Word *)v3[1];
    v5 = v3[2];
    if ((unint64_t)v4 >= v5)
    {
      v7 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v4 - *v3) >> 4);
      if (v7 + 1 > 0x111111111111111)
        abort();
      v8 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v5 - *v3) >> 4);
      v9 = 2 * v8;
      if (2 * v8 <= v7 + 1)
        v9 = v7 + 1;
      if (v8 >= 0x88888888888888)
        v10 = 0x111111111111111;
      else
        v10 = v9;
      v16 = v3 + 2;
      if (v10)
        v10 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v10);
      else
        v11 = 0;
      v12 = v10;
      v13 = (KB::Word *)(v10 + 240 * v7);
      v15 = v10 + 240 * v11;
      KB::Word::Word(v13, a2);
      v14 = (char *)v13 + 240;
      std::vector<KB::Word>::__swap_out_circular_buffer(v3, &v12);
      v6 = v3[1];
      result = std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v12);
    }
    else
    {
      result = (uint64_t)KB::Word::Word(v4, a2);
      v6 = result + 240;
    }
    v3[1] = v6;
  }
  return result;
}

id std::for_each[abi:nn180100]<std::__wrap_iter<KB::Word *>,void({block_pointer} {__strong})(KB::Word const&)>(uint64_t a1, uint64_t a2, void *a3)
{
  void (**v5)(id, _QWORD);
  void *v6;

  v5 = a3;
  while (a1 != a2)
  {
    v5[2](v5, a1);
    a1 += 240;
  }
  v6 = _Block_copy(v5);

  return v6;
}

uint64_t ___ZN2KB13LanguageModel33find_words_for_sentence_beginningEPK10__CFStringRKNSt3__16vectorINS_4WordENS4_9allocatorIS6_EEEEPK10__CFLocalejRS9__block_invoke_2(uint64_t result, KB::Word *a2)
{
  uint64_t *v3;
  KB::Word *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  KB::Word *v13;
  char *v14;
  unint64_t v15;
  uint64_t *v16;

  if ((*((_DWORD *)a2 + 26) & 0x2080) != 0x80)
  {
    v3 = *(uint64_t **)(result + 32);
    v4 = (KB::Word *)v3[1];
    v5 = v3[2];
    if ((unint64_t)v4 >= v5)
    {
      v7 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v4 - *v3) >> 4);
      if (v7 + 1 > 0x111111111111111)
        abort();
      v8 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v5 - *v3) >> 4);
      v9 = 2 * v8;
      if (2 * v8 <= v7 + 1)
        v9 = v7 + 1;
      if (v8 >= 0x88888888888888)
        v10 = 0x111111111111111;
      else
        v10 = v9;
      v16 = v3 + 2;
      if (v10)
        v10 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v10);
      else
        v11 = 0;
      v12 = v10;
      v13 = (KB::Word *)(v10 + 240 * v7);
      v15 = v10 + 240 * v11;
      KB::Word::Word(v13, a2);
      v14 = (char *)v13 + 240;
      std::vector<KB::Word>::__swap_out_circular_buffer(v3, &v12);
      v6 = v3[1];
      result = std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v12);
    }
    else
    {
      result = (uint64_t)KB::Word::Word(v4, a2);
      v6 = result + 240;
    }
    v3[1] = v6;
  }
  return result;
}

void std::vector<KB::Word>::__assign_with_size[abi:nn180100]<KB::Word*,KB::Word*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  const KB::Word *v6;
  void *v8;
  unint64_t v9;
  unint64_t v10;
  KB::Word *v11;
  uint64_t v12;
  KB::Word *v13;
  const KB::Word *v14;
  KB::Word *v15;
  uint64_t v16;
  uint64_t i;

  v6 = (const KB::Word *)a2;
  v8 = *(void **)a1;
  if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4) < a4)
  {
    std::vector<KB::Word>::__vdeallocate((void **)a1);
    if (a4 > 0x111111111111111)
      goto LABEL_21;
    v9 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4);
    if (v9 <= a4)
      v9 = a4;
    v10 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4) >= 0x88888888888888
        ? 0x111111111111111
        : v9;
    if (v10 > 0x111111111111111)
LABEL_21:
      abort();
    v11 = (KB::Word *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v10);
    *(_QWORD *)a1 = v11;
    *(_QWORD *)(a1 + 8) = v11;
    *(_QWORD *)(a1 + 16) = (char *)v11 + 240 * v12;
    while (v6 != (const KB::Word *)a3)
    {
      v13 = KB::Word::Word(v11, v6);
      v6 = (const KB::Word *)((char *)v6 + 240);
      v11 = (KB::Word *)((char *)v13 + 240);
    }
    goto LABEL_16;
  }
  if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v8) >> 4) < a4)
  {
    v14 = (const KB::Word *)(a2 + 16 * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v8) >> 4));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<KB::Word *,KB::Word *,KB::Word *>(a2, (uint64_t)v14, (uint64_t)v8);
    v11 = *(KB::Word **)(a1 + 8);
    while (v14 != (const KB::Word *)a3)
    {
      v15 = KB::Word::Word(v11, v14);
      v14 = (const KB::Word *)((char *)v14 + 240);
      v11 = (KB::Word *)((char *)v15 + 240);
    }
LABEL_16:
    *(_QWORD *)(a1 + 8) = v11;
    return;
  }
  v16 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<KB::Word *,KB::Word *,KB::Word *>(a2, a3, (uint64_t)v8);
  for (i = *(_QWORD *)(a1 + 8); i != v16; KB::Word::~Word((KB::Word *)(i - 240)))
    ;
  *(_QWORD *)(a1 + 8) = v16;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<KB::Word *,KB::Word *,KB::Word *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  if (a1 != a2)
  {
    v6 = 0;
    do
    {
      v7 = a3 + v6;
      v8 = a1 + v6;
      KB::String::operator=((KB::String *)(a3 + v6), (KB::String *)(a1 + v6));
      KB::ByteString::operator=((unsigned __int16 *)(a3 + v6 + 32), (const void **)(a1 + v6 + 32));
      v9 = *(_QWORD *)(a1 + v6 + 48);
      *(_DWORD *)(v7 + 56) = *(_DWORD *)(a1 + v6 + 56);
      *(_QWORD *)(v7 + 48) = v9;
      KB::String::operator=((KB::String *)(a3 + v6 + 64), (KB::String *)(a1 + v6 + 64));
      v10 = *(_OWORD *)(a1 + v6 + 96);
      v11 = *(_OWORD *)(a1 + v6 + 112);
      v12 = *(_OWORD *)(a1 + v6 + 144);
      *(_OWORD *)(v7 + 128) = *(_OWORD *)(a1 + v6 + 128);
      *(_OWORD *)(v7 + 144) = v12;
      *(_OWORD *)(v7 + 96) = v10;
      *(_OWORD *)(v7 + 112) = v11;
      KB::String::operator=((KB::String *)(a3 + v6 + 160), (KB::String *)(a1 + v6 + 160));
      *(_BYTE *)(v7 + 192) = *(_BYTE *)(a1 + v6 + 192);
      if (a1 != a3)
      {
        *(_DWORD *)(v7 + 232) = *(_DWORD *)(v8 + 232);
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((_QWORD *)(v7 + 200), *(_QWORD **)(v8 + 216));
      }
      v6 += 240;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void std::vector<KB::Word>::__vdeallocate(void **a1)
{
  char *v1;
  char *v3;
  void *v4;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
        KB::Word::~Word((KB::Word *)(v3 - 240));
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

BOOL KB::LanguageModel::lexicon_match(KB::LanguageModel *this, int a2, const KB::Word *a3)
{
  int v3;

  if (!a2)
    return 1;
  v3 = *((_DWORD *)a3 + 34);
  return v3 == -2 || v3 == 0 || v3 == a2;
}

void KB::LanguageModel::merge_words(uint64_t a1, unsigned int **a2, uint64_t *a3, int a4, uint64_t *a5)
{
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  BOOL v12;
  BOOL v13;
  KB::Word *v14;
  unint64_t v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  KB::Word *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  BOOL v26;
  BOOL v27;
  KB::Word *v28;
  unint64_t v29;
  char *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  KB::Word *v36;
  uint64_t v37;
  unsigned int *v38;
  KB::Word *v39;
  unint64_t v40;
  char *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  KB::Word *v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  BOOL v51;
  KB::Word *v53;
  unint64_t v54;
  char *v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  KB::Word *v61;
  _QWORD *v62;
  unint64_t v63;
  _QWORD **v64;
  _QWORD *v65;
  _QWORD **v66;
  unsigned int v67;
  _QWORD *v68;
  KB::Word *v69;
  unint64_t v70;
  char *v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  KB::Word *v77;
  _QWORD *v78;
  unsigned int v79;
  _QWORD **v80;
  _QWORD *v81;
  _QWORD **v82;
  unsigned int v83;
  _QWORD *v84;
  KB::Word *v85;
  unint64_t v86;
  char *v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  KB::Word *v93;
  int v94;
  BOOL v95;
  BOOL v96;
  KB::Word *v97;
  unint64_t v98;
  char *v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  KB::Word *v105;
  _QWORD **v106;
  _QWORD *v107;
  uint64_t v108;
  unint64_t v109;
  KB::Word *v110;
  char *v111;
  unint64_t v112;
  uint64_t *v113;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1))
  {
    v10 = *a2;
    v9 = a2[1];
    if (*a2 == v9)
    {
      v9 = *a2;
    }
    else
    {
      do
      {
        if (!a4
          || ((v11 = v10[34], v11 != -2) ? (v12 = v11 == 0) : (v12 = 1), !v12 ? (v13 = v11 == a4) : (v13 = 1), v13))
        {
          v14 = (KB::Word *)a5[1];
          v15 = a5[2];
          if ((unint64_t)v14 >= v15)
          {
            v17 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v14 - *a5) >> 4);
            v18 = v17 + 1;
            if (v17 + 1 > 0x111111111111111)
              goto LABEL_180;
            v19 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v15 - *a5) >> 4);
            if (2 * v19 > v18)
              v18 = 2 * v19;
            if (v19 >= 0x88888888888888)
              v20 = 0x111111111111111;
            else
              v20 = v18;
            v113 = a5 + 2;
            if (v20)
              v20 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v20);
            else
              v21 = 0;
            v22 = (KB::Word *)(v20 + 240 * v17);
            v109 = v20;
            v110 = v22;
            v112 = v20 + 240 * v21;
            KB::Word::Word(v22, (const KB::Word *)v10);
            v111 = (char *)v22 + 240;
            std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
            v16 = (char *)a5[1];
            std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
          }
          else
          {
            v16 = (char *)KB::Word::Word(v14, (const KB::Word *)v10) + 240;
          }
          a5[1] = (uint64_t)v16;
          v9 = a2[1];
        }
        v10 += 60;
      }
      while (v10 != v9);
    }
    v107 = 0;
    v108 = 0;
    v106 = &v107;
    if (a4)
    {
      if (a5[1] == *a5)
      {
        v38 = *a2;
        if (*a2 != v9)
        {
          do
          {
            v39 = (KB::Word *)a5[1];
            v40 = a5[2];
            if ((unint64_t)v39 >= v40)
            {
              v42 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v39 - *a5) >> 4);
              v43 = v42 + 1;
              if (v42 + 1 > 0x111111111111111)
                goto LABEL_180;
              v44 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v40 - *a5) >> 4);
              if (2 * v44 > v43)
                v43 = 2 * v44;
              if (v44 >= 0x88888888888888)
                v45 = 0x111111111111111;
              else
                v45 = v43;
              v113 = a5 + 2;
              if (v45)
                v45 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v45);
              else
                v46 = 0;
              v47 = (KB::Word *)(v45 + 240 * v42);
              v109 = v45;
              v110 = v47;
              v112 = v45 + 240 * v46;
              KB::Word::Word(v47, (const KB::Word *)v38);
              v111 = (char *)v47 + 240;
              std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
              v41 = (char *)a5[1];
              std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
            }
            else
            {
              v41 = (char *)KB::Word::Word(v39, (const KB::Word *)v38) + 240;
            }
            a5[1] = (uint64_t)v41;
            std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v106, v38[35], v38[35]);
            v38 += 60;
          }
          while (v38 != a2[1]);
        }
      }
    }
    v49 = *a3;
    v48 = a3[1];
    if (*a3 != v48)
    {
      do
      {
        if ((*(_DWORD *)(v49 + 104) & 0x42000) != 0x40000)
        {
          if (!a4)
            goto LABEL_82;
          v50 = *(_QWORD *)(v49 + 136);
          v51 = (_DWORD)v50 == -2 || (_DWORD)v50 == 0;
          if (v51 || (_DWORD)v50 == a4)
            goto LABEL_82;
          v62 = v107;
          if (v107)
          {
            v63 = HIDWORD(v50);
            v64 = &v107;
            do
            {
              v65 = v62;
              v66 = v64;
              v67 = *((_DWORD *)v62 + 7);
              v68 = v62 + 1;
              if (v67 >= v63)
              {
                v68 = v65;
                v64 = (_QWORD **)v65;
              }
              v62 = (_QWORD *)*v68;
            }
            while (v62);
            if (v64 != &v107)
            {
              if (v67 < v63)
                v65 = v66;
              if (*((_DWORD *)v65 + 7) <= v63)
              {
LABEL_82:
                v53 = (KB::Word *)a5[1];
                v54 = a5[2];
                if ((unint64_t)v53 >= v54)
                {
                  v56 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v53 - *a5) >> 4);
                  v57 = v56 + 1;
                  if (v56 + 1 > 0x111111111111111)
                    goto LABEL_180;
                  v58 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v54 - *a5) >> 4);
                  if (2 * v58 > v57)
                    v57 = 2 * v58;
                  if (v58 >= 0x88888888888888)
                    v59 = 0x111111111111111;
                  else
                    v59 = v57;
                  v113 = a5 + 2;
                  if (v59)
                    v59 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v59);
                  else
                    v60 = 0;
                  v61 = (KB::Word *)(v59 + 240 * v56);
                  v109 = v59;
                  v110 = v61;
                  v112 = v59 + 240 * v60;
                  KB::Word::Word(v61, (const KB::Word *)v49);
                  v111 = (char *)v61 + 240;
                  std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
                  v55 = (char *)a5[1];
                  std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
                }
                else
                {
                  v55 = (char *)KB::Word::Word(v53, (const KB::Word *)v49) + 240;
                }
                a5[1] = (uint64_t)v55;
                v48 = a3[1];
              }
            }
          }
        }
        v49 += 240;
      }
      while (v49 != v48);
    }
    goto LABEL_179;
  }
  v107 = 0;
  v108 = 0;
  v106 = &v107;
  v23 = *a3;
  v24 = a3[1];
  if (*a3 != v24)
  {
    do
    {
      if ((*(_BYTE *)(v23 + 106) & 4) != 0)
      {
        if (!a4
          || ((v25 = *(_DWORD *)(v23 + 136), v25 != -2) ? (v26 = v25 == 0) : (v26 = 1),
              !v26 ? (v27 = v25 == a4) : (v27 = 1),
              v27))
        {
          v28 = (KB::Word *)a5[1];
          v29 = a5[2];
          if ((unint64_t)v28 >= v29)
          {
            v31 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v28 - *a5) >> 4);
            v32 = v31 + 1;
            if (v31 + 1 > 0x111111111111111)
LABEL_180:
              abort();
            v33 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v29 - *a5) >> 4);
            if (2 * v33 > v32)
              v32 = 2 * v33;
            if (v33 >= 0x88888888888888)
              v34 = 0x111111111111111;
            else
              v34 = v32;
            v113 = a5 + 2;
            if (v34)
              v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v34);
            else
              v35 = 0;
            v36 = (KB::Word *)(v34 + 240 * v31);
            v109 = v34;
            v110 = v36;
            v112 = v34 + 240 * v35;
            KB::Word::Word(v36, (const KB::Word *)v23);
            v111 = (char *)v36 + 240;
            std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
            v30 = (char *)a5[1];
            std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
          }
          else
          {
            v30 = (char *)KB::Word::Word(v28, (const KB::Word *)v23) + 240;
          }
          a5[1] = (uint64_t)v30;
          std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v106, *(_DWORD *)(v23 + 136), *(_DWORD *)(v23 + 136));
        }
      }
      v23 += 240;
    }
    while (v23 != v24);
    v37 = *a3;
    v23 = a3[1];
    if (!a4)
      goto LABEL_127;
    goto LABEL_108;
  }
  v37 = *a3;
  if (a4)
  {
LABEL_108:
    if (*a5 == a5[1])
    {
      if (v37 == v23)
      {
        v37 = v23;
      }
      else
      {
        do
        {
          if ((*(_BYTE *)(v37 + 106) & 4) != 0)
          {
            v69 = (KB::Word *)a5[1];
            v70 = a5[2];
            if ((unint64_t)v69 >= v70)
            {
              v72 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v69 - *a5) >> 4);
              v73 = v72 + 1;
              if (v72 + 1 > 0x111111111111111)
                goto LABEL_180;
              v74 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v70 - *a5) >> 4);
              if (2 * v74 > v73)
                v73 = 2 * v74;
              if (v74 >= 0x88888888888888)
                v75 = 0x111111111111111;
              else
                v75 = v73;
              v113 = a5 + 2;
              if (v75)
                v75 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v75);
              else
                v76 = 0;
              v77 = (KB::Word *)(v75 + 240 * v72);
              v109 = v75;
              v110 = v77;
              v112 = v75 + 240 * v76;
              KB::Word::Word(v77, (const KB::Word *)v37);
              v111 = (char *)v77 + 240;
              std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
              v71 = (char *)a5[1];
              std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
            }
            else
            {
              v71 = (char *)KB::Word::Word(v69, (const KB::Word *)v37) + 240;
            }
            a5[1] = (uint64_t)v71;
            std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v106, *(_DWORD *)(v37 + 136), *(_DWORD *)(v37 + 136));
          }
          v37 += 240;
        }
        while (v37 != v23);
        v37 = *a3;
        v23 = a3[1];
      }
    }
  }
LABEL_127:
  if (v108)
  {
    for (; v37 != v23; v37 += 240)
    {
      if ((*(_BYTE *)(v37 + 106) & 4) == 0)
      {
        v78 = v107;
        if (v107)
        {
          v79 = *(_DWORD *)(v37 + 136);
          v80 = &v107;
          do
          {
            v81 = v78;
            v82 = v80;
            v83 = *((_DWORD *)v78 + 7);
            v84 = v78 + 1;
            if (v83 >= v79)
            {
              v84 = v81;
              v80 = (_QWORD **)v81;
            }
            v78 = (_QWORD *)*v84;
          }
          while (v78);
          if (v80 != &v107)
          {
            if (v83 < v79)
              v81 = v82;
            if (*((_DWORD *)v81 + 7) <= v79)
            {
              v85 = (KB::Word *)a5[1];
              v86 = a5[2];
              if ((unint64_t)v85 >= v86)
              {
                v88 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v85 - *a5) >> 4);
                v89 = v88 + 1;
                if (v88 + 1 > 0x111111111111111)
                  goto LABEL_180;
                v90 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v86 - *a5) >> 4);
                if (2 * v90 > v89)
                  v89 = 2 * v90;
                if (v90 >= 0x88888888888888)
                  v91 = 0x111111111111111;
                else
                  v91 = v89;
                v113 = a5 + 2;
                if (v91)
                  v91 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v91);
                else
                  v92 = 0;
                v93 = (KB::Word *)(v91 + 240 * v88);
                v109 = v91;
                v110 = v93;
                v112 = v91 + 240 * v92;
                KB::Word::Word(v93, (const KB::Word *)v37);
                v111 = (char *)v93 + 240;
                std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
                v87 = (char *)a5[1];
                std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
              }
              else
              {
                v87 = (char *)KB::Word::Word(v85, (const KB::Word *)v37) + 240;
              }
              a5[1] = (uint64_t)v87;
            }
          }
        }
      }
    }
  }
  else
  {
    for (; v37 != v23; v37 += 240)
    {
      if ((*(_BYTE *)(v37 + 106) & 4) == 0)
      {
        if (!a4
          || ((v94 = *(_DWORD *)(v37 + 136), v94 != -2) ? (v95 = v94 == 0) : (v95 = 1),
              !v95 ? (v96 = v94 == a4) : (v96 = 1),
              v96))
        {
          v97 = (KB::Word *)a5[1];
          v98 = a5[2];
          if ((unint64_t)v97 >= v98)
          {
            v100 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v97 - *a5) >> 4);
            v101 = v100 + 1;
            if (v100 + 1 > 0x111111111111111)
              goto LABEL_180;
            v102 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v98 - *a5) >> 4);
            if (2 * v102 > v101)
              v101 = 2 * v102;
            if (v102 >= 0x88888888888888)
              v103 = 0x111111111111111;
            else
              v103 = v101;
            v113 = a5 + 2;
            if (v103)
              v103 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v103);
            else
              v104 = 0;
            v105 = (KB::Word *)(v103 + 240 * v100);
            v109 = v103;
            v110 = v105;
            v112 = v103 + 240 * v104;
            KB::Word::Word(v105, (const KB::Word *)v37);
            v111 = (char *)v105 + 240;
            std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
            v99 = (char *)a5[1];
            std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
          }
          else
          {
            v99 = (char *)KB::Word::Word(v97, (const KB::Word *)v37) + 240;
          }
          a5[1] = (uint64_t)v99;
        }
      }
    }
  }
LABEL_179:
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v107);
}

uint64_t *std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>(uint64_t *result, unsigned int a2, int a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t **v6;
  _QWORD *v7;
  unsigned int v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t *v11;

  v4 = result;
  v6 = (uint64_t **)(result + 1);
  v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (_QWORD *)v5;
        v8 = *(_DWORD *)(v5 + 28);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = (uint64_t **)v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = result + 1;
LABEL_9:
    v9 = operator new(0x20uLL);
    v9[7] = a3;
    *(_QWORD *)v9 = 0;
    *((_QWORD *)v9 + 1) = 0;
    *((_QWORD *)v9 + 2) = v7;
    *v6 = (uint64_t *)v9;
    v10 = *(_QWORD *)*v4;
    if (v10)
    {
      *v4 = v10;
      v11 = *v6;
    }
    else
    {
      v11 = (uint64_t *)v9;
    }
    result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

unint64_t KB::LanguageModel::select_token_id_from_words(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, char a8, uint64_t a9)
{
  KB::Word *v9;
  KB::Word *v16;
  _BOOL4 v17;
  BOOL v18;
  unint64_t result;
  void *v20;
  BOOL v21;
  _BYTE v23[8];
  void *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v9 = *(KB::Word **)a2;
  if (*(_QWORD *)(a2 + 8) == *(_QWORD *)a2)
    return 0;
  if (((a7 & 0x10) == 0 || (a8 & 1) == 0) && (a7 & 3) != 0)
  {
    v16 = *(KB::Word **)a2;
    do
    {
      KB::Word::capitalized_string(v16, (uint64_t)v23);
      if (v23 == (_BYTE *)a5)
      {
        v20 = *(void **)(a5 + 8);
        if (v20)
          v21 = *(_BYTE *)(a5 + 6) == 1;
        else
          v21 = 0;
        if (v21)
          free(v20);
        goto LABEL_26;
      }
      v17 = KB::String::equal((KB::String *)a5, (const KB::String *)v23, 1);
      if (v24)
        v18 = v23[6] == 1;
      else
        v18 = 0;
      if (v18)
        free(v24);
      if (v17)
      {
        v9 = v16;
LABEL_26:
        result = *((_QWORD *)v9 + 17);
        if (!HIDWORD(result))
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 296))(a1, a4, a3);
        return result;
      }
      v16 = (KB::Word *)((char *)v16 + 240);
    }
    while (v16 != *(KB::Word **)(a2 + 8));
    if ((a7 & 2) != 0)
      return 0;
  }
  return KB::LanguageModel::id_for_maximum_likelihood_word(a1, (KB::Word **)a2, a3, a6, a9);
}

unint64_t KB::LanguageModel::find_token_id_for_word(uint64_t a1, __CFString *a2, uint64_t *a3, uint64_t a4, unsigned int a5, uint64_t a6, KB::String *this, BOOL *a8)
{
  int v16;
  unint64_t v17;
  unsigned int *v18;
  KB::Word *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  int v33;
  void *v34;
  KB::String *v36;
  uint64_t v37;
  __int128 v38;
  int v39;
  void **v40;
  void **v41;
  uint64_t v42;
  void **v43;
  void **v44;
  uint64_t v45;
  __int128 v46;
  uint64_t v47;
  unsigned int *v48;
  unsigned int *v49;
  void *v50[2];
  uint64_t v51;
  _QWORD v52[2];
  BOOL (*v53)(uint64_t, KB::String *);
  void *v54;
  _BYTE v55[40];
  _BYTE v56[8];
  void *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  KB::String::clear(this);
  *a8 = 0;
  if (!-[__CFString length](a2, "length"))
    return 0;
  if ((KB::LanguageModelContext::is_linguistically_void((KB::LanguageModelContext *)a4) & 1) != 0)
    v16 = 0;
  else
    v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 416))(a1, a4);
  KB::utf8_string(a2, (uint64_t)v56);
  (*(void (**)(unsigned int **__return_ptr, uint64_t, _BYTE *, uint64_t *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 288))(&v48, a1, v56, a3, a4, (a5 >> 5) & 1, 1);
  v36 = this;
  v37 = a6;
  if (v48 != v49)
  {
    v18 = v48;
    while ((v18[26] & 2) == 0)
    {
      v18 += 60;
      if (v18 == v49)
        goto LABEL_12;
    }
    a5 = a5 & 0xFFFFFFFC | 1;
  }
LABEL_12:
  *a8 = v49 != v48;
  v46 = 0uLL;
  v47 = 0;
  if ((a5 & 8) == 0 || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1) & 1) == 0)
  {
    v39 = v16;
    KB::DictionaryContainer::lookup(*a3, (const KB::String *)v56, 0, 0, (uint64_t *)v50);
    std::vector<KB::Word>::__vdeallocate((void **)&v46);
    v38 = *(_OWORD *)v50;
    v46 = *(_OWORD *)v50;
    v47 = v51;
    v50[1] = 0;
    v51 = 0;
    v50[0] = 0;
    v43 = v50;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v43);
    v19 = (KB::Word *)*((_QWORD *)&v38 + 1);
    v20 = v38;
    v52[0] = MEMORY[0x1E0C809B0];
    v52[1] = 3321888768;
    v53 = ___ZN2KB13LanguageModel22find_token_id_for_wordEPK10__CFStringRKN3WTF6RefPtrINS_19DictionaryContainerEEERKNS_20LanguageModelContextEjPK10__CFLocaleRNS_6StringERb_block_invoke_2;
    v54 = &__block_descriptor_65_a8_32c16_ZTSN2KB6StringE_e10_B16__0r_v8l;
    KB::String::String((KB::String *)v55, (const KB::String *)v56);
    v55[32] = (a5 & 8) == 0;
    v21 = v52;
    if ((_QWORD)v38 != *((_QWORD *)&v38 + 1))
    {
      while ((((uint64_t (*)(_QWORD *, uint64_t))v53)(v21, v20) & 1) == 0)
      {
        v20 += 240;
        if (v20 == *((_QWORD *)&v38 + 1))
          goto LABEL_25;
      }
    }
    if (v20 == *((_QWORD *)&v38 + 1))
    {
LABEL_25:
      v20 = *((_QWORD *)&v38 + 1);
    }
    else if (v20 + 240 != *((_QWORD *)&v38 + 1))
    {
      v22 = (uint64_t *)(v20 + 440);
      do
      {
        if ((((uint64_t (*)(_QWORD *, uint64_t *))v53)(v21, v22 - 25) & 1) == 0)
        {
          KB::String::operator=(v20, (KB::String *)(v22 - 25));
          KB::ByteString::operator=((unsigned __int16 *)(v20 + 32), (unsigned __int16 *)v22 - 84);
          v23 = *(v22 - 19);
          *(_DWORD *)(v20 + 56) = *((_DWORD *)v22 - 36);
          *(_QWORD *)(v20 + 48) = v23;
          KB::String::operator=(v20 + 64, (KB::String *)(v22 - 17));
          v24 = *(_OWORD *)(v22 - 13);
          v25 = *(_OWORD *)(v22 - 11);
          v26 = *(_OWORD *)(v22 - 7);
          *(_OWORD *)(v20 + 128) = *(_OWORD *)(v22 - 9);
          *(_OWORD *)(v20 + 144) = v26;
          *(_OWORD *)(v20 + 96) = v24;
          *(_OWORD *)(v20 + 112) = v25;
          KB::String::operator=(v20 + 160, (KB::String *)(v22 - 5));
          *(_BYTE *)(v20 + 192) = *((_BYTE *)v22 - 8);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(v20 + 200, v22);
          v20 += 240;
        }
        v27 = v22 + 5;
        v22 += 30;
      }
      while (v27 != *((uint64_t **)&v38 + 1));
      v19 = (KB::Word *)*((_QWORD *)&v46 + 1);
    }

    std::vector<KB::Word>::erase((uint64_t)&v46, v20, v19);
    v28 = (void *)v21[5];
    v16 = v39;
    if (v28 && *((_BYTE *)v21 + 38) == 1)
      free(v28);
  }
  v43 = 0;
  v44 = 0;
  v45 = 0;
  KB::LanguageModel::merge_words(a1, &v48, (uint64_t *)&v46, v16 & ((int)(a5 << 29) >> 31), (uint64_t *)&v43);
  if (v44 == v43)
  {
    v17 = 0;
  }
  else
  {
    if ((a5 & 8) == 0)
    {
      v40 = 0;
      v41 = 0;
      v42 = 0;
      KB::LanguageModel::find_vocabulary_words(a1, a2, (uint64_t)a3, v29, (KB::Word **)&v43, (uint64_t *)&v40);
      if (v41 != v40)
      {
        LODWORD(v50[0]) = 0x100000;
        WORD2(v50[0]) = 0;
        BYTE6(v50[0]) = 0;
        v50[1] = 0;
        LOBYTE(v51) = 0;
        v17 = KB::LanguageModel::select_token_id_from_words(a1, (uint64_t)&v40, (uint64_t)a3, (uint64_t)a2, (uint64_t)v56, a4, 1, 0, (uint64_t)v50);
        if (v50[1] && BYTE6(v50[0]) == 1)
          free(v50[1]);
        v50[0] = &v40;
        std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v50);
        goto LABEL_47;
      }
      v50[0] = &v40;
      std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v50);
    }
    v30 = language_modeling::v1::LinguisticContext::tokenSpan((language_modeling::v1::LinguisticContext *)(a4 + 64));
    if (v31 && *(_DWORD *)(v30 + 32 * v31 - 8) == 1)
    {
      -[__CFString capitalizedStringWithLocale:](a2, "capitalizedStringWithLocale:", v37);
      v32 = (void *)objc_claimAutoreleasedReturnValue();
      v33 = -[__CFString isEqualToString:](a2, "isEqualToString:", v32);
      if (v33)
      {
        v50[0] = 0;
        v50[1] = 0;
        v51 = 0;
        KB::LanguageModel::find_words_for_sentence_beginning(v33, a2, (uint64_t *)&v43, v37, a5, (uint64_t)v50);
        if (v50[1] == v50[0]
          || (v17 = KB::LanguageModel::id_for_maximum_likelihood_word(a1, (KB::Word **)v50, (uint64_t)a3, a4, (uint64_t)this), !HIDWORD(v17)))
        {
          v17 = KB::LanguageModel::select_token_id_from_words(a1, (uint64_t)v50, (uint64_t)a3, (uint64_t)a2, (uint64_t)v56, a4, 1, 0, (uint64_t)this);
        }
        v40 = v50;
        std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v40);

        goto LABEL_47;
      }

    }
    -[__CFString uppercaseStringWithLocale:](a2, "uppercaseStringWithLocale:", v37);
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = KB::LanguageModel::select_token_id_from_words(a1, (uint64_t)&v43, (uint64_t)a3, (uint64_t)a2, (uint64_t)v56, a4, a5, -[__CFString isEqualToString:](a2, "isEqualToString:", v34), (uint64_t)v36);

  }
LABEL_47:
  v50[0] = &v43;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v50);
  v50[0] = &v46;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v50);
  v50[0] = &v48;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v50);
  if (v57 && v56[6] == 1)
    free(v57);
  return v17;
}

BOOL ___ZN2KB13LanguageModel22find_token_id_for_wordEPK10__CFStringRKN3WTF6RefPtrINS_19DictionaryContainerEEERKNS_20LanguageModelContextEjPK10__CFLocaleRNS_6StringERb_block_invoke_2(uint64_t a1, KB::String *this)
{
  if (!KB::String::equal(this, (const KB::String *)(a1 + 32), 0))
    return 1;
  if (*(_BYTE *)(a1 + 64))
    return 0;
  return (*((_BYTE *)this + 106) & 4) == 0;
}

void std::vector<KB::Word>::erase(uint64_t a1, uint64_t a2, KB::Word *a3)
{
  KB::Word *v3;
  uint64_t v4;
  KB::Word *v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  if ((KB::Word *)a2 != a3)
  {
    v3 = a3;
    v4 = a2;
    v6 = *(KB::Word **)(a1 + 8);
    if (a3 != v6)
    {
      v7 = 16 * (((uint64_t)a3 - a2) >> 4);
      do
      {
        KB::String::operator=(v4, (KB::String *)(v4 + v7));
        KB::ByteString::operator=((unsigned __int16 *)(v4 + 32), (unsigned __int16 *)(v4 + v7 + 32));
        v8 = *(_QWORD *)(v4 + v7 + 48);
        *(_DWORD *)(v4 + 56) = *(_DWORD *)(v4 + v7 + 56);
        *(_QWORD *)(v4 + 48) = v8;
        KB::String::operator=(v4 + 64, (KB::String *)(v4 + v7 + 64));
        v9 = *(_OWORD *)(v4 + v7 + 96);
        v10 = *(_OWORD *)(v4 + v7 + 112);
        v11 = *(_OWORD *)(v4 + v7 + 144);
        *(_OWORD *)(v4 + 128) = *(_OWORD *)(v4 + v7 + 128);
        *(_OWORD *)(v4 + 144) = v11;
        *(_OWORD *)(v4 + 96) = v9;
        *(_OWORD *)(v4 + 112) = v10;
        KB::String::operator=(v4 + 160, (KB::String *)(v4 + v7 + 160));
        *(_BYTE *)(v4 + 192) = *(_BYTE *)(v4 + v7 + 192);
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(v4 + 200, (uint64_t *)(v4 + v7 + 200));
        v4 += 240;
      }
      while ((KB::Word *)(v4 + v7) != v6);
      v3 = *(KB::Word **)(a1 + 8);
    }
    while (v3 != (KB::Word *)v4)
    {
      v3 = (KB::Word *)((char *)v3 - 240);
      KB::Word::~Word(v3);
    }
    *(_QWORD *)(a1 + 8) = v4;
  }
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  if (*(_QWORD *)(a1 + 24))
  {
    v4 = *(_QWORD **)(a1 + 16);
    if (v4)
    {
      do
      {
        v5 = (_QWORD *)*v4;
        operator delete(v4);
        v4 = v5;
      }
      while (v5);
    }
    *(_QWORD *)(a1 + 16) = 0;
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      for (i = 0; i != v6; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
  v8 = *a2;
  *a2 = 0;
  v9 = *(void **)a1;
  *(_QWORD *)a1 = v8;
  if (v9)
    operator delete(v9);
  v12 = a2[2];
  v11 = a2 + 2;
  v10 = v12;
  v13 = *(v11 - 1);
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(a1 + 8) = v13;
  *(v11 - 1) = 0;
  v14 = v11[1];
  *(_QWORD *)(a1 + 24) = v14;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v11 + 4);
  if (v14)
  {
    v15 = *(_QWORD *)(v10 + 8);
    v16 = *(_QWORD *)(a1 + 8);
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v15 >= v16)
        v15 %= v16;
    }
    else
    {
      v15 &= v16 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v15) = a1 + 16;
    *v11 = 0;
    v11[1] = 0;
  }
}

KB::String *__copy_helper_block_a8_32c16_ZTSN2KB6StringE(uint64_t a1, uint64_t a2)
{
  return KB::String::String((KB::String *)(a1 + 32), (const KB::String *)(a2 + 32));
}

void __destroy_helper_block_a8_32c16_ZTSN2KB6StringE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 38) == 1)
      free(v2);
  }
}

void KB::LanguageModel::background_load(uint64_t a1, void *a2)
{
  KB::LanguageModel *v3;
  KB::LanguageModel *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  void *v8;
  unint64_t *v9;
  unint64_t v10;
  KB::LanguageModel *v11;

  v3 = a2;
  v4 = v3;
  v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5)
  {
    p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
    do
      v7 = __ldxr(p_shared_weak_owners);
    while (__stxr(v7 + 1, p_shared_weak_owners));
  }
  KB::LanguageModel::background_loading_queue(v3);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  if (v5)
  {
    v9 = (unint64_t *)&v5->__shared_weak_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = v4;
  TIDispatchAsync();

  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
  }

}

uint64_t ___ZN2KB13LanguageModel15background_loadENSt3__110shared_ptrIS0_EEU13block_pointerFvvE_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t result;

  v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = a1[5];
      if (v5 && ((*(uint64_t (**)(_QWORD))(*(_QWORD *)v5 + 16))(a1[5]) & 1) == 0)
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 560))(v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  result = a1[4];
  if (result)
    return (*(uint64_t (**)(void))(result + 16))();
  return result;
}

uint64_t __copy_helper_block_a8_40c43_ZTSNSt3__18weak_ptrIN2KB13LanguageModelEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_a8_40c43_ZTSNSt3__18weak_ptrIN2KB13LanguageModelEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void KB::LanguageModel::clear_dynamic_learning_bundles(const void *a1, void *a2)
{
  id v3;
  KB::LanguageModel *v4;
  void *v5;
  id v6;

  v3 = a2;
  if (a1)
  {
    v4 = (KB::LanguageModel *)CFRetain(a1);
    KB::LanguageModel::background_loading_queue(v4);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = v3;
    TIDispatchAsync();

  }
}

void ___ZN2KB13LanguageModel30clear_dynamic_learning_bundlesEPK7__CFURLU13block_pointerFvbE_block_invoke(uint64_t a1)
{
  id v2;
  __int128 v3;

  v3 = *(_OWORD *)(a1 + 32);
  v2 = (id)v3;
  TIDispatchSync();
  CFRelease(*(CFTypeRef *)(a1 + 40));

}

uint64_t ___ZN2KB13LanguageModel30clear_dynamic_learning_bundlesEPK7__CFURLU13block_pointerFvbE_block_invoke_2()
{
  return LMLanguageModelRemoveModelBundlesInDirectory();
}

void KB::LanguageModel::perform_maintenance(void *a1)
{
  KB::LanguageModel *v1;
  void *v2;
  KB::LanguageModel *v3;
  KB::LanguageModel *v4;

  v1 = a1;
  KB::LanguageModel::background_loading_queue(v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v1;
  v3 = v1;
  TIDispatchAsync();

}

void ___ZN2KB13LanguageModel19perform_maintenanceEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  id v2;

  LMLanguageModelPerformMaintenance();
  KB::LanguageModelImplStub::enumerate_cached_wrappers(&__block_literal_global_13682);
  v2 = *(id *)(a1 + 32);
  TIDispatchSync();

}

uint64_t ___ZN2KB13LanguageModel19perform_maintenanceEU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void KB::LanguageModel::get_static_unigrams_filepath(KB *a1@<X1>, uint64_t a2@<X8>)
{
  KB *v3;
  id v4;

  KB::ns_string(a1, a1);
  v4 = (id)objc_claimAutoreleasedReturnValue();
  UIKeyboardStaticUnigramsFile(v4);
  v3 = (KB *)objc_claimAutoreleasedReturnValue();
  KB::utf8_string(v3, a2);

}

float *KB::LanguageModel::PredictionInfo::PredictionInfo(_QWORD *a1, uint64_t a2, uint64_t a3, int a4, float a5)
{
  float *result;

  result = (float *)std::vector<TITokenID>::vector(a1, a2);
  result[6] = a5;
  *((_QWORD *)result + 4) = a3;
  *((_DWORD *)result + 10) = a4;
  *((_QWORD *)result + 19) = 0;
  *((_OWORD *)result + 3) = 0u;
  *((_OWORD *)result + 4) = 0u;
  *((_OWORD *)result + 5) = 0u;
  *((_OWORD *)result + 6) = 0u;
  *((_OWORD *)result + 7) = 0u;
  *((_OWORD *)result + 8) = 0u;
  if (*((_QWORD *)result + 1) != *(_QWORD *)result)
    result[36] = **(float **)result;
  return result;
}

{
  float *result;

  result = (float *)std::vector<TITokenID>::vector(a1, a2);
  result[6] = a5;
  *((_QWORD *)result + 4) = a3;
  *((_DWORD *)result + 10) = a4;
  *((_QWORD *)result + 19) = 0;
  *((_OWORD *)result + 3) = 0u;
  *((_OWORD *)result + 4) = 0u;
  *((_OWORD *)result + 5) = 0u;
  *((_OWORD *)result + 6) = 0u;
  *((_OWORD *)result + 7) = 0u;
  *((_OWORD *)result + 8) = 0u;
  if (*((_QWORD *)result + 1) != *(_QWORD *)result)
    result[36] = **(float **)result;
  return result;
}

KB::LanguageModel::PredictionInfo *KB::LanguageModel::PredictionInfo::PredictionInfo(KB::LanguageModel::PredictionInfo *this, const TIInlineCompletion *a2, int a3)
{
  double v6;
  float v7;
  int v8;
  char v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  int64x2_t *v14;
  std::string *p_p;
  uint64_t v16;
  uint64_t i;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  __int128 v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  __int128 v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  __int128 v32;
  int64x2_t v33;
  unint64_t v34;
  std::string *v35;
  int v36;
  char *v37;
  unint64_t v38;
  unint64_t v39;
  __int128 v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  __int128 v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  __int128 v52;
  int64x2_t v53;
  unint64_t v54;
  std::string *v55;
  int v56;
  std::string __p;
  uint64_t v59;
  uint64_t v60;
  void *v61[2];
  uint64_t v62;
  std::__split_buffer<std::string> v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  if (*((_BYTE *)a2 + 72))
    v6 = COERCE_DOUBLE(language_modeling::v1::InlineCompletion::probability((const TIInlineCompletion *)((char *)a2 + 64)));
  else
    v6 = *((double *)a2 + 6);
  v7 = v6;
  *((float *)this + 6) = __exp10f(v7);
  *((_QWORD *)this + 4) = 0;
  v8 = *((unsigned __int8 *)a2 + 72);
  if (*((_BYTE *)a2 + 72))
  {
    language_modeling::v1::InlineCompletion::probability((const TIInlineCompletion *)((char *)a2 + 64));
    v8 = v9 & 3;
  }
  *((_DWORD *)this + 10) = v8;
  v10 = (std::string *)((char *)this + 48);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v11 = *(_OWORD *)a2;
    *((_QWORD *)this + 8) = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
  }
  v12 = (std::string *)((char *)this + 72);
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v12, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v13 = *(_OWORD *)((char *)a2 + 24);
    *((_QWORD *)this + 11) = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v12->__r_.__value_.__l.__data_ = v13;
  }
  *((_OWORD *)this + 6) = 0u;
  v14 = (int64x2_t *)((char *)this + 96);
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = a3;
  *((_BYTE *)this + 149) = 0;
  *((_BYTE *)this + 150) = *((_DWORD *)a2 + 14) == 3;
  *((_QWORD *)this + 19) = 0;
  if (*((char *)a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  else
    __p = *(std::string *)a2;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  KB::String::String((KB::String *)&v63, (const char *)p_p);
  WORD2(v61[0]) = 0;
  BYTE6(v61[0]) = 0;
  v61[1] = " \t\n";
  LODWORD(v61[0]) = 1048579;
  BYTE1(v62) = 0;
  KB::sbs_string_tokenize((unsigned __int16 *)&v63, (const KB::String *)v61, &v59);
  if (v61[1] && BYTE6(v61[0]) == 1)
    free(v61[1]);
  if (v63.__begin_ && BYTE6(v63.__first_) == 1)
    free(v63.__begin_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v16 = v59;
  for (i = v60; v16 != i; v16 += 32)
  {
    if (*(_WORD *)v16)
    {
      if (*(_QWORD *)(v16 + 8))
        v18 = *(char **)(v16 + 8);
      else
        v18 = (char *)(v16 + 16);
    }
    else
    {
      v18 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(v61, v18);
    v20 = *((_QWORD *)this + 13);
    v19 = *((_QWORD *)this + 14);
    if (v20 >= v19)
    {
      v22 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v14->i64[0]) >> 3);
      v23 = v22 + 1;
      if (v22 + 1 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_75;
      v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v14->i64[0]) >> 3);
      if (2 * v24 > v23)
        v23 = 2 * v24;
      if (v24 >= 0x555555555555555)
        v25 = 0xAAAAAAAAAAAAAAALL;
      else
        v25 = v23;
      v63.__end_cap_.__value_ = (std::allocator<std::string> *)((char *)this + 112);
      if (v25)
        v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v25);
      else
        v26 = 0;
      v27 = v25 + 24 * v22;
      v28 = *(_OWORD *)v61;
      *(_QWORD *)(v27 + 16) = v62;
      *(_OWORD *)v27 = v28;
      v61[1] = 0;
      v62 = 0;
      v61[0] = 0;
      v30 = *((_QWORD *)this + 12);
      v29 = *((_QWORD *)this + 13);
      if (v29 == v30)
      {
        v33 = vdupq_n_s64(v29);
        v31 = v25 + 24 * v22;
      }
      else
      {
        v31 = v25 + 24 * v22;
        do
        {
          v32 = *(_OWORD *)(v29 - 24);
          *(_QWORD *)(v31 - 8) = *(_QWORD *)(v29 - 8);
          *(_OWORD *)(v31 - 24) = v32;
          v31 -= 24;
          *(_QWORD *)(v29 - 16) = 0;
          *(_QWORD *)(v29 - 8) = 0;
          *(_QWORD *)(v29 - 24) = 0;
          v29 -= 24;
        }
        while (v29 != v30);
        v33 = *v14;
      }
      v34 = v27 + 24;
      *((_QWORD *)this + 12) = v31;
      *((_QWORD *)this + 13) = v27 + 24;
      *(int64x2_t *)&v63.__begin_ = v33;
      v35 = (std::string *)*((_QWORD *)this + 14);
      *((_QWORD *)this + 14) = v25 + 24 * v26;
      v63.__end_cap_.__value_ = v35;
      v63.__first_ = (std::__split_buffer<std::string>::pointer)v33.i64[0];
      std::__split_buffer<std::string>::~__split_buffer(&v63);
      v36 = SHIBYTE(v62);
      *((_QWORD *)this + 13) = v34;
      if (v36 < 0)
        operator delete(v61[0]);
    }
    else
    {
      v21 = *(_OWORD *)v61;
      *(_QWORD *)(v20 + 16) = v62;
      *(_OWORD *)v20 = v21;
      *((_QWORD *)this + 13) = v20 + 24;
    }
    if (*(_WORD *)v16)
    {
      if (*(_QWORD *)(v16 + 8))
        v37 = *(char **)(v16 + 8);
      else
        v37 = (char *)(v16 + 16);
    }
    else
    {
      v37 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(v61, v37);
    v39 = *((_QWORD *)this + 16);
    v38 = *((_QWORD *)this + 17);
    if (v39 >= v38)
    {
      v41 = *((_QWORD *)this + 15);
      v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39 - v41) >> 3);
      v43 = v42 + 1;
      if (v42 + 1 > 0xAAAAAAAAAAAAAAALL)
LABEL_75:
        abort();
      v44 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v38 - v41) >> 3);
      if (2 * v44 > v43)
        v43 = 2 * v44;
      if (v44 >= 0x555555555555555)
        v45 = 0xAAAAAAAAAAAAAAALL;
      else
        v45 = v43;
      v63.__end_cap_.__value_ = (std::allocator<std::string> *)((char *)this + 136);
      if (v45)
        v45 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v45);
      else
        v46 = 0;
      v47 = v45 + 24 * v42;
      v48 = *(_OWORD *)v61;
      *(_QWORD *)(v47 + 16) = v62;
      *(_OWORD *)v47 = v48;
      v61[1] = 0;
      v62 = 0;
      v61[0] = 0;
      v50 = *((_QWORD *)this + 15);
      v49 = *((_QWORD *)this + 16);
      if (v49 == v50)
      {
        v53 = vdupq_n_s64(v49);
        v51 = v45 + 24 * v42;
      }
      else
      {
        v51 = v45 + 24 * v42;
        do
        {
          v52 = *(_OWORD *)(v49 - 24);
          *(_QWORD *)(v51 - 8) = *(_QWORD *)(v49 - 8);
          *(_OWORD *)(v51 - 24) = v52;
          v51 -= 24;
          *(_QWORD *)(v49 - 16) = 0;
          *(_QWORD *)(v49 - 8) = 0;
          *(_QWORD *)(v49 - 24) = 0;
          v49 -= 24;
        }
        while (v49 != v50);
        v53 = *(int64x2_t *)((char *)this + 120);
      }
      v54 = v47 + 24;
      *((_QWORD *)this + 15) = v51;
      *((_QWORD *)this + 16) = v47 + 24;
      *(int64x2_t *)&v63.__begin_ = v53;
      v55 = (std::string *)*((_QWORD *)this + 17);
      *((_QWORD *)this + 17) = v45 + 24 * v46;
      v63.__end_cap_.__value_ = v55;
      v63.__first_ = (std::__split_buffer<std::string>::pointer)v53.i64[0];
      std::__split_buffer<std::string>::~__split_buffer(&v63);
      v56 = SHIBYTE(v62);
      *((_QWORD *)this + 16) = v54;
      if (v56 < 0)
        operator delete(v61[0]);
    }
    else
    {
      v40 = *(_OWORD *)v61;
      *(_QWORD *)(v39 + 16) = v62;
      *(_OWORD *)v39 = v40;
      *((_QWORD *)this + 16) = v39 + 24;
    }
  }
  v63.__first_ = (std::__split_buffer<std::string>::pointer)&v59;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v63);
  return this;
}

KB::LanguageModel::PredictionInfo *KB::LanguageModel::PredictionInfo::PredictionInfo(KB::LanguageModel::PredictionInfo *this, const language_modeling::v1::Prediction *a2, int a3)
{
  float v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  std::string __p;
  std::string **v18;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v6 = COERCE_DOUBLE(language_modeling::v1::Prediction::probability(a2));
  *((float *)this + 6) = __exp10f(v6);
  *((_QWORD *)this + 4) = language_modeling::v1::Prediction::contextSize(a2);
  language_modeling::v1::Prediction::probability(a2);
  *((_DWORD *)this + 10) = v7 & 3;
  language_modeling::v1::Prediction::string(a2);
  language_modeling::v1::Prediction::log(a2);
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = a3;
  *((_BYTE *)this + 148) = language_modeling::v1::Prediction::source(a2) == 8;
  *(_WORD *)((char *)this + 149) = language_modeling::v1::Prediction::source(a2) == 2;
  *((_QWORD *)this + 19) = language_modeling::v1::Prediction::unique_id(a2);
  v8 = language_modeling::v1::Prediction::tokenSpan(a2);
  v18 = (std::string **)((char *)this + 96);
  if (v9)
  {
    v10 = v8;
    v11 = 32 * v9;
    do
    {
      if (*(char *)(v10 + 23) < 0)
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v10, *(_QWORD *)(v10 + 8));
      else
        __p = *(std::string *)v10;
      std::back_insert_iterator<std::vector<std::string>>::operator=[abi:nn180100](&v18, (__int128 *)&__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v10 += 32;
      v11 -= 32;
    }
    while (v11);
  }
  v12 = language_modeling::v1::Prediction::exactTokenSpan(a2);
  v18 = (std::string **)((char *)this + 120);
  if (v13)
  {
    v14 = v12;
    v15 = 32 * v13;
    do
    {
      if (*(char *)(v14 + 23) < 0)
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v14, *(_QWORD *)(v14 + 8));
      else
        __p = *(std::string *)v14;
      std::back_insert_iterator<std::vector<std::string>>::operator=[abi:nn180100](&v18, (__int128 *)&__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v14 += 32;
      v15 -= 32;
    }
    while (v15);
  }
  return this;
}

std::string ***std::back_insert_iterator<std::vector<std::string>>::operator=[abi:nn180100](std::string ***a1, __int128 *a2)
{
  std::string **v4;
  std::string *v5;
  std::allocator<std::string> *v6;
  __int128 v7;
  std::string *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  __int128 v14;
  std::string *v15;
  std::string *v16;
  unint64_t v17;
  __int128 v18;
  std::string *v19;
  std::string *v20;
  std::__split_buffer<std::string> v22;

  v4 = *a1;
  v5 = (*a1)[1];
  v6 = (std::allocator<std::string> *)(*a1 + 2);
  if ((unint64_t)v5 >= *(_QWORD *)v6)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)*v4) >> 3);
    v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
      abort();
    if (0x5555555555555556 * ((uint64_t)(*(_QWORD *)v6 - (_QWORD)*v4) >> 3) > v10)
      v10 = 0x5555555555555556 * ((uint64_t)(*(_QWORD *)v6 - (_QWORD)*v4) >> 3);
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)v6 - (_QWORD)*v4) >> 3) >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v10;
    v22.__end_cap_.__value_ = v6;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v11);
    else
      v12 = 0;
    v13 = v11 + 24 * v9;
    v14 = *a2;
    *(_QWORD *)(v13 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v13 = v14;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v16 = *v4;
    v15 = v4[1];
    if (v15 == *v4)
    {
      v19 = v4[1];
      v17 = v11 + 24 * v9;
    }
    else
    {
      v17 = v11 + 24 * v9;
      do
      {
        v18 = *(_OWORD *)&v15[-1].__r_.__value_.__l.__data_;
        *(_QWORD *)(v17 - 8) = *((_QWORD *)&v15[-1].__r_.__value_.__l + 2);
        *(_OWORD *)(v17 - 24) = v18;
        v17 -= 24;
        v15[-1].__r_.__value_.__l.__size_ = 0;
        v15[-1].__r_.__value_.__r.__words[2] = 0;
        v15[-1].__r_.__value_.__r.__words[0] = 0;
        --v15;
      }
      while (v15 != v16);
      v19 = *v4;
      v15 = v4[1];
    }
    v8 = (std::string *)(v13 + 24);
    *v4 = (std::string *)v17;
    v22.__first_ = v19;
    v22.__begin_ = v19;
    v4[1] = (std::string *)(v13 + 24);
    v22.__end_ = v15;
    v20 = v4[2];
    v4[2] = (std::string *)(v11 + 24 * v12);
    v22.__end_cap_.__value_ = v20;
    std::__split_buffer<std::string>::~__split_buffer(&v22);
  }
  else
  {
    v7 = *a2;
    v5->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v7;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v8 = v5 + 1;
  }
  v4[1] = v8;
  return a1;
}

uint64_t KB::LanguageModel::PredictionInfo::has_dynamic_contribution(KB::LanguageModel::PredictionInfo *this)
{
  return *((_DWORD *)this + 10) & 1;
}

uint64_t KB::LanguageModel::PredictionInfo::has_recency_contribution(KB::LanguageModel::PredictionInfo *this)
{
  return (*((unsigned __int8 *)this + 40) >> 1) & 1;
}

KB::String *KB::kb_user_directory@<X0>(KB::String *a1@<X8>)
{
  const char *v3;

  v3 = (const char *)objc_msgSend(objc_retainAutorelease((id)TI_KB_USER_DIRECTORY()), "fileSystemRepresentation");
  return KB::String::String(a1, v3);
}

uint64_t TI_KB_USER_DIRECTORY()
{
  uint64_t result;
  unsigned __int8 v1;
  void **p_cache;
  int v3;

  result = s_kb_user_directory;
  if (!s_kb_user_directory)
  {
    p_cache = &OBJC_METACLASS___TIKBSessionTouchInfo.cache;
    if ((v1 & 1) == 0)
    {
      p_cache = (void **)(&OBJC_METACLASS___TIKBSessionTouchInfo + 16);
      if (v3)
      {
        TI_KB_USER_DIRECTORY::default_kb_user_directory = CreateDefaultKeyboardUserDirectory();
        p_cache = (void **)(&OBJC_METACLASS___TIKBSessionTouchInfo + 16);
      }
    }
    return (uint64_t)p_cache[485];
  }
  return result;
}

uint64_t CreateDefaultKeyboardUserDirectory(void)
{
  void *v0;
  uint64_t v1;

  CPSharedResourcesDirectory();
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "stringByAppendingPathComponent:", CFSTR("/Library/Keyboard"));
  v1 = objc_claimAutoreleasedReturnValue();

  return v1;
}

unsigned __int16 *KB::kb_user_directory_file@<X0>(KB *this@<X0>, KB::String *a2@<X8>)
{
  KB::kb_user_directory(a2);
  KB::String::append((unsigned __int16 *)a2, "/", 0xFFFFuLL);
  return KB::String::append((unsigned __int16 *)a2, this);
}

double KB::system_uptime(KB *this)
{
  void *v1;
  double v2;
  double v3;

  objc_msgSend(MEMORY[0x1E0CB3898], "processInfo");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "systemUptime");
  v3 = v2;

  return v3;
}

uint64_t TI_IS_WILDCAT()
{
  return s_interface_idiom_is_pad;
}

uint64_t TI_SET_IS_WILDCAT(uint64_t result)
{
  s_interface_idiom_is_pad = result;
  return result;
}

uint64_t TI_IS_TRACE_LOGGING_ENABLED()
{
  return s_trace_logging_enabled;
}

uint64_t TI_SET_IS_TRACE_LOGGING_ENABLED(uint64_t result)
{
  s_trace_logging_enabled = result;
  return result;
}

uint64_t TI_IS_INTERNAL_INSTALL()
{
  if (TI_IS_INTERNAL_INSTALL::once_token != -1)
    dispatch_once(&TI_IS_INTERNAL_INSTALL::once_token, &__block_literal_global_3460);
  return TI_IS_INTERNAL_INSTALL::is_internal_install;
}

uint64_t TI_DEVICE_UNLOCKED()
{
  void *v0;
  void *v1;
  int v2;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  void *v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = getMKBGetDeviceLockStateSymbolLoc(void)::ptr;
  v8 = getMKBGetDeviceLockStateSymbolLoc(void)::ptr;
  if (!getMKBGetDeviceLockStateSymbolLoc(void)::ptr)
  {
    v1 = (void *)MobileKeyBagLibrary();
    v0 = dlsym(v1, "MKBGetDeviceLockState");
    v6[3] = (uint64_t)v0;
    getMKBGetDeviceLockStateSymbolLoc(void)::ptr = v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = ((uint64_t (*)(_QWORD))v0)(0);
    return !v2 || v2 == 3;
  }
  else
  {
    dlerror();
    abort_report_np();
    return MobileKeyBagLibrary();
  }
}

uint64_t MobileKeyBagLibrary(void)
{
  uint64_t v0;
  void *v2;

  if (MobileKeyBagLibraryCore(char **)::frameworkLibrary)
    return MobileKeyBagLibraryCore(char **)::frameworkLibrary;
  MobileKeyBagLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  v0 = MobileKeyBagLibraryCore(char **)::frameworkLibrary;
  if (!MobileKeyBagLibraryCore(char **)::frameworkLibrary)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

void TI_SET_KB_USER_DIRECTORY(CFTypeRef cf)
{
  if ((CFTypeRef)s_kb_user_directory != cf)
  {
    if (s_kb_user_directory)
    {
      CFRelease((CFTypeRef)s_kb_user_directory);
      s_kb_user_directory = 0;
    }
    if (cf)
      s_kb_user_directory = (uint64_t)CFRetain(cf);
  }
}

double TIGetCurrentTime()
{
  if (TIGetCurrentTime::onceToken != -1)
    dispatch_once(&TIGetCurrentTime::onceToken, &__block_literal_global_3);
  return *(double *)&TIGetCurrentTime::time_scale * (double)mach_absolute_time();
}

BOOL TI_SET_PROTECTION_CLASS_C(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  id v4;
  void *v6;
  id v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:", a1, 0, 0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = *MEMORY[0x1E0C99928];
  v3 = *MEMORY[0x1E0C99938];
  v7 = 0;
  objc_msgSend(v1, "setResourceValue:forKey:error:", v2, v3, &v7);
  v4 = v7;
  if (v4 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    objc_msgSend(v4, "description");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136315394;
    v9 = "TI_SET_PROTECTION_CLASS_C";
    v10 = 2112;
    v11 = v6;
    _os_log_error_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s  couldn't set protection class, error: %@", buf, 0x16u);

  }
  return v4 == 0;
}

uint64_t TI_IS_FILE_CLASS_C(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v7;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = 0;
  objc_msgSend(v2, "attributesOfItemAtPath:error:", v1, &v7);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v3, "objectForKey:", *MEMORY[0x1E0CB2AD8]);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "isEqualToString:", *MEMORY[0x1E0CB2AC0]);

  return v5;
}

uint64_t TI_SET_USING_ML_BASED_TAP_TYPING(uint64_t result)
{
  s_ml_based_tap_typing = result;
  return result;
}

uint64_t TI_IS_USING_ML_BASED_TAP_TYPING()
{
  return s_ml_based_tap_typing;
}

uint64_t TI_SET_USING_TOUCAN_LM(uint64_t result)
{
  s_use_lm_transformer = result;
  return result;
}

BOOL TI_IS_USING_TOUCAN_LM_BASED_COMPLETIONS()
{
  return s_use_lm_transformer != 0;
}

BOOL TI_IS_USING_TOUCAN_LM_BASED_AUTOCORRECTION()
{
  return s_use_lm_transformer == -1 || s_use_lm_transformer == 2;
}

uint64_t TI_SET_IS_USING_CUSTOM_DIALECT_LM(uint64_t result)
{
  s_using_custom_dialect_lm = result;
  return result;
}

uint64_t TI_IS_USING_CUSTOM_DIALECT_LM()
{
  return s_using_custom_dialect_lm;
}

void TI_SET_DIALECT_LM_PATH(CFTypeRef cf)
{
  if ((CFTypeRef)s_dialect_lm_path != cf)
  {
    if (s_dialect_lm_path)
    {
      CFRelease((CFTypeRef)s_dialect_lm_path);
      s_dialect_lm_path = 0;
    }
    if (cf)
      s_dialect_lm_path = (uint64_t)CFRetain(cf);
  }
}

void *TI_DIALECT_LM_PATH()
{
  void *v0;

  v0 = (void *)s_dialect_lm_path;
  if (!s_dialect_lm_path)
  {
    CPSharedResourcesDirectory();
    v0 = (void *)objc_claimAutoreleasedReturnValue();

  }
  return v0;
}

uint64_t TIIsRevision_Enabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TILogProblemSentencesToStdout()
{
  return _os_feature_enabled_impl();
}

uint64_t TIPrintTypingTranscriptToStdout()
{
  return _os_feature_enabled_impl();
}

uint64_t TIIsNumberToLetterCorrectionEnabled()
{
  uint64_t result;

  LODWORD(result) = _os_feature_enabled_impl();
  if (HIBYTE(number_to_letter_correction_locally_enabled(void)::locally_enabled))
    return (_BYTE)number_to_letter_correction_locally_enabled(void)::locally_enabled != 0;
  else
    return result;
}

uint64_t TISetNumberToLetterCorrectionEnabled(uint64_t result)
{
  number_to_letter_correction_locally_enabled(void)::locally_enabled = result | 0x100;
  return result;
}

uint64_t TIAreModernCandidateFiltersEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIMultilingualKeyboardEnabled()
{
  return _os_feature_enabled_impl();
}

BOOL TIMultilingualDynamicModelEnabled(char *a1)
{
  uint64_t i;
  size_t v3;
  unint64_t v4;
  _BOOL8 v5;
  void **v6;
  void *__p[2];
  unsigned __int8 v9;

  if (!_os_feature_enabled_impl())
    return 0;
  std::string::basic_string[abi:nn180100]<0>(__p, a1);
  for (i = 0; i != 4; ++i)
  {
    v3 = strlen((&off_1EA0FC398)[i]);
    if (std::string::starts_with[abi:nn180100]((uint64_t)__p, (&off_1EA0FC398)[i], v3))
    {
      v5 = 1;
      goto LABEL_16;
    }
  }
  if ((v9 & 0x80u) == 0)
    v4 = v9;
  else
    v4 = (unint64_t)__p[1];
  if (v4 >= 4)
  {
    if ((v9 & 0x80u) == 0)
      v6 = __p;
    else
      v6 = (void **)__p[0];
    v5 = std::string_view::compare[abi:nn180100]((uint64_t)v6, v4, v4 - 4, 0xFFFFFFFFFFFFFFFFLL, "Latn", 4uLL) == 0;
  }
  else
  {
    v5 = 0;
  }
LABEL_16:
  if ((char)v9 < 0)
    operator delete(__p[0]);
  return v5;
}

BOOL std::string::starts_with[abi:nn180100](uint64_t a1, void *__s2, size_t a3)
{
  unint64_t v4;
  uint64_t v5;

  if (*(char *)(a1 + 23) < 0)
  {
    v5 = a1;
    a1 = *(_QWORD *)a1;
    v4 = *(_QWORD *)(v5 + 8);
  }
  else
  {
    v4 = *(unsigned __int8 *)(a1 + 23);
  }
  return v4 >= a3 && std::string_view::compare[abi:nn180100](a1, v4, 0, a3, __s2, a3) == 0;
}

uint64_t std::string_view::compare[abi:nn180100](uint64_t a1, unint64_t a2, unint64_t a3, size_t a4, void *__s2, size_t a6)
{
  const void *v7;
  size_t v8;
  size_t v9;
  uint64_t result;
  unsigned int v11;

  if (a2 < a3)
    abort();
  v7 = (const void *)(a1 + a3);
  if (a2 - a3 >= a4)
    v8 = a4;
  else
    v8 = a2 - a3;
  if (a6 >= v8)
    v9 = v8;
  else
    v9 = a6;
  LODWORD(result) = memcmp(v7, __s2, v9);
  if (v8 < a6)
    v11 = -1;
  else
    v11 = 1;
  if (v8 == a6)
    v11 = 0;
  if ((_DWORD)result)
    return result;
  else
    return v11;
}

uint64_t TIUseTransliterationWithContext()
{
  return 0;
}

uint64_t TIMultilingualKeyboardSupportedLanguagesCount()
{
  if (_os_feature_enabled_impl())
    return 3;
  else
    return 2;
}

uint64_t TINonHindiIndiaEmojisEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIAreInlineCompletionsEnabled()
{
  if (HIBYTE(inline_completions_override))
    return inline_completions_override;
  else
    return _os_feature_enabled_impl();
}

uint64_t TIOverrideInlineCompletionsFlag(uint64_t result)
{
  inline_completions_override = result | 0x100;
  return result;
}

void TIRestoreInlineCompletionsFlag()
{
  if (HIBYTE(inline_completions_override))
    HIBYTE(inline_completions_override) = 0;
}

uint64_t TIInlineCompletionsFullAcceptanceBySpaceEnabled()
{
  if (HIBYTE(inline_completions_full_acceptance_by_space))
    return inline_completions_full_acceptance_by_space;
  else
    return _os_feature_enabled_impl();
}

uint64_t TIOverrideInlineCompletionsFullAcceptanceBySpace(uint64_t result)
{
  inline_completions_full_acceptance_by_space = result | 0x100;
  return result;
}

void TIRestoreInlineCompletionsFullAcceptanceBySpace()
{
  if (HIBYTE(inline_completions_full_acceptance_by_space))
    HIBYTE(inline_completions_full_acceptance_by_space) = 0;
}

uint64_t TIPromoteInlineToAutocorrectEnabled()
{
  if (HIBYTE(promote_inline_to_autocorrect))
    return promote_inline_to_autocorrect;
  else
    return _os_feature_enabled_impl();
}

uint64_t TIOverridePromoteInlineToAutocorrect(uint64_t result)
{
  promote_inline_to_autocorrect = result | 0x100;
  return result;
}

void TIRestorePromoteInlineToAutocorrect()
{
  if (HIBYTE(promote_inline_to_autocorrect))
    HIBYTE(promote_inline_to_autocorrect) = 0;
}

uint64_t TIPromoteAutocorrectToInlineEnabled()
{
  if (HIBYTE(promote_autocorrect_to_inline))
    return promote_autocorrect_to_inline;
  else
    return _os_feature_enabled_impl();
}

uint64_t TIOverridePromoteAutocorrectToInline(uint64_t result)
{
  promote_autocorrect_to_inline = result | 0x100;
  return result;
}

void TIRestorePromoteAutocorrectToInline()
{
  if (HIBYTE(promote_autocorrect_to_inline))
    HIBYTE(promote_autocorrect_to_inline) = 0;
}

void TIRestoreOverrideInlineCompletionPrecision()
{
  if (byte_1F0283360)
    byte_1F0283360 = 0;
}

uint64_t TIOverrideInlineCompletionPrecision(uint64_t result)
{
  inline_completion_precision_point_override = result;
  byte_1F0283360 = 1;
  return result;
}

uint64_t TIEnableInlineCompletionsForTestingEnabled()
{
  if (HIBYTE(enable_inline_for_testing))
    return enable_inline_for_testing;
  else
    return _os_feature_enabled_impl();
}

uint64_t TIOverrideEnableInlineCompletionForTesting(uint64_t result)
{
  enable_inline_for_testing = result | 0x100;
  return result;
}

void TIRestoreEnableInlineCompletionForTesting()
{
  if (HIBYTE(enable_inline_for_testing))
    HIBYTE(enable_inline_for_testing) = 0;
}

uint64_t TIAreInlineCompletionsEnabledEverywhere()
{
  if (HIBYTE(inline_completions_override))
    return inline_completions_override;
  else
    return _os_feature_enabled_impl();
}

uint64_t TIIsTransformerLMEnglishMultilingualEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TISwearWordPolicyV1Enabled()
{
  if (simular_swear_word_policy_v1_setting)
    return objc_msgSend((id)simular_swear_word_policy_v1_setting, "BOOLValue");
  else
    return _os_feature_enabled_impl();
}

void setSimularSwearWordPolicyV1Setting(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", a1);
  v1 = objc_claimAutoreleasedReturnValue();
  v2 = (void *)simular_swear_word_policy_v1_setting;
  simular_swear_word_policy_v1_setting = v1;

}

uint64_t TISwearWordPolicyV2Enabled()
{
  if (simular_swear_word_policy_v2_setting)
    return objc_msgSend((id)simular_swear_word_policy_v2_setting, "BOOLValue");
  else
    return _os_feature_enabled_impl();
}

void setSimularSwearWordPolicyV2Setting(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", a1);
  v1 = objc_claimAutoreleasedReturnValue();
  v2 = (void *)simular_swear_word_policy_v2_setting;
  simular_swear_word_policy_v2_setting = v1;

}

uint64_t TIAdaptationAutocorrectionRejectionV2Enabled()
{
  int v0;

  if (HIBYTE(adaptation_autocorrection_rejection_v2_override))
  {
    v0 = adaptation_autocorrection_rejection_v2_override;
    return v0 != 0;
  }
  if (HIBYTE(adaptation_autocorrection_rejection_v2_override_for_trial))
  {
    v0 = adaptation_autocorrection_rejection_v2_override_for_trial;
    return v0 != 0;
  }
  return _os_feature_enabled_impl();
}

void TIOverrideAdaptationAutocorrectionRejectionV2Trial(int a1)
{
  const char *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
  {
    v2 = "disabled";
    if (a1)
      v2 = "enabled";
    v3 = 136315394;
    v4 = "TIOverrideAdaptationAutocorrectionRejectionV2Trial";
    v5 = 2080;
    v6 = v2;
    _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  Trial: overriding adaptation_autocorrection_rejection_v2 to %s", (uint8_t *)&v3, 0x16u);
  }
  adaptation_autocorrection_rejection_v2_override_for_trial = a1 | 0x100;
}

uint64_t TIOverrideAdaptationAutocorrectionRejectionV2(uint64_t result)
{
  adaptation_autocorrection_rejection_v2_override = result | 0x100;
  return result;
}

void TIRestoreAdaptationAutocorrectionRejectionV2()
{
  if (HIBYTE(adaptation_autocorrection_rejection_v2_override))
    HIBYTE(adaptation_autocorrection_rejection_v2_override) = 0;
}

double TI_GET_SCALED_POINT(double a1, double a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, double a7, double a8, double a9, CGFloat a10, double a11, CGFloat a12)
{
  CGRect v22;
  CGRect v23;

  v22.origin.x = a3;
  v22.origin.y = a4;
  v22.size.width = a5;
  v22.size.height = a6;
  v23.origin.x = a9;
  v23.origin.y = a10;
  v23.size.width = a11;
  v23.size.height = a12;
  if (!CGRectEqualToRect(v22, v23))
    return a9 + (a1 - a3) / a5 * a11;
  return a1;
}

uint64_t TIIsTransientLexiconIngestionV2Enabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIAddAlternativesForRetrocorrectionEnabled()
{
  if (HIBYTE(add_alternatives_for_retrocorrection_override))
    return add_alternatives_for_retrocorrection_override;
  else
    return _os_feature_enabled_impl();
}

uint64_t TIOverrideAddAlternativesForRetrocorrection(uint64_t result)
{
  add_alternatives_for_retrocorrection_override = result | 0x100;
  return result;
}

void TIRestoreAddAlternativesForRetrocorrection()
{
  if (HIBYTE(add_alternatives_for_retrocorrection_override))
    HIBYTE(add_alternatives_for_retrocorrection_override) = 0;
}

uint64_t TIAreTransformerLMForVisionOSEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIAreInlineCompletionForVisionOSEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIIsStickersSuggestionsEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIPerRecipientAdaptationEnabled()
{
  return 1;
}

uint64_t KB::Input::Input(uint64_t this)
{
  *(_DWORD *)this = 0x100000;
  *(_WORD *)(this + 4) = 0;
  *(_BYTE *)(this + 6) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_BYTE *)(this + 16) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

{
  *(_DWORD *)this = 0x100000;
  *(_WORD *)(this + 4) = 0;
  *(_BYTE *)(this + 6) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_BYTE *)(this + 16) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

KB::String *KB::Input::Input(KB::Input *this, const KB::String *a2, int a3)
{
  KB::String *result;

  result = KB::String::String(this, a2);
  *((_DWORD *)result + 8) = a3;
  return result;
}

{
  KB::String *result;

  result = KB::String::String(this, a2);
  *((_DWORD *)result + 8) = a3;
  return result;
}

KB::String *KB::Input::Input(KB::Input *this, const KB::Input *a2)
{
  KB::String *result;

  result = KB::String::String(this, a2);
  *((_DWORD *)result + 8) = *((_DWORD *)a2 + 8);
  return result;
}

{
  KB::String *result;

  result = KB::String::String(this, a2);
  *((_DWORD *)result + 8) = *((_DWORD *)a2 + 8);
  return result;
}

KB::String *KB::Input::operator=(KB::String *result, KB::String *a2)
{
  if (result != a2)
  {
    result = KB::String::operator=(result, a2);
    *((_DWORD *)result + 8) = *((_DWORD *)a2 + 8);
  }
  return result;
}

uint64_t lookupVSeq(int a1, int a2, int a3)
{
  unsigned int *v3;
  _DWORD v5[4];

  v5[0] = a1;
  v5[1] = a2;
  v5[2] = a3;
  v3 = (unsigned int *)bsearch(v5, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
  if (v3)
    return v3[3];
  else
    return 0xFFFFFFFFLL;
}

uint64_t tripleVowelCompare(char *a1, char *a2)
{
  uint64_t v2;
  int v3;
  int v4;

  v2 = 0;
  while (1)
  {
    v3 = *(_DWORD *)&a1[v2];
    v4 = *(_DWORD *)&a2[v2];
    if (v3 < v4)
      break;
    if (v3 > v4)
      return 1;
    v2 += 4;
    if (v2 == 12)
      return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t lookupCSeq(int a1, int a2, int a3)
{
  unsigned int *v3;
  _DWORD v5[4];

  v5[0] = a1;
  v5[1] = a2;
  v5[2] = a3;
  v3 = (unsigned int *)bsearch(v5, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
  if (v3)
    return v3[3];
  else
    return 0xFFFFFFFFLL;
}

uint64_t tripleConCompare(char *a1, char *a2)
{
  uint64_t v2;
  int v3;
  int v4;

  v2 = 0;
  while (1)
  {
    v3 = *(_DWORD *)&a1[v2];
    v4 = *(_DWORD *)&a2[v2];
    if (v3 < v4)
      break;
    if (v3 > v4)
      return 1;
    v2 += 4;
    if (v2 == 12)
      return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t UkEngine::processRoof(uint64_t a1, int *a2)
{
  unsigned int v4;
  int v5;
  int v6;
  char v7;
  int v8;
  unsigned int v10;
  _DWORD *v11;
  int v12;
  uint64_t v13;
  int v14;
  _DWORD *v15;
  int v16;
  int v18;
  _DWORD *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  char v28;
  int v29;
  int v30;
  int *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int *v37;
  int v38;
  int v39;
  BOOL v40;
  int v41;
  int *v42;
  int v43;
  int v44;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  int v50;
  uint64_t v51;
  _DWORD *v52;
  int v53;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int TonePosition;
  int v64;
  uint64_t __key;
  int v66;

  if (!*(_DWORD *)(*(_QWORD *)(a1 + 8) + 4))
    return UkEngine::processAppend((UkEngine *)a1, a2);
  v4 = *(_DWORD *)(a1 + 28);
  if ((v4 & 0x80000000) != 0)
    return UkEngine::processAppend((UkEngine *)a1, a2);
  v5 = *(_DWORD *)(a1 + 36 * v4 + 3152);
  if (v5 < 0)
    return UkEngine::processAppend((UkEngine *)a1, a2);
  v6 = *a2;
  if (*a2 == 1)
  {
    v7 = 0;
    v8 = 13;
    goto LABEL_11;
  }
  if (v6 == 3)
  {
    v7 = 0;
    v8 = 109;
    goto LABEL_11;
  }
  if (v6 == 2)
  {
    v7 = 0;
    v8 = 57;
LABEL_11:
    v64 = v8;
    goto LABEL_13;
  }
  v64 = -1;
  v7 = 1;
LABEL_13:
  v10 = *(_DWORD *)(a1 + 3144 + 36 * (int)(v4 - v5) + 16);
  v11 = (_DWORD *)((char *)&VSeqList + 52 * (int)v10);
  v62 = v4 - v5;
  v12 = v4 - v5 - *v11 + 1;
  TonePosition = UkEngine::getTonePosition(a1, v10, v5 == 0);
  v61 = v12 + TonePosition;
  v13 = a1 + 3144 + 36 * (v12 + TonePosition);
  v16 = *(_DWORD *)(v13 + 24);
  v15 = (_DWORD *)(v13 + 24);
  v14 = v16;
  if (v10 - 43 > 0x17 || ((1 << (v10 - 43)) & 0xA00003) == 0)
  {
    v20 = *((_DWORD *)&VSeqList + 13 * (int)v10 + 10);
  }
  else
  {
    v18 = *((_DWORD *)&VSeqList + 13 * (int)v10 + 5);
    __key = 0x6D0000008FLL;
    v66 = v18;
    v19 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
    if (v19)
      v20 = v19[3];
    else
      v20 = -1;
  }
  if (v20 == -1)
  {
    v24 = *((_DWORD *)&VSeqList + 13 * (int)v10 + 9);
    if (v24 != -1)
    {
      v59 = v14;
      v25 = v24 + v12;
      v26 = a1 + 36 * (v24 + v12);
      v27 = *(_DWORD *)(v26 + 3172);
      v28 = v27 == v64 ? 1 : v7;
      if ((v28 & 1) != 0)
      {
        v29 = v27 == 57 ? 45 : 97;
        v30 = v27 == 13 ? 1 : v29;
        if (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 12) || v25 == *(_DWORD *)(a1 + 28))
        {
          v31 = (int *)(v26 + 3172);
          v32 = *(_DWORD *)(a1 + 16);
          if (v32 > v25)
          {
            v33 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v25, v32 - 1);
            *(_DWORD *)(a1 + 16) = v25;
            *(_DWORD *)(a1 + 20) = v33;
          }
          *v31 = v30;
          v34 = v12;
          if (*v11 == 2)
          {
            v48 = lookupVSeq(*(_DWORD *)(a1 + 36 * v12 + 3172), *(_DWORD *)(a1 + 36 * v12 + 3208), -1);
            v35 = v59;
            v36 = v62;
          }
          else
          {
            v35 = v59;
            v36 = v62;
            v37 = (int *)(a1 + 36 * v12);
            if (*v11 == 3)
            {
              v49 = v37[802];
              v50 = v37[811];
            }
            else
            {
              v49 = -1;
              v50 = -1;
            }
            v48 = lookupVSeq(v37[793], v49, v50);
          }
          v42 = (int *)((char *)&VSeqList + 52 * (int)v48);
          goto LABEL_71;
        }
      }
    }
  }
  else if ((v7 & 1) != 0 || *((_DWORD *)&VSeqList + 13 * v20 + *((int *)&VSeqList + 13 * v20 + 9) + 3) == v64)
  {
    v21 = *(_DWORD *)(a1 + 28);
    v22 = *(_DWORD *)(a1 + 36 * v21 + 3148);
    v23 = v22 == -1 ? -1 : *(_DWORD *)(a1 + 36 * (v21 - v22) + 3160);
    v34 = v12;
    v38 = *(_DWORD *)(a1 + 36 * v21 + 3156);
    v39 = v38 == -1 ? -1 : *(_DWORD *)(a1 + 36 * (v21 - v38) + 3160);
    if ((isValidCVC(v23, v20, v39) & 1) != 0)
    {
      v60 = v14;
      v40 = v10 - 43 > 0x17 || ((1 << (v10 - 43)) & 0xA00003) == 0;
      v41 = v12;
      if (v40)
        v41 = *((_DWORD *)&VSeqList + 13 * v20 + 9) + v12;
      if (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 12) || v41 == *(_DWORD *)(a1 + 28))
      {
        v42 = (int *)((char *)&VSeqList + 52 * v20);
        v43 = *(_DWORD *)(a1 + 16);
        if (v43 > v41)
        {
          v44 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v41, v43 - 1);
          *(_DWORD *)(a1 + 16) = v41;
          *(_DWORD *)(a1 + 20) = v44;
        }
        if (v10 - 43 > 0x17 || ((1 << (v10 - 43)) & 0xA00003) == 0)
        {
          *(_DWORD *)(a1 + 36 * v41 + 3172) = *((_DWORD *)&VSeqList + 13 * v20
                                                                      + *((int *)&VSeqList + 13 * v20 + 9)
                                                                      + 3);
        }
        else
        {
          v46 = a1 + 36 * v12;
          *(_DWORD *)(v46 + 3172) = 143;
          *(_DWORD *)(v46 + 3208) = 109;
        }
        v48 = v20;
        v35 = v60;
        v36 = v62;
LABEL_71:
        if (*v42 >= 1)
        {
          v51 = 0;
          v52 = (_DWORD *)(a1 + 36 * v34 + 3160);
          do
          {
            *v52 = v42[v51 + 6];
            v52 += 9;
            ++v51;
          }
          while (v51 < *v42);
        }
        v53 = UkEngine::getTonePosition(a1, v48, v36 == *(_DWORD *)(a1 + 28));
        if (TonePosition != v53 && v35 != 0)
        {
          v55 = v53 + v34;
          v56 = *(_DWORD *)(a1 + 16);
          if (v56 > v53 + v34)
          {
            v57 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v55, v56 - 1);
            *(_DWORD *)(a1 + 16) = v55;
            *(_DWORD *)(a1 + 20) = v57;
            v56 = v55;
          }
          *(_DWORD *)(a1 + 36 * v55 + 3168) = v35;
          if (v56 > v61)
          {
            v58 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v61, v56 - 1);
            *(_DWORD *)(a1 + 16) = v61;
            *(_DWORD *)(a1 + 20) = v58;
          }
          *v15 = 0;
        }
        v47 = 1;
        if (v20 == -1)
        {
          *(_DWORD *)(a1 + 32) = 0;
          UkEngine::processAppend((UkEngine *)a1, a2);
          *(_BYTE *)(a1 + 3137) = 1;
        }
        return v47;
      }
    }
  }
  return UkEngine::processAppend((UkEngine *)a1, a2);
}

uint64_t UkEngine::processAppend(UkEngine *this, _DWORD *a2)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  int v7;
  uint64_t result;
  uint64_t v9;
  _BOOL4 v10;
  BOOL v11;
  uint64_t v12;
  char *v13;
  int v14;
  int v15;
  int v16;

  switch(a2[1])
  {
    case 0:
      v4 = (int)a2[2];
      if (!*((_BYTE *)&IsVnVowel + v4))
        return UkEngine::appendConsonnant(this, (uint64_t)a2);
      if ((v5 = *((_DWORD *)this + 7), (v5 & 0x80000000) == 0)
        && *((_DWORD *)this + 9 * v5 + 786) == 2
        && ((v6 = *(_DWORD *)((char *)StdVnNoTone + ((4 * v4) | 4)), v7 = *((_DWORD *)this + 9 * v5 + 790), v7 == 20)
         && v6 == 143
         || v7 == 6 && v6 == 75))
      {
        return UkEngine::appendConsonnant(this, (uint64_t)a2);
      }
      else
      {
        return UkEngine::appendVowel((uint64_t)this, (uint64_t)a2);
      }
    case 1:
      *((_DWORD *)this + 8) = 0;
      return UkEngine::processWordEnd(this, (uint64_t)a2);
    case 2:
      v9 = *((_QWORD *)this + 1);
      if (*(_DWORD *)(v9 + 4))
      {
        if (*(_DWORD *)(v9 + 2104) == 10)
        {
          if (UkEngine::checkEscapeVIQR((uint64_t)this, (uint64_t)a2))
            return 1;
          v9 = *((_QWORD *)this + 1);
          v10 = a2[1] == 1;
          v11 = *(_DWORD *)(v9 + 4) == 0;
        }
        else
        {
          v11 = 0;
          v10 = 0;
        }
      }
      else
      {
        v10 = 0;
        v11 = 1;
      }
      result = 0;
      v12 = *((int *)this + 7) + 1;
      *((_DWORD *)this + 7) = v12;
      v13 = (char *)this + 36 * v12;
      *((_DWORD *)v13 + 786) = v10;
      *((_DWORD *)v13 + 789) = -1;
      *(_QWORD *)(v13 + 3148) = -1;
      v14 = a2[2];
      *((_DWORD *)v13 + 794) = a2[3];
      *((_DWORD *)v13 + 793) = v14 | 1;
      *((_DWORD *)v13 + 792) = 0;
      *((_DWORD *)v13 + 791) = (v14 | 1) != v14;
      if (v11)
        return result;
      if (*(_DWORD *)(v9 + 2104) != 6)
        return 0;
      v15 = *((_DWORD *)this + 4);
      if (v15 > (int)v12)
      {
        v16 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v12, v15 - 1);
        *((_DWORD *)this + 4) = v12;
        *((_DWORD *)this + 5) = v16;
      }
      return 1;
    case 3:
      result = 0;
      *((_DWORD *)this + 778) = -1;
      *(_QWORD *)((char *)this + 28) = 0xFFFFFFFFLL;
      *((_BYTE *)this + 3116) = 0;
      return result;
    default:
      return 0;
  }
}

uint64_t UkEngine::getTonePosition(uint64_t a1, unsigned int a2, int a3)
{
  int v3;
  uint64_t v4;

  v3 = *((_DWORD *)&VSeqList + 13 * (int)a2);
  if (v3 == 1)
    return 0;
  v4 = *((unsigned int *)&VSeqList + 13 * (int)a2 + 9);
  if ((_DWORD)v4 == -1)
  {
    if (*((_DWORD *)&VSeqList + 13 * (int)a2 + 11) == -1)
    {
      if (v3 == 3 || *(_DWORD *)(*(_QWORD *)(a1 + 8) + 16) && a2 <= 0x28 && ((1 << a2) & 0x1000A000000) != 0)
        return 1;
      else
        return a3 ^ 1u;
    }
    else
    {
      if (a2 - 44 > 0x17)
        return *((unsigned int *)&VSeqList + 13 * (int)a2 + 11);
      v4 = 1;
      if (((1 << (a2 - 44)) & 0xC00001) == 0)
        return *((unsigned int *)&VSeqList + 13 * (int)a2 + 11);
    }
  }
  return v4;
}

uint64_t UkEngine::getSeqSteps(UkEngine *this, int a2, int a3)
{
  int v3;
  int v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  int v20;
  _QWORD v21[3];
  uint64_t v22;
  int v23;

  v3 = a3 - a2;
  if (a3 < a2)
    return 0;
  v7 = *(_DWORD *)(*((_QWORD *)this + 1) + 2104);
  if (v7 == 12 || v7 == 0)
    return (v3 + 1);
  v21[0] = &off_1EA0FFB08;
  v21[1] = 0;
  v21[2] = 0;
  v22 = 0;
  v23 = 0;
  v20 = 0;
  CVnCharsetLib::getVnCharset((CVnCharsetLib *)VnCharsetLibObj, v7);
  v10 = v9;
  (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  v11 = v3 + 1;
  v12 = (unsigned int *)((char *)this + 36 * a2 + 3176);
  do
  {
    v13 = *(v12 - 1);
    if (v13 == -1)
    {
      v17 = *v12;
    }
    else
    {
      v14 = *(v12 - 2);
      if (*(v12 - 3))
        v15 = 0xFFFF;
      else
        v15 = 0x10000;
      v16 = v15 + v13;
      if (v14)
        v17 = v16 + 2 * v14;
      else
        v17 = v16;
    }
    if ((_DWORD)v17 != -1)
      (*(void (**)(uint64_t, _QWORD *, uint64_t, int *))(*(_QWORD *)v10 + 24))(v10, v21, v17, &v20);
    v12 += 9;
    --v11;
  }
  while (v11);
  if ((int)v22 >= 0)
    v18 = v22;
  else
    v18 = v22 + 1;
  v19 = v18 >> 1;
  if (*(_DWORD *)(*((_QWORD *)this + 1) + 2104) == 4)
    return v19;
  else
    return v22;
}

uint64_t isValidCVC(int a1, int a2, int a3)
{
  _BOOL8 valid;
  _BOOL4 v7;

  if (a2 == -1)
    return a1 == -1 || a3 != -1;
  if (a1 != -1)
  {
    valid = isValidCV(a1, a2);
    if (a3 != -1)
    {
      v7 = isValidVC(a2, a3);
      if (valid && v7)
        return 1;
      if (v7)
        return 0;
      if (a1 == 21 && a2 == 11)
      {
        valid = 1;
        if (a3 == 14 || a3 == 17)
          return valid;
      }
      return a1 == 8 && (a2 - 3) <= 1 && (a3 & 0xFFFFFFFE) == 0xE;
    }
    return valid;
  }
  return isValidVC(a2, a3);
}

BOOL isValidVC(int a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD __key[2];
  uint64_t v6;
  uint64_t v7;

  if (a2 == -1)
    return 1;
  v6 = v2;
  v7 = v3;
  if (!*((_DWORD *)&VSeqList + 13 * a1 + 2) || !*((_BYTE *)&CSeqList + 20 * a2 + 16))
    return 0;
  __key[0] = a1;
  __key[1] = a2;
  return bsearch(__key, &VCPairList, 0x99uLL, 8uLL, (int (__cdecl *)(const void *, const void *))VCPairCompare) != 0;
}

BOOL isValidCV(int a1, int a2)
{
  _BOOL8 result;
  uint64_t v4;
  BOOL v5;

  result = 1;
  if (a1 != -1 && a2 != -1)
  {
    switch(a1)
    {
      case 8:
        v5 = *((_DWORD *)&VSeqList + 13 * a2 + 3) == 75;
        break;
      case 21:
        v5 = *((_DWORD *)&VSeqList + 13 * a2 + 3) == 143;
        break;
      case 10:
        v4 = 0;
        while (isValidCV(ConSeq,VowelSeq)::kVseq[v4] != a2)
        {
          if (++v4 == 12)
            return 0;
        }
        v5 = (_DWORD)v4 == 12;
        break;
      default:
        return result;
    }
    return !v5;
  }
  return result;
}

uint64_t VCPairCompare(_DWORD *a1, _DWORD *a2)
{
  int v3;
  int v4;
  BOOL v5;
  _BOOL4 v6;

  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  if (*a1 > *a2)
    return 1;
  v3 = a1[1];
  v4 = a2[1];
  v5 = v3 < v4;
  v6 = v3 > v4;
  if (v5)
    return 0xFFFFFFFFLL;
  else
    return v6;
}

uint64_t UkEngine::processWordEnd(UkEngine *this, uint64_t a2)
{
  _DWORD *v4;
  uint64_t result;
  uint64_t v6;
  char *v7;
  int v8;
  uint64_t v9;
  char *v10;
  int v11;
  int v12;
  int v13;
  int v14;

  v4 = (_DWORD *)*((_QWORD *)this + 1);
  if (v4[5])
  {
    if (UkEngine::macroMatch((uint64_t)this, a2))
      return 1;
    v4 = (_DWORD *)*((_QWORD *)this + 1);
  }
  if (!v4[10] || *((_DWORD *)this + 8) || (*((_DWORD *)this + 7) & 0x80000000) != 0 || *((_BYTE *)this + 3139))
  {
    result = 0;
    v6 = *((int *)this + 7) + 1;
    *((_DWORD *)this + 7) = v6;
    v7 = (char *)this + 36 * v6;
    *(_OWORD *)(v7 + 3144) = xmmword_1DA910F50;
    v8 = *(_DWORD *)(a2 + 8);
    *((_DWORD *)v7 + 794) = *(_DWORD *)(a2 + 12);
    *((_DWORD *)v7 + 793) = v8 | 1;
    *((_DWORD *)v7 + 791) = (v8 | 1) != v8;
  }
  else
  {
    v14 = 0;
    if (v4[11])
    {
      if (UkEngine::lastWordIsNonVn(this))
      {
        v14 = **((_DWORD **)this + 391);
        if (UkEngine::restoreKeyStrokes((uint64_t)this, (_DWORD *)this + 5, *((_QWORD *)this + 390), &v14, (_DWORD *)this + 785))
        {
          *((_BYTE *)this + 3138) = 1;
          *((_BYTE *)this + 3136) = 1;
        }
      }
    }
    v9 = *((int *)this + 7) + 1;
    *((_DWORD *)this + 7) = v9;
    v10 = (char *)this + 36 * v9;
    *(_OWORD *)(v10 + 3144) = xmmword_1DA910F50;
    v12 = *(_DWORD *)(a2 + 8);
    v11 = *(_DWORD *)(a2 + 12);
    *((_DWORD *)v10 + 794) = v11;
    *((_DWORD *)v10 + 793) = v12 | 1;
    *((_DWORD *)v10 + 791) = (v12 | 1) != v12;
    if (*((_BYTE *)this + 3138))
    {
      v13 = v14;
      if (v14 < **((_DWORD **)this + 391))
      {
        *(_BYTE *)(*((_QWORD *)this + 390) + v14) = v11;
        **((_DWORD **)this + 391) = v13 + 1;
        return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t UkEngine::checkEscapeVIQR(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  int v5;
  uint64_t result;
  int v7;
  unsigned __int8 v8;
  int v9;
  unsigned int v10;
  _BOOL4 v11;
  BOOL v12;
  int v13;
  int v15;
  int v16;
  uint64_t v17;
  _BOOL4 v18;

  v2 = *(_DWORD *)(a1 + 28);
  if ((v2 & 0x80000000) != 0)
    return 0;
  v5 = *(_DWORD *)(a1 + 36 * v2 + 3144);
  if ((v5 - 3) >= 2)
  {
    if (v5)
      return 0;
    v8 = __toupper(*(_DWORD *)(a1 + 36 * v2 + 3176));
    result = 0;
    v7 = *(_DWORD *)(a2 + 12);
    if (v7 <= 62)
    {
      switch(v7)
      {
        case '\'':
        case '.':
          goto LABEL_32;
        case '(':
          if (v8 != 65)
            return 0;
LABEL_11:
          v7 = 40;
          goto LABEL_44;
        case '+':
          v7 = 43;
          if (v8 == 79 || v8 == 85)
            goto LABEL_44;
          return 0;
        default:
          return result;
      }
    }
    if (v7 > 95)
    {
      if (v7 != 96 && v7 != 126)
        return result;
    }
    else if (v7 != 63)
    {
      if (v7 != 94)
        return result;
      if (v8 == 65 || v8 == 79)
        goto LABEL_44;
      if (v8 != 69)
        return 0;
      v7 = 94;
      goto LABEL_44;
    }
LABEL_32:
    if ((v8 & 0xFB) != 0x41)
    {
      v10 = v8;
      v11 = v8 == 89;
      v10 -= 73;
      v12 = v10 > 0xC;
      v13 = (1 << v10) & 0x1041;
      if (v12 || v13 == 0)
      {
LABEL_40:
        if (!v11)
          return 0;
      }
    }
    goto LABEL_44;
  }
  result = 0;
  v7 = *(_DWORD *)(a2 + 12);
  if (v7 > 62)
  {
    if (v7 > 95)
    {
      if (v7 != 96 && v7 != 126)
        return result;
    }
    else if (v7 != 63)
    {
      if (v7 != 94)
        return result;
      v9 = *(_DWORD *)(a1 + 36 * v2 + 3172);
      v7 = 94;
      if (v9 == 1 || v9 == 45 || v9 == 97)
        goto LABEL_44;
      return 0;
    }
LABEL_28:
    if (*(_DWORD *)(a1 + 36 * v2 + 3168))
      return 0;
LABEL_44:
    v16 = *(_DWORD *)(a1 + 28);
    v17 = a1 + 36 * (v16 + 1);
    v18 = *(_DWORD *)(a2 + 4) == 1;
    *(_DWORD *)(v17 + 3144) = v18;
    *(_DWORD *)(v17 + 3156) = -1;
    *(_QWORD *)(v17 + 3148) = -1;
    *(_QWORD *)(v17 + 3172) = 0x3FFFFFFFFFLL;
    *(_DWORD *)(a1 + 28) = v16 + 2;
    *(_DWORD *)(v17 + 3180) = v18;
    *(_DWORD *)(v17 + 3192) = -1;
    *(_QWORD *)(v17 + 3184) = -1;
    *(_DWORD *)(v17 + 3212) = v7;
    *(_DWORD *)(v17 + 3208) = -1;
    **(_BYTE **)(a1 + 3120) = 92;
    *(_BYTE *)(*(_QWORD *)(a1 + 3120) + 1) = *(_DWORD *)(a2 + 12);
    **(_DWORD **)(a1 + 3128) = 2;
    result = 1;
    *(_BYTE *)(a1 + 3136) = 1;
    return result;
  }
  switch(v7)
  {
    case '\'':
    case '.':
      goto LABEL_28;
    case '(':
      if (*(_DWORD *)(a1 + 36 * v2 + 3172) != 1)
        return 0;
      goto LABEL_11;
    case '+':
      v15 = *(_DWORD *)(a1 + 36 * v2 + 3172);
      v11 = v15 == 143;
      v7 = 43;
      if (v15 != 97)
        goto LABEL_40;
      goto LABEL_44;
    default:
      return result;
  }
  return result;
}

uint64_t UkEngine::appendConsonnant(UkEngine *this, uint64_t a2)
{
  int v3;
  int v4;
  int v5;
  _DWORD *v6;
  _OWORD *v7;
  int v8;
  int v9;
  uint64_t v10;
  int *v11;
  int v12;
  int v13;
  _DWORD *v14;
  int v15;
  _DWORD *v16;
  int v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  unsigned int v22;
  int v23;
  int v24;
  _DWORD *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  _DWORD *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  char *v37;
  char v38;
  int v39;
  char *v40;
  int v41;
  char *v42;
  char *v43;
  int v44;
  int v45;
  char *v46;
  int v47;
  int v48;
  int v49;
  char *v50;
  _DWORD *v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  _BYTE v58[12];

  v3 = *((_DWORD *)this + 7);
  v4 = v3 + 1;
  *((_DWORD *)this + 7) = v3 + 1;
  v5 = v3 + 1;
  v6 = (_DWORD *)((char *)this + 36 * v3 + 36);
  v7 = v6 + 786;
  v8 = *(_DWORD *)(a2 + 8);
  v9 = v8 | 1;
  v6[793] = v8 | 1;
  v6[791] = (v8 | 1) != v8;
  v6[794] = *(_DWORD *)(a2 + 12);
  v6[792] = 0;
  if (v3 == -1 || (v10 = *((_QWORD *)this + 1), !*(_DWORD *)(v10 + 4)))
  {
    *v7 = xmmword_1DA910F70;
    *(_DWORD *)v58 = v8 | 1;
    *(_QWORD *)&v58[4] = -1;
    v16 = bsearch(v58, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
    if (v16)
      v17 = v16[3];
    else
      v17 = -1;
    *((_DWORD *)this + 9 * v5 + 790) = v17;
    v18 = *((_QWORD *)this + 1);
    if (!*(_DWORD *)(v18 + 4))
      return 0;
  }
  else
  {
    v11 = (int *)((char *)this + 36 * v3 + 3144);
    switch(*v11)
    {
      case 0:
        *v7 = xmmword_1DA910F60;
        goto LABEL_22;
      case 1:
        *v7 = xmmword_1DA910F70;
        *(_DWORD *)v58 = v8 | 1;
        *(_QWORD *)&v58[4] = -1;
        v25 = bsearch(v58, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
        if (v25)
          v26 = v25[3];
        else
          v26 = -1;
        *((_DWORD *)this + 9 * v5 + 790) = v26;
        goto LABEL_63;
      case 2:
      case 5:
      case 6:
        v12 = *((_DWORD *)this + 9 * v3 + 790);
        v13 = *((_DWORD *)&CSeqList + 5 * v12);
        if (v13 == 3)
          goto LABEL_52;
        if (v13 == 2)
        {
          *(_QWORD *)v58 = *(_QWORD *)((char *)&CSeqList + 20 * v12 + 4);
          *(_DWORD *)&v58[8] = v9;
          v14 = bsearch(v58, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
          if (!v14)
          {
            v15 = -1;
            goto LABEL_28;
          }
        }
        else
        {
          *(_DWORD *)v58 = *((_DWORD *)&CSeqList + 5 * v12 + 1);
          *(_DWORD *)&v58[4] = v9;
          v15 = -1;
          *(_DWORD *)&v58[8] = -1;
          v14 = bsearch(v58, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
          if (!v14)
            goto LABEL_28;
        }
        v15 = v14[3];
LABEL_28:
        if (v15 == -1)
          goto LABEL_52;
        v27 = *v11;
        if ((*v11 - 5) > 1)
          goto LABEL_49;
        v28 = *((_DWORD *)this + 9 * v3 + 787);
        v29 = *((_DWORD *)this + 7);
        if (v28 == -1)
          v30 = -1;
        else
          v30 = *((_DWORD *)this + 9 * v29 + 9 * ~v28 + 790);
        if (isValidCVC(v30, *((_DWORD *)this + 9 * v29 + 9 * ~*((_DWORD *)this + 9 * v3 + 788) + 790), v15))
        {
          v27 = *v11;
LABEL_49:
          if (v27 == 5)
          {
            *(_QWORD *)v7 = -4294967291;
            *((_DWORD *)this + 9 * v5 + 789) = 0;
            v39 = *((_DWORD *)this + 9 * v3 + 788) + 1;
          }
          else if (v27 == 2)
          {
            *(_QWORD *)v7 = 2;
            v39 = -1;
            *((_DWORD *)this + 9 * v5 + 789) = -1;
          }
          else
          {
            *(_DWORD *)v7 = 6;
            v40 = (char *)this + 36 * v3 + 3144;
            v41 = *((_DWORD *)v40 + 1);
            LODWORD(v40) = *((_DWORD *)v40 + 2);
            v42 = (char *)this + 36 * v5 + 3144;
            *((_DWORD *)v42 + 1) = v41 + 1;
            *((_DWORD *)v42 + 3) = 0;
            v39 = (_DWORD)v40 + 1;
          }
          v43 = (char *)this + 36 * v5;
          *((_DWORD *)v43 + 788) = v39;
          *((_DWORD *)v43 + 790) = v15;
        }
        else
        {
LABEL_52:
          *v7 = xmmword_1DA910F60;
        }
        goto LABEL_63;
      case 3:
      case 4:
        v19 = (char *)this + 36 * v3;
        v20 = *((int *)v19 + 790);
        if (v20 == 43 || v20 == 38)
          v22 = 44;
        else
          v22 = *((_DWORD *)v19 + 790);
        v23 = *((_DWORD *)v19 + 787);
        if (v23 == -1)
          v24 = -1;
        else
          v24 = *((_DWORD *)this + 9 * (v3 - v23) + 790);
        *(_DWORD *)v58 = v8 | 1;
        *(_QWORD *)&v58[4] = -1;
        v31 = bsearch(v58, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
        if (v31)
          v32 = v31[3];
        else
          v32 = -1;
        if (!isValidCVC(v24, v22, v32))
          goto LABEL_52;
        if ((_DWORD)v20 == 43)
        {
          v33 = *((_DWORD *)this + 7);
          v34 = *((_DWORD *)this + 4);
          if (v34 >= v33)
          {
            v35 = v33 - 1;
            v36 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v33 - 1, v34 - 1);
            *((_DWORD *)this + 4) = v35;
            *((_DWORD *)this + 5) = v36;
          }
          *((_DWORD *)this + 9 * v3 + 793) = 121;
          goto LABEL_43;
        }
        if ((_DWORD)v20 == 38)
        {
          UkEngine::markChange(this, *((_DWORD *)this + 7) - 2);
          v37 = (char *)this + 36 * *((int *)this + 7);
          *((_DWORD *)v37 + 775) = 155;
          *((_DWORD *)v37 + 772) = 10;
LABEL_43:
          *((_DWORD *)v19 + 790) = 44;
          v38 = 1;
          goto LABEL_57;
        }
        v38 = 0;
LABEL_57:
        if (*v11 == 3)
        {
          v44 = -1;
          v45 = 5;
        }
        else
        {
          v44 = *((_DWORD *)v19 + 787) + 1;
          v45 = 6;
        }
        *(_DWORD *)v7 = v45;
        v46 = (char *)this + 36 * v5 + 3144;
        *((_DWORD *)v46 + 1) = v44;
        *((_QWORD *)v46 + 1) = 1;
        *((_DWORD *)v46 + 4) = v32;
        v47 = *((_DWORD *)this + 7);
        v48 = v47 - *((_DWORD *)&VSeqList + 13 * (int)v20);
        v49 = v48 + UkEngine::getTonePosition((uint64_t)this, v20, 1);
        v50 = (char *)this + 36 * v49 + 3144;
        v52 = *((_DWORD *)v50 + 6);
        v51 = v50 + 24;
        if (v52)
        {
          v53 = v47 - *((_DWORD *)&VSeqList + 13 * (int)v22);
          v54 = v53 + UkEngine::getTonePosition((uint64_t)this, v22, 0);
          if (v54 != v49)
          {
            UkEngine::markChange(this, v54);
            *((_DWORD *)this + 9 * v54 + 792) = *v51;
            UkEngine::markChange(this, v49);
            *v51 = 0;
            return 1;
          }
        }
        if ((v38 & 1) != 0)
          return 1;
LABEL_63:
        v18 = *((_QWORD *)this + 1);
        break;
      default:
LABEL_22:
        if (*(_DWORD *)(v10 + 2104) == 6)
          goto LABEL_66;
        return 0;
    }
  }
  if (*(_DWORD *)(v18 + 2104) != 6)
    return 0;
  v4 = *((_DWORD *)this + 7);
LABEL_66:
  v55 = *((_DWORD *)this + 4);
  if (v55 > v4)
  {
    v56 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v4, v55 - 1);
    *((_DWORD *)this + 4) = v4;
    *((_DWORD *)this + 5) = v56;
  }
  return 1;
}

uint64_t UkEngine::appendVowel(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  int v6;
  int v7;
  int v8;
  _OWORD *v9;
  int v10;
  int v11;
  int v12;
  unsigned int *v13;
  uint64_t v14;
  _DWORD *v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  int *v21;
  int v22;
  int v23;
  BOOL v24;
  int v25;
  char *v26;
  _DWORD *v27;
  int v28;
  _DWORD *v29;
  _DWORD *v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  _DWORD *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int *v54;
  _DWORD *v55;
  unsigned int v56;
  int v57;
  int *v58;
  int v59;
  int v60;
  unsigned int *v61;
  int __key;
  uint64_t v63;

  v3 = *(int *)(a1 + 28);
  v4 = v3 + 1;
  *(_DWORD *)(a1 + 28) = v3 + 1;
  v5 = (_DWORD *)(a1 + 36 * (v3 + 1));
  v6 = *(_DWORD *)(a2 + 8);
  v7 = v6 | 1;
  v8 = StdVnNoTone[v6 | 1];
  v9 = v5 + 786;
  v5[793] = v8;
  v5[791] = (v6 | 1) != v6;
  v10 = (v6 | 1) - v8;
  if ((v6 | 1) >= v8)
    v11 = (v6 | 1) - v8;
  else
    v11 = v10 + 1;
  v12 = v11 >> 1;
  v5[792] = v11 >> 1;
  v13 = v5 + 794;
  v5[794] = *(_DWORD *)(a2 + 12);
  if ((_DWORD)v3 != -1 && *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4))
  {
    v14 = a1 + 36 * (int)v3;
    switch(*(_DWORD *)(v14 + 3144))
    {
      case 0:
      case 5:
      case 6:
        goto LABEL_7;
      case 1:
        *v9 = xmmword_1DA910F90;
        __key = v8;
        v63 = -1;
        v27 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
        if (v27)
          v28 = v27[3];
        else
          v28 = -1;
        *(_DWORD *)(a1 + 36 * v4 + 3160) = v28;
        goto LABEL_37;
      case 2:
        v29 = v5 + 792;
        __key = v8;
        v63 = -1;
        v30 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
        if (v30)
          v31 = v30[3];
        else
          v31 = -1;
        v32 = *(_DWORD *)(a1 + 36 * (int)v3 + 3160);
        if (!isValidCV(v32, v31))
        {
LABEL_7:
          *v9 = xmmword_1DA910F60;
          goto LABEL_37;
        }
        *v9 = xmmword_1DA910F80;
        *(_DWORD *)(a1 + 36 * v4 + 3160) = v31;
        if (v32 != 8)
          goto LABEL_37;
        v33 = a1 + 36 * (int)v3;
        v34 = *(_DWORD *)(v33 + 3168);
        if (!v34)
          goto LABEL_37;
        v35 = (_DWORD *)(v33 + 3168);
        if (!*v29)
          *v29 = v34;
        UkEngine::markChange((_DWORD *)a1, *(_DWORD *)(a1 + 28) - 1);
        *v35 = 0;
        return 1;
      case 3:
      case 4:
        v61 = v5 + 794;
        v18 = *(_DWORD *)(a1 + 3144 + 36 * (int)v3 + 16);
        v54 = (int *)((char *)&VSeqList + 52 * (int)v18);
        v55 = v5 + 792;
        v57 = *v54;
        v59 = v4 - *v54;
        v56 = v18;
        v19 = v59 + UkEngine::getTonePosition(a1, v18, 1);
        v20 = a1 + 3144 + 36 * v19;
        v23 = *(_DWORD *)(v20 + 24);
        v21 = (int *)(v20 + 24);
        v22 = v23;
        if (v7 != v8 && v22)
          goto LABEL_36;
        if (v57 == 3)
          goto LABEL_36;
        v24 = v57 == 2;
        v58 = v21;
        v25 = v22;
        v60 = v19;
        v26 = (char *)&VSeqList + 52 * (int)v56;
        if (v24)
        {
          v36 = *((_DWORD *)v26 + 4);
          v37 = v8;
        }
        else
        {
          v36 = v8;
          v37 = -1;
        }
        v38 = lookupVSeq(*((_DWORD *)v26 + 3), v36, v37);
        v39 = v25;
        v40 = v38;
        if (v38 == -1)
          goto LABEL_36;
        v41 = *(_DWORD *)(v14 + 3144);
        if (v41 == 4)
        {
          v42 = *(_DWORD *)(a1 + 3144 + 36 * (int)v3 + 4);
          if (!isValidCV(*(_DWORD *)(a1 + 3144 + 36 * (*(_DWORD *)(a1 + 28) + ~v42) + 16), v38))
          {
LABEL_36:
            *v9 = xmmword_1DA910F60;
            v13 = v61;
            goto LABEL_37;
          }
          v39 = v25;
          *(_DWORD *)v9 = 4;
          v43 = v42 + 1;
        }
        else
        {
          *(_DWORD *)v9 = v41;
          v43 = -1;
        }
        v50 = a1 + 36 * v4;
        *(_DWORD *)(v50 + 3148) = v43;
        *(_QWORD *)(v50 + 3152) = 0xFFFFFFFF00000000;
        *(_DWORD *)(v50 + 3160) = v40;
        *v55 = 0;
        v13 = v61;
        if (v39)
        {
          v51 = *(_DWORD *)(a1 + 28) - *v54 + UkEngine::getTonePosition(a1, v40, 1);
          if (v51 != v60)
          {
            UkEngine::markChange((_DWORD *)a1, v60);
            *v58 = 0;
            UkEngine::markChange((_DWORD *)a1, v51);
            if ((v10 + 1) >= 3)
              v53 = v12;
            else
              v53 = v25;
            *(_DWORD *)(a1 + 36 * v51 + 3168) = v53;
            return 1;
          }
          if ((v10 + 1) >= 3 && v12 != v25)
          {
            UkEngine::markChange((_DWORD *)a1, v60);
            *v58 = v12;
            return 1;
          }
        }
        else if ((v10 + 1) >= 3)
        {
          v45 = 1;
          v52 = *(_DWORD *)(a1 + 28) - *v54 + UkEngine::getTonePosition(a1, v40, 1);
          UkEngine::markChange((_DWORD *)a1, v52);
          *(_DWORD *)(a1 + 36 * v52 + 3168) = v12;
          return v45;
        }
LABEL_37:
        v17 = *(_QWORD *)(a1 + 8);
        goto LABEL_38;
      default:
        goto LABEL_37;
    }
  }
  *v9 = xmmword_1DA910F90;
  __key = v8;
  v63 = -1;
  v15 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
  if (v15)
    v16 = v15[3];
  else
    v16 = -1;
  *(_DWORD *)(a1 + 36 * v4 + 3160) = v16;
  v17 = *(_QWORD *)(a1 + 8);
  if (*(_DWORD *)(v17 + 4))
  {
LABEL_38:
    if (*(_DWORD *)(v17 + 2104) != 6)
    {
      v44 = *v13;
      if (v44 <= 0x7F)
      {
        if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v44 + 60) & 0x100) != 0)
          return 0;
      }
      else if (__maskrune(v44, 0x100uLL))
      {
        return 0;
      }
    }
    v46 = *(_DWORD *)(a1 + 28);
    v47 = *(_DWORD *)(a1 + 16);
    if (v47 > v46)
    {
      v48 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, *(_DWORD *)(a1 + 28), v47 - 1);
      *(_DWORD *)(a1 + 16) = v46;
      *(_DWORD *)(a1 + 20) = v48;
    }
    return 1;
  }
  return 0;
}

_DWORD *UkEngine::markChange(_DWORD *this, int a2)
{
  int v2;
  _DWORD *v4;
  int v5;

  v2 = this[4];
  if (v2 > a2)
  {
    v4 = this;
    this = (_DWORD *)UkEngine::getSeqSteps((UkEngine *)this, a2, v2 - 1);
    v5 = v4[5] + (_DWORD)this;
    v4[4] = a2;
    v4[5] = v5;
  }
  return this;
}

uint64_t UkEngine::macroMatch(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  BOOL v10;
  int v11;
  _DWORD *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int *v17;
  int *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  _DWORD *v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  int v34;
  int *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  _DWORD __key[17];
  _QWORD v44[9];

  v44[8] = *MEMORY[0x1E0C80C00];
  v41 = 0;
  v42 = 0;
  if (!*(_QWORD *)a1
    || ((*(void (**)(int *, int *))a1)(&v41, &v42), !v41)
    || (result = 0, v5 = *(_DWORD *)(a2 + 12), v5 != 13) && v5 != 32)
  {
    v6 = *(_DWORD *)(a1 + 28);
    if ((v6 & 0x80000000) == 0)
    {
      while (1)
      {
        v7 = *(_DWORD *)(a1 + 28);
        v8 = v7 - v6;
        if (v7 - v6 > 14)
          return 0;
        while (1)
        {
          v9 = *(_DWORD *)(a1 + 36 * v6 + 3144);
          if (v9 == 1)
            break;
          if (v8 > 14)
            return 0;
          ++v8;
          v10 = v6-- <= 0;
          if (v10)
          {
            v6 = -1;
            goto LABEL_19;
          }
        }
        v11 = *(_DWORD *)(a1 + 36 * v6 + 3172);
        v12 = (_DWORD *)(a1 + 36 * v6);
        if (v11 == -1)
        {
          v14 = v12[794];
        }
        else
        {
          v13 = v12[791] ? 0xFFFF : 0x10000;
          v14 = v11 + v13 + 2 * v12[792];
        }
        __key[0] = v14;
LABEL_19:
        v15 = v7 - v6;
        if (v7 <= v6)
        {
          v16 = v7 + 1;
        }
        else
        {
          v16 = v7 + 1;
          v17 = (int *)(a1 + 3212 + 36 * v6);
          v18 = (int *)v44;
          do
          {
            v19 = *(v17 - 1);
            if (v19 == -1)
            {
              v21 = *v17;
            }
            else
            {
              if (*(v17 - 3))
                v20 = 0xFFFF;
              else
                v20 = 0x10000;
              v21 = v19 + v20 + 2 * *(v17 - 2);
            }
            *v18++ = v21;
            v17 += 9;
            --v15;
          }
          while (v15);
        }
        __key[v16 - v6] = 0;
        v22 = *(_QWORD *)(a1 + 8);
        v23 = v22 + 10300;
        MacCompareStartMem = v22 + 10300;
        v24 = (int *)bsearch(v44, (const void *)(v22 + 2108), *(int *)(v22 + 141372), 8uLL, (int (__cdecl *)(const void *, const void *))macKeyCompare);
        if (v24)
          break;
        if (v9 == 1)
        {
          v25 = *(_QWORD *)(a1 + 8);
          v26 = v25 + 10300;
          MacCompareStartMem = v25 + 10300;
          v27 = (int *)bsearch(__key, (const void *)(v25 + 2108), *(int *)(v25 + 141372), 8uLL, (int (__cdecl *)(const void *, const void *))macKeyCompare);
          if (v27)
          {
            v28 = (_DWORD *)(v26 + v27[1]);
            goto LABEL_39;
          }
        }
        v10 = v6-- <= 0;
        if (v10)
          return 0;
      }
      v28 = (_DWORD *)(v23 + v24[1]);
      ++v6;
LABEL_39:
      v29 = *(_DWORD *)(a1 + 16);
      if (v29 > v6)
      {
        v30 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v6, v29 - 1);
        *(_DWORD *)(a1 + 16) = v6;
        *(_DWORD *)(a1 + 20) = v30;
      }
      v31 = 0;
      do
        v32 = v31;
      while (v28[v31++]);
      v39 = **(_DWORD **)(a1 + 3128);
      v40 = 4 * v32;
      VnConvert(7, *(_DWORD *)(*(_QWORD *)(a1 + 8) + 2104), v28, *(_QWORD *)(a1 + 3120), &v40, &v39);
      v34 = v39;
      v35 = *(int **)(a1 + 3128);
      if (*v35 > v39)
      {
        v39 = *v35 - v39;
        v36 = *(_DWORD *)(a2 + 8);
        if (v36 == -1)
          v37 = *(_DWORD *)(a2 + 12);
        else
          v37 = v36 + 0x10000;
        v38 = v37;
        v40 = 4;
        VnConvert(7, *(_DWORD *)(*(_QWORD *)(a1 + 8) + 2104), &v38, *(_QWORD *)(a1 + 3120) + v34, &v40, &v39);
        v34 += v39;
        v35 = *(int **)(a1 + 3128);
      }
      *(_DWORD *)(a1 + 3112) = -1;
      *(_QWORD *)(a1 + 28) = 0xFFFFFFFFLL;
      *(_BYTE *)(a1 + 3116) = 0;
      result = 1;
      *(_BYTE *)(a1 + 3136) = 1;
      *v35 = v34;
      return result;
    }
    return 0;
  }
  return result;
}

BOOL UkEngine::lastWordIsNonVn(UkEngine *this)
{
  unsigned int v1;
  int v3;
  _BOOL8 result;
  unsigned int v5;
  unsigned int v6;
  _DWORD *v7;
  char *v8;
  unsigned int v9;
  int v10;
  int v11;
  int valid;
  BOOL v13;

  v1 = *((_DWORD *)this + 7);
  if ((v1 & 0x80000000) != 0)
    return 0;
  v3 = *((_DWORD *)this + 9 * v1 + 786);
  result = 1;
  switch(v3)
  {
    case 0:
      return result;
    case 3:
    case 4:
      return *((_DWORD *)&VSeqList + 13 * *((int *)this + 9 * v1 + 790) + 1) == 0;
    case 5:
    case 6:
      v5 = v1 - *((_DWORD *)this + 9 * v1 + 788);
      v6 = *((_DWORD *)this + 9 * (int)v5 + 790);
      v7 = (_DWORD *)((char *)&VSeqList + 52 * (int)v6);
      if (!v7[1])
        return result;
      v8 = (char *)this + 36 * v1;
      v9 = *((_DWORD *)v8 + 790);
      v10 = *((_DWORD *)v8 + 787);
      v11 = v10 == -1 ? -1 : *((_DWORD *)this + 9 * (int)(v1 - v10) + 790);
      valid = isValidCVC(v11, *((_DWORD *)this + 9 * (int)v5 + 790), v9);
      result = 1;
      if (!valid)
        return result;
      v13 = v9 > 0x18 || ((1 << v9) & 0x1040006) == 0;
      if (v13
        || (*((_DWORD *)this
                          + 9 * (int)(v5 + UkEngine::getTonePosition((uint64_t)this, v6, 0) - *v7 + 1)
                          + 792)
                        - 2) >= 3)
      {
        return 0;
      }
      result = 1;
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t UkEngine::restoreKeyStrokes(uint64_t a1, _DWORD *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  int v9;
  int v10;
  char v11;
  BOOL v12;
  int v13;
  int v14;
  int v15;
  uint64_t result;
  int v17;
  uint64_t v18;
  uint64_t v19;

  *a5 = 1;
  if ((UkEngine::lastWordHasVnMark((UkEngine *)a1) & 1) == 0)
    goto LABEL_17;
  v9 = *(_DWORD *)(a1 + 28);
  *(_QWORD *)(a1 + 16) = (v9 + 1);
  v10 = *(_DWORD *)(a1 + 3112);
  if (v10 < 0)
    goto LABEL_17;
  v11 = 0;
  while (*(_DWORD *)(a1 + 24 * v10 + 44) != 1)
  {
    v11 |= *(_BYTE *)(a1 + 24 * v10 + 60) != 0;
    v12 = v10-- <= 0;
    if (v12)
    {
      v10 = -1;
      break;
    }
  }
  if ((v11 & 1) != 0)
  {
    if (v9 < 0)
      goto LABEL_18;
    v13 = v9;
    while (*(_DWORD *)(a1 + 36 * v13 + 3144) != 1)
    {
      *(_DWORD *)(a1 + 28) = v13 - 1;
      v12 = v13-- <= 0;
      if (v12)
      {
        v13 = -1;
        break;
      }
    }
    if (v9 <= v13)
    {
LABEL_18:
      v15 = 0;
    }
    else
    {
      v14 = v13 + 1;
      v15 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v13 + 1, v9);
      *(_DWORD *)(a1 + 16) = v14;
      *(_DWORD *)(a1 + 20) = v15;
    }
    *a2 = v15;
    *(_BYTE *)(a1 + 3139) = 1;
    if (v10 >= *(_DWORD *)(a1 + 3112))
    {
      v17 = 0;
    }
    else
    {
      v17 = 0;
      v18 = v10;
      v19 = a1 + 24 * v10 + 76;
      do
      {
        if (v17 < *a4)
          *(_BYTE *)(a3 + v17++) = *(_DWORD *)v19;
        ++v18;
        *(_BYTE *)(v19 + 8) = 0;
        UkEngine::processAppend((UkEngine *)a1);
        v19 += 24;
      }
      while (v18 < *(int *)(a1 + 3112));
    }
    *a4 = v17;
    *(_BYTE *)(a1 + 3139) = 0;
    return 1;
  }
  else
  {
LABEL_17:
    result = 0;
    *a2 = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t UkEngine::lastWordHasVnMark(UkEngine *this)
{
  unsigned int v1;
  int v2;
  uint64_t v3;

  v1 = *((_DWORD *)this + 7);
  if ((v1 & 0x80000000) == 0)
  {
    while (*((_DWORD *)this + 9 * v1 + 786) != 1)
    {
      v2 = v1;
      v3 = *((int *)this + 9 * v1 + 793);
      if ((_DWORD)v3 != -1
        && (*((_BYTE *)&IsVnVowel + v3) && *((_DWORD *)this + 9 * v2 + 792)
         || (_DWORD)v3 != StdVnRootChar[v3]))
      {
        return 1;
      }
      v1 = v2 - 1;
      if (v2 <= 0)
        return 0;
    }
  }
  return 0;
}

uint64_t UkEngine::processHookWithUO(UkEngine *this, _DWORD *a2)
{
  int v3;
  int v4;
  unsigned int v6;
  int *v7;
  int v8;
  _DWORD *v9;
  int v10;
  int v11;
  int TonePosition;
  char *v13;
  int v14;
  _DWORD *v15;
  int v16;
  int v17;
  _DWORD *v18;
  int v19;
  unsigned int v20;
  int v22;
  int v23;
  _DWORD *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  _DWORD *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  _DWORD *v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int *v48;
  uint64_t v49;
  _DWORD *v50;
  int v51;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  uint64_t __key;
  int v65;

  v3 = *((_DWORD *)this + 7);
  v4 = *((_DWORD *)this + 9 * v3 + 788);
  if (!*(_DWORD *)(*((_QWORD *)this + 1) + 12) && v4)
    return UkEngine::processAppend(this, a2);
  v6 = *((_DWORD *)this + 9 * (v3 - v4) + 790);
  v7 = (int *)((char *)&VSeqList + 52 * (int)v6);
  v10 = *v7;
  v9 = v7 + 3;
  v8 = v10;
  v63 = v3 - v4;
  v11 = v3 - v4 - v10 + 1;
  TonePosition = UkEngine::getTonePosition((uint64_t)this, v6, v4 == 0);
  v61 = v11 + TonePosition;
  v62 = TonePosition;
  v13 = (char *)this + 36 * v11 + 36 * TonePosition + 3144;
  v16 = *((_DWORD *)v13 + 6);
  v15 = v13 + 24;
  v14 = v16;
  if (*a2 == 7)
  {
    v22 = v9[1];
    if (v22 != 109 && v22 != 97)
    {
      v32 = v9[2];
      __key = 0x610000008FLL;
      v65 = v32;
      v33 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
      if (v33)
        v20 = v33[3];
      else
        v20 = -1;
      v19 = v14;
      v42 = v62;
      v41 = v63;
      if (*v9 != 155)
      {
        v26 = v11 + 1;
        v57 = *((_DWORD *)this + 4);
        if (v57 > v11 + 1)
        {
          v58 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11 + 1, v57 - 1);
          *((_DWORD *)this + 4) = v26;
          *((_DWORD *)this + 5) = v58;
        }
        goto LABEL_55;
      }
LABEL_52:
      v46 = *((_DWORD *)this + 4);
      if (v46 > v11)
      {
        v47 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11, v46 - 1);
        *((_DWORD *)this + 4) = v11;
        *((_DWORD *)this + 5) = v47;
      }
      *((_DWORD *)this + 9 * v11 + 793) = 143;
      v26 = v11 + 1;
LABEL_55:
      v27 = 1;
      v34 = 97;
      goto LABEL_56;
    }
    if (v4 || v8 != 2 || *((_DWORD *)this + 9 * v3 + 786) != 4 || *((_DWORD *)this + 9 * v3 + 772) != 25)
    {
      v23 = v9[2];
      __key = 0x790000009BLL;
      v65 = v23;
      v24 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
      if (v24)
        v20 = v24[3];
      else
        v20 = -1;
      v19 = v14;
      if (*v9 == 143)
      {
        v40 = *((_DWORD *)this + 4);
        v42 = v62;
        v41 = v63;
        if (v40 > v11)
        {
          v43 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11, v40 - 1);
          *((_DWORD *)this + 4) = v11;
          *((_DWORD *)this + 5) = v43;
        }
        v27 = 0;
        *((_DWORD *)this + 9 * v11 + 793) = 155;
        v26 = v11 + 1;
      }
      else
      {
        v26 = v11 + 1;
        v44 = *((_DWORD *)this + 4);
        v42 = v62;
        v41 = v63;
        v27 = 0;
        if (v44 > v11 + 1)
        {
          v45 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11 + 1, v44 - 1);
          *((_DWORD *)this + 4) = v26;
          *((_DWORD *)this + 5) = v45;
        }
      }
      v34 = 121;
      goto LABEL_56;
    }
    goto LABEL_28;
  }
  if (*a2 == 6)
  {
    if (*v9 != 143)
    {
      v17 = v9[2];
      __key = 0x610000008FLL;
      v65 = v17;
      v18 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
      v19 = v14;
      if (v18)
        v20 = v18[3];
      else
        v20 = -1;
      v42 = v62;
      v41 = v63;
      goto LABEL_52;
    }
    goto LABEL_25;
  }
  v25 = v9[1];
  if (*v9 != 143)
  {
    if (v25 != 97)
    {
      v38 = v9[2];
      __key = 0x610000008FLL;
      v65 = v38;
      v39 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
      if (v39)
        v20 = v39[3];
      else
        v20 = -1;
      v19 = v14;
      v42 = v62;
      v41 = v63;
      v59 = *((_DWORD *)this + 4);
      if (v59 > v11)
      {
        v60 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11, v59 - 1);
        *((_DWORD *)this + 4) = v11;
        *((_DWORD *)this + 5) = v60;
      }
      *((_DWORD *)this + 9 * v11 + 793) = 143;
      v26 = v11 + 1;
      v27 = 1;
      v34 = 97;
      goto LABEL_56;
    }
LABEL_28:
    v20 = *((_DWORD *)&VSeqList + 13 * (int)v6 + 12);
    v26 = v11 + 1;
    v30 = *((_DWORD *)this + 4);
    v27 = 0;
    if (v30 > v11 + 1)
    {
      v31 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11 + 1, v30 - 1);
      *((_DWORD *)this + 4) = v26;
      *((_DWORD *)this + 5) = v31;
    }
    goto LABEL_47;
  }
  if (v25 != 109 && v25 != 97)
  {
LABEL_25:
    v20 = *((_DWORD *)&VSeqList + 13 * (int)v6 + 12);
    v28 = *((_DWORD *)this + 4);
    v19 = v14;
    v27 = 0;
    if (v28 > v11)
    {
      v29 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11, v28 - 1);
      *((_DWORD *)this + 4) = v11;
      *((_DWORD *)this + 5) = v29;
    }
    v34 = 155;
    v26 = v11;
    goto LABEL_48;
  }
  if (!v4
    && (v6 & 0xFFFFFFFE) == 0x24
    && *((_DWORD *)this + 9 * v3 + 786) == 4
    && *((_DWORD *)this + 9 * v3 + 772) == 25)
  {
    v26 = v11 + 1;
    UkEngine::markChange(this, v11 + 1);
    v27 = 0;
    v20 = 38;
  }
  else
  {
    v35 = *((_DWORD *)&VSeqList + 13 * (int)v6 + 12);
    v36 = *((_DWORD *)this + 4);
    if (v36 > v11)
    {
      v37 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11, v36 - 1);
      *((_DWORD *)this + 4) = v11;
      *((_DWORD *)this + 5) = v37;
    }
    v27 = 0;
    *((_DWORD *)this + 9 * v11 + 793) = 155;
    v20 = *((_DWORD *)&VSeqList + 13 * v35 + 12);
    v26 = v11 + 1;
  }
LABEL_47:
  v34 = 121;
  v19 = v14;
LABEL_48:
  v42 = v62;
  v41 = v63;
LABEL_56:
  *((_DWORD *)this + 9 * v26 + 793) = v34;
  v48 = (int *)((char *)&VSeqList + 52 * (int)v20);
  if (*v48 >= 1)
  {
    v49 = 0;
    v50 = (_DWORD *)((char *)this + 36 * v11 + 3160);
    do
    {
      *v50 = *((_DWORD *)&VSeqList + 13 * (int)v20 + v49 + 6);
      v50 += 9;
      ++v49;
    }
    while (v49 < *v48);
  }
  v51 = UkEngine::getTonePosition((uint64_t)this, v20, v41 == *((_DWORD *)this + 7));
  if (v42 != v51 && v19 != 0)
  {
    v53 = v51 + v11;
    v54 = *((_DWORD *)this + 4);
    if (v54 > v53)
    {
      v55 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v53, v54 - 1);
      *((_DWORD *)this + 4) = v53;
      *((_DWORD *)this + 5) = v55;
      v54 = v53;
    }
    *((_DWORD *)this + 9 * v53 + 792) = v19;
    if (v54 > v61)
    {
      v56 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v61, v54 - 1);
      *((_DWORD *)this + 4) = v61;
      *((_DWORD *)this + 5) = v56;
    }
    *v15 = 0;
  }
  if (v27)
  {
    *((_DWORD *)this + 8) = 0;
    UkEngine::processAppend(this, a2);
    *((_BYTE *)this + 3137) = 1;
  }
  return 1;
}

uint64_t UkEngine::processHook(UkEngine *this, int *a2)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  int v7;
  unsigned int v8;
  int *v9;
  _DWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;
  BOOL v14;
  int v15;
  int v18;
  int TonePosition;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  char *v26;
  int v27;
  int v28;
  int v29;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  char *v36;
  int v37;
  int *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  int *v44;
  _DWORD *v45;
  int v46;
  int v47;
  int v48;
  char *v49;
  int *v50;
  uint64_t v51;
  _DWORD *v52;
  int v53;
  int v55;
  int v56;
  int v57;
  int v58;
  char *v59;
  int v60;
  int v61;

  v4 = *((_QWORD *)this + 1);
  if (!*(_DWORD *)(v4 + 4))
    return UkEngine::processAppend(this, a2);
  v5 = *((_DWORD *)this + 7);
  if ((v5 & 0x80000000) != 0)
    return UkEngine::processAppend(this, a2);
  v6 = *((_DWORD *)this + 9 * v5 + 788);
  if (v6 < 0)
    return UkEngine::processAppend(this, a2);
  v7 = v5 - v6;
  v8 = *((_DWORD *)this + 9 * (int)(v5 - v6) + 790);
  v9 = (int *)((char *)&VSeqList + 52 * (int)v8);
  v10 = v9 + 3;
  v11 = *a2;
  v12 = *v9 < 2 || v11 == 8;
  if (!v12 && (*v10 == 155 || *v10 == 143))
  {
    v13 = v9[4] - 97;
    v14 = v13 > 0x18;
    v15 = (1 << v13) & 0x1001001;
    if (!v14 && v15 != 0)
      return UkEngine::processHookWithUO(this, a2);
  }
  v18 = v7 - *v9 + 1;
  TonePosition = UkEngine::getTonePosition((uint64_t)this, v8, v6 == 0);
  v20 = TonePosition + v18;
  v21 = *((_DWORD *)this + 9 * TonePosition + 9 * v18 + 792);
  v22 = *((_DWORD *)&VSeqList + 13 * (int)v8 + 12);
  if (v22 != -1)
  {
    v23 = *((_DWORD *)&VSeqList + 13 * (int)v8 + 12);
    switch(v11)
    {
      case 5:
        if (*((_DWORD *)&VSeqList + 13 * v22 + *((int *)&VSeqList + 13 * v22 + 11) + 3) == 25)
          return UkEngine::processAppend(this, a2);
        break;
      case 6:
        if (*((_DWORD *)&VSeqList + 13 * v22 + *((int *)&VSeqList + 13 * v22 + 11) + 3) != 155)
          return UkEngine::processAppend(this, a2);
        break;
      case 7:
        if (*((_DWORD *)&VSeqList + 13 * v22 + *((int *)&VSeqList + 13 * v22 + 11) + 3) != 121)
          return UkEngine::processAppend(this, a2);
        break;
      case 8:
        if (*((_DWORD *)&VSeqList + 13 * v22 + *((int *)&VSeqList + 13 * v22 + 11) + 3) != 25)
          return UkEngine::processAppend(this, a2);
        break;
      default:
        break;
    }
    v31 = *((_DWORD *)this + 9 * v5 + 787);
    v61 = TonePosition;
    if (v31 == -1)
      v32 = -1;
    else
      v32 = *((_DWORD *)this + 9 * (int)(v5 - v31) + 790);
    v33 = *((_DWORD *)this + 9 * v5 + 789);
    v60 = v20;
    v59 = (char *)this + 36 * v20;
    v34 = v21;
    if (v33 == -1)
      v35 = -1;
    else
      v35 = *((_DWORD *)this + 9 * (int)(v5 - v33) + 790);
    if ((isValidCVC(v32, v22, v35) & 1) != 0)
    {
      v36 = (char *)&VSeqList + 52 * v22;
      v39 = *((_DWORD *)v36 + 11);
      v38 = (int *)(v36 + 44);
      v37 = v39;
      v40 = v39 + v18;
      if (*(_DWORD *)(*((_QWORD *)this + 1) + 12) || v40 == *((_DWORD *)this + 7))
      {
        v41 = *((_DWORD *)this + 4);
        if (v41 > v40)
        {
          v42 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v40, v41 - 1);
          *((_DWORD *)this + 4) = v40;
          *((_DWORD *)this + 5) = v42;
          v37 = *v38;
        }
        *((_DWORD *)this + 9 * v40 + 793) = *((_DWORD *)&VSeqList + 13 * v22 + v37 + 3);
        v43 = v22;
        goto LABEL_66;
      }
    }
    return UkEngine::processAppend(this, a2);
  }
  v24 = *((_DWORD *)&VSeqList + 13 * (int)v8 + 11);
  if (v24 == -1)
    return UkEngine::processAppend(this, a2);
  v25 = v24 + v18;
  v26 = (char *)this + 36 * v24 + 36 * v18;
  v27 = *((_DWORD *)v26 + 793);
  v28 = v27 == 155 ? 143 : 97;
  v29 = v27 == 25 ? 1 : v28;
  if (v25 != v5 && *(_DWORD *)(v4 + 12) == 0)
    return UkEngine::processAppend(this, a2);
  switch(v11)
  {
    case 8:
      if (v27 != 25)
        return UkEngine::processAppend(this, a2);
      break;
    case 7:
      if (v27 != 121)
        return UkEngine::processAppend(this, a2);
      break;
    case 6:
      if (v27 != 155)
        return UkEngine::processAppend(this, a2);
      break;
    default:
      if (v11 == 5 && v27 == 25)
        return UkEngine::processAppend(this, a2);
      break;
  }
  v60 = TonePosition + v18;
  v61 = TonePosition;
  v59 = (char *)this + 36 * v20;
  v34 = *((_DWORD *)this + 9 * TonePosition + 9 * v18 + 792);
  v44 = (int *)(v26 + 3172);
  UkEngine::markChange(this, v25);
  *v44 = v29;
  if (*v9 == 2)
  {
    v49 = (char *)this + 36 * v18;
    v46 = *((_DWORD *)v49 + 793);
    v47 = *((_DWORD *)v49 + 802);
LABEL_64:
    v48 = -1;
    goto LABEL_65;
  }
  if (*v9 != 3)
  {
    v46 = *((_DWORD *)this + 9 * v18 + 793);
    v47 = -1;
    goto LABEL_64;
  }
  v45 = (_DWORD *)((char *)this + 36 * v18);
  v46 = v45[793];
  v47 = v45[802];
  v48 = v45[811];
LABEL_65:
  v43 = lookupVSeq(v46, v47, v48);
  v23 = v43;
LABEL_66:
  v50 = (int *)((char *)&VSeqList + 52 * (int)v23);
  if (*v50 >= 1)
  {
    v51 = 0;
    v52 = (_DWORD *)((char *)this + 36 * v18 + 3160);
    do
    {
      *v52 = *((_DWORD *)&VSeqList + 13 * (int)v23 + v51 + 6);
      v52 += 9;
      ++v51;
    }
    while (v51 < *v50);
  }
  v53 = UkEngine::getTonePosition((uint64_t)this, v43, v7 == *((_DWORD *)this + 7));
  if (v61 != v53 && v34 != 0)
  {
    v55 = v53 + v18;
    v56 = *((_DWORD *)this + 4);
    if (v56 > v53 + v18)
    {
      v57 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v55, v56 - 1);
      *((_DWORD *)this + 4) = v55;
      *((_DWORD *)this + 5) = v57;
      v56 = v55;
    }
    *((_DWORD *)this + 9 * v55 + 792) = v34;
    if (v56 > v60)
    {
      v58 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v60, v56 - 1);
      *((_DWORD *)this + 4) = v60;
      *((_DWORD *)this + 5) = v58;
    }
    *((_DWORD *)v59 + 792) = 0;
  }
  if (v22 == -1)
  {
    *((_DWORD *)this + 8) = 0;
    UkEngine::processAppend(this, a2);
    *((_BYTE *)this + 3137) = 1;
  }
  return 1;
}

uint64_t UkEngine::processTone(UkEngine *this, _DWORD *a2)
{
  unsigned int v4;
  _DWORD *v5;
  int v6;
  int v7;
  int v8;
  char *v9;
  int v10;
  int v11;
  int *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  int v20;
  BOOL v21;
  int v22;
  char *v23;
  int v24;
  int v26;
  int v27;
  int v28;

  v4 = *((_DWORD *)this + 7);
  if ((v4 & 0x80000000) != 0)
    return UkEngine::processAppend(this, a2);
  v5 = (_DWORD *)*((_QWORD *)this + 1);
  if (!v5[1])
    return UkEngine::processAppend(this, a2);
  v6 = *((_DWORD *)this + 9 * v4 + 786);
  if (v6 == 2)
  {
    v7 = *((_DWORD *)this + 9 * v4 + 790);
    if ((v7 & 0xFFFFFFFE) == 8)
    {
      v8 = v4 - (v7 != 8);
      v9 = (char *)this + 36 * v8;
      v10 = *((_DWORD *)v9 + 792);
      v11 = a2[4];
      if (v10 | v11)
      {
        v12 = (int *)(v9 + 3168);
        v13 = *((_DWORD *)this + 4);
        if (v13 > v8)
        {
          v14 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v8, v13 - 1);
          *((_DWORD *)this + 4) = v8;
          *((_DWORD *)this + 5) = v14;
          v10 = *v12;
          v11 = a2[4];
        }
        if (v10 != v11)
        {
LABEL_28:
          *v12 = v11;
          return 1;
        }
        goto LABEL_25;
      }
      return UkEngine::processAppend(this, a2);
    }
  }
  v15 = *((_DWORD *)this + 9 * v4 + 788);
  if (v15 < 0)
    return UkEngine::processAppend(this, a2);
  v16 = v4 - v15;
  v17 = *((_DWORD *)this + 9 * (int)(v4 - v15) + 790);
  if (v5[10])
  {
    if (!v5[3] && !*((_DWORD *)&VSeqList + 13 * (int)v17 + 1))
      return UkEngine::processAppend(this, a2);
  }
  if ((v6 - 5) <= 1)
  {
    v18 = *((_DWORD *)this + 9 * v4 + 790);
    v19 = v18 > 0x18;
    v20 = (1 << v18) & 0x1040006;
    v21 = v19 || v20 == 0;
    if (!v21 && (a2[4] - 2) <= 2)
      return UkEngine::processAppend(this, a2);
  }
  v22 = v16 + UkEngine::getTonePosition((uint64_t)this, v17, v15 == 0) - *((_DWORD *)&VSeqList + 13 * (int)v17) + 1;
  v23 = (char *)this + 36 * v22;
  v24 = *((_DWORD *)v23 + 792);
  v11 = a2[4];
  if (!(v24 | v11))
    return UkEngine::processAppend(this, a2);
  v12 = (int *)(v23 + 3168);
  v26 = *((_DWORD *)this + 4);
  if (v24 != v11)
  {
    if (v26 > v22)
    {
      v28 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v22, v26 - 1);
      *((_DWORD *)this + 4) = v22;
      *((_DWORD *)this + 5) = v28;
      v11 = a2[4];
    }
    goto LABEL_28;
  }
  if (v26 > v22)
  {
    v27 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v22, v26 - 1);
    *((_DWORD *)this + 4) = v22;
    *((_DWORD *)this + 5) = v27;
  }
LABEL_25:
  *v12 = 0;
  *((_DWORD *)this + 8) = 0;
  UkEngine::processAppend(this, a2);
  *((_BYTE *)this + 3137) = 1;
  return 1;
}

uint64_t UkEngine::processDd(UkEngine *this, _DWORD *a2)
{
  uint64_t v4;
  unsigned int v5;
  char *v6;
  char *v7;
  uint64_t v8;
  int v9;
  int v10;
  int v12;
  _DWORD *v13;
  int v14;
  int v15;
  _OWORD *v17;
  _DWORD *v18;
  signed int v19;
  int v20;
  int v21;
  int v22;

  v4 = *((_QWORD *)this + 1);
  if (!*(_DWORD *)(v4 + 4))
    return UkEngine::processAppend(this, a2);
  v5 = *((_DWORD *)this + 7);
  if ((v5 & 0x80000000) != 0)
    return UkEngine::processAppend(this, a2);
  v6 = (char *)this + 36 * v5;
  if (!*((_DWORD *)v6 + 786))
  {
    v7 = (char *)this + 36 * v5;
    if (*((_DWORD *)v7 + 793) == 41)
    {
      v8 = *((int *)this + 9 * (int)(v5 - 1) + 793);
      if ((_DWORD)v8 == -1 || !*((_BYTE *)&IsVnVowel + v8))
      {
        v17 = v6 + 3144;
        v18 = v7 + 3172;
        *((_DWORD *)this + 8) = 1;
        v19 = *((_DWORD *)this + 4);
        if (v19 > (int)v5)
        {
          v20 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v5, v19 - 1);
          *((_DWORD *)this + 4) = v5;
          *((_DWORD *)this + 5) = v20;
        }
        *((_DWORD *)this + 9 * v5 + 790) = 4;
        *v18 = 43;
        *v17 = xmmword_1DA910F70;
        return 1;
      }
    }
  }
  v9 = *((_DWORD *)this + 9 * v5 + 787);
  if (v9 < 0)
    return UkEngine::processAppend(this, a2);
  v10 = *(_DWORD *)(v4 + 12);
  if (v9 && v10 == 0)
    return UkEngine::processAppend(this, a2);
  v12 = v5 - v9;
  v13 = (_DWORD *)((char *)this + 36 * v12 + 3160);
  if (*v13 == 4)
  {
    v21 = *((_DWORD *)this + 4);
    if (v21 > v12)
    {
      v22 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v12, v21 - 1);
      *((_DWORD *)this + 4) = v12;
      *((_DWORD *)this + 5) = v22;
    }
    *v13 = 3;
    *((_DWORD *)this + 9 * v12 + 793) = 41;
    *((_DWORD *)this + 8) = 0;
    UkEngine::processAppend(this, a2);
    *((_BYTE *)this + 3137) = 1;
    return 1;
  }
  if (*v13 != 3)
    return UkEngine::processAppend(this, a2);
  v14 = *((_DWORD *)this + 4);
  if (v14 > v12)
  {
    v15 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v12, v14 - 1);
    *((_DWORD *)this + 4) = v12;
    *((_DWORD *)this + 5) = v15;
  }
  *v13 = 4;
  *((_DWORD *)this + 9 * v12 + 793) = 43;
  return 1;
}

uint64_t UkEngine::processMapChar(UkEngine *this, _DWORD *a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t result;
  unsigned int v8;
  uint64_t v9;
  char *v10;
  char *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  int TonePosition;
  char *v23;
  _DWORD *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  BOOL v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;

  v37 = 0;
  if (*(_QWORD *)this)
  {
    (*(void (**)(uint64_t *, char *))this)(&v37, (char *)&v37 + 4);
    if (HIDWORD(v37))
    {
      v4 = a2[2];
      v5 = v4 - 1;
      if ((v4 & 1) == 0)
        v5 = v4 + 1;
      if (v4 == -1)
        v6 = -1;
      else
        v6 = v5;
      a2[2] = v6;
    }
  }
  result = UkEngine::processAppend(this, a2);
  if (*(_DWORD *)(*((_QWORD *)this + 1) + 4))
  {
    v8 = *((_DWORD *)this + 7);
    if ((v8 & 0x80000000) != 0)
      return 0;
    if (*((_DWORD *)this + 9 * v8 + 786) > 1u)
      return 1;
    v9 = (int)v8 - 1;
    *((_DWORD *)this + 7) = v9;
    v10 = (char *)this + 36 * v9;
    if (*((_DWORD *)v10 + 786) < 2u)
      goto LABEL_24;
    v11 = (char *)this + 36 * v9;
    v12 = *((_DWORD *)v11 + 793);
    if (*((_DWORD *)v11 + 791))
    {
      v13 = v12 - 1;
      if (v12 == a2[2])
      {
        a2[2] = v13;
        a2[3] = __toupper(a2[3]);
      }
    }
    else
    {
      v13 = *((_DWORD *)v11 + 793);
    }
    if (v13 == a2[2])
    {
      v14 = *((_DWORD *)v10 + 786);
      v15 = *((_DWORD *)this + 7);
      if (v14 == 2)
      {
        v16 = *((_DWORD *)this + 4);
        if (v16 > v15)
        {
          v17 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, *((_DWORD *)this + 7), v16 - 1);
          *((_DWORD *)this + 4) = v15;
          *((_DWORD *)this + 5) = v17;
          v15 = *((_DWORD *)this + 7);
        }
        *((_DWORD *)this + 7) = v15 - 1;
        goto LABEL_34;
      }
      v19 = *((_DWORD *)this + 9 * v9 + 788);
      v20 = *((_DWORD *)this + 9 * (v15 - v19) + 790);
      v21 = v15 - v19 - *((_DWORD *)&VSeqList + 13 * (int)v20) + 1;
      TonePosition = UkEngine::getTonePosition((uint64_t)this, v20, v19 == 0);
      v23 = (char *)this + 36 * v21 + 36 * TonePosition + 3144;
      v26 = *((_DWORD *)v23 + 6);
      v24 = v23 + 24;
      v25 = v26;
      v27 = *((_DWORD *)this + 4);
      if (v27 > v15)
      {
        v28 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v15, v27 - 1);
        *((_DWORD *)this + 4) = v15;
        *((_DWORD *)this + 5) = v28;
        v15 = *((_DWORD *)this + 7);
      }
      v29 = v15 - 1;
      *((_DWORD *)this + 7) = v15 - 1;
      if (v25)
        v30 = v15 < 1;
      else
        v30 = 1;
      if (v30 || (*((_DWORD *)this + 9 * v29 + 786) - 3) > 1)
        goto LABEL_34;
      v18 = 1;
      v31 = UkEngine::getTonePosition((uint64_t)this, *((_DWORD *)this + 9 * v29 + 790), 1);
      if (v31 != TonePosition)
      {
        v32 = v31 + v21;
        UkEngine::markChange(this, v31 + v21);
        *((_DWORD *)this + 9 * v32 + 792) = v25;
        UkEngine::markChange(this, v21 + TonePosition);
        *v24 = 0;
LABEL_34:
        v18 = 1;
      }
    }
    else
    {
LABEL_24:
      v18 = 0;
    }
    *a2 = 19;
    v33 = (int)a2[3];
    v34 = a2[3];
    if (v33 < 0x100)
    {
      v36 = UkcMap[v34];
      v35 = IsoVnLexiMap[v33];
    }
    else if ((int)v34 <= 255)
    {
      v35 = IsoVnLexiMap[v33];
      v36 = 2 * (v35 == -1);
    }
    else
    {
      v35 = -1;
      v36 = 2;
    }
    a2[1] = v36;
    a2[2] = v35;
    result = UkEngine::processAppend(this, a2);
    if (v18)
    {
      *((_DWORD *)this + 8) = 0;
      result = 1;
      *((_BYTE *)this + 3137) = 1;
    }
  }
  return result;
}

uint64_t UkEngine::processTelexW(UkEngine *this, int *a2)
{
  uint64_t v4;
  int v5;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;

  if (!*(_DWORD *)(*((_QWORD *)this + 1) + 4))
    return UkEngine::processAppend(this, a2);
  v15 = 0;
  if (*(_QWORD *)this)
    (*(void (**)(uint64_t *, char *))this)(&v15, (char *)&v15 + 4);
  if (UkEngine::processTelexW(UkKeyEvent &)::usedAsMapChar == 1)
  {
    *a2 = 17;
    v4 = a2[3];
    if (v4 <= 0x7F)
      v5 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v4 + 60) & 0x8000;
    else
      v5 = __maskrune(v4, 0x8000uLL);
    if (v5)
      v10 = 154;
    else
      v10 = 155;
    a2[2] = v10;
    if (HIDWORD(v15))
    {
      if ((v10 & 1) != 0)
        v11 = v10 - 1;
      else
        v11 = v10 + 1;
      a2[2] = v11;
    }
    a2[1] = 0;
    if (UkEngine::processMapChar(this, a2))
      return 1;
    v12 = *((_DWORD *)this + 7);
    if ((v12 & 0x80000000) == 0)
      *((_DWORD *)this + 7) = v12 - 1;
    UkEngine::processTelexW(UkKeyEvent &)::usedAsMapChar = 0;
    *a2 = 4;
    return UkEngine::processHook(this, a2);
  }
  else
  {
    *a2 = 4;
    UkEngine::processTelexW(UkKeyEvent &)::usedAsMapChar = 0;
    if (UkEngine::processHook(this, a2))
      return 1;
    v7 = *((_DWORD *)this + 7);
    if ((v7 & 0x80000000) == 0)
      *((_DWORD *)this + 7) = v7 - 1;
    *a2 = 17;
    v8 = a2[3];
    if (v8 <= 0x7F)
      v9 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x8000;
    else
      v9 = __maskrune(v8, 0x8000uLL);
    if (v9)
      v13 = 154;
    else
      v13 = 155;
    a2[2] = v13;
    if (HIDWORD(v15))
    {
      if ((v13 & 1) != 0)
        v14 = v13 - 1;
      else
        v14 = v13 + 1;
      a2[2] = v14;
    }
    a2[1] = 0;
    UkEngine::processTelexW(UkKeyEvent &)::usedAsMapChar = 1;
    return UkEngine::processMapChar(this, a2);
  }
}

double UkEngine::reset(UkEngine *this)
{
  double result;

  *((_DWORD *)this + 778) = -1;
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  *(_QWORD *)((char *)this + 28) = 0xFFFFFFFFLL;
  *((_BYTE *)this + 3116) = 0;
  return result;
}

uint64_t UkEngine::processEscChar(UkEngine *this, _DWORD *a2)
{
  unsigned int v2;

  if (*(_DWORD *)(*((_QWORD *)this + 1) + 4))
  {
    v2 = *((_DWORD *)this + 7);
    if ((v2 & 0x80000000) == 0 && *((_DWORD *)this + 9 * v2 + 786) >= 2u)
      *((_BYTE *)this + 3116) = 1;
  }
  return UkEngine::processAppend(this, a2);
}

uint64_t UkEngine::pass(UkEngine *this, unsigned int a2)
{
  _DWORD v4[5];

  UkInputProcessor::keyCodeToEvent(*((_QWORD *)this + 1) + 48, a2, v4);
  return UkEngine::processAppend(this, v4);
}

uint64_t UkEngine::processNoSpellCheck(UkEngine *a1, _DWORD *a2)
{
  int v4;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  _DWORD *v10;
  int v11;
  _DWORD *v12;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;

  v4 = *((_DWORD *)a1 + 7);
  v5 = (_DWORD *)((char *)a1 + 36 * v4);
  v6 = v5 + 786;
  v7 = (int)v5[793];
  if (*((_BYTE *)&IsVnVowel + v7))
  {
    *v6 = 3;
    *((_DWORD *)a1 + 9 * v4 + 788) = 0;
    v17 = v7;
    v18 = -1;
    v8 = bsearch(&v17, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
    if (v8)
      v9 = v8[3];
    else
      v9 = -1;
    v12 = (_DWORD *)((char *)a1 + 36 * v4);
    v12[790] = v9;
    v12[789] = -1;
    v12[787] = -1;
  }
  else
  {
    *(_OWORD *)v6 = xmmword_1DA910F70;
    v17 = v7;
    v18 = -1;
    v10 = bsearch(&v17, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
    if (v10)
      v11 = v10[3];
    else
      v11 = -1;
    *((_DWORD *)a1 + 9 * v4 + 790) = v11;
  }
  if (*a2 == 19 && (*((_DWORD *)a1 + 9 * v4 + 794) & 0xFFFFFFDF) - 65 < 0x1A)
    return 0;
  v14 = *((_DWORD *)a1 + 7);
  v15 = *((_DWORD *)a1 + 4);
  if (v15 > v14)
  {
    v16 = *((_DWORD *)a1 + 5) + UkEngine::getSeqSteps(a1, *((_DWORD *)a1 + 7), v15 - 1);
    *((_DWORD *)a1 + 4) = v14;
    *((_DWORD *)a1 + 5) = v16;
  }
  return 1;
}

uint64_t UkEngine::process(uint64_t a1, unsigned int a2, _DWORD *a3, unsigned __int8 *a4, int *a5, _DWORD *a6)
{
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  __int128 v24;
  int v25;

  UkEngine::prepareBuffer((_DWORD *)a1);
  v12 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 16) = v12 + 1;
  *(_DWORD *)(a1 + 20) = 0;
  *(_QWORD *)(a1 + 3120) = a4;
  *(_QWORD *)(a1 + 3128) = a5;
  *(_QWORD *)(a1 + 3136) = 0;
  UkInputProcessor::keyCodeToEvent(*(_QWORD *)(a1 + 8) + 48, a2, &v24);
  if (!*(_BYTE *)(a1 + 3116))
  {
    v17 = ((uint64_t (*)(uint64_t, __int128 *))UkEngine::process(unsigned int,int &,unsigned char *,int &,UkOutputType &)::UkKeyProcList[2 * (int)v24])(a1, &v24);
LABEL_8:
    v16 = v17;
    goto LABEL_9;
  }
  *(_BYTE *)(a1 + 3116) = 0;
  if (v12 < 0 || (v24 & 0xFFFFFFFE) == 0x12)
  {
    v17 = UkEngine::processAppend((UkEngine *)a1, &v24);
    goto LABEL_8;
  }
  *(_DWORD *)(a1 + 28) = v12 - 1;
  UkEngine::processAppend((UkEngine *)a1, &v24);
  v13 = *(_DWORD *)(a1 + 28);
  v14 = *(_DWORD *)(a1 + 16);
  if (v14 > (int)v13)
  {
    v15 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, *(_DWORD *)(a1 + 28), v14 - 1);
    *(_DWORD *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 20) = v15;
    v16 = 1;
LABEL_9:
    v13 = *(_DWORD *)(a1 + 28);
    goto LABEL_10;
  }
  v16 = 1;
LABEL_10:
  v18 = *(_QWORD *)(a1 + 8);
  if (!*(_DWORD *)(v18 + 4))
    goto LABEL_16;
  if ((v13 & 0x80000000) != 0)
    goto LABEL_27;
  if (!(*(_DWORD *)(a1 + 36 * v13 + 3144) | DWORD1(v24)) && (!*(_DWORD *)(v18 + 40) || *(_DWORD *)(a1 + 32)))
  {
    v16 = UkEngine::processNoSpellCheck((UkEngine *)a1, &v24);
    v13 = *(_DWORD *)(a1 + 28);
LABEL_16:
    if ((v13 & 0x80000000) != 0)
      goto LABEL_27;
  }
  if (HIDWORD(v24) < 0x100)
  {
    v19 = UkcMap[HIDWORD(v24)];
  }
  else if (SHIDWORD(v24) > 255 || IsoVnLexiMap[SHIDWORD(v24)] == -1)
  {
    v19 = 2;
  }
  else
  {
    v19 = 0;
  }
  DWORD1(v24) = v19;
  v20 = *(int *)(a1 + 3112) + 1;
  *(_DWORD *)(a1 + 3112) = v20;
  v21 = a1 + 24 * v20;
  *(_DWORD *)(v21 + 56) = v25;
  *(_OWORD *)(v21 + 40) = v24;
  if ((_DWORD)v16)
    v22 = *(_BYTE *)(a1 + 3138) == 0;
  else
    v22 = 0;
  *(_BYTE *)(a1 + 24 * *(int *)(a1 + 3112) + 60) = v22;
LABEL_27:
  if ((_DWORD)v16)
  {
    *a3 = *(_DWORD *)(a1 + 20);
    if (!*(_BYTE *)(a1 + 3136))
      UkEngine::writeOutput((UkEngine *)a1, a4, a5);
  }
  else
  {
    *a3 = 0;
    *a5 = 0;
  }
  *a6 = *(_DWORD *)(a1 + 3140);
  return v16;
}

_DWORD *UkEngine::prepareBuffer(_DWORD *this)
{
  _DWORD *v1;
  unint64_t v2;
  unint64_t v3;
  int *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unint64_t v9;
  unint64_t v10;

  v1 = this;
  v2 = this[7];
  if ((v2 & 0x80000000) == 0 && (int)v2 + 10 >= this[6])
  {
    v3 = v2 >> 1;
    v4 = &this[9 * (this[7] >> 1) + 786];
    do
    {
      v5 = v3;
      if (v3 >= v2)
        break;
      v6 = *v4;
      v4 += 9;
      ++v3;
    }
    while (v6 != 1);
    if ((_DWORD)v2 == v5)
    {
      v7 = -1;
    }
    else
    {
      v8 = v5 + 1;
      v7 = v2 - v8;
      this = memmove(this + 786, &this[9 * v8 + 786], 36 * ((int)v2 - v8 + 1));
    }
    v1[7] = v7;
  }
  v9 = v1[778];
  if ((int)v9 >= 1 && (int)v9 + 1 >= v1[9])
  {
    v10 = v9 >> 1;
    this = memmove(v1 + 10, &v1[6 * (v1[778] >> 1) + 10], 24 * ((int)v9 + 1 - (v1[778] >> 1)));
    v1[778] -= v10;
  }
  return this;
}

uint64_t UkEngine::writeOutput(UkEngine *this, unsigned __int8 *a2, int *a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t result;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  _QWORD v19[3];
  int v20;
  int v21;
  int v22;
  int v23;

  v23 = 0;
  v5 = *a3;
  v19[0] = &off_1EA0FFB08;
  v19[1] = a2;
  v19[2] = a2;
  v20 = 0;
  v21 = v5;
  v22 = 0;
  CVnCharsetLib::getVnCharset((CVnCharsetLib *)VnCharsetLibObj, *(_DWORD *)(*((_QWORD *)this + 1) + 2104));
  v7 = v6;
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v8 = *((int *)this + 4);
  v9 = *((_DWORD *)this + 7);
  if ((int)v8 > v9)
  {
    result = 0;
    *a3 = 0;
    return result;
  }
  v11 = v8 - 1;
  v12 = (int *)((char *)this + 36 * (int)v8 + 3176);
  v13 = 1;
  do
  {
    v14 = *(v12 - 1);
    if (v14 != -1)
    {
      v15 = *(v12 - 2);
      if (*(v12 - 3))
        v16 = 0xFFFF;
      else
        v16 = 0x10000;
      v17 = v16 + v14;
      if (v15)
        v18 = v17 + 2 * v15;
      else
        v18 = v17;
LABEL_13:
      if (v18 == -1)
        goto LABEL_15;
      goto LABEL_14;
    }
    if (*v12 <= 255)
    {
      v18 = IsoStdVnCharMap[*v12];
      goto LABEL_13;
    }
LABEL_14:
    v13 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v7 + 24))(v7, v19);
    v9 = *((_DWORD *)this + 7);
LABEL_15:
    ++v11;
    v12 += 9;
  }
  while (v11 < v9);
  *a3 = v20;
  if (v13)
    return 0;
  else
    return 5;
}

uint64_t UkEngine::synchKeyStrokeBuffer(uint64_t this)
{
  unsigned int v1;
  unsigned int v2;

  v1 = *(_DWORD *)(this + 3112);
  if ((v1 & 0x80000000) == 0)
    *(_DWORD *)(this + 3112) = --v1;
  v2 = *(_DWORD *)(this + 28);
  if ((v2 & 0x80000000) == 0 && *(_DWORD *)(this + 36 * v2 + 3144) == 1 && (v1 & 0x80000000) == 0)
  {
    do
    {
      if (*(_DWORD *)(this + 24 * v1 + 44) == 1)
        break;
      *(_DWORD *)(this + 3112) = v1 - 1;
    }
    while ((int)v1-- > 0);
  }
  return this;
}

BOOL UkEngine::processBackspace(UkEngine *this, _DWORD *a2, unsigned __int8 *a3, int *a4, _DWORD *a5)
{
  int v8;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  int v15;
  BOOL v16;
  _BOOL8 result;
  int v18;
  unsigned int v19;
  int v20;
  int TonePosition;
  int v22;
  int v23;
  char *v24;
  _DWORD *v25;
  int v26;
  int v27;
  BOOL v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;

  *a5 = 0;
  if (!*(_DWORD *)(*((_QWORD *)this + 1) + 4) || (v8 = *((_DWORD *)this + 7), v8 < 0))
  {
    result = 0;
    *a2 = 0;
    *a4 = 0;
  }
  else
  {
    *((_QWORD *)this + 2) = (v8 + 1);
    v10 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v8, v8);
    *((_DWORD *)this + 4) = v8;
    *((_DWORD *)this + 5) = v10;
    v11 = *((int *)this + 7);
    if (!(_DWORD)v11
      || *((_DWORD *)this + 9 * (int)v11 + 786) < 3u
      || ((v12 = v11 - 1, v13 = *((_DWORD *)this + 9 * v11 + 777), v14 = v13 > 6, v15 = (1 << v13) & 0x64, !v14)
        ? (v16 = v15 == 0)
        : (v16 = 1),
          !v16))
    {
      *((_DWORD *)this + 7) = v11 - 1;
LABEL_10:
      *a2 = v10;
      *a4 = 0;
      UkEngine::synchKeyStrokeBuffer((uint64_t)this);
      return *a2 > 1;
    }
    v18 = *((_DWORD *)this + 9 * (int)v11 + 788);
    v19 = *((_DWORD *)this + 9 * ((int)v11 - v18) + 790);
    v20 = v11 - v18 - *((_DWORD *)&VSeqList + 13 * (int)v19) + 1;
    v32 = *((_DWORD *)this + 9 * v12 + 790);
    TonePosition = UkEngine::getTonePosition((uint64_t)this, v19, v18 == 0);
    v30 = v20;
    v31 = v20 + TonePosition;
    v22 = TonePosition;
    v23 = UkEngine::getTonePosition((uint64_t)this, v32, 1);
    v24 = (char *)this + 36 * v31 + 3144;
    v27 = *((_DWORD *)v24 + 6);
    v25 = v24 + 24;
    v26 = v27;
    if (v27)
      v28 = v22 == v23;
    else
      v28 = 1;
    if (v28 || v31 == (_DWORD)v11 && *((_DWORD *)this + 9 * (int)v11 + 792))
    {
      *((_DWORD *)this + 7) = v12;
      goto LABEL_10;
    }
    v29 = v23 + v30;
    UkEngine::markChange(this, v23 + v30);
    *((_DWORD *)this + 9 * v29 + 792) = v26;
    UkEngine::markChange(this, v31);
    *v25 = 0;
    --*((_DWORD *)this + 7);
    UkEngine::synchKeyStrokeBuffer((uint64_t)this);
    *a2 = *((_DWORD *)this + 5);
    UkEngine::writeOutput(this, a3, a4);
    return 1;
  }
  return result;
}

uint64_t UkEngine::resetKeyBuf(uint64_t this)
{
  *(_DWORD *)(this + 3112) = -1;
  return this;
}

void UkEngine::UkEngine(UkEngine *this)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  __int128 v9;
  unsigned int v10;
  BOOL v11;
  int v12;

  _createGlobalVnCharsetIfNeeded();
  if (!UkEngine::m_classInit)
  {
    v2 = 0;
    v3 = &SortedVSeqList;
    v4 = &qword_1F027F694;
    do
    {
      *v3 = *v4;
      *((_DWORD *)v3 + 2) = *((_DWORD *)v4 + 2);
      *((_DWORD *)v3 + 3) = v2++;
      v3 += 2;
      v4 = (uint64_t *)((char *)v4 + 52);
    }
    while (v2 != 70);
    v5 = 0;
    v6 = &SortedCSeqList;
    v7 = &qword_1F02804C4;
    do
    {
      *v6 = *v7;
      *((_DWORD *)v6 + 2) = *((_DWORD *)v7 + 2);
      *((_DWORD *)v6 + 3) = v5++;
      v6 += 2;
      v7 = (uint64_t *)((char *)v7 + 20);
    }
    while (v5 != 29);
    qsort(&SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
    qsort(&SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
    qsort(&VCPairList, 0x99uLL, 8uLL, (int (__cdecl *)(const void *, const void *))VCPairCompare);
    v8 = 0;
    *(_QWORD *)&v9 = 0x101010101010101;
    *((_QWORD *)&v9 + 1) = 0x101010101010101;
    unk_1F0283416 = v9;
    xmmword_1F02833FC = v9;
    unk_1F028340C = v9;
    xmmword_1F02833DC = v9;
    unk_1F02833EC = v9;
    xmmword_1F02833BC = v9;
    unk_1F02833CC = v9;
    xmmword_1F028339C = v9;
    unk_1F02833AC = v9;
    xmmword_1F028337C = v9;
    unk_1F028338C = v9;
    IsVnVowel = v9;
    do
    {
      v10 = ((v8 >> 1) | ((_BYTE)v8 << 7));
      v11 = v10 > 0xC;
      v12 = (1 << v10) & 0x1495;
      if (v11 || v12 == 0)
      {
        *((_BYTE *)&IsVnVowel + *((int *)&AZLexiLower + v8)) = 0;
        *((_BYTE *)&IsVnVowel + *((int *)&AZLexiUpper + v8)) = 0;
      }
      ++v8;
    }
    while (v8 != 26);
    word_1F0283396 = 0;
    UkEngine::m_classInit = 1;
  }
  *((_DWORD *)this + 778) = -1;
  *(_OWORD *)((char *)this + 24) = xmmword_1DA910FA0;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *(_WORD *)((char *)this + 3137) = 0;
  *((_BYTE *)this + 3116) = 0;
}

uint64_t UkEngine::setSingleMode(uint64_t this)
{
  *(_DWORD *)(this + 32) = 1;
  return this;
}

void SetupUnikeyEngine(void)
{
  uint64_t v0;
  int32x4_t v1;
  int32x4_t v2;
  uint64_t i;
  uint64_t j;
  int v5;

  SetupInputClassifierTable();
  v0 = 0;
  v1 = (int32x4_t)xmmword_1DA910FB0;
  v2.i64[0] = 0x400000004;
  v2.i64[1] = 0x400000004;
  do
  {
    *(int32x4_t *)&IsoStdVnCharMap[v0] = v1;
    v1 = vaddq_s32(v1, v2);
    v0 += 4;
  }
  while (v0 != 256);
  for (i = 0; i != 27; ++i)
    IsoStdVnCharMap[SpecialWesternChars[i]] = i + 65722;
  for (j = 0; j != 256; ++j)
  {
    v5 = IsoVnLexiMap[j];
    if (v5 != -1)
      IsoStdVnCharMap[j] = v5 + 0x10000;
  }
}

BOOL UkEngine::atWordBeginning(UkEngine *this)
{
  unsigned int v1;

  v1 = *((_DWORD *)this + 7);
  return (v1 & 0x80000000) != 0 || *((_DWORD *)this + 9 * v1 + 786) == 1;
}

id phrasesFilePathForInputMode(uint64_t a1)
{
  void *v1;
  void *v2;

  +[TIInputMode inputModeWithIdentifier:](TIInputMode, "inputModeWithIdentifier:", a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  UIKeyboardPhraseLexiconPathForInputMode(v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

id dynamicFilePathForInputMode(void *a1, void *a2)
{
  id v3;
  id v4;
  uint64_t v5;
  void *v6;
  __CFString *v7;
  void *v8;

  v3 = a1;
  v4 = a2;
  v5 = objc_msgSend(v3, "length");
  v6 = 0;
  if (v4 && v5)
  {
    if ((objc_msgSend(v3, "isEqualToString:", CFSTR("en_US")) & 1) != 0)
    {
      v7 = CFSTR("dynamic-text.dat");
    }
    else
    {
      TIInputModeGetLanguageWithRegion();
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "stringByAppendingString:", CFSTR("-dynamic-text.dat"));
      v7 = (__CFString *)objc_claimAutoreleasedReturnValue();

    }
    if (-[__CFString length](v7, "length"))
    {
      objc_msgSend(v4, "stringByAppendingPathComponent:", v7);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v6 = 0;
    }

  }
  return v6;
}

id deltaUnigramsFilePathForInputMode(uint64_t a1)
{
  void *v1;
  void *v2;

  +[TIInputMode inputModeWithIdentifier:](TIInputMode, "inputModeWithIdentifier:", a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  UIKeyboardDeltaLexiconPathForInputMode(v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

void __createAndLoadDictionaryContainer(NSString *a1@<X0>, NSString *a2@<X1>, KB::DictionaryContainer **a3@<X8>)
{
  NSString *v5;
  NSString *v6;
  NSString *v7;
  char *v8;
  char *v9;
  NSString *v10;
  KB *v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  int64x2_t v21;
  char *v22;
  uint64_t v23;
  int v24;
  char v25;
  int64x2_t v26;
  char *v27;
  _BYTE v28[8];
  void *v29;
  int v30;
  __int16 v31;
  char v32;
  void *v33;
  char v34;
  int v35;
  __int16 v36;
  char v37;
  void *v38;
  char v39;
  int v40;
  __int16 v41;
  char v42;
  void *v43;
  char v44;
  _BYTE v45[8];
  void *v46;
  int64x2_t *v47;
  void *v48[2];
  unint64_t v49;
  char **v50;
  void *v51;
  _BYTE v52[8];
  void *v53;
  _BYTE v54[8];
  void *v55;
  _BYTE v56[8];
  void *v57;
  uint64_t v58;
  int v59;
  _BYTE v60[8];
  void *v61;
  _BYTE v62[8];
  void *v63;
  _BYTE v64[8];
  void *v65;
  _BYTE v66[8];
  void *v67;
  _BYTE v68[8];
  void *v69;
  uint64_t v70;
  int v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  if (v6)
  {
    UIKeyboardDynamicDictionaryFileWithSiriMode(v5, v6, 0);
    v7 = (NSString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v7 = 0;
  }
  __getLexiconInfo(v5, v7, 1.0, (uint64_t)v60);
  KB::String::String((KB::String *)&v47, (const KB::String *)v60);
  KB::String::String((KB::String *)&v50, (const KB::String *)v62);
  KB::String::String((KB::String *)v52, (const KB::String *)v64);
  KB::String::String((KB::String *)v54, (const KB::String *)v66);
  KB::String::String((KB::String *)v56, (const KB::String *)v68);
  v58 = v70;
  v59 = v71;
  v8 = (char *)operator new(0xB0uLL);
  v9 = v8 + 176;
  v26.i64[0] = (uint64_t)v8;
  v27 = v8 + 176;
  std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo const&,KB::LexiconInfo*>((uint64_t)v8, (uint64_t)&v47);
  v26.i64[1] = (uint64_t)v9;
  if (v57 && v56[6] == 1)
    free(v57);
  if (v55 && v54[6] == 1)
    free(v55);
  if (v53 && v52[6] == 1)
    free(v53);
  if (v51 && BYTE6(v50) == 1)
    free(v51);
  if (v48[0] && BYTE6(v47) == 1)
    free(v48[0]);
  v10 = objc_retainAutorelease(v5);
  if (TIMultilingualDynamicModelEnabled((char *)-[NSString UTF8String](v10, "UTF8String")))
  {
    KB::String::String((KB::String *)v45, "mul");
    v40 = 0x100000;
    v41 = 0;
    v42 = 0;
    v43 = 0;
    v44 = 0;
    v35 = 0x100000;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    v30 = 0x100000;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    dynamicFilePathForInputMode(CFSTR("mul"), v7);
    v11 = (KB *)objc_claimAutoreleasedReturnValue();
    KB::utf8_string(v11, (uint64_t)v28);
    v25 = 0;
    v24 = 1;
    if (v26.i64[1] >= (unint64_t)v27)
    {
      v13 = 0x2E8BA2E8BA2E8BA3 * ((v26.i64[1] - v26.i64[0]) >> 4);
      if ((unint64_t)(v13 + 1) > 0x1745D1745D1745DLL)
        abort();
      v14 = 0x5D1745D1745D1746 * ((uint64_t)&v27[-v26.i64[0]] >> 4);
      if (v14 <= v13 + 1)
        v14 = v13 + 1;
      if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((uint64_t)&v27[-v26.i64[0]] >> 4)) >= 0xBA2E8BA2E8BA2ELL)
        v15 = 0x1745D1745D1745DLL;
      else
        v15 = v14;
      v50 = &v27;
      if (v15)
        v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LexiconInfo>>(v15);
      else
        v16 = 0;
      v17 = v15 + 16 * ((v26.i64[1] - v26.i64[0]) >> 4);
      v47 = (int64x2_t *)v15;
      v48[0] = (void *)v17;
      v49 = v15 + 176 * v16;
      std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::String,KB::String,KB::String,KB::String,KB::String,unsigned int const&,BOOL,int,KB::LexiconInfo*>(v17, (KB::String *)v45, (KB::String *)&v40, (KB::String *)&v35, (KB::String *)&v30, (KB::String *)v28, &v25, &v24);
      v12 = (void *)(v17 + 176);
      v48[1] = (void *)(v17 + 176);
      v18 = v26.i64[1];
      v19 = v26.i64[0];
      v20 = v48[0];
      if (v26.i64[1] == v26.i64[0])
      {
        v21 = vdupq_n_s64(v26.u64[1]);
      }
      else
      {
        do
        {
          v18 -= 176;
          v20 = (void *)std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo,KB::LexiconInfo*>((uint64_t)v20 - 176, v18);
        }
        while (v18 != v19);
        v21 = v26;
        v12 = v48[1];
      }
      v26.i64[0] = (uint64_t)v20;
      v26.i64[1] = (uint64_t)v12;
      *(int64x2_t *)v48 = v21;
      v22 = v27;
      v27 = (char *)v49;
      v49 = (unint64_t)v22;
      v47 = (int64x2_t *)v21.i64[0];
      std::__split_buffer<KB::LexiconInfo>::~__split_buffer((uint64_t)&v47);
    }
    else
    {
      v12 = (void *)(std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::String,KB::String,KB::String,KB::String,KB::String,unsigned int const&,BOOL,int,KB::LexiconInfo*>(v26.i64[1], (KB::String *)v45, (KB::String *)&v40, (KB::String *)&v35, (KB::String *)&v30, (KB::String *)v28, &v25, &v24)+ 176);
    }
    v26.i64[1] = (uint64_t)v12;
    if (v29 && v28[6] == 1)
      free(v29);

    if (v33 && v32 == 1)
      free(v33);
    if (v38 && v37 == 1)
      free(v38);
    if (v43 && v42 == 1)
      free(v43);
    if (v46 && v45[6] == 1)
      free(v46);
  }
  v23 = operator new();
  *a3 = KB::DictionaryContainer::DictionaryContainer(v23, v26.i64, 1, 1, 1);
  v47 = &v26;
  std::vector<KB::LexiconInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&v47);
  if (v69 && v68[6] == 1)
    free(v69);
  if (v67 && v66[6] == 1)
    free(v67);
  if (v65 && v64[6] == 1)
    free(v65);
  if (v63 && v62[6] == 1)
    free(v63);
  if (v61 && v60[6] == 1)
    free(v61);

}

void __getLexiconInfo(NSString *a1@<X0>, NSString *a2@<X1>, float a3@<S0>, uint64_t a4@<X8>)
{
  NSString *v7;
  NSString *v8;
  KB *v9;
  KB *v10;
  KB *v11;
  NSString *v12;
  KB *v13;

  v7 = a2;
  v8 = a1;
  UIKeyboardStaticUnigramsFile(v8);
  v13 = (KB *)objc_claimAutoreleasedReturnValue();
  deltaUnigramsFilePathForInputMode((uint64_t)v8);
  v9 = (KB *)objc_claimAutoreleasedReturnValue();
  phrasesFilePathForInputMode((uint64_t)v8);
  v10 = (KB *)objc_claimAutoreleasedReturnValue();
  dynamicFilePathForInputMode(v8, v7);
  v11 = (KB *)objc_claimAutoreleasedReturnValue();

  v12 = objc_retainAutorelease(v8);
  LODWORD(v8) = TILexiconIDForLocaleIdentifier((char *)-[NSString UTF8String](v12, "UTF8String"));
  KB::utf8_string((KB *)v12, a4);

  KB::utf8_string(v13, a4 + 32);
  KB::utf8_string(v9, a4 + 64);
  KB::utf8_string(v10, a4 + 96);
  KB::utf8_string(v11, a4 + 128);
  *(_DWORD *)(a4 + 160) = (_DWORD)v8;
  *(_BYTE *)(a4 + 164) = 0;
  *(float *)(a4 + 168) = a3;

}

uint64_t std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::String,KB::String,KB::String,KB::String,KB::String,unsigned int const&,BOOL,int,KB::LexiconInfo*>(uint64_t a1, KB::String *a2, KB::String *a3, KB::String *a4, KB::String *a5, KB::String *a6, _BYTE *a7, int *a8)
{
  uint64_t v15;

  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 6) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v15 = KB::String::operator=(a1, a2);
  *(_DWORD *)(v15 + 32) = 0x100000;
  *(_WORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 38) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  KB::String::operator=(v15 + 32, a3);
  *(_DWORD *)(a1 + 64) = 0x100000;
  *(_WORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 70) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  KB::String::operator=(a1 + 64, a4);
  *(_DWORD *)(a1 + 96) = 0x100000;
  *(_WORD *)(a1 + 100) = 0;
  *(_BYTE *)(a1 + 102) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  KB::String::operator=(a1 + 96, a5);
  *(_DWORD *)(a1 + 128) = 0x100000;
  *(_WORD *)(a1 + 132) = 0;
  *(_BYTE *)(a1 + 134) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  KB::String::operator=(a1 + 128, a6);
  *(_DWORD *)(a1 + 160) = -2;
  *(_BYTE *)(a1 + 164) = *a7;
  *(float *)(a1 + 168) = (float)*a8;
  return a1;
}

void __createAndLoadLanguageModel(NSString *a1@<X0>, NSString *a2@<X1>, int a3@<W2>, _QWORD *a4@<X8>)
{
  void *v7;
  NSString *v8;
  NSString *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  CFTypeRef v14;
  CFTypeRef v15;
  CFTypeRef v16;
  __int128 v17;
  __int128 v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v21;
  unint64_t v22;
  unint64_t *p_shared_weak_owners;
  unint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  CFTypeRef v32;
  CFTypeRef v33;
  CFTypeRef v34;
  CFTypeRef v35[2];
  CFTypeRef v36[2];
  __int128 v37;
  __int128 v38;
  int v39;
  __int128 v40;
  CFTypeRef cf;
  CFTypeRef v42;
  CFTypeRef v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  int v48;
  _QWORD v49[2];

  v49[1] = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  a4[1] = 0;
  v7 = (void *)MEMORY[0x1E0C99DC8];
  v8 = a2;
  v9 = a1;
  objc_msgSend(v7, "localeWithLocaleIdentifier:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v49[0] = v10;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v49, 1);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  +[TIInputMode inputModeWithIdentifier:](TIInputMode, "inputModeWithIdentifier:", v9);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  KB::LanguageModelConfig::LanguageModelConfig((uint64_t)&cf, v10, 0, v11, 0, v8, 0, 0, 0, a3 ^ 1, 0, 0, 1, 90, objc_msgSend(v12, "doesSupportInlineCompletion"));
  v13 = operator new();
  v14 = cf;
  v32 = cf;
  if (cf)
  {
    CFRetain(cf);
    v32 = v14;
  }
  v15 = v42;
  v33 = v42;
  if (v42)
  {
    CFRetain(v42);
    v33 = v15;
  }
  v16 = v43;
  v34 = v43;
  if (v43)
  {
    CFRetain(v43);
    v34 = v16;
  }
  v17 = v44;
  v44 = 0u;
  *(_OWORD *)v35 = v17;
  v18 = v45;
  v45 = 0u;
  *(_OWORD *)v36 = v18;
  v37 = v46;
  v38 = v47;
  v39 = v48;
  KB::LanguageModelStr::LanguageModelStr(v13, (uint64_t)&v32);
  *(_QWORD *)&v40 = v13;
  v19 = (std::__shared_weak_count *)operator new();
  *(_OWORD *)&v19->__shared_owners_ = 0u;
  p_shared_owners = (unint64_t *)&v19->__shared_owners_;
  v19->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC5D8;
  v19[1].__vftable = (std::__shared_weak_count_vtbl *)v13;
  *((_QWORD *)&v40 + 1) = v19;
  v21 = *(std::__shared_weak_count **)(v13 + 160);
  if (v21)
  {
    if (v21->__shared_owners_ != -1)
      goto LABEL_20;
    do
      v22 = __ldxr(p_shared_owners);
    while (__stxr(v22 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v19->__shared_weak_owners_;
    do
      v24 = __ldxr(p_shared_weak_owners);
    while (__stxr(v24 + 1, p_shared_weak_owners));
    *(_QWORD *)(v13 + 152) = v13;
    *(_QWORD *)(v13 + 160) = v19;
    std::__shared_weak_count::__release_weak(v21);
  }
  else
  {
    do
      v25 = __ldxr(p_shared_owners);
    while (__stxr(v25 + 1, p_shared_owners));
    v26 = (unint64_t *)&v19->__shared_weak_owners_;
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
    *(_QWORD *)(v13 + 152) = v13;
    *(_QWORD *)(v13 + 160) = v19;
  }
  do
    v28 = __ldaxr(p_shared_owners);
  while (__stlxr(v28 - 1, p_shared_owners));
  if (!v28)
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
LABEL_20:
  std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100]((uint64_t)a4, &v40);
  v29 = (std::__shared_weak_count *)*((_QWORD *)&v40 + 1);
  if (*((_QWORD *)&v40 + 1))
  {
    v30 = (unint64_t *)(*((_QWORD *)&v40 + 1) + 8);
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  if (v36[1])
    CFRelease(v36[1]);
  if (v36[0])
    CFRelease(v36[0]);
  if (v35[1])
    CFRelease(v35[1]);
  if (v35[0])
    CFRelease(v35[0]);
  if (v34)
    CFRelease(v34);
  if (v33)
    CFRelease(v33);
  if (v32)
    CFRelease(v32);
  (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*a4 + 72))(*a4, 1);
  if (*((_QWORD *)&v45 + 1))
    CFRelease(*((CFTypeRef *)&v45 + 1));
  *((_QWORD *)&v45 + 1) = 0;
  if ((_QWORD)v45)
    CFRelease((CFTypeRef)v45);
  *(_QWORD *)&v45 = 0;
  if (*((_QWORD *)&v44 + 1))
    CFRelease(*((CFTypeRef *)&v44 + 1));
  *((_QWORD *)&v44 + 1) = 0;
  if ((_QWORD)v44)
    CFRelease((CFTypeRef)v44);
  *(_QWORD *)&v44 = 0;
  if (v43)
    CFRelease(v43);
  v43 = 0;
  if (v42)
    CFRelease(v42);
  v42 = 0;
  if (cf)
    CFRelease(cf);

}

void std::__shared_ptr_pointer<KB::LanguageModelStr *,std::shared_ptr<KB::LanguageModel>::__shared_ptr_default_delete<KB::LanguageModel,KB::LanguageModelStr>,std::allocator<KB::LanguageModelStr>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_pointer<KB::LanguageModelStr *,std::shared_ptr<KB::LanguageModel>::__shared_ptr_default_delete<KB::LanguageModel,KB::LanguageModelStr>,std::allocator<KB::LanguageModelStr>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t KB::LanguageModelConfig::LanguageModelConfig(uint64_t a1, CFTypeRef cf, char a3, CFTypeRef a4, CFTypeRef a5, CFTypeRef a6, CFTypeRef a7, CFTypeRef a8, CFTypeRef cfa, int a10, char a11, int a12, int a13, int a14, char a15)
{
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  unint64_t v27;
  int v28;
  void *v29;
  void *v30;
  char v31;
  void *v32;
  void *v33;
  int v34;
  void *v35;
  void *v36;
  int v37;
  char v38;

  *(_QWORD *)a1 = cf;
  if (cf)
  {
    CFRetain(cf);
    *(_QWORD *)a1 = cf;
  }
  *(_QWORD *)(a1 + 8) = a4;
  if (a4)
  {
    CFRetain(a4);
    *(_QWORD *)(a1 + 8) = a4;
  }
  *(_QWORD *)(a1 + 16) = cfa;
  if (cfa)
  {
    CFRetain(cfa);
    *(_QWORD *)(a1 + 16) = cfa;
  }
  *(_QWORD *)(a1 + 24) = a5;
  if (a5)
  {
    CFRetain(a5);
    *(_QWORD *)(a1 + 24) = a5;
  }
  *(_QWORD *)(a1 + 32) = a6;
  if (a6)
  {
    CFRetain(a6);
    *(_QWORD *)(a1 + 32) = a6;
  }
  *(_QWORD *)(a1 + 40) = a7;
  if (a7)
  {
    CFRetain(a7);
    *(_QWORD *)(a1 + 40) = a7;
  }
  *(_QWORD *)(a1 + 48) = a8;
  if (a8)
  {
    CFRetain(a8);
    *(_QWORD *)(a1 + 48) = a8;
  }
  *(_DWORD *)(a1 + 56) = a12;
  *(_DWORD *)(a1 + 60) = a10;
  *(_DWORD *)(a1 + 64) = a13;
  *(_BYTE *)(a1 + 72) = a3;
  *(_BYTE *)(a1 + 73) = a11;
  *(_BYTE *)(a1 + 86) = a15;
  if (TIGetKeyboardLanguageModelingDisableDynamicLanguageModelsValue(void)::onceToken != -1)
    dispatch_once(&TIGetKeyboardLanguageModelingDisableDynamicLanguageModelsValue(void)::onceToken, &__block_literal_global_3764);
  objc_msgSend(MEMORY[0x1E0DBDCA8], "sharedPreferencesController");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v23, "valueForPreferenceKey:", CFSTR("KeyboardLanguageModelingDisableDynamicLanguageModels"));
  v24 = (void *)objc_claimAutoreleasedReturnValue();

  LOBYTE(v23) = objc_msgSend(v24, "BOOLValue");
  *(_BYTE *)(a1 + 74) = (_BYTE)v23;
  objc_msgSend(MEMORY[0x1E0DBDCA8], "sharedPreferencesController");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v25, "valueForPreferenceKey:", *MEMORY[0x1E0DBE438]);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = objc_msgSend(v26, "integerValue");

  if (v27 > 2)
    v28 = 2;
  else
    v28 = dword_1DA90F940[v27];
  *(_DWORD *)(a1 + 68) = v28;
  objc_msgSend(MEMORY[0x1E0DBDCA8], "sharedPreferencesController");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v29, "valueForPreferenceKey:", *MEMORY[0x1E0DBE2C8]);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = objc_msgSend(v30, "BOOLValue");

  *(_BYTE *)(a1 + 75) = v31;
  objc_msgSend(MEMORY[0x1E0DBDCA8], "sharedPreferencesController");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v32, "valueForPreferenceKey:", *MEMORY[0x1E0DBE2D8]);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = objc_msgSend(v33, "integerValue");

  *(_DWORD *)(a1 + 80) = v34;
  objc_msgSend(MEMORY[0x1E0DBDCA8], "sharedPreferencesController");
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v35, "valueForPreferenceKey:", *MEMORY[0x1E0DBE2D0]);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = objc_msgSend(v36, "integerValue");

  *(_DWORD *)(a1 + 76) = v37;
  *(_DWORD *)(a1 + 88) = a14;
  *(_BYTE *)(a1 + 84) = 1;
  if (HIBYTE(inline_completions_override))
    v38 = (_BYTE)inline_completions_override != 0;
  else
    v38 = _os_feature_enabled_impl();
  *(_BYTE *)(a1 + 85) = v38;
  return a1;
}

{
  return KB::LanguageModelConfig::LanguageModelConfig(a1, cf, a3, a4, a5, a6, a7, a8, cfa, a10, a11, a12, a13, a14, a15);
}

void ___ZL62TIGetKeyboardLanguageModelingDisableDynamicLanguageModelsValuev_block_invoke()
{
  id v0;

  objc_msgSend(MEMORY[0x1E0DBDCA8], "sharedPreferencesController");
  v0 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "_configureKey:domain:defaultValue:", CFSTR("KeyboardLanguageModelingDisableDynamicLanguageModels"), CFSTR("com.apple.keyboard"), MEMORY[0x1E0C9AAA0]);

}

uint64_t KB::LanguageModelConfig::set_user_setting_transformer_lm_autocorrection(uint64_t result, int a2)
{
  *(_DWORD *)(result + 68) = a2;
  return result;
}

const void **KB::LanguageModelConfig::_set_app_context_under_mutex(const void **this, const __CFString *a2)
{
  return KB::retain_ptr<__CFDictionary const*>::operator=(this + 5, a2);
}

const void **KB::LanguageModelConfig::_set_recipient_context_under_mutex(const void **this, const __CFDictionary *a2)
{
  return KB::retain_ptr<__CFDictionary const*>::operator=(this + 6, a2);
}

uint64_t KB::LanguageModelConfig::_set_is_online(uint64_t result, int a2)
{
  *(_DWORD *)(result + 56) = a2;
  return result;
}

void KB::LanguageModelConfig::trial_parameters(KB::LanguageModelConfig *this@<X0>, const __CFDictionary *a2@<X1>, uint64_t a3@<X8>)
{
  LM::TrialParameters *v4;
  _QWORD *v5;
  uint64_t v6;
  void *__p[2];
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  v4 = (LM::TrialParameters *)*((_QWORD *)this + 2);
  if (v4)
  {
    LM::TrialParameters::createWithEncodedRepresentation(v4, a2);
    *(_OWORD *)a3 = *(_OWORD *)__p;
    *(_QWORD *)(a3 + 16) = v8;
    *(_QWORD *)(a3 + 24) = v9;
    v5 = v10;
    *(_QWORD *)(a3 + 32) = v10;
    v6 = a3 + 32;
    *(_QWORD *)(a3 + 40) = v11;
    if (v11)
    {
      v10[2] = v6;
      v5 = 0;
    }
    else
    {
      *(_QWORD *)(a3 + 24) = v6;
    }
    *(_BYTE *)(a3 + 48) = 1;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(v5);
  }
  else
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 48) = 0;
  }
}

uint64_t __Block_byref_object_copy__38(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(result + 48) = v2;
  return result;
}

const void ***__Block_byref_object_dispose__39(uint64_t a1)
{
  return std::unique_ptr<KB::StaticDictionary>::reset[abi:nn180100]((const void ****)(a1 + 48), 0);
}

uint64_t __Block_byref_object_copy__3874(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3875(uint64_t a1)
{

}

uint64_t std::__hash_table<std::__hash_value_type<KB::String,_LXLexicon const*>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,_LXLexicon const*>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,_LXLexicon const*>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,_LXLexicon const*>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  void *v5;

  v2 = *(_QWORD **)(a1 + 16);
  while (v2)
  {
    v3 = v2;
    v2 = (_QWORD *)*v2;
    v4 = (void *)v3[3];
    if (v4 && *((_BYTE *)v3 + 22) == 1)
      free(v4);
    operator delete(v3);
  }
  v5 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v5)
    operator delete(v5);
  return a1;
}

void TITransientLexiconManagerLoad()
{
  id v0;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v0 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "loadLexicons");

}

uint64_t TITransientLexiconManagerGetNamedEntitiesForLocale(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "namedEntityLexiconForLocale:", a1);

  return v3;
}

uint64_t TITransientLexiconManagerGetNamedEntityPhrasesForLocale(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "namedEntityPhraseLexiconForLocale:", a1);

  return v3;
}

uint64_t TITransientLexiconManagerGetAddressBookLexiconForLocale(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "addressBookLexiconForLocale:", a1);

  return v3;
}

uint64_t TITransientLexiconManagerGetAppNameLexiconForLocale(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "appNameLexiconForLocale:", a1);

  return v3;
}

void TITransientLexiconManagerLogEntities()
{
  id v0;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v0 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "debugLogEntities");

}

uint64_t TITransientLexiconManagerIsSupplementalLexiconSearchEnabled()
{
  void *v0;
  uint64_t v1;

  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = objc_msgSend(v0, "isSupplementalLexiconSearchEnabled");

  return v1;
}

__CFString *TINSXPCConnectionCodeSigningIdentifier(void *a1)
{
  const __CFAllocator *v1;
  __SecTask *v2;
  __CFString *v3;
  audit_token_t v5;

  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (a1)
    objc_msgSend(a1, "auditToken");
  else
    memset(&v5, 0, sizeof(v5));
  v2 = SecTaskCreateWithAuditToken(v1, &v5);
  v3 = (__CFString *)SecTaskCopySigningIdentifier(v2, 0);
  CFRelease(v2);
  return v3;
}

id TITypologyProfileStateLog()
{
  if (TITypologyProfileStateLog_onceToken != -1)
    dispatch_once(&TITypologyProfileStateLog_onceToken, &__block_literal_global_4009);
  return (id)TITypologyProfileStateLog_log;
}

uint64_t _areValidFieldValues(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  id v8;
  void *v9;
  int v10;
  uint64_t v11;
  void *v13;
  id v14;
  id v15;
  void *v16;
  id v17;
  id v18;
  void *v19;
  int v20;
  id v21;
  int v22;

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v5;
  if (v8
    && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)
    && (objc_msgSend(MEMORY[0x1E0C99D68], "distantPast"),
        v9 = (void *)objc_claimAutoreleasedReturnValue(),
        v10 = objc_msgSend(v8, "isEqualToDate:", v9),
        v9,
        !v10))
  {
    objc_msgSend(MEMORY[0x1E0C99D68], "now");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "laterDate:", v13);
    v14 = (id)objc_claimAutoreleasedReturnValue();

    if (v14 != v8)
    {
      v15 = v6;
      if (!v15 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {

        goto LABEL_5;
      }
      objc_msgSend(MEMORY[0x1E0C99D68], "now");
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "laterDate:", v16);
      v17 = (id)objc_claimAutoreleasedReturnValue();

      if (v17 != v15)
      {
        v18 = v7;
        if (!v18 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {

          goto LABEL_5;
        }
        if ((objc_msgSend(v18, "isEqualToString:", CFSTR("None")) & 1) != 0
          || (objc_msgSend(v18, "isEqualToString:", CFSTR("Enable")) & 1) != 0
          || objc_msgSend(v18, "isEqualToString:", CFSTR("NotNow")))
        {

        }
        else
        {
          v22 = objc_msgSend(v18, "isEqualToString:", CFSTR("Disabled"));

          if (!v22)
            goto LABEL_5;
        }
        objc_msgSend(MEMORY[0x1E0C99D68], "distantPast");
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        v20 = objc_msgSend(v15, "isEqualToDate:", v19);

        if (v20)
        {
          if ((objc_msgSend(v18, "isEqualToString:", CFSTR("None")) & 1) == 0)
            goto LABEL_5;
        }
        else
        {
          objc_msgSend(v8, "laterDate:", v15);
          v21 = (id)objc_claimAutoreleasedReturnValue();

          if (v21 == v8)
            goto LABEL_5;
        }
        v11 = 1;
        goto LABEL_6;
      }
    }
  }
  else
  {

  }
LABEL_5:
  v11 = 0;
LABEL_6:

  return v11;
}

void KB::RemoveAlternatesIfNoLinguisticCandidate::~RemoveAlternatesIfNoLinguisticCandidate(KB::RemoveAlternatesIfNoLinguisticCandidate *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::RemoveAlternatesIfNoLinguisticCandidate::filter_description(KB::RemoveAlternatesIfNoLinguisticCandidate *this)
{
  return "RemoveAlternatesIfNoLinguisticCandidate";
}

void KB::RemoveAlternatesIfNoLinguisticCandidate::filter_candidates(uint64_t a1, _QWORD *a2, const char *a3, uint64_t a4)
{
  uint64_t i;
  uint64_t v7;
  __CFString *v8;

  if (*a2 == a2[1])
  {
    v7 = a2[3];
    for (i = a2[4]; i != v7; KB::Candidate::~Candidate((KB::Candidate *)(i - 1000)))
      ;
    a2[4] = v7;
    v8 = *(__CFString **)(a4 + 56);
    if (v8)
      KB::append_format(v8, (__CFString *)"Removing alternate corrections as there are no linguistic autocorrection candidate\n", a3);
  }
}

uint64_t KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  char **v6;
  const __CFArray *v7;
  unint64_t i;
  const __CFDictionary *v9;
  std::string::size_type size;
  std::string *v11;
  int data;
  int v13;
  std::string *p_p;
  char *v16;
  const void *v17;
  CFTypeRef *v18;
  CFTypeRef *v19;
  const std::nothrow_t *v20;
  unint64_t v21;
  CFTypeRef *v22;
  BOOL v23;
  CFTypeRef *v24;
  applesauce::CF *exception;
  std::string __p;
  CFTypeRef cf[2];
  char v31;
  CFTypeRef v32;

  v2 = a1;
  *(_OWORD *)(a1 + 48) = 0u;
  v3 = (uint64_t *)(a1 + 48);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 80) = 1065353216;
  *(_QWORD *)(a1 + 88) = 0;
  v4 = *a2;
  if (a2[1] != *a2)
  {
    v5 = 0;
    v6 = (char **)(a1 + 24);
    while (1)
    {
      v7 = *(const __CFArray **)(v4 + 8 * v5);
      if (!v7)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      CFRetain(*(CFTypeRef *)(v4 + 8 * v5));
      for (i = 0; i < CFArrayGetCount(v7); ++i)
      {
        cf[0] = 0;
        applesauce::CF::at_or<applesauce::CF::DictionaryRef>(&v32, v7, i, cf);
        if (cf[0])
          CFRelease(cf[0]);
        v9 = (const __CFDictionary *)v32;
        if (v32)
        {
          CFRetain(v32);
          extract_name((uint64_t)cf, v9);
          CFRelease(v9);
          applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&__p, v9, CFSTR("Operation"));
          size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            size = __p.__r_.__value_.__l.__size_;
          if (size == 8)
          {
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              p_p = &__p;
            else
              p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            if (p_p->__r_.__value_.__r.__words[0] == 0x656469727265764FLL)
              goto LABEL_31;
LABEL_20:
            std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100](v6, v9);
          }
          else
          {
            if (size != 6)
              goto LABEL_20;
            v11 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? &__p
                : (std::string *)__p.__r_.__value_.__r.__words[0];
            data = (int)v11->__r_.__value_.__l.__data_;
            v13 = WORD2(v11->__r_.__value_.__r.__words[0]);
            if (data != 1701602628 || v13 != 25972)
              goto LABEL_20;
LABEL_31:
            v16 = std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v3, (uint64_t)cf, (uint64_t)cf);
            v17 = (const void *)*((_QWORD *)v16 + 5);
            *((_QWORD *)v16 + 5) = v9;
            CFRetain(v9);
            if (v17)
              CFRelease(v17);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          if (v31 < 0)
            operator delete((void *)cf[0]);
          CFRelease(v9);
          continue;
        }
      }
      CFRelease(v7);
      ++v5;
      v4 = *a2;
      if (v5 >= (a2[1] - *a2) >> 3)
      {
        v2 = a1;
        v19 = *(CFTypeRef **)(a1 + 24);
        v18 = *(CFTypeRef **)(a1 + 32);
        goto LABEL_36;
      }
    }
  }
  v18 = 0;
  v19 = 0;
LABEL_36:
  if ((char *)v18 - (char *)v19 < 1)
  {
LABEL_40:
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(v19, v18, v18 - v19, 0, 0);
  }
  else
  {
    v20 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
    v21 = v18 - v19;
    while (1)
    {
      v22 = (CFTypeRef *)operator new(8 * v21, v20);
      if (v22)
        break;
      v23 = v21 > 1;
      v21 >>= 1;
      if (!v23)
        goto LABEL_40;
    }
    v24 = v22;
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(v19, v18, v18 - v19, v22, v21);
    operator delete(v24);
  }
  return v2;
}

void sub_1DA794DE4()
{
  void *v0;

}

void std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(CFTypeRef *a1, CFTypeRef *a2, unint64_t a3, CFTypeRef *a4, uint64_t a5)
{
  CFTypeRef *v5;
  CFTypeRef *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  unint64_t v9;
  unsigned __int8 v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  unint64_t v14;
  CFTypeRef v15;
  CFTypeRef *v18;
  uint64_t v19;
  CFTypeRef *v20;
  uint64_t v21;
  CFTypeRef *v22;
  uint64_t v23;
  CFTypeRef *v24;
  CFTypeRef *v25;
  const __CFDictionary *v26;
  unint64_t v27;
  unsigned __int8 v28;
  uint64_t v29;
  unint64_t v30;
  char v31;
  unint64_t v32;
  uint64_t v33;
  const void **v34;
  const __CFDictionary *v35;
  unint64_t v36;
  unsigned __int8 v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  unint64_t v41;
  const void *v42;
  _QWORD *v43;
  CFTypeRef *v44;
  CFTypeRef *v45;
  CFTypeRef *v46;
  const __CFDictionary *v47;
  const __CFDictionary *v48;
  unint64_t v49;
  unsigned __int8 v50;
  uint64_t v51;
  unint64_t v52;
  char v53;
  unint64_t v54;
  CFTypeRef v55;
  uint64_t v56;
  CFTypeRef v57;
  uint64_t v58;
  CFTypeRef v59;
  const __CFDictionary *v60;
  applesauce::CF *exception;
  CFTypeRef v62;
  uint64_t v64[2];
  unint64_t v65;

  if (a3 < 2)
    return;
  v5 = a2;
  v6 = a1;
  if (a3 == 2)
  {
    v7 = (const __CFDictionary *)*(a2 - 1);
    if (!v7)
    {
      v62 = *a1;
      if (!*v6)
        goto LABEL_63;
      goto LABEL_72;
    }
    CFRetain(*(a2 - 1));
    v8 = (const __CFDictionary *)*v6;
    if (*v6)
    {
      CFRetain(*v6);
      v9 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v7);
      v11 = v10;
      v12 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v8);
      if (v13)
        v14 = v12;
      else
        v14 = -1;
      CFRelease(v8);
      CFRelease(v7);
      if (v11)
      {
        if (v9 < v14)
        {
          v15 = *v6;
          *v6 = 0;
          *v6 = *(v5 - 1);
          *(v5 - 1) = v15;
        }
      }
      return;
    }
LABEL_61:
    v60 = v7;
    goto LABEL_62;
  }
  if ((uint64_t)a3 <= 0)
  {
    if (a1 == a2)
      return;
    v22 = a1 + 1;
    if (a1 + 1 == a2)
      return;
    v23 = 0;
    v24 = a1;
    while (1)
    {
      v25 = v24;
      v7 = (const __CFDictionary *)*v22;
      if (!*v22)
      {
        v62 = *v24;
        if (!*v24)
          goto LABEL_63;
LABEL_72:
        CFRetain(v62);
        goto LABEL_63;
      }
      v24 = v22;
      CFRetain(*v22);
      v26 = (const __CFDictionary *)*v25;
      if (!*v25)
        goto LABEL_61;
      CFRetain(*v25);
      v27 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v7);
      v29 = v28;
      v30 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v26);
      if (v31)
        v32 = v30;
      else
        v32 = -1;
      CFRelease(v26);
      CFRelease(v7);
      if (v29 && v27 < v32)
      {
        v7 = (const __CFDictionary *)*v24;
        *v24 = *v25;
        *v25 = 0;
        if (v25 == v6)
        {
          *v6 = v7;
        }
        else
        {
          v33 = v23;
          if (!v7)
          {
            v62 = *(v25 - 1);
            if (!v62)
              goto LABEL_63;
            goto LABEL_72;
          }
          while (1)
          {
            v34 = (CFTypeRef *)((char *)v6 + v33);
            CFRetain(v7);
            v35 = *(const __CFDictionary **)((char *)v6 + v33 - 8);
            if (!v35)
              goto LABEL_61;
            CFRetain(*(v34 - 1));
            v36 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v7);
            v38 = v37;
            v39 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v35);
            v41 = v40 ? v39 : -1;
            CFRelease(v35);
            CFRelease(v7);
            v42 = *v34;
            if (!v38 || v36 >= v41)
              break;
            *(CFTypeRef *)((char *)v6 + v33) = *(v34 - 1);
            *(v34 - 1) = v42;
            v33 -= 8;
            if (!v33)
            {
              v43 = v6;
              goto LABEL_37;
            }
          }
          v43 = (CFTypeRef *)((char *)v6 + v33);
LABEL_37:
          *v43 = v7;
          v5 = a2;
          if (v42)
            CFRelease(v42);
        }
      }
      v22 = v24 + 1;
      v23 += 8;
      if (v24 + 1 == v5)
        return;
    }
  }
  v18 = a4;
  v19 = a3 >> 1;
  v20 = &a1[a3 >> 1];
  if ((uint64_t)a3 <= a5)
  {
    v64[0] = (uint64_t)a4;
    v64[1] = (uint64_t)&v65;
    v65 = 0;
    std::__stable_sort_move<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(a1, &a1[a3 >> 1], a3 >> 1, a4);
    v65 = a3 >> 1;
    v44 = &v18[v19];
    std::__stable_sort_move<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(&v6[a3 >> 1], v5, a3 - v19, v44);
    v65 = a3;
    v45 = &v18[a3];
    v46 = v44;
    while (v46 != v45)
    {
      v47 = (const __CFDictionary *)*v46;
      if (!*v46)
      {
        v62 = *v18;
        if (!*v18)
          goto LABEL_63;
        goto LABEL_72;
      }
      CFRetain(*v46);
      v48 = (const __CFDictionary *)*v18;
      if (!*v18)
      {
        v60 = v47;
LABEL_62:
        applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v60);
LABEL_63:
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      CFRetain(*v18);
      v49 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v47);
      v51 = v50;
      v52 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v48);
      if (v53)
        v54 = v52;
      else
        v54 = -1;
      CFRelease(v48);
      CFRelease(v47);
      v55 = *v6;
      if (v51 && v49 < v54)
      {
        *v6 = *v46;
        *v46++ = v55;
      }
      else
      {
        *v6 = *v18;
        *v18++ = v55;
      }
      ++v6;
      if (v18 == v44)
      {
        if (v46 != v45)
        {
          v56 = 0;
          do
          {
            v57 = v6[v56];
            v6[v56] = v46[v56];
            v46[v56++] = v57;
          }
          while (&v46[v56] != v45);
        }
        goto LABEL_60;
      }
    }
    if (v18 != v44)
    {
      v58 = 0;
      do
      {
        v59 = v6[v58];
        v6[v58] = v18[v58];
        v18[v58++] = v59;
      }
      while (&v18[v58] != v44);
    }
LABEL_60:
    std::unique_ptr<applesauce::CF::DictionaryRef,std::__destruct_n &>::reset[abi:nn180100](v64);
  }
  else
  {
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(a1, &a1[a3 >> 1], a3 >> 1, a4, a5);
    v21 = a3 - v19;
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(v20, v5, v21, v18, a5);
    std::__inplace_merge<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(v6, v20, v5, v19, v21, v18, a5);
  }
}

void applesauce::CF::construct_error(applesauce::CF *this)
{
  JUMPOUT(0x1DF0A1F28);
}

void applesauce::CF::at_or<applesauce::CF::DictionaryRef>(_QWORD *a1, CFArrayRef theArray, unint64_t a3, _QWORD *a4)
{
  const void *ValueAtIndex;
  const void *v9;
  CFTypeID v10;

  if (CFArrayGetCount(theArray) > a3)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, a3);
    if (ValueAtIndex)
    {
      v9 = ValueAtIndex;
      CFRetain(ValueAtIndex);
      v10 = CFGetTypeID(v9);
      if (v10 == CFDictionaryGetTypeID())
      {
        CFRetain(v9);
        *a1 = v9;
        CFRelease(v9);
        return;
      }
      CFRelease(v9);
    }
  }
  *a1 = *a4;
  *a4 = 0;
}

void extract_name(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFString *Value;
  _BOOL4 v4;
  uint64_t v5;
  NSObject *v6;
  void **v7;
  applesauce::CF *exception;
  void *__p[2];
  uint64_t v10;
  char v11;
  uint8_t buf[4];
  void **v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!theDict)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("FilterName"));
  if (!Value)
  {
    LOBYTE(__p[0]) = 0;
    v11 = 0;
    goto LABEL_7;
  }
  applesauce::CF::convert_as<std::string,0>((uint64_t)__p, Value);
  if (!v11)
  {
LABEL_7:
    std::string::basic_string[abi:nn180100]<0>((_QWORD *)a1, "");
    v4 = v10 < 0;
    goto LABEL_8;
  }
  if ((SHIBYTE(v10) & 0x80000000) == 0)
  {
    *(_OWORD *)a1 = *(_OWORD *)__p;
    *(_QWORD *)(a1 + 16) = v10;
    goto LABEL_11;
  }
  std::string::__init_copy_ctor_external((std::string *)a1, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
  v4 = 1;
LABEL_8:
  if (v11 && v4)
    operator delete(__p[0]);
LABEL_11:
  v5 = *(unsigned __int8 *)(a1 + 23);
  if ((v5 & 0x80u) != 0)
    v5 = *(_QWORD *)(a1 + 8);
  if (!v5)
  {
    filter_factory_log();
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      KB::std_string(CFSTR("FilterName"), __p);
      if (v10 >= 0)
        v7 = __p;
      else
        v7 = (void **)__p[0];
      *(_DWORD *)buf = 136315138;
      v13 = v7;
      _os_log_error_impl(&dword_1DA6F2000, v6, OS_LOG_TYPE_ERROR, "Filter specification must include key '%s' with string value.", buf, 0xCu);
      if (SHIBYTE(v10) < 0)
        operator delete(__p[0]);
    }

  }
}

void applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(std::string *a1, CFDictionaryRef theDict, void *key)
{
  const __CFString *Value;
  _BOOL4 v5;
  void *__p[2];
  int64_t v7;
  char v8;

  if (!key || (Value = (const __CFString *)CFDictionaryGetValue(theDict, key)) == 0)
  {
    LOBYTE(__p[0]) = 0;
    v8 = 0;
    goto LABEL_7;
  }
  applesauce::CF::convert_as<std::string,0>((uint64_t)__p, Value);
  if (!v8)
  {
LABEL_7:
    std::string::basic_string[abi:nn180100]<0>(a1, "");
    v5 = v7 < 0;
    goto LABEL_8;
  }
  if ((SHIBYTE(v7) & 0x80000000) == 0)
  {
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
    a1->__r_.__value_.__r.__words[2] = v7;
    return;
  }
  std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
  v5 = 1;
LABEL_8:
  if (v8)
  {
    if (v5)
      operator delete(__p[0]);
  }
}

char *std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  void **v15;
  char *v16;
  unint64_t v17;
  _QWORD *v18;
  std::string *v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  int8x8_t prime;
  void *v26;
  void *v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint8x8_t v31;
  unint64_t v32;
  uint8x8_t v33;
  uint64_t v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  unint64_t v39;
  void *v41;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = a1[1];
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(void ***)(*a1 + 8 * v3);
    if (v15)
    {
      v16 = (char *)*v15;
      if (*v15)
      {
        do
        {
          v17 = *((_QWORD *)v16 + 1);
          if (v17 == v11)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v16 + 16, (unsigned __int8 *)a2))
            {
              return v16;
            }
          }
          else
          {
            if (v14 > 1)
            {
              if (v17 >= v12)
                v17 %= v12;
            }
            else
            {
              v17 &= v12 - 1;
            }
            if (v17 != v3)
              break;
          }
          v16 = *(char **)v16;
        }
        while (v16);
      }
    }
  }
  v18 = a1 + 2;
  v16 = (char *)operator new(0x30uLL);
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = v11;
  v19 = (std::string *)(v16 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((_QWORD *)v16 + 4) = *(_QWORD *)(a3 + 16);
  }
  *((_QWORD *)v16 + 5) = 0;
  v20 = (float)(unint64_t)(a1[3] + 1);
  v21 = *((float *)a1 + 8);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    v22 = 1;
    if (v12 >= 3)
      v22 = (v12 & (v12 - 1)) != 0;
    v23 = v22 | (2 * v12);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      prime = (int8x8_t)v24;
    else
      prime = (int8x8_t)v23;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v12 = a1[1];
    if (*(_QWORD *)&prime > v12)
      goto LABEL_39;
    if (*(_QWORD *)&prime < v12)
    {
      v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (v33 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        v32 = std::__next_prime(v32);
      }
      else
      {
        v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2)
          v32 = v34;
      }
      if (*(_QWORD *)&prime <= v32)
        prime = (int8x8_t)v32;
      if (*(_QWORD *)&prime >= v12)
      {
        v12 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v26 = operator new(8 * *(_QWORD *)&prime);
          v27 = (void *)*a1;
          *a1 = (uint64_t)v26;
          if (v27)
            operator delete(v27);
          v28 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v28++) = 0;
          while (*(_QWORD *)&prime != v28);
          v29 = (_QWORD *)*v18;
          if (*v18)
          {
            v30 = v29[1];
            v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(_QWORD *)&prime)
                v30 %= *(_QWORD *)&prime;
            }
            else
            {
              v30 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v30) = v18;
            v35 = (_QWORD *)*v29;
            if (*v29)
            {
              do
              {
                v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(_QWORD *)&prime)
                    v36 %= *(_QWORD *)&prime;
                }
                else
                {
                  v36 &= *(_QWORD *)&prime - 1;
                }
                if (v36 != v30)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v36))
                  {
                    *(_QWORD *)(*a1 + 8 * v36) = v29;
                    goto LABEL_64;
                  }
                  *v29 = *v35;
                  *v35 = **(_QWORD **)(*a1 + 8 * v36);
                  **(_QWORD **)(*a1 + 8 * v36) = v35;
                  v35 = v29;
                }
                v36 = v30;
LABEL_64:
                v29 = v35;
                v35 = (_QWORD *)*v35;
                v30 = v36;
              }
              while (v35);
            }
          }
          v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        v41 = (void *)*a1;
        *a1 = 0;
        if (v41)
          operator delete(v41);
        v12 = 0;
        a1[1] = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v37 = *a1;
  v38 = *(_QWORD **)(*a1 + 8 * v3);
  if (v38)
  {
    *(_QWORD *)v16 = *v38;
LABEL_81:
    *v38 = v16;
    goto LABEL_82;
  }
  *(_QWORD *)v16 = *v18;
  *v18 = v16;
  *(_QWORD *)(v37 + 8 * v3) = v18;
  if (*(_QWORD *)v16)
  {
    v39 = *(_QWORD *)(*(_QWORD *)v16 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v39 >= v12)
        v39 %= v12;
    }
    else
    {
      v39 &= v12 - 1;
    }
    v38 = (_QWORD *)(*a1 + 8 * v39);
    goto LABEL_81;
  }
LABEL_82:
  ++a1[3];
  return v16;
}

void std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100](char **a1, CFTypeRef cf)
{
  unint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  int64x2_t v16;
  char *v17;
  char *v18;
  const void *v19;
  const void *v20;

  v5 = a1[1];
  v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    v7 = *a1;
    v8 = (v5 - *a1) >> 3;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61)
      abort();
    v10 = v4 - (_QWORD)v7;
    if (v10 >> 2 > v9)
      v9 = v10 >> 2;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
    {
      if (v11 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v12 = (char *)operator new(8 * v11);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    if (cf)
    {
      CFRetain(cf);
      v7 = *a1;
      v5 = a1[1];
    }
    v14 = &v12[8 * v11];
    *(_QWORD *)v13 = cf;
    v6 = v13 + 8;
    if (v5 == v7)
    {
      v16 = vdupq_n_s64((unint64_t)v5);
    }
    else
    {
      do
      {
        v15 = *((_QWORD *)v5 - 1);
        v5 -= 8;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
        *(_QWORD *)v5 = 0;
      }
      while (v5 != v7);
      v16 = *(int64x2_t *)a1;
    }
    *a1 = v13;
    a1[1] = v6;
    a1[2] = v14;
    v18 = (char *)v16.i64[1];
    v17 = (char *)v16.i64[0];
    while (v18 != v17)
    {
      v20 = (const void *)*((_QWORD *)v18 - 1);
      v18 -= 8;
      v19 = v20;
      if (v20)
        CFRelease(v19);
    }
    if (v17)
      operator delete(v17);
  }
  else
  {
    if (cf)
      CFRetain(cf);
    *(_QWORD *)v5 = cf;
    v6 = v5 + 8;
  }
  a1[1] = v6;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,applesauce::CF::DictionaryRef>,0>(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRelease(v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

double applesauce::CF::convert_as<std::string,0>(uint64_t a1, const __CFString *a2)
{
  CFTypeID TypeID;
  double result;
  char *CStringPtr;
  CFIndex Length;
  UInt8 *p_b;
  __int128 __b;
  uint64_t v10;
  CFIndex maxBufLen;
  CFRange v12;
  CFRange v13;

  if (a2 && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(a2)))
  {
    CStringPtr = (char *)CFStringGetCStringPtr(a2, 0x8000100u);
    if (CStringPtr)
    {
      std::string::basic_string[abi:nn180100]<0>(&__b, CStringPtr);
    }
    else
    {
      Length = CFStringGetLength(a2);
      maxBufLen = 0;
      v12.location = 0;
      v12.length = Length;
      CFStringGetBytes(a2, v12, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
      std::string::basic_string[abi:nn180100](&__b, maxBufLen, 0);
      if (v10 >= 0)
        p_b = (UInt8 *)&__b;
      else
        p_b = (UInt8 *)__b;
      v13.location = 0;
      v13.length = Length;
      CFStringGetBytes(a2, v13, 0x8000100u, 0, 0, p_b, maxBufLen, &maxBufLen);
    }
    result = *(double *)&__b;
    *(_OWORD *)a1 = __b;
    *(_QWORD *)(a1 + 16) = v10;
    *(_BYTE *)(a1 + 24) = 1;
  }
  else
  {
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 24) = 0;
  }
  return result;
}

_QWORD *std::string::basic_string[abi:nn180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

id filter_factory_log(void)
{
  if (filter_factory_log(void)::once_token != -1)
    dispatch_once(&filter_factory_log(void)::once_token, &__block_literal_global_234);
  return (id)filter_factory_log(void)::log;
}

void ___ZL18filter_factory_logv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.TextInput", "candidateFilterFactory");
  v1 = (void *)filter_factory_log(void)::log;
  filter_factory_log(void)::log = (uint64_t)v0;

}

unint64_t applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(const __CFDictionary *a1)
{
  const __CFNumber *Value;
  const __CFNumber *v2;
  CFTypeID TypeID;
  const __CFNumber *v4;
  CFNumberType v5;
  unint64_t v6;
  unint64_t v7;
  CFTypeID v8;
  unint64_t v9;
  unint64_t v10;
  const __CFNumber *v11;
  CFNumberType v12;
  const __CFNumber *v13;
  CFNumberType v14;
  const __CFNumber *v15;
  CFNumberType v16;
  const __CFNumber *v17;
  CFNumberType v18;
  const __CFNumber *v19;
  CFNumberType v20;
  int v21;
  char v22;
  BOOL v23;
  unsigned __int8 v24;
  uint64_t v25;
  unint64_t v26;
  BOOL v27;
  double valuePtr;

  if (a1)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("Position"));
    if (Value)
    {
      v2 = Value;
      TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(v2))
      {
        switch(CFNumberGetType(v2))
        {
          case kCFNumberSInt8Type:
            LOBYTE(valuePtr) = 0;
            v4 = v2;
            v5 = kCFNumberSInt8Type;
            goto LABEL_18;
          case kCFNumberSInt16Type:
            LOWORD(valuePtr) = 0;
            v11 = v2;
            v12 = kCFNumberSInt16Type;
            goto LABEL_26;
          case kCFNumberSInt32Type:
            LODWORD(valuePtr) = 0;
            v13 = v2;
            v14 = kCFNumberSInt32Type;
            goto LABEL_28;
          case kCFNumberSInt64Type:
            valuePtr = 0.0;
            v15 = v2;
            v16 = kCFNumberSInt64Type;
            goto LABEL_39;
          case kCFNumberFloat32Type:
            LODWORD(valuePtr) = 0;
            v17 = v2;
            v18 = kCFNumberFloat32Type;
            goto LABEL_35;
          case kCFNumberFloat64Type:
            valuePtr = 0.0;
            v19 = v2;
            v20 = kCFNumberFloat64Type;
            goto LABEL_41;
          case kCFNumberCharType:
            LOBYTE(valuePtr) = 0;
            v4 = v2;
            v5 = kCFNumberCharType;
LABEL_18:
            v21 = CFNumberGetValue(v4, v5, &valuePtr);
            if (v21)
              v22 = LOBYTE(valuePtr);
            else
              v22 = 0;
            if (v21 != 0 && SLOBYTE(valuePtr) < 0)
              v9 = -256;
            else
              v9 = 0;
            LOBYTE(v10) = v22;
            break;
          case kCFNumberShortType:
            LOWORD(valuePtr) = 0;
            v11 = v2;
            v12 = kCFNumberShortType;
LABEL_26:
            v23 = CFNumberGetValue(v11, v12, &valuePtr) == 0;
            v24 = LOBYTE(valuePtr);
            v25 = SLOWORD(valuePtr);
            goto LABEL_29;
          case kCFNumberIntType:
            LODWORD(valuePtr) = 0;
            v13 = v2;
            v14 = kCFNumberIntType;
LABEL_28:
            v23 = CFNumberGetValue(v13, v14, &valuePtr) == 0;
            v24 = LOBYTE(valuePtr);
            v25 = SLODWORD(valuePtr);
LABEL_29:
            v26 = v25 & 0xFFFFFFFFFFFFFF00 | v24;
            if (v23)
              v10 = 0;
            else
              v10 = v26;
            goto LABEL_45;
          case kCFNumberLongType:
            valuePtr = 0.0;
            v15 = v2;
            v16 = kCFNumberLongType;
            goto LABEL_39;
          case kCFNumberLongLongType:
            valuePtr = 0.0;
            v15 = v2;
            v16 = kCFNumberLongLongType;
            goto LABEL_39;
          case kCFNumberFloatType:
            LODWORD(valuePtr) = 0;
            v17 = v2;
            v18 = kCFNumberFloatType;
LABEL_35:
            v27 = CFNumberGetValue(v17, v18, &valuePtr) == 0;
            v10 = (unint64_t)*(float *)&valuePtr;
            goto LABEL_42;
          case kCFNumberDoubleType:
            valuePtr = 0.0;
            v19 = v2;
            v20 = kCFNumberDoubleType;
            goto LABEL_41;
          case kCFNumberCFIndexType:
            valuePtr = 0.0;
            v15 = v2;
            v16 = kCFNumberCFIndexType;
            goto LABEL_39;
          case kCFNumberNSIntegerType:
            valuePtr = 0.0;
            v15 = v2;
            v16 = kCFNumberNSIntegerType;
LABEL_39:
            v27 = CFNumberGetValue(v15, v16, &valuePtr) == 0;
            v10 = *(_QWORD *)&valuePtr;
            goto LABEL_42;
          case kCFNumberCGFloatType:
            valuePtr = 0.0;
            v19 = v2;
            v20 = kCFNumberCGFloatType;
LABEL_41:
            v27 = CFNumberGetValue(v19, v20, &valuePtr) == 0;
            v10 = (unint64_t)valuePtr;
LABEL_42:
            if (v27)
              v10 = 0;
LABEL_45:
            v9 = v10 & 0xFFFFFFFFFFFFFF00;
            break;
          default:
            v9 = 0;
            LOBYTE(v10) = 0;
            break;
        }
        v7 = v10 | v9;
      }
      else
      {
        v8 = CFBooleanGetTypeID();
        if (v8 == CFGetTypeID(v2))
          v7 = CFBooleanGetValue(v2);
        else
          v7 = 0;
      }
      v6 = v7 & 0xFFFFFFFFFFFFFF00;
      v7 = v7;
    }
    else
    {
      v6 = 0;
      v7 = 0;
    }
  }
  else
  {
    v6 = 0;
    v7 = 0;
  }
  return v7 | v6;
}

void std::__stable_sort_move<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(CFTypeRef *a1, CFTypeRef *a2, unint64_t a3, CFTypeRef *a4)
{
  CFTypeRef *v4;
  CFTypeRef *v7;
  CFTypeRef v8;
  CFTypeRef *v9;
  const __CFDictionary *v10;
  unint64_t v11;
  char v12;
  _BOOL4 v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  _BOOL4 v17;
  CFTypeRef *v18;
  CFTypeRef *v19;
  uint64_t v20;
  uint64_t v21;
  CFTypeRef *v22;
  uint64_t v23;
  CFTypeRef *v24;
  CFTypeRef v25;
  unint64_t v26;
  unsigned __int8 v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  unint64_t v31;
  CFTypeRef v32;
  CFTypeRef *v33;
  uint64_t v34;
  char *v35;
  const __CFDictionary *v36;
  unint64_t v37;
  unsigned __int8 v38;
  uint64_t v39;
  unint64_t v40;
  char v41;
  unint64_t v42;
  CFTypeRef v43;
  CFTypeRef *v44;
  CFTypeRef *v45;
  const __CFDictionary *v46;
  const __CFDictionary *v47;
  unint64_t v48;
  unsigned __int8 v49;
  uint64_t v50;
  unint64_t v51;
  char v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  const __CFDictionary *v56;
  CFTypeRef v57;
  applesauce::CF *exception;
  CFTypeRef *v60;
  CFTypeRef *v61;
  uint64_t *v62;
  uint64_t v63;

  if (!a3)
    return;
  v4 = a4;
  v7 = a1;
  if (a3 == 2)
  {
    v62 = &v63;
    v63 = 0;
    v9 = a2 - 1;
    v8 = *(a2 - 1);
    if (!v8)
    {
LABEL_76:
      v57 = *v7;
      if (!*v7)
        goto LABEL_73;
      goto LABEL_72;
    }
    CFRetain(v8);
    v10 = (const __CFDictionary *)*v7;
    if (*v7)
    {
      CFRetain(*v7);
      v11 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>((const __CFDictionary *)v8);
      v13 = v12 != 0;
      v14 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v10);
      if (v15)
        v16 = v14;
      else
        v16 = -1;
      v17 = v11 < v16;
      CFRelease(v10);
      CFRelease(v8);
      if (v13 && v17)
        v18 = v9;
      else
        v18 = v7;
      if (v13 && v17)
        v19 = v7;
      else
        v19 = v9;
      *v4 = *v18;
      *v18 = 0;
      v20 = v63;
      v4[1] = *v19;
      *v19 = 0;
      v21 = v20 + 1;
      goto LABEL_17;
    }
LABEL_69:
    v56 = (const __CFDictionary *)v8;
LABEL_70:
    applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v56);
    goto LABEL_73;
  }
  if (a3 == 1)
  {
    *a4 = *a1;
    *a1 = 0;
    return;
  }
  if ((uint64_t)a3 > 8)
  {
    v44 = &a1[a3 >> 1];
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(a1, v44, a3 >> 1, a4, a3 >> 1);
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(&v7[a3 >> 1], a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
    v62 = &v63;
    v63 = 0;
    if (v44 == a2)
    {
      v21 = 0;
LABEL_62:
      if (v7 == v44)
        goto LABEL_18;
      do
      {
        *v4++ = *v7;
        *v7++ = 0;
        ++v21;
      }
      while (v7 != v44);
LABEL_17:
      v63 = v21;
      goto LABEL_18;
    }
    v45 = &v7[a3 >> 1];
    while (1)
    {
      v46 = (const __CFDictionary *)*v45;
      if (!*v45)
        goto LABEL_76;
      CFRetain(*v45);
      v47 = (const __CFDictionary *)*v7;
      if (!*v7)
        break;
      CFRetain(*v7);
      v48 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v46);
      v50 = v49;
      v51 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v47);
      if (v52)
        v53 = v51;
      else
        v53 = -1;
      CFRelease(v47);
      CFRelease(v46);
      if (v50 && v48 < v53)
      {
        *v4 = *v45;
        *v45++ = 0;
      }
      else
      {
        *v4 = *v7;
        *v7++ = 0;
      }
      v54 = v63;
      v21 = ++v63;
      if (v7 == v44)
      {
        if (v45 == a2)
          goto LABEL_18;
        v55 = 1;
        do
        {
          v4[v55] = *v45;
          *v45++ = 0;
          ++v55;
        }
        while (v45 != a2);
        v21 = v54 + v55;
        goto LABEL_17;
      }
      ++v4;
      if (v45 == a2)
        goto LABEL_62;
    }
    v56 = v46;
    goto LABEL_70;
  }
  if (a1 != a2)
  {
    v61 = a4;
    v62 = &v63;
    *a4 = *a1;
    *a1 = 0;
    v22 = a1 + 1;
    v63 = 1;
    if (a1 + 1 == a2)
      goto LABEL_18;
    v23 = 0;
    v24 = a4;
    while (1)
    {
      v8 = *v22;
      if (!*v22)
        break;
      CFRetain(*v22);
      v25 = *v24;
      if (!*v24)
        goto LABEL_69;
      v60 = v24 + 1;
      CFRetain(v25);
      v26 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>((const __CFDictionary *)v8);
      v28 = v27;
      v29 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>((const __CFDictionary *)v25);
      if (v30)
        v31 = v29;
      else
        v31 = -1;
      CFRelease(v25);
      CFRelease(v8);
      if (!v28 || v26 >= v31)
      {
        ++v24;
        *v60 = *v22;
        *v22 = 0;
        ++v63;
        goto LABEL_45;
      }
      v32 = *v24;
      *v24 = 0;
      v24[1] = v32;
      ++v63;
      v33 = v4;
      if (v24 == v4)
        goto LABEL_44;
      v34 = v23;
      while (1)
      {
        v35 = (char *)v4 + v34;
        v8 = *v22;
        if (!*v22)
        {
          v57 = (CFTypeRef)*((_QWORD *)v35 - 1);
          if (v57)
            goto LABEL_72;
LABEL_73:
          exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
          applesauce::CF::construct_error(exception);
        }
        CFRetain(*v22);
        v36 = (const __CFDictionary *)*((_QWORD *)v35 - 1);
        if (!v36)
          goto LABEL_69;
        CFRetain(*((CFTypeRef *)v35 - 1));
        v37 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>((const __CFDictionary *)v8);
        v39 = v38;
        v40 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v36);
        v42 = v41 ? v40 : -1;
        CFRelease(v36);
        CFRelease(v8);
        if (!v39 || v37 >= v42)
          break;
        *(int8x16_t *)(v35 - 8) = vextq_s8(*(int8x16_t *)(v35 - 8), *(int8x16_t *)(v35 - 8), 8uLL);
        v34 -= 8;
        if (!v34)
        {
          v33 = v4;
          goto LABEL_44;
        }
      }
      v33 = (CFTypeRef *)((char *)v4 + v34);
LABEL_44:
      v43 = *v33;
      *v33 = *v22;
      *v22 = v43;
      v24 = v60;
LABEL_45:
      ++v22;
      v23 += 8;
      if (v22 == a2)
      {
LABEL_18:
        v61 = 0;
        std::unique_ptr<applesauce::CF::DictionaryRef,std::__destruct_n &>::reset[abi:nn180100]((uint64_t *)&v61);
        return;
      }
    }
    v57 = *v24;
    if (!*v24)
      goto LABEL_73;
LABEL_72:
    CFRetain(v57);
    goto LABEL_73;
  }
}

void std::unique_ptr<applesauce::CF::DictionaryRef,std::__destruct_n &>::reset[abi:nn180100](uint64_t *a1)
{
  uint64_t v1;
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  const void *v5;

  v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    v2 = (unint64_t *)a1[1];
    v3 = *v2;
    if (*v2)
    {
      v4 = 0;
      do
      {
        v5 = *(const void **)(v1 + 8 * v4);
        if (v5)
        {
          CFRelease(v5);
          v3 = *v2;
        }
        ++v4;
      }
      while (v4 < v3);
    }
  }
}

void std::__inplace_merge<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(CFTypeRef *a1, CFTypeRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, CFTypeRef *a6, uint64_t a7)
{
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  unint64_t v14;
  unsigned __int8 v15;
  uint64_t v16;
  unint64_t v17;
  char v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFTypeRef *v22;
  CFTypeRef *v23;
  unint64_t v24;
  CFTypeRef *v25;
  const __CFDictionary *v26;
  CFTypeRef *v27;
  CFTypeRef *v28;
  const __CFDictionary *v29;
  unint64_t v30;
  char v31;
  _BOOL4 v32;
  unint64_t v33;
  char v34;
  unint64_t v35;
  _BOOL4 v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  CFTypeRef *v41;
  const __CFDictionary *v42;
  CFTypeRef *v43;
  const __CFDictionary *v44;
  CFTypeRef *v45;
  unint64_t v46;
  char v47;
  _BOOL4 v48;
  unint64_t v49;
  char v50;
  unint64_t v51;
  _BOOL4 v52;
  CFTypeRef v53;
  CFTypeRef *v54;
  CFTypeRef *i;
  CFTypeRef *v56;
  CFTypeRef *v57;
  CFTypeRef v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  CFTypeRef *v62;
  CFTypeRef *v63;
  CFTypeRef *v64;
  CFTypeRef *v65;
  CFTypeRef *v66;
  const __CFDictionary *v67;
  unint64_t v68;
  char v69;
  unint64_t v70;
  char v71;
  unint64_t v72;
  _BOOL4 v73;
  CFTypeRef v74;
  CFTypeRef *v75;
  uint64_t v76;
  uint64_t v77;
  CFTypeRef *v78;
  CFTypeRef *v79;
  CFTypeRef *v80;
  CFTypeRef *v81;
  const __CFDictionary *v82;
  unint64_t v83;
  unsigned __int8 v84;
  uint64_t v85;
  unint64_t v86;
  char v87;
  unint64_t v88;
  CFTypeRef v89;
  CFTypeRef v90;
  uint64_t v91;
  CFTypeRef v92;
  uint64_t v93;
  CFTypeRef v94;
  const __CFDictionary *v95;
  CFTypeRef v96;
  applesauce::CF *exception;
  uint64_t v98;
  uint64_t v99;
  CFTypeRef *v100;
  CFTypeRef *v101;
  CFTypeRef *v102;
  CFTypeRef *v103;
  CFTypeRef *v104;
  uint64_t v106;
  _BOOL4 v107;
  uint64_t v108[2];
  uint64_t v109;

  v106 = a5;
  if (a5)
  {
    while (v106 > a7 && a4 > a7)
    {
      if (!a4)
        return;
      while (1)
      {
        v12 = (const __CFDictionary *)*a2;
        if (!*a2)
        {
          v96 = *a1;
          if (!*a1)
            goto LABEL_126;
          goto LABEL_125;
        }
        CFRetain(*a2);
        v13 = (const __CFDictionary *)*a1;
        if (!*a1)
          goto LABEL_122;
        CFRetain(*a1);
        v14 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v12);
        v16 = v15;
        v17 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v13);
        v19 = v18 ? v17 : -1;
        CFRelease(v13);
        CFRelease(v12);
        if (v16)
        {
          if (v14 < v19)
            break;
        }
        ++a1;
        if (!--a4)
          return;
      }
      v20 = v106;
      v104 = a3;
      if (a4 >= v106)
      {
        if (a4 == 1)
        {
          v90 = *a1;
          *a1 = 0;
          *a1 = *a2;
          *a2 = v90;
          return;
        }
        if (a4 >= 0)
          v39 = a4;
        else
          v39 = a4 + 1;
        v38 = v39 >> 1;
        v23 = &a1[v39 >> 1];
        v22 = a2;
        if (a2 != a3)
        {
          v99 = v39 >> 1;
          v101 = a1;
          v103 = a6;
          v40 = a3 - a2;
          v22 = a2;
          while (1)
          {
            v41 = &v22[v40 >> 1];
            v42 = (const __CFDictionary *)*v41;
            if (!*v41)
              break;
            v43 = v22;
            CFRetain(*v41);
            v44 = (const __CFDictionary *)*v23;
            if (!*v23)
            {
              v95 = v42;
LABEL_123:
              applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v95);
              goto LABEL_126;
            }
            v45 = v23;
            CFRetain(*v23);
            v46 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v42);
            v48 = v47 != 0;
            v49 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v44);
            if (v50)
              v51 = v49;
            else
              v51 = -1;
            v52 = v46 < v51;
            CFRelease(v44);
            CFRelease(v42);
            if (v48 && v52)
              v40 += ~(v40 >> 1);
            else
              v40 >>= 1;
            if (v48 && v52)
              v22 = v41 + 1;
            else
              v22 = v43;
            v23 = v45;
            if (!v40)
            {
              a6 = v103;
              v38 = v99;
              a1 = v101;
              goto LABEL_52;
            }
          }
          v96 = *v23;
          if (!*v23)
            goto LABEL_126;
LABEL_125:
          CFRetain(v96);
          goto LABEL_126;
        }
LABEL_52:
        v21 = v22 - a2;
      }
      else
      {
        if (v106 < 0)
          v20 = v106 + 1;
        v21 = v20 >> 1;
        v22 = &a2[v20 >> 1];
        v23 = a2;
        if (a2 != a1)
        {
          v98 = v20 >> 1;
          v100 = a1;
          v102 = a6;
          v24 = a2 - a1;
          v23 = a1;
          while (1)
          {
            v25 = &v23[v24 >> 1];
            v26 = (const __CFDictionary *)*v22;
            if (!*v22)
              break;
            v27 = v22;
            v28 = v23;
            CFRetain(*v22);
            v29 = (const __CFDictionary *)*v25;
            if (!*v25)
            {
              v95 = v26;
              goto LABEL_123;
            }
            CFRetain(*v25);
            v30 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v26);
            v32 = v31 != 0;
            v33 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v29);
            if (v34)
              v35 = v33;
            else
              v35 = -1;
            v36 = v30 < v35;
            CFRelease(v29);
            CFRelease(v26);
            v37 = !v32 || !v36;
            if (v32 && v36)
              v23 = v28;
            else
              v23 = v25 + 1;
            if (v37)
              v24 += ~(v24 >> 1);
            else
              v24 >>= 1;
            v22 = v27;
            if (!v24)
            {
              a6 = v102;
              v21 = v98;
              a1 = v100;
              goto LABEL_32;
            }
          }
          v96 = *v25;
          if (!*v25)
          {
LABEL_126:
            exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
            applesauce::CF::construct_error(exception);
          }
          goto LABEL_125;
        }
LABEL_32:
        v38 = v23 - a1;
      }
      if (v23 == a2)
      {
        v54 = v22;
      }
      else if (v22 == a2)
      {
        v54 = v23;
      }
      else
      {
        v53 = *v23;
        *v23 = 0;
        *v23 = *a2;
        v54 = v23 + 1;
        for (i = a2; ; *v54++ = *i)
        {
          *i++ = v53;
          if (i == v22)
            break;
          if (v54 == a2)
            a2 = i;
          v53 = *v54;
          *v54 = 0;
        }
        if (v54 != a2)
        {
          v56 = v54;
          v57 = a2;
          do
          {
            while (1)
            {
              v58 = *v56;
              *v56 = 0;
              *v56++ = *v57;
              *v57++ = v58;
              if (v57 == v22)
                break;
              if (v56 == a2)
                a2 = v57;
            }
            v57 = a2;
          }
          while (v56 != a2);
        }
      }
      a4 -= v38;
      v59 = v106 - v21;
      if (v38 + v21 >= a4 + v106 - v21)
      {
        std::__inplace_merge<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(v54, v22, v104, a4, v106 - v21, a6, a7);
        a2 = v23;
        v59 = v21;
        a4 = v38;
        a3 = v54;
      }
      else
      {
        std::__inplace_merge<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(a1, v23, v54, v38, v21, a6, a7);
        a1 = v54;
        a2 = v22;
        a3 = v104;
      }
      v106 = v59;
      if (!v59)
        return;
    }
    v108[0] = (uint64_t)a6;
    v108[1] = (uint64_t)&v109;
    v109 = 0;
    if (a4 <= v106)
    {
      if (a1 != a2)
      {
        v76 = 0;
        v77 = 0;
        do
        {
          a6[v76] = a1[v76];
          a1[v76] = 0;
          ++v77;
          ++v76;
        }
        while (&a1[v76] != a2);
        v78 = &a6[v76];
        v109 = v77;
        if (&a6[v76] != a6)
        {
          v79 = a2;
          while (v79 != a3)
          {
            v12 = (const __CFDictionary *)*v79;
            if (!*v79)
            {
              v96 = *a6;
              if (!*a6)
                goto LABEL_126;
              goto LABEL_125;
            }
            v80 = a3;
            v81 = v79;
            CFRetain(*v79);
            v82 = (const __CFDictionary *)*a6;
            if (!*a6)
            {
LABEL_122:
              v95 = v12;
              goto LABEL_123;
            }
            CFRetain(*a6);
            v83 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v12);
            v85 = v84;
            v86 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v82);
            if (v87)
              v88 = v86;
            else
              v88 = -1;
            CFRelease(v82);
            CFRelease(v12);
            v89 = *a1;
            if (v85 && v83 < v88)
            {
              *a1 = *v81;
              *v81++ = v89;
            }
            else
            {
              *a1 = *a6;
              *a6++ = v89;
            }
            ++a1;
            v79 = v81;
            a3 = v80;
            if (a6 == v78)
              goto LABEL_120;
          }
          v93 = 0;
          do
          {
            v94 = a1[v93];
            a1[v93] = a6[v93];
            a6[v93++] = v94;
          }
          while (&a6[v93 - 1] != v78 - 1);
        }
      }
    }
    else if (a3 != a2)
    {
      v60 = 0;
      v61 = 0;
      do
      {
        a6[v60] = a2[v60];
        a2[v60] = 0;
        ++v61;
        ++v60;
      }
      while (&a2[v60] != a3);
      v62 = a2;
      v63 = &a6[v60];
      v109 = v61;
      if (&a6[v60] != a6)
      {
        v64 = a3 - 1;
        while (v62 != a1)
        {
          v65 = v62 - 1;
          v12 = (const __CFDictionary *)*(v63 - 1);
          if (!v12)
          {
            v96 = *v65;
            if (!*v65)
              goto LABEL_126;
            goto LABEL_125;
          }
          v66 = v62;
          CFRetain(*(v63 - 1));
          v67 = (const __CFDictionary *)*v65;
          if (!*v65)
            goto LABEL_122;
          CFRetain(*v65);
          v68 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v12);
          v107 = v69 != 0;
          v70 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v67);
          if (v71)
            v72 = v70;
          else
            v72 = -1;
          v73 = v68 < v72;
          CFRelease(v67);
          CFRelease(v12);
          v74 = *v64;
          if (v107 && v73)
            v75 = v66;
          else
            v75 = v63;
          if (v107 && v73)
            v62 = v65;
          else
            v62 = v66;
          if (!v107 || !v73)
            --v63;
          *v64-- = *(v75 - 1);
          *(v75 - 1) = v74;
          if (v63 == a6)
            goto LABEL_120;
        }
        v91 = 0;
        do
        {
          v92 = v64[v91];
          v64[v91] = v63[v91 - 1];
          v63[--v91] = v92;
        }
        while (&v63[v91] != a6);
      }
    }
LABEL_120:
    std::unique_ptr<applesauce::CF::DictionaryRef,std::__destruct_n &>::reset[abi:nn180100](v108);
  }
}

void KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  const __CFDictionary *v9;
  unint64_t v10;
  char v11;
  unint64_t v12;
  unint64_t i;
  uint64_t v14;
  const __CFDictionary *v15;
  uint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  int8x8_t v19;
  unint64_t v20;
  uint8x8_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned __int8 **v24;
  unsigned __int8 *v25;
  unint64_t v26;
  const __CFDictionary *v27;
  std::string::size_type size;
  std::string *p_p;
  char **v30;
  CFTypeRef v31;
  std::string *v32;
  int data;
  int v34;
  const __CFDictionary *v36;
  CFTypeRef v37;
  NSDictionary *v38;
  NSDictionary *v39;
  float v40;
  char v41;
  char *v42;
  applesauce::CF *exception;
  CFTypeRef v44;
  CFTypeRef cf;
  NSDictionary *v46;
  std::string __p;
  void *v48[2];
  unsigned __int8 v49;

  v4 = 0;
  v5 = *(_QWORD *)(a1 + 88);
  while (1)
  {
    v6 = v4;
    v7 = v5 + v4;
    v8 = *(_QWORD *)(a1 + 24);
    if (v7 >= (*(_QWORD *)(a1 + 32) - v8) >> 3)
      break;
    v9 = *(const __CFDictionary **)(v8 + 8 * v5 + 8 * v6);
    if (!v9)
      goto LABEL_78;
    v10 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v9);
    if (v11)
      v12 = v10;
    else
      v12 = -1;
    v4 = v6 + 1;
    if (v12 > v6 + 1 + ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3))
    {
      v7 = v5 + v6;
      break;
    }
  }
  for (i = *(_QWORD *)(a1 + 88); i < v7; *(_QWORD *)(a1 + 88) = i)
  {
    v14 = *(_QWORD *)(a1 + 24);
    if (i >= (*(_QWORD *)(a1 + 32) - v14) >> 3)
      break;
    std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100]((char **)a1, *(CFTypeRef *)(v14 + 8 * i));
    i = *(_QWORD *)(a1 + 88) + 1;
  }
  v15 = (const __CFDictionary *)*a2;
  if (*a2)
  {
    CFRetain(*a2);
    extract_name((uint64_t)v48, v15);
    CFRelease(v15);
  }
  else
  {
    extract_name((uint64_t)v48, 0);
  }
  if ((v49 & 0x80u) == 0)
    v16 = (uint64_t *)v48;
  else
    v16 = (uint64_t *)v48[0];
  if ((v49 & 0x80u) == 0)
    v17 = v49;
  else
    v17 = (unint64_t)v48[1];
  v18 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v16, v17);
  v19 = *(int8x8_t *)(a1 + 56);
  if (!*(_QWORD *)&v19)
    goto LABEL_38;
  v20 = v18;
  v21 = (uint8x8_t)vcnt_s8(v19);
  v21.i16[0] = vaddlv_u8(v21);
  v22 = v21.u32[0];
  if (v21.u32[0] > 1uLL)
  {
    v23 = v18;
    if (v18 >= *(_QWORD *)&v19)
      v23 = v18 % *(_QWORD *)&v19;
  }
  else
  {
    v23 = (*(_QWORD *)&v19 - 1) & v18;
  }
  v24 = *(unsigned __int8 ***)(*(_QWORD *)(a1 + 48) + 8 * v23);
  if (!v24 || (v25 = *v24) == 0)
  {
LABEL_38:
    std::string::basic_string[abi:nn180100]<0>(&__p, "");
    v27 = 0;
    goto LABEL_39;
  }
  while (1)
  {
    v26 = *((_QWORD *)v25 + 1);
    if (v20 == v26)
      break;
    if (v22 > 1)
    {
      if (v26 >= *(_QWORD *)&v19)
        v26 %= *(_QWORD *)&v19;
    }
    else
    {
      v26 &= *(_QWORD *)&v19 - 1;
    }
    if (v26 != v23)
      goto LABEL_38;
LABEL_37:
    v25 = *(unsigned __int8 **)v25;
    if (!v25)
      goto LABEL_38;
  }
  if (!std::equal_to<std::string>::operator()[abi:nn180100](v25 + 16, (unsigned __int8 *)v48))
    goto LABEL_37;
  v42 = std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t *)(a1 + 48), (uint64_t)v48, (uint64_t)v48);
  v27 = (const __CFDictionary *)*((_QWORD *)v42 + 5);
  if (!v27)
    goto LABEL_38;
  CFRetain(*((CFTypeRef *)v42 + 5));
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&__p, v27, CFSTR("Operation"));
LABEL_39:
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (size != 6)
  {
    if (size == 8)
    {
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (p_p->__r_.__value_.__r.__words[0] == 0x656469727265764FLL)
      {
        v30 = (char **)a1;
        v31 = v27;
        goto LABEL_54;
      }
    }
LABEL_53:
    v31 = *a2;
    v30 = (char **)a1;
LABEL_54:
    std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100](v30, v31);
    goto LABEL_55;
  }
  v32 = &__p;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
  data = (int)v32->__r_.__value_.__l.__data_;
  v34 = WORD2(v32->__r_.__value_.__r.__words[0]);
  if (data != 1701602628 || v34 != 25972)
    goto LABEL_53;
  if (!v27)
    goto LABEL_78;
  cf = 0;
  applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(&v46, v27, CFSTR("Parameters"), &cf);
  if (cf)
    CFRelease(cf);
  v36 = (const __CFDictionary *)*a2;
  if (!*a2)
  {
LABEL_78:
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  v44 = 0;
  applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(&cf, v36, CFSTR("Parameters"), &v44);
  if (v44)
    CFRelease(v44);
  v37 = cf;
  v38 = v46;
  if (v46)
  {
    if (cf)
    {
      v39 = (id)cf;
      v41 = areDictionariesEqualWithPrecision(v39, v38, v40);

      if ((v41 & 1) == 0)
        std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100]((char **)a1, *a2);
      CFRelease(v39);
    }
    v37 = v38;
  }
  else if (!cf)
  {
    goto LABEL_55;
  }
  CFRelease(v37);
LABEL_55:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v27)
    CFRelease(v27);
  if ((char)v49 < 0)
    operator delete(v48[0]);
}

void sub_1DA796F14()
{
  void *v0;

}

void applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(_QWORD *a1, CFDictionaryRef theDict, void *key, _QWORD *a4)
{
  const void *Value;
  const void *v7;
  CFTypeID v8;

  if (key)
  {
    Value = CFDictionaryGetValue(theDict, key);
    if (Value)
    {
      v7 = Value;
      CFRetain(Value);
      v8 = CFGetTypeID(v7);
      if (v8 == CFDictionaryGetTypeID())
      {
        CFRetain(v7);
        *a1 = v7;
        CFRelease(v7);
        return;
      }
      CFRelease(v7);
    }
  }
  *a1 = *a4;
  *a4 = 0;
}

uint64_t areDictionariesEqualWithPrecision(NSDictionary *a1, NSDictionary *a2, float a3)
{
  NSDictionary *v4;
  NSDictionary *v5;
  uint64_t v6;
  NSDictionary *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  NSDictionary *v13;
  NSDictionary *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  v5 = a2;
  v6 = -[NSDictionary count](v4, "count");
  if (v6 == -[NSDictionary count](v5, "count"))
  {
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v7 = v4;
    v8 = -[NSDictionary countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    if (v8)
    {
      v9 = v8;
      v10 = *(_QWORD *)v22;
      while (2)
      {
        for (i = 0; i != v9; ++i)
        {
          if (*(_QWORD *)v22 != v10)
            objc_enumerationMutation(v7);
          v12 = *(_QWORD *)(*((_QWORD *)&v21 + 1) + 8 * i);
          -[NSDictionary objectForKeyedSubscript:](v7, "objectForKeyedSubscript:", v12, (_QWORD)v21);
          v13 = (NSDictionary *)objc_claimAutoreleasedReturnValue();
          -[NSDictionary objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", v12);
          v14 = (NSDictionary *)objc_claimAutoreleasedReturnValue();
          if (!v14)
          {
LABEL_22:

            v19 = 0;
            goto LABEL_24;
          }
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
          {
            if ((areDictionariesEqualWithPrecision(v13, v14, v15) & 1) == 0)
              goto LABEL_22;
          }
          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
            {
              -[NSDictionary floatValue](v13, "floatValue");
              v17 = v16;
              -[NSDictionary floatValue](v14, "floatValue");
              if (vabds_f32(v17, v18) > 0.001)
                goto LABEL_22;
            }
            else
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0 || !-[NSDictionary isEqual:](v13, "isEqual:", v14))
                goto LABEL_22;
            }
          }

        }
        v9 = -[NSDictionary countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
        v19 = 1;
        if (v9)
          continue;
        break;
      }
    }
    else
    {
      v19 = 1;
    }
LABEL_24:

  }
  else
  {
    v19 = 0;
  }

  return v19;
}

__n128 KB::CandidateFilterFactory::FilterStackDefinition::convert_filter_stack_definition_to_filters@<Q0>(KB::CandidateFilterFactory::FilterStackDefinition *this@<X0>, const KB::CandidateFilterConfiguration *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t i;
  CFTypeRef *v9;
  CFTypeRef *v10;
  CFTypeRef v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  char *v27;
  __int128 v28;
  int64x2_t v29;
  uint64_t v30;
  void *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  char *v35;
  int64x2_t *v36;
  __n128 result;
  int64x2_t v38;
  CFTypeRef v39;
  __int128 v40;
  int64x2_t v41;
  char *v42;

  v6 = *((_QWORD *)this + 11);
  v7 = *((_QWORD *)this + 3);
  for (i = *((_QWORD *)this + 4); v6 < (i - v7) >> 3; i = *((_QWORD *)this + 4))
  {
    *((_QWORD *)this + 11) = v6 + 1;
    std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100]((char **)this, *(CFTypeRef *)(v7 + 8 * v6));
    v6 = *((_QWORD *)this + 11);
    v7 = *((_QWORD *)this + 3);
  }
  v42 = 0;
  v41 = 0u;
  v9 = *(CFTypeRef **)this;
  v10 = (CFTypeRef *)*((_QWORD *)this + 1);
  if (*(CFTypeRef **)this == v10)
  {
    v35 = 0;
    v38 = 0uLL;
  }
  else
  {
    do
    {
      v11 = *v9;
      if (*v9)
      {
        CFRetain(*v9);
        v39 = v11;
        KB::CandidateFilterFactory::create_single_filter_from_specification(&v39, (uint64_t)a2, &v40);
        CFRelease(v11);
        if ((_QWORD)v40)
        {
          v12 = (_QWORD *)v41.i64[1];
          if (v41.i64[1] >= (unint64_t)v42)
          {
            v17 = (_QWORD *)v41.i64[0];
            v18 = (v41.i64[1] - v41.i64[0]) >> 4;
            v19 = v18 + 1;
            if ((unint64_t)(v18 + 1) >> 60)
              abort();
            v20 = (uint64_t)&v42[-v41.i64[0]];
            if ((uint64_t)&v42[-v41.i64[0]] >> 3 > v19)
              v19 = v20 >> 3;
            if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0)
              v21 = 0xFFFFFFFFFFFFFFFLL;
            else
              v21 = v19;
            if (v21 >> 60)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v22 = (char *)operator new(16 * v21);
            v23 = &v22[16 * v18];
            v24 = *((_QWORD *)&v40 + 1);
            *(_OWORD *)v23 = v40;
            if (v24)
            {
              v25 = (unint64_t *)(v24 + 8);
              do
                v26 = __ldxr(v25);
              while (__stxr(v26 + 1, v25));
              v12 = (_QWORD *)v41.i64[1];
            }
            if (v12 == v17)
            {
              v29 = vdupq_n_s64((unint64_t)v12);
              v27 = &v22[16 * v18];
            }
            else
            {
              v27 = &v22[16 * v18];
              do
              {
                v28 = *((_OWORD *)v12 - 1);
                v12 -= 2;
                *((_OWORD *)v27 - 1) = v28;
                v27 -= 16;
                *v12 = 0;
                v12[1] = 0;
              }
              while (v12 != v17);
              v29 = v41;
            }
            v16 = v23 + 16;
            v41.i64[0] = (uint64_t)v27;
            v41.i64[1] = (uint64_t)(v23 + 16);
            v42 = &v22[16 * v21];
            v30 = v29.i64[1];
            v31 = (void *)v29.i64[0];
            while ((void *)v30 != v31)
              v30 = std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](v30 - 16);
            if (v31)
              operator delete(v31);
          }
          else
          {
            *(_QWORD *)v41.i64[1] = v40;
            v13 = *((_QWORD *)&v40 + 1);
            v12[1] = *((_QWORD *)&v40 + 1);
            if (v13)
            {
              v14 = (unint64_t *)(v13 + 8);
              do
                v15 = __ldxr(v14);
              while (__stxr(v15 + 1, v14));
            }
            v16 = v12 + 2;
          }
          v41.i64[1] = (uint64_t)v16;
        }
        v32 = (std::__shared_weak_count *)*((_QWORD *)&v40 + 1);
        if (*((_QWORD *)&v40 + 1))
        {
          v33 = (unint64_t *)(*((_QWORD *)&v40 + 1) + 8);
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
          if (!v34)
          {
            ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
            std::__shared_weak_count::__release_weak(v32);
          }
        }
      }
      ++v9;
    }
    while (v9 != v10);
    v38 = v41;
    v35 = v42;
  }
  v36 = (int64x2_t *)operator new(0x38uLL);
  v36->i64[1] = 0;
  v36[1].i64[0] = 0;
  v36->i64[0] = (uint64_t)&off_1EA0FC7B8;
  v36[2] = v38;
  v36[3].i64[0] = (uint64_t)v35;
  a3[1] = v36;
  v36[1].i64[1] = (uint64_t)&off_1EA105D58;
  v42 = 0;
  v41 = 0uLL;
  *a3 = (char *)v36 + 24;
  *(_QWORD *)&v40 = &v41;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v40);
  return result;
}

void KB::CandidateFilterFactory::create_single_filter_from_specification(CFTypeRef *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  const __CFDictionary *v5;
  unsigned __int16 v7;
  const __CFDictionary *v9;
  NSObject *v10;
  NSObject *v11;
  void **v12;
  const char *v13;
  const char *v14;
  size_t v15;
  void **v16;
  const __CFDictionary *v17;
  NSObject *v18;
  int v19;
  NSObject *v20;
  NSObject *v21;
  void **v22;
  CFTypeRef v23;
  NSObject *v24;
  void **v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  void **v31;
  applesauce::CF *exception;
  const __CFDictionary *v33;
  CFTypeRef v34;
  CFTypeRef cf;
  void *__p[2];
  unsigned __int8 v37;
  uint8_t v38[4];
  void **v39;
  _BYTE buf[24];
  _BYTE *v41;
  unsigned __int8 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v5 = (const __CFDictionary *)*a1;
  if (!v5)
  {
    filter_factory_log();
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1DA6F2000, v10, OS_LOG_TYPE_INFO, "Single filter specification root object is null or not a dictionary.", buf, 2u);
    }

    goto LABEL_11;
  }
  v7 = applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const* const&>(v5);
  if (v7 >= 0x100u && v7 == 0)
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v9 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    extract_name((uint64_t)__p, v9);
    CFRelease(v9);
  }
  else
  {
    extract_name((uint64_t)__p, 0);
  }
  filter_factory_log();
  v11 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    v12 = __p;
    if ((v37 & 0x80u) != 0)
      v12 = (void **)__p[0];
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v12;
    _os_log_impl(&dword_1DA6F2000, v11, OS_LOG_TYPE_INFO, "Creating filter '%s'.", buf, 0xCu);
  }

  v13 = (const char *)objc_msgSend(CFSTR("CustomFilter"), "UTF8String");
  v14 = v13;
  if ((v37 & 0x80u) == 0)
    v15 = v37;
  else
    v15 = (size_t)__p[1];
  if (v15 == strlen(v13))
  {
    v16 = (v37 & 0x80u) == 0 ? __p : (void **)__p[0];
    if (!memcmp(v16, v14, v15))
    {
      v28 = *(_QWORD *)(a2 + 176);
      *a3 = *(_QWORD *)(a2 + 168);
      a3[1] = v28;
      if (v28)
      {
        v29 = (unint64_t *)(v28 + 8);
        do
          v30 = __ldxr(v29);
        while (__stxr(v30 + 1, v29));
      }
      goto LABEL_57;
    }
  }
  v17 = (const __CFDictionary *)*a1;
  if (!*a1)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  *(_QWORD *)buf = 0;
  applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(&cf, v17, CFSTR("Parameters"), buf);
  if (*(_QWORD *)buf)
    CFRelease(*(CFTypeRef *)buf);
  filter_factory_log();
  v18 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1DA6F2000, v18, OS_LOG_TYPE_INFO, "Looking for filter factory...", buf, 2u);
  }

  KB::CandidateFilterFactory::filter_factory_for_name((uint64_t)__p, (uint64_t)buf);
  v19 = v42;
  filter_factory_log();
  v20 = objc_claimAutoreleasedReturnValue();
  v21 = v20;
  if (v19)
  {
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      v22 = __p;
      if ((v37 & 0x80u) != 0)
        v22 = (void **)__p[0];
      *(_DWORD *)v38 = 136315138;
      v39 = v22;
      _os_log_impl(&dword_1DA6F2000, v21, OS_LOG_TYPE_INFO, "Found filter factory for '%s'.", v38, 0xCu);
    }

    if (v42)
    {
      v23 = cf;
      if (cf)
        CFRetain(cf);
      v34 = v23;
      if (v41)
      {
        (*(void (**)(_BYTE *, CFTypeRef *, uint64_t))(*(_QWORD *)v41 + 48))(v41, &v34, a2);
        if (v34)
          CFRelease(v34);
        if (!*a3)
        {
          filter_factory_log();
          v24 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
          {
            v25 = __p;
            if ((v37 & 0x80u) != 0)
              v25 = (void **)__p[0];
            *(_DWORD *)v38 = 136315138;
            v39 = v25;
            _os_log_impl(&dword_1DA6F2000, v24, OS_LOG_TYPE_INFO, "Skipped filter '%s' for provided specification and configuration.", v38, 0xCu);
          }

        }
        goto LABEL_49;
      }
    }
    else
    {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    std::__throw_bad_function_call[abi:nn180100]();
    applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const* const&>(v33);
    return;
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    v31 = __p;
    if ((v37 & 0x80u) != 0)
      v31 = (void **)__p[0];
    *(_DWORD *)v38 = 136315138;
    v39 = v31;
    _os_log_error_impl(&dword_1DA6F2000, v21, OS_LOG_TYPE_ERROR, "Unrecognized filter name '%s'", v38, 0xCu);
  }

  *a3 = 0;
  a3[1] = 0;
LABEL_49:
  if (!v42)
    goto LABEL_55;
  v26 = v41;
  if (v41 == buf)
  {
    v27 = 4;
    v26 = buf;
  }
  else
  {
    if (!v41)
      goto LABEL_55;
    v27 = 5;
  }
  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_55:
  if (cf)
    CFRelease(cf);
LABEL_57:
  if ((char)v37 < 0)
    operator delete(__p[0]);
}

uint64_t applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const* const&>(const __CFDictionary *a1)
{
  const __CFBoolean *Value;
  const __CFBoolean *v2;
  CFTypeID TypeID;
  _BOOL4 v4;
  int v5;
  CFTypeID v6;
  const __CFNumber *v7;
  CFNumberType v8;
  const __CFNumber *v9;
  CFNumberType v10;
  const __CFNumber *v11;
  CFNumberType v12;
  const __CFNumber *v13;
  CFNumberType v14;
  const __CFNumber *v15;
  CFNumberType v16;
  const __CFNumber *v17;
  CFNumberType v18;
  int v19;
  BOOL v20;
  int v21;
  BOOL v22;
  BOOL v23;
  double valuePtr;

  Value = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Enabled"));
  if (Value)
  {
    v2 = Value;
    TypeID = CFBooleanGetTypeID();
    if (TypeID == CFGetTypeID(v2))
    {
      v4 = CFBooleanGetValue(v2) != 0;
LABEL_42:
      v5 = 1;
      return v4 | (v5 << 8);
    }
    v6 = CFNumberGetTypeID();
    if (v6 == CFGetTypeID(v2))
    {
      switch(CFNumberGetType(v2))
      {
        case kCFNumberSInt8Type:
          LOBYTE(valuePtr) = 0;
          v7 = v2;
          v8 = kCFNumberSInt8Type;
          goto LABEL_15;
        case kCFNumberSInt16Type:
          LOWORD(valuePtr) = 0;
          v9 = v2;
          v10 = kCFNumberSInt16Type;
          goto LABEL_17;
        case kCFNumberSInt32Type:
          LODWORD(valuePtr) = 0;
          v11 = v2;
          v12 = kCFNumberSInt32Type;
          goto LABEL_19;
        case kCFNumberSInt64Type:
          valuePtr = 0.0;
          v13 = v2;
          v14 = kCFNumberSInt64Type;
          goto LABEL_30;
        case kCFNumberFloat32Type:
          LODWORD(valuePtr) = 0;
          v15 = v2;
          v16 = kCFNumberFloat32Type;
          goto LABEL_26;
        case kCFNumberFloat64Type:
          valuePtr = 0.0;
          v17 = v2;
          v18 = kCFNumberFloat64Type;
          goto LABEL_34;
        case kCFNumberCharType:
          LOBYTE(valuePtr) = 0;
          v7 = v2;
          v8 = kCFNumberCharType;
LABEL_15:
          v19 = CFNumberGetValue(v7, v8, &valuePtr);
          v20 = v19 == 0;
          v21 = LOBYTE(valuePtr);
          goto LABEL_20;
        case kCFNumberShortType:
          LOWORD(valuePtr) = 0;
          v9 = v2;
          v10 = kCFNumberShortType;
LABEL_17:
          v19 = CFNumberGetValue(v9, v10, &valuePtr);
          v20 = v19 == 0;
          v21 = LOWORD(valuePtr);
          goto LABEL_20;
        case kCFNumberIntType:
          LODWORD(valuePtr) = 0;
          v11 = v2;
          v12 = kCFNumberIntType;
LABEL_19:
          v19 = CFNumberGetValue(v11, v12, &valuePtr);
          v20 = v19 == 0;
          v21 = LODWORD(valuePtr);
LABEL_20:
          v22 = v20 || v21 == 0;
          break;
        case kCFNumberLongType:
          valuePtr = 0.0;
          v13 = v2;
          v14 = kCFNumberLongType;
          goto LABEL_30;
        case kCFNumberLongLongType:
          valuePtr = 0.0;
          v13 = v2;
          v14 = kCFNumberLongLongType;
          goto LABEL_30;
        case kCFNumberFloatType:
          LODWORD(valuePtr) = 0;
          v15 = v2;
          v16 = kCFNumberFloatType;
LABEL_26:
          v19 = CFNumberGetValue(v15, v16, &valuePtr);
          v23 = *(float *)&valuePtr == 0.0;
          goto LABEL_35;
        case kCFNumberDoubleType:
          valuePtr = 0.0;
          v17 = v2;
          v18 = kCFNumberDoubleType;
          goto LABEL_34;
        case kCFNumberCFIndexType:
          valuePtr = 0.0;
          v13 = v2;
          v14 = kCFNumberCFIndexType;
          goto LABEL_30;
        case kCFNumberNSIntegerType:
          valuePtr = 0.0;
          v13 = v2;
          v14 = kCFNumberNSIntegerType;
LABEL_30:
          v19 = CFNumberGetValue(v13, v14, &valuePtr);
          if (v19)
            v22 = *(_QWORD *)&valuePtr == 0;
          else
            v22 = 1;
          break;
        case kCFNumberCGFloatType:
          valuePtr = 0.0;
          v17 = v2;
          v18 = kCFNumberCGFloatType;
LABEL_34:
          v19 = CFNumberGetValue(v17, v18, &valuePtr);
          v23 = valuePtr == 0.0;
LABEL_35:
          v22 = v23 || v19 == 0;
          break;
        default:
          goto LABEL_8;
      }
      v4 = !v22;
      if (v19)
        goto LABEL_42;
    }
    else
    {
LABEL_8:
      v4 = 0;
    }
    v5 = 0;
    return v4 | (v5 << 8);
  }
  v5 = 0;
  v4 = 0;
  return v4 | (v5 << 8);
}

uint64_t KB::CandidateFilterFactory::filter_factory_for_name@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  _QWORD *i;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *v16;
  unint64_t v17;
  _QWORD *v19;
  uint64_t v20;
  _OWORD v21[2];
  int v22;
  _QWORD v23[3];
  _QWORD *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = KB::CandidateFilterFactory::filter_factory_lookup_table((KB::CandidateFilterFactory *)a1);
  memset(v21, 0, sizeof(v21));
  v22 = *(_DWORD *)(v4 + 32);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)v21, *(_QWORD *)(v4 + 8));
  for (i = *(_QWORD **)(v4 + 16); i; i = (_QWORD *)*i)
    std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>> const&>((uint64_t)v21, (uint64_t)(i + 2), (uint64_t)(i + 2));
  v6 = *(char *)(a1 + 23);
  if (v6 >= 0)
    v7 = (uint64_t *)a1;
  else
    v7 = *(uint64_t **)a1;
  if (v6 >= 0)
    v8 = *(unsigned __int8 *)(a1 + 23);
  else
    v8 = *(_QWORD *)(a1 + 8);
  v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  v10 = *((_QWORD *)&v21[0] + 1);
  if (!*((_QWORD *)&v21[0] + 1))
    goto LABEL_25;
  v11 = v9;
  v12 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)v21 + 8));
  v12.i16[0] = vaddlv_u8(v12);
  v13 = v12.u32[0];
  if (v12.u32[0] > 1uLL)
  {
    v14 = v9;
    if (v9 >= *((_QWORD *)&v21[0] + 1))
      v14 = v9 % *((_QWORD *)&v21[0] + 1);
  }
  else
  {
    v14 = (*((_QWORD *)&v21[0] + 1) - 1) & v9;
  }
  v15 = *(unsigned __int8 ***)(*(_QWORD *)&v21[0] + 8 * v14);
  if (!v15 || (v16 = *v15) == 0)
  {
LABEL_25:
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 32) = 0;
    return std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::~__hash_table((uint64_t)v21);
  }
  while (1)
  {
    v17 = *((_QWORD *)v16 + 1);
    if (v17 == v11)
      break;
    if (v13 > 1)
    {
      if (v17 >= v10)
        v17 %= v10;
    }
    else
    {
      v17 &= v10 - 1;
    }
    if (v17 != v14)
      goto LABEL_25;
LABEL_24:
    v16 = *(unsigned __int8 **)v16;
    if (!v16)
      goto LABEL_25;
  }
  if (!std::equal_to<std::string>::operator()[abi:nn180100](v16 + 16, (unsigned __int8 *)a1))
    goto LABEL_24;
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v23, (uint64_t)(v16 + 40));
  if (v24)
  {
    if (v24 != v23)
    {
      *(_QWORD *)(a2 + 24) = v24;
      goto LABEL_31;
    }
    *(_QWORD *)(a2 + 24) = a2;
    (*(void (**)(_QWORD *, uint64_t))(v23[0] + 24))(v23, a2);
    v19 = v24;
    *(_BYTE *)(a2 + 32) = 1;
    if (v19 == v23)
    {
      v20 = 4;
      v19 = v23;
LABEL_36:
      (*(void (**)(void))(*v19 + 8 * v20))();
    }
    else if (v19)
    {
      v20 = 5;
      goto LABEL_36;
    }
  }
  else
  {
    *(_QWORD *)(a2 + 24) = 0;
LABEL_31:
    *(_BYTE *)(a2 + 32) = 1;
  }
  return std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::~__hash_table((uint64_t)v21);
}

uint64_t KB::CandidateFilterFactory::filter_factory_lookup_table(KB::CandidateFilterFactory *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))std::unique_ptr<std::unordered_map<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>::~unique_ptr[abi:nn180100], &KB::CandidateFilterFactory::filter_factory_lookup_table(void)::lookup_table_ptr, &dword_1DA6F2000);
  }
  if (KB::CandidateFilterFactory::filter_factory_lookup_table(void)::once_token != -1)
    dispatch_once(&KB::CandidateFilterFactory::filter_factory_lookup_table(void)::once_token, &__block_literal_global_4265);
  return KB::CandidateFilterFactory::filter_factory_lookup_table(void)::lookup_table_ptr;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,0>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 24);
  v3 = *(_QWORD **)(a1 + 48);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>> const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  _QWORD *v18;
  std::string *v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  size_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;

  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (uint64_t *)a2;
  else
    v8 = *(uint64_t **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v3 = v10;
      if (v10 >= v12)
        v3 = v10 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v10;
    }
    v15 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v15)
    {
      for (i = *v15; i; i = *(unsigned __int8 **)i)
      {
        v17 = *((_QWORD *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
            return;
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12)
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3)
            break;
        }
      }
    }
  }
  v18 = operator new(0x48uLL);
  *v18 = 0;
  v18[1] = v11;
  v19 = (std::string *)(v18 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v18[4] = *(_QWORD *)(a3 + 16);
  }
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)(v18 + 5), a3 + 24);
  v20 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    v22 = 1;
    if (v12 >= 3)
      v22 = (v12 & (v12 - 1)) != 0;
    v23 = v22 | (2 * v12);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      v25 = v24;
    else
      v25 = v23;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v25);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v3 = v11 % v12;
      else
        v3 = v11;
    }
    else
    {
      v3 = (v12 - 1) & v11;
    }
  }
  v26 = *(_QWORD *)a1;
  v27 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v27)
  {
    *v18 = *v27;
LABEL_47:
    *v27 = v18;
    goto LABEL_48;
  }
  *v18 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v18;
  *(_QWORD *)(v26 + 8 * v3) = a1 + 16;
  if (*v18)
  {
    v28 = *(_QWORD *)(*v18 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12)
        v28 %= v12;
    }
    else
    {
      v28 &= v12 - 1;
    }
    v27 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    goto LABEL_47;
  }
LABEL_48:
  ++*(_QWORD *)(a1 + 24);
}

uint64_t *std::unique_ptr<std::unordered_map<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  std::unique_ptr<std::unordered_map<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>::reset[abi:nn180100](a1, 0);
  return a1;
}

void ___ZN2KB22CandidateFilterFactory27filter_factory_lookup_tableEv_block_invoke()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD v5[3];
  _QWORD v6[4];
  _QWORD v7[3];
  _QWORD v8[4];
  _QWORD v9[3];
  _QWORD v10[4];
  _QWORD v11[3];
  _QWORD v12[4];
  _QWORD v13[3];
  _QWORD v14[4];
  _QWORD v15[3];
  _QWORD v16[4];
  _QWORD v17[3];
  _QWORD v18[4];
  _QWORD v19[3];
  _QWORD v20[4];
  _QWORD v21[3];
  _QWORD v22[4];
  _QWORD v23[3];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD v26[4];
  _QWORD v27[3];
  _QWORD v28[4];
  _QWORD v29[3];
  _QWORD v30[4];
  _QWORD v31[3];
  _QWORD v32[4];
  _QWORD v33[3];
  _QWORD v34[4];
  _QWORD v35[3];
  _QWORD v36[4];
  _QWORD v37[3];
  _QWORD v38[4];
  _QWORD v39[3];
  _QWORD v40[4];
  _QWORD v41[3];
  _QWORD v42[4];
  _QWORD v43[3];
  _QWORD v44[4];
  _QWORD v45[3];
  _QWORD v46[4];
  _QWORD v47[3];
  _QWORD v48[4];
  _QWORD v49[3];
  _QWORD v50[4];
  _QWORD v51[3];
  _QWORD v52[4];
  _QWORD v53[3];
  _QWORD v54[4];
  _QWORD v55[3];
  _QWORD v56[4];
  _QWORD v57[3];
  _QWORD v58[4];
  _QWORD v59[3];
  _QWORD v60[4];
  _QWORD v61[3];
  _QWORD v62[4];
  _QWORD v63[3];
  _QWORD v64[4];
  _QWORD v65[3];
  _QWORD v66[4];
  _QWORD v67[3];
  _QWORD v68[4];
  _QWORD v69[3];
  _QWORD v70[4];
  _QWORD v71[3];
  _QWORD v72[4];
  _QWORD v73[3];
  _QWORD v74[4];
  _QWORD v75[3];
  _QWORD v76[4];
  _QWORD v77[3];
  _QWORD v78[4];
  _QWORD v79[3];
  _QWORD v80[4];
  _QWORD v81[3];
  _QWORD v82[4];
  _QWORD v83[3];
  _QWORD v84[4];
  _QWORD v85[3];
  _QWORD v86[5];

  v86[4] = *MEMORY[0x1E0C80C00];
  std::string::basic_string[abi:nn180100]<0>(v5, "FilterZeroProbability");
  v6[0] = &off_1EA0FC810;
  v6[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterZeroProbability>;
  v6[3] = v6;
  std::string::basic_string[abi:nn180100]<0>(v7, "FilterWordsConflictingWithValidContactNames");
  v8[0] = &off_1EA0FC810;
  v8[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWordsConflictingWithValidContactNames>;
  v8[3] = v8;
  std::string::basic_string[abi:nn180100]<0>(v9, "FilterAppNames");
  v10[0] = &off_1EA0FC810;
  v10[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAppNames>;
  v10[3] = v10;
  std::string::basic_string[abi:nn180100]<0>(v11, "FilterIncomplete");
  v12[0] = &off_1EA0FC810;
  v12[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterIncomplete>;
  v12[3] = v12;
  std::string::basic_string[abi:nn180100]<0>(v13, "FilterControlCharacters");
  v14[0] = &off_1EA0FC810;
  v14[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterControlCharacters>;
  v14[3] = v14;
  std::string::basic_string[abi:nn180100]<0>(v15, "FilterNotSuggestibleForInput");
  v16[0] = &off_1EA0FC810;
  v16[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>;
  v16[3] = v16;
  std::string::basic_string[abi:nn180100]<0>(v17, "FilterNumberMismatch");
  v18[0] = &off_1EA0FC810;
  v18[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNumberMismatch>;
  v18[3] = v18;
  std::string::basic_string[abi:nn180100]<0>(v19, "FilterNumberlikeTokenMismatch");
  v20[0] = &off_1EA0FC810;
  v20[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNumberlikeTokenMismatch>;
  v20[3] = v20;
  std::string::basic_string[abi:nn180100]<0>(v21, "FilterCharacterCount");
  v22[0] = &off_1EA0FC810;
  v22[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>;
  v22[3] = v22;
  std::string::basic_string[abi:nn180100]<0>(v23, "FilterAlteredURLFragments");
  v24[0] = &off_1EA0FC810;
  v24[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAlteredURLFragments>;
  v24[3] = v24;
  std::string::basic_string[abi:nn180100]<0>(v25, "FilterDoubleApostrophe");
  v26[0] = &off_1EA0FC810;
  v26[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDoubleApostrophe>;
  v26[3] = v26;
  std::string::basic_string[abi:nn180100]<0>(v27, "FilterWordEndingApostropheBetweenNonseparators");
  v28[0] = &off_1EA0FC810;
  v28[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWordEndingApostropheBetweenNonseparators>;
  v28[3] = v28;
  std::string::basic_string[abi:nn180100]<0>(v29, "FilterPopupVariantMismatch");
  v30[0] = &off_1EA0FC810;
  v30[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterPopupVariantMismatch>;
  v30[3] = v30;
  std::string::basic_string[abi:nn180100]<0>(v31, "FilterAllCapsNoSuggestWordsOfLength");
  v32[0] = &off_1EA0FC810;
  v32[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAllCapsNoSuggestWordsOfLength>;
  v32[3] = v32;
  std::string::basic_string[abi:nn180100]<0>(v33, "FilterMissingOneLetterWordFromInput");
  v34[0] = &off_1EA0FC810;
  v34[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterMissingOneLetterWordFromInput>;
  v34[3] = v34;
  std::string::basic_string[abi:nn180100]<0>(v35, "FilterCorrectionsIfAnyCandidateMatchesInput");
  v36[0] = &off_1EA0FC810;
  v36[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCorrectionsIfAnyCandidateMatchesInput>;
  v36[3] = v36;
  std::string::basic_string[abi:nn180100]<0>(v37, "FilterNondominantCorrectionOfMoreWords");
  v38[0] = &off_1EA0FC810;
  v38[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNondominantCorrectionOfMoreWords>;
  v38[3] = v38;
  std::string::basic_string[abi:nn180100]<0>(v39, "FilterInputPrefixMismatch");
  v40[0] = &off_1EA0FC810;
  v40[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterInputPrefixMismatch>;
  v40[3] = v40;
  std::string::basic_string[abi:nn180100]<0>(v41, "BoostPreferedFormForSortkey");
  v42[0] = &off_1EA0FC810;
  v42[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostPreferedFormForSortkey>;
  v42[3] = v42;
  std::string::basic_string[abi:nn180100]<0>(v43, "BoostMinimumVariation");
  v44[0] = &off_1EA0FC810;
  v44[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostMinimumVariation>;
  v44[3] = v44;
  std::string::basic_string[abi:nn180100]<0>(v45, "BoostCaseVariantsOfTopCandidate");
  v46[0] = &off_1EA0FC810;
  v46[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostCaseVariantsOfTopCandidate>;
  v46[3] = v46;
  std::string::basic_string[abi:nn180100]<0>(v47, "ExemptHighFrequencyWordsFromNoSuggest");
  v48[0] = &off_1EA0FC810;
  v48[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::ExemptHighFrequencyWordsFromNoSuggest>;
  v48[3] = v48;
  std::string::basic_string[abi:nn180100]<0>(v49, "RescoreShortWords");
  v50[0] = &off_1EA0FC810;
  v50[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::RescoreShortWords>;
  v50[3] = v50;
  std::string::basic_string[abi:nn180100]<0>(v51, "FilterLearnedTypo");
  v52[0] = &off_1EA0FC810;
  v52[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterLearnedTypo>;
  v52[3] = v52;
  std::string::basic_string[abi:nn180100]<0>(v53, "FilterTopDynamicWordsWithStaticVariant");
  v54[0] = &off_1EA0FC810;
  v54[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterTopDynamicWordsWithStaticVariant>;
  v54[3] = v54;
  std::string::basic_string[abi:nn180100]<0>(v55, "FilterInvalidTextReplacement");
  v56[0] = &off_1EA0FC810;
  v56[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterInvalidTextReplacement>;
  v56[3] = v56;
  std::string::basic_string[abi:nn180100]<0>(v57, "FilterContactWordsConflictingWithValidInput");
  v58[0] = &off_1EA0FC810;
  v58[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterContactWordsConflictingWithValidInput>;
  v58[3] = v58;
  std::string::basic_string[abi:nn180100]<0>(v59, "FilterWithoutSupplementalWords");
  v60[0] = &off_1EA0FC810;
  v60[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWithoutSupplementalWords>;
  v60[3] = v60;
  std::string::basic_string[abi:nn180100]<0>(v61, "FilterPartOfHyphenatedWord");
  v62[0] = &off_1EA0FC810;
  v62[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterPartOfHyphenatedWord>;
  v62[3] = v62;
  std::string::basic_string[abi:nn180100]<0>(v63, "FilterLowQualityContinuousPathRetrocorrections");
  v64[0] = &off_1EA0FC810;
  v64[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterLowQualityContinuousPathRetrocorrections>;
  v64[3] = v64;
  std::string::basic_string[abi:nn180100]<0>(v65, "FilterNoPredictContinuousPathAlternates");
  v66[0] = &off_1EA0FC810;
  v66[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNoPredictContinuousPathAlternates>;
  v66[3] = v66;
  std::string::basic_string[abi:nn180100]<0>(v67, "FilterContinuousPathAlternatesFromOtherLanguage");
  v68[0] = &off_1EA0FC810;
  v68[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterContinuousPathAlternatesFromOtherLanguage>;
  v68[3] = v68;
  std::string::basic_string[abi:nn180100]<0>(v69, "FilterSortkeyMatchFromDifferentLanguage");
  v70[0] = &off_1EA0FC810;
  v70[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterSortkeyMatchFromDifferentLanguage>;
  v70[3] = v70;
  std::string::basic_string[abi:nn180100]<0>(v71, "FilterDifferentLanguageThanContext");
  v72[0] = &off_1EA0FC810;
  v72[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDifferentLanguageThanContext>;
  v72[3] = v72;
  std::string::basic_string[abi:nn180100]<0>(v73, "ChooseTopQualityAutocorrection");
  v74[0] = &off_1EA0FC810;
  v74[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::ChooseTopQualityAutocorrection>;
  v74[3] = v74;
  std::string::basic_string[abi:nn180100]<0>(v75, "RemoveAlternatesIfNoLinguisticCandidate");
  v76[0] = &off_1EA0FC810;
  v76[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::RemoveAlternatesIfNoLinguisticCandidate>;
  v76[3] = v76;
  std::string::basic_string[abi:nn180100]<0>(v77, "FilterCommonLearnedTypos");
  v78[0] = &off_1EA0FC810;
  v78[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCommonLearnedTypos>;
  v78[3] = v78;
  std::string::basic_string[abi:nn180100]<0>(v79, "FilterNonVulgarIfTopCandidateVulgar");
  v80[0] = &off_1EA0FC810;
  v80[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNonVulgarIfTopCandidateVulgar>;
  v80[3] = v80;
  std::string::basic_string[abi:nn180100]<0>(v81, "AddAlternativesForRetrocorrection");
  v82[0] = &off_1EA0FC810;
  v82[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::AddAlternativesForRetrocorrection>;
  v82[3] = v82;
  std::string::basic_string[abi:nn180100]<0>(v83, "FilterDuplicates");
  v84[0] = &off_1EA0FC810;
  v84[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDuplicates>;
  v84[3] = v84;
  std::string::basic_string[abi:nn180100]<0>(v85, "FilterCaseVariantsOfStaticWords");
  v86[0] = &off_1EA0FC810;
  v86[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCaseVariantsOfStaticWords>;
  v86[3] = v86;
  v0 = operator new();
  v1 = 0;
  *(_OWORD *)v0 = 0u;
  *(_OWORD *)(v0 + 16) = 0u;
  *(_DWORD *)(v0 + 32) = 1065353216;
  do
  {
    std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>> const&>(v0, (uint64_t)&v5[v1], (uint64_t)&v5[v1]);
    v1 += 7;
  }
  while (v1 != 287);
  std::unique_ptr<std::unordered_map<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>::reset[abi:nn180100](&KB::CandidateFilterFactory::filter_factory_lookup_table(void)::lookup_table_ptr, v0);
  v2 = 287;
  do
  {
    v3 = (_QWORD *)v5[v2 - 1];
    if (&v5[v2 - 4] == v3)
    {
      v3 = &v5[v2 - 4];
      v4 = 4;
    }
    else
    {
      if (!v3)
        goto LABEL_9;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_9:
    if (*((char *)&v5[v2 - 4] - 1) < 0)
      operator delete((void *)v5[v2 - 7]);
    v2 -= 7;
  }
  while (v2 * 8);
}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterZeroProbability>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterZeroProbability";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCDA8;
  a2[1] = v6;
  v6[3] = &off_1EA0FDBD0;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA7989C0()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWordsConflictingWithValidContactNames>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  _QWORD *v8;
  const __CFDictionary *v9;
  applesauce::CF *exception;
  int v11;
  CFIndex Count;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v11 = 134217984;
      Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterWordsConflictingWithValidContactNames factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_float_for_key(v6, CFSTR("LanguagePowerRatio"), 0.0, 1.0);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_float_for_key(0, CFSTR("LanguagePowerRatio"), 0.0, 1.0);
  }
  if (HIDWORD(v7))
  {
    v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    *v8 = &off_1EA0FCD40;
    *((_DWORD *)v8 + 8) = v7;
    a2[1] = v8;
    v8[3] = &unk_1EA0FCD78;
    *a2 = v8 + 3;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA798B4C()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAppNames>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterAppNames";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCE10;
  a2[1] = v6;
  v6[3] = &off_1EA0FCDE0;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA798C80()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterIncomplete>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterIncomplete";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCE48;
  a2[1] = v6;
  v6[3] = &off_1EA0FDC00;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA798DB4()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterControlCharacters>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterControlCharacters";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCE80;
  a2[1] = v6;
  v6[3] = &off_1EA0FDC30;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA798EE8()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(CFDictionaryRef *a1@<X0>, unsigned int *a2@<X1>, _QWORD *a3@<X8>)
{
  const __CFDictionary *v6;
  NSObject *v7;
  unsigned __int8 v8;
  const char *v9;
  const char *v10;
  size_t v11;
  std::string *v12;
  const char *v13;
  const char *v14;
  size_t v15;
  std::string *v16;
  const char *v17;
  const char *v18;
  std::string::size_type size;
  std::string *v20;
  NSObject *v21;
  int v22;
  unsigned __int8 v23;
  const char *v24;
  const char *v25;
  size_t v26;
  std::string *v27;
  const char *v28;
  const char *v29;
  std::string::size_type v30;
  std::string *v31;
  NSObject *v32;
  int v33;
  unsigned __int8 v34;
  uint64_t *v35;
  std::string *v36;
  const char *v37;
  const char *v38;
  char v39;
  std::string::size_type v40;
  std::string *v41;
  const char *v42;
  const char *v43;
  std::string *v44;
  NSObject *v45;
  const __CFDictionary *v46;
  std::string *v47;
  std::string *p_buf;
  int v49;
  uint64_t v50;
  char *v51;
  _QWORD *v52;
  _QWORD *v53;
  std::string *p_p;
  std::string *v55;
  _BYTE *v56;
  std::string *v57;
  applesauce::CF *exception;
  std::string v59;
  _BYTE v60[12];
  __int16 v61;
  std::string *v62;
  char v63;
  uint8_t v64[4];
  _BYTE *v65;
  __int16 v66;
  std::string *v67;
  std::string __p;
  std::string buf;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  if (!v6 || CFDictionaryGetCount(v6) != 3)
  {
    filter_factory_log();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v46 = *a1;
      if (!*a1)
        goto LABEL_117;
      LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = CFDictionaryGetCount(v46);
      _os_log_error_impl(&dword_1DA6F2000, v7, OS_LOG_TYPE_ERROR, "FilterNotSuggestibleForInput factory expects 3 parameters, but specification includes %ld", (uint8_t *)&buf, 0xCu);
    }

  }
  if ((v8 & 1) == 0
  {
    KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::should_remove_vulgar = (uint64_t)CFSTR("ShouldRemoveVulgar");
  }
  if (!*a1)
    goto LABEL_117;
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&buf, *a1, (void *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::should_remove_vulgar);
  v9 = (const char *)objc_msgSend(CFSTR("RemoveVulgar"), "UTF8String");
  v10 = v9;
  v11 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? HIBYTE(buf.__r_.__value_.__r.__words[2])
      : buf.__r_.__value_.__l.__size_;
  if (v11 == strlen(v9)
    && ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (v12 = &buf)
      : (v12 = (std::string *)buf.__r_.__value_.__r.__words[0]),
        !memcmp(v12, v10, v11)))
  {
    v22 = 0;
  }
  else
  {
    v13 = (const char *)objc_msgSend(CFSTR("RemoveVulgarOnlyIfNotAllowlisted"), "UTF8String");
    v14 = v13;
    v15 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? HIBYTE(buf.__r_.__value_.__r.__words[2])
        : buf.__r_.__value_.__l.__size_;
    if (v15 == strlen(v13)
      && ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (v16 = &buf)
        : (v16 = (std::string *)buf.__r_.__value_.__r.__words[0]),
          !memcmp(v16, v14, v15)))
    {
      v22 = 1;
    }
    else
    {
      v17 = (const char *)objc_msgSend(CFSTR("DoNotRemoveVulgar"), "UTF8String");
      v18 = v17;
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      else
        size = buf.__r_.__value_.__l.__size_;
      if (size != strlen(v17)
        || ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? (v20 = &buf)
          : (v20 = (std::string *)buf.__r_.__value_.__r.__words[0]),
            memcmp(v20, v18, size)))
      {
        filter_factory_log();
        v21 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::should_remove_vulgar, &v59);
          if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v47 = &v59;
          else
            v47 = (std::string *)v59.__r_.__value_.__r.__words[0];
          p_buf = &buf;
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
          LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v47;
          WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_buf;
          _os_log_error_impl(&dword_1DA6F2000, v21, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or has unrecognized value '%s'", (uint8_t *)&__p, 0x16u);
          if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v59.__r_.__value_.__l.__data_);
        }

        *a3 = 0;
        a3[1] = 0;
        goto LABEL_81;
      }
      v22 = 2;
    }
  }
  if ((v23 & 1) == 0
  {
    KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::word_equivalence_type_key = (uint64_t)CFSTR("WordEquivalenceType");
  }
  if (!*a1)
    goto LABEL_117;
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&v59, *a1, (void *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::word_equivalence_type_key);
  v24 = (const char *)objc_msgSend(CFSTR("SortkeyEquivalence"), "UTF8String");
  v25 = v24;
  v26 = (v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? HIBYTE(v59.__r_.__value_.__r.__words[2])
      : v59.__r_.__value_.__l.__size_;
  if (v26 == strlen(v24)
    && ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (v27 = &v59)
      : (v27 = (std::string *)v59.__r_.__value_.__r.__words[0]),
        !memcmp(v27, v25, v26)))
  {
    v33 = 0;
  }
  else
  {
    v28 = (const char *)objc_msgSend(CFSTR("SurfaceFormEquivalence"), "UTF8String");
    v29 = v28;
    if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v30 = HIBYTE(v59.__r_.__value_.__r.__words[2]);
    else
      v30 = v59.__r_.__value_.__l.__size_;
    if (v30 != strlen(v28)
      || ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (v31 = &v59)
        : (v31 = (std::string *)v59.__r_.__value_.__r.__words[0]),
          memcmp(v31, v29, v30)))
    {
      filter_factory_log();
      v32 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::word_equivalence_type_key, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        v55 = &v59;
        if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v55 = (std::string *)v59.__r_.__value_.__r.__words[0];
        *(_DWORD *)v60 = 136315394;
        *(_QWORD *)&v60[4] = p_p;
        v61 = 2080;
        v62 = v55;
        _os_log_error_impl(&dword_1DA6F2000, v32, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or has unrecognized value '%s'", v60, 0x16u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }

      *a3 = 0;
      a3[1] = 0;
      goto LABEL_79;
    }
    v33 = 1;
  }
  if ((v34 & 1) == 0
  {
    KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::apply_filter_condition_key = (uint64_t)CFSTR("ApplyFilterCondition");
  }
  if (!*a1)
  {
LABEL_117:
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  v35 = &+[TILanguageModelLoaderManager recipientRecords]::__recipientRecords;
  v36 = &__p;
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&__p, *a1, (void *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::apply_filter_condition_key);
  v37 = (const char *)objc_msgSend(CFSTR("ApplyAlways"), "UTF8String");
  v38 = v37;
  v39 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v40 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v40 = __p.__r_.__value_.__l.__size_;
  if (v40 == strlen(v37)
    && ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (v41 = &__p)
      : (v41 = (std::string *)__p.__r_.__value_.__r.__words[0]),
        !memcmp(v41, v38, v40)))
  {
    v49 = 0;
  }
  else
  {
    v42 = (const char *)objc_msgSend(CFSTR("ApplyIfCandidatesContainInputMatch"), "UTF8String");
    v43 = v42;
    v39 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v40 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      v40 = __p.__r_.__value_.__l.__size_;
    if (v40 != strlen(v42)
      || ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (v44 = &__p)
        : (v44 = (std::string *)__p.__r_.__value_.__r.__words[0]),
          memcmp(v44, v43, v40)))
    {
      filter_factory_log();
      v45 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::apply_filter_condition_key, v60);
        if (v63 >= 0)
          v56 = v60;
        else
          v56 = *(_BYTE **)v60;
        v57 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v57 = (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)v64 = 136315394;
        v65 = v56;
        v66 = 2080;
        v67 = v57;
        _os_log_error_impl(&dword_1DA6F2000, v45, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or has unrecognized value '%s'", v64, 0x16u);
        if (v63 < 0)
          operator delete(*(void **)v60);
      }

      *a3 = 0;
      a3[1] = 0;
      if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) == 0)
        goto LABEL_79;
      goto LABEL_78;
    }
    v49 = 1;
  }
  v50 = *a2;
  if (*((_BYTE *)a2 + 184))
  {
    if (v50 >= 7)
      goto LABEL_101;
    v51 = (char *)&unk_1DA90FA08 + 4 * v50;
    LODWORD(a2) = dword_1DA90FA24[v50];
    v52 = &unk_1DA90FA60;
  }
  else
  {
    if (v50 >= 7)
      goto LABEL_101;
    v51 = (char *)&unk_1DA90F9B0 + 4 * v50;
    LODWORD(a2) = 402653186;
    v52 = &unk_1DA90F9D0;
  }
  LODWORD(v36) = *(_DWORD *)v51;
  LODWORD(v40) = dword_1DA90FA40[(int)v50];
  v35 = (uint64_t *)v52[(int)v50];
LABEL_101:
  v53 = operator new(0x48uLL);
  v53[1] = 0;
  v53[2] = 0;
  *v53 = &off_1EA0FC960;
  *((_DWORD *)v53 + 8) = (_DWORD)v36;
  *((_DWORD *)v53 + 9) = 0;
  *((_DWORD *)v53 + 10) = (_DWORD)a2;
  *((_DWORD *)v53 + 11) = v40;
  v53[6] = v35;
  *((_DWORD *)v53 + 14) = v33;
  *((_DWORD *)v53 + 15) = v49;
  *((_DWORD *)v53 + 16) = v22;
  a3[1] = v53;
  v53[3] = &off_1EA0FDC60;
  *a3 = v53 + 3;
  if (v39 < 0)
LABEL_78:
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_79:
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v59.__r_.__value_.__l.__data_);
LABEL_81:
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    operator delete(buf.__r_.__value_.__l.__data_);
}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNumberMismatch>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterNumberMismatch";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCEB8;
  a2[1] = v6;
  v6[3] = &off_1EA0FDCC0;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA799784()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNumberlikeTokenMismatch>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterNumberlikeTokenMismatch";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCEF0;
  a2[1] = v6;
  v6[3] = &off_1EA0FDCF0;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA7998B8()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(CFDictionaryRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  unsigned __int8 v6;
  std::string::size_type size;
  std::string *v8;
  unsigned int v9;
  int v10;
  NSObject *v11;
  void *v12;
  std::string::value_type *v13;
  int v14;
  unsigned __int8 v15;
  const char *v16;
  const char *v17;
  char v18;
  std::string::size_type v19;
  std::string *v20;
  const char *v21;
  const char *v22;
  std::string::size_type v23;
  std::string *v24;
  const char *v25;
  const char *v26;
  std::string::size_type v27;
  std::string *v28;
  const char *v29;
  const char *v30;
  std::string::size_type v31;
  std::string *v32;
  const char *v33;
  const char *v34;
  std::string::size_type v35;
  std::string *v36;
  const char *v37;
  const char *v38;
  std::string::size_type v39;
  std::string *v40;
  NSObject *v41;
  NSObject *v42;
  int v43;
  _QWORD *v44;
  const __CFDictionary *v45;
  std::string *v46;
  _BYTE *v47;
  std::string *v48;
  _BYTE *v49;
  std::string *p_p;
  applesauce::CF *exception;
  std::string v52;
  uint8_t v53[4];
  _BYTE *v54;
  __int16 v55;
  std::string *v56;
  std::string __p;
  _BYTE buf[12];
  int data_low;
  int v60;
  char v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (!v4 || CFDictionaryGetCount(v4) != 2)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v45 = *a1;
      if (!*a1)
        goto LABEL_112;
      LODWORD(__p.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = CFDictionaryGetCount(v45);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterCharacterCount factory expects 2 parameters, but specification includes %ld", (uint8_t *)&__p, 0xCu);
    }

  }
  if ((v6 & 1) == 0
  {
    KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::character_key = (uint64_t)CFSTR("Character");
  }
  if (!*a1)
  {
LABEL_112:
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&v52, *a1, (void *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::character_key);
  if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    size = HIBYTE(v52.__r_.__value_.__r.__words[2]);
    if (*((_BYTE *)&v52.__r_.__value_.__s + 23))
    {
      v8 = &v52;
      goto LABEL_12;
    }
LABEL_78:
    filter_factory_log();
    v42 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::character_key, &__p);
      v46 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v46;
      _os_log_error_impl(&dword_1DA6F2000, v42, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or is not a UTF-8 string", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    *a2 = 0;
    a2[1] = 0;
    goto LABEL_88;
  }
  size = v52.__r_.__value_.__l.__size_;
  if (!v52.__r_.__value_.__l.__size_)
    goto LABEL_78;
  v8 = (std::string *)v52.__r_.__value_.__r.__words[0];
LABEL_12:
  if (size >= 0xFFFF)
    v9 = 0xFFFF;
  else
    v9 = size;
  KB::String::String((KB::String *)&__p, (const char *)v8, v9);
  v10 = WORD2(__p.__r_.__value_.__r.__words[0]);
  if (!WORD2(__p.__r_.__value_.__r.__words[0]))
  {
    KB::String::compute_length((unsigned __int16 *)&__p);
    v10 = WORD2(__p.__r_.__value_.__r.__words[0]);
  }
  if (v10 != 1)
  {
    filter_factory_log();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::character_key, buf);
      if (v61 >= 0)
        v47 = buf;
      else
        v47 = *(_BYTE **)buf;
      v48 = &v52;
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v48 = (std::string *)v52.__r_.__value_.__r.__words[0];
      *(_DWORD *)v53 = 136315394;
      v54 = v47;
      v55 = 2080;
      v56 = v48;
      _os_log_error_impl(&dword_1DA6F2000, v11, OS_LOG_TYPE_ERROR, "String for key '%s' has more than one code point (string='%s')", v53, 0x16u);
      if (v61 < 0)
        operator delete(*(void **)buf);
    }

  }
  v12 = (void *)__p.__r_.__value_.__l.__size_;
  v13 = &__p.__r_.__value_.__s.__data_[16];
  if (__p.__r_.__value_.__l.__size_)
    v13 = (std::string::value_type *)__p.__r_.__value_.__l.__size_;
  *(_QWORD *)buf = v13;
  *(_DWORD *)&buf[8] = 0;
  data_low = LOWORD(__p.__r_.__value_.__l.__data_);
  v60 = 0;
  KB::String::iterator::initialize((uint64_t *)buf);
  v14 = v60;
  if (v12 && __p.__r_.__value_.__s.__data_[6] == 1)
    free(v12);
  if ((v15 & 1) == 0
  {
    KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::count_relation_key = (uint64_t)CFSTR("CharacterCountRelation");
  }
  if (!*a1)
    goto LABEL_112;
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&__p, *a1, (void *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::count_relation_key);
  v16 = (const char *)objc_msgSend(CFSTR("LessThanInputCount"), "UTF8String");
  v17 = v16;
  v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v19 = __p.__r_.__value_.__l.__size_;
  if (v19 == strlen(v16))
  {
    v20 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v20, v17, v19))
    {
      v43 = 0;
      goto LABEL_86;
    }
  }
  v21 = (const char *)objc_msgSend(CFSTR("LessThanOrEqualToInputCount"), "UTF8String");
  v22 = v21;
  v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v23 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v23 = __p.__r_.__value_.__l.__size_;
  if (v23 == strlen(v21))
  {
    v24 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v24, v22, v23))
    {
      v43 = 1;
      goto LABEL_86;
    }
  }
  v25 = (const char *)objc_msgSend(CFSTR("EqualToInputCount"), "UTF8String");
  v26 = v25;
  v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v27 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v27 = __p.__r_.__value_.__l.__size_;
  if (v27 == strlen(v25))
  {
    v28 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v28, v26, v27))
    {
      v43 = 2;
      goto LABEL_86;
    }
  }
  v29 = (const char *)objc_msgSend(CFSTR("NotEqualToInputCount"), "UTF8String");
  v30 = v29;
  v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v31 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v31 = __p.__r_.__value_.__l.__size_;
  if (v31 == strlen(v29))
  {
    v32 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v32, v30, v31))
    {
      v43 = 3;
      goto LABEL_86;
    }
  }
  v33 = (const char *)objc_msgSend(CFSTR("GreaterThanOrEqualToInputCount"), "UTF8String");
  v34 = v33;
  v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v35 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v35 = __p.__r_.__value_.__l.__size_;
  if (v35 == strlen(v33))
  {
    v36 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v36, v34, v35))
    {
      v43 = 4;
      goto LABEL_86;
    }
  }
  v37 = (const char *)objc_msgSend(CFSTR("GreaterThanInputCount"), "UTF8String");
  v38 = v37;
  v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v39 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v39 = __p.__r_.__value_.__l.__size_;
  if (v39 == strlen(v37))
  {
    v40 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v40, v38, v39))
    {
      v43 = 5;
LABEL_86:
      v44 = operator new(0x28uLL);
      v44[1] = 0;
      v44[2] = 0;
      *v44 = &off_1EA0FC9D0;
      *((_DWORD *)v44 + 8) = v14;
      *((_DWORD *)v44 + 9) = v43;
      a2[1] = v44;
      v44[3] = &off_1EA0FDD20;
      *a2 = v44 + 3;
      if ((v18 & 0x80) == 0)
        goto LABEL_88;
      goto LABEL_87;
    }
  }
  filter_factory_log();
  v41 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
  {
    KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::count_relation_key, buf);
    if (v61 >= 0)
      v49 = buf;
    else
      v49 = *(_BYTE **)buf;
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)v53 = 136315394;
    v54 = v49;
    v55 = 2080;
    v56 = p_p;
    _os_log_error_impl(&dword_1DA6F2000, v41, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or has unrecognized value '%s'", v53, 0x16u);
    if (v61 < 0)
      operator delete(*(void **)buf);
  }

  *a2 = 0;
  a2[1] = 0;
  if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
LABEL_87:
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_88:
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v52.__r_.__value_.__l.__data_);
}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAlteredURLFragments>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterAlteredURLFragments";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCF28;
  a2[1] = v6;
  v6[3] = &off_1EA0FDD50;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79A07C()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDoubleApostrophe>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterDoubleApostrophe";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCF60;
  a2[1] = v6;
  v6[3] = &off_1EA0FDD80;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79A1B0()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWordEndingApostropheBetweenNonseparators>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterWordEndingApostropheBetweenNonseparators";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCF98;
  a2[1] = v6;
  v6[3] = &off_1EA0FDDB0;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79A2E4()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterPopupVariantMismatch>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterPopupVariantMismatch";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCFD0;
  a2[1] = v6;
  v6[3] = &unk_1EA0FDDE0;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79A418()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAllCapsNoSuggestWordsOfLength>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  _QWORD *v8;
  const __CFDictionary *v9;
  applesauce::CF *exception;
  int v11;
  CFIndex Count;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v11 = 134217984;
      Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterAllCapsNoSuggestWordsOfLength factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_integer_for_key(v6, CFSTR("Length"), 1, 0xFFFF);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_integer_for_key(0, CFSTR("Length"), 1, 0xFFFF);
  }
  if (HIDWORD(v7))
  {
    v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    *v8 = &off_1EA0FCA08;
    *((_DWORD *)v8 + 8) = v7;
    a2[1] = v8;
    v8[3] = &off_1EA0FDE10;
    *a2 = v8 + 3;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA79A5A4()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterMissingOneLetterWordFromInput>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterMissingOneLetterWordFromInput";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FD008;
  a2[1] = v6;
  v6[3] = &off_1EA0FDE40;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79A6D8()
{
  void *v0;

}

char *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCorrectionsIfAnyCandidateMatchesInput>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  unint64_t v6;
  int v7;
  unint64_t v8;
  _QWORD *v9;
  char *result;

  v4 = *a1;
  if (!v4)
    goto LABEL_8;
  if (CFDictionaryGetCount(v4) != 1)
  {
    v7 = 0x7FFFFFFF;
    goto LABEL_12;
  }
  v5 = *a1;
  if (v5)
  {
    CFRetain(v5);
    v6 = bounded_integer_for_key(v5, CFSTR("WithinTopXAutocorrectionCandidates"), 1, 0x7FFFFFFF);
    if (HIDWORD(v6))
      v7 = v6;
    else
      v7 = 0x7FFFFFFF;
    CFRelease(v5);
  }
  else
  {
LABEL_8:
    v8 = bounded_integer_for_key(0, CFSTR("WithinTopXAutocorrectionCandidates"), 1, 0x7FFFFFFF);
    if (HIDWORD(v8))
      v7 = v8;
    else
      v7 = 0x7FFFFFFF;
  }
LABEL_12:
  v9 = operator new(0x28uLL);
  v9[1] = 0;
  v9[2] = 0;
  *v9 = &off_1EA0FC858;
  *((_DWORD *)v9 + 8) = v7;
  a2[1] = v9;
  v9[3] = &unk_1EA0FDE70;
  result = (char *)(v9 + 3);
  *a2 = result;
  return result;
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNondominantCorrectionOfMoreWords>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  const __CFDictionary *v8;
  unint64_t v9;
  _QWORD *v10;
  const __CFDictionary *v11;
  applesauce::CF *exception;
  int v13;
  CFIndex Count;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 2)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v11 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v13 = 134217984;
      Count = CFDictionaryGetCount(v11);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterNondominantCorrectionOfMoreWords factory expects 2 parameters, but specification includes %ld", (uint8_t *)&v13, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_float_for_key(v6, CFSTR("SortKeyMatchBoostRatio"), 1.0, INFINITY);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_float_for_key(0, CFSTR("SortKeyMatchBoostRatio"), 1.0, INFINITY);
  }
  if (!HIDWORD(v7))
    goto LABEL_13;
  v8 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v9 = bounded_float_for_key(v8, CFSTR("NonRetrocorrectionBoostRatio"), 1.0, INFINITY);
    CFRelease(v8);
  }
  else
  {
    v9 = bounded_float_for_key(0, CFSTR("NonRetrocorrectionBoostRatio"), 1.0, INFINITY);
  }
  if (HIDWORD(v9))
  {
    v10 = operator new(0x28uLL);
    v10[1] = 0;
    v10[2] = 0;
    *v10 = &off_1EA0FCA40;
    *((_DWORD *)v10 + 8) = v7;
    *((_DWORD *)v10 + 9) = v9;
    a2[1] = v10;
    v10[3] = &off_1EA0FDEA0;
    *a2 = v10 + 3;
  }
  else
  {
LABEL_13:
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA79A9B0()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterInputPrefixMismatch>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  const __CFDictionary *v8;
  unint64_t v9;
  _QWORD *v10;
  const __CFDictionary *v11;
  applesauce::CF *exception;
  int v13;
  CFIndex Count;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 2)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v11 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v13 = 134217984;
      Count = CFDictionaryGetCount(v11);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterInputPrefixMismatch factory expects 2 parameters, but specification includes %ld", (uint8_t *)&v13, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_integer_for_key(v6, CFSTR("MinPrefixMatchLen"), 0, 0xFFFF);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_integer_for_key(0, CFSTR("MinPrefixMatchLen"), 0, 0xFFFF);
  }
  if (!HIDWORD(v7))
    goto LABEL_13;
  v8 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v9 = bounded_integer_for_key(v8, CFSTR("MinTargetCandidates"), 0, 0xFFFF);
    CFRelease(v8);
  }
  else
  {
    v9 = bounded_integer_for_key(0, CFSTR("MinTargetCandidates"), 0, 0xFFFF);
  }
  if (HIDWORD(v9))
  {
    v10 = operator new(0x30uLL);
    v10[1] = 0;
    v10[2] = 0;
    *v10 = &off_1EA0FCA78;
    *((_DWORD *)v10 + 8) = v7;
    v10[5] = (int)v9;
    a2[1] = v10;
    v10[3] = &off_1EA0FDED0;
    *a2 = v10 + 3;
  }
  else
  {
LABEL_13:
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA79ABA0()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostPreferedFormForSortkey>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  _QWORD *v8;
  const __CFDictionary *v9;
  applesauce::CF *exception;
  int v11;
  CFIndex Count;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v11 = 134217984;
      Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "BoostPreferedFormForSortkey factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_float_for_key(v6, CFSTR("MinSuggestionDominanceRatio"), 1.0, INFINITY);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_float_for_key(0, CFSTR("MinSuggestionDominanceRatio"), 1.0, INFINITY);
  }
  if (HIDWORD(v7))
  {
    v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    *v8 = &off_1EA0FCAB0;
    *((_DWORD *)v8 + 8) = v7;
    a2[1] = v8;
    v8[3] = &off_1EA1012C8;
    *a2 = v8 + 3;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA79AD34()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostMinimumVariation>(CFTypeRef *a1@<X0>, unsigned int *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  int v4;
  const __CFDictionary *v8;
  NSObject *v9;
  const __CFDictionary *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  _QWORD *v14;
  _QWORD *v15;
  const __CFDictionary *v16;
  applesauce::CF *exception;
  int v18;
  CFIndex Count;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v8 = (const __CFDictionary *)*a1;
  if (!v8 || CFDictionaryGetCount(v8) != 1)
  {
    filter_factory_log();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v16 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v18 = 134217984;
      Count = CFDictionaryGetCount(v16);
      _os_log_error_impl(&dword_1DA6F2000, v9, OS_LOG_TYPE_ERROR, "BoostMinimumVariation factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v18, 0xCu);
    }

  }
  v10 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v11 = bounded_float_for_key(v10, CFSTR("MinCandidateDominanceRatio"), 1.0, INFINITY);
    CFRelease(v10);
  }
  else
  {
    v11 = bounded_float_for_key(0, CFSTR("MinCandidateDominanceRatio"), 1.0, INFINITY);
  }
  if (!HIDWORD(v11))
  {
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  v12 = *a2;
  if (*((_BYTE *)a2 + 184))
  {
    if (v12 < 7)
    {
      v13 = (char *)&unk_1DA90FA08 + 4 * v12;
      LODWORD(a2) = dword_1DA90FA24[v12];
      v14 = &unk_1DA90FA60;
LABEL_15:
      v4 = *(_DWORD *)v13;
      LODWORD(v10) = dword_1DA90FA40[(int)v12];
      v3 = v14[(int)v12];
    }
  }
  else if (v12 < 7)
  {
    v13 = (char *)&unk_1DA90F9B0 + 4 * v12;
    LODWORD(a2) = 402653186;
    v14 = &unk_1DA90F9D0;
    goto LABEL_15;
  }
  v15 = operator new(0x40uLL);
  v15[1] = 0;
  v15[2] = 0;
  *v15 = &off_1EA0FCAE8;
  *((_DWORD *)v15 + 8) = v11;
  *((_DWORD *)v15 + 10) = v4;
  *((_DWORD *)v15 + 11) = 0;
  *((_DWORD *)v15 + 12) = (_DWORD)a2;
  *((_DWORD *)v15 + 13) = (_DWORD)v10;
  v15[7] = v3;
  a3[1] = v15;
  v15[3] = &off_1EA1012F8;
  *a3 = v15 + 3;
}

void sub_1DA79AF58()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostCaseVariantsOfTopCandidate>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "BoostCaseVariantsOfTopCandidate";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FD040;
  a2[1] = v6;
  v6[3] = &unk_1EA101328;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79B08C()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::ExemptHighFrequencyWordsFromNoSuggest>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "ExemptHighFrequencyWordsFromNoSuggest";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FD078;
  a2[1] = v6;
  v6[3] = &off_1EA101358;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79B1C0()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::RescoreShortWords>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "RescoreShortWords";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x40uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FD0B0;
  v6[4] = 0;
  v6[5] = 0;
  v6[6] = 0;
  v6[7] = 0;
  a2[1] = v6;
  v6[3] = &off_1EA101388;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79B2FC()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterLearnedTypo>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterLearnedTypo";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FD118;
  a2[1] = v6;
  v6[3] = &off_1EA0FD0E8;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79B430()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterTopDynamicWordsWithStaticVariant>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  const __CFDictionary *v8;
  unint64_t v9;
  _QWORD *v10;
  const __CFDictionary *v11;
  applesauce::CF *exception;
  int v13;
  CFIndex Count;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 2)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v11 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v13 = 134217984;
      Count = CFDictionaryGetCount(v11);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterTopDynamicWordsWithStaticVariant factory expects 2 parameters, but specification includes %ld", (uint8_t *)&v13, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_integer_for_key(v6, CFSTR("MinUsageCountForDynamicCaseVariant"), 0, 0xFFFF);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_integer_for_key(0, CFSTR("MinUsageCountForDynamicCaseVariant"), 0, 0xFFFF);
  }
  if (!HIDWORD(v7))
    goto LABEL_13;
  v8 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v9 = bounded_float_for_key(v8, CFSTR("MinOmegaRatioForDynamicCaseVariant"), 1.0, INFINITY);
    CFRelease(v8);
  }
  else
  {
    v9 = bounded_float_for_key(0, CFSTR("MinOmegaRatioForDynamicCaseVariant"), 1.0, INFINITY);
  }
  if (HIDWORD(v9))
  {
    v10 = operator new(0x28uLL);
    v10[1] = 0;
    v10[2] = 0;
    *v10 = &off_1EA0FCB20;
    *((_DWORD *)v10 + 8) = v7;
    *((_DWORD *)v10 + 9) = v9;
    a2[1] = v10;
    v10[3] = &off_1EA0FCB58;
    *a2 = v10 + 3;
  }
  else
  {
LABEL_13:
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA79B620()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterInvalidTextReplacement>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterInvalidTextReplacement";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FD180;
  a2[1] = v6;
  v6[3] = &off_1EA0FD150;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79B754()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterContactWordsConflictingWithValidInput>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "CandidateFilterContactWordsConflictingWithValidInput";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FD1E8;
  a2[1] = v6;
  v6[3] = &off_1EA0FD1B8;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79B888()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWithoutSupplementalWords>(const __CFDictionary **a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  const __CFDictionary *v6;
  NSObject *v7;
  _QWORD *v8;
  const __CFDictionary *v9;
  applesauce::CF *exception;
  int v11;
  CFIndex Count;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  if (v6 && CFDictionaryGetCount(v6))
  {
    filter_factory_log();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v9 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v11 = 134217984;
      Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1DA6F2000, v7, OS_LOG_TYPE_ERROR, "FilterWithoutSupplementalWords factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }

  }
  if (*(_BYTE *)(a2 + 185))
  {
    v8 = operator new(0x20uLL);
    v8[1] = 0;
    v8[2] = 0;
    *v8 = &off_1EA0FC890;
    a3[1] = v8;
    v8[3] = &off_1EA0FC8C8;
    *a3 = v8 + 3;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_1DA79B9BC()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterPartOfHyphenatedWord>(const __CFDictionary **a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  const __CFDictionary *v6;
  NSObject *v7;
  _QWORD *v8;
  const __CFDictionary *v9;
  applesauce::CF *exception;
  int v11;
  CFIndex Count;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  if (v6 && CFDictionaryGetCount(v6))
  {
    filter_factory_log();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v9 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v11 = 134217984;
      Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1DA6F2000, v7, OS_LOG_TYPE_ERROR, "FilterPartOfHyphenatedWord> factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }

  }
  if (*(_BYTE *)(a2 + 185))
  {
    v8 = operator new(0x20uLL);
    v8[1] = 0;
    v8[2] = 0;
    *v8 = &off_1EA0FC8F8;
    a3[1] = v8;
    v8[3] = &off_1EA0FC930;
    *a3 = v8 + 3;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_1DA79BAF0()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterLowQualityContinuousPathRetrocorrections>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  _QWORD *v8;
  const __CFDictionary *v9;
  applesauce::CF *exception;
  int v11;
  CFIndex Count;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v11 = 134217984;
      Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterLowQualityContinuousPathRetrocorrections factory expects 2 parameters, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_float_for_key(v6, CFSTR("MinOmegaRatioForContinuousPathRetrocorrections"), 0.0, 1.0);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_float_for_key(0, CFSTR("MinOmegaRatioForContinuousPathRetrocorrections"), 0.0, 1.0);
  }
  if (HIDWORD(v7))
  {
    v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    *v8 = &off_1EA0FCB88;
    *((_DWORD *)v8 + 8) = v7;
    a2[1] = v8;
    v8[3] = &off_1EA0FF1A0;
    *a2 = v8 + 3;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA79BC7C()
{
  void *v0;

}

char *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNoPredictContinuousPathAlternates>@<X0>(const __CFDictionary **a1@<X0>, unsigned int *a2@<X1>, _QWORD *a3@<X8>)
{
  NSObject *v3;
  int v4;
  const __CFDictionary **v6;
  const __CFDictionary *v8;
  uint64_t v9;
  char *v10;
  _QWORD *v11;
  _QWORD *v12;
  char *result;
  const __CFDictionary *v14;
  applesauce::CF *exception;
  int v16;
  CFIndex Count;
  uint64_t v18;

  v6 = a1;
  v18 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  if (v8 && CFDictionaryGetCount(v8))
  {
    filter_factory_log();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v14 = *v6;
      if (!*v6)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v16 = 134217984;
      Count = CFDictionaryGetCount(v14);
      _os_log_error_impl(&dword_1DA6F2000, v3, OS_LOG_TYPE_ERROR, "FilterNoPredictContinuousPathAlternates factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v16, 0xCu);
    }

  }
  v9 = *a2;
  if (*((_BYTE *)a2 + 184))
  {
    if (v9 < 7)
    {
      v10 = (char *)&unk_1DA90FA08 + 4 * v9;
      LODWORD(a2) = dword_1DA90FA24[v9];
      v11 = &unk_1DA90FA60;
LABEL_10:
      v4 = *(_DWORD *)v10;
      LODWORD(v3) = dword_1DA90FA40[(int)v9];
      v6 = (const __CFDictionary **)v11[(int)v9];
    }
  }
  else if (v9 < 7)
  {
    v10 = (char *)&unk_1DA90F9B0 + 4 * v9;
    LODWORD(a2) = 402653186;
    v11 = &unk_1DA90F9D0;
    goto LABEL_10;
  }
  v12 = operator new(0x38uLL);
  v12[1] = 0;
  v12[2] = 0;
  *v12 = &off_1EA0FCBC0;
  *((_DWORD *)v12 + 8) = v4;
  *((_DWORD *)v12 + 9) = 0;
  *((_DWORD *)v12 + 10) = (_DWORD)a2;
  *((_DWORD *)v12 + 11) = (_DWORD)v3;
  v12[6] = v6;
  a3[1] = v12;
  v12[3] = &off_1EA0FF1D0;
  result = (char *)(v12 + 3);
  *a3 = result;
  return result;
}

void sub_1DA79BE2C()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterContinuousPathAlternatesFromOtherLanguage>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  _QWORD *v8;
  const __CFDictionary *v9;
  applesauce::CF *exception;
  int v11;
  CFIndex Count;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v11 = 134217984;
      Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterContinuousPathAlternatesFromOtherLanguage factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_float_for_key(v6, CFSTR("MinConfidenceToEstablishContinuousPathLanguage"), 0.0, 1.0);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_float_for_key(0, CFSTR("MinConfidenceToEstablishContinuousPathLanguage"), 0.0, 1.0);
  }
  if (HIDWORD(v7))
  {
    v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    *v8 = &off_1EA0FCBF8;
    *((_DWORD *)v8 + 8) = v7;
    a2[1] = v8;
    v8[3] = &off_1EA0FF200;
    *a2 = v8 + 3;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA79BFB8()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterSortkeyMatchFromDifferentLanguage>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  const __CFDictionary *v8;
  unint64_t v9;
  _QWORD *v10;
  const __CFDictionary *v11;
  applesauce::CF *exception;
  int v13;
  CFIndex Count;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 2)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v11 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v13 = 134217984;
      Count = CFDictionaryGetCount(v11);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterSortkeyMatchFromDifferentLanguage factory expects 2 parameters, but specification includes %ld", (uint8_t *)&v13, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_float_for_key(v6, CFSTR("MinConfidenceToEstablishCurrentLanguage"), 0.0, 1.0);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_float_for_key(0, CFSTR("MinConfidenceToEstablishCurrentLanguage"), 0.0, 1.0);
  }
  if (!HIDWORD(v7))
    goto LABEL_13;
  v8 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v9 = bounded_float_for_key(v8, CFSTR("SameLanguageSortkeyMatchDominanceRatio"), 1.0, INFINITY);
    CFRelease(v8);
  }
  else
  {
    v9 = bounded_float_for_key(0, CFSTR("SameLanguageSortkeyMatchDominanceRatio"), 1.0, INFINITY);
  }
  if (HIDWORD(v9))
  {
    v10 = operator new(0x28uLL);
    v10[1] = 0;
    v10[2] = 0;
    *v10 = &off_1EA0FCC30;
    *((_DWORD *)v10 + 8) = v7;
    *((_DWORD *)v10 + 9) = v9;
    a2[1] = v10;
    v10[3] = &off_1EA100248;
    *a2 = v10 + 3;
  }
  else
  {
LABEL_13:
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA79C1A8()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDifferentLanguageThanContext>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  _QWORD *v8;
  const __CFDictionary *v9;
  applesauce::CF *exception;
  int v11;
  CFIndex Count;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v11 = 134217984;
      Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterDifferentLanguageThanContext factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_float_for_key(v6, CFSTR("MinConfidenceToEstablishLanguage"), 0.0, 1.0);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_float_for_key(0, CFSTR("MinConfidenceToEstablishLanguage"), 0.0, 1.0);
  }
  if (HIDWORD(v7))
  {
    v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    *v8 = &off_1EA0FCC68;
    *((_DWORD *)v8 + 8) = v7;
    a2[1] = v8;
    v8[3] = &off_1EA100278;
    *a2 = v8 + 3;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA79C334()
{
  void *v0;

}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::ChooseTopQualityAutocorrection>(CFTypeRef *a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  const __CFDictionary *v6;
  unint64_t v7;
  const __CFDictionary *v8;
  unint64_t v9;
  const __CFDictionary *v10;
  unint64_t v11;
  const __CFDictionary *v12;
  unint64_t v13;
  const __CFDictionary *v14;
  unint64_t v15;
  const __CFDictionary *v16;
  _QWORD *v17;
  applesauce::CF *exception;
  int v19;
  CFIndex Count;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 5)
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v16 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v19 = 134217984;
      Count = CFDictionaryGetCount(v16);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "ChooseTopQualityAutocorrection factory expects 5 parameter, but specification includes %ld", (uint8_t *)&v19, 0xCu);
    }

  }
  v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v7 = bounded_float_for_key(v6, CFSTR("MinLinguisticSynergyForComplexCorrection"), 0.0, INFINITY);
    CFRelease(v6);
  }
  else
  {
    v7 = bounded_float_for_key(0, CFSTR("MinLinguisticSynergyForComplexCorrection"), 0.0, INFINITY);
  }
  if (!HIDWORD(v7))
    goto LABEL_27;
  v8 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v9 = bounded_float_for_key(v8, CFSTR("MinSuggestionDominanceRatio"), 1.0, INFINITY);
    CFRelease(v8);
  }
  else
  {
    v9 = bounded_float_for_key(0, CFSTR("MinSuggestionDominanceRatio"), 1.0, INFINITY);
  }
  if (!HIDWORD(v9))
    goto LABEL_27;
  v10 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v11 = bounded_integer_for_key(v10, CFSTR("MinStemLengthForPredictingOneLetter"), 0, 0xFFFF);
    CFRelease(v10);
  }
  else
  {
    v11 = bounded_integer_for_key(0, CFSTR("MinStemLengthForPredictingOneLetter"), 0, 0xFFFF);
  }
  if (!HIDWORD(v11))
    goto LABEL_27;
  v12 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v13 = bounded_integer_for_key(v12, CFSTR("MinStemLengthForPredictingTwoLetters"), 0, 0xFFFF);
    CFRelease(v12);
  }
  else
  {
    v13 = bounded_integer_for_key(0, CFSTR("MinStemLengthForPredictingTwoLetters"), 0, 0xFFFF);
  }
  if (!HIDWORD(v13))
    goto LABEL_27;
  v14 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    v15 = bounded_integer_for_key(v14, CFSTR("MinStemLengthForPredictingThreeLetters"), 0, 0xFFFF);
    CFRelease(v14);
  }
  else
  {
    v15 = bounded_integer_for_key(0, CFSTR("MinStemLengthForPredictingThreeLetters"), 0, 0xFFFF);
  }
  if (HIDWORD(v15))
  {
    v17 = operator new(0x38uLL);
    v17[1] = 0;
    v17[2] = 0;
    *v17 = &off_1EA0FCCA0;
    *((_DWORD *)v17 + 8) = v7;
    *((_DWORD *)v17 + 9) = v9;
    *((_DWORD *)v17 + 10) = v11;
    *((_DWORD *)v17 + 11) = v13;
    *((_DWORD *)v17 + 12) = v15;
    a2[1] = v17;
    v17[3] = &off_1EA1068B8;
    *a2 = v17 + 3;
  }
  else
  {
LABEL_27:
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1DA79C658()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::RemoveAlternatesIfNoLinguisticCandidate>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  CFIndex Count;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 134217984;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "RemoveAlternatesIfNoLinguisticCandidate factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0xCu);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FCCD8;
  a2[1] = v6;
  v6[3] = &off_1EA0FCD10;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79C778()
{
  void *v0;

}

char *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCommonLearnedTypos>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  char *v6;
  char *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterCommonLearnedTypos";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
      std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__deallocate_node(0);
    }

  }
  v6 = (char *)operator new(0x60uLL);
  *((_QWORD *)v6 + 1) = 0;
  *((_QWORD *)v6 + 2) = 0;
  *(_QWORD *)v6 = &off_1EA0FD250;
  *((_DWORD *)v6 + 8) = 51;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *((_DWORD *)v6 + 18) = 1065353216;
  *((_QWORD *)v6 + 10) = 0;
  *((_QWORD *)v6 + 11) = 0;
  a2[1] = v6;
  *((_QWORD *)v6 + 3) = &off_1EA0FD220;
  result = v6 + 24;
  *a2 = result;
  return result;
}

void sub_1DA79C8D4()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNonVulgarIfTopCandidateVulgar>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  CFIndex Count;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 134217984;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "FilterNonVulgarIfTopCandidateVulgar factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0xCu);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FC998;
  a2[1] = v6;
  v6[3] = &off_1EA0FDC90;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79C9F4()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::AddAlternativesForRetrocorrection>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "AddAlternativesForRetrocorrection";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FD288;
  a2[1] = v6;
  v6[3] = &off_1EA0FDF00;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79CB28()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDuplicates>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterDuplicates";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FD2C0;
  a2[1] = v6;
  v6[3] = &off_1EA0FDF30;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79CC5C()
{
  void *v0;

}

_QWORD *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCaseVariantsOfStaticWords>@<X0>(const __CFDictionary **a1@<X0>, _QWORD *a2@<X8>)
{
  const __CFDictionary *v4;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *result;
  const __CFDictionary *v8;
  applesauce::CF *exception;
  int v10;
  const char *v11;
  __int16 v12;
  CFIndex Count;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      v10 = 136315394;
      v11 = "FilterCaseVariantsOfStaticWords";
      v12 = 2048;
      Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v10, 0x16u);
    }

  }
  v6 = operator new(0x20uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1EA0FD2F8;
  a2[1] = v6;
  v6[3] = &off_1EA0FDF60;
  result = v6 + 3;
  *a2 = result;
  return result;
}

void sub_1DA79CD90()
{
  void *v0;

}

uint64_t std::unique_ptr<std::unordered_map<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>::reset[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::~__hash_table(result);
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

void std::__shared_ptr_emplace<KB::FilterCaseVariantsOfStaticWords>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD2F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterCaseVariantsOfStaticWords>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD2F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterCaseVariantsOfStaticWords>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterDuplicates>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD2C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterDuplicates>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD2C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterDuplicates>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::AddAlternativesForRetrocorrection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD288;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::AddAlternativesForRetrocorrection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD288;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::AddAlternativesForRetrocorrection>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterNonVulgarIfTopCandidateVulgar>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC998;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterNonVulgarIfTopCandidateVulgar>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC998;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterNonVulgarIfTopCandidateVulgar>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterCommonLearnedTypos>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD250;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterCommonLearnedTypos>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD250;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterCommonLearnedTypos>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::RemoveAlternatesIfNoLinguisticCandidate>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCCD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::RemoveAlternatesIfNoLinguisticCandidate>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCCD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::RemoveAlternatesIfNoLinguisticCandidate>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t bounded_float_for_key(const __CFDictionary *a1, const __CFString *key, float a3, float a4)
{
  const __CFNumber *v7;
  const __CFNumber *v8;
  CFTypeID TypeID;
  const __CFNumber *v10;
  CFNumberType v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  CFTypeID v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  const __CFNumber *v19;
  CFNumberType v20;
  const __CFNumber *v21;
  CFNumberType v22;
  const __CFNumber *v23;
  CFNumberType v24;
  const __CFNumber *v25;
  CFNumberType v26;
  const __CFNumber *v27;
  CFNumberType v28;
  int Value;
  int v30;
  float v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  float v35;
  float v36;
  _BOOL4 v38;
  _BYTE *v40;
  _BYTE *v41;
  _BYTE *v42;
  applesauce::CF *exception;
  _BYTE __p[12];
  char v45;
  _BYTE valuePtr[12];
  __int16 v47;
  double v48;
  __int16 v49;
  double v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  if (key && (v7 = (const __CFNumber *)CFDictionaryGetValue(a1, key)) != 0)
  {
    v8 = v7;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v8))
    {
      switch(CFNumberGetType(v8))
      {
        case kCFNumberSInt8Type:
          valuePtr[0] = 0;
          v10 = v8;
          v11 = kCFNumberSInt8Type;
          goto LABEL_18;
        case kCFNumberSInt16Type:
          *(_WORD *)valuePtr = 0;
          v19 = v8;
          v20 = kCFNumberSInt16Type;
          goto LABEL_20;
        case kCFNumberSInt32Type:
          *(_DWORD *)valuePtr = 0;
          v21 = v8;
          v22 = kCFNumberSInt32Type;
          goto LABEL_23;
        case kCFNumberSInt64Type:
          *(_QWORD *)valuePtr = 0;
          v23 = v8;
          v24 = kCFNumberSInt64Type;
          goto LABEL_31;
        case kCFNumberFloat32Type:
          *(_DWORD *)valuePtr = 0;
          v25 = v8;
          v26 = kCFNumberFloat32Type;
          goto LABEL_27;
        case kCFNumberFloat64Type:
          *(_QWORD *)valuePtr = 0;
          v27 = v8;
          v28 = kCFNumberFloat64Type;
          goto LABEL_33;
        case kCFNumberCharType:
          valuePtr[0] = 0;
          v10 = v8;
          v11 = kCFNumberCharType;
LABEL_18:
          Value = CFNumberGetValue(v10, v11, valuePtr);
          v30 = valuePtr[0];
          goto LABEL_21;
        case kCFNumberShortType:
          *(_WORD *)valuePtr = 0;
          v19 = v8;
          v20 = kCFNumberShortType;
LABEL_20:
          Value = CFNumberGetValue(v19, v20, valuePtr);
          v30 = *(__int16 *)valuePtr;
LABEL_21:
          v31 = (float)v30;
          goto LABEL_34;
        case kCFNumberIntType:
          *(_DWORD *)valuePtr = 0;
          v21 = v8;
          v22 = kCFNumberIntType;
LABEL_23:
          Value = CFNumberGetValue(v21, v22, valuePtr);
          v31 = (float)*(int *)valuePtr;
          goto LABEL_34;
        case kCFNumberLongType:
          *(_QWORD *)valuePtr = 0;
          v23 = v8;
          v24 = kCFNumberLongType;
          goto LABEL_31;
        case kCFNumberLongLongType:
          *(_QWORD *)valuePtr = 0;
          v23 = v8;
          v24 = kCFNumberLongLongType;
          goto LABEL_31;
        case kCFNumberFloatType:
          *(_DWORD *)valuePtr = 0;
          v25 = v8;
          v26 = kCFNumberFloatType;
LABEL_27:
          Value = CFNumberGetValue(v25, v26, valuePtr);
          v32 = *(unsigned int *)valuePtr;
          goto LABEL_35;
        case kCFNumberDoubleType:
          *(_QWORD *)valuePtr = 0;
          v27 = v8;
          v28 = kCFNumberDoubleType;
          goto LABEL_33;
        case kCFNumberCFIndexType:
          *(_QWORD *)valuePtr = 0;
          v23 = v8;
          v24 = kCFNumberCFIndexType;
          goto LABEL_31;
        case kCFNumberNSIntegerType:
          *(_QWORD *)valuePtr = 0;
          v23 = v8;
          v24 = kCFNumberNSIntegerType;
LABEL_31:
          Value = CFNumberGetValue(v23, v24, valuePtr);
          v31 = (float)*(uint64_t *)valuePtr;
          goto LABEL_34;
        case kCFNumberCGFloatType:
          *(_QWORD *)valuePtr = 0;
          v27 = v8;
          v28 = kCFNumberCGFloatType;
LABEL_33:
          Value = CFNumberGetValue(v27, v28, valuePtr);
          v31 = *(double *)valuePtr;
LABEL_34:
          v32 = LODWORD(v31);
LABEL_35:
          v18 = v32 | 0x100000000;
          if (!Value)
            v18 = 0;
          v16 = v18 & 0xFFFFFF00;
          v17 = v18 & 0x100000000;
          break;
        default:
          v16 = 0;
          v17 = 0;
          LOBYTE(v18) = 0;
          break;
      }
      v14 = v17 | v16 & 0xFFFFFF00 | v18;
    }
    else
    {
      v15 = CFBooleanGetTypeID();
      if (v15 == CFGetTypeID(v8))
        v14 = COERCE_UNSIGNED_INT((float)CFBooleanGetValue(v8)) | 0x100000000;
      else
        v14 = 0;
    }
    v13 = v14 & 0x100000000;
    v12 = v14 & 0xFFFFFF00;
    LODWORD(v14) = v14;
  }
  else
  {
    v12 = 0;
    v13 = 0;
    LODWORD(v14) = 0;
  }
  if (!HIDWORD(v13))
  {
    filter_factory_log();
    v33 = objc_claimAutoreleasedReturnValue();
    a3 = 0.0;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      KB::std_string(key, valuePtr);
      if (v49 >= 0)
        v40 = valuePtr;
      else
        v40 = *(_BYTE **)valuePtr;
      *(_DWORD *)__p = 136315138;
      *(_QWORD *)&__p[4] = v40;
      _os_log_error_impl(&dword_1DA6F2000, v33, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or its value is not float", __p, 0xCu);
      if (SHIBYTE(v49) < 0)
        operator delete(*(void **)valuePtr);
    }
    v34 = 0;
LABEL_53:

    v36 = a3;
    return v34 | LODWORD(v36);
  }
  LODWORD(v35) = v12 | v13 | v14;
  v36 = v35;
  if (v35 < a3 || v35 > a4)
  {
    filter_factory_log();
    v33 = objc_claimAutoreleasedReturnValue();
    v38 = os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
    if (v36 >= a3)
    {
      if (v38)
      {
        KB::std_string(key, __p);
        v42 = v45 >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)valuePtr = 136315650;
        *(_QWORD *)&valuePtr[4] = v42;
        v47 = 2048;
        v48 = v36;
        v49 = 2048;
        v50 = a4;
        _os_log_error_impl(&dword_1DA6F2000, v33, OS_LOG_TYPE_ERROR, "Key '%s' has value %f, which is greater than upper bound %f", valuePtr, 0x20u);
        if (v45 < 0)
          operator delete(*(void **)__p);
      }
      v34 = 0x100000000;
      a3 = a4;
    }
    else
    {
      if (v38)
      {
        KB::std_string(key, __p);
        v41 = v45 >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)valuePtr = 136315650;
        *(_QWORD *)&valuePtr[4] = v41;
        v47 = 2048;
        v48 = v36;
        v49 = 2048;
        v50 = a3;
        _os_log_error_impl(&dword_1DA6F2000, v33, OS_LOG_TYPE_ERROR, "Key '%s' has value %f, which is less than lower bound %f", valuePtr, 0x20u);
        if (v45 < 0)
          operator delete(*(void **)__p);
      }
      v34 = 0x100000000;
    }
    goto LABEL_53;
  }
  v34 = 0x100000000;
  return v34 | LODWORD(v36);
}

uint64_t bounded_integer_for_key(const __CFDictionary *a1, const __CFString *key, int a3, int a4)
{
  NSObject *v5;
  const __CFNumber *v7;
  const __CFNumber *v8;
  CFTypeID TypeID;
  const __CFNumber *v10;
  CFNumberType v11;
  unsigned int v12;
  unint64_t v13;
  int v14;
  CFTypeID v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  const __CFNumber *v20;
  CFNumberType v21;
  const __CFNumber *v22;
  CFNumberType v23;
  const __CFNumber *v24;
  CFNumberType v25;
  const __CFNumber *v26;
  CFNumberType v27;
  int Value;
  uint64_t v29;
  unsigned __int8 v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  NSObject *v37;
  _BOOL4 v38;
  _BYTE *v40;
  _BYTE *v41;
  _BYTE *v42;
  applesauce::CF *exception;
  _BYTE __p[12];
  char v45;
  _BYTE valuePtr[12];
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  LODWORD(v5) = a3;
  if (key && (v7 = (const __CFNumber *)CFDictionaryGetValue(a1, key)) != 0)
  {
    v8 = v7;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v8))
    {
      switch(CFNumberGetType(v8))
      {
        case kCFNumberSInt8Type:
          valuePtr[0] = 0;
          v10 = v8;
          v11 = kCFNumberSInt8Type;
          goto LABEL_18;
        case kCFNumberSInt16Type:
          *(_WORD *)valuePtr = 0;
          v20 = v8;
          v21 = kCFNumberSInt16Type;
          goto LABEL_25;
        case kCFNumberSInt32Type:
          *(_DWORD *)valuePtr = 0;
          v22 = v8;
          v23 = kCFNumberSInt32Type;
          goto LABEL_36;
        case kCFNumberSInt64Type:
          *(_QWORD *)valuePtr = 0;
          v22 = v8;
          v23 = kCFNumberSInt64Type;
          goto LABEL_36;
        case kCFNumberFloat32Type:
          *(_DWORD *)valuePtr = 0;
          v24 = v8;
          v25 = kCFNumberFloat32Type;
          goto LABEL_32;
        case kCFNumberFloat64Type:
          *(_QWORD *)valuePtr = 0;
          v26 = v8;
          v27 = kCFNumberFloat64Type;
          goto LABEL_38;
        case kCFNumberCharType:
          valuePtr[0] = 0;
          v10 = v8;
          v11 = kCFNumberCharType;
LABEL_18:
          Value = CFNumberGetValue(v10, v11, valuePtr);
          v29 = Value != 0;
          if (Value)
            v30 = valuePtr[0];
          else
            v30 = 0;
          v31 = -256;
          if ((v29 & (valuePtr[0] < 0)) == 0)
            v31 = 0;
          v19 = v29 << 32;
          LODWORD(v16) = v31 & 0xFFFFFF00 | v30;
          v18 = v16 & 0xFFFFFF00;
          break;
        case kCFNumberShortType:
          *(_WORD *)valuePtr = 0;
          v20 = v8;
          v21 = kCFNumberShortType;
LABEL_25:
          if (CFNumberGetValue(v20, v21, valuePtr))
            v16 = *(__int16 *)valuePtr & 0xFFFFFFFFLL | 0x100000000;
          else
            v16 = 0;
          goto LABEL_41;
        case kCFNumberIntType:
          *(_DWORD *)valuePtr = 0;
          v22 = v8;
          v23 = kCFNumberIntType;
          goto LABEL_36;
        case kCFNumberLongType:
          *(_QWORD *)valuePtr = 0;
          v22 = v8;
          v23 = kCFNumberLongType;
          goto LABEL_36;
        case kCFNumberLongLongType:
          *(_QWORD *)valuePtr = 0;
          v22 = v8;
          v23 = kCFNumberLongLongType;
          goto LABEL_36;
        case kCFNumberFloatType:
          *(_DWORD *)valuePtr = 0;
          v24 = v8;
          v25 = kCFNumberFloatType;
LABEL_32:
          v32 = CFNumberGetValue(v24, v25, valuePtr);
          v33 = (int)*(float *)valuePtr;
          goto LABEL_39;
        case kCFNumberDoubleType:
          *(_QWORD *)valuePtr = 0;
          v26 = v8;
          v27 = kCFNumberDoubleType;
          goto LABEL_38;
        case kCFNumberCFIndexType:
          *(_QWORD *)valuePtr = 0;
          v22 = v8;
          v23 = kCFNumberCFIndexType;
          goto LABEL_36;
        case kCFNumberNSIntegerType:
          *(_QWORD *)valuePtr = 0;
          v22 = v8;
          v23 = kCFNumberNSIntegerType;
LABEL_36:
          v32 = CFNumberGetValue(v22, v23, valuePtr);
          v33 = *(unsigned int *)valuePtr;
          goto LABEL_39;
        case kCFNumberCGFloatType:
          *(_QWORD *)valuePtr = 0;
          v26 = v8;
          v27 = kCFNumberCGFloatType;
LABEL_38:
          v32 = CFNumberGetValue(v26, v27, valuePtr);
          v33 = (int)*(double *)valuePtr;
LABEL_39:
          v16 = v33 | 0x100000000;
          if (!v32)
            v16 = 0;
LABEL_41:
          v18 = v16 & 0xFFFFFF00;
          v19 = v16 & 0x100000000;
          break;
        default:
          v18 = 0;
          v19 = 0;
          LOBYTE(v16) = 0;
          break;
      }
      v17 = v19 | v18 & 0xFFFFFF00;
      v16 = v16;
    }
    else
    {
      v15 = CFBooleanGetTypeID();
      if (v15 == CFGetTypeID(v8))
      {
        v16 = CFBooleanGetValue(v8);
        v17 = 0x100000000;
      }
      else
      {
        v16 = 0;
        v17 = 0;
      }
    }
    v14 = v17 | v16;
    v13 = (v17 | v16) & 0x100000000;
    v12 = v14 & 0xFFFFFF00;
    v14 = v14;
  }
  else
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
  }
  if (HIDWORD(v13))
  {
    v36 = v12 | v13 | v14;
    if (v36 < (int)v5 || v36 > a4)
    {
      filter_factory_log();
      v37 = objc_claimAutoreleasedReturnValue();
      v38 = os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
      if (v36 >= (int)v5)
      {
        if (v38)
        {
          KB::std_string(key, __p);
          v42 = v45 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)valuePtr = 136315650;
          *(_QWORD *)&valuePtr[4] = v42;
          v47 = 1024;
          v48 = v36;
          v49 = 1024;
          v50 = a4;
          _os_log_error_impl(&dword_1DA6F2000, v37, OS_LOG_TYPE_ERROR, "Key '%s' has value %d, which is greater than upper bound %d", valuePtr, 0x18u);
          if (v45 < 0)
            operator delete(*(void **)__p);
        }

        v35 = a4 & 0xFFFFFF00;
        v34 = 0x100000000;
        LOBYTE(v5) = a4;
      }
      else
      {
        if (v38)
        {
          KB::std_string(key, __p);
          v41 = v45 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)valuePtr = 136315650;
          *(_QWORD *)&valuePtr[4] = v41;
          v47 = 1024;
          v48 = v36;
          v49 = 1024;
          v50 = (int)v5;
          _os_log_error_impl(&dword_1DA6F2000, v37, OS_LOG_TYPE_ERROR, "Key '%s' has value %d, which is less than lower bound %d", valuePtr, 0x18u);
          if (v45 < 0)
            operator delete(*(void **)__p);
        }

        v35 = 0;
        v34 = 0x100000000;
      }
    }
    else
    {
      v35 = v36 & 0xFFFFFF00;
      v34 = 0x100000000;
      LOBYTE(v5) = v36;
    }
  }
  else
  {
    filter_factory_log();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      KB::std_string(key, valuePtr);
      if (v50 >= 0)
        v40 = valuePtr;
      else
        v40 = *(_BYTE **)valuePtr;
      *(_DWORD *)__p = 136315138;
      *(_QWORD *)&__p[4] = v40;
      _os_log_error_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or its value is not int32_t", __p, 0xCu);
      if (SHIBYTE(v50) < 0)
        operator delete(*(void **)valuePtr);
    }

    v34 = 0;
    LOBYTE(v5) = 0;
    v35 = 0;
  }
  return v34 | v35 | v5;
}

void std::__shared_ptr_emplace<KB::ChooseTopQualityAutocorrection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCCA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::ChooseTopQualityAutocorrection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCCA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::ChooseTopQualityAutocorrection>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterDifferentLanguageThanContext>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCC68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterDifferentLanguageThanContext>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCC68;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterDifferentLanguageThanContext>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterSortkeyMatchFromDifferentLanguage>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCC30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterSortkeyMatchFromDifferentLanguage>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCC30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterSortkeyMatchFromDifferentLanguage>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterContinuousPathAlternatesFromOtherLanguage>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCBF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterContinuousPathAlternatesFromOtherLanguage>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCBF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterContinuousPathAlternatesFromOtherLanguage>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterNoPredictContinuousPathAlternates>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCBC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterNoPredictContinuousPathAlternates>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCBC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterNoPredictContinuousPathAlternates>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterLowQualityContinuousPathRetrocorrections>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCB88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterLowQualityContinuousPathRetrocorrections>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCB88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterLowQualityContinuousPathRetrocorrections>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterPartOfHyphenatedWord>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC8F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterPartOfHyphenatedWord>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC8F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterPartOfHyphenatedWord>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterWithoutSupplementalWords>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC890;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterWithoutSupplementalWords>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC890;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterWithoutSupplementalWords>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterContactWordsConflictingWithValidInput>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD1E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterContactWordsConflictingWithValidInput>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD1E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterContactWordsConflictingWithValidInput>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterInvalidTextReplacement>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD180;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterInvalidTextReplacement>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD180;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterInvalidTextReplacement>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterTopDynamicWordsWithStaticVariant>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCB20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterTopDynamicWordsWithStaticVariant>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCB20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterTopDynamicWordsWithStaticVariant>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterLearnedTypo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD118;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterLearnedTypo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD118;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterLearnedTypo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::RescoreShortWords>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD0B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::RescoreShortWords>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD0B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::RescoreShortWords>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::ExemptHighFrequencyWordsFromNoSuggest>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD078;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::ExemptHighFrequencyWordsFromNoSuggest>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD078;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::ExemptHighFrequencyWordsFromNoSuggest>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::BoostCaseVariantsOfTopCandidate>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD040;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::BoostCaseVariantsOfTopCandidate>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD040;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::BoostCaseVariantsOfTopCandidate>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::BoostMinimumVariation>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCAE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::BoostMinimumVariation>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCAE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::BoostMinimumVariation>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::BoostPreferedFormForSortkey>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCAB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::BoostPreferedFormForSortkey>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCAB0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::BoostPreferedFormForSortkey>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterInputPrefixMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCA78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterInputPrefixMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCA78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterInputPrefixMismatch>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterNondominantCorrectionOfMoreWords>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCA40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterNondominantCorrectionOfMoreWords>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCA40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterNondominantCorrectionOfMoreWords>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterCorrectionsIfAnyCandidateMatchesInput>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC858;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterCorrectionsIfAnyCandidateMatchesInput>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC858;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterCorrectionsIfAnyCandidateMatchesInput>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterMissingOneLetterWordFromInput>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD008;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterMissingOneLetterWordFromInput>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD008;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterMissingOneLetterWordFromInput>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterAllCapsNoSuggestWordsOfLength>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCA08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterAllCapsNoSuggestWordsOfLength>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCA08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterAllCapsNoSuggestWordsOfLength>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterPopupVariantMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCFD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterPopupVariantMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCFD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterPopupVariantMismatch>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterWordEndingApostropheBetweenNonseparators>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCF98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterWordEndingApostropheBetweenNonseparators>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCF98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterWordEndingApostropheBetweenNonseparators>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterDoubleApostrophe>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCF60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterDoubleApostrophe>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCF60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterDoubleApostrophe>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterAlteredURLFragments>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCF28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterAlteredURLFragments>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCF28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterAlteredURLFragments>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterCharacterCount>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC9D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterCharacterCount>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC9D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterCharacterCount>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterNumberlikeTokenMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCEF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterNumberlikeTokenMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCEF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterNumberlikeTokenMismatch>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterNumberMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCEB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterNumberMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCEB8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterNumberMismatch>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterNotSuggestibleForInput>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC960;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterNotSuggestibleForInput>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC960;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterNotSuggestibleForInput>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterControlCharacters>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCE80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterControlCharacters>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCE80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterControlCharacters>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterIncomplete>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCE48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterIncomplete>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCE48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterIncomplete>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterAppNames>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCE10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterAppNames>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCE10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterAppNames>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::FilterWordsConflictingWithValidContactNames>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCD40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterWordsConflictingWithValidContactNames>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCD40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterWordsConflictingWithValidContactNames>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__function::__func<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&),std::allocator<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>,std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&),std::allocator<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>,std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA0FC810;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&),std::allocator<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>,std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA0FC810;
  a2[1] = v2;
  return result;
}

void std::__function::__func<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&),std::allocator<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>,std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::operator()(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  void (*v3)(CFTypeRef *, uint64_t);
  CFTypeRef cf;

  v3 = *(void (**)(CFTypeRef *, uint64_t))(a1 + 8);
  cf = *a2;
  *a2 = 0;
  v3(&cf, a3);
  if (cf)
    CFRelease(cf);
}

void std::__shared_ptr_emplace<KB::FilterZeroProbability>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCDA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::FilterZeroProbability>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FCDA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::FilterZeroProbability>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<KB::CompositeCandidateFilter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC7B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::CompositeCandidateFilter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FC7B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::CompositeCandidateFilter>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void KB::CandidateFilterFactory::create_standard_filter_definition(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  uint8_t v12[16];
  uint8_t buf[16];
  uint8_t v14[16];
  uint8_t v15[16];
  uint8_t v16[16];

  if (KB::CandidateFilterFlags::candidate_filter_flag_type((unsigned int **)(a1 + 144)) - 1 > 1)
    return;
  v4 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 - 1) < 4)
  {
    v5 = *(_DWORD *)(a1 + 136);
    if (v5)
    {
      if (v5 == 1)
      {
        filter_factory_log();
        v6 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1DA6F2000, v6, OS_LOG_TYPE_INFO, "Create standard prediction, completion, or replacement candidate filter (TIFavoniusCandQualityFilter).", buf, 2u);
        }

        KB::CandidateFilterFactory::create_standard_prediction_completion_or_replacement_filter_favonius_definition(a1, a2);
      }
    }
    else
    {
      filter_factory_log();
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)v12 = 0;
        _os_log_impl(&dword_1DA6F2000, v10, OS_LOG_TYPE_INFO, "Create standard prediction, completion, or replacement candidate filter (TICandQualityFilter).", v12, 2u);
      }

      KB::CandidateFilterFactory::create_standard_prediction_completion_or_replacement_filter_defintion(a1, a2);
    }
    return;
  }
  if ((v4 - 5) < 2)
    goto LABEL_9;
  if (v4)
    return;
  v8 = *(_DWORD *)(a1 + 136);
  if (v8)
  {
    if (v8 != 1)
    {
LABEL_9:
      filter_factory_log();
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)v14 = 0;
        _os_log_impl(&dword_1DA6F2000, v7, OS_LOG_TYPE_INFO, "Create standard continuous path candidate filter.", v14, 2u);
      }

      KB::CandidateFilterFactory::create_standard_continuous_path_filter_definition(a1, a2);
      return;
    }
    filter_factory_log();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v16 = 0;
      _os_log_impl(&dword_1DA6F2000, v9, OS_LOG_TYPE_INFO, "Create standard autocorrect candidate filter (TIFavoniusCandQualityFilter).", v16, 2u);
    }

    KB::CandidateFilterFactory::create_standard_autocorrect_filter_favonius_definition(a1, a2);
  }
  else
  {
    filter_factory_log();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v15 = 0;
      _os_log_impl(&dword_1DA6F2000, v11, OS_LOG_TYPE_INFO, "Create standard autocorrect candidate filter (TICandQualityFilter).", v15, 2u);
    }

    KB::CandidateFilterFactory::create_standard_autocorrect_filter_definition(a1, a2);
  }
}

void KB::CandidateFilterFactory::create_standard_autocorrect_filter_favonius_definition(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  id v15;
  void *v16;
  CFTypeID v17;
  const void *v18;
  id v19;
  void *v20;
  CFTypeID v21;
  const void *v22;
  unint64_t v23;
  id v24;
  void *v25;
  CFTypeID v26;
  const void *v27;
  BOOL v28;
  id v29;
  void *v30;
  CFTypeID v31;
  const void *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *p_shared_owners;
  unint64_t v36;
  unint64_t v37;
  id v38;
  void *v39;
  CFTypeID v40;
  const void *v41;
  int v42;
  _BOOL4 v43;
  id v44;
  void *v45;
  CFTypeID v46;
  const void *v47;
  id v48;
  CFTypeID v49;
  CFTypeRef *v50;
  id v51;
  void *v52;
  CFTypeID v53;
  const void *v54;
  id v55;
  void *v56;
  CFTypeID v57;
  const void *v58;
  id v59;
  void *v60;
  CFTypeID v61;
  const void *v62;
  id v63;
  void *v64;
  CFTypeID v65;
  const void *v66;
  void *v67;
  id v68;
  void *v69;
  CFTypeID v70;
  const void *v71;
  id v72;
  void *v73;
  CFTypeID v74;
  const void *v75;
  void *v76;
  id v77;
  void *v78;
  CFTypeID v79;
  const void *v80;
  id v81;
  void *v82;
  CFTypeID v83;
  const void *v84;
  double v85;
  void *v86;
  void *v87;
  id v88;
  void *v89;
  CFTypeID v90;
  const void *v91;
  id v92;
  void *v93;
  CFTypeID v94;
  const void *v95;
  id v96;
  void *v97;
  CFTypeID v98;
  const void *v99;
  id v100;
  void *v101;
  CFTypeID v102;
  const void *v103;
  double v104;
  void *v105;
  double v106;
  void *v107;
  void *v108;
  id v109;
  void *v110;
  CFTypeID v111;
  const void *v112;
  double v113;
  void *v114;
  double v115;
  void *v116;
  void *v117;
  id v118;
  void *v119;
  CFTypeID v120;
  const void *v121;
  void *v122;
  id v123;
  void *v124;
  CFTypeID v125;
  const void *v126;
  id v127;
  void *v128;
  CFTypeID v129;
  const void *v130;
  double v131;
  void *v132;
  void *v133;
  id v134;
  void *v135;
  CFTypeID v136;
  const void *v137;
  id v138;
  void *v139;
  CFTypeID v140;
  const void *v141;
  id v142;
  void *v143;
  CFTypeID v144;
  const void *v145;
  id v146;
  void *v147;
  CFTypeID v148;
  const void *v149;
  void *v150;
  double v151;
  void *v152;
  void *v153;
  id v154;
  void *v155;
  CFTypeID v156;
  const void *v157;
  double v158;
  void *v159;
  void *v160;
  id v161;
  void *v162;
  CFTypeID v163;
  const void *v164;
  double v165;
  void *v166;
  double v167;
  void *v168;
  void *v169;
  void *v170;
  void *v171;
  void *v172;
  id v173;
  void *v174;
  CFTypeID v175;
  const void *v176;
  void *v177;
  id v178;
  void *v179;
  CFTypeID v180;
  const void *v181;
  id v182;
  void *v183;
  CFTypeID v184;
  const void *v185;
  id v186;
  void *v187;
  CFTypeID v188;
  const void *v189;
  applesauce::CF *exception;
  int v191;
  unsigned int v192;
  CFTypeRef v193;
  CFTypeRef v194;
  CFTypeRef v195;
  CFTypeRef v196;
  CFTypeRef v197;
  CFTypeRef v198;
  CFTypeRef v199;
  CFTypeRef v200;
  CFTypeRef v201;
  CFTypeRef v202;
  CFTypeRef v203;
  CFTypeRef v204;
  CFTypeRef v205;
  CFTypeRef v206;
  CFTypeRef v207;
  CFTypeRef v208;
  CFTypeRef v209;
  CFTypeRef v210;
  CFTypeRef v211;
  CFTypeRef v212;
  CFTypeRef v213;
  CFTypeRef v214;
  CFTypeRef v215;
  CFTypeRef v216;
  CFTypeRef v217;
  CFTypeRef v218;
  void *v219;
  void *v220;
  CFTypeRef v221;
  CFTypeRef v222;
  CFTypeRef v223;
  CFTypeRef v224;
  CFTypeRef v225;
  const __CFString *v226;
  const __CFString *v227;
  const __CFString *v228;
  const __CFString *v229;
  _QWORD v230[3];
  _QWORD v231[3];
  _QWORD v232[2];
  _QWORD v233[2];
  _QWORD v234[5];
  _QWORD v235[5];
  _QWORD v236[2];
  _QWORD v237[2];
  const __CFString *v238;
  void *v239;
  _QWORD v240[2];
  _QWORD v241[2];
  _QWORD v242[2];
  _QWORD v243[2];
  _QWORD v244[2];
  _QWORD v245[2];
  const __CFString *v246;
  const __CFString *v247;
  const __CFString *v248;
  const __CFString *v249;
  const __CFString *v250;
  const __CFString *v251;
  const __CFString *v252;
  void *v253;
  _QWORD v254[2];
  _QWORD v255[2];
  const __CFString *v256;
  const __CFString *v257;
  _QWORD v258[3];
  _QWORD v259[3];
  _QWORD v260[2];
  _QWORD v261[2];
  _QWORD v262[2];
  _QWORD v263[2];
  _QWORD v264[2];
  _QWORD v265[2];
  _QWORD v266[2];
  _QWORD v267[2];
  _QWORD v268[2];
  _QWORD v269[2];
  const __CFString *v270;
  const __CFString *v271;
  const __CFString *v272;
  const __CFString *v273;
  const __CFString *v274;
  const __CFString *v275;
  const __CFString *v276;
  void *v277;
  _QWORD v278[2];
  _QWORD v279[2];
  const __CFString *v280;
  const __CFString *v281;
  _QWORD v282[2];
  _QWORD v283[2];
  _QWORD v284[2];
  _QWORD v285[2];
  const __CFString *v286;
  const __CFString *v287;
  const __CFString *v288;
  void *v289;
  _QWORD v290[2];
  _QWORD v291[2];
  const __CFString *v292;
  const __CFString *v293;
  const __CFString *v294;
  const __CFString *v295;
  const __CFString *v296;
  const __CFString *v297;
  const __CFString *v298;
  const __CFString *v299;
  const __CFString *v300;
  const __CFString *v301;
  const __CFString *v302;
  const __CFString *v303;
  const __CFString *v304;
  const __CFString *v305;
  const __CFString *v306;
  const __CFString *v307;
  const __CFString *v308;
  const __CFString *v309;
  const __CFString *v310;
  const __CFString *v311;
  const __CFString *v312;
  _QWORD v313[3];

  v313[1] = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 40);
  v5 = *(_DWORD *)(a1 + 44);
  v7 = *(_DWORD *)(a1 + 48);
  v6 = *(_DWORD *)(a1 + 52);
  v191 = *(_DWORD *)(a1 + 60);
  v9 = *(unsigned int *)(a1 + 80);
  v8 = *(_DWORD *)(a1 + 84);
  v192 = *(_DWORD *)(a1 + 88);
  v10 = *(_DWORD *)(a1 + 92);
  v12 = *(_DWORD *)(a1 + 100);
  v11 = *(_DWORD *)(a1 + 104);
  v13 = *(unsigned int *)(a1 + 108);
  v14 = *(_DWORD *)(a1 + 120);
  v312 = CFSTR("FilterName");
  v313[0] = CFSTR("FilterZeroProbability");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v313, &v312, 1);
  v15 = (id)objc_claimAutoreleasedReturnValue();
  v16 = v15;
  if (v15)
  {
    CFRetain(v15);
    v225 = v16;
    v17 = CFGetTypeID(v16);
    v18 = v16;
    if (v17 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v18 = 0;
    v225 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v225);
  if (v18)
    CFRelease(v18);

  v310 = CFSTR("FilterName");
  v311 = CFSTR("FilterIncomplete");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v311, &v310, 1);
  v19 = (id)objc_claimAutoreleasedReturnValue();
  v20 = v19;
  if (v19)
  {
    CFRetain(v19);
    v224 = v20;
    v21 = CFGetTypeID(v20);
    v22 = v20;
    if (v21 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v22 = 0;
    v224 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v224);
  if (v22)
    CFRelease(v22);

  v23 = 0x1E0C99000uLL;
  if (*(_BYTE *)(a1 + 185))
  {
    v308 = CFSTR("FilterName");
    v309 = CFSTR("FilterWithoutSupplementalWords");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v309, &v308, 1);
    v24 = (id)objc_claimAutoreleasedReturnValue();
    v25 = v24;
    if (v24)
    {
      CFRetain(v24);
      v223 = v25;
      v26 = CFGetTypeID(v25);
      v27 = v25;
      v28 = v26 == CFDictionaryGetTypeID();
      v23 = 0x1E0C99000;
      if (!v28)
        goto LABEL_209;
    }
    else
    {
      v27 = 0;
      v223 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v223);
    if (v27)
      CFRelease(v27);

    v306 = CFSTR("FilterName");
    v307 = CFSTR("FilterPartOfHyphenatedWord");
    objc_msgSend(*(id *)(v23 + 3456), "dictionaryWithObjects:forKeys:count:", &v307, &v306, 1);
    v29 = (id)objc_claimAutoreleasedReturnValue();
    v30 = v29;
    if (v29)
    {
      CFRetain(v29);
      v222 = v30;
      v31 = CFGetTypeID(v30);
      v32 = v30;
      if (v31 != CFDictionaryGetTypeID())
        goto LABEL_209;
    }
    else
    {
      v32 = 0;
      v222 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v222);
    if (v32)
      CFRelease(v32);

    v23 = 0x1E0C99000uLL;
  }
  v33 = *(_QWORD *)(a1 + 168);
  v34 = *(std::__shared_weak_count **)(a1 + 176);
  if (!v34)
    goto LABEL_32;
  p_shared_owners = (unint64_t *)&v34->__shared_owners_;
  do
    v36 = __ldxr(p_shared_owners);
  while (__stxr(v36 + 1, p_shared_owners));
  do
    v37 = __ldaxr(p_shared_owners);
  while (__stlxr(v37 - 1, p_shared_owners));
  if (!v37)
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
    if (!v33)
      goto LABEL_42;
  }
  else
  {
LABEL_32:
    if (!v33)
      goto LABEL_42;
  }
  v304 = CFSTR("FilterName");
  v305 = CFSTR("CustomFilter");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v305, &v304, 1);
  v38 = (id)objc_claimAutoreleasedReturnValue();
  v39 = v38;
  if (v38)
  {
    CFRetain(v38);
    v221 = v39;
    v40 = CFGetTypeID(v39);
    v41 = v39;
    if (v40 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v41 = 0;
    v221 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v221);
  if (v41)
    CFRelease(v41);

LABEL_42:
  v42 = _os_feature_enabled_impl();
  v43 = (_BYTE)number_to_letter_correction_locally_enabled(void)::locally_enabled != 0;
  if (!HIBYTE(number_to_letter_correction_locally_enabled(void)::locally_enabled))
    v43 = v42;
  if (v43)
  {
    v302 = CFSTR("FilterName");
    v303 = CFSTR("FilterNumberlikeTokenMismatch");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v303, &v302, 1);
    v44 = (id)objc_claimAutoreleasedReturnValue();
    v45 = v44;
    if (v44)
    {
      CFRetain(v44);
      v220 = v45;
      v46 = CFGetTypeID(v45);
      v47 = v45;
      if (v46 != CFDictionaryGetTypeID())
        goto LABEL_209;
    }
    else
    {
      v47 = 0;
      v220 = 0;
    }

    v50 = (CFTypeRef *)&v220;
  }
  else
  {
    v300 = CFSTR("FilterName");
    v301 = CFSTR("FilterNumberMismatch");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v301, &v300, 1);
    v48 = (id)objc_claimAutoreleasedReturnValue();
    v45 = v48;
    if (v48)
    {
      CFRetain(v48);
      v219 = v45;
      v49 = CFGetTypeID(v45);
      v47 = v45;
      if (v49 != CFDictionaryGetTypeID())
        goto LABEL_209;
    }
    else
    {
      v47 = 0;
      v219 = 0;
    }

    v50 = (CFTypeRef *)&v219;
  }
  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, v50);
  if (v47)
    CFRelease(v47);

  v298 = CFSTR("FilterName");
  v299 = CFSTR("FilterControlCharacters");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v299, &v298, 1);
  v51 = (id)objc_claimAutoreleasedReturnValue();
  v52 = v51;
  if (v51)
  {
    CFRetain(v51);
    v218 = v52;
    v53 = CFGetTypeID(v52);
    v54 = v52;
    if (v53 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v54 = 0;
    v218 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v218);
  if (v54)
    CFRelease(v54);

  v296 = CFSTR("FilterName");
  v297 = CFSTR("FilterAlteredURLFragments");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v297, &v296, 1);
  v55 = (id)objc_claimAutoreleasedReturnValue();
  v56 = v55;
  if (v55)
  {
    CFRetain(v55);
    v217 = v56;
    v57 = CFGetTypeID(v56);
    v58 = v56;
    if (v57 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v58 = 0;
    v217 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v217);
  if (v58)
    CFRelease(v58);

  v294 = CFSTR("FilterName");
  v295 = CFSTR("FilterDoubleApostrophe");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v295, &v294, 1);
  v59 = (id)objc_claimAutoreleasedReturnValue();
  v60 = v59;
  if (v59)
  {
    CFRetain(v59);
    v216 = v60;
    v61 = CFGetTypeID(v60);
    v62 = v60;
    if (v61 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v62 = 0;
    v216 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v216);
  if (v62)
    CFRelease(v62);

  v292 = CFSTR("FilterName");
  v293 = CFSTR("FilterWordEndingApostropheBetweenNonseparators");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v293, &v292, 1);
  v63 = (id)objc_claimAutoreleasedReturnValue();
  v64 = v63;
  if (v63)
  {
    CFRetain(v63);
    v215 = v64;
    v65 = CFGetTypeID(v64);
    v66 = v64;
    if (v65 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v66 = 0;
    v215 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v215);
  if (v66)
    CFRelease(v66);

  v291[0] = CFSTR("FilterAllCapsNoSuggestWordsOfLength");
  v290[0] = CFSTR("FilterName");
  v290[1] = CFSTR("Parameters");
  v288 = CFSTR("Length");
  v289 = &unk_1EA140348;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v289, &v288, 1);
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  v291[1] = v67;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v291, v290, 2);
  v68 = (id)objc_claimAutoreleasedReturnValue();
  v69 = v68;
  if (v68)
  {
    CFRetain(v68);
    v214 = v69;
    v70 = CFGetTypeID(v69);
    v71 = v69;
    v28 = v70 == CFDictionaryGetTypeID();
    v23 = 0x1E0C99000;
    if (!v28)
      goto LABEL_209;
  }
  else
  {
    v71 = 0;
    v214 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v214);
  if (v71)
    CFRelease(v71);

  v286 = CFSTR("FilterName");
  v287 = CFSTR("FilterPopupVariantMismatch");
  objc_msgSend(*(id *)(v23 + 3456), "dictionaryWithObjects:forKeys:count:", &v287, &v286, 1);
  v72 = (id)objc_claimAutoreleasedReturnValue();
  v73 = v72;
  if (v72)
  {
    CFRetain(v72);
    v213 = v73;
    v74 = CFGetTypeID(v73);
    v75 = v73;
    if (v74 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v75 = 0;
    v213 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v213);
  if (v75)
    CFRelease(v75);

  v285[0] = CFSTR("FilterCharacterCount");
  v284[0] = CFSTR("FilterName");
  v284[1] = CFSTR("Parameters");
  v282[0] = CFSTR("Character");
  v282[1] = CFSTR("CharacterCountRelation");
  v283[0] = CFSTR("&");
  v283[1] = CFSTR("GreaterThanOrEqualToInputCount");
  objc_msgSend(*(id *)(v23 + 3456), "dictionaryWithObjects:forKeys:count:", v283, v282, 2);
  v76 = (void *)objc_claimAutoreleasedReturnValue();
  v285[1] = v76;
  objc_msgSend(*(id *)(v23 + 3456), "dictionaryWithObjects:forKeys:count:", v285, v284, 2);
  v77 = (id)objc_claimAutoreleasedReturnValue();
  v78 = v77;
  if (v77)
  {
    CFRetain(v77);
    v212 = v78;
    v79 = CFGetTypeID(v78);
    v80 = v78;
    v28 = v79 == CFDictionaryGetTypeID();
    v23 = 0x1E0C99000;
    if (!v28)
      goto LABEL_209;
  }
  else
  {
    v80 = 0;
    v212 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v212);
  if (v80)
    CFRelease(v80);

  v280 = CFSTR("FilterName");
  v281 = CFSTR("FilterContactWordsConflictingWithValidInput");
  objc_msgSend(*(id *)(v23 + 3456), "dictionaryWithObjects:forKeys:count:", &v281, &v280, 1);
  v81 = (id)objc_claimAutoreleasedReturnValue();
  v82 = v81;
  if (v81)
  {
    CFRetain(v81);
    v211 = v82;
    v83 = CFGetTypeID(v82);
    v84 = v82;
    if (v83 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v84 = 0;
    v211 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v211);
  if (v84)
    CFRelease(v84);

  v279[0] = CFSTR("FilterWordsConflictingWithValidContactNames");
  v278[0] = CFSTR("FilterName");
  v278[1] = CFSTR("Parameters");
  v276 = CFSTR("LanguagePowerRatio");
  LODWORD(v85) = v14;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v85);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  v277 = v86;
  objc_msgSend(*(id *)(v23 + 3456), "dictionaryWithObjects:forKeys:count:", &v277, &v276, 1);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  v279[1] = v87;
  objc_msgSend(*(id *)(v23 + 3456), "dictionaryWithObjects:forKeys:count:", v279, v278, 2);
  v88 = (id)objc_claimAutoreleasedReturnValue();
  v89 = v88;
  if (v88)
  {
    CFRetain(v88);
    v210 = v89;
    v90 = CFGetTypeID(v89);
    v91 = v89;
    if (v90 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v91 = 0;
    v210 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v210);
  if (v91)
    CFRelease(v91);

  v274 = CFSTR("FilterName");
  v275 = CFSTR("RescoreShortWords");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v275, &v274, 1);
  v92 = (id)objc_claimAutoreleasedReturnValue();
  v93 = v92;
  if (v92)
  {
    CFRetain(v92);
    v209 = v93;
    v94 = CFGetTypeID(v93);
    v95 = v93;
    if (v94 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v95 = 0;
    v209 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v209);
  if (v95)
    CFRelease(v95);

  v272 = CFSTR("FilterName");
  v273 = CFSTR("FilterMissingOneLetterWordFromInput");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v273, &v272, 1);
  v96 = (id)objc_claimAutoreleasedReturnValue();
  v97 = v96;
  if (v96)
  {
    CFRetain(v96);
    v208 = v97;
    v98 = CFGetTypeID(v97);
    v99 = v97;
    if (v98 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v99 = 0;
    v208 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v208);
  if (v99)
    CFRelease(v99);

  v270 = CFSTR("FilterName");
  v271 = CFSTR("FilterCommonLearnedTypos");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v271, &v270, 1);
  v100 = (id)objc_claimAutoreleasedReturnValue();
  v101 = v100;
  if (v100)
  {
    CFRetain(v100);
    v207 = v101;
    v102 = CFGetTypeID(v101);
    v103 = v101;
    if (v102 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v103 = 0;
    v207 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v207);
  if (v103)
    CFRelease(v103);

  v269[0] = CFSTR("FilterSortkeyMatchFromDifferentLanguage");
  v268[0] = CFSTR("FilterName");
  v268[1] = CFSTR("Parameters");
  v266[0] = CFSTR("MinConfidenceToEstablishCurrentLanguage");
  LODWORD(v104) = v10;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v104);
  v105 = (void *)objc_claimAutoreleasedReturnValue();
  v267[0] = v105;
  v266[1] = CFSTR("SameLanguageSortkeyMatchDominanceRatio");
  LODWORD(v106) = v12;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v106);
  v107 = (void *)objc_claimAutoreleasedReturnValue();
  v267[1] = v107;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v267, v266, 2);
  v108 = (void *)objc_claimAutoreleasedReturnValue();
  v269[1] = v108;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v269, v268, 2);
  v109 = (id)objc_claimAutoreleasedReturnValue();
  v110 = v109;
  if (v109)
  {
    CFRetain(v109);
    v206 = v110;
    v111 = CFGetTypeID(v110);
    v112 = v110;
    if (v111 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v112 = 0;
    v206 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v206);
  if (v112)
    CFRelease(v112);

  v265[0] = CFSTR("FilterNondominantCorrectionOfMoreWords");
  v264[0] = CFSTR("FilterName");
  v264[1] = CFSTR("Parameters");
  v262[0] = CFSTR("SortKeyMatchBoostRatio");
  LODWORD(v113) = v7;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v113);
  v114 = (void *)objc_claimAutoreleasedReturnValue();
  v263[0] = v114;
  v262[1] = CFSTR("NonRetrocorrectionBoostRatio");
  LODWORD(v115) = v6;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v115);
  v116 = (void *)objc_claimAutoreleasedReturnValue();
  v263[1] = v116;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v263, v262, 2);
  v117 = (void *)objc_claimAutoreleasedReturnValue();
  v265[1] = v117;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v265, v264, 2);
  v118 = (id)objc_claimAutoreleasedReturnValue();
  v119 = v118;
  if (v118)
  {
    CFRetain(v118);
    v205 = v119;
    v120 = CFGetTypeID(v119);
    v121 = v119;
    if (v120 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v121 = 0;
    v205 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v205);
  if (v121)
    CFRelease(v121);

  v261[0] = CFSTR("FilterNotSuggestibleForInput");
  v260[0] = CFSTR("FilterName");
  v260[1] = CFSTR("Parameters");
  v258[0] = CFSTR("WordEquivalenceType");
  v258[1] = CFSTR("ApplyFilterCondition");
  v259[0] = CFSTR("SortkeyEquivalence");
  v259[1] = CFSTR("ApplyAlways");
  v258[2] = CFSTR("ShouldRemoveVulgar");
  v259[2] = CFSTR("DoNotRemoveVulgar");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v259, v258, 3);
  v122 = (void *)objc_claimAutoreleasedReturnValue();
  v261[1] = v122;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v261, v260, 2);
  v123 = (id)objc_claimAutoreleasedReturnValue();
  v124 = v123;
  if (v123)
  {
    CFRetain(v123);
    v204 = v124;
    v125 = CFGetTypeID(v124);
    v126 = v124;
    if (v125 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v126 = 0;
    v204 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v204);
  if (v126)
    CFRelease(v126);

  v256 = CFSTR("FilterName");
  v257 = CFSTR("FilterNonVulgarIfTopCandidateVulgar");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v257, &v256, 1);
  v127 = (id)objc_claimAutoreleasedReturnValue();
  v128 = v127;
  if (v127)
  {
    CFRetain(v127);
    v203 = v128;
    v129 = CFGetTypeID(v128);
    v130 = v128;
    if (v129 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v130 = 0;
    v203 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v203);
  if (v130)
    CFRelease(v130);

  v255[0] = CFSTR("BoostMinimumVariation");
  v254[0] = CFSTR("FilterName");
  v254[1] = CFSTR("Parameters");
  v252 = CFSTR("MinCandidateDominanceRatio");
  LODWORD(v131) = v5;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v131);
  v132 = (void *)objc_claimAutoreleasedReturnValue();
  v253 = v132;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v253, &v252, 1);
  v133 = (void *)objc_claimAutoreleasedReturnValue();
  v255[1] = v133;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v255, v254, 2);
  v134 = (id)objc_claimAutoreleasedReturnValue();
  v135 = v134;
  if (v134)
  {
    CFRetain(v134);
    v202 = v135;
    v136 = CFGetTypeID(v135);
    v137 = v135;
    if (v136 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v137 = 0;
    v202 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v202);
  if (v137)
    CFRelease(v137);

  v250 = CFSTR("FilterName");
  v251 = CFSTR("FilterInvalidTextReplacement");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v251, &v250, 1);
  v138 = (id)objc_claimAutoreleasedReturnValue();
  v139 = v138;
  if (v138)
  {
    CFRetain(v138);
    v201 = v139;
    v140 = CFGetTypeID(v139);
    v141 = v139;
    if (v140 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v141 = 0;
    v201 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v201);
  if (v141)
    CFRelease(v141);

  v248 = CFSTR("FilterName");
  v249 = CFSTR("FilterLearnedTypo");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v249, &v248, 1);
  v142 = (id)objc_claimAutoreleasedReturnValue();
  v143 = v142;
  if (v142)
  {
    CFRetain(v142);
    v200 = v143;
    v144 = CFGetTypeID(v143);
    v145 = v143;
    if (v144 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v145 = 0;
    v200 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v200);
  if (v145)
    CFRelease(v145);

  v246 = CFSTR("FilterName");
  v247 = CFSTR("FilterCaseVariantsOfStaticWords");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v247, &v246, 1);
  v146 = (id)objc_claimAutoreleasedReturnValue();
  v147 = v146;
  if (v146)
  {
    CFRetain(v146);
    v199 = v147;
    v148 = CFGetTypeID(v147);
    v149 = v147;
    if (v148 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v149 = 0;
    v199 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v199);
  if (v149)
    CFRelease(v149);

  v245[0] = CFSTR("FilterTopDynamicWordsWithStaticVariant");
  v244[0] = CFSTR("FilterName");
  v244[1] = CFSTR("Parameters");
  v242[0] = CFSTR("MinUsageCountForDynamicCaseVariant");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v13);
  v150 = (void *)objc_claimAutoreleasedReturnValue();
  v243[0] = v150;
  v242[1] = CFSTR("MinOmegaRatioForDynamicCaseVariant");
  LODWORD(v151) = v11;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v151);
  v152 = (void *)objc_claimAutoreleasedReturnValue();
  v243[1] = v152;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v243, v242, 2);
  v153 = (void *)objc_claimAutoreleasedReturnValue();
  v245[1] = v153;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v245, v244, 2);
  v154 = (id)objc_claimAutoreleasedReturnValue();
  v155 = v154;
  if (v154)
  {
    CFRetain(v154);
    v198 = v155;
    v156 = CFGetTypeID(v155);
    v157 = v155;
    if (v156 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v157 = 0;
    v198 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v198);
  if (v157)
    CFRelease(v157);

  v241[0] = CFSTR("BoostPreferedFormForSortkey");
  v240[0] = CFSTR("FilterName");
  v240[1] = CFSTR("Parameters");
  v238 = CFSTR("MinSuggestionDominanceRatio");
  LODWORD(v158) = v4;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v158);
  v159 = (void *)objc_claimAutoreleasedReturnValue();
  v239 = v159;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v239, &v238, 1);
  v160 = (void *)objc_claimAutoreleasedReturnValue();
  v241[1] = v160;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v241, v240, 2);
  v161 = (id)objc_claimAutoreleasedReturnValue();
  v162 = v161;
  if (v161)
  {
    CFRetain(v161);
    v197 = v162;
    v163 = CFGetTypeID(v162);
    v164 = v162;
    if (v163 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v164 = 0;
    v197 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v197);
  if (v164)
    CFRelease(v164);

  v236[0] = CFSTR("FilterName");
  v236[1] = CFSTR("Parameters");
  v237[0] = CFSTR("ChooseTopQualityAutocorrection");
  v234[0] = CFSTR("MinLinguisticSynergyForComplexCorrection");
  LODWORD(v165) = v191;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v165);
  v166 = (void *)objc_claimAutoreleasedReturnValue();
  v235[0] = v166;
  v234[1] = CFSTR("MinSuggestionDominanceRatio");
  LODWORD(v167) = v4;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v167);
  v168 = (void *)objc_claimAutoreleasedReturnValue();
  v235[1] = v168;
  v234[2] = CFSTR("MinStemLengthForPredictingOneLetter");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v9);
  v169 = (void *)objc_claimAutoreleasedReturnValue();
  v235[2] = v169;
  v234[3] = CFSTR("MinStemLengthForPredictingTwoLetters");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v8);
  v170 = (void *)objc_claimAutoreleasedReturnValue();
  v235[3] = v170;
  v234[4] = CFSTR("MinStemLengthForPredictingThreeLetters");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v192);
  v171 = (void *)objc_claimAutoreleasedReturnValue();
  v235[4] = v171;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v235, v234, 5);
  v172 = (void *)objc_claimAutoreleasedReturnValue();
  v237[1] = v172;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v237, v236, 2);
  v173 = (id)objc_claimAutoreleasedReturnValue();
  v174 = v173;
  if (v173)
  {
    CFRetain(v173);
    v196 = v174;
    v175 = CFGetTypeID(v174);
    v176 = v174;
    if (v175 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v176 = 0;
    v196 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v196);
  if (v176)
    CFRelease(v176);

  v232[0] = CFSTR("FilterName");
  v232[1] = CFSTR("Parameters");
  v233[0] = CFSTR("FilterNotSuggestibleForInput");
  v230[0] = CFSTR("WordEquivalenceType");
  v230[1] = CFSTR("ApplyFilterCondition");
  v231[0] = CFSTR("SurfaceFormEquivalence");
  v231[1] = CFSTR("ApplyAlways");
  v230[2] = CFSTR("ShouldRemoveVulgar");
  v231[2] = CFSTR("RemoveVulgarOnlyIfNotAllowlisted");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v231, v230, 3);
  v177 = (void *)objc_claimAutoreleasedReturnValue();
  v233[1] = v177;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v233, v232, 2);
  v178 = (id)objc_claimAutoreleasedReturnValue();
  v179 = v178;
  if (v178)
  {
    CFRetain(v178);
    v195 = v179;
    v180 = CFGetTypeID(v179);
    v181 = v179;
    if (v180 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v181 = 0;
    v195 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v195);
  if (v181)
    CFRelease(v181);

  v228 = CFSTR("FilterName");
  v229 = CFSTR("RemoveAlternatesIfNoLinguisticCandidate");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v229, &v228, 1);
  v182 = (id)objc_claimAutoreleasedReturnValue();
  v183 = v182;
  if (v182)
  {
    CFRetain(v182);
    v194 = v183;
    v184 = CFGetTypeID(v183);
    v185 = v183;
    if (v184 != CFDictionaryGetTypeID())
    {
LABEL_209:
      exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(exception);
    }
  }
  else
  {
    v185 = 0;
    v194 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v194);
  if (v185)
    CFRelease(v185);

  v226 = CFSTR("FilterName");
  v227 = CFSTR("FilterDuplicates");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v227, &v226, 1);
  v186 = (id)objc_claimAutoreleasedReturnValue();
  v187 = v186;
  if (v186)
  {
    CFRetain(v186);
    v193 = v187;
    v188 = CFGetTypeID(v187);
    v189 = v187;
    if (v188 != CFDictionaryGetTypeID())
      goto LABEL_209;
  }
  else
  {
    v189 = 0;
    v193 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v193);
  if (v189)
    CFRelease(v189);

}

void KB::CandidateFilterFactory::create_standard_autocorrect_filter_definition(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  id v14;
  void *v15;
  CFTypeID v16;
  const void *v17;
  BOOL v18;
  double v19;
  void *v20;
  uint64_t v21;
  unint64_t v22;
  void *v23;
  id v24;
  void *v25;
  CFTypeID v26;
  const void *v27;
  id v28;
  void *v29;
  CFTypeID v30;
  const void *v31;
  id v32;
  void *v33;
  CFTypeID v34;
  const void *v35;
  id v36;
  void *v37;
  CFTypeID v38;
  const void *v39;
  id v40;
  void *v41;
  CFTypeID v42;
  const void *v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  unint64_t v48;
  id v49;
  void *v50;
  CFTypeID v51;
  const void *v52;
  id v53;
  void *v54;
  CFTypeID v55;
  const void *v56;
  void *v57;
  void *v58;
  id v59;
  void *v60;
  CFTypeID v61;
  const void *v62;
  void *v63;
  id v64;
  void *v65;
  CFTypeID v66;
  const void *v67;
  id v68;
  void *v69;
  CFTypeID v70;
  const void *v71;
  double v72;
  void *v73;
  void *v74;
  id v75;
  void *v76;
  CFTypeID v77;
  const void *v78;
  int v79;
  _BOOL4 v80;
  id v81;
  void *v82;
  CFTypeID v83;
  const void *v84;
  id v85;
  CFTypeID v86;
  CFTypeRef *v87;
  void *v88;
  id v89;
  void *v90;
  CFTypeID v91;
  const void *v92;
  id v93;
  void *v94;
  CFTypeID v95;
  const void *v96;
  id v97;
  void *v98;
  CFTypeID v99;
  const void *v100;
  id v101;
  void *v102;
  CFTypeID v103;
  const void *v104;
  id v105;
  void *v106;
  CFTypeID v107;
  const void *v108;
  id v109;
  void *v110;
  CFTypeID v111;
  const void *v112;
  id v113;
  void *v114;
  CFTypeID v115;
  const void *v116;
  void *v117;
  double v118;
  void *v119;
  void *v120;
  id v121;
  void *v122;
  CFTypeID v123;
  const void *v124;
  double v125;
  void *v126;
  void *v127;
  id v128;
  void *v129;
  CFTypeID v130;
  const void *v131;
  double v132;
  void *v133;
  double v134;
  void *v135;
  void *v136;
  void *v137;
  void *v138;
  void *v139;
  id v140;
  void *v141;
  CFTypeID v142;
  const void *v143;
  void *v144;
  id v145;
  void *v146;
  CFTypeID v147;
  const void *v148;
  id v149;
  void *v150;
  CFTypeID v151;
  const void *v152;
  id v153;
  void *v154;
  CFTypeID v155;
  const void *v156;
  applesauce::CF *exception;
  unsigned int v158;
  unsigned int v159;
  CFTypeRef v160;
  CFTypeRef v161;
  CFTypeRef v162;
  CFTypeRef v163;
  CFTypeRef v164;
  CFTypeRef v165;
  CFTypeRef v166;
  CFTypeRef v167;
  CFTypeRef v168;
  CFTypeRef v169;
  CFTypeRef v170;
  CFTypeRef v171;
  CFTypeRef v172;
  void *v173;
  void *v174;
  CFTypeRef v175;
  CFTypeRef v176;
  CFTypeRef v177;
  CFTypeRef v178;
  CFTypeRef v179;
  CFTypeRef v180;
  CFTypeRef v181;
  CFTypeRef v182;
  CFTypeRef v183;
  CFTypeRef v184;
  CFTypeRef v185;
  CFTypeRef v186;
  const __CFString *v187;
  const __CFString *v188;
  const __CFString *v189;
  const __CFString *v190;
  _QWORD v191[3];
  _QWORD v192[3];
  _QWORD v193[2];
  _QWORD v194[2];
  _QWORD v195[5];
  _QWORD v196[5];
  _QWORD v197[2];
  _QWORD v198[2];
  const __CFString *v199;
  void *v200;
  _QWORD v201[2];
  _QWORD v202[2];
  _QWORD v203[2];
  _QWORD v204[2];
  _QWORD v205[2];
  _QWORD v206[2];
  const __CFString *v207;
  const __CFString *v208;
  const __CFString *v209;
  const __CFString *v210;
  const __CFString *v211;
  const __CFString *v212;
  const __CFString *v213;
  const __CFString *v214;
  const __CFString *v215;
  const __CFString *v216;
  const __CFString *v217;
  const __CFString *v218;
  _QWORD v219[2];
  _QWORD v220[2];
  _QWORD v221[2];
  _QWORD v222[2];
  const __CFString *v223;
  const __CFString *v224;
  const __CFString *v225;
  const __CFString *v226;
  const __CFString *v227;
  void *v228;
  _QWORD v229[2];
  _QWORD v230[2];
  const __CFString *v231;
  const __CFString *v232;
  _QWORD v233[3];
  _QWORD v234[3];
  _QWORD v235[2];
  _QWORD v236[2];
  const __CFString *v237;
  void *v238;
  _QWORD v239[2];
  _QWORD v240[2];
  const __CFString *v241;
  const __CFString *v242;
  const __CFString *v243;
  const __CFString *v244;
  const __CFString *v245;
  const __CFString *v246;
  const __CFString *v247;
  const __CFString *v248;
  const __CFString *v249;
  const __CFString *v250;
  const __CFString *v251;
  const __CFString *v252;
  const __CFString *v253;
  void *v254;
  _QWORD v255[2];
  _QWORD v256[2];
  const __CFString *v257;
  _QWORD v258[3];

  v258[1] = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 40);
  v5 = *(_DWORD *)(a1 + 44);
  v6 = *(_DWORD *)(a1 + 60);
  v7 = *(_DWORD *)(a1 + 80);
  v159 = *(_DWORD *)(a1 + 84);
  v8 = *(_DWORD *)(a1 + 88);
  v9 = *(_DWORD *)(a1 + 104);
  v10 = *(unsigned int *)(a1 + 108);
  v11 = *(_DWORD *)(a1 + 120);
  v12 = *(unsigned int *)(a1 + 124);
  v257 = CFSTR("FilterName");
  v258[0] = CFSTR("FilterZeroProbability");
  v13 = 0x1E0C99000uLL;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v258, &v257, 1);
  v14 = (id)objc_claimAutoreleasedReturnValue();
  v15 = v14;
  if (v14)
  {
    CFRetain(v14);
    v186 = v15;
    v16 = CFGetTypeID(v15);
    v17 = v15;
    v18 = v16 == CFDictionaryGetTypeID();
    v13 = 0x1E0C99000;
    if (!v18)
      goto LABEL_175;
  }
  else
  {
    v17 = 0;
    v186 = 0;
  }
  v158 = v8;

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v186);
  if (v17)
    CFRelease(v17);

  v255[0] = CFSTR("FilterName");
  v255[1] = CFSTR("Parameters");
  v256[0] = CFSTR("FilterWordsConflictingWithValidContactNames");
  v253 = CFSTR("LanguagePowerRatio");
  LODWORD(v19) = v11;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v19);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v254 = v20;
  objc_msgSend(*(id *)(v13 + 3456), "dictionaryWithObjects:forKeys:count:", &v254, &v253, 1);
  v21 = objc_claimAutoreleasedReturnValue();
  v22 = v13;
  v23 = (void *)v21;
  v256[1] = v21;
  objc_msgSend(*(id *)(v22 + 3456), "dictionaryWithObjects:forKeys:count:", v256, v255, 2);
  v24 = (id)objc_claimAutoreleasedReturnValue();
  v25 = v24;
  if (v24)
  {
    CFRetain(v24);
    v185 = v25;
    v26 = CFGetTypeID(v25);
    v27 = v25;
    if (v26 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v27 = 0;
    v185 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v185);
  if (v27)
    CFRelease(v27);

  v251 = CFSTR("FilterName");
  v252 = CFSTR("RescoreShortWords");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v252, &v251, 1);
  v28 = (id)objc_claimAutoreleasedReturnValue();
  v29 = v28;
  if (v28)
  {
    CFRetain(v28);
    v184 = v29;
    v30 = CFGetTypeID(v29);
    v31 = v29;
    if (v30 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v31 = 0;
    v184 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v184);
  if (v31)
    CFRelease(v31);

  v249 = CFSTR("FilterName");
  v250 = CFSTR("FilterIncomplete");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v250, &v249, 1);
  v32 = (id)objc_claimAutoreleasedReturnValue();
  v33 = v32;
  if (v32)
  {
    CFRetain(v32);
    v183 = v33;
    v34 = CFGetTypeID(v33);
    v35 = v33;
    if (v34 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v35 = 0;
    v183 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v183);
  if (v35)
    CFRelease(v35);

  if (*(_BYTE *)(a1 + 185))
  {
    v247 = CFSTR("FilterName");
    v248 = CFSTR("FilterWithoutSupplementalWords");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v248, &v247, 1);
    v36 = (id)objc_claimAutoreleasedReturnValue();
    v37 = v36;
    if (v36)
    {
      CFRetain(v36);
      v182 = v37;
      v38 = CFGetTypeID(v37);
      v39 = v37;
      if (v38 != CFDictionaryGetTypeID())
        goto LABEL_175;
    }
    else
    {
      v39 = 0;
      v182 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v182);
    if (v39)
      CFRelease(v39);

    v245 = CFSTR("FilterName");
    v246 = CFSTR("FilterPartOfHyphenatedWord");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v246, &v245, 1);
    v40 = (id)objc_claimAutoreleasedReturnValue();
    v41 = v40;
    if (v40)
    {
      CFRetain(v40);
      v181 = v41;
      v42 = CFGetTypeID(v41);
      v43 = v41;
      if (v42 != CFDictionaryGetTypeID())
        goto LABEL_175;
    }
    else
    {
      v43 = 0;
      v181 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v181);
    if (v43)
      CFRelease(v43);

  }
  v44 = *(_QWORD *)(a1 + 168);
  v45 = *(std::__shared_weak_count **)(a1 + 176);
  if (!v45)
    goto LABEL_44;
  p_shared_owners = (unint64_t *)&v45->__shared_owners_;
  do
    v47 = __ldxr(p_shared_owners);
  while (__stxr(v47 + 1, p_shared_owners));
  do
    v48 = __ldaxr(p_shared_owners);
  while (__stlxr(v48 - 1, p_shared_owners));
  if (!v48)
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
    if (!v44)
      goto LABEL_54;
  }
  else
  {
LABEL_44:
    if (!v44)
      goto LABEL_54;
  }
  v243 = CFSTR("FilterName");
  v244 = CFSTR("CustomFilter");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v244, &v243, 1);
  v49 = (id)objc_claimAutoreleasedReturnValue();
  v50 = v49;
  if (v49)
  {
    CFRetain(v49);
    v180 = v50;
    v51 = CFGetTypeID(v50);
    v52 = v50;
    if (v51 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v52 = 0;
    v180 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v180);
  if (v52)
    CFRelease(v52);

LABEL_54:
  v241 = CFSTR("FilterName");
  v242 = CFSTR("FilterControlCharacters");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v242, &v241, 1);
  v53 = (id)objc_claimAutoreleasedReturnValue();
  v54 = v53;
  if (v53)
  {
    CFRetain(v53);
    v179 = v54;
    v55 = CFGetTypeID(v54);
    v56 = v54;
    if (v55 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v56 = 0;
    v179 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v179);
  if (v56)
    CFRelease(v56);

  if (!*(_BYTE *)(a1 + 188))
  {
    v240[0] = CFSTR("FilterCorrectionsIfAnyCandidateMatchesInput");
    v239[0] = CFSTR("FilterName");
    v239[1] = CFSTR("Parameters");
    v237 = CFSTR("WithinTopXAutocorrectionCandidates");
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v12);
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    v238 = v57;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v238, &v237, 1);
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    v240[1] = v58;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v240, v239, 2);
    v59 = (id)objc_claimAutoreleasedReturnValue();
    v60 = v59;
    if (v59)
    {
      CFRetain(v59);
      v178 = v60;
      v61 = CFGetTypeID(v60);
      v62 = v60;
      if (v61 != CFDictionaryGetTypeID())
        goto LABEL_175;
    }
    else
    {
      v62 = 0;
      v178 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v178);
    if (v62)
      CFRelease(v62);

  }
  v236[0] = CFSTR("FilterNotSuggestibleForInput");
  v235[0] = CFSTR("FilterName");
  v235[1] = CFSTR("Parameters");
  v233[0] = CFSTR("WordEquivalenceType");
  v233[1] = CFSTR("ApplyFilterCondition");
  v234[0] = CFSTR("SortkeyEquivalence");
  v234[1] = CFSTR("ApplyIfCandidatesContainInputMatch");
  v233[2] = CFSTR("ShouldRemoveVulgar");
  v234[2] = CFSTR("DoNotRemoveVulgar");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v234, v233, 3);
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  v236[1] = v63;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v236, v235, 2);
  v64 = (id)objc_claimAutoreleasedReturnValue();
  v65 = v64;
  if (v64)
  {
    CFRetain(v64);
    v177 = v65;
    v66 = CFGetTypeID(v65);
    v67 = v65;
    if (v66 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v67 = 0;
    v177 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v177);
  if (v67)
    CFRelease(v67);

  v231 = CFSTR("FilterName");
  v232 = CFSTR("FilterNonVulgarIfTopCandidateVulgar");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v232, &v231, 1);
  v68 = (id)objc_claimAutoreleasedReturnValue();
  v69 = v68;
  if (v68)
  {
    CFRetain(v68);
    v176 = v69;
    v70 = CFGetTypeID(v69);
    v71 = v69;
    if (v70 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v71 = 0;
    v176 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v176);
  if (v71)
    CFRelease(v71);

  v230[0] = CFSTR("BoostMinimumVariation");
  v229[0] = CFSTR("FilterName");
  v229[1] = CFSTR("Parameters");
  v227 = CFSTR("MinCandidateDominanceRatio");
  LODWORD(v72) = v5;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v72);
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  v228 = v73;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v228, &v227, 1);
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  v230[1] = v74;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v230, v229, 2);
  v75 = (id)objc_claimAutoreleasedReturnValue();
  v76 = v75;
  if (v75)
  {
    CFRetain(v75);
    v175 = v76;
    v77 = CFGetTypeID(v76);
    v78 = v76;
    if (v77 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v78 = 0;
    v175 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v175);
  if (v78)
    CFRelease(v78);

  v79 = _os_feature_enabled_impl();
  v80 = (_BYTE)number_to_letter_correction_locally_enabled(void)::locally_enabled != 0;
  if (!HIBYTE(number_to_letter_correction_locally_enabled(void)::locally_enabled))
    v80 = v79;
  if (v80)
  {
    v225 = CFSTR("FilterName");
    v226 = CFSTR("FilterNumberlikeTokenMismatch");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v226, &v225, 1);
    v81 = (id)objc_claimAutoreleasedReturnValue();
    v82 = v81;
    if (v81)
    {
      CFRetain(v81);
      v174 = v82;
      v83 = CFGetTypeID(v82);
      v84 = v82;
      if (v83 != CFDictionaryGetTypeID())
        goto LABEL_175;
    }
    else
    {
      v84 = 0;
      v174 = 0;
    }

    v87 = (CFTypeRef *)&v174;
  }
  else
  {
    v223 = CFSTR("FilterName");
    v224 = CFSTR("FilterNumberMismatch");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v224, &v223, 1);
    v85 = (id)objc_claimAutoreleasedReturnValue();
    v82 = v85;
    if (v85)
    {
      CFRetain(v85);
      v173 = v82;
      v86 = CFGetTypeID(v82);
      v84 = v82;
      if (v86 != CFDictionaryGetTypeID())
        goto LABEL_175;
    }
    else
    {
      v84 = 0;
      v173 = 0;
    }

    v87 = (CFTypeRef *)&v173;
  }
  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, v87);
  if (v84)
    CFRelease(v84);

  v222[0] = CFSTR("FilterCharacterCount");
  v221[0] = CFSTR("FilterName");
  v221[1] = CFSTR("Parameters");
  v219[0] = CFSTR("Character");
  v219[1] = CFSTR("CharacterCountRelation");
  v220[0] = CFSTR("&");
  v220[1] = CFSTR("LessThanOrEqualToInputCount");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v220, v219, 2);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  v222[1] = v88;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v222, v221, 2);
  v89 = (id)objc_claimAutoreleasedReturnValue();
  v90 = v89;
  if (v89)
  {
    CFRetain(v89);
    v172 = v90;
    v91 = CFGetTypeID(v90);
    v92 = v90;
    if (v91 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v92 = 0;
    v172 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v172);
  if (v92)
    CFRelease(v92);

  v217 = CFSTR("FilterName");
  v218 = CFSTR("FilterAlteredURLFragments");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v218, &v217, 1);
  v93 = (id)objc_claimAutoreleasedReturnValue();
  v94 = v93;
  if (v93)
  {
    CFRetain(v93);
    v171 = v94;
    v95 = CFGetTypeID(v94);
    v96 = v94;
    if (v95 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v96 = 0;
    v171 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v171);
  if (v96)
    CFRelease(v96);

  v215 = CFSTR("FilterName");
  v216 = CFSTR("FilterDoubleApostrophe");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v216, &v215, 1);
  v97 = (id)objc_claimAutoreleasedReturnValue();
  v98 = v97;
  if (v97)
  {
    CFRetain(v97);
    v170 = v98;
    v99 = CFGetTypeID(v98);
    v100 = v98;
    if (v99 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v100 = 0;
    v170 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v170);
  if (v100)
    CFRelease(v100);

  v213 = CFSTR("FilterName");
  v214 = CFSTR("FilterWordEndingApostropheBetweenNonseparators");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v214, &v213, 1);
  v101 = (id)objc_claimAutoreleasedReturnValue();
  v102 = v101;
  if (v101)
  {
    CFRetain(v101);
    v169 = v102;
    v103 = CFGetTypeID(v102);
    v104 = v102;
    if (v103 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v104 = 0;
    v169 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v169);
  if (v104)
    CFRelease(v104);

  v211 = CFSTR("FilterName");
  v212 = CFSTR("FilterInvalidTextReplacement");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v212, &v211, 1);
  v105 = (id)objc_claimAutoreleasedReturnValue();
  v106 = v105;
  if (v105)
  {
    CFRetain(v105);
    v168 = v106;
    v107 = CFGetTypeID(v106);
    v108 = v106;
    if (v107 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v108 = 0;
    v168 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v168);
  if (v108)
    CFRelease(v108);

  v209 = CFSTR("FilterName");
  v210 = CFSTR("FilterLearnedTypo");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v210, &v209, 1);
  v109 = (id)objc_claimAutoreleasedReturnValue();
  v110 = v109;
  if (v109)
  {
    CFRetain(v109);
    v167 = v110;
    v111 = CFGetTypeID(v110);
    v112 = v110;
    if (v111 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v112 = 0;
    v167 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v167);
  if (v112)
    CFRelease(v112);

  v207 = CFSTR("FilterName");
  v208 = CFSTR("FilterCaseVariantsOfStaticWords");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v208, &v207, 1);
  v113 = (id)objc_claimAutoreleasedReturnValue();
  v114 = v113;
  if (v113)
  {
    CFRetain(v113);
    v166 = v114;
    v115 = CFGetTypeID(v114);
    v116 = v114;
    if (v115 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v116 = 0;
    v166 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v166);
  if (v116)
    CFRelease(v116);

  v206[0] = CFSTR("FilterTopDynamicWordsWithStaticVariant");
  v205[0] = CFSTR("FilterName");
  v205[1] = CFSTR("Parameters");
  v203[0] = CFSTR("MinUsageCountForDynamicCaseVariant");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v10);
  v117 = (void *)objc_claimAutoreleasedReturnValue();
  v204[0] = v117;
  v203[1] = CFSTR("MinOmegaRatioForDynamicCaseVariant");
  LODWORD(v118) = v9;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v118);
  v119 = (void *)objc_claimAutoreleasedReturnValue();
  v204[1] = v119;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v204, v203, 2);
  v120 = (void *)objc_claimAutoreleasedReturnValue();
  v206[1] = v120;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v206, v205, 2);
  v121 = (id)objc_claimAutoreleasedReturnValue();
  v122 = v121;
  if (v121)
  {
    CFRetain(v121);
    v165 = v122;
    v123 = CFGetTypeID(v122);
    v124 = v122;
    if (v123 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v124 = 0;
    v165 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v165);
  if (v124)
    CFRelease(v124);

  v201[0] = CFSTR("FilterName");
  v201[1] = CFSTR("Parameters");
  v202[0] = CFSTR("BoostPreferedFormForSortkey");
  v199 = CFSTR("MinSuggestionDominanceRatio");
  LODWORD(v125) = v4;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v125);
  v126 = (void *)objc_claimAutoreleasedReturnValue();
  v200 = v126;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v200, &v199, 1);
  v127 = (void *)objc_claimAutoreleasedReturnValue();
  v202[1] = v127;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v202, v201, 2);
  v128 = (id)objc_claimAutoreleasedReturnValue();
  v129 = v128;
  if (v128)
  {
    CFRetain(v128);
    v164 = v129;
    v130 = CFGetTypeID(v129);
    v131 = v129;
    if (v130 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v131 = 0;
    v164 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v164);
  if (v131)
    CFRelease(v131);

  v197[0] = CFSTR("FilterName");
  v197[1] = CFSTR("Parameters");
  v198[0] = CFSTR("ChooseTopQualityAutocorrection");
  v195[0] = CFSTR("MinLinguisticSynergyForComplexCorrection");
  LODWORD(v132) = v6;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v132);
  v133 = (void *)objc_claimAutoreleasedReturnValue();
  v196[0] = v133;
  v195[1] = CFSTR("MinSuggestionDominanceRatio");
  LODWORD(v134) = v4;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v134);
  v135 = (void *)objc_claimAutoreleasedReturnValue();
  v196[1] = v135;
  v195[2] = CFSTR("MinStemLengthForPredictingOneLetter");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v7);
  v136 = (void *)objc_claimAutoreleasedReturnValue();
  v196[2] = v136;
  v195[3] = CFSTR("MinStemLengthForPredictingTwoLetters");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v159);
  v137 = (void *)objc_claimAutoreleasedReturnValue();
  v196[3] = v137;
  v195[4] = CFSTR("MinStemLengthForPredictingThreeLetters");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v158);
  v138 = (void *)objc_claimAutoreleasedReturnValue();
  v196[4] = v138;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v196, v195, 5);
  v139 = (void *)objc_claimAutoreleasedReturnValue();
  v198[1] = v139;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v198, v197, 2);
  v140 = (id)objc_claimAutoreleasedReturnValue();
  v141 = v140;
  if (v140)
  {
    CFRetain(v140);
    v163 = v141;
    v142 = CFGetTypeID(v141);
    v143 = v141;
    if (v142 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v143 = 0;
    v163 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v163);
  if (v143)
    CFRelease(v143);

  v193[1] = CFSTR("Parameters");
  v194[0] = CFSTR("FilterNotSuggestibleForInput");
  v191[0] = CFSTR("WordEquivalenceType");
  v191[1] = CFSTR("ApplyFilterCondition");
  v192[0] = CFSTR("SurfaceFormEquivalence");
  v192[1] = CFSTR("ApplyAlways");
  v191[2] = CFSTR("ShouldRemoveVulgar");
  v192[2] = CFSTR("RemoveVulgarOnlyIfNotAllowlisted");
  v193[0] = CFSTR("FilterName");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v192, v191, 3);
  v144 = (void *)objc_claimAutoreleasedReturnValue();
  v194[1] = v144;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v194, v193, 2);
  v145 = (id)objc_claimAutoreleasedReturnValue();
  v146 = v145;
  if (v145)
  {
    CFRetain(v145);
    v162 = v146;
    v147 = CFGetTypeID(v146);
    v148 = v146;
    if (v147 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v148 = 0;
    v162 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v162);
  if (v148)
    CFRelease(v148);

  v189 = CFSTR("FilterName");
  v190 = CFSTR("RemoveAlternatesIfNoLinguisticCandidate");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v190, &v189, 1);
  v149 = (id)objc_claimAutoreleasedReturnValue();
  v150 = v149;
  if (v149)
  {
    CFRetain(v149);
    v161 = v150;
    v151 = CFGetTypeID(v150);
    v152 = v150;
    if (v151 != CFDictionaryGetTypeID())
    {
LABEL_175:
      exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(exception);
    }
  }
  else
  {
    v152 = 0;
    v161 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v161);
  if (v152)
    CFRelease(v152);

  v187 = CFSTR("FilterName");
  v188 = CFSTR("FilterDuplicates");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v188, &v187, 1);
  v153 = (id)objc_claimAutoreleasedReturnValue();
  v154 = v153;
  if (v153)
  {
    CFRetain(v153);
    v160 = v154;
    v155 = CFGetTypeID(v154);
    v156 = v154;
    if (v155 != CFDictionaryGetTypeID())
      goto LABEL_175;
  }
  else
  {
    v156 = 0;
    v160 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v160);
  if (v156)
    CFRelease(v156);

}

void KB::CandidateFilterFactory::create_standard_continuous_path_filter_definition(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  id v7;
  void *v8;
  CFTypeID v9;
  const void *v10;
  id v11;
  void *v12;
  CFTypeID v13;
  const void *v14;
  id v15;
  void *v16;
  CFTypeID v17;
  const void *v18;
  id v19;
  void *v20;
  CFTypeID v21;
  const void *v22;
  id v23;
  void *v24;
  CFTypeID v25;
  const void *v26;
  id v27;
  void *v28;
  CFTypeID v29;
  const void *v30;
  void *v31;
  id v32;
  void *v33;
  CFTypeID v34;
  const void *v35;
  double v36;
  void *v37;
  void *v38;
  id v39;
  void *v40;
  CFTypeID v41;
  const void *v42;
  double v43;
  void *v44;
  void *v45;
  id v46;
  void *v47;
  CFTypeID v48;
  const void *v49;
  id v50;
  void *v51;
  CFTypeID v52;
  const void *v53;
  double v54;
  id v55;
  void *v56;
  CFTypeID v57;
  const void *v58;
  void *v59;
  void *v60;
  id v61;
  void *v62;
  CFTypeID v63;
  const void *v64;
  applesauce::CF *exception;
  CFTypeRef v66;
  CFTypeRef v67;
  CFTypeRef v68;
  CFTypeRef v69;
  CFTypeRef v70;
  CFTypeRef v71;
  CFTypeRef v72;
  CFTypeRef v73;
  CFTypeRef v74;
  CFTypeRef v75;
  CFTypeRef v76;
  CFTypeRef v77;
  const __CFString *v78;
  void *v79;
  _QWORD v80[2];
  _QWORD v81[2];
  const __CFString *v82;
  const __CFString *v83;
  const __CFString *v84;
  const __CFString *v85;
  const __CFString *v86;
  void *v87;
  _QWORD v88[2];
  _QWORD v89[2];
  const __CFString *v90;
  void *v91;
  _QWORD v92[2];
  _QWORD v93[2];
  _QWORD v94[3];
  _QWORD v95[3];
  _QWORD v96[2];
  _QWORD v97[2];
  const __CFString *v98;
  const __CFString *v99;
  const __CFString *v100;
  const __CFString *v101;
  const __CFString *v102;
  const __CFString *v103;
  const __CFString *v104;
  const __CFString *v105;
  const __CFString *v106;
  const __CFString *v107;
  const __CFString *v108;
  _QWORD v109[3];

  v109[1] = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 40);
  v5 = *(_DWORD *)(a1 + 56);
  v6 = *(_DWORD *)(a1 + 96);
  v108 = CFSTR("FilterName");
  v109[0] = CFSTR("FilterZeroProbability");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v109, &v108, 1);
  v7 = (id)objc_claimAutoreleasedReturnValue();
  v8 = v7;
  if (v7)
  {
    CFRetain(v7);
    v77 = v8;
    v9 = CFGetTypeID(v8);
    v10 = v8;
    if (v9 != CFDictionaryGetTypeID())
      goto LABEL_73;
  }
  else
  {
    v10 = 0;
    v77 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v77);
  if (v10)
    CFRelease(v10);

  v106 = CFSTR("FilterName");
  v107 = CFSTR("FilterIncomplete");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v107, &v106, 1);
  v11 = (id)objc_claimAutoreleasedReturnValue();
  v12 = v11;
  if (v11)
  {
    CFRetain(v11);
    v76 = v12;
    v13 = CFGetTypeID(v12);
    v14 = v12;
    if (v13 != CFDictionaryGetTypeID())
      goto LABEL_73;
  }
  else
  {
    v14 = 0;
    v76 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v76);
  if (v14)
    CFRelease(v14);

  if (*(_BYTE *)(a1 + 185))
  {
    v104 = CFSTR("FilterName");
    v105 = CFSTR("FilterWithoutSupplementalWords");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v105, &v104, 1);
    v15 = (id)objc_claimAutoreleasedReturnValue();
    v16 = v15;
    if (v15)
    {
      CFRetain(v15);
      v75 = v16;
      v17 = CFGetTypeID(v16);
      v18 = v16;
      if (v17 != CFDictionaryGetTypeID())
        goto LABEL_73;
    }
    else
    {
      v18 = 0;
      v75 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v75);
    if (v18)
      CFRelease(v18);

    v102 = CFSTR("FilterName");
    v103 = CFSTR("FilterPartOfHyphenatedWord");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v103, &v102, 1);
    v19 = (id)objc_claimAutoreleasedReturnValue();
    v20 = v19;
    if (v19)
    {
      CFRetain(v19);
      v74 = v20;
      v21 = CFGetTypeID(v20);
      v22 = v20;
      if (v21 != CFDictionaryGetTypeID())
        goto LABEL_73;
    }
    else
    {
      v22 = 0;
      v74 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v74);
    if (v22)
      CFRelease(v22);

  }
  v100 = CFSTR("FilterName");
  v101 = CFSTR("FilterInvalidTextReplacement");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v101, &v100, 1);
  v23 = (id)objc_claimAutoreleasedReturnValue();
  v24 = v23;
  if (v23)
  {
    CFRetain(v23);
    v73 = v24;
    v25 = CFGetTypeID(v24);
    v26 = v24;
    if (v25 != CFDictionaryGetTypeID())
      goto LABEL_73;
  }
  else
  {
    v26 = 0;
    v73 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v73);
  if (v26)
    CFRelease(v26);

  v98 = CFSTR("FilterName");
  v99 = CFSTR("ExemptHighFrequencyWordsFromNoSuggest");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v99, &v98, 1);
  v27 = (id)objc_claimAutoreleasedReturnValue();
  v28 = v27;
  if (v27)
  {
    CFRetain(v27);
    v72 = v28;
    v29 = CFGetTypeID(v28);
    v30 = v28;
    if (v29 != CFDictionaryGetTypeID())
      goto LABEL_73;
  }
  else
  {
    v30 = 0;
    v72 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v72);
  if (v30)
    CFRelease(v30);

  v96[1] = CFSTR("Parameters");
  v97[0] = CFSTR("FilterNotSuggestibleForInput");
  v94[0] = CFSTR("WordEquivalenceType");
  v94[1] = CFSTR("ApplyFilterCondition");
  v95[0] = CFSTR("SurfaceFormEquivalence");
  v95[1] = CFSTR("ApplyAlways");
  v96[0] = CFSTR("FilterName");
  v94[2] = CFSTR("ShouldRemoveVulgar");
  v95[2] = CFSTR("RemoveVulgarOnlyIfNotAllowlisted");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v95, v94, 3);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v97[1] = v31;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v97, v96, 2);
  v32 = (id)objc_claimAutoreleasedReturnValue();
  v33 = v32;
  if (v32)
  {
    CFRetain(v32);
    v71 = v33;
    v34 = CFGetTypeID(v33);
    v35 = v33;
    if (v34 != CFDictionaryGetTypeID())
      goto LABEL_73;
  }
  else
  {
    v35 = 0;
    v71 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v71);
  if (v35)
    CFRelease(v35);

  v92[1] = CFSTR("Parameters");
  v93[0] = CFSTR("FilterLowQualityContinuousPathRetrocorrections");
  v92[0] = CFSTR("FilterName");
  v90 = CFSTR("MinOmegaRatioForContinuousPathRetrocorrections");
  LODWORD(v36) = v5;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v36);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v91 = v37;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v91, &v90, 1);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v93[1] = v38;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v93, v92, 2);
  v39 = (id)objc_claimAutoreleasedReturnValue();
  v40 = v39;
  if (v39)
  {
    CFRetain(v39);
    v70 = v40;
    v41 = CFGetTypeID(v40);
    v42 = v40;
    if (v41 != CFDictionaryGetTypeID())
      goto LABEL_73;
  }
  else
  {
    v42 = 0;
    v70 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v70);
  if (v42)
    CFRelease(v42);

  v88[1] = CFSTR("Parameters");
  v89[0] = CFSTR("BoostPreferedFormForSortkey");
  v88[0] = CFSTR("FilterName");
  v86 = CFSTR("MinSuggestionDominanceRatio");
  LODWORD(v43) = v4;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v43);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v87 = v44;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v87, &v86, 1);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v89[1] = v45;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v89, v88, 2);
  v46 = (id)objc_claimAutoreleasedReturnValue();
  v47 = v46;
  if (v46)
  {
    CFRetain(v46);
    v69 = v47;
    v48 = CFGetTypeID(v47);
    v49 = v47;
    if (v48 != CFDictionaryGetTypeID())
      goto LABEL_73;
  }
  else
  {
    v49 = 0;
    v69 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v69);
  if (v49)
    CFRelease(v49);

  v84 = CFSTR("FilterName");
  v85 = CFSTR("FilterNoPredictContinuousPathAlternates");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v85, &v84, 1);
  v50 = (id)objc_claimAutoreleasedReturnValue();
  v51 = v50;
  if (v50)
  {
    CFRetain(v50);
    v68 = v51;
    v52 = CFGetTypeID(v51);
    v53 = v51;
    if (v52 != CFDictionaryGetTypeID())
      goto LABEL_73;
  }
  else
  {
    v53 = 0;
    v68 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v68);
  if (v53)
    CFRelease(v53);

  if (*(_BYTE *)(a1 + 187))
  {
    v82 = CFSTR("FilterName");
    v83 = CFSTR("BoostCaseVariantsOfTopCandidate");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v83, &v82, 1);
    v55 = (id)objc_claimAutoreleasedReturnValue();
    v56 = v55;
    if (v55)
    {
      CFRetain(v55);
      v67 = v56;
      v57 = CFGetTypeID(v56);
      v58 = v56;
      if (v57 != CFDictionaryGetTypeID())
      {
LABEL_73:
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
    }
    else
    {
      v58 = 0;
      v67 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v67);
    if (v58)
      CFRelease(v58);

  }
  v80[1] = CFSTR("Parameters");
  v81[0] = CFSTR("FilterContinuousPathAlternatesFromOtherLanguage");
  v80[0] = CFSTR("FilterName");
  v78 = CFSTR("MinConfidenceToEstablishContinuousPathLanguage");
  LODWORD(v54) = v6;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v54);
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  v79 = v59;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v79, &v78, 1);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  v81[1] = v60;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v81, v80, 2);
  v61 = (id)objc_claimAutoreleasedReturnValue();
  v62 = v61;
  if (v61)
  {
    CFRetain(v61);
    v66 = v62;
    v63 = CFGetTypeID(v62);
    v64 = v62;
    if (v63 != CFDictionaryGetTypeID())
      goto LABEL_73;
  }
  else
  {
    v64 = 0;
    v66 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v66);
  if (v64)
    CFRelease(v64);

}

void KB::CandidateFilterFactory::create_standard_prediction_completion_or_replacement_filter_favonius_definition(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  id v8;
  void *v9;
  CFTypeID v10;
  const void *v11;
  id v12;
  void *v13;
  CFTypeID v14;
  const void *v15;
  id v16;
  void *v17;
  CFTypeID v18;
  const void *v19;
  id v20;
  void *v21;
  CFTypeID v22;
  const void *v23;
  id v24;
  void *v25;
  CFTypeID v26;
  const void *v27;
  int v28;
  _BOOL4 v29;
  id v30;
  void *v31;
  CFTypeID v32;
  const void *v33;
  id v34;
  CFTypeID v35;
  CFTypeRef *v36;
  id v37;
  void *v38;
  CFTypeID v39;
  const void *v40;
  id v41;
  void *v42;
  CFTypeID v43;
  const void *v44;
  id v45;
  void *v46;
  CFTypeID v47;
  const void *v48;
  void *v49;
  id v50;
  void *v51;
  CFTypeID v52;
  const void *v53;
  id v54;
  void *v55;
  CFTypeID v56;
  const void *v57;
  void *v58;
  id v59;
  void *v60;
  CFTypeID v61;
  const void *v62;
  void *v63;
  id v64;
  void *v65;
  CFTypeID v66;
  const void *v67;
  double v68;
  void *v69;
  void *v70;
  id v71;
  void *v72;
  CFTypeID v73;
  const void *v74;
  id v75;
  void *v76;
  CFTypeID v77;
  const void *v78;
  void *v79;
  id v80;
  void *v81;
  CFTypeID v82;
  const void *v83;
  double v84;
  void *v85;
  void *v86;
  id v87;
  void *v88;
  CFTypeID v89;
  const void *v90;
  BOOL v91;
  uint64_t v92;
  void *v93;
  void *v94;
  void *v95;
  id v96;
  void *v97;
  CFTypeID v98;
  const void *v99;
  id v100;
  void *v101;
  CFTypeID v102;
  const void *v103;
  applesauce::CF *exception;
  uint64_t v105;
  CFTypeRef v106;
  CFTypeRef v107;
  CFTypeRef v108;
  CFTypeRef v109;
  CFTypeRef v110;
  CFTypeRef v111;
  CFTypeRef v112;
  CFTypeRef v113;
  CFTypeRef v114;
  CFTypeRef v115;
  CFTypeRef v116;
  CFTypeRef v117;
  CFTypeRef v118;
  void *v119;
  void *v120;
  CFTypeRef v121;
  CFTypeRef v122;
  CFTypeRef v123;
  CFTypeRef v124;
  CFTypeRef v125;
  const __CFString *v126;
  const __CFString *v127;
  _QWORD v128[2];
  _QWORD v129[2];
  _QWORD v130[2];
  _QWORD v131[2];
  const __CFString *v132;
  void *v133;
  _QWORD v134[2];
  _QWORD v135[2];
  _QWORD v136[3];
  _QWORD v137[3];
  _QWORD v138[2];
  _QWORD v139[2];
  const __CFString *v140;
  const __CFString *v141;
  const __CFString *v142;
  void *v143;
  _QWORD v144[2];
  _QWORD v145[2];
  _QWORD v146[3];
  _QWORD v147[3];
  _QWORD v148[2];
  _QWORD v149[2];
  _QWORD v150[2];
  _QWORD v151[2];
  _QWORD v152[2];
  _QWORD v153[2];
  const __CFString *v154;
  const __CFString *v155;
  const __CFString *v156;
  void *v157;
  _QWORD v158[2];
  _QWORD v159[2];
  const __CFString *v160;
  const __CFString *v161;
  const __CFString *v162;
  const __CFString *v163;
  const __CFString *v164;
  const __CFString *v165;
  const __CFString *v166;
  const __CFString *v167;
  const __CFString *v168;
  const __CFString *v169;
  const __CFString *v170;
  const __CFString *v171;
  const __CFString *v172;
  const __CFString *v173;
  const __CFString *v174;
  const __CFString *v175;
  const __CFString *v176;
  const __CFString *v177;
  const __CFString *v178;
  _QWORD v179[3];

  v179[1] = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 44);
  v5 = *(_DWORD *)(a1 + 64);
  v6 = *(_QWORD *)(a1 + 72);
  v7 = *(_DWORD *)(a1 + 92);
  v178 = CFSTR("FilterName");
  v179[0] = CFSTR("FilterZeroProbability");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v179, &v178, 1);
  v8 = (id)objc_claimAutoreleasedReturnValue();
  v9 = v8;
  if (v8)
  {
    CFRetain(v8);
    v125 = v9;
    v10 = CFGetTypeID(v9);
    v11 = v9;
    if (v10 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v11 = 0;
    v125 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v125);
  if (v11)
    CFRelease(v11);

  v176 = CFSTR("FilterName");
  v177 = CFSTR("FilterAppNames");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v177, &v176, 1);
  v12 = (id)objc_claimAutoreleasedReturnValue();
  v13 = v12;
  if (v12)
  {
    CFRetain(v12);
    v124 = v13;
    v14 = CFGetTypeID(v13);
    v15 = v13;
    if (v14 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v15 = 0;
    v124 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v124);
  if (v15)
    CFRelease(v15);

  v174 = CFSTR("FilterName");
  v175 = CFSTR("FilterIncomplete");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v175, &v174, 1);
  v16 = (id)objc_claimAutoreleasedReturnValue();
  v17 = v16;
  if (v16)
  {
    CFRetain(v16);
    v123 = v17;
    v18 = CFGetTypeID(v17);
    v19 = v17;
    if (v18 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v19 = 0;
    v123 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v123);
  if (v19)
    CFRelease(v19);

  if (*(_BYTE *)(a1 + 185))
  {
    v172 = CFSTR("FilterName");
    v173 = CFSTR("FilterWithoutSupplementalWords");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v173, &v172, 1);
    v20 = (id)objc_claimAutoreleasedReturnValue();
    v21 = v20;
    if (v20)
    {
      CFRetain(v20);
      v122 = v21;
      v22 = CFGetTypeID(v21);
      v23 = v21;
      if (v22 != CFDictionaryGetTypeID())
        goto LABEL_125;
    }
    else
    {
      v23 = 0;
      v122 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v122);
    if (v23)
      CFRelease(v23);

    v170 = CFSTR("FilterName");
    v171 = CFSTR("FilterPartOfHyphenatedWord");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v171, &v170, 1);
    v24 = (id)objc_claimAutoreleasedReturnValue();
    v25 = v24;
    if (v24)
    {
      CFRetain(v24);
      v121 = v25;
      v26 = CFGetTypeID(v25);
      v27 = v25;
      if (v26 != CFDictionaryGetTypeID())
        goto LABEL_125;
    }
    else
    {
      v27 = 0;
      v121 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v121);
    if (v27)
      CFRelease(v27);

  }
  v28 = _os_feature_enabled_impl();
  v29 = (_BYTE)number_to_letter_correction_locally_enabled(void)::locally_enabled != 0;
  if (!HIBYTE(number_to_letter_correction_locally_enabled(void)::locally_enabled))
    v29 = v28;
  if (v29)
  {
    v168 = CFSTR("FilterName");
    v169 = CFSTR("FilterNumberlikeTokenMismatch");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v169, &v168, 1);
    v30 = (id)objc_claimAutoreleasedReturnValue();
    v31 = v30;
    if (v30)
    {
      CFRetain(v30);
      v120 = v31;
      v32 = CFGetTypeID(v31);
      v33 = v31;
      if (v32 != CFDictionaryGetTypeID())
        goto LABEL_125;
    }
    else
    {
      v33 = 0;
      v120 = 0;
    }

    v36 = (CFTypeRef *)&v120;
  }
  else
  {
    v166 = CFSTR("FilterName");
    v167 = CFSTR("FilterNumberMismatch");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v167, &v166, 1);
    v34 = (id)objc_claimAutoreleasedReturnValue();
    v31 = v34;
    if (v34)
    {
      CFRetain(v34);
      v119 = v31;
      v35 = CFGetTypeID(v31);
      v33 = v31;
      if (v35 != CFDictionaryGetTypeID())
        goto LABEL_125;
    }
    else
    {
      v33 = 0;
      v119 = 0;
    }

    v36 = (CFTypeRef *)&v119;
  }
  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, v36);
  if (v33)
    CFRelease(v33);

  v164 = CFSTR("FilterName");
  v165 = CFSTR("FilterControlCharacters");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v165, &v164, 1);
  v37 = (id)objc_claimAutoreleasedReturnValue();
  v38 = v37;
  if (v37)
  {
    CFRetain(v37);
    v118 = v38;
    v39 = CFGetTypeID(v38);
    v40 = v38;
    if (v39 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v40 = 0;
    v118 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v118);
  if (v40)
    CFRelease(v40);

  v162 = CFSTR("FilterName");
  v163 = CFSTR("FilterDoubleApostrophe");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v163, &v162, 1);
  v41 = (id)objc_claimAutoreleasedReturnValue();
  v42 = v41;
  if (v41)
  {
    CFRetain(v41);
    v117 = v42;
    v43 = CFGetTypeID(v42);
    v44 = v42;
    if (v43 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v44 = 0;
    v117 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v117);
  if (v44)
    CFRelease(v44);

  v160 = CFSTR("FilterName");
  v161 = CFSTR("FilterWordEndingApostropheBetweenNonseparators");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v161, &v160, 1);
  v45 = (id)objc_claimAutoreleasedReturnValue();
  v46 = v45;
  if (v45)
  {
    CFRetain(v45);
    v116 = v46;
    v47 = CFGetTypeID(v46);
    v48 = v46;
    if (v47 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v48 = 0;
    v116 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v116);
  if (v48)
    CFRelease(v48);

  v159[0] = CFSTR("FilterAllCapsNoSuggestWordsOfLength");
  v158[0] = CFSTR("FilterName");
  v158[1] = CFSTR("Parameters");
  v156 = CFSTR("Length");
  v157 = &unk_1EA140348;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v157, &v156, 1);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v159[1] = v49;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v159, v158, 2);
  v50 = (id)objc_claimAutoreleasedReturnValue();
  v51 = v50;
  if (v50)
  {
    CFRetain(v50);
    v115 = v51;
    v52 = CFGetTypeID(v51);
    v53 = v51;
    if (v52 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v53 = 0;
    v115 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v115);
  if (v53)
    CFRelease(v53);

  v154 = CFSTR("FilterName");
  v155 = CFSTR("FilterPopupVariantMismatch");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v155, &v154, 1);
  v54 = (id)objc_claimAutoreleasedReturnValue();
  v55 = v54;
  if (v54)
  {
    CFRetain(v54);
    v114 = v55;
    v56 = CFGetTypeID(v55);
    v57 = v55;
    if (v56 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v57 = 0;
    v114 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v114);
  if (v57)
    CFRelease(v57);

  v153[0] = CFSTR("FilterCharacterCount");
  v152[0] = CFSTR("FilterName");
  v152[1] = CFSTR("Parameters");
  v150[0] = CFSTR("Character");
  v150[1] = CFSTR("CharacterCountRelation");
  v151[0] = CFSTR("&");
  v151[1] = CFSTR("GreaterThanOrEqualToInputCount");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v151, v150, 2);
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  v153[1] = v58;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v153, v152, 2);
  v59 = (id)objc_claimAutoreleasedReturnValue();
  v60 = v59;
  if (v59)
  {
    CFRetain(v59);
    v113 = v60;
    v61 = CFGetTypeID(v60);
    v62 = v60;
    if (v61 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v62 = 0;
    v113 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v113);
  if (v62)
    CFRelease(v62);

  v148[1] = CFSTR("Parameters");
  v149[0] = CFSTR("FilterNotSuggestibleForInput");
  v146[0] = CFSTR("WordEquivalenceType");
  v146[1] = CFSTR("ApplyFilterCondition");
  v147[0] = CFSTR("SortkeyEquivalence");
  v147[1] = CFSTR("ApplyAlways");
  v146[2] = CFSTR("ShouldRemoveVulgar");
  v147[2] = CFSTR("RemoveVulgar");
  v148[0] = CFSTR("FilterName");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v147, v146, 3);
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  v149[1] = v63;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v149, v148, 2);
  v64 = (id)objc_claimAutoreleasedReturnValue();
  v65 = v64;
  if (v64)
  {
    CFRetain(v64);
    v112 = v65;
    v66 = CFGetTypeID(v65);
    v67 = v65;
    if (v66 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v67 = 0;
    v112 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v112);
  if (v67)
    CFRelease(v67);
  v105 = v6;

  v144[0] = CFSTR("FilterName");
  v144[1] = CFSTR("Parameters");
  v145[0] = CFSTR("BoostMinimumVariation");
  v142 = CFSTR("MinCandidateDominanceRatio");
  LODWORD(v68) = v4;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v68);
  v69 = (void *)objc_claimAutoreleasedReturnValue();
  v143 = v69;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v143, &v142, 1);
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  v145[1] = v70;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v145, v144, 2);
  v71 = (id)objc_claimAutoreleasedReturnValue();
  v72 = v71;
  if (v71)
  {
    CFRetain(v71);
    v111 = v72;
    v73 = CFGetTypeID(v72);
    v74 = v72;
    if (v73 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v74 = 0;
    v111 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v111);
  if (v74)
    CFRelease(v74);

  v140 = CFSTR("FilterName");
  v141 = CFSTR("FilterInvalidTextReplacement");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v141, &v140, 1);
  v75 = (id)objc_claimAutoreleasedReturnValue();
  v76 = v75;
  if (v75)
  {
    CFRetain(v75);
    v110 = v76;
    v77 = CFGetTypeID(v76);
    v78 = v76;
    if (v77 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v78 = 0;
    v110 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v110);
  if (v78)
    CFRelease(v78);

  v138[1] = CFSTR("Parameters");
  v139[0] = CFSTR("FilterNotSuggestibleForInput");
  v136[0] = CFSTR("WordEquivalenceType");
  v136[1] = CFSTR("ApplyFilterCondition");
  v137[0] = CFSTR("SurfaceFormEquivalence");
  v137[1] = CFSTR("ApplyAlways");
  v136[2] = CFSTR("ShouldRemoveVulgar");
  v137[2] = CFSTR("RemoveVulgar");
  v138[0] = CFSTR("FilterName");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v137, v136, 3);
  v79 = (void *)objc_claimAutoreleasedReturnValue();
  v139[1] = v79;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v139, v138, 2);
  v80 = (id)objc_claimAutoreleasedReturnValue();
  v81 = v80;
  if (v80)
  {
    CFRetain(v80);
    v109 = v81;
    v82 = CFGetTypeID(v81);
    v83 = v81;
    if (v82 != CFDictionaryGetTypeID())
      goto LABEL_125;
  }
  else
  {
    v83 = 0;
    v109 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v109);
  if (v83)
    CFRelease(v83);

  v134[1] = CFSTR("Parameters");
  v135[0] = CFSTR("FilterDifferentLanguageThanContext");
  v134[0] = CFSTR("FilterName");
  v132 = CFSTR("MinConfidenceToEstablishLanguage");
  LODWORD(v84) = v7;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v84);
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  v133 = v85;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v133, &v132, 1);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  v135[1] = v86;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v135, v134, 2);
  v87 = (id)objc_claimAutoreleasedReturnValue();
  v88 = v87;
  if (v87)
  {
    CFRetain(v87);
    v108 = v88;
    v89 = CFGetTypeID(v88);
    v90 = v88;
    v91 = v89 == CFDictionaryGetTypeID();
    v92 = a1;
    if (!v91)
      goto LABEL_125;
  }
  else
  {
    v90 = 0;
    v108 = 0;
    v92 = a1;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v108);
  if (v90)
    CFRelease(v90);

  if (*(_BYTE *)(v92 + 186))
  {
    v130[1] = CFSTR("Parameters");
    v131[0] = CFSTR("FilterInputPrefixMismatch");
    v130[0] = CFSTR("FilterName");
    v128[0] = CFSTR("MinPrefixMatchLen");
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v5);
    v93 = (void *)objc_claimAutoreleasedReturnValue();
    v128[1] = CFSTR("MinTargetCandidates");
    v129[0] = v93;
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", v105);
    v94 = (void *)objc_claimAutoreleasedReturnValue();
    v129[1] = v94;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v129, v128, 2);
    v95 = (void *)objc_claimAutoreleasedReturnValue();
    v131[1] = v95;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v131, v130, 2);
    v96 = (id)objc_claimAutoreleasedReturnValue();
    v97 = v96;
    if (v96)
    {
      CFRetain(v96);
      v107 = v97;
      v98 = CFGetTypeID(v97);
      v99 = v97;
      if (v98 != CFDictionaryGetTypeID())
      {
LABEL_125:
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
    }
    else
    {
      v99 = 0;
      v107 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v107);
    if (v99)
      CFRelease(v99);

  }
  if (*(_BYTE *)(v92 + 187))
  {
    v126 = CFSTR("FilterName");
    v127 = CFSTR("BoostCaseVariantsOfTopCandidate");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v127, &v126, 1);
    v100 = (id)objc_claimAutoreleasedReturnValue();
    v101 = v100;
    if (v100)
    {
      CFRetain(v100);
      v106 = v101;
      v102 = CFGetTypeID(v101);
      v103 = v101;
      if (v102 != CFDictionaryGetTypeID())
        goto LABEL_125;
    }
    else
    {
      v103 = 0;
      v106 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v106);
    if (v103)
      CFRelease(v103);

  }
}

void KB::CandidateFilterFactory::create_standard_prediction_completion_or_replacement_filter_defintion(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  id v8;
  void *v9;
  CFTypeID v10;
  const void *v11;
  id v12;
  void *v13;
  CFTypeID v14;
  const void *v15;
  id v16;
  void *v17;
  CFTypeID v18;
  const void *v19;
  id v20;
  void *v21;
  CFTypeID v22;
  const void *v23;
  id v24;
  void *v25;
  CFTypeID v26;
  const void *v27;
  id v28;
  void *v29;
  CFTypeID v30;
  const void *v31;
  void *v32;
  id v33;
  void *v34;
  CFTypeID v35;
  const void *v36;
  uint64_t v37;
  double v38;
  void *v39;
  void *v40;
  id v41;
  void *v42;
  CFTypeID v43;
  const void *v44;
  int v45;
  _BOOL4 v46;
  id v47;
  void *v48;
  CFTypeID v49;
  const void *v50;
  id v51;
  CFTypeID v52;
  CFTypeRef *v53;
  void *v54;
  id v55;
  void *v56;
  CFTypeID v57;
  const void *v58;
  id v59;
  void *v60;
  CFTypeID v61;
  const void *v62;
  id v63;
  void *v64;
  CFTypeID v65;
  const void *v66;
  id v67;
  void *v68;
  CFTypeID v69;
  const void *v70;
  void *v71;
  id v72;
  void *v73;
  CFTypeID v74;
  const void *v75;
  double v76;
  void *v77;
  void *v78;
  id v79;
  void *v80;
  CFTypeID v81;
  const void *v82;
  BOOL v83;
  uint64_t v84;
  void *v85;
  void *v86;
  void *v87;
  id v88;
  void *v89;
  CFTypeID v90;
  const void *v91;
  id v92;
  void *v93;
  CFTypeID v94;
  const void *v95;
  applesauce::CF *exception;
  uint64_t v97;
  CFTypeRef v98;
  CFTypeRef v99;
  CFTypeRef v100;
  CFTypeRef v101;
  CFTypeRef v102;
  CFTypeRef v103;
  CFTypeRef v104;
  CFTypeRef v105;
  void *v106;
  void *v107;
  CFTypeRef v108;
  CFTypeRef v109;
  CFTypeRef v110;
  CFTypeRef v111;
  CFTypeRef v112;
  CFTypeRef v113;
  CFTypeRef v114;
  CFTypeRef v115;
  const __CFString *v116;
  const __CFString *v117;
  _QWORD v118[2];
  _QWORD v119[2];
  _QWORD v120[2];
  _QWORD v121[2];
  const __CFString *v122;
  void *v123;
  _QWORD v124[2];
  _QWORD v125[2];
  _QWORD v126[3];
  _QWORD v127[3];
  _QWORD v128[2];
  _QWORD v129[2];
  const __CFString *v130;
  const __CFString *v131;
  const __CFString *v132;
  const __CFString *v133;
  const __CFString *v134;
  const __CFString *v135;
  _QWORD v136[2];
  _QWORD v137[2];
  _QWORD v138[2];
  _QWORD v139[2];
  const __CFString *v140;
  const __CFString *v141;
  const __CFString *v142;
  const __CFString *v143;
  const __CFString *v144;
  void *v145;
  _QWORD v146[2];
  _QWORD v147[2];
  _QWORD v148[3];
  _QWORD v149[3];
  _QWORD v150[2];
  _QWORD v151[2];
  const __CFString *v152;
  const __CFString *v153;
  const __CFString *v154;
  const __CFString *v155;
  const __CFString *v156;
  const __CFString *v157;
  const __CFString *v158;
  const __CFString *v159;
  const __CFString *v160;
  const __CFString *v161;
  const __CFString *v162;
  _QWORD v163[3];

  v163[1] = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 44);
  v5 = *(_DWORD *)(a1 + 64);
  v6 = *(_QWORD *)(a1 + 72);
  v7 = *(_DWORD *)(a1 + 92);
  v162 = CFSTR("FilterName");
  v163[0] = CFSTR("FilterZeroProbability");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v163, &v162, 1);
  v8 = (id)objc_claimAutoreleasedReturnValue();
  v9 = v8;
  if (v8)
  {
    CFRetain(v8);
    v115 = v9;
    v10 = CFGetTypeID(v9);
    v11 = v9;
    if (v10 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v11 = 0;
    v115 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v115);
  if (v11)
    CFRelease(v11);

  v160 = CFSTR("FilterName");
  v161 = CFSTR("FilterAppNames");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v161, &v160, 1);
  v12 = (id)objc_claimAutoreleasedReturnValue();
  v13 = v12;
  if (v12)
  {
    CFRetain(v12);
    v114 = v13;
    v14 = CFGetTypeID(v13);
    v15 = v13;
    if (v14 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v15 = 0;
    v114 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v114);
  if (v15)
    CFRelease(v15);

  v158 = CFSTR("FilterName");
  v159 = CFSTR("FilterIncomplete");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v159, &v158, 1);
  v16 = (id)objc_claimAutoreleasedReturnValue();
  v17 = v16;
  if (v16)
  {
    CFRetain(v16);
    v113 = v17;
    v18 = CFGetTypeID(v17);
    v19 = v17;
    if (v18 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v19 = 0;
    v113 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v113);
  if (v19)
    CFRelease(v19);

  if (*(_BYTE *)(a1 + 185))
  {
    v156 = CFSTR("FilterName");
    v157 = CFSTR("FilterWithoutSupplementalWords");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v157, &v156, 1);
    v20 = (id)objc_claimAutoreleasedReturnValue();
    v21 = v20;
    if (v20)
    {
      CFRetain(v20);
      v112 = v21;
      v22 = CFGetTypeID(v21);
      v23 = v21;
      if (v22 != CFDictionaryGetTypeID())
        goto LABEL_113;
    }
    else
    {
      v23 = 0;
      v112 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v112);
    if (v23)
      CFRelease(v23);

    v154 = CFSTR("FilterName");
    v155 = CFSTR("FilterPartOfHyphenatedWord");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v155, &v154, 1);
    v24 = (id)objc_claimAutoreleasedReturnValue();
    v25 = v24;
    if (v24)
    {
      CFRetain(v24);
      v111 = v25;
      v26 = CFGetTypeID(v25);
      v27 = v25;
      if (v26 != CFDictionaryGetTypeID())
        goto LABEL_113;
    }
    else
    {
      v27 = 0;
      v111 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v111);
    if (v27)
      CFRelease(v27);

  }
  v152 = CFSTR("FilterName");
  v153 = CFSTR("FilterControlCharacters");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v153, &v152, 1);
  v28 = (id)objc_claimAutoreleasedReturnValue();
  v29 = v28;
  if (v28)
  {
    CFRetain(v28);
    v110 = v29;
    v30 = CFGetTypeID(v29);
    v31 = v29;
    if (v30 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v31 = 0;
    v110 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v110);
  if (v31)
    CFRelease(v31);

  v150[0] = CFSTR("FilterName");
  v150[1] = CFSTR("Parameters");
  v151[0] = CFSTR("FilterNotSuggestibleForInput");
  v148[0] = CFSTR("WordEquivalenceType");
  v148[1] = CFSTR("ApplyFilterCondition");
  v149[0] = CFSTR("SortkeyEquivalence");
  v149[1] = CFSTR("ApplyIfCandidatesContainInputMatch");
  v148[2] = CFSTR("ShouldRemoveVulgar");
  v149[2] = CFSTR("RemoveVulgar");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v149, v148, 3);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v151[1] = v32;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v151, v150, 2);
  v33 = (id)objc_claimAutoreleasedReturnValue();
  v34 = v33;
  if (v33)
  {
    CFRetain(v33);
    v109 = v34;
    v35 = CFGetTypeID(v34);
    v36 = v34;
    if (v35 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v36 = 0;
    v109 = 0;
  }
  v97 = v6;

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v109);
  if (v36)
    CFRelease(v36);
  v37 = a1;

  v147[0] = CFSTR("BoostMinimumVariation");
  v146[0] = CFSTR("FilterName");
  v146[1] = CFSTR("Parameters");
  v144 = CFSTR("MinCandidateDominanceRatio");
  LODWORD(v38) = v4;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v38);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v145 = v39;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v145, &v144, 1);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v147[1] = v40;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v147, v146, 2);
  v41 = (id)objc_claimAutoreleasedReturnValue();
  v42 = v41;
  if (v41)
  {
    CFRetain(v41);
    v108 = v42;
    v43 = CFGetTypeID(v42);
    v44 = v42;
    if (v43 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v44 = 0;
    v108 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v108);
  if (v44)
    CFRelease(v44);

  v45 = _os_feature_enabled_impl();
  v46 = (_BYTE)number_to_letter_correction_locally_enabled(void)::locally_enabled != 0;
  if (!HIBYTE(number_to_letter_correction_locally_enabled(void)::locally_enabled))
    v46 = v45;
  if (v46)
  {
    v142 = CFSTR("FilterName");
    v143 = CFSTR("FilterNumberlikeTokenMismatch");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v143, &v142, 1);
    v47 = (id)objc_claimAutoreleasedReturnValue();
    v48 = v47;
    if (v47)
    {
      CFRetain(v47);
      v107 = v48;
      v49 = CFGetTypeID(v48);
      v50 = v48;
      if (v49 != CFDictionaryGetTypeID())
        goto LABEL_113;
    }
    else
    {
      v50 = 0;
      v107 = 0;
    }

    v53 = (CFTypeRef *)&v107;
  }
  else
  {
    v140 = CFSTR("FilterName");
    v141 = CFSTR("FilterNumberMismatch");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v141, &v140, 1);
    v51 = (id)objc_claimAutoreleasedReturnValue();
    v48 = v51;
    if (v51)
    {
      CFRetain(v51);
      v106 = v48;
      v52 = CFGetTypeID(v48);
      v50 = v48;
      if (v52 != CFDictionaryGetTypeID())
        goto LABEL_113;
    }
    else
    {
      v50 = 0;
      v106 = 0;
    }

    v53 = (CFTypeRef *)&v106;
  }
  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, v53);
  if (v50)
    CFRelease(v50);

  v138[1] = CFSTR("Parameters");
  v139[0] = CFSTR("FilterCharacterCount");
  v136[0] = CFSTR("Character");
  v136[1] = CFSTR("CharacterCountRelation");
  v137[0] = CFSTR("&");
  v137[1] = CFSTR("LessThanOrEqualToInputCount");
  v138[0] = CFSTR("FilterName");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v137, v136, 2);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  v139[1] = v54;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v139, v138, 2);
  v55 = (id)objc_claimAutoreleasedReturnValue();
  v56 = v55;
  if (v55)
  {
    CFRetain(v55);
    v105 = v56;
    v57 = CFGetTypeID(v56);
    v58 = v56;
    if (v57 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v58 = 0;
    v105 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v105);
  if (v58)
    CFRelease(v58);

  v134 = CFSTR("FilterName");
  v135 = CFSTR("FilterDoubleApostrophe");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v135, &v134, 1);
  v59 = (id)objc_claimAutoreleasedReturnValue();
  v60 = v59;
  if (v59)
  {
    CFRetain(v59);
    v104 = v60;
    v61 = CFGetTypeID(v60);
    v62 = v60;
    if (v61 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v62 = 0;
    v104 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v104);
  if (v62)
    CFRelease(v62);

  v132 = CFSTR("FilterName");
  v133 = CFSTR("FilterWordEndingApostropheBetweenNonseparators");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v133, &v132, 1);
  v63 = (id)objc_claimAutoreleasedReturnValue();
  v64 = v63;
  if (v63)
  {
    CFRetain(v63);
    v103 = v64;
    v65 = CFGetTypeID(v64);
    v66 = v64;
    if (v65 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v66 = 0;
    v103 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v103);
  if (v66)
    CFRelease(v66);

  v130 = CFSTR("FilterName");
  v131 = CFSTR("FilterInvalidTextReplacement");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v131, &v130, 1);
  v67 = (id)objc_claimAutoreleasedReturnValue();
  v68 = v67;
  if (v67)
  {
    CFRetain(v67);
    v102 = v68;
    v69 = CFGetTypeID(v68);
    v70 = v68;
    if (v69 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v70 = 0;
    v102 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v102);
  if (v70)
    CFRelease(v70);

  v128[1] = CFSTR("Parameters");
  v129[0] = CFSTR("FilterNotSuggestibleForInput");
  v126[0] = CFSTR("WordEquivalenceType");
  v126[1] = CFSTR("ApplyFilterCondition");
  v127[0] = CFSTR("SurfaceFormEquivalence");
  v127[1] = CFSTR("ApplyAlways");
  v126[2] = CFSTR("ShouldRemoveVulgar");
  v127[2] = CFSTR("RemoveVulgar");
  v128[0] = CFSTR("FilterName");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v127, v126, 3);
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  v129[1] = v71;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v129, v128, 2);
  v72 = (id)objc_claimAutoreleasedReturnValue();
  v73 = v72;
  if (v72)
  {
    CFRetain(v72);
    v101 = v73;
    v74 = CFGetTypeID(v73);
    v75 = v73;
    if (v74 != CFDictionaryGetTypeID())
      goto LABEL_113;
  }
  else
  {
    v75 = 0;
    v101 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v101);
  if (v75)
    CFRelease(v75);

  v124[1] = CFSTR("Parameters");
  v125[0] = CFSTR("FilterDifferentLanguageThanContext");
  v124[0] = CFSTR("FilterName");
  v122 = CFSTR("MinConfidenceToEstablishLanguage");
  LODWORD(v76) = v7;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v76);
  v77 = (void *)objc_claimAutoreleasedReturnValue();
  v123 = v77;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v123, &v122, 1);
  v78 = (void *)objc_claimAutoreleasedReturnValue();
  v125[1] = v78;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v125, v124, 2);
  v79 = (id)objc_claimAutoreleasedReturnValue();
  v80 = v79;
  if (v79)
  {
    CFRetain(v79);
    v100 = v80;
    v81 = CFGetTypeID(v80);
    v82 = v80;
    v83 = v81 == CFDictionaryGetTypeID();
    v84 = v37;
    if (!v83)
      goto LABEL_113;
  }
  else
  {
    v82 = 0;
    v100 = 0;
    v84 = v37;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v100);
  if (v82)
    CFRelease(v82);

  if (*(_BYTE *)(v84 + 186))
  {
    v120[1] = CFSTR("Parameters");
    v121[0] = CFSTR("FilterInputPrefixMismatch");
    v120[0] = CFSTR("FilterName");
    v118[0] = CFSTR("MinPrefixMatchLen");
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v5);
    v85 = (void *)objc_claimAutoreleasedReturnValue();
    v118[1] = CFSTR("MinTargetCandidates");
    v119[0] = v85;
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", v97);
    v86 = (void *)objc_claimAutoreleasedReturnValue();
    v119[1] = v86;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v119, v118, 2);
    v87 = (void *)objc_claimAutoreleasedReturnValue();
    v121[1] = v87;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v121, v120, 2);
    v88 = (id)objc_claimAutoreleasedReturnValue();
    v89 = v88;
    if (v88)
    {
      CFRetain(v88);
      v99 = v89;
      v90 = CFGetTypeID(v89);
      v91 = v89;
      if (v90 != CFDictionaryGetTypeID())
      {
LABEL_113:
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
    }
    else
    {
      v91 = 0;
      v99 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v99);
    if (v91)
      CFRelease(v91);

  }
  if (*(_BYTE *)(v84 + 187))
  {
    v116 = CFSTR("FilterName");
    v117 = CFSTR("BoostCaseVariantsOfTopCandidate");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v117, &v116, 1);
    v92 = (id)objc_claimAutoreleasedReturnValue();
    v93 = v92;
    if (v92)
    {
      CFRetain(v92);
      v98 = v93;
      v94 = CFGetTypeID(v93);
      v95 = v93;
      if (v94 != CFDictionaryGetTypeID())
        goto LABEL_113;
    }
    else
    {
      v95 = 0;
      v98 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v98);
    if (v95)
      CFRelease(v95);

  }
}

void KB::CandidateFilterFactory::create_empty_filter(_QWORD *a1@<X8>)
{
  _QWORD *v3;
  _QWORD v4[3];
  void **v5;

  v3 = operator new(0x38uLL);
  v3[1] = 0;
  v3[2] = 0;
  *v3 = &off_1EA0FC7B8;
  v3[5] = 0;
  v3[6] = 0;
  v3[4] = 0;
  a1[1] = v3;
  v3[3] = &off_1EA105D58;
  memset(v4, 0, sizeof(v4));
  *a1 = v3 + 3;
  v5 = (void **)v4;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v5);
}

void KB::CandidateFilterFactory::create_standard_filter(KB::CandidateFilterFactory *this@<X0>, _QWORD *a2@<X8>)
{
  void **v5[3];
  uint64_t v6;
  uint64_t v7;
  uint64_t v8[3];
  void ***v9;

  memset(v8, 0, sizeof(v8));
  KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition((uint64_t)v5, v8);
  KB::CandidateFilterFactory::create_standard_filter_definition((uint64_t)this, (uint64_t)v5);
  KB::CandidateFilterFactory::FilterStackDefinition::convert_filter_stack_definition_to_filters((KB::CandidateFilterFactory::FilterStackDefinition *)v5, this, a2);
  std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::~__hash_table((uint64_t)&v7);
  v9 = (void ***)&v6;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100]((void ***)&v9);
  v9 = v5;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100]((void ***)&v9);
  v5[0] = (void **)v8;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100](v5);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,applesauce::CF::DictionaryRef>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  const void *v6;
  const void *v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = (const void *)*((_QWORD *)v4 - 1);
        v4 -= 8;
        v6 = v7;
        if (v7)
          CFRelease(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void KB::CandidateFilterFactory::select_filter_specification_for_configuration(CFDictionaryRef *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  std::string::size_type size;
  std::string *v7;
  NSObject *v8;
  NSObject *v9;
  std::string::size_type v10;
  std::string *v11;
  const __CFDictionary *v12;
  const __CFArray *v13;
  unint64_t v14;
  unsigned int **v15;
  NSObject *v16;
  uint64_t v17;
  const char *v18;
  const __CFDictionary *v19;
  const __CFArray *Value;
  NSObject *v21;
  const void *v22;
  std::string::size_type v23;
  uint64_t v24;
  char *v25;
  const char *v26;
  const char *v27;
  std::string::size_type v28;
  uint64_t v29;
  std::string::size_type v30;
  std::string *v31;
  unsigned int v32;
  std::string *v33;
  std::string::size_type v34;
  std::string::size_type v35;
  int v36;
  BOOL v37;
  std::string *v38;
  std::string::size_type v39;
  std::string::size_type v40;
  std::string::size_type v41;
  int v44;
  const KB::String *v45;
  const __CFDictionary *v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  char v50;
  const __CFDictionary *v51;
  unsigned int v52;
  int v53;
  unsigned int v54;
  int v55;
  char v56;
  uint64_t v57;
  _BOOL4 v58;
  BOOL v59;
  void *v60;
  const __CFString *Language;
  CFTypeRef v62;
  std::string::size_type v63;
  _BOOL4 v64;
  __int128 v65;
  const __CFString *Region;
  CFTypeRef v67;
  std::string::size_type v68;
  _BOOL4 v69;
  __int128 v70;
  const __CFString *Variant;
  const __CFArray **v72;
  std::string::size_type v73;
  _BOOL4 v74;
  __int128 v75;
  NSObject *v76;
  CFDictionaryRef *v77;
  NSObject *v78;
  const char *v79;
  const char *v80;
  NSObject *v81;
  std::string *p_p;
  const char *v83;
  NSObject *v84;
  uint32_t v85;
  std::string *v86;
  std::string *v87;
  applesauce::CF *exception;
  KB *v89;
  unsigned int **v90;
  unsigned int *v91;
  __n128 v92;
  uint64_t v93;
  CFTypeRef cf;
  CFTypeRef v95;
  std::string v96;
  CFDictionaryRef theDict;
  CFTypeRef v98;
  CFTypeRef v99;
  CFArrayRef theArray;
  std::string v101;
  std::string __p;
  __n128 *v103;
  std::string v104;
  std::string v105;
  _BYTE buf[22];
  char v107;
  char v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  if (!*a1)
  {
    filter_factory_log();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1DA6F2000, v9, OS_LOG_TYPE_INFO, "Specification root object is null or not a dictionary.", buf, 2u);
    }

    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    return;
  }
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&__p, *a1, CFSTR("PayloadType"));
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __p.__r_.__value_.__l.__size_;
  if (size != 37
    || ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (v7 = &__p)
      : (v7 = (std::string *)__p.__r_.__value_.__r.__words[0]),
        memcmp(v7, "TextInputCandidateFilterSpecification", 0x25uLL)))
  {
    filter_factory_log();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = p_p;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "TextInputCandidateFilterSpecification";
      _os_log_error_impl(&dword_1DA6F2000, v8, OS_LOG_TYPE_ERROR, "Payload type '%s' is not '%s'", buf, 0x16u);
    }

    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    goto LABEL_11;
  }
  if (!*a1)
    goto LABEL_241;
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&v101, *a1, CFSTR("PayloadVersion"));
  v10 = HIBYTE(v101.__r_.__value_.__r.__words[2]);
  if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v10 = v101.__r_.__value_.__l.__size_;
  if (v10 != 1
    || ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (v11 = &v101)
      : (v11 = (std::string *)v101.__r_.__value_.__r.__words[0]),
        v11->__r_.__value_.__s.__data_[0] != 49))
  {
    filter_factory_log();
    v81 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      v86 = &v101;
      if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v86 = (std::string *)v101.__r_.__value_.__r.__words[0];
      v87 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v87 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v86;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v87;
      v83 = "Unrecognized payload version '%s' for payload type '%s'.";
      v84 = v81;
      v85 = 22;
      goto LABEL_240;
    }
LABEL_225:

    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    goto LABEL_226;
  }
  v12 = *a1;
  if (!*a1)
    goto LABEL_241;
  *(_QWORD *)buf = 0;
  applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(&theArray, v12, CFSTR("Payload"), buf);
  if (*(_QWORD *)buf)
    CFRelease(*(CFTypeRef *)buf);
  v13 = theArray;
  if (!theArray)
  {
    filter_factory_log();
    v81 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v83 = "Specification is missing the payload";
      v84 = v81;
      v85 = 2;
LABEL_240:
      _os_log_error_impl(&dword_1DA6F2000, v84, OS_LOG_TYPE_ERROR, v83, buf, v85);
      goto LABEL_225;
    }
    goto LABEL_225;
  }
  v14 = 0;
  v15 = (unsigned int **)(a2 + 36);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v89 = (KB *)(a2 + 2);
  v90 = (unsigned int **)(a2 + 36);
  v91 = a2;
  while (v14 < CFArrayGetCount(v13))
  {
    v99 = 0;
    filter_factory_log();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      v17 = *a2;
      v18 = "UNKNOWN";
      if (v17 <= 6)
        v18 = off_1EA101E38[v17];
      *(_DWORD *)buf = 134218242;
      *(_QWORD *)&buf[4] = v14;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v18;
      _os_log_impl(&dword_1DA6F2000, v16, OS_LOG_TYPE_INFO, "Try to match rule %ld for lookup type %s", buf, 0x16u);
    }

    *(_QWORD *)buf = 0;
    applesauce::CF::at_or<applesauce::CF::DictionaryRef>(&v98, v13, v14, buf);
    if (*(_QWORD *)buf)
      CFRelease(*(CFTypeRef *)buf);
    if (!v98)
    {
      filter_factory_log();
      v21 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1DA6F2000, v21, OS_LOG_TYPE_ERROR, "Filter specification rule is not a dictionary.", buf, 2u);
      }
      goto LABEL_48;
    }
    *(_QWORD *)buf = 0;
    applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(&theDict, (CFDictionaryRef)v98, CFSTR("MatchCriteria"), buf);
    if (*(_QWORD *)buf)
      CFRelease(*(CFTypeRef *)buf);
    v19 = theDict;
    if (!theDict)
    {
      filter_factory_log();
      v21 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        KB::utf8_string(CFSTR("MatchCriteria"), (uint64_t)buf);
        v26 = *(const char **)&buf[8];
        if (!*(_QWORD *)&buf[8])
          v26 = &buf[16];
        v27 = "";
        if (*(_WORD *)buf)
          v27 = v26;
        LODWORD(v105.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v105.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
        _os_log_error_impl(&dword_1DA6F2000, v21, OS_LOG_TYPE_ERROR, "Filter specification rule is missing key '%s', or key value is not a dictionary.", (uint8_t *)&v105, 0xCu);
        if (*(_QWORD *)&buf[8] && buf[6] == 1)
          free(*(void **)&buf[8]);
      }
LABEL_48:

      v22 = 0;
      goto LABEL_211;
    }
    memset(&v96, 0, sizeof(v96));
    Value = (const __CFArray *)CFDictionaryGetValue(theDict, CFSTR("LookupTypes"));
    if (Value)
    {
      applesauce::CF::convert_as<std::vector<std::string>,0>((int64x2_t *)buf, Value);
      if (v108)
      {
        memset(&v105, 0, sizeof(v105));
        std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(&v105, *(__int128 **)buf, *(__int128 **)&buf[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 3));
        if (v108)
        {
          v104.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v104);
        }
        goto LABEL_51;
      }
    }
    else
    {
      buf[0] = 0;
      v108 = 0;
    }
    v105 = v96;
    memset(&v96, 0, sizeof(v96));
LABEL_51:
    *(_QWORD *)buf = &v96;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
    if (v105.__r_.__value_.__r.__words[0] != v105.__r_.__value_.__l.__size_)
    {
      std::string::basic_string[abi:nn180100]<0>(buf, "*");
      v23 = v105.__r_.__value_.__l.__size_;
      v24 = std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v105.__r_.__value_.__l.__data_, v105.__r_.__value_.__l.__size_, (unsigned __int8 **)buf);
      if (v107 < 0)
        operator delete(*(void **)buf);
      if (v24 == v23)
      {
        switch(*a2)
        {
          case 0u:
            v25 = "Autocorrection";
            goto LABEL_69;
          case 1u:
            v25 = "Completions";
            goto LABEL_69;
          case 3u:
            v25 = "Predictions";
            goto LABEL_69;
          case 4u:
            v25 = "Replacement";
            goto LABEL_69;
          case 5u:
            v25 = "ContinuousPath";
            goto LABEL_69;
          case 6u:
            v25 = "ContinuousPathAlternates";
LABEL_69:
            std::string::basic_string[abi:nn180100]<0>(buf, v25);
            v28 = v105.__r_.__value_.__l.__size_;
            v29 = std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v105.__r_.__value_.__l.__data_, v105.__r_.__value_.__l.__size_, (unsigned __int8 **)buf);
            if (v107 < 0)
              operator delete(*(void **)buf);
            if (v29 != v28)
              goto LABEL_72;
            goto LABEL_147;
          default:
LABEL_147:
            *(_QWORD *)buf = &v105;
            std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
            v22 = 0;
            break;
        }
        goto LABEL_210;
      }
    }
LABEL_72:
    applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&v96, v19, CFSTR("FilterClass"));
    v30 = HIBYTE(v96.__r_.__value_.__r.__words[2]);
    if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v30 = v96.__r_.__value_.__l.__size_;
    if (v30)
    {
      if (v30 != 1)
        goto LABEL_79;
      v31 = (std::string *)v96.__r_.__value_.__r.__words[0];
      if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v31 = &v96;
      if (v31->__r_.__value_.__s.__data_[0] != 42)
      {
LABEL_79:
        v32 = a2[34];
        if (v32 == 1)
        {
          if (v30 != 25)
            goto LABEL_100;
          v38 = (std::string *)v96.__r_.__value_.__r.__words[0];
          if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v38 = &v96;
          v39 = v38->__r_.__value_.__r.__words[0];
          v40 = v38->__r_.__value_.__l.__size_;
          v41 = v38->__r_.__value_.__r.__words[2];
          v36 = v38[1].__r_.__value_.__s.__data_[0];
          v37 = v39 == 0x7375696E6F766146 && v40 == 0x6C617551646E6143 && v41 == 0x65746C6946797469;
        }
        else
        {
          if (v32 || v30 != 17)
            goto LABEL_100;
          v33 = (std::string *)v96.__r_.__value_.__r.__words[0];
          if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v33 = &v96;
          v34 = v33->__r_.__value_.__r.__words[0];
          v35 = v33->__r_.__value_.__l.__size_;
          v36 = v33->__r_.__value_.__s.__data_[16];
          v37 = v34 == 0x6C617551646E6143 && v35 == 0x65746C6946797469;
        }
        if (!v37 || v36 != 114)
        {
LABEL_100:
          v22 = 0;
          if ((*((_BYTE *)&v96.__r_.__value_.__s + 23) & 0x80) != 0)
            goto LABEL_208;
          goto LABEL_209;
        }
      }
    }
    *(_QWORD *)buf = 0;
    applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(&v95, v19, CFSTR("Flags"), buf);
    if (*(_QWORD *)buf)
      CFRelease(*(CFTypeRef *)buf);
    v44 = KB::CandidateFilterFlags::candidate_filter_flag_type(v15);
    v46 = (const __CFDictionary *)v95;
    if (!v95)
    {
      std::vector<KB::FilterFlag>::vector(buf, (uint64_t)v15);
      if (*(_QWORD *)buf == *(_QWORD *)&buf[8])
      {
        v58 = 1;
      }
      else
      {
        v57 = *(_QWORD *)buf + 8;
        do
        {
          v58 = *(_BYTE *)(v57 - 4) == 0;
          if (*(_BYTE *)(v57 - 4))
            v59 = 1;
          else
            v59 = v57 == *(_QWORD *)&buf[8];
          v57 += 8;
        }
        while (!v59);
      }
      if (*(_QWORD *)buf)
      {
        *(_QWORD *)&buf[8] = *(_QWORD *)buf;
        operator delete(*(void **)buf);
      }
      if (v58)
        goto LABEL_152;
LABEL_138:
      v22 = 0;
      a2 = v91;
      goto LABEL_205;
    }
    v47 = *((_QWORD *)a2 + 18);
    v48 = *((_QWORD *)a2 + 19);
    if (v47 == v48)
      goto LABEL_152;
    v49 = v44;
    v50 = 1;
    do
    {
      if (*(_DWORD *)v47 == 1)
      {
        v104.__r_.__value_.__r.__words[0] = 0;
        applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(buf, v46, CFSTR("PostLMProcessing"), &v104);
        v51 = *(const __CFDictionary **)buf;
        if (v104.__r_.__value_.__r.__words[0])
          CFRelease(v104.__r_.__value_.__l.__data_);
        if (v51)
        {
          v54 = (unsigned __int16)applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const* const&>(v51);
          if (v54 <= 0x100)
            LOBYTE(v54) = 0;
          v55 = v54 != 0;
          if ((v50 & 1) == 0)
          {
LABEL_121:
            v50 = 0;
            if (v51)
              goto LABEL_125;
            goto LABEL_126;
          }
        }
        else
        {
          v55 = 0;
          if ((v50 & 1) == 0)
            goto LABEL_121;
        }
        if (v49 == 2)
          v56 = v55;
        else
          v56 = 0;
        if (*(unsigned __int8 *)(v47 + 4) == v55)
          v50 = 1;
        else
          v50 = v56;
        if (v51)
          goto LABEL_125;
      }
      else if (!*(_DWORD *)v47)
      {
        v104.__r_.__value_.__r.__words[0] = 0;
        applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(buf, v46, CFSTR("PreLMProcessing"), &v104);
        v51 = *(const __CFDictionary **)buf;
        if (v104.__r_.__value_.__r.__words[0])
          CFRelease(v104.__r_.__value_.__l.__data_);
        if (v51)
        {
          v52 = (unsigned __int16)applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const* const&>(v51);
          if (v52 <= 0x100)
            LOBYTE(v52) = 0;
          v53 = v52 != 0;
        }
        else
        {
          v53 = 0;
        }
        v50 &= *(unsigned __int8 *)(v47 + 4) == v53;
        if (v51)
LABEL_125:
          CFRelease(v51);
      }
LABEL_126:
      v47 += 8;
    }
    while (v47 != v48);
    if ((v50 & 1) == 0)
      goto LABEL_138;
LABEL_152:
    KB::ns_string(v89, v45);
    v60 = (void *)objc_claimAutoreleasedReturnValue();
    Language = (const __CFString *)TIInputModeGetLanguage();
    KB::std_string(Language, buf);
    v104.__r_.__value_.__r.__words[0] = 0;
    applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(&cf, v19, CFSTR("Languages"), &v104);
    if (v104.__r_.__value_.__r.__words[0])
      CFRelease(v104.__r_.__value_.__l.__data_);
    v62 = cf;
    a2 = v91;
    if (cf)
    {
      v92 = 0uLL;
      v93 = 0;
      applesauce::CF::convert_or<std::vector<std::string>,0>(&v104, (const __CFArray *)cf, &v92);
      v103 = &v92;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v103);
      v63 = v104.__r_.__value_.__l.__size_;
      if (v104.__r_.__value_.__r.__words[0] != v104.__r_.__value_.__l.__size_
        && std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)buf) == v63)
      {
        std::string::basic_string[abi:nn180100]<0>(&v92, "*");
        v65 = *(_OWORD *)&v104.__r_.__value_.__l.__data_;
        v64 = (_QWORD)v65
            + 24
            * ((std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)&v92)- (uint64_t)v65)/ 24) != *((_QWORD *)&v65 + 1);
        if (SHIBYTE(v93) < 0)
          operator delete((void *)v92.n128_u64[0]);
        v92.n128_u64[0] = (unint64_t)&v104;
        std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
        a2 = v91;
      }
      else
      {
        v92.n128_u64[0] = (unint64_t)&v104;
        std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
        v64 = 1;
      }
      CFRelease(v62);
    }
    else
    {
      v64 = 1;
    }
    if (v107 < 0)
      operator delete(*(void **)buf);
    if (v64)
    {
      Region = (const __CFString *)TIInputModeGetRegion();
      KB::std_string(Region, buf);
      v104.__r_.__value_.__r.__words[0] = 0;
      applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(&cf, v19, CFSTR("Regions"), &v104);
      if (v104.__r_.__value_.__r.__words[0])
        CFRelease(v104.__r_.__value_.__l.__data_);
      v67 = cf;
      if (cf)
      {
        v92 = 0uLL;
        v93 = 0;
        applesauce::CF::convert_or<std::vector<std::string>,0>(&v104, (const __CFArray *)cf, &v92);
        v103 = &v92;
        std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v103);
        v68 = v104.__r_.__value_.__l.__size_;
        if (v104.__r_.__value_.__r.__words[0] != v104.__r_.__value_.__l.__size_
          && std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)buf) == v68)
        {
          std::string::basic_string[abi:nn180100]<0>(&v92, "*");
          v70 = *(_OWORD *)&v104.__r_.__value_.__l.__data_;
          v69 = (_QWORD)v70
              + 24
              * ((std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)&v92)- (uint64_t)v70)/ 24) != *((_QWORD *)&v70 + 1);
          if (SHIBYTE(v93) < 0)
            operator delete((void *)v92.n128_u64[0]);
          v92.n128_u64[0] = (unint64_t)&v104;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
          a2 = v91;
        }
        else
        {
          v92.n128_u64[0] = (unint64_t)&v104;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
          v69 = 1;
        }
        CFRelease(v67);
      }
      else
      {
        v69 = 1;
      }
      if (v107 < 0)
        operator delete(*(void **)buf);
      if (v69)
      {
        Variant = (const __CFString *)TIInputModeGetVariant();
        KB::std_string(Variant, buf);
        v104.__r_.__value_.__r.__words[0] = 0;
        applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(&cf, v19, CFSTR("Variants"), &v104);
        if (v104.__r_.__value_.__r.__words[0])
          CFRelease(v104.__r_.__value_.__l.__data_);
        if (cf)
        {
          v72 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&cf);
          v92 = 0uLL;
          v93 = 0;
          applesauce::CF::convert_or<std::vector<std::string>,0>(&v104, *v72, &v92);
          v103 = &v92;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v103);
          v73 = v104.__r_.__value_.__l.__size_;
          if (v104.__r_.__value_.__r.__words[0] != v104.__r_.__value_.__l.__size_
            && std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)buf) == v73)
          {
            std::string::basic_string[abi:nn180100]<0>(&v92, "*");
            v75 = *(_OWORD *)&v104.__r_.__value_.__l.__data_;
            v74 = (_QWORD)v75
                + 24
                * ((std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)&v92)- (uint64_t)v75)/ 24) != *((_QWORD *)&v75 + 1);
            if (SHIBYTE(v93) < 0)
              operator delete((void *)v92.n128_u64[0]);
            v92.n128_u64[0] = (unint64_t)&v104;
            std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
            a2 = v91;
          }
          else
          {
            v92.n128_u64[0] = (unint64_t)&v104;
            std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
            v74 = 1;
          }
          if (cf)
            CFRelease(cf);
        }
        else
        {
          v74 = 1;
        }
        if (v107 < 0)
          operator delete(*(void **)buf);
        if (v74)
        {
          filter_factory_log();
          v76 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1DA6F2000, v76, OS_LOG_TYPE_INFO, "Found matching rule!", buf, 2u);
          }

          v77 = (CFDictionaryRef *)applesauce::CF::ArrayRef::operator->(&v98);
          v104.__r_.__value_.__r.__words[0] = 0;
          applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(buf, *v77, CFSTR("FilterStack"), &v104);
          v22 = *(const void **)buf;
          v99 = *(CFTypeRef *)buf;
          if (v104.__r_.__value_.__r.__words[0])
            CFRelease(v104.__r_.__value_.__l.__data_);
          if (v22)
          {
            std::vector<applesauce::CF::ArrayRef>::push_back[abi:nn180100]((char **)a3, &v99);
            goto LABEL_204;
          }
          filter_factory_log();
          v78 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
          {
            KB::utf8_string(CFSTR("FilterStack"), (uint64_t)buf);
            v79 = *(const char **)&buf[8];
            if (!*(_QWORD *)&buf[8])
              v79 = &buf[16];
            v80 = "";
            if (*(_WORD *)buf)
              v80 = v79;
            LODWORD(v104.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)v104.__r_.__value_.__r.__words + 4) = (std::string::size_type)v80;
            _os_log_error_impl(&dword_1DA6F2000, v78, OS_LOG_TYPE_ERROR, "Filter specification rule is missing key '%s', or key value is not an array.", (uint8_t *)&v104, 0xCu);
            if (*(_QWORD *)&buf[8] && buf[6] == 1)
              free(*(void **)&buf[8]);
          }

        }
      }
    }
    v22 = 0;
LABEL_204:

LABEL_205:
    if (v46)
      CFRelease(v46);
    v15 = v90;
    if ((*((_BYTE *)&v96.__r_.__value_.__s + 23) & 0x80) != 0)
LABEL_208:
      operator delete(v96.__r_.__value_.__l.__data_);
LABEL_209:
    *(_QWORD *)buf = &v105;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
    if (v19)
LABEL_210:
      CFRelease(v19);
LABEL_211:
    if (v98)
      CFRelease(v98);
    if (v22)
    {
      CFRelease(v22);
      v13 = theArray;
    }
    ++v14;
    if (!v13)
    {
LABEL_241:
      exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(exception);
    }
  }
  if (theArray)
    CFRelease(theArray);
LABEL_226:
  if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v101.__r_.__value_.__l.__data_);
LABEL_11:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1DA7A4868()
{
  void *v0;

}

void applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(_QWORD *a1, CFDictionaryRef theDict, void *key, _QWORD *a4)
{
  const void *Value;
  const void *v7;
  CFTypeID v8;

  if (theDict)
  {
    if (key)
    {
      Value = CFDictionaryGetValue(theDict, key);
      if (Value)
      {
        v7 = Value;
        CFRetain(Value);
        v8 = CFGetTypeID(v7);
        if (v8 == CFArrayGetTypeID())
        {
          CFRetain(v7);
          *a1 = v7;
          CFRelease(v7);
          return;
        }
        CFRelease(v7);
      }
    }
  }
  *a1 = *a4;
  *a4 = 0;
}

uint64_t std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  uint64_t v3;
  char v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;

  v3 = a1;
  if (a1 != a2)
  {
    v5 = *((_BYTE *)a3 + 23);
    if (v5 >= 0)
      v6 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
    else
      v6 = a3[1];
    if (v5 >= 0)
      v7 = (unsigned __int8 *)a3;
    else
      v7 = *a3;
    do
    {
      v8 = *(unsigned __int8 *)(v3 + 23);
      if ((v8 & 0x80u) == 0)
        v9 = (unsigned __int8 *)*(unsigned __int8 *)(v3 + 23);
      else
        v9 = *(unsigned __int8 **)(v3 + 8);
      if (v9 == v6)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v3, v7, *(_QWORD *)(v3 + 8)))
            return v3;
        }
        else
        {
          if (!*(_BYTE *)(v3 + 23))
            return v3;
          v10 = 0;
          while (*(unsigned __int8 *)(v3 + v10) == v7[v10])
          {
            if (v8 == ++v10)
              return v3;
          }
        }
      }
      v3 += 24;
    }
    while (v3 != a2);
    return a2;
  }
  return v3;
}

_QWORD *std::vector<KB::FilterFlag>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](a1, v5 >> 3);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

__n128 applesauce::CF::convert_or<std::vector<std::string>,0>(std::string *a1, const __CFArray *a2, __n128 *a3)
{
  __n128 result;
  int64x2_t v6;
  char v7;
  int64x2_t *v8;

  applesauce::CF::convert_as<std::vector<std::string>,0>(&v6, a2);
  if (v7)
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(a1, (__int128 *)v6.i64[0], (__int128 *)v6.i64[1], 0xAAAAAAAAAAAAAAABLL * ((v6.i64[1] - v6.i64[0]) >> 3));
    v8 = &v6;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v8);
  }
  else
  {
    result = *a3;
    *(__n128 *)&a1->__r_.__value_.__l.__data_ = *a3;
    a1->__r_.__value_.__r.__words[2] = a3[1].n128_u64[0];
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    a3->n128_u64[0] = 0;
  }
  return result;
}

_QWORD *applesauce::CF::ArrayRef::operator->(_QWORD *result)
{
  applesauce::CF *exception;

  if (!*result)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_1DA7A4AF0()
{
  void *v0;

}

void std::vector<applesauce::CF::ArrayRef>::push_back[abi:nn180100](char **a1, CFTypeRef *a2)
{
  unint64_t v4;
  char *v5;
  CFTypeRef v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  CFTypeRef v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  int64x2_t v21;
  char *v22;
  char *v23;
  const void *v24;
  const void *v25;

  v5 = a1[1];
  v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    v8 = (v5 - *a1) >> 3;
    if ((unint64_t)(v8 + 1) >> 61)
      abort();
    v9 = v4 - (_QWORD)*a1;
    v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v11);
      v14 = v13;
    }
    else
    {
      v12 = 0;
      v14 = 0;
    }
    v15 = &v12[8 * v8];
    v16 = *a2;
    if (v16)
      CFRetain(v16);
    v17 = &v12[8 * v14];
    *(_QWORD *)v15 = v16;
    v7 = v15 + 8;
    v19 = *a1;
    v18 = a1[1];
    if (v18 == *a1)
    {
      v21 = vdupq_n_s64((unint64_t)v18);
    }
    else
    {
      do
      {
        v20 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *((_QWORD *)v15 - 1) = v20;
        v15 -= 8;
        *(_QWORD *)v18 = 0;
      }
      while (v18 != v19);
      v21 = *(int64x2_t *)a1;
    }
    *a1 = v15;
    a1[1] = v7;
    a1[2] = v17;
    v23 = (char *)v21.i64[1];
    v22 = (char *)v21.i64[0];
    while (v23 != v22)
    {
      v25 = (const void *)*((_QWORD *)v23 - 1);
      v23 -= 8;
      v24 = v25;
      if (v25)
        CFRelease(v24);
    }
    if (v22)
      operator delete(v22);
  }
  else
  {
    v6 = *a2;
    if (*a2)
      CFRetain(*a2);
    *(_QWORD *)v5 = v6;
    v7 = v5 + 8;
  }
  a1[1] = v7;
}

void applesauce::CF::convert_as<std::vector<std::string>,0>(int64x2_t *a1, const __CFArray *a2)
{
  CFTypeID TypeID;
  CFIndex Count;
  int v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  __int128 v12;
  int64x2_t v13;
  std::string *v14;
  CFIndex v15;
  const __CFString *ValueAtIndex;
  int v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  __int128 v27;
  int64x2_t v28;
  char v29;
  unint64_t v30;
  std::string *v31;
  void *__p[2];
  uint64_t v33;
  unsigned __int8 v34;
  int64x2_t v35;
  std::string *v36;
  std::__split_buffer<std::string> v37;

  if (a2 && (TypeID = CFArrayGetTypeID(), TypeID == CFGetTypeID(a2)))
  {
    Count = CFArrayGetCount(a2);
    v6 = Count;
    v35 = 0uLL;
    v36 = 0;
    if (Count << 32)
    {
      if (Count << 32 < 0)
LABEL_39:
        abort();
      v37.__end_cap_.__value_ = (std::allocator<std::string> *)&v36;
      v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((int)Count);
      v9 = v35.i64[1];
      v10 = v35.i64[0];
      if (v35.i64[1] == v35.i64[0])
      {
        v13 = vdupq_n_s64(v35.u64[1]);
        v11 = v7;
      }
      else
      {
        v11 = v7;
        do
        {
          v12 = *(_OWORD *)(v9 - 24);
          *((_QWORD *)v11 - 1) = *(_QWORD *)(v9 - 8);
          *(_OWORD *)(v11 - 24) = v12;
          v11 -= 24;
          *(_QWORD *)(v9 - 16) = 0;
          *(_QWORD *)(v9 - 8) = 0;
          *(_QWORD *)(v9 - 24) = 0;
          v9 -= 24;
        }
        while (v9 != v10);
        v13 = v35;
      }
      v35.i64[0] = (uint64_t)v11;
      v35.i64[1] = (uint64_t)v7;
      *(int64x2_t *)&v37.__begin_ = v13;
      v14 = v36;
      v36 = (std::string *)&v7[24 * v8];
      v37.__end_cap_.__value_ = v14;
      v37.__first_ = (std::__split_buffer<std::string>::pointer)v13.i64[0];
      std::__split_buffer<std::string>::~__split_buffer(&v37);
    }
    if (v6 < 1)
    {
LABEL_35:
      *a1 = v35;
      a1[1].i64[0] = (uint64_t)v36;
      v36 = 0;
      v35 = 0uLL;
      a1[1].i8[8] = 1;
    }
    else
    {
      v15 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v15);
        applesauce::CF::convert_as<std::string,0>((uint64_t)__p, ValueAtIndex);
        v17 = v34;
        if (!v34)
          break;
        v18 = v35.i64[1];
        if (v35.i64[1] >= (unint64_t)v36)
        {
          v19 = 0xAAAAAAAAAAAAAAABLL * ((v35.i64[1] - v35.i64[0]) >> 3);
          v20 = v19 + 1;
          if (v19 + 1 > 0xAAAAAAAAAAAAAAALL)
            goto LABEL_39;
          if (0x5555555555555556 * (((uint64_t)v36 - v35.i64[0]) >> 3) > v20)
            v20 = 0x5555555555555556 * (((uint64_t)v36 - v35.i64[0]) >> 3);
          if (0xAAAAAAAAAAAAAAABLL * (((uint64_t)v36 - v35.i64[0]) >> 3) >= 0x555555555555555)
            v21 = 0xAAAAAAAAAAAAAAALL;
          else
            v21 = v20;
          v37.__end_cap_.__value_ = (std::allocator<std::string> *)&v36;
          if (v21)
            v21 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v21);
          else
            v22 = 0;
          v23 = v21 + 24 * v19;
          *(_QWORD *)(v23 + 16) = v33;
          *(_OWORD *)v23 = *(_OWORD *)__p;
          __p[1] = 0;
          v33 = 0;
          __p[0] = 0;
          v24 = v35.i64[1];
          v25 = v35.i64[0];
          if (v35.i64[1] == v35.i64[0])
          {
            v29 = 0;
            v28 = vdupq_n_s64(v35.u64[1]);
            v26 = v23;
          }
          else
          {
            v26 = v21 + 24 * v19;
            do
            {
              v27 = *(_OWORD *)(v24 - 24);
              *(_QWORD *)(v26 - 8) = *(_QWORD *)(v24 - 8);
              *(_OWORD *)(v26 - 24) = v27;
              v26 -= 24;
              *(_QWORD *)(v24 - 16) = 0;
              *(_QWORD *)(v24 - 8) = 0;
              *(_QWORD *)(v24 - 24) = 0;
              v24 -= 24;
            }
            while (v24 != v25);
            v28 = v35;
            v17 = v34;
            v29 = HIBYTE(v33);
          }
          v30 = v23 + 24;
          v35.i64[0] = v26;
          v35.i64[1] = v23 + 24;
          *(int64x2_t *)&v37.__begin_ = v28;
          v31 = v36;
          v36 = (std::string *)(v21 + 24 * v22);
          v37.__end_cap_.__value_ = v31;
          v37.__first_ = (std::__split_buffer<std::string>::pointer)v28.i64[0];
          std::__split_buffer<std::string>::~__split_buffer(&v37);
          v35.i64[1] = v30;
          if (v17)
          {
            if (v29 < 0)
              operator delete(__p[0]);
          }
        }
        else
        {
          *(_OWORD *)v35.i64[1] = *(_OWORD *)__p;
          *(_QWORD *)(v18 + 16) = v33;
          __p[1] = 0;
          v33 = 0;
          __p[0] = 0;
          v35.i64[1] = v18 + 24;
        }
        if (++v15 == v6)
          goto LABEL_35;
      }
      a1->i8[0] = 0;
      a1[1].i8[8] = 0;
    }
    v37.__first_ = (std::__split_buffer<std::string>::pointer)&v35;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
  }
  else
  {
    a1->i8[0] = 0;
    a1[1].i8[8] = 0;
  }
}

char *std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;

  if (a2 >> 61)
    abort();
  result = (char *)operator new(8 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * a2];
  return result;
}

void KB::CandidateFilterFactory::create_filter_stack_from_specification(uint64_t *a1@<X0>, const KB::CandidateFilterConfiguration *a2@<X1>, _QWORD *a3@<X8>)
{
  NSObject *v5;
  const char *v6;
  _BYTE v7[24];
  uint64_t v8;
  uint64_t v9;
  _BYTE buf[24];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition((uint64_t)v7, a1);
  KB::CandidateFilterFactory::create_standard_filter_definition((uint64_t)a2, (uint64_t)v7);
  KB::CandidateFilterFactory::FilterStackDefinition::convert_filter_stack_definition_to_filters((KB::CandidateFilterFactory::FilterStackDefinition *)v7, a2, a3);
  filter_factory_log();
  v5 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    if (*a3)
      v6 = "yes";
    else
      v6 = "no";
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v6;
    _os_log_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_INFO, "Done creating filter stack (success=%s)", buf, 0xCu);
  }

  std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::~__hash_table((uint64_t)&v9);
  *(_QWORD *)buf = &v8;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  *(_QWORD *)buf = v7;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
}

void KB::LanguageModelContainer::~LanguageModelContainer(KB::LanguageModelContainer *this)
{
  KB::LanguageModelContainer::~LanguageModelContainer(this);
  JUMPOUT(0x1DF0A2144);
}

{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  std::__shared_weak_count *v5;
  void **v6;

  *(_QWORD *)this = &off_1EA0FD330;
  v2 = (_QWORD *)*((_QWORD *)this + 8);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,NSObject  {objcproto17OS_dispatch_queue}* {__strong}>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v4)
    operator delete(v4);
  v6 = (void **)((char *)this + 24);
  std::vector<KB::LanguageModelLexiconGroup>::__destroy_vector::operator()[abi:nn180100](&v6);
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

uint64_t KB::LanguageModelContainer::is_string_based_lm_model(KB::LanguageModelContainer *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  BOOL v5;

  v1 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 4);
  if (v1 == v2)
    return 0;
  v3 = v1 + 56;
  do
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 - 56) + 24))(*(_QWORD *)(v3 - 56));
    if ((result & 1) != 0)
      break;
    v5 = v3 == v2;
    v3 += 56;
  }
  while (!v5);
  return result;
}

uint64_t KB::LanguageModelContainer::lexicon_id(KB::LanguageModelContainer *this)
{
  return 0xFFFFFFFFLL;
}

void KB::LanguageModelContainer::lexicon_id_vector(KB::LanguageModelContainer *this@<X0>, char **a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  char *v5;
  _DWORD *v6;
  _DWORD *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  int v16;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 4);
  if (v3 != v2)
  {
    v5 = 0;
    v17 = *((_QWORD *)this + 4);
    do
    {
      if (*(_QWORD *)v3)
      {
        (*(void (**)(_DWORD **__return_ptr))(**(_QWORD **)v3 + 48))(&v18);
        v6 = v18;
        v7 = v19;
        if (v18 != v19)
        {
          v8 = (unint64_t)a2[2];
          v9 = *a2;
          do
          {
            if ((unint64_t)v5 >= v8)
            {
              v10 = (v5 - v9) >> 2;
              v11 = v10 + 1;
              if ((unint64_t)(v10 + 1) >> 62)
                abort();
              if ((uint64_t)(v8 - (_QWORD)v9) >> 1 > v11)
                v11 = (uint64_t)(v8 - (_QWORD)v9) >> 1;
              if (v8 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL)
                v12 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v12 = v11;
              if (v12)
                v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v12);
              else
                v13 = 0;
              v14 = (char *)(v12 + 4 * v10);
              *(_DWORD *)v14 = *v6;
              v15 = v14 + 4;
              while (v5 != v9)
              {
                v16 = *((_DWORD *)v5 - 1);
                v5 -= 4;
                *((_DWORD *)v14 - 1) = v16;
                v14 -= 4;
              }
              v8 = v12 + 4 * v13;
              *a2 = v14;
              a2[1] = v15;
              a2[2] = (char *)v8;
              if (v9)
                operator delete(v9);
              v9 = v14;
              v5 = v15;
            }
            else
            {
              *(_DWORD *)v5 = *v6;
              v5 += 4;
            }
            a2[1] = v5;
            ++v6;
          }
          while (v6 != v7);
          v2 = v17;
          v6 = v18;
        }
        if (v6)
        {
          v19 = v6;
          operator delete(v6);
        }
      }
      v3 += 56;
    }
    while (v3 != v2);
  }
}

void KB::LanguageModelContainer::active_locale_identifiers_vector(KB::LanguageModelContainer *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = *((_QWORD *)this + 3);
  v3 = *((_QWORD *)this + 4);
  if (v2 != v3)
  {
    v5 = 0;
    do
    {
      (*(void (**)(_QWORD **__return_ptr))(**(_QWORD **)v2 + 56))(&v18);
      v6 = v18;
      v7 = v19;
      if (v18 != v19)
      {
        do
        {
          v8 = a2[2];
          if ((unint64_t)v5 >= v8)
          {
            v9 = (_QWORD *)*a2;
            v10 = ((uint64_t)v5 - *a2) >> 3;
            v11 = v10 + 1;
            if ((unint64_t)(v10 + 1) >> 61)
              abort();
            v12 = v8 - (_QWORD)v9;
            if (v12 >> 2 > v11)
              v11 = v12 >> 2;
            if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
              v13 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v13 = v11;
            if (v13)
              v13 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v13);
            else
              v14 = 0;
            v15 = (_QWORD *)(v13 + 8 * v10);
            *v15 = *v6;
            v16 = v15 + 1;
            if (v5 != v9)
            {
              do
              {
                v17 = *--v5;
                *--v15 = v17;
              }
              while (v5 != v9);
              v5 = (_QWORD *)*a2;
            }
            *a2 = v15;
            a2[1] = v16;
            a2[2] = v13 + 8 * v14;
            if (v5)
              operator delete(v5);
            v5 = v16;
          }
          else
          {
            *v5++ = *v6;
          }
          a2[1] = v5;
          ++v6;
        }
        while (v6 != v7);
        v6 = v18;
      }
      if (v6)
      {
        v19 = v6;
        operator delete(v6);
      }
      v2 += 56;
    }
    while (v2 != v3);
  }
}

uint64_t KB::LanguageModelContainer::does_support_english(KB::LanguageModelContainer *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  BOOL v5;

  v1 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 4);
  if (v1 == v2)
    return 0;
  v3 = v1 + 56;
  do
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 - 56) + 64))(*(_QWORD *)(v3 - 56));
    if ((result & 1) != 0)
      break;
    v5 = v3 == v2;
    v3 += 56;
  }
  while (!v5);
  return result;
}

uint64_t KB::LanguageModelContainer::load(uint64_t this, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *i;
  uint64_t v5;

  v2 = *(uint64_t **)(this + 24);
  for (i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 72))(v5, a2))
  {
    v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::reload_with_locales(uint64_t this, const __CFArray *a2)
{
  uint64_t *v2;
  uint64_t *i;
  uint64_t v5;

  v2 = *(uint64_t **)(this + 24);
  for (i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const __CFArray *))(*(_QWORD *)v5 + 80))(v5, a2))
  {
    v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::synchronized_load(uint64_t this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;

  v1 = *(uint64_t **)(this + 24);
  v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 96))(v3);
  }
  return this;
}

uint64_t KB::LanguageModelContainer::clear_dynamic_learning_cache(uint64_t this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;

  v1 = *(uint64_t **)(this + 24);
  v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 104))(v3);
  }
  return this;
}

uint64_t KB::LanguageModelContainer::clear_recent_text_cache(uint64_t this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;

  v1 = *(uint64_t **)(this + 24);
  v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 112))(v3);
  }
  return this;
}

uint64_t KB::LanguageModelContainer::does_provide_completions(KB::LanguageModelContainer *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  BOOL v5;

  v1 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 4);
  if (v1 == v2)
    return 1;
  v3 = v1 + 56;
  do
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 - 56) + 128))(*(_QWORD *)(v3 - 56));
    if ((_DWORD)result)
      v5 = v3 == v2;
    else
      v5 = 1;
    v3 += 56;
  }
  while (!v5);
  return result;
}

uint64_t KB::LanguageModelContainer::does_provide_inline_completions(KB::LanguageModelContainer *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  BOOL v5;

  v1 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 4);
  if (v1 == v2)
    return 0;
  v3 = v1 + 56;
  do
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 - 56) + 144))(*(_QWORD *)(v3 - 56));
    if ((result & 1) != 0)
      break;
    v5 = v3 == v2;
    v3 += 56;
  }
  while (!v5);
  return result;
}

uint64_t KB::LanguageModelContainer::does_provide_inline_completions_for_locale(KB::LanguageModelContainer *this, const KB::String *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t result;
  BOOL v7;

  v2 = *((_QWORD *)this + 3);
  v3 = *((_QWORD *)this + 4);
  if (v2 == v3)
    return 0;
  v5 = v2 + 56;
  do
  {
    result = (*(uint64_t (**)(_QWORD, const KB::String *))(**(_QWORD **)(v5 - 56) + 152))(*(_QWORD *)(v5 - 56), a2);
    if ((result & 1) != 0)
      break;
    v7 = v5 == v3;
    v5 += 56;
  }
  while (!v7);
  return result;
}

uint64_t KB::LanguageModelContainer::supports_fragment_based_conditional_prob(KB::LanguageModelContainer *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  BOOL v5;

  v1 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 4);
  if (v1 == v2)
    return 1;
  v3 = v1 + 56;
  do
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 - 56) + 168))(*(_QWORD *)(v3 - 56));
    if ((_DWORD)result)
      v5 = v3 == v2;
    else
      v5 = 1;
    v3 += 56;
  }
  while (!v5);
  return result;
}

uint64_t KB::LanguageModelContainer::should_score_completion_candidate(KB::LanguageModelContainer *this, const KB::Candidate *a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = KB::LanguageModelContainer::index_for_lexicon_id(this, *(_DWORD *)(*((_QWORD *)a2 + 1) + 240 * *(_QWORD *)a2 - 104));
  if (v3 == -1)
    return 1;
  v4 = *(_QWORD *)(*((_QWORD *)this + 3) + 56 * v3);
  return (*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 128))(v4) ^ 1;
}

uint64_t KB::LanguageModelContainer::wire_memory(uint64_t this)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = *(_QWORD **)(this + 24);
  v2 = *(_QWORD **)(this + 32);
  while (v1 != v2)
  {
    this = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 16))(*v1);
    if ((_DWORD)this)
      this = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 184))(*v1);
    v1 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::unwire_memory(uint64_t this)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = *(_QWORD **)(this + 24);
  v2 = *(_QWORD **)(this + 32);
  while (v1 != v2)
  {
    this = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 16))(*v1);
    if ((_DWORD)this)
      this = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 192))(*v1);
    v1 += 7;
  }
  return this;
}

void KB::LanguageModelContainer::get_num_candidates(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t v6;

  v1 = *(uint64_t **)(a1 + 24);
  v2 = *v1;
  v3 = (std::__shared_weak_count *)v1[1];
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 200))(v2);
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 200))(v2);
  }
}

void KB::LanguageModelContainer::copyLinguisticDataFiles(KB::LanguageModelContainer *this)
{
  uint64_t *v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t v6;

  v1 = (uint64_t *)*((_QWORD *)this + 3);
  v2 = *v1;
  v3 = (std::__shared_weak_count *)v1[1];
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 208))(v2);
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 208))(v2);
  }
}

uint64_t KB::LanguageModelContainer::set_inline_completion_personalization(uint64_t this, const KB::String *a2)
{
  uint64_t *v2;
  uint64_t *i;
  uint64_t v5;

  v2 = *(uint64_t **)(this + 24);
  for (i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const KB::String *))(*(_QWORD *)v5 + 240))(v5, a2))
  {
    v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::set_app_context(uint64_t this, const __CFString *a2)
{
  uint64_t *v2;
  uint64_t *i;
  uint64_t v5;

  v2 = *(uint64_t **)(this + 24);
  for (i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const __CFString *))(*(_QWORD *)v5 + 248))(v5, a2))
  {
    v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::set_recipient_context(uint64_t this, const __CFDictionary *a2)
{
  uint64_t *v2;
  uint64_t *i;
  uint64_t v5;

  v2 = *(uint64_t **)(this + 24);
  for (i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const __CFDictionary *))(*(_QWORD *)v5 + 256))(v5, a2))
  {
    v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::start_session(uint64_t result, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *i;
  uint64_t v5;

  v2 = *(uint64_t **)(result + 24);
  for (i = *(uint64_t **)(result + 32);
        v2 != i;
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 264))(v5, a2))
  {
    v5 = *v2;
    v2 += 7;
  }
  return result;
}

uint64_t KB::LanguageModelContainer::id_for_separator(KB::LanguageModelContainer *this)
{
  uint64_t *v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v1 = (uint64_t *)*((_QWORD *)this + 3);
  if (v1 == *((uint64_t **)this + 4))
    return 0;
  v2 = *v1;
  v3 = (std::__shared_weak_count *)v1[1];
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  if (v2)
  {
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 280))(v2);
    if (!v3)
      return v6;
  }
  else
  {
    v6 = 0;
    if (!v3)
      return v6;
  }
  v7 = (unint64_t *)&v3->__shared_owners_;
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v6;
}

void KB::LanguageModelContainer::static_words_for_string(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unsigned int a6@<W5>, uint64_t *a7@<X8>)
{
  uint64_t v8;
  unint64_t v14;
  const KB::Word *v15;
  const KB::Word *v16;
  const KB::Word *v17;
  const KB::Word *v19;
  const KB::Word *v20;
  const KB::Word **v21;

  *a7 = 0;
  a7[1] = 0;
  a7[2] = 0;
  v8 = *(_QWORD *)(a1 + 24);
  if (*(_QWORD *)(a1 + 32) != v8)
  {
    v14 = 0;
    do
    {
      (*(void (**)(const KB::Word **__return_ptr, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v8 + 56 * v14) + 288))(&v19, *(_QWORD *)(v8 + 56 * v14), a2, a3, a4, a5, a6);
      v16 = v19;
      v15 = v20;
      v17 = v19;
      if (v19 != v20)
      {
        do
        {
          *((float *)v16 + 12) = KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*(_QWORD *)(a1 + 24) + 56 * v14), *((_DWORD *)v16 + 34))* *((float *)v16 + 12);
          v16 = (const KB::Word *)((char *)v16 + 240);
        }
        while (v16 != v15);
        v17 = v19;
        v16 = v20;
      }
      std::vector<KB::Word>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Word*>,std::__wrap_iter<KB::Word*>>((KB::Word *)a7, a7[1], v17, v16, 0xEEEEEEEEEEEEEEEFLL * ((v16 - v17) >> 4));
      v21 = &v19;
      std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v21);
      ++v14;
      v8 = *(_QWORD *)(a1 + 24);
    }
    while (v14 < 0x6DB6DB6DB6DB6DB7 * ((*(_QWORD *)(a1 + 32) - v8) >> 3));
  }
}

uint64_t KB::LanguageModelContainer::is_dynamic_word_id(KB::LanguageModelContainer *this, TITokenID a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD v7[2];
  uint64_t (*v8)(uint64_t, _QWORD *);
  void *v9;
  TITokenID v10;

  v2 = (_QWORD *)*((_QWORD *)this + 3);
  v3 = (_QWORD *)*((_QWORD *)this + 4);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v8 = ___ZNK2KB22LanguageModelContainer18is_dynamic_word_idE9TITokenID_block_invoke;
  v9 = &__block_descriptor_40_e10_B16__0r_v8l;
  v10 = a2;
  v4 = v7;
  if (v2 == v3)
  {
    v5 = 0;
  }
  else
  {
    do
    {
      v5 = v8((uint64_t)v4, v2);
      if ((v5 & 1) != 0)
        break;
      v2 += 7;
    }
    while (v2 != v3);
  }

  return v5;
}

unint64_t KB::LanguageModelContainer::add_dynamic_word(KB::LanguageModelContainer *this, const __CFString *a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  KB::LanguageModelLexiconGroup *v8;
  unint64_t result;

  v6 = KB::LanguageModelContainer::index_for_lexicon_id(this, a3);
  v7 = *((_QWORD *)this + 3);
  if (v6 >= 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 4) - v7) >> 3))
    return 0;
  v8 = (KB::LanguageModelLexiconGroup *)(v7 + 56 * v6);
  KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v8, a3);
  result = (*(uint64_t (**)(_QWORD, const __CFString *, uint64_t))(**(_QWORD **)v8 + 312))(*(_QWORD *)v8, a2, a3);
  if (!HIDWORD(result))
    return 0;
  return result;
}

uint64_t KB::LanguageModelContainer::increment_usage_count(uint64_t this, const KB::String *a2, const TITokenID *a3, const KB::LanguageModelContext *a4)
{
  TITokenID v5;
  KB::LanguageModelContainer *v8;
  int v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  __int16 v15;
  char v16;
  void *v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (HIDWORD(*(unint64_t *)a3) != 1)
  {
    v8 = (KB::LanguageModelContainer *)this;
    v5 = *a3;
    v9 = KB::LanguageModelContainer::lexicon_id_for_token((KB::LanguageModelContainer *)this, v5, a4);
    this = KB::LanguageModelContainer::index_for_lexicon_id(v8, v9);
    if (this != -1)
    {
      v10 = (_QWORD *)(*((_QWORD *)v8 + 3) + 56 * this);
      v11 = language_modeling::v1::LinguisticContext::tokenSpan((const KB::LanguageModelContext *)((char *)a4 + 64));
      if (v12)
      {
        if (*(_DWORD *)(v11 + 32 * v12 - 8) == 1)
        {
          v13 = *v10;
          v14 = 0x100000;
          v15 = 0;
          v16 = 0;
          v17 = 0;
          v18 = 0;
          (*(void (**)(uint64_t, int *, void *, const KB::LanguageModelContext *))(*(_QWORD *)v13 + 320))(v13, &v14, &kTITokenIDBeginningOfSentence, a4);
          if (v17)
          {
            if (v16 == 1)
              free(v17);
          }
        }
      }
      return (*(uint64_t (**)(_QWORD, const KB::String *, const TITokenID *, const KB::LanguageModelContext *))(*(_QWORD *)*v10 + 320))(*v10, a2, a3, a4);
    }
  }
  return this;
}

void KB::LanguageModelContainer::decrement_usage_count(KB::LanguageModelContainer *this, const KB::String *a2, const TITokenID *a3, const KB::LanguageModelContext *a4)
{
  TITokenID v5;
  int v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  __int16 v16;
  char v17;
  void *v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (HIDWORD(*(unint64_t *)a3) != 1)
  {
    v5 = *a3;
    v9 = KB::LanguageModelContainer::lexicon_id_for_token(this, v5, a4);
    v10 = KB::LanguageModelContainer::index_for_lexicon_id(this, v9);
    if (v10 != -1)
    {
      v11 = (_QWORD *)(*((_QWORD *)this + 3) + 56 * v10);
      (*(void (**)(_QWORD, const KB::String *, const TITokenID *, const KB::LanguageModelContext *))(*(_QWORD *)*v11 + 328))(*v11, a2, a3, a4);
      v12 = language_modeling::v1::LinguisticContext::tokenSpan((const KB::LanguageModelContext *)((char *)a4 + 64));
      if (v13)
      {
        if (*(_DWORD *)(v12 + 32 * v13 - 8) == 1)
        {
          v14 = *v11;
          v15 = 0x100000;
          v16 = 0;
          v17 = 0;
          v18 = 0;
          v19 = 0;
          (*(void (**)(uint64_t, int *, void *, const KB::LanguageModelContext *))(*(_QWORD *)v14 + 328))(v14, &v15, &kTITokenIDBeginningOfSentence, a4);
          if (v18)
          {
            if (v17 == 1)
              free(v18);
          }
        }
      }
    }
  }
}

uint64_t KB::LanguageModelContainer::register_negative_evidence(KB::LanguageModelContainer *a1, uint64_t a2, TITokenID *a3, const KB::LanguageModelContext *a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;
  TITokenID v13;
  unint64_t v14;
  int v15;
  uint64_t v16;

  result = (*(uint64_t (**)(KB::LanguageModelContainer *))(*(_QWORD *)a1 + 24))(a1);
  if ((_DWORD)result)
  {
    result = (*(uint64_t (**)(KB::LanguageModelContainer *, uint64_t, TITokenID *))(*(_QWORD *)a1 + 384))(a1, a2, a3);
    if (!(_DWORD)result)
      return result;
    v13 = *a3;
    goto LABEL_6;
  }
  v13 = *a3;
  v14 = HIDWORD(*(unint64_t *)a3);
  if (v14 && v14 >= 0x1F4)
  {
LABEL_6:
    v15 = KB::LanguageModelContainer::lexicon_id_for_token(a1, v13, a4);
    result = KB::LanguageModelContainer::index_for_lexicon_id(a1, v15);
    if (result != -1)
    {
      v16 = *(_QWORD *)(*((_QWORD *)a1 + 3) + 56 * result);
      return (*(uint64_t (**)(uint64_t, uint64_t, TITokenID *, const KB::LanguageModelContext *, uint64_t, uint64_t))(*(_QWORD *)v16 + 336))(v16, a2, a3, a4, a5, a6);
    }
  }
  return result;
}

unint64_t KB::LanguageModelContainer::record_usage_with_differential_privacy(KB::LanguageModelContainer *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t result;
  uint64_t v9;
  KB::LanguageModelLexiconGroup *v10;

  result = KB::LanguageModelContainer::index_for_lexicon_id(a1, a3);
  v9 = *((_QWORD *)a1 + 3);
  if (result < 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)a1 + 4) - v9) >> 3))
  {
    v10 = (KB::LanguageModelLexiconGroup *)(v9 + 56 * result);
    KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v10, a3);
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)v10 + 344))(*(_QWORD *)v10, a2, a3, a4);
  }
  return result;
}

double KB::LanguageModelContainer::last_offline_adaptation_time(KB::LanguageModelContainer *this)
{
  uint64_t *v1;
  uint64_t *v2;
  double v3;
  uint64_t v4;
  double v5;

  v1 = (uint64_t *)*((_QWORD *)this + 3);
  v2 = (uint64_t *)*((_QWORD *)this + 4);
  v3 = 0.0;
  while (v1 != v2)
  {
    v4 = *v1;
    v1 += 7;
    v5 = (*(double (**)(uint64_t))(*(_QWORD *)v4 + 352))(v4);
    if (v5 < v3)
      v3 = v5;
  }
  return v3;
}

uint64_t KB::LanguageModelContainer::should_adapt_to_paragraph(KB::LanguageModelContainer *this, const __CFString *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD v9[2];
  uint64_t (*v10)(uint64_t, _QWORD *);
  void *v11;
  const __CFString *v12;

  if (!(*(unsigned int (**)(KB::LanguageModelContainer *))(*(_QWORD *)this + 16))(this))
    return 0;
  v4 = (_QWORD *)*((_QWORD *)this + 3);
  v5 = (_QWORD *)*((_QWORD *)this + 4);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v10 = ___ZNK2KB22LanguageModelContainer25should_adapt_to_paragraphEPK10__CFString_block_invoke;
  v11 = &__block_descriptor_40_e10_B16__0r_v8l;
  v12 = a2;
  v6 = v9;
  if (v4 == v5)
  {
    v7 = 0;
  }
  else
  {
    do
    {
      v7 = v10((uint64_t)v6, v4);
      if ((v7 & 1) != 0)
        break;
      v4 += 7;
    }
    while (v4 != v5);
  }

  return v7;
}

void KB::LanguageModelContainer::adapt_to_paragraph(uint64_t a1, KB *this, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  _QWORD *v12;
  _QWORD *v13;
  CFTypeRef v14;
  CFTypeRef cf;

  KB::cf_string_no_copy(this, (CFStringRef *)&cf);
  v12 = *(_QWORD **)(a1 + 24);
  v13 = *(_QWORD **)(a1 + 32);
  v14 = cf;
  while (v12 != v13)
  {
    if ((_DWORD)a5 == 2 || (*(unsigned int (**)(_QWORD, CFTypeRef))(*(_QWORD *)*v12 + 360))(*v12, v14))
      (*(void (**)(_QWORD, KB *, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)*v12 + 368))(*v12, this, a3, a4, a5, a6);
    v12 += 7;
  }
  if (v14)
    CFRelease(v14);
}

uint64_t KB::LanguageModelContainer::is_swear_word_policy_enabled(KB::LanguageModelContainer *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = KB::LanguageModelContainer::index_for_lexicon_id(this, a2);
  if (v4 == -1)
    return 1;
  v5 = *(_QWORD *)(*((_QWORD *)this + 3) + 56 * v4);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 376))(v5, a2);
}

uint64_t KB::LanguageModelContainer::can_reason_about(KB::LanguageModelContainer *this, const KB::String *a2, const TITokenID *a3)
{
  uint64_t v6;
  _QWORD *v7;

  if ((*(unsigned int (**)(KB::LanguageModelContainer *))(*(_QWORD *)this + 16))(this))
  {
    v6 = KB::LanguageModelContainer::index_for_lexicon_id(this, a3->lexicon_id);
    if (v6 != -1)
    {
      v7 = (_QWORD *)(*((_QWORD *)this + 3) + 56 * v6);
      return (*(uint64_t (**)(_QWORD, const KB::String *, const TITokenID *))(*(_QWORD *)*v7 + 384))(*v7, a2, a3);
    }
    if (a3->word_id <= 0x1F3)
    {
      v7 = (_QWORD *)*((_QWORD *)this + 3);
      if (v7 != *((_QWORD **)this + 4))
        return (*(uint64_t (**)(_QWORD, const KB::String *, const TITokenID *))(*(_QWORD *)*v7 + 384))(*v7, a2, a3);
    }
  }
  return 0;
}

void KB::LanguageModelContainer::marginal_likelihood(KB::LanguageModelContainer *this, const KB::String *a2, const TITokenID *a3)
{
  unsigned int lexicon_id;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  lexicon_id = a3->lexicon_id;
  v7 = KB::LanguageModelContainer::index_for_lexicon_id(this, a3->lexicon_id);
  if (v7 != -1)
  {
    v8 = 56 * v7;
    KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((_QWORD *)this + 3) + 56 * v7), lexicon_id);
    v9 = (_QWORD *)(*((_QWORD *)this + 3) + v8);
LABEL_3:
    (*(float (**)(_QWORD, const KB::String *, const TITokenID *))(*(_QWORD *)*v9 + 392))(*v9, a2, a3);
    return;
  }
  if (a3->word_id <= 0x1F3)
  {
    v9 = (_QWORD *)*((_QWORD *)this + 3);
    if (v9 != *((_QWORD **)this + 4))
      goto LABEL_3;
  }
}

void KB::LanguageModelContainer::conditional_likelihood(KB::LanguageModelContainer *this@<X0>, const KB::String *a2@<X1>, const TITokenID *a3@<X2>, const KB::LanguageModelContext *a4@<X3>, float a5@<S0>, __CFString *a6@<X4>, float32x2_t *a7@<X8>)
{
  uint64_t lexicon_id;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  uint64_t *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::string *v26;
  void *v27;
  float v28;
  float32x2_t v29;
  int v30;
  std::string v31;
  uint64_t v32;
  int v33;
  std::string __p;

  v32 = KB::k_invalid_likelihood_value;
  v33 = dword_1F0280D10;
  if (byte_1F0280D18[23] < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)byte_1F0280D18, *(std::string::size_type *)&byte_1F0280D18[8]);
  else
    __p = *(std::string *)byte_1F0280D18;
  lexicon_id = a3->lexicon_id;
  v15 = KB::LanguageModelContainer::index_for_lexicon_id(this, a3->lexicon_id);
  if (v15 != -1)
  {
    v16 = v15;
    LODWORD(v28) = COERCE_UNSIGNED_INT64((*(double (**)(KB::LanguageModelContainer *, uint64_t, const KB::LanguageModelContext *))(*(_QWORD *)this + 432))(this, lexicon_id, a4));
    v17 = *(_QWORD *)(*((_QWORD *)this + 3) + 56 * v16);
    (*(void (**)(float32x2_t *__return_ptr, uint64_t, const KB::String *, const TITokenID *, const KB::LanguageModelContext *, __CFString *, float))(*(_QWORD *)v17 + 400))(&v29, v17, a2, a3, a4, a6, a5);
    v32 = (uint64_t)v29;
    v33 = v30;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v31;
    goto LABEL_8;
  }
  v18 = 0.0;
  if (a3->word_id <= 0x1F3 && *((_QWORD *)this + 3) != *((_QWORD *)this + 4))
  {
    LODWORD(v28) = COERCE_UNSIGNED_INT64((*(double (**)(KB::LanguageModelContainer *, _QWORD, const KB::LanguageModelContext *))(*(_QWORD *)this + 432))(this, 0, a4));
    v19 = (uint64_t *)*((_QWORD *)this + 3);
    v20 = *v19;
    v21 = (std::__shared_weak_count *)v19[1];
    if (v21)
    {
      p_shared_owners = (unint64_t *)&v21->__shared_owners_;
      do
        v23 = __ldxr(p_shared_owners);
      while (__stxr(v23 + 1, p_shared_owners));
    }
    (*(void (**)(float32x2_t *__return_ptr, uint64_t, const KB::String *, const TITokenID *, const KB::LanguageModelContext *, __CFString *, float))(*(_QWORD *)v20 + 400))(&v29, v20, a2, a3, a4, a6, a5);
    v32 = (uint64_t)v29;
    v33 = v30;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    __p = v31;
    *((_BYTE *)&v31.__r_.__value_.__s + 23) = 0;
    v31.__r_.__value_.__s.__data_[0] = 0;
    v18 = v28;
    if (v21)
    {
      v24 = (unint64_t *)&v21->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
LABEL_8:
        v18 = v28;
      }
    }
  }
  *a7 = vmul_n_f32((float32x2_t)v32, v18);
  a7[1].i32[0] = v33;
  v26 = (std::string *)&a7[2];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    v27 = (void *)__p.__r_.__value_.__r.__words[0];
    std::string::__init_copy_ctor_external(v26, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    operator delete(v27);
  }
  else
  {
    *(_OWORD *)&v26->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    a7[4] = (float32x2_t)__p.__r_.__value_.__r.__words[2];
  }
}

void KB::LanguageModelContainer::conditional_likelihood_batched(KB::LanguageModelContainer *a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, char a6@<W5>, _QWORD *a7@<X8>)
{
  uint64_t *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t v14;
  unsigned int *v16;
  unsigned int *v17;
  _QWORD *v18;
  unint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  uint64_t v27;
  KB::LanguageModelLexiconGroup *v28;
  _QWORD *v29;
  unsigned int *v30;
  unsigned int *v31;
  unint64_t v32;
  unsigned int *v33;
  unint64_t v34;
  BOOL *v35;
  uint64_t v36;
  int v37;
  KB::LanguageModelLexiconGroup *v38;
  int v39;
  uint64_t *v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  int v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  const KB::LanguageModelContext *v63;
  void **v64;
  const KB::LanguageModelContext *v65;
  unint64_t v66;
  void **v67;
  NSObject *v68;
  std::__shared_weak_count *v69;
  std::__shared_weak_count *v70;
  std::__shared_weak_count *v71;
  unint64_t *p_shared_weak_owners;
  unint64_t v73;
  unint64_t *v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t *v77;
  void *v78;
  unint64_t v79;
  void ***v80;
  KB::LanguageModelLexiconGroup *v82;
  void *v83;
  NSObject *v85;
  _BYTE v86[24];
  void *v87[8];
  void *__p[2];
  char v89;
  void **v90;
  const KB::LanguageModelContext *v91;
  void **v92;
  int v93;
  __int128 v94;
  unint64_t v95;
  char v96;
  uint64_t v97;
  void **v98;
  std::mutex v99;
  uint64_t v100;

  v100 = *MEMORY[0x1E0C80C00];
  v97 = a5;
  v96 = a6;
  v9 = (uint64_t *)*((_QWORD *)a1 + 3);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)a1 + 4) - (_QWORD)v9) >> 3)) <= 1)
  {
    v10 = *v9;
    v11 = (std::__shared_weak_count *)v9[1];
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
      (*(void (**)(uint64_t, unsigned int **, uint64_t *))(*(_QWORD *)v10 + 408))(v10, a2, a3);
      do
        v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    else
    {
      (*(void (**)(uint64_t, unsigned int **, uint64_t *))(*(_QWORD *)v10 + 408))(v10, a2, a3);
    }
    return;
  }
  *a7 = 0;
  a7[1] = 0;
  a7[2] = 0;
  v16 = *a2;
  v17 = a2[1];
  if (*a2 != v17)
  {
    do
    {
      std::vector<KB::LikelihoodInfo>::vector(&v94, *v16, (uint64_t)&KB::k_invalid_likelihood_value);
      v18 = (_QWORD *)a7[1];
      v19 = a7[2];
      if ((unint64_t)v18 >= v19)
      {
        v21 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v18 - *a7) >> 3);
        v22 = v21 + 1;
        if (v21 + 1 > 0xAAAAAAAAAAAAAAALL)
          goto LABEL_100;
        v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - *a7) >> 3);
        if (2 * v23 > v22)
          v22 = 2 * v23;
        if (v23 >= 0x555555555555555)
          v24 = 0xAAAAAAAAAAAAAAALL;
        else
          v24 = v22;
        *(_QWORD *)&v99.__m_.__opaque[24] = a7 + 2;
        v25 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v24);
        v26 = &v25[24 * v21];
        v99.__m_.__sig = (uint64_t)v25;
        *(_QWORD *)v99.__m_.__opaque = v26;
        *(_QWORD *)&v99.__m_.__opaque[16] = &v25[24 * v27];
        *((_QWORD *)v26 + 1) = 0;
        *((_QWORD *)v26 + 2) = 0;
        *(_QWORD *)v26 = 0;
        *(_OWORD *)v26 = v94;
        *((_QWORD *)v26 + 2) = v95;
        v94 = 0uLL;
        v95 = 0;
        *(_QWORD *)&v99.__m_.__opaque[8] = v26 + 24;
        std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(a7, &v99);
        v20 = (_QWORD *)a7[1];
        std::__split_buffer<std::vector<KB::LikelihoodInfo>>::~__split_buffer((uint64_t)&v99);
      }
      else
      {
        *v18 = 0;
        v18[1] = 0;
        v18[2] = 0;
        *(_OWORD *)v18 = v94;
        v18[2] = v95;
        v94 = 0uLL;
        v95 = 0;
        v20 = v18 + 3;
      }
      a7[1] = v20;
      v99.__m_.__sig = (uint64_t)&v94;
      std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&v99);
      v16 += 250;
    }
    while (v16 != v17);
  }
  v93 = (*(uint64_t (**)(KB::LanguageModelContainer *, uint64_t *))(*(_QWORD *)a1 + 416))(a1, a4);
  v94 = 0uLL;
  v95 = 0;
  v28 = (KB::LanguageModelLexiconGroup *)*((_QWORD *)a1 + 3);
  v82 = (KB::LanguageModelLexiconGroup *)*((_QWORD *)a1 + 4);
  v83 = a7;
  if (v28 == v82)
  {
    v90 = 0;
    v91 = 0;
    v92 = 0;
    goto LABEL_78;
  }
  v29 = 0;
  do
  {
    memset(&v99, 0, 24);
    std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__init_with_size[abi:nn180100]<std::vector<language_modeling::v1::TokenMetadata>*,std::vector<language_modeling::v1::TokenMetadata>*>(&v99, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
    v31 = *a2;
    v30 = a2[1];
    if (v30 == *a2)
      goto LABEL_46;
    v32 = 0;
    do
    {
      v33 = &v31[250 * v32];
      if (!*(_QWORD *)v33)
        goto LABEL_44;
      v34 = 0;
      do
      {
        v35 = (BOOL *)(*(_QWORD *)(v99.__m_.__sig + 24 * v32) + 2 * v34);
        v36 = *((_QWORD *)v33 + 1);
        if (v96 && (*(_BYTE *)(v36 + 240 * v34 + 106) & 2) != 0)
        {
          v39 = v93;
          v38 = v28;
          goto LABEL_31;
        }
        v37 = *(_DWORD *)(v36 + 240 * v34 + 136);
        if (KB::LanguageModelContainer::index_for_lexicon_id(a1, v37) != -1)
        {
          v38 = v28;
          v39 = v37;
LABEL_31:
          *v35 = KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v38, v39);
          goto LABEL_32;
        }
        if (*(_DWORD *)(*((_QWORD *)v33 + 1) + 240 * v34 + 140) > 0x1F3u)
        {
          *v35 = 0;
        }
        else
        {
          v40 = (uint64_t *)*((_QWORD *)a1 + 3);
          v41 = *v40;
          v42 = (std::__shared_weak_count *)v40[1];
          if (v42)
          {
            v43 = (unint64_t *)&v42->__shared_owners_;
            do
              v44 = __ldxr(v43);
            while (__stxr(v44 + 1, v43));
          }
          v45 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v41 + 40))(v41);
          *v35 = KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v28, v45);
          if (v42)
          {
            v46 = (unint64_t *)&v42->__shared_owners_;
            do
              v47 = __ldaxr(v46);
            while (__stlxr(v47 - 1, v46));
            if (!v47)
            {
              ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
              std::__shared_weak_count::__release_weak(v42);
            }
          }
        }
LABEL_32:
        ++v34;
      }
      while (v34 < *(_QWORD *)v33);
      v31 = *a2;
      v30 = a2[1];
LABEL_44:
      ++v32;
    }
    while (v32 < 0x1CAC083126E978D5 * (((char *)v30 - (char *)v31) >> 3));
    v29 = (_QWORD *)*((_QWORD *)&v94 + 1);
LABEL_46:
    if ((unint64_t)v29 < v95)
    {
      *v29 = 0;
      v29[1] = 0;
      v29[2] = 0;
      std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__init_with_size[abi:nn180100]<std::vector<language_modeling::v1::TokenMetadata>*,std::vector<language_modeling::v1::TokenMetadata>*>(v29, v99.__m_.__sig, *(uint64_t *)v99.__m_.__opaque, 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)v99.__m_.__opaque - v99.__m_.__sig) >> 3));
      v29 += 3;
      goto LABEL_64;
    }
    v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v29 - v94) >> 3);
    v49 = v48 + 1;
    if (v48 + 1 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_100;
    if (0x5555555555555556 * ((uint64_t)(v95 - v94) >> 3) > v49)
      v49 = 0x5555555555555556 * ((uint64_t)(v95 - v94) >> 3);
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v95 - v94) >> 3) >= 0x555555555555555)
      v50 = 0xAAAAAAAAAAAAAAALL;
    else
      v50 = v49;
    if (v50)
      v50 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v50);
    else
      v51 = 0;
    v52 = (_QWORD *)(v50 + 24 * v48);
    v53 = v50 + 24 * v51;
    *v52 = 0;
    v52[1] = 0;
    v52[2] = 0;
    std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__init_with_size[abi:nn180100]<std::vector<language_modeling::v1::TokenMetadata>*,std::vector<language_modeling::v1::TokenMetadata>*>(v52, v99.__m_.__sig, *(uint64_t *)v99.__m_.__opaque, 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)v99.__m_.__opaque - v99.__m_.__sig) >> 3));
    v29 = v52 + 3;
    v55 = *((_QWORD *)&v94 + 1);
    v54 = v94;
    if (*((_QWORD *)&v94 + 1) == (_QWORD)v94)
    {
      *(_QWORD *)&v94 = v52;
      *((_QWORD *)&v94 + 1) = v52 + 3;
      v95 = v53;
      if (v55)
        goto LABEL_63;
    }
    else
    {
      do
      {
        *(v52 - 3) = 0;
        *(v52 - 2) = 0;
        v52 -= 3;
        v52[2] = 0;
        v56 = *(_OWORD *)(v55 - 24);
        v55 -= 24;
        *(_OWORD *)v52 = v56;
        v52[2] = *(_QWORD *)(v55 + 16);
        *(_QWORD *)v55 = 0;
        *(_QWORD *)(v55 + 8) = 0;
        *(_QWORD *)(v55 + 16) = 0;
      }
      while (v55 != v54);
      v55 = *((_QWORD *)&v94 + 1);
      v57 = v94;
      *(_QWORD *)&v94 = v52;
      *((_QWORD *)&v94 + 1) = v29;
      v95 = v53;
      if (v55 != v57)
      {
        do
        {
          v55 -= 24;
          v90 = (void **)v55;
          std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100](&v90);
        }
        while (v55 != v57);
        v55 = v57;
      }
      if (v55)
LABEL_63:
        operator delete((void *)v55);
    }
LABEL_64:
    *((_QWORD *)&v94 + 1) = v29;
    v90 = (void **)&v99;
    std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100](&v90);
    v28 = (KB::LanguageModelLexiconGroup *)((char *)v28 + 56);
  }
  while (v28 != v82);
  v59 = *((_QWORD *)a1 + 3);
  v58 = *((_QWORD *)a1 + 4);
  v90 = 0;
  v91 = 0;
  v92 = 0;
  v60 = v58 - v59;
  if (!v60)
    goto LABEL_78;
  v61 = 0x6DB6DB6DB6DB6DB7 * (v60 >> 3);
  if (v61 >= 0x276276276276277)
LABEL_100:
    abort();
  v90 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelContext>>(v61);
  v91 = (const KB::LanguageModelContext *)v90;
  v92 = &v90[13 * v62];
  v63 = (const KB::LanguageModelContext *)&v90[13 * v61];
  v64 = v90 + 8;
  do
  {
    v64[4] = 0;
    *(_OWORD *)v64 = 0u;
    *((_OWORD *)v64 + 1) = 0u;
    *((_OWORD *)v64 - 2) = 0u;
    *((_OWORD *)v64 - 1) = 0u;
    *((_OWORD *)v64 - 4) = 0u;
    *((_OWORD *)v64 - 3) = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)v64);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)(v64 + 1));
    v64[2] = 0;
    v64[3] = 0;
    v64[4] = 0;
    v65 = (const KB::LanguageModelContext *)(v64 + 5);
    v64 += 13;
  }
  while (v65 != v63);
  v91 = v63;
  if (*((_QWORD *)a1 + 4) != *((_QWORD *)a1 + 3))
  {
    v66 = 0;
    v67 = v90;
    do
    {
      ++v66;
      v67 = (void **)(KB::LanguageModelContext::operator=((uint64_t)v67, a4) + 104);
    }
    while (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)a1 + 4) - *((_QWORD *)a1 + 3)) >> 3) > v66);
  }
LABEL_78:
  memset(v99.__m_.__opaque, 0, sizeof(v99.__m_.__opaque));
  v99.__m_.__sig = 850045863;
  v68 = dispatch_group_create();
  v69 = (std::__shared_weak_count *)*((_QWORD *)a1 + 2);
  if (v69)
  {
    v70 = std::__shared_weak_count::lock(v69);
    v71 = v70;
    if (v70)
    {
      p_shared_weak_owners = (unint64_t *)&v70->__shared_weak_owners_;
      do
        v73 = __ldxr(p_shared_weak_owners);
      while (__stxr(v73 + 1, p_shared_weak_owners));
      v74 = (unint64_t *)&v70->__shared_owners_;
      do
        v75 = __ldaxr(v74);
      while (__stlxr(v75 - 1, v74));
      if (!v75)
      {
        ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
        std::__shared_weak_count::__release_weak(v71);
      }
    }
  }
  else
  {
    v71 = 0;
  }
  if (*((_QWORD *)a1 + 4) != *((_QWORD *)a1 + 3))
  {
    v76 = 0;
    v77 = (unint64_t *)&v71->__shared_weak_owners_;
    do
    {
      dispatch_group_enter(v68);
      KB::LanguageModelLexiconGroup::lexicon_group_identifier((KB::LanguageModelLexiconGroup *)(*((_QWORD *)a1 + 3) + 56 * v76), (uint64_t)__p);
      KB::LanguageModelContainer::get_autocorrection_queue((uint64_t)a1, (uint64_t)__p);
      v78 = (void *)objc_claimAutoreleasedReturnValue();
      if (v71)
      {
        do
          v79 = __ldxr(v77);
        while (__stxr(v79 + 1, v77));
      }
      memset(v86, 0, sizeof(v86));
      std::vector<KB::LanguageModelContext>::__init_with_size[abi:nn180100]<KB::LanguageModelContext*,KB::LanguageModelContext*>((KB::LanguageModelContext *)v86, (const KB::LanguageModelContext *)v90, v91, 0x4EC4EC4EC4EC4EC5 * ((v91 - (const KB::LanguageModelContext *)v90) >> 3));
      memset(v87, 0, 24);
      std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__init_with_size[abi:nn180100]<std::vector<std::vector<language_modeling::v1::TokenMetadata>>*,std::vector<std::vector<language_modeling::v1::TokenMetadata>>*>(v87, (uint64_t *)v94, *((uint64_t **)&v94 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)&v94 + 1) - v94) >> 3));
      v87[3] = a2;
      v87[4] = &v96;
      v87[5] = v83;
      v87[6] = &v99;
      v87[7] = a1;
      v85 = v68;
      TIDispatchAsync();

      if (v89 < 0)
        operator delete(__p[0]);

      v98 = v87;
      std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__destroy_vector::operator()[abi:nn180100](&v98);
      v98 = (void **)v86;
      std::vector<KB::LanguageModelContext>::__destroy_vector::operator()[abi:nn180100](&v98);
      if (v71)
        std::__shared_weak_count::__release_weak(v71);
      ++v76;
    }
    while (v76 < 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)a1 + 4) - *((_QWORD *)a1 + 3)) >> 3));
  }
  dispatch_group_wait(v68, 0xFFFFFFFFFFFFFFFFLL);
  if (v71)
    std::__shared_weak_count::__release_weak(v71);

  std::mutex::~mutex(&v99);
  v99.__m_.__sig = (uint64_t)&v90;
  std::vector<KB::LanguageModelContext>::__destroy_vector::operator()[abi:nn180100](v80);
  v99.__m_.__sig = (uint64_t)&v94;
  std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v99);
}

uint64_t KB::LanguageModelContainer::most_probable_lexicon_for_context(KB::LanguageModelContainer *this, const KB::LanguageModelContext *a2)
{
  int v3;

  v3 = 0;
  return (*(uint64_t (**)(KB::LanguageModelContainer *, const KB::LanguageModelContext *, int *))(*(_QWORD *)this + 424))(this, a2, &v3);
}

uint64_t KB::LanguageModelContainer::most_probable_lexicon_for_context(KB::LanguageModelContainer *this, const KB::LanguageModelContext *a2, float *a3)
{
  uint64_t v4;
  unint64_t v7;
  uint64_t v8;
  float v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int *v12;
  float v13;
  unsigned int *v15;
  unsigned int *v16;

  v4 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 4) == v4)
  {
    v8 = 0;
    v9 = 0.0;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    v9 = -3.4028e38;
    do
    {
      v10 = *(_QWORD *)(v4 + 56 * v7);
      if (v10)
      {
        (*(void (**)(unsigned int **__return_ptr))(*(_QWORD *)v10 + 48))(&v15);
        v11 = v15;
        v12 = v16;
        if (v15 != v16)
        {
          do
          {
            v13 = (*(float (**)(KB::LanguageModelContainer *, _QWORD, const KB::LanguageModelContext *))(*(_QWORD *)this + 432))(this, *v11, a2);
            if (v13 > v9)
            {
              v8 = *v11;
              v9 = v13;
            }
            ++v11;
          }
          while (v11 != v12);
          v11 = v15;
        }
        if (v11)
        {
          v16 = v11;
          operator delete(v11);
        }
      }
      ++v7;
      v4 = *((_QWORD *)this + 3);
    }
    while (v7 < 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 4) - v4) >> 3));
  }
  *a3 = v9;
  return v8;
}

float KB::LanguageModelContainer::probability_of_lexicon_given_context(KB::LanguageModelContainer *this, unsigned int a2, const KB::LanguageModelContext *a3)
{
  uint64_t v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  _QWORD *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  _QWORD v26[10];
  int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  float *v38;
  uint64_t v39;
  int v40;

  v6 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 4) - v6 != 56 || (v7 = 1.0, *(_DWORD *)(v6 + 40) != 1))
  {
    v8 = KB::LanguageModelContainer::index_for_lexicon_id(this, a2);
    if (v8 == -1)
    {
      if (a2)
        return 0.0;
      else
        return 0.04;
    }
    else
    {
      v9 = v8;
      v37 = 0;
      v38 = (float *)&v37;
      v39 = 0x2020000000;
      v40 = 0;
      v33 = 0;
      v34 = (float *)&v33;
      v35 = 0x2020000000;
      v36 = 0;
      v29 = 0;
      v30 = &v29;
      v31 = 0x2020000000;
      v32 = 0;
      v26[0] = MEMORY[0x1E0C809B0];
      v26[1] = 3221225472;
      v26[2] = ___ZNK2KB22LanguageModelContainer36probability_of_lexicon_given_contextEjRKNS_20LanguageModelContextE_block_invoke;
      v26[3] = &unk_1EA0FD598;
      v26[4] = &v29;
      v26[5] = &v37;
      v27 = 1059648963;
      v28 = a2;
      v26[6] = &v33;
      v26[7] = this;
      v26[8] = v8;
      v26[9] = 4;
      v10 = v26;
      if (!enumerate_context_backwards((uint64_t)a3, (uint64_t)v10))
      {
        v11 = *(uint64_t **)a3;
        v12 = (std::__shared_weak_count *)*((_QWORD *)a3 + 1);
        if (v12)
        {
          p_shared_owners = (unint64_t *)&v12->__shared_owners_;
          do
            v14 = __ldxr(p_shared_owners);
          while (__stxr(v14 + 1, p_shared_owners));
        }
        if (v11)
        {
          v15 = *v11;
          v16 = v11[1];
          while (v15 != v16 && !enumerate_context_backwards(v15, (uint64_t)v10))
            v15 += 104;
        }
        if (v12)
        {
          v17 = (unint64_t *)&v12->__shared_owners_;
          do
            v18 = __ldaxr(v17);
          while (__stlxr(v18 - 1, v17));
          if (!v18)
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
        }
      }

      v19 = v30 + 3;
      if (v30[3])
      {
        v20 = v34[6];
      }
      else
      {
        do
        {
          *v19 = 1;
          v38[6] = v38[6] + 1.0;
          v21 = KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((_QWORD *)this + 3) + 56 * v9), a2);
          v20 = v21 + v34[6];
          v34[6] = v20;
          v19 = v30 + 3;
        }
        while (!v30[3]);
      }
      v22 = v38[6];
      if (v22 <= 0.0)
        v22 = 1.0;
      v23 = v20 / v22;
      v24 = (float)(KB::LanguageModelContainer::lexicon_stationary_probability(this, a2) * (float)(v20 / v22)) + 0.0;
      v7 = v24
         + (float)((float)(KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((_QWORD *)this + 3) + 56 * v9), a2)* 0.04)* (float)(1.0 - v23));
      _Block_object_dispose(&v29, 8);
      _Block_object_dispose(&v33, 8);
      _Block_object_dispose(&v37, 8);
    }
  }
  return v7;
}

void KB::LanguageModelContainer::predictions(KB::LanguageModelContainer *a1, const KB::LanguageModelContext *a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  std::vector<std::string> *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  std::vector<std::string> *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  void **v23;
  std::__shared_weak_count *v24;
  void *__p;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  std::vector<std::string> *v31;
  uint64_t v32;
  void **v33;
  _BYTE v34[24];
  _BYTE *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v30 = 0;
  v31 = 0;
  v32 = 0;
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v23, a2);
  KB::LanguageModelContainer::update_context_with_predominant_locale(a1, (KB::LanguageModelContext *)&v23);
  v7 = (uint64_t *)*((_QWORD *)a1 + 3);
  v8 = (uint64_t *)*((_QWORD *)a1 + 4);
  if (v7 != v8)
  {
    while (1)
    {
      v9 = *v7;
      v10 = operator new(0x20uLL);
      *v10 = &off_1EA0FD6A8;
      v10[1] = &v30;
      v10[2] = a1;
      v10[3] = &v23;
      v35 = v10;
      (*(void (**)(uint64_t, void ***, uint64_t, _BYTE *))(*(_QWORD *)v9 + 440))(v9, &v23, a3, v34);
      v11 = v35;
      if (v35 == v34)
        break;
      if (v35)
      {
        v12 = 5;
LABEL_6:
        (*(void (**)(void))(*v11 + 8 * v12))();
      }
      v7 += 7;
      if (v7 == v8)
      {
        v13 = v30;
        v14 = v31;
        goto LABEL_10;
      }
    }
    v11 = v34;
    v12 = 4;
    goto LABEL_6;
  }
  v14 = 0;
  v13 = 0;
LABEL_10:
  v15 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v14 - v13) >> 5));
  if (v14 == (std::vector<std::string> *)v13)
    v16 = 0;
  else
    v16 = v15;
  std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*,false>(v13, v14, v16, 1);
  v17 = v30;
  v18 = v31;
  while ((std::vector<std::string> *)v17 != v18)
  {
    v19 = *(_QWORD *)(a4 + 24);
    if (!v19)
      std::__throw_bad_function_call[abi:nn180100]();
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v19 + 48))(v19, v17);
    v17 += 160;
  }
  v33 = (void **)&v29;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v33);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v28);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v27);
  if (__p)
  {
    v26 = __p;
    operator delete(__p);
  }
  v20 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  v23 = (void **)&v30;
  std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v23);
}

KB::LanguageModelContainer::PredictionEnumeratorContainer *KB::LanguageModelContainer::create_prediction_enumerator@<X0>(KB::LanguageModelContainer *this@<X0>, const KB::LanguageModelContext *a2@<X1>, unsigned int a3@<W2>, KB::LanguageModelContainer::PredictionEnumeratorContainer **a4@<X8>)
{
  _QWORD *v8;
  KB::LanguageModelContainer::PredictionEnumeratorContainer *result;

  v8 = operator new(0x70uLL);
  v8[1] = 0;
  v8[2] = 0;
  *v8 = &off_1EA0FD670;
  result = KB::LanguageModelContainer::PredictionEnumeratorContainer::PredictionEnumeratorContainer((KB::LanguageModelContainer::PredictionEnumeratorContainer *)(v8 + 3), this, a2, a3);
  *a4 = result;
  a4[1] = (KB::LanguageModelContainer::PredictionEnumeratorContainer *)v8;
  return result;
}

uint64_t KB::LanguageModelContainer::is_token_blocklisted(KB::LanguageModelContainer *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v10 = KB::LanguageModelContainer::index_for_lexicon_id(a1, a3);
  if (v10 == -1)
    return HIDWORD(a3) > 0x1F3;
  v11 = v10;
  v12 = *(_QWORD *)(*((_QWORD *)a1 + 3) + 56 * v10);
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12))
    return 1;
  v13 = *(_QWORD *)(*((_QWORD *)a1 + 3) + 56 * v11);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13 + 464))(v13, a2, a3, a4, a5);
}

uint64_t KB::LanguageModelContainer::is_text_blocklisted(KB::LanguageModelContainer *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v19[2];
  uint64_t (*v20)(uint64_t, _QWORD *);
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;

  if (!(_DWORD)a3)
    return 0;
  if ((_DWORD)a3 == -1)
  {
    v12 = (_QWORD *)*((_QWORD *)this + 3);
    v13 = (_QWORD *)*((_QWORD *)this + 4);
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 3221225472;
    v20 = ___ZNK2KB22LanguageModelContainer19is_text_blocklistedERKNS_6StringEjRKNS_20LanguageModelContextERKN3WTF6RefPtrINS_19DictionaryContainerEEE27TIBlocklistSensitivityLevel_block_invoke;
    v21 = &__block_descriptor_64_e10_B16__0r_v8l;
    v22 = a2;
    v23 = a4;
    v24 = a5;
    v25 = -1;
    v26 = a6;
    v14 = v19;
    if (v12 == v13)
    {
      v15 = 0;
    }
    else
    {
      do
      {
        v15 = v20((uint64_t)v14, v12);
        if ((v15 & 1) != 0)
          break;
        v12 += 7;
      }
      while (v12 != v13);
    }

  }
  else
  {
    v16 = KB::LanguageModelContainer::index_for_lexicon_id(this, a3);
    if (v16 != -1)
    {
      v17 = *(_QWORD *)(*((_QWORD *)this + 3) + 56 * v16);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v17 + 472))(v17, a2, a3, a4, a5, a6);
    }
    return 1;
  }
  return v15;
}

uint64_t KB::LanguageModelContainer::should_not_suggest_or_predict_text(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD v8[2];
  uint64_t (*v9)(uint64_t, _QWORD *);
  void *v10;
  uint64_t v11;
  uint64_t v12;

  v3 = *(_QWORD **)(a1 + 24);
  v4 = *(_QWORD **)(a1 + 32);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v9 = ___ZNK2KB22LanguageModelContainer34should_not_suggest_or_predict_textERKNS_6StringERKN3WTF6RefPtrINS_19DictionaryContainerEEE_block_invoke;
  v10 = &__block_descriptor_48_e10_B16__0r_v8l;
  v11 = a2;
  v12 = a3;
  v5 = v8;
  if (v3 == v4)
  {
    v6 = 0;
  }
  else
  {
    do
    {
      v6 = v9((uint64_t)v5, v3);
      if ((v6 & 1) != 0)
        break;
      v3 += 7;
    }
    while (v3 != v4);
  }

  return v6;
}

uint64_t KB::LanguageModelContainer::predictions(KB::LanguageModelContainer *a1, const KB::Candidate **a2, KB::LanguageModelContext *a3, uint64_t a4, char a5)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  char v14;
  _QWORD v15[3];
  _QWORD *v16;
  _BYTE v17[24];
  _BYTE *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v14 = a5;
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v17, a4);
  v15[0] = &off_1EA0FD6F0;
  v15[1] = a1;
  v15[2] = &v14;
  v16 = v15;
  v8 = KB::LanguageModelContainer::unified_predictions(a1, a2, a3, (uint64_t)v17, (uint64_t)v15);
  v9 = v16;
  if (v16 == v15)
  {
    v10 = 4;
    v9 = v15;
  }
  else
  {
    if (!v16)
      goto LABEL_6;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_6:
  v11 = v18;
  if (v18 == v17)
  {
    v12 = 4;
    v11 = v17;
    goto LABEL_10;
  }
  if (v18)
  {
    v12 = 5;
LABEL_10:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }
  return v8;
}

uint64_t KB::LanguageModelContainer::completions(KB::LanguageModelContainer *a1, const KB::Candidate **a2, KB::LanguageModelContext *a3, uint64_t a4, uint64_t a5, int a6)
{
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  int v15;
  _BYTE v16[24];
  _QWORD *v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v15 = a6;
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v18, a4);
  v10 = operator new(0x20uLL);
  *v10 = &off_1EA0FD738;
  v10[1] = a1;
  v10[2] = a5;
  v10[3] = &v15;
  v17 = v10;
  v11 = KB::LanguageModelContainer::unified_predictions(a1, a2, a3, (uint64_t)v18, (uint64_t)v16);
  (*(void (**)(_QWORD *))(*v10 + 40))(v10);
  v12 = v19;
  if (v19 == v18)
  {
    v13 = 4;
    v12 = v18;
    goto LABEL_5;
  }
  if (v19)
  {
    v13 = 5;
LABEL_5:
    (*(void (**)(void))(*v12 + 8 * v13))();
  }
  return v11;
}

void KB::LanguageModelContainer::inline_completions_with_stems(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _BYTE *a6@<X8>)
{
  int v12;
  KB::LanguageModelLexiconGroup *v13;
  KB::LanguageModelLexiconGroup *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  float v20;
  uint8_t *v21;
  uint8_t buf[24];
  double v23;
  _BYTE v24[24];
  _BYTE *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v20 = 0.0;
  v12 = (*(uint64_t (**)(_QWORD *, uint64_t, float *))(*a1 + 424))(a1, a3, &v20);
  v13 = (KB::LanguageModelLexiconGroup *)a1[3];
  v14 = (KB::LanguageModelLexiconGroup *)a1[4];
  while (1)
  {
    if (v13 == v14)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        v19 = TILocaleIdentifierForLexiconID(v12);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "inline_completions_with_stems";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v19;
        *(_WORD *)&buf[22] = 2048;
        v23 = v20;
        _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  Inline completion not supported on detected language  (language : %s confidence = %f)", buf, 0x20u);
      }
      memset(buf, 0, sizeof(buf));
      v15 = *(_QWORD *)(a5 + 24);
      if (v15)
      {
        (*(void (**)(uint64_t, uint8_t *, _QWORD, uint64_t))(*(_QWORD *)v15 + 48))(v15, buf, *a2, a3);
        *a6 = 0;
        a6[24] = 0;
        v21 = buf;
        std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&v21);
      }
      else
      {
        std::__throw_bad_function_call[abi:nn180100]();
        KB::LanguageModelContainer::register_inline_completion_acceptance_rejection();
      }
      return;
    }
    if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)v13 + 144))(*(_QWORD *)v13)
      && KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v13, v12))
    {
      break;
    }
    v13 = (KB::LanguageModelLexiconGroup *)((char *)v13 + 56);
  }
  v16 = *(_QWORD *)v13;
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v24, a5);
  (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v16 + 512))(v16, a2, a3, a4, v24);
  v17 = v25;
  if (v25 == v24)
  {
    v18 = 4;
    v17 = v24;
  }
  else
  {
    if (!v25)
      return;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
}

void KB::LanguageModelContainer::register_inline_completion_acceptance_rejection(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t v6;

  v1 = *(uint64_t **)(a1 + 24);
  v2 = *v1;
  v3 = (std::__shared_weak_count *)v1[1];
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 520))(v2);
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  else
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 520))(v2);
  }
}

void KB::LanguageModelContainer::tokenize_text(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  uint64_t *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  id v13;
  id v14;

  v5 = a3;
  v6 = *(uint64_t **)(a1 + 24);
  if (v6 != *(uint64_t **)(a1 + 32))
  {
    v7 = *v6;
    v8 = (std::__shared_weak_count *)v6[1];
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
    }
    if (v7)
    {
      v13 = v5;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 528))(v7, a2);
      v5 = v13;
    }
    if (v8)
    {
      v11 = (unint64_t *)&v8->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        v14 = v5;
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
        v5 = v14;
      }
    }
  }

}

void KB::LanguageModelContainer::set_string_converter(uint64_t a1, void *a2)
{
  id v3;
  uint64_t *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  id v11;
  id v12;

  v3 = a2;
  v4 = *(uint64_t **)(a1 + 24);
  if (v4 != *(uint64_t **)(a1 + 32))
  {
    v5 = *v4;
    v6 = (std::__shared_weak_count *)v4[1];
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    if (v5)
    {
      v11 = v3;
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 536))(v5);
      v3 = v11;
    }
    if (v6)
    {
      v9 = (unint64_t *)&v6->__shared_owners_;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        v12 = v3;
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
        v3 = v12;
      }
    }
  }

}

void KB::LanguageModelContainer::engine_string_to_surface_form(KB::LanguageModelContainer *this@<X0>, CFTypeRef cf@<X1>, _QWORD *a3@<X8>)
{
  uint64_t *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  v5 = (uint64_t *)*((_QWORD *)this + 3);
  if (v5 == *((uint64_t **)this + 4))
  {
    v7 = 0;
  }
  else
  {
    v6 = *v5;
    v7 = (std::__shared_weak_count *)v5[1];
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
    if (v6)
    {
      (*(void (**)(uint64_t, CFTypeRef))(*(_QWORD *)v6 + 544))(v6, cf);
      goto LABEL_10;
    }
  }
  *a3 = cf;
  if (cf)
  {
    CFRetain(cf);
    *a3 = cf;
  }
LABEL_10:
  if (v7)
  {
    v10 = (unint64_t *)&v7->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

uint64_t KB::LanguageModelContainer::do_store(uint64_t this, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *i;
  uint64_t v5;

  v2 = *(uint64_t **)(this + 24);
  for (i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 568))(v5, a2))
  {
    v5 = *v2;
    v2 += 7;
  }
  return this;
}

BOOL KB::LanguageModelLexiconGroup::model_contains_lexicon_id(KB::LanguageModelLexiconGroup *this, int a2)
{
  uint64_t v2;
  _DWORD *v4;
  _DWORD *v5;
  _DWORD *v7;
  _DWORD *v8;

  v2 = *(_QWORD *)this;
  if (v2)
  {
    (*(void (**)(_DWORD **__return_ptr))(*(_QWORD *)v2 + 48))(&v7);
    v4 = v8;
    v5 = v7;
    if (v7 != v8)
    {
      v5 = v7;
      while (*v5 != a2)
      {
        if (++v5 == v8)
        {
          v5 = v8;
          break;
        }
      }
    }
    if (v7)
    {
      v8 = v7;
      operator delete(v7);
    }
  }
  else
  {
    v5 = 0;
    v4 = 0;
  }
  return v5 != v4;
}

uint64_t KB::LanguageModelContainer::unified_predictions(KB::LanguageModelContainer *a1, const KB::Candidate **a2, KB::LanguageModelContext *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  char v14;
  void **v15;
  _QWORD *v16;
  uint64_t v17;
  char v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BOOL8 v29;
  _QWORD *v30;
  uint64_t v31;
  char v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *p_shared_owners;
  unint64_t v38;
  void *__p[3];
  void *v42;
  void *v43;
  uint64_t v44;
  void **v45;
  void **v46;
  uint64_t v47;
  void *v48;
  void *v49;
  uint64_t v50;
  void **v51;
  void **v52;
  uint64_t v53;
  _BYTE v54[8];
  std::__shared_weak_count *v55;
  void *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void ***v61;
  _QWORD v62[3];
  _QWORD *v63;
  _QWORD v64[3];
  _QWORD *v65;
  _QWORD v66[3];
  _QWORD *v67;
  _QWORD v68[3];
  _QWORD *v69;
  _QWORD v70[3];
  _QWORD *v71;
  _QWORD v72[3];
  _QWORD *v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v54, a3);
  KB::LanguageModelContainer::update_context_with_predominant_locale(a1, (KB::LanguageModelContext *)v54);
  if (((*(uint64_t (**)(KB::LanguageModelContainer *))(*(_QWORD *)a1 + 128))(a1) & 1) == 0)
  {
    v8 = *((_QWORD *)a1 + 3);
    v9 = *((_QWORD *)a1 + 4);
    goto LABEL_6;
  }
  v8 = *((_QWORD *)a1 + 3);
  v9 = *((_QWORD *)a1 + 4);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((v9 - v8) >> 3)) < 2)
  {
LABEL_6:
    if (v9 == v8)
    {
      v14 = 0;
      goto LABEL_61;
    }
    v13 = 0;
    v14 = 0;
    v15 = 0;
    while (!(*(unsigned int (**)(_QWORD))(**(_QWORD **)(v8 + v13) + 128))(*(_QWORD *)(v8 + v13)))
    {
      v62[0] = &off_1EA0FD780;
      v62[1] = a1;
      v62[2] = a4;
      v63 = v62;
      v51 = v15;
      v21 = *(_QWORD *)(a5 + 24);
      if (!v21)
        goto LABEL_69;
      v18 = (*(uint64_t (**)(uint64_t, const KB::Candidate **, _BYTE *, _QWORD *, void ***))(*(_QWORD *)v21 + 48))(v21, a2, v54, v62, &v51);
      v22 = v63;
      if (v63 == v62)
      {
        v22 = v62;
        v23 = 4;
        goto LABEL_23;
      }
      if (v63)
      {
        v23 = 5;
LABEL_23:
        (*(void (**)(void))(*v22 + 8 * v23))();
      }
LABEL_24:
      v14 |= v18;
      v15 = (void **)((char *)v15 + 1);
      v8 = *((_QWORD *)a1 + 3);
      v13 += 56;
      if ((unint64_t)v15 >= 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)a1 + 4) - v8) >> 3))
        goto LABEL_61;
    }
    v51 = 0;
    v52 = 0;
    v53 = 0;
    v16 = (*(_QWORD *(**)(void **__return_ptr))(**(_QWORD **)(*((_QWORD *)a1 + 3) + v13) + 48))(__p);
    KB::LanguageModelContainer::remove_differing_lex_stems((uint64_t)v16, __p, a2, (uint64_t *)&v51);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v64[0] = &off_1EA0FD780;
    v64[1] = a1;
    v64[2] = a4;
    v65 = v64;
    v45 = v15;
    v17 = *(_QWORD *)(a5 + 24);
    if (!v17)
      goto LABEL_69;
    v18 = (*(uint64_t (**)(uint64_t, void ***, _BYTE *, _QWORD *, void ***))(*(_QWORD *)v17 + 48))(v17, &v51, v54, v64, &v45);
    v19 = v65;
    if (v65 == v64)
    {
      v19 = v64;
      v20 = 4;
    }
    else
    {
      if (!v65)
      {
LABEL_21:
        v45 = (void **)&v51;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v45);
        goto LABEL_24;
      }
      v20 = 5;
    }
    (*(void (**)(void))(*v19 + 8 * v20))();
    goto LABEL_21;
  }
  v10 = KB::LanguageModelContainer::most_probable_lexicon_for_context_and_stems(a1, (KB::LanguageModelContext *)v54, a2);
  v11 = KB::LanguageModelContainer::index_for_lexicon_id(a1, v10);
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v12 = *(_QWORD **)(*((_QWORD *)a1 + 3) + 56 * v11);
  if (v12)
  {
    v12 = (*(_QWORD *(**)(void **__return_ptr))(*v12 + 48))(&v48);
  }
  else
  {
    v48 = 0;
    v49 = 0;
    v50 = 0;
  }
  KB::LanguageModelContainer::remove_differing_lex_stems((uint64_t)v12, &v48, a2, (uint64_t *)&v51);
  if (v48)
  {
    v49 = v48;
    operator delete(v48);
  }
  if (v52 == v51)
  {
    v70[0] = &off_1EA0FD780;
    v70[1] = a1;
    v70[2] = a4;
    v71 = v70;
    v45 = (void **)v11;
    v27 = *(_QWORD *)(a5 + 24);
    if (!v27)
      goto LABEL_69;
    v14 = (*(uint64_t (**)(uint64_t, const KB::Candidate **, _BYTE *, _QWORD *, void ***))(*(_QWORD *)v27 + 48))(v27, a2, v54, v70, &v45);
    v25 = v71;
    if (v71 == v70)
    {
      v26 = 4;
      v25 = v70;
      goto LABEL_39;
    }
  }
  else
  {
    v72[0] = &off_1EA0FD780;
    v72[1] = a1;
    v72[2] = a4;
    v73 = v72;
    v45 = (void **)v11;
    v24 = *(_QWORD *)(a5 + 24);
    if (!v24)
      goto LABEL_69;
    v14 = (*(uint64_t (**)(uint64_t, void ***, _BYTE *, _QWORD *, void ***))(*(_QWORD *)v24 + 48))(v24, &v51, v54, v72, &v45);
    v25 = v73;
    if (v73 == v72)
    {
      v26 = 4;
      v25 = v72;
LABEL_39:
      (*(void (**)(void))(*v25 + 8 * v26))();
      goto LABEL_40;
    }
  }
  if (v25)
  {
    v26 = 5;
    goto LABEL_39;
  }
LABEL_40:
  if (v52 == v51 || (v14 & 1) == 0)
  {
    v28 = *((_QWORD *)a1 + 3);
    if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)a1 + 4) - v28) >> 3)) < 2)
      goto LABEL_60;
    v29 = v11 == 0;
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v30 = *(_QWORD **)(v28 + 56 * v29);
    if (v30)
    {
      v30 = (*(_QWORD *(**)(void **__return_ptr))(*v30 + 48))(&v42);
    }
    else
    {
      v42 = 0;
      v43 = 0;
      v44 = 0;
    }
    KB::LanguageModelContainer::remove_differing_lex_stems((uint64_t)v30, &v42, a2, (uint64_t *)&v45);
    if (v42)
    {
      v43 = v42;
      operator delete(v42);
    }
    if (v46 == v45)
    {
      v66[0] = &off_1EA0FD780;
      v66[1] = a1;
      v66[2] = a4;
      v67 = v66;
      v61 = (void ***)v29;
      v35 = *(_QWORD *)(a5 + 24);
      if (v35)
      {
        v32 = (*(uint64_t (**)(uint64_t, const KB::Candidate **, _BYTE *, _QWORD *, void ****))(*(_QWORD *)v35 + 48))(v35, a2, v54, v66, &v61);
        v33 = v67;
        if (v67 == v66)
        {
          v34 = 4;
          v33 = v66;
          goto LABEL_58;
        }
        goto LABEL_55;
      }
    }
    else
    {
      v68[0] = &off_1EA0FD780;
      v68[1] = a1;
      v68[2] = a4;
      v69 = v68;
      v61 = (void ***)v29;
      v31 = *(_QWORD *)(a5 + 24);
      if (v31)
      {
        v32 = (*(uint64_t (**)(uint64_t, void ***, _BYTE *, _QWORD *, void ****))(*(_QWORD *)v31 + 48))(v31, &v45, v54, v68, &v61);
        v33 = v69;
        if (v69 == v68)
        {
          v34 = 4;
          v33 = v68;
          goto LABEL_58;
        }
LABEL_55:
        if (!v33)
        {
LABEL_59:
          v14 |= v32;
          v61 = &v45;
          std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v61);
          goto LABEL_60;
        }
        v34 = 5;
LABEL_58:
        (*(void (**)(void))(*v33 + 8 * v34))();
        goto LABEL_59;
      }
    }
LABEL_69:
    std::__throw_bad_function_call[abi:nn180100]();
  }
  v14 = 1;
LABEL_60:
  v45 = (void **)&v51;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v45);
LABEL_61:
  v51 = (void **)&v60;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v51);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v59);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v58);
  if (v56)
  {
    v57 = v56;
    operator delete(v56);
  }
  v36 = v55;
  if (v55)
  {
    p_shared_owners = (unint64_t *)&v55->__shared_owners_;
    do
      v38 = __ldaxr(p_shared_owners);
    while (__stlxr(v38 - 1, p_shared_owners));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  return v14 & 1;
}

void KB::LanguageModelContainer::update_context_with_predominant_locale(KB::LanguageModelContainer *this, KB::LanguageModelContext *a2)
{
  int v3;
  char *v4;
  std::string __p;
  std::string v6;

  v3 = (*(uint64_t (**)(KB::LanguageModelContainer *))(*(_QWORD *)this + 416))(this);
  if (v3)
  {
    v4 = (char *)TILocaleIdentifierForLexiconID(v3);
    std::string::basic_string[abi:nn180100]<0>(&v6, v4);
    if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&__p, v6.__r_.__value_.__l.__data_, v6.__r_.__value_.__l.__size_);
    else
      __p = v6;
    KB::LanguageModelContext::set_predominant_locale((uint64_t)a2, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v6.__r_.__value_.__l.__data_);
  }
}

uint64_t KB::LanguageModelContainer::most_probable_lexicon_for_context_and_stems(_QWORD *a1, KB::LanguageModelContext *a2, const KB::Candidate **a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  void **v9;
  unsigned int *v10;
  const KB::Candidate *v11;
  const KB::Candidate *v12;
  float v13;
  uint64_t v14;
  float *v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  TITokenID v20;
  TITokenID v21;
  BOOL v22;
  unsigned int v23;
  uint8x8_t v24;
  unint64_t v25;
  uint64_t **v26;
  uint64_t *i;
  unint64_t v28;
  uint64_t v29;
  float *v30;
  float v31;
  float v32;
  float *v33;
  std::__shared_weak_count *v34;
  unint64_t *p_shared_owners;
  unint64_t v36;
  float *v37;
  float *v38;
  uint64_t v39;
  float v40;
  float v41;
  char v43[8];
  std::__shared_weak_count *v44;
  void *__p;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  int v52;
  unsigned int v53;
  char v54;
  void *v55;
  void **v56;
  void **v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v50 = 0u;
  v51 = 0u;
  v52 = 1065353216;
  v6 = a1[3];
  v7 = a1[4];
  while (v6 != v7)
  {
    if (*(_QWORD *)v6)
    {
      (*(void (**)(void ***__return_ptr))(**(_QWORD **)v6 + 48))(&v56);
      v8 = (unsigned int *)v56;
      v9 = v57;
      if (v56 != v57)
      {
        do
        {
          v10 = v8 + 1;
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&v50, *v8, v8)+ 5) = 0;
          v8 = v10;
        }
        while (v10 != (unsigned int *)v9);
        v8 = (unsigned int *)v56;
      }
      if (v8)
      {
        v57 = (void **)v8;
        operator delete(v8);
      }
    }
    v6 += 56;
  }
  v11 = *a3;
  v12 = a3[1];
  if (*a3 == v12)
  {
    v13 = 0.0;
  }
  else
  {
    v13 = 0.0;
    do
    {
      if (*(_QWORD *)v11)
      {
        v14 = 240 * *(_QWORD *)v11;
        v15 = (float *)(*((_QWORD *)v11 + 1) + 52);
        v16 = 1.0;
        do
        {
          v17 = *v15;
          v15 += 60;
          v16 = v16 * v17;
          v14 -= 240;
        }
        while (v14);
      }
      else
      {
        v16 = 1.0;
      }
      KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v43, a2);
      KB::Candidate::Candidate((KB::Candidate *)&v56, v11);
      if ((int)v56 >= 2)
      {
        v18 = 0;
        v19 = 17;
        do
        {
          v20 = (TITokenID)v57[v19];
          KB::Word::capitalized_string((KB::Word *)&v57[v19 - 17], (uint64_t)&v53);
          v21 = v20;
          KB::LanguageModelContext::append((KB::LanguageModelContext *)v43, v21, (const KB::String *)&v53, 0);
          if (v55)
            v22 = v54 == 1;
          else
            v22 = 0;
          if (v22)
            free(v55);
          ++v18;
          v19 += 30;
        }
        while (v18 < (int)v56 - 1);
      }
      v23 = (*(uint64_t (**)(_QWORD *, char *))(*a1 + 416))(a1, v43);
      v53 = v23;
      if (*((_QWORD *)&v50 + 1))
      {
        v24 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v50 + 8));
        v24.i16[0] = vaddlv_u8(v24);
        if (v24.u32[0] > 1uLL)
        {
          v25 = v23;
          if (*((_QWORD *)&v50 + 1) <= (unint64_t)v23)
            v25 = (unint64_t)v23 % *((_QWORD *)&v50 + 1);
        }
        else
        {
          v25 = (DWORD2(v50) - 1) & v23;
        }
        v26 = *(uint64_t ***)(v50 + 8 * v25);
        if (v26)
        {
          for (i = *v26; i; i = (uint64_t *)*i)
          {
            v28 = i[1];
            if (v28 == v23)
            {
              if (*((_DWORD *)i + 4) == v23)
              {
                if (*(_QWORD *)v11)
                {
                  v29 = 240 * *(_QWORD *)v11;
                  v30 = (float *)(*((_QWORD *)v11 + 1) + 52);
                  v31 = 1.0;
                  do
                  {
                    v32 = *v30;
                    v30 += 60;
                    v31 = v31 * v32;
                    v29 -= 240;
                  }
                  while (v29);
                }
                else
                {
                  v31 = 1.0;
                }
                v33 = (float *)std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&v50, v23, &v53);
                v33[5] = v31 + v33[5];
                break;
              }
            }
            else
            {
              if (v24.u32[0] > 1uLL)
              {
                if (v28 >= *((_QWORD *)&v50 + 1))
                  v28 %= *((_QWORD *)&v50 + 1);
              }
              else
              {
                v28 &= *((_QWORD *)&v50 + 1) - 1;
              }
              if (v28 != v25)
                break;
            }
          }
        }
      }
      KB::Candidate::~Candidate((KB::Candidate *)&v56);
      v56 = (void **)&v49;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v56);
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v48);
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v47);
      if (__p)
      {
        v46 = __p;
        operator delete(__p);
      }
      v34 = v44;
      if (v44)
      {
        p_shared_owners = (unint64_t *)&v44->__shared_owners_;
        do
          v36 = __ldaxr(p_shared_owners);
        while (__stlxr(v36 - 1, p_shared_owners));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
      v13 = v13 + v16;
      v11 = (const KB::Candidate *)((char *)v11 + 1000);
    }
    while (v11 != v12);
  }
  v37 = (float *)v51;
  if ((_QWORD)v51)
  {
    v38 = (float *)v51;
    do
    {
      v38[5] = v38[5] / v13;
      v38 = *(float **)v38;
    }
    while (v38);
    LODWORD(v39) = 0;
    v40 = -3.4028e38;
    do
    {
      v41 = v37[5];
      if (v41 <= v40)
        v39 = v39;
      else
        v39 = *((unsigned int *)v37 + 4);
      if (v41 > v40)
        v40 = v37[5];
      v37 = *(float **)v37;
    }
    while (v37);
  }
  else
  {
    v39 = 0;
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)&v50);
  return v39;
}

uint64_t KB::LanguageModelContainer::index_for_lexicon_id(KB::LanguageModelContainer *this, int a2)
{
  uint64_t v2;
  unint64_t i;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  BOOL v9;
  unint64_t v10;

  v2 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 4) != v2)
  {
    for (i = 0; i < 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 4) - v2) >> 3); ++i)
    {
      v6 = *(std::__shared_weak_count **)(v2 + 56 * i + 8);
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
        v9 = KB::LanguageModelLexiconGroup::model_contains_lexicon_id((KB::LanguageModelLexiconGroup *)(*((_QWORD *)this + 3) + 56 * i), a2);
        do
          v10 = __ldaxr(p_shared_owners);
        while (__stlxr(v10 - 1, p_shared_owners));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        if (v9)
          return i;
      }
      else if (KB::LanguageModelLexiconGroup::model_contains_lexicon_id((KB::LanguageModelLexiconGroup *)(v2 + 56 * i), a2))
      {
        return i;
      }
      v2 = *((_QWORD *)this + 3);
    }
  }
  return -1;
}

void KB::LanguageModelContainer::remove_differing_lex_stems(uint64_t a1, _QWORD *a2, const KB::Candidate **a3, uint64_t *a4)
{
  const KB::Candidate *v4;
  const KB::Candidate *v5;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  KB::Word *v13;
  uint64_t v14;
  _DWORD *v15;
  BOOL is_linguistically_void;
  char v17;
  KB::Candidate *v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  KB::Candidate *v26;
  uint64_t *v27;
  const KB::Candidate *v28;
  _QWORD v30[5];

  v4 = *a3;
  v5 = a3[1];
  if (*a3 != v5)
  {
    v27 = a4 + 2;
    v28 = a3[1];
    do
    {
      if ((int)*(_QWORD *)v4 < 2)
        goto LABEL_17;
      v7 = 0;
      v8 = (_DWORD *)*a2;
      v9 = (_DWORD *)a2[1];
      v10 = *((_QWORD *)v4 + 1);
      v11 = (int)(*(_QWORD *)v4 - 1);
      v12 = 1;
      do
      {
        v13 = (KB::Word *)(v10 + 240 * v7);
        v14 = *((_QWORD *)v13 + 17);
        v15 = v8;
        if (v8 != v9)
        {
          v15 = v8;
          while (*v15 != (_DWORD)v14)
          {
            if (++v15 == v9)
            {
              v15 = v9;
              break;
            }
          }
        }
        if (HIDWORD(v14) >= 0x1F4)
        {
          is_linguistically_void = KB::Word::is_linguistically_void(v13);
          v17 = v15 != v9 || is_linguistically_void;
          v12 &= v17;
        }
        ++v7;
      }
      while (v7 < v11);
      v5 = v28;
      if ((v12 & 1) != 0)
      {
LABEL_17:
        v18 = (KB::Candidate *)a4[1];
        v19 = a4[2];
        if ((unint64_t)v18 >= v19)
        {
          v21 = 0x1CAC083126E978D5 * (((uint64_t)v18 - *a4) >> 3);
          v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) > 0x4189374BC6A7EFLL)
            abort();
          v23 = 0x1CAC083126E978D5 * ((uint64_t)(v19 - *a4) >> 3);
          if (2 * v23 > v22)
            v22 = 2 * v23;
          if (v23 >= 0x20C49BA5E353F7)
            v24 = 0x4189374BC6A7EFLL;
          else
            v24 = v22;
          v30[4] = v27;
          if (v24)
            v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v24);
          else
            v25 = 0;
          v26 = (KB::Candidate *)(v24 + 1000 * v21);
          v30[0] = v24;
          v30[1] = v26;
          v30[3] = v24 + 1000 * v25;
          KB::Candidate::Candidate(v26, v4);
          v30[2] = (char *)v26 + 1000;
          std::vector<KB::Candidate>::__swap_out_circular_buffer(a4, v30);
          v20 = (char *)a4[1];
          std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)v30);
        }
        else
        {
          v20 = (char *)KB::Candidate::Candidate(v18, v4) + 1000;
        }
        a4[1] = (uint64_t)v20;
      }
      v4 = (const KB::Candidate *)((char *)v4 + 1000);
    }
    while (v4 != v5);
  }
}

void std::__function::__func<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0,std::allocator<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0,std::allocator<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA0FD780;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0,std::allocator<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FD780;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_QWORD *std::__function::__func<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0,std::allocator<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  void *v16[3];
  __int128 v17;
  int v18;
  std::string v19;
  std::string __p;
  std::string v21;
  std::string v22;
  __int128 v23;
  std::string *v24;

  v8 = *(_QWORD *)(a1 + 8);
  std::vector<TITokenID>::vector(v16, a2);
  v17 = *(_OWORD *)(a2 + 24);
  v18 = *(_DWORD *)(a2 + 40);
  if (*(char *)(a2 + 71) < 0)
    std::string::__init_copy_ctor_external(&v19, *(const std::string::value_type **)(a2 + 48), *(_QWORD *)(a2 + 56));
  else
    v19 = *(std::string *)(a2 + 48);
  if (*(char *)(a2 + 95) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a2 + 72), *(_QWORD *)(a2 + 80));
  else
    __p = *(std::string *)(a2 + 72);
  memset(&v21, 0, sizeof(v21));
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(&v21, *(__int128 **)(a2 + 96), *(__int128 **)(a2 + 104), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 104) - *(_QWORD *)(a2 + 96)) >> 3));
  memset(&v22, 0, sizeof(v22));
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(&v22, *(__int128 **)(a2 + 120), *(__int128 **)(a2 + 128), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 128) - *(_QWORD *)(a2 + 120)) >> 3));
  v23 = *(_OWORD *)(a2 + 144);
  v9 = (*(float (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v8 + 432))(v8, *(unsigned int *)(a2 + 144), a4);
  *(float *)&v17 = v9 * *(float *)&v17;
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24);
  if (v10)
  {
    v11 = (*(uint64_t (**)(uint64_t, void **, uint64_t, uint64_t))(*(_QWORD *)v10 + 48))(v10, v16, a3, a4);
    v24 = &v22;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v24);
    v24 = &v21;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v19.__r_.__value_.__l.__data_);
    if (v16[0])
    {
      v16[1] = v16[0];
      operator delete(v16[0]);
    }
    return (_QWORD *)v11;
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    return std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v13, v14, v15);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void std::__function::__func<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0,std::allocator<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0,std::allocator<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1EA0FD738;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0,std::allocator<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FD738;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0,std::allocator<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD v22[3];
  _QWORD *v23;
  _BYTE v24[24];
  _BYTE *v25;
  _BYTE v26[24];
  _BYTE *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v9 = (_QWORD *)a4[3];
  if (v9)
  {
    if (v9 == a4)
    {
      v23 = v22;
      (*(void (**)(_QWORD *, _QWORD *))(*a4 + 24))(a4, v22);
    }
    else
    {
      v23 = (_QWORD *)a4[3];
      a4[3] = 0;
    }
  }
  else
  {
    v23 = 0;
  }
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) - v10) >> 3)) <= *a5)
  {
    v12 = 0;
    goto LABEL_28;
  }
  v11 = *(_QWORD *)(v10 + 56 * *a5);
  if (v23)
  {
    if (v23 == v22)
    {
      v27 = v26;
      (*(void (**)(_QWORD *, _BYTE *))(v22[0] + 24))(v22, v26);
    }
    else
    {
      v27 = (_BYTE *)(*(uint64_t (**)(void))(*v23 + 16))();
    }
  }
  else
  {
    v27 = 0;
  }
  v13 = *(_QWORD **)(a1 + 16);
  v14 = (_QWORD *)v13[3];
  if (v14)
  {
    if (v14 == v13)
    {
      v25 = v24;
      (*(void (**)(_QWORD *, _BYTE *))(*v13 + 24))(v13, v24);
    }
    else
    {
      v25 = (_BYTE *)(*(uint64_t (**)(_QWORD))(*v14 + 16))(v13[3]);
    }
  }
  else
  {
    v25 = 0;
  }
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, _QWORD))(*(_QWORD *)v11 + 496))(v11, a2, a3, v26, v24, **(unsigned int **)(a1 + 24));
  v15 = v25;
  if (v25 == v24)
  {
    v16 = 4;
    v15 = v24;
  }
  else
  {
    if (!v25)
      goto LABEL_23;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_23:
  v17 = v27;
  if (v27 == v26)
  {
    v18 = 4;
    v17 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_28;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_28:
  v19 = v23;
  if (v23 == v22)
  {
    v20 = 4;
    v19 = v22;
    goto LABEL_32;
  }
  if (v23)
  {
    v20 = 5;
LABEL_32:
    (*(void (**)(void))(*v19 + 8 * v20))();
  }
  return v12;
}

void std::__function::__func<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA0FD6F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FD6F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD v18[3];
  _QWORD *v19;
  _BYTE v20[24];
  _BYTE *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v9 = (_QWORD *)a4[3];
  if (v9)
  {
    if (v9 == a4)
    {
      v19 = v18;
      (*(void (**)(_QWORD *, _QWORD *))(*a4 + 24))(a4, v18);
    }
    else
    {
      v19 = (_QWORD *)a4[3];
      a4[3] = 0;
    }
  }
  else
  {
    v19 = 0;
  }
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) - v10) >> 3)) <= *a5)
  {
    v12 = 0;
    goto LABEL_18;
  }
  v11 = *(_QWORD *)(v10 + 56 * *a5);
  if (v19)
  {
    if (v19 == v18)
    {
      v21 = v20;
      (*(void (**)(_QWORD *, _BYTE *))(v18[0] + 24))(v18, v20);
    }
    else
    {
      v21 = (_BYTE *)(*(uint64_t (**)(void))(*v19 + 16))();
    }
  }
  else
  {
    v21 = 0;
  }
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _BYTE *, _QWORD))(*(_QWORD *)v11 + 488))(v11, a2, a3, v20, **(unsigned __int8 **)(a1 + 16));
  v13 = v21;
  if (v21 == v20)
  {
    v14 = 4;
    v13 = v20;
  }
  else
  {
    if (!v21)
      goto LABEL_18;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_18:
  v15 = v19;
  if (v19 == v18)
  {
    v16 = 4;
    v15 = v18;
    goto LABEL_22;
  }
  if (v19)
  {
    v16 = 5;
LABEL_22:
    (*(void (**)(void))(*v15 + 8 * v16))();
  }
  return v12;
}

uint64_t ___ZNK2KB22LanguageModelContainer34should_not_suggest_or_predict_textERKNS_6StringERKN3WTF6RefPtrINS_19DictionaryContainerEEE_block_invoke(uint64_t a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)*a2 + 480))(*a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t ___ZNK2KB22LanguageModelContainer19is_text_blocklistedERKNS_6StringEjRKNS_20LanguageModelContextERKN3WTF6RefPtrINS_19DictionaryContainerEEE27TIBlocklistSensitivityLevel_block_invoke(uint64_t a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)*a2 + 472))(*a2, *(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 56), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(unsigned int *)(a1 + 60));
}

KB::LanguageModelContainer::PredictionEnumeratorContainer *KB::LanguageModelContainer::PredictionEnumeratorContainer::PredictionEnumeratorContainer(KB::LanguageModelContainer::PredictionEnumeratorContainer *this, const KB::LanguageModelContainer *a2, const KB::LanguageModelContext *a3, unsigned int a4)
{
  int64x2_t *v6;
  __int128 *v7;
  __int128 *v8;
  char *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  void **v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  char *v35;
  __int128 v36;
  int64x2_t v37;
  void **v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 *v43;
  __int128 *v44;
  char *v45;
  uint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t v53;
  char *v54;
  __int128 v55;
  unint64_t *v56;
  unint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  char *v60;
  __int128 v61;
  int64x2_t v62;
  void **v63;
  char *i;
  unint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  uint64_t v72;
  char *v73;
  _QWORD *v74;
  _QWORD *v75;
  char *v76;
  __int128 v77;
  int64x2_t v78;
  _OWORD *v79;
  void **v80;
  std::__shared_weak_count *v81;
  unint64_t *p_shared_owners;
  unint64_t v83;
  __int128 v86;
  int64x2_t v87;
  char *v88;
  int64x2_t *v89;
  int64x2_t v90;
  void **v91;
  char **v92;

  *(_QWORD *)this = &off_1EA0FD640;
  *(_OWORD *)((char *)this + 8) = 0u;
  v6 = (int64x2_t *)((char *)this + 8);
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_QWORD *)this + 7) = a2;
  *((_QWORD *)this + 8) = a3;
  *((_QWORD *)this + 9) = -1;
  *((_BYTE *)this + 80) = 0;
  v87 = 0uLL;
  v88 = 0;
  v7 = (__int128 *)*((_QWORD *)a2 + 3);
  v8 = (__int128 *)*((_QWORD *)a2 + 4);
  if (v7 == v8)
  {
    v28 = 0;
  }
  else
  {
    v9 = 0;
    do
    {
      if (v9 >= v88)
      {
        v13 = (uint64_t)&v9[-v87.i64[0]] >> 4;
        if ((unint64_t)(v13 + 1) >> 60)
          goto LABEL_81;
        v14 = (uint64_t)&v88[-v87.i64[0]] >> 3;
        if (v14 <= v13 + 1)
          v14 = v13 + 1;
        if ((unint64_t)&v88[-v87.i64[0]] >= 0x7FFFFFFFFFFFFFF0)
          v15 = 0xFFFFFFFFFFFFFFFLL;
        else
          v15 = v14;
        v92 = &v88;
        v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v15);
        v18 = &v16[16 * v13];
        v19 = *v7;
        *(_OWORD *)v18 = *v7;
        if (*((_QWORD *)&v19 + 1))
        {
          v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
          do
            v21 = __ldxr(v20);
          while (__stxr(v21 + 1, v20));
        }
        v22 = (_QWORD *)v87.i64[1];
        v23 = (_QWORD *)v87.i64[0];
        if (v87.i64[1] == v87.i64[0])
        {
          v26 = vdupq_n_s64(v87.u64[1]);
          v24 = &v16[16 * v13];
        }
        else
        {
          v24 = &v16[16 * v13];
          do
          {
            v25 = *((_OWORD *)v22 - 1);
            v22 -= 2;
            *((_OWORD *)v24 - 1) = v25;
            v24 -= 16;
            *v22 = 0;
            v22[1] = 0;
          }
          while (v22 != v23);
          v26 = v87;
        }
        v9 = v18 + 16;
        v87.i64[0] = (uint64_t)v24;
        v87.i64[1] = (uint64_t)(v18 + 16);
        v90 = v26;
        v27 = (void **)v88;
        v88 = &v16[16 * v17];
        v91 = v27;
        v89 = (int64x2_t *)v26.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v89);
      }
      else
      {
        *(_QWORD *)v9 = *(_QWORD *)v7;
        v10 = *((_QWORD *)v7 + 1);
        *((_QWORD *)v9 + 1) = v10;
        if (v10)
        {
          v11 = (unint64_t *)(v10 + 8);
          do
            v12 = __ldxr(v11);
          while (__stxr(v12 + 1, v11));
        }
        v9 += 16;
      }
      v87.i64[1] = (uint64_t)v9;
      v7 = (__int128 *)((char *)v7 + 56);
    }
    while (v7 != v8);
    v28 = (uint64_t)&v9[-v87.i64[0]] >> 4;
  }
  v89 = &v87;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v89);
  v29 = *((_QWORD *)this + 1);
  if (v28 > (*((_QWORD *)this + 3) - v29) >> 4)
  {
    if (v28 >> 60)
      goto LABEL_81;
    v30 = *((_QWORD *)this + 2) - v29;
    v92 = (char **)((char *)this + 24);
    v31 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v28);
    v34 = (_QWORD *)*((_QWORD *)this + 1);
    v33 = (_QWORD *)*((_QWORD *)this + 2);
    if (v33 == v34)
    {
      v37 = vdupq_n_s64((unint64_t)v33);
      v35 = &v31[v30];
    }
    else
    {
      v35 = &v31[v30];
      do
      {
        v36 = *((_OWORD *)v33 - 1);
        v33 -= 2;
        *((_OWORD *)v35 - 1) = v36;
        v35 -= 16;
        *v33 = 0;
        v33[1] = 0;
      }
      while (v33 != v34);
      v37 = *v6;
    }
    *((_QWORD *)this + 1) = v35;
    *((_QWORD *)this + 2) = &v31[v30];
    v90 = v37;
    v38 = (void **)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = &v31[16 * v32];
    v91 = v38;
    v89 = (int64x2_t *)v37.i64[0];
    std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v89);
  }
  v39 = *((_QWORD *)this + 4);
  if (0xCCCCCCCCCCCCCCCDLL * ((*((_QWORD *)this + 6) - v39) >> 5) >= v28)
    goto LABEL_37;
  if (v28 >= 0x19999999999999ALL)
LABEL_81:
    abort();
  v40 = *((_QWORD *)this + 5) - v39;
  v92 = (char **)((char *)this + 48);
  v89 = (int64x2_t *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v28);
  v90.i64[0] = (uint64_t)v89->i64 + v40;
  v90.i64[1] = (uint64_t)v89->i64 + v40;
  v91 = (void **)&v89[10 * v41];
  std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer((uint64_t *)this + 4, &v89);
  std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)&v89);
LABEL_37:
  v42 = *((_QWORD *)this + 7);
  v88 = 0;
  v87 = 0uLL;
  v43 = *(__int128 **)(v42 + 24);
  v44 = *(__int128 **)(v42 + 32);
  if (v43 != v44)
  {
    v45 = 0;
    do
    {
      if (v45 >= v88)
      {
        v49 = (uint64_t)&v45[-v87.i64[0]] >> 4;
        if ((unint64_t)(v49 + 1) >> 60)
          goto LABEL_81;
        v50 = (uint64_t)&v88[-v87.i64[0]] >> 3;
        if (v50 <= v49 + 1)
          v50 = v49 + 1;
        if ((unint64_t)&v88[-v87.i64[0]] >= 0x7FFFFFFFFFFFFFF0)
          v51 = 0xFFFFFFFFFFFFFFFLL;
        else
          v51 = v50;
        v92 = &v88;
        v52 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v51);
        v54 = &v52[16 * v49];
        v55 = *v43;
        *(_OWORD *)v54 = *v43;
        if (*((_QWORD *)&v55 + 1))
        {
          v56 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
          do
            v57 = __ldxr(v56);
          while (__stxr(v57 + 1, v56));
        }
        v58 = (_QWORD *)v87.i64[1];
        v59 = (_QWORD *)v87.i64[0];
        if (v87.i64[1] == v87.i64[0])
        {
          v62 = vdupq_n_s64(v87.u64[1]);
          v60 = &v52[16 * v49];
        }
        else
        {
          v60 = &v52[16 * v49];
          do
          {
            v61 = *((_OWORD *)v58 - 1);
            v58 -= 2;
            *((_OWORD *)v60 - 1) = v61;
            v60 -= 16;
            *v58 = 0;
            v58[1] = 0;
          }
          while (v58 != v59);
          v62 = v87;
        }
        v45 = v54 + 16;
        v87.i64[0] = (uint64_t)v60;
        v87.i64[1] = (uint64_t)(v54 + 16);
        v90 = v62;
        v63 = (void **)v88;
        v88 = &v52[16 * v53];
        v91 = v63;
        v89 = (int64x2_t *)v62.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v89);
      }
      else
      {
        *(_QWORD *)v45 = *(_QWORD *)v43;
        v46 = *((_QWORD *)v43 + 1);
        *((_QWORD *)v45 + 1) = v46;
        if (v46)
        {
          v47 = (unint64_t *)(v46 + 8);
          do
            v48 = __ldxr(v47);
          while (__stxr(v48 + 1, v47));
        }
        v45 += 16;
      }
      v87.i64[1] = (uint64_t)v45;
      v43 = (__int128 *)((char *)v43 + 56);
    }
    while (v43 != v44);
    for (i = (char *)v87.i64[0]; i != v45; i += 16)
    {
      (*(void (**)(__int128 *__return_ptr, _QWORD, const KB::LanguageModelContext *, _QWORD))(**(_QWORD **)i + 456))(&v86, *(_QWORD *)i, a3, a4);
      v66 = (_OWORD *)*((_QWORD *)this + 2);
      v65 = *((_QWORD *)this + 3);
      if ((unint64_t)v66 >= v65)
      {
        v67 = ((uint64_t)v66 - v6->i64[0]) >> 4;
        v68 = v67 + 1;
        if ((unint64_t)(v67 + 1) >> 60)
          goto LABEL_81;
        v69 = v65 - v6->i64[0];
        if (v69 >> 3 > v68)
          v68 = v69 >> 3;
        if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF0)
          v70 = 0xFFFFFFFFFFFFFFFLL;
        else
          v70 = v68;
        v92 = (char **)((char *)this + 24);
        v71 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v70);
        v73 = &v71[16 * v67];
        *(_OWORD *)v73 = v86;
        v86 = 0uLL;
        v75 = (_QWORD *)*((_QWORD *)this + 1);
        v74 = (_QWORD *)*((_QWORD *)this + 2);
        if (v74 == v75)
        {
          v78 = vdupq_n_s64((unint64_t)v74);
          v76 = &v71[16 * v67];
        }
        else
        {
          v76 = &v71[16 * v67];
          do
          {
            v77 = *((_OWORD *)v74 - 1);
            v74 -= 2;
            *((_OWORD *)v76 - 1) = v77;
            v76 -= 16;
            *v74 = 0;
            v74[1] = 0;
          }
          while (v74 != v75);
          v78 = *v6;
        }
        v79 = v73 + 16;
        *((_QWORD *)this + 1) = v76;
        *((_QWORD *)this + 2) = v73 + 16;
        v90 = v78;
        v80 = (void **)*((_QWORD *)this + 3);
        *((_QWORD *)this + 3) = &v71[16 * v72];
        v91 = v80;
        v89 = (int64x2_t *)v78.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v89);
        v81 = (std::__shared_weak_count *)*((_QWORD *)&v86 + 1);
        *((_QWORD *)this + 2) = v79;
        if (v81)
        {
          p_shared_owners = (unint64_t *)&v81->__shared_owners_;
          do
            v83 = __ldaxr(p_shared_owners);
          while (__stlxr(v83 - 1, p_shared_owners));
          if (!v83)
          {
            ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
            std::__shared_weak_count::__release_weak(v81);
          }
        }
      }
      else
      {
        *v66 = v86;
        *((_QWORD *)this + 2) = v66 + 1;
      }
    }
  }
  v89 = &v87;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v89);
  return this;
}

void KB::LanguageModelContainer::PredictionEnumeratorContainer::~PredictionEnumeratorContainer(KB::LanguageModelContainer::PredictionEnumeratorContainer *this)
{
  void **v1;
  void **v2;

  *(_QWORD *)this = &off_1EA0FD640;
  v1 = (void **)((char *)this + 8);
  v2 = (void **)((char *)this + 32);
  std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v2);
  v2 = v1;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

{
  void **v1;
  void **v2;

  *(_QWORD *)this = &off_1EA0FD640;
  v1 = (void **)((char *)this + 8);
  v2 = (void **)((char *)this + 32);
  std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v2);
  v2 = v1;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v2);
  JUMPOUT(0x1DF0A2144);
}

__n128 KB::LanguageModelContainer::PredictionEnumeratorContainer::get_prediction@<Q0>(KB::LanguageModelContainer::PredictionEnumeratorContainer *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  std::string *v7;
  const std::string::value_type **v8;
  __int128 v9;
  std::string *v10;
  const std::string::value_type **v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __n128 result;

  v3 = *((_QWORD *)this + 9);
  v4 = *((_QWORD *)this + 4);
  v5 = v4 + 160 * v3;
  std::vector<TITokenID>::vector((_QWORD *)a2, v5);
  v6 = *(_OWORD *)(v5 + 24);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(v5 + 40);
  *(_OWORD *)(a2 + 24) = v6;
  v7 = (std::string *)(a2 + 48);
  v8 = (const std::string::value_type **)(v5 + 48);
  if (*(char *)(v5 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *v8, *(_QWORD *)(v4 + 160 * v3 + 56));
  }
  else
  {
    v9 = *(_OWORD *)v8;
    *(_QWORD *)(a2 + 64) = *(_QWORD *)(v5 + 64);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  v10 = (std::string *)(a2 + 72);
  v11 = (const std::string::value_type **)(v4 + 160 * v3 + 72);
  if (*(char *)(v5 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *v11, *(_QWORD *)(v4 + 160 * v3 + 80));
  }
  else
  {
    v12 = *(_OWORD *)v11;
    *(_QWORD *)(a2 + 88) = *(_QWORD *)(v4 + 160 * v3 + 88);
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v12;
  }
  v13 = v4 + 160 * v3;
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)(a2 + 96), *(__int128 **)(v13 + 96), *(__int128 **)(v13 + 104), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v13 + 104) - *(_QWORD *)(v13 + 96)) >> 3));
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  v14 = a2 + 120;
  *(_QWORD *)(v14 + 16) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)v14, *(__int128 **)(v13 + 120), *(__int128 **)(v13 + 128), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v13 + 128) - *(_QWORD *)(v13 + 120)) >> 3));
  result = *(__n128 *)(v13 + 144);
  *(__n128 *)(v14 + 24) = result;
  return result;
}

BOOL KB::LanguageModelContainer::PredictionEnumeratorContainer::advance(KB::LanguageModelContainer::PredictionEnumeratorContainer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  unsigned int *v6;
  uint64_t v7;
  __int128 v8;
  void **v9;
  __int128 v10;
  void **v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  __int128 v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  char *v37;
  unsigned int *v38;
  uint64_t v39;
  unint64_t v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  __int128 v50;
  uint64_t v51;
  __int128 v52;
  void **v53;
  __int128 v54;
  uint64_t v55;
  uint64_t v56;
  _BOOL8 result;
  void **v58;
  void *v59[2];
  unsigned int *v60;
  __int128 v61;
  int v62;
  void *v63[2];
  _QWORD v64[4];
  _OWORD v65[3];
  __int128 v66;
  void **v67[6];

  if (*((_BYTE *)this + 80))
  {
    v2 = *(_QWORD *)(*((_QWORD *)this + 1) + 16 * *((_QWORD *)this + 9));
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2))
    {
      v3 = *((_QWORD *)this + 9);
      v4 = *((_QWORD *)this + 4);
      v5 = (void **)(v4 + 160 * v3);
      (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v2 + 16))(v59, v2);
      v6 = (unsigned int *)*v5;
      if (*v5)
      {
        v5[1] = v6;
        operator delete(v6);
      }
      *(_OWORD *)v5 = *(_OWORD *)v59;
      v5[2] = v60;
      v59[1] = 0;
      v60 = 0;
      v59[0] = 0;
      v7 = v4 + 160 * v3;
      v8 = v61;
      *(_DWORD *)(v7 + 40) = v62;
      *(_OWORD *)(v7 + 24) = v8;
      v9 = (void **)(v7 + 48);
      if (*((char *)v5 + 71) < 0)
        operator delete(*v9);
      v10 = *(_OWORD *)v63;
      *(_QWORD *)(v7 + 64) = v64[0];
      *(_OWORD *)v9 = v10;
      HIBYTE(v64[0]) = 0;
      LOBYTE(v63[0]) = 0;
      v11 = (void **)(v4 + 160 * v3 + 72);
      if (*((char *)v5 + 95) < 0)
        operator delete(*v11);
      v12 = *(_OWORD *)&v64[1];
      *(_QWORD *)(v4 + 160 * v3 + 88) = v64[3];
      *(_OWORD *)v11 = v12;
      HIBYTE(v64[3]) = 0;
      LOBYTE(v64[1]) = 0;
      v13 = v4 + 160 * v3;
      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v13 + 96));
      *(_OWORD *)(v13 + 96) = v65[0];
      *(_QWORD *)(v13 + 112) = *(_QWORD *)&v65[1];
      memset(v65, 0, 24);
      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v13 + 120));
      *(_OWORD *)(v13 + 120) = *(_OWORD *)((char *)&v65[1] + 8);
      *(_QWORD *)(v13 + 136) = *((_QWORD *)&v65[2] + 1);
      memset((char *)&v65[1] + 8, 0, 24);
      *(_OWORD *)(v13 + 144) = v66;
      v67[0] = (void **)&v65[1] + 1;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
      v67[0] = (void **)v65;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
      if (SHIBYTE(v64[3]) < 0)
        operator delete((void *)v64[1]);
      if (SHIBYTE(v64[0]) < 0)
        operator delete(v63[0]);
      if (v59[0])
      {
        v59[1] = v59[0];
        operator delete(v59[0]);
      }
      if (*v5 == v5[1])
      {
LABEL_67:
        result = 0;
        *((_QWORD *)this + 9) = -1;
        return result;
      }
      *(float *)(v7 + 24) = (*(float (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 7) + 432))(*((_QWORD *)this + 7), *(unsigned int *)*v5, *((_QWORD *)this + 8))* *(float *)(v7 + 24);
    }
    else
    {
      LODWORD(v61) = 0;
      *((_QWORD *)&v61 + 1) = 0;
      v62 = 0;
      *((_QWORD *)&v66 + 1) = 0;
      *(_OWORD *)v63 = 0u;
      memset(v64, 0, sizeof(v64));
      memset(v65, 0, sizeof(v65));
      v45 = *((_QWORD *)this + 9);
      v46 = *((_QWORD *)this + 4);
      v47 = v46 + 160 * v45;
      v48 = *(void **)v47;
      if (*(_QWORD *)v47)
      {
        *(_QWORD *)(v47 + 8) = v48;
        operator delete(v48);
      }
      *(_QWORD *)v47 = 0;
      *(_QWORD *)(v47 + 8) = 0;
      *(_QWORD *)(v47 + 16) = 0;
      v59[1] = 0;
      v60 = 0;
      v59[0] = 0;
      v49 = v46 + 160 * v45;
      v50 = v61;
      *(_DWORD *)(v49 + 40) = v62;
      *(_OWORD *)(v49 + 24) = v50;
      v51 = v49 + 48;
      if (*(char *)(v47 + 71) < 0)
        operator delete(*(void **)v51);
      v52 = *(_OWORD *)v63;
      *(_QWORD *)(v51 + 16) = v64[0];
      *(_OWORD *)v51 = v52;
      HIBYTE(v64[0]) = 0;
      LOBYTE(v63[0]) = 0;
      v53 = (void **)(v46 + 160 * v45 + 72);
      if (*(char *)(v47 + 95) < 0)
        operator delete(*v53);
      v54 = *(_OWORD *)&v64[1];
      *(_QWORD *)(v46 + 160 * v45 + 88) = v64[3];
      *(_OWORD *)v53 = v54;
      HIBYTE(v64[3]) = 0;
      LOBYTE(v64[1]) = 0;
      v55 = v46 + 160 * v45;
      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v55 + 96));
      *(_QWORD *)(v55 + 96) = 0;
      *(_QWORD *)(v55 + 104) = 0;
      *(_QWORD *)(v55 + 112) = 0;
      memset(v65, 0, 24);
      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v55 + 120));
      *(_QWORD *)(v55 + 120) = 0;
      *(_QWORD *)(v55 + 128) = 0;
      *(_QWORD *)(v55 + 136) = 0;
      memset((char *)&v65[1] + 8, 0, 24);
      *(_OWORD *)(v55 + 144) = v66;
      v67[0] = (void **)&v65[1] + 1;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
      v67[0] = (void **)v65;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
      if (SHIBYTE(v64[3]) < 0)
        operator delete((void *)v64[1]);
      if (SHIBYTE(v64[0]) < 0)
        operator delete(v63[0]);
      if (v59[0])
      {
        v59[1] = v59[0];
        operator delete(v59[0]);
      }
    }
  }
  else
  {
    *((_BYTE *)this + 80) = 1;
    v14 = *((_QWORD *)this + 1);
    if (*((_QWORD *)this + 2) != v14)
    {
      v15 = 0;
      v16 = 0;
      v17 = (_QWORD *)((char *)this + 32);
      v58 = (void **)((char *)this + 48);
      do
      {
        v18 = *(_QWORD *)(v14 + v15);
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v18 + 24))(v18))
        {
          (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v18 + 16))(v59, v18);
          v19 = *((_QWORD *)this + 5);
          v20 = *((_QWORD *)this + 6);
          if (v19 >= v20)
          {
            v28 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v19 - *v17) >> 5);
            v29 = v28 + 1;
            if (v28 + 1 > 0x199999999999999)
              goto LABEL_69;
            v30 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - *v17) >> 5);
            if (2 * v30 > v29)
              v29 = 2 * v30;
            if (v30 >= 0xCCCCCCCCCCCCCCLL)
              v31 = 0x199999999999999;
            else
              v31 = v29;
            v67[4] = v58;
            if (v31)
              v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v31);
            else
              v32 = 0;
            v40 = v31 + 160 * v28;
            v67[0] = (void **)v31;
            v67[1] = (void **)v40;
            v67[3] = (void **)(v31 + 160 * v32);
            *(_QWORD *)v40 = 0;
            *(_QWORD *)(v40 + 8) = 0;
            *(_QWORD *)(v40 + 16) = 0;
            *(_OWORD *)v40 = *(_OWORD *)v59;
            *(_QWORD *)(v40 + 16) = v60;
            v59[0] = 0;
            v59[1] = 0;
            v60 = 0;
            v41 = v61;
            *(_DWORD *)(v40 + 40) = v62;
            *(_OWORD *)(v40 + 24) = v41;
            v42 = *(_OWORD *)v63;
            *(_QWORD *)(v40 + 64) = v64[0];
            *(_OWORD *)(v40 + 48) = v42;
            v63[1] = 0;
            v64[0] = 0;
            v63[0] = 0;
            v43 = *(_OWORD *)&v64[1];
            *(_QWORD *)(v40 + 88) = v64[3];
            *(_OWORD *)(v40 + 72) = v43;
            memset(&v64[1], 0, 24);
            *(_QWORD *)(v40 + 96) = 0;
            *(_QWORD *)(v40 + 104) = 0;
            *(_QWORD *)(v40 + 112) = 0;
            *(_OWORD *)(v40 + 96) = v65[0];
            *(_QWORD *)(v40 + 112) = *(_QWORD *)&v65[1];
            memset(v65, 0, 24);
            *(_QWORD *)(v40 + 120) = 0;
            *(_QWORD *)(v40 + 128) = 0;
            *(_QWORD *)(v40 + 136) = 0;
            *(_OWORD *)(v40 + 120) = *(_OWORD *)((char *)&v65[1] + 8);
            *(_QWORD *)(v40 + 136) = *((_QWORD *)&v65[2] + 1);
            memset((char *)&v65[1] + 8, 0, 24);
            *(_OWORD *)(v40 + 144) = v66;
            v67[2] = (void **)(v40 + 160);
            std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer((uint64_t *)this + 4, v67);
            v24 = *((_QWORD *)this + 5);
            std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)v67);
          }
          else
          {
            *(_QWORD *)v19 = 0;
            *(_QWORD *)(v19 + 8) = 0;
            *(_QWORD *)(v19 + 16) = 0;
            *(_OWORD *)v19 = *(_OWORD *)v59;
            *(_QWORD *)(v19 + 16) = v60;
            v59[0] = 0;
            v59[1] = 0;
            v60 = 0;
            v21 = v62;
            *(_OWORD *)(v19 + 24) = v61;
            *(_DWORD *)(v19 + 40) = v21;
            v22 = v64[0];
            *(_OWORD *)(v19 + 48) = *(_OWORD *)v63;
            *(_QWORD *)(v19 + 64) = v22;
            v63[1] = 0;
            v64[0] = 0;
            v63[0] = 0;
            v23 = *(_OWORD *)&v64[1];
            *(_QWORD *)(v19 + 88) = v64[3];
            *(_QWORD *)(v19 + 96) = 0;
            *(_OWORD *)(v19 + 72) = v23;
            memset(&v64[1], 0, 24);
            *(_QWORD *)(v19 + 104) = 0;
            *(_QWORD *)(v19 + 112) = 0;
            *(_OWORD *)(v19 + 96) = v65[0];
            v65[0] = 0uLL;
            *(_QWORD *)(v19 + 112) = *(_QWORD *)&v65[1];
            *(_QWORD *)(v19 + 120) = 0;
            *(_QWORD *)&v65[1] = 0;
            *(_QWORD *)(v19 + 128) = 0;
            *(_QWORD *)(v19 + 136) = 0;
            *(_OWORD *)(v19 + 120) = *(_OWORD *)((char *)&v65[1] + 8);
            *(_QWORD *)(v19 + 136) = *((_QWORD *)&v65[2] + 1);
            memset((char *)&v65[1] + 8, 0, 24);
            *(_OWORD *)(v19 + 144) = v66;
            v24 = v19 + 160;
          }
          *((_QWORD *)this + 5) = v24;
          v67[0] = (void **)&v65[1] + 1;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
          v67[0] = (void **)v65;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
          if (SHIBYTE(v64[3]) < 0)
            operator delete((void *)v64[1]);
          if (SHIBYTE(v64[0]) < 0)
            operator delete(v63[0]);
          if (v59[0])
          {
            v59[1] = v59[0];
            operator delete(v59[0]);
          }
          v44 = *((_QWORD *)this + 5);
          if (*(_QWORD *)(v44 - 160) == *(_QWORD *)(v44 - 152))
            goto LABEL_67;
          *(float *)(v44 - 136) = (*(float (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 7) + 432))(*((_QWORD *)this + 7), *(unsigned int *)(v44 - 16), *((_QWORD *)this + 8))* *(float *)(v44 - 136);
        }
        else
        {
          v25 = *((_QWORD *)this + 5);
          v26 = *((_QWORD *)this + 6);
          if (v25 >= v26)
          {
            v33 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v25 - *v17) >> 5);
            v34 = v33 + 1;
            if (v33 + 1 > 0x199999999999999)
LABEL_69:
              abort();
            v35 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v26 - *v17) >> 5);
            if (2 * v35 > v34)
              v34 = 2 * v35;
            if (v35 >= 0xCCCCCCCCCCCCCCLL)
              v36 = 0x199999999999999;
            else
              v36 = v34;
            *((_QWORD *)&v61 + 1) = v58;
            v37 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v36);
            v38 = (unsigned int *)&v37[160 * v33];
            v59[0] = v37;
            v59[1] = v38;
            *(_QWORD *)&v61 = &v37[160 * v39];
            *((_QWORD *)v38 + 1) = 0;
            *((_QWORD *)v38 + 2) = 0;
            *(_QWORD *)v38 = 0;
            v38[6] = 0;
            *((_QWORD *)v38 + 4) = 0;
            v38[10] = 0;
            *((_QWORD *)v38 + 19) = 0;
            *((_OWORD *)v38 + 3) = 0u;
            *((_OWORD *)v38 + 4) = 0u;
            *((_OWORD *)v38 + 5) = 0u;
            *((_OWORD *)v38 + 6) = 0u;
            *((_OWORD *)v38 + 7) = 0u;
            *((_OWORD *)v38 + 8) = 0u;
            v60 = v38 + 40;
            std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer((uint64_t *)this + 4, v59);
            v27 = *((_QWORD *)this + 5);
            std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)v59);
          }
          else
          {
            *(_QWORD *)v25 = 0;
            *(_QWORD *)(v25 + 8) = 0;
            *(_QWORD *)(v25 + 16) = 0;
            *(_DWORD *)(v25 + 24) = 0;
            *(_QWORD *)(v25 + 32) = 0;
            *(_DWORD *)(v25 + 40) = 0;
            *(_QWORD *)(v25 + 152) = 0;
            *(_OWORD *)(v25 + 48) = 0u;
            *(_OWORD *)(v25 + 64) = 0u;
            *(_OWORD *)(v25 + 80) = 0u;
            *(_OWORD *)(v25 + 96) = 0u;
            v27 = v25 + 160;
            *(_OWORD *)(v25 + 112) = 0u;
            *(_OWORD *)(v25 + 128) = 0u;
          }
          *((_QWORD *)this + 5) = v27;
        }
        ++v16;
        v14 = *((_QWORD *)this + 1);
        v15 += 16;
      }
      while (v16 < (*((_QWORD *)this + 2) - v14) >> 4);
    }
  }
  KB::LanguageModelContainer::PredictionEnumeratorContainer::update_next_prediction_index(this);
  v56 = *((_QWORD *)this + 9);
  return v56 != -1 && *(float *)(*((_QWORD *)this + 4) + 160 * v56 + 24) > 0.0;
}

_QWORD *KB::LanguageModelContainer::PredictionEnumeratorContainer::update_next_prediction_index(_QWORD *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  float *v6;
  float v7;
  uint64_t v8;
  float v9;
  float v10;

  v2 = this[4];
  v1 = this[5];
  v3 = v1 - v2;
  if (v1 != v2)
  {
    v4 = 0;
    v5 = v3 / 160;
    if (v5 <= 1)
      v5 = 1;
    v6 = (float *)(v2 + 24);
    v7 = 0.0;
    v8 = -1;
    do
    {
      v9 = *v6;
      v6 += 40;
      v10 = v9;
      if (v9 > v7)
      {
        v7 = v10;
        v8 = v4;
      }
      ++v4;
    }
    while (v5 != v4);
    if (v8 != -1)
      this[9] = v8;
  }
  return this;
}

void std::__shared_ptr_emplace<KB::LanguageModelContainer::PredictionEnumeratorContainer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD670;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::LanguageModelContainer::PredictionEnumeratorContainer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD670;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::LanguageModelContainer::PredictionEnumeratorContainer>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*,false>(uint64_t a1, std::vector<std::string> *a2, uint64_t a3, char a4)
{
  __int128 *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  std::vector<std::string> *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  std::vector<std::string> *v19;
  std::vector<std::string> *v20;
  __int128 v21;
  _OWORD *v22;
  unint64_t v23;
  float v24;
  unint64_t v25;
  std::vector<std::string> *v26;
  unint64_t v27;
  float v28;
  std::vector<std::string> *v29;
  float v30;
  uint64_t v31;
  unint64_t v32;
  float v33;
  float v34;
  void **v35;
  std::string *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  void *v40;
  __int128 v41;
  void **v42;
  __int128 v43;
  void **v44;
  __int128 v45;
  BOOL v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  float v51;
  uint64_t v52;
  float v53;
  unint64_t v54;
  unint64_t v55;
  std::vector<std::string> *v56;
  float v57;
  float v58;
  float v59;
  void **v60;
  void *v61;
  __int128 *v62;
  void **v63;
  __int128 v64;
  void **v65;
  __int128 v66;
  __int128 v67;
  void *v68;
  __int128 v69;
  void **v70;
  __int128 v71;
  void **v72;
  __int128 v73;
  std::vector<std::string> *v74;
  uint64_t v75;
  std::vector<std::string> *v76;
  std::vector<std::string> *v77;
  std::vector<std::string> *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  void *v87;
  void **v88;
  uint64_t v89;
  void **v90;
  uint64_t v91;
  float v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  std::vector<std::string> *v96;
  std::vector<std::string> *v97;
  _OWORD *v98;
  uint64_t v99;
  void *v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  float v111;
  uint64_t v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  float v116;
  uint64_t v117;
  void *v118;
  __int128 v119;
  void **v120;
  void **v121;
  __int128 v122;
  void **v123;
  __int128 v124;
  uint64_t v125;
  void *v126;
  uint64_t v127;
  int v128;
  void **v129;
  __int128 v130;
  __int128 v131;
  int64_t v132;
  uint64_t v133;
  std::vector<std::string> *v134;
  uint64_t v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  int64_t v142;
  void *v143;
  __int128 v144;
  void **v145;
  void **v146;
  __int128 v147;
  void **v148;
  __int128 v149;
  _OWORD *v150;
  void **v151;
  void *v152;
  __int128 v153;
  void **v154;
  __int128 v155;
  __int128 v156;
  std::vector<std::string>::pointer *v157;
  std::string *end;
  std::vector<std::string>::pointer *v159;
  __int128 v160;
  void **v161;
  __int128 v162;
  __int128 v163;
  uint64_t v164;
  unint64_t v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  float v169;
  unint64_t v170;
  void *v171;
  uint64_t v172;
  __int128 v173;
  void **v174;
  __int128 v175;
  void **v176;
  uint64_t v177;
  __int128 v178;
  std::vector<std::string> *v179;
  _QWORD *v180;
  std::vector<std::string> *v181;
  uint64_t v182;
  void *v183;
  __int128 v184;
  uint64_t v185;
  __int128 v186;
  __int128 v187;
  uint64_t v188;
  _QWORD *v189;
  _QWORD *v190;
  std::string *v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  void *v202;
  void **v203;
  void **v204;
  void *v205;
  void **v206;
  __int128 v207;
  void **v208;
  __int128 v209;
  __int128 v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  __int128 *v217;
  uint64_t v218;
  __int128 *v219;
  __int128 *v220;
  float *v221;
  std::string *v222;
  __int128 *v223;
  int64_t v224;
  std::string *v225;
  std::string *v226;
  uint64_t p_end;
  uint64_t v229;
  _OWORD *v230;
  void *v231;
  std::string *v232;
  std::string *v233;
  void **v234;
  void *v237;
  std::string *v238;
  std::string *v239;
  __int128 v240;
  int v241;
  __int128 v242;
  std::string *v243;
  __int128 v244;
  std::string *v245;
  __int128 v246;
  std::string *v247;
  __int128 v248;
  std::string *v249;
  __int128 v250;
  void **v251;
  __int128 v252;
  uint64_t v253;
  __int128 v254;
  int v255;
  __int128 v256;
  uint64_t v257;
  __int128 __p;
  uint64_t v259;
  __int128 v260;
  uint64_t v261;
  __int128 v262;
  uint64_t v263;
  __int128 v264;

  v5 = &v254;
LABEL_2:
  v6 = a1;
  p_end = (uint64_t)&a2[-7].__end_;
  while (2)
  {
    v7 = v6;
    v8 = (uint64_t)a2 - v6;
    v9 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 5);
    a1 = v7;
    switch(v9)
    {
      case 0:
      case 1:
        return;
      case 2:
        if (*(float *)&a2[-6].__end_ > *(float *)(v7 + 24))
        {
          v74 = (std::vector<std::string> *)v7;
          v75 = (uint64_t)&a2[-7].__end_;
          goto LABEL_92;
        }
        return;
      case 3:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)v7, (std::vector<std::string> *)(v7 + 160), p_end);
        return;
      case 4:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(v7, v7 + 160, v7 + 320, p_end);
        return;
      case 5:
        v76 = (std::vector<std::string> *)(v7 + 160);
        v77 = (std::vector<std::string> *)(v7 + 320);
        v78 = (std::vector<std::string> *)(v7 + 480);
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(a1, a1 + 160, a1 + 320, a1 + 480);
        if (*(float *)&a2[-6].__end_ > *(float *)(a1 + 504))
        {
          std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(v78, p_end);
          if (*(float *)(a1 + 504) > *(float *)(a1 + 344))
          {
            std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(v77, (uint64_t)v78);
            if (*(float *)(a1 + 344) > *(float *)(a1 + 184))
            {
              std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(v76, (uint64_t)v77);
              if (*(float *)(a1 + 184) > *(float *)(a1 + 24))
              {
                v74 = (std::vector<std::string> *)a1;
                v75 = (uint64_t)v76;
LABEL_92:
                std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(v74, v75);
              }
            }
          }
        }
        return;
      default:
        if (v8 > 3839)
        {
          if (!a3)
          {
            if ((std::vector<std::string> *)v7 != a2)
            {
              v104 = (unint64_t)(v9 - 2) >> 1;
              v105 = v104;
              do
              {
                v106 = v105;
                if (v104 >= v105)
                {
                  v107 = (2 * v105) | 1;
                  v108 = a1 + 160 * v107;
                  if (2 * v106 + 2 < v9 && *(float *)(a1 + 160 * v107 + 24) > *(float *)(v108 + 184))
                  {
                    v108 += 160;
                    v107 = 2 * v106 + 2;
                  }
                  v109 = a1 + 160 * v106;
                  v111 = *(float *)(v109 + 24);
                  v110 = v109 + 24;
                  if (*(float *)(v108 + 24) <= v111)
                  {
                    v112 = a1 + 160 * v106;
                    v231 = *(void **)v112;
                    *(_QWORD *)&v252 = *(_QWORD *)v112;
                    v229 = *(_QWORD *)(v112 + 8);
                    *((_QWORD *)&v252 + 1) = v229;
                    v253 = *(_QWORD *)(v112 + 16);
                    *(_QWORD *)v112 = 0;
                    *(_QWORD *)(v112 + 8) = 0;
                    *(_QWORD *)(v112 + 16) = 0;
                    v113 = *(_OWORD *)v110;
                    v255 = *(_DWORD *)(v110 + 16);
                    v254 = v113;
                    v114 = *(_OWORD *)(v112 + 48);
                    v257 = *(_QWORD *)(v112 + 64);
                    v256 = v114;
                    *(_QWORD *)(v112 + 56) = 0;
                    *(_QWORD *)(v112 + 64) = 0;
                    *(_QWORD *)(v112 + 48) = 0;
                    v115 = *(_OWORD *)(v112 + 72);
                    v259 = *(_QWORD *)(v112 + 88);
                    __p = v115;
                    *(_QWORD *)(v112 + 80) = 0;
                    *(_QWORD *)(v112 + 88) = 0;
                    *(_QWORD *)(v112 + 72) = 0;
                    v260 = *(_OWORD *)(v112 + 96);
                    v261 = *(_QWORD *)(v112 + 112);
                    *(_QWORD *)(v112 + 96) = 0;
                    *(_QWORD *)(v112 + 104) = 0;
                    *(_QWORD *)(v112 + 112) = 0;
                    v262 = *(_OWORD *)(v112 + 120);
                    v263 = *(_QWORD *)(v112 + 136);
                    *(_QWORD *)(v112 + 128) = 0;
                    *(_QWORD *)(v112 + 136) = 0;
                    *(_QWORD *)(v112 + 120) = 0;
                    v264 = *(_OWORD *)(v112 + 144);
                    v116 = *(float *)&v254;
                    do
                    {
                      v117 = v108;
                      v118 = *(void **)v112;
                      if (*(_QWORD *)v112)
                      {
                        *(_QWORD *)(v112 + 8) = v118;
                        operator delete(v118);
                        *(_QWORD *)v112 = 0;
                        *(_QWORD *)(v112 + 8) = 0;
                        *(_QWORD *)(v112 + 16) = 0;
                      }
                      *(_OWORD *)v112 = *(_OWORD *)v117;
                      *(_QWORD *)(v112 + 16) = *(_QWORD *)(v117 + 16);
                      *(_QWORD *)(v117 + 8) = 0;
                      *(_QWORD *)(v117 + 16) = 0;
                      *(_QWORD *)v117 = 0;
                      v119 = *(_OWORD *)(v117 + 24);
                      *(_DWORD *)(v112 + 40) = *(_DWORD *)(v117 + 40);
                      *(_OWORD *)(v112 + 24) = v119;
                      v120 = (void **)(v112 + 48);
                      if (*(char *)(v112 + 71) < 0)
                        operator delete(*v120);
                      v121 = (void **)(v117 + 48);
                      v122 = *(_OWORD *)(v117 + 48);
                      *(_QWORD *)(v112 + 64) = *(_QWORD *)(v117 + 64);
                      *(_OWORD *)v120 = v122;
                      *(_BYTE *)(v117 + 71) = 0;
                      *(_BYTE *)(v117 + 48) = 0;
                      v123 = (void **)(v112 + 72);
                      if (*(char *)(v112 + 95) < 0)
                        operator delete(*v123);
                      v124 = *(_OWORD *)(v117 + 72);
                      *(_QWORD *)(v112 + 88) = *(_QWORD *)(v117 + 88);
                      *(_OWORD *)v123 = v124;
                      *(_BYTE *)(v117 + 95) = 0;
                      *(_BYTE *)(v117 + 72) = 0;
                      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v112 + 96));
                      *(_OWORD *)(v112 + 96) = *(_OWORD *)(v117 + 96);
                      *(_QWORD *)(v112 + 112) = *(_QWORD *)(v117 + 112);
                      *(_QWORD *)(v117 + 96) = 0;
                      *(_QWORD *)(v117 + 104) = 0;
                      *(_QWORD *)(v117 + 112) = 0;
                      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v112 + 120));
                      *(_OWORD *)(v112 + 120) = *(_OWORD *)(v117 + 120);
                      *(_QWORD *)(v112 + 136) = *(_QWORD *)(v117 + 136);
                      *(_QWORD *)(v117 + 120) = 0;
                      *(_QWORD *)(v117 + 128) = 0;
                      *(_QWORD *)(v117 + 136) = 0;
                      *(_OWORD *)(v112 + 144) = *(_OWORD *)(v117 + 144);
                      if (v104 < v107)
                        break;
                      v125 = (2 * v107) | 1;
                      v108 = a1 + 160 * v125;
                      if (2 * v107 + 2 < v9 && *(float *)(a1 + 160 * v125 + 24) > *(float *)(v108 + 184))
                      {
                        v108 += 160;
                        v125 = 2 * v107 + 2;
                      }
                      v112 = v117;
                      v107 = v125;
                    }
                    while (*(float *)(v108 + 24) <= v116);
                    v126 = *(void **)v117;
                    v127 = v229;
                    if (*(_QWORD *)v117)
                    {
                      *(_QWORD *)(v117 + 8) = v126;
                      operator delete(v126);
                      *(_QWORD *)v117 = 0;
                      *(_QWORD *)(v117 + 8) = 0;
                      *(_QWORD *)(v117 + 16) = 0;
                      v127 = *((_QWORD *)&v252 + 1);
                    }
                    *(_QWORD *)v117 = v231;
                    *(_QWORD *)(v117 + 8) = v127;
                    *(_QWORD *)(v117 + 16) = v253;
                    v252 = 0uLL;
                    v253 = 0;
                    v128 = v255;
                    *(_OWORD *)(v117 + 24) = v254;
                    *(_DWORD *)(v117 + 40) = v128;
                    if (*(char *)(v117 + 71) < 0)
                      operator delete(*v121);
                    v129 = (void **)(v117 + 72);
                    v130 = v256;
                    *(_QWORD *)(v117 + 64) = v257;
                    *(_OWORD *)v121 = v130;
                    HIBYTE(v257) = 0;
                    LOBYTE(v256) = 0;
                    if (*(char *)(v117 + 95) < 0)
                      operator delete(*v129);
                    v131 = __p;
                    *(_QWORD *)(v117 + 88) = v259;
                    *(_OWORD *)v129 = v131;
                    HIBYTE(v259) = 0;
                    LOBYTE(__p) = 0;
                    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v117 + 96));
                    *(_OWORD *)(v117 + 96) = v260;
                    *(_QWORD *)(v117 + 112) = v261;
                    v260 = 0uLL;
                    v261 = 0;
                    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v117 + 120));
                    *(_OWORD *)(v117 + 120) = v262;
                    *(_QWORD *)(v117 + 136) = v263;
                    v262 = 0uLL;
                    v263 = 0;
                    *(_OWORD *)(v117 + 144) = v264;
                    v237 = &v262;
                    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v237);
                    v237 = &v260;
                    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v237);
                    if (SHIBYTE(v259) < 0)
                      operator delete((void *)__p);
                    if (SHIBYTE(v257) < 0)
                      operator delete((void *)v256);
                    if ((_QWORD)v252)
                    {
                      *((_QWORD *)&v252 + 1) = v252;
                      operator delete((void *)v252);
                    }
                  }
                }
                v105 = v106 - 1;
              }
              while (v106);
              v132 = v8 / 0xA0uLL;
              v220 = (__int128 *)(a1 + 48);
              v219 = (__int128 *)(a1 + 72);
              do
              {
                v133 = 0;
                v134 = a2;
                v135 = a1;
                v232 = *(std::string **)(a1 + 8);
                v233 = *(std::string **)a1;
                v237 = *(void **)a1;
                v238 = v232;
                v225 = *(std::string **)(a1 + 16);
                v239 = v225;
                *(_QWORD *)(a1 + 8) = 0;
                *(_QWORD *)(a1 + 16) = 0;
                *(_QWORD *)a1 = 0;
                v136 = *(_OWORD *)(a1 + 24);
                v241 = *(_DWORD *)(a1 + 40);
                v240 = v136;
                v137 = *v220;
                v243 = *(std::string **)(a1 + 64);
                v242 = v137;
                *(_QWORD *)v220 = 0;
                *(_QWORD *)(a1 + 56) = 0;
                *(_QWORD *)(a1 + 64) = 0;
                v138 = *v219;
                v245 = *(std::string **)(a1 + 88);
                v244 = v138;
                *(_QWORD *)v219 = 0;
                *(_QWORD *)(a1 + 80) = 0;
                *(_QWORD *)(a1 + 88) = 0;
                v246 = *(_OWORD *)(a1 + 96);
                v247 = *(std::string **)(a1 + 112);
                *(_QWORD *)(a1 + 96) = 0;
                *(_QWORD *)(a1 + 104) = 0;
                *(_QWORD *)(a1 + 112) = 0;
                v248 = *(_OWORD *)(a1 + 120);
                v249 = *(std::string **)(a1 + 136);
                *(_QWORD *)(a1 + 120) = 0;
                *(_QWORD *)(a1 + 128) = 0;
                *(_QWORD *)(a1 + 136) = 0;
                v250 = *(_OWORD *)(a1 + 144);
                do
                {
                  v139 = v133 + 1;
                  v140 = v135 + 160 * (v133 + 1);
                  v141 = 2 * v133;
                  v133 = (2 * v133) | 1;
                  v142 = v141 + 2;
                  if (v142 < v132 && *(float *)(v135 + 160 * v139 + 24) > *(float *)(v140 + 184))
                  {
                    v140 += 160;
                    v133 = v142;
                  }
                  v143 = *(void **)v135;
                  if (*(_QWORD *)v135)
                  {
                    *(_QWORD *)(v135 + 8) = v143;
                    operator delete(v143);
                    *(_QWORD *)v135 = 0;
                    *(_QWORD *)(v135 + 8) = 0;
                    *(_QWORD *)(v135 + 16) = 0;
                  }
                  *(_OWORD *)v135 = *(_OWORD *)v140;
                  *(_QWORD *)(v135 + 16) = *(_QWORD *)(v140 + 16);
                  *(_QWORD *)(v140 + 8) = 0;
                  *(_QWORD *)(v140 + 16) = 0;
                  *(_QWORD *)v140 = 0;
                  v144 = *(_OWORD *)(v140 + 24);
                  *(_DWORD *)(v135 + 40) = *(_DWORD *)(v140 + 40);
                  *(_OWORD *)(v135 + 24) = v144;
                  v145 = (void **)(v135 + 48);
                  if (*(char *)(v135 + 71) < 0)
                    operator delete(*v145);
                  v146 = (void **)(v140 + 48);
                  v147 = *(_OWORD *)(v140 + 48);
                  *(_QWORD *)(v135 + 64) = *(_QWORD *)(v140 + 64);
                  *(_OWORD *)v145 = v147;
                  *(_BYTE *)(v140 + 71) = 0;
                  *(_BYTE *)(v140 + 48) = 0;
                  v148 = (void **)(v135 + 72);
                  if (*(char *)(v135 + 95) < 0)
                    operator delete(*v148);
                  v149 = *(_OWORD *)(v140 + 72);
                  *(_QWORD *)(v135 + 88) = *(_QWORD *)(v140 + 88);
                  *(_OWORD *)v148 = v149;
                  *(_BYTE *)(v140 + 95) = 0;
                  *(_BYTE *)(v140 + 72) = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v135 + 96));
                  *(_OWORD *)(v135 + 96) = *(_OWORD *)(v140 + 96);
                  *(_QWORD *)(v135 + 112) = *(_QWORD *)(v140 + 112);
                  *(_QWORD *)(v140 + 96) = 0;
                  *(_QWORD *)(v140 + 104) = 0;
                  *(_QWORD *)(v140 + 112) = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v135 + 120));
                  *(_OWORD *)(v135 + 120) = *(_OWORD *)(v140 + 120);
                  *(_QWORD *)(v135 + 136) = *(_QWORD *)(v140 + 136);
                  *(_QWORD *)(v140 + 120) = 0;
                  *(_QWORD *)(v140 + 128) = 0;
                  *(_QWORD *)(v140 + 136) = 0;
                  *(_OWORD *)(v135 + 144) = *(_OWORD *)(v140 + 144);
                  v135 = v140;
                }
                while (v133 <= (uint64_t)((unint64_t)(v132 - 2) >> 1));
                v150 = (_OWORD *)(v140 + 24);
                v151 = (void **)(v140 + 72);
                v152 = *(void **)v140;
                a2 = (std::vector<std::string> *)((char *)a2 - 160);
                if ((std::vector<std::string>::pointer *)v140 == &v134[-7].__end_)
                {
                  v191 = v232;
                  if (v152)
                  {
                    *(_QWORD *)(v140 + 8) = v152;
                    operator delete(v152);
                    *(_QWORD *)v140 = 0;
                    *(_QWORD *)(v140 + 8) = 0;
                    *(_QWORD *)(v140 + 16) = 0;
                    v191 = v238;
                  }
                  *(_QWORD *)v140 = v233;
                  *(_QWORD *)(v140 + 8) = v191;
                  *(_QWORD *)(v140 + 16) = v239;
                  v237 = 0;
                  v238 = 0;
                  v239 = 0;
                  v192 = v240;
                  *(_DWORD *)(v140 + 40) = v241;
                  *v150 = v192;
                  if (*(char *)(v140 + 71) < 0)
                    operator delete(*v146);
                  v193 = v242;
                  *(_QWORD *)(v140 + 64) = v243;
                  *(_OWORD *)v146 = v193;
                  HIBYTE(v243) = 0;
                  LOBYTE(v242) = 0;
                  if (*(char *)(v140 + 95) < 0)
                    operator delete(*v151);
                  v194 = v244;
                  *(_QWORD *)(v140 + 88) = v245;
                  *(_OWORD *)v151 = v194;
                  HIBYTE(v245) = 0;
                  LOBYTE(v244) = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v140 + 96));
                  *(_OWORD *)(v140 + 96) = v246;
                  *(_QWORD *)(v140 + 112) = v247;
                  v246 = 0uLL;
                  v247 = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v140 + 120));
                  *(_OWORD *)(v140 + 120) = v248;
                  *(_QWORD *)(v140 + 136) = v249;
                  v248 = 0uLL;
                  v249 = 0;
                  *(_OWORD *)(v140 + 144) = v250;
                }
                else
                {
                  if (v152)
                  {
                    *(_QWORD *)(v140 + 8) = v152;
                    operator delete(v152);
                    *(_QWORD *)v140 = 0;
                    *(_QWORD *)(v140 + 8) = 0;
                    *(_QWORD *)(v140 + 16) = 0;
                  }
                  v223 = (__int128 *)(v140 + 144);
                  *(_OWORD *)v140 = *(_OWORD *)&v134[-7].__end_;
                  *(_QWORD *)(v140 + 16) = v134[-6].__begin_;
                  a2->__end_ = 0;
                  a2->__end_cap_.__value_ = 0;
                  a2->__begin_ = 0;
                  v153 = *(_OWORD *)&v134[-6].__end_;
                  *(_DWORD *)(v140 + 40) = v134[-5].__begin_;
                  *v150 = v153;
                  if (*(char *)(v140 + 71) < 0)
                    operator delete(*v146);
                  v221 = (float *)(v140 + 24);
                  v154 = (void **)&v134[-5].__end_;
                  v155 = *(_OWORD *)&v134[-5].__end_;
                  *(_QWORD *)(v140 + 64) = v134[-4].__begin_;
                  *(_OWORD *)v146 = v155;
                  HIBYTE(v134[-4].__begin_) = 0;
                  LOBYTE(v134[-5].__end_) = 0;
                  if (*(char *)(v140 + 95) < 0)
                    operator delete(*v151);
                  v156 = *(_OWORD *)&v134[-4].__end_;
                  *(_QWORD *)(v140 + 88) = v134[-3].__begin_;
                  v217 = (__int128 *)(v140 + 72);
                  *(_OWORD *)v151 = v156;
                  HIBYTE(v134[-3].__begin_) = 0;
                  LOBYTE(v134[-4].__end_) = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v140 + 96));
                  *(_OWORD *)(v140 + 96) = *(_OWORD *)&v134[-3].__end_;
                  *(_QWORD *)(v140 + 112) = v134[-2].__begin_;
                  v134[-3].__end_ = 0;
                  v134[-3].__end_cap_.__value_ = 0;
                  v134[-2].__begin_ = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v140 + 120));
                  v157 = &v134[-2].__end_;
                  *(_OWORD *)(v140 + 120) = *(_OWORD *)&v134[-2].__end_;
                  *(_QWORD *)(v140 + 136) = v134[-1].__begin_;
                  *v157 = 0;
                  v157[1] = 0;
                  v157[2] = 0;
                  *v223 = *(_OWORD *)&v134[-1].__end_;
                  end = v134[-7].__end_;
                  if (end)
                  {
                    v134[-7].__end_cap_.__value_ = end;
                    operator delete(end);
                  }
                  v224 = v132;
                  v159 = &v134[-6].__end_;
                  v134[-7].__end_ = v233;
                  v134[-7].__end_cap_.__value_ = v232;
                  v134[-6].__begin_ = v225;
                  v238 = 0;
                  v239 = 0;
                  v237 = 0;
                  v160 = v240;
                  *((_DWORD *)v159 + 4) = v241;
                  *(_OWORD *)v159 = v160;
                  if (SHIBYTE(v134[-4].__begin_) < 0)
                    operator delete(*v154);
                  v161 = (void **)&v134[-4].__end_;
                  v162 = v242;
                  v134[-4].__begin_ = v243;
                  *(_OWORD *)v154 = v162;
                  HIBYTE(v243) = 0;
                  LOBYTE(v242) = 0;
                  if (SHIBYTE(v134[-3].__begin_) < 0)
                    operator delete(*v161);
                  v163 = v244;
                  v134[-3].__begin_ = v245;
                  *(_OWORD *)v161 = v163;
                  HIBYTE(v245) = 0;
                  LOBYTE(v244) = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)((char *)v134 - 64));
                  *(_OWORD *)&v134[-3].__end_ = v246;
                  v134[-2].__begin_ = v247;
                  v246 = 0uLL;
                  v247 = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)((char *)v134 - 40));
                  *(_OWORD *)&v134[-2].__end_ = v248;
                  v134[-1].__begin_ = v249;
                  v248 = 0uLL;
                  v249 = 0;
                  *(_OWORD *)&v134[-1].__end_ = v250;
                  v164 = v140 + 160 - a1;
                  v132 = v224;
                  if (v164 >= 161)
                  {
                    v165 = (v164 / 0xA0uLL - 2) >> 1;
                    if (*(float *)(a1 + 160 * v165 + 24) > *v221)
                    {
                      v213 = *(_QWORD *)v140;
                      *(_QWORD *)&v252 = *(_QWORD *)v140;
                      v212 = *(_QWORD *)(v140 + 8);
                      *((_QWORD *)&v252 + 1) = v212;
                      v211 = *(_QWORD *)(v140 + 16);
                      v253 = v211;
                      *(_QWORD *)v140 = 0;
                      *(_QWORD *)(v140 + 8) = 0;
                      *(_QWORD *)(v140 + 16) = 0;
                      v166 = *(_OWORD *)v221;
                      v255 = *(_DWORD *)(v140 + 40);
                      v254 = v166;
                      v167 = *(_OWORD *)v146;
                      v257 = *(_QWORD *)(v140 + 64);
                      v256 = v167;
                      *(_QWORD *)(v140 + 56) = 0;
                      *(_QWORD *)(v140 + 64) = 0;
                      *v146 = 0;
                      v168 = *v217;
                      v259 = *(_QWORD *)(v140 + 88);
                      __p = v168;
                      *(_QWORD *)(v140 + 80) = 0;
                      *(_QWORD *)(v140 + 88) = 0;
                      *(_QWORD *)v217 = 0;
                      v226 = *(std::string **)(v140 + 96);
                      *(_QWORD *)&v260 = v226;
                      v218 = *(_QWORD *)(v140 + 104);
                      *((_QWORD *)&v260 + 1) = v218;
                      v215 = *(_QWORD *)(v140 + 112);
                      v261 = v215;
                      *(_QWORD *)(v140 + 104) = 0;
                      *(_QWORD *)(v140 + 112) = 0;
                      *(_QWORD *)(v140 + 96) = 0;
                      v222 = *(std::string **)(v140 + 120);
                      *(_QWORD *)&v262 = v222;
                      v216 = *(_QWORD *)(v140 + 128);
                      *((_QWORD *)&v262 + 1) = v216;
                      v214 = *(_QWORD *)(v140 + 136);
                      v263 = v214;
                      *(_QWORD *)(v140 + 128) = 0;
                      *(_QWORD *)(v140 + 136) = 0;
                      *(_QWORD *)(v140 + 120) = 0;
                      v264 = *v223;
                      v169 = *(float *)&v254;
                      do
                      {
                        v170 = v165;
                        v171 = *(void **)v140;
                        if (*(_QWORD *)v140)
                        {
                          *(_QWORD *)(v140 + 8) = v171;
                          operator delete(v171);
                          *(_QWORD *)v140 = 0;
                          *(_QWORD *)(v140 + 8) = 0;
                          *(_QWORD *)(v140 + 16) = 0;
                        }
                        v172 = a1 + 160 * v170;
                        *(_OWORD *)v140 = *(_OWORD *)v172;
                        *(_QWORD *)(v140 + 16) = *(_QWORD *)(v172 + 16);
                        *(_QWORD *)(v172 + 8) = 0;
                        *(_QWORD *)(v172 + 16) = 0;
                        *(_QWORD *)v172 = 0;
                        v173 = *(_OWORD *)(v172 + 24);
                        *(_DWORD *)(v140 + 40) = *(_DWORD *)(v172 + 40);
                        *(_OWORD *)(v140 + 24) = v173;
                        v174 = (void **)(v140 + 48);
                        if (*(char *)(v140 + 71) < 0)
                          operator delete(*v174);
                        v175 = *(_OWORD *)(v172 + 48);
                        *(_QWORD *)(v140 + 64) = *(_QWORD *)(v172 + 64);
                        *(_OWORD *)v174 = v175;
                        *(_BYTE *)(v172 + 71) = 0;
                        v234 = (void **)(v172 + 48);
                        *(_BYTE *)(v172 + 48) = 0;
                        v176 = (void **)(v140 + 72);
                        if (*(char *)(v140 + 95) < 0)
                          operator delete(*v176);
                        v177 = a1 + 160 * v170;
                        v178 = *(_OWORD *)(v177 + 72);
                        *(_QWORD *)(v140 + 88) = *(_QWORD *)(v177 + 88);
                        *(_OWORD *)v176 = v178;
                        *(_BYTE *)(v172 + 95) = 0;
                        *(_BYTE *)(v177 + 72) = 0;
                        std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v140 + 96));
                        v179 = (std::vector<std::string> *)(v177 + 96);
                        *(_OWORD *)(v140 + 96) = *(_OWORD *)(v177 + 96);
                        v180 = (_QWORD *)(v177 + 112);
                        *(_QWORD *)(v140 + 112) = *(_QWORD *)(v177 + 112);
                        *(_QWORD *)(v177 + 104) = 0;
                        *(_QWORD *)(v177 + 96) = 0;
                        *(_QWORD *)(v177 + 112) = 0;
                        std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v140 + 120));
                        v181 = (std::vector<std::string> *)(v177 + 120);
                        *(_OWORD *)(v140 + 120) = *(_OWORD *)(v177 + 120);
                        v182 = v177 + 136;
                        *(_QWORD *)(v140 + 136) = *(_QWORD *)(v177 + 136);
                        *(_QWORD *)(v177 + 128) = 0;
                        *(_QWORD *)(v177 + 136) = 0;
                        *(_QWORD *)(v177 + 120) = 0;
                        *(_OWORD *)(v140 + 144) = *(_OWORD *)(v177 + 144);
                        if (!v170)
                          break;
                        v165 = (v170 - 1) >> 1;
                        v140 = a1 + 160 * v170;
                      }
                      while (*(float *)(a1 + 160 * v165 + 24) > v169);
                      v183 = *(void **)v172;
                      if (*(_QWORD *)v172)
                      {
                        *(_QWORD *)(v172 + 8) = v183;
                        operator delete(v183);
                      }
                      *(_QWORD *)v172 = v213;
                      *(_QWORD *)(v172 + 8) = v212;
                      *(_QWORD *)(v172 + 16) = v211;
                      v253 = 0;
                      v252 = 0uLL;
                      v184 = v254;
                      *(_DWORD *)(v172 + 40) = v255;
                      *(_OWORD *)(v172 + 24) = v184;
                      if (*(char *)(v172 + 71) < 0)
                        operator delete(*v234);
                      v185 = v177 + 72;
                      v186 = v256;
                      *(_QWORD *)(v172 + 64) = v257;
                      *(_OWORD *)v234 = v186;
                      HIBYTE(v257) = 0;
                      LOBYTE(v256) = 0;
                      if (*(char *)(v172 + 95) < 0)
                        operator delete(*(void **)v185);
                      v187 = __p;
                      v188 = a1 + 160 * v170;
                      v189 = (_QWORD *)(v188 + 104);
                      v190 = (_QWORD *)(v188 + 128);
                      *(_QWORD *)(v185 + 16) = v259;
                      *(_OWORD *)v185 = v187;
                      HIBYTE(v259) = 0;
                      LOBYTE(__p) = 0;
                      std::vector<std::string>::__vdeallocate(v179);
                      v179->__begin_ = v226;
                      *v189 = v218;
                      *v180 = v215;
                      v260 = 0uLL;
                      v261 = 0;
                      std::vector<std::string>::__vdeallocate(v181);
                      v181->__begin_ = v222;
                      *v190 = v216;
                      *(_QWORD *)v182 = v214;
                      v262 = 0uLL;
                      v263 = 0;
                      *(_OWORD *)(v182 + 8) = v264;
                      v251 = (void **)&v262;
                      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v251);
                      v251 = (void **)&v260;
                      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v251);
                      if (SHIBYTE(v259) < 0)
                        operator delete((void *)__p);
                      v132 = v224;
                      if (SHIBYTE(v257) < 0)
                        operator delete((void *)v256);
                      if ((_QWORD)v252)
                      {
                        *((_QWORD *)&v252 + 1) = v252;
                        operator delete((void *)v252);
                      }
                    }
                  }
                }
                *(_QWORD *)&v252 = &v248;
                std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v252);
                *(_QWORD *)&v252 = &v246;
                std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v252);
                if (SHIBYTE(v245) < 0)
                  operator delete((void *)v244);
                if (SHIBYTE(v243) < 0)
                  operator delete((void *)v242);
                if (v237)
                {
                  v238 = (std::string *)v237;
                  operator delete(v237);
                }
              }
              while (v132-- > 2);
            }
            return;
          }
          v10 = (unint64_t)v9 >> 1;
          v11 = (std::vector<std::string> *)(v7 + 160 * ((unint64_t)v9 >> 1));
          if ((unint64_t)v8 <= 0x5000)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(v11, (std::vector<std::string> *)v7, p_end);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)v7, v11, p_end);
            v12 = 5 * v10;
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)(v7 + 160), (std::vector<std::string> *)(v7 + 32 * v12 - 160), (uint64_t)&a2[-14].__end_cap_);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)(v7 + 320), (std::vector<std::string> *)(v7 + 160 + 32 * v12), (uint64_t)&a2[-20]);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)(v7 + 32 * v12 - 160), v11, v7 + 160 + 32 * v12);
            std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)v7, (uint64_t)v11);
          }
          --a3;
          if ((a4 & 1) == 0 && *(float *)(v7 - 136) <= *(float *)(v7 + 24))
          {
            v252 = *(_OWORD *)v7;
            v253 = *(_QWORD *)(v7 + 16);
            *(_QWORD *)(v7 + 8) = 0;
            *(_QWORD *)(v7 + 16) = 0;
            *(_QWORD *)v7 = 0;
            v47 = *(_OWORD *)(v7 + 24);
            *((_DWORD *)v5 + 4) = *(_DWORD *)(v7 + 40);
            *v5 = v47;
            v48 = *(_OWORD *)(v7 + 48);
            v257 = *(_QWORD *)(v7 + 64);
            v256 = v48;
            *(_QWORD *)(v7 + 48) = 0;
            *(_QWORD *)(v7 + 56) = 0;
            *(_QWORD *)(v7 + 64) = 0;
            v49 = *(_OWORD *)(v7 + 72);
            v259 = *(_QWORD *)(v7 + 88);
            __p = v49;
            *(_QWORD *)(v7 + 72) = 0;
            *(_QWORD *)(v7 + 80) = 0;
            *(_QWORD *)(v7 + 88) = 0;
            v260 = *(_OWORD *)(v7 + 96);
            v261 = *(_QWORD *)(v7 + 112);
            *(_QWORD *)(v7 + 96) = 0;
            v50 = *(_OWORD *)(v7 + 120);
            *(_QWORD *)(v7 + 104) = 0;
            *(_QWORD *)(v7 + 112) = 0;
            v262 = v50;
            v263 = *(_QWORD *)(v7 + 136);
            *(_QWORD *)(v7 + 120) = 0;
            *(_QWORD *)(v7 + 128) = 0;
            *(_QWORD *)(v7 + 136) = 0;
            v264 = *(_OWORD *)(v7 + 144);
            v51 = *(float *)&v254;
            if (*(float *)&v254 <= *(float *)&a2[-6].__end_)
            {
              v54 = v7 + 160;
              do
              {
                v6 = v54;
                if (v54 >= (unint64_t)a2)
                  break;
                v54 += 160;
              }
              while (*(float *)&v254 <= *(float *)(v6 + 24));
            }
            else
            {
              v52 = v7;
              do
              {
                v6 = v52 + 160;
                v53 = *(float *)(v52 + 184);
                v52 += 160;
              }
              while (*(float *)&v254 <= v53);
            }
            v55 = (unint64_t)a2;
            if (v6 < (unint64_t)a2)
            {
              v56 = a2;
              do
              {
                v55 = (unint64_t)&v56[-7].__end_;
                v57 = *(float *)&v56[-6].__end_;
                v56 = (std::vector<std::string> *)((char *)v56 - 160);
              }
              while (*(float *)&v254 > v57);
            }
            while (v6 < v55)
            {
              std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)v6, v55);
              do
              {
                v58 = *(float *)(v6 + 184);
                v6 += 160;
              }
              while (v51 <= v58);
              do
              {
                v59 = *(float *)(v55 - 136);
                v55 -= 160;
              }
              while (v51 > v59);
            }
            v60 = (void **)(v6 - 160);
            if (v6 - 160 != v7)
            {
              v61 = *(void **)v7;
              if (*(_QWORD *)v7)
              {
                *(_QWORD *)(v7 + 8) = v61;
                operator delete(v61);
                *(_QWORD *)v7 = 0;
                *(_QWORD *)(v7 + 8) = 0;
                *(_QWORD *)(v7 + 16) = 0;
              }
              v62 = v5;
              v63 = (void **)(v7 + 48);
              *(_OWORD *)v7 = *(_OWORD *)(v6 - 160);
              *(_QWORD *)(v7 + 16) = *(_QWORD *)(v6 - 144);
              *(_QWORD *)(v6 - 152) = 0;
              *(_QWORD *)(v6 - 144) = 0;
              *v60 = 0;
              v64 = *(_OWORD *)(v6 - 136);
              *(_DWORD *)(v7 + 40) = *(_DWORD *)(v6 - 120);
              *(_OWORD *)(v7 + 24) = v64;
              if (*(char *)(v7 + 71) < 0)
                operator delete(*v63);
              v65 = (void **)(v7 + 72);
              v66 = *(_OWORD *)(v6 - 112);
              *(_QWORD *)(v7 + 64) = *(_QWORD *)(v6 - 96);
              *(_OWORD *)v63 = v66;
              *(_BYTE *)(v6 - 89) = 0;
              *(_BYTE *)(v6 - 112) = 0;
              if (*(char *)(v7 + 95) < 0)
                operator delete(*v65);
              v67 = *(_OWORD *)(v6 - 88);
              *(_QWORD *)(v7 + 88) = *(_QWORD *)(v6 - 72);
              *(_OWORD *)v65 = v67;
              *(_BYTE *)(v6 - 65) = 0;
              *(_BYTE *)(v6 - 88) = 0;
              std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v7 + 96));
              *(_OWORD *)(v7 + 96) = *(_OWORD *)(v6 - 64);
              *(_QWORD *)(v7 + 112) = *(_QWORD *)(v6 - 48);
              *(_QWORD *)(v6 - 64) = 0;
              *(_QWORD *)(v6 - 56) = 0;
              *(_QWORD *)(v6 - 48) = 0;
              std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v7 + 120));
              *(_OWORD *)(v7 + 120) = *(_OWORD *)(v6 - 40);
              *(_QWORD *)(v7 + 136) = *(_QWORD *)(v6 - 24);
              *(_QWORD *)(v6 - 40) = 0;
              *(_QWORD *)(v6 - 32) = 0;
              *(_QWORD *)(v6 - 24) = 0;
              *(_OWORD *)(v7 + 144) = *(_OWORD *)(v6 - 16);
              v5 = v62;
            }
            v68 = *v60;
            if (*v60)
            {
              *(_QWORD *)(v6 - 152) = v68;
              operator delete(v68);
              *v60 = 0;
              *(_QWORD *)(v6 - 152) = 0;
              *(_QWORD *)(v6 - 144) = 0;
            }
            *(_OWORD *)(v6 - 160) = v252;
            *(_QWORD *)(v6 - 144) = v253;
            v253 = 0;
            v252 = 0uLL;
            v69 = *v5;
            *(_DWORD *)(v6 - 120) = *((_DWORD *)v5 + 4);
            *(_OWORD *)(v6 - 136) = v69;
            v70 = (void **)(v6 - 112);
            if (*(char *)(v6 - 89) < 0)
              operator delete(*v70);
            v71 = v256;
            *(_QWORD *)(v6 - 96) = v257;
            *(_OWORD *)v70 = v71;
            HIBYTE(v257) = 0;
            LOBYTE(v256) = 0;
            v72 = (void **)(v6 - 88);
            if (*(char *)(v6 - 65) < 0)
              operator delete(*v72);
            v73 = __p;
            *(_QWORD *)(v6 - 72) = v259;
            *(_OWORD *)v72 = v73;
            HIBYTE(v259) = 0;
            LOBYTE(__p) = 0;
            std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v6 - 64));
            *(_OWORD *)(v6 - 64) = v260;
            *(_QWORD *)(v6 - 48) = v261;
            v260 = 0uLL;
            v261 = 0;
            std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v6 - 40));
            *(_OWORD *)(v6 - 40) = v262;
            *(_QWORD *)(v6 - 24) = v263;
            v262 = 0uLL;
            v263 = 0;
            *(_OWORD *)(v6 - 16) = v264;
            v237 = &v262;
            std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v237);
            v237 = &v260;
            std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v237);
            if (SHIBYTE(v259) < 0)
              operator delete((void *)__p);
            if (SHIBYTE(v257) < 0)
              operator delete((void *)v256);
            if ((_QWORD)v252)
            {
              *((_QWORD *)&v252 + 1) = v252;
              operator delete((void *)v252);
            }
            goto LABEL_51;
          }
          v252 = *(_OWORD *)v7;
          v253 = *(_QWORD *)(v7 + 16);
          *(_QWORD *)(v7 + 8) = 0;
          *(_QWORD *)(v7 + 16) = 0;
          *(_QWORD *)v7 = 0;
          v13 = v7 + 24;
          v14 = *(_OWORD *)(v7 + 24);
          *((_DWORD *)v5 + 4) = *(_DWORD *)(v7 + 40);
          *v5 = v14;
          v15 = v7 + 48;
          v16 = *(_OWORD *)(v7 + 48);
          v257 = *(_QWORD *)(v7 + 64);
          v256 = v16;
          *(_QWORD *)(v7 + 48) = 0;
          *(_QWORD *)(v7 + 56) = 0;
          *(_QWORD *)(v7 + 64) = 0;
          v17 = v7 + 72;
          v18 = *(_OWORD *)(v7 + 72);
          v259 = *(_QWORD *)(v7 + 88);
          __p = v18;
          *(_QWORD *)(v7 + 72) = 0;
          *(_QWORD *)(v7 + 80) = 0;
          *(_QWORD *)(v7 + 88) = 0;
          v19 = (std::vector<std::string> *)(v7 + 96);
          v260 = *(_OWORD *)(v7 + 96);
          v261 = *(_QWORD *)(v7 + 112);
          *(_QWORD *)(v7 + 96) = 0;
          v20 = (std::vector<std::string> *)(v7 + 120);
          v21 = *(_OWORD *)(v7 + 120);
          *(_QWORD *)(v7 + 104) = 0;
          *(_QWORD *)(v7 + 112) = 0;
          v262 = v21;
          v263 = *(_QWORD *)(v7 + 136);
          *(_QWORD *)(v7 + 120) = 0;
          *(_QWORD *)(v7 + 128) = 0;
          *(_QWORD *)(v7 + 136) = 0;
          v22 = (_OWORD *)(v7 + 144);
          v264 = *(_OWORD *)(v7 + 144);
          v23 = v7;
          v24 = *(float *)&v254;
          do
          {
            v25 = v23;
            v23 += 160;
          }
          while (*(float *)(v25 + 184) > *(float *)&v254);
          v26 = a2;
          if (v25 == v7)
          {
            v29 = a2;
            while (v23 < (unint64_t)v29)
            {
              v27 = (unint64_t)&v29[-7].__end_;
              v30 = *(float *)&v29[-6].__end_;
              v29 = (std::vector<std::string> *)((char *)v29 - 160);
              if (v30 > *(float *)&v254)
                goto LABEL_21;
            }
            v27 = (unint64_t)v29;
          }
          else
          {
            do
            {
              v27 = (unint64_t)&v26[-7].__end_;
              v28 = *(float *)&v26[-6].__end_;
              v26 = (std::vector<std::string> *)((char *)v26 - 160);
            }
            while (v28 <= *(float *)&v254);
          }
LABEL_21:
          v230 = v22;
          v31 = v15;
          v6 = v23;
          if (v23 < v27)
          {
            v32 = v27;
            do
            {
              std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)v6, v32);
              do
              {
                v33 = *(float *)(v6 + 184);
                v6 += 160;
              }
              while (v33 > v24);
              do
              {
                v34 = *(float *)(v32 - 136);
                v32 -= 160;
              }
              while (v34 <= v24);
            }
            while (v6 < v32);
          }
          v35 = (void **)(v6 - 160);
          if (v6 - 160 != a1)
          {
            v36 = *(std::string **)a1;
            if (*(_QWORD *)a1)
            {
              *(_QWORD *)(a1 + 8) = v36;
              operator delete(v36);
              *(_QWORD *)a1 = 0;
              *(_QWORD *)(a1 + 8) = 0;
              *(_QWORD *)(a1 + 16) = 0;
            }
            *(_OWORD *)a1 = *(_OWORD *)(v6 - 160);
            *(_QWORD *)(a1 + 16) = *(_QWORD *)(v6 - 144);
            *(_QWORD *)(v6 - 152) = 0;
            *(_QWORD *)(v6 - 144) = 0;
            *v35 = 0;
            v37 = *(_OWORD *)(v6 - 136);
            *(_DWORD *)(v13 + 16) = *(_DWORD *)(v6 - 120);
            *(_OWORD *)v13 = v37;
            if (*(char *)(a1 + 71) < 0)
              operator delete(*(void **)v31);
            v38 = *(_OWORD *)(v6 - 112);
            *(_QWORD *)(v31 + 16) = *(_QWORD *)(v6 - 96);
            *(_OWORD *)v31 = v38;
            *(_BYTE *)(v6 - 89) = 0;
            *(_BYTE *)(v6 - 112) = 0;
            if (*(char *)(a1 + 95) < 0)
              operator delete(*(void **)v17);
            v39 = *(_OWORD *)(v6 - 88);
            *(_QWORD *)(v17 + 16) = *(_QWORD *)(v6 - 72);
            *(_OWORD *)v17 = v39;
            *(_BYTE *)(v6 - 65) = 0;
            *(_BYTE *)(v6 - 88) = 0;
            std::vector<std::string>::__vdeallocate(v19);
            *(_OWORD *)(a1 + 96) = *(_OWORD *)(v6 - 64);
            *(_QWORD *)(a1 + 112) = *(_QWORD *)(v6 - 48);
            *(_QWORD *)(v6 - 64) = 0;
            *(_QWORD *)(v6 - 56) = 0;
            *(_QWORD *)(v6 - 48) = 0;
            std::vector<std::string>::__vdeallocate(v20);
            *(_OWORD *)(a1 + 120) = *(_OWORD *)(v6 - 40);
            *(_QWORD *)(a1 + 136) = *(_QWORD *)(v6 - 24);
            *(_QWORD *)(v6 - 40) = 0;
            *(_QWORD *)(v6 - 32) = 0;
            *(_QWORD *)(v6 - 24) = 0;
            *v230 = *(_OWORD *)(v6 - 16);
          }
          v40 = *v35;
          if (*v35)
          {
            *(_QWORD *)(v6 - 152) = v40;
            operator delete(v40);
            *v35 = 0;
            *(_QWORD *)(v6 - 152) = 0;
            *(_QWORD *)(v6 - 144) = 0;
          }
          *(_OWORD *)(v6 - 160) = v252;
          *(_QWORD *)(v6 - 144) = v253;
          v253 = 0;
          v252 = 0uLL;
          v5 = &v254;
          v41 = v254;
          *(_DWORD *)(v6 - 120) = v255;
          *(_OWORD *)(v6 - 136) = v41;
          v42 = (void **)(v6 - 112);
          if (*(char *)(v6 - 89) < 0)
            operator delete(*v42);
          v43 = v256;
          *(_QWORD *)(v6 - 96) = v257;
          *(_OWORD *)v42 = v43;
          HIBYTE(v257) = 0;
          LOBYTE(v256) = 0;
          v44 = (void **)(v6 - 88);
          if (*(char *)(v6 - 65) < 0)
            operator delete(*v44);
          v45 = __p;
          *(_QWORD *)(v6 - 72) = v259;
          *(_OWORD *)v44 = v45;
          HIBYTE(v259) = 0;
          LOBYTE(__p) = 0;
          std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v6 - 64));
          *(_OWORD *)(v6 - 64) = v260;
          *(_QWORD *)(v6 - 48) = v261;
          v260 = 0uLL;
          v261 = 0;
          std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v6 - 40));
          *(_OWORD *)(v6 - 40) = v262;
          *(_QWORD *)(v6 - 24) = v263;
          v262 = 0uLL;
          v263 = 0;
          *(_OWORD *)(v6 - 16) = v264;
          v237 = &v262;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v237);
          v237 = &v260;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v237);
          if (SHIBYTE(v259) < 0)
            operator delete((void *)__p);
          if (SHIBYTE(v257) < 0)
            operator delete((void *)v256);
          if ((_QWORD)v252)
          {
            *((_QWORD *)&v252 + 1) = v252;
            operator delete((void *)v252);
          }
          if (v23 < v27)
            goto LABEL_50;
          v46 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)a1, (std::vector<std::string> *)(v6 - 160));
          if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)v6, a2))
          {
            if (v46)
              continue;
LABEL_50:
            std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*,false>(a1, v6 - 160, a3, a4 & 1);
LABEL_51:
            a4 = 0;
            continue;
          }
          a2 = (std::vector<std::string> *)(v6 - 160);
          if (v46)
            return;
          goto LABEL_2;
        }
        if ((a4 & 1) != 0)
        {
          if ((std::vector<std::string> *)v7 != a2)
          {
            v79 = v7 + 160;
            if ((std::vector<std::string> *)(v7 + 160) != a2)
            {
              v80 = 0;
              v81 = v7;
              do
              {
                v82 = v79;
                if (*(float *)(v81 + 184) > *(float *)(v81 + 24))
                {
                  v252 = *(_OWORD *)v79;
                  v253 = *(_QWORD *)(v81 + 176);
                  *(_QWORD *)v79 = 0;
                  *(_QWORD *)(v79 + 8) = 0;
                  *(_QWORD *)(v79 + 16) = 0;
                  v254 = *(_OWORD *)(v81 + 184);
                  v255 = *(_DWORD *)(v81 + 200);
                  v256 = *(_OWORD *)(v81 + 208);
                  v257 = *(_QWORD *)(v81 + 224);
                  *(_QWORD *)(v81 + 208) = 0;
                  *(_QWORD *)(v81 + 216) = 0;
                  __p = *(_OWORD *)(v81 + 232);
                  v259 = *(_QWORD *)(v81 + 248);
                  *(_QWORD *)(v81 + 224) = 0;
                  *(_QWORD *)(v81 + 232) = 0;
                  *(_QWORD *)(v81 + 240) = 0;
                  *(_QWORD *)(v81 + 248) = 0;
                  v260 = *(_OWORD *)(v81 + 256);
                  v83 = *(_QWORD *)(v81 + 272);
                  *(_QWORD *)(v81 + 256) = 0;
                  *(_QWORD *)(v81 + 264) = 0;
                  v262 = *(_OWORD *)(v81 + 280);
                  v84 = *(_QWORD *)(v81 + 296);
                  v261 = v83;
                  v263 = v84;
                  *(_QWORD *)(v81 + 272) = 0;
                  *(_QWORD *)(v81 + 280) = 0;
                  *(_QWORD *)(v81 + 288) = 0;
                  *(_QWORD *)(v81 + 296) = 0;
                  v85 = v80;
                  v264 = *(_OWORD *)(v81 + 304);
                  while (1)
                  {
                    v86 = a1 + v85;
                    v87 = *(void **)(a1 + v85 + 160);
                    if (v87)
                    {
                      *(_QWORD *)(v86 + 168) = v87;
                      operator delete(v87);
                      *(_QWORD *)(v86 + 176) = 0;
                    }
                    *(_OWORD *)(v86 + 160) = *(_OWORD *)v86;
                    *(_QWORD *)(v86 + 176) = *(_QWORD *)(v86 + 16);
                    *(_QWORD *)(v86 + 8) = 0;
                    *(_QWORD *)(v86 + 16) = 0;
                    *(_QWORD *)v86 = 0;
                    *(_OWORD *)(v86 + 184) = *(_OWORD *)(v86 + 24);
                    *(_DWORD *)(v86 + 200) = *(_DWORD *)(v86 + 40);
                    v88 = (void **)(v86 + 208);
                    if (*(char *)(v86 + 231) < 0)
                      operator delete(*v88);
                    v89 = a1 + v85;
                    *(_OWORD *)v88 = *(_OWORD *)(v86 + 48);
                    *(_QWORD *)(v86 + 224) = *(_QWORD *)(v86 + 64);
                    *(_BYTE *)(a1 + v85 + 71) = 0;
                    *(_BYTE *)(v86 + 48) = 0;
                    v90 = (void **)(a1 + v85 + 232);
                    if (*(char *)(a1 + v85 + 255) < 0)
                      operator delete(*v90);
                    *(_OWORD *)v90 = *(_OWORD *)(v89 + 72);
                    *(_QWORD *)(a1 + v85 + 248) = *(_QWORD *)(v89 + 88);
                    *(_BYTE *)(v89 + 95) = 0;
                    *(_BYTE *)(v89 + 72) = 0;
                    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v89 + 256));
                    *(_OWORD *)(v89 + 256) = *(_OWORD *)(v89 + 96);
                    *(_QWORD *)(v89 + 272) = *(_QWORD *)(v89 + 112);
                    *(_QWORD *)(v89 + 104) = 0;
                    *(_QWORD *)(v89 + 112) = 0;
                    *(_QWORD *)(v89 + 96) = 0;
                    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v89 + 280));
                    *(_OWORD *)(v89 + 280) = *(_OWORD *)(v89 + 120);
                    *(_QWORD *)(v89 + 296) = *(_QWORD *)(v89 + 136);
                    *(_QWORD *)(v89 + 128) = 0;
                    *(_QWORD *)(v89 + 136) = 0;
                    *(_QWORD *)(v89 + 120) = 0;
                    *(_OWORD *)(v89 + 304) = *(_OWORD *)(v89 + 144);
                    if (!v85)
                      break;
                    v91 = a1 + v85;
                    v92 = *(float *)(a1 + v85 - 136);
                    v85 -= 160;
                    if (*(float *)&v254 <= v92)
                    {
                      v93 = v91 + 24;
                      v94 = v91 + 48;
                      v95 = v91 + 72;
                      v96 = (std::vector<std::string> *)(v91 + 96);
                      v97 = (std::vector<std::string> *)(v91 + 120);
                      v98 = (_OWORD *)(v91 + 144);
                      v99 = a1 + v85 + 160;
                      goto LABEL_116;
                    }
                  }
                  v93 = a1 + 24;
                  v94 = a1 + 48;
                  v99 = a1;
                  v95 = a1 + 72;
                  v96 = (std::vector<std::string> *)(a1 + 96);
                  v97 = (std::vector<std::string> *)(a1 + 120);
                  v98 = (_OWORD *)(a1 + 144);
LABEL_116:
                  v100 = *(void **)v99;
                  if (*(_QWORD *)v99)
                  {
                    *(_QWORD *)(v99 + 8) = v100;
                    operator delete(v100);
                    *(_QWORD *)v99 = 0;
                    *(_QWORD *)(v99 + 8) = 0;
                    *(_QWORD *)(v99 + 16) = 0;
                  }
                  *(_OWORD *)v99 = v252;
                  *(_QWORD *)(v99 + 16) = v253;
                  v252 = 0uLL;
                  v253 = 0;
                  v101 = v254;
                  *(_DWORD *)(v93 + 16) = v255;
                  *(_OWORD *)v93 = v101;
                  if (*(char *)(v99 + 71) < 0)
                    operator delete(*(void **)v94);
                  v102 = v256;
                  *(_QWORD *)(v94 + 16) = v257;
                  *(_OWORD *)v94 = v102;
                  HIBYTE(v257) = 0;
                  LOBYTE(v256) = 0;
                  if (*(char *)(v99 + 95) < 0)
                    operator delete(*(void **)v95);
                  v103 = __p;
                  *(_QWORD *)(v95 + 16) = v259;
                  *(_OWORD *)v95 = v103;
                  HIBYTE(v259) = 0;
                  LOBYTE(__p) = 0;
                  std::vector<std::string>::__vdeallocate(v96);
                  v96->__begin_ = (std::vector<std::string>::pointer)v260;
                  *(_QWORD *)(v99 + 104) = *((_QWORD *)&v260 + 1);
                  *(_QWORD *)(v99 + 112) = v261;
                  v260 = 0uLL;
                  v261 = 0;
                  std::vector<std::string>::__vdeallocate(v97);
                  v97->__begin_ = (std::vector<std::string>::pointer)v262;
                  *(_QWORD *)(v99 + 128) = *((_QWORD *)&v262 + 1);
                  *(_QWORD *)(v99 + 136) = v263;
                  v262 = 0uLL;
                  v263 = 0;
                  *v98 = v264;
                  v237 = &v262;
                  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v237);
                  v237 = &v260;
                  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v237);
                  if (SHIBYTE(v259) < 0)
                    operator delete((void *)__p);
                  if (SHIBYTE(v257) < 0)
                    operator delete((void *)v256);
                  if ((_QWORD)v252)
                  {
                    *((_QWORD *)&v252 + 1) = v252;
                    operator delete((void *)v252);
                  }
                }
                v79 = v82 + 160;
                v80 += 160;
                v81 = v82;
              }
              while ((std::vector<std::string> *)(v82 + 160) != a2);
            }
          }
        }
        else if ((std::vector<std::string> *)v7 != a2)
        {
          v196 = v7 + 160;
          if ((std::vector<std::string> *)(v7 + 160) != a2)
          {
            do
            {
              v197 = v196;
              v198 = a1;
              if (*(float *)(a1 + 184) > *(float *)(a1 + 24))
              {
                v252 = *(_OWORD *)v196;
                v253 = *(_QWORD *)(a1 + 176);
                *(_QWORD *)v196 = 0;
                *(_QWORD *)(v196 + 8) = 0;
                *(_QWORD *)(v196 + 16) = 0;
                v254 = *(_OWORD *)(a1 + 184);
                v255 = *(_DWORD *)(a1 + 200);
                v256 = *(_OWORD *)(a1 + 208);
                v257 = *(_QWORD *)(a1 + 224);
                *(_QWORD *)(a1 + 208) = 0;
                *(_QWORD *)(a1 + 216) = 0;
                __p = *(_OWORD *)(a1 + 232);
                v259 = *(_QWORD *)(a1 + 248);
                *(_QWORD *)(a1 + 224) = 0;
                *(_QWORD *)(a1 + 232) = 0;
                *(_QWORD *)(a1 + 240) = 0;
                *(_QWORD *)(a1 + 248) = 0;
                v260 = *(_OWORD *)(a1 + 256);
                v199 = *(_QWORD *)(a1 + 272);
                *(_QWORD *)(a1 + 256) = 0;
                *(_QWORD *)(a1 + 264) = 0;
                v262 = *(_OWORD *)(a1 + 280);
                v200 = *(_QWORD *)(a1 + 296);
                v261 = v199;
                v263 = v200;
                *(_QWORD *)(a1 + 272) = 0;
                *(_QWORD *)(a1 + 280) = 0;
                *(_QWORD *)(a1 + 288) = 0;
                *(_QWORD *)(a1 + 296) = 0;
                v264 = *(_OWORD *)(a1 + 304);
                do
                {
                  v201 = v198;
                  v202 = *(void **)(v198 + 160);
                  if (v202)
                  {
                    *(_QWORD *)(v198 + 168) = v202;
                    operator delete(v202);
                    *(_QWORD *)(v201 + 176) = 0;
                  }
                  *(_OWORD *)(v201 + 160) = *(_OWORD *)v201;
                  *(_QWORD *)(v201 + 176) = *(_QWORD *)(v201 + 16);
                  *(_QWORD *)(v201 + 8) = 0;
                  *(_QWORD *)(v201 + 16) = 0;
                  *(_QWORD *)v201 = 0;
                  *(_OWORD *)(v201 + 184) = *(_OWORD *)(v201 + 24);
                  *(_DWORD *)(v201 + 200) = *(_DWORD *)(v201 + 40);
                  v203 = (void **)(v201 + 208);
                  if (*(char *)(v201 + 231) < 0)
                    operator delete(*v203);
                  *(_OWORD *)v203 = *(_OWORD *)(v201 + 48);
                  *(_QWORD *)(v201 + 224) = *(_QWORD *)(v201 + 64);
                  *(_BYTE *)(v201 + 71) = 0;
                  *(_BYTE *)(v201 + 48) = 0;
                  v204 = (void **)(v201 + 232);
                  if (*(char *)(v201 + 255) < 0)
                    operator delete(*v204);
                  *(_OWORD *)v204 = *(_OWORD *)(v201 + 72);
                  *(_QWORD *)(v201 + 248) = *(_QWORD *)(v201 + 88);
                  *(_BYTE *)(v201 + 95) = 0;
                  *(_BYTE *)(v201 + 72) = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v201 + 256));
                  *(_OWORD *)(v201 + 256) = *(_OWORD *)(v201 + 96);
                  *(_QWORD *)(v201 + 272) = *(_QWORD *)(v201 + 112);
                  *(_QWORD *)(v201 + 104) = 0;
                  *(_QWORD *)(v201 + 112) = 0;
                  *(_QWORD *)(v201 + 96) = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v201 + 280));
                  *(_OWORD *)(v201 + 280) = *(_OWORD *)(v201 + 120);
                  *(_QWORD *)(v201 + 296) = *(_QWORD *)(v201 + 136);
                  *(_QWORD *)(v201 + 128) = 0;
                  *(_QWORD *)(v201 + 136) = 0;
                  *(_QWORD *)(v201 + 120) = 0;
                  *(_OWORD *)(v201 + 304) = *(_OWORD *)(v201 + 144);
                  v198 = v201 - 160;
                }
                while (*(float *)&v254 > *(float *)(v201 - 136));
                v205 = *(void **)v201;
                if (*(_QWORD *)v201)
                {
                  *(_QWORD *)(v201 + 8) = v205;
                  operator delete(v205);
                  *(_QWORD *)v201 = 0;
                  *(_QWORD *)(v201 + 8) = 0;
                  *(_QWORD *)(v201 + 16) = 0;
                }
                v206 = (void **)(v201 + 48);
                *(_OWORD *)v201 = v252;
                *(_QWORD *)(v201 + 16) = v253;
                v253 = 0;
                v252 = 0uLL;
                v207 = v254;
                *(_DWORD *)(v201 + 40) = v255;
                *(_OWORD *)(v201 + 24) = v207;
                if (*(char *)(v201 + 71) < 0)
                  operator delete(*v206);
                v208 = (void **)(v201 + 72);
                v209 = v256;
                *(_QWORD *)(v201 + 64) = v257;
                *(_OWORD *)v206 = v209;
                HIBYTE(v257) = 0;
                LOBYTE(v256) = 0;
                if (*(char *)(v201 + 95) < 0)
                  operator delete(*v208);
                v210 = __p;
                *(_QWORD *)(v201 + 88) = v259;
                *(_OWORD *)v208 = v210;
                HIBYTE(v259) = 0;
                LOBYTE(__p) = 0;
                std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v201 + 96));
                *(_OWORD *)(v201 + 96) = v260;
                *(_QWORD *)(v201 + 112) = v261;
                v260 = 0uLL;
                v261 = 0;
                std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v201 + 120));
                *(_OWORD *)(v201 + 120) = v262;
                *(_QWORD *)(v201 + 136) = v263;
                v262 = 0uLL;
                v263 = 0;
                *(_OWORD *)(v201 + 144) = v264;
                v237 = &v262;
                std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v237);
                v237 = &v260;
                std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v237);
                if (SHIBYTE(v259) < 0)
                  operator delete((void *)__p);
                if (SHIBYTE(v257) < 0)
                  operator delete((void *)v256);
                if ((_QWORD)v252)
                {
                  *((_QWORD *)&v252 + 1) = v252;
                  operator delete((void *)v252);
                }
              }
              v196 = v197 + 160;
              a1 = v197;
            }
            while ((std::vector<std::string> *)(v197 + 160) != a2);
          }
        }
        return;
    }
  }
}

void std::__function::__func<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0,std::allocator<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0,std::allocator<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1EA0FD6A8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0,std::allocator<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FD6A8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

float std::__function::__func<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0,std::allocator<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::operator()(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  float v14;
  uint64_t v15;
  float result;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t *v21;

  v5 = (uint64_t *)a1[1];
  v4 = a1[2];
  v6 = v5[1];
  v7 = v5[2];
  if (v6 >= v7)
  {
    v9 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - *v5) >> 5);
    if (v9 + 1 > 0x199999999999999)
      abort();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *v5) >> 5);
    v11 = 2 * v10;
    if (2 * v10 <= v9 + 1)
      v11 = v9 + 1;
    if (v10 >= 0xCCCCCCCCCCCCCCLL)
      v12 = 0x199999999999999;
    else
      v12 = v11;
    v21 = v5 + 2;
    if (v12)
      v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v12);
    else
      v13 = 0;
    v17 = v12;
    v18 = v12 + 160 * v9;
    v20 = v12 + 160 * v13;
    std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo const&,KB::LanguageModel::PredictionInfo*>(v18, a2);
    v19 = v18 + 160;
    std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer(v5, &v17);
    v8 = v5[1];
    std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)&v17);
  }
  else
  {
    v8 = std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo const&,KB::LanguageModel::PredictionInfo*>(v6, a2)+ 160;
  }
  v5[1] = v8;
  v14 = (*(float (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v4 + 432))(v4, *(unsigned int *)(a2 + 144), a1[3]);
  v15 = *(_QWORD *)(a1[1] + 8);
  result = v14 * *(float *)(v15 - 136);
  *(float *)(v15 - 136) = result;
  return result;
}

void std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(std::vector<std::string> *this, uint64_t a2)
{
  std::vector<std::string> *v4;
  std::string *v5;
  std::vector<std::string>::pointer v6;
  std::vector<std::string> *v7;
  std::vector<std::string>::pointer v8;
  std::vector<std::string> *v9;
  std::vector<std::string>::pointer v10;
  std::string *v11;
  __int128 v12;
  __int128 *v13;
  std::vector<std::string> *v14;
  __int128 v15;
  __int128 v16;
  void *v17;
  void **v18;
  std::string *value;
  std::vector<std::string>::pointer end;
  std::vector<std::string>::pointer begin;
  std::string *v22;
  std::vector<std::string>::pointer v23;
  std::string *v24;
  std::vector<std::string>::pointer v25;
  std::vector<std::string>::pointer v26;
  std::vector<std::string>::pointer v27;
  __int128 v28;
  int v29;
  std::vector<std::string> v30;
  void *__p[2];
  std::string *v32;
  std::vector<std::string>::pointer v33;
  std::vector<std::string>::pointer v34;
  std::string *v35;
  std::vector<std::string>::pointer v36;
  std::vector<std::string>::pointer v37;
  std::string *v38;
  __int128 v39;
  void **v40[2];

  end = this->__end_;
  begin = this->__begin_;
  value = this->__end_cap_.__value_;
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  v28 = *(_OWORD *)&this[1].__begin_;
  v29 = (int)this[1].__end_cap_.__value_;
  v4 = this + 2;
  v30 = this[2];
  this[2].__begin_ = 0;
  this[2].__end_ = 0;
  v5 = this[3].__end_cap_.__value_;
  *(_OWORD *)__p = *(_OWORD *)&this[3].__begin_;
  this[2].__end_cap_.__value_ = 0;
  this[3].__begin_ = 0;
  v7 = this + 4;
  v6 = this[4].__begin_;
  this[3].__end_ = 0;
  this[3].__end_cap_.__value_ = 0;
  v32 = v5;
  v33 = v6;
  v26 = v6;
  v22 = this[4].__end_cap_.__value_;
  v23 = this[4].__end_;
  v34 = v23;
  v35 = v22;
  this[4].__begin_ = 0;
  v9 = this + 5;
  v8 = this[5].__begin_;
  this[4].__end_ = 0;
  this[4].__end_cap_.__value_ = 0;
  v10 = this[5].__end_;
  v11 = this[5].__end_cap_.__value_;
  v27 = v8;
  v36 = v8;
  v37 = v10;
  v24 = v11;
  v25 = v10;
  v38 = v11;
  this[5].__begin_ = 0;
  this[5].__end_ = 0;
  this[5].__end_cap_.__value_ = 0;
  v39 = *(_OWORD *)&this[6].__begin_;
  *this = *(std::vector<std::string> *)a2;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v12 = *(_OWORD *)(a2 + 24);
  LODWORD(this[1].__end_cap_.__value_) = *(_DWORD *)(a2 + 40);
  *(_OWORD *)&this[1].__begin_ = v12;
  v13 = (__int128 *)(a2 + 48);
  if (SHIBYTE(this[2].__end_cap_.__value_) < 0)
    operator delete(v4->__begin_);
  v14 = this + 3;
  v15 = *v13;
  v4->__end_cap_.__value_ = (std::string *)*((_QWORD *)v13 + 2);
  *(_OWORD *)&v4->__begin_ = v15;
  *(_BYTE *)(a2 + 71) = 0;
  *(_BYTE *)(a2 + 48) = 0;
  if (SHIBYTE(this[3].__end_cap_.__value_) < 0)
    operator delete(v14->__begin_);
  v16 = *(_OWORD *)(a2 + 72);
  this[3].__end_cap_.__value_ = *(std::string **)(a2 + 88);
  *(_OWORD *)&v14->__begin_ = v16;
  *(_BYTE *)(a2 + 95) = 0;
  *(_BYTE *)(a2 + 72) = 0;
  std::vector<std::string>::__vdeallocate(v7);
  *(_OWORD *)&this[4].__begin_ = *(_OWORD *)(a2 + 96);
  this[4].__end_cap_.__value_ = *(std::string **)(a2 + 112);
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  std::vector<std::string>::__vdeallocate(v9);
  *(_OWORD *)&this[5].__begin_ = *(_OWORD *)(a2 + 120);
  this[5].__end_cap_.__value_ = *(std::string **)(a2 + 136);
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  *(_QWORD *)(a2 + 136) = 0;
  *(_OWORD *)&this[6].__begin_ = *(_OWORD *)(a2 + 144);
  v17 = *(void **)a2;
  if (*(_QWORD *)a2)
  {
    *(_QWORD *)(a2 + 8) = v17;
    operator delete(v17);
  }
  *(_QWORD *)a2 = begin;
  *(_QWORD *)(a2 + 8) = end;
  *(_QWORD *)(a2 + 16) = value;
  *(_OWORD *)(a2 + 24) = v28;
  *(_DWORD *)(a2 + 40) = v29;
  if (*(char *)(a2 + 71) < 0)
    operator delete(*(void **)v13);
  v18 = (void **)(a2 + 72);
  *(std::vector<std::string> *)v13 = v30;
  if (*(char *)(a2 + 95) < 0)
    operator delete(*v18);
  *(_OWORD *)v18 = *(_OWORD *)__p;
  *(_QWORD *)(a2 + 88) = v32;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(a2 + 96));
  *(_QWORD *)(a2 + 96) = v26;
  *(_QWORD *)(a2 + 104) = v23;
  *(_QWORD *)(a2 + 112) = v22;
  v34 = 0;
  v35 = 0;
  v33 = 0;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(a2 + 120));
  *(_QWORD *)(a2 + 120) = v27;
  *(_QWORD *)(a2 + 128) = v25;
  *(_QWORD *)(a2 + 136) = v24;
  v37 = 0;
  v38 = 0;
  v36 = 0;
  *(_OWORD *)(a2 + 144) = v39;
  v40[0] = (void **)&v36;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v40);
  v40[0] = (void **)&v33;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v40);
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(std::vector<std::string> *this, std::vector<std::string> *a2, uint64_t a3)
{
  std::vector<std::string> *v5;
  float v6;
  float v7;
  std::vector<std::string> *v8;

  v5 = this;
  v6 = *(float *)&a2[1].__begin_;
  v7 = *(float *)(a3 + 24);
  if (v6 > *(float *)&this[1].__begin_)
  {
    if (v7 <= v6)
    {
      std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(this, (uint64_t)a2);
      if (*(float *)(a3 + 24) <= *(float *)&a2[1].__begin_)
        return;
      this = a2;
    }
    v8 = (std::vector<std::string> *)a3;
    goto LABEL_9;
  }
  if (v7 > v6)
  {
    std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(a2, a3);
    if (*(float *)&a2[1].__begin_ > *(float *)&v5[1].__begin_)
    {
      this = v5;
      v8 = a2;
LABEL_9:
      std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(this, (uint64_t)v8);
    }
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)a1, (std::vector<std::string> *)a2, a3);
  if (*(float *)(a4 + 24) > *(float *)(a3 + 24))
  {
    std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)a3, a4);
    if (*(float *)(a3 + 24) > *(float *)(a2 + 24))
    {
      std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)a2, a3);
      if (*(float *)(a2 + 24) > *(float *)(a1 + 24))
        std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)a1, a2);
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(std::vector<std::string> *this, std::vector<std::string> *a2)
{
  std::vector<std::string> *v2;
  unint64_t v4;
  _BOOL8 result;
  std::__compressed_pair<std::string *> *p_end;
  std::vector<std::string> *v7;
  std::vector<std::string> *v8;
  std::vector<std::string> *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  char *v13;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  void **v18;
  char *v19;
  float v20;
  std::vector<std::string> *v21;
  std::vector<std::string> *v22;
  std::vector<std::string> *v23;
  std::vector<std::string> *v24;
  std::vector<std::string> *v25;
  std::vector<std::string> *v26;
  std::string *begin;
  std::string *v28;
  std::string *v29;
  std::string *v30;
  std::string *v31;
  std::vector<std::string> *v32;
  std::vector<std::string> *v33;
  void *v34[2];
  std::string *value;
  __int128 v36;
  int v37;
  __int128 v38;
  std::string *v39;
  __int128 __p;
  std::string *v41;
  __int128 v42;
  std::string *v43;
  __int128 v44;
  std::string *v45;
  __int128 v46;
  void **v47[2];

  v2 = a2;
  v4 = 0xCCCCCCCCCCCCCCCDLL * (((char *)a2 - (char *)this) >> 5);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(float *)&a2[-6].__end_ > *(float *)&this[1].__begin_)
      {
        p_end = (std::__compressed_pair<std::string *> *)&a2[-7].__end_;
        v7 = this;
        goto LABEL_4;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(this, (std::vector<std::string> *)((char *)this + 160), (uint64_t)&a2[-7].__end_);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((uint64_t)this, (uint64_t)&this[6].__end_cap_, (uint64_t)&this[13].__end_, (uint64_t)&a2[-7].__end_);
      return 1;
    case 5uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((uint64_t)this, (uint64_t)&this[6].__end_cap_, (uint64_t)&this[13].__end_, (uint64_t)&this[20]);
      if (*(float *)&v2[-6].__end_ > *(float *)&this[21].__begin_)
      {
        std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(this + 20, (uint64_t)&v2[-7].__end_);
        if (*(float *)&this[21].__begin_ > *(float *)&this[14].__end_)
        {
          std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)((char *)this + 320), (uint64_t)&this[20]);
          if (*(float *)&this[14].__end_ > *(float *)&this[7].__end_cap_.__value_)
          {
            std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)((char *)this + 160), (uint64_t)&this[13].__end_);
            if (*(float *)&this[7].__end_cap_.__value_ > *(float *)&this[1].__begin_)
            {
              v7 = this;
              p_end = &this[6].__end_cap_;
LABEL_4:
              std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(v7, (uint64_t)p_end);
            }
          }
        }
      }
      return 1;
    default:
      v8 = (std::vector<std::string> *)((char *)this + 320);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(this, (std::vector<std::string> *)((char *)this + 160), (uint64_t)&this[13].__end_);
      v9 = this + 20;
      if (&this[20] == v2)
        return 1;
      v10 = 0;
      v11 = 0;
      v32 = v2;
      break;
  }
  while (1)
  {
    if (*(float *)&v9[1].__begin_ > *(float *)&v8[1].__begin_)
    {
      *(_OWORD *)v34 = *(_OWORD *)&v9->__begin_;
      value = v9->__end_cap_.__value_;
      v9->__end_ = 0;
      v9->__end_cap_.__value_ = 0;
      v9->__begin_ = 0;
      v36 = *(_OWORD *)&v9[1].__begin_;
      v37 = (int)v9[1].__end_cap_.__value_;
      v38 = *(_OWORD *)&v9[2].__begin_;
      v39 = v9[2].__end_cap_.__value_;
      v9[2].__begin_ = 0;
      v9[2].__end_ = 0;
      v41 = v9[3].__end_cap_.__value_;
      __p = *(_OWORD *)&v9[3].__begin_;
      v9[2].__end_cap_.__value_ = 0;
      v9[3].__begin_ = 0;
      v9[3].__end_ = 0;
      v9[3].__end_cap_.__value_ = 0;
      v42 = *(_OWORD *)&v9[4].__begin_;
      v43 = v9[4].__end_cap_.__value_;
      v9[4].__begin_ = 0;
      v9[4].__end_ = 0;
      v44 = *(_OWORD *)&v9[5].__begin_;
      v45 = v9[5].__end_cap_.__value_;
      v9[4].__end_cap_.__value_ = 0;
      v9[5].__begin_ = 0;
      v9[5].__end_ = 0;
      v9[5].__end_cap_.__value_ = 0;
      v12 = v10;
      v46 = *(_OWORD *)&v9[6].__begin_;
      while (1)
      {
        v13 = (char *)this + v12;
        v14 = *(std::vector<std::string>::pointer *)((char *)&this[20].__begin_ + v12);
        if (v14)
        {
          *((_QWORD *)v13 + 61) = v14;
          operator delete(v14);
          *((_QWORD *)v13 + 62) = 0;
        }
        *((_OWORD *)v13 + 30) = *((_OWORD *)v13 + 20);
        *((_QWORD *)v13 + 62) = *((_QWORD *)v13 + 42);
        *((_QWORD *)v13 + 40) = 0;
        *((_QWORD *)v13 + 41) = 0;
        *((_QWORD *)v13 + 42) = 0;
        *((_DWORD *)v13 + 130) = *((_DWORD *)v13 + 90);
        *(_OWORD *)(v13 + 504) = *(_OWORD *)(v13 + 344);
        v15 = v13 + 528;
        if (v13[551] < 0)
          operator delete(*(void **)v15);
        v16 = v13 + 368;
        v17 = (char *)this + v12;
        *(_OWORD *)v15 = *(_OWORD *)v16;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v16 + 2);
        *((_BYTE *)&this[16].__begin_ + v12 + 7) = 0;
        *v16 = 0;
        v18 = (void **)((char *)&this[23].__begin_ + v12);
        if (*((char *)&this[23].__end_cap_.__value_ + v12 + 7) < 0)
          operator delete(*v18);
        *(std::string **)((char *)&this[23].__end_cap_.__value_ + v12) = (std::string *)*((_QWORD *)v17 + 51);
        *(_OWORD *)v18 = *(_OWORD *)(v17 + 392);
        v17[415] = 0;
        v17[392] = 0;
        std::vector<std::string>::__vdeallocate((std::vector<std::string> *)v17 + 24);
        *((_OWORD *)v17 + 36) = *((_OWORD *)v17 + 26);
        *((_QWORD *)v17 + 74) = *((_QWORD *)v17 + 54);
        *((_QWORD *)v17 + 53) = 0;
        *((_QWORD *)v17 + 54) = 0;
        *((_QWORD *)v17 + 52) = 0;
        std::vector<std::string>::__vdeallocate((std::vector<std::string> *)v17 + 25);
        *(_OWORD *)(v17 + 600) = *(_OWORD *)(v17 + 440);
        *((_QWORD *)v17 + 77) = *((_QWORD *)v17 + 57);
        *((_QWORD *)v17 + 56) = 0;
        *((_QWORD *)v17 + 57) = 0;
        *((_QWORD *)v17 + 55) = 0;
        *((_OWORD *)v17 + 39) = *((_OWORD *)v17 + 29);
        if (v12 == -320)
          break;
        v19 = (char *)this + v12;
        v20 = *(float *)((char *)&this[7].__end_cap_.__value_ + v12);
        v12 -= 160;
        if (*(float *)&v36 <= v20)
        {
          v21 = (std::vector<std::string> *)(v19 + 344);
          v22 = (std::vector<std::string> *)(v19 + 368);
          v23 = (std::vector<std::string> *)((char *)this + v12 + 480);
          v33 = (std::vector<std::string> *)(v19 + 464);
          v24 = (std::vector<std::string> *)(v19 + 392);
          v25 = (std::vector<std::string> *)(v19 + 440);
          v26 = (std::vector<std::string> *)(v19 + 416);
          goto LABEL_20;
        }
      }
      v21 = this + 1;
      v22 = this + 2;
      v33 = this + 6;
      v24 = this + 3;
      v25 = this + 5;
      v26 = this + 4;
      v23 = this;
LABEL_20:
      begin = v23->__begin_;
      if (v23->__begin_)
      {
        v23->__end_ = begin;
        operator delete(begin);
        v23->__begin_ = 0;
        v23->__end_ = 0;
        v23->__end_cap_.__value_ = 0;
      }
      *(_OWORD *)&v23->__begin_ = *(_OWORD *)v34;
      v23->__end_cap_.__value_ = value;
      *(_OWORD *)&v21->__begin_ = v36;
      LODWORD(v21->__end_cap_.__value_) = v37;
      if (SHIBYTE(v23[2].__end_cap_.__value_) < 0)
        operator delete(v22->__begin_);
      v22->__end_cap_.__value_ = v39;
      *(_OWORD *)&v22->__begin_ = v38;
      if (SHIBYTE(v23[3].__end_cap_.__value_) < 0)
        operator delete(v24->__begin_);
      *(_OWORD *)&v24->__begin_ = __p;
      v24->__end_cap_.__value_ = v41;
      std::vector<std::string>::__vdeallocate(v26);
      v28 = (std::string *)*((_QWORD *)&v42 + 1);
      v26->__begin_ = (std::vector<std::string>::pointer)v42;
      v29 = v43;
      v23[4].__end_ = v28;
      v23[4].__end_cap_.__value_ = v29;
      v42 = 0uLL;
      v43 = 0;
      std::vector<std::string>::__vdeallocate(v25);
      v30 = (std::string *)*((_QWORD *)&v44 + 1);
      v25->__begin_ = (std::vector<std::string>::pointer)v44;
      v31 = v45;
      v23[5].__end_ = v30;
      v23[5].__end_cap_.__value_ = v31;
      v45 = 0;
      v44 = 0uLL;
      *(_OWORD *)&v33->__begin_ = v46;
      v47[0] = (void **)&v44;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v47);
      v47[0] = (void **)&v42;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v47);
      v2 = v32;
      if (++v11 == 8)
        return &v9[6].__end_cap_ == (std::__compressed_pair<std::string *> *)v32;
    }
    v8 = v9;
    v10 += 160;
    v9 = (std::vector<std::string> *)((char *)v9 + 160);
    if (v9 == v2)
      return 1;
  }
}

void ___ZNK2KB22LanguageModelContainer36probability_of_lexicon_given_contextEjRKNS_20LanguageModelContextE_block_invoke(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  _QWORD *v6;
  float v7;
  uint64_t v8;
  unint64_t v9;
  float v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  char v14;
  uint64_t v15;
  float v16;
  float v17;

  if ((HIDWORD(a2) - 500) <= 0xFFFFFE0C)
  {
    v6 = *(_QWORD **)(a1 + 56);
    v7 = *(float *)(a1 + 80);
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v9 = *(_QWORD *)(v8 + 24);
    *(_QWORD *)(v8 + 24) = v9 + 1;
    v10 = powf(v7, (float)v9);
    *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v10
                                                               + *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)
                                                                          + 24);
    v11 = v6[3];
    v12 = (unint64_t)(0x6DB6DB6DB6DB6DB7 * ((v6[4] - v11) >> 3)) <= 1 && *(_DWORD *)(v11 + 40) < 2;
    v13 = *(_DWORD *)(a1 + 84);
    v14 = (*(uint64_t (**)(_QWORD *, uint64_t))(*v6 + 304))(v6, a2) ^ 1 | v12;
    if (v13 == (_DWORD)a2)
    {
      v15 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
      v16 = *(float *)(v15 + 24);
      if ((v14 & 1) != 0)
        v17 = v10 + v16;
      else
        v17 = v16 + (float)(v10 * 0.6);
      *(float *)(v15 + 24) = v17;
    }
    else if ((v14 & 1) == 0)
    {
      KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(v6[3] + 56 * *(_QWORD *)(a1 + 64)), *(_DWORD *)(a1 + 84));
    }
  }
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= *(_QWORD *)(a1 + 72))
    *a3 = 1;
}

BOOL enumerate_context_backwards(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v6;
  unint64_t v7;
  uint64_t i;
  _BOOL8 result;
  char v10;

  v10 = 0;
  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 24) - v2;
  if (!v3)
    return 0;
  v6 = 0;
  v7 = v3 >> 3;
  for (i = -8; ; i -= 8)
  {
    (*(void (**)(uint64_t, _QWORD, char *))(a2 + 16))(a2, *(_QWORD *)(v2 + 8 * v7 + i), &v10);
    result = v10 != 0;
    if (v10)
      break;
    v2 = *(_QWORD *)(a1 + 16);
    v7 = (*(_QWORD *)(a1 + 24) - v2) >> 3;
    if (v7 <= ++v6)
      return 0;
  }
  return result;
}

float KB::LanguageModelLexiconGroup::lexicon_weight(KB::LanguageModelLexiconGroup *this, unsigned int a2)
{
  uint64_t *v2;

  v2 = std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::find<unsigned int>((_QWORD *)this + 2, a2);
  if (!v2)
    abort();
  return *((float *)v2 + 5);
}

float KB::LanguageModelContainer::lexicon_stationary_probability(KB::LanguageModelContainer *this, int a2)
{
  uint64_t v2;
  unint64_t v5;
  float v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int *v11;
  unsigned int *v12;

  v2 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 4) == v2)
    return 1.0;
  v5 = 0;
  v6 = 1.0;
  do
  {
    v7 = *(_QWORD *)(v2 + 56 * v5);
    if (v7)
    {
      (*(void (**)(unsigned int **__return_ptr))(*(_QWORD *)v7 + 48))(&v11);
      v8 = v11;
      v9 = v12;
      if (v11 != v12)
      {
        do
        {
          if (*v8 != a2)
            v6 = v6
               + (float)(KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((_QWORD *)this + 3) + 56 * v5), *v8)* -0.04);
          ++v8;
        }
        while (v8 != v9);
        v8 = v11;
      }
      if (v8)
      {
        v12 = v8;
        operator delete(v8);
      }
    }
    ++v5;
    v2 = *((_QWORD *)this + 3);
  }
  while (v5 < 0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)this + 4) - v2) >> 3));
  return v6;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::find<unsigned int>(_QWORD *a1, unsigned int a2)
{
  unint64_t v2;
  uint8x8_t v3;
  unint64_t v4;
  uint64_t **v5;
  uint64_t *result;
  unint64_t v7;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
      v4 = a2 % v2;
  }
  else
  {
    v4 = ((_DWORD)v2 - 1) & a2;
  }
  v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  for (result = *v5; result; result = (uint64_t *)*result)
  {
    v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2)
        return result;
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2)
          v7 %= v2;
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4)
        return 0;
    }
  }
  return result;
}

_QWORD *std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__init_with_size[abi:nn180100]<std::vector<language_modeling::v1::TokenMetadata>*,std::vector<language_modeling::v1::TokenMetadata>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  int64_t v11;
  char *v12;

  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v6 = result;
    result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(a4);
    v7 = result;
    *v6 = result;
    v6[1] = result;
    v6[2] = &result[3 * v8];
    while (a2 != a3)
    {
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
      v10 = *(const void **)a2;
      v9 = *(_QWORD *)(a2 + 8);
      v11 = v9 - *(_QWORD *)a2;
      if (v9 != *(_QWORD *)a2)
      {
        std::vector<language_modeling::v1::TokenMetadata>::__vallocate[abi:nn180100](v7, v11 >> 1);
        v12 = (char *)v7[1];
        result = memmove(v12, v10, v11);
        v7[1] = &v12[v11];
      }
      v7 += 3;
      a2 += 24;
    }
    v6[1] = v7;
  }
  return result;
}

void std::vector<KB::LanguageModelContext>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 104;
        std::__destroy_at[abi:nn180100]<KB::LanguageModelContext,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        v6 = v4;
        std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void KB::LanguageModelLexiconGroup::lexicon_group_identifier(KB::LanguageModelLexiconGroup *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  uint64_t v6;
  std::string *p_p;
  std::string::size_type size;
  std::string __p;
  unsigned int *v10;
  unsigned int *v11;

  v3 = *(_QWORD *)this;
  if (v3)
  {
    (*(void (**)(unsigned int **__return_ptr))(*(_QWORD *)v3 + 48))(&v10);
    v4 = v10;
    v5 = v11;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    if (v4 != v5)
    {
      do
      {
        v6 = *(unsigned __int8 *)(a2 + 23);
        if ((v6 & 0x80u) != 0)
          v6 = *(_QWORD *)(a2 + 8);
        if (v6)
          std::string::append((std::string *)a2, "+", 1uLL);
        std::to_string(&__p, *v4);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          size = __p.__r_.__value_.__l.__size_;
        std::string::append((std::string *)a2, (const std::string::value_type *)p_p, size);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        ++v4;
      }
      while (v4 != v5);
      v4 = v10;
    }
    if (v4)
    {
      v11 = v4;
      operator delete(v4);
    }
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
}

id KB::LanguageModelContainer::get_autocorrection_queue(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  int v5;
  uint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  int8x8_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  NSObject *v17;
  const char *p_p;
  dispatch_queue_t v19;
  char *v20;
  void *v21;
  id v22;
  void *__p;
  char v25;

  v4 = (uint64_t *)(a1 + 48);
  v5 = *(char *)(a2 + 23);
  if (v5 >= 0)
    v6 = (uint64_t *)a2;
  else
    v6 = *(uint64_t **)a2;
  if (v5 >= 0)
    v7 = *(unsigned __int8 *)(a2 + 23);
  else
    v7 = *(_QWORD *)(a2 + 8);
  v8 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v6, v7);
  v9 = *(int8x8_t *)(a1 + 56);
  if (v9)
  {
    v10 = v8;
    v11 = (uint8x8_t)vcnt_s8(v9);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v13 = v8;
      if (v8 >= *(_QWORD *)&v9)
        v13 = v8 % *(_QWORD *)&v9;
    }
    else
    {
      v13 = (*(_QWORD *)&v9 - 1) & v8;
    }
    v14 = *(unsigned __int8 ***)(*v4 + 8 * v13);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
            return *((id *)i + 5);
        }
        else
        {
          if (v12 > 1)
          {
            if (v16 >= *(_QWORD *)&v9)
              v16 %= *(_QWORD *)&v9;
          }
          else
          {
            v16 &= *(_QWORD *)&v9 - 1;
          }
          if (v16 != v13)
            break;
        }
      }
    }
  }
  std::operator+<char>();
  dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
  v17 = objc_claimAutoreleasedReturnValue();
  if (v25 >= 0)
    p_p = (const char *)&__p;
  else
    p_p = (const char *)__p;
  v19 = dispatch_queue_create(p_p, v17);
  v20 = std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v4, a2, a2);
  v21 = (void *)*((_QWORD *)v20 + 5);
  *((_QWORD *)v20 + 5) = v19;

  v22 = *((id *)std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v4, a2, a2)+ 5);
  if (v25 < 0)
    operator delete(__p);
  return v22;
}

void ___ZNK2KB22LanguageModelContainer30conditional_likelihood_batchedERKNSt3__16vectorINS_9CandidateENS1_9allocatorIS3_EEEERKNS2_INS2_IN17language_modeling2v113TokenMetadataENS4_ISB_EEEENS4_ISD_EEEERKNS_20LanguageModelContextEP10__CFStringb_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  KB::LanguageModelLexiconGroup *v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL8 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  char *v26;
  const std::string::value_type **v27;
  char *v28;
  void **v29;
  TITokenID *v30;
  TITokenID v31;
  std::__shared_weak_count *v32;
  unint64_t *p_shared_owners;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  std::mutex *v37;
  std::__shared_weak_count *v38;
  KB::LanguageModelContext *v39;
  KB::LanguageModelLexiconGroup *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void **v45;
  int v46;
  std::string v47;
  void **v48;
  std::__shared_weak_count *v49;
  void *__p;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;

  v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2 && (v3 = *(_QWORD *)(a1 + 40), (v4 = std::__shared_weak_count::lock(v2)) != 0))
  {
    v5 = v4;
    if (*(_QWORD *)(a1 + 48))
    {
      v6 = *(_QWORD *)(a1 + 96);
      v7 = (KB::LanguageModelLexiconGroup *)(*(_QWORD *)(v3 + 24) + 56 * v6);
      v8 = *(_QWORD *)(a1 + 104) + 104 * v6;
      v9 = *(_QWORD *)(a1 + 128) + 24 * v6;
      v38 = v4;
      if (**(_BYTE **)(a1 + 72))
        v10 = KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v7, **(_DWORD **)(a1 + 64));
      else
        v10 = 0;
      (*(void (**)(uint64_t *__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _BOOL8))(**(_QWORD **)v7 + 408))(&v43, *(_QWORD *)v7, *(_QWORD *)(a1 + 80), v9, v8, **(_QWORD **)(a1 + 88), v10);
      v11 = *(_QWORD *)(v3 + 24);
      v12 = *(_QWORD *)(a1 + 96);
      v13 = *(_QWORD *)(a1 + 104);
      v14 = *(_QWORD *)(a1 + 128);
      v41 = *(_QWORD *)(a1 + 184);
      v42 = a1;
      v37 = *(std::mutex **)(a1 + 176);
      std::mutex::lock(v37);
      if (v44 != v43)
      {
        v15 = 0;
        v39 = (KB::LanguageModelContext *)(v13 + 104 * v12);
        v40 = (KB::LanguageModelLexiconGroup *)(v11 + 56 * v12);
        v16 = (_QWORD *)(v14 + 24 * v12);
        do
        {
          KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v48, v39);
          if (*(_QWORD *)(v43 + 24 * v15 + 8) != *(_QWORD *)(v43 + 24 * v15))
          {
            v17 = 0;
            v18 = 0;
            v19 = 0;
            v20 = (_QWORD *)(**(_QWORD **)(v42 + 152) + 1000 * v15 + 8);
            v21 = 39;
            do
            {
              v22 = *(_QWORD *)(*v16 + 24 * v15);
              if (*(_BYTE *)(v22 + v17))
              {
                v23 = *v20 + v18;
                v24 = *(unsigned int *)(v23 + 136);
                if (!KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v40, *(_DWORD *)(v23 + 136))
                  && (!**(_BYTE **)(v42 + 160) || (*(_BYTE *)(*v20 + v18 + 106) & 2) == 0))
                {
                  v24 = 0;
                }
                v25 = (*(float (**)(uint64_t, uint64_t, void ***))(*(_QWORD *)v41 + 432))(v41, v24, &v48);
                v26 = (char *)(*(_QWORD *)(v43 + 24 * v15) + v21);
                v45 = (void **)vmul_n_f32(*(float32x2_t *)(v26 - 39), v25);
                v46 = *(_DWORD *)(v26 - 31);
                v27 = (const std::string::value_type **)(v26 - 23);
                if (*v26 < 0)
                {
                  std::string::__init_copy_ctor_external(&v47, *v27, *(_QWORD *)(v26 - 15));
                }
                else
                {
                  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = *(_OWORD *)v27;
                  v47.__r_.__value_.__r.__words[2] = *(_QWORD *)(v26 - 7);
                }
                v28 = (char *)(*(_QWORD *)(**(_QWORD **)(v42 + 168) + 24 * v15) + v21);
                *(_QWORD *)(v28 - 39) = v45;
                *(_DWORD *)(v28 - 31) = v46;
                v29 = (void **)(v28 - 23);
                if (*v28 < 0)
                  operator delete(*v29);
                *(std::string *)v29 = v47;
                v22 = *(_QWORD *)(*v16 + 24 * v15);
              }
              if (!*(_BYTE *)(v22 + v17 + 1))
              {
                v30 = (TITokenID *)(*v20 + v18);
                v31 = v30[17];
                KB::LanguageModelContext::append((KB::LanguageModelContext *)&v48, v31, (const KB::String *)v30, 0);
              }
              ++v19;
              v18 += 240;
              v17 += 2;
              v21 += 40;
            }
            while (v19 < 0xCCCCCCCCCCCCCCCDLL
                        * ((uint64_t)(*(_QWORD *)(v43 + 24 * v15 + 8) - *(_QWORD *)(v43 + 24 * v15)) >> 3));
          }
          v45 = (void **)&v54;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v45);
          language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v53);
          language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v52);
          if (__p)
          {
            v51 = __p;
            operator delete(__p);
          }
          v32 = v49;
          if (v49)
          {
            p_shared_owners = (unint64_t *)&v49->__shared_owners_;
            do
              v34 = __ldaxr(p_shared_owners);
            while (__stlxr(v34 - 1, p_shared_owners));
            if (!v34)
            {
              ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
              std::__shared_weak_count::__release_weak(v32);
            }
          }
          ++v15;
        }
        while (v15 < 0xAAAAAAAAAAAAAAABLL * ((v44 - v43) >> 3));
      }
      std::mutex::unlock(v37);
      v48 = (void **)&v43;
      std::vector<std::vector<KB::LikelihoodInfo>>::__destroy_vector::operator()[abi:nn180100](&v48);
      dispatch_group_leave(*(dispatch_group_t *)(v42 + 32));
      v5 = v38;
    }
    else
    {
      dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
    }
    v35 = (unint64_t *)&v5->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  }
}

KB::LanguageModelContext *std::vector<KB::LanguageModelContext>::__init_with_size[abi:nn180100]<KB::LanguageModelContext*,KB::LanguageModelContext*>(KB::LanguageModelContext *result, const KB::LanguageModelContext *a2, const KB::LanguageModelContext *a3, unint64_t a4)
{
  KB::LanguageModelContext *v6;
  KB::LanguageModelContext *v7;

  if (a4)
  {
    v6 = result;
    std::vector<KB::LanguageModelContext>::__vallocate[abi:nn180100](result, a4);
    result = (KB::LanguageModelContext *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v7 = KB::LanguageModelContext::LanguageModelContext(result, a2);
      a2 = (const KB::LanguageModelContext *)((char *)a2 + 104);
      result = (KB::LanguageModelContext *)((char *)v7 + 104);
    }
    *((_QWORD *)v6 + 1) = result;
  }
  return result;
}

_QWORD *std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__init_with_size[abi:nn180100]<std::vector<std::vector<language_modeling::v1::TokenMetadata>>*,std::vector<std::vector<language_modeling::v1::TokenMetadata>>*>(_QWORD *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v6 = result;
    result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(a4);
    v7 = result;
    *v6 = result;
    v6[1] = result;
    for (v6[2] = &result[3 * v8]; a2 != a3; v7 += 3)
    {
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
      v9 = *a2;
      v10 = a2[1];
      a2 += 3;
      result = std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__init_with_size[abi:nn180100]<std::vector<language_modeling::v1::TokenMetadata>*,std::vector<language_modeling::v1::TokenMetadata>*>(v7, v9, v10, 0xAAAAAAAAAAAAAAABLL * ((v10 - v9) >> 3));
    }
    v6[1] = v7;
  }
  return result;
}

char *std::vector<KB::LanguageModelContext>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x276276276276277)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelContext>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[104 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelContext>>(unint64_t a1)
{
  if (a1 >= 0x276276276276277)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(104 * a1);
}

_QWORD *__copy_helper_block_a8_48c53_ZTSNSt3__18weak_ptrIKN2KB22LanguageModelContainerEEE104c67_ZTSNSt3__16vectorIN2KB20LanguageModelContextENS_9allocatorIS2_EEEE128c113_ZTSNSt3__16vectorINS0_INS0_IN17language_modeling2v113TokenMetadataENS_9allocatorIS3_EEEENS4_IS6_EEEENS4_IS8_EEEE(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;

  v4 = *(_QWORD *)(a2 + 56);
  a1[6] = *(_QWORD *)(a2 + 48);
  a1[7] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[14] = 0;
  a1[15] = 0;
  a1[13] = 0;
  std::vector<KB::LanguageModelContext>::__init_with_size[abi:nn180100]<KB::LanguageModelContext*,KB::LanguageModelContext*>((KB::LanguageModelContext *)(a1 + 13), *(const KB::LanguageModelContext **)(a2 + 104), *(const KB::LanguageModelContext **)(a2 + 112), 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(_QWORD *)(a2 + 112) - *(_QWORD *)(a2 + 104)) >> 3));
  a1[16] = 0;
  a1[17] = 0;
  v7 = a1 + 16;
  v7[2] = 0;
  return std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__init_with_size[abi:nn180100]<std::vector<std::vector<language_modeling::v1::TokenMetadata>>*,std::vector<std::vector<language_modeling::v1::TokenMetadata>>*>(v7, *(uint64_t **)(a2 + 128), *(uint64_t **)(a2 + 136), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 136) - *(_QWORD *)(a2 + 128)) >> 3));
}

void __destroy_helper_block_a8_48c53_ZTSNSt3__18weak_ptrIKN2KB22LanguageModelContainerEEE104c67_ZTSNSt3__16vectorIN2KB20LanguageModelContextENS_9allocatorIS2_EEEE128c113_ZTSNSt3__16vectorINS0_INS0_IN17language_modeling2v113TokenMetadataENS_9allocatorIS3_EEEENS4_IS6_EEEENS4_IS8_EEEE(uint64_t a1)
{
  void **v2;
  std::__shared_weak_count *v3;
  void **v4;

  v2 = (void **)(a1 + 104);
  v4 = (void **)(a1 + 128);
  std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__destroy_vector::operator()[abi:nn180100](&v4);
  v4 = v2;
  std::vector<KB::LanguageModelContext>::__destroy_vector::operator()[abi:nn180100](&v4);
  v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,NSObject  {objcproto17OS_dispatch_queue}* {__strong}>,0>(uint64_t a1)
{

  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t ___ZNK2KB22LanguageModelContainer25should_adapt_to_paragraphEPK10__CFString_block_invoke(uint64_t a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 360))(*a2, *(_QWORD *)(a1 + 32));
}

uint64_t KB::LanguageModelContainer::lexicon_id_for_token(KB::LanguageModelContainer *this, TITokenID a2, const KB::LanguageModelContext *a3)
{
  TITokenID v3;
  _DWORD *v4;
  void *__p[3];

  v3 = a2;
  if (a2.lexicon_id && a2.lexicon_id != -2)
    return (uint64_t)v3;
  v4 = (_DWORD *)*((_QWORD *)this + 3);
  if (*((_QWORD *)this + 4) - (_QWORD)v4 == 56 && v4[10] == 1)
  {
    (*(void (**)(void **__return_ptr))(**(_QWORD **)v4 + 48))(__p);
    v3 = (TITokenID)*(unsigned int *)__p[0];
    __p[1] = __p[0];
    operator delete(__p[0]);
    return (uint64_t)v3;
  }
  return (*(uint64_t (**)(KB::LanguageModelContainer *, const KB::LanguageModelContext *))(*(_QWORD *)this + 416))(this, a3);
}

uint64_t ___ZNK2KB22LanguageModelContainer18is_dynamic_word_idE9TITokenID_block_invoke(uint64_t a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 304))(*a2, *(_QWORD *)(a1 + 32));
}

KB::Word *std::vector<KB::Word>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Word*>,std::__wrap_iter<KB::Word*>>(KB::Word *result, uint64_t a2, const KB::Word *a3, const KB::Word *a4, uint64_t a5)
{
  const KB::Word *v6;
  uint64_t v7;
  uint64_t *v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  const KB::Word *v24;
  KB::Word *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  KB::Word *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  KB::Word *v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _QWORD v46[5];

  if (a5 < 1)
    return result;
  v6 = a3;
  v7 = a2;
  v8 = (uint64_t *)result;
  v9 = (char *)result + 16;
  v10 = *((_QWORD *)result + 2);
  v11 = *((_QWORD *)result + 1);
  if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v10 - v11) >> 4)) >= a5)
  {
    v21 = v11 - a2;
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - a2) >> 4)) >= a5)
    {
      v23 = (uint64_t)a3 + 240 * a5;
      v25 = (KB::Word *)*((_QWORD *)result + 1);
    }
    else
    {
      v23 = (uint64_t)a3 + 16 * ((uint64_t)(v11 - a2) >> 4);
      if ((const KB::Word *)v23 == a4)
      {
        v25 = (KB::Word *)*((_QWORD *)result + 1);
      }
      else
      {
        v24 = (const KB::Word *)((char *)a3 + 16 * ((uint64_t)(v11 - a2) >> 4));
        v25 = (KB::Word *)*((_QWORD *)result + 1);
        do
        {
          result = KB::Word::Word(v25, v24);
          v24 = (const KB::Word *)((char *)v24 + 240);
          v25 = (KB::Word *)((char *)v25 + 240);
        }
        while (v24 != a4);
      }
      v8[1] = (uint64_t)v25;
      if (v21 < 1)
        return result;
    }
    v35 = (KB::Word *)(v7 + 240 * a5);
    v36 = (char *)v25 - 240 * a5;
    v37 = (uint64_t)v25;
    if ((unint64_t)v36 < v11)
    {
      v38 = (unint64_t)v25 - 240 * a5;
      v37 = (uint64_t)v25;
      do
      {
        v39 = KB::Word::Word(v37, v38);
        v38 += 240;
        v37 = v39 + 240;
      }
      while (v38 < v11);
    }
    v8[1] = v37;
    if (v25 != v35)
    {
      v40 = 0;
      do
      {
        v41 = (char *)v25 + v40;
        KB::String::operator=((uint64_t)v25 + v40 - 240, (KB::String *)&v36[v40 - 240]);
        KB::ByteString::operator=((unsigned __int16 *)((char *)v25 + v40 - 208), (unsigned __int16 *)&v36[v40 - 208]);
        v42 = *(_QWORD *)&v36[v40 - 192];
        *((_DWORD *)v41 - 46) = *(_DWORD *)&v36[v40 - 184];
        *((_QWORD *)v41 - 24) = v42;
        KB::String::operator=((uint64_t)v25 + v40 - 176, (KB::String *)&v36[v40 - 176]);
        v43 = *(_OWORD *)&v36[v40 - 144];
        v44 = *(_OWORD *)&v36[v40 - 128];
        v45 = *(_OWORD *)&v36[v40 - 96];
        *((_OWORD *)v41 - 7) = *(_OWORD *)&v36[v40 - 112];
        *((_OWORD *)v41 - 6) = v45;
        *((_OWORD *)v41 - 9) = v43;
        *((_OWORD *)v41 - 8) = v44;
        KB::String::operator=((uint64_t)v25 + v40 - 80, (KB::String *)&v36[v40 - 80]);
        *(v41 - 48) = v36[v40 - 48];
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign((uint64_t)v25 + v40 - 40, (uint64_t *)&v36[v40 - 40]);
        v40 -= 240;
      }
      while (-16 * ((v25 - v35) >> 4) != v40);
    }
    return (KB::Word *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<KB::Word *,KB::Word *,KB::Word *>((uint64_t)v6, v23, v7);
  }
  else
  {
    v12 = *(_QWORD *)result;
    v13 = a5 - 0x1111111111111111 * ((uint64_t)(v11 - *(_QWORD *)result) >> 4);
    if (v13 > 0x111111111111111)
      abort();
    v14 = 0xEEEEEEEEEEEEEEEFLL * ((a2 - v12) >> 4);
    v15 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v12) >> 4);
    v16 = 2 * v15;
    if (2 * v15 <= v13)
      v16 = a5 - 0x1111111111111111 * ((uint64_t)(v11 - *(_QWORD *)result) >> 4);
    if (v15 >= 0x88888888888888)
      v17 = 0x111111111111111;
    else
      v17 = v16;
    v46[4] = v9;
    if (v17)
    {
      v18 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v17);
      v20 = v19;
    }
    else
    {
      v18 = 0;
      v20 = 0;
    }
    v26 = (uint64_t)&v18[240 * v14];
    v27 = 240 * a5;
    v28 = v26 + v27;
    v29 = (KB::Word *)v26;
    do
    {
      v29 = (KB::Word *)((char *)KB::Word::Word(v29, v6) + 240);
      v6 = (const KB::Word *)((char *)v6 + 240);
      v27 -= 240;
    }
    while (v27);
    v30 = *v8;
    if (*v8 != v7)
    {
      v31 = v7;
      do
      {
        v26 -= 240;
        v31 -= 240;
        KB::Word::Word(v26, v31);
      }
      while (v31 != v30);
    }
    v32 = v8[1];
    if (v32 != v7)
    {
      do
      {
        KB::Word::Word(v28, v7);
        v7 += 240;
        v28 += 240;
      }
      while (v7 != v32);
      v7 = v8[1];
    }
    v33 = *v8;
    *v8 = v26;
    v8[1] = v28;
    v34 = v8[2];
    v8[2] = (uint64_t)&v18[240 * v20];
    v46[2] = v7;
    v46[3] = v34;
    v46[0] = v33;
    v46[1] = v33;
    return (KB::Word *)std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)v46);
  }
}

_QWORD *KB::LanguageModelLexiconGroup::LanguageModelLexiconGroup(uint64_t a1, uint64_t *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 48) = 1065353216;
  return std::shared_ptr<KB::LanguageModel>::operator=[abi:nn180100]((_QWORD *)a1, *a2, a2[1]);
}

{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 48) = 1065353216;
  return std::shared_ptr<KB::LanguageModel>::operator=[abi:nn180100]((_QWORD *)a1, *a2, a2[1]);
}

float *KB::LanguageModelLexiconGroup::set_lexicon_weight(KB::LanguageModelLexiconGroup *this, unsigned int a2, float a3)
{
  float *result;
  unsigned int v5;

  v5 = a2;
  result = (float *)std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)this + 16, a2, &v5);
  result[5] = a3;
  return result;
}

uint64_t KB::LanguageModelLexiconGroup::lexicon_id_vector@<X0>(KB::LanguageModelLexiconGroup *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = *(_QWORD *)this;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

float KB::LanguageModelLexiconGroup::any_lexicon_weight(KB::LanguageModelLexiconGroup *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 4);
  if (v1)
    return *(float *)(v1 + 20);
  else
    return 0.0;
}

uint64_t KB::LanguageModelContainer::LanguageModelContainer(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  *(_QWORD *)a1 = &off_1EA0FD330;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v3 = *(_QWORD **)a2;
  v4 = *(_QWORD **)(a2 + 8);
  if (v4 != *(_QWORD **)a2)
  {
    v5 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v4 - *(_QWORD *)a2) >> 3);
    if (v5 >= 0x492492492492493)
      abort();
    v6 = std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelLexiconGroup>>(v5);
    *(_QWORD *)(a1 + 24) = v6;
    *(_QWORD *)(a1 + 32) = v6;
    *(_QWORD *)(a1 + 40) = &v6[7 * v7];
    do
    {
      v8 = v3[1];
      *v6 = *v3;
      v6[1] = v8;
      if (v8)
      {
        v9 = (unint64_t *)(v8 + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      std::unordered_map<unsigned int,float>::unordered_map((uint64_t)(v6 + 2), (uint64_t)(v3 + 2));
      v3 += 7;
      v6 += 7;
    }
    while (v3 != v4);
    *(_QWORD *)(a1 + 32) = v6;
  }
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 1065353216;
  return a1;
}

float KB::LanguageModelContainer::lexicon_prior_probability(KB::LanguageModelContainer *this, unsigned int a2)
{
  uint64_t v4;

  v4 = KB::LanguageModelContainer::index_for_lexicon_id(this, a2);
  if (v4 == -1)
    return 0.0;
  else
    return KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((_QWORD *)this + 3) + 56 * v4), a2);
}

uint64_t KB::LanguageModelContainer::set_lexicon_prior_probability(KB::LanguageModelContainer *this, unsigned int a2, float a3)
{
  uint64_t result;
  uint64_t v7;
  unsigned int v8;

  result = KB::LanguageModelContainer::index_for_lexicon_id(this, a2);
  if (result != -1)
  {
    v7 = *((_QWORD *)this + 3);
    v8 = a2;
    result = (uint64_t)std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v7 + 56 * result + 16, a2, &v8);
    *(float *)(result + 20) = a3;
  }
  return result;
}

uint64_t KB::LanguageModelContainer::language_model@<X0>(KB::LanguageModelContainer *this@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  uint64_t result;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  result = KB::LanguageModelContainer::index_for_lexicon_id(this, a2);
  if (result == -1)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    v6 = (uint64_t *)(*((_QWORD *)this + 3) + 56 * result);
    v8 = *v6;
    v7 = v6[1];
    *a3 = v8;
    a3[1] = v7;
    if (v7)
    {
      v9 = (unint64_t *)(v7 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
  }
  return result;
}

uint64_t KB::LanguageModelContainer::language_models@<X0>(uint64_t this@<X0>, char **a2@<X8>)
{
  __int128 *v2;
  __int128 *v3;
  char *v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  __int128 v17;
  unint64_t *v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  int64x2_t v24;
  char *v25;
  uint64_t v26;
  int64x2_t v27;
  char *v28;
  _QWORD *v29;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = *(__int128 **)(this + 24);
  v3 = *(__int128 **)(this + 32);
  if (v2 != v3)
  {
    v5 = 0;
    v6 = a2 + 2;
    do
    {
      if ((unint64_t)v5 >= *v6)
      {
        v10 = (v5 - *a2) >> 4;
        if ((unint64_t)(v10 + 1) >> 60)
          abort();
        v11 = *v6 - (_QWORD)*a2;
        v12 = v11 >> 3;
        if (v11 >> 3 <= (unint64_t)(v10 + 1))
          v12 = v10 + 1;
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
          v13 = 0xFFFFFFFFFFFFFFFLL;
        else
          v13 = v12;
        v29 = v6;
        v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v13);
        v16 = &v14[16 * v10];
        v17 = *v2;
        *(_OWORD *)v16 = *v2;
        if (*((_QWORD *)&v17 + 1))
        {
          v18 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
          do
            v19 = __ldxr(v18);
          while (__stxr(v19 + 1, v18));
        }
        v21 = *a2;
        v20 = a2[1];
        if (v20 == *a2)
        {
          v24 = vdupq_n_s64((unint64_t)v20);
          v22 = &v14[16 * v10];
        }
        else
        {
          v22 = &v14[16 * v10];
          do
          {
            v23 = *((_OWORD *)v20 - 1);
            v20 -= 16;
            *((_OWORD *)v22 - 1) = v23;
            v22 -= 16;
            *(_QWORD *)v20 = 0;
            *((_QWORD *)v20 + 1) = 0;
          }
          while (v20 != v21);
          v24 = *(int64x2_t *)a2;
        }
        v5 = v16 + 16;
        *a2 = v22;
        a2[1] = v16 + 16;
        v27 = v24;
        v25 = a2[2];
        a2[2] = &v14[16 * v15];
        v28 = v25;
        v26 = v24.i64[0];
        this = std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v26);
      }
      else
      {
        *(_QWORD *)v5 = *(_QWORD *)v2;
        v7 = *((_QWORD *)v2 + 1);
        *((_QWORD *)v5 + 1) = v7;
        if (v7)
        {
          v8 = (unint64_t *)(v7 + 8);
          do
            v9 = __ldxr(v8);
          while (__stxr(v9 + 1, v8));
        }
        v5 += 16;
      }
      a2[1] = v5;
      v2 = (__int128 *)((char *)v2 + 56);
    }
    while (v2 != v3);
  }
  return this;
}

void KB::LanguageModelContainer::prior_lexicon_probabilities(KB::LanguageModelContainer *this@<X0>, float **a2@<X8>)
{
  KB::LanguageModelLexiconGroup *v2;
  KB::LanguageModelLexiconGroup *v3;
  float *v5;
  unsigned int *v6;
  unsigned int *v7;
  unint64_t v8;
  float *v9;
  float v10;
  float v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  float *v16;
  float *v17;
  int v18;
  KB::LanguageModelLexiconGroup *v19;
  unsigned int *v20;
  unsigned int *v21;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = (KB::LanguageModelLexiconGroup *)*((_QWORD *)this + 3);
  v3 = (KB::LanguageModelLexiconGroup *)*((_QWORD *)this + 4);
  if (v2 != v3)
  {
    v5 = 0;
    v19 = (KB::LanguageModelLexiconGroup *)*((_QWORD *)this + 4);
    do
    {
      if (*(_QWORD *)v2)
      {
        (*(void (**)(unsigned int **__return_ptr))(**(_QWORD **)v2 + 48))(&v20);
        v6 = v20;
        v7 = v21;
        if (v20 != v21)
        {
          v8 = (unint64_t)a2[2];
          v9 = *a2;
          do
          {
            v10 = KB::LanguageModelLexiconGroup::lexicon_weight(v2, *v6);
            v11 = v10;
            if ((unint64_t)v5 >= v8)
            {
              v12 = v5 - v9;
              v13 = v12 + 1;
              if ((unint64_t)(v12 + 1) >> 62)
                abort();
              if ((uint64_t)(v8 - (_QWORD)v9) >> 1 > v13)
                v13 = (uint64_t)(v8 - (_QWORD)v9) >> 1;
              if (v8 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL)
                v14 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v14 = v13;
              if (v14)
                v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v14);
              else
                v15 = 0;
              v16 = (float *)(v14 + 4 * v12);
              *v16 = v11;
              v17 = v16 + 1;
              while (v5 != v9)
              {
                v18 = *((_DWORD *)v5-- - 1);
                *((_DWORD *)v16-- - 1) = v18;
              }
              v8 = v14 + 4 * v15;
              *a2 = v16;
              a2[1] = v17;
              a2[2] = (float *)v8;
              if (v9)
                operator delete(v9);
              v9 = v16;
              v5 = v17;
            }
            else
            {
              *v5++ = v10;
            }
            a2[1] = v5;
            ++v6;
          }
          while (v6 != v7);
          v3 = v19;
          v6 = v20;
        }
        if (v6)
        {
          v21 = v6;
          operator delete(v6);
        }
      }
      v2 = (KB::LanguageModelLexiconGroup *)((char *)v2 + 56);
    }
    while (v2 != v3);
  }
}

uint64_t KB::LanguageModelContainer::primary_language_model@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v2 = *(uint64_t **)(this + 24);
  if (v2 == *(uint64_t **)(this + 32))
  {
    *a2 = 0;
    a2[1] = 0;
  }
  else
  {
    v4 = *v2;
    v3 = v2[1];
    *a2 = v4;
    a2[1] = v3;
    if (v3)
    {
      v5 = (unint64_t *)(v3 + 8);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
  }
  return this;
}

float KB::LanguageModelContainer::lexicon_transition_probability(KB::LanguageModelContainer *this, uint64_t a2, unsigned int a3)
{
  return KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((_QWORD *)this + 3) + 56 * a2), a3)* 0.04;
}

BOOL KB::LanguageModelContainer::PredictionEnumeratorContainer::has_more_predictions(KB::LanguageModelContainer::PredictionEnumeratorContainer *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 9);
  return v1 != -1 && *(float *)(*((_QWORD *)this + 4) + 160 * v1 + 24) > 0.0;
}

void TI::IndicUtils::convertLetterToSign(uint64_t *a1@<X0>, const KB::String *a2@<X1>, uint64_t a3@<X8>)
{
  _BOOL4 v6;
  BOOL v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  const KB::String *v13;
  uint64_t v14;
  void *v16;
  const char *v17;
  void *v18;
  void *v19;
  int v20;
  char v21;
  _BOOL4 v22;
  KB::String *v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  __int128 v28;
  uint64_t v29;
  _BYTE v30[8];
  void *v31;
  _BYTE v32[8];
  void *v33;
  _BYTE v34[8];
  void *v35;
  _BYTE v36[8];
  void *v37;
  _BYTE v38[8];
  void *v39;
  _BYTE v40[8];
  void *v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  unsigned int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!*((_WORD *)a1 + 2))
  {
    KB::String::compute_length((unsigned __int16 *)a1);
    if (!*((_WORD *)a1 + 2))
    {
      *(_DWORD *)a3 = 0x100000;
      *(_WORD *)(a3 + 4) = 0;
      *(_BYTE *)(a3 + 6) = 0;
      *(_QWORD *)(a3 + 8) = 0;
      KB::String::operator=(a3, (KB::String *)a1);
      return;
    }
  }
  KB::String::String((KB::String *)a3, (const KB::String *)a1);
  KB::String::String((KB::String *)&v44, "ॲ");
  if (&v44 == a1)
  {
    v16 = (void *)a1[1];
    if (v16 && *((_BYTE *)a1 + 6) == 1)
      free(v16);
  }
  else
  {
    v6 = KB::String::equal((KB::String *)a1, (const KB::String *)&v44, 1);
    if (v45 && BYTE6(v44) == 1)
      free(v45);
    if (!v6)
    {
      KB::String::String((KB::String *)&v44, "ഔ");
      if (&v44 == a1)
      {
        v18 = (void *)a1[1];
        if (v18 && *((_BYTE *)a1 + 6) == 1)
          free(v18);
      }
      else
      {
        v7 = KB::String::equal((KB::String *)a1, (const KB::String *)&v44, 1);
        if (v45 && BYTE6(v44) == 1)
          free(v45);
        if (!v7)
        {
          v8 = 0;
          v9 = *((unsigned __int16 *)a1 + 2);
          v23 = (KB::String *)a3;
          while (1)
          {
            v10 = TI::IndicUtils::kVowelLettersA[v8];
            if (!v9)
            {
              KB::String::compute_length((unsigned __int16 *)a1);
              v9 = *((unsigned __int16 *)a1 + 2);
            }
            v11 = a1[1];
            v12 = *(unsigned __int16 *)a1;
            if (v9 > 1)
            {
              v13 = a2;
              if (v11)
                v14 = a1[1];
              else
                v14 = (uint64_t)(a1 + 2);
              v44 = v14;
              LODWORD(v45) = 0;
              HIDWORD(v45) = v12;
              v46 = 0;
              KB::String::iterator::initialize(&v44);
              if (v46 == v10)
              {
                *(_QWORD *)&v28 = v14;
                DWORD2(v28) = 0;
                HIDWORD(v28) = v12;
                LODWORD(v29) = 0;
                KB::String::iterator::initialize((uint64_t *)&v28);
                v42 = v28;
                v43 = v29;
                KB::String::iterator::operator++((uint64_t *)&v42);
                v24 = v14;
                v25 = v12;
                v26 = v12;
                v27 = 0;
                KB::String::iterator::initialize(&v24);
                KB::String::String((KB::String *)&v44, (const KB::String::iterator *)&v42, (const KB::String::iterator *)&v24);
                if (v10 == 2437 || v10 == 2821)
                {
                  KB::String::String((KB::String *)v36, (const KB::String *)&v44);
                  a2 = v13;
                  KB::String::String((KB::String *)v34, v13);
                  v22 = !shouldConvertToSign_beng_orya((KB::String *)v36, (KB::String *)v34);
                }
                else
                {
                  v22 = 0;
                  a2 = v13;
                  if (v10 == 2565)
                  {
                    KB::String::String((KB::String *)v40, (const KB::String *)&v44);
                    KB::String::String((KB::String *)v38, v13);
                    convertTippiToBindiIfNeeded((uint64_t)&v42, (const KB::String *)v40, (KB::String *)v38);
                    KB::String::operator=((uint64_t)&v44, (KB::String *)&v42);
                    a3 = (uint64_t)v23;
                    if (*((_QWORD *)&v42 + 1) && BYTE6(v42) == 1)
                      free(*((void **)&v42 + 1));
                    if (v39 && v38[6] == 1)
                      free(v39);
                    if (v41 && v40[6] == 1)
                      free(v41);
                    goto LABEL_78;
                  }
                }
                a3 = (uint64_t)v23;
                if (v10 == 2821 || v10 == 2437)
                {
                  if (v35 && v34[6] == 1)
                    free(v35);
                  if (v37 && v36[6] == 1)
                    free(v37);
                  if (!v22)
                    goto LABEL_78;
LABEL_77:
                  KB::String::operator=((KB::String *)&v44, (KB::String *)a1);
                }
                else if (v22)
                {
                  goto LABEL_77;
                }
LABEL_78:
                KB::String::operator=((KB::String *)a3, (KB::String *)&v44);
LABEL_79:
                v19 = v45;
                if (v45)
                {
                  v20 = BYTE6(v44);
                  goto LABEL_41;
                }
                goto LABEL_43;
              }
              a2 = v13;
              a3 = (uint64_t)v23;
            }
            if (!v11)
              v11 = (uint64_t)(a1 + 2);
            v44 = v11;
            LODWORD(v45) = 0;
            HIDWORD(v45) = v12;
            v46 = 0;
            KB::String::iterator::initialize(&v44);
            if (v46 > v10 && v10 + 16 > v46)
            {
              v44 = v11;
              LODWORD(v45) = 0;
              HIDWORD(v45) = v12;
              v46 = 0;
              KB::String::iterator::initialize(&v44);
              KB::String::String((uint64_t)&v44, v46 + 56);
              KB::String::operator=(a3, (KB::String *)&v44);
              goto LABEL_79;
            }
            if (++v8 == 9)
              goto LABEL_43;
          }
        }
      }
      v17 = "ൗ";
      goto LABEL_39;
    }
  }
  v17 = "ॅ";
LABEL_39:
  KB::String::String((KB::String *)&v42, v17);
  KB::String::operator=(a3, (KB::String *)&v42);
  v19 = (void *)*((_QWORD *)&v42 + 1);
  if (*((_QWORD *)&v42 + 1))
  {
    v20 = BYTE6(v42);
LABEL_41:
    if (v20 == 1)
      free(v19);
  }
LABEL_43:
  KB::String::String((KB::String *)v32, (const KB::String *)a3);
  KB::String::String((KB::String *)v30, a2);
  v21 = shouldAddSignToContext((uint64_t)v32, (KB::String *)v30);
  if (v31 && v30[6] == 1)
    free(v31);
  if (v33 && v32[6] == 1)
    free(v33);
  if ((v21 & 1) == 0)
    KB::String::operator=((KB::String *)a3, (KB::String *)a1);
}

uint64_t convertTippiToBindiIfNeeded(uint64_t a1, const KB::String *a2, KB::String *a3)
{
  int v6;
  _BYTE v8[8];
  void *v9;
  _BYTE v10[8];
  void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (KB::String::last(a2) == 2672)
  {
    if ((v6 = KB::String::last(a3), (v6 - 2566) <= 0x3A)
      && ((1 << (v6 - 6)) & 0x50000000000661DLL) != 0
      || (v6 - 2631) <= 5 && ((1 << (v6 - 71)) & 0x33) != 0)
    {
      KB::String::String((KB::String *)v8, a2);
      convertTippiToBindi((uint64_t)v10, (KB::String *)v8);
      KB::String::operator=((uint64_t)a2, (KB::String *)v10);
      if (v11 && v10[6] == 1)
        free(v11);
      if (v9 && v8[6] == 1)
        free(v9);
    }
  }
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 6) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  return KB::String::operator=(a1, a2);
}

BOOL shouldConvertToSign_beng_orya(KB::String *a1, KB::String *a2)
{
  return (a1 != (KB::String *)&kVowelSignYAPHALAA_beng
       && !KB::String::equal(a1, (const KB::String *)&kVowelSignYAPHALAA_beng, 1)
       || KB::String::last(a2) - 2494 >= 0xF)
      && (a1 != (KB::String *)&kVowelSignYAPHALAA_orya
       && !KB::String::equal(a1, (const KB::String *)&kVowelSignYAPHALAA_orya, 1)
       || KB::String::last(a2) - 2878 >= 0xF);
}

unint64_t shouldAddSignToContext(uint64_t a1, KB::String *a2)
{
  _BOOL4 v4;
  BOOL v5;
  _BOOL4 v6;
  _BOOL4 v7;
  _BOOL4 v8;
  void *v9;
  int v10;
  unint64_t result;
  unsigned int v12;
  void *v13;
  int v14;
  void *v15;
  int v16;
  void *v17;
  int v18;
  unsigned int v19;
  _BYTE v20[6];
  char v21;
  void *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  KB::String::String((KB::String *)v20, "ँ");
  if (v20 == (_BYTE *)a1)
  {
    v9 = *(void **)(a1 + 8);
    if (v9 && *(_BYTE *)(a1 + 6) == 1)
      free(v9);
  }
  else
  {
    v4 = KB::String::equal((KB::String *)a1, (const KB::String *)v20, 1);
    if (v22)
      v5 = v21 == 1;
    else
      v5 = 0;
    if (v5)
      free(v22);
    if (!v4)
    {
      KB::String::String((KB::String *)v20, "ં");
      if (v20 == (_BYTE *)a1)
      {
        v13 = *(void **)(a1 + 8);
        if (v13 && *(_BYTE *)(a1 + 6) == 1)
          free(v13);
      }
      else
      {
        v6 = KB::String::equal((KB::String *)a1, (const KB::String *)v20, 1);
        if (v22 && v21 == 1)
          free(v22);
        if (!v6)
        {
          KB::String::String((KB::String *)v20, "ઁ");
          if (v20 == (_BYTE *)a1)
          {
            v15 = *(void **)(a1 + 8);
            if (v15 && *(_BYTE *)(a1 + 6) == 1)
              free(v15);
          }
          else
          {
            v7 = KB::String::equal((KB::String *)a1, (const KB::String *)v20, 1);
            if (v22 && v21 == 1)
              free(v22);
            if (!v7)
            {
              KB::String::String((KB::String *)v20, "ੱ");
              if (v20 == (_BYTE *)a1)
              {
                v17 = *(void **)(a1 + 8);
                if (v17 && *(_BYTE *)(a1 + 6) == 1)
                  free(v17);
LABEL_50:
                v18 = KB::String::last(a2);
                if ((v18 - 2566) > 0x3C
                  || ((1 << (v18 - 6)) & 0x1500000000006615) == 0)
                {
                  result = 1;
                  v19 = v18 - 2631;
                  if (v19 > 5 || ((1 << v19) & 0x33) == 0)
                    return result;
                }
                return 0;
              }
              v8 = KB::String::equal((KB::String *)a1, (const KB::String *)v20, 1);
              if (v22 && v21 == 1)
                free(v22);
              if (v8)
                goto LABEL_50;
              return 1;
            }
          }
          v16 = KB::String::last(a2);
          return ((v16 - 2701) > 0x3F
               || ((1 << (v16 + 115)) & 0xDD0C0000000000DDLL) == 0)
              && (v16 - 2695) >= 4;
        }
      }
      v14 = KB::String::last(a2);
      if ((v14 - 2701) >= 0x3D)
        return 1;
      else
        return (0xEFFFFFFFFFFFFEEuLL >> (v14 + 115)) & 1;
    }
  }
  v10 = KB::String::last(a2);
  if ((v10 - 2312) <= 0x3D && ((1 << (v10 - 8)) & 0x2180000000001B01) != 0)
    return 0;
  result = 1;
  v12 = v10 - 2375;
  if (v12 <= 0x2B && ((1 << v12) & 0x80000000037) != 0)
    return 0;
  return result;
}

uint64_t KB::String::last(KB::String *this)
{
  int v1;
  char *v2;
  __int128 v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;

  v1 = *(unsigned __int16 *)this;
  if (!*(_WORD *)this)
    return 0;
  v2 = (char *)*((_QWORD *)this + 1);
  if (!v2)
    v2 = (char *)this + 16;
  *(_QWORD *)&v4 = v2;
  DWORD2(v4) = v1;
  HIDWORD(v4) = v1;
  LODWORD(v5) = 0;
  KB::String::iterator::initialize((uint64_t *)&v4);
  v6 = v4;
  v7 = v5;
  KB::String::iterator::operator--((KB::String::iterator *)&v6);
  return v7;
}

uint64_t convertTippiToBindi(uint64_t a1, KB::String *a2)
{
  if (KB::String::last(a2) == 2672)
  {
    KB::String::pop_last(a2);
    KB::String::append(a2, 0xA02u);
  }
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 6) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  return KB::String::operator=(a1, a2);
}

void TI::IndicUtils::convertModifierLetterToSign(unsigned __int16 *a1@<X0>, const KB::String *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  _BOOL4 v11;
  char v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  __int128 v17;
  uint64_t v18;
  _BYTE v19[8];
  void *v20;
  _BYTE v21[8];
  void *v22;
  _BYTE v23[8];
  void *v24;
  _BYTE v25[8];
  void *v26;
  _BYTE v27[8];
  void *v28;
  _BYTE v29[8];
  void *v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v6 = a1[2];
  if (!a1[2])
  {
    KB::String::compute_length(a1);
    v6 = a1[2];
  }
  if (v6 <= 1)
  {
    *(_DWORD *)a3 = 0x100000;
    *(_WORD *)(a3 + 4) = 0;
    *(_BYTE *)(a3 + 6) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    KB::String::operator=(a3, (KB::String *)a1);
    return;
  }
  KB::String::String((KB::String *)a3, (const KB::String *)a1);
  v7 = 0;
  if (*((_QWORD *)a1 + 1))
    v8 = *((_QWORD *)a1 + 1);
  else
    v8 = (uint64_t)(a1 + 8);
  v9 = *a1;
  while (1)
  {
    v10 = TI::IndicUtils::kVowelLettersA[v7];
    v33 = v8;
    LODWORD(v34) = 0;
    HIDWORD(v34) = v9;
    v35 = 0;
    KB::String::iterator::initialize(&v33);
    if (v35 == v10)
      break;
    if (++v7 == 9)
      goto LABEL_40;
  }
  *(_QWORD *)&v17 = v8;
  DWORD2(v17) = 0;
  HIDWORD(v17) = v9;
  LODWORD(v18) = 0;
  KB::String::iterator::initialize((uint64_t *)&v17);
  v31 = v17;
  v32 = v18;
  KB::String::iterator::operator++((uint64_t *)&v31);
  v13 = v8;
  v14 = v9;
  v15 = v9;
  v16 = 0;
  KB::String::iterator::initialize(&v13);
  KB::String::String((KB::String *)&v33, (const KB::String::iterator *)&v31, (const KB::String::iterator *)&v13);
  if (v10 == 2437 || v10 == 2821)
  {
    KB::String::String((KB::String *)v25, (const KB::String *)&v33);
    KB::String::String((KB::String *)v23, a2);
    v11 = !shouldConvertToSign_beng_orya((KB::String *)v25, (KB::String *)v23);
  }
  else
  {
    v11 = 0;
    if (v10 == 2565)
    {
      KB::String::String((KB::String *)v29, (const KB::String *)&v33);
      KB::String::String((KB::String *)v27, a2);
      convertTippiToBindiIfNeeded((uint64_t)&v31, (const KB::String *)v29, (KB::String *)v27);
      KB::String::operator=((uint64_t)&v33, (KB::String *)&v31);
      if (*((_QWORD *)&v31 + 1) && BYTE6(v31) == 1)
        free(*((void **)&v31 + 1));
      if (v28 && v27[6] == 1)
        free(v28);
      if (v30 && v29[6] == 1)
        free(v30);
      goto LABEL_37;
    }
  }
  if (v10 != 2821 && v10 != 2437)
  {
    if (!v11)
      goto LABEL_37;
    goto LABEL_36;
  }
  if (v24 && v23[6] == 1)
    free(v24);
  if (v26 && v25[6] == 1)
    free(v26);
  if (v11)
LABEL_36:
    KB::String::operator=((KB::String *)&v33, (KB::String *)a1);
LABEL_37:
  KB::String::operator=((KB::String *)a3, (KB::String *)&v33);
  if (v34 && BYTE6(v33) == 1)
    free(v34);
LABEL_40:
  KB::String::String((KB::String *)v21, (const KB::String *)a3);
  KB::String::String((KB::String *)v19, a2);
  v12 = shouldAddSignToContext((uint64_t)v21, (KB::String *)v19);
  if (v20 && v19[6] == 1)
    free(v20);
  if (v22 && v21[6] == 1)
    free(v22);
  if ((v12 & 1) == 0)
    KB::String::operator=((KB::String *)a3, (KB::String *)a1);
}

void TI::IndicUtils::convertVowel(const KB::String *a1@<X0>, uint64_t a2@<X8>)
{
  BOOL v4;
  _BOOL4 v5;
  const char *v6;
  const KB::String *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v15;
  void *v16;
  int v17;
  KB::String *v18;
  const char *v19;
  unsigned int v20;
  _BYTE v21[8];
  void *v22;
  _BYTE v23[8];
  void *v24;
  unsigned __int16 v25[2];
  __int16 v26;
  char v27;
  void *v28;
  uint64_t v29;
  uint64_t *v30;
  void *v31;
  unsigned int v32;
  int v33;
  __int16 v34;
  char v35;
  void *v36;
  char v37;
  uint64_t v38;
  void *v39;
  _BYTE v40[8];
  void *v41;
  uint64_t *v42;
  void *v43;
  unsigned int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  KB::String::String((KB::String *)&v38, a1);
  v33 = 0x100000;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  TI::IndicUtils::convertLetterToSign(&v38, (const KB::String *)&v33, (uint64_t)v40);
  if (v36)
    v4 = v35 == 1;
  else
    v4 = 0;
  if (v4)
    free(v36);
  if (v39 && BYTE6(v38) == 1)
    free(v39);
  if (v40 == (_BYTE *)a1 || KB::String::equal((KB::String *)v40, a1, 1))
  {
    KB::String::String((KB::String *)v25, a1);
    if (v26 || (KB::String::compute_length(v25), v26))
    {
      KB::String::String((KB::String *)&v42, "ॅ");
      v5 = KB::String::equal((KB::String *)v25, (const KB::String *)&v42, 1);
      if (v43 && BYTE6(v42) == 1)
        free(v43);
      if (v5)
      {
        v6 = "ॲ";
LABEL_19:
        KB::String::String((KB::String *)&v30, v6);
        goto LABEL_43;
      }
      if (KB::String::equal((KB::String *)v25, (const KB::String *)&kVowelSignYAPHALAA_beng, 1))
      {
        v7 = (const KB::String *)&kVowelLetterYAPHALAA_beng;
      }
      else
      {
        if (!KB::String::equal((KB::String *)v25, (const KB::String *)&kVowelSignYAPHALAA_orya, 1))
        {
          KB::String::String((KB::String *)&v42, "ൗ");
          v8 = KB::String::equal((KB::String *)v25, (const KB::String *)&v42, 1);
          if (v43 && BYTE6(v42) == 1)
            free(v43);
          if (!v8)
          {
            v9 = 0;
            if (v28)
              v10 = (uint64_t *)v28;
            else
              v10 = &v29;
            v11 = v25[0];
            while (1)
            {
              v12 = TI::IndicUtils::kVowelLettersA[v9];
              v42 = v10;
              LODWORD(v43) = 0;
              HIDWORD(v43) = v11;
              v44 = 0;
              KB::String::iterator::initialize((uint64_t *)&v42);
              if (v12 - 4 <= v44 && v12 - 1 > v44)
                break;
              if ((v44 & 0xFFFFFFFE) == 0xA70)
                break;
              v42 = v10;
              LODWORD(v43) = 0;
              HIDWORD(v43) = v11;
              v44 = 0;
              KB::String::iterator::initialize((uint64_t *)&v42);
              v13 = v44 - 56;
              if (v44 - 56 > v12 && v12 + 16 > v13)
              {
                KB::String::String((uint64_t)&v30, v13);
                goto LABEL_43;
              }
              if (++v9 == 9)
                goto LABEL_42;
            }
            KB::String::String((uint64_t)&v42, v12);
            v30 = v10;
            LODWORD(v31) = 0;
            HIDWORD(v31) = v11;
            v32 = 0;
            KB::String::iterator::initialize((uint64_t *)&v30);
            v20 = v32;
            KB::String::String((KB::String *)&v30, (const KB::String *)&v42);
            KB::String::append((KB::String *)&v30, v20);
            if (v43 && BYTE6(v42) == 1)
              free(v43);
            goto LABEL_43;
          }
          v6 = "ഔ";
          goto LABEL_19;
        }
        v7 = (const KB::String *)&kVowelLetterYAPHALAA_orya;
      }
      KB::String::String((KB::String *)&v30, v7);
    }
    else
    {
LABEL_42:
      LODWORD(v30) = 0x100000;
      WORD2(v30) = 0;
      BYTE6(v30) = 0;
      v31 = 0;
      KB::String::operator=((uint64_t)&v30, (KB::String *)v25);
    }
LABEL_43:
    KB::String::operator=((uint64_t)v40, (KB::String *)&v30);
    if (v31 && BYTE6(v30) == 1)
      free(v31);
    if (v28 && v27 == 1)
      free(v28);
  }
  v15 = KB::String::last((KB::String *)v40);
  if (v15 > 2673)
  {
    if (v15 == 2674)
    {
      KB::String::String((KB::String *)a2, "ਇ");
      KB::String::String((KB::String *)(a2 + 32), "ਈ");
      v18 = (KB::String *)(a2 + 64);
      v19 = "ਏ";
    }
    else
    {
      if (v15 != 2675)
        goto LABEL_65;
      KB::String::String((KB::String *)a2, "ਉ");
      KB::String::String((KB::String *)(a2 + 32), "ਊ");
      v18 = (KB::String *)(a2 + 64);
      v19 = "ਓ";
    }
    KB::String::String(v18, v19);
    goto LABEL_66;
  }
  if (v15 != 2562)
  {
    if (v15 == 2672)
    {
      KB::String::String((KB::String *)a2, (const KB::String *)v40);
      KB::String::String((KB::String *)v23, (const KB::String *)v40);
      convertTippiToBindi(a2 + 32, (KB::String *)v23);
      *(_DWORD *)(a2 + 64) = 0x100000;
      *(_WORD *)(a2 + 68) = 0;
      *(_BYTE *)(a2 + 70) = 0;
      *(_QWORD *)(a2 + 72) = 0;
      *(_BYTE *)(a2 + 80) = 0;
      v16 = v24;
      if (!v24)
        goto LABEL_66;
      v17 = v23[6];
      goto LABEL_61;
    }
LABEL_65:
    KB::String::String((KB::String *)a2, (const KB::String *)v40);
    *(_DWORD *)(a2 + 32) = 0x100000;
    *(_WORD *)(a2 + 36) = 0;
    *(_BYTE *)(a2 + 38) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    *(_BYTE *)(a2 + 48) = 0;
    *(_DWORD *)(a2 + 64) = 0x100000;
    *(_WORD *)(a2 + 68) = 0;
    *(_BYTE *)(a2 + 70) = 0;
    *(_QWORD *)(a2 + 72) = 0;
    *(_BYTE *)(a2 + 80) = 0;
    goto LABEL_66;
  }
  KB::String::String((KB::String *)a2, (const KB::String *)v40);
  KB::String::String((KB::String *)v21, (const KB::String *)v40);
  if (KB::String::last((KB::String *)v21) == 2562)
  {
    KB::String::pop_last((KB::String *)v21);
    KB::String::append((KB::String *)v21, 0xA70u);
  }
  *(_DWORD *)(a2 + 32) = 0x100000;
  *(_WORD *)(a2 + 36) = 0;
  *(_BYTE *)(a2 + 38) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  KB::String::operator=(a2 + 32, (KB::String *)v21);
  *(_DWORD *)(a2 + 64) = 0x100000;
  *(_WORD *)(a2 + 68) = 0;
  *(_BYTE *)(a2 + 70) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_BYTE *)(a2 + 80) = 0;
  v16 = v22;
  if (v22)
  {
    v17 = v21[6];
LABEL_61:
    if (v17 == 1)
      free(v16);
  }
LABEL_66:
  if (v41)
  {
    if (v40[6] == 1)
      free(v41);
  }
}

uint64_t TI::IndicUtils::initialVowelLetterForScript(int a1)
{
  if (a1 <= 20)
  {
    if (a1 > 14)
    {
      if (a1 == 15)
        return 2693;
      if (a1 == 16)
        return 2565;
    }
    else
    {
      if (a1 == 4)
        return 2437;
      if (a1 == 10)
        return 2309;
    }
  }
  else if (a1 <= 30)
  {
    if (a1 == 21)
      return 3205;
    if (a1 == 26)
      return 3333;
  }
  else
  {
    switch(a1)
    {
      case 31:
        return 2821;
      case 35:
        return 2949;
      case 36:
        return 3077;
    }
  }
  return 0;
}

uint64_t TI::IndicUtils::viramaSignForScript(int a1)
{
  return TI::IndicUtils::initialVowelLetterForScript(a1) + 72;
}

uint64_t TI::IndicUtils::consonantLetterRAForScript(int a1)
{
  return TI::IndicUtils::initialVowelLetterForScript(a1) + 43;
}

BOOL TI::IndicUtils::isAlphabeticLayout(KB::String *a1)
{
  _BOOL8 v2;
  BOOL v3;
  _BYTE v5[8];
  void *v6;
  _BYTE v7[8];
  void *v8;
  _BYTE v9[8];
  void *v10;
  _BYTE v11[8];
  void *v12;
  _BYTE v13[8];
  void *v14;
  _BYTE v15[8];
  void *v16;
  _BYTE v17[8];
  void *v18;
  _BYTE v19[8];
  void *v20;
  _BYTE v21[8];
  void *v22;
  _BYTE v23[8];
  void *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  KB::String::String((KB::String *)v23, "Bengali-Alphabetic");
  v2 = 1;
  if (!KB::String::equal(a1, (const KB::String *)v23, 1))
  {
    KB::String::String((KB::String *)v21, "Gujarati-Alphabetic");
    if (!KB::String::equal(a1, (const KB::String *)v21, 1))
    {
      KB::String::String((KB::String *)v19, "Hindi-Alphabetic");
      if (!KB::String::equal(a1, (const KB::String *)v19, 1))
      {
        KB::String::String((KB::String *)v17, "Kannada-Alphabetic");
        if (!KB::String::equal(a1, (const KB::String *)v17, 1))
        {
          KB::String::String((KB::String *)v15, "Malayalam-Alphabetic");
          if (!KB::String::equal(a1, (const KB::String *)v15, 1))
          {
            KB::String::String((KB::String *)v13, "Marathi-Alphabetic");
            if (!KB::String::equal(a1, (const KB::String *)v13, 1))
            {
              KB::String::String((KB::String *)v11, "Oriya-Alphabetic");
              if (!KB::String::equal(a1, (const KB::String *)v11, 1))
              {
                KB::String::String((KB::String *)v9, "Punjabi-Alphabetic");
                if (!KB::String::equal(a1, (const KB::String *)v9, 1))
                {
                  KB::String::String((KB::String *)v7, "Tamil-Alphabetic");
                  if (!KB::String::equal(a1, (const KB::String *)v7, 1))
                  {
                    KB::String::String((KB::String *)v5, "Telugu-Alphabetic");
                    v2 = KB::String::equal(a1, (const KB::String *)v5, 1);
                    if (v6)
                    {
                      if (v5[6] == 1)
                        free(v6);
                    }
                  }
                  if (v8 && v7[6] == 1)
                    free(v8);
                }
                if (v10 && v9[6] == 1)
                  free(v10);
              }
              if (v12 && v11[6] == 1)
                free(v12);
            }
            if (v14 && v13[6] == 1)
              free(v14);
          }
          if (v16 && v15[6] == 1)
            free(v16);
        }
        if (v18 && v17[6] == 1)
          free(v18);
      }
      if (v20 && v19[6] == 1)
        free(v20);
    }
    if (v22 && v21[6] == 1)
      free(v22);
  }
  if (v24)
    v3 = v23[6] == 1;
  else
    v3 = 0;
  if (v3)
    free(v24);
  return v2;
}

_BYTE *KB::SetOnlySearchSupplementalLexiconForScope::SetOnlySearchSupplementalLexiconForScope(_BYTE *this, int a2)
{
  int v2;
  BOOL v3;

  *this = a2;
  v2 = KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon;
  this[1] = KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon;
  if (v2)
    v3 = 1;
  else
    v3 = a2 == 0;
  if (!v3)
    KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon = 1;
  return this;
}

{
  int v2;
  BOOL v3;

  *this = a2;
  v2 = KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon;
  this[1] = KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon;
  if (v2)
    v3 = 1;
  else
    v3 = a2 == 0;
  if (!v3)
    KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon = 1;
  return this;
}

void KB::SetOnlySearchSupplementalLexiconForScope::~SetOnlySearchSupplementalLexiconForScope(KB::SetOnlySearchSupplementalLexiconForScope *this)
{
  if (*(_BYTE *)this)
  {
    if (!*((_BYTE *)this + 1))
      KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon = 0;
  }
}

{
  if (*(_BYTE *)this)
  {
    if (!*((_BYTE *)this + 1))
      KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon = 0;
  }
}

_BYTE *KB::SetInputHasSupplementalPrefixForScope::SetInputHasSupplementalPrefixForScope(_BYTE *this, int a2)
{
  int v2;
  BOOL v3;

  *this = a2;
  v2 = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
  this[1] = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
  if (v2)
    v3 = 1;
  else
    v3 = a2 == 0;
  if (!v3)
    KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix = 1;
  return this;
}

{
  int v2;
  BOOL v3;

  *this = a2;
  v2 = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
  this[1] = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
  if (v2)
    v3 = 1;
  else
    v3 = a2 == 0;
  if (!v3)
    KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix = 1;
  return this;
}

void KB::SetInputHasSupplementalPrefixForScope::~SetInputHasSupplementalPrefixForScope(KB::SetInputHasSupplementalPrefixForScope *this)
{
  if (*(_BYTE *)this)
  {
    if (!*((_BYTE *)this + 1))
      KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix = 0;
  }
}

{
  if (*(_BYTE *)this)
  {
    if (!*((_BYTE *)this + 1))
      KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix = 0;
  }
}

void KB::InputManagerSpecialization::~InputManagerSpecialization(KB::InputManagerSpecialization *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1EA0FD7C8;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 1) = 0;
}

{
  const void *v2;

  *(_QWORD *)this = &off_1EA0FD7C8;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x1DF0A2144);
}

{
  const void *v2;

  *(_QWORD *)this = &off_1EA0FD7C8;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 1) = 0;
}

void KB::InputManagerSpecialization::create_input_segment_filter(_QWORD *a1@<X8>)
{
  unsigned __int8 v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;

  if ((v2 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))WTF::RefPtr<KB::InputSegmentFilter>::~RefPtr, &KB::InputManagerSpecialization::create_input_segment_filter(WTF::PassRefPtr<TI::Favonius::KeyboardLayout>)const::filter, &dword_1DA6F2000);
  }
  if (KB::InputManagerSpecialization::create_input_segment_filter(WTF::PassRefPtr<TI::Favonius::KeyboardLayout>)const::once != -1)
    dispatch_once(&KB::InputManagerSpecialization::create_input_segment_filter(WTF::PassRefPtr<TI::Favonius::KeyboardLayout>)const::once, &__block_literal_global_4641);
  v3 = KB::InputManagerSpecialization::create_input_segment_filter(WTF::PassRefPtr<TI::Favonius::KeyboardLayout>)const::filter;
  *a1 = KB::InputManagerSpecialization::create_input_segment_filter(WTF::PassRefPtr<TI::Favonius::KeyboardLayout>)const::filter;
  if (v3)
  {
    v4 = (unsigned int *)(v3 + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
  }
}

uint64_t KB::InputManagerSpecialization::get_does_need_spell_check(KB::InputManagerSpecialization *this, const KB::String *a2)
{
  return 0;
}

uint64_t KB::InputManagerSpecialization::get_period_ends_sentence_after_word(KB::InputManagerSpecialization *this, const KB::String *a2)
{
  return 1;
}

uint64_t KB::InputManagerSpecialization::get_should_correct_explicitly_shifted_word(KB::InputManagerSpecialization *this)
{
  return 1;
}

uint64_t KB::InputManagerSpecialization::get_should_promote_case_variants_of_top_candidate(KB::InputManagerSpecialization *this)
{
  return 0;
}

uint64_t KB::InputManagerSpecialization::do_capitalize_first_letter(KB::InputManagerSpecialization *this, KB::Word *a2, int a3)
{
  return KB::Word::capitalize_first_letter(a2, a3);
}

void KB::InputManagerSpecialization::do_create_custom_candidate_filter(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

unsigned int **WTF::RefPtr<KB::InputSegmentFilter>::~RefPtr(unsigned int **a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *a1;
  if (v2)
  {
    v3 = v2 + 2;
    v4 = atomic_load(v2 + 2);
    if (v4 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
    else
    {
      do
        v5 = __ldaxr(v3);
      while (__stlxr(v5 - 1, v3));
    }
  }
  return a1;
}

void KB::DefaultInputSegmentFilter::~DefaultInputSegmentFilter(KB::DefaultInputSegmentFilter *this)
{
  JUMPOUT(0x1DF0A2144);
}

KB::InputManagerSpecialization *KB::InputManagerSpecialization::InputManagerSpecialization(KB::InputManagerSpecialization *this, CFTypeRef cf)
{
  *(_QWORD *)this = &off_1EA0FD7C8;
  *((_QWORD *)this + 1) = cf;
  if (cf)
  {
    CFRetain(cf);
    *((_QWORD *)this + 1) = cf;
  }
  return this;
}

{
  *(_QWORD *)this = &off_1EA0FD7C8;
  *((_QWORD *)this + 1) = cf;
  if (cf)
  {
    CFRetain(cf);
    *((_QWORD *)this + 1) = cf;
  }
  return this;
}

void TIInputManager_translit::~TIInputManager_translit(TIInputManager_translit *this)
{
  TIInputManager::~TIInputManager(this);
  JUMPOUT(0x1DF0A2144);
}

_QWORD *TIInputManager_translit::create_custom_candidate_filter@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x20uLL);
  v2[1] = 0;
  v2[2] = 0;
  *v2 = &off_1EA0FD850;
  a1[1] = v2;
  v2[3] = &off_1EA1009B0;
  result = v2 + 3;
  *a1 = result;
  return result;
}

KB::String *TIInputManager::filter_pre_lookup_input@<X0>(const KB::String *a1@<X1>, KB::String *a2@<X8>)
{
  return KB::String::String(a2, a1);
}

void TIInputManager::internal_string_to_external(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[32] = 0;
}

void TIInputManager::external_string_to_internal(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[32] = 0;
}

uint64_t TIInputManager::should_exclude_filter_corrections_if_any_candidate_matches_input(TIInputManager *this)
{
  return 0;
}

void std::__shared_ptr_emplace<KB::CandidateFilter_Indic>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD850;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::CandidateFilter_Indic>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FD850;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::CandidateFilter_Indic>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t _getRandomNForMaxN(int a1)
{
  uint64_t result;

  LODWORD(result) = arc4random_uniform(a1 + 1);
  if (result <= 2)
    return 2;
  else
    return result;
}

void TIInputManager::~TIInputManager(TIInputManager *this)
{
  TIInputManager::~TIInputManager(this);
  JUMPOUT(0x1DF0A2144);
}

{
  const void *v2;
  const void *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  unsigned int *v11;
  void *v12;
  uint64_t v13;
  const void *v14;
  void *v15;
  void *v16;
  void *v17;
  void **v18;

  *(_QWORD *)this = &off_1EA0FD888;
  v2 = (const void *)*((_QWORD *)this + 70);
  if (v2)
    _Block_release(v2);
  v3 = (const void *)*((_QWORD *)this + 87);
  if (v3)
    CFRelease(v3);
  std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>>>::destroy(*((_QWORD **)this + 83));
  TI::VulgarWordUsageDatabaseWrapper::~VulgarWordUsageDatabaseWrapper((const void **)this + 74);
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 568);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 69);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  v18 = (void **)((char *)this + 512);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v18);
  language_modeling::v1::LinguisticContext::~LinguisticContext((TIInputManager *)((char *)this + 504));
  language_modeling::v1::LinguisticContext::~LinguisticContext((TIInputManager *)((char *)this + 496));
  v7 = (void *)*((_QWORD *)this + 56);
  if (v7)
  {
    *((_QWORD *)this + 57) = v7;
    operator delete(v7);
  }
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 432);
  v8 = (void *)*((_QWORD *)this + 51);
  if (v8 && *((_BYTE *)this + 406) == 1)
    free(v8);
  std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(*((_QWORD **)this + 42));
  v9 = *((_QWORD *)this + 40);
  if (v9)
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v9);
  v10 = (void *)*((_QWORD *)this + 37);
  if (v10 && *((_BYTE *)this + 294) == 1)
    free(v10);
  WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::~Vector((_QWORD *)this + 32);
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 232);
  v11 = (unsigned int *)*((_QWORD *)this + 28);
  if (v11)
    WTF::RefCounted<KB::DictionaryContainer>::deref(v11);
  v12 = (void *)*((_QWORD *)this + 25);
  if (v12 && *((_BYTE *)this + 198) == 1)
    free(v12);
  v13 = *((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  v14 = (const void *)*((_QWORD *)this + 17);
  if (v14)
    CFRelease(v14);
  *((_QWORD *)this + 17) = 0;
  v15 = (void *)*((_QWORD *)this + 14);
  if (v15 && *((_BYTE *)this + 110) == 1)
    free(v15);
  v16 = (void *)*((_QWORD *)this + 9);
  if (v16 && *((_BYTE *)this + 70) == 1)
    free(v16);
  v17 = (void *)*((_QWORD *)this + 5);
  if (v17 && *((_BYTE *)this + 38) == 1)
    free(v17);
  v18 = (void **)((char *)this + 8);
  std::vector<KB::Input>::__destroy_vector::operator()[abi:nn180100](&v18);
}

void TIInputManager::autocorrections(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _BYTE *v6;
  _BOOL4 v7;
  _BYTE v8[6];
  char v9;
  void *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 536))
  {
    TIInputManager::lookup(a1, 0, 1u, a2, a3);
    return;
  }
  if (*(_BYTE *)(a1 + 680))
    goto LABEL_4;
  v6 = (_BYTE *)(a1 + 32);
  if (*(_WORD *)(a1 + 32))
  {
    TIInputManager::legacy_input_stem((TIInputManager *)a1, (uint64_t)v8);
    if (v6 == v8)
    {
      if (v10 && v9 == 1)
        free(v10);
    }
    else
    {
      v7 = KB::String::equal((KB::String *)(a1 + 32), (const KB::String *)v8, 1);
      if (v10)
      {
        if (v9 == 1)
          free(v10);
      }
      if (!v7)
        goto LABEL_11;
    }
LABEL_4:
    *(_QWORD *)(a3 + 100) = 0x10000000000000;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_WORD *)(a3 + 108) = 0;
    *(_BYTE *)(a3 + 110) = 0;
    *(_QWORD *)(a3 + 112) = 0;
    *(_BYTE *)(a3 + 120) = 0;
    return;
  }
LABEL_11:
  TIInputManager::lookup(a1, 0, 1u, a2, a3);
}

void TIInputManager::completion_candidates(uint64_t a1@<X0>, unsigned int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  TIInputManager::lookup(a1, 1, a2, a3, a4);
}

void TIInputManager::inline_completion_candidates(void *aBlock@<X4>, uint64_t a2@<X0>, uint64_t a3@<X1>, const KB::String *a4@<X2>, uint64_t a5@<X3>, uint64_t a6@<X8>)
{
  void *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD v22[3];
  _OWORD v23[3];
  int v24;
  char v25;
  __int128 v26;
  void *__p[2];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  _QWORD v33[2];
  void **v34;
  _QWORD v35[3];
  _QWORD *v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  _BYTE v46[8];
  void *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v11 = _Block_copy(aBlock);
  v33[0] = v11;
  v33[1] = a2;
  if (*(_BYTE *)(a2 + 680))
  {
    v24 = 0;
    memset(v22, 0, sizeof(v22));
    memset(v23, 0, sizeof(v23));
    bzero(&v37, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)&v37);
    v32 = 0;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    *(_OWORD *)__p = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v30);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v30 + 8));
    v31 = 0uLL;
    v32 = 0;
    TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))const::$_0::operator()((uint64_t)v33, (uint64_t)v22, &v37, (const KB::LanguageModelContext *)&v26, 0);
    v34 = (void **)&v31;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v34);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v30 + 8));
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v30);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v26 + 1);
    if (*((_QWORD *)&v26 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v26 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    KB::Candidate::~Candidate((KB::Candidate *)&v37);
    *(_BYTE *)a6 = 0;
    *(_BYTE *)(a6 + 136) = 0;
LABEL_10:
    *(_QWORD *)&v37 = (char *)&v23[1] + 8;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
    *(_QWORD *)&v37 = v23;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
    *(_QWORD *)&v37 = (char *)&v22[1] + 8;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
    *(_QWORD *)&v37 = v22;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
    return;
  }
  v15 = *(_QWORD *)(a2 + 184);
  v35[0] = &off_1EA0FD9E8;
  v35[1] = v11;
  v35[2] = a2;
  v36 = v35;
  (*(void (**)(_OWORD *__return_ptr, uint64_t, const KB::String *, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v15 + 80))(v22, v15, a4, a3, a5, v35);
  v16 = v36;
  if (v36 == v35)
  {
    v17 = 4;
    v16 = v35;
  }
  else
  {
    if (!v36)
      goto LABEL_16;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_16:
  if (v25)
  {
    KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)&v37, (const KB::Candidate **)v22);
    KB::String::String((KB::String *)v46, a4);
    *(_OWORD *)a6 = v37;
    v18 = v40;
    *(_QWORD *)(a6 + 16) = v38;
    v37 = 0uLL;
    *(_OWORD *)(a6 + 24) = v39;
    *(_QWORD *)(a6 + 40) = v18;
    v38 = 0;
    v39 = 0uLL;
    v40 = 0;
    *(_OWORD *)(a6 + 48) = v41;
    v19 = v44;
    *(_QWORD *)(a6 + 64) = v42;
    v41 = 0uLL;
    *(_OWORD *)(a6 + 72) = v43;
    *(_QWORD *)(a6 + 88) = v19;
    v42 = 0;
    v43 = 0uLL;
    v44 = 0;
    v20 = v45;
    *(_DWORD *)(a6 + 104) = 0x100000;
    v21 = a6 + 104;
    *(_QWORD *)(v21 - 8) = v20;
    *(_WORD *)(v21 + 4) = 0;
    *(_BYTE *)(v21 + 6) = 0;
    *(_QWORD *)(v21 + 8) = 0;
    KB::String::operator=(v21, (KB::String *)v46);
    *(_BYTE *)(v21 + 32) = 1;
    if (v47 && v46[6] == 1)
      free(v47);
    *(_QWORD *)&v26 = &v43;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
    *(_QWORD *)&v26 = &v41;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
    *(_QWORD *)&v26 = &v39;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
    *(_QWORD *)&v26 = &v37;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
    if (v25)
      goto LABEL_10;
  }
  else
  {
    *(_BYTE *)a6 = 0;
    *(_BYTE *)(a6 + 136) = 0;
  }
}

BOOL TIInputManager::should_accept_candidate_for_mixed_case_input(uint64_t a1, _QWORD *a2, _LXLexicon *a3, const char *a4, _QWORD *a5, char a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  const KB::String *v18;
  int v19;
  uint64_t v20;
  _BOOL8 v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  size_t v27;
  void *v28;
  const char *v29;
  const char *v30;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  _WORD v40[3];
  char v41;
  void *v42;
  _QWORD v43[3];

  v43[2] = *MEMORY[0x1E0C80C00];
  v11 = a5[1];
  v12 = v11 - *a5;
  if (v11 == *a5)
  {
    v14 = 0;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    v15 = v12 >> 2;
    do
    {
      v14 += *(_DWORD *)(*a5 + 4 * v13) & ~(*(_DWORD *)(*a5 + 4 * v13) >> 1) & 1;
      ++v13;
    }
    while (v15 > v13);
  }
  if (*((_QWORD *)a4 + 1))
    v16 = *((_QWORD *)a4 + 1);
  else
    v16 = (uint64_t)(a4 + 16);
  v36 = v16;
  v17 = *(unsigned __int16 *)a4;
  v37 = 0;
  v38 = v17;
  v39 = 0;
  KB::String::iterator::initialize(&v36);
  v32 = v16;
  v33 = v17;
  v34 = v17;
  v35 = 0;
  KB::String::iterator::initialize(&v32);
  v19 = v33;
  if (v37 != v33)
  {
    v20 = MEMORY[0x1E0C80978];
    do
    {
      if ((v39 & 0x80) != 0)
      {
        if (!__maskrune((char)v39, 0x100uLL))
          goto LABEL_19;
      }
      else if ((*(_DWORD *)(v20 + 4 * (char)v39 + 60) & 0x100) == 0)
      {
        goto LABEL_19;
      }
      KB::String::iterator::operator++(&v36);
    }
    while (v37 != v19);
  }
  if (v14 <= 1 && (a6 & 1) != 0)
    return 1;
LABEL_19:
  if (*a2)
  {
    v22 = 240 * *a2 - 240;
    v23 = (uint64_t *)(a2[1] + 224);
    do
    {
      v25 = *v23;
      v23 += 30;
      v24 = v25;
      if (v25)
        v26 = 1;
      else
        v26 = v22 == 0;
      v22 -= 240;
    }
    while (!v26);
    if (v24)
      return KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 8) + 72), a3, (const KB::String *)a4, v18) == 0;
  }
  KB::Word::capitalized_string((KB::Word *)a3, (uint64_t)v40);
  v27 = *(unsigned __int16 *)a4;
  v28 = v42;
  if (v27 > v40[0])
  {
    v21 = 0;
    if (!v42)
      return v21;
    goto LABEL_38;
  }
  if (v42)
    v29 = (const char *)v42;
  else
    v29 = (const char *)v43;
  if (*((_QWORD *)a4 + 1))
    v30 = (const char *)*((_QWORD *)a4 + 1);
  else
    v30 = a4 + 16;
  v21 = strncmp(v29, v30, v27) == 0;
  if (v28)
  {
LABEL_38:
    if (v41 == 1)
      free(v28);
  }
  return v21;
}

void TIInputManager::create_quality_filter(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  const void *v31;
  CFTypeID v32;
  CFTypeRef *v33;
  CFTypeRef *v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  CFTypeRef v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  __int128 v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  __int128 v60;
  CFDictionaryRef v61;
  __int128 v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  __int128 v65;
  uint64_t v66;
  _OWORD v67[6];
  std::string __p;
  void **v69;
  _BYTE v70[8];
  void *v71;
  __int128 v72;
  void *v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  int v80;
  __int128 v81;
  uint64_t v82;
  uint64_t v83;
  std::__shared_weak_count *v84;
  int v85;
  char v86;
  _BYTE v87[8];
  void *v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  a4[1] = 0;
  if (*(_BYTE *)(a1 + 691))
  {
    KB::CandidateFilterFactory::create_empty_filter(&v72);
    std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100]((uint64_t)a4, &v72);
    v5 = (std::__shared_weak_count *)*((_QWORD *)&v72 + 1);
    if (*((_QWORD *)&v72 + 1))
    {
      v6 = (unint64_t *)(*((_QWORD *)&v72 + 1) + 8);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  else
  {
    v11 = KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon;
    std::vector<KB::FilterFlag>::vector(&__p, a3);
    TIInputManager::candidate_filter_cache_key(&__p, a2, v11, (uint64_t)v87);
    if (__p.__r_.__value_.__r.__words[0])
    {
      __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    TIInputManager::candidate_filter_for_key(a1, (const KB::String *)v87, &v72);
    std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100]((uint64_t)a4, &v72);
    v12 = (std::__shared_weak_count *)*((_QWORD *)&v72 + 1);
    if (*((_QWORD *)&v72 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v72 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    if (!*a4)
    {
      v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 16))(*(_QWORD *)(a1 + 184));
      KB::String::String((KB::String *)v70, (const KB::String *)(a1 + 104));
      KB::CandidateFilterParameters::CandidateFilterParameters((uint64_t)v67, *(_QWORD *)(a1 + 136), v16, v15, v17, *(_DWORD *)(a1 + 584) != 0);
      v18 = *(_DWORD *)(a1 + 584);
      std::vector<KB::FilterFlag>::vector(&v65, a3);
      *(_QWORD *)&v72 = __PAIR64__(v15, a2);
      DWORD2(v72) = 0x100000;
      WORD6(v72) = 0;
      BYTE14(v72) = 0;
      v73 = 0;
      KB::String::operator=((uint64_t)&v72 + 8, (KB::String *)v70);
      v76 = v67[2];
      v77 = v67[3];
      v78 = v67[4];
      v79 = v67[5];
      v74 = v67[0];
      v75 = v67[1];
      v80 = v18;
      v81 = v65;
      v19 = v66;
      v65 = 0uLL;
      v66 = 0;
      v83 = 0;
      v84 = 0;
      v82 = v19;
      v85 = 0x10000;
      v86 = 0;
      if (v71 && v70[6] == 1)
        free(v71);
      LOBYTE(v85) = *(_BYTE *)(a1 + 684);
      BYTE2(v85) = *(_BYTE *)(a1 + 689);
      BYTE1(v85) = v11;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)a1 + 56))(&v63, a1, a2);
      v21 = v63;
      v20 = v64;
      if (v64)
      {
        p_shared_owners = (unint64_t *)&v64->__shared_owners_;
        do
          v23 = __ldxr(p_shared_owners);
        while (__stxr(v23 + 1, p_shared_owners));
      }
      v24 = v84;
      v83 = v21;
      v84 = v20;
      if (v24)
      {
        v25 = (unint64_t *)&v24->__shared_owners_;
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      v27 = v64;
      if (v64)
      {
        v28 = (unint64_t *)&v64->__shared_owners_;
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
      v86 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
      if ((a2 - 3) < 4 || (_DWORD)a2 == 1)
      {
        v30 = *(_QWORD *)(a1 + 544);
        if (v30)
        {
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v30 + 40))(v30))
            HIBYTE(v85) = 1;
        }
      }
      v31 = *(const void **)(a1 + 696);
      if (v31)
      {
        CFRetain(*(CFTypeRef *)(a1 + 696));
        v32 = CFGetTypeID(v31);
        if (v32 == CFDictionaryGetTypeID())
        {
          v61 = (CFDictionaryRef)v31;
          KB::CandidateFilterFactory::select_filter_specification_for_configuration(&v61, (unsigned int *)&v72, (uint64_t)&v62);
          CFRelease(v31);
        }
        else
        {
          CFRelease(v31);
          v61 = 0;
          KB::CandidateFilterFactory::select_filter_specification_for_configuration(&v61, (unsigned int *)&v72, (uint64_t)&v62);
        }
        v58 = 0;
        v59 = 0;
        v57 = 0;
        v34 = (CFTypeRef *)*((_QWORD *)&v62 + 1);
        v33 = (CFTypeRef *)v62;
        v35 = *((_QWORD *)&v62 + 1) - v62;
        if (*((_QWORD *)&v62 + 1) != (_QWORD)v62)
        {
          if (v35 < 0)
            abort();
          v36 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v35 >> 3);
          v57 = v36;
          v59 = &v36[v37];
          do
          {
            v38 = *v33;
            if (*v33)
              CFRetain(*v33);
            *v36++ = v38;
            ++v33;
          }
          while (v33 != v34);
          v58 = v36;
        }
        KB::CandidateFilterFactory::create_filter_stack_from_specification((uint64_t *)&v57, (const KB::CandidateFilterConfiguration *)&v72, &v60);
        std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100]((uint64_t)a4, &v60);
        v39 = (std::__shared_weak_count *)*((_QWORD *)&v60 + 1);
        if (*((_QWORD *)&v60 + 1))
        {
          v40 = (unint64_t *)(*((_QWORD *)&v60 + 1) + 8);
          do
            v41 = __ldaxr(v40);
          while (__stlxr(v41 - 1, v40));
          if (!v41)
          {
            ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
            std::__shared_weak_count::__release_weak(v39);
          }
        }
        v69 = (void **)&v57;
        std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100](&v69);
        *(_QWORD *)&v60 = &v62;
        std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100]((void ***)&v60);
      }
      v42 = *a4;
      if (*a4)
        goto LABEL_60;
      KB::CandidateFilterFactory::create_standard_filter((KB::CandidateFilterFactory *)&v72, &v62);
      std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100]((uint64_t)a4, &v62);
      v43 = (std::__shared_weak_count *)*((_QWORD *)&v62 + 1);
      if (*((_QWORD *)&v62 + 1))
      {
        v44 = (unint64_t *)(*((_QWORD *)&v62 + 1) + 8);
        do
          v45 = __ldaxr(v44);
        while (__stlxr(v45 - 1, v44));
        if (!v45)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
      }
      v42 = *a4;
      if (*a4)
      {
LABEL_60:
        v46 = a4[1];
        *(_QWORD *)&v56 = v42;
        *((_QWORD *)&v56 + 1) = v46;
        if (v46)
        {
          v47 = (unint64_t *)(v46 + 8);
          do
            v48 = __ldxr(v47);
          while (__stxr(v48 + 1, v47));
        }
        v49 = KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::operator[](a1 + 632, (const KB::String *)v87);
        std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100](v49, &v56);
        v50 = (std::__shared_weak_count *)*((_QWORD *)&v56 + 1);
        if (*((_QWORD *)&v56 + 1))
        {
          v51 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
          do
            v52 = __ldaxr(v51);
          while (__stlxr(v52 - 1, v51));
          if (!v52)
          {
            ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
            std::__shared_weak_count::__release_weak(v50);
          }
        }
      }
      v53 = v84;
      if (v84)
      {
        v54 = (unint64_t *)&v84->__shared_owners_;
        do
          v55 = __ldaxr(v54);
        while (__stlxr(v55 - 1, v54));
        if (!v55)
        {
          ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
          std::__shared_weak_count::__release_weak(v53);
        }
      }
      if ((_QWORD)v81)
      {
        *((_QWORD *)&v81 + 1) = v81;
        operator delete((void *)v81);
      }
      if (v73 && BYTE14(v72) == 1)
        free(v73);
    }
    if (v88 && v87[6] == 1)
      free(v88);
  }
}

uint64_t TIInputManager::create_custom_candidate_filter@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 544);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 80))(result);
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void TIInputManager::candidate_filter_cache_key(std::string *this@<X2>, int a2@<W0>, int a3@<W1>, uint64_t a4@<X8>)
{
  std::string *p_p;
  std::string __p;

  *(_DWORD *)a4 = 0x100000;
  *(_WORD *)(a4 + 4) = 0;
  *(_BYTE *)(a4 + 6) = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_BYTE *)(a4 + 16) = 0;
  KB::CandidateFilterFlags::serialize_flag_val(this, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  KB::String::append_format((KB::String *)a4, "lut:%d osl:%d cff:%s", a2, a3, (const char *)p_p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

uint64_t TIInputManager::candidate_filter_for_key@<X0>(uint64_t this@<X0>, const KB::String *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  uint64_t *v11;
  const char *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v4 = *(_QWORD *)(this + 664);
  if (!v4)
    goto LABEL_17;
  v6 = this;
  v7 = this + 664;
  v8 = *((_QWORD *)a2 + 1) ? (const char *)*((_QWORD *)a2 + 1) : (char *)a2 + 16;
  v9 = this + 664;
  do
  {
    if (*(_QWORD *)(v4 + 40))
      v10 = *(const char **)(v4 + 40);
    else
      v10 = (const char *)(v4 + 48);
    this = strcmp(v10, v8);
    v11 = (uint64_t *)(v4 + 8);
    if ((int)this >= 0)
    {
      v11 = (uint64_t *)v4;
      v9 = v4;
    }
    v4 = *v11;
  }
  while (*v11);
  if (v7 == v9
    || (*(_QWORD *)(v9 + 40) ? (v12 = *(const char **)(v9 + 40)) : (v12 = (const char *)(v9 + 48)),
        this = strcmp(v8, v12),
        (this & 0x80000000) != 0))
  {
LABEL_17:
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    this = KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::operator[](v6 + 632, a2);
    v13 = *(_QWORD *)(this + 8);
    *a3 = *(_QWORD *)this;
    a3[1] = v13;
    if (v13)
    {
      v14 = (unint64_t *)(v13 + 8);
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
  }
  return this;
}

uint64_t KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::operator[](uint64_t a1, const KB::String *a2)
{
  KB::String *v4;
  KB::String *v5;
  _QWORD *v6;
  uint64_t *v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t **v10;
  const char *v11;
  _QWORD *v12;
  _QWORD *v13;
  const char *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  const char *v24;
  const char *v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  int v30;
  uint64_t *v31;
  const char *v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  BOOL v42;
  void *v43;

  v4 = (KB::String *)operator new();
  v5 = KB::String::String(v4, a2);
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  v6 = operator new(0x48uLL);
  KB::String::String((KB::String *)(v6 + 4), a2);
  v7 = *(uint64_t **)(a1 + 32);
  v6[8] = v4;
  v8 = v6 + 8;
  v9 = (uint64_t *)(a1 + 32);
  v10 = (uint64_t **)(a1 + 32);
  if (v7)
  {
    if (v6[5])
      v11 = (const char *)v6[5];
    else
      v11 = (const char *)(v6 + 6);
    while (1)
    {
      while (1)
      {
        v9 = v7;
        v12 = (_QWORD *)v7[5];
        v13 = v7 + 6;
        v14 = (const char *)(v12 ? v12 : v13);
        if ((strcmp(v11, v14) & 0x80000000) == 0)
          break;
        v7 = (uint64_t *)*v9;
        v10 = (uint64_t **)v9;
        if (!*v9)
          goto LABEL_13;
      }
      if ((strcmp(v14, v11) & 0x80000000) == 0)
        break;
      v10 = (uint64_t **)(v9 + 1);
      v7 = (uint64_t *)v9[1];
      if (!v7)
        goto LABEL_13;
    }
    std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>::reset[abi:nn180100](v6 + 8);
    v35 = (void *)v6[5];
    if (v35 && *((_BYTE *)v6 + 38) == 1)
      free(v35);
    operator delete(v6);
    v36 = v9[8];
    v8 = v9 + 8;
    v37 = *(_QWORD *)(a1 + 8);
    if (v37 != v36)
    {
      v38 = *(_QWORD *)(v36 + 48);
      v39 = *(_QWORD *)(v36 + 56);
      if (v38)
        *(_QWORD *)(v38 + 56) = v39;
      if (v39)
        *(_QWORD *)(v39 + 48) = v38;
      v40 = *(_QWORD *)(a1 + 16);
      if (v40 == v36)
      {
        *(_QWORD *)(a1 + 16) = v38;
        v40 = v38;
      }
      *(_QWORD *)(v36 + 48) = 0;
      *(_QWORD *)(v36 + 56) = v37;
      if (v37)
        *(_QWORD *)(v37 + 48) = v36;
      *(_QWORD *)(a1 + 8) = v36;
      if (!v40)
        *(_QWORD *)(a1 + 16) = v36;
    }
  }
  else
  {
LABEL_13:
    *v6 = 0;
    v6[1] = 0;
    v6[2] = v9;
    *v10 = v6;
    v15 = **(_QWORD **)(a1 + 24);
    v16 = v6;
    if (v15)
    {
      *(_QWORD *)(a1 + 24) = v15;
      v16 = *v10;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 32), v16);
    v17 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(a1 + 40) = v17 + 1;
    v18 = (_QWORD *)v6[8];
    v19 = *(_QWORD *)(a1 + 8);
    v18[6] = 0;
    v18[7] = v19;
    if (v19)
      *(_QWORD *)(v19 + 48) = v18;
    *(_QWORD *)(a1 + 8) = v18;
    v20 = *(_QWORD **)(a1 + 16);
    if (!v20)
    {
      *(_QWORD *)(a1 + 16) = v18;
      v20 = v18;
    }
    if ((unint64_t)(v17 + 1) > *(_QWORD *)a1)
    {
      v21 = v20[6];
      v22 = v20[7];
      if (v21)
        *(_QWORD *)(v21 + 56) = v22;
      if (v22)
        *(_QWORD *)(v22 + 48) = v21;
      if (v18 == v20)
        *(_QWORD *)(a1 + 8) = v22;
      *(_QWORD *)(a1 + 16) = v21;
      v23 = *(uint64_t **)(a1 + 32);
      if (v23)
      {
        v24 = (const char *)v20[1];
        v25 = (const char *)(v20 + 2);
        if (v24)
          v26 = v24;
        else
          v26 = v25;
        v27 = a1 + 32;
        v28 = *(_QWORD *)(a1 + 32);
        do
        {
          if (*(_QWORD *)(v28 + 40))
            v29 = *(const char **)(v28 + 40);
          else
            v29 = (const char *)(v28 + 48);
          v30 = strcmp(v29, v26);
          v31 = (uint64_t *)(v28 + 8);
          if (v30 >= 0)
          {
            v31 = (uint64_t *)v28;
            v27 = v28;
          }
          v28 = *v31;
        }
        while (*v31);
        if (a1 + 32 != v27)
        {
          v32 = *(_QWORD *)(v27 + 40) ? *(const char **)(v27 + 40) : (const char *)(v27 + 48);
          if ((strcmp(v26, v32) & 0x80000000) == 0)
          {
            v33 = *(_QWORD **)(v27 + 8);
            if (v33)
            {
              do
              {
                v34 = v33;
                v33 = (_QWORD *)*v33;
              }
              while (v33);
            }
            else
            {
              v41 = (_QWORD *)v27;
              do
              {
                v34 = (_QWORD *)v41[2];
                v42 = *v34 == (_QWORD)v41;
                v41 = v34;
              }
              while (!v42);
            }
            if (*(_QWORD *)(a1 + 24) == v27)
              *(_QWORD *)(a1 + 24) = v34;
            *(_QWORD *)(a1 + 40) = v17;
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v23, (uint64_t *)v27);
            std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>::reset[abi:nn180100]((uint64_t *)(v27 + 64));
            v43 = *(void **)(v27 + 40);
            if (v43 && *(_BYTE *)(v27 + 38) == 1)
              free(v43);
            operator delete((void *)v27);
          }
        }
      }
    }
  }
  return *v8 + 32;
}

uint64_t *std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>::reset[abi:nn180100](uint64_t *result)
{
  uint64_t v1;
  void *v2;

  v1 = *result;
  *result = 0;
  if (v1)
  {
    std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](v1 + 32);
    v2 = *(void **)(v1 + 8);
    if (v2)
    {
      if (*(_BYTE *)(v1 + 6) == 1)
        free(v2);
    }
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

void TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))const::$_0::operator()(uint64_t a1, uint64_t a2, _WORD *a3, const KB::LanguageModelContext *a4, int a5)
{
  uint64_t v5;
  TIInputManager *v10;
  __CFString *Mutable;
  _WORD *v12;
  uint64_t v13;
  int v14;
  const KB::String *v15;
  const KB::String *v16;
  void (**v17)(const void *, uint64_t, _WORD *, uint64_t);
  CFTypeRef cf;
  int *v19[3];
  void *__p[3];
  _BYTE v21[24];
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;

  LODWORD(v5) = a5;
  v27 = *MEMORY[0x1E0C80C00];
  v10 = *(TIInputManager **)(a1 + 8);
  if (*((_QWORD *)v10 + 71))
    Mutable = CFStringCreateMutable(0, 0);
  else
    Mutable = 0;
  KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v21, (const KB::Candidate **)a2);
  v12 = a3 + 444;
  if (!a3[444])
    KB::Candidate::compute_string((KB::Candidate *)a3);
  TIInputManager::apply_policy_decisions_inline_completions(v10, (KB::CandidateCollection *)a2, (const KB::String *)(a3 + 444), a4, Mutable);
  memset(v19, 0, sizeof(v19));
  KB::CandidateFilterFlags::CandidateFilterFlags(__p, v19);
  v13 = *((_QWORD *)v10 + 71);
  if (v13)
  {
    if (!*v12)
      KB::Candidate::compute_string((KB::Candidate *)a3);
    v14 = KB::CandidateFilterFlags::candidate_filter_flag_type((unsigned int **)__p);
    v15 = (const KB::String *)&kGenericFlagDesc;
    if (v14 == 1)
      v15 = (const KB::String *)&kPostLMFlagDesc;
    if (v14)
      v16 = v15;
    else
      v16 = (const KB::String *)&kPreLMFlagDesc;
    KB::String::String((KB::String *)&v25, v16);
    cf = 0;
    (*(void (**)(uint64_t, _WORD *, uint64_t, void ***, _BYTE *, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)v13 + 24))(v13, a3 + 444, 2, &v25, v21, Mutable, a2, &cf);
    if (cf)
      CFRelease(cf);
    cf = 0;
    if (v26 && BYTE6(v25) == 1)
      free(v26);
  }
  if (*(_QWORD *)(a2 + 8) == *(_QWORD *)a2)
    v5 = 0;
  else
    v5 = v5;
  v17 = *(void (***)(const void *, uint64_t, _WORD *, uint64_t))a1;
  if (!*v12)
    KB::Candidate::compute_string((KB::Candidate *)a3);
  v17[2](v17, a2, a3 + 444, v5);
  _Block_release(*(const void **)a1);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v25 = (void **)&v24;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v25);
  v25 = (void **)&v23;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v25);
  v25 = (void **)&v22;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v25);
  v25 = (void **)v21;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v25);
  if (Mutable)
    CFRelease(Mutable);
}

KB::CandidateCollection *KB::CandidateCollection::CandidateCollection(KB::CandidateCollection *this, const KB::Candidate **a2)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>(this, *a2, a2[1], 0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3));
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::CandidateCollection *)((char *)this + 24), a2[3], a2[4], 0x1CAC083126E978D5 * ((a2[4] - a2[3]) >> 3));
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::CandidateCollection *)((char *)this + 48), a2[6], a2[7], 0x1CAC083126E978D5 * ((a2[7] - a2[6]) >> 3));
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::CandidateCollection *)((char *)this + 72), a2[9], a2[10], 0x1CAC083126E978D5 * ((a2[10] - a2[9]) >> 3));
  *((_QWORD *)this + 12) = a2[12];
  return this;
}

void std::__function::__func<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0,std::allocator<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0>,void ()(KB::CandidateCollection&,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0,std::allocator<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0>,void ()(KB::CandidateCollection&,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA0FD9E8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0,std::allocator<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0>,void ()(KB::CandidateCollection&,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FD9E8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0,std::allocator<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0>,void ()(KB::CandidateCollection&,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>::operator()(uint64_t a1, uint64_t a2, _WORD *a3, const KB::LanguageModelContext *a4, unsigned __int8 *a5)
{
  TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))const::$_0::operator()(a1 + 8, a2, a3, a4, *a5);
}

void TIInputManager::apply_policy_decisions_inline_completions(TIInputManager *this, KB::CandidateCollection *a2, const KB::String *a3, const KB::LanguageModelContext *a4, __CFString *a5)
{
  uint64_t v5;
  const void *v6;
  const void *v7;
  const KB::LanguageModelContext *v8;
  const KB::LanguageModelContext *v9;
  const KB::String *v10;
  const KB::String *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  const void *v18;
  int v19;
  unsigned int *v20;
  unsigned int v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  unsigned int *v33;
  void **v34[8];
  char v35[8];
  std::__shared_weak_count *v36;
  void *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  std::vector<unsigned int> v42;
  int *v43[3];
  void *__p[3];
  uint64_t v45;
  std::__shared_weak_count *v46;
  _BYTE v47[1000];
  int v48;
  __int16 v49;
  char v50;
  void *v51;
  char v52;
  _BYTE v53[1000];
  _BYTE v54[3184];
  _QWORD v55[126];

  v5 = MEMORY[0x1E0C80A78](this, a2, a3, a4, a5);
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v14 = v5;
  v55[125] = *MEMORY[0x1E0C80C00];
  memset(v43, 0, sizeof(v43));
  KB::CandidateFilterFlags::CandidateFilterFlags(__p, v43);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, void **))(*(_QWORD *)v14 + 48))(&v45, v14, 2, __p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v45)
  {
    KB::Candidate::Candidate((KB::Candidate *)v55, v11, *(_DWORD *)(v14 + 248));
    KB::Candidate::Candidate((KB::Candidate *)v53, (const KB::Candidate *)v55);
    memset(&v42, 0, sizeof(v42));
    KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v35, v9);
    v48 = 0x100000;
    v49 = 0;
    v50 = 0;
    v51 = 0;
    v52 = 0;
    bzero(v47, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)v47);
    KB::CandidateFilterLookupContext::CandidateFilterLookupContext((uint64_t)v54, (const KB::Candidate *)v53, &v42, (const KB::LanguageModelContext *)v35, (const KB::String *)&v48, (const KB::Candidate *)v47, 2);
    KB::Candidate::~Candidate((KB::Candidate *)v47);
    if (v51 && v50 == 1)
      free(v51);
    v34[0] = (void **)&v41;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v34);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v40);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v39);
    if (v37)
    {
      v38 = v37;
      operator delete(v37);
    }
    v15 = v36;
    if (v36)
    {
      p_shared_owners = (unint64_t *)&v36->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    if (v42.__begin_)
    {
      v42.__end_ = v42.__begin_;
      operator delete(v42.__begin_);
    }
    KB::Candidate::~Candidate((KB::Candidate *)v53);
    v18 = *(const void **)(v14 + 136);
    v19 = *(_DWORD *)(v14 + 248);
    v20 = *(unsigned int **)(v14 + 224);
    v33 = v20;
    if (v20)
    {
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 + 1, v20));
    }
    v22 = *(std::__shared_weak_count **)(v14 + 240);
    v31 = *(_QWORD *)(v14 + 232);
    v32 = v22;
    if (v22)
    {
      v23 = (unint64_t *)&v22->__shared_owners_;
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }
    KB::CandidateFilterResources::CandidateFilterResources((uint64_t)v34, v18, v19, (uint64_t *)&v33, (uint64_t)&v31, *(const void **)(v14 + 560), 0, v7);
    v25 = v32;
    if (v32)
    {
      v26 = (unint64_t *)&v32->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    if (v33)
      WTF::RefCounted<KB::DictionaryContainer>::deref(v33);
    (*(void (**)(uint64_t, uint64_t, _BYTE *, void ***))(*(_QWORD *)v45 + 24))(v45, v13, v54, v34);
    KB::CandidateFilterResources::~CandidateFilterResources((KB::CandidateFilterResources *)v34);
    KB::CandidateFilterLookupContext::~CandidateFilterLookupContext((KB::CandidateFilterLookupContext *)v54);
    KB::Candidate::~Candidate((KB::Candidate *)v55);
  }
  v28 = v46;
  if (v46)
  {
    v29 = (unint64_t *)&v46->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
}

void KB::CandidateFilterLookupContext::~CandidateFilterLookupContext(KB::CandidateFilterLookupContext *this)
{
  void *v2;
  void *v3;
  void *v4;
  void **v5;

  KB::Candidate::~Candidate((KB::CandidateFilterLookupContext *)((char *)this + 2168));
  v2 = (void *)*((_QWORD *)this + 268);
  if (v2 && *((_BYTE *)this + 2142) == 1)
    free(v2);
  v5 = (void **)((char *)this + 2112);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v5);
  language_modeling::v1::LinguisticContext::~LinguisticContext((KB::CandidateFilterLookupContext *)((char *)this + 2104));
  language_modeling::v1::LinguisticContext::~LinguisticContext((KB::CandidateFilterLookupContext *)((char *)this + 2096));
  v3 = (void *)*((_QWORD *)this + 256);
  if (v3)
  {
    *((_QWORD *)this + 257) = v3;
    operator delete(v3);
  }
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 2032);
  v4 = (void *)*((_QWORD *)this + 251);
  if (v4)
  {
    *((_QWORD *)this + 252) = v4;
    operator delete(v4);
  }
  if (*((_BYTE *)this + 2000))
    KB::Candidate::~Candidate((KB::CandidateFilterLookupContext *)((char *)this + 1000));
  KB::Candidate::~Candidate(this);
}

void TIInputManager::lookup(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, int a4@<W3>, uint64_t a5@<X8>)
{
  unsigned __int16 *v10;
  const char *v11;
  const char *v12;
  unsigned int v13;
  _QWORD v14[5];
  int v15;
  int v16;
  unsigned __int16 v17[2];
  __int16 v18;
  char v19;
  void *v20;
  _QWORD v21[3];

  v21[2] = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a2 != 5)
  {
    v10 = (unsigned __int16 *)(a1 + 64);
    if (*(_WORD *)(a1 + 68) || (KB::String::compute_length((unsigned __int16 *)(a1 + 64)), *(_WORD *)(a1 + 68)))
    {
      TIInputManager::legacy_input_stem((TIInputManager *)a1, (uint64_t)v17);
      if (v18 || (KB::String::compute_length(v17), v18))
      {
        if (v17[0] <= *v10)
        {
          v11 = *(_QWORD *)(a1 + 72) ? *(const char **)(a1 + 72) : (const char *)(a1 + 80);
          v12 = (const char *)(v20 ? v20 : v21);
          if (!strncasecmp(v11, v12, v17[0]))
          {
            v13 = *(_DWORD *)(a1 + 96);
            if (*(_DWORD *)(a1 + 172) > v13)
              v13 = *(_DWORD *)(a1 + 172);
            *(_DWORD *)(a1 + 172) = v13;
          }
        }
      }
      if (v20 && v19 == 1)
        free(v20);
    }
  }
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 0x40000000;
  v14[2] = ___ZN14TIInputManager6lookupEN2KB10LookupTypeEj14TIShiftContext_block_invoke;
  v14[3] = &__block_descriptor_tmp_7;
  v14[4] = a1;
  v15 = a2;
  v16 = a4;
  TIInputManager::perform_lookup(a1, a2, a3, (uint64_t)v14, a5);
}

unsigned __int16 *TIInputManager::legacy_input_stem@<X0>(TIInputManager *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  unsigned __int16 *v3;
  uint64_t v4;
  uint64_t v5;
  char v6;

  v2 = *((unsigned int *)this + 24);
  v3 = (unsigned __int16 *)((char *)this + 8);
  v4 = v2 + 1;
  v5 = 40 * v2 - 8;
  do
  {
    if (!--v4)
      break;
    v6 = *(_BYTE *)(*(_QWORD *)v3 + v5);
    v5 -= 40;
  }
  while ((v6 & 0x40) == 0);
  return TIInputManager::input_substring(v3, v4, (int)v2 - (int)v4, a2);
}

void ___ZN14TIInputManager6lookupEN2KB10LookupTypeEj14TIShiftContext_block_invoke(uint64_t a1, unint64_t *a2, __CFString *a3)
{
  unint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unsigned __int16 *v14;
  const KB::String *v15;
  TIInputManager *v16;
  _BYTE v17[6];
  char v18;
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  v7 = (uint64_t *)a2[1];
  v8 = 126 - 2 * __clz(0x1CAC083126E978D5 * ((uint64_t)((uint64_t)v7 - v6) >> 3));
  v9 = *(_QWORD *)(a1 + 32);
  if (v7 == (uint64_t *)v6)
    v10 = 0;
  else
    v10 = v8;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,false>(v6, v7, v10, 1);
  if (TIInputManager::inject_supplemental_candidate(v9, *(_DWORD *)(a1 + 40), (uint64_t *)a2))
  {
    v11 = (uint64_t *)a2[1];
    v12 = 126 - 2 * __clz(0x1CAC083126E978D5 * ((uint64_t)((uint64_t)v11 - *a2) >> 3));
    if (v11 == (uint64_t *)*a2)
      v13 = 0;
    else
      v13 = v12;
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,false>(*a2, v11, v13, 1);
  }
  TIInputManager::apply_case_insensitive_constraints(v9, (uint64_t)a2, *(_DWORD *)(a1 + 40), (uint64_t)a3);
  TIInputManager::apply_case_changes(v9, (uint64_t)a2, (unsigned __int16 *)(v9 + 8), *(unsigned int *)(v9 + 96), *(unsigned int *)(a1 + 44), a3);
  v14 = TIInputManager::input_substring((unsigned __int16 *)(v9 + 8), 0, *(_DWORD *)(v9 + 96), (uint64_t)v17);
  TIInputManager::apply_apostrophe_changes((TIInputManager *)v14, (KB::CandidateCollection *)a2, (const KB::String *)v17, a3);
  if (v19 && v18 == 1)
    free(v19);
  TIInputManager::input_substring((unsigned __int16 *)(v9 + 8), 0, *(_DWORD *)(v9 + 96), (uint64_t)v17);
  TIInputManager::apply_shortcut_conversions((TIInputManager *)v9, (KB::CandidateCollection *)a2, v15, a3);
  if (v19 && v18 == 1)
    free(v19);
  v16 = *(TIInputManager **)(v9 + 544);
  if (v16)
    v16 = (TIInputManager *)(*(uint64_t (**)(TIInputManager *, unint64_t *))(*(_QWORD *)v16 + 64))(v16, a2);
  if (*(_DWORD *)(a1 + 40) == 5)
    TIInputManager::remove_text_replacement_from_top(v16, (const KB::Candidate **)a2);
}

void TIInputManager::perform_lookup(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unsigned __int16 *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  __int128 v16;
  _OWORD v17[2];
  __int128 v18;
  _OWORD v19[2];
  uint64_t v20;
  uint64_t v21;
  void *v22;
  int v23;
  __int16 v24;
  char v25;
  void *v26;
  char v27;
  int v28;
  __int16 v29;
  char v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  void **v35;
  void *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  HIDWORD(v20) = 0;
  v16 = 0u;
  memset(v17, 0, sizeof(v17));
  v18 = 0u;
  memset(v19, 0, sizeof(v19));
  v10 = (unsigned __int16 *)(a1 + 8);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)&v35);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void ***))(*(_QWORD *)a1 + 64))(&v33, a1, &v35);
  v28 = 0x100000;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v23 = 0x100000;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  if ((_DWORD)a2 != 3
    && (_DWORD)a2 != 5
    && !TIInputManager::should_generate_candidates(a1, (KB::String *)(a1 + 400), (KB::String *)&v33, a2 | 0x100000000))
  {
    goto LABEL_23;
  }
  if (!KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon)
  {
    KB::String::operator=((KB::String *)&v23, (KB::String *)&v33);
    KB::String::operator=((KB::String *)&v28, (KB::String *)&v35);
    if (!*(_BYTE *)(a1 + 686)
      || !TIInputManager::lookup_spellcheck_candidates(a1, (uint64_t)&v16, a2, (const KB::String *)&v33, a4))
    {
      if (!(_DWORD)a2 || (_DWORD)a2 == 5)
        goto LABEL_22;
      if (*(_BYTE *)(a1 + 680))
      {
        if (!(_WORD)v23)
          goto LABEL_22;
      }
      else
      {
        if (!*(_WORD *)(a1 + 32))
          goto LABEL_22;
        TIInputManager::input_substring(v10, 0, -858993459 * ((*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3), (uint64_t)&v21);
        if ((uint64_t *)(a1 + 32) != &v21 && !KB::String::equal((KB::String *)(a1 + 32), (const KB::String *)&v21, 1))
        {
          if (v22 && BYTE6(v21) == 1)
            free(v22);
          goto LABEL_22;
        }
        v15 = (unsigned __int16)v23;
        if (v22 && BYTE6(v21) == 1)
          free(v22);
        if (!v15)
          goto LABEL_22;
      }
      if (TIInputManager::lookup_revision_candidates((const KB::String **)a1, (uint64_t *)&v16, a2, a4, a3, (const KB::String *)&v23))
      {
        goto LABEL_23;
      }
LABEL_22:
      (*(void (**)(_QWORD, uint64_t, int *, _QWORD, _QWORD))(**(_QWORD **)(a1 + 184) + 144))(*(_QWORD *)(a1 + 184), a1 + 432, &v23, *(unsigned int *)(a1 + 96), -858993459 * ((*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3));
      TIInputManager::lookup_static_dynamic_candidates(a1, (uint64_t)&v16, a2, (uint64_t)&v23, a4, a3);
    }
LABEL_23:
    if ((_DWORD)a2 == 5)
      TI::ConfidenceModel::update_confidence_for_candidates((TI::ConfidenceModel *)(a1 + 144), (KB::CandidateCollection *)&v16);
    goto LABEL_25;
  }
  TIInputManager::input_substring(v10, 0, -858993459 * ((*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3), (uint64_t)&v21);
  KB::String::operator=((uint64_t)&v28, (KB::String *)&v21);
  if (v22 && BYTE6(v21) == 1)
    free(v22);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(_QWORD *)a1 + 64))(&v21, a1, &v28);
  KB::String::operator=((uint64_t)&v23, (KB::String *)&v21);
  if (v22 && BYTE6(v21) == 1)
    free(v22);
  if (!(_DWORD)a2
    && !*(_BYTE *)(a1 + 680)
    && !*(_WORD *)(a1 + 32)
    && (_WORD)v33
    && TIInputManager::lookup_revision_candidates((const KB::String **)a1, (uint64_t *)&v16, 0, a4, a3, (const KB::String *)&v33))
  {
    KB::String::operator=((KB::String *)&v23, (KB::String *)&v33);
    KB::String::operator=((KB::String *)&v28, (KB::String *)&v35);
    goto LABEL_25;
  }
  (*(void (**)(_QWORD, uint64_t, int *, _QWORD, _QWORD))(**(_QWORD **)(a1 + 184) + 144))(*(_QWORD *)(a1 + 184), a1 + 432, &v23, *(unsigned int *)(a1 + 96), -858993459 * ((*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3));
  v11 = TIInputManager::lookup_static_dynamic_candidates(a1, (uint64_t)&v16, a2, (uint64_t)&v23, a4, a3);
  if ((_DWORD)a2 == 5 || v11)
    goto LABEL_23;
  if (*(_BYTE *)(a1 + 680) || !*(_WORD *)(a1 + 32))
  {
    if (!(_WORD)v23)
      goto LABEL_25;
    goto LABEL_17;
  }
  TIInputManager::input_substring(v10, 0, -858993459 * ((*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3), (uint64_t)&v21);
  if ((uint64_t *)(a1 + 32) == &v21 || KB::String::equal((KB::String *)(a1 + 32), (const KB::String *)&v21, 1))
  {
    v14 = (unsigned __int16)v23;
    if (v22 && BYTE6(v21) == 1)
      free(v22);
    if (!v14)
      goto LABEL_25;
LABEL_17:
    TIInputManager::lookup_revision_candidates((const KB::String **)a1, (uint64_t *)&v16, a2, a4, a3, (const KB::String *)&v23);
    goto LABEL_25;
  }
  if (v22 && BYTE6(v21) == 1)
    free(v22);
LABEL_25:
  *(_OWORD *)a5 = v16;
  *(_QWORD *)(a5 + 16) = *(_QWORD *)&v17[0];
  v16 = 0uLL;
  *(_OWORD *)(a5 + 24) = *(_OWORD *)((char *)v17 + 8);
  *(_QWORD *)(a5 + 40) = *((_QWORD *)&v17[1] + 1);
  memset(v17, 0, sizeof(v17));
  *(_OWORD *)(a5 + 48) = v18;
  *(_QWORD *)(a5 + 64) = *(_QWORD *)&v19[0];
  v18 = 0uLL;
  *(_OWORD *)(a5 + 72) = *(_OWORD *)((char *)v19 + 8);
  v12 = v20;
  *(_QWORD *)(a5 + 88) = *((_QWORD *)&v19[1] + 1);
  memset(v19, 0, sizeof(v19));
  *(_DWORD *)(a5 + 104) = 0x100000;
  v13 = a5 + 104;
  *(_QWORD *)(v13 - 8) = v12;
  *(_WORD *)(v13 + 4) = 0;
  *(_BYTE *)(v13 + 6) = 0;
  *(_QWORD *)(v13 + 8) = 0;
  KB::String::operator=(v13, (KB::String *)&v28);
  if (v26 && v25 == 1)
    free(v26);
  if (v31 && v30 == 1)
    free(v31);
  if (v34 && BYTE6(v33) == 1)
    free(v34);
  if (v36 && BYTE6(v35) == 1)
    free(v36);
  v35 = (void **)v19 + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v35);
  v35 = (void **)&v18;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v35);
  v35 = (void **)v17 + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v35);
  v35 = (void **)&v16;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v35);
}

BOOL TIInputManager::should_generate_candidates(uint64_t a1, KB::String *a2, KB::String *this, uint64_t a4)
{
  unsigned int v8;
  void *v9;
  const char *v10;
  BOOL v11;
  char *v12;
  unsigned __int16 *v13;
  int v14;
  char *v15;
  char *v16;
  char *v17;
  const KB::String *v18;
  const KB::String *v19;
  const KB::String *v20;
  _BOOL8 v21;
  int v22;
  int v23;
  int v24;
  int v25;
  __int128 v27;
  uint64_t v28;
  char *v29;
  int v30;
  int v31;
  int v32;
  __int128 v33;
  UChar32 c[2];
  char *v35;
  int v36;
  int v37;
  int v38;
  __int128 v39;
  uint64_t v40;
  int v41;
  __int16 v42;
  char v43;
  void *v44;
  _BYTE v45[16];
  int v46;
  __int16 v47;
  char v48;
  char *v49;
  _BYTE v50[16];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (**(_QWORD **)(*(_QWORD *)(a1 + 224) + 8) == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 8) + 8)
    && !TITransientLexiconManagerGetActiveSupplementalLexiconWords())
  {
    return 0;
  }
  if (!*(_DWORD *)(a1 + 536))
  {
    v13 = (unsigned __int16 *)KB::String::String((KB::String *)&v46, a2);
    KB::String::append(v13, this);
    v42 = 0;
    v43 = 0;
    v44 = "!@#$%^*_[]/\\|.?+=<>";
    v41 = 1048595;
    v45[1] = 0;
    KB::String::find_last_of((KB::String *)&v39, (const KB::String *)&v46, (const KB::String *)&v41);
    v14 = (unsigned __int16)v46;
    v15 = v49;
    v16 = v50;
    if (v49)
      v17 = v49;
    else
      v17 = v50;
    v35 = v17;
    v36 = (unsigned __int16)v46;
    v37 = (unsigned __int16)v46;
    v38 = 0;
    KB::String::iterator::initialize((uint64_t *)&v35);
    if (DWORD2(v39) == v36)
      goto LABEL_22;
    v33 = v39;
    *(_QWORD *)c = v40;
    KB::String::iterator::operator++((uint64_t *)&v33);
    v29 = v17;
    v30 = v14;
    v31 = v14;
    v32 = 0;
    KB::String::iterator::initialize((uint64_t *)&v29);
    v22 = DWORD2(v33);
    v23 = v30;
    if (DWORD2(v33) != v30)
    {
      while (!u_isspace(c[0]))
      {
        KB::String::iterator::operator++((uint64_t *)&v33);
        if (DWORD2(v33) == v23)
        {
          v22 = v23;
          goto LABEL_51;
        }
      }
      v22 = DWORD2(v33);
    }
LABEL_51:
    v24 = (unsigned __int16)v46;
    v15 = v49;
    if (v49)
      v16 = v49;
    v35 = v16;
    v36 = (unsigned __int16)v46;
    v37 = (unsigned __int16)v46;
    v38 = 0;
    KB::String::iterator::initialize((uint64_t *)&v35);
    if (v22 == v36)
    {
      v25 = DWORD2(v39);
    }
    else
    {
      v25 = DWORD2(v39);
      if (v22 >= SDWORD2(v39))
      {
LABEL_22:
        if (v44 && v43 == 1)
        {
          free(v44);
          v15 = v49;
        }
        if (v15 && v48 == 1)
          free(v15);
        goto LABEL_4;
      }
    }
    v35 = v16;
    v36 = 0;
    v37 = v24;
    v38 = 0;
    KB::String::iterator::initialize((uint64_t *)&v35);
    if (v25 == v36
      || (_DWORD)v40 != 46
      && (v27 = v39, v28 = v40, KB::String::iterator::operator--((KB::String::iterator *)&v27), (_DWORD)v28 != 46))
    {
      if (v44 && v43 == 1)
      {
        free(v44);
        v15 = v49;
      }
      if (!v15 || v48 != 1)
        return 0;
      v12 = v15;
LABEL_63:
      free(v12);
      return 0;
    }
    goto LABEL_22;
  }
LABEL_4:
  if (*(_WORD *)this)
  {
    v47 = 0;
    v48 = 0;
    v49 = ".,ªº-";
    v46 = 1048583;
    v50[1] = 0;
    v8 = KB::String::last(this);
    KB::String::String((uint64_t)&v41, v8);
    if ((a4 & 0xFF00000000) == 0
      || a4 != 1
      || ((v9 = v44) != 0 ? (v10 = (const char *)v44) : (v10 = v45), strcmp(v10, "-")))
    {
      v11 = KB::String::contains((KB::String *)&v46, (const KB::String *)&v41);
      v9 = v44;
      if (v11)
      {
        if (v44 && v43 == 1)
          free(v44);
        v12 = v49;
        if (!v49 || v48 != 1)
          return 0;
        goto LABEL_63;
      }
    }
    if (v9 && v43 == 1)
      free(v9);
    if (v49 && v48 == 1)
      free(v49);
  }
  if (*(_WORD *)(a1 + 104))
  {
    if (*(_QWORD *)(a1 + 112))
      v18 = *(const KB::String **)(a1 + 112);
    else
      v18 = (const KB::String *)(a1 + 120);
  }
  else
  {
    v18 = (const KB::String *)"";
  }
  KB::string_to_lowercase(this, v18, (KB::String *)&v46);
  v19 = (const KB::String *)repeating_character_threshold(*(const __CFLocale **)(a1 + 136));
  v21 = (KB::string_contains_run((KB *)&v46, v19) & 1) == 0
     && (v20 = (const KB::String *)repeating_character_threshold(*(const __CFLocale **)(a1 + 136)),
         (KB::string_contains_pair_run((KB *)&v46, v20) & 1) == 0)
     && !KB::string_contains_terminal_run((KB *)&v46, (const KB::String *)3);
  if (v49 && v48 == 1)
    free(v49);
  return v21;
}

BOOL TIInputManager::lookup_revision_candidates(const KB::String **a1, uint64_t *a2, unsigned int a3, uint64_t a4, unsigned int a5, const KB::String *a6)
{
  int v10;
  uint64_t i;
  uint64_t v12;
  TI::Favonius::FavoniusStrokeBuildManager *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  TI::Favonius::FavoniusStrokeBuildManager *v21;
  uint64_t *v22;
  char v23;
  _QWORD *v24;
  _BOOL8 v25;
  TI::Favonius::FavoniusStrokeBuildManager *v26;
  unint64_t v28;
  unsigned int v29;
  __int128 v30;
  void *__p[2];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  void **v37[3];
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _OWORD v41[3];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  int v45;
  TI::Favonius::FavoniusStrokeBuildManager *v46;
  uint64_t v47;
  unsigned int v48;
  void **v49;
  _BYTE v50[24];
  _BYTE *v51;
  int v52;
  __int16 v53;
  char v54;
  void *v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v48 = a3;
  v47 = a4;
  if (a5 <= 6)
    v10 = 6;
  else
    v10 = a5;
  v29 = v10;
  v12 = *a2;
  for (i = a2[1]; i != v12; KB::Candidate::~Candidate((KB::Candidate *)(i - 1000)))
    ;
  a2[1] = v12;
  TIInputManager::create_autocorrection_engine_with_synthetic_typing(a1, a6, &v46);
  v45 = 0;
  memset(v41, 0, sizeof(v41));
  v28 = a5;
  v42 = 0u;
  v43 = 0u;
  v44 = 0u;
  while (v46
       && (*(unsigned int (**)(TI::Favonius::FavoniusStrokeBuildManager *))(*(_QWORD *)v46 + 160))(v46))
  {
    v52 = 0x100000;
    v53 = 0;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    v13 = v46;
    v36 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    *(_OWORD *)__p = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v34);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v34 + 8));
    v35 = 0uLL;
    v36 = 0;
    v14 = v48;
    v15 = operator new(0x38uLL);
    *v15 = &off_1EA0FDA78;
    v15[1] = a1;
    v15[2] = a6;
    v15[3] = &v52;
    v15[4] = &v48;
    v15[5] = &v47;
    v15[6] = &v46;
    v51 = v15;
    (*(void (**)(void ***__return_ptr, TI::Favonius::FavoniusStrokeBuildManager *, const KB::String *, __int128 *, _QWORD, int *, uint64_t, _BYTE *))(*(_QWORD *)v13 + 72))(v37, v13, a6, &v30, v29, &v52, v14, v50);
    v16 = v51;
    if (v51 == v50)
    {
      v16 = v50;
      v17 = 4;
    }
    else
    {
      if (!v51)
        goto LABEL_15;
      v17 = 5;
    }
    (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_15:
    v49 = (void **)&v35;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v49);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v34 + 8));
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v34);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v18 = (std::__shared_weak_count *)*((_QWORD *)&v30 + 1);
    if (*((_QWORD *)&v30 + 1))
    {
      v19 = (unint64_t *)(*((_QWORD *)&v30 + 1) + 8);
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *))(*(_QWORD *)v46 + 56))(v46);
    v21 = v46;
    v22 = TIInputManager::favonius_layout((TIInputManager *)a1);
    (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, uint64_t *))(*(_QWORD *)v21 + 96))(v21, v22);
    if ((*(unsigned int (**)(TI::Favonius::FavoniusStrokeBuildManager *))(*(_QWORD *)v46 + 160))(v46)
      && 0x1CAC083126E978D5 * (v37[1] - v37[0]) < v28)
    {
      KB::CandidateCollection::addOnlySupplementalCandidates((uint64_t)v41, (uint64_t)v37);
      if (!KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon
        || *(_QWORD *)&v41[0] == *((_QWORD *)&v41[0] + 1)
        && (_QWORD)v42 == *((_QWORD *)&v42 + 1)
        && *((_QWORD *)&v43 + 1) == (_QWORD)v44)
      {
        v23 = 1;
        goto LABEL_31;
      }
    }
    else
    {
      KB::CandidateCollection::add((KB::CandidateCollection *)v41, (const KB::Candidate **)v37);
    }
    v23 = 0;
LABEL_31:
    *(_QWORD *)&v30 = &v40;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v30);
    *(_QWORD *)&v30 = &v39;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v30);
    *(_QWORD *)&v30 = &v38;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v30);
    *(_QWORD *)&v30 = v37;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v30);
    if (v55 && v54 == 1)
      free(v55);
    if ((v23 & 1) == 0)
      break;
  }
  v24 = (_QWORD *)KB::CandidateCollection::operator=((uint64_t)a2, (uint64_t)v41);
  v25 = *v24 != v24[1] || v24[6] != v24[7] || v24[9] != v24[10];
  v37[0] = (void **)&v43 + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v37);
  v37[0] = (void **)&v42;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v37);
  v37[0] = (void **)&v41[1] + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v37);
  v37[0] = (void **)v41;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v37);
  v26 = v46;
  v46 = 0;
  if (v26)
    (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *))(*(_QWORD *)v26 + 8))(v26);
  return v25;
}

BOOL TIInputManager::lookup_static_dynamic_candidates(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  _BOOL8 v16;
  void **v18[3];
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD v22[3];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  int v26;
  uint64_t v27;
  int v28;
  void ***v29;
  _BYTE v30[24];
  _BYTE *v31;
  _BYTE v32[8];
  void *v33;
  int v34;
  __int16 v35;
  char v36;
  void *v37;
  char v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v28 = a3;
  v27 = a5;
  v34 = 0x100000;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v10 = 6;
  if ((_DWORD)a3 == 5)
    v10 = *(_DWORD *)(a1 + 704);
  v26 = 0;
  if (v10 <= a6)
    v11 = a6;
  else
    v11 = v10;
  memset(v22, 0, sizeof(v22));
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v12 = *(_QWORD *)(a1 + 184);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)v32);
  v13 = operator new(0x30uLL);
  *v13 = &off_1EA0FDA30;
  v13[1] = a1;
  v13[2] = a4;
  v13[3] = &v34;
  v13[4] = &v28;
  v13[5] = &v27;
  v31 = v13;
  (*(void (**)(void ***__return_ptr, uint64_t, _BYTE *, uint64_t, uint64_t, int *, uint64_t, _BYTE *))(*(_QWORD *)v12 + 72))(v18, v12, v32, a1 + 432, v11, &v34, a3, v30);
  KB::CandidateCollection::operator=((uint64_t)v22, (uint64_t)v18);
  v29 = (void ***)&v21;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v29);
  v29 = (void ***)&v20;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v29);
  v29 = (void ***)&v19;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v29);
  v29 = v18;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v29);
  v14 = v31;
  if (v31 == v30)
  {
    v15 = 4;
    v14 = v30;
    goto LABEL_10;
  }
  if (v31)
  {
    v15 = 5;
LABEL_10:
    (*(void (**)(void))(*v14 + 8 * v15))();
  }
  if (v33 && v32[6] == 1)
    free(v33);
  KB::CandidateCollection::operator=(a2, (uint64_t)v22);
  v16 = *(_QWORD *)&v22[0] != *((_QWORD *)&v22[0] + 1)
     || (_QWORD)v23 != *((_QWORD *)&v23 + 1)
     || *((_QWORD *)&v24 + 1) != v25;
  v18[0] = (void **)&v24 + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v18);
  v18[0] = (void **)&v23;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v18);
  v18[0] = (void **)&v22[1] + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v18);
  v18[0] = (void **)v22;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v18);
  if (v37 && v36 == 1)
    free(v37);
  return v16;
}

BOOL TIInputManager::lookup_spellcheck_candidates(uint64_t a1, uint64_t a2, uint64_t a3, const KB::String *a4, uint64_t a5)
{
  _BOOL8 v5;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  __CFString *Mutable;
  uint64_t v17;
  int v18;
  const KB::String *v19;
  const KB::String *v20;
  CFTypeRef v21;
  const KB::Candidate *v22;
  uint64_t v23;
  KB::String *v24;
  const KB::Candidate *i;
  const KB::Candidate *v26;
  CFTypeRef v27;
  int *v28[3];
  void *__p[3];
  CFTypeRef cf;
  std::vector<unsigned int> v31;
  _BYTE v32[24];
  _BYTE v33[24];
  _BYTE v34[32];
  std::vector<unsigned int> *v35;
  void *v36;
  _BYTE v37[8];
  void *v38;
  _QWORD v39[126];

  v39[125] = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a3 != 1)
  {
    KB::Candidate::Candidate((KB::Candidate *)v39, a4, 0);
    if (!v39[0])
    {
      v5 = 0;
LABEL_10:
      KB::Candidate::~Candidate((KB::Candidate *)v39);
      return v5;
    }
    KB::String::String((KB::String *)v37, (const KB::String *)(v39[1] + 240 * v39[0] - 240));
    if (*(_BYTE *)(a1 + 685)
      || *(_BYTE *)(a1 + 681)
      && (*(int (**)(_QWORD, _BYTE *, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 224) + 24) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 24), v37, 0xFFFFFFFFLL) > 2|| !TIInputManager::does_need_spell_check((TIInputManager *)a1, (const KB::String *)v37))
    {
      v5 = 0;
LABEL_6:
      if (v38 && v37[6] == 1)
        free(v38);
      goto LABEL_10;
    }
    if (!TIInputManager::is_autoshift((TIInputManager *)a1))
      goto LABEL_23;
    TIInputManager::input_flags_vector((TIInputManager *)a1, &v31);
    if (v31.__end_ == v31.__begin_)
    {
      if (v31.__end_)
        operator delete(v31.__end_);
    }
    else
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = v31.__begin_[v12] & 0x13;
        v12 = v13++;
      }
      while (v14 != 1 && v31.__end_ - v31.__begin_ > v12);
      operator delete(v31.__begin_);
      if (v14 == 1)
      {
LABEL_23:
        KB::spellcheck_candidates(a4, (const KB::String *)(a1 + 104), (uint64_t)&v31);
        KB::CandidateCollection::operator=(a2, (uint64_t)&v31);
        v35 = (std::vector<unsigned int> *)v34;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        v35 = (std::vector<unsigned int> *)v33;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        v35 = (std::vector<unsigned int> *)v32;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        v35 = &v31;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
LABEL_29:
        KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)&v31, (const KB::Candidate **)a2);
        if (*(_QWORD *)(a1 + 568))
        {
          Mutable = CFStringCreateMutable(0, 0);
          CFStringAppend(Mutable, CFSTR("Skipped candidate quality filters for spellchecking candidates.\n"));
        }
        else
        {
          Mutable = 0;
        }
        TIInputManager::filter_spellcheck_candidates((TIInputManager *)a1, (uint64_t **)a2, a4);
        (*(void (**)(uint64_t, uint64_t, __CFString *))(a5 + 16))(a5, a2, Mutable);
        if (*(_QWORD *)(a1 + 568))
        {
          (*(void (**)(CFTypeRef *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)(a1 + 184) + 488))(&cf, *(_QWORD *)(a1 + 184), a3);
          memset(v28, 0, sizeof(v28));
          KB::CandidateFilterFlags::CandidateFilterFlags(__p, v28);
          v17 = *(_QWORD *)(a1 + 568);
          v18 = KB::CandidateFilterFlags::candidate_filter_flag_type((unsigned int **)__p);
          v19 = (const KB::String *)&kGenericFlagDesc;
          if (v18 == 1)
            v19 = (const KB::String *)&kPostLMFlagDesc;
          if (v18)
            v20 = v19;
          else
            v20 = (const KB::String *)&kPreLMFlagDesc;
          KB::String::String((KB::String *)&v35, v20);
          v21 = cf;
          v27 = cf;
          if (cf)
          {
            CFRetain(cf);
            v27 = v21;
          }
          (*(void (**)(uint64_t, const KB::String *, uint64_t, std::vector<unsigned int> **, std::vector<unsigned int> *, __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)v17 + 24))(v17, a4, a3, &v35, &v31, Mutable, a2, &v27);
          if (v27)
            CFRelease(v27);
          v27 = 0;
          if (v36 && BYTE6(v35) == 1)
            free(v36);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          if (cf)
            CFRelease(cf);
        }
        v22 = *(const KB::Candidate **)a2;
        v23 = *(_QWORD *)(a2 + 8);
        v5 = *(_QWORD *)a2 != v23;
        if (!(_DWORD)a3 && *(_QWORD *)a2 != v23)
        {
          v24 = (const KB::Candidate *)((char *)v22 + 888);
          if (!*((_WORD *)v22 + 444))
            KB::Candidate::compute_string(v22);
          if (v24 == a4 || KB::String::equal(v24, a4, 1))
          {
            v26 = *(const KB::Candidate **)a2;
            for (i = *(const KB::Candidate **)(a2 + 8);
                  i != v26;
            *(_QWORD *)(a2 + 8) = v26;
          }
        }
        if (Mutable)
          CFRelease(Mutable);
        v35 = (std::vector<unsigned int> *)v34;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        v35 = (std::vector<unsigned int> *)v33;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        v35 = (std::vector<unsigned int> *)v32;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        v35 = &v31;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        goto LABEL_6;
      }
    }
    KB::lower_string(a4, *(const KB::String **)(a1 + 136), (KB::String *)&v35);
    KB::spellcheck_candidates((KB *)&v35, (const KB::String *)(a1 + 104), (uint64_t)&v31);
    KB::CandidateCollection::operator=(a2, (uint64_t)&v31);
    __p[0] = v34;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
    __p[0] = v33;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
    __p[0] = v32;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
    __p[0] = &v31;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
    if (v36 && BYTE6(v35) == 1)
      free(v36);
    goto LABEL_29;
  }
  return 0;
}

uint64_t TIInputManager::does_need_spell_check(TIInputManager *this, const KB::String *a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v9;
  uint64_t v10;
  void **v11;

  v4 = *((unsigned __int16 *)a2 + 2);
  if (!*((_WORD *)a2 + 2))
  {
    KB::String::compute_length((unsigned __int16 *)a2);
    v4 = *((unsigned __int16 *)a2 + 2);
  }
  if (v4 < 3)
    return 0;
  KB::DictionaryContainer::lookup(*((_QWORD *)this + 28), a2, 1, 1, &v9);
  v6 = *((_QWORD *)this + 68);
  if (v6)
    v7 = 0;
  else
    v7 = v9 == v10;
  v5 = v7;
  if (v6 && v9 == v10)
    v5 = (*(uint64_t (**)(uint64_t, const KB::String *))(*(_QWORD *)v6 + 24))(v6, a2);
  v11 = (void **)&v9;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v11);
  return v5;
}

BOOL TIInputManager::is_autoshift(TIInputManager *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;

  v1 = *((unsigned int *)this + 24);
  v2 = v1 + 1;
  v3 = 40 * v1 - 8;
  while (--v2)
  {
    v4 = *((_QWORD *)this + 1);
    v5 = *(_BYTE *)(v4 + v3);
    v3 -= 40;
    if ((v5 & 0x40) != 0)
      return (_DWORD)v2 != -858993459 * ((unint64_t)(*((_QWORD *)this + 2) - v4) >> 3)
          && (*(_DWORD *)(v4 + 40 * v2 + 32) & 0x42) == 2;
  }
  v4 = *((_QWORD *)this + 1);
  return (_DWORD)v2 != -858993459 * ((unint64_t)(*((_QWORD *)this + 2) - v4) >> 3)
      && (*(_DWORD *)(v4 + 40 * v2 + 32) & 0x42) == 2;
}

void TIInputManager::input_flags_vector(TIInputManager *this@<X0>, std::vector<unsigned int> *a2@<X8>)
{
  uint64_t v4;
  unint64_t v5;
  char *end;
  unsigned int *value;
  std::vector<unsigned int>::pointer begin;
  unsigned int v9;
  unsigned int *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;

  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  std::vector<unsigned int>::reserve(a2, -858993459 * ((*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3));
  v4 = *((_QWORD *)this + 1);
  if (-858993459 * ((unint64_t)(*((_QWORD *)this + 2) - v4) >> 3))
  {
    v5 = 0;
    end = (char *)a2->__end_;
    value = a2->__end_cap_.__value_;
    begin = a2->__begin_;
    do
    {
      v9 = *(_DWORD *)(v4 + 40 * v5 + 32);
      if (end >= (char *)value)
      {
        v11 = (end - (char *)begin) >> 2;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 62)
          abort();
        if (((char *)value - (char *)begin) >> 1 > v12)
          v12 = ((char *)value - (char *)begin) >> 1;
        if ((unint64_t)((char *)value - (char *)begin) >= 0x7FFFFFFFFFFFFFFCLL)
          v13 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v13 = v12;
        if (v13)
          v13 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v13);
        else
          v14 = 0;
        v15 = (unsigned int *)(v13 + 4 * v11);
        *v15 = v9;
        v10 = v15 + 1;
        while (end != (char *)begin)
        {
          v16 = *((_DWORD *)end - 1);
          end -= 4;
          *--v15 = v16;
        }
        value = (unsigned int *)(v13 + 4 * v14);
        a2->__begin_ = v15;
        a2->__end_ = v10;
        a2->__end_cap_.__value_ = value;
        if (begin)
          operator delete(begin);
        begin = v15;
      }
      else
      {
        *(_DWORD *)end = v9;
        v10 = (unsigned int *)(end + 4);
      }
      a2->__end_ = v10;
      ++v5;
      v4 = *((_QWORD *)this + 1);
      end = (char *)v10;
    }
    while (v5 < -858993459 * ((unint64_t)(*((_QWORD *)this + 2) - v4) >> 3));
  }
}

uint64_t KB::CandidateCollection::operator=(uint64_t a1, uint64_t a2)
{
  std::vector<KB::Candidate>::__vdeallocate((void **)a1);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  std::vector<KB::Candidate>::__vdeallocate((void **)(a1 + 24));
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  std::vector<KB::Candidate>::__vdeallocate((void **)(a1 + 48));
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  std::vector<KB::Candidate>::__vdeallocate((void **)(a1 + 72));
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  return a1;
}

{
  if (a1 != a2)
  {
    std::vector<KB::Candidate>::__assign_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate **)a1, *(const KB::Candidate **)a2, *(const KB::Candidate **)(a2 + 8), 0x1CAC083126E978D5 * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3));
    std::vector<KB::Candidate>::__assign_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate **)(a1 + 24), *(const KB::Candidate **)(a2 + 24), *(const KB::Candidate **)(a2 + 32), 0x1CAC083126E978D5 * ((uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 3));
    std::vector<KB::Candidate>::__assign_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate **)(a1 + 48), *(const KB::Candidate **)(a2 + 48), *(const KB::Candidate **)(a2 + 56), 0x1CAC083126E978D5 * ((uint64_t)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48)) >> 3));
    std::vector<KB::Candidate>::__assign_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate **)(a1 + 72), *(const KB::Candidate **)(a2 + 72), *(const KB::Candidate **)(a2 + 80), 0x1CAC083126E978D5 * ((uint64_t)(*(_QWORD *)(a2 + 80) - *(_QWORD *)(a2 + 72)) >> 3));
  }
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  return a1;
}

void TIInputManager::filter_spellcheck_candidates(TIInputManager *this, uint64_t **a2, const KB::String *a3)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  _QWORD v8[6];

  v4 = *((_QWORD *)this + 68);
  if (v4)
  {
    (*(void (**)(_QWORD, uint64_t **, const KB::String *))(*(_QWORD *)v4 + 56))(*((_QWORD *)this + 68), a2, a3);
  }
  else
  {
    v6 = *a2;
    v5 = a2[1];
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = ___ZNK14TIInputManager28filter_spellcheck_candidatesERN2KB19CandidateCollectionERKNS0_6StringE_block_invoke;
    v8[3] = &__block_descriptor_tmp_25;
    v8[4] = this;
    v8[5] = a3;
    v7 = std::remove_if[abi:nn180100]<std::__wrap_iter<KB::Candidate *>,BOOL({block_pointer})(KB::Candidate const&)>(v6, v5, (uint64_t)v8);
    std::vector<KB::Candidate>::erase((uint64_t)a2, v7, (KB::Candidate *)a2[1]);
  }
}

BOOL ___ZNK14TIInputManager28filter_spellcheck_candidatesERN2KB19CandidateCollectionERKNS0_6StringE_block_invoke(uint64_t a1, _WORD *a2, uint64_t a3, const KB::String *a4)
{
  uint64_t v5;
  _LXLexicon *v6;

  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 224) + 8);
  v6 = (_LXLexicon *)(a2 + 444);
  if (!a2[444])
    KB::Candidate::compute_string((KB::Candidate *)a2);
  return KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(v5 + 72), v6, *(const KB::String **)(a1 + 40), a4) != 0;
}

uint64_t *std::remove_if[abi:nn180100]<std::__wrap_iter<KB::Candidate *>,BOOL({block_pointer})(KB::Candidate const&)>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t *i;

  if (a1 == a2)
    return a2;
  v5 = a1;
  while (((*(uint64_t (**)(uint64_t, uint64_t *))(a3 + 16))(a3, v5) & 1) == 0)
  {
    v5 += 125;
    if (v5 == a2)
      return a2;
  }
  if (v5 == a2)
    return a2;
  for (i = v5 + 125; i != a2; i += 125)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t *))(a3 + 16))(a3, i) & 1) == 0)
    {
      KB::Candidate::operator=(v5, i);
      v5 += 125;
    }
  }
  return v5;
}

void std::vector<unsigned int>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  int64_t v3;
  char *v4;
  unsigned int *v5;
  uint64_t v6;
  unsigned int *v7;
  std::vector<unsigned int>::pointer begin;
  unsigned int *end;
  unsigned int *v10;
  unsigned int v11;

  if (__n > this->__end_cap_.__value_ - this->__begin_)
  {
    if (__n >> 62)
      abort();
    v3 = (char *)this->__end_ - (char *)this->__begin_;
    v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(__n);
    v5 = (unsigned int *)&v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    v7 = (unsigned int *)&v4[4 * v6];
    begin = this->__begin_;
    end = this->__end_;
    v10 = v5;
    if (end != this->__begin_)
    {
      v10 = v5;
      do
      {
        v11 = *--end;
        *--v10 = v11;
      }
      while (end != begin);
    }
    this->__begin_ = v10;
    this->__end_ = v5;
    this->__end_cap_.__value_ = v7;
    if (begin)
      operator delete(begin);
  }
}

void std::vector<KB::Candidate>::__assign_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>(KB::Candidate **a1, const KB::Candidate *a2, const KB::Candidate *a3, unint64_t a4)
{
  const KB::Candidate *v6;
  KB::Candidate *v8;
  unint64_t v9;
  unint64_t v10;
  KB::Candidate *v11;
  KB::Candidate *v12;
  KB::Candidate *v13;
  const KB::Candidate *v14;
  uint64_t v15;
  KB::Candidate *v16;
  KB::Candidate *v17;

  v6 = a2;
  v8 = *a1;
  if (0x1CAC083126E978D5 * ((a1[2] - *a1) >> 3) >= a4)
  {
    v13 = a1[1];
    if (0x1CAC083126E978D5 * ((v13 - v8) >> 3) >= a4)
    {
      if (a2 != a3)
      {
        do
        {
          KB::Candidate::operator=((uint64_t)v8, (uint64_t)v6);
          v6 = (const KB::Candidate *)((char *)v6 + 1000);
          v8 = (KB::Candidate *)((char *)v8 + 1000);
        }
        while (v6 != a3);
        v13 = a1[1];
      }
      while (v13 != v8)
        KB::Candidate::~Candidate((KB::Candidate *)((char *)v13 - 1000));
      a1[1] = v8;
    }
    else
    {
      v14 = (const KB::Candidate *)((char *)a2 + 8 * ((v13 - v8) >> 3));
      if (v13 != v8)
      {
        v15 = 8 * ((v13 - v8) >> 3);
        do
        {
          KB::Candidate::operator=((uint64_t)v8, (uint64_t)v6);
          v6 = (const KB::Candidate *)((char *)v6 + 1000);
          v8 = (KB::Candidate *)((char *)v8 + 1000);
          v15 -= 1000;
        }
        while (v15);
        v8 = a1[1];
      }
      v16 = v8;
      if (v14 != a3)
      {
        v16 = v8;
        do
        {
          v17 = KB::Candidate::Candidate(v16, v14);
          v14 = (const KB::Candidate *)((char *)v14 + 1000);
          v16 = (KB::Candidate *)((char *)v17 + 1000);
        }
        while (v14 != a3);
      }
      a1[1] = v16;
    }
  }
  else
  {
    std::vector<KB::Candidate>::__vdeallocate((void **)a1);
    if (a4 > 0x4189374BC6A7EFLL)
      abort();
    v9 = 0x395810624DD2F1AALL * ((a1[2] - *a1) >> 3);
    if (v9 <= a4)
      v9 = a4;
    if ((unint64_t)(0x1CAC083126E978D5 * ((a1[2] - *a1) >> 3)) >= 0x20C49BA5E353F7)
      v10 = 0x4189374BC6A7EFLL;
    else
      v10 = v9;
    std::vector<KB::Candidate>::__vallocate[abi:nn180100](a1, v10);
    v11 = a1[1];
    while (v6 != a3)
    {
      v12 = KB::Candidate::Candidate(v11, v6);
      v6 = (const KB::Candidate *)((char *)v6 + 1000);
      v11 = (KB::Candidate *)((char *)v12 + 1000);
    }
    a1[1] = v11;
  }
}

void std::__function::__func<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0,std::allocator<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0,std::allocator<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1EA0FDA30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0,std::allocator<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1EA0FDA30;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0,std::allocator<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::operator()(uint64_t a1, const KB::Candidate **a2, uint64_t a3, unsigned __int8 *a4)
{
  int v6;
  uint64_t v7;
  NSObject *log;
  os_signpost_id_t v9;
  os_signpost_id_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int64_t v14;
  char *v15;
  NSObject *v16;
  os_signpost_id_t v17;
  os_signpost_id_t v18;
  int v19;
  const KB::String *v20;
  const KB::String *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CFTypeRef v25;
  __int128 v26;
  CFMutableStringRef Mutable;
  unsigned int *__p;
  unsigned int *v29;
  __int128 v30;
  CFTypeRef v31;
  int64_t v32;
  void *__dst;
  uint64_t v34;
  _BYTE v35[24];
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  CFTypeRef cf;
  uint8_t buf[8];
  void *v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD v44[7];

  v44[5] = *MEMORY[0x1E0C80C00];
  __p = *(unsigned int **)a3;
  v29 = *(unsigned int **)a3;
  v26 = *(_OWORD *)(a3 + 8);
  v30 = v26;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  v6 = *a4;
  v7 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)(v7 + 568))
    Mutable = CFStringCreateMutable(0, 0);
  else
    Mutable = 0;
  KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v35, a2);
  kdebug_trace();
  log = kac_get_log();
  v9 = os_signpost_id_make_with_pointer(log, (const void *)(v7 ^ 0x15));
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v10 = v9;
    if (os_signpost_enabled(log))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1DA6F2000, log, OS_SIGNPOST_INTERVAL_BEGIN, v10, "kbdManager.filterCandidates", "", buf, 2u);
    }
  }
  v11 = *(_QWORD *)(a1 + 16);
  v12 = *(_QWORD *)(a1 + 24);
  v13 = **(unsigned int **)(a1 + 32);
  __dst = 0;
  v34 = 0;
  v32 = 0;
  v14 = v26 - (_QWORD)__p;
  if ((unsigned int *)v26 != __p)
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](&v32, v14 >> 3);
    v15 = (char *)__dst;
    memmove(__dst, __p, v14);
    __dst = &v15[v14];
    v14 = v32;
  }
  TIInputManager::filter_raw_candidates(v7, (uint64_t)a2, v11, v12, v13);
  KB::CandidateCollection::operator=((uint64_t)a2, (uint64_t)buf);
  cf = v44;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  cf = &v43;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  cf = &v42;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  cf = buf;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  if (v14)
    operator delete((void *)v14);
  kdebug_trace();
  v16 = kac_get_log();
  v17 = os_signpost_id_make_with_pointer(v16, (const void *)(v7 ^ 0x15));
  if (v17 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v18 = v17;
    if (os_signpost_enabled(v16))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1DA6F2000, v16, OS_SIGNPOST_INTERVAL_END, v18, "kbdManager.filterCandidates", "", buf, 2u);
    }
  }
  if (v6)
    (*(void (**)(void))(**(_QWORD **)(a1 + 40) + 16))();
  if (*(_QWORD *)(v7 + 568))
  {
    (*(void (**)(CFTypeRef *__return_ptr, _QWORD, _QWORD))(**(_QWORD **)(v7 + 184) + 488))(&cf, *(_QWORD *)(v7 + 184), **(unsigned int **)(a1 + 32));
    v19 = KB::CandidateFilterFlags::candidate_filter_flag_type(&v29);
    v20 = (const KB::String *)&kGenericFlagDesc;
    if (v19 == 1)
      v20 = (const KB::String *)&kPostLMFlagDesc;
    if (v19)
      v21 = v20;
    else
      v21 = (const KB::String *)&kPreLMFlagDesc;
    KB::String::String((KB::String *)buf, v21);
    v22 = *(_QWORD *)(v7 + 568);
    v23 = *(_QWORD *)(a1 + 16);
    v24 = **(unsigned int **)(a1 + 32);
    v25 = cf;
    v31 = cf;
    if (cf)
    {
      CFRetain(cf);
      v31 = v25;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *, _BYTE *, CFMutableStringRef, const KB::Candidate **, CFTypeRef *))(*(_QWORD *)v22 + 24))(v22, v23, v24, buf, v35, Mutable, a2, &v31);
    if (v31)
      CFRelease(v31);
    v31 = 0;
    if (v41 && buf[6] == 1)
      free(v41);
    if (cf)
      CFRelease(cf);
  }
  *(_QWORD *)buf = &v38;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  *(_QWORD *)buf = &v37;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  *(_QWORD *)buf = &v36;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  *(_QWORD *)buf = v35;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  if (Mutable)
    CFRelease(Mutable);
  if (__p)
    operator delete(__p);
}

void TIInputManager::filter_raw_candidates(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  const void *v6;
  const void *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const KB::String *v14;
  const KB::String *v15;
  const KB::String *v16;
  const KB::String *v17;
  uint64_t v18;
  KB::CandidateCollection *v19;
  KB::CandidateCollection *v20;
  const KB::Candidate **v21;
  char v22;
  int v23;
  int v24;
  unsigned __int8 v25;
  unsigned int v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  uint64_t v33;
  BOOL v34;
  const void *v35;
  int v36;
  unsigned int *v37;
  unsigned int v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  unsigned int *v50;
  __int128 v51;
  uint64_t v52;
  char v53[8];
  std::__shared_weak_count *v54;
  void *v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  std::vector<unsigned int> v60;
  void *__p[3];
  uint64_t v62;
  std::__shared_weak_count *v63;
  int v64;
  __int16 v65;
  char v66;
  void *v67;
  char v68;
  _BYTE v69[1000];
  _BYTE v70[8];
  void *v71;
  _BYTE v72[1000];
  char v73;
  _BYTE v74[1000];
  __int128 v75;
  unsigned int v76[789];
  BOOL v77;
  BOOL v78;
  BOOL v79;
  char v80;
  BOOL v81;
  _BYTE v82[1000];
  _BYTE v83[1000];
  char v84;
  _BYTE v85[1000];
  uint64_t v86;
  void *v87;
  char v88;
  uint64_t v89;

  v5 = MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5);
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v18 = v5;
  v20 = v19;
  v89 = *MEMORY[0x1E0C80C00];
  KB::CandidateCollection::CandidateCollection(v19, v21);
  std::vector<KB::FilterFlag>::vector(__p, v11);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, void **))(*(_QWORD *)v18 + 48))(&v62, v18, v13, __p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v62)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t, const KB::String *))(*(_QWORD *)v18 + 72))(&v86, v18, v17);
    KB::Candidate::Candidate((KB::Candidate *)v85, v17, *(_DWORD *)(v18 + 248));
    v22 = v88;
    if (v88)
    {
      KB::Candidate::Candidate((KB::Candidate *)v83, (const KB::String *)&v86, *(_DWORD *)(v18 + 248));
      v22 = 1;
    }
    else
    {
      v83[0] = 0;
    }
    v84 = v22;
    KB::Candidate::Candidate((KB::Candidate *)v82, (const KB::String *)(v18 + 192), 0);
    v23 = KB::String::last((KB::String *)(v18 + 400));
    v24 = KB::String::last((KB::String *)(v18 + 400));
    if ((v25 & 1) == 0
    {
      KB::String::String((KB::String *)&TIInputManager::filter_raw_candidates(KB::CandidateCollection const&,KB::String const&,KB::String const&,KB::LookupType,KB::CandidateFilterFlags,BOOL,__CFString *)const::disallowed_domain_characters, ",~:;!@#$%^&'.(){}[]_/\\<>|");
      __cxa_atexit((void (*)(void *))KB::String::~String, &TIInputManager::filter_raw_candidates(KB::CandidateCollection const&,KB::String const&,KB::String const&,KB::LookupType,KB::CandidateFilterFlags,BOOL,__CFString *)const::disallowed_domain_characters, &dword_1DA6F2000);
    }
    v26 = *(unsigned __int16 *)(v18 + 400);
    if (v26 >= 2)
    {
      v28 = *(_QWORD *)(v18 + 408);
      if (!v28)
        v28 = v18 + 416;
      *(_QWORD *)&v51 = v28;
      DWORD2(v51) = v26;
      HIDWORD(v51) = v26;
      LODWORD(v52) = 0;
      KB::String::iterator::initialize((uint64_t *)&v51);
      v75 = v51;
      *(_QWORD *)v76 = v52;
      v29 = 2;
      do
      {
        KB::String::iterator::operator--((KB::String::iterator *)&v75);
        --v29;
      }
      while (v29);
      v27 = !KB::String::contains((KB::String *)&TIInputManager::filter_raw_candidates(KB::CandidateCollection const&,KB::String const&,KB::String const&,KB::LookupType,KB::CandidateFilterFlags,BOOL,__CFString *)const::disallowed_domain_characters, v76[0]);
    }
    else
    {
      v27 = 1;
    }
    KB::Candidate::Candidate((KB::Candidate *)v74, (const KB::Candidate *)v85);
    v72[0] = 0;
    v73 = 0;
    if (v84)
    {
      KB::Candidate::Candidate((KB::Candidate *)v72, (const KB::Candidate *)v83);
      v73 = 1;
    }
    TIInputManager::input_flags_vector((TIInputManager *)v18, &v60);
    KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v53, (const KB::LanguageModelContext *)(v18 + 432));
    KB::String::String((KB::String *)v70, v15);
    KB::Candidate::Candidate((KB::Candidate *)v69, (const KB::Candidate *)v82);
    KB::CandidateFilterLookupContext::CandidateFilterLookupContext((uint64_t)&v75, (uint64_t)v74, (const KB::Candidate *)v72, (uint64_t)&v60, (uint64_t)v53, (KB::String *)v70, (uint64_t)v69, v13);
    KB::Candidate::~Candidate((KB::Candidate *)v69);
    if (v71 && v70[6] == 1)
      free(v71);
    *(_QWORD *)&v51 = &v59;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v51);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v58);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v57);
    if (v55)
    {
      v56 = v55;
      operator delete(v55);
    }
    v30 = v54;
    if (v54)
    {
      p_shared_owners = (unint64_t *)&v54->__shared_owners_;
      do
        v32 = __ldaxr(p_shared_owners);
      while (__stlxr(v32 - 1, p_shared_owners));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    if (v60.__begin_)
    {
      v60.__end_ = v60.__begin_;
      operator delete(v60.__begin_);
    }
    if (v73)
      KB::Candidate::~Candidate((KB::Candidate *)v72);
    KB::Candidate::~Candidate((KB::Candidate *)v74);
    v33 = *(_QWORD *)(v18 + 8);
    if (-858993459 * ((unint64_t)(*(_QWORD *)(v18 + 16) - v33) >> 3))
      v34 = (*(_DWORD *)(v33 + 32) & 3) == 1;
    else
      v34 = 0;
    v77 = v34;
    v78 = v23 == 45;
    v79 = v24 == 46;
    v81 = v27;
    v80 = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
    v35 = *(const void **)(v18 + 136);
    v36 = *(_DWORD *)(v18 + 248);
    v37 = *(unsigned int **)(v18 + 224);
    v50 = v37;
    if (v37)
    {
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 + 1, v37));
    }
    v39 = *(std::__shared_weak_count **)(v18 + 240);
    v48 = *(_QWORD *)(v18 + 232);
    v49 = v39;
    if (v39)
    {
      v40 = (unint64_t *)&v39->__shared_owners_;
      do
        v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
    }
    KB::CandidateFilterResources::CandidateFilterResources((uint64_t)&v51, v35, v36, (uint64_t *)&v50, (uint64_t)&v48, *(const void **)(v18 + 560), v18 + 592, v7);
    v42 = v49;
    if (v49)
    {
      v43 = (unint64_t *)&v49->__shared_owners_;
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
    }
    if (v50)
      WTF::RefCounted<KB::DictionaryContainer>::deref(v50);
    (*(void (**)(uint64_t, KB::CandidateCollection *, __int128 *, __int128 *))(*(_QWORD *)v62 + 24))(v62, v20, &v75, &v51);
    if (!(_DWORD)v13 && v9)
    {
      if (*(_QWORD *)v20 == *((_QWORD *)v20 + 1))
      {
        v64 = 0x100000;
        v65 = 0;
        v66 = 0;
        v67 = 0;
        v68 = 0;
      }
      else
      {
        KB::Candidate::capitalized_string(*(KB::Candidate **)v20, (uint64_t)&v64);
      }
      KB::String::operator=(v18 + 192, (KB::String *)&v64);
      if (v67)
      {
        if (v66 == 1)
          free(v67);
      }
    }
    KB::CandidateFilterResources::~CandidateFilterResources((KB::CandidateFilterResources *)&v51);
    KB::CandidateFilterLookupContext::~CandidateFilterLookupContext((KB::CandidateFilterLookupContext *)&v75);
    KB::Candidate::~Candidate((KB::Candidate *)v82);
    if (v84)
      KB::Candidate::~Candidate((KB::Candidate *)v83);
    KB::Candidate::~Candidate((KB::Candidate *)v85);
    if (v88 && v87 && BYTE6(v86) == 1)
      free(v87);
  }
  v45 = v63;
  if (v63)
  {
    v46 = (unint64_t *)&v63->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
}

TI::Favonius::FavoniusStrokeBuildManager *TIInputManager::create_autocorrection_engine_with_synthetic_typing@<X0>(const KB::String **this@<X0>, const KB::String *a2@<X1>, TI::Favonius::FavoniusStrokeBuildManager **a3@<X8>)
{
  double v6;
  unsigned int *v7;
  unsigned int v8;
  _QWORD *v9;
  int v10;
  TI::Favonius::FavoniusStrokeBuildManager *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  __n128 v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  TI::Favonius::FavoniusStrokeBuildManager *v25;
  unsigned int v26;
  int v27;
  TI::Favonius::FavoniusStrokeBuildManager *result;
  unsigned int *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int16 v32;
  uint64_t v33;
  _QWORD *v34;
  int v35;
  int v36;
  int v37;
  _QWORD *v38;
  int v39;
  int v40;
  unsigned int v41;
  TI::Favonius::FavoniusStrokeBuildManager *v42;
  _QWORD v43[3];
  _QWORD *v44;
  _BYTE v45[6];
  char v46;
  void *v47;
  int v48;
  __int16 v49;
  char v50;
  void *v51;
  char v52;
  _WORD v53[3];
  char v54;
  _QWORD *v55;
  _QWORD v56[4];

  v56[2] = *MEMORY[0x1E0C80C00];
  v6 = KB::system_uptime((KB *)this);
  TIInputManager::create_autocorrection_engine((TIInputManager *)this, &v42);
  v7 = (unsigned int *)*TIInputManager::favonius_layout((TIInputManager *)this);
  if (v7)
  {
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 + 1, v7));
  }
  KB::lower_string(a2, this[17], (KB::String *)v53);
  v48 = 0x100000;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  if (v55)
    v9 = v55;
  else
    v9 = v56;
  v38 = v9;
  v10 = v53[0];
  v39 = 0;
  v40 = v53[0];
  v41 = 0;
  KB::String::iterator::initialize((uint64_t *)&v38);
  v34 = v9;
  v35 = v10;
  v36 = v10;
  v37 = 0;
  KB::String::iterator::initialize((uint64_t *)&v34);
  v11 = v42;
  if (v39 == v35)
    goto LABEL_41;
  v12 = 0;
  do
  {
    v13 = v41;
    (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, char *, int *, uint64_t, uint64_t))(*(_QWORD *)v11 + 144))(v11, (char *)this + 432, &v48, v12, v12);
    KB::String::String((uint64_t)v45, v13);
    KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*((_QWORD *)this[28] + 1) + 72), (_LXLexicon *)v45, &v32);
    if (!v32)
    {
      if (v47 && v46 == 1)
        free(v47);
      goto LABEL_38;
    }
    TI::Favonius::KeyboardLayout::key_for_char((uint64_t)v7, v13, v43);
    v14 = v43[0];
    v31 = v43[0];
    if (v43[0])
      goto LABEL_19;
    v43[0] = &off_1EA0FDAC0;
    v43[1] = &v31;
    v44 = v43;
    v15.n128_f32[0] = TI::Favonius::KeyboardLayout::enumerate_keys_with_sort_key((uint64_t)v7, &v32, (uint64_t)v43);
    v16 = v44;
    if (v44 == v43)
    {
      v16 = v43;
      v17 = 4;
    }
    else
    {
      if (!v44)
        goto LABEL_18;
      v17 = 5;
    }
    (*(void (**)(__n128))(*v16 + 8 * v17))(v15);
LABEL_18:
    v14 = v31;
    if (!v31)
    {
      v27 = 0;
      *a3 = 0;
      goto LABEL_31;
    }
LABEL_19:
    v18 = *(_QWORD *)(v14 + 96);
    v19 = *(_QWORD *)(v14 + 104);
    v20 = operator new();
    v21 = (unsigned int *)v20;
    *(_DWORD *)v20 = 1;
    *(_QWORD *)(v20 + 8) = v18;
    *(_QWORD *)(v20 + 16) = v19;
    *(_DWORD *)(v20 + 24) = 1084227584;
    *(double *)(v20 + 32) = v6;
    *(_OWORD *)(v20 + 40) = xmmword_1DA910FC0;
    *(_QWORD *)(v20 + 56) = v7;
    if (v7)
    {
      do
        v22 = __ldaxr(v7);
      while (__stlxr(v22 + 1, v7));
    }
    v30 = v20;
    do
      v23 = __ldaxr((unsigned int *)v20);
    while (__stlxr(v23 + 1, (unsigned int *)v20));
    v24 = (*(uint64_t (**)(TI::Favonius::FavoniusStrokeBuildManager *, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v11 + 24))(v11, &v30, 0xFFFFFFFFLL, 1);
    if (v30)
      WTF::RefCounted<TI::Favonius::Touch>::deref(v30);
    v25 = v42;
    v29 = v21;
    do
      v26 = __ldaxr(v21);
    while (__stlxr(v26 + 1, v21));
    (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, unsigned int **, uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, &v29, v24, 0);
    if (v29)
      WTF::RefCounted<TI::Favonius::Touch>::deref((uint64_t)v29);
    v11 = v42;
    v27 = 1;
    (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, uint64_t, _QWORD))(*(_QWORD *)v42 + 48))(v42, 1, 0);
    KB::String::append((unsigned __int16 *)&v48, (const KB::String *)v45);
    v12 = (v12 + 1);
    WTF::RefCounted<TI::Favonius::Touch>::deref((uint64_t)v21);
    if (v31)
      WTF::RefCounted<TI::Favonius::Key>::deref(v31);
LABEL_31:
    if (v32 >= 0xFu && v33)
      MEMORY[0x1DF0A212C](v33, 0x1000C8077774924);
    if (v47 && v46 == 1)
      free(v47);
    if (!v27)
      goto LABEL_42;
LABEL_38:
    KB::String::iterator::operator++((uint64_t *)&v38);
  }
  while (v39 != v35);
  v11 = v42;
LABEL_41:
  v42 = 0;
  *a3 = v11;
LABEL_42:
  if (v51 && v50 == 1)
    free(v51);
  if (v55 && v54 == 1)
    free(v55);
  if (v7)
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref((uint64_t)v7);
  result = v42;
  if (v42)
    return (TI::Favonius::FavoniusStrokeBuildManager *)(*(uint64_t (**)(TI::Favonius::FavoniusStrokeBuildManager *))(*(_QWORD *)v42 + 8))(v42);
  return result;
}

uint64_t *TIInputManager::favonius_layout(TIInputManager *this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  KB::String *v7;
  int v8;

  v2 = (uint64_t *)((char *)this + 320);
  v3 = *((_QWORD *)this + 40);
  if (!v3)
  {
    v4 = operator new();
    v5 = TI::Favonius::KeyboardLayout::KeyboardLayout(v4, (_QWORD *)this + 32);
    v6 = *((_QWORD *)this + 40);
    *((_QWORD *)this + 40) = v5;
    if (v6)
    {
      WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v6);
      v5 = *v2;
    }
    *(_BYTE *)(v5 + 112) = *((_BYTE *)this + 280);
    KB::String::operator=((KB::String *)(v5 + 208), (TIInputManager *)((char *)this + 288));
    v3 = *((_QWORD *)this + 40);
  }
  v8 = *(unsigned __int16 *)(v3 + 208);
  v7 = (KB::String *)(v3 + 208);
  if (!v8)
    KB::String::operator=(v7, (TIInputManager *)((char *)this + 288));
  return v2;
}

void std::__function::__func<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0,std::allocator<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0,std::allocator<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x38uLL);
  *(_QWORD *)v2 = &off_1EA0FDA78;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 std::__function::__func<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0,std::allocator<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1EA0FDA78;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0,std::allocator<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::operator()(uint64_t a1, const KB::Candidate **a2, uint64_t a3, unsigned __int8 *a4)
{
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  unsigned int *v14;
  uint64_t v15;
  int v16;
  const KB::String *v17;
  const KB::String *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFTypeRef v22;
  __int128 v23;
  CFMutableStringRef Mutable;
  int v25;
  unsigned int *v26;
  __int128 v27;
  CFTypeRef v28;
  int64_t v29;
  void *__dst;
  uint64_t v31;
  _BYTE v32[24];
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  CFTypeRef cf;
  void **v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[6];

  v41[4] = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned int **)a3;
  v26 = *(unsigned int **)a3;
  v23 = *(_OWORD *)(a3 + 8);
  v27 = v23;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  v25 = *a4;
  v7 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)(v7 + 568))
    Mutable = CFStringCreateMutable(0, 0);
  else
    Mutable = 0;
  v8 = (uint64_t)a2;
  KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v32, a2);
  v9 = *(_QWORD *)(a1 + 16);
  v10 = *(_QWORD *)(a1 + 24);
  v11 = **(unsigned int **)(a1 + 32);
  __dst = 0;
  v31 = 0;
  v29 = 0;
  v12 = v23 - (_QWORD)v6;
  if ((unsigned int *)v23 == v6)
  {
    v14 = v6;
  }
  else
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](&v29, v12 >> 3);
    v13 = (char *)__dst;
    v14 = v6;
    memmove(__dst, v6, v12);
    __dst = &v13[v12];
    v12 = v29;
  }
  TIInputManager::filter_raw_candidates(v7, v8, v9, v10, v11);
  KB::CandidateCollection::operator=(v8, (uint64_t)&v37);
  cf = v41;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  cf = &v40;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  cf = &v39;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  cf = &v37;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  if (v12)
    operator delete((void *)v12);
  if (v25)
    (*(void (**)(void))(**(_QWORD **)(a1 + 40) + 16))();
  v15 = *(_QWORD *)(v7 + 568);
  if (v15)
  {
    (*(void (**)(uint64_t, _QWORD, BOOL))(*(_QWORD *)v15 + 16))(v15, **(_QWORD **)(a1 + 48), *(_QWORD *)(v7 + 224) != 0);
    (*(void (**)(CFTypeRef *__return_ptr, _QWORD, _QWORD))(***(_QWORD ***)(a1 + 48) + 488))(&cf, **(_QWORD **)(a1 + 48), **(unsigned int **)(a1 + 32));
    v16 = KB::CandidateFilterFlags::candidate_filter_flag_type(&v26);
    v17 = (const KB::String *)&kGenericFlagDesc;
    if (v16 == 1)
      v17 = (const KB::String *)&kPostLMFlagDesc;
    if (v16)
      v18 = v17;
    else
      v18 = (const KB::String *)&kPreLMFlagDesc;
    KB::String::String((KB::String *)&v37, v18);
    v19 = *(_QWORD *)(v7 + 568);
    v20 = *(_QWORD *)(a1 + 16);
    v21 = **(unsigned int **)(a1 + 32);
    v22 = cf;
    v28 = cf;
    if (cf)
    {
      CFRetain(cf);
      v28 = v22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, void ***, _BYTE *, CFMutableStringRef, uint64_t, CFTypeRef *))(*(_QWORD *)v19 + 24))(v19, v20, v21, &v37, v32, Mutable, v8, &v28);
    if (v28)
      CFRelease(v28);
    v28 = 0;
    if (v38 && BYTE6(v37) == 1)
      free(v38);
    if (cf)
      CFRelease(cf);
  }
  v37 = (void **)&v35;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v37);
  v37 = (void **)&v34;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v37);
  v37 = (void **)&v33;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v37);
  v37 = (void **)v32;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v37);
  if (Mutable)
    CFRelease(Mutable);
  if (v14)
    operator delete(v14);
}

void TIInputManager::create_autocorrection_engine(TIInputManager *this@<X0>, TI::Favonius::FavoniusStrokeBuildManager **a2@<X8>)
{
  TI::Favonius::FavoniusStrokeBuildManager *v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unsigned int *v20;
  unsigned int *v21;
  unsigned int *v22;

  v4 = (TI::Favonius::FavoniusStrokeBuildManager *)operator new();
  TI::Favonius::FavoniusStrokeBuildManager::FavoniusStrokeBuildManager(v4);
  v5 = *((_QWORD *)this + 23);
  if (v5)
  {
    (*(void (**)(unsigned int **__return_ptr))(*(_QWORD *)v5 + 168))(&v22);
    (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, unsigned int **))(*(_QWORD *)v4 + 176))(v4, &v22);
    if (v22)
    {
      v6 = v22 + 2;
      v7 = atomic_load(v22 + 2);
      if (v7 == 1)
      {
        (*(void (**)(void))(*(_QWORD *)v22 + 40))();
      }
      else
      {
        do
          v8 = __ldaxr(v6);
        while (__stlxr(v8 - 1, v6));
      }
    }
    (*(void (**)(unsigned int **__return_ptr))(**((_QWORD **)this + 23) + 184))(&v21);
    (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, unsigned int **))(*(_QWORD *)v4 + 192))(v4, &v21);
    if (v21)
    {
      v9 = v21 + 2;
      v10 = atomic_load(v21 + 2);
      if (v10 == 1)
      {
        (*(void (**)(void))(*(_QWORD *)v21 + 8))();
      }
      else
      {
        do
          v11 = __ldaxr(v9);
        while (__stlxr(v11 - 1, v9));
      }
    }
    (*(void (**)(unsigned int **__return_ptr))(**((_QWORD **)this + 23) + 216))(&v20);
    (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, unsigned int **))(*(_QWORD *)v4 + 224))(v4, &v20);
    if (v20)
    {
      v12 = v20 + 2;
      v13 = atomic_load(v20 + 2);
      if (v13 == 1)
      {
        (*(void (**)(void))(*(_QWORD *)v20 + 16))();
      }
      else
      {
        do
          v14 = __ldaxr(v12);
        while (__stlxr(v14 - 1, v12));
      }
    }
    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 23) + 200))(&v18);
    (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, uint64_t *))(*(_QWORD *)v4 + 208))(v4, &v18);
    v15 = v19;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  *a2 = v4;
}

uint64_t WTF::RefCounted<TI::Favonius::Touch>::deref(uint64_t result)
{
  unsigned int v1;
  uint64_t v2;
  unsigned int v3;

  v1 = atomic_load((unsigned int *)result);
  if (v1 == 1)
  {
    v2 = *(_QWORD *)(result + 56);
    if (v2)
      WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v2);
    JUMPOUT(0x1DF0A2144);
  }
  do
    v3 = __ldaxr((unsigned int *)result);
  while (__stlxr(v3 - 1, (unsigned int *)result));
  return result;
}

void std::__function::__func<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0,std::allocator<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0>,void ()(WTF::RefPtr<TI::Favonius::LayoutKey> const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0,std::allocator<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0>,void ()(WTF::RefPtr<TI::Favonius::LayoutKey> const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA0FDAC0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0,std::allocator<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0>,void ()(WTF::RefPtr<TI::Favonius::LayoutKey> const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA0FDAC0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0,std::allocator<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0>,void ()(WTF::RefPtr<TI::Favonius::LayoutKey> const&)>::operator()(uint64_t result, unsigned int **a2)
{
  uint64_t *v2;
  unsigned int *v3;
  unsigned int v4;

  v2 = *(uint64_t **)(result + 8);
  if (!*v2)
  {
    v3 = *a2;
    if (*a2)
    {
      do
        v4 = __ldaxr(v3);
      while (__stlxr(v4 + 1, v3));
      result = *v2;
      *v2 = (uint64_t)v3;
      if (result)
        return WTF::RefCounted<TI::Favonius::Key>::deref(result);
    }
    else
    {
      *v2 = 0;
    }
  }
  return result;
}

uint64_t *KB::String::find_last_of(KB::String *this, const KB::String *a2, const KB::String *a3)
{
  int v6;
  char *v7;
  char *v9;
  int v10;
  int v11;
  int v12;

  v6 = *(unsigned __int16 *)a2;
  v7 = (char *)*((_QWORD *)a2 + 1);
  if (!v7)
    v7 = (char *)a2 + 16;
  v9 = v7;
  v10 = v6;
  v11 = v6;
  v12 = 0;
  KB::String::iterator::initialize((uint64_t *)&v9);
  return KB::String::find_last_of(a2, a3, (const KB::String::iterator *)&v9, (uint64_t)this);
}

uint64_t repeating_character_threshold(const __CFLocale *a1)
{
  const __CFString *Value;

  if (a1
    && (Value = (const __CFString *)CFLocaleGetValue(a1, (CFLocaleKey)*MEMORY[0x1E0C9B088]),
        CFStringCompare(Value, CFSTR("de"), 0) == kCFCompareEqualTo))
  {
    return 4;
  }
  else
  {
    return 3;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,false>(unint64_t a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  float v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  float v22;
  uint64_t *v23;
  float v24;
  uint64_t *v25;
  uint64_t *v26;
  float v27;
  float v28;
  char v29;
  float v30;
  uint64_t v31;
  float v32;
  unint64_t v33;
  float v34;
  uint64_t *v35;
  uint64_t *v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  float v46;
  uint64_t v47;
  float v48;
  float v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t v52;
  float v53;
  uint64_t *v54;
  float v55;
  uint64_t v56;
  uint64_t v57[93];
  float v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
LABEL_2:
  v8 = a1;
  v56 = a1 + 1000;
  v9 = a1 + 2000;
  while (2)
  {
    v10 = (uint64_t)a2 - v8;
    v11 = 0x1CAC083126E978D5 * (((uint64_t)a2 - v8) >> 3);
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v41 = expf(*((float *)a2 - 64));
        if (v41 > expf(*(float *)(v8 + 744)))
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v8, a2 - 125);
        return;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v8, v8 + 1000, (uint64_t)(a2 - 125));
        return;
      case 4uLL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v8, v8 + 1000, v8 + 2000, (uint64_t)(a2 - 125));
        return;
      case 5uLL:
        std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v8, v8 + 1000, v8 + 2000, v8 + 3000, (uint64_t)(a2 - 125));
        return;
      default:
        if (v10 > 23999)
        {
          if (!a3)
          {
            if ((uint64_t *)v8 != a2)
              std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,KB::Candidate *>(v8, a2, a2);
            return;
          }
          v12 = v11 >> 1;
          v13 = (uint64_t *)(v8 + 1000 * (v11 >> 1));
          v14 = (uint64_t)(a2 - 125);
          if ((unint64_t)v10 < 0x1F401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>((uint64_t)v13, v8, v14);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v8, (uint64_t)v13, v14);
            v15 = v8 + 1000 * v12;
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v56, v15 - 1000, (uint64_t)(a2 - 250));
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v9, v15 + 1000, (uint64_t)(a2 - 375));
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v15 - 1000, (uint64_t)v13, v15 + 1000);
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v8, v13);
          }
          --a3;
          if ((a4 & 1) != 0 || (v16 = expf(*(float *)(v8 - 256)), v16 > expf(*(float *)(v8 + 744))))
          {
            KB::Candidate::Candidate((uint64_t)v57, v8);
            v17 = expf(v58);
            v18 = (uint64_t *)v8;
            do
            {
              v19 = (uint64_t)v18;
              v18 += 125;
            }
            while (expf(*(float *)(v19 + 1744)) > v17);
            v20 = a2;
            if (v19 == v8)
            {
              v23 = a2;
              while (v18 < v23)
              {
                v21 = v23 - 125;
                v24 = expf(*((float *)v23 - 64));
                v23 = v21;
                if (v24 > v17)
                  goto LABEL_21;
              }
              v21 = v23;
            }
            else
            {
              do
              {
                v21 = v20 - 125;
                v22 = expf(*((float *)v20 - 64));
                v20 = v21;
              }
              while (v22 <= v17);
            }
LABEL_21:
            if (v18 < v21)
            {
              v25 = v18;
              v26 = v21;
              do
              {
                std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v25, v26);
                v27 = expf(v58);
                do
                {
                  v19 = (uint64_t)v25;
                  v25 += 125;
                }
                while (expf(*(float *)(v19 + 1744)) > v27);
                do
                {
                  v28 = *((float *)v26 - 64);
                  v26 -= 125;
                }
                while (expf(v28) <= v27);
              }
              while (v25 < v26);
            }
            if (v19 != v8)
              KB::Candidate::operator=((uint64_t *)v8, (uint64_t *)v19);
            KB::Candidate::operator=((uint64_t *)v19, v57);
            KB::Candidate::~Candidate((KB::Candidate *)v57);
            if (v18 >= v21)
            {
              v29 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v8, v19);
              a1 = v19 + 1000;
              if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v19 + 1000, (uint64_t)a2))
              {
                a2 = (uint64_t *)v19;
                if ((v29 & 1) == 0)
                  continue;
                return;
              }
              if ((v29 & 1) != 0)
                goto LABEL_2;
            }
            std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,false>(v8, v19, a3, a4 & 1);
            a4 = 0;
            a1 = v19 + 1000;
            goto LABEL_2;
          }
          KB::Candidate::Candidate((uint64_t)v57, v8);
          v30 = expf(v58);
          if (v30 <= expf(*((float *)a2 - 64)))
          {
            v33 = v8 + 1000;
            do
            {
              a1 = v33;
              if (v33 >= (unint64_t)a2)
                break;
              v34 = expf(*(float *)(v33 + 744));
              v33 = a1 + 1000;
            }
            while (v30 <= v34);
          }
          else
          {
            v31 = v8;
            do
            {
              a1 = v31 + 1000;
              v32 = expf(*(float *)(v31 + 1744));
              v31 = a1;
            }
            while (v30 <= v32);
          }
          v35 = a2;
          if (a1 < (unint64_t)a2)
          {
            v36 = a2;
            do
            {
              v35 = v36 - 125;
              v37 = expf(*((float *)v36 - 64));
              v36 = v35;
            }
            while (v30 > v37);
          }
          while (a1 < (unint64_t)v35)
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, v35);
            v38 = expf(v58);
            do
            {
              v39 = *(float *)(a1 + 1744);
              a1 += 1000;
            }
            while (v38 <= expf(v39));
            do
            {
              v40 = *((float *)v35 - 64);
              v35 -= 125;
            }
            while (v38 > expf(v40));
          }
          if (a1 - 1000 != v8)
            KB::Candidate::operator=((uint64_t *)v8, (uint64_t *)(a1 - 1000));
          KB::Candidate::operator=((uint64_t *)(a1 - 1000), v57);
          KB::Candidate::~Candidate((KB::Candidate *)v57);
          a4 = 0;
          goto LABEL_2;
        }
        if ((a4 & 1) != 0)
        {
          if ((uint64_t *)v8 != a2)
          {
            v42 = v8 + 1000;
            if ((uint64_t *)(v8 + 1000) != a2)
            {
              v43 = 0;
              v44 = v8;
              do
              {
                v45 = v44;
                v44 = v42;
                v46 = expf(*(float *)(v45 + 1744));
                if (v46 > expf(*(float *)(v45 + 744)))
                {
                  KB::Candidate::Candidate((uint64_t)v57, v44);
                  v47 = v43;
                  while (1)
                  {
                    KB::Candidate::operator=((uint64_t *)(v8 + v47 + 1000), (uint64_t *)(v8 + v47));
                    if (!v47)
                      break;
                    v48 = expf(v58);
                    v49 = expf(*(float *)(v8 + v47 - 256));
                    v47 -= 1000;
                    if (v48 <= v49)
                    {
                      v50 = (uint64_t *)(v8 + v47 + 1000);
                      goto LABEL_69;
                    }
                  }
                  v50 = (uint64_t *)v8;
LABEL_69:
                  KB::Candidate::operator=(v50, v57);
                  KB::Candidate::~Candidate((KB::Candidate *)v57);
                }
                v42 = v44 + 1000;
                v43 += 1000;
              }
              while ((uint64_t *)(v44 + 1000) != a2);
            }
          }
        }
        else if ((uint64_t *)v8 != a2)
        {
          v51 = (uint64_t *)(v8 + 1000);
          while (v51 != a2)
          {
            v52 = (uint64_t)v51;
            v53 = expf(*(float *)(v8 + 1744));
            if (v53 > expf(*(float *)(v8 + 744)))
            {
              KB::Candidate::Candidate((uint64_t)v57, v52);
              do
              {
                v54 = (uint64_t *)v8;
                KB::Candidate::operator=((uint64_t *)(v8 + 1000), (uint64_t *)v8);
                v8 -= 1000;
                v55 = expf(v58);
              }
              while (v55 > expf(*((float *)v54 - 64)));
              KB::Candidate::operator=(v54, v57);
              KB::Candidate::~Candidate((KB::Candidate *)v57);
            }
            v51 = (uint64_t *)(v52 + 1000);
            v8 = v52;
          }
        }
        return;
    }
  }
}

uint64_t TIInputManager::inject_supplemental_candidate(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v6;
  char v7;
  uint64_t v9;
  uint64_t v10;
  char v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  KB::Candidate *v16;
  char *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  char *v30;
  _QWORD v31[2];
  uint64_t (*v32)(uint64_t, _LXLexicon *, const KB::String *, const KB::String *);
  void *v33;
  uint64_t v34;
  _QWORD v35[30];
  char v36;
  int v37;
  _BYTE v38[240];
  char v39;
  _BYTE v40[8];
  void *v41;
  unint64_t v42;
  char *v43;
  char *v44;
  unint64_t v45;
  uint64_t *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!TITransientLexiconManagerGetActiveSupplementalLexiconWords()
    || a2 != 1
    && (a2
     || !*(_DWORD *)(a1 + 536)
     || (v6 = *(_QWORD *)(a1 + 224)) != 0 && **(_QWORD **)(v6 + 8) != *(_QWORD *)(*(_QWORD *)(v6 + 8) + 8)))
  {
    v7 = 0;
    return v7 & 1;
  }
  TIInputManager::legacy_input_stem((TIInputManager *)a1, (uint64_t)v40);
  v31[0] = MEMORY[0x1E0C809B0];
  v31[1] = 0x40000000;
  v32 = ___ZN14TIInputManager29inject_supplemental_candidateEN2KB10LookupTypeERNS0_19CandidateCollectionE_block_invoke;
  v33 = &__block_descriptor_tmp_5_4702;
  v34 = a1;
  v35[0] = MEMORY[0x1E0C809B0];
  v35[1] = 0x40000000;
  v35[2] = ___ZN14TIInputManager30word_from_supplemental_lexiconERN2KB6StringE_block_invoke;
  v35[3] = &__block_descriptor_tmp_4703;
  v35[4] = a1;
  KB::DynamicDictionary::word_from_supplemental_lexicon(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 24), v38);
  v10 = *a3;
  v9 = a3[1];
  if (!v39)
  {
    if (v9 == *a3)
    {
      v7 = 0;
      goto LABEL_61;
    }
    v18 = 0;
    v7 = 0;
    while (1)
    {
      v19 = (_QWORD *)(v10 + 1000 * v18);
      if (*v19)
      {
        v20 = 240 * *v19 - 240;
        v21 = (uint64_t *)(v19[1] + 224);
        do
        {
          v23 = *v21;
          v21 += 30;
          v22 = v23;
          if (v23)
            v24 = 1;
          else
            v24 = v20 == 0;
          v20 -= 240;
        }
        while (!v24);
        if (!v22)
        {
          KB::DynamicDictionary::word_from_supplemental_lexicon(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 24), v35);
          if (v36)
          {
            KB::Candidate::pop_last_word((KB::Candidate *)(v10 + 1000 * v18));
            if (!v36)
              goto LABEL_66;
            KB::Candidate::append((unsigned __int16 *)(v10 + 1000 * v18), (const KB::Word *)v35);
            if (v36)
              KB::Word::~Word((KB::Word *)v35);
            v7 = 1;
          }
          v10 = *a3;
          v9 = a3[1];
        }
      }
      if (++v18 >= (unint64_t)(0x1CAC083126E978D5 * ((v9 - v10) >> 3)))
        goto LABEL_61;
    }
  }
  if (v9 == *a3)
  {
LABEL_22:
    TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)&v42);
    KB::Candidate::Candidate((KB::Candidate *)v35, (const KB::String *)&v42, 0);
    if (v43 && BYTE6(v42) == 1)
      free(v43);
    if (v35[0])
      KB::Candidate::pop_last_word((KB::Candidate *)v35);
    if (v39)
    {
      KB::Candidate::append((unsigned __int16 *)v35, (const KB::Word *)v38);
      v37 = 1065353216;
      v15 = a3[2];
      v16 = (KB::Candidate *)a3[1];
      if ((unint64_t)v16 < v15)
      {
        v17 = (char *)KB::Candidate::Candidate(v16, (const KB::Candidate *)v35) + 1000;
LABEL_59:
        a3[1] = (uint64_t)v17;
        KB::Candidate::~Candidate((KB::Candidate *)v35);
        v11 = 1;
        goto LABEL_60;
      }
      v25 = 0x1CAC083126E978D5 * (((uint64_t)v16 - *a3) >> 3);
      if ((unint64_t)(v25 + 1) <= 0x4189374BC6A7EFLL)
      {
        v26 = 0x1CAC083126E978D5 * ((uint64_t)(v15 - *a3) >> 3);
        v27 = 2 * v26;
        if (2 * v26 <= v25 + 1)
          v27 = v25 + 1;
        if (v26 >= 0x20C49BA5E353F7)
          v28 = 0x4189374BC6A7EFLL;
        else
          v28 = v27;
        v46 = a3 + 2;
        if (v28)
          v28 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v28);
        else
          v29 = 0;
        v30 = (char *)(v28 + 1000 * v25);
        v42 = v28;
        v43 = v30;
        v45 = v28 + 1000 * v29;
        KB::Candidate::Candidate((KB::Candidate *)v30, (const KB::Candidate *)v35);
        v44 = v30 + 1000;
        std::vector<KB::Candidate>::__swap_out_circular_buffer(a3, &v42);
        v17 = (char *)a3[1];
        std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v42);
        goto LABEL_59;
      }
    }
    else
    {
LABEL_66:
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    abort();
  }
  v11 = 0;
  v12 = 0;
LABEL_12:
  v13 = 1000 * v12;
  do
  {
    v14 = *(_QWORD *)(v10 + v13);
    if (v14)
    {
      if ((((uint64_t (*)(_QWORD *, _BYTE *, uint64_t))v32)(v31, v40, *(_QWORD *)(v10 + v13 + 8) + 240 * v14 - 240) & 1) != 0)
      {
        KB::Candidate::pop_last_word((KB::Candidate *)(v10 + v13));
        if (!v39)
          goto LABEL_66;
        KB::Candidate::append((unsigned __int16 *)(v10 + v13), (const KB::Word *)v38);
        *(_DWORD *)(v10 + 1000 * v12++ + 744) = 1065353216;
        v10 = *a3;
        v9 = a3[1];
        v11 = 1;
        if (v12 >= 0x1CAC083126E978D5 * ((v9 - *a3) >> 3))
          goto LABEL_60;
        goto LABEL_12;
      }
      v10 = *a3;
      v9 = a3[1];
    }
    ++v12;
    v13 += 1000;
  }
  while (v12 < 0x1CAC083126E978D5 * ((v9 - v10) >> 3));
  if ((v11 & 1) == 0)
    goto LABEL_22;
LABEL_60:
  v7 = v11;
LABEL_61:
  if (v39)
    KB::Word::~Word((KB::Word *)v38);
  if (v41 && v40[6] == 1)
    free(v41);
  return v7 & 1;
}

void TIInputManager::apply_case_insensitive_constraints(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  int v8;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  _QWORD v15[4];
  _QWORD v16[5];
  _BYTE v17[8];
  void *v18;
  _BYTE v19[8];
  void *v20;
  _BYTE v21[8];
  void *v22;
  uint64_t v23;
  int v24;
  _BYTE v25[8];
  void *v26;
  _BYTE v27[8];
  void *v28;
  _BYTE v29[8];
  void *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 172) <= *(_DWORD *)(a1 + 176))
    v8 = *(_DWORD *)(a1 + 176);
  else
    v8 = *(_DWORD *)(a1 + 172);
  v9 = (unsigned __int16 *)(a1 + 8);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, v8, (uint64_t)v29);
  TIInputManager::input_substring(v9, 0, *(_DWORD *)(a1 + 172), (uint64_t)v27);
  TIInputManager::input_substring(v9, 0, *(_DWORD *)(a1 + 96), (uint64_t)v25);
  v10 = 0;
  v15[0] = a2;
  v15[1] = a2 + 24;
  v15[2] = a2 + 48;
  v15[3] = a2 + 72;
  do
  {
    v11 = v15[v10];
    v12 = *(uint64_t **)v11;
    v13 = *(uint64_t **)(v11 + 8);
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 1174405120;
    v16[2] = ___ZN14TIInputManager34apply_case_insensitive_constraintsERN2KB19CandidateCollectionENS0_10LookupTypeEP10__CFString_block_invoke;
    v16[3] = &__block_descriptor_tmp_18;
    v16[4] = a1;
    KB::String::String((KB::String *)v17, (const KB::String *)v29);
    KB::String::String((KB::String *)v19, (const KB::String *)v27);
    KB::String::String((KB::String *)v21, (const KB::String *)v25);
    v24 = a3;
    v23 = a4;
    v14 = std::remove_if[abi:nn180100]<std::__wrap_iter<KB::Candidate *>,BOOL({block_pointer})(KB::Candidate const&)>(v12, v13, (uint64_t)v16);
    std::vector<KB::Candidate>::erase(v11, v14, *(KB::Candidate **)(v11 + 8));
    if (v22 && v21[6] == 1)
      free(v22);
    if (v20 && v19[6] == 1)
      free(v20);
    if (v18 && v17[6] == 1)
      free(v18);
    ++v10;
  }
  while (v10 != 4);
  if (v26 && v25[6] == 1)
    free(v26);
  if (v28 && v27[6] == 1)
    free(v28);
  if (v30)
  {
    if (v29[6] == 1)
      free(v30);
  }
}

void TIInputManager::apply_case_changes(uint64_t a1, uint64_t a2, unsigned __int16 *a3, std::vector<unsigned int>::size_type a4, uint64_t a5, __CFString *a6)
{
  std::vector<unsigned int>::size_type v8;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  uint64_t v18;
  KB::Candidate *v19;
  const char *v20;
  const char *v21;
  const char *v22;
  const char *v23;
  const char *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t *v30;
  _QWORD v31[4];
  _WORD v32[3];
  char v33;
  void *v34;
  uint64_t v35;
  _WORD v36[3];
  char v37;
  void *v38;
  _QWORD v39[4];

  v8 = a4;
  v11 = 0;
  v39[2] = *MEMORY[0x1E0C80C00];
  v31[0] = a2;
  v31[1] = a2 + 24;
  v12 = (uint64_t *)(a1 + 224);
  v31[2] = a2 + 48;
  v31[3] = a2 + 72;
  v30 = (uint64_t *)(a1 + 224);
  v29 = a4;
  do
  {
    v28 = v11;
    v13 = (uint64_t *)v31[v11];
    v14 = *v13;
    if (v13[1] != *v13)
    {
      v15 = 0;
      v16 = 0;
      do
      {
        if (TIInputManager::apply_case_changes(a1, v14 + 1000 * v15, a3, v8, a5, *(unsigned __int8 *)(a1 + 683), v12, a6))
        {
          ++v16;
          v17 = (uint64_t *)v13[1];
        }
        else
        {
          v18 = a5;
          if (a6)
          {
            v19 = (KB::Candidate *)(*v13 + 1000 * v15);
            KB::Candidate::capitalized_string(v19, (uint64_t)v36);
            v20 = (const char *)v38;
            if (!v38)
              v20 = (const char *)v39;
            if (v36[0])
              v21 = v20;
            else
              v21 = "";
            KB::Candidate::token_ids_as_string(v19, (uint64_t)v32);
            v23 = (const char *)v34;
            if (!v34)
              v23 = (const char *)&v35;
            if (v32[0])
              v24 = v23;
            else
              v24 = "";
            KB::append_format(a6, (__CFString *)"[%s] {%s} removed by %s\n", v22, v21, v24, "apply_case_changes");
            if (v34 && v33 == 1)
              free(v34);
            if (v38 && v37 == 1)
              free(v38);
          }
          v25 = (uint64_t *)v13[1];
          v17 = (uint64_t *)(*v13 + 1000 * v15);
          v26 = v17 + 125;
          if (v17 + 125 != v25)
          {
            do
            {
              v27 = v17;
              v17 += 125;
            }
            while (KB::Candidate::operator=(v27, v17) + 250 != v25);
            v26 = (uint64_t *)v13[1];
          }
          a5 = v18;
          while (v26 != v17)
            KB::Candidate::~Candidate((KB::Candidate *)(v26 - 125));
          v13[1] = (uint64_t)v17;
          v8 = v29;
          v12 = v30;
        }
        v15 = v16;
        v14 = *v13;
      }
      while (0x1CAC083126E978D5 * (((uint64_t)v17 - *v13) >> 3) > (unint64_t)v16);
    }
    v11 = v28 + 1;
  }
  while (v28 != 3);
}

void TIInputManager::apply_apostrophe_changes(TIInputManager *this, KB::CandidateCollection *a2, const KB::String *a3, __CFString *a4)
{
  uint64_t v6;
  KB::Candidate **v7;
  KB::Candidate *v8;
  KB::Candidate *v9;
  char v10;
  KB::Word *v11;
  KB::Word *v12;
  _BYTE *v13;
  _BYTE *v14;
  uint64_t v15;
  _BYTE *v16;
  const char *v17;
  const char *v18;
  const char *v19;
  const char *v20;
  const char *v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  _QWORD v25[4];
  int v26;
  __int16 v27;
  char v28;
  void *v29;
  _BYTE v30[16];
  _WORD v31[3];
  char v32;
  void *v33;
  uint64_t v34;
  _WORD v35[3];
  char v36;
  char *v37;
  _QWORD v38[4];

  v38[2] = *MEMORY[0x1E0C80C00];
  if (KB::String::contains(a3, 0x2019u))
  {
    v6 = 0;
    v25[0] = a2;
    v25[1] = (char *)a2 + 24;
    v25[2] = (char *)a2 + 48;
    v25[3] = (char *)a2 + 72;
    do
    {
      v24 = v6;
      v7 = (KB::Candidate **)v25[v6];
      v8 = *v7;
      v9 = v7[1];
      while (v8 != v9)
      {
        if (*(_QWORD *)v8)
        {
          v10 = 0;
          v11 = (KB::Word *)*((_QWORD *)v8 + 1);
          v12 = (KB::Word *)((char *)v11 + 240 * *(_QWORD *)v8);
          do
          {
            while (1)
            {
              v13 = (_BYTE *)*((_QWORD *)v11 + 1);
              if (!v13)
                v13 = (char *)v11 + 16;
              v14 = (_BYTE *)*(unsigned __int16 *)v11;
              if (*(_WORD *)v11)
              {
                v15 = *(unsigned __int16 *)v11;
                v16 = v13;
                while (*v16 != 39)
                {
                  ++v16;
                  if (!--v15)
                  {
                    v16 = &v14[(_QWORD)v13];
                    break;
                  }
                }
              }
              else
              {
                v16 = v13;
              }
              if ((_BYTE *)(v16 - v13) == v14)
                break;
              KB::Word::capitalized_string(v11, (uint64_t)v31);
              v27 = 0;
              v28 = 0;
              v29 = "’";
              v26 = 1048579;
              v30[1] = 0;
              KB::String::replace_char((KB::String *)v31, (const KB::String *)&v26, 39, (uint64_t)v35);
              if (v29 && v28 == 1)
                free(v29);
              if (v33 && v32 == 1)
                free(v33);
              if (a4)
              {
                KB::Candidate::capitalized_string(v8, (uint64_t)v31);
                v17 = (const char *)v33;
                if (!v33)
                  v17 = (const char *)&v34;
                if (v31[0])
                  v18 = v17;
                else
                  v18 = "";
                KB::Word::capitalized_string(v11, (uint64_t)&v26);
                v20 = (const char *)v29;
                if (!v29)
                  v20 = v30;
                if ((_WORD)v26)
                  v21 = v20;
                else
                  v21 = "";
                v22 = v37;
                if (!v37)
                  v22 = (const char *)v38;
                if (v35[0])
                  v23 = v22;
                else
                  v23 = "";
                KB::append_format(a4, (__CFString *)"[%s] converted [%s] to [%s] by %s\n", v19, v18, v21, v23, "apply_apostrophe_changes");
                if (v29 && v28 == 1)
                  free(v29);
                if (v33 && v32 == 1)
                  free(v33);
              }
              KB::String::operator=(v11, (KB::String *)v35);
              if (v37)
              {
                if (v36 == 1)
                  free(v37);
              }
              v11 = (KB::Word *)((char *)v11 + 240);
              v10 = 1;
              if (v11 == v12)
                goto LABEL_52;
            }
            v11 = (KB::Word *)((char *)v11 + 240);
          }
          while (v11 != v12);
          if ((v10 & 1) == 0)
            goto LABEL_53;
LABEL_52:
          KB::Candidate::compute_string(v8);
        }
LABEL_53:
        v8 = (KB::Candidate *)((char *)v8 + 1000);
      }
      v6 = v24 + 1;
    }
    while (v24 != 3);
  }
}

void TIInputManager::apply_shortcut_conversions(TIInputManager *this, KB::CandidateCollection *a2, const KB::String *a3, __CFString *a4)
{
  uint64_t v6;
  KB::Candidate **v7;
  KB::Candidate *v8;
  KB::Candidate *v9;
  const KB::String *v10;
  uint64_t v11;
  const char *v12;
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  uint64_t v19;
  KB::Candidate *v20;
  _QWORD v21[4];
  __int16 v22[3];
  char v23;
  void *v24;
  uint64_t v25;
  __int16 v26[3];
  char v27;
  void *v28;
  uint64_t v29;
  __int16 v30[3];
  char v31;
  void *v32;
  uint64_t v33;
  _WORD v34[120];
  uint64_t v35;

  v6 = 0;
  v35 = *MEMORY[0x1E0C80C00];
  v21[0] = a2;
  v21[1] = (char *)a2 + 24;
  v21[2] = (char *)a2 + 48;
  v21[3] = (char *)a2 + 72;
  do
  {
    v7 = (KB::Candidate **)v21[v6];
    v9 = *v7;
    v8 = v7[1];
    v19 = v6;
    v20 = v8;
    while (v9 != v8)
    {
      if (*(_QWORD *)v9)
      {
        v10 = (const KB::String *)*((_QWORD *)v9 + 1);
        v11 = 240 * *(_QWORD *)v9;
        do
        {
          if ((*((_BYTE *)v10 + 106) & 1) != 0)
          {
            TIInputManager::conversion_for_shortcut(this, v10, (KB::Word *)v34);
            if (v34[0])
            {
              if (a4)
              {
                KB::Candidate::capitalized_string(v9, (uint64_t)v30);
                v12 = (const char *)v32;
                if (!v32)
                  v12 = (const char *)&v33;
                if (v30[0])
                  v13 = v12;
                else
                  v13 = "";
                KB::Word::capitalized_string(v10, (uint64_t)v26);
                v14 = (const char *)v28;
                if (!v28)
                  v14 = (const char *)&v29;
                if (v26[0])
                  v15 = v14;
                else
                  v15 = "";
                KB::Word::capitalized_string((KB::Word *)v34, (uint64_t)v22);
                v17 = (const char *)v24;
                if (!v24)
                  v17 = (const char *)&v25;
                if (v22[0])
                  v18 = v17;
                else
                  v18 = "";
                KB::append_format(a4, (__CFString *)"[%s] converted [%s] to [%s] by %s\n", v16, v13, v15, v18, "apply_shortcut_conversions");
                if (v24 && v23 == 1)
                  free(v24);
                if (v28 && v27 == 1)
                  free(v28);
                if (v32)
                {
                  if (v31 == 1)
                    free(v32);
                }
              }
              KB::String::operator=(v10, (KB::String *)v34);
              KB::Candidate::compute_string(v9);
            }
            KB::Word::~Word((KB::Word *)v34);
          }
          v10 = (const KB::String *)((char *)v10 + 240);
          v11 -= 240;
        }
        while (v11);
      }
      v9 = (KB::Candidate *)((char *)v9 + 1000);
      v8 = v20;
    }
    v6 = v19 + 1;
  }
  while (v19 != 3);
}

void TIInputManager::remove_text_replacement_from_top(TIInputManager *this, const KB::Candidate **a2)
{
  const KB::Candidate *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if ((unint64_t)(0x1CAC083126E978D5 * ((a2[1] - v3) >> 3)) >= 2)
  {
    KB::Candidate::Candidate((KB::Candidate *)&v7, v3);
    if (v7)
    {
      v5 = 240 * v7;
      v6 = v8;
      while ((*(_BYTE *)(v6 + 106) & 1) == 0)
      {
        v6 += 240;
        v5 -= 240;
        if (!v5)
          goto LABEL_10;
      }
    }
    else
    {
      v6 = v8;
    }
    if (v6 != v8 + 240 * v7)
    {
      KB::Candidate::operator=((uint64_t)*a2, (uint64_t)*a2 + 1000);
      KB::Candidate::operator=((uint64_t)*a2 + 1000, (uint64_t)&v7);
    }
LABEL_10:
    KB::Candidate::~Candidate((KB::Candidate *)&v7);
  }
}

void TIInputManager::conversion_for_shortcut(TIInputManager *this@<X0>, const KB::String *a2@<X1>, KB::Word *a3@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  const KB::String *v7;
  const KB::String *v8;
  uint64_t v9;
  const KB::String **v10;
  void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = *(uint64_t **)(*(_QWORD *)(*((_QWORD *)this + 28) + 24) + 24);
  if (v4 && (v5 = *v4) != 0 && *(unsigned __int16 *)a2 < 0x41u)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    KB::UserDictionary::conversions_for_shortcut(v5, a2, (uint64_t)&v7);
    if (v8 == v7)
    {
      *((_OWORD *)a3 + 13) = 0u;
      *((_OWORD *)a3 + 14) = 0u;
      *((_OWORD *)a3 + 11) = 0u;
      *((_OWORD *)a3 + 12) = 0u;
      *((_OWORD *)a3 + 9) = 0u;
      *((_OWORD *)a3 + 10) = 0u;
      *((_OWORD *)a3 + 7) = 0u;
      *((_OWORD *)a3 + 8) = 0u;
      *((_OWORD *)a3 + 5) = 0u;
      *((_OWORD *)a3 + 6) = 0u;
      *((_OWORD *)a3 + 3) = 0u;
      *((_OWORD *)a3 + 4) = 0u;
      *((_OWORD *)a3 + 1) = 0u;
      *((_OWORD *)a3 + 2) = 0u;
      *(_OWORD *)a3 = 0u;
      KB::Word::Word(a3);
    }
    else
    {
      KB::match_shortcut_conversion_case_with_input(a2, v7, (KB::String *)&v10);
      KB::Word::Word(a3, (const KB::String *)&v10, &kTITokenIDUNK, 0);
      if (v11)
      {
        if (BYTE6(v10) == 1)
          free(v11);
      }
    }
    v10 = &v7;
    std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v10);
  }
  else
  {
    *((_OWORD *)a3 + 13) = 0u;
    *((_OWORD *)a3 + 14) = 0u;
    *((_OWORD *)a3 + 11) = 0u;
    *((_OWORD *)a3 + 12) = 0u;
    *((_OWORD *)a3 + 9) = 0u;
    *((_OWORD *)a3 + 10) = 0u;
    *((_OWORD *)a3 + 7) = 0u;
    *((_OWORD *)a3 + 8) = 0u;
    *((_OWORD *)a3 + 5) = 0u;
    *((_OWORD *)a3 + 6) = 0u;
    *((_OWORD *)a3 + 3) = 0u;
    *((_OWORD *)a3 + 4) = 0u;
    *((_OWORD *)a3 + 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *(_OWORD *)a3 = 0u;
    KB::Word::Word(a3);
  }
}

uint64_t TIInputManager::apply_case_changes(uint64_t a1, uint64_t a2, unsigned __int16 *a3, std::vector<unsigned int>::size_type a4, int a5, unsigned int a6, uint64_t *a7, __CFString *a8)
{
  std::vector<unsigned int>::pointer begin;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  void *v21;
  uint64_t v22;
  int v23;
  unint64_t v24;
  unsigned __int16 *v25;
  unsigned int v26;
  int v27;
  unint64_t v28;
  unsigned int *v29;
  unsigned int *v30;
  unint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  unsigned int v40;
  KB *v41;
  const KB::String *v42;
  uint64_t v43;
  const KB::String *v44;
  BOOL v45;
  uint64_t v46;
  _DWORD *v47;
  char *v48;
  uint64_t v49;
  unsigned int v50;
  char *v51;
  uint64_t v52;
  unsigned int v53;
  unsigned int v54;
  _QWORD *v55;
  int v56;
  char *v57;
  int64_t v58;
  char *v59;
  uint64_t v60;
  const KB::String *v61;
  _BOOL4 has_lowercase_characters;
  const KB::String *v63;
  unsigned int v64;
  const KB::String *v65;
  int64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  unint64_t v71;
  unint64_t v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  BOOL v77;
  int v78;
  const KB::String *v79;
  unsigned int v80;
  const KB::String *v81;
  int v83;
  unsigned int *v84;
  size_t v85;
  unsigned int *v86;
  uint64_t v87;
  void (*v88)(void);
  uint64_t v89;
  unsigned int v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int64x2_t v97;
  uint64x2_t v98;
  int64x2_t v99;
  int32x2_t v100;
  int8x8_t v101;
  int8x8_t v102;
  unint64_t v103;
  int8x8_t v104;
  __int32 v105;
  uint64_t v106;
  unsigned int v107;
  void *v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int64x2_t v112;
  uint64x2_t v113;
  int64x2_t v114;
  int32x2_t v115;
  int8x8_t v116;
  int8x8_t v117;
  unint64_t v118;
  int8x8_t v119;
  __int32 v120;
  uint64_t v121;
  KB::Word *v122;
  int v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  _BYTE *v130;
  int v131;
  int v132;
  int v133;
  _BYTE *v134;
  uint64_t v135;
  int v136;
  const char *v137;
  const char *v138;
  const char *v139;
  const char *v140;
  const char *v141;
  int v142;
  unsigned int *v143;
  unsigned int v144;
  uint64_t v145;
  const char *v147;
  const char *v148;
  const char *v149;
  const char *v150;
  const char *v151;
  const char *v152;
  const char *v153;
  const char *v154;
  const char *v155;
  const char *v156;
  const char *v157;
  const char *v158;
  const char *v159;
  const char *v160;
  const char *v161;
  uint64_t v162;
  uint64_t v163;
  int v166;
  int v167;
  int64x2_t v168;
  unsigned int *__src;
  int v170;
  unsigned int v171;
  uint64_t v173;
  unsigned int *v174;
  uint64_t v175;
  _QWORD v176[2];
  BOOL (*v177)(uint64_t, KB::String *);
  void *v178;
  uint64_t v179;
  ByteString v180;
  char *v181;
  void *__p[2];
  char *v183;
  void *v184;
  _BYTE *v185;
  void *v186;
  char *v187;
  char *v188;
  std::vector<unsigned int> v189;
  _BYTE v190[24];
  __int128 v191;
  _QWORD v192[2];
  unsigned __int16 v193[2];
  unsigned __int16 v194;
  char v195;
  void *v196;
  _BYTE v197[16];
  unsigned __int16 v198[2];
  unsigned __int16 v199;
  char v200;
  _QWORD *v201;
  _QWORD v202[4];

  v202[2] = *MEMORY[0x1E0C80C00];
  TIInputManager::input_substring(a3, 0, a4, (uint64_t)v198);
  TIInputManager::input_flags_subvector(a4, a3, 0, &v189);
  begin = v189.__begin_;
  v187 = 0;
  v188 = 0;
  v14 = a4;
  v186 = 0;
  if ((_DWORD)a4)
  {
    v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(a4);
    v186 = v15;
    v188 = &v15[4 * v16];
    memmove(v15, begin, 4 * a4);
    v187 = &v15[4 * a4];
    if (4 * a4)
    {
      v17 = 0;
      v18 = *(_DWORD *)(a2 + 780);
      do
      {
        v19 = *(_DWORD *)&v15[4 * v17];
        if (v19)
        {
          if (*(_DWORD *)&v15[4 * v17] & 0x10 | v18 & 1)
            *(_DWORD *)&v15[4 * v17] = v19 & 0xFFFFFFFE;
          v18 >>= 1;
        }
        ++v17;
      }
      while (a4 > (unint64_t)v17);
    }
  }
  else
  {
    v15 = 0;
  }
  v20 = v199;
  if (!v199)
  {
    KB::String::compute_length(v198);
    v20 = v199;
  }
  v175 = a1;
  v167 = a5;
  if (v20 <= a4)
    goto LABEL_28;
  if (v20 || (KB::String::compute_length(v198), (v20 = v199) != 0))
  {
    v21 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v20);
    bzero(v21, 4 * v20);
    v173 = (uint64_t)v21 + 4 * v20;
    if ((_DWORD)a4)
      goto LABEL_17;
  }
  else
  {
    v21 = 0;
    v173 = 0;
    if ((_DWORD)a4)
    {
LABEL_17:
      v22 = 0;
      v23 = 0;
      do
      {
        v24 = 0;
        v25 = (unsigned __int16 *)(*(_QWORD *)a3 + 40 * v22);
        v26 = v25[2];
        v27 = v23;
        if (v25[2])
          goto LABEL_22;
LABEL_21:
        KB::String::compute_length(v25);
        v26 = v25[2];
LABEL_22:
        while (v24 < v26)
        {
          *((_DWORD *)v21 + (v27 + v24++)) = *(_DWORD *)&v15[4 * v22];
          if (!v26)
            goto LABEL_21;
        }
        if (!v26)
        {
          KB::String::compute_length(v25);
          v26 = v25[2];
        }
        v23 = v27 + v26;
        ++v22;
      }
      while (v22 != v14);
    }
  }
  std::vector<unsigned int>::__assign_with_size[abi:nn180100]<unsigned int *,unsigned int *>((char *)&v186, (char *)v21, v173, (v173 - (uint64_t)v21) >> 2);
  if (v21)
    operator delete(v21);
LABEL_28:
  KB::word_ranges((KB *)v198, 0, (unint64_t **)&v184);
  v28 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    do
    {
      if ((*(_BYTE *)(*(_QWORD *)(a2 + 8) + 240 * v32 + 135) & 4) == 0)
      {
        if ((unint64_t)v30 >= v31)
        {
          v35 = v30 - v29;
          v36 = v35 + 1;
          if ((unint64_t)(v35 + 1) >> 62)
LABEL_318:
            abort();
          if ((uint64_t)(v31 - (_QWORD)v29) >> 1 > v36)
            v36 = (uint64_t)(v31 - (_QWORD)v29) >> 1;
          if (v31 - (unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL)
            v37 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v37 = v36;
          if (v37)
            v37 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v37);
          else
            v38 = 0;
          v39 = (unsigned int *)(v37 + 4 * v35);
          *v39 = v33;
          v34 = v39 + 1;
          while (v30 != v29)
          {
            v40 = *--v30;
            *--v39 = v40;
          }
          v31 = v37 + 4 * v38;
          if (v29)
            operator delete(v29);
          v29 = v39;
        }
        else
        {
          *v30 = v33;
          v34 = v30 + 1;
        }
        v28 = *(_QWORD *)a2;
        v30 = v34;
      }
      v32 = ++v33;
    }
    while (v28 > v33);
    if ((a6 & 1) == 0 && v28)
    {
      v41 = *(KB **)(a2 + 8);
      v42 = (const KB::String *)(a1 + 120);
      v43 = 240 * v28;
      do
      {
        if (*(_WORD *)(v175 + 104))
        {
          if (*(_QWORD *)(v175 + 112))
            v44 = *(const KB::String **)(v175 + 112);
          else
            v44 = v42;
        }
        else
        {
          v44 = (const KB::String *)"";
        }
        KB::string_to_lowercase(v41, v44, (KB::String *)v193);
        KB::String::operator=(v41, (KB::String *)v193);
        if (v196)
          v45 = v195 == 1;
        else
          v45 = 0;
        if (v45)
          free(v196);
        v41 = (KB *)((char *)v41 + 240);
        v43 -= 240;
      }
      while (v43);
      if (*(_QWORD *)a2)
      {
        v46 = 240 * *(_QWORD *)a2;
        v47 = (_DWORD *)(*(_QWORD *)(a2 + 8) + 104);
        do
        {
          v47[4] = 0;
          *v47 &= ~1u;
          v47 += 60;
          v46 -= 240;
        }
        while (v46);
      }
    }
  }
  else
  {
    v29 = 0;
    v30 = 0;
  }
  v48 = (char *)v184;
  if (v185 == v184)
    goto LABEL_253;
  v49 = 0;
  v50 = 0;
  v162 = (v185 - (_BYTE *)v184) >> 3;
  v163 = v30 - v29;
  __src = v29 + 1;
  v168 = vdupq_n_s64(2uLL);
  while (2)
  {
    v174 = v30;
    v51 = &v48[8 * v49];
    v52 = *(unsigned int *)v51;
    v53 = *((_DWORD *)v51 + 1);
    v54 = v53 + v52;
    if (v201)
      v55 = v201;
    else
      v55 = v202;
    *(_QWORD *)v190 = v55;
    v56 = v198[0];
    *(_DWORD *)&v190[8] = 0;
    *(_QWORD *)&v190[12] = v198[0];
    KB::String::iterator::initialize((uint64_t *)v190);
    v191 = *(_OWORD *)v190;
    v192[0] = *(_QWORD *)&v190[16];
    std::__advance[abi:nn180100]<KB::String::iterator>((KB::String::iterator *)&v191, (int)v52);
    *(_QWORD *)&v180.var0.var0.var0 = v55;
    *(_DWORD *)&v180.var0.var1.var1[6] = 0;
    *(_DWORD *)&v180.var0.var1.var1[10] = v56;
    LODWORD(v181) = 0;
    KB::String::iterator::initialize((uint64_t *)&v180);
    *(ByteString *)__p = v180;
    v183 = v181;
    std::__advance[abi:nn180100]<KB::String::iterator>((KB::String::iterator *)__p, (int)v54);
    KB::String::String((KB::String *)v193, (const KB::String::iterator *)&v191, (const KB::String::iterator *)__p);
    __p[1] = 0;
    v183 = 0;
    __p[0] = 0;
    if (!v53)
      goto LABEL_126;
    v171 = v50;
    v57 = (char *)v186 + 4 * v52;
    v58 = (_BYTE *)v186 + 4 * v54 - v57;
    if (v58 < 0)
      goto LABEL_318;
    v59 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v58 >> 2);
    __p[0] = v59;
    __p[1] = v59;
    v183 = &v59[4 * v60];
    memmove(v59, v57, v58);
    __p[1] = &v59[4 * (v58 >> 2)];
    if (__p[0] == __p[1])
    {
LABEL_126:
      v30 = v29;
      if (v29 != v174)
      {
        v84 = v29 + 1;
        v85 = (char *)v174 - (char *)__src;
        if (v174 == __src)
          goto LABEL_130;
        goto LABEL_128;
      }
      goto LABEL_131;
    }
    has_lowercase_characters = KB::string_has_lowercase_characters((KB *)v193, v61);
    v64 = KB::count_uppercase_letters((KB *)v193, v63);
    v66 = (char *)__p[1] - (char *)__p[0];
    if (__p[1] == __p[0])
    {
      v68 = 0;
    }
    else
    {
      v67 = 0;
      v68 = 0;
      do
      {
        v68 |= ((_DWORD)v67 != 0) & *((_DWORD *)__p[0] + v67);
        ++v67;
      }
      while (v66 >> 2 > (unint64_t)v67);
    }
    v69 = has_lowercase_characters & (v68 | (v64 > 1));
    if ((v69 & 1) == 0)
    {
      if (has_lowercase_characters)
      {
        v70 = 4;
        v170 = 1;
        if (v64 > 1 || (((unint64_t)v66 > 4) & v68) != 0)
          goto LABEL_85;
        v83 = *(_DWORD *)__p[0];
      }
      else
      {
        v83 = *(_DWORD *)__p[0];
        if (((v167 == 4) & ((*(_DWORD *)__p[0] & 2u) >> 1)) != 0)
          v70 = 2;
        else
          v70 = 4;
        if (((v167 == 4) & ((*(_DWORD *)__p[0] & 2u) >> 1)) != 0 || v64 > 1)
          goto LABEL_125;
        if ((((unint64_t)v66 > 4) & v68) != 0)
          goto LABEL_148;
      }
      if ((v83 & 1) == 0)
      {
        v70 = 0;
        goto LABEL_124;
      }
      v70 = 3;
      if (v167 != 5 || v66 != 4)
      {
LABEL_124:
        if ((v83 & 2) != 0)
        {
LABEL_142:
          if (v29 != v174)
          {
            if ((*(_BYTE *)(*(_QWORD *)(a2 + 8) + 240 * *v29 + 104) & 0x20) == 0)
            {
              v89 = *(_QWORD *)(v175 + 544);
              if (v89)
                (*(void (**)(uint64_t))(*(_QWORD *)v89 + 72))(v89);
              else
                KB::Word::capitalize_first_letter((KB::Word *)(*(_QWORD *)(a2 + 8) + 240 * *v29), 0);
            }
            v85 = (char *)v174 - (char *)__src;
            if (v174 != __src)
            {
              v86 = v29;
              v84 = v29 + 1;
              goto LABEL_129;
            }
            goto LABEL_130;
          }
          if (!a8)
            goto LABEL_285;
          v152 = (const char *)v201;
          if (!v201)
            v152 = (const char *)v202;
          if (v198[0])
            v153 = v152;
          else
            v153 = "";
          KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)&v191);
          v155 = (const char *)*((_QWORD *)&v191 + 1);
          if (!*((_QWORD *)&v191 + 1))
            v155 = (const char *)v192;
          if ((_WORD)v191)
            v156 = v155;
          else
            v156 = "";
          KB::append_format(a8, (__CFString *)"input [%s] was considered to have capitalization type WordCapitalizationTypeAutoshift and candidate [%s] was not accepted; will be filtered out\n",
            v154,
            v153,
            v156);
LABEL_282:
          if (*((_QWORD *)&v191 + 1) && BYTE6(v191) == 1)
            free(*((void **)&v191 + 1));
          goto LABEL_285;
        }
LABEL_125:
        v170 = 1;
        switch(v70)
        {
          case 0:
            goto LABEL_126;
          case 1:
            goto LABEL_142;
          case 2:
            if (v29 != v174)
            {
              v90 = *v29;
              v91 = *(_QWORD *)(a2 + 8);
              v92 = v91 + 240 * *v29;
              v93 = *(unsigned __int16 *)(v92 + 4);
              if (!*(_WORD *)(v92 + 4))
              {
                KB::String::compute_length((unsigned __int16 *)(v91 + 240 * v90));
                v93 = *(unsigned __int16 *)(v92 + 4);
              }
              v190[0] = 1;
              std::vector<BOOL>::vector(&v191, v93, v190);
              if (*((_QWORD *)&v191 + 1) >= 0x20uLL)
                v94 = 32;
              else
                v94 = *((_QWORD *)&v191 + 1);
              if (v94)
              {
                v95 = 0;
                v96 = ((_BYTE)v94 + 1) & 0x7E;
                v97 = 0uLL;
                v98 = (uint64x2_t)vdupq_n_s64(v94 - 1);
                v99 = (int64x2_t)xmmword_1DA910FD0;
                v100 = (int32x2_t)0x100000000;
                do
                {
                  v101 = *(int8x8_t *)v97.i8;
                  v102 = (int8x8_t)vmovn_s64((int64x2_t)vcgeq_u64(v98, (uint64x2_t)v99));
                  v103 = v95 >> 6;
                  if ((v102.i8[0] & 1) != 0)
                    v97.i64[0] = *(_QWORD *)(v191 + 8 * v103);
                  if ((v102.i8[4] & 1) != 0)
                    v97.i64[1] = *(_QWORD *)(v191 + 8 * v103);
                  v97 = vceqzq_s64((int64x2_t)vandq_s8((int8x16_t)v97, (int8x16_t)vshlq_u64((uint64x2_t)vdupq_n_s64(1uLL), (uint64x2_t)v99)));
                  *(int8x8_t *)v97.i8 = vorr_s8(vbic_s8((int8x8_t)vshl_u32((uint32x2_t)0x100000001, (uint32x2_t)v100), (int8x8_t)vmovn_s64(v97)), v101);
                  v95 += 2;
                  v99 = vaddq_s64(v99, vdupq_n_s64(2uLL));
                  v100 = vadd_s32(v100, (int32x2_t)0x200000002);
                }
                while (v96 != v95);
                v104 = vbsl_s8(v102, *(int8x8_t *)v97.i8, v101);
                v105 = v104.i32[0] | v104.i32[1];
              }
              else
              {
                v105 = 0;
              }
              v128 = v91 + 240 * v90;
              *(_DWORD *)(v128 + 120) = v105;
              *(_DWORD *)(v128 + 104) = *(_DWORD *)(v128 + 104) & 0xFFFFFFFE | (v105 == 1);
              v85 = (char *)v174 - (char *)__src;
              if (v174 != __src)
                memmove(v29, __src, (char *)v174 - (char *)__src);
              if ((_QWORD)v191)
                operator delete((void *)v191);
LABEL_130:
              v30 = (unsigned int *)((char *)v29 + v85);
              goto LABEL_131;
            }
            if (!a8)
              goto LABEL_285;
            v157 = (const char *)v201;
            if (!v201)
              v157 = (const char *)v202;
            if (v198[0])
              v158 = v157;
            else
              v158 = "";
            KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)&v191);
            v160 = (const char *)*((_QWORD *)&v191 + 1);
            if (!*((_QWORD *)&v191 + 1))
              v160 = (const char *)v192;
            if ((_WORD)v191)
              v161 = v160;
            else
              v161 = "";
            KB::append_format(a8, (__CFString *)"input [%s] was considered to have capitalization type WordCapitalizationTypeAutoshiftAllCharacters and candidate [%s] was not accepted; will be filtered out\n",
              v159,
              v158,
              v161);
            break;
          case 3:
            v106 = *(_QWORD *)(v175 + 544);
            if (v106 && !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v106 + 40))(v106) || v163 != v162)
            {
              v30 = v174;
              goto LABEL_234;
            }
            v30 = v174;
            if (v163 - v49 != v174 - v29)
              goto LABEL_234;
            v124 = *(_QWORD *)(a2 + 8);
            v125 = v124 + 240 * *v29;
            if ((*(_BYTE *)(v125 + 104) & 1) != 0)
              goto LABEL_213;
            if (!*a7)
              goto LABEL_209;
            KB::DictionaryContainer::lookup(*a7, (const KB::String *)(v124 + 240 * *v29), 1, 1, (uint64_t *)&v191);
            v127 = *((_QWORD *)&v191 + 1);
            v126 = v191;
            v176[0] = MEMORY[0x1E0C809B0];
            v176[1] = 0x40000000;
            v177 = ___ZNK14TIInputManager18apply_case_changesERN2KB9CandidateERKNSt3__16vectorINS0_5InputENS3_9allocatorIS5_EEEEj14TIShiftContextbRKN3WTF6RefPtrINS0_19DictionaryContainerEEEP10__CFString_block_invoke;
            v178 = &__block_descriptor_tmp_10;
            v179 = v125;
            while (2)
            {
              if (v126 == v127)
              {
                *(_QWORD *)v190 = &v191;
                std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v190);
LABEL_209:
                v130 = v196;
                if (!v196)
                  v130 = v197;
                *(_QWORD *)v190 = v130;
                *(_DWORD *)&v190[8] = 0;
                *(_QWORD *)&v190[12] = v193[0];
                KB::String::iterator::initialize((uint64_t *)v190);
                KB::String::String((uint64_t)&v191, *(unsigned int *)&v190[16]);
                KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*(_QWORD *)(v175 + 224) + 8) + 72), (_LXLexicon *)v125, v190);
                KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*(_QWORD *)(v175 + 224) + 8) + 72), (_LXLexicon *)&v191, &v180);
              }
              else
              {
                if ((((uint64_t (*)(_QWORD *, uint64_t))v177)(v176, v126) & 1) == 0)
                {
                  v126 += 240;
                  continue;
                }
                *(_QWORD *)v190 = &v191;
                std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v190);
LABEL_213:
                v131 = *(unsigned __int16 *)(v125 + 4);
                if (!*(_WORD *)(v125 + 4))
                {
                  KB::String::compute_length((unsigned __int16 *)v125);
                  v131 = *(unsigned __int16 *)(v125 + 4);
                }
                v132 = v194;
                if (!v194)
                {
                  KB::String::compute_length(v193);
                  v132 = v194;
                }
                v133 = v132 - 1;
                v134 = v196;
                if (!v196)
                  v134 = v197;
                *(_QWORD *)v190 = v134;
                *(_DWORD *)&v190[8] = 0;
                *(_QWORD *)&v190[12] = v193[0];
                KB::String::iterator::initialize((uint64_t *)v190);
                KB::String::String((uint64_t)&v191, *(unsigned int *)&v190[16]);
                KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*(_QWORD *)(v175 + 224) + 8) + 72), (_LXLexicon *)v125, v190);
                KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*(_QWORD *)(v175 + 224) + 8) + 72), (_LXLexicon *)&v191, &v180);
                if (v133 <= v131 && KB::ByteString::starts_with((KB::ByteString *)v190, &v180))
                {
                  v135 = *(_QWORD *)(v175 + 544);
                  if (v135)
                    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v135 + 72))(v135, v125, 1);
                  else
                    KB::Word::capitalize_first_letter((KB::Word *)v125, 1);
                  v50 = v171;
                  if (v174 != __src)
                    memmove(v29, __src, (char *)v174 - (char *)__src);
                  v136 = 0;
                  v30 = v174 - 1;
LABEL_224:
                  if (v180.var0.var0.var0 >= 0xFu && v180.var0.var0.var1)
                    MEMORY[0x1DF0A212C](v180.var0.var0.var1, 0x1000C8077774924);
                  if (*(unsigned __int16 *)v190 >= 0xFu && *(_QWORD *)&v190[8])
                    MEMORY[0x1DF0A212C](*(_QWORD *)&v190[8], 0x1000C8077774924);
                  if (*((_QWORD *)&v191 + 1) && BYTE6(v191) == 1)
                    free(*((void **)&v191 + 1));
                  if (!v136)
                    goto LABEL_131;
LABEL_234:
                  if (a8)
                  {
                    v137 = (const char *)v201;
                    if (!v201)
                      v137 = (const char *)v202;
                    if (v198[0])
                      v138 = v137;
                    else
                      v138 = "";
                    KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)&v191);
                    v140 = (const char *)*((_QWORD *)&v191 + 1);
                    if (!*((_QWORD *)&v191 + 1))
                      v140 = (const char *)v192;
                    if ((_WORD)v191)
                      v141 = v140;
                    else
                      v141 = "";
                    KB::append_format(a8, (__CFString *)"input [%s] was considered to have capitalization type WordCapitalizationTypeExplicitShift and candidate [%s] was not accepted; falling through to WordCapitalizationType"
                                    "AllCaps/WordCapitalizationTypeMixedCase\n",
                      v139,
                      v138,
                      v141);
                    if (*((_QWORD *)&v191 + 1) && BYTE6(v191) == 1)
                      free(*((void **)&v191 + 1));
                  }
                  v170 = 0;
                  v70 = 3;
                  v174 = v30;
                  goto LABEL_85;
                }
              }
              break;
            }
            v136 = 1;
            v50 = v171;
            goto LABEL_224;
          case 4:
            goto LABEL_85;
          default:
            v30 = v174;
            goto LABEL_131;
        }
        goto LABEL_282;
      }
LABEL_148:
      v70 = 4;
      v170 = 1;
      goto LABEL_85;
    }
    v170 = 0;
    v70 = 5;
LABEL_85:
    v71 = v174 - v29;
    if (v174 == v29)
    {
      v72 = 0;
      goto LABEL_111;
    }
    v166 = v70;
    v72 = 0;
    v73 = 1;
    while (1)
    {
      v74 = v29[v72];
      v75 = *(_QWORD *)(a2 + 8);
      v76 = v75 + 240 * v74;
      if (!v69)
        break;
      if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, void **, _QWORD))(*(_QWORD *)v175 + 40))(v175, a2, v75 + 240 * v74, v193, __p, a6) & 1) != 0)
      {
        if ((*(_BYTE *)__p[0] & 1) == 0 || (*(_BYTE *)(v75 + 240 * v74 + 104) & 0x20) != 0)
          goto LABEL_111;
        v87 = *(_QWORD *)(v175 + 544);
        if (v87)
        {
          v88 = *(void (**)(void))(*(_QWORD *)v87 + 72);
LABEL_205:
          v88();
          goto LABEL_111;
        }
        v122 = (KB::Word *)(v75 + 240 * v74);
        v123 = 0;
        goto LABEL_207;
      }
LABEL_104:
      v72 = v73;
      if (v71 <= v73++)
        goto LABEL_111;
    }
    if (*(_QWORD *)a2 - 1 == v74)
    {
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*(_QWORD *)(v175 + 224) + 8) + 72), (_LXLexicon *)(v75 + 240 * v74), &v191);
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*(_QWORD *)(v175 + 224) + 8) + 72), (_LXLexicon *)v193, v190);
      v77 = KB::ByteString::starts_with((KB::ByteString *)&v191, (const ByteString *)v190);
      if (*(unsigned __int16 *)v190 >= 0xFu && *(_QWORD *)&v190[8])
        MEMORY[0x1DF0A212C](*(_QWORD *)&v190[8], 0x1000C8077774924);
      if ((unsigned __int16)v191 >= 0xFu && *((_QWORD *)&v191 + 1))
        MEMORY[0x1DF0A212C](*((_QWORD *)&v191 + 1), 0x1000C8077774924);
      if (!v77)
        goto LABEL_104;
    }
    else if (KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(*(_QWORD *)(*(_QWORD *)(v175 + 224) + 8) + 72), (_LXLexicon *)(v75 + 240 * v74), (const KB::String *)v193, v65))
    {
      goto LABEL_104;
    }
    *((_QWORD *)&v191 + 1) = 1;
    *(_QWORD *)&v191 = &off_1EA103EF8;
    v78 = KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)&v191, (const KB::String *)(v75 + 240 * v74), (const KB::String *)v193, 0, 0);
    if ((v170 & v78) == 1)
    {
      v80 = KB::count_word_medial_punctuation((KB *)(v75 + 240 * v74), v79);
      if (v80 <= KB::count_word_medial_punctuation((KB *)v193, v81))
        goto LABEL_169;
      goto LABEL_104;
    }
    if ((v78 & 1) == 0)
      goto LABEL_104;
    if (v166 == 3)
    {
      v129 = *(_QWORD *)(v175 + 544);
      if (v129)
      {
        v88 = *(void (**)(void))(*(_QWORD *)v129 + 72);
        goto LABEL_205;
      }
      v122 = (KB::Word *)(v75 + 240 * v74);
      v123 = 1;
LABEL_207:
      KB::Word::capitalize_first_letter(v122, v123);
      goto LABEL_111;
    }
    if (v166 != 4)
      goto LABEL_111;
LABEL_169:
    v107 = *(unsigned __int16 *)(v76 + 4);
    if (!*(_WORD *)(v76 + 4))
    {
      KB::String::compute_length((unsigned __int16 *)(v75 + 240 * v74));
      v107 = *(unsigned __int16 *)(v76 + 4);
    }
    v190[0] = 1;
    std::vector<BOOL>::vector(&v191, v107, v190);
    v108 = (void *)v191;
    if (*((_QWORD *)&v191 + 1) >= 0x20uLL)
      v109 = 32;
    else
      v109 = *((_QWORD *)&v191 + 1);
    if (v109)
    {
      v110 = 0;
      v111 = ((_BYTE)v109 + 1) & 0x7E;
      v112 = 0uLL;
      v113 = (uint64x2_t)vdupq_n_s64(v109 - 1);
      v114 = (int64x2_t)xmmword_1DA910FD0;
      v115 = (int32x2_t)0x100000000;
      do
      {
        v116 = *(int8x8_t *)v112.i8;
        v117 = (int8x8_t)vmovn_s64((int64x2_t)vcgeq_u64(v113, (uint64x2_t)v114));
        v118 = v110 >> 6;
        if ((v117.i8[0] & 1) != 0)
          v112.i64[0] = *(_QWORD *)(v191 + 8 * v118);
        if ((v117.i8[4] & 1) != 0)
          v112.i64[1] = *(_QWORD *)(v191 + 8 * v118);
        v112 = vceqzq_s64((int64x2_t)vandq_s8((int8x16_t)v112, (int8x16_t)vshlq_u64((uint64x2_t)vdupq_n_s64(1uLL), (uint64x2_t)v114)));
        *(int8x8_t *)v112.i8 = vorr_s8(vbic_s8((int8x8_t)vshl_u32((uint32x2_t)0x100000001, (uint32x2_t)v115), (int8x8_t)vmovn_s64(v112)), v116);
        v110 += 2;
        v114 = vaddq_s64(v114, v168);
        v115 = vadd_s32(v115, (int32x2_t)0x200000002);
      }
      while (v111 != v110);
      v119 = vbsl_s8(v117, *(int8x8_t *)v112.i8, v116);
      v120 = v119.i32[0] | v119.i32[1];
    }
    else
    {
      v120 = 0;
    }
    v121 = v75 + 240 * v74;
    *(_DWORD *)(v121 + 120) = v120;
    *(_DWORD *)(v121 + 104) = *(_DWORD *)(v121 + 104) & 0xFFFFFFFE | (v120 == 1);
    if (v108)
      operator delete(v108);
LABEL_111:
    if (v71 > v72)
    {
      v84 = &__src[v72];
      if (v29 != v84)
      {
        v85 = (char *)v174 - (char *)v84;
        v50 = v171;
        if (v174 == v84)
          goto LABEL_130;
LABEL_128:
        v86 = v29;
LABEL_129:
        memmove(v86, v84, v85);
        goto LABEL_130;
      }
      v30 = v174;
      v50 = v171;
LABEL_131:
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v196 && v195 == 1)
        free(v196);
      v48 = (char *)v184;
      v49 = ++v50;
      if (v50 >= (unint64_t)((v185 - (_BYTE *)v184) >> 3))
      {
LABEL_253:
        v142 = v167;
        if (v29 != v30)
        {
          v143 = v29;
          do
          {
            v144 = *v143++;
            TIInputManager::apply_shift_context_to_prediction(v175, v142, (KB::Word *)(*(_QWORD *)(a2 + 8) + 240 * v144));
            if (v142 == 2)
              v142 = 0;
          }
          while (v143 != v30);
        }
        KB::Candidate::commit_custom_capitalization((KB::Candidate *)a2);
        v145 = 1;
        if (v29)
          goto LABEL_259;
        goto LABEL_260;
      }
      continue;
    }
    break;
  }
  if (a8)
  {
    v147 = (const char *)v201;
    if (!v201)
      v147 = (const char *)v202;
    if (v198[0])
      v148 = v147;
    else
      v148 = "";
    KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)&v191);
    v150 = (const char *)*((_QWORD *)&v191 + 1);
    if (!*((_QWORD *)&v191 + 1))
      v150 = (const char *)v192;
    if ((_WORD)v191)
      v151 = v150;
    else
      v151 = "";
    KB::append_format(a8, (__CFString *)"input [%s] was considered to have capitalization type WordCapitalizationTypeAllCaps/WordCapitalizationTypeMixedCase and candidate [%s] was not accepted; will be filtered out\n",
      v149,
      v148,
      v151);
    goto LABEL_282;
  }
LABEL_285:
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v196 && v195 == 1)
    free(v196);
  v145 = 0;
  if (v29)
LABEL_259:
    operator delete(v29);
LABEL_260:
  if (v184)
    operator delete(v184);
  if (v186)
    operator delete(v186);
  if (v189.__begin_)
    operator delete(v189.__begin_);
  if (v201 && v200 == 1)
    free(v201);
  return v145;
}

void TIInputManager::input_flags_subvector(std::vector<unsigned int>::size_type __n@<X2>, _QWORD *a2@<X0>, unsigned int a3@<W1>, std::vector<unsigned int> *a4@<X8>)
{
  int v4;
  uint64_t v8;
  char *end;
  unsigned int *value;
  uint64_t v11;
  std::vector<unsigned int>::pointer begin;
  unsigned int v13;
  unsigned int *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;

  v4 = __n;
  a4->__begin_ = 0;
  a4->__end_ = 0;
  a4->__end_cap_.__value_ = 0;
  std::vector<unsigned int>::reserve(a4, __n);
  v8 = v4 + a3;
  if (v8 > a3)
  {
    end = (char *)a4->__end_;
    value = a4->__end_cap_.__value_;
    v11 = a3;
    begin = a4->__begin_;
    do
    {
      v13 = *(_DWORD *)(*a2 + 40 * v11 + 32);
      if (end >= (char *)value)
      {
        v15 = (end - (char *)begin) >> 2;
        v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 62)
          abort();
        if (((char *)value - (char *)begin) >> 1 > v16)
          v16 = ((char *)value - (char *)begin) >> 1;
        if ((unint64_t)((char *)value - (char *)begin) >= 0x7FFFFFFFFFFFFFFCLL)
          v17 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v17 = v16;
        if (v17)
          v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v17);
        else
          v18 = 0;
        v19 = (unsigned int *)(v17 + 4 * v15);
        *v19 = v13;
        v14 = v19 + 1;
        while (end != (char *)begin)
        {
          v20 = *((_DWORD *)end - 1);
          end -= 4;
          *--v19 = v20;
        }
        value = (unsigned int *)(v17 + 4 * v18);
        a4->__begin_ = v19;
        a4->__end_ = v14;
        a4->__end_cap_.__value_ = value;
        if (begin)
          operator delete(begin);
        begin = v19;
      }
      else
      {
        *(_DWORD *)end = v13;
        v14 = (unsigned int *)(end + 4);
      }
      a4->__end_ = v14;
      ++v11;
      end = (char *)v14;
    }
    while (v11 != v8);
  }
}

char *std::vector<unsigned int>::__assign_with_size[abi:nn180100]<unsigned int *,unsigned int *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62)
      abort();
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned int>::__vallocate[abi:nn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

BOOL ___ZNK14TIInputManager18apply_case_changesERN2KB9CandidateERKNSt3__16vectorINS0_5InputENS3_9allocatorIS5_EEEEj14TIShiftContextbRKN3WTF6RefPtrINS0_19DictionaryContainerEEEP10__CFString_block_invoke(uint64_t a1, KB::String *this)
{
  return *((float *)this + 12) > 0.0
      && (*((_BYTE *)this + 104) & 1) != 0
      && KB::String::equal(this, *(const KB::String **)(a1 + 32), 0);
}

_QWORD *std::vector<BOOL>::vector(_QWORD *a1, unint64_t a2, unsigned __int8 *a3)
{
  _QWORD *v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  _QWORD *v11;
  int v12;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if ((a2 & 0x8000000000000000) != 0)
      abort();
    v6 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(((a2 - 1) >> 6) + 1);
    *a1 = v6;
    a1[2] = v7;
    v8 = *a3;
    a1[1] = a2;
    if (a2 >= 0x41)
      v9 = (a2 - 1) >> 6;
    else
      v9 = 0;
    v6[v9] = 0;
    v11 = v6;
    v12 = 0;
    if (v8)
      std::__fill_n[abi:nn180100]<true,std::vector<BOOL>>(&v11, a2);
    else
      std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&v11, a2);
  }
  return a1;
}

void TIInputManager::apply_shift_context_to_prediction(uint64_t a1, int a2, KB::Word *this)
{
  unsigned int v4;
  void *v5;
  uint64_t v6;
  unint64_t v7;
  int32x2_t v8;
  uint64_t v9;
  int64x2_t v10;
  uint64x2_t v11;
  uint64x2_t v12;
  int64x2_t v13;
  int64x2_t v14;
  int8x8_t v15;
  int8x8_t v16;
  unint64_t v17;
  int8x8_t v18;
  __int32 v19;
  uint64_t v20;
  unsigned __int8 v21;
  void *v22;
  unint64_t v23;

  if ((a2 - 2) < 2)
  {
    if ((*((_BYTE *)this + 104) & 0x20) != 0)
      return;
LABEL_19:
    v20 = *(_QWORD *)(a1 + 544);
    if (v20)
      (*(void (**)(uint64_t, KB::Word *, _QWORD))(*(_QWORD *)v20 + 72))(v20, this, 0);
    else
      KB::Word::capitalize_first_letter(this, 0);
    return;
  }
  if ((a2 - 4) >= 2)
  {
    if (a2 != 1)
      return;
    goto LABEL_19;
  }
  v4 = *((unsigned __int16 *)this + 2);
  if (!*((_WORD *)this + 2))
  {
    KB::String::compute_length((unsigned __int16 *)this);
    v4 = *((unsigned __int16 *)this + 2);
  }
  v21 = 1;
  std::vector<BOOL>::vector(&v22, v4, &v21);
  v5 = v22;
  if (v23 >= 0x20)
    v6 = 32;
  else
    v6 = v23;
  if (v6)
  {
    v7 = 0;
    v8 = (int32x2_t)0x100000000;
    v9 = ((_BYTE)v6 + 1) & 0x7E;
    v10 = 0uLL;
    v11 = (uint64x2_t)vdupq_n_s64(v6 - 1);
    v12 = (uint64x2_t)vdupq_n_s64(1uLL);
    v13 = (int64x2_t)xmmword_1DA910FD0;
    v14 = vdupq_n_s64(2uLL);
    do
    {
      v15 = *(int8x8_t *)v10.i8;
      v16 = (int8x8_t)vmovn_s64((int64x2_t)vcgeq_u64(v11, (uint64x2_t)v13));
      v17 = v7 >> 6;
      if ((v16.i8[0] & 1) != 0)
        v10.i64[0] = *((_QWORD *)v22 + v17);
      if ((v16.i8[4] & 1) != 0)
        v10.i64[1] = *((_QWORD *)v22 + v17);
      v10 = vceqzq_s64((int64x2_t)vandq_s8((int8x16_t)v10, (int8x16_t)vshlq_u64(v12, (uint64x2_t)v13)));
      *(int8x8_t *)v10.i8 = vorr_s8(vbic_s8((int8x8_t)vshl_u32((uint32x2_t)0x100000001, (uint32x2_t)v8), (int8x8_t)vmovn_s64(v10)), v15);
      v7 += 2;
      v13 = vaddq_s64(v13, v14);
      v8 = vadd_s32(v8, (int32x2_t)0x200000002);
    }
    while (v9 != v7);
    v18 = vbsl_s8(v16, *(int8x8_t *)v10.i8, v15);
    v19 = v18.i32[0] | v18.i32[1];
  }
  else
  {
    v19 = 0;
  }
  *((_DWORD *)this + 30) = v19;
  *((_DWORD *)this + 26) = *((_DWORD *)this + 26) & 0xFFFFFFFE | (v19 == 1);
  if (v5)
    operator delete(v5);
}

_QWORD *std::__fill_n[abi:nn180100]<true,std::vector<BOOL>>(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;
  int v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;

  v2 = a2;
  v3 = result;
  v4 = *((_DWORD *)result + 2);
  v5 = (_QWORD *)*result;
  if (v4)
  {
    if ((64 - v4) >= a2)
      v6 = a2;
    else
      v6 = (64 - v4);
    *v5++ |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4);
    v2 = a2 - v6;
    *result = v5;
  }
  v7 = v2 >> 6;
  if (v2 >= 0x40)
    result = memset(v5, 255, 8 * v7);
  if ((v2 & 0x3F) != 0)
  {
    v8 = &v5[v7];
    *v3 = v8;
    *v8 |= 0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F);
  }
  return result;
}

void std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  int v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;

  v2 = a2;
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_QWORD **)a1;
  if (v4)
  {
    if ((64 - v4) >= a2)
      v6 = a2;
    else
      v6 = (64 - v4);
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4));
    v2 = a2 - v6;
    *(_QWORD *)a1 = v5;
  }
  v7 = v2 >> 6;
  if (v2 >= 0x40)
    bzero(v5, 8 * v7);
  if ((v2 & 0x3F) != 0)
  {
    v8 = &v5[v7];
    *(_QWORD *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }
}

BOOL ___ZN14TIInputManager34apply_case_insensitive_constraintsERN2KB19CandidateCollectionENS0_10LookupTypeEP10__CFString_block_invoke(uint64_t a1, KB::Candidate *a2)
{
  _BOOL4 v4;
  __CFString *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  _WORD v12[3];
  char v13;
  void *v14;
  uint64_t v15;
  _WORD v16[3];
  char v17;
  void *v18;
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  v4 = TIInputManager::matches_case_insensitive_constraints(*(_QWORD *)(a1 + 32), (uint64_t)a2, (_LXLexicon *)(a1 + 40), (_LXLexicon *)(a1 + 72), (unsigned __int16 *)(a1 + 104), *(_DWORD *)(a1 + 144));
  if (!v4)
  {
    v5 = *(__CFString **)(a1 + 136);
    if (v5)
    {
      KB::Candidate::capitalized_string(a2, (uint64_t)v16);
      v6 = (const char *)v18;
      if (!v18)
        v6 = (const char *)v19;
      if (v16[0])
        v7 = v6;
      else
        v7 = "";
      KB::Candidate::token_ids_as_string(a2, (uint64_t)v12);
      v9 = (const char *)v14;
      if (!v14)
        v9 = (const char *)&v15;
      if (v12[0])
        v10 = v9;
      else
        v10 = "";
      KB::append_format(v5, (__CFString *)"[%s] {%s} removed by %s\n", v8, v7, v10, "apply_case_insensitive_constraints");
      if (v14 && v13 == 1)
        free(v14);
      if (v18 && v17 == 1)
        free(v18);
    }
  }
  return !v4;
}

KB::String *__copy_helper_block_8_40c17_ZTSKN2KB6StringE72c17_ZTSKN2KB6StringE104c17_ZTSKN2KB6StringE(uint64_t a1, uint64_t a2)
{
  KB::String::String((KB::String *)(a1 + 40), (const KB::String *)(a2 + 40));
  KB::String::String((KB::String *)(a1 + 72), (const KB::String *)(a2 + 72));
  return KB::String::String((KB::String *)(a1 + 104), (const KB::String *)(a2 + 104));
}

void __destroy_helper_block_8_40c17_ZTSKN2KB6StringE72c17_ZTSKN2KB6StringE104c17_ZTSKN2KB6StringE(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = *(void **)(a1 + 112);
  if (v2 && *(_BYTE *)(a1 + 110) == 1)
    free(v2);
  v3 = *(void **)(a1 + 80);
  if (v3 && *(_BYTE *)(a1 + 78) == 1)
    free(v3);
  v4 = *(void **)(a1 + 48);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 46) == 1)
      free(v4);
  }
}

BOOL TIInputManager::matches_case_insensitive_constraints(uint64_t a1, uint64_t a2, _LXLexicon *a3, _LXLexicon *a4, unsigned __int16 *a5, int a6)
{
  KB::String *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  BOOL v18;
  uint64_t v19;
  size_t v20;
  const char *v21;
  const char *v22;
  BOOL v24;
  _BOOL4 v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  __int16 v29;
  char v30;
  void *v31;
  char v32;
  ByteString v33;
  _WORD v34[3];
  char v35;
  void *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!*(_WORD *)(a2 + 888))
    KB::Candidate::compute_string((KB::Candidate *)a2);
  v12 = (KB::String *)(a2 + 888);
  if (!a6)
  {
    if (!*(_WORD *)v12)
      KB::Candidate::compute_string((KB::Candidate *)a2);
    if (*(_BYTE *)(a2 + 962) && *(_WORD *)a3)
    {
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 8) + 72), (_LXLexicon *)(a2 + 888), v34);
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 8) + 72), a3, &v33);
      v24 = KB::ByteString::starts_with((KB::ByteString *)v34, &v33);
      if (v33.var0.var0.var0 >= 0xFu && v33.var0.var0.var1)
        MEMORY[0x1DF0A212C](v33.var0.var0.var1, 0x1000C8077774924);
      if (v34[0] >= 0xFu && v36)
        MEMORY[0x1DF0A212C](v36, 0x1000C8077774924);
      if (!v24)
        return 0;
    }
    else if (*(_WORD *)a4)
    {
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 8) + 72), (_LXLexicon *)(a2 + 888), v34);
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 8) + 72), a4, &v33);
      v25 = KB::ByteString::starts_with((KB::ByteString *)v34, &v33);
      if (v33.var0.var0.var0 >= 0xFu && v33.var0.var0.var1)
        MEMORY[0x1DF0A212C](v33.var0.var0.var1, 0x1000C8077774924);
      if (v34[0] >= 0xFu && v36)
        MEMORY[0x1DF0A212C](v36, 0x1000C8077774924);
      if (!v25)
        return 0;
    }
    if (*(_BYTE *)(a1 + 680))
    {
      v26 = *(unsigned __int16 *)(a2 + 892);
      if (!*(_WORD *)(a2 + 892))
      {
        KB::String::compute_length((unsigned __int16 *)(a2 + 888));
        v26 = *(unsigned __int16 *)(a2 + 892);
      }
      v27 = a5[2];
      if (!a5[2])
      {
        KB::String::compute_length(a5);
        v27 = a5[2];
      }
      if (v26 > v27)
        return 0;
    }
  }
  if (*(_QWORD *)a2)
  {
    v13 = 240 * *(_QWORD *)a2 - 240;
    v14 = (uint64_t *)(*(_QWORD *)(a2 + 8) + 224);
    do
    {
      v16 = *v14;
      v14 += 30;
      v15 = v16;
      if (v16)
        v17 = 1;
      else
        v17 = v13 == 0;
      v13 -= 240;
    }
    while (!v17);
    if (v15)
      return 1;
  }
  if (*(_WORD *)(a1 + 32))
  {
    KB::String::String((KB::String *)v34, (const KB::String *)(a1 + 32));
    if (KB::String::contains((KB::String *)v34, 0x2019u))
    {
      v29 = 0;
      v30 = 0;
      v31 = "'";
      v28 = 1048577;
      v32 = 0;
      KB::String::replace_char((KB::String *)v34, (const KB::String *)&v28, 8217, (uint64_t)&v33);
      KB::String::operator=((uint64_t)v34, (KB::String *)&v33);
      if (v33.var0.var0.var1 && v33.var0.var1.var1[4] == 1)
        free(v33.var0.var0.var1);
      if (v31 && v30 == 1)
        free(v31);
    }
    v18 = KB::String::equal((KB::String *)(a2 + 888), (const KB::String *)v34, 0);
    if (v36 && v35 == 1)
      free(v36);
    if (v18)
      return 0;
  }
  v19 = *(_QWORD *)(*(_QWORD *)(a1 + 224) + 24);
  if (!KB::String::equal(v12, (const KB::String *)(v19 + 56), 0))
    return 1;
  v20 = *a5;
  if (v20 > *(unsigned __int16 *)(v19 + 56))
    return 0;
  if (*(_QWORD *)(v19 + 64))
    v21 = *(const char **)(v19 + 64);
  else
    v21 = (const char *)(v19 + 72);
  if (*((_QWORD *)a5 + 1))
    v22 = (const char *)*((_QWORD *)a5 + 1);
  else
    v22 = (const char *)(a5 + 8);
  return strncasecmp(v21, v22, v20) == 0;
}

uint64_t ___ZN14TIInputManager29inject_supplemental_candidateEN2KB10LookupTypeERNS0_19CandidateCollectionE_block_invoke(uint64_t a1, _LXLexicon *a2, const KB::String *a3, const KB::String *a4)
{
  uint64_t v6;
  KB::CollatorWrapper **v7;
  const KB::String *v8;
  int v9;
  KB::CollatorWrapper **v10;
  const KB::String *v11;
  _BOOL8 v12;
  unsigned __int16 v14[3];
  char v15;
  void *v16;
  _BYTE v17[8];
  void *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 32);
  if (!KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(*(_QWORD *)(*(_QWORD *)(v6 + 224) + 8) + 72), a2, a3, a4))return 1;
  if (!(*(unsigned int (**)(_QWORD))(**(_QWORD **)(v6 + 232) + 16))(*(_QWORD *)(v6 + 232))
    || !(*(unsigned int (**)(_QWORD))(**(_QWORD **)(v6 + 232) + 64))(*(_QWORD *)(v6 + 232)))
  {
    return 0;
  }
  KB::String::String((KB::String *)v17, "'s");
  v7 = (KB::CollatorWrapper **)(*(_QWORD *)(*(_QWORD *)(v6 + 224) + 8) + 72);
  KB::String::String((KB::String *)v14, (const KB::String *)a2);
  KB::String::append(v14, (const KB::String *)v17);
  v9 = KB::CollatorWrapper::sortkey_compare_strings(v7, (_LXLexicon *)v14, a3, v8);
  if (v16 && v15 == 1)
    free(v16);
  if (v9)
  {
    v10 = (KB::CollatorWrapper **)(*(_QWORD *)(*(_QWORD *)(v6 + 224) + 8) + 72);
    KB::String::String((KB::String *)v14, a3);
    KB::String::append(v14, (const KB::String *)v17);
    v12 = KB::CollatorWrapper::sortkey_compare_strings(v10, a2, (const KB::String *)v14, v11) == 0;
    if (v16 && v15 == 1)
      free(v16);
  }
  else
  {
    v12 = 1;
  }
  if (v18 && v17[6] == 1)
    free(v18);
  return v12;
}

BOOL ___ZN14TIInputManager30word_from_supplemental_lexiconERN2KB6StringE_block_invoke(uint64_t a1, _LXLexicon *a2, const KB::String *a3, const KB::String *a4)
{
  return KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 224) + 8) + 72), a2, a3, a4) == 0;
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v6;
  float v7;
  float v8;
  uint64_t *v9;
  float v10;
  uint64_t *v11;
  float v12;

  v6 = expf(*(float *)(a2 + 744));
  v7 = expf(*(float *)(a1 + 744));
  v8 = expf(*(float *)(a3 + 744));
  if (v6 > v7)
  {
    v9 = (uint64_t *)a1;
    if (v8 <= v6)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
      v10 = expf(*(float *)(a3 + 744));
      if (v10 <= expf(*(float *)(a2 + 744)))
        return;
      v9 = (uint64_t *)a2;
    }
    v11 = (uint64_t *)a3;
    goto LABEL_9;
  }
  if (v8 > v6)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
    v12 = expf(*(float *)(a2 + 744));
    if (v12 > expf(*(float *)(a1 + 744)))
    {
      v9 = (uint64_t *)a1;
      v11 = (uint64_t *)a2;
LABEL_9:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v9, v11);
    }
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  float v8;
  float v9;
  float v10;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a2, a3);
  v8 = expf(*(float *)(a4 + 744));
  if (v8 > expf(*(float *)(a3 + 744)))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
    v9 = expf(*(float *)(a3 + 744));
    if (v9 > expf(*(float *)(a2 + 744)))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
      v10 = expf(*(float *)(a2 + 744));
      if (v10 > expf(*(float *)(a1 + 744)))
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
    }
  }
}

void std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  float v10;
  float v11;
  float v12;
  float v13;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a2, a3, a4);
  v10 = expf(*(float *)(a5 + 744));
  if (v10 > expf(*(float *)(a4 + 744)))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a4, (uint64_t *)a5);
    v11 = expf(*(float *)(a4 + 744));
    if (v11 > expf(*(float *)(a3 + 744)))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
      v12 = expf(*(float *)(a3 + 744));
      if (v12 > expf(*(float *)(a2 + 744)))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
        v13 = expf(*(float *)(a2 + 744));
        if (v13 > expf(*(float *)(a1 + 744)))
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
      }
    }
  }
}

void std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,KB::Candidate *>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  float v12;
  int64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  uint64_t v23;
  unint64_t v24;
  float v25;
  uint64_t *v26;
  float v27;
  uint64_t v29[125];
  uint64_t v30[93];
  float v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if ((uint64_t *)a1 != a2)
  {
    v4 = a2;
    v6 = (uint64_t)a2 - a1;
    v7 = ((uint64_t)a2 - a1) / 1000;
    if ((uint64_t)a2 - a1 >= 1001)
    {
      v8 = (unint64_t)(v7 - 2) >> 1;
      v9 = v8 + 1;
      v10 = a1 + 1000 * v8;
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, v7, v10);
        v10 -= 1000;
        --v9;
      }
      while (v9);
    }
    if (v4 != a3)
    {
      v11 = v4;
      do
      {
        v12 = expf(*((float *)v11 + 186));
        if (v12 > expf(*(float *)(a1 + 744)))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v11, (uint64_t *)a1);
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, v7, a1);
        }
        v11 += 125;
      }
      while (v11 != a3);
    }
    if (v6 >= 1001)
    {
      v13 = v6 / 0x3E8uLL;
      do
      {
        KB::Candidate::Candidate((uint64_t)v29, a1);
        v14 = 0;
        v15 = v13 - 2;
        if (v13 < 2)
          v15 = v13 - 1;
        v16 = v15 >> 1;
        v17 = a1;
        do
        {
          v18 = (uint64_t *)v17;
          v19 = v14 + 1;
          v17 += 1000 * (v14 + 1);
          v20 = 2 * v14;
          v14 = (2 * v14) | 1;
          v21 = v20 + 2;
          if (v20 + 2 < v13)
          {
            v22 = expf(*(float *)&v18[125 * v19 + 93]);
            if (v22 > expf(*(float *)(v17 + 1744)))
            {
              v17 += 1000;
              v14 = v21;
            }
          }
          KB::Candidate::operator=(v18, (uint64_t *)v17);
        }
        while (v14 <= v16);
        v4 -= 125;
        if ((uint64_t *)v17 == v4)
        {
          KB::Candidate::operator=((uint64_t *)v17, v29);
        }
        else
        {
          KB::Candidate::operator=((uint64_t *)v17, v4);
          KB::Candidate::operator=(v4, v29);
          v23 = v17 - a1 + 1000;
          if (v23 >= 1001)
          {
            v24 = (unint64_t)(0x1CAC083126E978D5 * (v23 >> 3) - 2) >> 1;
            v25 = expf(*(float *)(a1 + 1000 * v24 + 744));
            if (v25 > expf(*(float *)(v17 + 744)))
            {
              KB::Candidate::Candidate((uint64_t)v30, v17);
              do
              {
                v26 = (uint64_t *)v17;
                v17 = a1 + 1000 * v24;
                KB::Candidate::operator=(v26, (uint64_t *)v17);
                if (!v24)
                  break;
                v24 = (v24 - 1) >> 1;
                v27 = expf(*(float *)(a1 + 1000 * v24 + 744));
              }
              while (v27 > expf(v31));
              KB::Candidate::operator=((uint64_t *)v17, v30);
              KB::Candidate::~Candidate((KB::Candidate *)v30);
            }
          }
        }
        KB::Candidate::~Candidate((KB::Candidate *)v29);
      }
      while (v13-- > 2);
    }
  }
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(uint64_t a1, uint64_t a2)
{
  _BOOL8 v4;
  float v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  float v10;
  uint64_t v11;
  float v12;
  float v13;
  uint64_t *v14;
  uint64_t v16[93];
  float v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = 1;
  switch(0x1CAC083126E978D5 * ((a2 - a1) >> 3))
  {
    case 0:
    case 1:
      return v4;
    case 2:
      v5 = expf(*(float *)(a2 - 256));
      if (v5 > expf(*(float *)(a1 + 744)))
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)(a2 - 1000));
      return v4;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a1 + 1000, a2 - 1000);
      return v4;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a1 + 1000, a1 + 2000, a2 - 1000);
      return v4;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a1 + 1000, a1 + 2000, a1 + 3000, a2 - 1000);
      return v4;
    default:
      v6 = a1 + 2000;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a1 + 1000, a1 + 2000);
      v7 = a1 + 3000;
      if (a1 + 3000 == a2)
        return 1;
      v8 = 0;
      v9 = 0;
      break;
  }
  while (1)
  {
    v10 = expf(*(float *)(v7 + 744));
    if (v10 > expf(*(float *)(v6 + 744)))
      break;
LABEL_14:
    v6 = v7;
    v8 += 1000;
    v7 += 1000;
    if (v7 == a2)
      return 1;
  }
  KB::Candidate::Candidate((uint64_t)v16, v7);
  v11 = v8;
  while (1)
  {
    KB::Candidate::operator=((uint64_t *)(a1 + v11 + 3000), (uint64_t *)(a1 + v11 + 2000));
    if (v11 == -2000)
      break;
    v12 = expf(v17);
    v13 = expf(*(float *)(a1 + v11 + 1744));
    v11 -= 1000;
    if (v12 <= v13)
    {
      v14 = (uint64_t *)(a1 + v11 + 3000);
      goto LABEL_12;
    }
  }
  v14 = (uint64_t *)a1;
LABEL_12:
  KB::Candidate::operator=(v14, v16);
  if (++v9 != 8)
  {
    KB::Candidate::~Candidate((KB::Candidate *)v16);
    goto LABEL_14;
  }
  v4 = v7 + 1000 == a2;
  KB::Candidate::~Candidate((KB::Candidate *)v16);
  return v4;
}

void std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t *v13;
  uint64_t v14;
  float v15;
  float v16;
  uint64_t v17[93];
  float v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a2 - 2;
  if (a2 >= 2)
  {
    v4 = a3;
    v6 = v3 >> 1;
    if ((uint64_t)(v3 >> 1) >= 0x1CAC083126E978D5 * ((a3 - a1) >> 3))
    {
      v8 = (0x395810624DD2F1AALL * ((a3 - a1) >> 3)) | 1;
      v9 = a1 + 1000 * v8;
      v10 = 0x395810624DD2F1AALL * ((a3 - a1) >> 3) + 2;
      if (v10 < a2)
      {
        v11 = expf(*(float *)(a1 + 1000 * v8 + 744));
        if (v11 > expf(*(float *)(v9 + 1744)))
        {
          v9 += 1000;
          v8 = v10;
        }
      }
      v12 = expf(*(float *)(v9 + 744));
      if (v12 <= expf(*(float *)(v4 + 744)))
      {
        KB::Candidate::Candidate((uint64_t)v17, v4);
        do
        {
          v13 = (uint64_t *)v9;
          KB::Candidate::operator=((uint64_t *)v4, (uint64_t *)v9);
          if (v6 < v8)
            break;
          v14 = (2 * v8) | 1;
          v9 = a1 + 1000 * v14;
          if (2 * v8 + 2 < a2)
          {
            v15 = expf(*(float *)(a1 + 1000 * v14 + 744));
            if (v15 > expf(*(float *)(v9 + 1744)))
            {
              v9 += 1000;
              v14 = 2 * v8 + 2;
            }
          }
          v16 = expf(*(float *)(v9 + 744));
          v4 = (uint64_t)v13;
          v8 = v14;
        }
        while (v16 <= expf(v18));
        KB::Candidate::operator=(v13, v17);
        KB::Candidate::~Candidate((KB::Candidate *)v17);
      }
    }
  }
}

void std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>>>::destroy(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>>>::destroy(*a1);
    std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>>>::destroy(a1[1]);
    std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>::reset[abi:nn180100](a1 + 8);
    v2 = (void *)a1[5];
    if (v2)
    {
      if (*((_BYTE *)a1 + 38) == 1)
        free(v2);
    }
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(*a1);
    std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<int const,KB::ContinuousPathDetector::AnnotatedPath>,0>(a1 + 4);
    operator delete(a1);
  }
}

void std::vector<KB::Input>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 4);
        if (v6)
        {
          if (*(v4 - 34) == 1)
            free(v6);
        }
        v4 -= 40;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<int const,KB::ContinuousPathDetector::AnnotatedPath>,0>(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  void *v4;

  v2 = a1[7];
  if (v2)
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v2);
  v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }
}

uint64_t TIInputManager::LockedInput::locked_length(TIInputManager::LockedInput *this)
{
  unsigned int v1;

  v1 = *((_DWORD *)this + 1);
  if (*(_DWORD *)this <= v1)
    return v1;
  else
    return *(unsigned int *)this;
}

uint64_t TIInputManager::LockedInput::locked_length_without_deletion(TIInputManager::LockedInput *this)
{
  return *(unsigned int *)this;
}

unsigned int *TIInputManager::LockedInput::set_shadow_locked_length(unsigned int *this, unsigned int a2)
{
  unsigned int v2;

  v2 = *this;
  if (*this <= a2)
    v2 = a2;
  *this = v2;
  return this;
}

unsigned int *TIInputManager::LockedInput::set_accepted_locked_length(unsigned int *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  unsigned int v4;

  v3 = *this;
  v4 = this[1];
  if (*this <= a2)
    v3 = a2;
  if (v4 >= a3)
    v4 = a3;
  *this = v3;
  this[1] = v4;
  return this;
}

unsigned int *TIInputManager::LockedInput::set_deletion_locked_length(unsigned int *this, unsigned int a2)
{
  this[1] = a2;
  if (*this > a2)
    *this = a2;
  return this;
}

uint32x2_t TIInputManager::LockedInput::drop_input_prefix_of_length(uint32x2_t *this, unsigned int a2)
{
  uint32x2_t result;

  result = vqsub_u32(*this, (uint32x2_t)vdup_n_s32(a2));
  *this = result;
  return result;
}

_QWORD *TIInputManager::LockedInput::clear(_QWORD *this)
{
  *this = 0;
  return this;
}

void TIInputManager::TIInputManager(TIInputManager *this)
{
  uint64_t v2;
  CFAbsoluteTime Current;
  uint64_t v4;
  void *__p[2];
  uint64_t v6;
  void **v7;

  *(_QWORD *)this = &off_1EA0FD888;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_WORD *)this + 16) = 0;
  *(_DWORD *)((char *)this + 34) = 16;
  *((_BYTE *)this + 38) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_BYTE *)this + 48) = 0;
  *((_DWORD *)this + 16) = 0x100000;
  *((_WORD *)this + 34) = 0;
  *((_BYTE *)this + 70) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_BYTE *)this + 80) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_DWORD *)this + 26) = 0x100000;
  *((_WORD *)this + 54) = 0;
  *((_BYTE *)this + 110) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_BYTE *)this + 120) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_OWORD *)this + 9) = xmmword_1DA910FE0;
  *((_DWORD *)this + 40) = 1028443341;
  *(_OWORD *)((char *)this + 164) = xmmword_1DA910FF0;
  *((_QWORD *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0x100000;
  *((_WORD *)this + 98) = 0;
  *((_BYTE *)this + 198) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_BYTE *)this + 208) = 0;
  __p[0] = 0;
  __p[1] = 0;
  v6 = 0;
  v2 = operator new();
  *((_QWORD *)this + 28) = KB::DictionaryContainer::DictionaryContainer(v2, (uint64_t *)__p, 0, 0, 1);
  v7 = __p;
  std::vector<KB::LexiconInfo>::__destroy_vector::operator()[abi:nn180100](&v7);
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_DWORD *)this + 62) = 1;
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 34) = 0;
  *((_QWORD *)this + 32) = 0;
  *((_DWORD *)this + 72) = 0x100000;
  *((_WORD *)this + 146) = 0;
  *((_BYTE *)this + 294) = 0;
  *((_QWORD *)this + 37) = 0;
  *((_BYTE *)this + 304) = 0;
  *((_QWORD *)this + 40) = 0;
  Current = CFAbsoluteTimeGetCurrent();
  *((_QWORD *)this + 42) = 0;
  *((_QWORD *)this + 43) = 0;
  *((_QWORD *)this + 41) = (char *)this + 336;
  *((_OWORD *)this + 22) = xmmword_1DA911000;
  *((_QWORD *)this + 46) = 0x40A0000040000000;
  *((CFAbsoluteTime *)this + 47) = Current;
  *((_QWORD *)this + 48) = 0;
  *((_DWORD *)this + 98) = -1;
  *((_BYTE *)this + 396) = 0;
  *((_DWORD *)this + 100) = 0x100000;
  *((_WORD *)this + 202) = 0;
  *((_BYTE *)this + 406) = 0;
  *((_QWORD *)this + 51) = 0;
  *((_BYTE *)this + 416) = 0;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 30) = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((TIInputManager *)((char *)this + 496));
  language_modeling::v1::LinguisticContext::LinguisticContext((TIInputManager *)((char *)this + 504));
  *((_QWORD *)this + 65) = 0;
  *((_QWORD *)this + 64) = 0;
  *((_QWORD *)this + 66) = 0;
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *(_OWORD *)((char *)this + 572) = 0u;
  TI::VulgarWordUsageDatabaseWrapper::VulgarWordUsageDatabaseWrapper((TIInputManager *)((char *)this + 592));
  *((_QWORD *)this + 79) = 16;
  *((_QWORD *)this + 84) = 0;
  *((_QWORD *)this + 83) = 0;
  *((_QWORD *)this + 81) = 0;
  *((_QWORD *)this + 80) = 0;
  *((_QWORD *)this + 82) = (char *)this + 664;
  *((_DWORD *)this + 170) = 0;
  *(_DWORD *)((char *)this + 683) = 0;
  *(_DWORD *)((char *)this + 687) = 65537;
  *((_BYTE *)this + 691) = 0;
  *((_QWORD *)this + 87) = 0;
  *((_DWORD *)this + 176) = 15;
  std::string::basic_string[abi:nn180100]<0>(__p, "");
  KB::LanguageModelContext::append((TIInputManager *)((char *)this + 432), 0x100000000uLL, (uint64_t)__p, 0);
  if (SHIBYTE(v6) < 0)
    operator delete(__p[0]);
  TIInputManager::create_autocorrection_engine(this, (TI::Favonius::FavoniusStrokeBuildManager **)__p);
  v4 = *((_QWORD *)this + 23);
  *((void **)this + 23) = __p[0];
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

KB::DictionaryContainer *TIInputManager::load_dictionaries(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  const __CFString *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  KB::DictionaryContainer *result;
  unsigned int *v17;
  _QWORD *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  KB::DynamicDictionary::unload_user_dictionary(*(KB::DynamicDictionary **)(*(_QWORD *)(a1 + 224) + 24));
  if (!*(_BYTE *)(a1 + 690))
  {
    if (TI_IS_INTERNAL_INSTALL::once_token != -1)
      dispatch_once(&TI_IS_INTERNAL_INSTALL::once_token, &__block_literal_global_3460);
    if (TI_IS_INTERNAL_INSTALL::is_internal_install)
    {
      KB::ContinuousPathDetector::Parameters::user_parameters(v10, (uint64_t)&v20);
      v18 = 0;
      v19 = 0;
      *((_QWORD *)&v21 + 1) = CFAbsoluteTimeGetCurrent();
      v22 = 0;
      v11 = a1 + 336;
      std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(*(_QWORD **)(a1 + 336));
      v12 = v18;
      *(_QWORD *)(a1 + 328) = &v18;
      *(_QWORD *)(a1 + 336) = v12;
      v13 = v19;
      *(_QWORD *)(a1 + 344) = v19;
      if (v13)
      {
        v12[2] = v11;
        v18 = 0;
        v19 = 0;
        v12 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 328) = v11;
      }
      v14 = v21;
      *(_OWORD *)(a1 + 352) = v20;
      *(_OWORD *)(a1 + 368) = v14;
      *(_QWORD *)(a1 + 384) = v22;
      std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(v12);
    }
  }
  v15 = operator new();
  result = KB::DictionaryContainer::DictionaryContainer(v15, a2, a3 != 0, a4, 1);
  v17 = *(unsigned int **)(a1 + 224);
  *(_QWORD *)(a1 + 224) = result;
  if (!v17
    || (WTF::RefCounted<KB::DictionaryContainer>::deref(v17), (result = *(KB::DictionaryContainer **)(a1 + 224)) != 0))
  {
    *((_BYTE *)result + 65) = a5;
  }
  if (a5)
    *(_DWORD *)(a1 + 704) = 8;
  return result;
}

KB::String *TIInputManager::dynamic_set_transient_string(TIInputManager *this, const KB::String *a2)
{
  return KB::String::operator=((KB::String *)(*(_QWORD *)(*((_QWORD *)this + 28) + 24) + 56), a2);
}

void TIInputManager::set_locale_identifier(TIInputManager *this, const KB::String *a2)
{
  CFLocaleIdentifier v4;
  CFLocaleRef v5;
  const void *v6;
  char *v7;
  char *v8;
  CFLocaleIdentifier localeIdentifier[2];
  char v10;

  KB::String::operator=((TIInputManager *)((char *)this + 104), a2);
  KB::cf_string_impl<KB::String>(localeIdentifier, (unsigned __int16 *)a2);
  v4 = localeIdentifier[0];
  v5 = CFLocaleCreate(0, localeIdentifier[0]);
  v6 = (const void *)*((_QWORD *)this + 17);
  if (v6)
    CFRelease(v6);
  *((_QWORD *)this + 17) = v5;
  if (v4)
    CFRelease(v4);
  if (*((_QWORD *)this + 23))
  {
    v7 = (char *)*((_QWORD *)a2 + 1);
    if (!v7)
      v7 = (char *)a2 + 16;
    if (*(_WORD *)a2)
      v8 = v7;
    else
      v8 = "";
    std::string::basic_string[abi:nn180100]<0>(localeIdentifier, v8);
    (*(void (**)(_QWORD, CFLocaleIdentifier *))(**((_QWORD **)this + 23) + 448))(*((_QWORD *)this + 23), localeIdentifier);
    if (v10 < 0)
      operator delete((void *)localeIdentifier[0]);
  }
}

void TIInputManager::set_filter_specification_overrides(TIInputManager *this, CFTypeRef cf)
{
  const void *v4;

  if (cf)
    CFRetain(cf);
  v4 = (const void *)*((_QWORD *)this + 87);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 87) = cf;
  std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>>>::destroy(*((_QWORD **)this + 83));
  *((_QWORD *)this + 82) = (char *)this + 664;
  *((_QWORD *)this + 84) = 0;
  *((_QWORD *)this + 83) = 0;
  *((_QWORD *)this + 81) = 0;
  *((_QWORD *)this + 80) = 0;
}

unsigned __int16 *TIInputManager::input_string@<X0>(TIInputManager *this@<X0>, uint64_t a2@<X8>)
{
  return TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, -858993459 * ((*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3), a2);
}

unsigned __int16 *TIInputManager::input_substring@<X0>(TIInputManager *this@<X0>, unsigned int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  return TIInputManager::input_substring((unsigned __int16 *)this + 4, a2, a3, a4);
}

unsigned __int16 *TIInputManager::input_stem@<X0>(TIInputManager *this@<X0>, uint64_t a2@<X8>)
{
  return TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, *((_DWORD *)this + 24), a2);
}

uint64_t TIInputManager::legacy_input_start_index(TIInputManager *this)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  char v5;

  v2 = *((unsigned int *)this + 24);
  result = v2 + 1;
  v4 = 40 * v2 - 8;
  do
  {
    if (!--result)
      break;
    v5 = *(_BYTE *)(*((_QWORD *)this + 1) + v4);
    v4 -= 40;
  }
  while ((v5 & 0x40) == 0);
  return result;
}

uint64_t TIInputManager::legacy_input_end_index(TIInputManager *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  int v5;
  char *v6;
  char v7;

  result = *((unsigned int *)this + 24);
  v3 = *((_QWORD *)this + 1);
  v4 = -858993459 * ((unint64_t)(*((_QWORD *)this + 2) - v3) >> 3);
  v5 = v4 - result;
  if (v4 > result)
  {
    v6 = (char *)(v3 + 40 * result + 32);
    while (1)
    {
      v7 = *v6;
      v6 += 40;
      if ((v7 & 0x40) != 0)
        break;
      ++result;
      if (!--v5)
        return v4;
    }
  }
  return result;
}

void TIInputManager::add_input(TIInputManager *this, const KB::String *a2, unsigned int a3)
{
  uint64_t *v6;
  unint64_t v7;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  KB::String *v13;
  unint64_t v14;
  KB::String *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  KB::String *v20;
  KB::String *v21;
  char *v22;
  KB::String *v23;
  uint64_t v24;
  const char *v25;
  _BOOL4 v26;
  uint64_t v27;
  KB::String *v28;
  KB::String *v29;
  KB::String *v30;
  char *v31;
  char *v32;
  _BYTE v33[8];
  void *v34;
  unsigned int v35;
  KB::String *v36;
  void *v37;
  KB::String *v38;
  char *v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v6 = TIInputManager::favonius_layout(this);
  v7 = *(unsigned int *)(*v6 + 200);
  if ((unint64_t)((uint64_t)(*(_QWORD *)(*v6 + 16) - *(_QWORD *)(*v6 + 8)) >> 3) >> 1 < v7 || v7 > 0xB)
    v9 = a3 | 0x20;
  else
    v9 = a3;
  KB::String::String((KB::String *)v33, a2);
  v10 = *((_QWORD *)this + 3);
  v11 = *((_QWORD *)this + 1);
  v35 = v9;
  v12 = *((unsigned int *)this + 24);
  v13 = (KB::String *)(v11 + 40 * v12);
  v14 = *((_QWORD *)this + 2);
  if (v14 >= v10)
  {
    v16 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - v11) >> 3) + 1;
    if (v16 > 0x666666666666666)
      abort();
    v17 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - v11) >> 3);
    if (2 * v17 > v16)
      v16 = 2 * v17;
    if (v17 >= 0x333333333333333)
      v18 = 0x666666666666666;
    else
      v18 = v16;
    v32 = (char *)this + 24;
    if (v18)
    {
      v20 = (KB::String *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v18);
    }
    else
    {
      v20 = 0;
      v19 = 0;
    }
    v21 = (KB::String *)((char *)v20 + 40 * v12);
    v28 = v20;
    v29 = v21;
    v22 = (char *)v20 + 40 * v19;
    v30 = v21;
    v31 = v22;
    if (v19 == v12)
    {
      if ((_DWORD)v12)
      {
        v23 = (KB::String *)((char *)v21 - 40 * ((unint64_t)(v12 + 1) >> 1));
        v21 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>(v21, v21, v23);
        v29 = v23;
        v30 = v21;
      }
      else
      {
        v40 = (char *)this + 24;
        v28 = (KB::String *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(1uLL);
        v29 = v28;
        v36 = v20;
        v37 = v20;
        v30 = v28;
        v31 = (char *)v28 + 40 * v24;
        v38 = v20;
        v39 = v22;
        std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)&v36);
        v21 = v28;
      }
    }
    KB::String::String(v21, (const KB::String *)v33);
    *((_DWORD *)v21 + 8) = v35;
    v30 = (KB::String *)((char *)v30 + 40);
    std::vector<KB::Input>::__swap_out_circular_buffer((uint64_t)this + 8, &v28, v13);
    std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)&v28);
  }
  else if (v13 == (KB::String *)v14)
  {
    KB::String::String((KB::String *)(v11 + 40 * v12), (const KB::String *)v33);
    *(_DWORD *)(v11 + 40 * v12 + 32) = v35;
    *((_QWORD *)this + 2) = (char *)v13 + 40;
  }
  else
  {
    std::vector<KB::Input>::__move_range((uint64_t)this + 8, v11 + 40 * v12, v14, (uint64_t)v13 + 40);
    v15 = (KB::String *)v33;
    if (v13 <= (KB::String *)v33)
      v15 = (KB::String *)&v33[40 * (*((_QWORD *)this + 2) > (unint64_t)v33)];
    if (v13 != v15)
    {
      KB::String::operator=((KB::String *)(v11 + 40 * v12), v15);
      *(_DWORD *)(v11 + 40 * v12 + 32) = *((_DWORD *)v15 + 8);
    }
  }
  ++*((_DWORD *)this + 24);
  *((_BYTE *)this + 680) = 0;
  if (*((_QWORD *)a2 + 1))
    v25 = (const char *)*((_QWORD *)a2 + 1);
  else
    v25 = (char *)a2 + 16;
  v26 = strcmp(v25, " ") == 0;
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 23) + 48))(*((_QWORD *)this + 23), 1, v26 & (v9 >> 7));
  if ((v9 & 4) != 0)
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 23) + 136))(*((_QWORD *)this + 23));
    v27 = *((_QWORD *)this + 23);
    TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, *((_DWORD *)this + 24), (uint64_t)&v36);
    (*(void (**)(uint64_t, char *, KB::String **, _QWORD, _QWORD))(*(_QWORD *)v27 + 144))(v27, (char *)this + 432, &v36, *((unsigned int *)this + 24), -858993459 * ((*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3));
    if (v37)
    {
      if (BYTE6(v36) == 1)
        free(v37);
    }
  }
  if (v34)
  {
    if (v33[6] == 1)
      free(v34);
  }
}

KB::String *std::vector<KB::Input>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  const KB::String *v10;
  KB::String *result;
  KB::String *v12;
  uint64_t v13;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = v6 - a4;
  v8 = a2 + v6 - a4;
  if (v8 >= a3)
  {
    result = *(KB::String **)(a1 + 8);
  }
  else
  {
    v10 = (const KB::String *)(a2 + v6 - a4);
    result = *(KB::String **)(a1 + 8);
    do
    {
      v12 = KB::String::String(result, v10);
      *((_DWORD *)v12 + 8) = *((_DWORD *)v10 + 8);
      v10 = (const KB::String *)((char *)v10 + 40);
      result = (KB::String *)((char *)v12 + 40);
    }
    while ((unint64_t)v10 < a3);
  }
  *(_QWORD *)(a1 + 8) = result;
  if (v6 != a4)
  {
    v13 = 0;
    do
    {
      if (v8 != v6)
      {
        result = KB::String::operator=((KB::String *)(v6 + v13 - 40), (KB::String *)(v8 + v13 - 40));
        *(_DWORD *)(v6 + v13 - 8) = *(_DWORD *)(v8 + v13 - 8);
      }
      v13 -= 40;
    }
    while (-8 * (v7 >> 3) != v13);
  }
  return result;
}

KB::String *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>(KB::String *a1, KB::String *a2, KB::String *this)
{
  KB::String *v5;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if (v5 != this)
      {
        KB::String::operator=(this, v5);
        *((_DWORD *)this + 8) = *((_DWORD *)v5 + 8);
      }
      v5 = (KB::String *)((char *)v5 + 40);
      this = (KB::String *)((char *)this + 40);
    }
    while (v5 != a2);
  }
  return this;
}

uint64_t std::__split_buffer<KB::Input>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      v4 = v2 - 40;
      *(_QWORD *)(a1 + 16) = v2 - 40;
      v5 = *(void **)(v2 - 32);
      if (v5 && *(_BYTE *)(v2 - 34) == 1)
      {
        free(v5);
        v4 = *(_QWORD *)(a1 + 16);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

KB::String *std::vector<KB::Input>::__swap_out_circular_buffer(uint64_t a1, _QWORD *a2, KB::String *a3)
{
  KB::String *v3;
  KB::String *v6;
  KB::String *v7;
  KB::String *v8;
  KB::String *v9;
  KB::String *v10;
  KB::String *v11;
  KB::String *v12;
  KB::String *v13;
  uint64_t v14;
  uint64_t v15;

  v3 = a3;
  v6 = (KB::String *)a2[1];
  v7 = *(KB::String **)a1;
  v8 = v6;
  if (v7 != a3)
  {
    v9 = a3;
    v10 = (KB::String *)a2[1];
    do
    {
      v8 = KB::String::String((KB::String *)((char *)v10 - 40), (KB::String *)((char *)v9 - 40));
      *((_DWORD *)v10 - 2) = *((_DWORD *)v9 - 2);
      v9 = (KB::String *)((char *)v9 - 40);
      v10 = v8;
    }
    while (v9 != v7);
  }
  a2[1] = v8;
  v11 = *(KB::String **)(a1 + 8);
  v12 = (KB::String *)a2[2];
  if (v11 != v3)
  {
    do
    {
      KB::String::String(v12, v3);
      *((_DWORD *)v12 + 8) = *((_DWORD *)v3 + 8);
      v3 = (KB::String *)((char *)v3 + 40);
      v12 = (KB::String *)((char *)v12 + 40);
    }
    while (v3 != v11);
    v8 = (KB::String *)a2[1];
  }
  a2[2] = v12;
  v13 = *(KB::String **)a1;
  *(_QWORD *)a1 = v8;
  a2[1] = v13;
  v14 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2[2];
  a2[2] = v14;
  v15 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = a2[3];
  a2[3] = v15;
  *a2 = a2[1];
  return v6;
}

void TIInputManager::set_input(TIInputManager *this, const KB::String *a2)
{
  KB::String **v4;
  size_t v5;
  int v6;
  const char *v7;
  const char *v8;
  uint64_t v9;
  uint64_t j;
  void *v11;
  unsigned int v12;
  const KB::String *v13;
  const KB::String *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  KB::String *v19;
  void *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  KB::String *v24;
  uint64_t v25;
  KB::String *v26;
  UChar32 v27;
  unsigned int v28;
  _BOOL4 v29;
  KB::String *v30;
  unint64_t v31;
  KB::String *v32;
  char *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  KB::String *v39;
  BOOL v40;
  int v41;
  uint64_t v42;
  KB::String *v43;
  KB::String *v44;
  KB::String *v45;
  unint64_t i;
  unsigned int v47;
  uint64_t v48;
  KB::String *v49;
  const KB::String *v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  uint64_t v56;
  uint64_t v57;
  KB::String *v58;
  KB::String *v59;
  int64x2_t v60;
  unint64_t v61;
  KB::String *v62;
  KB::String *k;
  void *v64;
  char v65[8];
  int v66;
  __int128 v67;
  uint64_t v68;
  int64x2_t v69;
  unint64_t v70;
  _BYTE v71[8];
  void *v72;
  _BOOL4 v73;
  _BYTE v74[8];
  void *v75;
  int v76;
  __int16 v77;
  char v78;
  void *v79;
  char v80;
  int v81;
  _WORD v82[3];
  char v83;
  uint64_t *v84;
  uint64_t v85;
  _BYTE v86[24];
  unint64_t v87;
  unint64_t *v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v4 = (KB::String **)((char *)this + 8);
  TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, *((_DWORD *)this + 24), (uint64_t)v82);
  if (KB::String::contains((KB::String *)v82, 0x2019u))
  {
    v77 = 0;
    v78 = 0;
    v79 = "'";
    v76 = 1048577;
    v80 = 0;
    KB::String::replace_char((KB::String *)v82, (const KB::String *)&v76, 8217, (uint64_t)v86);
    KB::String::operator=((uint64_t)v82, (KB::String *)v86);
    if (*(_QWORD *)&v86[8] && v86[6] == 1)
      free(*(void **)&v86[8]);
    if (v79 && v78 == 1)
      free(v79);
  }
  v69 = 0uLL;
  v70 = 0;
  v5 = *(unsigned __int16 *)a2;
  v6 = v82[0];
  if (v5 <= v82[0])
  {
    v7 = (const char *)(v84 ? v84 : &v85);
    v8 = *((_QWORD *)a2 + 1) ? (const char *)*((_QWORD *)a2 + 1) : (char *)a2 + 16;
    if (!strncmp(&v7[v82[0] - v5], v8, v5))
    {
      *(_QWORD *)&v67 = v7;
      DWORD2(v67) = 0;
      HIDWORD(v67) = v6;
      LODWORD(v68) = 0;
      KB::String::iterator::initialize((uint64_t *)&v67);
      KB::String::find((KB::String *)v82, a2, (uint64_t)v65);
      *(_OWORD *)v86 = v67;
      *(_QWORD *)&v86[16] = v68;
      v41 = v66;
      if (DWORD2(v67) == v66)
      {
        v42 = 0;
      }
      else
      {
        v42 = 0;
        do
        {
          ++v42;
          KB::String::iterator::operator++((uint64_t *)v86);
        }
        while (*(_DWORD *)&v86[8] != v41);
      }
      v45 = 0;
      for (i = 0; ; ++i)
      {
        v47 = *((unsigned __int16 *)a2 + 2);
        if (!*((_WORD *)a2 + 2))
        {
          KB::String::compute_length((unsigned __int16 *)a2);
          v47 = *((unsigned __int16 *)a2 + 2);
        }
        if (i >= v47)
          break;
        v48 = v42 + i;
        v49 = *v4;
        v50 = (KB::String *)((char *)*v4 + 40 * v42 + 40 * i);
        if ((unint64_t)v45 >= v70)
        {
          v51 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v45 - v69.i64[0]) >> 3);
          v52 = v51 + 1;
          if (v51 + 1 > 0x666666666666666)
            goto LABEL_110;
          if (0x999999999999999ALL * ((uint64_t)(v70 - v69.i64[0]) >> 3) > v52)
            v52 = 0x999999999999999ALL * ((uint64_t)(v70 - v69.i64[0]) >> 3);
          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v70 - v69.i64[0]) >> 3) >= 0x333333333333333)
            v53 = 0x666666666666666;
          else
            v53 = v52;
          v88 = &v70;
          if (v53)
            v53 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v53);
          else
            v54 = 0;
          v55 = (_DWORD *)(v53 + 40 * v51);
          *(_QWORD *)v86 = v53;
          *(_QWORD *)&v86[8] = v55;
          v87 = v53 + 40 * v54;
          KB::String::String((KB::String *)v55, v50);
          v55[8] = *((_DWORD *)v49 + 10 * v48 + 8);
          v45 = (KB::String *)(v55 + 10);
          *(_QWORD *)&v86[16] = v45;
          v56 = v69.i64[1];
          v57 = v69.i64[0];
          v58 = *(KB::String **)&v86[8];
          if (v69.i64[1] == v69.i64[0])
          {
            v60 = vdupq_n_s64(v69.u64[1]);
          }
          else
          {
            do
            {
              v59 = v58;
              v58 = KB::String::String((KB::String *)((char *)v58 - 40), (const KB::String *)(v56 - 40));
              *((_DWORD *)v59 - 2) = *(_DWORD *)(v56 - 8);
              v56 -= 40;
            }
            while (v56 != v57);
            v60 = v69;
            v45 = *(KB::String **)&v86[16];
          }
          v69.i64[0] = (uint64_t)v58;
          v69.i64[1] = (uint64_t)v45;
          *(int64x2_t *)&v86[8] = v60;
          v61 = v70;
          v70 = v87;
          v87 = v61;
          *(_QWORD *)v86 = v60.i64[0];
          std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)v86);
        }
        else
        {
          KB::String::String(v45, (KB::String *)((char *)*v4 + 40 * v42 + 40 * i));
          *((_DWORD *)v45 + 8) = *((_DWORD *)v49 + 10 * v48 + 8);
          v45 = (KB::String *)((char *)v45 + 40);
        }
        v69.i64[1] = (uint64_t)v45;
      }
    }
  }
  v9 = *((_QWORD *)this + 1);
  for (j = *((_QWORD *)this + 2); j != v9; j -= 40)
  {
    v11 = *(void **)(j - 32);
    if (v11)
    {
      if (*(_BYTE *)(j - 34) == 1)
        free(v11);
    }
  }
  *((_QWORD *)this + 2) = v9;
  KB::String::operator=((TIInputManager *)((char *)this + 32), a2);
  v12 = *((unsigned __int16 *)a2 + 2);
  if (!*((_WORD *)a2 + 2))
  {
    KB::String::compute_length((unsigned __int16 *)a2);
    v12 = *((unsigned __int16 *)a2 + 2);
  }
  std::vector<KB::Input>::reserve(v4, v12);
  v13 = (const KB::String *)v69.i64[1];
  v14 = (const KB::String *)v69.i64[0];
  v15 = 0xCCCCCCCCCCCCCCCDLL * ((v69.i64[1] - v69.i64[0]) >> 3);
  if (v15 == *(unsigned __int16 *)a2)
  {
    if (v4 != (KB::String **)&v69)
    {
      v16 = *((_QWORD *)this + 3);
      v17 = *((_QWORD *)this + 1);
      if (0xCCCCCCCCCCCCCCCDLL * ((v16 - v17) >> 3) < v15)
      {
        if (v17)
        {
          v18 = *((_QWORD *)this + 2);
          v19 = (KB::String *)*((_QWORD *)this + 1);
          if (v18 != v17)
          {
            do
            {
              v20 = *(void **)(v18 - 32);
              if (v20 && *(_BYTE *)(v18 - 34) == 1)
                free(v20);
              v18 -= 40;
            }
            while (v18 != v17);
            v19 = *v4;
          }
          *((_QWORD *)this + 2) = v17;
          operator delete(v19);
          v16 = 0;
          *v4 = 0;
          v4[1] = 0;
          v4[2] = 0;
        }
        v21 = 0xCCCCCCCCCCCCCCCDLL * (v16 >> 3);
        v22 = 2 * v21;
        if (2 * v21 <= v15)
          v22 = v15;
        if (v21 >= 0x333333333333333)
          v23 = 0x666666666666666;
        else
          v23 = v22;
        if (v23 > 0x666666666666666)
LABEL_110:
          abort();
        v24 = (KB::String *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v23);
        *((_QWORD *)this + 1) = v24;
        *((_QWORD *)this + 2) = v24;
        *((_QWORD *)this + 3) = (char *)v24 + 40 * v25;
        while (v14 != v13)
        {
          v26 = KB::String::String(v24, v14);
          *((_DWORD *)v26 + 8) = *((_DWORD *)v14 + 8);
          v14 = (const KB::String *)((char *)v14 + 40);
          v24 = (KB::String *)((char *)v26 + 40);
        }
        goto LABEL_76;
      }
      if (0xCCCCCCCCCCCCCCCDLL * ((*((_QWORD *)this + 2) - v17) >> 3) < v15)
      {
        v43 = (KB::String *)(v69.i64[0] + 8 * ((*((_QWORD *)this + 2) - v17) >> 3));
        std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>((KB::String *)v69.i64[0], v43, *((KB::String **)this + 1));
        v24 = (KB::String *)*((_QWORD *)this + 2);
        while (v43 != v13)
        {
          v44 = KB::String::String(v24, v43);
          *((_DWORD *)v44 + 8) = *((_DWORD *)v43 + 8);
          v43 = (KB::String *)((char *)v43 + 40);
          v24 = (KB::String *)((char *)v44 + 40);
        }
LABEL_76:
        *((_QWORD *)this + 2) = v24;
        goto LABEL_106;
      }
      v62 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>((KB::String *)v69.i64[0], (KB::String *)v69.i64[1], *((KB::String **)this + 1));
      for (k = (KB::String *)*((_QWORD *)this + 2); k != v62; k = (KB::String *)((char *)k - 40))
      {
        v64 = (void *)*((_QWORD *)k - 4);
        if (v64 && *((_BYTE *)k - 34) == 1)
          free(v64);
      }
      *((_QWORD *)this + 2) = v62;
    }
  }
  else
  {
    KB::String::String((KB::String *)&v76, a2);
    v81 = 0;
    while (1)
    {
      v27 = KB::UTF8Iterator::next((KB::UTF8Iterator *)&v76);
      if (!v27)
        break;
      v28 = v27;
      v29 = u_isupper(v27) != 0;
      KB::String::String((uint64_t)v74, v28);
      KB::String::String((KB::String *)v71, (const KB::String *)v74);
      v73 = v29;
      v30 = (KB::String *)*((_QWORD *)this + 2);
      v31 = *((_QWORD *)this + 3);
      if ((unint64_t)v30 >= v31)
      {
        v34 = 0xCCCCCCCCCCCCCCCDLL * ((v30 - *v4) >> 3);
        v35 = v34 + 1;
        if (v34 + 1 > 0x666666666666666)
          goto LABEL_110;
        v36 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v31 - (_QWORD)*v4) >> 3);
        if (2 * v36 > v35)
          v35 = 2 * v36;
        if (v36 >= 0x333333333333333)
          v37 = 0x666666666666666;
        else
          v37 = v35;
        v88 = (unint64_t *)((char *)this + 24);
        if (v37)
          v37 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v37);
        else
          v38 = 0;
        v39 = (KB::String *)(v37 + 40 * v34);
        *(_QWORD *)v86 = v37;
        *(_QWORD *)&v86[8] = v39;
        v87 = v37 + 40 * v38;
        KB::String::String(v39, (const KB::String *)v71);
        *((_DWORD *)v39 + 8) = v73;
        *(_QWORD *)&v86[16] = (char *)v39 + 40;
        std::vector<KB::Input>::__swap_out_circular_buffer(v4, v86);
        v33 = (char *)*((_QWORD *)this + 2);
        std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)v86);
      }
      else
      {
        v32 = KB::String::String(v30, (const KB::String *)v71);
        *((_DWORD *)v32 + 8) = v73;
        v33 = (char *)v32 + 40;
      }
      *((_QWORD *)this + 2) = v33;
      if (v72 && v71[6] == 1)
        free(v72);
      if (v75 && v74[6] == 1)
        free(v75);
    }
    if (v79)
      v40 = v78 == 1;
    else
      v40 = 0;
    if (v40)
      free(v79);
  }
LABEL_106:
  *((_DWORD *)this + 24) = -858993459 * ((*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3);
  KB::String::clear((TIInputManager *)((char *)this + 64));
  *((_BYTE *)this + 680) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_DWORD *)this + 44) = 0;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 23) + 136))(*((_QWORD *)this + 23));
  *(_QWORD *)v86 = &v69;
  std::vector<KB::Input>::__destroy_vector::operator()[abi:nn180100]((void ***)v86);
  if (v84 && v83 == 1)
    free(v84);
}

KB::String **std::vector<KB::Input>::reserve(KB::String **result, unint64_t a2)
{
  KB::String **v2;
  int64_t v3;
  uint64_t v4;
  _QWORD v5[5];

  if (0xCCCCCCCCCCCCCCCDLL * ((result[2] - *result) >> 3) < a2)
  {
    v2 = result;
    v3 = result[1] - *result;
    v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 40 * v4;
    std::vector<KB::Input>::__swap_out_circular_buffer(v2, v5);
    return (KB::String **)std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)v5);
  }
  return result;
}

KB::String *std::vector<KB::Input>::__swap_out_circular_buffer(KB::String **a1, _QWORD *a2)
{
  KB::String *v4;
  KB::String *v5;
  KB::String *v6;
  KB::String *result;
  KB::String *v8;
  KB::String *v9;
  KB::String *v10;

  v4 = *a1;
  v5 = a1[1];
  v6 = (KB::String *)a2[1];
  if (v5 == *a1)
  {
    result = (KB::String *)a2[1];
  }
  else
  {
    do
    {
      result = KB::String::String((KB::String *)((char *)v6 - 40), (KB::String *)((char *)v5 - 40));
      *((_DWORD *)v6 - 2) = *((_DWORD *)v5 - 2);
      v5 = (KB::String *)((char *)v5 - 40);
      v6 = result;
    }
    while (v5 != v4);
  }
  a2[1] = result;
  v8 = *a1;
  *a1 = result;
  a2[1] = v8;
  v9 = a1[1];
  a1[1] = (KB::String *)a2[2];
  a2[2] = v9;
  v10 = a1[2];
  a1[2] = (KB::String *)a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

KB::String *TIInputManager::set_original_input(TIInputManager *this, const KB::String *a2)
{
  return KB::String::operator=((TIInputManager *)((char *)this + 32), a2);
}

void TIInputManager::delete_suffix_from_input(TIInputManager *this, const KB::String *a2)
{
  unsigned int v3;
  unsigned int v5;
  int v6;
  BOOL v7;
  _BOOL4 v8;
  int v10;
  BOOL v11;
  _BYTE v12[8];
  void *v13;
  int v14;
  __int16 v15;
  char v16;
  void *v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v14 = 0x100000;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v3 = *((_DWORD *)this + 24);
  if (v3)
  {
    v5 = 0;
    v6 = -1;
    do
    {
      TIInputManager::input_substring((unsigned __int16 *)this + 4, v3 + v6, ++v5, (uint64_t)v12);
      KB::String::operator=((uint64_t)&v14, (KB::String *)v12);
      if (v13)
        v7 = v12[6] == 1;
      else
        v7 = 0;
      if (v7)
        free(v13);
      v8 = KB::String::equal(a2, (const KB::String *)&v14, 1);
      v3 = *((_DWORD *)this + 24);
      --v6;
    }
    while (v5 < v3 && !v8);
    if (v8)
      v10 = v5;
    else
      v10 = 1;
  }
  else
  {
    v10 = 1;
  }
  do
  {
    TIInputManager::delete_from_input(this);
    --v10;
  }
  while (v10);
  if (v17)
    v11 = v16 == 1;
  else
    v11 = 0;
  if (v11)
    free(v17);
}

void TIInputManager::delete_from_input(TIInputManager *this)
{
  int v1;
  uint64_t v3;
  char *v4;
  unsigned int v5;
  uint64_t v6;
  KB::String *v7;
  KB::String *i;
  void *v9;
  unsigned int v10;
  _BYTE v11[8];
  void *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v1 = *((_DWORD *)this + 24);
  if (v1)
  {
    v3 = *((_QWORD *)this + 23);
    v4 = (char *)this + 432;
    TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, v1, (uint64_t)v11);
    (*(void (**)(uint64_t, char *, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)v3 + 144))(v3, v4, v11, *((unsigned int *)this + 24), -858993459 * ((*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3));
    if (v12 && v11[6] == 1)
      free(v12);
    if (*((_DWORD *)this + 24) && -858993459 * ((*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3))
    {
      KB::String::clear((TIInputManager *)((char *)this + 32));
      v5 = *((_DWORD *)this + 24) - 1;
      *((_DWORD *)this + 24) = v5;
      v6 = *((_QWORD *)this + 1) + 40 * v5;
      v7 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>((KB::String *)(v6 + 40), *((KB::String **)this + 2), (KB::String *)v6);
      for (i = (KB::String *)*((_QWORD *)this + 2); i != v7; i = (KB::String *)((char *)i - 40))
      {
        v9 = (void *)*((_QWORD *)i - 4);
        if (v9 && *((_BYTE *)i - 34) == 1)
          free(v9);
      }
      *((_QWORD *)this + 2) = v7;
      v10 = *((_DWORD *)this + 24);
      *((_DWORD *)this + 44) = v10;
      if (*((_DWORD *)this + 43) > v10)
        *((_DWORD *)this + 43) = v10;
      *((_BYTE *)this + 680) = 1;
      (*(void (**)(_QWORD))(**((_QWORD **)this + 23) + 56))(*((_QWORD *)this + 23));
    }
  }
}

_DWORD *TIInputManager::lock_input(_DWORD *this)
{
  unsigned int v1;
  unsigned int v2;

  v1 = this[24];
  v2 = this[43];
  if (v2 <= v1)
    v2 = this[24];
  if (this[44] < v1)
    v1 = this[44];
  this[43] = v2;
  this[44] = v1;
  return this;
}

void TIInputManager::drop_input_prefix(KB::String **this, unsigned int a2)
{
  char *v3;

  v3 = (char *)(this + 1);
  std::vector<KB::Input>::erase((uint64_t)(this + 1), this[1], (KB::String *)((char *)this[1] + 40 * a2));
  *((_DWORD *)v3 + 22) -= a2;
  *(uint32x2_t *)(v3 + 164) = vqsub_u32(*(uint32x2_t *)(v3 + 164), (uint32x2_t)vdup_n_s32(a2));
  KB::String::clear((KB::String *)(v3 + 56));
}

void std::vector<KB::Input>::erase(uint64_t a1, KB::String *this, KB::String *a3)
{
  KB::String *v4;
  KB::String *i;
  void *v6;

  if (this != a3)
  {
    v4 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>(a3, *(KB::String **)(a1 + 8), this);
    for (i = *(KB::String **)(a1 + 8); i != v4; i = (KB::String *)((char *)i - 40))
    {
      v6 = (void *)*((_QWORD *)i - 4);
      if (v6)
      {
        if (*((_BYTE *)i - 34) == 1)
          free(v6);
      }
    }
    *(_QWORD *)(a1 + 8) = v4;
  }
}

void TIInputManager::clear_shadow_typing(TIInputManager *this)
{
  KB::String::clear((TIInputManager *)((char *)this + 64));
}

void TIInputManager::accept_input(TIInputManager *this)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  _BYTE v5[8];
  void *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *((_DWORD *)this + 24);
  v3 = *((_DWORD *)this + 43);
  if (v3 <= v2)
    v3 = *((_DWORD *)this + 24);
  if (*((_DWORD *)this + 44) < v2)
    v2 = *((_DWORD *)this + 44);
  *((_DWORD *)this + 43) = v3;
  *((_DWORD *)this + 44) = v2;
  TIInputManager::legacy_input_stem(this, (uint64_t)v5);
  KB::String::operator=((uint64_t)this + 64, (KB::String *)v5);
  if (v6)
    v4 = v5[6] == 1;
  else
    v4 = 0;
  if (v4)
    free(v6);
}

uint64_t TIInputManager::set_input_index(TIInputManager *this, unsigned int a2)
{
  unsigned int v2;
  uint64_t v3;

  v2 = -858993459 * ((*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3);
  if (v2 >= a2)
    v2 = a2;
  *((_DWORD *)this + 24) = v2;
  v3 = **((_QWORD **)this + 23);
  if (*((_BYTE *)this + 688))
    return (*(uint64_t (**)(void))(v3 + 64))();
  else
    return (*(uint64_t (**)(void))(v3 + 136))();
}

void TIInputManager::text_accepted(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, uint64_t a4, int a5, uint64_t a6)
{
  unsigned __int16 *v12;
  std::vector<unsigned int>::pointer begin;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  int v20;
  KB::String *v21;
  unint64_t v22;
  KB::String *v23;
  int64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  KB::String *v30;
  KB::String *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  KB::String *v36;
  uint64_t v37;
  KB::String *v38;
  KB::String *v39;
  KB::String *v40;
  int64_t v41;
  KB::String *v42;
  uint64_t v43;
  KB::String *v44;
  KB::String *v45;
  int64x2_t v46;
  char *v47;
  KB::String *v48;
  uint64_t v49;
  const KB::String *v50;
  unint64_t v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  _BOOL4 has_uppercase_characters;
  _BOOL4 v56;
  _BOOL4 v57;
  int v58;
  KB::String *v59;
  uint64_t v60;
  unsigned int v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  unsigned int v66;
  unsigned int v67;
  KB::String *v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  uint64_t v73;
  int v74;
  int v75;
  unsigned int v76;
  std::vector<unsigned int> __p;
  _QWORD v78[3];
  KB::String *v79;
  KB::String *v80[2];
  char *v81;
  uint64_t v82;
  _BYTE v83[8];
  void *v84;
  int v85;
  _BYTE v86[8];
  void *v87;
  _BYTE v88[8];
  void *v89;
  KB::String *v90;
  int64x2_t v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v12 = (unsigned __int16 *)(a1 + 8);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)v88);
  if (a2 != a3 && !KB::String::equal((KB::String *)a2, (const KB::String *)a3, 1))
  {
    KB::String::operator=((KB::String *)(a1 + 64), (KB::String *)v88);
    TIInputManager::input_flags_vector((TIInputManager *)a1, &__p);
    v14 = a3[2];
    if (!a3[2])
    {
      KB::String::compute_length(a3);
      v14 = a3[2];
    }
    v68 = (KB::String *)a3;
    v15 = *(_DWORD *)(a1 + 96);
    if (v15 >= v14)
    {
      v17 = *(_DWORD *)(a1 + 96);
      if (!v14)
      {
        KB::String::compute_length(a3);
        v14 = a3[2];
        v17 = *(_DWORD *)(a1 + 96);
      }
      v16 = v15 - v14;
      v15 = v17;
    }
    else
    {
      v16 = 0;
    }
    std::vector<KB::Input>::erase((uint64_t)v12, (KB::String *)(*(_QWORD *)(a1 + 8) + 40 * v16), (KB::String *)(*(_QWORD *)(a1 + 8) + 40 * v15));
    *(_DWORD *)(a1 + 96) = v16;
    if (*((_QWORD *)a2 + 1))
      v18 = *((_QWORD *)a2 + 1);
    else
      v18 = (uint64_t)(a2 + 8);
    v73 = v18;
    v19 = *a2;
    v74 = 0;
    v75 = v19;
    v76 = 0;
    KB::String::iterator::initialize(&v73);
    v69 = v18;
    v70 = v19;
    v71 = v19;
    v72 = 0;
    KB::String::iterator::initialize(&v69);
    v67 = v16;
    v20 = v16;
    if (v74 != v70)
    {
      v64 = a5;
      v66 = a6;
      do
      {
        KB::String::String((uint64_t)v86, v76);
        v21 = (KB::String *)(*(_QWORD *)(a1 + 8) + 40 * *(unsigned int *)(a1 + 96));
        KB::String::String((KB::String *)v83, (const KB::String *)v86);
        v85 = 0;
        v23 = *(KB::String **)(a1 + 8);
        v22 = *(_QWORD *)(a1 + 16);
        v24 = 0xCCCCCCCCCCCCCCCDLL * ((v21 - v23) >> 3);
        v25 = *(_QWORD *)(a1 + 24);
        if (v22 >= v25)
        {
          v26 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v22 - (_QWORD)v23) >> 3) + 1;
          if (v26 > 0x666666666666666)
            abort();
          v27 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v25 - (_QWORD)v23) >> 3);
          if (2 * v27 > v26)
            v26 = 2 * v27;
          if (v27 >= 0x333333333333333)
            v28 = 0x666666666666666;
          else
            v28 = v26;
          v82 = a1 + 24;
          if (v28)
          {
            v30 = (KB::String *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v28);
          }
          else
          {
            v30 = 0;
            v29 = 0;
          }
          v31 = (KB::String *)((char *)v30 + 8 * ((v21 - v23) >> 3));
          v79 = v30;
          v80[0] = v31;
          v80[1] = v31;
          v81 = (char *)v30 + 40 * v29;
          if (v24 == v29)
          {
            if (v21 - v23 < 1)
            {
              if (v21 == v23)
                v34 = 1;
              else
                v34 = 0x999999999999999ALL * ((v21 - v23) >> 3);
              v35 = v34 >> 2;
              v93 = v82;
              v36 = (KB::String *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v34);
              v38 = v36;
              v39 = (KB::String *)((char *)v36 + 40 * v35);
              v40 = v80[0];
              if (v80[1] == v80[0])
              {
                v46 = vdupq_n_s64((unint64_t)v80[0]);
                v42 = (KB::String *)((char *)v36 + 40 * v35);
              }
              else
              {
                v65 = v37;
                v41 = (v80[1] - v80[0]) / 40;
                v42 = (KB::String *)((char *)v39 + 40 * v41);
                v43 = 40 * v41;
                v44 = v39;
                do
                {
                  v45 = KB::String::String(v44, v40);
                  *((_DWORD *)v45 + 8) = *((_DWORD *)v40 + 8);
                  v44 = (KB::String *)((char *)v45 + 40);
                  v40 = (KB::String *)((char *)v40 + 40);
                  v43 -= 40;
                }
                while (v43);
                v46 = *(int64x2_t *)v80;
                v37 = v65;
              }
              v47 = v81;
              v90 = v79;
              v79 = v38;
              v80[0] = v39;
              v91 = v46;
              v80[1] = v42;
              v81 = (char *)v38 + 40 * v37;
              v92 = v47;
              std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)&v90);
              v31 = v80[1];
              a6 = v66;
            }
            else
            {
              v32 = v24 + 2;
              if (v24 >= -1)
                v32 = v24 + 1;
              v33 = -5 * (v32 >> 1);
              v31 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>(v31, v31, (KB::String *)((char *)v31 - 40 * (v32 >> 1)));
              v80[0] = (KB::String *)((char *)v80[0] + 8 * v33);
              v80[1] = v31;
            }
          }
          v48 = KB::String::String(v31, (const KB::String *)v83);
          *((_DWORD *)v48 + 8) = v85;
          v80[1] = (KB::String *)((char *)v80[1] + 40);
          std::vector<KB::Input>::__swap_out_circular_buffer((uint64_t)v12, &v79, v21);
          std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)&v79);
        }
        else if (v21 == (KB::String *)v22)
        {
          KB::String::String(v21, (const KB::String *)v83);
          *((_DWORD *)v23 + 2 * ((v21 - v23) >> 3) + 8) = v85;
          *(_QWORD *)(a1 + 16) = (char *)v21 + 40;
        }
        else
        {
          std::vector<KB::Input>::__move_range((uint64_t)v12, (uint64_t)v21, v22, (uint64_t)v21 + 40);
          if (v21 != (KB::String *)v83)
          {
            KB::String::operator=(v21, (KB::String *)v83);
            *((_DWORD *)v23 + 2 * ((v21 - v23) >> 3) + 8) = v85;
          }
        }
        if (v84 && v83[6] == 1)
          free(v84);
        ++*(_DWORD *)(a1 + 96);
        if (v87 && v86[6] == 1)
          free(v87);
        KB::String::iterator::operator++(&v73);
      }
      while (v74 != v70);
      v20 = *(_DWORD *)(a1 + 96);
      a5 = v64;
      a4 = a4;
    }
    v49 = *(_QWORD *)(a1 + 184);
    TIInputManager::input_substring(v12, 0, v20, (uint64_t)&v90);
    (*(void (**)(KB::String **__return_ptr, uint64_t, KB::String **, KB::String *, _BYTE *, uint64_t, unsigned __int16 *, uint64_t))(*(_QWORD *)v49 + 104))(&v79, v49, &v90, v68, v88, a4, a2, a6);
    if (v91.i64[0] && BYTE6(v90) == 1)
      free((void *)v91.i64[0]);
    if ((a6 & 1) == 0
      && (KB::String *)(v80[0] - v79) >= (KB::String *)5
      && *((_DWORD *)v80[0] - 1) == -1
      && *((_DWORD *)v80[0] - 2) == -1)
    {
      (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 136))(*(_QWORD *)(a1 + 184));
    }
    if (v67 >= *(_DWORD *)(a1 + 96))
    {
      v59 = v79;
      if (v79)
      {
LABEL_80:
        v80[0] = v59;
        operator delete(v59);
      }
    }
    else
    {
      v51 = v67;
      v52 = a5 & 0xFFFFFFFE;
      v53 = *(_QWORD *)v12;
      v54 = 40 * v67;
      do
      {
        has_uppercase_characters = KB::string_has_uppercase_characters((KB *)(v53 + v54), v50);
        v56 = has_uppercase_characters;
        if (v54)
          v57 = 0;
        else
          v57 = has_uppercase_characters;
        if (((v52 == 2) & a6 & v57) != 0)
          v58 = has_uppercase_characters | 2;
        else
          v58 = has_uppercase_characters;
        v59 = v79;
        if (v51 < (v80[0] - v79) >> 2)
        {
          v60 = *((unsigned int *)v79 + v51);
          if ((_DWORD)v60 != -1)
          {
            v61 = __p.__begin_[v60];
            if (v56)
              v62 = v61 & 0x12;
            else
              v62 = 0;
            v63 = v61 & 0x2C | v58 | v62;
            if ((v58 & ((v61 & 1) == 0)) != 0)
              v58 = v63 | 0x10;
            else
              v58 = v63;
          }
        }
        v53 = *(_QWORD *)(a1 + 8);
        *(_DWORD *)(v53 + v54 + 32) = v58;
        ++v51;
        v54 += 40;
      }
      while (v51 < *(unsigned int *)(a1 + 96));
      if (v59)
        goto LABEL_80;
    }
    begin = __p.__begin_;
    if (__p.__begin_)
      goto LABEL_82;
    goto LABEL_83;
  }
  (*(void (**)(_QWORD *__return_ptr, _QWORD, _BYTE *, unsigned __int16 *, _BYTE *, uint64_t, unsigned __int16 *, uint64_t))(**(_QWORD **)(a1 + 184) + 104))(v78, *(_QWORD *)(a1 + 184), v88, a3, v88, a4, a2, a6);
  begin = (std::vector<unsigned int>::pointer)v78[0];
  if (v78[0])
  {
    v78[1] = v78[0];
LABEL_82:
    operator delete(begin);
  }
LABEL_83:
  LODWORD(v90) = 0x100000;
  WORD2(v90) = 0;
  BYTE6(v90) = 0;
  v91.i64[0] = 0;
  v91.i8[8] = 0;
  KB::String::operator=((KB::String *)(*(_QWORD *)(*(_QWORD *)(a1 + 224) + 24) + 56), (KB::String *)&v90);
  if (v91.i64[0] && BYTE6(v90) == 1)
    free((void *)v91.i64[0]);
  LODWORD(v90) = 0x100000;
  WORD2(v90) = 0;
  BYTE6(v90) = 0;
  v91.i64[0] = 0;
  v91.i8[8] = 0;
  KB::String::operator=((KB::String *)(a1 + 32), (KB::String *)&v90);
  if (v91.i64[0] && BYTE6(v90) == 1)
    free((void *)v91.i64[0]);
  if (v89)
  {
    if (v88[6] == 1)
      free(v89);
  }
}

uint64_t TIInputManager::user_frequency(TIInputManager *this, const KB::String *a2)
{
  return (*(uint64_t (**)(_QWORD, const KB::String *))(**(_QWORD **)(*((_QWORD *)this + 28) + 24) + 64))(*(_QWORD *)(*((_QWORD *)this + 28) + 24), a2);
}

uint64_t TIInputManager::set_autoshift(uint64_t this, int a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;
  int v5;

  v2 = *(_QWORD *)(this + 8);
  if (-858993459 * ((unint64_t)(*(_QWORD *)(this + 16) - v2) >> 3))
  {
    v3 = *(_DWORD *)(v2 + 32);
    v4 = v3 & 0xFFFFFFFD;
    if ((v3 & a2) != 0)
      v5 = 2;
    else
      v5 = 0;
    *(_DWORD *)(v2 + 32) = v5 | v4;
  }
  return this;
}

uint64_t TIInputManager::is_uppercase(TIInputManager *this, unsigned int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  if (-858993459 * ((unint64_t)(*((_QWORD *)this + 2) - v2) >> 3) <= a2)
    return 0;
  else
    return *(_BYTE *)(v2 + 40 * a2 + 32) & 1;
}

BOOL TIInputManager::is_first_character_explicitly_shifted(TIInputManager *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  return -858993459 * ((unint64_t)(*((_QWORD *)this + 2) - v1) >> 3)
      && (*(_DWORD *)(v1 + 32) & 3) == 1;
}

void TIInputManager::autocorrection(uint64_t a1@<X0>, void *a2@<X8>)
{
  const KB::Candidate **v3;
  const KB::Candidate *v4[3];
  uint64_t v5;
  uint64_t v6;
  _BYTE v7[40];
  void *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  (*(void (**)(const KB::Candidate **__return_ptr))(*(_QWORD *)a1 + 16))(v4);
  if (v4[1] == v4[0])
  {
    bzero(a2, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)a2);
  }
  else
  {
    KB::Candidate::Candidate((KB::Candidate *)a2, v4[0]);
  }
  if (v8 && v7[38] == 1)
    free(v8);
  v3 = (const KB::Candidate **)v7;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v3);
  v3 = (const KB::Candidate **)&v6;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v3);
  v3 = (const KB::Candidate **)&v5;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v3);
  v3 = v4;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v3);
}

uint64_t TIInputManager::register_inline_completion_acceptance_rejection(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 88))(*(_QWORD *)(a1 + 184));
}

uint64_t TIInputManager::user_dictionary(TIInputManager *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 28) + 24) + 24);
  if (v1)
    return *(_QWORD *)v1;
  else
    return 0;
}

KB::UserDictionary *TIInputManager::single_character_completions_for_shortcut_prefix@<X0>(KB::UserDictionary *this@<X0>, const KB::String *a2@<X1>, uint64_t a3@<X8>)
{
  KB::UserDictionary **v3;

  v3 = *(KB::UserDictionary ***)(*(_QWORD *)(*((_QWORD *)this + 28) + 24) + 24);
  if (v3)
  {
    this = *v3;
    if (*v3)
      return (KB::UserDictionary *)KB::UserDictionary::single_character_completions_for_shortcut_prefix(this, a2, a3);
  }
  *(_DWORD *)a3 = 0x100000;
  *(_WORD *)(a3 + 4) = 0;
  *(_BYTE *)(a3 + 6) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 16) = 0;
  return this;
}

uint64_t TIInputManager::maximum_shortcut_length(TIInputManager *this)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = *(uint64_t **)(*(_QWORD *)(*((_QWORD *)this + 28) + 24) + 24);
  if (v1 && (v2 = *v1) != 0)
    return *(unsigned int *)(v2 + 88);
  else
    return 0;
}

BOOL TIInputManager::has_user_explicit_shift(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unsigned int v5;
  BOOL v6;
  _BOOL8 result;

  v1 = *a1;
  v2 = a1[1] - *a1;
  if (!v2)
    return 0;
  v3 = 0;
  v4 = v2 >> 2;
  v5 = 1;
  do
  {
    v6 = (*(_DWORD *)(v1 + 4 * v3) & 0x13) == 1;
    result = v6;
    v3 = v5++;
  }
  while (!v6 && v4 > v3);
  return result;
}

void TIInputManager::word_from_supplemental_lexicon(TIInputManager *this@<X0>, _BYTE *a2@<X8>)
{
  KB::DynamicDictionary::word_from_supplemental_lexicon(*(_QWORD *)(*((_QWORD *)this + 28) + 24), a2);
}

uint64_t TIInputManager::apply_custom_conversions(TIInputManager *this, CandidateCollection *a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 68);
  if (result)
    return (*(uint64_t (**)(uint64_t, CandidateCollection *))(*(_QWORD *)result + 64))(result, a2);
  return result;
}

uint64_t TIInputManager::should_correct_explicitly_shifted_word(TIInputManager *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 68);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 40))(v1);
  else
    return 1;
}

uint64_t TIInputManager::should_promote_case_variants_of_top_candidate(TIInputManager *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 68);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

uint64_t TIInputManager::capitalize_first_letter(TIInputManager *this, KB::Word *a2, int a3)
{
  uint64_t v3;

  v3 = *((_QWORD *)this + 68);
  if (v3)
    return (*(uint64_t (**)(uint64_t, KB::Word *))(*(_QWORD *)v3 + 72))(v3, a2);
  else
    return KB::Word::capitalize_first_letter(a2, a3);
}

void TIInputManager::drop_input_prefix_and_update_autocorrection_engine(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 *v8;
  _BYTE v9[6];
  char v10;
  void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 184);
  v7 = a1 + 432;
  v8 = (unsigned __int16 *)(a1 + 8);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)v9);
  (*(void (**)(uint64_t, uint64_t, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)v6 + 144))(v6, v7, v9, *(unsigned int *)(a1 + 96), -858993459 * ((*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3));
  if (v11 && v10 == 1)
    free(v11);
  TIInputManager::input_substring(v8, 0, a2, (uint64_t)v9);
  std::vector<KB::Input>::erase((uint64_t)v8, *(KB::String **)(a1 + 8), (KB::String *)(*(_QWORD *)(a1 + 8) + 40 * a2));
  *(_DWORD *)(a1 + 96) -= a2;
  *(uint32x2_t *)(a1 + 172) = vqsub_u32(*(uint32x2_t *)(a1 + 172), (uint32x2_t)vdup_n_s32(a2));
  KB::String::clear((KB::String *)(a1 + 64));
  (*(void (**)(uint64_t))(a3 + 16))(a3);
  (*(void (**)(_QWORD, uint64_t, uint64_t, _BYTE *))(**(_QWORD **)(a1 + 184) + 128))(*(_QWORD *)(a1 + 184), v7, a2, v9);
  if (v11)
  {
    if (v10 == 1)
      free(v11);
  }
}

uint64_t TIInputManager::input_context(TIInputManager *this)
{
  return (uint64_t)this + 400;
}

uint64_t TIInputManager::set_input_context(TIInputManager *this, const KB::String *a2, const KB::LanguageModelContext *a3)
{
  KB::String::operator=((TIInputManager *)((char *)this + 400), a2);
  return KB::LanguageModelContext::operator=((uint64_t)this + 432, (uint64_t *)a3);
}

void TIInputManager::sync_with_input_from_UI(TIInputManager *this)
{
  uint64_t v2;
  char *v3;
  _BYTE v4[8];
  void *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 23);
  v3 = (char *)this + 432;
  TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, *((_DWORD *)this + 24), (uint64_t)v4);
  (*(void (**)(uint64_t, char *, _BYTE *, _QWORD, _QWORD))(*(_QWORD *)v2 + 144))(v2, v3, v4, *((unsigned int *)this + 24), -858993459 * ((*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3));
  if (v5)
  {
    if (v4[6] == 1)
      free(v5);
  }
}

void TIInputManager::tokenize_input_context(const KB::String *a1@<X1>, _QWORD *a2@<X8>)
{
  BOOL v3;
  int v4;
  __int16 v5;
  char v6;
  void *v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = 0;
  v7 = " \n\t";
  v4 = 1048579;
  v8 = 0;
  KB::string_split_after((unsigned __int16 *)a1, (const KB::String *)&v4, a2);
  if (v7)
    v3 = v6 == 1;
  else
    v3 = 0;
  if (v3)
    free(v7);
}

unsigned int *TIInputManager::set_typing_model(TIInputManager *this, unsigned int **a2)
{
  unsigned int *v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int *result;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int *v17;

  v3 = *a2;
  *a2 = 0;
  v4 = *((_QWORD *)this + 68);
  if (v4)
  {
    v5 = (unsigned int *)*TIInputManager::favonius_layout(this);
    v16 = v5;
    if (v5)
    {
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 + 1, v5));
    }
    (*(void (**)(unsigned int **__return_ptr, uint64_t, unsigned int **))(*(_QWORD *)v4 + 16))(&v17, v4, &v16);
    (*(void (**)(unsigned int *, unsigned int **))(*(_QWORD *)v3 + 24))(v3, &v17);
    if (v17)
    {
      v7 = v17 + 2;
      v8 = atomic_load(v17 + 2);
      if (v8 == 1)
      {
        (*(void (**)(void))(*(_QWORD *)v17 + 8))();
      }
      else
      {
        do
          v9 = __ldaxr(v7);
        while (__stlxr(v9 - 1, v7));
      }
    }
    if (v16)
      WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref((uint64_t)v16);
  }
  v10 = *((_QWORD *)this + 23);
  v15 = v3;
  (*(void (**)(uint64_t, unsigned int **))(*(_QWORD *)v10 + 176))(v10, &v15);
  result = v15;
  if (v15)
  {
    v12 = v15 + 2;
    v13 = atomic_load(v15 + 2);
    if (v13 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v15 + 40))();
    }
    else
    {
      do
        v14 = __ldaxr(v12);
      while (__stlxr(v14 - 1, v12));
    }
  }
  return result;
}

uint64_t TIInputManager::set_candidate_generator(uint64_t a1, unsigned int **a2)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t result;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int *v8;

  v2 = *(_QWORD *)(a1 + 184);
  v3 = *a2;
  *a2 = 0;
  v8 = v3;
  (*(void (**)(uint64_t, unsigned int **))(*(_QWORD *)v2 + 192))(v2, &v8);
  result = (uint64_t)v8;
  if (v8)
  {
    v5 = v8 + 2;
    v6 = atomic_load(v8 + 2);
    if (v6 == 1)
    {
      return (*(uint64_t (**)(void))(*(_QWORD *)v8 + 8))();
    }
    else
    {
      do
        v7 = __ldaxr(v5);
      while (__stlxr(v7 - 1, v5));
    }
  }
  return result;
}

void TIInputManager::set_candidate_refinery(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  v2 = *(_QWORD *)(a1 + 184);
  v3 = (std::__shared_weak_count *)a2[1];
  v9 = *a2;
  v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 208))(v2, &v9);
  v6 = v10;
  if (v10)
  {
    v7 = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

uint64_t TIInputManager::set_search_algorithm(uint64_t a1, unsigned int **a2)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t result;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int *v8;

  v2 = *(_QWORD *)(a1 + 184);
  v3 = *a2;
  *a2 = 0;
  v8 = v3;
  (*(void (**)(uint64_t, unsigned int **))(*(_QWORD *)v2 + 224))(v2, &v8);
  result = (uint64_t)v8;
  if (v8)
  {
    v5 = v8 + 2;
    v6 = atomic_load(v8 + 2);
    if (v6 == 1)
    {
      return (*(uint64_t (**)(void))(*(_QWORD *)v8 + 16))();
    }
    else
    {
      do
        v7 = __ldaxr(v5);
      while (__stlxr(v7 - 1, v5));
    }
  }
  return result;
}

void TIInputManager::set_word_medial_punctuation_predicate(uint64_t a1, void *aBlock)
{
  const void *v4;

  v4 = *(const void **)(a1 + 560);
  if (aBlock)
    _Block_copy(aBlock);
  *(_QWORD *)(a1 + 560) = aBlock;
  if (v4)
    _Block_release(v4);
}

BOOL TIInputManager::candidate_contains_space(TIInputManager *this, const KB::Candidate *a2)
{
  uint64_t v3;
  char *v4;
  char *v5;

  v3 = *((unsigned __int16 *)this + 444);
  if (*((_WORD *)this + 444))
  {
    v4 = (char *)*((_QWORD *)this + 112);
    if (!v4)
      v4 = (char *)this + 904;
  }
  else
  {
    KB::Candidate::compute_string(this);
    v3 = *((unsigned __int16 *)this + 444);
    v4 = (char *)*((_QWORD *)this + 112);
    if (!v4)
      v4 = (char *)this + 904;
    if (!*((_WORD *)this + 444))
    {
      v5 = v4;
      return v5 - v4 != v3;
    }
  }
  v5 = v4;
  while (*v5 != 32)
  {
    if (++v5 == &v4[v3])
    {
      v5 = &v4[v3];
      return v5 - v4 != v3;
    }
  }
  return v5 - v4 != v3;
}

uint64_t TIInputManager::period_ends_sentence_after_word(TIInputManager *this, const KB::String *a2, uint64_t a3)
{
  uint64_t v6;
  KB::Word *v7;
  uint64_t i;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  const KB::String *v13;
  int v14;
  uint64_t v15;
  KB::Word *v16;
  int v17;
  char v18;
  char v19;
  char v20;
  BOOL v21;
  int v22;
  BOOL v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  KB::Word *v28;
  KB::Word *v29;
  KB::Word **v30;
  uint64_t v31;

  KB::DictionaryContainer::lookup(*((_QWORD *)this + 28), a2, 0, 1, (uint64_t *)&v28);
  v6 = (uint64_t)v28;
  v7 = v29;
  if (v28 != v29)
  {
    while (1)
    {
      v30 = (KB::Word **)&off_1EA103EF8;
      v31 = 1;
      if (!KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)&v30, (const KB::String *)v6, a2, 0, 0))break;
      v6 += 240;
      if ((KB::Word *)v6 == v7)
      {
        v6 = (uint64_t)v7;
        goto LABEL_10;
      }
    }
    if ((KB::Word *)v6 != v7)
    {
      for (i = v6 + 240; (KB::Word *)i != v7; i += 240)
      {
        v30 = (KB::Word **)&off_1EA103EF8;
        v31 = 1;
        if (KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)&v30, (const KB::String *)i, a2, 0, 0))
        {
          KB::String::operator=(v6, (KB::String *)i);
          KB::ByteString::operator=((unsigned __int16 *)(v6 + 32), (unsigned __int16 *)(i + 32));
          v9 = *(_QWORD *)(i + 48);
          *(_DWORD *)(v6 + 56) = *(_DWORD *)(i + 56);
          *(_QWORD *)(v6 + 48) = v9;
          KB::String::operator=(v6 + 64, (KB::String *)(i + 64));
          v10 = *(_OWORD *)(i + 96);
          v11 = *(_OWORD *)(i + 112);
          v12 = *(_OWORD *)(i + 144);
          *(_OWORD *)(v6 + 128) = *(_OWORD *)(i + 128);
          *(_OWORD *)(v6 + 144) = v12;
          *(_OWORD *)(v6 + 96) = v10;
          *(_OWORD *)(v6 + 112) = v11;
          KB::String::operator=(v6 + 160, (KB::String *)(i + 160));
          *(_BYTE *)(v6 + 192) = *(_BYTE *)(i + 192);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(v6 + 200, (uint64_t *)(i + 200));
          v6 += 240;
        }
      }
    }
  }
LABEL_10:
  std::vector<KB::Word>::erase((uint64_t)&v28, v6, v29);
  if (v28 == v29)
  {
    v24 = 1;
  }
  else
  {
    v14 = KB::string_capitalization(a2, v13);
    v15 = (uint64_t)v28;
    v16 = v29;
    if (v28 == v29)
    {
      v26 = 0;
      goto LABEL_30;
    }
    v17 = v14;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    do
    {
      v21 = (a3 & 1) != 0 || *(_DWORD *)(v15 + 120) == v17;
      if ((*(_BYTE *)(v15 + 104) & 0x40) == 0)
      {
        v22 = KB::String::last((KB::String *)v15);
        v23 = v22 != 46 && v21;
        v19 |= v23;
        v18 |= v22 != 46;
      }
      v20 |= v21;
      v15 += 240;
    }
    while ((KB::Word *)v15 != v16);
    if ((v20 & 1) != 0)
      v24 = v19;
    else
      v24 = v18;
  }
  v25 = *((_QWORD *)this + 68);
  v26 = (v25 == 0) & v24;
  if (v25 && (v24 & 1) != 0)
    v26 = (*(uint64_t (**)(uint64_t, const KB::String *, uint64_t))(*(_QWORD *)v25 + 32))(v25, a2, a3);
LABEL_30:
  v30 = &v28;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v30);
  return v26;
}

uint64_t TIInputManager::set_candidate_filter_for_key(uint64_t a1, __int128 *a2, const KB::String *a3)
{
  uint64_t v4;

  v4 = KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::operator[](a1 + 632, a3);
  return std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100](v4, a2);
}

_BYTE *TIInputManager::set_uses_text_checker(_BYTE *this, int a2)
{
  this[686] = a2;
  if (a2)
    return _text_checker(1);
  return this;
}

BOOL TIInputManager::has_continuous_path(TIInputManager *this)
{
  return *((_DWORD *)this + 98) >= 0;
}

uint64_t TIInputManager::has_unfinished_continuous_path(TIInputManager *this)
{
  return *((unsigned __int8 *)this + 396);
}

void TIInputManager::clear_continuous_path(TIInputManager *this)
{
  (*(void (**)(_QWORD))(**((_QWORD **)this + 23) + 352))(*((_QWORD *)this + 23));
  *((_DWORD *)this + 98) = -1;
  KB::ContinuousPathDetector::clear_completed_paths((uint64_t **)this + 41);
}

uint64_t TIInputManager::add_touch(uint64_t a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, int a6, uint64_t a7, double a8, double a9, double a10, float a11)
{
  uint64_t v22;
  int v23;
  uint64_t *v24;
  uint64_t v25;
  unsigned int *v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  _BOOL8 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v39;
  CFStringRef v40;
  CFStringRef appendedString;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned __int16 v45[3];
  char v46;
  void *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 256)
    || (v35 = *(_QWORD *)(a1 + 320)) == 0
    || ((*(_QWORD *)(v35 + 16) - *(_QWORD *)(v35 + 8)) & 0x7FFFFFFF8) != 0)
  {
    v22 = *(_QWORD *)(a1 + 184);
    TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)v45);
    (*(void (**)(uint64_t, uint64_t, unsigned __int16 *, _QWORD, _QWORD))(*(_QWORD *)v22 + 144))(v22, a1 + 432, v45, *(unsigned int *)(a1 + 96), -858993459 * ((*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3));
    if (v47 && v46 == 1)
      free(v47);
    if (a4 <= 7)
      v23 = a4 > 1;
    else
      v23 = 2;
    v24 = TIInputManager::favonius_layout((TIInputManager *)a1);
    v25 = operator new();
    *(_DWORD *)v25 = 1;
    *(double *)(v25 + 8) = a8;
    *(double *)(v25 + 16) = a9;
    *(float *)(v25 + 24) = a11;
    *(double *)(v25 + 32) = a10;
    *(_DWORD *)(v25 + 40) = a2;
    *(_DWORD *)(v25 + 44) = a6;
    *(_DWORD *)(v25 + 48) = a3;
    *(_DWORD *)(v25 + 52) = v23;
    v26 = (unsigned int *)*v24;
    *(_QWORD *)(v25 + 56) = *v24;
    if (v26)
    {
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 + 1, v26));
    }
    v44 = v25;
    if (a2 > 1)
    {
      if (a2 == 2)
      {
        v31 = *(_QWORD *)(a1 + 184);
        v42 = v25;
        do
          v32 = __ldaxr((unsigned int *)v25);
        while (__stlxr(v32 + 1, (unsigned int *)v25));
        v30 = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v31 + 32))(v31, &v42, a5, a7);
        if (v42)
          WTF::RefCounted<TI::Favonius::Touch>::deref(v42);
        *(_BYTE *)(a1 + 396) = 0;
        v33 = *(_QWORD *)(a1 + 568);
        if (v33)
        {
          v34 = KB::ContinuousPathDetector::looks_like_continuous_path((KB::ContinuousPathDetector *)(a1 + 328), *(_DWORD *)(v44 + 48));
          (*(void (**)(uint64_t, _QWORD, _BOOL8))(*(_QWORD *)v33 + 16))(v33, *(_QWORD *)(a1 + 184), v34);
        }
      }
      else
      {
        v30 = 0xFFFFFFFFLL;
        if (a2 - 3 <= 1)
        {
          v36 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 184) + 40))(*(_QWORD *)(a1 + 184), a3);
          *(_DWORD *)(a1 + 392) = -1;
          *(_BYTE *)(a1 + 396) = 0;
          v30 = v36;
        }
      }
    }
    else
    {
      v28 = *(_QWORD *)(a1 + 184);
      v43 = v25;
      do
        v29 = __ldaxr((unsigned int *)v25);
      while (__stlxr(v29 + 1, (unsigned int *)v25));
      v30 = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v28 + 24))(v28, &v43, a5, a7);
      if (v43)
        WTF::RefCounted<TI::Favonius::Touch>::deref(v43);
    }
    if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 288))(*(_QWORD *)(a1 + 184)))
    {
      KB::ContinuousPathDetector::observe_touch_event((_QWORD **)(a1 + 328), &v44, v30, a5);
      v37 = v44;
      if (KB::ContinuousPathDetector::looks_like_continuous_path((KB::ContinuousPathDetector *)(a1 + 328), *(_DWORD *)(v44 + 48)))
      {
        *(_DWORD *)(a1 + 392) = a3;
        if (a2 == 1)
        {
          *(_BYTE *)(a1 + 396) = 1;
          v30 = 4294967294;
          goto LABEL_32;
        }
        v30 = 4294967294;
      }
      else
      {
        *(_DWORD *)(a1 + 392) = -1;
      }
      if (a2 == 2 && *(_QWORD *)(a1 + 568))
      {
        KB::ContinuousPathDetector::description((KB::ContinuousPathDetector *)(a1 + 328), (uint64_t)v45);
        KB::String::append(v45, "\n", 0xFFFFuLL);
        v39 = *(_QWORD *)(a1 + 568);
        KB::cf_string_impl<KB::String>(&appendedString, v45);
        v40 = appendedString;
        if (appendedString)
        {
          CFStringAppend(*(CFMutableStringRef *)(v39 + 8), appendedString);
          CFRelease(v40);
        }
        if (v47 && v46 == 1)
          free(v47);
      }
      goto LABEL_32;
    }
    v37 = v44;
    if (!v44)
      return v30;
LABEL_32:
    WTF::RefCounted<TI::Favonius::Touch>::deref(v37);
    return v30;
  }
  return a5;
}

uint64_t TIInputManager::delete_from_favonius_stroke_history(TIInputManager *this)
{
  uint64_t v1;
  uint64_t *v2;

  v1 = *((_QWORD *)this + 23);
  v2 = TIInputManager::favonius_layout(this);
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v1 + 96))(v1, v2);
}

uint64_t TIInputManager::set_key_layout(uint64_t a1, unsigned int **a2)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 320);
  *(_QWORD *)(a1 + 320) = 0;
  if (v4)
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v4);
  v5 = *a2;
  if (*a2)
  {
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 + 1, v5));
  }
  result = *(_QWORD *)(a1 + 320);
  *(_QWORD *)(a1 + 320) = v5;
  if (result)
    return WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(result);
  return result;
}

uint64_t TIInputManager::set_layout_uses_two_hands(uint64_t this, char a2)
{
  uint64_t v2;

  *(_BYTE *)(this + 280) = a2;
  v2 = *(_QWORD *)(this + 320);
  if (v2)
    *(_BYTE *)(v2 + 112) = a2;
  return this;
}

TI::Favonius::FavoniusStrokeBuildManager *TIInputManager::candidates_for_string@<X0>(uint64_t a1@<X0>, const KB::String *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  TI::Favonius::FavoniusStrokeBuildManager *result;
  TI::Favonius::FavoniusStrokeBuildManager *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  BOOL v16;
  __int128 v17;
  void *__p[2];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  TI::Favonius::FavoniusStrokeBuildManager *v24;
  int v25;
  void **v26;
  _BYTE v27[24];
  _BYTE *v28;
  int v29;
  __int16 v30;
  char v31;
  void *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v25 = a3;
  result = TIInputManager::create_autocorrection_engine_with_synthetic_typing((const KB::String **)a1, a2, &v24);
  v8 = v24;
  if (!v24)
  {
    *(_DWORD *)(a4 + 100) = 0;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 80) = 0u;
    return result;
  }
  v9 = *(_QWORD *)(a1 + 568);
  if (v9)
    (*(void (**)(uint64_t, TI::Favonius::FavoniusStrokeBuildManager *, BOOL))(*(_QWORD *)v9 + 16))(v9, v24, *(_QWORD *)(a1 + 224) != 0);
  v29 = 0x100000;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v23 = 0;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  *(_OWORD *)__p = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v21);
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v21 + 8));
  v22 = 0uLL;
  v23 = 0;
  v10 = operator new(0x28uLL);
  *v10 = &off_1EA0FDB08;
  v10[1] = a1;
  v10[2] = a2;
  v10[3] = &v29;
  v10[4] = &v25;
  v28 = v10;
  v11 = 4;
  (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, const KB::String *, __int128 *, uint64_t, int *, uint64_t, _BYTE *))(*(_QWORD *)v8 + 72))(v8, a2, &v17, 12, &v29, 4, v27);
  v12 = v28;
  if (v28 == v27)
  {
    v12 = v27;
    goto LABEL_9;
  }
  if (v28)
  {
    v11 = 5;
LABEL_9:
    (*(void (**)(_QWORD *))(*v12 + 8 * v11))(v12);
  }
  v26 = (void **)&v22;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v26);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v21 + 8));
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v21);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v32)
    v16 = v31 == 1;
  else
    v16 = 0;
  if (v16)
    free(v32);
  result = v24;
  if (v24)
    return (TI::Favonius::FavoniusStrokeBuildManager *)(*(uint64_t (**)(TI::Favonius::FavoniusStrokeBuildManager *))(*(_QWORD *)v24 + 8))(v24);
  return result;
}

void std::__function::__func<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0,std::allocator<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0,std::allocator<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1EA0FDB08;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0,std::allocator<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FDB08;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0,std::allocator<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  const KB::Candidate **v6;
  const KB::Candidate **v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  _BYTE *v11;
  unsigned int *v12;
  int64_t v13;
  char *v14;
  CFMutableStringRef Mutable;
  char v16;
  uint64_t v17;
  unsigned int v18;
  char *v19;
  char *v20;
  int64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  const void *v26;
  int v27;
  unsigned int *v28;
  unsigned int v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  const KB::String *v36;
  int v37;
  const KB::String *v38;
  const KB::String *v39;
  uint64_t v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  void *v48;
  __int128 v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  unsigned int *v52;
  void **v53[8];
  char v54[8];
  std::__shared_weak_count *v55;
  void *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  char *v62;
  char *v63;
  _BYTE v64[24];
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  uint64_t v73;
  void *v74[4];
  void *__p;
  void *__dst;
  uint64_t v77;
  uint64_t v78;
  std::__shared_weak_count *v79;
  CFTypeRef cf;
  uint64_t v81;
  void *v82;
  uint64_t v83;
  _BYTE v84[1000];
  _BYTE v85[8];
  void *v86;
  _BYTE v87[1000];
  char v88;
  _BYTE v89[80];
  void **v90[396];
  char v91;
  _BYTE v92[1000];
  _BYTE v93[1000];
  char v94;
  _BYTE v95[1000];
  uint64_t v96;
  void *v97;
  char v98;
  uint64_t v99;

  v5 = MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5);
  v7 = v6;
  v8 = v5;
  v99 = *MEMORY[0x1E0C80C00];
  v48 = *(void **)v10;
  v9 = v48;
  v49 = *(_OWORD *)(v10 + 8);
  v11 = (_BYTE *)v49;
  *(_QWORD *)(v10 + 8) = 0;
  *(_QWORD *)(v10 + 16) = 0;
  *(_QWORD *)v10 = 0;
  v12 = *(unsigned int **)(v5 + 8);
  __dst = 0;
  v77 = 0;
  __p = 0;
  v13 = v11 - v9;
  if (v11 != v9)
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](&__p, v13 >> 3);
    v14 = (char *)__dst;
    memmove(__dst, v9, v13);
    __dst = &v14[v13];
  }
  (*(void (**)(uint64_t *__return_ptr, unsigned int *, uint64_t, void **))(*(_QWORD *)v12 + 48))(&v78, v12, 4, &__p);
  if (__p)
  {
    __dst = __p;
    operator delete(__p);
  }
  if (v78)
  {
    if (*((_QWORD *)v12 + 71))
      Mutable = CFStringCreateMutable(0, 0);
    else
      Mutable = 0;
    (*(void (**)(uint64_t *__return_ptr, unsigned int *, _QWORD))(*(_QWORD *)v12 + 72))(&v96, v12, *(_QWORD *)(v8 + 16));
    KB::Candidate::Candidate((KB::Candidate *)v95, *(const KB::String **)(v8 + 16), v12[62]);
    v16 = v98;
    if (v98)
    {
      KB::Candidate::Candidate((KB::Candidate *)v93, (const KB::String *)&v96, v12[62]);
      v16 = 1;
    }
    else
    {
      v93[0] = 0;
    }
    v94 = v16;
    v17 = *(_QWORD *)(v8 + 16);
    v18 = *(unsigned __int16 *)(v17 + 4);
    if (*(_WORD *)(v17 + 4)
      || (KB::String::compute_length(*(unsigned __int16 **)(v8 + 16)),
          v18 = *(unsigned __int16 *)(v17 + 4),
          *(_WORD *)(v17 + 4)))
    {
      v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v18);
      bzero(v19, 4 * v18);
      v20 = &v19[4 * v18];
    }
    else
    {
      v20 = 0;
      v19 = 0;
    }
    v70 = 0u;
    v71 = 0u;
    v68 = 0u;
    v69 = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v72);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v73);
    memset(v74, 0, 24);
    bzero(v92, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)v92);
    KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v64, v7);
    KB::Candidate::Candidate((KB::Candidate *)v89, (const KB::Candidate *)v95);
    v87[0] = 0;
    v88 = 0;
    if (v94)
    {
      KB::Candidate::Candidate((KB::Candidate *)v87, (const KB::Candidate *)v93);
      v88 = 1;
    }
    v61 = 0;
    v62 = 0;
    v63 = 0;
    v21 = v20 - v19;
    if (v21)
    {
      if (v21 < 0)
        abort();
      v61 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v21 >> 2);
      v63 = (char *)v61 + 4 * v22;
      memmove(v61, v19, v21);
      v62 = (char *)v61 + v21;
    }
    KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v54, (const KB::LanguageModelContext *)&v68);
    KB::String::String((KB::String *)v85, *(const KB::String **)(v8 + 24));
    KB::Candidate::Candidate((KB::Candidate *)v84, (const KB::Candidate *)v92);
    KB::CandidateFilterLookupContext::CandidateFilterLookupContext((uint64_t)v90, (uint64_t)v89, (const KB::Candidate *)v87, (uint64_t)&v61, (uint64_t)v54, (KB::String *)v85, (uint64_t)v84, 4);
    KB::Candidate::~Candidate((KB::Candidate *)v84);
    if (v86 && v85[6] == 1)
      free(v86);
    v53[0] = (void **)&v60;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v53);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v59);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v58);
    if (v56)
    {
      v57 = v56;
      operator delete(v56);
    }
    v23 = v55;
    if (v55)
    {
      p_shared_owners = (unint64_t *)&v55->__shared_owners_;
      do
        v25 = __ldaxr(p_shared_owners);
      while (__stlxr(v25 - 1, p_shared_owners));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    if (v61)
    {
      v62 = (char *)v61;
      operator delete(v61);
    }
    if (v88)
      KB::Candidate::~Candidate((KB::Candidate *)v87);
    KB::Candidate::~Candidate((KB::Candidate *)v89);
    v91 = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
    v26 = (const void *)*((_QWORD *)v12 + 17);
    v27 = v12[62];
    v28 = (unsigned int *)*((_QWORD *)v12 + 28);
    v52 = v28;
    if (v28)
    {
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 + 1, v28));
    }
    v30 = (std::__shared_weak_count *)*((_QWORD *)v12 + 30);
    v50 = *((_QWORD *)v12 + 29);
    v51 = v30;
    if (v30)
    {
      v31 = (unint64_t *)&v30->__shared_owners_;
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
    }
    KB::CandidateFilterResources::CandidateFilterResources((uint64_t)v53, v26, v27, (uint64_t *)&v52, (uint64_t)&v50, *((const void **)v12 + 70), (uint64_t)(v12 + 148), Mutable);
    v33 = v51;
    if (v51)
    {
      v34 = (unint64_t *)&v51->__shared_owners_;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    if (v52)
      WTF::RefCounted<KB::DictionaryContainer>::deref(v52);
    (*(void (**)(uint64_t, const KB::Candidate **, void ***, void ***))(*(_QWORD *)v78 + 24))(v78, v7, v90, v53);
    v82 = 0;
    v81 = 0;
    v83 = 0;
    TIInputManager::apply_case_changes((uint64_t)v12, (uint64_t)v7, (unsigned __int16 *)&v81, 0, **(unsigned int **)(v8 + 32), 0);
    cf = &v81;
    std::vector<KB::Input>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
    TIInputManager::apply_shortcut_conversions((TIInputManager *)v12, (KB::CandidateCollection *)v7, v36, 0);
    if (*((_QWORD *)v12 + 71))
    {
      v37 = KB::CandidateFilterFlags::candidate_filter_flag_type((unsigned int **)&v48);
      v38 = (const KB::String *)&kGenericFlagDesc;
      if (v37 == 1)
        v38 = (const KB::String *)&kPostLMFlagDesc;
      if (v37)
        v39 = v38;
      else
        v39 = (const KB::String *)&kPreLMFlagDesc;
      KB::String::String((KB::String *)&v81, v39);
      v40 = *((_QWORD *)v12 + 71);
      v41 = *(_QWORD *)(v8 + 16);
      cf = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, _BYTE *, CFMutableStringRef, const KB::Candidate **, CFTypeRef *))(*(_QWORD *)v40 + 24))(v40, v41, 4, &v81, v64, Mutable, v7, &cf);
      if (cf)
        CFRelease(cf);
      cf = 0;
      if (v82 && BYTE6(v81) == 1)
        free(v82);
    }
    KB::CandidateFilterResources::~CandidateFilterResources((KB::CandidateFilterResources *)v53);
    KB::CandidateFilterLookupContext::~CandidateFilterLookupContext((KB::CandidateFilterLookupContext *)v90);
    v90[0] = (void **)&v67;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v90);
    v90[0] = (void **)&v66;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v90);
    v90[0] = (void **)&v65;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v90);
    v90[0] = (void **)v64;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v90);
    KB::Candidate::~Candidate((KB::Candidate *)v92);
    v90[0] = v74;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v90);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v73);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v72);
    if ((_QWORD)v69)
    {
      *((_QWORD *)&v69 + 1) = v69;
      operator delete((void *)v69);
    }
    v42 = (std::__shared_weak_count *)*((_QWORD *)&v68 + 1);
    if (*((_QWORD *)&v68 + 1))
    {
      v43 = (unint64_t *)(*((_QWORD *)&v68 + 1) + 8);
      do
        v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
      }
    }
    if (v19)
      operator delete(v19);
    if (v94)
      KB::Candidate::~Candidate((KB::Candidate *)v93);
    KB::Candidate::~Candidate((KB::Candidate *)v95);
    if (v98 && v97 && BYTE6(v96) == 1)
      free(v97);
    if (Mutable)
      CFRelease(Mutable);
  }
  v45 = v79;
  if (v79)
  {
    v46 = (unint64_t *)&v79->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  if (v48)
    operator delete(v48);
}

TI::Favonius::FavoniusStrokeBuildManager *TIInputManager::predictions_for_string(TIInputManager *a1, unsigned __int16 *a2, unsigned int a3)
{
  TI::Favonius::FavoniusStrokeBuildManager *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  TI::Favonius::FavoniusStrokeBuildManager *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  BOOL v18;
  TI::Favonius::FavoniusStrokeBuildManager *result;
  __int128 v20;
  void *__p[2];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  TI::Favonius::FavoniusStrokeBuildManager *v27;
  unsigned int v28;
  void **v29;
  _BYTE v30[24];
  _BYTE *v31;
  void **v32;
  void *v33;
  char v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v28 = a3;
  TIInputManager::create_autocorrection_engine(a1, &v27);
  v5 = v27;
  (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *))(*(_QWORD *)v27 + 136))(v27);
  v26 = 0;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  *(_OWORD *)__p = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v24);
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v24 + 8));
  v25 = 0uLL;
  v26 = 0;
  if (!a2[2])
  {
    KB::String::compute_length(a2);
    if (!a2[2])
      KB::String::compute_length(a2);
  }
  (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, __int128 *, unsigned __int16 *))(*(_QWORD *)v5 + 144))(v5, &v20, a2);
  v32 = (void **)&v25;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v32);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v24 + 8));
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v24);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v6 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
  if (*((_QWORD *)&v20 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = *((_QWORD *)a1 + 71);
  v10 = v27;
  if (v9)
    (*(void (**)(uint64_t, TI::Favonius::FavoniusStrokeBuildManager *, BOOL))(*(_QWORD *)v9 + 16))(v9, v27, *((_QWORD *)a1 + 28) != 0);
  LODWORD(v32) = 0x100000;
  WORD2(v32) = 0;
  BYTE6(v32) = 0;
  v33 = 0;
  v34 = 0;
  v26 = 0;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  *(_OWORD *)__p = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v24);
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v24 + 8));
  v25 = 0uLL;
  v26 = 0;
  v11 = v28;
  v12 = operator new(0x28uLL);
  *v12 = &off_1EA0FDB50;
  v12[1] = a1;
  v12[2] = &v28;
  v12[3] = a2;
  v12[4] = &v32;
  v31 = v12;
  v13 = 4;
  (*(void (**)(TI::Favonius::FavoniusStrokeBuildManager *, unsigned __int16 *, __int128 *, uint64_t, void ***, uint64_t, _BYTE *))(*(_QWORD *)v10 + 72))(v10, a2, &v20, 4, &v32, v11, v30);
  v14 = v31;
  if (v31 == v30)
  {
    v14 = v30;
  }
  else
  {
    if (!v31)
      goto LABEL_18;
    v13 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v13))();
LABEL_18:
  v29 = (void **)&v25;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v29);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v24 + 8));
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v24);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  v15 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
  if (*((_QWORD *)&v20 + 1))
  {
    v16 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v33)
    v18 = BYTE6(v32) == 1;
  else
    v18 = 0;
  if (v18)
    free(v33);
  result = v27;
  if (v27)
    return (TI::Favonius::FavoniusStrokeBuildManager *)(*(uint64_t (**)(TI::Favonius::FavoniusStrokeBuildManager *))(*(_QWORD *)v27 + 8))(v27);
  return result;
}

void std::__function::__func<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0,std::allocator<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0,std::allocator<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1EA0FDB50;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0,std::allocator<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FDB50;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0,std::allocator<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  const KB::Candidate **v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  int64_t v13;
  char *v14;
  CFMutableStringRef Mutable;
  char v16;
  uint64_t v17;
  unsigned int v18;
  char *v19;
  char *v20;
  const void *v21;
  int v22;
  unsigned int *v23;
  unsigned int v24;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  int v31;
  int64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  unsigned int v38;
  unsigned __int16 *v39;
  const void *v40;
  int v41;
  uint64_t v42;
  KB::String *v43;
  _DWORD *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  KB::String *v49;
  uint64_t v50;
  uint64_t v51;
  KB::String *v52;
  KB::String *v53;
  int64x2_t v54;
  unint64_t v55;
  unsigned int v56;
  void **v57;
  int v58;
  uint64_t v59;
  KB::CandidateCollection *v60;
  const KB::String *v61;
  int v62;
  const KB::String *v63;
  const KB::String *v64;
  uint64_t v65;
  uint64_t v66;
  CFTypeRef v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  uint64_t v74;
  _BYTE *v75;
  const KB::Candidate **v76;
  void *v77;
  __int128 v78;
  uint64_t v79;
  int v80;
  int v81;
  int v82;
  CFTypeRef v83;
  int v84;
  int v85;
  unsigned int v86;
  int64x2_t v87;
  unint64_t v88;
  char v89[8];
  std::__shared_weak_count *v90;
  void *v91;
  void *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  void *v96;
  char *v97;
  char *v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  uint64_t v103;
  uint64_t v104;
  _QWORD v105[4];
  _BYTE v106[24];
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  std::__shared_weak_count *v111;
  unsigned int *v112;
  _BYTE v113[64];
  void *__p;
  void *__dst;
  uint64_t v116;
  uint64_t v117;
  std::__shared_weak_count *v118;
  CFTypeRef cf;
  void *v120;
  _BYTE v121[1000];
  _BYTE v122[8];
  void *v123;
  _BYTE v124[1000];
  char v125;
  _BYTE v126[1000];
  void **v127[396];
  BOOL v128;
  char v129;
  _BYTE v130[1000];
  _BYTE v131[1000];
  char v132;
  _BYTE v133[1000];
  uint64_t v134;
  void *v135;
  char v136;
  int64x2_t *v137;
  int64x2_t v138;
  unint64_t v139;
  unint64_t *v140;
  uint64_t v141;

  v5 = MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5);
  v76 = v6;
  v7 = v5;
  v141 = *MEMORY[0x1E0C80C00];
  v77 = *(void **)v9;
  v8 = v77;
  v78 = *(_OWORD *)(v9 + 8);
  v10 = (_BYTE *)v78;
  *(_QWORD *)(v9 + 8) = 0;
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)v9 = 0;
  v11 = *(_QWORD *)(v5 + 8);
  v12 = **(unsigned int **)(v5 + 16);
  v116 = 0;
  __p = 0;
  __dst = 0;
  v13 = v10 - v8;
  if (v10 != v8)
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](&__p, v13 >> 3);
    v14 = (char *)__dst;
    memmove(__dst, v8, v13);
    __dst = &v14[v13];
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, void **))(*(_QWORD *)v11 + 48))(&v117, v11, v12, &__p);
  if (__p)
  {
    __dst = __p;
    operator delete(__p);
  }
  if (v117)
  {
    if (*(_QWORD *)(v11 + 568))
      Mutable = CFStringCreateMutable(0, 0);
    else
      Mutable = 0;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v11 + 72))(&v134, v11, *(_QWORD *)(v7 + 24));
    KB::Candidate::Candidate((KB::Candidate *)v133, *(const KB::String **)(v7 + 24), *(_DWORD *)(v11 + 248));
    v16 = v136;
    if (v136)
    {
      KB::Candidate::Candidate((KB::Candidate *)v131, (const KB::String *)&v134, *(_DWORD *)(v11 + 248));
      v16 = 1;
    }
    else
    {
      v131[0] = 0;
    }
    v132 = v16;
    v17 = *(_QWORD *)(v7 + 24);
    v18 = *(unsigned __int16 *)(v17 + 4);
    if (*(_WORD *)(v17 + 4)
      || (KB::String::compute_length(*(unsigned __int16 **)(v7 + 24)),
          v18 = *(unsigned __int16 *)(v17 + 4),
          *(_WORD *)(v17 + 4)))
    {
      v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v18);
      bzero(v19, 4 * v18);
      v75 = v19;
      v20 = &v19[4 * v18];
    }
    else
    {
      v20 = 0;
      v75 = 0;
    }
    v21 = *(const void **)(v11 + 136);
    v22 = *(_DWORD *)(v11 + 248);
    v23 = *(unsigned int **)(v11 + 224);
    v112 = v23;
    if (v23)
    {
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 + 1, v23));
    }
    v25 = *(std::__shared_weak_count **)(v11 + 240);
    v110 = *(_QWORD *)(v11 + 232);
    v111 = v25;
    if (v25)
    {
      p_shared_owners = (unint64_t *)&v25->__shared_owners_;
      do
        v27 = __ldxr(p_shared_owners);
      while (__stxr(v27 + 1, p_shared_owners));
    }
    KB::CandidateFilterResources::CandidateFilterResources((uint64_t)v113, v21, v22, (uint64_t *)&v112, (uint64_t)&v110, *(const void **)(v11 + 560), v11 + 592, Mutable);
    v28 = v111;
    if (v111)
    {
      v29 = (unint64_t *)&v111->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    if (v112)
      WTF::RefCounted<KB::DictionaryContainer>::deref(v112);
    KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v106, v76);
    v101 = 0u;
    v102 = 0u;
    v99 = 0u;
    v100 = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v103);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v104);
    memset(v105, 0, 24);
    bzero(v130, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)v130);
    v31 = KB::String::last((KB::String *)(v11 + 400));
    KB::Candidate::Candidate((KB::Candidate *)v126, (const KB::Candidate *)v133);
    v124[0] = 0;
    v125 = 0;
    if (v132)
    {
      KB::Candidate::Candidate((KB::Candidate *)v124, (const KB::Candidate *)v131);
      v125 = 1;
    }
    v96 = 0;
    v97 = 0;
    v98 = 0;
    v32 = v20 - v75;
    if (v20 != v75)
    {
      if (v20 - v75 < 0)
LABEL_121:
        abort();
      v96 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v32 >> 2);
      v98 = (char *)v96 + 4 * v33;
      memmove(v96, v75, v32);
      v97 = (char *)v96 + v32;
    }
    KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v89, (const KB::LanguageModelContext *)&v99);
    KB::String::String((KB::String *)v122, *(const KB::String **)(v7 + 32));
    KB::Candidate::Candidate((KB::Candidate *)v121, (const KB::Candidate *)v130);
    KB::CandidateFilterLookupContext::CandidateFilterLookupContext((uint64_t)v127, (uint64_t)v126, (const KB::Candidate *)v124, (uint64_t)&v96, (uint64_t)v89, (KB::String *)v122, (uint64_t)v121, **(_DWORD **)(v7 + 16));
    KB::Candidate::~Candidate((KB::Candidate *)v121);
    if (v123 && v122[6] == 1)
      free(v123);
    v137 = (int64x2_t *)&v95;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v137);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v94);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v93);
    if (v91)
    {
      v92 = v91;
      operator delete(v91);
    }
    v34 = v90;
    if (v90)
    {
      v35 = (unint64_t *)&v90->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
    if (v96)
    {
      v97 = (char *)v96;
      operator delete(v96);
    }
    if (v125)
      KB::Candidate::~Candidate((KB::Candidate *)v124);
    KB::Candidate::~Candidate((KB::Candidate *)v126);
    v129 = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
    v128 = v31 == 46;
    (*(void (**)(uint64_t, const KB::Candidate **, void ***, _BYTE *))(*(_QWORD *)v117 + 24))(v117, v76, v127, v113);
    v87 = 0uLL;
    v88 = 0;
    v37 = *(_QWORD *)(v7 + 24);
    v38 = *(unsigned __int16 *)(v37 + 4);
    if (!*(_WORD *)(v37 + 4))
    {
      KB::String::compute_length(*(unsigned __int16 **)(v7 + 24));
      v38 = *(unsigned __int16 *)(v37 + 4);
    }
    std::vector<KB::Input>::reserve((KB::String **)&v87, v38);
    v74 = v7;
    v39 = *(unsigned __int16 **)(v7 + 24);
    v40 = (const void *)*((_QWORD *)v39 + 1);
    if (!v40)
      v40 = v39 + 8;
    v83 = v40;
    v84 = 0;
    v85 = *v39;
    v86 = 0;
    KB::String::iterator::initialize((uint64_t *)&v83);
    v41 = *v39;
    v42 = *((_QWORD *)v39 + 1);
    if (!v42)
      v42 = (uint64_t)(v39 + 8);
    v79 = v42;
    v80 = v41;
    v81 = v41;
    v82 = 0;
    KB::String::iterator::initialize(&v79);
    if (v84 != v80)
    {
      do
      {
        KB::String::String((uint64_t)&cf, v86);
        if (v87.i64[1] >= v88)
        {
          v45 = 0xCCCCCCCCCCCCCCCDLL * ((v87.i64[1] - v87.i64[0]) >> 3);
          v46 = v45 + 1;
          if (v45 + 1 > 0x666666666666666)
            goto LABEL_121;
          if (0x999999999999999ALL * ((uint64_t)(v88 - v87.i64[0]) >> 3) > v46)
            v46 = 0x999999999999999ALL * ((uint64_t)(v88 - v87.i64[0]) >> 3);
          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v88 - v87.i64[0]) >> 3) >= 0x333333333333333)
            v47 = 0x666666666666666;
          else
            v47 = v46;
          v140 = &v88;
          if (v47)
            v47 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v47);
          else
            v48 = 0;
          v49 = (KB::String *)(v47 + 40 * v45);
          v137 = (int64x2_t *)v47;
          v138.i64[0] = (uint64_t)v49;
          v139 = v47 + 40 * v48;
          KB::String::String(v49, (const KB::String *)&cf);
          *((_DWORD *)v49 + 8) = 0;
          v44 = (_DWORD *)((char *)v49 + 40);
          v138.i64[1] = (uint64_t)v44;
          v50 = v87.i64[1];
          v51 = v87.i64[0];
          v52 = (KB::String *)v138.i64[0];
          if (v87.i64[1] == v87.i64[0])
          {
            v54 = vdupq_n_s64(v87.u64[1]);
          }
          else
          {
            do
            {
              v53 = v52;
              v52 = KB::String::String((KB::String *)((char *)v52 - 40), (const KB::String *)(v50 - 40));
              *((_DWORD *)v53 - 2) = *(_DWORD *)(v50 - 8);
              v50 -= 40;
            }
            while (v50 != v51);
            v54 = v87;
            v44 = (_DWORD *)v138.i64[1];
          }
          v87.i64[0] = (uint64_t)v52;
          v87.i64[1] = (uint64_t)v44;
          v138 = v54;
          v55 = v88;
          v88 = v139;
          v139 = v55;
          v137 = (int64x2_t *)v54.i64[0];
          std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)&v137);
        }
        else
        {
          v43 = KB::String::String((KB::String *)v87.i64[1], (const KB::String *)&cf);
          *((_DWORD *)v43 + 8) = 0;
          v44 = (_DWORD *)((char *)v43 + 40);
        }
        v87.i64[1] = (uint64_t)v44;
        if (v120 && BYTE6(cf) == 1)
          free(v120);
        KB::String::iterator::operator++((uint64_t *)&v83);
      }
      while (v84 != v80);
      v39 = *(unsigned __int16 **)(v74 + 24);
    }
    v56 = *v39;
    if (*v39)
    {
      v57 = (void **)*((_QWORD *)v39 + 1);
      if (!v57)
        v57 = (void **)(v39 + 8);
      v137 = (int64x2_t *)v57;
      v138.i32[0] = 0;
      *(uint64_t *)((char *)v138.i64 + 4) = v56;
      KB::String::iterator::initialize((uint64_t *)&v137);
      v58 = u_isupper(v138.i32[2]);
      v59 = v87.i64[0];
      v60 = (KB::CandidateCollection *)v76;
      if (v58)
        *(_DWORD *)(v87.i64[0] + 32) = 3;
    }
    else
    {
      v59 = v87.i64[0];
      v60 = (KB::CandidateCollection *)v76;
    }
    TIInputManager::apply_case_changes(v11, (uint64_t)v60, (unsigned __int16 *)&v87, -858993459 * ((unint64_t)(v87.i64[1] - v59) >> 3), 0, 0);
    TIInputManager::apply_shortcut_conversions((TIInputManager *)v11, v60, v61, 0);
    if (*(_QWORD *)(v11 + 568))
    {
      v62 = KB::CandidateFilterFlags::candidate_filter_flag_type((unsigned int **)&v77);
      v63 = (const KB::String *)&kGenericFlagDesc;
      if (v62 == 1)
        v63 = (const KB::String *)&kPostLMFlagDesc;
      if (v62)
        v64 = v63;
      else
        v64 = (const KB::String *)&kPreLMFlagDesc;
      KB::String::String((KB::String *)&v137, v64);
      (*(void (**)(CFTypeRef *__return_ptr, _QWORD, _QWORD))(**(_QWORD **)(v11 + 184) + 488))(&cf, *(_QWORD *)(v11 + 184), 0);
      v65 = *(_QWORD *)(v11 + 568);
      v66 = *(_QWORD *)(v74 + 24);
      v67 = cf;
      v83 = cf;
      if (cf)
      {
        CFRetain(cf);
        v83 = v67;
      }
      (*(void (**)(uint64_t, uint64_t, _QWORD, int64x2_t **, _BYTE *, CFMutableStringRef, KB::CandidateCollection *, CFTypeRef *))(*(_QWORD *)v65 + 24))(v65, v66, 0, &v137, v106, Mutable, v60, &v83);
      if (v83)
        CFRelease(v83);
      v83 = 0;
      if (cf)
        CFRelease(cf);
      if (v138.i64[0] && BYTE6(v137) == 1)
        free((void *)v138.i64[0]);
    }
    v137 = &v87;
    std::vector<KB::Input>::__destroy_vector::operator()[abi:nn180100]((void ***)&v137);
    KB::CandidateFilterLookupContext::~CandidateFilterLookupContext((KB::CandidateFilterLookupContext *)v127);
    KB::Candidate::~Candidate((KB::Candidate *)v130);
    v127[0] = (void **)v105;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v127);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v104);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v103);
    if ((_QWORD)v100)
    {
      *((_QWORD *)&v100 + 1) = v100;
      operator delete((void *)v100);
    }
    v68 = (std::__shared_weak_count *)*((_QWORD *)&v99 + 1);
    if (*((_QWORD *)&v99 + 1))
    {
      v69 = (unint64_t *)(*((_QWORD *)&v99 + 1) + 8);
      do
        v70 = __ldaxr(v69);
      while (__stlxr(v70 - 1, v69));
      if (!v70)
      {
        ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
        std::__shared_weak_count::__release_weak(v68);
      }
    }
    v127[0] = (void **)&v109;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v127);
    v127[0] = (void **)&v108;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v127);
    v127[0] = (void **)&v107;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v127);
    v127[0] = (void **)v106;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v127);
    KB::CandidateFilterResources::~CandidateFilterResources((KB::CandidateFilterResources *)v113);
    if (v75)
      operator delete(v75);
    if (v132)
      KB::Candidate::~Candidate((KB::Candidate *)v131);
    KB::Candidate::~Candidate((KB::Candidate *)v133);
    if (v136 && v135 && BYTE6(v134) == 1)
      free(v135);
    if (Mutable)
      CFRelease(Mutable);
  }
  v71 = v118;
  if (v118)
  {
    v72 = (unint64_t *)&v118->__shared_owners_;
    do
      v73 = __ldaxr(v72);
    while (__stlxr(v73 - 1, v72));
    if (!v73)
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
  if (v77)
    operator delete(v77);
}

void TIInputManager::phrase_candidates_for_string(TIInputManager *this@<X0>, const KB::String *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  KB::String *v9;
  KB::String *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *i;
  unsigned __int16 *v14;
  _BYTE *v15;
  uint64_t v16;
  _BYTE *v17;
  const KB::String *v18;
  KB::String *v19;
  unsigned __int16 *j;
  unsigned __int16 *v21;
  _BYTE *v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  unsigned __int16 *v29;
  unsigned __int16 *v30;
  unsigned __int16 **v31;

  KB::StaticDictionary::candidates_for_string(*(KB::StaticDictionary **)(*((_QWORD *)this + 28) + 16), a2, 0, (_QWORD *)a4);
  if (!a3
    || KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon && *((_DWORD *)this + 134))
  {
    v8 = *(_QWORD *)(a4 + 8) - *(_QWORD *)a4;
    KB::DynamicDictionary::retrieve_phrase_candidates(*(KB::DynamicDictionary **)(*((_QWORD *)this + 28) + 24), (unsigned __int16 *)a2);
    v9 = *(KB::String **)(a4 + 8);
    v10 = (KB::String *)(*(_QWORD *)a4 + v8);
    if (v10 != v9)
    {
      v11 = *((_QWORD *)this + 28);
      v12 = *(_QWORD *)(a4 + 8);
LABEL_6:
      KB::DictionaryContainer::lookup(v11, v10, 0, 1, (uint64_t *)&v29);
      for (i = v29; ; i += 120)
      {
        if (i == v30)
        {
          v31 = &v29;
          std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
          v10 = (KB::String *)((char *)v10 + 240);
          if (v10 != v9)
            goto LABEL_6;
          goto LABEL_46;
        }
        if (!*((_QWORD *)i + 28))
          goto LABEL_49;
        v14 = (unsigned __int16 *)*((_QWORD *)i + 1);
        if (!v14)
          v14 = i + 8;
        v15 = (_BYTE *)*i;
        if (*i)
        {
          v16 = *i;
          v17 = v14;
          while (*v17 != 45)
          {
            ++v17;
            if (!--v16)
            {
              v17 = &v15[(_QWORD)v14];
              break;
            }
          }
        }
        else
        {
          v17 = v14;
        }
        if ((_BYTE *)(v17 - (_BYTE *)v14) == v15)
        {
LABEL_49:
          if ((i[53] & 4) != 0 || *((_DWORD *)i + 31))
            break;
        }
      }
      v31 = &v29;
      std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
      if (v10 == v9)
        goto LABEL_46;
      v18 = (KB::String *)((char *)v10 + 240);
      if ((KB::String *)((char *)v10 + 240) != v9)
      {
        v12 = (uint64_t)v10;
        do
        {
          v19 = v18;
          KB::DictionaryContainer::lookup(v11, v18, 0, 1, (uint64_t *)&v29);
          for (j = v29; ; j += 120)
          {
            if (j == v30)
            {
              v31 = &v29;
              std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
              KB::String::operator=(v12, v19);
              KB::ByteString::operator=((unsigned __int16 *)(v12 + 32), (unsigned __int16 *)v10 + 136);
              v25 = *((_QWORD *)v10 + 36);
              *(_DWORD *)(v12 + 56) = *((_DWORD *)v10 + 74);
              *(_QWORD *)(v12 + 48) = v25;
              KB::String::operator=(v12 + 64, (KB::String *)((char *)v10 + 304));
              v26 = *((_OWORD *)v10 + 21);
              v27 = *((_OWORD *)v10 + 22);
              v28 = *((_OWORD *)v10 + 24);
              *(_OWORD *)(v12 + 128) = *((_OWORD *)v10 + 23);
              *(_OWORD *)(v12 + 144) = v28;
              *(_OWORD *)(v12 + 96) = v26;
              *(_OWORD *)(v12 + 112) = v27;
              KB::String::operator=(v12 + 160, (KB::String *)((char *)v10 + 400));
              *(_BYTE *)(v12 + 192) = *((_BYTE *)v10 + 432);
              std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(v12 + 200, (uint64_t *)v10 + 55);
              v12 += 240;
              goto LABEL_43;
            }
            if (!*((_QWORD *)j + 28))
              goto LABEL_50;
            v21 = (unsigned __int16 *)*((_QWORD *)j + 1);
            if (!v21)
              v21 = j + 8;
            v22 = (_BYTE *)*j;
            if (*j)
            {
              v23 = *j;
              v24 = v21;
              while (*v24 != 45)
              {
                ++v24;
                if (!--v23)
                {
                  v24 = &v22[(_QWORD)v21];
                  break;
                }
              }
            }
            else
            {
              v24 = v21;
            }
            if ((_BYTE *)(v24 - (_BYTE *)v21) == v22)
            {
LABEL_50:
              if ((j[53] & 4) != 0 || *((_DWORD *)j + 31))
                break;
            }
          }
          v31 = &v29;
          std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
LABEL_43:
          v18 = (KB::String *)((char *)v19 + 240);
          v10 = v19;
        }
        while ((KB::String *)((char *)v19 + 240) != v9);
        goto LABEL_46;
      }
    }
    v12 = (uint64_t)v10;
LABEL_46:
    std::vector<KB::Word>::erase(a4, v12, *(KB::Word **)(a4 + 8));
  }
}

void TIInputManager::phrase_completed_by_word(uint64_t a1@<X0>, KB::String *a2@<X1>, KB::String *a3@<X2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, KB::Candidate *a7@<X8>)
{
  KB::Candidate *j;
  uint64_t v13;
  unsigned int v14;
  KB::String *v15;
  unsigned __int16 *v16;
  KB::String *i;
  unsigned __int16 *v18;
  void *v19;
  BOOL v20;
  const KB::String *v21;
  const KB::String *v22;
  uint64_t v23;
  unsigned __int16 *v24;
  uint64_t v25;
  KB::String *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  const KB::String *v34;
  const KB::String *v35;
  KB::String *v36;
  KB::String *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  KB::String *v41;
  uint64_t v42;
  KB::String *v43;
  unsigned __int16 *v44;
  KB::String *v45;
  uint64_t v46;
  BOOL v47;
  KB::String *v48;
  KB::String *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  unint64_t v55;
  unint64_t k;
  _QWORD *v57;
  uint64_t v58;
  _BYTE *v59;
  uint64_t v60;
  uint64_t v61;
  const KB::String *v62;
  uint64_t v63;
  int v66;
  int v67;
  unsigned int v68;
  const char *v70;
  const KB::String *v71;
  const KB::String *v72;
  void *v73;
  int v74;
  int v75;
  uint64_t v76;
  KB::Candidate *v77;
  int v78;
  unsigned __int16 *v79;
  KB::String *v80;
  _BOOL4 v81;
  int v82;
  TIInputManager *v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  KB::String *v88;
  KB::String *v89;
  uint64_t v90;
  float v91;
  const KB::String *v92;
  const KB::String *v93;
  _BYTE v94[8];
  void *v95;
  char v96;
  int v97;
  __int16 v98;
  char v99;
  void *v100;
  char v101;
  _BYTE buf[24];
  _BYTE v103[20];
  unsigned int v104;
  int v105;
  _BYTE v106[8];
  void *v107;
  char v108;
  _BYTE v109[8];
  void *v110;
  char v111;
  _BYTE v112[6];
  char v113;
  void *v114;
  TITokenID v115;
  void *v116;
  char v117;
  _BYTE v118[6];
  char v119;
  void *v120;
  _WORD v121[3];
  char v122;
  _QWORD *v123;
  _QWORD v124[5];

  j = a7;
  v124[2] = *MEMORY[0x1E0C80C00];
  if (!*(_WORD *)a2)
  {
    bzero(a7, 0x3E8uLL);
    KB::Candidate::Candidate(j);
    return;
  }
  v79 = (unsigned __int16 *)(a1 + 8);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)buf);
  v81 = buf == (_BYTE *)a2 || KB::String::equal(a2, (const KB::String *)buf, 1);
  if (*(_QWORD *)&buf[8] && buf[6] == 1)
    free(*(void **)&buf[8]);
  TIInputManager::tokenize_input_context(a2, &v92);
  v91 = 0.0;
  v85 = 0;
  if ((KB::LanguageModelContext::is_linguistically_void((KB::LanguageModelContext *)(a1 + 432)) & 1) == 0)
  {
    v13 = *(_QWORD *)(a1 + 232);
    if (v13 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 16))(v13))
      v85 = (*(uint64_t (**)(_QWORD, uint64_t, float *))(**(_QWORD **)(a1 + 232) + 424))(*(_QWORD *)(a1 + 232), a1 + 432, &v91);
    else
      v85 = 0;
  }
  v82 = a5;
  TIInputManager::tokenize_input_context((const KB::String *)(a1 + 400), &v88);
  v14 = *(_DWORD *)(a1 + 536);
  v15 = v88;
  v80 = a3;
  v84 = (TIInputManager *)a1;
  v78 = a6;
  if (v14)
  {
    v16 = (unsigned __int16 *)v89;
    KB::String::String((uint64_t)buf, v14);
    if (v15 != (KB::String *)v16 && v15 != (KB::String *)buf)
    {
      do
      {
        if (KB::String::equal(v15, (const KB::String *)buf, 1))
          break;
        v15 = (KB::String *)((char *)v15 + 32);
        if (v15 == (KB::String *)v16)
          break;
      }
      while (v15 != (KB::String *)buf);
    }
    if (v15 != (KB::String *)v16)
    {
      for (i = (KB::String *)((char *)v15 + 32); i != (KB::String *)v16; i = (KB::String *)((char *)i + 32))
      {
        if (i != (KB::String *)buf && !KB::String::equal(i, (const KB::String *)buf, 1))
        {
          KB::String::operator=((uint64_t)v15, i);
          v15 = (KB::String *)((char *)v15 + 32);
        }
      }
    }
    v18 = (unsigned __int16 *)v89;
    if (v15 != v89)
    {
      while (v18 != (unsigned __int16 *)v15)
      {
        v19 = (void *)*((_QWORD *)v18 - 3);
        if (v19 && *((_BYTE *)v18 - 26) == 1)
          free(v19);
        v18 -= 16;
      }
      v89 = v15;
    }
    if (*(_QWORD *)&buf[8])
      v20 = buf[6] == 1;
    else
      v20 = 0;
    if (v20)
      free(*(void **)&buf[8]);
    v15 = v88;
  }
  v21 = v92;
  v22 = v93;
  if (v93 - v92 >= 1)
  {
    v23 = (v93 - v92) >> 5;
    v24 = (unsigned __int16 *)v89;
    v25 = (v89 - v15) >> 5;
    v26 = (KB::String *)((char *)v15 + ((v89 - v15) & 0xFFFFFFFFFFFFFFE0));
    if (v23 > (v90 - (uint64_t)v89) >> 5)
    {
      v27 = v25 + v23;
      if ((unint64_t)(v25 + v23) >> 59)
        abort();
      v28 = v90 - (_QWORD)v15;
      if ((v90 - (uint64_t)v15) >> 4 > v27)
        v27 = v28 >> 4;
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFE0)
        v29 = 0x7FFFFFFFFFFFFFFLL;
      else
        v29 = v27;
      *(_QWORD *)&v103[8] = &v90;
      if (v29)
      {
        v31 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v29);
      }
      else
      {
        v31 = 0;
        v30 = 0;
      }
      v37 = (KB::String *)&v31[32 * v25];
      *(_QWORD *)buf = v31;
      *(_QWORD *)&buf[8] = v37;
      *(_QWORD *)v103 = &v31[32 * v30];
      v38 = 32 * v23;
      v39 = (uint64_t)v37 + 32 * v23;
      do
      {
        v37 = (KB::String *)((char *)KB::String::String(v37, v21) + 32);
        v21 = (const KB::String *)((char *)v21 + 32);
        v38 -= 32;
      }
      while (v38);
      *(_QWORD *)&buf[16] = v39;
      v40 = *(_QWORD *)&buf[8];
      v41 = v88;
      if (v88 != v26)
      {
        v42 = *(_QWORD *)&buf[8] - 32;
        v43 = v26;
        do
        {
          *(_DWORD *)v42 = 0x100000;
          v43 = (KB::String *)((char *)v43 - 32);
          *(_WORD *)(v42 + 4) = 0;
          *(_BYTE *)(v42 + 6) = 0;
          *(_QWORD *)(v42 + 8) = 0;
          v40 = KB::String::operator=(v42, v43);
          v42 = v40 - 32;
        }
        while (v43 != v41);
        v39 = *(_QWORD *)&buf[16];
      }
      *(_QWORD *)&buf[8] = v40;
      v44 = (unsigned __int16 *)v89;
      if (v89 != v26)
      {
        do
        {
          *(_DWORD *)v39 = 0x100000;
          *(_WORD *)(v39 + 4) = 0;
          *(_BYTE *)(v39 + 6) = 0;
          *(_QWORD *)(v39 + 8) = 0;
          KB::String::operator=(v39, v26);
          v26 = (KB::String *)((char *)v26 + 32);
          v39 += 32;
        }
        while (v26 != (KB::String *)v44);
        v40 = *(_QWORD *)&buf[8];
        v26 = v89;
      }
      v45 = v88;
      v46 = v90;
      v88 = (KB::String *)v40;
      v89 = (KB::String *)v39;
      v90 = *(_QWORD *)v103;
      *(_QWORD *)&buf[16] = v26;
      *(_QWORD *)v103 = v46;
      *(_QWORD *)buf = v45;
      *(_QWORD *)&buf[8] = v45;
      std::__split_buffer<KB::String>::~__split_buffer((uint64_t)buf);
      goto LABEL_78;
    }
    v77 = j;
    v32 = v89 - v26;
    v33 = (v89 - v26) >> 5;
    v76 = (v89 - v15) >> 5;
    if (v33 >= v23)
    {
      v34 = (const KB::String *)((char *)v92 + 32 * v23);
      v36 = v89;
LABEL_70:
      v48 = (KB::String *)((char *)v26 + 32 * v23);
      v49 = (KB::String *)((char *)v36 - 32 * v23);
      v50 = (uint64_t)v36;
      if (v49 < (KB::String *)v24)
      {
        v50 = (uint64_t)v36;
        do
        {
          *(_DWORD *)v50 = 0x100000;
          *(_WORD *)(v50 + 4) = 0;
          *(_BYTE *)(v50 + 6) = 0;
          *(_QWORD *)(v50 + 8) = 0;
          v51 = KB::String::operator=(v50, v49);
          v49 = (KB::String *)((char *)v49 + 32);
          v50 = v51 + 32;
        }
        while (v49 < (KB::String *)v24);
      }
      v89 = (KB::String *)v50;
      if (v36 != v48)
      {
        v52 = (uint64_t)v36 - 32;
        v53 = 32 * ((v36 - v48) >> 5);
        do
        {
          v52 = KB::String::operator=(v52, (KB::String *)((char *)v15 + 32 * v76 + v53 - 32)) - 32;
          v53 -= 32;
        }
        while (v53);
      }
      for (j = v77; v21 != v34; v26 = (KB::String *)((char *)v26 + 32))
      {
        KB::String::operator=(v26, v21);
        v21 = (const KB::String *)((char *)v21 + 32);
      }
      goto LABEL_78;
    }
    v34 = (const KB::String *)((char *)v92 + 32 * v33);
    if (v34 == v93)
    {
      v36 = v89;
    }
    else
    {
      v35 = (const KB::String *)((char *)v92 + 32 * v33);
      v36 = v89;
      do
      {
        KB::String::String(v36, v35);
        v35 = (const KB::String *)((char *)v35 + 32);
        v36 = (KB::String *)((char *)v36 + 32);
      }
      while (v35 != v22);
    }
    v89 = v36;
    v47 = v32 < 1;
    j = v77;
    if (!v47)
      goto LABEL_70;
  }
LABEL_78:
  v54 = v82;
  if (v81)
    v55 = 1;
  else
    v55 = (v93 - v92) >> 5;
  if (v55 <= 4)
  {
    for (k = 4; k >= v55; --k)
    {
      if (k <= (v89 - v88) >> 5 && (k != 1 || v54))
      {
        *(_DWORD *)buf = 0x100000;
        *(_WORD *)&buf[4] = 0;
        buf[6] = 0;
        *(_QWORD *)&buf[8] = 0;
        buf[16] = 0;
        KB::string_join((unsigned __int16 *)v89 - 16 * k, (unsigned __int16 *)v89, (const KB::String *)buf, (uint64_t)v121);
        if (*(_QWORD *)&buf[8] && buf[6] == 1)
          free(*(void **)&buf[8]);
        if (v123)
          v57 = v123;
        else
          v57 = v124;
        if (v121[0])
        {
          v58 = v121[0];
          v59 = v57;
          while (*v59 != 10)
          {
            ++v59;
            if (!--v58)
            {
              v59 = (char *)v57 + v121[0];
              break;
            }
          }
        }
        else
        {
          v59 = v57;
        }
        if (v59 - (_BYTE *)v57 == v121[0])
        {
          TIInputManager::phrase_candidates_for_string(v84, (const KB::String *)v121, v54, (uint64_t)&v86);
          if (v86 != v87)
          {
            if (v81)
            {
              KB::String::operator=(v80, (KB::String *)v121);
            }
            else
            {
              v115.lexicon_id = 0x100000;
              LOWORD(v115.word_id) = 0;
              BYTE2(v115.word_id) = 0;
              v116 = 0;
              v117 = 0;
              KB::string_join((unsigned __int16 *)v89 - 16 * k, (unsigned __int16 *)((char *)v89 + v92 - v93), (const KB::String *)&v115, (uint64_t)v118);
              TIInputManager::input_substring(v79, 0, *((_DWORD *)v84 + 24), (uint64_t)v112);
              KB::String::String((KB::String *)buf, (const KB::String *)v118);
              KB::String::append((unsigned __int16 *)buf, (const KB::String *)v112);
              KB::String::operator=((uint64_t)v80, (KB::String *)buf);
              if (*(_QWORD *)&buf[8] && buf[6] == 1)
                free(*(void **)&buf[8]);
              if (v114 && v113 == 1)
                free(v114);
              if (v120 && v119 == 1)
                free(v120);
              if (v116 && BYTE2(v115.word_id) == 1)
                free(v116);
            }
            v60 = v86;
            v61 = v87;
            while (v60 != v61)
            {
              *(_QWORD *)buf = &off_1EA103EF8;
              *(_QWORD *)&buf[8] = 1;
              if (KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)buf, (const KB::String *)v60, (const KB::String *)v121, 0, 0))
              {
                v63 = *(_QWORD *)(v60 + 136);
                if (v85 == (_DWORD)v63 || *(_QWORD *)(v60 + 136) == 0 || v85 == 0)
                {
                  v66 = *(_DWORD *)(v60 + 104);
                  if ((v66 & 0x800012) != 0
                    || (*(_DWORD *)(v60 + 104) & 0x2080) == 0x80
                    || (v66 & 0x2042000) == 0x2000000)
                  {
                    if (a4)
                    {
                      KB::String::String((KB::String *)v94, v80);
                      v96 = 1;
                      create_candidate_from_word(j, v60, (KB::String *)v94);
                      if (v96)
                      {
                        v73 = v95;
                        if (v95)
                        {
                          v74 = v94[6];
LABEL_174:
                          if (v74 == 1)
                            free(v73);
                        }
                      }
LABEL_176:
                      *(_QWORD *)buf = &v86;
                      std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
                      if (v123 && v122 == 1)
                        free(v123);
                      goto LABEL_153;
                    }
                  }
                  else
                  {
                    if (!*((_BYTE *)v84 + 683))
                    {
                      v71 = (const KB::String *)TILocaleIdentifierForLexiconID(*(_QWORD *)(v60 + 136));
                      KB::string_to_lowercase((KB *)v60, v71, (KB::String *)v118);
                      v115 = *(TITokenID *)(v60 + 136);
                      KB::Word::Word((KB::Word *)buf, (const KB::String *)v118, &v115, 0);
                      if (v120 && v119 == 1)
                        free(v120);
                      v105 = KB::string_capitalization(v80, v72);
                      v104 = v104 & 0xFFFFFFFE | (v105 == 1);
                      KB::Word::capitalized_string((KB::Word *)buf, (uint64_t)v118);
                      v97 = 0x100000;
                      v98 = 0;
                      v99 = 0;
                      v100 = 0;
                      KB::String::operator=((uint64_t)&v97, (KB::String *)v118);
                      v101 = 1;
                      create_candidate_from_word(j, v60, (KB::String *)&v97);
                      if (v101 && v100 && v99 == 1)
                        free(v100);
                      if (v120 && v119 == 1)
                        free(v120);
                      KB::Word::~Word((KB::Word *)buf);
                      goto LABEL_176;
                    }
                    if (*(_QWORD *)(v60 + 224)
                      && KB::CollatorWrapper::sortkey_starts_with((KB::CollatorWrapper *)(*(_QWORD *)(*((_QWORD *)v84 + 28) + 8) + 72), (_LXLexicon *)v60, (_LXLexicon *)v80))
                    {
                      if (!v81)
                      {
                        v115.lexicon_id = 0x100000;
                        LOWORD(v115.word_id) = 0;
                        BYTE2(v115.word_id) = 0;
                        v116 = 0;
                        v117 = 0;
                        KB::string_join((unsigned __int16 *)v89 - 16 * k, (unsigned __int16 *)((char *)v89 + v92 - v93), (const KB::String *)&v115, (uint64_t)v118);
                        TIInputManager::input_substring(v79, 0, -858993459 * ((*((_QWORD *)v84 + 2) - *((_QWORD *)v84 + 1)) >> 3), (uint64_t)v112);
                        KB::String::String((KB::String *)buf, (const KB::String *)v118);
                        KB::String::append((unsigned __int16 *)buf, (const KB::String *)v112);
                        KB::String::operator=((uint64_t)v80, (KB::String *)buf);
                        if (*(_QWORD *)&buf[8] && buf[6] == 1)
                          free(*(void **)&buf[8]);
                        if (v114 && v113 == 1)
                          free(v114);
                        if (v120 && v119 == 1)
                          free(v120);
                        if (v116 && BYTE2(v115.word_id) == 1)
                          free(v116);
                      }
                      v109[0] = 0;
                      v111 = 0;
                      create_candidate_from_word(j, v60, (KB::String *)v109);
                      if (v111)
                      {
                        v73 = v110;
                        if (v110)
                        {
                          v74 = v109[6];
                          goto LABEL_174;
                        }
                      }
                      goto LABEL_176;
                    }
                    if (k == 1 && !*(_WORD *)v80)
                    {
                      TIInputManager::apply_shift_context_to_prediction((uint64_t)v84, v78, (KB::Word *)v60);
                      goto LABEL_171;
                    }
                    v67 = KB::string_capitalization(v80, v62);
                    v68 = *(_DWORD *)(v60 + 120);
                    if ((v67 & ~v68) == 0)
                      goto LABEL_171;
                    if ((v67 & ~v68) == 1)
                    {
                      v75 = *(_DWORD *)(v60 + 104);
                      if ((v75 & 0x20) == 0)
                      {
                        *(_DWORD *)(v60 + 120) = v68 | 1;
                        *(_DWORD *)(v60 + 104) = v75 & 0xFFFFFFFE | (v68 < 2);
                      }
LABEL_171:
                      v106[0] = 0;
                      v108 = 0;
                      create_candidate_from_word(j, v60, (KB::String *)v106);
                      if (v108)
                      {
                        v73 = v107;
                        if (v107)
                        {
                          v74 = v106[6];
                          goto LABEL_174;
                        }
                      }
                      goto LABEL_176;
                    }
                  }
                }
                else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
                {
                  v70 = "";
                  if (*(_WORD *)v60)
                  {
                    v70 = *(const char **)(v60 + 8);
                    if (!v70)
                      v70 = (const char *)(v60 + 16);
                  }
                  *(_DWORD *)buf = 136316162;
                  *(_QWORD *)&buf[4] = "phrase_completed_by_word";
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = v70;
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)v103 = v63;
                  *(_WORD *)&v103[4] = 1024;
                  *(_DWORD *)&v103[6] = v85;
                  *(_WORD *)&v103[10] = 2048;
                  *(double *)&v103[12] = v91;
                  _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  Phrase candidate  %s was found but is not from the most probable lexicon (word.lexicon_id = %d, current_lexicon_id = %d; language confidence = %f)",
                    buf,
                    0x2Cu);
                }
              }
              v60 += 240;
            }
          }
          *(_QWORD *)buf = &v86;
          std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
          if (v123 && v122 == 1)
            free(v123);
          v54 = v82;
        }
        else if (v123 && v122 == 1)
        {
          free(v123);
        }
      }
    }
  }
  bzero(j, 0x3E8uLL);
  KB::Candidate::Candidate(j);
LABEL_153:
  *(_QWORD *)buf = &v88;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  *(_QWORD *)buf = &v92;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
}

void create_candidate_from_word(KB::Candidate *a1, uint64_t a2, KB::String *a3)
{
  uint64_t v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[8];
  void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)a3 + 32))
    KB::String::String((KB::String *)v10, a3);
  else
    KB::Word::capitalized_string((KB::Word *)a2, (uint64_t)v10);
  KB::Candidate::Candidate(a1, (const KB::String *)v10, 0);
  if (v11 && v10[6] == 1)
    free(v11);
  if ((*(_BYTE *)(a2 + 105) & 1) != 0 && *(_QWORD *)a1)
  {
    v5 = 240 * *(_QWORD *)a1;
    v6 = (_DWORD *)(*((_QWORD *)a1 + 1) + 104);
    do
    {
      *v6 |= 0x100u;
      v6 += 60;
      v5 -= 240;
    }
    while (v5);
  }
  if (*(_QWORD *)(a2 + 224))
  {
    v7 = *(_QWORD *)a1;
    if (*(_QWORD *)a1)
    {
      v8 = *((_QWORD *)a1 + 1) + 200;
      v9 = 240 * v7;
      do
      {
        if (v8 - 200 != a2)
        {
          *(_DWORD *)(v8 + 32) = *(_DWORD *)(a2 + 232);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((_QWORD *)v8, *(_QWORD **)(a2 + 216));
        }
        v8 += 240;
        v9 -= 240;
      }
      while (v9);
    }
  }
}

BOOL TIInputManager::word_has_surface_form(TIInputManager *this, const KB::Word *a2)
{
  unsigned __int8 v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unsigned int v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  uint64_t is_tamil_script;
  const char *v13;
  const char *v14;
  void *v15;
  _QWORD *v16;
  int v17;
  int v18;
  BOOL v19;
  _QWORD *v21;
  int v22;
  int v23;
  int v24;
  _QWORD *v25;
  int v26;
  int v27;
  int v28;
  _WORD v29[3];
  char v30;
  void *v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  if ((v4 & 1) == 0
  {
    KB::String::String((KB::String *)&TIInputManager::word_has_surface_form(KB::Word const&)const::ko, "ko");
    __cxa_atexit((void (*)(void *))KB::String::~String, &TIInputManager::word_has_surface_form(KB::Word const&)const::ko, &dword_1DA6F2000);
  }
  if ((v5 & 1) == 0
  {
    KB::String::String((KB::String *)&TIInputManager::word_has_surface_form(KB::Word const&)const::ta, "ta");
    __cxa_atexit((void (*)(void *))KB::String::~String, &TIInputManager::word_has_surface_form(KB::Word const&)const::ta, &dword_1DA6F2000);
  }
  if ((v6 & 1) == 0
  {
    KB::String::String((KB::String *)&TIInputManager::word_has_surface_form(KB::Word const&)const::chr, "chr");
    __cxa_atexit((void (*)(void *))KB::String::~String, &TIInputManager::word_has_surface_form(KB::Word const&)const::chr, &dword_1DA6F2000);
  }
  v7 = *((unsigned __int16 *)this + 52);
  if ((unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::ko <= v7)
  {
    v8 = *((_QWORD *)this + 14) ? (const char *)*((_QWORD *)this + 14) : (char *)this + 120;
    v9 = qword_1EDAEE150 ? (const char *)qword_1EDAEE150 : (const char *)&unk_1EDAEE158;
    if (!strncmp(v8, v9, (unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::ko))
      return 0;
  }
  if ((unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::ta <= v7
    && (*((_QWORD *)this + 14) ? (v10 = (const char *)*((_QWORD *)this + 14)) : (v10 = (char *)this + 120),
        qword_1EDAEE170 ? (v11 = (const char *)qword_1EDAEE170) : (v11 = (const char *)&unk_1EDAEE178),
        !strncmp(v10, v11, (unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::ta)))
  {
    KB::Word::capitalized_string(a2, (uint64_t)v29);
    v15 = v31;
    if (v31)
      v16 = v31;
    else
      v16 = v32;
    v25 = v16;
    v17 = v29[0];
    v26 = 0;
    v27 = v29[0];
    v28 = 0;
    KB::String::iterator::initialize((uint64_t *)&v25);
    v21 = v16;
    v22 = v17;
    v23 = v17;
    v24 = 0;
    KB::String::iterator::initialize((uint64_t *)&v21);
    v18 = v22;
    if (v26 == v22)
    {
      is_tamil_script = 0;
    }
    else
    {
      do
      {
        is_tamil_script = character_is_tamil_script();
        if ((is_tamil_script & 1) != 0)
          break;
        KB::String::iterator::operator++((uint64_t *)&v25);
      }
      while (v26 != v18);
      v15 = v31;
    }
    if (v15)
      v19 = v30 == 1;
    else
      v19 = 0;
    if (v19)
      free(v15);
  }
  else if ((unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::chr <= v7)
  {
    if (*((_QWORD *)this + 14))
      v13 = (const char *)*((_QWORD *)this + 14);
    else
      v13 = (char *)this + 120;
    if (qword_1EDAEE190)
      v14 = (const char *)qword_1EDAEE190;
    else
      v14 = (const char *)&unk_1EDAEE198;
    return strncmp(v13, v14, (unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::chr) != 0;
  }
  else
  {
    return 1;
  }
  return is_tamil_script;
}

uint64_t TIInputManager::dictionary_contains_word(TIInputManager *this, const KB::String *a2, const KB::String *a3, char a4)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[2];
  uint64_t (*v14)(uint64_t, const KB::Word *);
  void *v15;
  TIInputManager *v16;
  const KB::String *v17;
  const KB::String *v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  void **v22;

  v5 = *((_QWORD *)this + 28);
  if (!v5)
    return 0;
  KB::DictionaryContainer::lookup(v5, a2, 0, 1, &v20);
  v9 = v20;
  v10 = v21;
  if (v20 == v21)
  {
    v11 = 0;
  }
  else
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 0x40000000;
    v14 = ___ZNK14TIInputManager24dictionary_contains_wordERKN2KB6StringES3_b_block_invoke;
    v15 = &__block_descriptor_tmp_33;
    v16 = this;
    v17 = a3;
    v18 = a2;
    v19 = a4;
    do
    {
      v11 = v14((uint64_t)v13, (const KB::Word *)v9);
      if ((v11 & 1) != 0)
        break;
      v9 += 240;
    }
    while (v9 != v10);
  }
  v22 = (void **)&v20;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v22);
  return v11;
}

uint64_t ___ZNK14TIInputManager24dictionary_contains_wordERKN2KB6StringES3_b_block_invoke(uint64_t a1, const KB::Word *a2)
{
  TIInputManager *v4;
  _BOOL4 has_surface_form;
  uint64_t v6;
  const KB::String *v7;
  KB::CollatorWrapper **v8;
  const KB::String *v9;
  int v10;
  BOOL v11;
  _BOOL8 v12;
  int v13;
  int v14;
  BOOL v16;
  _QWORD v17[2];
  _BYTE v18[6];
  char v19;
  void *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(TIInputManager **)(a1 + 32);
  has_surface_form = TIInputManager::word_has_surface_form(v4, a2);
  v6 = 48;
  if (has_surface_form)
    v6 = 40;
  v7 = *(const KB::String **)(a1 + v6);
  v8 = (KB::CollatorWrapper **)(*(_QWORD *)(*((_QWORD *)v4 + 28) + 8) + 72);
  KB::Word::capitalized_string(a2, (uint64_t)v18);
  v10 = KB::CollatorWrapper::sortkey_compare_strings(v8, (_LXLexicon *)v18, v7, v9);
  if (v20)
    v11 = v19 == 1;
  else
    v11 = 0;
  if (v11)
    free(v20);
  v12 = 0;
  v16 = 0;
  if (!v10)
  {
    KB::Word::capitalized_string(a2, (uint64_t)v18);
    v17[0] = &off_1EA103EF8;
    v17[1] = 1;
    v13 = KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)v17, (const KB::String *)v18, v7, &v16, 0);
    if (v20 && v19 == 1)
      free(v20);
    if (v16)
      v14 = 0;
    else
      v14 = v13;
    if (v14 == 1)
    {
      if (*(_BYTE *)(a1 + 56))
      {
        KB::Word::capitalized_string(a2, (uint64_t)v18);
        v12 = v18 == (_BYTE *)v7 || KB::String::equal((KB::String *)v18, v7, 1);
        if (v20 && v19 == 1)
          free(v20);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v12;
}

void TIInputManager::matching_words_from_dictionary(TIInputManager *this@<X0>, const KB::String *a2@<X1>, const KB::String *a3@<X2>, char a4@<W3>, uint64_t *a5@<X8>)
{
  uint64_t v7;
  const KB::Word *v11;
  const KB::Word *v12;
  TIInputManager *v13;
  const KB::String *v14;
  KB::CollatorWrapper **v15;
  const KB::String *v16;
  int v17;
  BOOL v18;
  int v19;
  int v20;
  BOOL v21;
  KB::Word *v22;
  unint64_t v23;
  char *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  char *v30;
  const KB::Word *v31;
  const KB::Word *v32;
  BOOL v33;
  _QWORD v34[2];
  TIInputManager *v35;
  _BYTE v36[8];
  void *v37;
  _BYTE v38[8];
  void *v39;
  char v40;
  void **v41;
  void *v42;
  char *v43;
  unint64_t v44;
  uint64_t *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  v7 = *((_QWORD *)this + 28);
  if (v7)
  {
    KB::DictionaryContainer::lookup(v7, a2, 0, 1, (uint64_t *)&v31);
    v11 = v31;
    v12 = v32;
    if (v31 != v32)
    {
      v35 = this;
      KB::String::String((KB::String *)v36, a3);
      KB::String::String((KB::String *)v38, a2);
      v40 = a4;
      do
      {
        v13 = v35;
        if (TIInputManager::word_has_surface_form(v35, v11))
          v14 = (const KB::String *)v36;
        else
          v14 = (const KB::String *)v38;
        v15 = (KB::CollatorWrapper **)(*(_QWORD *)(*((_QWORD *)v13 + 28) + 8) + 72);
        KB::Word::capitalized_string(v11, (uint64_t)&v41);
        v17 = KB::CollatorWrapper::sortkey_compare_strings(v15, (_LXLexicon *)&v41, v14, v16);
        if (v42)
          v18 = BYTE6(v41) == 1;
        else
          v18 = 0;
        if (v18)
          free(v42);
        v33 = 0;
        if (!v17)
        {
          KB::Word::capitalized_string(v11, (uint64_t)&v41);
          v34[0] = &off_1EA103EF8;
          v34[1] = 1;
          v19 = KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)v34, (const KB::String *)&v41, v14, &v33, 0);
          if (v42 && BYTE6(v41) == 1)
            free(v42);
          if (v33)
            v20 = 0;
          else
            v20 = v19;
          if (v20 == 1)
          {
            if (!v40)
              goto LABEL_26;
            KB::Word::capitalized_string(v11, (uint64_t)&v41);
            v21 = KB::String::equal((KB::String *)&v41, v14, 1);
            if (v42 && BYTE6(v41) == 1)
              free(v42);
            if (v21)
            {
LABEL_26:
              v22 = (KB::Word *)a5[1];
              v23 = a5[2];
              if ((unint64_t)v22 >= v23)
              {
                v25 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v22 - *a5) >> 4);
                v26 = v25 + 1;
                if (v25 + 1 > 0x111111111111111)
                  abort();
                v27 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v23 - *a5) >> 4);
                if (2 * v27 > v26)
                  v26 = 2 * v27;
                if (v27 >= 0x88888888888888)
                  v28 = 0x111111111111111;
                else
                  v28 = v26;
                v45 = a5 + 2;
                if (v28)
                  v28 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v28);
                else
                  v29 = 0;
                v30 = (char *)(v28 + 240 * v25);
                v41 = (void **)v28;
                v42 = v30;
                v44 = v28 + 240 * v29;
                KB::Word::Word((KB::Word *)v30, v11);
                v43 = v30 + 240;
                std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v41);
                v24 = (char *)a5[1];
                std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v41);
              }
              else
              {
                v24 = (char *)KB::Word::Word(v22, v11) + 240;
              }
              a5[1] = (uint64_t)v24;
            }
          }
        }
        v11 = (const KB::Word *)((char *)v11 + 240);
      }
      while (v11 != v12);
      if (v39 && v38[6] == 1)
        free(v39);
      if (v37)
      {
        if (v36[6] == 1)
          free(v37);
      }
    }
    v41 = (void **)&v31;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v41);
  }
}

uint64_t TIInputManager::keys_for_input(TIInputManager *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 23) + 240))(*((_QWORD *)this + 23));
}

uint64_t TIInputManager::initialize_search_if_necessary_from_last_touch(TIInputManager *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 23) + 248))(*((_QWORD *)this + 23));
}

BOOL TIInputManager::is_input_hit_test_corrected(TIInputManager *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t v4;

  if (*((_DWORD *)this + 24) >= a3)
    v3 = a3;
  else
    v3 = *((_DWORD *)this + 24);
  if (v3 <= a2)
    return 0;
  LODWORD(v4) = a2;
  if (((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 23) + 280))(*((_QWORD *)this + 23)) & 1) != 0)
    return 1;
  while (v3 - 1 != (_DWORD)v4)
  {
    v4 = (v4 + 1);
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)this + 23) + 280))(*((_QWORD *)this + 23), v4))
    {
      return v4 < v3;
    }
  }
  LODWORD(v4) = v3;
  return v4 < v3;
}

void debug_print_candidates(uint64_t *a1, const char *a2, uint64_t a3)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  const char *v15;
  const char *v16;
  float v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  double v23;
  __int16 v24;
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    v19 = "debug_print_candidates";
    _os_log_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s  ===================", buf, 0xCu);
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v6 = 0x1CAC083126E978D5 * ((a1[1] - *a1) >> 3);
    if (*(_WORD *)a3)
    {
      v7 = *(const char **)(a3 + 8);
      if (!v7)
        v7 = (const char *)(a3 + 16);
    }
    else
    {
      v7 = "";
    }
    *(_DWORD *)buf = 136315906;
    v19 = "debug_print_candidates";
    v20 = 2082;
    v21 = a2;
    v22 = 2048;
    v23 = *(double *)&v6;
    v24 = 2082;
    v25 = v7;
    _os_log_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s  %{public}s: %lu (%{public}s)", buf, 0x2Au);
  }
  v9 = *a1;
  v8 = a1[1];
  if (v8 != *a1)
  {
    v10 = 0;
    v11 = MEMORY[0x1E0C81028];
    v12 = 904;
    do
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v13 = v9 + v12;
        v14 = *(unsigned __int16 *)(v9 + v12 - 16);
        if (!*(_WORD *)(v9 + v12 - 16))
        {
          KB::Candidate::compute_string((KB::Candidate *)(v13 - 904));
          v14 = *(unsigned __int16 *)(v13 - 16);
        }
        v15 = *(const char **)(v13 - 8);
        if (!v15)
          v15 = (const char *)(v9 + v12);
        if (v14)
          v16 = v15;
        else
          v16 = "";
        v17 = expf(*(float *)(v13 - 160));
        *(_DWORD *)buf = 136315650;
        v19 = "debug_print_candidates";
        v20 = 2082;
        v21 = v16;
        v22 = 2048;
        v23 = v17;
        _os_log_impl(&dword_1DA6F2000, v11, OS_LOG_TYPE_DEFAULT, "%s     %{public}s, omega: %f", buf, 0x20u);
        v9 = *a1;
        v8 = a1[1];
      }
      ++v10;
      v12 += 1000;
    }
    while (0x1CAC083126E978D5 * ((v8 - v9) >> 3) > v10);
  }
}

void KB::FilterZeroProbability::~FilterZeroProbability(KB::FilterZeroProbability *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterZeroProbability::filter_description(KB::FilterZeroProbability *this)
{
  return "FilterZeroProbability";
}

_QWORD *KB::FilterZeroProbability::filter_candidates(KB::FilterZeroProbability *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v5;
  _QWORD *result;
  uint64_t v7;
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v5 = *((_QWORD *)a4 + 7);
  v8[0] = &off_1EA0FDFD8;
  v9 = v8;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v5, (uint64_t)"FilterZeroProbability", v8);
  result = v9;
  if (v9 == v8)
  {
    v7 = 4;
    result = v8;
  }
  else
  {
    if (!v9)
      return result;
    v7 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

void std::__function::__func<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA0FDFD8;
  return result;
}

void std::__function::__func<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA0FDFD8;
}

BOOL std::__function::__func<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t a2, unsigned __int16 **a3)
{
  unsigned __int16 *v3;
  float v4;
  float v5;

  v3 = *a3;
  v4 = expf(*(float *)(a2 + 744));
  v5 = v4;
  if (v3 && v4 == 0.0)
    KB::String::append(v3, "omega=0", 0xFFFFuLL);
  return v5 == 0.0;
}

void KB::FilterIncomplete::~FilterIncomplete(KB::FilterIncomplete *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterIncomplete::filter_description(KB::FilterIncomplete *this)
{
  return "FilterIncomplete";
}

_QWORD *KB::FilterIncomplete::filter_candidates(KB::FilterIncomplete *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v5;
  _QWORD *result;
  uint64_t v7;
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v5 = *((_QWORD *)a4 + 7);
  v8[0] = &off_1EA0FE020;
  v9 = v8;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v5, (uint64_t)"FilterIncomplete", v8);
  result = v9;
  if (v9 == v8)
  {
    v7 = 4;
    result = v8;
  }
  else
  {
    if (!v9)
      return result;
    v7 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

void std::__function::__func<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA0FE020;
  return result;
}

void std::__function::__func<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA0FE020;
}

uint64_t std::__function::__func<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, _QWORD *a2, KB::String **a3)
{
  _BOOL8 v3;
  uint64_t v4;
  int v5;
  int v6;
  BOOL v7;
  const char *v8;
  const char *v9;

  if (*a2)
    return 0;
  v4 = a2[1];
  v5 = *(_DWORD *)(v4 + 132);
  v6 = *(_DWORD *)(v4 - 108);
  v3 = (v5 & 0x10000000 | v6 & 0x20000000) != 0;
  if (*a3)
    v7 = (v5 & 0x10000000 | v6 & 0x20000000) == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = "no";
    if ((v5 & 0x10000000) != 0)
      v9 = "yes";
    else
      v9 = "no";
    if ((v6 & 0x20000000) != 0)
      v8 = "yes";
    KB::String::append_format(*a3, "needs_prefix=%s, needs_suffix=%s", v9, v8);
    return 1;
  }
  return v3;
}

void KB::FilterControlCharacters::~FilterControlCharacters(KB::FilterControlCharacters *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterControlCharacters::filter_description(KB::FilterControlCharacters *this)
{
  return "FilterControlCharacters";
}

_QWORD *KB::FilterControlCharacters::filter_candidates(KB::FilterControlCharacters *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v5;
  _QWORD *result;
  uint64_t v7;
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v5 = *((_QWORD *)a4 + 7);
  v8[0] = &off_1EA0FE068;
  v9 = v8;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v5, (uint64_t)"FilterControlCharacters", v8);
  result = v9;
  if (v9 == v8)
  {
    v7 = 4;
    result = v8;
  }
  else
  {
    if (!v9)
      return result;
    v7 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

void std::__function::__func<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA0FE068;
  return result;
}

void std::__function::__func<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA0FE068;
}

BOOL std::__function::__func<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, _WORD *a2, KB::String **a3)
{
  KB::String *v3;
  KB *v4;
  _BOOL8 has_control_characters;
  _BOOL8 v6;
  BOOL v7;

  v3 = *a3;
  v4 = (KB *)(a2 + 444);
  if (!a2[444])
    KB::Candidate::compute_string((KB::Candidate *)a2);
  has_control_characters = KB::string_has_control_characters(v4, (const KB::String *)a2);
  v6 = has_control_characters;
  if (v3)
    v7 = !has_control_characters;
  else
    v7 = 1;
  if (!v7)
    KB::String::append_format(v3, "candidate word contains control characters");
  return v6;
}

void KB::FilterNotSuggestibleForInput::~FilterNotSuggestibleForInput(KB::FilterNotSuggestibleForInput *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterNotSuggestibleForInput::filter_description(KB::FilterNotSuggestibleForInput *this)
{
  return "FilterNotSuggestibleForInput";
}

void KB::FilterNotSuggestibleForInput::filter_candidates(KB::FilterNotSuggestibleForInput *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  const KB::Candidate *v45;
  const KB::Candidate *v46;
  uint64_t v47;
  const KB::Candidate **v48;
  _BYTE v49[24];
  _BYTE *v50;
  _BYTE v51[1000];
  _QWORD v52[3];
  _QWORD *v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 9) != 1)
    goto LABEL_5;
  v8 = *((_QWORD *)a4 + 2);
  if (v8)
  {
    do
      v9 = __ldaxr((unsigned int *)v8);
    while (__stlxr(v9 + 1, (unsigned int *)v8));
  }
  v10 = *(_QWORD *)(v8 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v8);
  if (KB::FilterNotSuggestibleForInput::does_candidate_list_contain_input_match((uint64_t)a2, (uint64_t)a3, v10))
  {
LABEL_5:
    KB::Candidate::Candidate((KB::Candidate *)v51, a3);
    v11 = *((_QWORD *)a4 + 2);
    if (v11)
    {
      do
        v12 = __ldaxr((unsigned int *)v11);
      while (__stlxr(v12 + 1, (unsigned int *)v11));
    }
    v13 = *(_QWORD *)(v11 + 8) + 144;
    WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v11);
    std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v49, v13);
    v14 = *((_DWORD *)this + 8);
    v43 = *(_OWORD *)((char *)this + 8);
    v44 = *((_QWORD *)this + 3);
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v15 = *((_QWORD *)a4 + 7);
    v16 = operator new(0x48uLL);
    *(_QWORD *)v16 = &off_1EA0FDF90;
    v16[2] = v14;
    *((_QWORD *)v16 + 2) = this;
    *((_QWORD *)v16 + 3) = a4;
    *((_QWORD *)v16 + 4) = v51;
    *((_QWORD *)v16 + 5) = &v43;
    *((_QWORD *)v16 + 6) = v49;
    *((_QWORD *)v16 + 7) = a3;
    *((_QWORD *)v16 + 8) = &v45;
    v53 = v16;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v15, (uint64_t)"FilterNotSuggestibleForInput", v52);
    v19 = v53;
    if (v53 == v52)
    {
      v20 = 4;
      v19 = v52;
    }
    else
    {
      if (!v53)
        goto LABEL_12;
      v20 = 5;
    }
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v19 + 8 * v20))(v19, v17, v18);
LABEL_12:
    std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)a2, *((_QWORD *)a2 + 1), v45, v46, 0x1CAC083126E978D5 * ((v46 - v45) >> 3));
    v48 = &v45;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v48);
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v21 = *((_QWORD *)a4 + 7);
    v22 = operator new(0x48uLL);
    *(_QWORD *)v22 = &off_1EA0FDF90;
    v22[2] = v14;
    *((_QWORD *)v22 + 2) = this;
    *((_QWORD *)v22 + 3) = a4;
    *((_QWORD *)v22 + 4) = v51;
    *((_QWORD *)v22 + 5) = &v43;
    *((_QWORD *)v22 + 6) = v49;
    *((_QWORD *)v22 + 7) = a3;
    *((_QWORD *)v22 + 8) = &v45;
    v53 = v22;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2 + 24, v21, (uint64_t)"FilterNotSuggestibleForInput", v52);
    v25 = v53;
    if (v53 == v52)
    {
      v26 = 4;
      v25 = v52;
    }
    else
    {
      if (!v53)
        goto LABEL_17;
      v26 = 5;
    }
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v25 + 8 * v26))(v25, v23, v24);
LABEL_17:
    std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)a2 + 3, *((_QWORD *)a2 + 4), v45, v46, 0x1CAC083126E978D5 * ((v46 - v45) >> 3));
    v48 = &v45;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v48);
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v27 = *((_QWORD *)a4 + 7);
    v28 = operator new(0x48uLL);
    *(_QWORD *)v28 = &off_1EA0FDF90;
    v28[2] = v14;
    *((_QWORD *)v28 + 2) = this;
    *((_QWORD *)v28 + 3) = a4;
    *((_QWORD *)v28 + 4) = v51;
    *((_QWORD *)v28 + 5) = &v43;
    *((_QWORD *)v28 + 6) = v49;
    *((_QWORD *)v28 + 7) = a3;
    *((_QWORD *)v28 + 8) = &v45;
    v53 = v28;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2 + 48, v27, (uint64_t)"FilterNotSuggestibleForInput", v52);
    v31 = v53;
    if (v53 == v52)
    {
      v32 = 4;
      v31 = v52;
    }
    else
    {
      if (!v53)
        goto LABEL_22;
      v32 = 5;
    }
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v31 + 8 * v32))(v31, v29, v30);
LABEL_22:
    std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)a2 + 6, *((_QWORD *)a2 + 7), v45, v46, 0x1CAC083126E978D5 * ((v46 - v45) >> 3));
    v48 = &v45;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v48);
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v33 = *((_QWORD *)a4 + 7);
    v34 = operator new(0x48uLL);
    *(_QWORD *)v34 = &off_1EA0FDF90;
    v34[2] = v14;
    *((_QWORD *)v34 + 2) = this;
    *((_QWORD *)v34 + 3) = a4;
    *((_QWORD *)v34 + 4) = v51;
    *((_QWORD *)v34 + 5) = &v43;
    *((_QWORD *)v34 + 6) = v49;
    *((_QWORD *)v34 + 7) = a3;
    *((_QWORD *)v34 + 8) = &v45;
    v53 = v34;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2 + 72, v33, (uint64_t)"FilterNotSuggestibleForInput", v52);
    v37 = v53;
    if (v53 == v52)
    {
      v38 = 4;
      v37 = v52;
    }
    else
    {
      if (!v53)
        goto LABEL_27;
      v38 = 5;
    }
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v37 + 8 * v38))(v37, v35, v36);
LABEL_27:
    std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)a2 + 9, *((_QWORD *)a2 + 10), v45, v46, 0x1CAC083126E978D5 * ((v46 - v45) >> 3));
    v48 = &v45;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v48);
    v41 = v50;
    if (v50 == v49)
    {
      v42 = 4;
      v41 = v49;
    }
    else
    {
      if (!v50)
      {
LABEL_32:
        KB::Candidate::~Candidate((KB::Candidate *)v51);
        return;
      }
      v42 = 5;
    }
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v41 + 8 * v42))(v41, v39, v40);
    goto LABEL_32;
  }
}

uint64_t KB::FilterNotSuggestibleForInput::does_candidate_list_contain_input_match(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  _QWORD *v4;

  v3 = *(_QWORD **)a1;
  v4 = *(_QWORD **)(a1 + 8);
  if (*(_QWORD **)a1 == v4)
    return 0;
  while ((*(_BYTE *)(v3[1] + 240 * *v3 - 134) & 0x80) != 0
       || (KB::CandidateFilter::candidate_matches_input((uint64_t)v3, a2, a3) & 1) == 0)
  {
    v3 += 125;
    if (v3 == v4)
      return 0;
  }
  return 1;
}

void std::__function::__func<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1},std::allocator<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1}>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1},std::allocator<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1}>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x48uLL);
  *(_QWORD *)v2 = &off_1EA0FDF90;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  result = *(__n128 *)(a1 + 56);
  *(__n128 *)(v2 + 56) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1},std::allocator<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1}>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a2 = &off_1EA0FDF90;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1},std::allocator<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1}>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, const KB::Candidate *a2, KB::String **a3)
{
  KB::String *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  _BOOL4 v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _BOOL4 v20;
  TI::VulgarWordUsageDatabaseWrapper *v21;
  BOOL is_allowlisted_somewhere;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  KB::String *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  const KB::Word *v31;
  _QWORD v33[5];
  _QWORD v34[5];
  _BYTE v35[24];
  uint64_t v36;
  _QWORD v37[5];
  uint64_t v38;
  void *v39;
  _BYTE v40[240];
  unsigned __int16 v41[500];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  v6 = *(_QWORD *)(a1 + 16);
  KB::FilterNotSuggestibleForInput::ovs_words_across_languages(a2, *(unsigned int ***)(a1 + 24), (uint64_t)v35);
  v7 = v36;
  v8 = v37[3];
  if (KB::CandidateFilter::is_suggestible_for_input((uint64_t *)a2, *(_QWORD **)(a1 + 32), *(_DWORD *)(a1 + 8), *(KB::WordSuggestionPolicy **)(a1 + 40), *(_QWORD *)(a1 + 48), v5))v9 = v7 == 0;
  else
    v9 = 0;
  if (v9)
    goto LABEL_27;
  v10 = *((_QWORD *)a2 + 1);
  v11 = v10 + 240 * *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    v12 = 240 * *(_QWORD *)a2;
    while ((*(_BYTE *)(v10 + 107) & 8) == 0)
    {
      v10 += 240;
      v12 -= 240;
      if (!v12)
      {
        v10 = v11;
        break;
      }
    }
  }
  v13 = !v8 && v10 == v11;
  v14 = !v13;
  v15 = simular_swear_word_policy_v1_setting
      ? objc_msgSend((id)simular_swear_word_policy_v1_setting, "BOOLValue")
      : _os_feature_enabled_impl();
  if ((v15 & v14) == 1 && *(_DWORD *)(v6 + 40) == 2)
    goto LABEL_27;
  if (simular_swear_word_policy_v2_setting)
    v16 = objc_msgSend((id)simular_swear_word_policy_v2_setting, "BOOLValue");
  else
    v16 = _os_feature_enabled_impl();
  if ((v16 & v14) == 1)
  {
    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
    std::unordered_map<KB::String,KB::Word>::unordered_map((uint64_t)v34, (uint64_t)v37);
    if (KB::Candidate::every_vulgar_word_is_allowlisted(a2, v17, v34, 0))
    {
      v18 = *(_DWORD *)(v6 + 40);
      std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v34);
      if (v18 == 1)
      {
LABEL_27:
        v19 = 0;
        goto LABEL_56;
      }
    }
    else
    {
      std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v34);
    }
  }
  v20 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 3168) == 4 && v14;
  if (!v20
    || (v21 = *(TI::VulgarWordUsageDatabaseWrapper **)(*(_QWORD *)(a1 + 24) + 48),
        std::unordered_map<KB::String,KB::Word>::unordered_map((uint64_t)v33, (uint64_t)v37),
        is_allowlisted_somewhere = KB::Candidate::every_vulgar_word_is_allowlisted_somewhere(a2, v21, v33, 0),
        std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v33),
        v19 = 0,
        !is_allowlisted_somewhere))
  {
    if (simular_swear_word_policy_v2_setting)
    {
      if ((objc_msgSend((id)simular_swear_word_policy_v2_setting, "BOOLValue") & 1) == 0)
        goto LABEL_55;
    }
    else if (!_os_feature_enabled_impl())
    {
      goto LABEL_55;
    }
    v23 = *(_QWORD **)(a1 + 56);
    if (*(_QWORD *)a2 == *v23)
    {
      v24 = *((_QWORD *)a2 + 1);
      if ((*(_BYTE *)(v24 + 107) & 8) != 0)
      {
        v25 = *(_QWORD *)a2 - 1;
        v26 = (KB::String *)(v24 + 240 * v25);
        if ((*((_BYTE *)v26 + 107) & 8) == 0)
        {
          v27 = v23[1];
          if (v24 != v27)
          {
            v19 = 1;
            if (KB::String::equal(v26, (const KB::String *)(v27 + 240 * v25), 1))
              goto LABEL_56;
            KB::Candidate::Candidate((KB::Candidate *)v41, a2);
            KB::Candidate::clear((KB::Candidate *)v41);
            if (*(_QWORD *)a2)
            {
              v28 = 0;
              v29 = 0;
              do
              {
                KB::Word::Word((KB::Word *)v40, (const KB::Word *)(*((_QWORD *)a2 + 1) + v28));
                if ((v40[107] & 8) != 0)
                  goto LABEL_50;
                KB::Word::lowercased_string((KB::Word *)v40, (KB::String *)&v38);
                v30 = std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::find<KB::String>(v37, &v38);
                if (v39 && BYTE6(v38) == 1)
                  free(v39);
                if (v30)
LABEL_50:
                  v31 = (const KB::Word *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + v28);
                else
                  v31 = (const KB::Word *)v40;
                KB::Candidate::append(v41, v31);
                KB::Word::~Word((KB::Word *)v40);
                ++v29;
                v28 += 240;
              }
              while (v29 < *(_QWORD *)a2);
            }
            std::vector<KB::Candidate>::push_back[abi:nn180100](*(uint64_t **)(a1 + 64), (const KB::Candidate *)v41);
            KB::Candidate::~Candidate((KB::Candidate *)v41);
          }
        }
      }
    }
LABEL_55:
    v19 = 1;
  }
LABEL_56:
  std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v37);
  std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v35);
  return v19;
}

void KB::FilterNotSuggestibleForInput::ovs_words_across_languages(const KB::Candidate *a1@<X1>, unsigned int **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 v19;
  unsigned int *v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL4 v26;
  int v27;
  int v28;
  void *v29;
  uint64_t v30;
  KB::Word *v31;
  uint64_t v32;
  const KB::Word *v33;
  const KB::Word *v34;
  unsigned __int16 *v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  unsigned __int16 *v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  unsigned int *v43;
  unsigned int v44;
  unsigned int *v45;
  unsigned int v46;
  const KB::Word *v47;
  uint64_t v48;
  _BOOL4 v49;
  unsigned __int16 *v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  unsigned __int16 *v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  char *v59;
  const KB::CandidateFilterResources *v60;
  uint64_t v61;
  uint64_t v63[3];
  KB::String *v64;
  void *v65;
  uint64_t v66;
  void *v67;
  void **v68[4];
  const void *v69[2];
  uint64_t v70;
  int v71;
  _BYTE v72[32];
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  _BYTE v77[32];
  char v78;
  _QWORD *v79;
  int v80;
  uint64_t v81;
  void *v82;
  const void *v83;
  void *v84;
  uint64_t v85;
  int v86;
  _BYTE v87[8];
  void *v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;
  int v94;
  char v95;
  _QWORD *v96;
  int v97;
  uint64_t v98;

  v98 = *MEMORY[0x1E0C80C00];
  v58 = *(_QWORD *)a1;
  v5 = *((_QWORD *)a1 + 2);
  if (v5 && (v7 = (char *)malloc_type_malloc(240 * v5, 0x10B2040DF775671uLL)) != 0)
  {
    v8 = v7;
    v9 = *(_QWORD *)a1;
    v59 = v7;
    if (*(_QWORD *)a1)
    {
      v10 = 0;
      v11 = *((_QWORD *)a1 + 1);
      v12 = 240 * v9;
      do
      {
        KB::Word::Word((KB::Word *)&v8[v10], (const KB::Word *)(v11 + v10));
        v10 += 240;
      }
      while (v12 != v10);
    }
  }
  else
  {
    v59 = 0;
  }
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  *(_OWORD *)(a3 + 40) = 0u;
  v61 = a3 + 40;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_DWORD *)(a3 + 72) = 1065353216;
  v60 = (const KB::CandidateFilterResources *)a2;
  v13 = a2[2];
  if (!v13)
    goto LABEL_50;
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 + 1, v13));
  WTF::RefCounted<KB::DictionaryContainer>::deref(v13);
  v15 = a2[2];
  if (v15)
  {
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 + 1, v15));
  }
  v17 = *((_QWORD *)v15 + 6);
  v18 = v17 - *((_QWORD *)v15 + 5);
  if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v18 >> 4)) <= 2)
    v19 = v18 != 352 || *(_DWORD *)(v17 - 16) == -2;
  else
    v19 = 0;
  WTF::RefCounted<KB::DictionaryContainer>::deref(v15);
  v20 = a2[2];
  if (v20)
  {
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 + 1, v20));
  }
  v22 = *((_QWORD *)v20 + 5);
  v23 = *((_QWORD *)v20 + 6);
  if (v22 == v23)
  {
    v28 = 1;
LABEL_48:
    WTF::RefCounted<KB::DictionaryContainer>::deref(v20);
    goto LABEL_49;
  }
  do
  {
    KB::String::String((KB::String *)&v81, (const KB::String *)v22);
    KB::String::String((KB::String *)&v83, (const KB::String *)(v22 + 32));
    KB::String::String((KB::String *)v87, (const KB::String *)(v22 + 64));
    KB::String::String((KB::String *)&v89, (const KB::String *)(v22 + 96));
    KB::String::String((KB::String *)&v91, (const KB::String *)(v22 + 128));
    v24 = *(_QWORD *)(v22 + 160);
    v94 = *(_DWORD *)(v22 + 168);
    v93 = v24;
    v26 = (_DWORD)v24 != -2 && BYTE4(v24) != 0;
    if (*((_QWORD *)&v91 + 1) && BYTE6(v91) == 1)
      free(*((void **)&v91 + 1));
    if (*((_QWORD *)&v89 + 1) && BYTE6(v89) == 1)
      free(*((void **)&v89 + 1));
    if (v88 && v87[6] == 1)
      free(v88);
    if (v84 && BYTE6(v83) == 1)
      free(v84);
    if (v82 && BYTE6(v81) == 1)
      free(v82);
    v22 += 176;
    v27 = v22 == v23 || v26;
  }
  while (v27 != 1);
  v28 = !v26;
  if (v20)
    goto LABEL_48;
LABEL_49:
  if (((v19 | v28) & 1) == 0)
  {
    v29 = v59;
    if (!v58)
      goto LABEL_93;
    v33 = (const KB::Word *)&v59[240 * v58];
    v34 = (const KB::Word *)v59;
    do
    {
      KB::Word::Word((KB::Word *)&v81, v34);
      if ((BYTE11(v89) & 0x38) != 0)
      {
        v68[0] = (void **)&v81;
        v35 = (unsigned __int16 *)std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String const&>,std::tuple<>>(a3, &v81, (const KB::String **)v68);
        KB::String::operator=((KB::String *)(v35 + 24), (KB::String *)&v81);
        KB::ByteString::operator=(v35 + 40, &v83);
        *((_QWORD *)v35 + 12) = v85;
        *((_DWORD *)v35 + 26) = v86;
        KB::String::operator=((KB::String *)(v35 + 56), (KB::String *)v87);
        v36 = v90;
        v38 = v91;
        v37 = v92;
        *((_OWORD *)v35 + 9) = v89;
        *((_OWORD *)v35 + 10) = v36;
        *((_OWORD *)v35 + 11) = v38;
        *((_OWORD *)v35 + 12) = v37;
        KB::String::operator=((KB::String *)(v35 + 104), (KB::String *)&v93);
        *((_BYTE *)v35 + 240) = v95;
        if (v35 + 24 != (unsigned __int16 *)&v81)
        {
          *((_DWORD *)v35 + 70) = v97;
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((_QWORD *)v35 + 31, v96);
        }
        if ((BYTE11(v89) & 8) != 0)
        {
          v68[0] = (void **)&v81;
          v39 = (unsigned __int16 *)std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String const&>,std::tuple<>>(v61, &v81, (const KB::String **)v68);
          KB::String::operator=((KB::String *)(v39 + 24), (KB::String *)&v81);
          KB::ByteString::operator=(v39 + 40, &v83);
          *((_QWORD *)v39 + 12) = v85;
          *((_DWORD *)v39 + 26) = v86;
          KB::String::operator=((KB::String *)(v39 + 56), (KB::String *)v87);
          v40 = v90;
          v42 = v91;
          v41 = v92;
          *((_OWORD *)v39 + 9) = v89;
          *((_OWORD *)v39 + 10) = v40;
          *((_OWORD *)v39 + 11) = v42;
          *((_OWORD *)v39 + 12) = v41;
          KB::String::operator=((KB::String *)(v39 + 104), (KB::String *)&v93);
          *((_BYTE *)v39 + 240) = v95;
          if (v39 + 24 != (unsigned __int16 *)&v81)
          {
            *((_DWORD *)v39 + 70) = v97;
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((_QWORD *)v39 + 31, v96);
          }
        }
      }
      else
      {
        v43 = (unsigned int *)*((_QWORD *)v60 + 2);
        if (v43)
        {
          do
            v44 = __ldaxr(v43);
          while (__stlxr(v44 + 1, v43));
          WTF::RefCounted<KB::DictionaryContainer>::deref(v43);
          v45 = (unsigned int *)*((_QWORD *)v60 + 2);
          if (v45)
          {
            do
              v46 = __ldaxr(v45);
            while (__stlxr(v46 + 1, v45));
            KB::DictionaryContainer::lookup((uint64_t)v45, (const KB::String *)&v81, 1, 1, v63);
            WTF::RefCounted<KB::DictionaryContainer>::deref(v45);
          }
          else
          {
            KB::DictionaryContainer::lookup(0, (const KB::String *)&v81, 1, 1, v63);
          }
          v47 = (const KB::Word *)v63[0];
          v48 = v63[1];
          while (v47 != (const KB::Word *)v48)
          {
            KB::Word::Word((KB::Word *)v68, v47);
            if ((BYTE11(v73) & 0x38) != 0)
            {
              KB::Word::lowercased_string((KB::Word *)v68, (KB::String *)&v66);
              KB::Word::lowercased_string((KB::Word *)&v81, (KB::String *)&v64);
              v49 = KB::String::equal((KB::String *)&v66, (const KB::String *)&v64, 1);
              if (v65 && BYTE6(v64) == 1)
                free(v65);
              if (v67 && BYTE6(v66) == 1)
                free(v67);
              if (v49)
              {
                KB::Word::lowercased_string((KB::Word *)v68, (KB::String *)&v66);
                v64 = (KB::String *)&v66;
                v50 = (unsigned __int16 *)std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>(a3, &v66, &v64);
                KB::String::operator=((KB::String *)(v50 + 24), (KB::String *)v68);
                KB::ByteString::operator=(v50 + 40, v69);
                *((_QWORD *)v50 + 12) = v70;
                *((_DWORD *)v50 + 26) = v71;
                KB::String::operator=((KB::String *)(v50 + 56), (KB::String *)v72);
                v51 = v74;
                v53 = v75;
                v52 = v76;
                *((_OWORD *)v50 + 9) = v73;
                *((_OWORD *)v50 + 10) = v51;
                *((_OWORD *)v50 + 11) = v53;
                *((_OWORD *)v50 + 12) = v52;
                KB::String::operator=((KB::String *)(v50 + 104), (KB::String *)v77);
                *((_BYTE *)v50 + 240) = v78;
                if (v50 + 24 != (unsigned __int16 *)v68)
                {
                  *((_DWORD *)v50 + 70) = v80;
                  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((_QWORD *)v50 + 31, v79);
                }
                if (v67 && BYTE6(v66) == 1)
                  free(v67);
                if ((BYTE11(v73) & 8) != 0)
                {
                  KB::Word::lowercased_string((KB::Word *)v68, (KB::String *)&v66);
                  v64 = (KB::String *)&v66;
                  v54 = (unsigned __int16 *)std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>(v61, &v66, &v64);
                  KB::String::operator=((KB::String *)(v54 + 24), (KB::String *)v68);
                  KB::ByteString::operator=(v54 + 40, v69);
                  *((_QWORD *)v54 + 12) = v70;
                  *((_DWORD *)v54 + 26) = v71;
                  KB::String::operator=((KB::String *)(v54 + 56), (KB::String *)v72);
                  v55 = v74;
                  v57 = v75;
                  v56 = v76;
                  *((_OWORD *)v54 + 9) = v73;
                  *((_OWORD *)v54 + 10) = v55;
                  *((_OWORD *)v54 + 11) = v57;
                  *((_OWORD *)v54 + 12) = v56;
                  KB::String::operator=((KB::String *)(v54 + 104), (KB::String *)v77);
                  *((_BYTE *)v54 + 240) = v78;
                  if (v54 + 24 != (unsigned __int16 *)v68)
                  {
                    *((_DWORD *)v54 + 70) = v80;
                    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((_QWORD *)v54 + 31, v79);
                  }
                  if (v67 && BYTE6(v66) == 1)
                    free(v67);
                }
              }
            }
            KB::Word::~Word((KB::Word *)v68);
            v47 = (const KB::Word *)((char *)v47 + 240);
          }
          v68[0] = (void **)v63;
          std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](v68);
          v33 = (const KB::Word *)&v59[240 * v58];
        }
      }
      KB::Word::~Word((KB::Word *)&v81);
      v34 = (const KB::Word *)((char *)v34 + 240);
    }
    while (v34 != v33);
  }
LABEL_50:
  v29 = v59;
  if (v58)
  {
    v30 = 240 * v58;
    v31 = (KB::Word *)v59;
    do
    {
      KB::Word::~Word(v31);
      v31 = (KB::Word *)(v32 + 240);
      v30 -= 240;
    }
    while (v30);
  }
LABEL_93:
  free(v29);
}

uint64_t std::unordered_map<KB::String,KB::Word>::unordered_map(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  _QWORD *v5;
  _QWORD *v6;
  KB::String *v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  v5 = *(_QWORD **)(a2 + 16);
  if (v5)
  {
    v6 = (_QWORD *)(a1 + 16);
    do
    {
      if (v5[3])
        v7 = (KB::String *)v5[3];
      else
        v7 = (KB::String *)(v5 + 4);
      v8 = KB::String::hash(v7, (const char *)*((unsigned __int16 *)v5 + 8));
      v9 = v8;
      v10 = *(_QWORD *)(a1 + 8);
      if (v10)
      {
        v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
        v11.i16[0] = vaddlv_u8(v11);
        v12 = v11.u32[0];
        if (v11.u32[0] > 1uLL)
        {
          v2 = v8;
          if (v10 <= v8)
            v2 = v8 % v10;
        }
        else
        {
          v2 = ((_DWORD)v10 - 1) & v8;
        }
        v13 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v2);
        if (v13)
        {
          v14 = (_QWORD *)*v13;
          if (*v13)
          {
            do
            {
              v15 = v14[1];
              if (v15 == v9)
              {
                if (v14 == v5 || KB::String::equal((KB::String *)(v14 + 2), (const KB::String *)(v5 + 2), 1))
                  goto LABEL_45;
              }
              else
              {
                if (v12 > 1)
                {
                  if (v15 >= v10)
                    v15 %= v10;
                }
                else
                {
                  v15 &= v10 - 1;
                }
                if (v15 != v2)
                  break;
              }
              v14 = (_QWORD *)*v14;
            }
            while (v14);
          }
        }
      }
      v16 = operator new(0x120uLL);
      *v16 = 0;
      v16[1] = v9;
      KB::String::String((KB::String *)(v16 + 2), (const KB::String *)(v5 + 2));
      KB::Word::Word((KB::Word *)(v16 + 6), (const KB::Word *)(v5 + 6));
      v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
      v18 = *(float *)(a1 + 32);
      if (!v10 || (float)(v18 * (float)v10) < v17)
      {
        v19 = (v10 & (v10 - 1)) != 0;
        if (v10 < 3)
          v19 = 1;
        v20 = v19 | (2 * v10);
        v21 = vcvtps_u32_f32(v17 / v18);
        if (v20 <= v21)
          v22 = v21;
        else
          v22 = v20;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v22);
        v10 = *(_QWORD *)(a1 + 8);
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v10 <= v9)
            v2 = v9 % v10;
          else
            v2 = v9;
        }
        else
        {
          v2 = ((_DWORD)v10 - 1) & v9;
        }
      }
      v23 = *(_QWORD *)a1;
      v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v2);
      if (v24)
      {
        *v16 = *v24;
      }
      else
      {
        *v16 = *v6;
        *v6 = v16;
        *(_QWORD *)(v23 + 8 * v2) = v6;
        if (!*v16)
          goto LABEL_44;
        v25 = *(_QWORD *)(*v16 + 8);
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v25 >= v10)
            v25 %= v10;
        }
        else
        {
          v25 &= v10 - 1;
        }
        v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
      }
      *v24 = v16;
LABEL_44:
      ++*(_QWORD *)(a1 + 24);
LABEL_45:
      v5 = (_QWORD *)*v5;
    }
    while (v5);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  void *v5;

  v2 = *(_QWORD **)(a1 + 16);
  while (v2)
  {
    v3 = v2;
    v2 = (_QWORD *)*v2;
    KB::Word::~Word((KB::Word *)(v3 + 6));
    v4 = (void *)v3[3];
    if (v4 && *((_BYTE *)v3 + 22) == 1)
      free(v4);
    operator delete(v3);
  }
  v5 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v5)
    operator delete(v5);
  return a1;
}

_QWORD *std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String const&>,std::tuple<>>(uint64_t a1, _QWORD *a2, const KB::String **a3)
{
  unint64_t v3;
  KB::String *v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  void **v13;
  _QWORD *v14;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  if (a2[1])
    v7 = (KB::String *)a2[1];
  else
    v7 = (KB::String *)(a2 + 2);
  v8 = KB::String::hash(v7, (const char *)*(unsigned __int16 *)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v10 <= v8)
        v3 = v8 % v10;
    }
    else
    {
      v3 = ((_DWORD)v10 - 1) & v8;
    }
    v13 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      v14 = *v13;
      if (*v13)
      {
        do
        {
          v15 = v14[1];
          if (v15 == v9)
          {
            if (v14 + 2 == a2 || KB::String::equal((KB::String *)(v14 + 2), (const KB::String *)a2, 1))
              return v14;
          }
          else
          {
            if (v12 > 1)
            {
              if (v15 >= v10)
                v15 %= v10;
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v3)
              break;
          }
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
    }
  }
  v14 = operator new(0x120uLL);
  *v14 = 0;
  v14[1] = v9;
  KB::String::String((KB::String *)(v14 + 2), *a3);
  *((_OWORD *)v14 + 16) = 0u;
  *((_OWORD *)v14 + 17) = 0u;
  *((_OWORD *)v14 + 14) = 0u;
  *((_OWORD *)v14 + 15) = 0u;
  *((_OWORD *)v14 + 12) = 0u;
  *((_OWORD *)v14 + 13) = 0u;
  *((_OWORD *)v14 + 10) = 0u;
  *((_OWORD *)v14 + 11) = 0u;
  *((_OWORD *)v14 + 8) = 0u;
  *((_OWORD *)v14 + 9) = 0u;
  *((_OWORD *)v14 + 6) = 0u;
  *((_OWORD *)v14 + 7) = 0u;
  *((_OWORD *)v14 + 4) = 0u;
  *((_OWORD *)v14 + 5) = 0u;
  *((_OWORD *)v14 + 3) = 0u;
  KB::Word::Word((KB::Word *)(v14 + 6));
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v10 <= v9)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = ((_DWORD)v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v23)
  {
    *v14 = *v23;
LABEL_42:
    *v23 = v14;
    goto LABEL_43;
  }
  *v14 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v14;
  *(_QWORD *)(v22 + 8 * v3) = a1 + 16;
  if (*v14)
  {
    v24 = *(_QWORD *)(*v14 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v24 >= v10)
        v24 %= v10;
    }
    else
    {
      v24 &= v10 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_42;
  }
LABEL_43:
  ++*(_QWORD *)(a1 + 24);
  return v14;
}

_QWORD *std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>(uint64_t a1, _QWORD *a2, KB::String **a3)
{
  unint64_t v3;
  KB::String *v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  void **v13;
  _QWORD *v14;
  unint64_t v15;
  KB::String *v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  if (a2[1])
    v7 = (KB::String *)a2[1];
  else
    v7 = (KB::String *)(a2 + 2);
  v8 = KB::String::hash(v7, (const char *)*(unsigned __int16 *)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v10 <= v8)
        v3 = v8 % v10;
    }
    else
    {
      v3 = ((_DWORD)v10 - 1) & v8;
    }
    v13 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      v14 = *v13;
      if (*v13)
      {
        do
        {
          v15 = v14[1];
          if (v15 == v9)
          {
            if (v14 + 2 == a2 || KB::String::equal((KB::String *)(v14 + 2), (const KB::String *)a2, 1))
              return v14;
          }
          else
          {
            if (v12 > 1)
            {
              if (v15 >= v10)
                v15 %= v10;
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v3)
              break;
          }
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
    }
  }
  v14 = operator new(0x120uLL);
  *v14 = 0;
  v14[1] = v9;
  v16 = *a3;
  *((_DWORD *)v14 + 4) = 0x100000;
  *((_WORD *)v14 + 10) = 0;
  *((_BYTE *)v14 + 22) = 0;
  v14[3] = 0;
  KB::String::operator=((uint64_t)(v14 + 2), v16);
  *((_OWORD *)v14 + 16) = 0u;
  *((_OWORD *)v14 + 17) = 0u;
  *((_OWORD *)v14 + 14) = 0u;
  *((_OWORD *)v14 + 15) = 0u;
  *((_OWORD *)v14 + 12) = 0u;
  *((_OWORD *)v14 + 13) = 0u;
  *((_OWORD *)v14 + 10) = 0u;
  *((_OWORD *)v14 + 11) = 0u;
  *((_OWORD *)v14 + 8) = 0u;
  *((_OWORD *)v14 + 9) = 0u;
  *((_OWORD *)v14 + 6) = 0u;
  *((_OWORD *)v14 + 7) = 0u;
  *((_OWORD *)v14 + 4) = 0u;
  *((_OWORD *)v14 + 5) = 0u;
  *((_OWORD *)v14 + 3) = 0u;
  KB::Word::Word((KB::Word *)(v14 + 6));
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    v19 = 1;
    if (v10 >= 3)
      v19 = (v10 & (v10 - 1)) != 0;
    v20 = v19 | (2 * v10);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v22);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v10 <= v9)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = ((_DWORD)v10 - 1) & v9;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v24)
  {
    *v14 = *v24;
LABEL_42:
    *v24 = v14;
    goto LABEL_43;
  }
  *v14 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v14;
  *(_QWORD *)(v23 + 8 * v3) = a1 + 16;
  if (*v14)
  {
    v25 = *(_QWORD *)(*v14 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10)
        v25 %= v10;
    }
    else
    {
      v25 &= v10 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_42;
  }
LABEL_43:
  ++*(_QWORD *)(a1 + 24);
  return v14;
}

void KB::FilterNonVulgarIfTopCandidateVulgar::~FilterNonVulgarIfTopCandidateVulgar(KB::FilterNonVulgarIfTopCandidateVulgar *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterNonVulgarIfTopCandidateVulgar::filter_description(KB::FilterNonVulgarIfTopCandidateVulgar *this)
{
  return "FilterNonVulgarIfTopCandidateVulgar";
}

void KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::FilterNonVulgarIfTopCandidateVulgar *this, const KB::Candidate **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  const KB::Candidate *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL is_allowlisted;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _OWORD v14[2];
  int v15;
  _QWORD v16[3];
  _QWORD *v17;
  _OWORD buf[62];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (simular_swear_word_policy_v1_setting)
  {
    if ((objc_msgSend((id)simular_swear_word_policy_v1_setting, "BOOLValue", a3) & 1) != 0)
      goto LABEL_3;
  }
  else if ((_os_feature_enabled_impl() & 1) != 0)
  {
LABEL_3:
    v6 = *a2;
    if (*a2 == a2[1])
      return;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf[0]) = 136315138;
      *(_QWORD *)((char *)buf + 4) = "filter_candidates";
      _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  Swear Word Policy V1 Enabled", (uint8_t *)buf, 0xCu);
      v6 = *a2;
    }
    KB::Candidate::Candidate((KB::Candidate *)buf, v6);
    if (*(_QWORD *)&buf[0])
    {
      v7 = 240 * *(_QWORD *)&buf[0];
      v8 = *((_QWORD *)&buf[0] + 1);
      while ((*(_BYTE *)(v8 + 107) & 8) == 0)
      {
        v8 += 240;
        v7 -= 240;
        if (!v7)
          goto LABEL_27;
      }
    }
    else
    {
      v8 = *((_QWORD *)&buf[0] + 1);
    }
    if (v8 == *((_QWORD *)&buf[0] + 1) + 240 * *(_QWORD *)&buf[0])
      goto LABEL_27;
    if (simular_swear_word_policy_v2_setting)
    {
      if ((objc_msgSend((id)simular_swear_word_policy_v2_setting, "BOOLValue") & 1) == 0)
      {
LABEL_21:
        *((_DWORD *)a2 + 25) |= 1u;
        if ((unint64_t)(0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3)) >= 2)
        {
          v11 = *((_QWORD *)a4 + 7);
          v16[0] = &off_1EA0FE0B0;
          v16[1] = buf;
          v17 = v16;
          KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v11, (uint64_t)"FilterNonVulgarIfTopCandidateVulgar", v16);
          v12 = v17;
          if (v17 == v16)
          {
            v13 = 4;
            v12 = v16;
            goto LABEL_26;
          }
          if (v17)
          {
            v13 = 5;
LABEL_26:
            (*(void (**)(void))(*v12 + 8 * v13))();
          }
        }
LABEL_27:
        KB::Candidate::~Candidate((KB::Candidate *)buf);
        return;
      }
    }
    else if (!_os_feature_enabled_impl())
    {
      goto LABEL_21;
    }
    v9 = *((_QWORD *)a4 + 6);
    memset(v14, 0, sizeof(v14));
    v15 = 1065353216;
    is_allowlisted = KB::Candidate::every_vulgar_word_is_allowlisted(buf, v9, v14, 0);
    std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v14);
    if (is_allowlisted)
      goto LABEL_27;
    goto LABEL_21;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf[0]) = 136315138;
    *(_QWORD *)((char *)buf + 4) = "filter_candidates";
    _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  Swear Word Policy V1 Disabled", (uint8_t *)buf, 0xCu);
  }
}

void std::__function::__func<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA0FE0B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA0FE0B0;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t a2, KB::String **a3)
{
  KB::String *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  int v11;
  const char *v12;
  const char *v13;
  uint64_t v14;
  int v15;
  const char *v16;
  const char *v17;
  _BYTE v18[22];
  __int16 v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  v6 = *(_QWORD *)(a2 + 8);
  v7 = v6 + 240 * *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    v8 = 240 * *(_QWORD *)a2;
    while ((*(_BYTE *)(v6 + 107) & 8) == 0)
    {
      v6 += 240;
      v8 -= 240;
      if (!v8)
      {
        v6 = v7;
        break;
      }
    }
  }
  if (v5)
    v9 = v6 == v7;
  else
    v9 = 0;
  if (v9)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      v11 = *(unsigned __int16 *)(a2 + 888);
      if (!*(_WORD *)(a2 + 888))
      {
        KB::Candidate::compute_string((KB::Candidate *)a2);
        v11 = *(unsigned __int16 *)(a2 + 888);
      }
      v12 = *(const char **)(a2 + 896);
      if (!v12)
        v12 = (const char *)(a2 + 904);
      if (v11)
        v13 = v12;
      else
        v13 = "";
      v14 = *(_QWORD *)(a1 + 8);
      v15 = *(unsigned __int16 *)(v14 + 888);
      if (!*(_WORD *)(v14 + 888))
      {
        KB::Candidate::compute_string((KB::Candidate *)v14);
        v15 = *(unsigned __int16 *)(v14 + 888);
      }
      v16 = *(const char **)(v14 + 896);
      if (!v16)
        v16 = (const char *)(v14 + 904);
      *(_DWORD *)v18 = 136315650;
      *(_QWORD *)&v18[4] = "operator()";
      if (v15)
        v17 = v16;
      else
        v17 = "";
      *(_WORD *)&v18[12] = 2080;
      *(_QWORD *)&v18[14] = v13;
      v19 = 2080;
      v20 = v17;
      _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  Word %s is non-vulgar. Top candidate %s is a vulgar word leading to non-vulgar words to be removed.", v18, 0x20u);
    }
    KB::String::append_format(v5, "Word is non-vulgar. Top candidate is a vulgar word leading to non-vulgar words to be removed.", *(_OWORD *)v18);
  }
  return v6 == v7;
}

void KB::FilterNumberMismatch::~FilterNumberMismatch(KB::FilterNumberMismatch *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterNumberMismatch::filter_description(KB::FilterNumberMismatch *this)
{
  return "FilterNumberMismatch";
}

void KB::FilterNumberMismatch::filter_candidates(KB::FilterNumberMismatch *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  KB *v7;
  const KB::String *v8;
  BOOL has_nonnumbers;
  __CFString *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v7 = (const KB::CandidateFilterLookupContext *)((char *)a3 + 888);
  if (!*((_WORD *)a3 + 444))
    KB::Candidate::compute_string(a3);
  if (KB::string_has_numbers(v7, a2))
  {
    has_nonnumbers = KB::string_has_nonnumbers((KB *)(*((_QWORD *)a3 + 1) + 240 * *(_QWORD *)a3 - 240), v8);
    v10 = (__CFString *)*((_QWORD *)a4 + 7);
    if (has_nonnumbers)
    {
      v15[0] = &off_1EA0FE0F8;
      v15[1] = a3;
      v15[2] = a4;
      v16 = v15;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, (uint64_t)v10, (uint64_t)"FilterNumberMismatch", v15);
      v11 = v16;
      if (v16 == v15)
      {
        v12 = 4;
        v11 = v15;
      }
      else
      {
        if (!v16)
          return;
        v12 = 5;
      }
      (*(void (**)(void))(*v11 + 8 * v12))();
    }
    else
    {
      if (v10)
        CFStringAppendFormat(v10, 0, CFSTR("All candidates removed (last input word is purely numeric) by %s\n"), "filter_candidates");
      v14 = *(_QWORD *)a2;
      for (i = *((_QWORD *)a2 + 1); i != v14; KB::Candidate::~Candidate((KB::Candidate *)(i - 1000)))
        ;
      *((_QWORD *)a2 + 1) = v14;
    }
  }
}

void std::__function::__func<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA0FE0F8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FE0F8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, _WORD *a2, KB::String **a3)
{
  KB::String *v5;
  _LXLexicon *v6;
  _WORD *v7;
  _LXLexicon *v8;
  _BOOL4 v9;
  _BOOL4 v10;
  const char *v11;
  const char *v12;
  ByteString v14;
  unsigned __int16 v15;
  uint64_t v16;
  __int16 v17[3];
  char v18;
  void *v19;
  _QWORD v20[3];

  v20[2] = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  v6 = (_LXLexicon *)(a2 + 444);
  if (!a2[444])
    KB::Candidate::compute_string((KB::Candidate *)a2);
  KB::CandidateFilter::_sortkey_for_string(v6, *(const KB::String **)(a1 + 16), &v15);
  v7 = *(_WORD **)(a1 + 8);
  v8 = (_LXLexicon *)(v7 + 444);
  if (!v7[444])
    KB::Candidate::compute_string((KB::Candidate *)v7);
  KB::CandidateFilter::_sortkey_for_string(v8, *(const KB::String **)(a1 + 16), &v14);
  v9 = KB::ByteString::starts_with((KB::ByteString *)&v15, &v14);
  v10 = v9;
  if (v5 && !v9)
  {
    KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)v17);
    v11 = (const char *)v19;
    if (!v19)
      v11 = (const char *)v20;
    if (v17[0])
      v12 = v11;
    else
      v12 = "";
    KB::String::append_format(v5, "'%s' does not preserve numbers typed in the input manager string", v12);
    if (v19 && v18 == 1)
      free(v19);
  }
  if (v14.var0.var0.var0 >= 0xFu && v14.var0.var0.var1)
    MEMORY[0x1DF0A212C](v14.var0.var0.var1, 0x1000C8077774924);
  if (v15 >= 0xFu && v16)
    MEMORY[0x1DF0A212C](v16, 0x1000C8077774924);
  return !v10;
}

void KB::FilterNumberlikeTokenMismatch::~FilterNumberlikeTokenMismatch(KB::FilterNumberlikeTokenMismatch *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterNumberlikeTokenMismatch::filter_description(KB::FilterNumberlikeTokenMismatch *this)
{
  return "FilterNumberlikeTokenMismatch";
}

uint64_t KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::FilterNumberlikeTokenMismatch *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  KB *v7;
  uint64_t result;
  const KB::String *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned __int16 *v18;
  int v19;
  unsigned __int16 *v20;
  unsigned int *v21;
  unsigned int v22;
  __int128 v23;
  UChar32 v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned __int16 *v27;
  int v28;
  unsigned int *v29;
  unsigned int v30;
  __int128 v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  _QWORD v41[3];
  _QWORD *v42;
  uint64_t v43;
  void *v44;
  UChar32 c;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v7 = (const KB::CandidateFilterLookupContext *)((char *)a3 + 888);
  if (!*((_WORD *)a3 + 444))
    KB::Candidate::compute_string(a3);
  result = KB::string_has_numbers(v7, a2);
  if ((_DWORD)result)
  {
    if (*(_QWORD *)a3)
    {
      v10 = 0;
      v11 = 0;
      do
      {
        v12 = (uint64_t *)(*((_QWORD *)a3 + 1) + 240 * v10);
        v13 = KB::count_numbers((KB *)v12, v9);
        if (!v13)
          goto LABEL_41;
        if (v13 >= KB::count_letters((KB *)v12, v9))
          goto LABEL_40;
        v14 = *((unsigned __int16 *)v12 + 2);
        if (!*((_WORD *)v12 + 2))
        {
          KB::String::compute_length((unsigned __int16 *)v12);
          v14 = *((unsigned __int16 *)v12 + 2);
        }
        if (v14 < 3)
          goto LABEL_41;
        v15 = v12[1];
        if (!v15)
          v15 = (uint64_t)(v12 + 2);
        v43 = v15;
        LODWORD(v44) = 0;
        HIDWORD(v44) = *(unsigned __int16 *)v12;
        c = 0;
        KB::String::iterator::initialize(&v43);
        TI::Favonius::KeyClassification::KeyClassification((TI::Favonius::KeyClassification *)&v43, c);
        if ((v43 & 4) != 0)
        {
          v16 = (unsigned int *)*((_QWORD *)a4 + 2);
          if (v16)
          {
            do
              v17 = __ldaxr(v16);
            while (__stlxr(v17 + 1, v16));
            WTF::RefCounted<KB::DictionaryContainer>::deref(v16);
            v18 = (unsigned __int16 *)v12[1];
            if (!v18)
              v18 = (unsigned __int16 *)(v12 + 2);
            *(_QWORD *)&v37 = v18;
            DWORD2(v37) = 0;
            HIDWORD(v37) = *(unsigned __int16 *)v12;
            LODWORD(v38) = 0;
            KB::String::iterator::initialize((uint64_t *)&v37);
            v39 = v37;
            v40 = v38;
            KB::String::iterator::operator++((uint64_t *)&v39);
            v19 = *(unsigned __int16 *)v12;
            v20 = (unsigned __int16 *)v12[1];
            if (!v20)
              v20 = (unsigned __int16 *)(v12 + 2);
            *(_QWORD *)&v35 = v20;
            DWORD2(v35) = v19;
            HIDWORD(v35) = v19;
            LODWORD(v36) = 0;
            KB::String::iterator::initialize((uint64_t *)&v35);
            KB::String::String((KB::String *)&v43, (const KB::String::iterator *)&v39, (const KB::String::iterator *)&v35);
            v21 = (unsigned int *)*((_QWORD *)a4 + 2);
            if (v21)
            {
              do
                v22 = __ldaxr(v21);
              while (__stlxr(v22 + 1, v21));
              KB::DictionaryContainer::lookup((uint64_t)v21, (const KB::String *)&v43, 0, 0, (uint64_t *)&v39);
              WTF::RefCounted<KB::DictionaryContainer>::deref(v21);
            }
            else
            {
              KB::DictionaryContainer::lookup(0, (const KB::String *)&v43, 0, 0, (uint64_t *)&v39);
            }
            v23 = v39;
            *(_QWORD *)&v37 = &v39;
            std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
            if (v44 && BYTE6(v43) == 1)
              free(v44);
            if ((_QWORD)v23 != *((_QWORD *)&v23 + 1))
              goto LABEL_40;
          }
        }
        v24 = KB::String::last((KB::String *)v12);
        TI::Favonius::KeyClassification::KeyClassification((TI::Favonius::KeyClassification *)&v43, v24);
        if ((v43 & 4) == 0)
          goto LABEL_41;
        v25 = (unsigned int *)*((_QWORD *)a4 + 2);
        if (!v25)
          goto LABEL_41;
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 + 1, v25));
        WTF::RefCounted<KB::DictionaryContainer>::deref(v25);
        v27 = v12[1] ? (unsigned __int16 *)v12[1] : (unsigned __int16 *)(v12 + 2);
        *(_QWORD *)&v39 = v27;
        DWORD2(v39) = 0;
        v28 = *(unsigned __int16 *)v12;
        HIDWORD(v39) = v28;
        LODWORD(v40) = 0;
        KB::String::iterator::initialize((uint64_t *)&v39);
        *(_QWORD *)&v35 = v27;
        DWORD2(v35) = v28;
        HIDWORD(v35) = v28;
        LODWORD(v36) = 0;
        KB::String::iterator::initialize((uint64_t *)&v35);
        v37 = v35;
        v38 = v36;
        KB::String::iterator::operator--((KB::String::iterator *)&v37);
        KB::String::String((KB::String *)&v43, (const KB::String::iterator *)&v39, (const KB::String::iterator *)&v37);
        v29 = (unsigned int *)*((_QWORD *)a4 + 2);
        if (v29)
        {
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 + 1, v29));
          KB::DictionaryContainer::lookup((uint64_t)v29, (const KB::String *)&v43, 0, 0, (uint64_t *)&v39);
          WTF::RefCounted<KB::DictionaryContainer>::deref(v29);
        }
        else
        {
          KB::DictionaryContainer::lookup(0, (const KB::String *)&v43, 0, 0, (uint64_t *)&v39);
        }
        v31 = v39;
        *(_QWORD *)&v37 = &v39;
        std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
        if (v44)
        {
          if (BYTE6(v43) == 1)
            free(v44);
        }
        if ((_QWORD)v31 != *((_QWORD *)&v31 + 1))
LABEL_40:
          v11 = ++v10;
        else
LABEL_41:
          ++v10;
      }
      while (v10 < *(_QWORD *)a3);
    }
    else
    {
      v11 = 0;
    }
    v32 = *((_QWORD *)a4 + 7);
    v33 = operator new(0x20uLL);
    *v33 = &off_1EA0FE140;
    v33[1] = a3;
    v33[2] = a4;
    v33[3] = v11;
    v42 = v33;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v32, (uint64_t)"FilterNumberlikeTokenMismatch", v41);
    result = (uint64_t)v42;
    if (v42 == v41)
    {
      v34 = 4;
      result = (uint64_t)v41;
    }
    else
    {
      if (!v42)
        return result;
      v34 = 5;
    }
    return (*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v34))();
  }
  return result;
}

void std::__function::__func<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1EA0FE140;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FE140;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(_QWORD *a1, unint64_t *a2, KB::String **a3)
{
  unint64_t v5;
  KB::String *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  KB::String *v13;
  KB::String *v14;
  uint64_t v15;
  int v16;
  const char *v17;
  const char *v18;
  _WORD v20[3];
  char v21;
  void *v22;
  _QWORD v23[3];

  v5 = 0;
  v23[2] = *MEMORY[0x1E0C80C00];
  v6 = *a3;
  do
  {
    v7 = v5;
    v8 = a1[3];
    if (v5 >= v8)
      break;
    if (v5 < *a2)
    {
      v9 = a2[1];
      v10 = *(_QWORD *)(a1[1] + 8);
      v11 = *(_QWORD *)(a1[2] + 16);
      if (v11)
      {
        do
          v12 = __ldaxr((unsigned int *)v11);
        while (__stlxr(v12 + 1, (unsigned int *)v11));
      }
      v13 = (KB::String *)(v9 + 240 * v7);
      v14 = (KB::String *)(v10 + 240 * v7);
      v15 = *(_QWORD *)(v11 + 8) + 144;
      WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v11);
      v16 = KB::Word::preserves_input(v13, v14, v15) ^ 1;
      if (!v6)
        goto LABEL_17;
LABEL_9:
      if (v16)
      {
        KB::Word::capitalized_string((KB::Word *)(*(_QWORD *)(a1[1] + 8) + 240 * v7), (uint64_t)v20);
        v17 = (const char *)v22;
        if (!v22)
          v17 = (const char *)v23;
        v18 = "";
        if (v20[0])
          v18 = v17;
        KB::String::append_format(v6, "Candidate does not preserve input word '%s', which contains numbers", v18);
        if (v22 && v21 == 1)
          free(v22);
      }
      goto LABEL_17;
    }
    v16 = 1;
    if (v6)
      goto LABEL_9;
LABEL_17:
    v5 = v7 + 1;
  }
  while (!v16);
  return v7 < v8;
}

void KB::FilterCharacterCount::~FilterCharacterCount(KB::FilterCharacterCount *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterCharacterCount::filter_description(KB::FilterCharacterCount *this)
{
  return "FilterCharacterCount";
}

uint64_t KB::FilterCharacterCount::filter_candidates(KB::FilterCharacterCount *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  unsigned int v7;
  KB::String *v8;
  int v9;
  void *v10;
  char v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  _QWORD v18[3];
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v7 = *((_DWORD *)this + 2);
  v8 = (const KB::CandidateFilterLookupContext *)((char *)a3 + 888);
  if (!*((_WORD *)a3 + 444))
    KB::Candidate::compute_string(a3);
  v9 = KB::String::count(v8, v7);
  switch(*((_DWORD *)this + 3))
  {
    case 0:
      v10 = std::cmp_less[abi:nn180100]<unsigned int,unsigned int>;
      v11 = 1;
      v12 = 60;
      break;
    case 1:
      v10 = std::cmp_less_equal[abi:nn180100]<unsigned int,unsigned int>;
      v11 = 2;
      v12 = 15676;
      break;
    case 2:
      v10 = std::cmp_equal[abi:nn180100]<unsigned int,unsigned int>;
      v11 = 2;
      v12 = 15677;
      break;
    case 3:
      v10 = std::cmp_not_equal[abi:nn180100]<unsigned int,unsigned int>;
      v11 = 2;
      v12 = 15649;
      break;
    case 4:
      v10 = std::cmp_greater_equal[abi:nn180100]<unsigned int,unsigned int>;
      v11 = 2;
      v12 = 15678;
      break;
    case 5:
      v10 = std::cmp_greater[abi:nn180100]<unsigned int,unsigned int>;
      v11 = 1;
      v12 = 62;
      break;
    default:
      v12 = 0;
      v11 = 0;
      v10 = 0;
      break;
  }
  v13 = (char *)operator new(0x30uLL);
  *(_QWORD *)v13 = off_1EA0FE188;
  *((_DWORD *)v13 + 2) = v7;
  *((_DWORD *)v13 + 3) = v9;
  *((_QWORD *)v13 + 2) = v10;
  *((_QWORD *)v13 + 3) = v12;
  *((_QWORD *)v13 + 4) = 0;
  *(_QWORD *)(v13 + 39) = 0;
  v13[47] = v11;
  v14 = *((_QWORD *)a4 + 7);
  v19 = std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone((uint64_t)v13);
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v14, (uint64_t)"FilterCharacterCount", v18);
  v15 = v19;
  if (v19 == (char *)v18)
  {
    v16 = 4;
    v15 = (char *)v18;
    goto LABEL_15;
  }
  if (v19)
  {
    v16 = 5;
LABEL_15:
    (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
  }
  return (*(uint64_t (**)(char *))(*(_QWORD *)v13 + 40))(v13);
}

BOOL std::cmp_less[abi:nn180100]<unsigned int,unsigned int>(unsigned int a1, unsigned int a2)
{
  return a1 < a2;
}

BOOL std::cmp_less_equal[abi:nn180100]<unsigned int,unsigned int>(unsigned int a1, unsigned int a2)
{
  return a2 >= a1;
}

BOOL std::cmp_equal[abi:nn180100]<unsigned int,unsigned int>(int a1, int a2)
{
  return a1 == a2;
}

BOOL std::cmp_not_equal[abi:nn180100]<unsigned int,unsigned int>(int a1, int a2)
{
  return a1 != a2;
}

BOOL std::cmp_greater_equal[abi:nn180100]<unsigned int,unsigned int>(unsigned int a1, unsigned int a2)
{
  return a1 >= a2;
}

BOOL std::cmp_greater[abi:nn180100]<unsigned int,unsigned int>(unsigned int a1, unsigned int a2)
{
  return a2 < a1;
}

uint64_t std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA0FE188;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = off_1EA0FE188;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  JUMPOUT(0x1DF0A2144);
}

char *std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  std::string *v3;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = off_1EA0FE188;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  v3 = (std::string *)(v2 + 24);
  if (*(char *)(a1 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 24), *(_QWORD *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 24);
    *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  }
  return v2;
}

void std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  std::string *v2;
  __int128 v3;

  *(_QWORD *)a2 = off_1EA0FE188;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  v2 = (std::string *)(a2 + 24);
  if (*(char *)(a1 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a1 + 24), *(_QWORD *)(a1 + 32));
  }
  else
  {
    v3 = *(_OWORD *)(a1 + 24);
    *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::destroy(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
}

void std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::destroy_deallocate(void **__p)
{
  if (*((char *)__p + 47) < 0)
    operator delete(__p[3]);
  operator delete(__p);
}

uint64_t std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, _WORD *a2, KB::String **a3)
{
  KB::String *v4;
  uint64_t (*v5)(uint64_t, _QWORD);
  KB::String *v6;
  uint64_t v7;
  int v8;
  int v9;
  const char *v10;
  const char *v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  _WORD v16[3];
  char v17;
  void *v18;
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  v4 = *a3;
  v5 = *(uint64_t (**)(uint64_t, _QWORD))(a1 + 16);
  v6 = (KB::String *)(a2 + 444);
  if (!a2[444])
    KB::Candidate::compute_string((KB::Candidate *)a2);
  v7 = KB::String::count(v6, *(_DWORD *)(a1 + 8));
  v8 = v5(v7, *(unsigned int *)(a1 + 12));
  v9 = v8;
  if (v4 && (v8 & 1) == 0)
  {
    KB::String::String((uint64_t)v16, *(_DWORD *)(a1 + 8));
    v10 = (const char *)v18;
    if (!v18)
      v10 = (const char *)v19;
    if (v16[0])
      v11 = v10;
    else
      v11 = "";
    v14 = *(const char **)(a1 + 24);
    v13 = a1 + 24;
    v12 = v14;
    if (*(char *)(v13 + 23) >= 0)
      v12 = (const char *)v13;
    KB::String::append_format(v4, "candidate count of '%s' is not %s input count", v11, v12);
    if (v18 && v17 == 1)
      free(v18);
  }
  return v9 ^ 1u;
}

void KB::FilterAlteredURLFragments::~FilterAlteredURLFragments(KB::FilterAlteredURLFragments *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterAlteredURLFragments::filter_description(KB::FilterAlteredURLFragments *this)
{
  return "FilterAlteredURLFragments";
}

void KB::FilterAlteredURLFragments::filter_candidates(KB::FilterAlteredURLFragments *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD v17[3];
  _QWORD *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v7 = *((unsigned __int16 *)a3 + 444);
  if (*((_WORD *)a3 + 444))
  {
    v8 = (char *)*((_QWORD *)a3 + 112);
    if (!v8)
      v8 = (char *)a3 + 904;
  }
  else
  {
    KB::Candidate::compute_string(a3);
    v7 = *((unsigned __int16 *)a3 + 444);
    v8 = (char *)*((_QWORD *)a3 + 112);
    if (!v8)
      v8 = (char *)a3 + 904;
    if (!*((_WORD *)a3 + 444))
    {
      v9 = v8;
      goto LABEL_13;
    }
  }
  v9 = v8;
  while (*v9 != 46)
  {
    if (++v9 == &v8[v7])
    {
      v9 = &v8[v7];
      break;
    }
  }
LABEL_13:
  if (v9 - v8 != v7 || *((_BYTE *)a3 + 3174))
  {
    v10 = *((_QWORD *)a4 + 2);
    if (v10)
    {
      do
        v11 = __ldaxr((unsigned int *)v10);
      while (__stlxr(v11 + 1, (unsigned int *)v10));
    }
    v12 = *(_QWORD *)(v10 + 8) + 144;
    WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v10);
    v13 = *((_QWORD *)a4 + 7);
    v14 = operator new(0x20uLL);
    *v14 = &off_1EA0FE1D0;
    v14[1] = a3;
    v14[2] = v12;
    v14[3] = a3;
    v18 = v14;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v13, (uint64_t)"FilterAlteredURLFragments", v17);
    v15 = v18;
    if (v18 == v17)
    {
      v16 = 4;
      v15 = v17;
    }
    else
    {
      if (!v18)
        return;
      v16 = 5;
    }
    (*(void (**)(void))(*v15 + 8 * v16))();
  }
}

void std::__function::__func<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1EA0FE1D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FE1D0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  KB::String *v5;
  unsigned int v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  BOOL v11;
  _BOOL8 result;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  const char *v18;
  int v19;
  BOOL v20;
  BOOL v21;
  uint64_t v22;
  const char *v23;
  const char *v24;
  const char *v25;
  _WORD v26[3];
  char v27;
  void *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  v6 = KB::Candidate::num_words_preserving_input(a2, *(_QWORD **)(a1 + 8), *(_QWORD *)(a1 + 16));
  v7 = *(_QWORD *)(a1 + 8);
  v8 = (_BYTE *)*(unsigned __int16 *)(v7 + 888);
  if (*(_WORD *)(v7 + 888))
  {
    v9 = *(_BYTE **)(v7 + 896);
    if (!v9)
      v9 = (_BYTE *)(v7 + 904);
  }
  else
  {
    KB::Candidate::compute_string(*(KB::Candidate **)(a1 + 8));
    v8 = (_BYTE *)*(unsigned __int16 *)(v7 + 888);
    v9 = *(_BYTE **)(v7 + 896);
    if (!v9)
      v9 = (_BYTE *)(v7 + 904);
    if (!*(_WORD *)(v7 + 888))
    {
      v10 = v9;
      goto LABEL_13;
    }
  }
  v10 = v9;
  while (*v10 != 46)
  {
    if (++v10 == &v8[(_QWORD)v9])
    {
      v10 = &v8[(_QWORD)v9];
      break;
    }
  }
LABEL_13:
  if ((_BYTE *)(v10 - v9) == v8)
  {
    if (*(_BYTE *)(*(_QWORD *)(a1 + 24) + 3176))
      v11 = v6 == 0;
    else
      v11 = 0;
    if (!v11)
      return 0;
    if (!v5)
      return 1;
    KB::Candidate::capitalized_string(a2, (uint64_t)v26);
    KB::String::append_format(v5, "candidate %s proceeds '.' in context and does not preserve input word url format");
LABEL_21:
    if (v28)
    {
      if (v27 == 1)
        free(v28);
    }
    return 1;
  }
  if (!v6)
    return 0;
  if (*(_QWORD *)a2 == v6)
    return 0;
  v13 = *(_QWORD **)(a1 + 8);
  if (*v13 == v6)
    return 0;
  v14 = v13[1];
  v15 = v14 + 240 * (v6 - 1);
  v16 = *(const char **)(v15 + 8);
  v17 = (const char *)(v15 + 16);
  if (v16)
    v18 = v16;
  else
    v18 = v17;
  v19 = strcmp(v18, ".");
  if (v19)
    v20 = 0;
  else
    v20 = v6 >= 2;
  if (v20)
  {
    v22 = v14 + 240 * (v6 - 2);
    v23 = *(const char **)(v22 + 8);
    v24 = (const char *)(v22 + 16);
    if (v23)
      v25 = v23;
    else
      v25 = v24;
    v21 = strcmp(v25, ".") == 0;
  }
  else
  {
    v21 = 0;
  }
  result = 0;
  if (!v19 && !v21)
  {
    result = (*(_DWORD *)(v14 + 240 * v6 + 132) & 0x4000000) == 0;
    if (v5)
    {
      if ((*(_DWORD *)(v14 + 240 * v6 + 132) & 0x4000000) == 0)
      {
        KB::Candidate::capitalized_string(a2, (uint64_t)v26);
        KB::String::append_format(v5, "candidate %s contains '.' and does not preserve input word url format");
        goto LABEL_21;
      }
    }
  }
  return result;
}

void KB::FilterDoubleApostrophe::~FilterDoubleApostrophe(KB::FilterDoubleApostrophe *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterDoubleApostrophe::filter_description(KB::FilterDoubleApostrophe *this)
{
  return "FilterDoubleApostrophe";
}

void KB::FilterDoubleApostrophe::filter_candidates(KB::FilterDoubleApostrophe *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD v13[3];
  _QWORD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v7 = *((unsigned __int16 *)a3 + 444);
  if (*((_WORD *)a3 + 444))
  {
    v8 = (char *)*((_QWORD *)a3 + 112);
    if (!v8)
      v8 = (char *)a3 + 904;
  }
  else
  {
    KB::Candidate::compute_string(a3);
    v7 = *((unsigned __int16 *)a3 + 444);
    v8 = (char *)*((_QWORD *)a3 + 112);
    if (!v8)
      v8 = (char *)a3 + 904;
    if (!*((_WORD *)a3 + 444))
    {
      v9 = v8;
      goto LABEL_13;
    }
  }
  v9 = v8;
  while (*v9 != 39)
  {
    if (++v9 == &v8[v7])
    {
      v9 = &v8[v7];
      break;
    }
  }
LABEL_13:
  if (v9 - v8 == v7)
    return;
  v10 = *((_QWORD *)a4 + 7);
  v13[0] = &off_1EA0FE218;
  v14 = v13;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v10, (uint64_t)"FilterDoubleApostrophe", v13);
  v11 = v14;
  if (v14 == v13)
  {
    v12 = 4;
    v11 = v13;
  }
  else
  {
    if (!v14)
      return;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
}

void std::__function::__func<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA0FE218;
  return result;
}

void std::__function::__func<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA0FE218;
}

uint64_t std::__function::__func<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, unint64_t *a2, KB::String **a3)
{
  unint64_t v3;
  unint64_t v4;
  KB::String *v5;
  unint64_t v6;
  unsigned int i;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  _BOOL4 v12;
  unsigned __int16 *v13;
  uint64_t v14;
  int v15;
  _BOOL4 v16;
  uint64_t v19;
  int v20;
  int v21;
  int v22;

  v3 = *a2;
  if (!*a2)
    return 0;
  v4 = 0;
  v5 = *a3;
  v6 = a2[1];
  for (i = 1; ; ++i)
  {
    if ((*(_BYTE *)(v6 + 240 * v4 + 135) & 4) != 0)
    {
      v8 = v6 + 240 * v4;
      v9 = *(_QWORD *)(v8 + 8);
      v10 = v8 + 16;
      v11 = (const char *)(v9 ? v9 : v10);
      if (!strcmp(v11, "'"))
      {
        v12 = i != 1
           && (*(_BYTE *)(v6 + 240 * (i - 2) + 135) & 4) == 0
           && KB::String::last((KB::String *)(v6 + 240 * (i - 2))) == 39;
        if (v3 - 1 <= v4 || (*(_BYTE *)(v6 + 240 * i + 135) & 4) != 0)
        {
          v16 = 0;
        }
        else
        {
          v13 = (unsigned __int16 *)(v6 + 240 * i);
          v14 = *((_QWORD *)v13 + 1);
          if (!v14)
            v14 = (uint64_t)(v13 + 8);
          v19 = v14;
          v15 = *v13;
          v20 = 0;
          v21 = v15;
          v22 = 0;
          KB::String::iterator::initialize(&v19);
          v16 = v22 == 39;
        }
        if (v12 || v16)
          break;
      }
    }
    v4 = i;
    if (v3 <= i)
      return 0;
  }
  if (v5)
    KB::String::append_format(v5, "candidate contains word that has multiple adjacent apostrophes");
  return 1;
}

void KB::FilterWordEndingApostropheBetweenNonseparators::~FilterWordEndingApostropheBetweenNonseparators(KB::FilterWordEndingApostropheBetweenNonseparators *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterWordEndingApostropheBetweenNonseparators::filter_description(KB::FilterWordEndingApostropheBetweenNonseparators *this)
{
  return "FilterWordEndingApostropheBetweenNonseparators";
}

_QWORD *KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::FilterWordEndingApostropheBetweenNonseparators *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;
  _QWORD v13[3];
  _QWORD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v7 = *((_QWORD *)a4 + 2);
  if (v7)
  {
    do
      v8 = __ldaxr((unsigned int *)v7);
    while (__stlxr(v8 + 1, (unsigned int *)v7));
  }
  v9 = *(_QWORD *)(v7 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v7);
  v10 = *((_QWORD *)a4 + 7);
  v13[0] = &off_1EA0FE260;
  v13[1] = a3;
  v13[2] = v9;
  v14 = v13;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v10, (uint64_t)"FilterWordEndingApostropheBetweenNonseparators", v13);
  result = v14;
  if (v14 == v13)
  {
    v12 = 4;
    result = v13;
  }
  else
  {
    if (!v14)
      return result;
    v12 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v12))();
}

void std::__function::__func<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA0FE260;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FE260;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t a2, KB::String **a3)
{
  KB::String *v5;
  uint64_t v6;
  KB::Candidate *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  unsigned __int16 *v12;
  _WORD *v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v18;
  int v19;
  int v20;
  int v21;

  if (*(_QWORD *)a2 < 3uLL)
    return 0;
  v5 = *a3;
  v6 = *(_QWORD *)(a1 + 16);
  if (!*(_WORD *)(a2 + 888))
    KB::Candidate::compute_string((KB::Candidate *)a2);
  v7 = *(KB::Candidate **)(a1 + 8);
  if (!*((_WORD *)v7 + 444))
    KB::Candidate::compute_string(v7);
  v8 = *(_QWORD *)(v6 + 24);
  if (!v8)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x1DA7C4170);
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t, _WORD *))(*(_QWORD *)v8 + 48))(v8, a2 + 888, (_WORD *)v7 + 444)|| (unint64_t)(*(_QWORD *)a2 - 3) > 0xFFFFFFFFFFFFFFFDLL)
  {
    return 0;
  }
  v9 = 1;
  for (i = 612; ; i += 240)
  {
    v11 = *(_QWORD *)(a2 + 8);
    v12 = (unsigned __int16 *)(v11 + i - 372);
    v13 = (_WORD *)(v11 + i - 368);
    v14 = (unsigned __int16)*v13;
    if (!*v13)
    {
      KB::String::compute_length((unsigned __int16 *)(v11 + i - 372));
      v14 = (unsigned __int16)*v13;
    }
    if (v14 == 1)
    {
      v15 = *(_QWORD *)(v11 + i - 364) ? *(_QWORD *)(v11 + i - 364) : v11 + i - 356;
      v18 = v15;
      v16 = *v12;
      v19 = 0;
      v20 = v16;
      v21 = 0;
      KB::String::iterator::initialize(&v18);
      if (v21 == 39 || (v18 = v15, v19 = 0, v20 = v16, v21 = 0, KB::String::iterator::initialize(&v18), v21 == 8217))
      {
        if (((*(_DWORD *)(*(_QWORD *)(a2 + 8) + i - 480) | *(_DWORD *)(*(_QWORD *)(a2 + 8) + i)) & 0x4000000) == 0)
          break;
      }
    }
    if (++v9 >= (unint64_t)(*(_QWORD *)a2 - 1))
      return 0;
  }
  if (v5)
    KB::String::append_format(v5, "candidate is a word ending with an apostrophe between nonseparators");
  return 1;
}

void KB::FilterPopupVariantMismatch::~FilterPopupVariantMismatch(KB::FilterPopupVariantMismatch *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterPopupVariantMismatch::filter_description(KB::FilterPopupVariantMismatch *this)
{
  return "FilterPopupVariantMismatch";
}

void KB::FilterPopupVariantMismatch::filter_candidates(KB::FilterPopupVariantMismatch *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD v13[3];
  _QWORD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v6 = (_BYTE *)*((_QWORD *)a3 + 251);
  v7 = (_BYTE *)*((_QWORD *)a3 + 252);
  if (v6 != v7)
  {
    while ((*v6 & 4) == 0)
    {
      v6 += 4;
      if (v6 == v7)
        return;
    }
  }
  if (v6 != v7)
  {
    v8 = *(_QWORD *)a4;
    v9 = *((_QWORD *)a4 + 7);
    v10 = operator new(0x20uLL);
    *v10 = &off_1EA0FE2A8;
    v10[1] = a3;
    v10[2] = (char *)a3 + 2008;
    v10[3] = v8;
    v14 = v10;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v9, (uint64_t)"FilterPopupVariantMismatch", v13);
    v11 = v14;
    if (v14 == v13)
    {
      v12 = 4;
      v11 = v13;
    }
    else
    {
      if (!v14)
        return;
      v12 = 5;
    }
    (*(void (**)(void))(*v11 + 8 * v12))();
  }
}

void std::__function::__func<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1EA0FE2A8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FE2A8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, _WORD *a2, KB::String **a3)
{
  KB::String *v4;
  KB *v5;
  _WORD *v6;
  KB *v7;
  _BOOL4 v8;
  _BOOL4 v9;

  v4 = *a3;
  v5 = (KB *)(a2 + 444);
  if (!a2[444])
    KB::Candidate::compute_string((KB::Candidate *)a2);
  v6 = *(_WORD **)(a1 + 8);
  v7 = (KB *)(v6 + 444);
  if (!v6[444])
    KB::Candidate::compute_string((KB::Candidate *)v6);
  v8 = KB::FilterPopupVariantMismatch::candidate_matches_popup_variants(v5, v7, *(_QWORD **)(a1 + 16), *(KB::String **)(a1 + 24));
  v9 = v8;
  if (v4 && !v8)
    KB::String::append_format(v4, "candidate does not match popup variants");
  return !v9;
}

BOOL KB::FilterPopupVariantMismatch::candidate_matches_popup_variants(KB *a1, KB *this, _QWORD *a3, KB::String *a4)
{
  unsigned int v8;
  unint64_t v9;
  BOOL v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  KB *v14;
  UChar32 v15;
  UChar32 v16;
  BOOL *v17;
  _BYTE v19[8];
  void *v20;
  int v21;
  _BYTE v22[8];
  void *v23;
  int v24;
  _BYTE v25[8];
  void *v26;
  _BYTE v27[8];
  void *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v8 = *((unsigned __int16 *)this + 2);
  if (!*((_WORD *)this + 2))
  {
    KB::String::compute_length((unsigned __int16 *)this);
    v8 = *((unsigned __int16 *)this + 2);
  }
  KB::lower_string(this, a4, (KB::String *)v27);
  KB::lower_string(a1, a4, (KB::String *)v25);
  KB::String::String((KB::String *)v22, (const KB::String *)v27);
  v24 = 0;
  KB::String::String((KB::String *)v19, (const KB::String *)v25);
  v21 = 0;
  if (v8)
  {
    v9 = 0;
    v10 = 0;
    v11 = v8;
    while (1)
    {
      if (v9 >= (uint64_t)(a3[1] - *a3) >> 2)
        LOBYTE(v12) = 0;
      else
        v12 = *(_DWORD *)(*a3 + 4 * v9);
      v13 = KB::UTF8Iterator::next((KB::UTF8Iterator *)v22);
      v14 = (KB *)KB::UTF8Iterator::next((KB::UTF8Iterator *)v19);
      v15 = KB::UTF8Iterator::next((KB::UTF8Iterator *)v22);
      v16 = KB::UTF8Iterator::next((KB::UTF8Iterator *)v19);
      if ((v12 & 4) != 0)
        break;
LABEL_20:
      if (((0x4000050u >> u_charType(v15)) & 1) == 0)
        KB::UTF8Iterator::prev((KB::UTF8Iterator *)v22);
      if (((0x4000050u >> u_charType(v16)) & 1) == 0)
        KB::UTF8Iterator::prev((KB::UTF8Iterator *)v19);
      v10 = ++v9 >= v11;
      if (v11 == v9)
        goto LABEL_29;
    }
    if (v15 > 729)
    {
      if (v15 == 730 || v15 == 732 || v15 == 901)
        goto LABEL_17;
    }
    else if ((v15 - 168) <= 0xC && ((1 << (v15 + 88)) & 0x1081) != 0)
    {
      goto LABEL_17;
    }
    if (u_charType(v15) != 4)
    {
      if (!KB::substitution_allowed(v14, v13, 0, v17))
        goto LABEL_29;
LABEL_18:
      if (u_charType(v13) == 6 && u_charType((UChar32)v14) != 6)
        goto LABEL_29;
      goto LABEL_20;
    }
LABEL_17:
    if (!KB::character_has_diacritic(v14, v15))
      goto LABEL_29;
    goto LABEL_18;
  }
  v10 = 1;
LABEL_29:
  if (v20 && v19[6] == 1)
    free(v20);
  if (v23 && v22[6] == 1)
    free(v23);
  if (v26 && v25[6] == 1)
    free(v26);
  if (v28 && v27[6] == 1)
    free(v28);
  return v10;
}

void KB::FilterAllCapsNoSuggestWordsOfLength::~FilterAllCapsNoSuggestWordsOfLength(KB::FilterAllCapsNoSuggestWordsOfLength *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterAllCapsNoSuggestWordsOfLength::filter_description(KB::FilterAllCapsNoSuggestWordsOfLength *this)
{
  return "FilterAllCapsNoSuggestWordsOfLength";
}

void KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::FilterAllCapsNoSuggestWordsOfLength *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4, uint64_t a5)
{
  KB *v8;
  BOOL v10;
  int v11;
  uint64_t v12;
  uint64_t (***v13)();
  uint64_t v14;
  uint64_t (**v15)();
  int v16;
  uint64_t (***v17)();
  _BYTE v18[6];
  char v19;
  void *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v8 = (const KB::CandidateFilterLookupContext *)((char *)a3 + 888);
  if (!*((_WORD *)a3 + 444))
  {
    KB::Candidate::compute_string(a3);
    if (!*((_WORD *)a3 + 444))
      KB::Candidate::compute_string(a3);
  }
  KB::upper_string(v8, 0, a3, (uint64_t)a4, a5, (KB::String *)v18);
  if (v8 == (KB *)v18)
  {
    if (v20 && v19 == 1)
      free(v20);
  }
  else
  {
    v10 = KB::String::equal(v8, (const KB::String *)v18, 1);
    if (v20)
    {
      if (v19 == 1)
        free(v20);
    }
    if (!v10)
    {
      v11 = *((_DWORD *)this + 2);
      v12 = *((_QWORD *)a4 + 7);
      v15 = &off_1EA0FE2F0;
      v16 = v11;
      v17 = &v15;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v12, (uint64_t)"FilterAllCapsNoSuggestWordsOfLength", &v15);
      v13 = v17;
      if (v17 == &v15)
      {
        v14 = 4;
        v13 = &v15;
      }
      else
      {
        if (!v17)
          return;
        v14 = 5;
      }
      (*v13)[v14]();
    }
  }
}

void std::__function::__func<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_DWORD *std::__function::__func<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  _DWORD *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_1EA0FE2F0;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_1EA0FE2F0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

BOOL std::__function::__func<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t *a2, KB::String **a3)
{
  KB::String *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[2];
  BOOL (*v14)(uint64_t, KB::String *);
  void *v15;
  int v16;

  v4 = *a3;
  v5 = *a2;
  v6 = a2[1];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 0x40000000;
  v14 = ___ZZNK2KB35FilterAllCapsNoSuggestWordsOfLength17filter_candidatesERNS_19CandidateCollectionERKNS_28CandidateFilterLookupContextERKNS_24CandidateFilterResourcesEENK3__0clERKNS_9CandidateEPNS_6StringE_block_invoke;
  v15 = &__block_descriptor_tmp_64;
  v16 = *(_DWORD *)(a1 + 8);
  if (v5)
  {
    v8 = v6 + 240 * v5;
    v9 = 240 * v5;
    while ((((uint64_t (*)(_QWORD *, uint64_t))v14)(v13, v6) & 1) == 0)
    {
      v6 += 240;
      v9 -= 240;
      if (!v9)
      {
        v6 = v8;
        break;
      }
    }
    v10 = v6;
    v5 = *a2;
    v6 = a2[1];
  }
  else
  {
    v10 = v6;
  }
  v11 = v6 + 240 * v5;
  if (v4 && v10 != v11)
    KB::String::append_format(v4, "candidate word of length=%u is all-caps and not suggestible", *(_DWORD *)(a1 + 8));
  return v10 != v11;
}

BOOL ___ZZNK2KB35FilterAllCapsNoSuggestWordsOfLength17filter_candidatesERNS_19CandidateCollectionERKNS_28CandidateFilterLookupContextERKNS_24CandidateFilterResourcesEENK3__0clERKNS_9CandidateEPNS_6StringE_block_invoke(uint64_t a1, KB::String *this)
{
  int v4;
  int v5;
  int v6;

  v4 = *((unsigned __int16 *)this + 2);
  if (!*((_WORD *)this + 2))
  {
    KB::String::compute_length((unsigned __int16 *)this);
    v4 = *((unsigned __int16 *)this + 2);
  }
  if (*(_DWORD *)(a1 + 32) != v4)
    return 0;
  v5 = *((_DWORD *)this + 26);
  if ((v5 & 0x800012) == 0)
  {
    v6 = v5 & 0x2042000;
    if ((*((_DWORD *)this + 26) & 0x2080) != 0x80 && v6 != 0x2000000)
      return 0;
  }
  if (!v4)
  {
    KB::String::compute_length((unsigned __int16 *)this);
    LOWORD(v4) = *((_WORD *)this + 2);
  }
  return ((-1 << v4) | *((_DWORD *)this + 30)) == -1;
}

void KB::FilterMissingOneLetterWordFromInput::~FilterMissingOneLetterWordFromInput(KB::FilterMissingOneLetterWordFromInput *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterMissingOneLetterWordFromInput::filter_description(KB::FilterMissingOneLetterWordFromInput *this)
{
  return "FilterMissingOneLetterWordFromInput";
}

_QWORD *KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::FilterMissingOneLetterWordFromInput *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  _QWORD *result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[3];
  _QWORD *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v7 = *((_QWORD *)a4 + 2);
  if (v7)
  {
    do
      v8 = __ldaxr((unsigned int *)v7);
    while (__stlxr(v8 + 1, (unsigned int *)v7));
  }
  v9 = *(_QWORD *)(v7 + 8);
  result = WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v7);
  if (*(_QWORD *)a3)
  {
    v11 = *((_QWORD *)a3 + 1);
    v12 = v9 + 144;
    v13 = 240 * *(_QWORD *)a3;
    v14 = v11;
    while (1)
    {
      if ((*(_BYTE *)(v14 + 135) & 4) != 0)
        goto LABEL_15;
      v15 = *(unsigned __int16 *)(v14 + 4);
      if (!*(_WORD *)(v14 + 4))
      {
        result = KB::String::compute_length((unsigned __int16 *)v14);
        v15 = *(unsigned __int16 *)(v14 + 4);
      }
      if (v15 > 1)
        goto LABEL_15;
      result = (_QWORD *)KB::FilterMissingOneLetterWordFromInput::word_is_static_and_suggestible_and_in_candidates((KB::String *)v14, (uint64_t)a2);
      if (!(_DWORD)result)
        goto LABEL_15;
      v16 = *((_QWORD *)a4 + 7);
      v18[0] = &off_1EA0FE358;
      v18[1] = v11;
      v18[2] = v12;
      v19 = v18;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v16, (uint64_t)"FilterMissingOneLetterWordFromInput", v18);
      result = v19;
      if (v19 == v18)
        break;
      if (v19)
      {
        v17 = 5;
LABEL_14:
        result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v17))();
      }
LABEL_15:
      v14 += 240;
      v11 += 240;
      v13 -= 240;
      if (!v13)
        return result;
    }
    result = v18;
    v17 = 4;
    goto LABEL_14;
  }
  return result;
}

uint64_t KB::FilterMissingOneLetterWordFromInput::word_is_static_and_suggestible_and_in_candidates(KB::String *a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  v2 = *(_QWORD **)a2;
  v3 = *(_QWORD **)(a2 + 8);
  if (*(_QWORD **)a2 == v3)
    return 0;
  while (!*v2)
  {
LABEL_14:
    v2 += 125;
    if (v2 == v3)
      return 0;
  }
  v5 = v2[1];
  v6 = 240 * *v2;
  while (1)
  {
    if ((*(_BYTE *)(v5 + 135) & 4) == 0 && ((KB::String *)v5 == a1 || KB::String::equal((KB::String *)v5, a1, 1)))
    {
      v7 = *(_DWORD *)(v5 + 104);
      if ((v7 & 0x800012) == 0)
      {
        v8 = v7 & 0x40000;
        if ((*(_DWORD *)(v5 + 104) & 0x2080) != 0x80 && v8 != 0)
          return 1;
      }
    }
    v5 += 240;
    v6 -= 240;
    if (!v6)
      goto LABEL_14;
  }
}

void std::__function::__func<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA0FE358;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA0FE358;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t *a2, KB::String **a3)
{
  uint64_t v3;
  unsigned __int8 v5;
  unsigned __int8 v6;
  KB::String *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;

  v3 = *a2;
  if (*a2)
  {
    v5 = 0;
    v6 = 0;
    v7 = *a3;
    v8 = a2[1];
    v9 = 240 * v3;
    do
    {
      if ((*(_BYTE *)(v8 + 135) & 4) == 0)
      {
        v10 = *(unsigned __int16 *)(v8 + 4);
        if (!*(_WORD *)(v8 + 4))
        {
          KB::String::compute_length((unsigned __int16 *)v8);
          v10 = *(unsigned __int16 *)(v8 + 4);
        }
        if (v10 == 1)
        {
          v11 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24);
          if (!v11)
          {
            std::__throw_bad_function_call[abi:nn180100]();
            JUMPOUT(0x1DA7C4D2CLL);
          }
          v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v11 + 48))(v11, v8, *(_QWORD *)(a1 + 8));
          v6 |= v12 != 0;
          v5 |= v12 == 0;
        }
      }
      v8 += 240;
      v9 -= 240;
    }
    while (v9);
    LOBYTE(v3) = v5 & (v6 ^ 1);
    if (v7 && (v5 & (v6 ^ 1) & 1) != 0)
    {
      KB::String::append_format(v7, "candidate does not preserve original 1 letter word");
      LOBYTE(v3) = 1;
    }
  }
  return v3 & 1;
}

void KB::FilterCorrectionsIfAnyCandidateMatchesInput::~FilterCorrectionsIfAnyCandidateMatchesInput(KB::FilterCorrectionsIfAnyCandidateMatchesInput *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::FilterCorrectionsIfAnyCandidateMatchesInput::filter_description(KB::FilterCorrectionsIfAnyCandidateMatchesInput *this)
{
  return "FilterCorrectionsIfAnyCandidateMatchesInput";
}

uint64_t KB::FilterCorrectionsIfAnyCandidateMatchesInput::filter_candidates(KB::FilterCorrectionsIfAnyCandidateMatchesInput *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t result;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;

  v8 = *((_QWORD *)a4 + 2);
  if (v8)
  {
    do
      v9 = __ldaxr((unsigned int *)v8);
    while (__stlxr(v9 + 1, (unsigned int *)v8));
  }
  v10 = *(_QWORD *)(v8 + 8);
  result = (uint64_t)WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v8);
  v12 = *(_QWORD **)a2;
  v13 = (_QWORD *)*((_QWORD *)a2 + 1);
  if (*(_QWORD **)a2 != v13)
  {
    v14 = v10 + 144;
    while (1)
    {
      if ((*(_BYTE *)(v12[1] + 240 * *v12 - 134) & 0x80) == 0)
      {
        result = KB::CandidateFilter::candidate_matches_input((uint64_t)v12, (uint64_t)a3, v14);
        if ((result & 1) != 0)
          break;
        if (*((_BYTE *)a3 + 2000))
        {
          result = KB::CandidateFilter::candidate_matches_input((uint64_t)v12, (uint64_t)a3 + 1000, v14);
          if ((result & 1) != 0)
            break;
        }
      }
      v12 += 125;
      if (v12 == v13)
      {
        v12 = v13;
        break;
      }
    }
    if (v12 != *((_QWORD **)a2 + 1)
      && 0x1CAC083126E978D5 * (((uint64_t)v12 - *(_QWORD *)a2) >> 3) <= *((unsigned int *)this + 2))
    {
      return (uint64_t)KB::CandidateFilter::remove_candidates_with_input_mismatch((uint64_t)this, (uint64_t)a2, *(_DWORD *)a3, (uint64_t)a3, (uint64_t)a4, (uint64_t)"match length is equal to the number of input words");
    }
  }
  return result;
}

