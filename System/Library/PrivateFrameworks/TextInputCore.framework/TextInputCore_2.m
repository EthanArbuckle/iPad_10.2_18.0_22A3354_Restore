void KB::LexiconIDManager::LexiconIDManager(KB::LexiconIDManager *this)
{
  *(_QWORD *)this = 0;
  atomic_store(0, (unint64_t *)this);
}

{
  *(_QWORD *)this = 0;
  atomic_store(0, (unint64_t *)this);
}

void KB::LexiconIDManager::~LexiconIDManager(KB::LexiconIDManager *this)
{
  do
    __ldaxr((unint64_t *)this);
  while (__stxr(0, (unint64_t *)this));
}

{
  do
    __ldaxr((unint64_t *)this);
  while (__stxr(0, (unint64_t *)this));
}

unint64_t *KB::LexiconIDManager::clear(unint64_t *this)
{
  do
    __ldaxr(this);
  while (__stxr(0, this));
  return this;
}

unint64_t KB::LexiconIDManager::locale_for_id(KB::LexiconIDManager *this, int a2)
{
  unint64_t result;

  result = atomic_load((unint64_t *)this);
  if (result)
  {
    while (*(_DWORD *)(result + 24) != a2)
    {
      result = *(_QWORD *)(result + 32);
      if (!result)
        return result;
    }
    if (*(char *)(result + 23) < 0)
      return *(_QWORD *)result;
  }
  return result;
}

uint64_t __Block_byref_object_copy__12117(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__12118(uint64_t a1)
{

}

uint64_t TI::Favonius::SearchNodeSource::can_refill_on_clone(TI::Favonius::SearchNodeSource *this)
{
  return 0;
}

void TI::Favonius::SearchNodeSource::node_at_current_bound(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

void TI::Favonius::SearchNodeSource::branch_at_current_bound(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t TI::Favonius::SearchNodeSource::SearchNodeSource(uint64_t result, uint64_t *a2)
{
  uint64_t v2;

  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)result = off_1EA102A78;
  v2 = *a2;
  *a2 = 0;
  *(_QWORD *)(result + 16) = v2;
  *(_DWORD *)(result + 24) = -8388608;
  return result;
}

void TI::Favonius::SearchNodeSource::~SearchNodeSource(TI::Favonius::SearchNodeSource *this)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = off_1EA102A78;
  v1 = (unsigned int *)*((_QWORD *)this + 2);
  if (v1)
  {
    v2 = v1 + 2;
    v3 = atomic_load(v1 + 2);
    if (v3 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 8))(v1);
    }
    else
    {
      do
        v4 = __ldaxr(v2);
      while (__stlxr(v4 - 1, v2));
    }
  }
}

void TI::Favonius::SearchNodeTransposition::~SearchNodeTransposition(TI::Favonius::SearchNodeTransposition *this)
{
  TI::Favonius::SearchNodeTransposition::~SearchNodeTransposition(this);
  JUMPOUT(0x1DF0A2144);
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;

  *(_QWORD *)this = &off_1EA102AC0;
  WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::~Vector((uint64_t)this + 256);
  v2 = (unsigned int *)*((_QWORD *)this + 31);
  if (v2)
  {
    v3 = v2 + 2;
    v4 = atomic_load(v2 + 2);
    if (v4 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 248))(v2);
    }
    else
    {
      do
        v5 = __ldaxr(v3);
      while (__stlxr(v5 - 1, v3));
    }
  }
  v6 = (unsigned int *)*((_QWORD *)this + 30);
  if (v6)
  {
    v7 = v6 + 2;
    v8 = atomic_load(v6 + 2);
    if (v8 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
    else
    {
      do
        v9 = __ldaxr(v7);
      while (__stlxr(v9 - 1, v7));
    }
  }
  v10 = *((_QWORD *)this + 29);
  if (v10)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v10);
  v11 = (unsigned int *)*((_QWORD *)this + 28);
  if (v11)
  {
    v12 = v11 + 2;
    v13 = atomic_load(v11 + 2);
    if (v13 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v11 + 8))(v11);
    }
    else
    {
      do
        v14 = __ldaxr(v12);
      while (__stlxr(v14 - 1, v12));
    }
  }
  TI::Favonius::SearchNode::~SearchNode(this);
}

unsigned int *TI::Favonius::SearchNodeTransposition::clone_substituting_touch@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned int *result;
  uint64_t v7;
  unsigned int v8;
  _QWORD *v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int *v15;

  result = (unsigned int *)(*(uint64_t (**)(unsigned int *, _QWORD))(*(_QWORD *)*a2 + 72))(*a2, *(__int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 62));
  if (result)
  {
    v7 = (uint64_t)result;
    do
      v8 = __ldaxr(result);
    while (__stlxr(v8 + 1, result));
    v9 = (_QWORD *)operator new();
    v10 = *a2;
    *a2 = 0;
    v14 = v7;
    v15 = v10;
    TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(v9, a1, &v15, &v14);
    if (v14)
      WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v14);
    result = v15;
    if (v15)
    {
      v11 = v15 + 2;
      v12 = atomic_load(v15 + 2);
      if (v12 == 1)
      {
        result = (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v15 + 8))();
      }
      else
      {
        do
          v13 = __ldaxr(v11);
        while (__stlxr(v13 - 1, v11));
      }
    }
  }
  else
  {
    v9 = 0;
  }
  *a3 = v9;
  return result;
}

uint64_t TI::Favonius::SearchNodeTransposition::node_at_current_bound@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  unsigned int *v2;
  unsigned int v3;

  if (!*(_QWORD *)(this + 64) && *(_BYTE *)(this + 148) && *(_BYTE *)(this + 149))
  {
    *(_BYTE *)(this + 149) = 0;
    *(_DWORD *)(this + 24) = -8388608;
    *a2 = this;
    v2 = (unsigned int *)(this + 8);
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + 1, v2));
  }
  else
  {
    *a2 = 0;
  }
  return this;
}

_QWORD *TI::Favonius::SearchNodeTransposition::branch_at_current_bound@<X0>(TI::Favonius::SearchNodeTransposition *this@<X0>, TI::Favonius::SearchNodeTransposition **a2@<X8>)
{
  TI::Favonius::SearchNodeTransposition *v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  _QWORD *result;
  unsigned int *v17;
  unsigned int *v18;

  if (!*((_QWORD *)this + 32))
    return TI::Favonius::SearchNode::branch_at_current_bound(this, a2);
  v4 = (TI::Favonius::SearchNodeTransposition *)operator new();
  v5 = (unsigned int *)*((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = 0;
  v17 = 0;
  v18 = v5;
  TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(v4, this, (uint64_t *)&v18, &v17);
  if (v17)
  {
    v6 = v17 + 2;
    v7 = atomic_load(v17 + 2);
    if (v7 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v17 + 248))();
    }
    else
    {
      do
        v8 = __ldaxr(v6);
      while (__stlxr(v8 - 1, v6));
    }
  }
  if (v18)
  {
    v9 = v18 + 2;
    v10 = atomic_load(v18 + 2);
    if (v10 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v18 + 248))();
    }
    else
    {
      do
        v11 = __ldaxr(v9);
      while (__stlxr(v11 - 1, v9));
    }
  }
  v12 = (unsigned int *)*((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = 0;
  if (v12)
  {
    v13 = v12 + 2;
    v14 = atomic_load(v12 + 2);
    if (v14 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v12 + 248))(v12);
    }
    else
    {
      do
        v15 = __ldaxr(v13);
      while (__stlxr(v15 - 1, v13));
    }
  }
  result = (_QWORD *)(*(uint64_t (**)(TI::Favonius::SearchNodeTransposition *))(*(_QWORD *)this + 48))(this);
  *a2 = v4;
  return result;
}

float TI::Favonius::SearchNodeTransposition::decrease_bound_on_score(TI::Favonius::SearchNodeTransposition *this)
{
  uint64_t v2;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  void *v14;

  v2 = *((_QWORD *)this + 32);
  if (*((_QWORD *)this + 31))
  {
    if (!v2)
      return TI::Favonius::SearchNode::decrease_bound_on_score(this);
  }
  else if (!v2)
  {
    TI::Favonius::SearchNodeTransposition::compute_language_model_data_for_first_key(this);
    v5 = *((_QWORD *)this + 32);
    v4 = *((_QWORD *)this + 33);
    v14 = &__block_literal_global_12229;
    v6 = 126 - 2 * __clz(v5);
    if (v5)
      v7 = v6;
    else
      v7 = 0;
    std::__introsort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*,false>(v4, (uint64_t *)(v4 + 8 * v5), (uint64_t)&v14, v7, 1);
    v2 = *((_QWORD *)this + 32);
  }
  v8 = *((_QWORD *)this + 33) + 8 * v2;
  v9 = *(_QWORD *)(v8 - 8);
  *(_QWORD *)(v8 - 8) = 0;
  v10 = (unsigned int *)*((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = v9;
  if (v10)
  {
    v11 = v10 + 2;
    v12 = atomic_load(v10 + 2);
    if (v12 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v10 + 248))(v10);
    }
    else
    {
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 - 1, v11));
    }
  }
  WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::shrink((unsigned int *)this + 64, *((_QWORD *)this + 32) - 1);
  return TI::Favonius::SearchNodeTransposition::set_bound_on_score(this);
}

uint64_t TI::Favonius::SearchNodeTransposition::touch_count(TI::Favonius::SearchNodeTransposition *this)
{
  return 2;
}

uint64_t TI::Favonius::SearchNodeTransposition::key_count(TI::Favonius::SearchNodeTransposition *this)
{
  return 2;
}

TI::Favonius::SearchNodeTransposition *TI::Favonius::SearchNodeTransposition::clone_with_parent@<X0>(TI::Favonius::SearchNodeTransposition *this@<X0>, TI::Favonius::SearchNode *a2@<X1>, TI::Favonius::SearchNodeTransposition **a3@<X8>)
{
  TI::Favonius::SearchNodeTransposition *v6;
  TI::Favonius::SearchNodeTransposition *result;

  v6 = (TI::Favonius::SearchNodeTransposition *)operator new();
  result = TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(v6, this, a2);
  if (!*((_BYTE *)result + 148))
  {
    do
      result = (TI::Favonius::SearchNodeTransposition *)(*(uint64_t (**)(TI::Favonius::SearchNodeTransposition *))(*(_QWORD *)v6 + 48))(v6);
    while (!*((_BYTE *)v6 + 148));
  }
  *a3 = v6;
  return result;
}

void TI::Favonius::SearchNodeTransposition::clone_discarding_first_touch_with_parent(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

unsigned int *TI::Favonius::SearchNodeTransposition::clone_discarding_second_touch_with_parent@<X0>(TI::Favonius::SearchNodeTransposition *this@<X0>, TI::Favonius::SearchNode *a2@<X1>, _QWORD *a3@<X8>)
{
  KB::String *v6;
  const KB::String *v7;
  unsigned int *result;
  _BYTE *v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int *v18;
  unsigned int v19;
  uint64_t (*i)(void);
  unsigned int v21;
  unsigned int *v22;
  unsigned int *v23;
  unsigned int *v24;

  v6 = (TI::Favonius::SearchNodeTransposition *)((char *)this + 88);
  v7 = (const KB::String *)(*(_QWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 7) + 16))(*((_QWORD *)a2 + 7))
                          + 8);
  if (v6 == v7 || (result = (unsigned int *)KB::String::equal(v6, v7, 1), (_DWORD)result))
  {
    v9 = (_BYTE *)operator new();
    v10 = (unsigned int *)*((_QWORD *)this + 28);
    v24 = v10;
    if (v10)
    {
      v11 = v10 + 2;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 + 1, v11));
    }
    v13 = (unsigned int *)*((_QWORD *)this + 29);
    v23 = v13;
    if (v13)
    {
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 + 1, v13));
    }
    (*(void (**)(unsigned int **__return_ptr, _QWORD, _QWORD))(**((_QWORD **)this + 7) + 208))(&v22, *((_QWORD *)this + 7), *((_QWORD *)a2 + 7));
    TI::Favonius::SearchNode::SearchNode((uint64_t)v9, (uint64_t)a2, (uint64_t *)&v24, (uint64_t *)&v23, (uint64_t *)&v22, 0, *((float *)this + 38), NAN);
    if (v22)
    {
      v15 = v22 + 2;
      v16 = atomic_load(v22 + 2);
      if (v16 == 1)
      {
        (*(void (**)(void))(*(_QWORD *)v22 + 248))();
      }
      else
      {
        do
          v17 = __ldaxr(v15);
        while (__stlxr(v17 - 1, v15));
      }
    }
    if (v23)
      WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v23);
    result = v24;
    if (!v24)
      goto LABEL_22;
    v18 = v24 + 2;
    v19 = atomic_load(v24 + 2);
    if (v19 != 1)
    {
      do
        v21 = __ldaxr(v18);
      while (__stlxr(v21 - 1, v18));
      goto LABEL_22;
    }
    for (i = *(uint64_t (**)(void))(*(_QWORD *)v24 + 8); ; i = *(uint64_t (**)(void))(*(_QWORD *)v9 + 48))
    {
      result = (unsigned int *)i();
LABEL_22:
      if (v9[148])
        break;
    }
  }
  else
  {
    v9 = 0;
  }
  *a3 = v9;
  return result;
}

void TI::Favonius::SearchNodeTransposition::append_local_keys_for_debugging(TI::Favonius::SearchNodeTransposition *this, KB::String *a2)
{
  uint64_t v4;
  TI::Favonius::Key **v5;

  KB::String::append(a2, 0x7Bu);
  TI::Favonius::Key::append_debug_data(*(TI::Favonius::Key **)(*((_QWORD *)this + 29) + 8), a2);
  v4 = *((_QWORD *)this + 6);
  if (v4)
    v5 = (TI::Favonius::Key **)(v4 + 8);
  else
    v5 = (TI::Favonius::Key **)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 7) + 16))(*((_QWORD *)this + 7));
  TI::Favonius::Key::append_debug_data(*v5, a2);
  KB::String::append(a2, 0x7Du);
}

uint64_t TI::Favonius::SearchNodeTransposition::compute_language_model_data(uint64_t a1, uint64_t a2)
{
  unsigned int *v2;
  unsigned int v3;
  uint64_t result;
  unsigned int *v5;

  v2 = *(unsigned int **)(*(_QWORD *)(a1 + 232) + 8);
  v5 = v2;
  if (v2)
  {
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + 1, v2));
  }
  (*(void (**)(_QWORD, uint64_t, unsigned int **))(**(_QWORD **)(a1 + 248) + 40))(*(_QWORD *)(a1 + 248), a2, &v5);
  result = (uint64_t)v5;
  if (v5)
    return WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v5);
  return result;
}

unsigned int *TI::Favonius::SearchNodeTransposition::compute_geometry_model_data(unsigned int **this)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int *result;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int *v14;

  if (!this[30])
    TI::Favonius::SearchNodeTransposition::compute_geometry_model_data_for_first_key((TI::Favonius::SearchNodeTransposition *)this);
  v2 = this[6];
  if (v2)
  {
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + 1, v2));
  }
  v4 = this[30];
  v5 = this[2];
  v14 = v5;
  if (v5)
  {
    v6 = v5 + 2;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
  }
  v13 = v2;
  if (v2)
  {
    do
      v8 = __ldaxr(v2);
    while (__stlxr(v8 + 1, v2));
  }
  (*(void (**)(unsigned int *, unsigned int **, unsigned int **))(*(_QWORD *)v4 + 56))(v4, &v14, &v13);
  if (v13)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v13);
  result = v14;
  if (v14)
  {
    v10 = v14 + 2;
    v11 = atomic_load(v14 + 2);
    if (v11 == 1)
    {
      result = (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v14 + 8))();
    }
    else
    {
      do
        v12 = __ldaxr(v10);
      while (__stlxr(v12 - 1, v10));
    }
  }
  if (v2)
    return (unsigned int *)WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v2);
  return result;
}

void TI::Favonius::SearchNodeTransposition::set_language_scores_from_parent_and_typing_hypothesis(TI::Favonius::SearchNodeTransposition *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 7);
  if (!v1)
    v1 = *((_QWORD *)this + 31);
  TI::Favonius::SearchNode::set_language_scores_from_parent_and_typing_hypothesis((uint64_t)this, v1);
}

unsigned int *TI::Favonius::SearchNodeTransposition::clone_with_typing@<X0>(_QWORD *a1@<X0>, unsigned int **a2@<X1>, TI::Favonius::SearchNodeTransposition **a3@<X8>)
{
  TI::Favonius::SearchNodeTransposition *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int *result;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int *v18;
  unsigned int *v19;

  v6 = (TI::Favonius::SearchNodeTransposition *)operator new();
  v7 = (unsigned int *)a1[31];
  v19 = v7;
  if (v7)
  {
    v8 = v7 + 2;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
  }
  v10 = *a2;
  *a2 = 0;
  v18 = v10;
  *a3 = TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(v6, a1, (uint64_t *)&v19, &v18);
  if (v18)
  {
    v11 = v18 + 2;
    v12 = atomic_load(v18 + 2);
    if (v12 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v18 + 248))();
    }
    else
    {
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 - 1, v11));
    }
  }
  result = v19;
  if (v19)
  {
    v15 = v19 + 2;
    v16 = atomic_load(v19 + 2);
    if (v16 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v19 + 248))();
    }
    else
    {
      do
        v17 = __ldaxr(v15);
      while (__stlxr(v17 - 1, v15));
    }
  }
  return result;
}

TI::Favonius::SearchNodeTransposition *TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(TI::Favonius::SearchNodeTransposition *a1, _QWORD *a2, uint64_t *a3, unsigned int **a4)
{
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int *v21;

  v7 = *a4;
  *a4 = 0;
  v21 = v7;
  TI::Favonius::SearchNode::SearchNode((uint64_t)a1, (uint64_t)a2, (uint64_t *)&v21);
  if (v21)
  {
    v8 = v21 + 2;
    v9 = atomic_load(v21 + 2);
    if (v9 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v21 + 248))();
    }
    else
    {
      do
        v10 = __ldaxr(v8);
      while (__stlxr(v10 - 1, v8));
    }
  }
  *(_QWORD *)a1 = &off_1EA102AC0;
  v11 = a2[28];
  *((_QWORD *)a1 + 28) = v11;
  if (v11)
  {
    v12 = (unsigned int *)(v11 + 8);
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
  }
  v14 = (unsigned int *)a2[29];
  *((_QWORD *)a1 + 29) = v14;
  if (v14)
  {
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 + 1, v14));
  }
  v16 = a2[30];
  *((_QWORD *)a1 + 30) = v16;
  if (v16)
  {
    v17 = (unsigned int *)(v16 + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 + 1, v17));
  }
  v19 = *a3;
  *a3 = 0;
  *((_QWORD *)a1 + 31) = v19;
  *((_QWORD *)a1 + 32) = 0;
  *((_QWORD *)a1 + 33) = 0;
  *((_QWORD *)a1 + 34) = 0;
  if (!*((_QWORD *)a1 + 7))
    TI::Favonius::SearchNodeTransposition::set_bound_on_score(a1);
  return a1;
}

float TI::Favonius::SearchNodeTransposition::set_bound_on_score(TI::Favonius::SearchNodeTransposition *this)
{
  float v2;
  float v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  uint64_t v7;
  float v8;
  float result;

  v2 = *(float *)(*((_QWORD *)this + 6) + 32);
  v3 = v2 + (*(float (**)(_QWORD))(**((_QWORD **)this + 2) + 24))(*((_QWORD *)this + 2));
  v4 = *((_QWORD *)this + 30);
  if (!v4)
  {
    v3 = v3 + *(float *)(*((_QWORD *)this + 29) + 32);
    v5 = *((_QWORD *)this + 4);
    if (!*(_QWORD *)(v5 + 32))
      goto LABEL_5;
    v4 = *(_QWORD *)(v5 + 128);
  }
  v3 = v3 + (*(float (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
  v5 = *((_QWORD *)this + 4);
LABEL_5:
  v6 = *(float *)(v5 + 136);
  v7 = *((_QWORD *)this + 31);
  if (v7)
  {
    v8 = (*(float (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
    v6 = v6 + logf(v8);
  }
  result = v3 + (float)(*((float *)this + 38) * v6);
  *((float *)this + 6) = result;
  return result;
}

unsigned int *TI::Favonius::SearchNodeTransposition::compute_geometry_model_data_for_first_key(TI::Favonius::SearchNodeTransposition *this)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int *result;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int *v21;
  unsigned int *v22;

  v2 = *(_QWORD *)(*((_QWORD *)this + 4) + 128);
  v3 = (unsigned int *)*((_QWORD *)this + 28);
  v21 = v3;
  if (v3)
  {
    v4 = v3 + 2;
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
  }
  v6 = (unsigned int *)*((_QWORD *)this + 29);
  v20 = v6;
  if (v6)
  {
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
  }
  (*(void (**)(unsigned int **__return_ptr, uint64_t, unsigned int **, unsigned int **))(*(_QWORD *)v2 + 48))(&v22, v2, &v21, &v20);
  v8 = (unsigned int *)*((_QWORD *)this + 30);
  v9 = v22;
  v22 = 0;
  *((_QWORD *)this + 30) = v9;
  if (v8)
  {
    v10 = v8 + 2;
    v11 = atomic_load(v8 + 2);
    if (v11 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v8 + 8))(v8);
    }
    else
    {
      do
        v12 = __ldaxr(v10);
      while (__stlxr(v12 - 1, v10));
    }
    if (v22)
    {
      v13 = v22 + 2;
      v14 = atomic_load(v22 + 2);
      if (v14 == 1)
      {
        (*(void (**)(void))(*(_QWORD *)v22 + 8))();
      }
      else
      {
        do
          v15 = __ldaxr(v13);
        while (__stlxr(v15 - 1, v13));
      }
    }
  }
  if (v20)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v20);
  result = v21;
  if (v21)
  {
    v17 = v21 + 2;
    v18 = atomic_load(v21 + 2);
    if (v18 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v21 + 8))();
    }
    else
    {
      do
        v19 = __ldaxr(v17);
      while (__stlxr(v19 - 1, v17));
    }
  }
  return result;
}

TI::Favonius::SearchNodeTransposition *TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(TI::Favonius::SearchNodeTransposition *this, const TI::Favonius::SearchNodeTransposition *a2, TI::Favonius::SearchNode *a3)
{
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int *v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int *v29;
  unsigned int *v30;

  v6 = (unsigned int *)*((_QWORD *)a2 + 2);
  v30 = v6;
  if (v6)
  {
    v7 = v6 + 2;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 + 1, v7));
  }
  v9 = (unsigned int *)*((_QWORD *)a2 + 6);
  v29 = v9;
  if (v9)
  {
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 + 1, v9));
  }
  v28 = 0;
  TI::Favonius::SearchNode::SearchNode((uint64_t)this, (uint64_t)a3, (uint64_t *)&v30, (uint64_t *)&v29, (uint64_t *)&v28, 0, *((float *)a2 + 38), NAN);
  if (v28)
  {
    v11 = v28 + 2;
    v12 = atomic_load(v28 + 2);
    if (v12 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v28 + 248))();
    }
    else
    {
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 - 1, v11));
    }
  }
  if (v29)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v29);
  if (v30)
  {
    v14 = v30 + 2;
    v15 = atomic_load(v30 + 2);
    if (v15 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v30 + 8))();
    }
    else
    {
      do
        v16 = __ldaxr(v14);
      while (__stlxr(v16 - 1, v14));
    }
  }
  *(_QWORD *)this = &off_1EA102AC0;
  v17 = *((_QWORD *)a2 + 28);
  *((_QWORD *)this + 28) = v17;
  if (v17)
  {
    v18 = (unsigned int *)(v17 + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 + 1, v18));
  }
  v20 = (unsigned int *)*((_QWORD *)a2 + 29);
  *((_QWORD *)this + 29) = v20;
  if (v20)
  {
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 + 1, v20));
  }
  *((_QWORD *)this + 30) = 0;
  (*(void (**)(uint64_t *__return_ptr, _QWORD, _QWORD))(**((_QWORD **)a2 + 31) + 208))(&v27, *((_QWORD *)a2 + 31), *((_QWORD *)a3 + 7));
  *((_QWORD *)this + 31) = v27;
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 34) = 0;
  (*(void (**)(unsigned int **__return_ptr))(**((_QWORD **)a2 + 7) + 208))(&v26);
  (*(void (**)(TI::Favonius::SearchNodeTransposition *, unsigned int **))(*(_QWORD *)this + 152))(this, &v26);
  if (v26)
  {
    v22 = v26 + 2;
    v23 = atomic_load(v26 + 2);
    if (v23 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v26 + 248))();
    }
    else
    {
      do
        v24 = __ldaxr(v22);
      while (__stlxr(v24 - 1, v22));
    }
  }
  (*(void (**)(TI::Favonius::SearchNodeTransposition *))(*(_QWORD *)this + 136))(this);
  return this;
}

unsigned int *TI::Favonius::SearchNodeTransposition::compute_language_model_data_for_first_key(TI::Favonius::SearchNodeTransposition *this)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int *result;
  unsigned int *v4;

  v1 = *(unsigned int **)(*((_QWORD *)this + 6) + 8);
  v4 = v1;
  if (v1)
  {
    do
      v2 = __ldaxr(v1);
    while (__stlxr(v2 + 1, v1));
  }
  TI::Favonius::SearchNode::get_language_extensions(*((_QWORD *)this + 4), (unint64_t *)this + 32, (uint64_t *)&v4);
  result = v4;
  if (v4)
    return (unsigned int *)WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v4);
  return result;
}

BOOL ___ZN2TI8Favonius23SearchNodeTransposition23decrease_bound_on_scoreEv_block_invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  float v4;

  v4 = (*(float (**)(_QWORD))(*(_QWORD *)*a2 + 24))(*a2);
  return v4 < (*(float (**)(_QWORD))(*(_QWORD *)*a3 + 24))(*a3);
}

_QWORD *TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(_QWORD *a1, uint64_t a2, unsigned int **a3, uint64_t *a4)
{
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int *v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int *v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int *v30;
  uint64_t v31;
  unsigned int *v32;

  v6 = *(_QWORD *)(a2 + 32);
  v7 = *a3;
  *a3 = 0;
  v8 = *a4;
  *a4 = 0;
  v31 = v8;
  v32 = v7;
  v9 = *(unsigned int **)(a2 + 56);
  v30 = v9;
  if (v9)
  {
    v10 = v9 + 2;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 + 1, v10));
  }
  TI::Favonius::SearchNode::SearchNode((uint64_t)a1, v6, (uint64_t *)&v32, &v31, (uint64_t *)&v30, (_QWORD *)(a2 + 64), *(float *)(a2 + 152), NAN);
  if (v30)
  {
    v12 = v30 + 2;
    v13 = atomic_load(v30 + 2);
    if (v13 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v30 + 248))();
    }
    else
    {
      do
        v14 = __ldaxr(v12);
      while (__stlxr(v14 - 1, v12));
    }
  }
  if (v31)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v31);
  if (v32)
  {
    v15 = v32 + 2;
    v16 = atomic_load(v32 + 2);
    if (v16 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v32 + 8))();
    }
    else
    {
      do
        v17 = __ldaxr(v15);
      while (__stlxr(v17 - 1, v15));
    }
  }
  *a1 = &off_1EA102AC0;
  v18 = *(_QWORD *)(a2 + 224);
  a1[28] = v18;
  if (v18)
  {
    v19 = (unsigned int *)(v18 + 8);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 + 1, v19));
  }
  v21 = *(unsigned int **)(a2 + 232);
  a1[29] = v21;
  if (v21)
  {
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 + 1, v21));
  }
  v23 = *(_QWORD *)(a2 + 240);
  a1[30] = v23;
  if (v23)
  {
    v24 = (unsigned int *)(v23 + 8);
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 + 1, v24));
  }
  v26 = *(_QWORD *)(a2 + 248);
  a1[31] = v26;
  if (v26)
  {
    v27 = (unsigned int *)(v26 + 8);
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 + 1, v27));
  }
  WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::Vector(a1 + 32, (_QWORD *)(a2 + 256));
  return a1;
}

uint64_t TI::Favonius::SearchNodeTransposition::create@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, unsigned int *a4@<X3>, unsigned int *a5@<X4>, uint64_t *a6@<X8>, float a7@<S0>)
{
  uint64_t v14;
  uint64_t result;

  v14 = operator new();
  result = TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(v14, a1, a2, a3, a4, a5, a7);
  *a6 = result;
  return result;
}

uint64_t TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, float a7)
{
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int *v23;
  unsigned int *v24;
  unsigned int *v25;

  v25 = a5;
  if (a5)
  {
    v10 = a5 + 2;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 + 1, v10));
  }
  v24 = a6;
  if (a6)
  {
    do
      v12 = __ldaxr(a6);
    while (__stlxr(v12 + 1, a6));
  }
  v23 = 0;
  TI::Favonius::SearchNode::SearchNode(a1, a2, (uint64_t *)&v25, (uint64_t *)&v24, (uint64_t *)&v23, 0, a7, NAN);
  if (v23)
  {
    v13 = v23 + 2;
    v14 = atomic_load(v23 + 2);
    if (v14 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v23 + 248))();
    }
    else
    {
      do
        v15 = __ldaxr(v13);
      while (__stlxr(v15 - 1, v13));
    }
  }
  if (v24)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v24);
  if (v25)
  {
    v16 = v25 + 2;
    v17 = atomic_load(v25 + 2);
    if (v17 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v25 + 8))();
    }
    else
    {
      do
        v18 = __ldaxr(v16);
      while (__stlxr(v18 - 1, v16));
    }
  }
  *(_QWORD *)a1 = &off_1EA102AC0;
  *(_QWORD *)(a1 + 224) = a3;
  if (a3)
  {
    v19 = (unsigned int *)(a3 + 8);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 + 1, v19));
  }
  *(_QWORD *)(a1 + 232) = a4;
  if (a4)
  {
    do
      v21 = __ldaxr(a4);
    while (__stlxr(v21 + 1, a4));
  }
  *(_QWORD *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  TI::Favonius::SearchNodeTransposition::set_bound_on_score((TI::Favonius::SearchNodeTransposition *)a1);
  return a1;
}

void TI::Favonius::SearchNodeSkippingTouch::~SearchNodeSkippingTouch(TI::Favonius::SearchNodeSkippingTouch *this)
{
  TI::Favonius::SearchNode::~SearchNode(this);
  JUMPOUT(0x1DF0A2144);
}

unsigned int *TI::Favonius::SearchNodeSkippingTouch::clone_substituting_touch@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int *result;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int *v13;

  v6 = operator new();
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *a2;
  *a2 = 0;
  v13 = v8;
  TI::Favonius::SearchNodeSkippingTouch::SearchNodeSkippingTouch(v6, v7, &v13, *(float *)(a1 + 152));
  result = v13;
  if (v13)
  {
    v10 = v13 + 2;
    v11 = atomic_load(v13 + 2);
    if (v11 == 1)
    {
      result = (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v13 + 8))();
    }
    else
    {
      do
        v12 = __ldaxr(v10);
      while (__stlxr(v12 - 1, v10));
    }
  }
  *a3 = v6;
  return result;
}

float TI::Favonius::SearchNodeSkippingTouch::decrease_bound_on_score(TI::Favonius::SearchNodeSkippingTouch *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  float result;
  const float *v11;
  float32x2_t v12;
  float32x2_t v13;
  unsigned int *v14;

  if (!*((_BYTE *)this + 148))
  {
    if (!*((_QWORD *)this + 16))
    {
      (*(void (**)(unsigned int **__return_ptr, TI::Favonius::SearchNodeSkippingTouch *))(*(_QWORD *)this + 120))(&v14, this);
      v2 = (unsigned int *)*((_QWORD *)this + 16);
      v3 = v14;
      v14 = 0;
      *((_QWORD *)this + 16) = v3;
      if (v2)
      {
        v4 = v2 + 2;
        v5 = atomic_load(v2 + 2);
        if (v5 == 1)
        {
          (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
        }
        else
        {
          do
            v6 = __ldaxr(v4);
          while (__stlxr(v6 - 1, v4));
        }
        if (v14)
        {
          v7 = v14 + 2;
          v8 = atomic_load(v14 + 2);
          if (v8 == 1)
          {
            (*(void (**)(void))(*(_QWORD *)v14 + 8))();
          }
          else
          {
            do
              v9 = __ldaxr(v7);
            while (__stlxr(v9 - 1, v7));
          }
        }
      }
      *((float *)this + 36) = (*(float (**)(_QWORD))(**((_QWORD **)this + 16) + 16))(*((_QWORD *)this + 16));
      (*(void (**)(TI::Favonius::SearchNodeSkippingTouch *))(*(_QWORD *)this + 136))(this);
    }
    *((_BYTE *)this + 148) = (*(uint64_t (**)(TI::Favonius::SearchNodeSkippingTouch *))(*(_QWORD *)this + 128))(this);
    result = *((float *)this + 38);
    v11 = (const float *)((char *)this + 144);
    v12 = vld1_dup_f32(v11);
    v13 = vmla_n_f32(v12, *(float32x2_t *)((char *)this + 136), result);
    *(float32x2_t *)((char *)this + 156) = v13;
    *((_DWORD *)this + 6) = v13.i32[0];
  }
  return result;
}

uint64_t TI::Favonius::SearchNodeSkippingTouch::key_count(TI::Favonius::SearchNodeSkippingTouch *this)
{
  return 0;
}

unsigned int *TI::Favonius::SearchNodeSkippingTouch::clone_with_parent@<X0>(TI::Favonius::SearchNodeSkippingTouch *this@<X0>, TI::Favonius::SearchNode *a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned int *v6;
  uint64_t v7;
  _BYTE *v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int *result;
  unsigned int *v13;
  unsigned int v14;
  uint64_t (*i)(void);
  unsigned int v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int *v21;

  (*(void (**)(unsigned int **__return_ptr, _QWORD, _QWORD))(**((_QWORD **)this + 7) + 208))(&v21, *((_QWORD *)this + 7), *((_QWORD *)a2 + 7));
  v6 = v21;
  v7 = operator new();
  v8 = (_BYTE *)v7;
  v9 = (unsigned int *)*((_QWORD *)this + 2);
  v20 = v9;
  if (v9)
  {
    v10 = v9 + 2;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 + 1, v10));
  }
  TI::Favonius::SearchNodeSkippingTouch::SearchNodeSkippingTouch(v7, (uint64_t)a2, &v20, *((float *)this + 38));
  result = v20;
  if (!v20)
    goto LABEL_11;
  v13 = v20 + 2;
  v14 = atomic_load(v20 + 2);
  if (v14 != 1)
  {
    do
      v16 = __ldaxr(v13);
    while (__stlxr(v16 - 1, v13));
    goto LABEL_11;
  }
  for (i = *(uint64_t (**)(void))(*(_QWORD *)v20 + 8); ; i = *(uint64_t (**)(void))(*(_QWORD *)v8 + 48))
  {
    result = (unsigned int *)i();
LABEL_11:
    if (v8[148])
      break;
  }
  *a3 = v8;
  if (v6)
  {
    v17 = v6 + 2;
    v18 = atomic_load(v6 + 2);
    if (v18 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v6 + 248))(v6);
    }
    else
    {
      do
        v19 = __ldaxr(v17);
      while (__stlxr(v19 - 1, v17));
    }
  }
  return result;
}

unsigned __int16 *TI::Favonius::SearchNodeSkippingTouch::append_local_keys_for_debugging(TI::Favonius::SearchNodeSkippingTouch *this, KB::String *a2)
{
  return KB::String::append((unsigned __int16 *)a2, "{}", 0xFFFFuLL);
}

unsigned int *TI::Favonius::SearchNodeSkippingTouch::compute_geometry_model_data(TI::Favonius::SearchNodeSkippingTouch *this)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int *result;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;

  v2 = *(_QWORD *)(*((_QWORD *)this + 4) + 128);
  v3 = (unsigned int *)*((_QWORD *)this + 2);
  v10 = v3;
  if (v3)
  {
    v4 = v3 + 2;
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
  }
  (*(void (**)(uint64_t, unsigned int **))(*(_QWORD *)v2 + 80))(v2, &v10);
  result = v10;
  if (v10)
  {
    v7 = v10 + 2;
    v8 = atomic_load(v10 + 2);
    if (v8 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v10 + 8))();
    }
    else
    {
      do
        v9 = __ldaxr(v7);
      while (__stlxr(v9 - 1, v7));
    }
  }
  return result;
}

BOOL TI::Favonius::SearchNodeSkippingTouch::compute_score_is_final(TI::Favonius::SearchNodeSkippingTouch *this)
{
  return *((_QWORD *)this + 16) != 0;
}

TI::Favonius::SearchNodeSkippingTouch *TI::Favonius::SearchNodeSkippingTouch::clone_with_typing@<X0>(const TI::Favonius::SearchNodeSkippingTouch *a1@<X0>, TI::Favonius::SearchNodeSkippingTouch **a2@<X8>)
{
  TI::Favonius::SearchNodeSkippingTouch *v4;
  TI::Favonius::SearchNodeSkippingTouch *result;

  v4 = (TI::Favonius::SearchNodeSkippingTouch *)operator new();
  result = TI::Favonius::SearchNodeSkippingTouch::SearchNodeSkippingTouch(v4, a1);
  *a2 = result;
  return result;
}

TI::Favonius::SearchNodeSkippingTouch *TI::Favonius::SearchNodeSkippingTouch::SearchNodeSkippingTouch(TI::Favonius::SearchNodeSkippingTouch *this, const TI::Favonius::SearchNodeSkippingTouch *a2)
{
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int *v10;

  v3 = (unsigned int *)*((_QWORD *)a2 + 4);
  if (v3)
  {
    v3 = (unsigned int *)*((_QWORD *)v3 + 7);
    if (v3)
    {
      v4 = v3 + 2;
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 + 1, v4));
    }
  }
  v10 = v3;
  TI::Favonius::SearchNode::SearchNode((uint64_t)this, (uint64_t)a2, (uint64_t *)&v10);
  if (v10)
  {
    v6 = v10 + 2;
    v7 = atomic_load(v10 + 2);
    if (v7 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v10 + 248))();
    }
    else
    {
      do
        v8 = __ldaxr(v6);
      while (__stlxr(v8 - 1, v6));
    }
  }
  *(_QWORD *)this = &off_1EA102CA0;
  return this;
}

uint64_t TI::Favonius::SearchNodeSkippingTouch::SearchNodeSkippingTouch(uint64_t a1, uint64_t a2, unsigned int **a3, float a4)
{
  unsigned int *v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int *v16;
  uint64_t v17;
  unsigned int *v18;

  v5 = *a3;
  *a3 = 0;
  v17 = 0;
  v18 = v5;
  v6 = *(unsigned int **)(a2 + 56);
  v16 = v6;
  if (v6)
  {
    v7 = v6 + 2;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 + 1, v7));
  }
  TI::Favonius::SearchNode::SearchNode(a1, a2, (uint64_t *)&v18, &v17, (uint64_t *)&v16, 0, a4, NAN);
  if (v16)
  {
    v9 = v16 + 2;
    v10 = atomic_load(v16 + 2);
    if (v10 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v16 + 248))();
    }
    else
    {
      do
        v11 = __ldaxr(v9);
      while (__stlxr(v11 - 1, v9));
    }
  }
  if (v17)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v17);
  if (v18)
  {
    v12 = v18 + 2;
    v13 = atomic_load(v18 + 2);
    if (v13 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v18 + 8))();
    }
    else
    {
      do
        v14 = __ldaxr(v12);
      while (__stlxr(v14 - 1, v12));
    }
  }
  *(_QWORD *)a1 = &off_1EA102CA0;
  *(float *)(a1 + 24) = (*(float (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16))
                      + (float)(*(float *)(*(_QWORD *)(a1 + 32) + 144)
                              + (float)(*(float *)(a1 + 152) * *(float *)(*(_QWORD *)(a1 + 32) + 136)));
  return a1;
}

unsigned int *TI::Favonius::SearchNodeSkippingTouch::create@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X8>, float a4@<S0>)
{
  uint64_t v8;
  unsigned int *v9;
  unsigned int *result;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int *v14;

  v8 = operator new();
  v9 = *a2;
  *a2 = 0;
  v14 = v9;
  *a3 = TI::Favonius::SearchNodeSkippingTouch::SearchNodeSkippingTouch(v8, a1, &v14, a4);
  result = v14;
  if (v14)
  {
    v11 = v14 + 2;
    v12 = atomic_load(v14 + 2);
    if (v12 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v14 + 8))();
    }
    else
    {
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 - 1, v11));
    }
  }
  return result;
}

void TIInlineCompletionsCache::TIInlineCompletionsCache(TIInlineCompletionsCache *this, uint64_t a2)
{
  *(_QWORD *)this = a2;
  *((_BYTE *)this + 8) = 0;
  *((_BYTE *)this + 192) = 0;
}

{
  *(_QWORD *)this = a2;
  *((_BYTE *)this + 8) = 0;
  *((_BYTE *)this + 192) = 0;
}

void TIInlineCompletionsCache::cached_candidate(KB::LanguageModelContext *this@<X1>, uint64_t a2@<X0>, const void **a3@<X2>, size_t a4@<X3>, _BYTE *a5@<X8>)
{
  const void *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  NSObject *v18;
  const char *v19;
  uint64_t v20;
  unint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 **v23;
  uint64_t v24;
  unsigned __int8 *v25;
  unsigned __int8 *v26;
  int v27;
  unsigned __int8 *v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  std::string *v33;
  std::string::size_type v34;
  std::string *v35;
  std::string::size_type size;
  std::string::size_type v37;
  size_t v38;
  char *p_s2;
  std::string *v40;
  char *v41;
  const void *v42;
  size_t v43;
  unsigned __int8 v44;
  std::string::size_type v45;
  int v46;
  size_t v47;
  void *v48;
  std::string::size_type v49;
  std::string *v50;
  __int128 *v51;
  std::string::size_type *v52;
  std::string::size_type v53;
  std::string __p[4];
  std::string v55;
  std::string v56;
  std::string v57;
  uint64_t v58;
  int v59;
  char v60[8];
  char v61;
  void *__s2;
  int v63[2];
  unsigned __int8 v64;
  std::string v65;
  uint8_t buf[4];
  _BYTE v67[12];
  void *v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a2 + 192))
    goto LABEL_44;
  v10 = (const void *)*((unsigned __int8 *)a3 + 23);
  if ((char)v10 < 0)
    v10 = a3[1];
  if (!v10)
  {
    if (KB::LanguageModelContext::is_linguistically_void(this))
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v67 = "cached_candidate";
        v18 = MEMORY[0x1E0C81028];
        v19 = "%s  TIInlineCompletionsCache:: Context is not linguistically void. Also prefix is empty - will not look into cache.";
LABEL_43:
        _os_log_debug_impl(&dword_1DA6F2000, v18, OS_LOG_TYPE_DEBUG, v19, buf, 0xCu);
      }
    }
    else
    {
      v29 = *((_QWORD *)this + 3);
      if (v29 == *((_QWORD *)this + 2) || *(_DWORD *)(v29 - 4) > 0x1F3u)
        goto LABEL_5;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v67 = "cached_candidate";
        v18 = MEMORY[0x1E0C81028];
        v19 = "%s  TIInlineCompletionsCache:: Context is not linguistically void but ends with a sentence delimiter or sp"
              "ecial token. Also prefix is empty - will not look into cache.";
        goto LABEL_43;
      }
    }
LABEL_44:
    *a5 = 0;
    a5[88] = 0;
    return;
  }
LABEL_5:
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)buf, (const KB::LanguageModelContext *)(a2 + 8));
  v11 = v72;
  v12 = 0xAAAAAAAAAAAAAAABLL * ((v73 - v72) >> 3);
  v13 = *((_QWORD *)this + 10);
  v14 = 0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 11) - v13) >> 3);
  if (v14 >= v12 && v14 <= *(_QWORD *)a2 - 0x5555555555555555 * ((v73 - v72) >> 3))
  {
    if (v73 != v72)
    {
      v20 = 0;
      if (v12 <= 1)
        v21 = 1;
      else
        v21 = 0xAAAAAAAAAAAAAAABLL * ((v73 - v72) >> 3);
      while (1)
      {
        v22 = (unsigned __int8 *)(v13 + 24 * v20);
        v23 = (unsigned __int8 **)(v11 + 24 * v20);
        v24 = v22[23];
        if ((v24 & 0x80u) == 0)
          v25 = (unsigned __int8 *)v22[23];
        else
          v25 = (unsigned __int8 *)*((_QWORD *)v22 + 1);
        v26 = (unsigned __int8 *)*((unsigned __int8 *)v23 + 23);
        v27 = (char)v26;
        if ((char)v26 < 0)
          v26 = v23[1];
        if (v25 != v26)
          goto LABEL_7;
        if (v27 >= 0)
          v28 = (unsigned __int8 *)(v11 + 24 * v20);
        else
          v28 = *v23;
        if ((v24 & 0x80) != 0)
        {
          if (memcmp(*(const void **)v22, v28, *((_QWORD *)v22 + 1)))
            goto LABEL_7;
        }
        else if (v22[23])
        {
          while (*v22 == *v28)
          {
            ++v22;
            ++v28;
            if (!--v24)
              goto LABEL_37;
          }
          goto LABEL_7;
        }
LABEL_37:
        if (++v20 == v21)
          goto LABEL_47;
      }
    }
    v21 = 0;
LABEL_47:
    std::string::basic_string[abi:nn180100]<0>(&v65, "");
    v30 = v14 - v21;
    if (v14 > v21)
    {
      v31 = (char *)(v13 + 24 * v21);
      do
      {
        v32 = v31;
        if (v31[23] < 0)
          v32 = *(char **)v31;
        std::string::basic_string[abi:nn180100]<0>(&v56, v32);
        v33 = std::string::append(&v56, " ", 1uLL);
        v34 = v33->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
        __p[0].__r_.__value_.__r.__words[2] = v34;
        v33->__r_.__value_.__l.__size_ = 0;
        v33->__r_.__value_.__r.__words[2] = 0;
        v33->__r_.__value_.__r.__words[0] = 0;
        if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v35 = __p;
        else
          v35 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
        if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(__p[0].__r_.__value_.__r.__words[2]);
        else
          size = __p[0].__r_.__value_.__l.__size_;
        std::string::append(&v65, (const std::string::value_type *)v35, size);
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p[0].__r_.__value_.__l.__data_);
        if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v56.__r_.__value_.__l.__data_);
        v31 += 24;
        --v30;
      }
      while (v30);
    }
    if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v37 = HIBYTE(v65.__r_.__value_.__r.__words[2]);
    else
      v37 = v65.__r_.__value_.__l.__size_;
    if (*((char *)a3 + 23) >= 0)
      v38 = *((unsigned __int8 *)a3 + 23);
    else
      v38 = (size_t)a3[1];
    p_s2 = (char *)&__s2;
    std::string::basic_string[abi:nn180100]((uint64_t)&__s2, v38 + v37);
    if ((v64 & 0x80u) != 0)
      p_s2 = (char *)__s2;
    if (v37)
    {
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v40 = &v65;
      else
        v40 = (std::string *)v65.__r_.__value_.__r.__words[0];
      memmove(p_s2, v40, v37);
    }
    v41 = &p_s2[v37];
    if (v38)
    {
      if (*((char *)a3 + 23) >= 0)
        v42 = a3;
      else
        v42 = *a3;
      memmove(v41, v42, v38);
    }
    v41[v38] = 0;
    v43 = v64;
    v44 = v64;
    if ((v64 & 0x80u) != 0)
      v43 = *(_QWORD *)v63;
    if (v43 < a4)
    {
      *a5 = 0;
      a5[88] = 0;
LABEL_118:
      if ((v44 & 0x80) != 0)
        operator delete(__s2);
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v65.__r_.__value_.__l.__data_);
      goto LABEL_8;
    }
    if (!*(_BYTE *)(a2 + 192))
      goto LABEL_122;
    if (*(char *)(a2 + 135) < 0)
      std::string::__init_copy_ctor_external(&v56, *(const std::string::value_type **)(a2 + 112), *(_QWORD *)(a2 + 120));
    else
      v56 = *(std::string *)(a2 + 112);
    if (*(char *)(a2 + 159) < 0)
      std::string::__init_copy_ctor_external(&v57, *(const std::string::value_type **)(a2 + 136), *(_QWORD *)(a2 + 144));
    else
      v57 = *(std::string *)(a2 + 136);
    v58 = *(_QWORD *)(a2 + 160);
    v59 = *(_DWORD *)(a2 + 168);
    v60[0] = 0;
    v61 = 0;
    if (*(_BYTE *)(a2 + 184))
    {
      MEMORY[0x1DF0A1C10](v60, a2 + 176);
      v61 = 1;
    }
    if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v55, v56.__r_.__value_.__l.__data_, v56.__r_.__value_.__l.__size_);
    else
      v55 = v56;
    v45 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
    v46 = SHIBYTE(v55.__r_.__value_.__r.__words[2]);
    if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v45 = v55.__r_.__value_.__l.__size_;
    if ((char)v64 < 0)
    {
      v47 = *(_QWORD *)v63;
      if (v45 < *(_QWORD *)v63)
        goto LABEL_108;
      v48 = __s2;
    }
    else
    {
      v47 = v64;
      if (v45 < v64)
        goto LABEL_108;
      v48 = &__s2;
    }
    if (std::string::starts_with[abi:nn180100]((uint64_t)&v55, v48, v47))
    {
      if (*(_BYTE *)(a2 + 192))
      {
        v49 = HIBYTE(v65.__r_.__value_.__r.__words[2]);
        if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v49 = v65.__r_.__value_.__l.__size_;
        v53 = v49;
        std::pair<TIInlineCompletion,unsigned long>::pair[abi:nn180100]<TIInlineCompletion const&,unsigned long,0>(__p, (__int128 *)(a2 + 112), &v53);
        std::pair<TIInlineCompletion,unsigned long>::pair[abi:nn180100]((uint64_t)a5, (__int128 *)__p);
        a5[88] = 1;
        std::pair<TIInlineCompletion,unsigned long>::~pair((uint64_t)__p);
        goto LABEL_109;
      }
LABEL_122:
      v50 = (std::string *)std::__throw_bad_optional_access[abi:nn180100]();
      std::pair<TIInlineCompletion,unsigned long>::pair[abi:nn180100]<TIInlineCompletion const&,unsigned long,0>(v50, v51, v52);
      return;
    }
LABEL_108:
    *a5 = 0;
    a5[88] = 0;
LABEL_109:
    if (v46 < 0)
      operator delete(v55.__r_.__value_.__l.__data_);
    if (v61)
      language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)v60);
    if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v57.__r_.__value_.__l.__data_);
    if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v56.__r_.__value_.__l.__data_);
    v44 = v64;
    goto LABEL_118;
  }
LABEL_7:
  *a5 = 0;
  a5[88] = 0;
LABEL_8:
  __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v72;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v71);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v70);
  if (v68)
  {
    v69 = v68;
    operator delete(v68);
  }
  v15 = *(std::__shared_weak_count **)&v67[4];
  if (*(_QWORD *)&v67[4])
  {
    v16 = (unint64_t *)(*(_QWORD *)&v67[4] + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

std::string *std::pair<TIInlineCompletion,unsigned long>::pair[abi:nn180100]<TIInlineCompletion const&,unsigned long,0>(std::string *this, __int128 *a2, std::string::size_type *a3)
{
  __int128 v6;
  std::string *v7;
  __int128 v8;
  std::string::size_type v9;
  int v10;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v6 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v6;
  }
  v7 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v8 = *(__int128 *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  v9 = *((_QWORD *)a2 + 6);
  v10 = *((_DWORD *)a2 + 14);
  this[2].__r_.__value_.__s.__data_[16] = 0;
  LODWORD(this[2].__r_.__value_.__r.__words[1]) = v10;
  this[2].__r_.__value_.__r.__words[0] = v9;
  this[3].__r_.__value_.__s.__data_[0] = 0;
  if (*((_BYTE *)a2 + 72))
  {
    MEMORY[0x1DF0A1C10]();
    this[3].__r_.__value_.__s.__data_[0] = 1;
  }
  this[3].__r_.__value_.__l.__size_ = *a3;
  return this;
}

uint64_t std::pair<TIInlineCompletion,unsigned long>::pair[abi:nn180100](uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  v4 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  v5 = *(__int128 *)((char *)a2 + 24);
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  *(_OWORD *)(a1 + 24) = v5;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 5) = 0;
  *((_QWORD *)a2 + 3) = 0;
  v6 = *((_QWORD *)a2 + 6);
  v7 = *((_DWORD *)a2 + 14);
  *(_BYTE *)(a1 + 64) = 0;
  v8 = a1 + 64;
  *(_DWORD *)(v8 - 8) = v7;
  *(_QWORD *)(v8 - 16) = v6;
  *(_BYTE *)(v8 + 8) = 0;
  if (*((_BYTE *)a2 + 72))
  {
    language_modeling::v1::InlineCompletion::InlineCompletion();
    *(_BYTE *)(a1 + 72) = 1;
  }
  *(_QWORD *)(a1 + 80) = *((_QWORD *)a2 + 10);
  return a1;
}

uint64_t std::pair<TIInlineCompletion,unsigned long>::~pair(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 72))
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 64));
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t TIInlineCompletionsCache::clear(uint64_t this)
{
  uint64_t v1;

  if (*(_BYTE *)(this + 192))
  {
    v1 = this;
    this = std::pair<KB::LanguageModelContext,TIInlineCompletion>::~pair(this + 8);
    *(_BYTE *)(v1 + 192) = 0;
  }
  return this;
}

void TIInlineCompletionsCache::update(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  language_modeling::v1::InlineCompletion *v6;

  v4 = a1 + 8;
  if (*(_BYTE *)(a1 + 192))
  {
    KB::LanguageModelContext::operator=(v4, (uint64_t *)a2);
    std::string::operator=((std::string *)(a1 + 112), (const std::string *)(a2 + 104));
    std::string::operator=((std::string *)(a1 + 136), (const std::string *)(a2 + 128));
    v5 = *(_QWORD *)(a2 + 152);
    *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 160);
    *(_QWORD *)(a1 + 160) = v5;
    v6 = (language_modeling::v1::InlineCompletion *)(a1 + 176);
    if (*(unsigned __int8 *)(a1 + 184) == *(unsigned __int8 *)(a2 + 176))
    {
      if (*(_BYTE *)(a1 + 184))
        language_modeling::v1::InlineCompletion::operator=();
    }
    else if (*(_BYTE *)(a1 + 184))
    {
      language_modeling::v1::InlineCompletion::~InlineCompletion(v6);
      *(_BYTE *)(a1 + 184) = 0;
    }
    else
    {
      MEMORY[0x1DF0A1C10](v6, a2 + 168);
      *(_BYTE *)(a1 + 184) = 1;
    }
  }
  else
  {
    std::pair<KB::LanguageModelContext,TIInlineCompletion>::pair[abi:nn180100](v4, a2);
    *(_BYTE *)(a1 + 192) = 1;
  }
}

BOOL TIInlineCompletionsCache::empty(TIInlineCompletionsCache *this)
{
  return *((_BYTE *)this + 192) == 0;
}

void TI::Favonius::SearchNodeInsertingKey::~SearchNodeInsertingKey(TI::Favonius::SearchNodeInsertingKey *this)
{
  TI::Favonius::SearchNodeInsertingKey::~SearchNodeInsertingKey(this);
  JUMPOUT(0x1DF0A2144);
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *(_QWORD *)this = &off_1EA102D58;
  v2 = (unsigned int *)*((_QWORD *)this + 29);
  if (v2)
  {
    v3 = v2 + 2;
    v4 = atomic_load(v2 + 2);
    if (v4 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
    else
    {
      do
        v5 = __ldaxr(v3);
      while (__stlxr(v5 - 1, v3));
    }
  }
  v6 = (unsigned int *)*((_QWORD *)this + 28);
  if (v6)
  {
    v7 = v6 + 2;
    v8 = atomic_load(v6 + 2);
    if (v8 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 248))(v6);
    }
    else
    {
      do
        v9 = __ldaxr(v7);
      while (__stlxr(v9 - 1, v7));
    }
  }
  TI::Favonius::SearchNode::~SearchNode(this);
}

unsigned int *TI::Favonius::SearchNodeInsertingKey::clone_substituting_touch@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X8>)
{
  unsigned int *result;
  uint64_t v7;
  unsigned int v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int *v27;
  uint64_t v28;
  unsigned int *v29;

  result = (unsigned int *)(*(uint64_t (**)(unsigned int *, _QWORD))(*(_QWORD *)*a2 + 72))(*a2, *(__int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 62));
  if (result)
  {
    v7 = (uint64_t)result;
    do
      v8 = __ldaxr(result);
    while (__stlxr(v8 + 1, result));
    v9 = *(float *)(a1 + 152);
    v10 = (*(float (**)(_QWORD))(**(_QWORD **)(a1 + 224) + 24))(*(_QWORD *)(a1 + 224));
    v11 = v9 * logf(v10);
    v12 = operator new();
    v13 = v12;
    v14 = *(_QWORD *)(a1 + 32);
    v15 = *a2;
    *a2 = 0;
    v28 = v7;
    v29 = v15;
    v16 = *(_QWORD *)(a1 + 224);
    v17 = *(_QWORD *)(a1 + 232);
    v18 = *(unsigned int **)(a1 + 56);
    v27 = v18;
    if (v18)
    {
      v19 = v18 + 2;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 + 1, v19));
    }
    TI::Favonius::SearchNodeInsertingKey::SearchNodeInsertingKey(v12, v14, &v29, v16, v17, &v28, &v27, (_QWORD *)(a1 + 64), *(float *)(a1 + 152), v11);
    if (v27)
    {
      v21 = v27 + 2;
      v22 = atomic_load(v27 + 2);
      if (v22 == 1)
      {
        (*(void (**)(void))(*(_QWORD *)v27 + 248))();
      }
      else
      {
        do
          v23 = __ldaxr(v21);
        while (__stlxr(v23 - 1, v21));
      }
    }
    if (v28)
      WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v28);
    result = v29;
    if (v29)
    {
      v24 = v29 + 2;
      v25 = atomic_load(v29 + 2);
      if (v25 == 1)
      {
        result = (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v29 + 8))();
      }
      else
      {
        do
          v26 = __ldaxr(v24);
        while (__stlxr(v26 - 1, v24));
      }
    }
  }
  else
  {
    v13 = 0;
  }
  *a3 = v13;
  return result;
}

float TI::Favonius::SearchNodeInsertingKey::decrease_bound_on_score(TI::Favonius::SearchNodeInsertingKey *this)
{
  float result;

  TI::Favonius::SearchNode::decrease_bound_on_score(this);
  result = (float)(*((float *)this + 6) + *((float *)this + 60)) + *((float *)this + 61);
  *((float *)this + 6) = result;
  return result;
}

uint64_t TI::Favonius::SearchNodeInsertingKey::key_count(TI::Favonius::SearchNodeInsertingKey *this)
{
  return 2;
}

unsigned int *TI::Favonius::SearchNodeInsertingKey::clone_with_parent@<X0>(TI::Favonius::SearchNodeInsertingKey *this@<X0>, unsigned int **a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned int *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int *v16;
  _BYTE *v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  float v25;
  float v26;
  float v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int *result;
  unsigned int *v32;
  unsigned int v33;
  uint64_t (*i)(void);
  unsigned int v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int *v45;
  unsigned int *v46;
  unsigned int *v47;
  unsigned int *v48;
  unsigned int *v49;

  if (!a2[4]
    && (*(_WORD *)(*(_QWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 28) + 16))(*((_QWORD *)this + 28))
                 + 60) & 0x20) != 0)
  {
    return TI::Favonius::SearchNode::clone_with_parent(this, (TI::Favonius::SearchNode *)a2, a3);
  }
  (*(void (**)(unsigned int **__return_ptr, _QWORD, unsigned int *))(**((_QWORD **)this + 28) + 208))(&v49, *((_QWORD *)this + 28), a2[7]);
  v6 = v49;
  v7 = a2[16];
  if (v7)
  {
    v8 = v7 + 2;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
  }
  v10 = *(unsigned int **)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v6 + 16))(v6);
  v48 = v10;
  if (v10)
  {
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 + 1, v10));
  }
  (*(void (**)(unsigned int **__return_ptr, unsigned int *, unsigned int **, _QWORD))(*(_QWORD *)v7 + 72))(&v49, v7, &v48, *((_QWORD *)this + 2));
  v12 = v49;
  v49 = 0;
  if (v48)
    WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v48);
  v13 = v7 + 2;
  v14 = atomic_load(v7 + 2);
  if (v14 == 1)
  {
    (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
  }
  else
  {
    do
      v15 = __ldaxr(v13);
    while (__stlxr(v15 - 1, v13));
  }
  (*(void (**)(unsigned int **__return_ptr, _QWORD, unsigned int *))(**((_QWORD **)this + 7) + 208))(&v49, *((_QWORD *)this + 7), v6);
  v16 = v49;
  v17 = (_BYTE *)operator new();
  v18 = (unsigned int *)*((_QWORD *)this + 2);
  v47 = v18;
  if (v18)
  {
    v19 = v18 + 2;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 + 1, v19));
  }
  v21 = (unsigned int *)*((_QWORD *)this + 6);
  v46 = v21;
  if (v21)
  {
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 + 1, v21));
  }
  v45 = v16;
  if (v16)
  {
    v23 = v16 + 2;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 + 1, v23));
  }
  v25 = *((float *)this + 38);
  v26 = (*(float (**)(unsigned int *))(*(_QWORD *)v6 + 24))(v6);
  v27 = logf(v26);
  TI::Favonius::SearchNodeInsertingKey::SearchNodeInsertingKey((uint64_t)v17, (uint64_t)a2, &v47, (uint64_t)v6, (uint64_t)v12, (uint64_t *)&v46, &v45, 0, v25, v25 * v27);
  if (v45)
  {
    v28 = v45 + 2;
    v29 = atomic_load(v45 + 2);
    if (v29 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v45 + 248))();
    }
    else
    {
      do
        v30 = __ldaxr(v28);
      while (__stlxr(v30 - 1, v28));
    }
  }
  if (v46)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v46);
  result = v47;
  if (!v47)
    goto LABEL_35;
  v32 = v47 + 2;
  v33 = atomic_load(v47 + 2);
  if (v33 != 1)
  {
    do
      v35 = __ldaxr(v32);
    while (__stlxr(v35 - 1, v32));
    goto LABEL_35;
  }
  for (i = *(uint64_t (**)(void))(*(_QWORD *)v47 + 8); ; i = *(uint64_t (**)(void))(*(_QWORD *)v17 + 48))
  {
    result = (unsigned int *)i();
LABEL_35:
    if (v17[148])
      break;
  }
  *a3 = v17;
  if (v16)
  {
    v36 = v16 + 2;
    v37 = atomic_load(v16 + 2);
    if (v37 == 1)
    {
      result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v16 + 248))(v16);
    }
    else
    {
      do
        v38 = __ldaxr(v36);
      while (__stlxr(v38 - 1, v36));
    }
  }
  if (v12)
  {
    v39 = v12 + 2;
    v40 = atomic_load(v12 + 2);
    if (v40 == 1)
    {
      result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v12 + 8))(v12);
    }
    else
    {
      do
        v41 = __ldaxr(v39);
      while (__stlxr(v41 - 1, v39));
    }
  }
  v42 = v6 + 2;
  v43 = atomic_load(v6 + 2);
  if (v43 == 1)
    return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v6 + 248))(v6);
  do
    v44 = __ldaxr(v42);
  while (__stlxr(v44 - 1, v42));
  return result;
}

uint64_t *TI::Favonius::SearchNodeInsertingKey::append_local_keys_for_debugging(TI::Favonius::SearchNodeInsertingKey *this, KB::String *a2)
{
  TI::Favonius::Key **v4;
  uint64_t v5;
  TI::Favonius::Key **v6;

  KB::String::append(a2, 0x7Bu);
  v4 = (TI::Favonius::Key **)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 28) + 16))(*((_QWORD *)this + 28));
  TI::Favonius::Key::append_debug_data(*v4, a2);
  KB::String::append(a2, 0x7Du);
  v5 = *((_QWORD *)this + 6);
  if (v5)
    v6 = (TI::Favonius::Key **)(v5 + 8);
  else
    v6 = (TI::Favonius::Key **)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 7) + 16))(*((_QWORD *)this + 7));
  return TI::Favonius::Key::append_debug_data(*v6, a2);
}

uint64_t TI::Favonius::SearchNodeInsertingKey::compute_language_model_data(uint64_t a1, uint64_t a2)
{
  unsigned int *v2;
  unsigned int v3;
  uint64_t result;
  unsigned int *v5;

  *(_DWORD *)(a1 + 240) = 0;
  v2 = *(unsigned int **)(*(_QWORD *)(a1 + 48) + 8);
  v5 = v2;
  if (v2)
  {
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + 1, v2));
  }
  (*(void (**)(_QWORD, uint64_t, unsigned int **))(**(_QWORD **)(a1 + 224) + 40))(*(_QWORD *)(a1 + 224), a2, &v5);
  result = (uint64_t)v5;
  if (v5)
    return WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v5);
  return result;
}

unsigned int *TI::Favonius::SearchNodeInsertingKey::compute_geometry_model_data(TI::Favonius::SearchNodeInsertingKey *this)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int *result;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int *v13;

  *((_DWORD *)this + 61) = 0;
  v2 = *((_QWORD *)this + 29);
  v3 = (unsigned int *)*((_QWORD *)this + 2);
  v13 = v3;
  if (v3)
  {
    v4 = v3 + 2;
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
  }
  v6 = (unsigned int *)*((_QWORD *)this + 6);
  v12 = v6;
  if (v6)
  {
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
  }
  (*(void (**)(uint64_t, unsigned int **, unsigned int **))(*(_QWORD *)v2 + 48))(v2, &v13, &v12);
  if (v12)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v12);
  result = v13;
  if (v13)
  {
    v9 = v13 + 2;
    v10 = atomic_load(v13 + 2);
    if (v10 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v13 + 8))();
    }
    else
    {
      do
        v11 = __ldaxr(v9);
      while (__stlxr(v11 - 1, v9));
    }
  }
  return result;
}

unsigned int *TI::Favonius::SearchNodeInsertingKey::clone_with_typing@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  unsigned int *v7;
  unsigned int *result;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;

  v6 = operator new();
  v7 = *a2;
  *a2 = 0;
  v12 = v7;
  *a3 = TI::Favonius::SearchNodeInsertingKey::SearchNodeInsertingKey(v6, a1, &v12);
  result = v12;
  if (v12)
  {
    v9 = v12 + 2;
    v10 = atomic_load(v12 + 2);
    if (v10 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v12 + 248))();
    }
    else
    {
      do
        v11 = __ldaxr(v9);
      while (__stlxr(v11 - 1, v9));
    }
  }
  return result;
}

uint64_t TI::Favonius::SearchNodeInsertingKey::instance_error_correction_type(TI::Favonius::SearchNodeInsertingKey *this)
{
  return 4;
}

uint64_t TI::Favonius::SearchNodeInsertingKey::SearchNodeInsertingKey(uint64_t a1, uint64_t a2, unsigned int **a3)
{
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  float v15;
  float v16;
  unsigned int *v18;

  v5 = *a3;
  *a3 = 0;
  v18 = v5;
  TI::Favonius::SearchNode::SearchNode(a1, a2, (uint64_t *)&v18);
  if (v18)
  {
    v6 = v18 + 2;
    v7 = atomic_load(v18 + 2);
    if (v7 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v18 + 248))();
    }
    else
    {
      do
        v8 = __ldaxr(v6);
      while (__stlxr(v8 - 1, v6));
    }
  }
  *(_QWORD *)a1 = &off_1EA102D58;
  v9 = *(_QWORD *)(a2 + 224);
  *(_QWORD *)(a1 + 224) = v9;
  if (v9)
  {
    v10 = (unsigned int *)(v9 + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 + 1, v10));
  }
  v12 = *(_QWORD *)(a2 + 232);
  *(_QWORD *)(a1 + 232) = v12;
  if (v12)
  {
    v13 = (unsigned int *)(v12 + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 + 1, v13));
  }
  v15 = *(float *)(a2 + 240);
  v16 = *(float *)(a2 + 244);
  *(float *)(a1 + 240) = v15;
  *(float *)(a1 + 244) = v16;
  *(float *)(a1 + 24) = v16 + (float)(v15 + *(float *)(a1 + 24));
  return a1;
}

uint64_t TI::Favonius::SearchNodeInsertingKey::SearchNodeInsertingKey(uint64_t a1, uint64_t a2, unsigned int **a3, uint64_t a4, uint64_t a5, uint64_t *a6, unsigned int **a7, _QWORD *a8, float a9, float a10)
{
  unsigned int *v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int *v28;
  uint64_t v29;
  unsigned int *v30;

  v14 = *a3;
  *a3 = 0;
  v15 = *a6;
  *a6 = 0;
  v29 = v15;
  v30 = v14;
  v16 = *a7;
  *a7 = 0;
  v28 = v16;
  TI::Favonius::SearchNode::SearchNode(a1, a2, (uint64_t *)&v30, &v29, (uint64_t *)&v28, a8, a9, NAN);
  if (v28)
  {
    v17 = v28 + 2;
    v18 = atomic_load(v28 + 2);
    if (v18 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v28 + 248))();
    }
    else
    {
      do
        v19 = __ldaxr(v17);
      while (__stlxr(v19 - 1, v17));
    }
  }
  if (v29)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v29);
  if (v30)
  {
    v20 = v30 + 2;
    v21 = atomic_load(v30 + 2);
    if (v21 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v30 + 8))();
    }
    else
    {
      do
        v22 = __ldaxr(v20);
      while (__stlxr(v22 - 1, v20));
    }
  }
  *(_QWORD *)a1 = &off_1EA102D58;
  *(_QWORD *)(a1 + 224) = a4;
  if (a4)
  {
    v23 = (unsigned int *)(a4 + 8);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 + 1, v23));
  }
  *(_QWORD *)(a1 + 232) = a5;
  if (a5)
  {
    v25 = (unsigned int *)(a5 + 8);
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 + 1, v25));
  }
  *(float *)(a1 + 240) = a10;
  *(float *)(a1 + 244) = (*(float (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
  if (*(_QWORD *)(a1 + 32)
    && (*(_WORD *)(*(_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 224) + 16))(*(_QWORD *)(a1 + 224))
                 + 60) & 0x20) != 0)
  {
    ++*(_DWORD *)(a1 + 168);
  }
  *(float *)(a1 + 24) = (float)(*(float *)(a1 + 24) + *(float *)(a1 + 240)) + *(float *)(a1 + 244);
  return a1;
}

unsigned int *TI::Favonius::SearchNodeInsertingKey::create@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X8>, float a7@<S0>, float a8@<S1>)
{
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int *result;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int *v26;
  uint64_t v27;
  unsigned int *v28;

  v16 = operator new();
  v17 = *a2;
  *a2 = 0;
  v18 = *a5;
  *a5 = 0;
  v27 = v18;
  v28 = v17;
  v26 = 0;
  *a6 = TI::Favonius::SearchNodeInsertingKey::SearchNodeInsertingKey(v16, a1, &v28, a3, a4, &v27, &v26, 0, a7, a8);
  if (v26)
  {
    v19 = v26 + 2;
    v20 = atomic_load(v26 + 2);
    if (v20 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v26 + 248))();
    }
    else
    {
      do
        v21 = __ldaxr(v19);
      while (__stlxr(v21 - 1, v19));
    }
  }
  if (v27)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v27);
  result = v28;
  if (v28)
  {
    v23 = v28 + 2;
    v24 = atomic_load(v28 + 2);
    if (v24 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v28 + 8))();
    }
    else
    {
      do
        v25 = __ldaxr(v23);
      while (__stlxr(v25 - 1, v23));
    }
  }
  return result;
}

void TIFitAffineMLLMatrix::TIFitAffineMLLMatrix(TIFitAffineMLLMatrix *this, uint64_t a2)
{
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 2) = (char *)this + 24;
}

{
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 2) = (char *)this + 24;
}

void TIFitAffineMLLMatrix::TIFitAffineMLLMatrix(TIFitAffineMLLMatrix *this, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)this = a3;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 2) = (char *)this + 24;
}

{
  *(_QWORD *)this = a3;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 2) = (char *)this + 24;
}

_QWORD *TIFitAffineMLLMatrix::TIFitAffineMLLMatrix(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t **v6;
  BOOL v7;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  uint64_t v13;
  unint64_t v15;

  a1[3] = 0;
  a1[2] = a1 + 3;
  v6 = (uint64_t **)(a1 + 2);
  *a1 = a3;
  a1[1] = a2;
  a1[4] = 0;
  v15 = 0;
  if (a3 * a2)
    v7 = a5 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v9 = 0;
    v10 = a3 * a2 - 1;
    v11 = 8 * a5 - 8;
    do
    {
      v12 = *(double *)(a4 + 8 * v9);
      if (v12 != 0.0)
        *((double *)std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(v6, v9, (uint64_t *)&v15)+ 5) = v12;
      v15 = v9 + 1;
      if (v10 == v9)
        break;
      v13 = v11;
      v11 -= 8;
      ++v9;
    }
    while (v13);
  }
  return a1;
}

uint64_t *std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t *v9;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)operator new(0x30uLL);
    v9[4] = *a3;
    v9[5] = 0;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v7, v6, v9);
    return v9;
  }
  return (uint64_t *)v7;
}

__n128 TIFitAffineMLLMatrix::TIFitAffineMLLMatrix(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  a1[2].n128_u64[0] = 0;
  a1[1].n128_u64[1] = 0;
  a1[1].n128_u64[0] = (unint64_t)&a1[1].n128_u64[1];
  return result;
}

{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  a1[2].n128_u64[0] = 0;
  a1[1].n128_u64[1] = 0;
  a1[1].n128_u64[0] = (unint64_t)&a1[1].n128_u64[1];
  return result;
}

void TIFitAffineMLLMatrix::TIFitAffineMLLMatrix(TIFitAffineMLLMatrix *this, const TIFitAffineMLLMatrix *a2)
{
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = (char *)this + 24;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 2, *((_QWORD **)a2 + 2), (_QWORD *)a2 + 3);
}

{
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = (char *)this + 24;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 2, *((_QWORD **)a2 + 2), (_QWORD *)a2 + 3);
}

uint64_t *std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t *v5;
  uint64_t *v6;
  unint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  BOOL v12;
  unint64_t v13;
  uint64_t **v14;
  uint64_t **v15;
  uint64_t *v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = result;
    v6 = result + 1;
    do
    {
      v7 = v4 + 4;
      v8 = (uint64_t *)v5[1];
      v9 = v6;
      if ((uint64_t *)*v5 == v6)
        goto LABEL_9;
      v10 = (uint64_t *)v5[1];
      v11 = v6;
      if (v8)
      {
        do
        {
          v9 = v10;
          v10 = (uint64_t *)v10[1];
        }
        while (v10);
      }
      else
      {
        do
        {
          v9 = (uint64_t *)v11[2];
          v12 = *v9 == (_QWORD)v11;
          v11 = v9;
        }
        while (v12);
      }
      v13 = *v7;
      if (v9[4] < *v7)
      {
LABEL_9:
        if (v8)
          v14 = (uint64_t **)v9;
        else
          v14 = (uint64_t **)v6;
        if (v8)
          v15 = (uint64_t **)(v9 + 1);
        else
          v15 = (uint64_t **)v6;
      }
      else
      {
        v14 = (uint64_t **)v6;
        v15 = (uint64_t **)v6;
        if (v8)
        {
          v15 = (uint64_t **)v6;
          while (1)
          {
            while (1)
            {
              v14 = (uint64_t **)v8;
              v19 = v8[4];
              if (v13 >= v19)
                break;
              v8 = *v14;
              v15 = v14;
              if (!*v14)
                goto LABEL_16;
            }
            if (v19 >= v13)
              break;
            v15 = v14 + 1;
            v8 = v14[1];
            if (!v8)
              goto LABEL_16;
          }
        }
      }
      if (!*v15)
      {
LABEL_16:
        v16 = (uint64_t *)operator new(0x30uLL);
        *((_OWORD *)v16 + 2) = *(_OWORD *)v7;
        result = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at((uint64_t **)v5, (uint64_t)v14, v15, v16);
      }
      v17 = (_QWORD *)v4[1];
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = (_QWORD *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          v18 = (_QWORD *)v4[2];
          v12 = *v18 == (_QWORD)v4;
          v4 = v18;
        }
        while (!v12);
      }
      v4 = v18;
    }
    while (v18 != a3);
  }
  return result;
}

uint64_t *TIFitAffineMLLMatrix::operator=@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t **v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t **v16;
  uint64_t **v17;
  _QWORD *v18;
  BOOL v19;
  uint64_t *v20;
  uint64_t *i;
  uint64_t **v22;
  _OWORD *v23;
  uint64_t *v24;
  uint64_t **v25;
  uint64_t **v26;
  _QWORD *v27;
  _QWORD *v28;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  if (a1 == a2)
    goto LABEL_47;
  v5 = *(_QWORD **)(a2 + 16);
  v6 = (_QWORD *)(a2 + 24);
  if (*(_QWORD *)(a1 + 32))
  {
    v8 = (uint64_t **)(a1 + 24);
    v7 = *(_QWORD *)(a1 + 24);
    v9 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = a1 + 24;
    *(_QWORD *)(v7 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    if (*(_QWORD *)(v9 + 8))
      v10 = *(uint64_t **)(v9 + 8);
    else
      v10 = (uint64_t *)v9;
    if (v10)
    {
      v11 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::_DetachedTreeCache::__detach_next((uint64_t)v10);
      if (v5 == v6)
      {
        v13 = v10;
      }
      else
      {
        v12 = v5;
        do
        {
          v13 = v11;
          v14 = v12[4];
          v10[4] = v14;
          v10[5] = v12[5];
          v15 = *v8;
          v16 = (uint64_t **)(a1 + 24);
          v17 = (uint64_t **)(a1 + 24);
          if (*v8)
          {
            do
            {
              while (1)
              {
                v16 = (uint64_t **)v15;
                if (v14 >= v15[4])
                  break;
                v15 = (uint64_t *)*v15;
                v17 = v16;
                if (!*v16)
                  goto LABEL_15;
              }
              v15 = (uint64_t *)v15[1];
            }
            while (v15);
            v17 = v16 + 1;
          }
LABEL_15:
          std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at((uint64_t **)(a1 + 16), (uint64_t)v16, v17, v10);
          if (v11)
            v11 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::_DetachedTreeCache::__detach_next((uint64_t)v11);
          else
            v11 = 0;
          v18 = (_QWORD *)v12[1];
          if (v18)
          {
            do
            {
              v5 = v18;
              v18 = (_QWORD *)*v18;
            }
            while (v18);
          }
          else
          {
            do
            {
              v5 = (_QWORD *)v12[2];
              v19 = *v5 == (_QWORD)v12;
              v12 = v5;
            }
            while (!v19);
          }
          if (!v13)
            break;
          v12 = v5;
          v10 = v13;
        }
        while (v5 != v6);
      }
      std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v13);
      if (!v11)
        goto LABEL_33;
      for (i = (uint64_t *)v11[2]; i; i = (uint64_t *)i[2])
        v11 = i;
      v20 = v11;
    }
    else
    {
      v20 = 0;
    }
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v20);
  }
LABEL_33:
  if (v5 != v6)
  {
    v22 = (uint64_t **)(a1 + 24);
    do
    {
      v23 = operator new(0x30uLL);
      v23[2] = *((_OWORD *)v5 + 2);
      v24 = *v22;
      v25 = (uint64_t **)(a1 + 24);
      v26 = (uint64_t **)(a1 + 24);
      if (*v22)
      {
        do
        {
          while (1)
          {
            v25 = (uint64_t **)v24;
            if (*((_QWORD *)v23 + 4) >= (unint64_t)v24[4])
              break;
            v24 = (uint64_t *)*v24;
            v26 = v25;
            if (!*v25)
              goto LABEL_41;
          }
          v24 = (uint64_t *)v24[1];
        }
        while (v24);
        v26 = v25 + 1;
      }
LABEL_41:
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at((uint64_t **)(a1 + 16), (uint64_t)v25, v26, (uint64_t *)v23);
      v27 = (_QWORD *)v5[1];
      if (v27)
      {
        do
        {
          v28 = v27;
          v27 = (_QWORD *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          v28 = (_QWORD *)v5[2];
          v19 = *v28 == (_QWORD)v5;
          v5 = v28;
        }
        while (!v19);
      }
      v5 = v28;
    }
    while (v28 != v6);
  }
LABEL_47:
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = a3 + 24;
  return std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)(a3 + 16), *(_QWORD **)(a1 + 16), (_QWORD *)(a1 + 24));
}

char *TIFitAffineMLLMatrix::identity@<X0>(char *this@<X0>, char **a2@<X8>)
{
  char *v3;
  unint64_t i;

  *a2 = this;
  a2[1] = this;
  a2[4] = 0;
  a2[3] = 0;
  a2[2] = (char *)(a2 + 3);
  if (this)
  {
    v3 = this;
    for (i = 0; (char *)i != v3; ++i)
    {
      this = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)a2, i, i);
      *(_QWORD *)this = 0x3FF0000000000000;
    }
  }
  return this;
}

char *TIFitAffineMLLMatrix::valueAt(TIFitAffineMLLMatrix *this, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  _QWORD *v4;
  char *v5;
  char *v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  _QWORD *v13;
  unint64_t v15;

  if (*(_QWORD *)this <= a3)
  {
    v3 = -1;
  }
  else if (*((_QWORD *)this + 1) > a2)
  {
    v3 = a3 + *(_QWORD *)this * a2;
  }
  else
  {
    v3 = -1;
  }
  v15 = v3;
  v5 = (char *)this + 24;
  v4 = (_QWORD *)*((_QWORD *)this + 3);
  if (!v4)
    goto LABEL_17;
  v6 = (char *)this + 24;
  do
  {
    v7 = v4[4];
    v8 = v7 >= v3;
    if (v7 >= v3)
      v9 = v4;
    else
      v9 = v4 + 1;
    if (v8)
      v6 = (char *)v4;
    v4 = (_QWORD *)*v9;
  }
  while (*v9);
  if (v6 == v5 || v3 < *((_QWORD *)v6 + 4))
  {
LABEL_17:
    std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)this + 2, v3, (uint64_t *)&v15)[5] = 0;
    v10 = *(_QWORD **)v5;
    if (!*(_QWORD *)v5)
      goto LABEL_28;
    v6 = v5;
    do
    {
      v11 = v10[4];
      v12 = v11 >= v3;
      if (v11 >= v3)
        v13 = v10;
      else
        v13 = v10 + 1;
      if (v12)
        v6 = (char *)v10;
      v10 = (_QWORD *)*v13;
    }
    while (*v13);
    if (v6 == v5 || v3 < *((_QWORD *)v6 + 4))
LABEL_28:
      v6 = v5;
  }
  return v6 + 40;
}

char *TIFitAffineMLLMatrix::diag@<X0>(char *this@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v4;
  TIFitAffineMLLMatrix *v5;
  unint64_t v6;
  double v7;

  v4 = *(_QWORD *)this;
  *a2 = *(_QWORD *)this;
  a2[1] = v4;
  a2[4] = 0;
  a2[3] = 0;
  a2[2] = (unint64_t)(a2 + 3);
  if (v4)
  {
    v5 = (TIFitAffineMLLMatrix *)this;
    v6 = 0;
    do
    {
      v7 = TIFitAffineMLLMatrix::valueAt(v5, 0, v6);
      this = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)a2, v6, v6);
      *(double *)this = v7;
      ++v6;
    }
    while (v6 < *a2);
  }
  return this;
}

double TIFitAffineMLLMatrix::valueAt(TIFitAffineMLLMatrix *this, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  char *v4;
  _QWORD *v5;
  _QWORD *v6;
  double result;
  double *v8;
  unint64_t v9;
  BOOL v10;
  _QWORD *v11;

  if (*(_QWORD *)this <= a3)
  {
    v3 = -1;
  }
  else
  {
    v3 = a3 + *(_QWORD *)this * a2;
    if (*((_QWORD *)this + 1) <= a2)
      v3 = -1;
  }
  v6 = (_QWORD *)*((_QWORD *)this + 3);
  v4 = (char *)this + 24;
  v5 = v6;
  result = 0.0;
  if (v6)
  {
    v8 = (double *)v4;
    do
    {
      v9 = v5[4];
      v10 = v9 >= v3;
      if (v9 >= v3)
        v11 = v5;
      else
        v11 = v5 + 1;
      if (v10)
        v8 = (double *)v5;
      v5 = (_QWORD *)*v11;
    }
    while (*v11);
    if (v8 != (double *)v4 && v3 >= *((_QWORD *)v8 + 4))
      return v8[5];
  }
  return result;
}

char *TIFitAffineMLLMatrix::diag@<X0>(char *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  unint64_t v6;
  uint64_t v7;
  char *v8;
  double v9;
  uint64_t v10;

  *a4 = result;
  a4[1] = result;
  a4[4] = 0;
  a4[3] = 0;
  a4[2] = (char *)(a4 + 3);
  if (result && a3)
  {
    v6 = 0;
    v7 = 8 * a3 - 8;
    v8 = result - 1;
    do
    {
      v9 = *(double *)(a2 + 8 * v6);
      if (v9 != 0.0)
      {
        result = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)a4, v6, v6);
        *(double *)result = v9;
      }
      if (v8 == (char *)v6)
        break;
      ++v6;
      v10 = v7;
      v7 -= 8;
    }
    while (v10);
  }
  return result;
}

char *TIFitAffineMLLMatrix::ones@<X0>(char *this@<X0>, uint64_t a2@<X1>, TIFitAffineMLLMatrix *a3@<X8>)
{
  char *v5;
  unint64_t i;
  unint64_t v7;

  *(_QWORD *)a3 = a2;
  *((_QWORD *)a3 + 1) = this;
  *((_QWORD *)a3 + 4) = 0;
  *((_QWORD *)a3 + 3) = 0;
  *((_QWORD *)a3 + 2) = (char *)a3 + 24;
  if (this)
  {
    v5 = this;
    for (i = 0; (char *)i != v5; ++i)
    {
      if (a2)
      {
        v7 = 0;
        do
        {
          this = TIFitAffineMLLMatrix::valueAt(a3, i, v7);
          *(_QWORD *)this = 0x3FF0000000000000;
          ++v7;
        }
        while (a2 != v7);
      }
    }
  }
  return this;
}

void TIFitAffineMLLMatrix::clear(TIFitAffineMLLMatrix *this)
{
  _QWORD *v1;

  v1 = (_QWORD *)((char *)this + 24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*((_QWORD **)this + 3));
  *(v1 - 1) = v1;
  *v1 = 0;
  v1[1] = 0;
}

void TIFitAffineMLLMatrix::values(TIFitAffineMLLMatrix *this@<X0>, double **a2@<X8>)
{
  double *v4;
  double *v5;
  unint64_t i;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  double *v10;
  double v11;
  double v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  double *v17;
  uint64_t v18;
  uint64_t v19;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v19 = *((_QWORD *)this + 1);
  if (v19)
  {
    v4 = 0;
    v5 = 0;
    for (i = 0; i != v19; ++i)
    {
      v7 = *(_QWORD *)this;
      if (*(_QWORD *)this)
      {
        v8 = 0;
        v9 = (unint64_t)a2[2];
        v10 = *a2;
        do
        {
          v11 = TIFitAffineMLLMatrix::valueAt(this, i, v8);
          v12 = v11;
          if ((unint64_t)v5 >= v9)
          {
            v13 = v5 - v10;
            v14 = v13 + 1;
            if ((unint64_t)(v13 + 1) >> 61)
              abort();
            if ((uint64_t)(v9 - (_QWORD)v10) >> 2 > v14)
              v14 = (uint64_t)(v9 - (_QWORD)v10) >> 2;
            if (v9 - (unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
              v15 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v15 = v14;
            if (v15)
            {
              v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v15);
              v5 = v4;
            }
            else
            {
              v16 = 0;
            }
            v17 = (double *)(v15 + 8 * v13);
            *v17 = v12;
            v4 = v17 + 1;
            while (v5 != v10)
            {
              v18 = *((_QWORD *)v5-- - 1);
              *((_QWORD *)v17-- - 1) = v18;
            }
            v9 = v15 + 8 * v16;
            *a2 = v17;
            a2[1] = v4;
            a2[2] = (double *)v9;
            if (v10)
              operator delete(v10);
            v10 = v17;
          }
          else
          {
            *v5 = v11;
            v4 = v5 + 1;
          }
          a2[1] = v4;
          ++v8;
          v5 = v4;
        }
        while (v8 != v7);
      }
    }
  }
}

void TIFitAffineMLLMatrix::setValues(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t **v7;
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  uint64_t v14;
  unint64_t v15;

  v6 = (_QWORD *)(a1 + 24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)(a1 + 24));
  *(_QWORD *)(a1 + 16) = v6;
  v7 = (uint64_t **)(a1 + 16);
  *(_QWORD *)(a1 + 32) = 0;
  *v6 = 0;
  v15 = 0;
  v8 = *(_QWORD *)a1 * *(_QWORD *)(a1 + 8);
  if (v8)
    v9 = a3 == 0;
  else
    v9 = 1;
  if (!v9)
  {
    v10 = 0;
    v11 = v8 - 1;
    v12 = 8 * a3 - 8;
    do
    {
      v13 = *(double *)(a2 + 8 * v10);
      if (v13 != 0.0)
        *((double *)std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(v7, v10, (uint64_t *)&v15)+ 5) = v13;
      v15 = v10 + 1;
      if (v11 == v10)
        break;
      v14 = v12;
      v12 -= 8;
      ++v10;
    }
    while (v14);
  }
}

void TIFitAffineMLLMatrix::setDiagValues(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;

  v6 = (_QWORD *)(a1 + 24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)(a1 + 24));
  *(_QWORD *)(a1 + 16) = v6;
  *v6 = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
    v8 = a3 == 0;
  else
    v8 = 1;
  if (!v8)
  {
    v9 = 0;
    v10 = v7 - 1;
    v11 = 8 * a3 - 8;
    do
    {
      v12 = *(double *)(a2 + 8 * v9);
      if (v12 != 0.0)
      {
        if (*(_QWORD *)a1 <= v9)
        {
          v13 = -1;
        }
        else if (*(_QWORD *)(a1 + 8) > v9)
        {
          v13 = v9 + v9 * *(_QWORD *)a1;
        }
        else
        {
          v13 = -1;
        }
        v15 = v13;
        *((double *)std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(a1 + 16), v13, (uint64_t *)&v15)+ 5) = v12;
      }
      if (v10 == v9)
        break;
      ++v9;
      v14 = v11;
      v11 -= 8;
    }
    while (v14);
  }
}

unint64_t TIFitAffineMLLMatrix::keyFromIndexes(TIFitAffineMLLMatrix *this, unint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)this <= a3 || *((_QWORD *)this + 1) <= a2)
    return -1;
  else
    return a3 + *(_QWORD *)this * a2;
}

void TIFitAffineMLLMatrix::setDiagValues(uint64_t a1, uint64_t *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  unint64_t v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v4 = (_QWORD *)(a1 + 24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)(a1 + 24));
  *(_QWORD *)(a1 + 16) = v4;
  *v4 = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *a2;
  v7 = a2[1];
  if (v5)
    v8 = v6 == v7;
  else
    v8 = 1;
  if (!v8)
  {
    v9 = v6 + 8;
    v10 = 1;
    do
    {
      v11 = *(double *)(v9 - 8);
      if (v11 != 0.0)
      {
        v12 = v10 - 1;
        if (*(_QWORD *)a1 <= (unint64_t)(v10 - 1))
        {
          v15 = -1;
        }
        else
        {
          v13 = *(_QWORD *)(a1 + 8) > v12;
          v14 = v12 + v12 * *(_QWORD *)a1;
          if (v13)
            v15 = v14;
          else
            v15 = -1;
        }
        v16 = v15;
        *((double *)std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(a1 + 16), v15, (uint64_t *)&v16)+ 5) = v11;
      }
      if (v5 == v10)
        break;
      ++v10;
      v8 = v9 == v7;
      v9 += 8;
    }
    while (!v8);
  }
}

double *TIFitAffineMLLMatrix::addRow@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v8;
  double *result;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  double v13;
  uint64_t v14;

  *(_OWORD *)a4 = *(_OWORD *)a1;
  a4[4] = 0;
  a4[3] = 0;
  a4[2] = (uint64_t)(a4 + 3);
  v8 = a1[1];
  result = (double *)std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>(a4 + 2, (_QWORD *)a1[2], a1 + 3);
  ++a4[1];
  v10 = *a1;
  if (*a1 && a3)
  {
    v11 = 0;
    v12 = 8 * a3 - 8;
    do
    {
      v13 = *(double *)(a2 + 8 * v11);
      if (v13 != 0.0)
      {
        result = (double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)a4, v8, v11);
        *result = v13;
        v10 = *a1;
      }
      if (++v11 == v10)
        break;
      v14 = v12;
      v12 -= 8;
    }
    while (v14);
  }
  return result;
}

_QWORD *TIFitAffineMLLMatrix::addRow@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v5;
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[3];
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD **)(a1 + 16);
  v8 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = a3 + 24;
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_QWORD *)(a3 + 32) = 0;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)(a3 + 16), v5, (_QWORD *)(a1 + 24));
  ++*(_QWORD *)(a3 + 8);
  v9[0] = &unk_1EA102E10;
  v9[1] = a3;
  v9[2] = &v8;
  v10 = v9;
  TIFitAffineMLLMatrix::do_for_each_valid_element(a2, (uint64_t)v9);
  result = v10;
  if (v10 == v9)
  {
    v7 = 4;
    result = v9;
  }
  else
  {
    if (!v10)
      return result;
    v7 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8 * v7))(result);
}

uint64_t TIFitAffineMLLMatrix::do_for_each_valid_element(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t result;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  char v12[24];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v3 = v10;
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v10, a2);
  v4 = operator new(0x30uLL);
  v5 = v4;
  v6 = v11;
  *v4 = &off_1EA102F78;
  v4[1] = a1;
  if (v6)
  {
    if (v6 == v10)
    {
      v4[5] = v4 + 2;
      (*(void (**)(_QWORD *))(v10[0] + 24))(v10);
    }
    else
    {
      v4[5] = v6;
      v11 = 0;
    }
  }
  else
  {
    v4[5] = 0;
  }
  v13 = v5;
  TIFitAffineMLLMatrix::do_for_each_valid_element(a1, (uint64_t)v12);
  result = (*(uint64_t (**)(_QWORD *))(*v5 + 40))(v5);
  if (v11 == v10)
  {
    v8 = 4;
  }
  else
  {
    if (!v11)
      return result;
    v8 = 5;
    v3 = v11;
  }
  return (*(uint64_t (**)(_QWORD *))(*v3 + 8 * v8))(v3);
}

_QWORD *TIFitAffineMLLMatrix::do_for_each_valid_element(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t v10;

  v2 = (_QWORD *)result[2];
  v3 = result + 3;
  if (v2 != result + 3)
  {
    while (1)
    {
      v10 = v2[4];
      v5 = *(_QWORD *)(a2 + 24);
      if (!v5)
        break;
      result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t *, _QWORD *))(*(_QWORD *)v5 + 48))(v5, &v10, v2 + 5);
      v6 = (_QWORD *)v2[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v2[2];
          v8 = *v7 == (_QWORD)v2;
          v2 = v7;
        }
        while (!v8);
      }
      v2 = v7;
      if (v7 == v3)
        return result;
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return std::__function::__func<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0,std::allocator<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0>,void ()(unsigned long,double const&)>::~__func(v9);
  }
  return result;
}

_QWORD *std::__function::__func<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0,std::allocator<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0>,void ()(unsigned long,double const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1EA102F78;
  v2 = a1 + 2;
  v3 = (_QWORD *)a1[5];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0,std::allocator<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0>,void ()(unsigned long,double const&)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1EA102F78;
  v1 = a1 + 2;
  v2 = (_QWORD *)a1[5];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0,std::allocator<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0>,void ()(unsigned long,double const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0x30uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_1EA102F78;
  v2[1] = v3;
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

uint64_t std::__function::__func<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0,std::allocator<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0>,void ()(unsigned long,double const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_1EA102F78;
  a2[1] = v2;
  return std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)(a2 + 2), a1 + 16);
}

_QWORD *std::__function::__func<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0,std::allocator<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0>,void ()(unsigned long,double const&)>::destroy(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 16);
  result = *(_QWORD **)(a1 + 40);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void std::__function::__func<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0,std::allocator<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0>,void ()(unsigned long,double const&)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 16;
  v3 = (char *)*((_QWORD *)__p + 5);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

uint64_t std::__function::__func<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0,std::allocator<TIFitAffineMLLMatrix::do_for_each_valid_element(std::function<void ()(unsigned long,unsigned long,double const&)>)::$_0>,void ()(unsigned long,double const&)>::operator()(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v7;
  unint64_t v8;

  v3 = **(_QWORD **)(a1 + 8);
  v4 = *a2 / v3;
  v7 = *a2 % v3;
  v8 = v4;
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x1DA87C6ECLL);
  }
  return (*(uint64_t (**)(uint64_t, unint64_t *, unint64_t *, uint64_t))(*(_QWORD *)v5 + 48))(v5, &v8, &v7, a3);
}

void std::__function::__func<TIFitAffineMLLMatrix::addRow(TIFitAffineMLLMatrix)::$_0,std::allocator<TIFitAffineMLLMatrix::addRow(TIFitAffineMLLMatrix)::$_0>,void ()(unsigned long,unsigned long,double const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::addRow(TIFitAffineMLLMatrix)::$_0,std::allocator<TIFitAffineMLLMatrix::addRow(TIFitAffineMLLMatrix)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &unk_1EA102E10;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::addRow(TIFitAffineMLLMatrix)::$_0,std::allocator<TIFitAffineMLLMatrix::addRow(TIFitAffineMLLMatrix)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &unk_1EA102E10;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

char *std::__function::__func<TIFitAffineMLLMatrix::addRow(TIFitAffineMLLMatrix)::$_0,std::allocator<TIFitAffineMLLMatrix::addRow(TIFitAffineMLLMatrix)::$_0>,void ()(unsigned long,unsigned long,double const&)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t v4;
  char *result;

  v4 = *a4;
  result = TIFitAffineMLLMatrix::valueAt(*(TIFitAffineMLLMatrix **)(a1 + 8), **(_QWORD **)(a1 + 16), *a3);
  *(_QWORD *)result = v4;
  return result;
}

_QWORD *TIFitAffineMLLMatrix::deleteRow@<X0>(TIFitAffineMLLMatrix *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = *((_QWORD *)this + 1) - 1;
  *a3 = *(_QWORD *)this;
  a3[1] = v3;
  a3[4] = 0;
  a3[3] = 0;
  a3[2] = a3 + 3;
  v6 = a2;
  v7[0] = &off_1EA102E58;
  v7[1] = &v6;
  v7[2] = a3;
  v8 = v7;
  TIFitAffineMLLMatrix::do_for_each_valid_element(this, (uint64_t)v7);
  result = v8;
  if (v8 == v7)
  {
    v5 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      return result;
    v5 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void std::__function::__func<TIFitAffineMLLMatrix::deleteRow(unsigned long)::$_0,std::allocator<TIFitAffineMLLMatrix::deleteRow(unsigned long)::$_0>,void ()(unsigned long,unsigned long,double const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::deleteRow(unsigned long)::$_0,std::allocator<TIFitAffineMLLMatrix::deleteRow(unsigned long)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA102E58;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::deleteRow(unsigned long)::$_0,std::allocator<TIFitAffineMLLMatrix::deleteRow(unsigned long)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA102E58;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

char *std::__function::__func<TIFitAffineMLLMatrix::deleteRow(unsigned long)::$_0,std::allocator<TIFitAffineMLLMatrix::deleteRow(unsigned long)::$_0>,void ()(unsigned long,unsigned long,double const&)>::operator()(char *result, unint64_t *a2, unint64_t *a3, uint64_t *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  TIFitAffineMLLMatrix *v8;

  v4 = *a2;
  v5 = *a3;
  v6 = **((_QWORD **)result + 1);
  if (v6 <= v4)
  {
    if (v6 >= v4)
      return result;
    v7 = *a4;
    v8 = (TIFitAffineMLLMatrix *)*((_QWORD *)result + 2);
    --v4;
  }
  else
  {
    v7 = *a4;
    v8 = (TIFitAffineMLLMatrix *)*((_QWORD *)result + 2);
  }
  result = TIFitAffineMLLMatrix::valueAt(v8, v4, v5);
  *(_QWORD *)result = v7;
  return result;
}

BOOL TIFitAffineMLLMatrix::hasValue(TIFitAffineMLLMatrix *this, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  char *v4;
  _QWORD *v5;
  _QWORD *v6;
  char *v7;
  unint64_t v8;
  BOOL v9;
  _QWORD *v10;

  if (*(_QWORD *)this <= a3)
    return 0;
  if (*((_QWORD *)this + 1) <= a2)
    return 0;
  v3 = a3 + *(_QWORD *)this * a2;
  if (v3 == -1)
    return 0;
  v6 = (_QWORD *)*((_QWORD *)this + 3);
  v4 = (char *)this + 24;
  v5 = v6;
  if (!v6)
    goto LABEL_15;
  v7 = v4;
  do
  {
    v8 = v5[4];
    v9 = v8 >= v3;
    if (v8 >= v3)
      v10 = v5;
    else
      v10 = v5 + 1;
    if (v9)
      v7 = (char *)v5;
    v5 = (_QWORD *)*v10;
  }
  while (*v10);
  if (v7 == v4 || v3 < *((_QWORD *)v7 + 4))
LABEL_15:
    v7 = v4;
  return v7 != v4;
}

void TIFitAffineMLLMatrix::operator+(__int128 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  double v12;
  _QWORD *v13;
  _QWORD *v14;
  BOOL v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;

  v4 = *a1;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = a3 + 24;
  *(_OWORD *)a3 = v4;
  *(_QWORD *)(a3 + 32) = 0;
  v5 = (_QWORD *)*((_QWORD *)a1 + 2);
  v6 = (_QWORD *)a1 + 3;
  v7 = *(_QWORD **)(a2 + 16);
  v8 = (_QWORD *)(a2 + 24);
  while (v5 != v6)
  {
    v10 = v5 + 4;
    v9 = v5[4];
    if (v7 == v8)
    {
LABEL_18:
      v18 = v5[5];
      std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(a3 + 16), v9, v10)[5] = v18;
      v19 = (_QWORD *)v5[1];
      if (v19)
      {
        do
        {
          v5 = v19;
          v19 = (_QWORD *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = v5;
          v5 = (_QWORD *)v5[2];
        }
        while ((_QWORD *)*v5 != v20);
      }
    }
    else
    {
      v11 = v7[4];
      if (v9 == v11)
      {
        v12 = *((double *)v5 + 5) + *((double *)v7 + 5);
        *((double *)std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(a3 + 16), v9, v10)+ 5) = v12;
        v13 = (_QWORD *)v5[1];
        if (v13)
        {
          do
          {
            v14 = v13;
            v13 = (_QWORD *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            v14 = (_QWORD *)v5[2];
            v15 = *v14 == (_QWORD)v5;
            v5 = v14;
          }
          while (!v15);
        }
        v16 = (_QWORD *)v7[1];
        if (v16)
        {
          do
          {
            v7 = v16;
            v16 = (_QWORD *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            v17 = v7;
            v7 = (_QWORD *)v7[2];
          }
          while ((_QWORD *)*v7 != v17);
        }
        v5 = v14;
      }
      else
      {
        if (v9 < v11)
          goto LABEL_18;
LABEL_23:
        v21 = v7[5];
        std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(a3 + 16), v11, v7 + 4)[5] = v21;
        v22 = (_QWORD *)v7[1];
        if (v22)
        {
          do
          {
            v7 = v22;
            v22 = (_QWORD *)*v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            v23 = v7;
            v7 = (_QWORD *)v7[2];
          }
          while ((_QWORD *)*v7 != v23);
        }
      }
    }
  }
  if (v7 != v8)
  {
    v11 = v7[4];
    goto LABEL_23;
  }
  TIFitAffineMLLMatrix::removeDefaults((TIFitAffineMLLMatrix *)a3);
}

void TIFitAffineMLLMatrix::removeDefaults(TIFitAffineMLLMatrix *this)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t *v5;
  uint64_t **v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  BOOL v17;
  unint64_t *v18;
  unint64_t *v19;
  uint64_t v20;
  _QWORD v21[3];
  _QWORD *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21[0] = &off_1EA103098;
  v21[1] = &v18;
  v22 = v21;
  TIFitAffineMLLMatrix::do_for_each_valid_element(this, (uint64_t)v21);
  v2 = v22;
  if (v22 == v21)
  {
    v3 = 4;
    v2 = v21;
  }
  else
  {
    if (!v22)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  v4 = v18;
  v5 = v19;
  if (v18 != v19)
  {
    v6 = (uint64_t **)((char *)this + 24);
    do
    {
      v7 = *v6;
      if (*v6)
      {
        v8 = *v4;
        v9 = (uint64_t *)((char *)this + 24);
        v10 = *v6;
        do
        {
          v11 = v10[4];
          v12 = v11 >= v8;
          if (v11 >= v8)
            v13 = (uint64_t **)v10;
          else
            v13 = (uint64_t **)(v10 + 1);
          if (v12)
            v9 = v10;
          v10 = *v13;
        }
        while (*v13);
        if (v9 != (uint64_t *)v6 && v8 >= v9[4])
        {
          v14 = (uint64_t *)v9[1];
          v15 = v9;
          if (v14)
          {
            do
            {
              v16 = v14;
              v14 = (uint64_t *)*v14;
            }
            while (v14);
          }
          else
          {
            do
            {
              v16 = (uint64_t *)v15[2];
              v17 = *v16 == (_QWORD)v15;
              v15 = v16;
            }
            while (!v17);
          }
          if (*((uint64_t **)this + 2) == v9)
            *((_QWORD *)this + 2) = v16;
          --*((_QWORD *)this + 4);
          std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v7, v9);
          operator delete(v9);
        }
      }
      ++v4;
    }
    while (v4 != v5);
    v4 = v18;
  }
  if (v4)
  {
    v19 = v4;
    operator delete(v4);
  }
}

void std::__function::__func<TIFitAffineMLLMatrix::removeDefaults(void)::$_0,std::allocator<TIFitAffineMLLMatrix::removeDefaults(void)::$_0>,void ()(unsigned long,double const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<TIFitAffineMLLMatrix::removeDefaults(void)::$_0,std::allocator<TIFitAffineMLLMatrix::removeDefaults(void)::$_0>,void ()(unsigned long,double const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA103098;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TIFitAffineMLLMatrix::removeDefaults(void)::$_0,std::allocator<TIFitAffineMLLMatrix::removeDefaults(void)::$_0>,void ()(unsigned long,double const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA103098;
  a2[1] = v2;
  return result;
}

void std::__function::__func<TIFitAffineMLLMatrix::removeDefaults(void)::$_0,std::allocator<TIFitAffineMLLMatrix::removeDefaults(void)::$_0>,void ()(unsigned long,double const&)>::operator()(uint64_t a1, uint64_t *a2, double *a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;

  if (*a3 == 0.0)
  {
    v3 = *a2;
    v4 = *(_QWORD *)(a1 + 8);
    v6 = *(_QWORD **)(v4 + 8);
    v5 = *(_QWORD *)(v4 + 16);
    if ((unint64_t)v6 >= v5)
    {
      v8 = *(_QWORD **)v4;
      v9 = ((uint64_t)v6 - *(_QWORD *)v4) >> 3;
      v10 = v9 + 1;
      if ((unint64_t)(v9 + 1) >> 61)
        abort();
      v11 = v5 - (_QWORD)v8;
      if (v11 >> 2 > v10)
        v10 = v11 >> 2;
      v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8;
      v13 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v12)
        v13 = v10;
      if (v13)
      {
        v13 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v13);
        v8 = *(_QWORD **)v4;
        v6 = *(_QWORD **)(v4 + 8);
      }
      else
      {
        v14 = 0;
      }
      v15 = (_QWORD *)(v13 + 8 * v9);
      v16 = v13 + 8 * v14;
      *v15 = v3;
      v7 = v15 + 1;
      while (v6 != v8)
      {
        v17 = *--v6;
        *--v15 = v17;
      }
      *(_QWORD *)v4 = v15;
      *(_QWORD *)(v4 + 8) = v7;
      *(_QWORD *)(v4 + 16) = v16;
      if (v8)
        operator delete(v8);
    }
    else
    {
      *v6 = v3;
      v7 = v6 + 1;
    }
    *(_QWORD *)(v4 + 8) = v7;
  }
}

void TIFitAffineMLLMatrix::operator+=(TIFitAffineMLLMatrix *this, uint64_t a2)
{
  uint64_t **v3;
  char *v4;
  char *v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  double v11;
  char *v12;
  char *v13;
  BOOL v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;

  v3 = (uint64_t **)((char *)this + 16);
  v4 = (char *)*((_QWORD *)this + 2);
  v5 = (char *)this + 24;
  v6 = *(_QWORD **)(a2 + 16);
  v7 = (_QWORD *)(a2 + 24);
  while (v4 != v5)
  {
    v9 = (uint64_t *)(v4 + 32);
    v8 = *((_QWORD *)v4 + 4);
    if (v6 == v7)
    {
LABEL_18:
      v17 = *((_QWORD *)v4 + 5);
      std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(v3, v8, v9)[5] = v17;
      v18 = (char *)*((_QWORD *)v4 + 1);
      if (v18)
      {
        do
        {
          v4 = v18;
          v18 = *(char **)v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = v4;
          v4 = (char *)*((_QWORD *)v4 + 2);
        }
        while (*(char **)v4 != v19);
      }
    }
    else
    {
      v10 = v6[4];
      if (v8 == v10)
      {
        v11 = *((double *)v4 + 5) + *((double *)v6 + 5);
        *((double *)std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(v3, v8, v9)+ 5) = v11;
        v12 = (char *)*((_QWORD *)v4 + 1);
        if (v12)
        {
          do
          {
            v13 = v12;
            v12 = *(char **)v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            v13 = (char *)*((_QWORD *)v4 + 2);
            v14 = *(_QWORD *)v13 == (_QWORD)v4;
            v4 = v13;
          }
          while (!v14);
        }
        v15 = (_QWORD *)v6[1];
        if (v15)
        {
          do
          {
            v6 = v15;
            v15 = (_QWORD *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            v16 = v6;
            v6 = (_QWORD *)v6[2];
          }
          while ((_QWORD *)*v6 != v16);
        }
        v4 = v13;
      }
      else
      {
        if (v8 < v10)
          goto LABEL_18;
LABEL_23:
        v20 = v6[5];
        std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(v3, v10, v6 + 4)[5] = v20;
        v21 = (_QWORD *)v6[1];
        if (v21)
        {
          do
          {
            v6 = v21;
            v21 = (_QWORD *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            v22 = v6;
            v6 = (_QWORD *)v6[2];
          }
          while ((_QWORD *)*v6 != v22);
        }
      }
    }
  }
  if (v6 != v7)
  {
    v10 = v6[4];
    goto LABEL_23;
  }
  TIFitAffineMLLMatrix::removeDefaults(this);
}

void TIFitAffineMLLMatrix::operator-(__int128 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  double v12;
  _QWORD *v13;
  _QWORD *v14;
  BOOL v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;

  v4 = *a1;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = a3 + 24;
  *(_OWORD *)a3 = v4;
  *(_QWORD *)(a3 + 32) = 0;
  v5 = (_QWORD *)*((_QWORD *)a1 + 2);
  v6 = (_QWORD *)a1 + 3;
  v7 = *(_QWORD **)(a2 + 16);
  v8 = (_QWORD *)(a2 + 24);
  while (v5 != v6)
  {
    v10 = v5 + 4;
    v9 = v5[4];
    if (v7 == v8)
    {
LABEL_18:
      v18 = v5[5];
      std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(a3 + 16), v9, v10)[5] = v18;
      v19 = (_QWORD *)v5[1];
      if (v19)
      {
        do
        {
          v5 = v19;
          v19 = (_QWORD *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = v5;
          v5 = (_QWORD *)v5[2];
        }
        while ((_QWORD *)*v5 != v20);
      }
    }
    else
    {
      v11 = v7[4];
      if (v9 == v11)
      {
        v12 = *((double *)v5 + 5) - *((double *)v7 + 5);
        *((double *)std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(a3 + 16), v9, v10)+ 5) = v12;
        v13 = (_QWORD *)v5[1];
        if (v13)
        {
          do
          {
            v14 = v13;
            v13 = (_QWORD *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            v14 = (_QWORD *)v5[2];
            v15 = *v14 == (_QWORD)v5;
            v5 = v14;
          }
          while (!v15);
        }
        v16 = (_QWORD *)v7[1];
        if (v16)
        {
          do
          {
            v7 = v16;
            v16 = (_QWORD *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            v17 = v7;
            v7 = (_QWORD *)v7[2];
          }
          while ((_QWORD *)*v7 != v17);
        }
        v5 = v14;
      }
      else
      {
        if (v9 < v11)
          goto LABEL_18;
LABEL_23:
        v21 = v7[5];
        std::__tree<std::__value_type<unsigned long,double>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,double>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,double>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(a3 + 16), v11, v7 + 4)[5] = v21;
        v22 = (_QWORD *)v7[1];
        if (v22)
        {
          do
          {
            v7 = v22;
            v22 = (_QWORD *)*v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            v23 = v7;
            v7 = (_QWORD *)v7[2];
          }
          while ((_QWORD *)*v7 != v23);
        }
      }
    }
  }
  if (v7 != v8)
  {
    v11 = v7[4];
    goto LABEL_23;
  }
  TIFitAffineMLLMatrix::removeDefaults((TIFitAffineMLLMatrix *)a3);
}

void TIFitAffineMLLMatrix::operator*=(TIFitAffineMLLMatrix *this, double a2)
{
  TIFitAffineMLLMatrix *v2;
  TIFitAffineMLLMatrix *v3;
  TIFitAffineMLLMatrix *v4;
  BOOL v5;

  v2 = (TIFitAffineMLLMatrix *)*((_QWORD *)this + 2);
  if (v2 != (TIFitAffineMLLMatrix *)((char *)this + 24))
  {
    do
    {
      *((double *)v2 + 5) = *((double *)v2 + 5) * a2;
      v3 = (TIFitAffineMLLMatrix *)*((_QWORD *)v2 + 1);
      if (v3)
      {
        do
        {
          v4 = v3;
          v3 = *(TIFitAffineMLLMatrix **)v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          v4 = (TIFitAffineMLLMatrix *)*((_QWORD *)v2 + 2);
          v5 = *(_QWORD *)v4 == (_QWORD)v2;
          v2 = v4;
        }
        while (!v5);
      }
      v2 = v4;
    }
    while (v4 != (TIFitAffineMLLMatrix *)((char *)this + 24));
  }
  TIFitAffineMLLMatrix::removeDefaults(this);
}

void TIFitAffineMLLMatrix::operator*(_QWORD *a1@<X0>, TIFitAffineMLLMatrix *a2@<X8>, double a3@<D0>)
{
  _QWORD *v4;
  uint64_t v5;
  double v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v6 = a3;
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 2) = (char *)a2 + 24;
  v7[0] = &off_1EA102EA0;
  v7[1] = a2;
  v7[2] = &v6;
  v8 = v7;
  TIFitAffineMLLMatrix::do_for_each_valid_element(a1, (uint64_t)v7);
  v4 = v8;
  if (v8 == v7)
  {
    v5 = 4;
    v4 = v7;
    goto LABEL_5;
  }
  if (v8)
  {
    v5 = 5;
LABEL_5:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  TIFitAffineMLLMatrix::removeDefaults(a2);
}

void std::__function::__func<TIFitAffineMLLMatrix::operator*(double)::$_0,std::allocator<TIFitAffineMLLMatrix::operator*(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::operator*(double)::$_0,std::allocator<TIFitAffineMLLMatrix::operator*(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA102EA0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::operator*(double)::$_0,std::allocator<TIFitAffineMLLMatrix::operator*(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA102EA0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

char *std::__function::__func<TIFitAffineMLLMatrix::operator*(double)::$_0,std::allocator<TIFitAffineMLLMatrix::operator*(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3, double *a4)
{
  double v4;
  char *result;

  v4 = *a4 * **(double **)(a1 + 16);
  result = TIFitAffineMLLMatrix::valueAt(*(TIFitAffineMLLMatrix **)(a1 + 8), *a2, *a3);
  *(double *)result = v4;
  return result;
}

void TIFitAffineMLLMatrix::operator*(TIFitAffineMLLMatrix *this@<X0>, TIFitAffineMLLMatrix *a2@<X1>, TIFitAffineMLLMatrix *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t i;
  uint64_t v9;
  unint64_t j;
  uint64_t v11;
  unint64_t v12;
  double v13;
  double v14;

  v4 = *((_QWORD *)this + 1);
  v5 = *(_QWORD *)a2;
  *(_QWORD *)a3 = *(_QWORD *)a2;
  *((_QWORD *)a3 + 1) = v4;
  *((_QWORD *)a3 + 4) = 0;
  *((_QWORD *)a3 + 3) = 0;
  *((_QWORD *)a3 + 2) = (char *)a3 + 24;
  if (v5)
  {
    for (i = 0; i != v5; ++i)
    {
      v9 = *((_QWORD *)a3 + 1);
      if (v9)
      {
        for (j = 0; j != v9; ++j)
        {
          v11 = *(_QWORD *)this;
          if (*(_QWORD *)this)
          {
            v12 = 0;
            v13 = 0.0;
            do
            {
              v14 = TIFitAffineMLLMatrix::valueAt(this, j, v12);
              v13 = v13 + v14 * TIFitAffineMLLMatrix::valueAt(a2, v12++, i);
            }
            while (v11 != v12);
          }
          else
          {
            v13 = 0.0;
          }
          *(double *)TIFitAffineMLLMatrix::valueAt(a3, j, i) = v13;
        }
      }
    }
  }
  TIFitAffineMLLMatrix::removeDefaults(a3);
}

void TIFitAffineMLLMatrix::operator/(_QWORD *a1@<X0>, TIFitAffineMLLMatrix *a2@<X8>, double a3@<D0>)
{
  _QWORD *v4;
  uint64_t v5;
  double v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v6 = a3;
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 2) = (char *)a2 + 24;
  v7[0] = &off_1EA102EE8;
  v7[1] = a2;
  v7[2] = &v6;
  v8 = v7;
  TIFitAffineMLLMatrix::do_for_each_valid_element(a1, (uint64_t)v7);
  v4 = v8;
  if (v8 == v7)
  {
    v5 = 4;
    v4 = v7;
    goto LABEL_5;
  }
  if (v8)
  {
    v5 = 5;
LABEL_5:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  TIFitAffineMLLMatrix::removeDefaults(a2);
}

void std::__function::__func<TIFitAffineMLLMatrix::operator/(double)::$_0,std::allocator<TIFitAffineMLLMatrix::operator/(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::operator/(double)::$_0,std::allocator<TIFitAffineMLLMatrix::operator/(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA102EE8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::operator/(double)::$_0,std::allocator<TIFitAffineMLLMatrix::operator/(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA102EE8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

char *std::__function::__func<TIFitAffineMLLMatrix::operator/(double)::$_0,std::allocator<TIFitAffineMLLMatrix::operator/(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3, double *a4)
{
  double v4;
  char *result;

  v4 = *a4 / **(double **)(a1 + 16);
  result = TIFitAffineMLLMatrix::valueAt(*(TIFitAffineMLLMatrix **)(a1 + 8), *a2, *a3);
  *(double *)result = v4;
  return result;
}

void TIFitAffineMLLMatrix::operator/(TIFitAffineMLLMatrix *this@<X1>, TIFitAffineMLLMatrix *a2@<X0>, TIFitAffineMLLMatrix *a3@<X8>)
{
  _BYTE v5[24];
  _QWORD *v6;

  TIFitAffineMLLMatrix::inverse(this, (TIFitAffineMLLMatrix *)v5);
  TIFitAffineMLLMatrix::operator*(a2, (TIFitAffineMLLMatrix *)v5, a3);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v6);
}

void TIFitAffineMLLMatrix::inverse(TIFitAffineMLLMatrix *this@<X0>, TIFitAffineMLLMatrix *a2@<X8>)
{
  uint64_t v4;
  double v5;
  double v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  double v11;
  _BYTE v12[24];
  _QWORD *v13;

  v4 = *((_QWORD *)this + 1);
  *(_QWORD *)a2 = v4;
  *((_QWORD *)a2 + 1) = v4;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 2) = (char *)a2 + 24;
  TIFitAffineMLLMatrix::determinant(this);
  v6 = v5;
  TIFitAffineMLLMatrix::coFactor(this, (TIFitAffineMLLMatrix *)v12);
  v7 = *((_QWORD *)this + 1);
  if (v7)
  {
    v8 = 0;
    v9 = *(_QWORD *)this;
    do
    {
      if (v9)
      {
        v10 = 0;
        do
        {
          v11 = *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v12, v8, v10) / v6;
          *(double *)TIFitAffineMLLMatrix::valueAt(a2, v10++, v8) = v11;
          v9 = *(_QWORD *)this;
        }
        while (v10 < *(_QWORD *)this);
        v7 = *((_QWORD *)this + 1);
      }
      ++v8;
    }
    while (v8 < v7);
  }
  TIFitAffineMLLMatrix::removeDefaults(a2);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v13);
}

void TIFitAffineMLLMatrix::determinant(TIFitAffineMLLMatrix *this)
{
  unint64_t v2;
  unint64_t i;
  uint64_t v4;
  unint64_t j;
  unint64_t v6;
  unint64_t v7;
  double v8;
  unint64_t v9;
  double v10;
  TIFitAffineMLLMatrix *v11;
  double v12;
  double v13;
  double v14;
  void **v15[3];
  _QWORD *v16[2];
  void *v17[3];

  v2 = *((_QWORD *)this + 1);
  if (v2 == 3)
  {
    TIFitAffineMLLMatrix::valueAt(this, 0, 0);
    TIFitAffineMLLMatrix::valueAt(this, 0, 1uLL);
    TIFitAffineMLLMatrix::valueAt(this, 0, 2uLL);
    TIFitAffineMLLMatrix::valueAt(this, 1uLL, 0);
    TIFitAffineMLLMatrix::valueAt(this, 1uLL, 1uLL);
    TIFitAffineMLLMatrix::valueAt(this, 1uLL, 2uLL);
    TIFitAffineMLLMatrix::valueAt(this, 2uLL, 0);
    TIFitAffineMLLMatrix::valueAt(this, 2uLL, 1uLL);
    TIFitAffineMLLMatrix::valueAt(this, 2uLL, 2uLL);
  }
  else if (v2 == 2)
  {
    TIFitAffineMLLMatrix::valueAt(this, 0, 0);
    TIFitAffineMLLMatrix::valueAt(this, 1uLL, 1uLL);
    TIFitAffineMLLMatrix::valueAt(this, 0, 1uLL);
    TIFitAffineMLLMatrix::valueAt(this, 1uLL, 0);
  }
  else
  {
    memset(v17, 0, sizeof(v17));
    if (v2)
    {
      for (i = 0; i < v2; ++i)
      {
        v15[0] = (void **)(v2 - 1);
        v15[1] = (void **)(v2 - 1);
        v16[0] = 0;
        v16[1] = 0;
        v15[2] = (void **)v16;
        std::vector<TIFitAffineMLLMatrix>::push_back[abi:nn180100](v17, (uint64_t)v15);
        std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v16[0]);
        v2 = *((_QWORD *)this + 1);
      }
      if (v2)
      {
        v4 = 0;
        while (v2 >= 2)
        {
          for (j = 1; j < v2; ++j)
          {
            v6 = 0;
            v7 = 0;
            do
            {
              if (v4 != v6)
              {
                v8 = TIFitAffineMLLMatrix::valueAt(this, j, v6);
                *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)((char *)v17[0] + 40 * v4), j - 1, v7) = v8;
                v2 = *((_QWORD *)this + 1);
                ++v7;
              }
              ++v6;
            }
            while (v6 < v2);
          }
          if (++v4 >= v2)
          {
            if (!v2)
              goto LABEL_23;
            break;
          }
        }
        v9 = 0;
        v10 = 0.0;
        v11 = (TIFitAffineMLLMatrix *)v17[0];
        do
        {
          v12 = TIFitAffineMLLMatrix::valueAt(this, 0, v9);
          TIFitAffineMLLMatrix::determinant(v11);
          v14 = -v12;
          if ((v9 & 1) == 0)
            v14 = v12;
          v10 = v10 + v14 * v13;
          ++v9;
          v11 = (TIFitAffineMLLMatrix *)((char *)v11 + 40);
        }
        while (*((_QWORD *)this + 1) > v9);
      }
    }
LABEL_23:
    v15[0] = v17;
    std::vector<TIFitAffineMLLMatrix>::__destroy_vector::operator()[abi:nn180100](v15);
  }
}

void TIFitAffineMLLMatrix::coFactor(TIFitAffineMLLMatrix *this@<X0>, TIFitAffineMLLMatrix *a2@<X8>)
{
  uint64_t v3;
  double v5;
  double v6;
  double v7;
  double v8;
  char *v9;
  unint64_t v10;
  int64x2_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  int64x2_t v22;
  __int128 v23;
  void **v24;
  void **v25;
  unint64_t v26;
  char *v27;
  unint64_t i;
  unint64_t j;
  unint64_t v30;
  unint64_t v31;
  unsigned int v32;
  unint64_t v33;
  int v34;
  unint64_t v35;
  double v36;
  unint64_t k;
  uint64_t v38;
  unint64_t v39;
  char v40;
  double v41;
  double v42;
  unint64_t v43;
  char *v44;
  void *v45;
  char *v46;
  int64x2_t v47;
  int64x2_t v48;
  __int128 v49;
  _QWORD **v50;
  _QWORD *v51[2];
  void **v52;

  *(_OWORD *)a2 = *(_OWORD *)this;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 2) = (char *)a2 + 24;
  v3 = *((_QWORD *)this + 1);
  if (v3)
  {
    if (v3 == 2)
    {
      v5 = TIFitAffineMLLMatrix::valueAt(this, 1uLL, 1uLL);
      *(double *)TIFitAffineMLLMatrix::valueAt(a2, 0, 0) = v5;
      v6 = -TIFitAffineMLLMatrix::valueAt(this, 1uLL, 0);
      *(double *)TIFitAffineMLLMatrix::valueAt(a2, 0, 1uLL) = v6;
      v7 = -TIFitAffineMLLMatrix::valueAt(this, 0, 1uLL);
      *(double *)TIFitAffineMLLMatrix::valueAt(a2, 1uLL, 0) = v7;
      v8 = TIFitAffineMLLMatrix::valueAt(this, 0, 0);
      *(double *)TIFitAffineMLLMatrix::valueAt(a2, 1uLL, 1uLL) = v8;
    }
    else
    {
      v9 = 0;
      v10 = 0;
      v11 = 0uLL;
      while (1)
      {
        v49 = 0uLL;
        v50 = 0;
        v12 = (_QWORD *)v11.i64[1];
        if (v11.i64[1] >= (unint64_t)v9)
        {
          v14 = (_QWORD *)v11.i64[0];
          v15 = 0xAAAAAAAAAAAAAAABLL * ((v11.i64[1] - v11.i64[0]) >> 3);
          v16 = v15 + 1;
          if (v15 + 1 > 0xAAAAAAAAAAAAAAALL)
            abort();
          v47 = v11;
          if (0x5555555555555556 * ((uint64_t)&v9[-v11.i64[0]] >> 3) > v16)
            v16 = 0x5555555555555556 * ((uint64_t)&v9[-v11.i64[0]] >> 3);
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v9[-v11.i64[0]] >> 3) >= 0x555555555555555)
            v16 = 0xAAAAAAAAAAAAAAALL;
          if (v16 > 0xAAAAAAAAAAAAAAALL)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v17 = 3 * v16;
          v18 = (char *)operator new(24 * v16);
          v19 = v18;
          v20 = &v18[24 * v15];
          *((_QWORD *)v20 + 1) = 0;
          *((_QWORD *)v20 + 2) = 0;
          *(_QWORD *)v20 = 0;
          v50 = 0;
          v49 = 0uLL;
          if (v12 == v14)
          {
            v22 = vdupq_laneq_s64(v47, 1);
            v21 = &v18[24 * v15];
          }
          else
          {
            v21 = &v18[24 * v15];
            v22 = v47;
            do
            {
              *((_QWORD *)v21 - 3) = 0;
              *((_QWORD *)v21 - 2) = 0;
              v21 -= 24;
              *((_QWORD *)v21 + 2) = 0;
              v23 = *(_OWORD *)(v12 - 3);
              v12 -= 3;
              *(_OWORD *)v21 = v23;
              *((_QWORD *)v21 + 2) = v12[2];
              *v12 = 0;
              v12[1] = 0;
              v12[2] = 0;
            }
            while (v12 != v14);
          }
          v25 = (void **)v22.i64[1];
          v45 = (void *)v22.i64[0];
          v24 = (void **)v22.i64[0];
          while (v25 != v24)
          {
            v25 -= 3;
            v52 = v25;
            std::vector<TIFitAffineMLLMatrix>::__destroy_vector::operator()[abi:nn180100](&v52);
          }
          v9 = &v19[8 * v17];
          v13 = (uint64_t)(v20 + 24);
          v11.i64[0] = (uint64_t)v21;
          if (v45)
          {
            operator delete(v45);
            v11.i64[0] = (uint64_t)v21;
          }
        }
        else
        {
          *(_OWORD *)v11.i64[1] = 0uLL;
          *(_QWORD *)(v11.i64[1] + 16) = 0;
          *(_OWORD *)v11.i64[1] = v49;
          *(_QWORD *)(v11.i64[1] + 16) = v50;
          v49 = 0uLL;
          v50 = 0;
          v13 = v11.i64[1] + 24;
        }
        v46 = (char *)v11.i64[0];
        v11.i64[1] = v13;
        v48 = v11;
        v52 = (void **)&v49;
        std::vector<TIFitAffineMLLMatrix>::__destroy_vector::operator()[abi:nn180100](&v52);
        v26 = *((_QWORD *)this + 1);
        v27 = v46;
        if (!v26)
          break;
        for (i = 0; i < v26; ++i)
        {
          *(_QWORD *)&v49 = v26 - 1;
          *((_QWORD *)&v49 + 1) = v26 - 1;
          v51[0] = 0;
          v51[1] = 0;
          v50 = v51;
          std::vector<TIFitAffineMLLMatrix>::push_back[abi:nn180100]((void **)&v46[24 * v10], (uint64_t)&v49);
          std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v51[0]);
          v26 = *((_QWORD *)this + 1);
        }
        ++v10;
        v11 = v48;
        if (v26 <= v10)
        {
          if (v26)
          {
            for (j = 0; j < v26; ++j)
            {
              v30 = 0;
              do
              {
                v31 = 0;
                v32 = 0;
                do
                {
                  v33 = 0;
                  v34 = 0;
                  v35 = v32;
                  do
                  {
                    if (j != v31 && v30 != v33)
                    {
                      v36 = TIFitAffineMLLMatrix::valueAt(this, v31, v33);
                      *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)(*(_QWORD *)&v46[24 * j] + 40 * v30), v35, v34) = v36;
                      v26 = *((_QWORD *)this + 1);
                      ++v34;
                    }
                    ++v33;
                  }
                  while (v26 > v33);
                  if (j == v31)
                    v32 = v35;
                  else
                    v32 = v35 + 1;
                  ++v31;
                }
                while (v26 > v31);
                ++v30;
              }
              while (v26 > v30);
            }
            if (v26)
            {
              for (k = 0; k < v43; ++k)
              {
                v38 = 0;
                v39 = 0;
                v40 = (k & 1) == 0;
                do
                {
                  TIFitAffineMLLMatrix::determinant((TIFitAffineMLLMatrix *)(*(_QWORD *)&v46[24 * k] + v38));
                  if ((v40 & 1) != 0)
                    v42 = v41;
                  else
                    v42 = -v41;
                  *(double *)TIFitAffineMLLMatrix::valueAt(a2, k, v39) = v42;
                  v40 ^= 1u;
                  ++v39;
                  v43 = *((_QWORD *)this + 1);
                  v38 += 40;
                }
                while (v43 > v39);
              }
            }
          }
          break;
        }
      }
      if (v46)
      {
        v44 = (char *)v48.i64[1];
        if ((char *)v48.i64[1] != v46)
        {
          do
          {
            v44 -= 24;
            *(_QWORD *)&v49 = v44;
            std::vector<TIFitAffineMLLMatrix>::__destroy_vector::operator()[abi:nn180100]((void ***)&v49);
          }
          while (v44 != v46);
          v27 = (char *)v48.i64[0];
        }
        operator delete(v27);
      }
    }
  }
  TIFitAffineMLLMatrix::removeDefaults(a2);
}

void std::vector<TIFitAffineMLLMatrix>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 40;
        std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*((_QWORD **)v4 - 2));
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<TIFitAffineMLLMatrix>::push_back[abi:nn180100](void **a1, uint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  __int128 v17;
  uint64_t *v18;
  char *v19;
  char *v20;

  v5 = (char *)a1[1];
  v4 = (char *)a1[2];
  if (v5 < v4)
  {
    *(_OWORD *)v5 = *(_OWORD *)a2;
    *((_QWORD *)v5 + 3) = 0;
    *((_QWORD *)v5 + 4) = 0;
    *((_QWORD *)v5 + 2) = v5 + 24;
    std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)v5 + 2, *(_QWORD **)(a2 + 16), (_QWORD *)(a2 + 24));
    v6 = v5 + 40;
    goto LABEL_21;
  }
  v7 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (_BYTE *)*a1) >> 3);
  if (v7 + 1 > 0x666666666666666)
    abort();
  v8 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - (_BYTE *)*a1) >> 3);
  v9 = 2 * v8;
  if (2 * v8 <= v7 + 1)
    v9 = v7 + 1;
  if (v8 >= 0x333333333333333)
    v10 = 0x666666666666666;
  else
    v10 = v9;
  if (v10)
  {
    if (v10 > 0x666666666666666)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v11 = (char *)operator new(40 * v10);
  }
  else
  {
    v11 = 0;
  }
  v12 = &v11[40 * v7];
  v13 = &v11[40 * v10];
  *(_OWORD *)v12 = *(_OWORD *)a2;
  *((_QWORD *)v12 + 3) = 0;
  *((_QWORD *)v12 + 4) = 0;
  *((_QWORD *)v12 + 2) = v12 + 24;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)v12 + 2, *(_QWORD **)(a2 + 16), (_QWORD *)(a2 + 24));
  v6 = v12 + 40;
  v15 = (char *)*a1;
  v14 = (char *)a1[1];
  if (v14 == *a1)
  {
    *a1 = v12;
    a1[1] = v6;
    a1[2] = v13;
    if (!v14)
      goto LABEL_21;
    goto LABEL_20;
  }
  v16 = 0;
  do
  {
    v17 = *(_OWORD *)&v14[v16 - 40];
    *(_QWORD *)&v12[v16 - 16] = 0;
    *(_QWORD *)&v12[v16 - 24] = &v12[v16 - 16];
    v18 = (uint64_t *)&v12[v16 - 24];
    *((_OWORD *)v18 - 1) = v17;
    v18[2] = 0;
    std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>(v18, *(_QWORD **)&v14[v16 - 24], &v14[v16 - 16]);
    v16 -= 40;
  }
  while (&v14[v16] != v15);
  v19 = &v12[v16];
  v20 = (char *)*a1;
  v14 = (char *)a1[1];
  *a1 = v19;
  a1[1] = v6;
  a1[2] = v13;
  if (v14 != v20)
  {
    do
    {
      std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*((_QWORD **)v14 - 2));
      v14 -= 40;
    }
    while (v14 != v20);
    v14 = v20;
  }
  if (v14)
LABEL_20:
    operator delete(v14);
LABEL_21:
  a1[1] = v6;
}

_QWORD *TIFitAffineMLLMatrix::submatrix@<X0>(_QWORD *result@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v4;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  _BYTE v19[24];
  _BYTE *v20;
  uint64_t v21;

  v4 = result;
  v21 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  v7 = a2[1];
  v18 = *a2;
  if (v7 == -1)
    v8 = result[1];
  else
    v8 = v7 + v6;
  v9 = *a3;
  v10 = a3[1];
  v16 = *a3;
  v17 = v8 - 1;
  if (v10 == -1)
    v11 = *result;
  else
    v11 = v10 + v9;
  v15 = v11 - 1;
  *a4 = v11 - v9;
  a4[1] = v8 - v6;
  a4[4] = 0;
  a4[3] = 0;
  a4[2] = a4 + 3;
  if (v6 <= v8 - 1 && v9 <= v11 - 1)
  {
    v13 = operator new(0x30uLL);
    *v13 = &off_1EA102F30;
    v13[1] = &v18;
    v13[2] = &v17;
    v13[3] = &v16;
    v13[4] = &v15;
    v13[5] = a4;
    v20 = v13;
    TIFitAffineMLLMatrix::do_for_each_valid_element(v4, (uint64_t)v19);
    result = v20;
    if (v20 == v19)
    {
      v14 = 4;
      result = v19;
    }
    else
    {
      if (!v20)
        return result;
      v14 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v14))();
  }
  return result;
}

void std::__function::__func<TIFitAffineMLLMatrix::submatrix(TIFitAffineMLLMatrixDimRange const&,TIFitAffineMLLMatrixDimRange const&)::$_0,std::allocator<TIFitAffineMLLMatrix::submatrix(TIFitAffineMLLMatrixDimRange const&,TIFitAffineMLLMatrixDimRange const&)::$_0>,void ()(unsigned long,unsigned long,double const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::submatrix(TIFitAffineMLLMatrixDimRange const&,TIFitAffineMLLMatrixDimRange const&)::$_0,std::allocator<TIFitAffineMLLMatrix::submatrix(TIFitAffineMLLMatrixDimRange const&,TIFitAffineMLLMatrixDimRange const&)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1EA102F30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::submatrix(TIFitAffineMLLMatrixDimRange const&,TIFitAffineMLLMatrixDimRange const&)::$_0,std::allocator<TIFitAffineMLLMatrix::submatrix(TIFitAffineMLLMatrixDimRange const&,TIFitAffineMLLMatrixDimRange const&)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1EA102F30;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

char *std::__function::__func<TIFitAffineMLLMatrix::submatrix(TIFitAffineMLLMatrixDimRange const&,TIFitAffineMLLMatrixDimRange const&)::$_0,std::allocator<TIFitAffineMLLMatrix::submatrix(TIFitAffineMLLMatrixDimRange const&,TIFitAffineMLLMatrixDimRange const&)::$_0>,void ()(unsigned long,unsigned long,double const&)>::operator()(char *result, unint64_t *a2, unint64_t *a3, uint64_t *a4)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v4 = *a2;
  v5 = **((_QWORD **)result + 1);
  v6 = *a2 >= v5;
  v7 = *a2 - v5;
  if (v6 && **((_QWORD **)result + 2) >= v4)
  {
    v8 = *a3;
    v9 = **((_QWORD **)result + 3);
    v6 = *a3 >= v9;
    v10 = *a3 - v9;
    if (v6 && **((_QWORD **)result + 4) >= v8)
    {
      v11 = *a4;
      result = TIFitAffineMLLMatrix::valueAt(*((TIFitAffineMLLMatrix **)result + 5), v7, v10);
      *(_QWORD *)result = v11;
    }
  }
  return result;
}

_QWORD *TIFitAffineMLLMatrix::transform@<X0>(int8x16_t *this@<X0>, int8x16_t *a2@<X8>)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  *a2 = vextq_s8(*this, *this, 8uLL);
  a2[2].i64[0] = 0;
  a2[1].i64[1] = 0;
  a2[1].i64[0] = (uint64_t)&a2[1].i64[1];
  v4[0] = &off_1EA102FC0;
  v4[1] = a2;
  v5 = v4;
  TIFitAffineMLLMatrix::do_for_each_valid_element(this, (uint64_t)v4);
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void std::__function::__func<TIFitAffineMLLMatrix::transform(void)::$_0,std::allocator<TIFitAffineMLLMatrix::transform(void)::$_0>,void ()(unsigned long,unsigned long,double const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<TIFitAffineMLLMatrix::transform(void)::$_0,std::allocator<TIFitAffineMLLMatrix::transform(void)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA102FC0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TIFitAffineMLLMatrix::transform(void)::$_0,std::allocator<TIFitAffineMLLMatrix::transform(void)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA102FC0;
  a2[1] = v2;
  return result;
}

char *std::__function::__func<TIFitAffineMLLMatrix::transform(void)::$_0,std::allocator<TIFitAffineMLLMatrix::transform(void)::$_0>,void ()(unsigned long,unsigned long,double const&)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t v4;
  char *result;

  v4 = *a4;
  result = TIFitAffineMLLMatrix::valueAt(*(TIFitAffineMLLMatrix **)(a1 + 8), *a3, *a2);
  *(_QWORD *)result = v4;
  return result;
}

void TIFitAffineMLLMatrix::cholesky(TIFitAffineMLLMatrix *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4;
  unint64_t v5;
  double v6;
  unint64_t j;
  char *v8;
  double v9;
  _QWORD *v10;
  unint64_t v11;
  double v12;
  unint64_t k;
  double v14;
  double v15;
  char *v16;
  double v17;
  unint64_t v18;
  double v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t i;
  double v25;
  double v26;
  char *v27;
  char *v28;
  unint64_t v29;
  double v30;
  char *v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  unint64_t v35;
  uint64_t v36;
  double v37;
  double v38;
  char *v39;
  double v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  _QWORD **v53;
  _QWORD *v54[2];
  _QWORD v55[3];
  _QWORD *v56[2];
  __int128 v57;
  _QWORD *v58;
  _QWORD *v59[2];
  _QWORD v60[3];
  _QWORD *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v57 = *(_OWORD *)this;
  v59[0] = 0;
  v59[1] = 0;
  v58 = v59;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)&v58, *((_QWORD **)this + 2), (_QWORD *)this + 3);
  if (!*((_QWORD *)this + 1))
  {
    v21 = 0;
    v10 = *(_QWORD **)this;
LABEL_18:
    v55[0] = 1;
    v55[1] = v21;
    v56[0] = 0;
    v56[1] = 0;
    v55[2] = v56;
    v51 = 1;
    v52 = v21;
    v54[0] = 0;
    v54[1] = 0;
    v53 = v54;
    if (v10)
    {
      v22 = 0;
      while (*(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v22, v22) != 0.0)
      {
        v23 = *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v55, v22, 0);
        *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v51, v22, 0) = v23;
        if (v22)
        {
          for (i = 0; i != v22; ++i)
          {
            v25 = *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v51, i, 0);
            v26 = *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, i, v22);
            v27 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v51, v22, 0);
            *(double *)v27 = *(double *)v27 - v25 * v26;
          }
          v28 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v22, v22);
          v29 = v22;
        }
        else
        {
          v28 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, 0, 0);
          v29 = 0;
        }
        v30 = *(double *)v28;
        v31 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v51, v29, 0);
        *(double *)v31 = *(double *)v31 / v30;
        if (++v22 >= *(_QWORD *)this)
        {
          v21 = *((_QWORD *)this + 1);
          v32 = *(_QWORD *)this - 1;
          if (v21)
            goto LABEL_31;
          goto LABEL_39;
        }
      }
      goto LABEL_38;
    }
    v32 = -1;
    if (v21)
    {
LABEL_31:
      v33 = v21 - 1;
      v34 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v21 - 1, v32);
      while (*(double *)v34 != 0.0)
      {
        v35 = v33;
        v36 = *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v55, v33, 0);
        *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v51, v33, 0) = v36;
        while (v21 < *((_QWORD *)this + 1))
        {
          v37 = *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v51, v21, 0);
          v38 = *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v21, v32);
          v39 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v51, v33, 0);
          *(double *)v39 = *(double *)v39 - v37 * v38;
          ++v21;
        }
        v40 = *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v33, v32);
        v41 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v51, v33, 0);
        *(double *)v41 = *(double *)v41 / v40;
        if (!v33)
          goto LABEL_39;
        --v32;
        --v33;
        v34 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v35 - 1, v32);
        v21 = v35;
      }
LABEL_38:
      *(_OWORD *)a2 = *(_OWORD *)this;
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(a2 + 24) = 0;
      *(_QWORD *)(a2 + 16) = a2 + 24;
      std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v54[0]);
      std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v56[0]);
      goto LABEL_45;
    }
LABEL_39:
    v60[0] = &off_1EA103008;
    v60[1] = &v57;
    v61 = v60;
    TIFitAffineMLLMatrix::do_for_each_valid_element(&v57, (uint64_t)v60);
    v49 = v61;
    if (v61 == v60)
    {
      v50 = 4;
      v49 = v60;
    }
    else
    {
      if (!v61)
      {
LABEL_44:
        TIFitAffineMLLMatrix::removeDefaults((TIFitAffineMLLMatrix *)&v57);
        std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v54[0]);
        std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v56[0]);
        *(_OWORD *)a2 = v57;
        *(_QWORD *)(a2 + 32) = 0;
        *(_QWORD *)(a2 + 24) = 0;
        *(_QWORD *)(a2 + 16) = a2 + 24;
        std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)(a2 + 16), v58, v59);
        goto LABEL_45;
      }
      v50 = 5;
    }
    (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unint64_t))(*v49 + 8 * v50))(v49, v42, v43, v44, v45, v46, v47, v48, v51, v52);
    goto LABEL_44;
  }
  v4 = 0;
  while (1)
  {
    v5 = v4;
    v6 = *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v4, v4);
    if (v4)
    {
      for (j = 0; j != v4; ++j)
      {
        v8 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v4, j);
        v6 = v6 - *(double *)v8 * *(double *)v8;
      }
    }
    if (v6 <= 0.0)
      break;
    v9 = sqrt(v6);
    *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v4, v4) = v9;
    ++v4;
    v10 = *(_QWORD **)this;
    if (v5 + 1 < *(_QWORD *)this)
    {
      v11 = v5 + 1;
      v12 = 1.0 / v9;
      do
      {
        if (v5)
        {
          for (k = 0; k != v5; ++k)
          {
            v14 = *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, k, v11);
            v15 = *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, k, v5);
            v16 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v5, v11);
            *(double *)v16 = *(double *)v16 - v14 * v15;
          }
          v17 = v12 * *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v5, v11);
          *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v5, v11) = v17;
          v18 = v5;
        }
        else
        {
          v19 = *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, 0, v11);
          v20 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, 0, v11);
          v18 = 0;
          v17 = v12 * v19;
          *(double *)v20 = v17;
        }
        *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v57, v11++, v18) = v17;
        v10 = *(_QWORD **)this;
      }
      while (v11 < *(_QWORD *)this);
    }
    v21 = *((_QWORD *)this + 1);
    if (v4 >= v21)
      goto LABEL_18;
  }
  *(_OWORD *)a2 = *(_OWORD *)this;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 16) = a2 + 24;
LABEL_45:
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v59[0]);
}

void std::__function::__func<TIFitAffineMLLMatrix::cholesky(void)::$_0,std::allocator<TIFitAffineMLLMatrix::cholesky(void)::$_0>,void ()(unsigned long,unsigned long,double const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<TIFitAffineMLLMatrix::cholesky(void)::$_0,std::allocator<TIFitAffineMLLMatrix::cholesky(void)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA103008;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TIFitAffineMLLMatrix::cholesky(void)::$_0,std::allocator<TIFitAffineMLLMatrix::cholesky(void)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA103008;
  a2[1] = v2;
  return result;
}

char *std::__function::__func<TIFitAffineMLLMatrix::cholesky(void)::$_0,std::allocator<TIFitAffineMLLMatrix::cholesky(void)::$_0>,void ()(unsigned long,unsigned long,double const&)>::operator()(char *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;

  v3 = *a2;
  v4 = *a3;
  if (v4 < v3)
  {
    result = TIFitAffineMLLMatrix::valueAt(*((TIFitAffineMLLMatrix **)result + 1), v3, v4);
    *(_QWORD *)result = 0;
  }
  return result;
}

_QWORD *TIFitAffineMLLMatrix::pow@<X0>(TIFitAffineMLLMatrix *this@<X0>, double a2@<D0>, _QWORD *a3@<X8>)
{
  _QWORD *result;
  uint64_t v5;
  double v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v6 = a2;
  *(_OWORD *)a3 = *(_OWORD *)this;
  a3[3] = 0;
  a3[4] = 0;
  a3[2] = a3 + 3;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>(a3 + 2, *((_QWORD **)this + 2), (_QWORD *)this + 3);
  v7[0] = &off_1EA103050;
  v7[1] = a3;
  v7[2] = &v6;
  v8 = v7;
  TIFitAffineMLLMatrix::do_for_each_valid_element(a3, (uint64_t)v7);
  result = v8;
  if (v8 == v7)
  {
    v5 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      return result;
    v5 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8 * v5))(result);
}

void std::__function::__func<TIFitAffineMLLMatrix::pow(double)::$_0,std::allocator<TIFitAffineMLLMatrix::pow(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::pow(double)::$_0,std::allocator<TIFitAffineMLLMatrix::pow(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA103050;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIFitAffineMLLMatrix::pow(double)::$_0,std::allocator<TIFitAffineMLLMatrix::pow(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA103050;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

char *std::__function::__func<TIFitAffineMLLMatrix::pow(double)::$_0,std::allocator<TIFitAffineMLLMatrix::pow(double)::$_0>,void ()(unsigned long,unsigned long,double const&)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3, long double *a4)
{
  unint64_t v5;
  unint64_t v6;
  long double v7;
  char *result;

  v5 = *a2;
  v6 = *a3;
  v7 = pow(*a4, **(long double **)(a1 + 16));
  result = TIFitAffineMLLMatrix::valueAt(*(TIFitAffineMLLMatrix **)(a1 + 8), v5, v6);
  *(long double *)result = v7;
  return result;
}

char *TIFitAffineMLLMatrix::sumCols@<X0>(char *this@<X0>, TIFitAffineMLLMatrix *a2@<X8>)
{
  double v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t i;
  double v8;

  v3 = *(double *)this;
  *(_QWORD *)a2 = *(_QWORD *)this;
  *((_QWORD *)a2 + 1) = 1;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 2) = (char *)a2 + 24;
  if (v3 != 0.0)
  {
    v4 = this;
    v5 = 0;
    v6 = *((_QWORD *)this + 1);
    do
    {
      if (v6)
      {
        for (i = 0; i < v6; ++i)
        {
          v8 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v4, i, v5);
          this = TIFitAffineMLLMatrix::valueAt(a2, 0, v5);
          *(double *)this = v8 + *(double *)this;
          v6 = *((_QWORD *)v4 + 1);
        }
        v3 = *(double *)v4;
      }
      ++v5;
    }
    while (*(_QWORD *)&v3 > v5);
  }
  return this;
}

char *TIFitAffineMLLMatrix::sumRows@<X0>(char *this@<X0>, TIFitAffineMLLMatrix *a2@<X8>)
{
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  double v6;
  unint64_t v7;
  double v8;

  v3 = *((_QWORD *)this + 1);
  *(_QWORD *)a2 = 1;
  *((_QWORD *)a2 + 1) = v3;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 2) = (char *)a2 + 24;
  if (v3)
  {
    v4 = (unint64_t *)this;
    v5 = 0;
    v6 = *(double *)this;
    do
    {
      if (v6 != 0.0)
      {
        v7 = 0;
        do
        {
          v8 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v4, v5, v7);
          this = TIFitAffineMLLMatrix::valueAt(a2, v5, 0);
          *(double *)this = v8 + *(double *)this;
          ++v7;
          v6 = *(double *)v4;
        }
        while (*v4 > v7);
        v3 = v4[1];
      }
      ++v5;
    }
    while (v3 > v5);
  }
  return this;
}

double TIFitAffineMLLMatrix::univalue(TIFitAffineMLLMatrix *this)
{
  return TIFitAffineMLLMatrix::valueAt(this, 0, 0);
}

unint64_t TIFitAffineMLLMatrix::indexesFromKey(TIFitAffineMLLMatrix *this, unint64_t a2)
{
  return a2 / *(_QWORD *)this;
}

uint64_t TIFitAffineMLLMatrix::print(uint64_t this)
{
  uint64_t v1;
  TIFitAffineMLLMatrix *v2;
  unint64_t i;
  uint64_t v4;
  unint64_t v5;
  double v6;

  v1 = *(_QWORD *)(this + 8);
  if (v1)
  {
    v2 = (TIFitAffineMLLMatrix *)this;
    for (i = 0; i != v1; ++i)
    {
      v4 = *(_QWORD *)v2;
      if (*(_QWORD *)v2)
      {
        v5 = 0;
        do
        {
          v6 = TIFitAffineMLLMatrix::valueAt(v2, i, v5);
          printf(" %5.4f", v6);
          ++v5;
        }
        while (v4 != v5);
      }
      this = putchar(10);
    }
  }
  return this;
}

void operator+(TIFitAffineMLLMatrix *this@<X1>, double *a2@<X0>, TIFitAffineMLLMatrix *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t i;
  unint64_t j;
  double v10;
  double v11;

  v4 = *(_QWORD *)this;
  v5 = *((_QWORD *)this + 1);
  *(_QWORD *)a3 = *(_QWORD *)this;
  *((_QWORD *)a3 + 1) = v5;
  *((_QWORD *)a3 + 4) = 0;
  *((_QWORD *)a3 + 3) = 0;
  *((_QWORD *)a3 + 2) = (char *)a3 + 24;
  if (v4)
  {
    for (i = 0; i != v4; ++i)
    {
      if (v5)
      {
        for (j = 0; j != v5; ++j)
        {
          v10 = *a2;
          v11 = v10 + TIFitAffineMLLMatrix::valueAt(this, i, j);
          *(double *)TIFitAffineMLLMatrix::valueAt(a3, i, j) = v11;
        }
      }
    }
  }
  TIFitAffineMLLMatrix::removeDefaults(a3);
}

void operator-(TIFitAffineMLLMatrix *this@<X1>, double *a2@<X0>, TIFitAffineMLLMatrix *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t i;
  unint64_t j;
  double v10;
  double v11;

  v4 = *(_QWORD *)this;
  v5 = *((_QWORD *)this + 1);
  *(_QWORD *)a3 = *(_QWORD *)this;
  *((_QWORD *)a3 + 1) = v5;
  *((_QWORD *)a3 + 4) = 0;
  *((_QWORD *)a3 + 3) = 0;
  *((_QWORD *)a3 + 2) = (char *)a3 + 24;
  if (v4)
  {
    for (i = 0; i != v4; ++i)
    {
      if (v5)
      {
        for (j = 0; j != v5; ++j)
        {
          v10 = *a2;
          v11 = v10 - TIFitAffineMLLMatrix::valueAt(this, i, j);
          *(double *)TIFitAffineMLLMatrix::valueAt(a3, i, j) = v11;
        }
      }
    }
  }
  TIFitAffineMLLMatrix::removeDefaults(a3);
}

void operator*(uint64_t a1@<X0>, _QWORD *a2@<X1>, TIFitAffineMLLMatrix *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _BYTE v9[24];
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)a3 = *(_OWORD *)a2;
  *((_QWORD *)a3 + 4) = 0;
  *((_QWORD *)a3 + 3) = 0;
  *((_QWORD *)a3 + 2) = (char *)a3 + 24;
  v6 = operator new(0x20uLL);
  *v6 = &off_1EA1030E0;
  v6[1] = a3;
  v6[2] = a1;
  v6[3] = a2;
  v10 = v6;
  TIFitAffineMLLMatrix::do_for_each_valid_element(a2, (uint64_t)v9);
  v7 = v10;
  if (v10 == v9)
  {
    v8 = 4;
    v7 = v9;
    goto LABEL_5;
  }
  if (v10)
  {
    v8 = 5;
LABEL_5:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  TIFitAffineMLLMatrix::removeDefaults(a3);
}

void std::__function::__func<operator*(double const&,TIFitAffineMLLMatrix const&)::$_0,std::allocator<operator*(double const&,TIFitAffineMLLMatrix const&)::$_0>,void ()(unsigned long,unsigned long,double const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<operator*(double const&,TIFitAffineMLLMatrix const&)::$_0,std::allocator<operator*(double const&,TIFitAffineMLLMatrix const&)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1EA1030E0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<operator*(double const&,TIFitAffineMLLMatrix const&)::$_0,std::allocator<operator*(double const&,TIFitAffineMLLMatrix const&)::$_0>,void ()(unsigned long,unsigned long,double const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA1030E0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

char *std::__function::__func<operator*(double const&,TIFitAffineMLLMatrix const&)::$_0,std::allocator<operator*(double const&,TIFitAffineMLLMatrix const&)::$_0>,void ()(unsigned long,unsigned long,double const&)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4;
  unint64_t v5;
  double v6;
  double v7;
  char *result;

  v4 = *a2;
  v5 = *a3;
  v6 = **(double **)(a1 + 16);
  v7 = v6 * TIFitAffineMLLMatrix::valueAt(*(TIFitAffineMLLMatrix **)(a1 + 24), *a2, *a3);
  result = TIFitAffineMLLMatrix::valueAt(*(TIFitAffineMLLMatrix **)(a1 + 8), v4, v5);
  *(double *)result = v7;
  return result;
}

void operator/(TIFitAffineMLLMatrix *this@<X1>, uint64_t a2@<X0>, TIFitAffineMLLMatrix *a3@<X8>)
{
  _QWORD v5[5];

  TIFitAffineMLLMatrix::inverse(this, (TIFitAffineMLLMatrix *)v5);
  operator*(a2, v5, a3);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy((_QWORD *)v5[3]);
}

id getSTKStickerUsageManagerClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getSTKStickerUsageManagerClass_softClass;
  v7 = getSTKStickerUsageManagerClass_softClass;
  if (!getSTKStickerUsageManagerClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getSTKStickerUsageManagerClass_block_invoke;
    v3[3] = &unk_1EA107058;
    v3[4] = &v4;
    __getSTKStickerUsageManagerClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

Class __getSTKStickerUsageManagerClass_block_invoke(uint64_t a1)
{
  Class result;

  if (!StickersLibraryCore_frameworkLibrary)
    StickersLibraryCore_frameworkLibrary = _sl_dlopen();
  result = objc_getClass("STKStickerUsageManager");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  getSTKStickerUsageManagerClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t FlagsForCandidate()
{
  int v0;
  int v1;
  int IsExtensionForCandidateBar;
  int v3;
  int v4;
  unsigned int v5;
  int IsSinglePhraseCandidate;
  unsigned __int16 v7;

  v0 = MecabraCandidateIsExtensionCandidate() != 0;
  if (MecabraCandidateIsEmojiCandidate())
    v0 |= 2u;
  if (MecabraCandidateIsUserWordCandidate())
    v0 |= 4u;
  if (MecabraCandidateIsAutocorrectionCandidate())
    v0 |= 8u;
  if (MecabraCandidateIsOTAWordlistCandidate())
    v0 |= 0x10u;
  if (MecabraCandidateIsRegionalCandidate())
    v0 |= 0x20u;
  v1 = v0 | 0x80;
  if (MecabraCandidateIsBilingualCandidate())
    v0 |= 0x80u;
  if (MecabraCandidateGetKind() != 83)
    v1 = v0;
  IsExtensionForCandidateBar = MecabraCandidateIsExtensionForCandidateBar();
  if (MecabraCandidateIsPartialCandidate() | IsExtensionForCandidateBar)
    v3 = v1 | 0x200;
  else
    v3 = v1;
  v4 = ((unsigned __int16)MecabraCandidateGetWubixingType() << 9) & 0x400;
  v5 = v4 & 0xFFFFF7FF | (((MecabraCandidateGetWubixingType() >> 2) & 1) << 11) | v3;
  IsSinglePhraseCandidate = MecabraCandidateIsSinglePhraseCandidate();
  v7 = v5 | 0x1000;
  if (!IsSinglePhraseCandidate)
    return (unsigned __int16)v5;
  return v7;
}

id _sbsOverrideLog()
{
  if (_sbsOverrideLog_onceToken != -1)
    dispatch_once(&_sbsOverrideLog_onceToken, &__block_literal_global_27);
  return (id)_sbsOverrideLog_logFacility;
}

void ___sbsOverrideLog_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.TextInput", "StatusBarStyleOverrides");
  v1 = (void *)_sbsOverrideLog_logFacility;
  _sbsOverrideLog_logFacility = (uint64_t)v0;

}

Class __getMCProfileConnectionClass_block_invoke_13057(uint64_t a1)
{
  Class result;

  ManagedConfigurationLibrary_13060();
  result = objc_getClass("MCProfileConnection");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getMCProfileConnectionClass_softClass_13056 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    return (Class)ManagedConfigurationLibrary_13060();
  }
  return result;
}

uint64_t ManagedConfigurationLibrary_13060()
{
  uint64_t v0;
  void *v2;

  if (ManagedConfigurationLibraryCore_frameworkLibrary_13063)
    return ManagedConfigurationLibraryCore_frameworkLibrary_13063;
  ManagedConfigurationLibraryCore_frameworkLibrary_13063 = _sl_dlopen();
  v0 = ManagedConfigurationLibraryCore_frameworkLibrary_13063;
  if (!ManagedConfigurationLibraryCore_frameworkLibrary_13063)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

id getKSTextReplacementDidChangeNotification()
{
  id *v0;
  void *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (id *)getKSTextReplacementDidChangeNotificationSymbolLoc_ptr;
  v7 = getKSTextReplacementDidChangeNotificationSymbolLoc_ptr;
  if (!getKSTextReplacementDidChangeNotificationSymbolLoc_ptr)
  {
    v1 = (void *)KeyboardServicesLibrary_13070();
    v0 = (id *)dlsym(v1, "KSTextReplacementDidChangeNotification");
    v5[3] = (uint64_t)v0;
    getKSTextReplacementDidChangeNotificationSymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *v0;
  dlerror();
  v3 = abort_report_np();
  return (id)ShortcutsDidChange(v3);
}

uint64_t ShortcutsDidChange()
{
  return TIDispatchAsync();
}

uint64_t KeyboardServicesLibrary_13070()
{
  uint64_t v0;
  void *v2;

  if (KeyboardServicesLibraryCore_frameworkLibrary_13072)
    return KeyboardServicesLibraryCore_frameworkLibrary_13072;
  KeyboardServicesLibraryCore_frameworkLibrary_13072 = _sl_dlopen();
  v0 = KeyboardServicesLibraryCore_frameworkLibrary_13072;
  if (!KeyboardServicesLibraryCore_frameworkLibrary_13072)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

void TI::Favonius::SearchNodeGeometryExtensionsInsertingKey::~SearchNodeGeometryExtensionsInsertingKey(TI::Favonius::SearchNodeGeometryExtensionsInsertingKey *this)
{
  TI::Favonius::SearchNodeGeometryExtensionsInsertingKey::~SearchNodeGeometryExtensionsInsertingKey(this);
  JUMPOUT(0x1DF0A2144);
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *(_QWORD *)this = &off_1EA1032D0;
  v2 = (unsigned int *)*((_QWORD *)this + 11);
  if (v2)
  {
    v3 = v2 + 2;
    v4 = atomic_load(v2 + 2);
    if (v4 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
    else
    {
      do
        v5 = __ldaxr(v3);
      while (__stlxr(v5 - 1, v3));
    }
  }
  v6 = (unsigned int *)*((_QWORD *)this + 10);
  if (v6)
  {
    v7 = v6 + 2;
    v8 = atomic_load(v6 + 2);
    if (v8 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 248))(v6);
    }
    else
    {
      do
        v9 = __ldaxr(v7);
      while (__stlxr(v9 - 1, v7));
    }
  }
  TI::Favonius::SearchNodeGeometryExtensions::~SearchNodeGeometryExtensions(this);
}

unsigned int *TI::Favonius::SearchNodeGeometryExtensionsInsertingKey::clone_substituting_touch@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  unsigned int *v7;
  unsigned int *result;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;

  v6 = operator new();
  v7 = *a2;
  *a2 = 0;
  v12 = v7;
  *a3 = TI::Favonius::SearchNodeGeometryExtensionsInsertingKey::SearchNodeGeometryExtensionsInsertingKey(v6, a1, &v12);
  result = v12;
  if (v12)
  {
    v9 = v12 + 2;
    v10 = atomic_load(v12 + 2);
    if (v10 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v12 + 8))();
    }
    else
    {
      do
        v11 = __ldaxr(v9);
      while (__stlxr(v11 - 1, v9));
    }
  }
  return result;
}

unsigned int *TI::Favonius::SearchNodeGeometryExtensionsInsertingKey::create_extension@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int **a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X8>, float a6@<S0>)
{
  uint64_t v12;
  uint64_t v13;
  unsigned int *result;
  uint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int *v21;

  v12 = *(_QWORD *)(a1 + 80);
  v13 = *(_QWORD *)(a1 + 88);
  result = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
  v15 = *a4;
  if ((*(_WORD *)(*(_QWORD *)result + 60) & 0x20) != 0 && (*(_WORD *)(*(_QWORD *)(v15 + 8) + 60) & 0x20) != 0)
  {
    *a5 = 0;
  }
  else
  {
    v16 = *a3;
    *a3 = 0;
    v20 = v15;
    v21 = v16;
    *a4 = 0;
    TI::Favonius::SearchNodeInsertingKey::create(a2, &v21, v12, v13, &v20, a5, a6, *(float *)(a1 + 96));
    if (v20)
      WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v20);
    result = v21;
    if (v21)
    {
      v17 = v21 + 2;
      v18 = atomic_load(v21 + 2);
      if (v18 == 1)
      {
        return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v21 + 8))();
      }
      else
      {
        do
          v19 = __ldaxr(v17);
        while (__stlxr(v19 - 1, v17));
      }
    }
  }
  return result;
}

uint64_t TI::Favonius::SearchNodeGeometryExtensionsInsertingKey::SearchNodeGeometryExtensionsInsertingKey(uint64_t a1, uint64_t a2, unsigned int **a3)
{
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v16;

  v5 = *a3;
  *a3 = 0;
  v16 = v5;
  TI::Favonius::SearchNodeGeometryExtensions::SearchNodeGeometryExtensions(a1, a2, (uint64_t *)&v16);
  if (v16)
  {
    v6 = v16 + 2;
    v7 = atomic_load(v16 + 2);
    if (v7 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v16 + 8))();
    }
    else
    {
      do
        v8 = __ldaxr(v6);
      while (__stlxr(v8 - 1, v6));
    }
  }
  *(_QWORD *)a1 = &off_1EA1032D0;
  v9 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 80) = v9;
  if (v9)
  {
    v10 = (unsigned int *)(v9 + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 + 1, v10));
  }
  v12 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 88) = v12;
  if (v12)
  {
    v13 = (unsigned int *)(v12 + 8);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 + 1, v13));
  }
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  return a1;
}

unsigned int *TI::Favonius::SearchNodeGeometryExtensionsInsertingKey::create@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>, float a5@<S0>)
{
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int *result;
  unsigned int *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int *v31;
  unsigned int *v32;
  unsigned int *v33;
  unsigned int *v34;

  v10 = *(_QWORD *)(a1 + 128);
  v11 = *(unsigned int **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 16))(a3);
  v33 = v11;
  if (v11)
  {
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 + 1, v11));
  }
  (*(void (**)(unsigned int **__return_ptr, uint64_t, unsigned int **, unsigned int *))(*(_QWORD *)v10 + 72))(&v34, v10, &v33, *a2);
  v13 = v34;
  v34 = 0;
  if (v33)
    WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v33);
  v14 = (*(float (**)(uint64_t))(*(_QWORD *)a3 + 24))(a3);
  v15 = logf(v14) * a5;
  v16 = (*(float (**)(unsigned int *))(*(_QWORD *)*a2 + 32))(*a2);
  v17 = operator new();
  v18 = *a2;
  *a2 = 0;
  v31 = v13;
  v32 = v18;
  if (v13)
  {
    v19 = v13 + 2;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 + 1, v19));
  }
  *a4 = TI::Favonius::SearchNodeGeometryExtensionsInsertingKey::SearchNodeGeometryExtensionsInsertingKey(v17, a1, &v32, a3, (uint64_t *)&v31, a5, v15, v16);
  if (v31)
  {
    v21 = v31 + 2;
    v22 = atomic_load(v31 + 2);
    if (v22 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v31 + 8))();
    }
    else
    {
      do
        v23 = __ldaxr(v21);
      while (__stlxr(v23 - 1, v21));
    }
  }
  result = v32;
  if (v32)
  {
    v25 = v32 + 2;
    v26 = atomic_load(v32 + 2);
    if (v26 == 1)
    {
      result = (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v32 + 8))();
    }
    else
    {
      do
        v27 = __ldaxr(v25);
      while (__stlxr(v27 - 1, v25));
    }
  }
  if (v13)
  {
    v28 = v13 + 2;
    v29 = atomic_load(v13 + 2);
    if (v29 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v13 + 8))(v13);
    }
    else
    {
      do
        v30 = __ldaxr(v28);
      while (__stlxr(v30 - 1, v28));
    }
  }
  return result;
}

uint64_t TI::Favonius::SearchNodeGeometryExtensionsInsertingKey::SearchNodeGeometryExtensionsInsertingKey(uint64_t a1, uint64_t a2, unsigned int **a3, uint64_t a4, uint64_t *a5, float a6, float a7, float a8)
{
  unsigned int *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int *v20;

  v12 = *a3;
  *a3 = 0;
  v20 = v12;
  TI::Favonius::SearchNodeGeometryExtensions::SearchNodeGeometryExtensions(a1, a2, (uint64_t *)&v20, 1, a6, a7 + a8);
  if (v20)
  {
    v13 = v20 + 2;
    v14 = atomic_load(v20 + 2);
    if (v14 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v20 + 8))();
    }
    else
    {
      do
        v15 = __ldaxr(v13);
      while (__stlxr(v15 - 1, v13));
    }
  }
  *(_QWORD *)a1 = &off_1EA1032D0;
  *(_QWORD *)(a1 + 80) = a4;
  if (a4)
  {
    v16 = (unsigned int *)(a4 + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 + 1, v16));
  }
  v18 = *a5;
  *a5 = 0;
  *(_QWORD *)(a1 + 88) = v18;
  *(float *)(a1 + 96) = a7;
  return a1;
}

void GetConsonantLettersSetAndArray(int a1, _QWORD *a2, _QWORD *a3)
{
  void *v6;
  void *v7;
  id v8;
  id v9;
  void *v10;
  void (**v11)(_QWORD, _QWORD, _QWORD);
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[4];
  id v15;
  id v16;

  if (a2)
  {
    v6 = (void *)objc_opt_new();
    if (a3)
    {
LABEL_3:
      objc_msgSend(MEMORY[0x1E0C99DE8], "array");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      goto LABEL_6;
    }
  }
  else
  {
    v6 = 0;
    if (a3)
      goto LABEL_3;
  }
  v7 = 0;
LABEL_6:
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3221225472;
  v14[2] = ___ZL30GetConsonantLettersSetAndArray11UScriptCodePU15__autoreleasingP14NSCharacterSetPU15__autoreleasingP7NSArray_block_invoke;
  v14[3] = &unk_1EA103400;
  v8 = v6;
  v15 = v8;
  v9 = v7;
  v16 = v9;
  v10 = _Block_copy(v14);
  v11 = (void (**)(_QWORD, _QWORD, _QWORD))v10;
  if (a1 <= 20)
  {
    if (a1 > 14)
    {
      if (a1 == 15)
      {
        (*((void (**)(void *, uint64_t, uint64_t))v10 + 2))(v10, 2709, 37);
        v11[2](v11, 2748, 1);
        v12 = 8;
        v13 = 2809;
      }
      else
      {
        if (a1 != 16)
          goto LABEL_28;
        (*((void (**)(void *, uint64_t, uint64_t))v10 + 2))(v10, 2581, 37);
        v11[2](v11, 2620, 1);
        v12 = 6;
        v13 = 2649;
      }
    }
    else if (a1 == 4)
    {
      (*((void (**)(void *, uint64_t, uint64_t))v10 + 2))(v10, 2453, 37);
      v11[2](v11, 2492, 1);
      v11[2](v11, 2510, 1);
      v11[2](v11, 2524, 4);
      v12 = 2;
      v13 = 2544;
    }
    else
    {
      if (a1 != 10)
        goto LABEL_28;
      (*((void (**)(void *, uint64_t, uint64_t))v10 + 2))(v10, 2325, 37);
      v11[2](v11, 2364, 1);
      v12 = 8;
      v11[2](v11, 2392, 8);
      v13 = 2424;
    }
  }
  else if (a1 <= 30)
  {
    if (a1 == 21)
    {
      (*((void (**)(void *, uint64_t, uint64_t))v10 + 2))(v10, 3221, 37);
      v11[2](v11, 3260, 1);
      v12 = 2;
      v13 = 3293;
    }
    else
    {
      if (a1 != 26)
        goto LABEL_28;
      (*((void (**)(void *, uint64_t, uint64_t))v10 + 2))(v10, 3349, 37);
      v11[2](v11, 3386, 1);
      v11[2](v11, 3412, 3);
      v12 = 6;
      v13 = 3450;
    }
  }
  else
  {
    switch(a1)
    {
      case 31:
        (*((void (**)(void *, uint64_t, uint64_t))v10 + 2))(v10, 2837, 37);
        v12 = 1;
        v11[2](v11, 2876, 1);
        v11[2](v11, 2908, 4);
        v13 = 2929;
        break;
      case 35:
        v12 = 37;
        v13 = 2965;
        break;
      case 36:
        (*((void (**)(void *, uint64_t, uint64_t))v10 + 2))(v10, 3093, 37);
        v12 = 6;
        v13 = 3160;
        break;
      default:
        goto LABEL_28;
    }
  }
  v11[2](v11, v13, v12);
LABEL_28:
  if (a2)
    *a2 = objc_retainAutorelease(v8);
  if (a3)
    *a3 = objc_retainAutorelease(v9);

}

void ___ZL30GetConsonantLettersSetAndArray11UScriptCodePU15__autoreleasingP14NSCharacterSetPU15__autoreleasingP7NSArray_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  unint64_t v7;
  void *v8;
  void *v9;
  unsigned __int16 i;

  v6 = *(void **)(a1 + 32);
  if (v6)
    objc_msgSend(v6, "addCharactersInRange:", a2, a3);
  if (*(_QWORD *)(a1 + 40))
  {
    v7 = a2 + a3;
    for (i = a2; v7 > i; ++i)
    {
      v8 = *(void **)(a1 + 40);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCharacters:length:", &i, 1);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "addObject:", v9);

    }
  }
}

uint64_t GetScriptCodeForLanguage(NSString *a1)
{
  id v1;

  objc_msgSend(MEMORY[0x1E0C99DC8], "scriptCodeFromLanguage:", a1);
  v1 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  objc_msgSend(v1, "UTF8String");
  uscript_getCode();

  return 0;
}

void ___ZL16GetTallConjunctsv_block_invoke()
{
  uint64_t v0;
  void *v1;

  objc_msgSend(MEMORY[0x1E0C99E60], "setWithArray:", &unk_1EA140120);
  v0 = objc_claimAutoreleasedReturnValue();
  v1 = (void *)GetTallConjuncts(void)::__tallConjuncts;
  GetTallConjuncts(void)::__tallConjuncts = v0;

}

void ___ZL18GetAkhandConjunctsv_block_invoke()
{
  void *v0;

  v0 = (void *)GetAkhandConjuncts(void)::__akhandConjuncts;
  GetAkhandConjuncts(void)::__akhandConjuncts = (uint64_t)&unk_1EA140108;

}

void TI::ConfidenceModel::compute_confidence2(TI::ConfidenceModel *this, CandidateCollection *a2)
{
  Candidate *var0;

  var0 = a2->var0.var0;
  if ((unint64_t)(0x1CAC083126E978D5 * ((a2->var0.var1 - a2->var0.var0) >> 3)) > 1)
  {
    expf(*((float *)var0 + 437) - *((float *)var0 + 187));
    expf(*((float *)var0 + 436) - *((float *)var0 + 186));
  }
}

double TI::ConfidenceModel::compute_confidence1(TI::ConfidenceModel *this, KB::CandidateCollection *a2, unsigned int a3)
{
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  KB::Candidate *v7;
  uint64_t i;
  const KB::Candidate *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  KB::Candidate *v14;
  KB::Candidate *v15;
  KB::Candidate *v16;
  int64x2_t v17;
  uint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  double v23;
  float v24;
  _QWORD *v25;
  double v26;
  double v27;
  unsigned int v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  KB::Candidate *v32;
  _QWORD *v33;
  _BOOL4 v35;
  BOOL v36;
  float v37;
  double v38;
  _QWORD *v39;
  KB::Candidate *v42[2];
  _OWORD v43[2];
  _OWORD v44[3];
  int v45;
  KB::String *v46;
  _OWORD v47[2];
  _OWORD *v48;
  uint64_t v49;
  void *v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;

  v3 = a3;
  v53 = *MEMORY[0x1E0C80C00];
  v4 = 652835029 * ((*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 3);
  v45 = 0;
  if (v4 >= a3)
    v5 = a3;
  else
    v5 = v4;
  *(_OWORD *)v42 = 0u;
  memset(v43, 0, sizeof(v43));
  memset(v44, 0, sizeof(v44));
  if ((_DWORD)v5)
  {
    v7 = 0;
    for (i = 0; i != v5; ++i)
    {
      v9 = (const KB::Candidate *)(*(_QWORD *)a2 + 1000 * i);
      if ((unint64_t)v7 >= *(_QWORD *)&v43[0])
      {
        v10 = 0x1CAC083126E978D5 * ((v7 - v42[0]) >> 3);
        v11 = v10 + 1;
        if ((unint64_t)(v10 + 1) > 0x4189374BC6A7EFLL)
          abort();
        if (0x395810624DD2F1AALL * ((uint64_t)(*(_QWORD *)&v43[0] - (unint64_t)v42[0]) >> 3) > v11)
          v11 = 0x395810624DD2F1AALL * ((uint64_t)(*(_QWORD *)&v43[0] - (unint64_t)v42[0]) >> 3);
        if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(*(_QWORD *)&v43[0] - (unint64_t)v42[0]) >> 3)) >= 0x20C49BA5E353F7)
          v12 = 0x4189374BC6A7EFLL;
        else
          v12 = v11;
        v48 = v43;
        if (v12)
          v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v12);
        else
          v13 = 0;
        v14 = (KB::Candidate *)(v12 + 1000 * v10);
        *(_QWORD *)&v47[0] = v12;
        *((_QWORD *)&v47[0] + 1) = v14;
        *((_QWORD *)&v47[1] + 1) = v12 + 1000 * v13;
        KB::Candidate::Candidate(v14, v9);
        v7 = (KB::Candidate *)((char *)v14 + 1000);
        *(_QWORD *)&v47[1] = v7;
        v15 = v42[1];
        v16 = (KB::Candidate *)*((_QWORD *)&v47[0] + 1);
        if (v42[1] == v42[0])
        {
          v17 = vdupq_n_s64((unint64_t)v42[1]);
        }
        else
        {
          do
          {
            v15 = (KB::Candidate *)((char *)v15 - 1000);
            v16 = (KB::Candidate *)KB::Candidate::Candidate((uint64_t)v16 - 1000, (uint64_t)v15);
          }
          while (v15 != v42[0]);
          v17 = *(int64x2_t *)v42;
          v7 = *(KB::Candidate **)&v47[1];
        }
        v42[0] = v16;
        v42[1] = v7;
        *(int64x2_t *)((char *)v47 + 8) = v17;
        v18 = *(_QWORD *)&v43[0];
        *(_QWORD *)&v43[0] = *((_QWORD *)&v47[1] + 1);
        *((_QWORD *)&v47[1] + 1) = v18;
        *(_QWORD *)&v47[0] = v17.i64[0];
        std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)v47);
      }
      else
      {
        KB::Candidate::Candidate(v7, (const KB::Candidate *)(*(_QWORD *)a2 + 1000 * i));
        v7 = (KB::Candidate *)((char *)v7 + 1000);
      }
      v42[1] = v7;
    }
    v3 = a3;
    v19 = (uint64_t *)v42[0];
  }
  else
  {
    v7 = 0;
    v19 = 0;
  }
  v20 = 126 - 2 * __clz(0x1CAC083126E978D5 * ((v7 - (KB::Candidate *)v19) >> 3));
  if (v7 == (KB::Candidate *)v19)
    v21 = 0;
  else
    v21 = v20;
  std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,false>(v19, v7, v21, 1);
  v22 = 0x1CAC083126E978D5 * ((v42[1] - v42[0]) >> 3);
  if (v22)
  {
    if (v22 == 1)
    {
      v23 = 1.0;
    }
    else
    {
      memset(v47, 0, sizeof(v47));
      LODWORD(v48) = 1065353216;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)v47, (unint64_t)(float)(unint64_t)(int)v3);
      v51 = xmmword_1DA9104B0;
      v52 = 0x3FF0000000000000;
      if (v3 == 2)
        *(_QWORD *)&v51 = 0x3FF0000000000000;
      v24 = *((float *)v42[0] + 186);
      KB::Candidate::capitalized_string(v42[0], (uint64_t)&v49);
      v46 = (KB::String *)&v49;
      v25 = std::__hash_table<std::__hash_value_type<KB::String,KB::Candidate>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Candidate>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Candidate>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Candidate>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>((uint64_t)v47, &v49, &v46);
      KB::Candidate::operator=((uint64_t)(v25 + 6), (uint64_t)v42[0]);
      if (v50 && BYTE6(v49) == 1)
        free(v50);
      v26 = 0.0;
      v27 = 0.0;
      if (v5 >= 2)
      {
        v28 = 0;
        v29 = expf(v24);
        v30 = v5 - 1;
        v31 = 1744;
        do
        {
          v32 = (KB::Candidate *)((char *)v42[0] + v31 - 744);
          KB::Candidate::capitalized_string(v32, (uint64_t)&v49);
          v33 = std::__hash_table<std::__hash_value_type<KB::String,KB::Candidate>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Candidate>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Candidate>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Candidate>>>::find<KB::String>(*(uint64_t *)&v47[0], *((unint64_t *)&v47[0] + 1), &v49);
          v35 = v29 > 0.0 && v33 == 0;
          if (v50)
            v36 = BYTE6(v49) == 1;
          else
            v36 = 0;
          if (v36)
            free(v50);
          if (v35)
          {
            v37 = expf(*(float *)((char *)v42[0] + v31));
            if (v28 >= 2)
              v28 = 2;
            v38 = *((double *)&v51 + v28);
            KB::Candidate::capitalized_string(v32, (uint64_t)&v49);
            v46 = (KB::String *)&v49;
            v39 = std::__hash_table<std::__hash_value_type<KB::String,KB::Candidate>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Candidate>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Candidate>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Candidate>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>((uint64_t)v47, &v49, &v46);
            KB::Candidate::operator=((uint64_t)(v39 + 6), (uint64_t)v32);
            if (v50 && BYTE6(v49) == 1)
              free(v50);
            v26 = v26 + (1.0 - v37 / v29) * v38;
            v27 = v27 + v38;
            ++v28;
            v29 = v37;
          }
          v31 += 1000;
          --v30;
        }
        while (v30);
      }
      if (v27 == 0.0)
        v23 = 1.0;
      else
        v23 = v26 / v27;
      std::__hash_table<std::__hash_value_type<KB::String,KB::Candidate>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Candidate>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Candidate>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Candidate>>>::~__hash_table((uint64_t)v47);
    }
  }
  else
  {
    v23 = 0.0;
  }
  *(_QWORD *)&v47[0] = (char *)&v44[1] + 8;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)v47);
  *(_QWORD *)&v47[0] = v44;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)v47);
  *(_QWORD *)&v47[0] = (char *)v43 + 8;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)v47);
  *(_QWORD *)&v47[0] = v42;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)v47);
  return v23;
}

void TI::ConfidenceModel::update_confidence_for_candidates(TI::ConfidenceModel *this, KB::CandidateCollection *a2)
{
  float v4;
  float v5;
  _BOOL8 v6;
  int v7;
  double v8;
  int v9;
  int v10;

  v4 = *((float *)this + 3);
  v5 = *((float *)this + 1);
  v6 = KB::CandidateCollection::contains_secondary_language_candidates(a2, &v10, 3u);
  if (v6)
  {
    v4 = *((float *)this + 4);
    v5 = *((float *)this + 2);
  }
  v7 = *((_DWORD *)this + 5);
  if (v7)
  {
    v8 = 0.0;
    if (v7 == 1)
      TI::ConfidenceModel::compute_confidence2((TI::ConfidenceModel *)v6, (CandidateCollection *)a2);
  }
  else
  {
    v8 = TI::ConfidenceModel::compute_confidence1((TI::ConfidenceModel *)v6, a2, *((_DWORD *)this + 6));
  }
  if (v8 >= *(float *)this)
  {
    *((_DWORD *)a2 + 24) = 0;
  }
  else
  {
    if (v8 >= v5)
      v9 = 1;
    else
      v9 = 2;
    *((_DWORD *)a2 + 24) = v9;
    if (*(_QWORD *)a2 != *((_QWORD *)a2 + 1) && expf(*(float *)(*(_QWORD *)a2 + 744)) < v4)
      *((_DWORD *)a2 + 24) = 2;
  }
}

void TI::Favonius::SearchNodeLanguageThenGeometryExtensions::~SearchNodeLanguageThenGeometryExtensions(TI::Favonius::SearchNodeLanguageThenGeometryExtensions *this)
{
  TI::Favonius::SearchNodeLanguageThenGeometryExtensions::~SearchNodeLanguageThenGeometryExtensions(this);
  JUMPOUT(0x1DF0A2144);
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *(_QWORD *)this = &off_1EA103430;
  WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::~Vector((uint64_t)this + 48);
  v2 = (unsigned int *)*((_QWORD *)this + 4);
  if (v2)
  {
    v3 = v2 + 2;
    v4 = atomic_load(v2 + 2);
    if (v4 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
    else
    {
      do
        v5 = __ldaxr(v3);
      while (__stlxr(v5 - 1, v3));
    }
  }
  *(_QWORD *)this = off_1EA102A78;
  v6 = (unsigned int *)*((_QWORD *)this + 2);
  if (v6)
  {
    v7 = v6 + 2;
    v8 = atomic_load(v6 + 2);
    if (v8 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
    else
    {
      do
        v9 = __ldaxr(v7);
      while (__stlxr(v9 - 1, v7));
    }
  }
}

unsigned int *TI::Favonius::SearchNodeLanguageThenGeometryExtensions::clone_substituting_touch@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  unsigned int *v7;
  unsigned int *result;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;

  v6 = operator new();
  v7 = *a2;
  *a2 = 0;
  v12 = v7;
  *a3 = TI::Favonius::SearchNodeLanguageThenGeometryExtensions::SearchNodeLanguageThenGeometryExtensions(v6, a1, (uint64_t *)&v12);
  result = v12;
  if (v12)
  {
    v9 = v12 + 2;
    v10 = atomic_load(v12 + 2);
    if (v10 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v12 + 8))();
    }
    else
    {
      do
        v11 = __ldaxr(v9);
      while (__stlxr(v11 - 1, v9));
    }
  }
  return result;
}

unsigned int *TI::Favonius::SearchNodeLanguageThenGeometryExtensions::branch_at_current_bound@<X0>(TI::Favonius::SearchNodeLanguageThenGeometryExtensions *this@<X0>, uint64_t *a2@<X8>)
{
  unsigned int *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int *v21;

  v6 = *((_QWORD *)this + 6);
  result = (unsigned int *)((char *)this + 48);
  v5 = v6;
  if (v6)
  {
    v7 = v5 - 1;
    v8 = *(unsigned int **)(*((_QWORD *)this + 7) + 8 * (v5 - 1));
    if (v8)
    {
      v9 = v8 + 2;
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 + 1, v9));
      v7 = *(_QWORD *)result - 1;
    }
    WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::shrink(result, v7);
    TI::Favonius::SearchNodeLanguageThenGeometryExtensions::set_bound_on_score(this);
    v11 = *((_QWORD *)this + 4);
    v12 = (unsigned int *)*((_QWORD *)this + 2);
    v21 = v12;
    if (v12)
    {
      v13 = v12 + 2;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 + 1, v13));
    }
    TI::Favonius::SearchNodeGeometryExtensionsInsertingKey::create(v11, &v21, (uint64_t)v8, a2, *((float *)this + 10));
    result = v21;
    if (v21)
    {
      v15 = v21 + 2;
      v16 = atomic_load(v21 + 2);
      if (v16 == 1)
      {
        result = (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v21 + 8))();
      }
      else
      {
        do
          v17 = __ldaxr(v15);
        while (__stlxr(v17 - 1, v15));
      }
    }
    if (v8)
    {
      v18 = v8 + 2;
      v19 = atomic_load(v8 + 2);
      if (v19 == 1)
      {
        return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v8 + 248))(v8);
      }
      else
      {
        do
          v20 = __ldaxr(v18);
        while (__stlxr(v20 - 1, v18));
      }
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void TI::Favonius::SearchNodeLanguageThenGeometryExtensions::decrease_bound_on_score(TI::Favonius::SearchNodeLanguageThenGeometryExtensions *this)
{
  uint64_t v2;
  uint64_t v3;
  TI::Favonius::KeyFactory *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int *v8;

  if (!*((_BYTE *)this + 72))
  {
    TI::Favonius::SearchNode::get_language_extensions(*((_QWORD *)this + 4), (unint64_t *)this + 6);
    *((_BYTE *)this + 72) = 1;
    if (*((_BYTE *)this + 73))
    {
      v2 = *(_QWORD *)(*((_QWORD *)this + 4) + 56);
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 64))(v2))
      {
        if ((*(_WORD *)(*((_QWORD *)this + 4) + 120) & 0x20) == 0)
        {
          v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
          v4 = (TI::Favonius::KeyFactory *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
          TI::Favonius::KeyFactory::create_key(v4, 0x20u, &v8);
          (*(void (**)(uint64_t, char *, unsigned int **))(*(_QWORD *)v2 + 40))(v2, (char *)this + 48, &v8);
          if (v8)
            WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v8);
        }
      }
    }
    v5 = *((_QWORD *)this + 6);
    v6 = 126 - 2 * __clz(v5);
    if (v5)
      v7 = v6;
    else
      v7 = 0;
    std::__introsort<std::_ClassicAlgPolicy,TI::Favonius::SearchNodeLanguageThenGeometryExtensions::LetterExtensionComparator &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,false>(*((unsigned int ***)this + 7), (unsigned int **)(*((_QWORD *)this + 7) + 8 * v5), v7, 1);
    TI::Favonius::SearchNodeLanguageThenGeometryExtensions::set_bound_on_score(this);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,TI::Favonius::SearchNodeLanguageThenGeometryExtensions::LetterExtensionComparator &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,false>(unsigned int **a1, unsigned int **a2, uint64_t a3, char a4)
{
  unsigned int **v7;
  unsigned int **v8;
  unsigned int **v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int **v13;
  unsigned int *v14;
  float v15;
  unsigned int *v16;
  unsigned int **v17;
  unsigned int **v18;
  unsigned int *v19;
  float v20;
  unsigned int **v21;
  uint64_t v22;
  float v23;
  uint64_t v24;
  float v25;
  unsigned int **v26;
  unsigned int **v27;
  unsigned int *v28;
  unsigned int *v29;
  float v30;
  uint64_t v31;
  float v32;
  unsigned int *v33;
  unsigned int *v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int *v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  BOOL v42;
  unsigned int *v43;
  float v44;
  float v45;
  unsigned int *v46;
  unsigned int **v47;
  float v48;
  unsigned int **v49;
  float v50;
  uint64_t v51;
  unsigned int *v52;
  float v53;
  unsigned int *v54;
  float v55;
  uint64_t v56;
  unsigned int **v57;
  unsigned int *v58;
  unsigned int *v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int *v63;
  unsigned int *v64;
  unsigned int v65;
  unsigned int v66;
  float v67;
  unsigned int *v68;
  unsigned int **v69;
  BOOL v71;
  unsigned int **v72;
  unsigned int **v73;
  float v74;
  unsigned int *v75;
  unsigned int *v76;
  unsigned int **i;
  unsigned int **v78;
  unsigned int *v79;
  unsigned int *v80;
  unsigned int v81;
  unsigned int v82;
  float v83;
  unsigned int *v84;
  unsigned int *v85;
  unsigned int v86;
  unsigned int v87;
  int64_t v88;
  int64_t v89;
  uint64_t v90;
  unsigned int **v91;
  float v92;
  unsigned int **v93;
  float v94;
  unsigned int *v95;
  unsigned int **v96;
  unsigned int *v97;
  unsigned int *v98;
  unsigned int *v99;
  unsigned int v100;
  unsigned int v101;
  uint64_t v102;
  uint64_t v103;
  float v104;
  float v105;
  unsigned int *v106;
  unsigned int *v107;
  unsigned int v108;
  unsigned int v109;
  uint64_t v110;
  uint64_t v111;
  unsigned int *v112;
  uint64_t v113;
  uint64_t v114;
  unsigned int **v115;
  unsigned int **v116;
  uint64_t v117;
  uint64_t v118;
  float v119;
  unsigned int *v120;
  unsigned int *v121;
  unsigned int *v122;
  unsigned int v123;
  unsigned int v124;
  unsigned int **v125;
  unsigned int *v126;
  unsigned int *v127;
  unsigned int *v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int *v131;
  unsigned int *v132;
  unsigned int v133;
  unsigned int v134;
  uint64_t v135;
  unint64_t v136;
  unsigned int **v137;
  float v138;
  unsigned int *v139;
  unsigned int **v140;
  unsigned int *v141;
  unsigned int *v142;
  unsigned int *v143;
  unsigned int v144;
  unsigned int v145;
  float v146;
  unsigned int *v147;
  unsigned int *v148;
  unsigned int v149;
  unsigned int v150;
  unsigned int *v151;
  unsigned int v152;
  unsigned int v153;
  unsigned int **v155;
  float v156;
  unsigned int *v157;
  unsigned int *v158;
  unsigned int **v159;
  unsigned int **v160;
  unsigned int *v161;
  unsigned int *v162;
  unsigned int v163;
  unsigned int v164;
  float v165;
  float v166;
  unsigned int *v167;
  unsigned int v168;
  unsigned int v169;
  int64_t v170;

void TI::Favonius::SearchNodeLanguageThenGeometryExtensions::set_bound_on_score(TI::Favonius::SearchNodeLanguageThenGeometryExtensions *this)
{
  uint64_t v2;
  uint64_t v3;
  float v4;
  float v5;
  float v6;
  float v7;

  if (*((_BYTE *)this + 72))
  {
    v2 = *((_QWORD *)this + 6);
    if (v2)
    {
      v3 = *(_QWORD *)(*((_QWORD *)this + 7) + 8 * v2 - 8);
      v4 = (*(float (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
      v6 = *((float *)this + 10);
      v5 = *((float *)this + 11);
      v7 = v5 + (float)(v6 * logf(v4));
    }
    else
    {
      v7 = -INFINITY;
    }
  }
  else
  {
    v7 = *((float *)this + 11);
  }
  *((float *)this + 6) = v7;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TI::Favonius::SearchNodeLanguageThenGeometryExtensions::LetterExtensionComparator &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(unsigned int **a1, unsigned int **a2)
{
  uint64_t v4;
  _BOOL8 result;
  float v6;
  unsigned int *v7;
  unsigned int **v8;
  unsigned int **v9;
  int v10;
  float v11;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int **i;
  unsigned int **v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  float v20;
  unsigned int *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (*(float (**)(_QWORD))(*(_QWORD *)*(a2 - 1) + 24))(*(a2 - 1));
      if (v6 < (*(float (**)(unsigned int *))(*(_QWORD *)*a1 + 24))(*a1))
      {
        v7 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,TI::Favonius::SearchNodeLanguageExtensions::LetterExtensionComparator &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v8 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, a1 + 2);
      v9 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v10 = 0;
      break;
  }
  while (1)
  {
    v11 = (*(float (**)(unsigned int *))(*(_QWORD *)*v9 + 24))(*v9);
    if (v11 < (*(float (**)(unsigned int *))(*(_QWORD *)*v8 + 24))(*v8))
    {
      v12 = 0;
      v13 = *v9;
      *v9 = 0;
      for (i = v9; ; v12 = *i)
      {
        v15 = i;
        i = v8;
        v16 = *v8;
        *v8 = 0;
        *v15 = v16;
        if (v12)
        {
          v17 = v12 + 2;
          v18 = atomic_load(v12 + 2);
          if (v18 == 1)
          {
            (*(void (**)(unsigned int *))(*(_QWORD *)v12 + 248))(v12);
          }
          else
          {
            do
              v19 = __ldaxr(v17);
            while (__stlxr(v19 - 1, v17));
          }
        }
        if (v8 == a1)
          break;
        v20 = (*(float (**)(unsigned int *))(*(_QWORD *)v13 + 24))(v13);
        --v8;
        if (v20 >= (*(float (**)(_QWORD))(*(_QWORD *)*(i - 1) + 24))(*(i - 1)))
          goto LABEL_16;
      }
      i = a1;
LABEL_16:
      v21 = *i;
      *i = v13;
      if (v21)
      {
        v22 = v21 + 2;
        v23 = atomic_load(v21 + 2);
        if (v23 == 1)
        {
          (*(void (**)(unsigned int *))(*(_QWORD *)v21 + 248))(v21);
        }
        else
        {
          do
            v24 = __ldaxr(v22);
          while (__stlxr(v24 - 1, v22));
        }
      }
      if (++v10 == 8)
        return v9 + 1 == a2;
    }
    v8 = v9++;
    if (v9 == a2)
      return 1;
  }
}

uint64_t TI::Favonius::SearchNodeLanguageThenGeometryExtensions::SearchNodeLanguageThenGeometryExtensions(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;

  v5 = *a3;
  *a3 = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = -8388608;
  *(_QWORD *)a1 = &off_1EA103430;
  v6 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = v6;
  if (v6)
  {
    v7 = (unsigned int *)(v6 + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 + 1, v7));
  }
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::Vector((_QWORD *)(a1 + 48), (_QWORD *)(a2 + 48));
  *(_WORD *)(a1 + 72) = *(_WORD *)(a2 + 72);
  return a1;
}

unsigned int *TI::Favonius::SearchNodeLanguageThenGeometryExtensions::create@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, char a3@<W2>, uint64_t *a4@<X8>, float a5@<S0>)
{
  uint64_t v10;
  unsigned int *v11;
  unsigned int *result;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int *v16;

  v10 = operator new();
  v11 = *a2;
  *a2 = 0;
  v16 = v11;
  *a4 = TI::Favonius::SearchNodeLanguageThenGeometryExtensions::SearchNodeLanguageThenGeometryExtensions(v10, a1, (uint64_t *)&v16, a3, a5);
  result = v16;
  if (v16)
  {
    v13 = v16 + 2;
    v14 = atomic_load(v16 + 2);
    if (v14 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v16 + 8))();
    }
    else
    {
      do
        v15 = __ldaxr(v13);
      while (__stlxr(v15 - 1, v13));
    }
  }
  return result;
}

uint64_t TI::Favonius::SearchNodeLanguageThenGeometryExtensions::SearchNodeLanguageThenGeometryExtensions(uint64_t a1, uint64_t a2, uint64_t *a3, char a4, float a5)
{
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  float v11;

  v7 = *a3;
  *a3 = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 24) = -8388608;
  *(_QWORD *)a1 = &off_1EA103430;
  *(_QWORD *)(a1 + 32) = a2;
  v8 = (unsigned int *)(a2 + 8);
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 + 1, v8));
  v10 = *(_QWORD *)(a1 + 32);
  *(float *)(a1 + 40) = a5;
  v11 = *(float *)(v10 + 144) + (float)(a5 * *(float *)(v10 + 136));
  *(float *)(a1 + 44) = v11 + (*(float (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 73) = a4;
  TI::Favonius::SearchNodeLanguageThenGeometryExtensions::set_bound_on_score((TI::Favonius::SearchNodeLanguageThenGeometryExtensions *)a1);
  return a1;
}

uint64_t TI::Favonius::DictionaryHypothesis::create@<X0>(unsigned int **a1@<X0>, const KB::String *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  uint64_t result;

  v6 = operator new();
  result = TI::Favonius::DictionaryHypothesis::DictionaryHypothesis(v6, a1, a2);
  *a3 = result;
  return result;
}

uint64_t TI::Favonius::DictionaryHypothesis::DictionaryHypothesis(uint64_t a1, unsigned int **a2, const KB::String *a3)
{
  unsigned int *v5;
  unsigned int v6;
  KB::DictionaryCursors *v7;
  float v13;

  *(_DWORD *)a1 = 1;
  v5 = *a2;
  *(_QWORD *)(a1 + 8) = *a2;
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + 1, v5));
  v7 = KB::DictionaryCursors::DictionaryCursors((KB::DictionaryCursors *)(a1 + 16), *(const KB::DictionaryContainer **)(a1 + 8));
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 96) = _D0;
  if (*(_WORD *)a3)
  {
    v13 = KB::DictionaryCursors::advance(v7, *(const KB::DictionaryContainer **)(a1 + 8), a3);
    *(float *)(a1 + 96) = v13;
    *(float *)(a1 + 100) = v13;
  }
  return a1;
}

float TI::Favonius::DictionaryHypothesis::termination_probability(const KB::DictionaryContainer **this)
{
  return KB::DictionaryCursors::termination_probability((KB::DictionaryCursors *)(this + 2), this[1]);
}

void TI::Favonius::DictionaryHypothesis::_words(uint64_t a1, uint64_t *a2, int a3, char a4, char a5)
{
  const void *v8;
  float v11;
  const KB::Word *v12;
  uint64_t v13;
  float v14;
  uint64_t v15;
  unsigned int v16;
  float *v17;
  KB::DictionaryContainer *v18;
  TITokenID v19;
  uint64_t v20;
  unsigned int v21;
  unsigned __int16 *v22;
  _QWORD v24[6];
  char v25;
  char v26;
  const KB::Word *v27;
  const KB::Word *v28;
  uint64_t v29;
  __n128 (*v30)(_QWORD *, uint64_t);
  void (*v31)(uint64_t);
  _QWORD v32[3];
  const void *v33;
  const KB::Word **v34;
  void *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon)
  {
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v8 = *(const void **)(*(_QWORD *)(a1 + 72) + 40);
    v33 = v8;
    if (v8)
    {
      CFRetain(v8);
      v33 = v8;
      TI::Favonius::DictionaryHypothesis::merge_dynamic_words((TI::Favonius::DictionaryHypothesis *)a1, (uint64_t *)&v27, &v33, 5u, 0, a3, 0);
      CFRelease(v8);
    }
    else
    {
      TI::Favonius::DictionaryHypothesis::merge_dynamic_words((TI::Favonius::DictionaryHypothesis *)a1, (uint64_t *)&v27, &v33, 5u, 0, a3, 0);
    }
    std::vector<KB::Word>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Word*>,std::__wrap_iter<KB::Word*>>((KB::Word *)a2, a2[1], v27, v28, 0xEEEEEEEEEEEEEEEFLL * ((v28 - v27) >> 4));
    v34 = &v27;
  }
  else
  {
    v27 = 0;
    v28 = (const KB::Word *)&v27;
    v29 = 0x4002000000;
    v30 = __Block_byref_object_copy__13513;
    v31 = __Block_byref_object_dispose__13514;
    memset(v32, 0, sizeof(v32));
    KB::StaticDictionaryCursor::derive_words((KB::StaticDictionaryCursor *)(a1 + 16), (uint64_t)v32);
    KB::DictionaryCursors::probability_of_static_trie_given_termination((KB::DictionaryCursors *)(a1 + 16), *(const KB::DictionaryContainer **)(a1 + 8));
    v12 = v28;
    v13 = *((_QWORD *)v28 + 5);
    if (*((_QWORD *)v28 + 6) != v13)
    {
      v14 = v11;
      v15 = 0;
      v16 = 1;
      do
      {
        v17 = (float *)(v13 + 240 * v15);
        v17[12] = v14 * v17[12];
        v18 = *(KB::DictionaryContainer **)(a1 + 8);
        if (*((_QWORD *)v18 + 4) && (*(_BYTE *)(v13 + 240 * v15 + 135) & 0x10) != 0)
        {
          v19 = *(TITokenID *)(v13 + 240 * v15 + 136);
          KB::DictionaryContainer::affix_sentinel(v18, v19, 1, (uint64_t)&v34);
          v20 = (unsigned __int16)v34;
          if (v35 && BYTE6(v34) == 1)
            free(v35);
          if ((_DWORD)v20)
          {
            v21 = *(unsigned __int16 *)v17;
            if (v21 >= v20)
            {
              v22 = (unsigned __int16 *)*((_QWORD *)v17 + 1);
              if (!v22)
                v22 = (unsigned __int16 *)(v17 + 4);
              KB::String::String((KB::String *)&v34, (const char *)v22 + v20, (unsigned __int16)(v21 - v20));
              KB::String::operator=((KB::String *)v17, (KB::String *)&v34);
              if (v35 && BYTE6(v34) == 1)
                free(v35);
            }
          }
        }
        v15 = v16;
        v12 = v28;
        v13 = *((_QWORD *)v28 + 5);
      }
      while (0xEEEEEEEEEEEEEEEFLL * ((*((_QWORD *)v28 + 6) - v13) >> 4) > v16++);
    }
    if ((a4 & 1) != 0)
    {
      v24[0] = MEMORY[0x1E0C809B0];
      v24[1] = 0x40000000;
      v24[2] = ___ZNK2TI8Favonius20DictionaryHypothesis6_wordsERNSt3__16vectorIN2KB4WordENS2_9allocatorIS5_EEEEbbb_block_invoke;
      v24[3] = &unk_1EA103470;
      v24[4] = &v27;
      v24[5] = a1;
      v25 = a3;
      v26 = a5;
      (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 72) + 40))(*(_QWORD *)(a1 + 72), v24);
      v12 = v28;
    }
    std::vector<KB::Word>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Word*>,std::__wrap_iter<KB::Word*>>((KB::Word *)a2, a2[1], *((const KB::Word **)v12 + 5), *((const KB::Word **)v12 + 6), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((_QWORD *)v12 + 6) - *((_QWORD *)v12 + 5)) >> 4));
    _Block_object_dispose(&v27, 8);
    v34 = (const KB::Word **)v32;
  }
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v34);
}

void TI::Favonius::DictionaryHypothesis::merge_dynamic_words(TI::Favonius::DictionaryHypothesis *a1, uint64_t *a2, _QWORD *a3, unsigned int a4, uint64_t a5, int a6, int a7)
{
  int HasEntries;
  int v15;
  int v16;
  uint64_t *v17;
  float v18;
  uint64_t *v19;
  float v20;
  uint64_t **v21;
  float v22;
  uint64_t **v23;
  float v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  __n128 (*v28)(_QWORD *, uint64_t);
  void (*v29)(uint64_t);
  _QWORD v30[3];
  void **v31;

  if (a4 != 5 || TITransientLexiconManagerIsSupplementalLexiconSearchEnabled())
  {
    if (*a3)
    {
      HasEntries = LXCursorHasEntries();
      if (*a3)
      {
        if (HasEntries)
        {
          if (a4 > 2)
            v15 = 0;
          else
            v15 = *(_DWORD *)((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(*((_QWORD *)a1 + 1) + 24)
                                                                         + 48))(*(_QWORD *)(*((_QWORD *)a1 + 1) + 24), a5)+ 160);
          v25 = 0;
          v26 = &v25;
          v27 = 0x4002000000;
          v28 = __Block_byref_object_copy__4;
          v29 = __Block_byref_object_dispose__5;
          memset(v30, 0, sizeof(v30));
          LXCursorEnumerateEntries();
          v16 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 1) + 40) + 160);
          switch(a4)
          {
            case 0u:
              v19 = v26 + 5;
              v20 = TI::Favonius::DictionaryHypothesis::partial_probability_per_dynamic_usage(a1);
              TI::Favonius::DictionaryHypothesis::merge_persistent_custom_words(a2, v19, v15, v16, v20);
              break;
            case 1u:
            case 2u:
            case 3u:
              v17 = v26 + 5;
              v18 = TI::Favonius::DictionaryHypothesis::partial_probability_per_dynamic_usage(a1);
              TI::Favonius::DictionaryHypothesis::merge_transient_dynamic_words((KB::String **)a2, v17, a4, v15, v16, a6, a7, v18);
              break;
            case 4u:
              v21 = (uint64_t **)(v26 + 5);
              v22 = TI::Favonius::DictionaryHypothesis::partial_probability_per_dynamic_usage(a1);
              TI::Favonius::DictionaryHypothesis::merge_named_entity_words(a2, v21, v15, v16, a6, v22);
              break;
            case 5u:
              v23 = (uint64_t **)(v26 + 5);
              v24 = TI::Favonius::DictionaryHypothesis::partial_probability_per_dynamic_usage(a1);
              TI::Favonius::DictionaryHypothesis::merge_supplemental_item_words((uint64_t)a1, (uint64_t)a2, v23, v15, v16, v24);
              break;
            default:
              break;
          }
          _Block_object_dispose(&v25, 8);
          v31 = (void **)v30;
          std::vector<KB::retain_ptr<__CFString const*>>::__destroy_vector::operator()[abi:nn180100](&v31);
        }
      }
    }
  }
}

__n128 __Block_byref_object_copy__13513(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__13514(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 40);
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v1);
}

void ___ZNK2TI8Favonius20DictionaryHypothesis6_wordsERNSt3__16vectorIN2KB4WordENS2_9allocatorIS5_EEEEbbb_block_invoke(uint64_t a1, const void **a2, unsigned int a3, uint64_t a4)
{
  TI::Favonius::DictionaryHypothesis *v7;
  uint64_t v8;
  uint64_t *v9;
  const void *v10;
  const void *v11;

  v7 = *(TI::Favonius::DictionaryHypothesis **)(a1 + 40);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v9 = (uint64_t *)(v8 + 40);
  v10 = *a2;
  v11 = v10;
  if (v10)
  {
    CFRetain(v10);
    v11 = v10;
    TI::Favonius::DictionaryHypothesis::merge_dynamic_words(v7, v9, &v11, a3, a4, *(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49));
    CFRelease(v10);
  }
  else
  {
    TI::Favonius::DictionaryHypothesis::merge_dynamic_words(v7, (uint64_t *)(v8 + 40), &v11, a3, a4, *(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49));
  }
}

__n128 __Block_byref_object_copy__4(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 40);
  std::vector<KB::retain_ptr<__CFString const*>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

void ___ZNK2TI8Favonius20DictionaryHypothesis19merge_dynamic_wordsERNSt3__16vectorIN2KB4WordENS2_9allocatorIS5_EEEENS4_10retain_ptrIPK9_LXCursorEENS4_16DynamicEntryTypeEmbb_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  int64x2_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  const void *v23;
  const void *v24;
  _BYTE v25[240];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 40);
  if (cf)
    CFRetain(cf);
  if (*(_DWORD *)(a1 + 48) == 5
    || (v5 = *(_QWORD *)(v4 + 8),
        KB::Word::Word((uint64_t)v25, (uint64_t)cf, *(_DWORD *)(a1 + 52)),
        LOBYTE(v5) = KB::DynamicDictionary::is_word_in_supplemental_lexicon(*(KB::DynamicDictionary **)(v5 + 24), (const KB::String *)v25), KB::Word::~Word((KB::Word *)v25), (v5 & 1) == 0))
  {
    v6 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
    v8 = (_QWORD *)v6[6];
    v7 = v6[7];
    if ((unint64_t)v8 >= v7)
    {
      v10 = (_QWORD *)v6[5];
      v11 = v8 - v10;
      v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 61)
        abort();
      v13 = v7 - (_QWORD)v10;
      if (v13 >> 2 > v12)
        v12 = v13 >> 2;
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v14 = v12;
      if (v14)
      {
        if (v14 >> 61)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v15 = (char *)operator new(8 * v14);
      }
      else
      {
        v15 = 0;
      }
      v16 = &v15[8 * v11];
      *(_QWORD *)v16 = cf;
      if (cf)
      {
        CFRetain(cf);
        *(_QWORD *)v16 = cf;
        v10 = (_QWORD *)v6[5];
        v8 = (_QWORD *)v6[6];
      }
      v17 = &v15[8 * v14];
      v9 = v16 + 8;
      if (v8 == v10)
      {
        v19 = vdupq_n_s64((unint64_t)v8);
      }
      else
      {
        do
        {
          v18 = *--v8;
          *v8 = 0;
          *((_QWORD *)v16 - 1) = v18;
          v16 -= 8;
        }
        while (v8 != v10);
        v19 = *(int64x2_t *)(v6 + 5);
      }
      v6[5] = v16;
      v6[6] = v9;
      v6[7] = v17;
      v21 = v19.i64[1];
      v20 = (char *)v19.i64[0];
      if (v19.i64[1] != v19.i64[0])
      {
        v22 = (char *)v19.i64[1];
        do
        {
          v24 = (const void *)*((_QWORD *)v22 - 1);
          v22 -= 8;
          v23 = v24;
          if (v24)
            CFRelease(v23);
          *(_QWORD *)(v21 - 8) = 0;
          v21 = (uint64_t)v22;
        }
        while (v22 != v20);
      }
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v8 = cf;
      if (cf)
      {
        CFRetain(cf);
        *v8 = cf;
      }
      v9 = v8 + 1;
    }
    v6[6] = v9;
  }
  if (cf)
    CFRelease(cf);
}

float TI::Favonius::DictionaryHypothesis::partial_probability_per_dynamic_usage(TI::Favonius::DictionaryHypothesis *this)
{
  unsigned int v2;
  float v3;
  float v4;

  v2 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 9) + 88))(*((_QWORD *)this + 9), *(_QWORD *)(*((_QWORD *)this + 1) + 24));
  if (v2)
    v3 = 1.0 / (double)v2;
  else
    v3 = 0.0;
  KB::DictionaryCursors::probability_of_static_trie_given_termination((TI::Favonius::DictionaryHypothesis *)((char *)this + 16), *((const KB::DictionaryContainer **)this + 1));
  return v3 * (float)(1.0 - v4);
}

void TI::Favonius::DictionaryHypothesis::merge_transient_dynamic_words(KB::String **a1, uint64_t *a2, int a3, int a4, int a5, int a6, int a7, float a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  int64x2_t v20;
  char *v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  float v27;
  const __CFString *v28;
  void *v29;
  BOOL v30;
  __int8 *v31;
  const char *v32;
  KB::String *v33;
  KB::String *v34;
  char v35;
  int v36;
  _BOOL4 v37;
  int v38;
  int v39;
  char *v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  KB::Word *v44;
  uint64_t v45;
  uint64_t v46;
  int64x2_t v47;
  unint64_t v48;
  int64x2_t v53;
  char *v54;
  _BYTE v55[8];
  void *v56;
  size_t __n;
  void *v58[2];
  char *v59;
  char **v60;
  int v61;
  int v62;
  int v63;
  unint64_t v64;
  int64x2_t v65;
  unint64_t v66;
  char **v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  v53 = 0uLL;
  v54 = 0;
  v12 = *a2;
  v13 = a2[1];
  v14 = v13 - *a2;
  if (v13 != *a2)
  {
    if ((unint64_t)v14 >= 0x888888888888889)
      goto LABEL_82;
    v60 = &v54;
    v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v14 >> 3);
    __n = (size_t)v15;
    v58[0] = v15;
    v17 = &v15[240 * v16];
    v58[1] = v15;
    v59 = v17;
    v18 = v53.i64[1];
    if (v53.i64[1] == v53.i64[0])
    {
      v20 = vdupq_n_s64(v53.u64[1]);
      v19 = (uint64_t)v15;
    }
    else
    {
      v19 = (uint64_t)v15;
      do
      {
        v19 -= 240;
        v18 -= 240;
        KB::Word::Word(v19, v18);
      }
      while (v18 != v53.i64[0]);
      v20 = v53;
      v15 = (char *)v58[1];
      v17 = v59;
    }
    v53.i64[0] = v19;
    v53.i64[1] = (uint64_t)v15;
    *(int64x2_t *)v58 = v20;
    v21 = v54;
    v54 = v17;
    v59 = v21;
    __n = v20.i64[0];
    std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&__n);
    v12 = *a2;
    v13 = a2[1];
  }
  if (v13 == v12)
    goto LABEL_81;
  v22 = 0;
  v23 = 0;
  if (a3 == 2)
    v24 = 0x80000000;
  else
    v24 = 0x10000;
  if (a3 == 1)
    v25 = 0x20000;
  else
    v25 = v24;
  do
  {
    v26 = *(_QWORD *)(v12 + 8 * v22);
    if (v26)
      v27 = (float)LXEntryGetUsageCount() * a8;
    else
      v27 = 0.0;
    if ((a3 - 1) <= 1)
    {
      if ((TIIsLexiconIDEnglish(a4) & 1) != 0)
      {
LABEL_38:
        a4 = 0;
        goto LABEL_39;
      }
      KB::String::String((KB::String *)&__n, "'s");
      v28 = (const __CFString *)LXEntryCopyStoredString();
      KB::utf8_string(v28, (uint64_t)&v64);
      v29 = (void *)v65.i64[0];
      if ((unsigned __int16)__n <= (unsigned __int16)v64)
      {
        v31 = &v65.i8[8];
        if (v65.i64[0])
          v31 = (__int8 *)v65.i64[0];
        if (v58[0])
          v32 = (const char *)v58[0];
        else
          v32 = (const char *)&v58[1];
        v30 = strncmp(&v31[(unsigned __int16)v64 - (unint64_t)(unsigned __int16)__n], v32, (unsigned __int16)__n) == 0;
        if (!v29)
        {
LABEL_32:
          if (v28)
            CFRelease(v28);
          if (v58[0] && BYTE6(__n) == 1)
            free(v58[0]);
          if (v30)
            goto LABEL_80;
          goto LABEL_38;
        }
      }
      else
      {
        v30 = 0;
        if (!v65.i64[0])
          goto LABEL_32;
      }
      if (BYTE6(v64) == 1)
        free(v29);
      goto LABEL_32;
    }
LABEL_39:
    TI::Favonius::DictionaryHypothesis::word_from_dynamic_entry(v26, a3, a4, a5, (uint64_t)&__n, v27);
    if (a6)
    {
      if (v62)
      {
        TI::Favonius::DictionaryHypothesis::decapitalize_word_matching_previous_words((KB::String *)&__n, *a1, a1[1], a3);
      }
      else if ((v61 & 0x800012) == 0 && (v61 & 0x2080) != 0x80 && (v61 & 0x2042000) != 0x2000000)
      {
        TI::Favonius::DictionaryHypothesis::decapitalize_previous_words_matching_word(*a1, a1[1], (KB::String *)&__n);
      }
    }
    if (!a7 || (v33 = *a1, v34 = a1[1], *a1 == v34))
    {
LABEL_62:
      if (v53.i64[1] < (unint64_t)v54)
      {
        v40 = (char *)KB::Word::Word((KB::Word *)v53.i64[1], (const KB::Word *)&__n) + 240;
LABEL_78:
        v53.i64[1] = (uint64_t)v40;
        goto LABEL_79;
      }
      v41 = 0xEEEEEEEEEEEEEEEFLL * ((v53.i64[1] - v53.i64[0]) >> 4) + 1;
      if (v41 <= 0x111111111111111)
      {
        if (0xDDDDDDDDDDDDDDDELL * ((uint64_t)&v54[-v53.i64[0]] >> 4) > v41)
          v41 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)&v54[-v53.i64[0]] >> 4);
        if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)&v54[-v53.i64[0]] >> 4) >= 0x88888888888888)
          v42 = 0x111111111111111;
        else
          v42 = v41;
        v67 = &v54;
        if (v42)
          v42 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v42);
        else
          v43 = 0;
        v44 = (KB::Word *)(v42 + 16 * ((v53.i64[1] - v53.i64[0]) >> 4));
        v64 = v42;
        v65.i64[0] = (uint64_t)v44;
        v66 = v42 + 240 * v43;
        KB::Word::Word(v44, (const KB::Word *)&__n);
        v40 = (char *)v44 + 240;
        v65.i64[1] = (uint64_t)v44 + 240;
        v45 = v53.i64[1];
        v46 = v65.i64[0];
        if (v53.i64[1] == v53.i64[0])
        {
          v47 = vdupq_n_s64(v53.u64[1]);
        }
        else
        {
          do
          {
            v45 -= 240;
            v46 = KB::Word::Word(v46 - 240, v45);
          }
          while (v45 != v53.i64[0]);
          v47 = v53;
          v40 = (char *)v65.i64[1];
        }
        v53.i64[0] = v46;
        v53.i64[1] = (uint64_t)v40;
        v65 = v47;
        v48 = (unint64_t)v54;
        v54 = (char *)v66;
        v66 = v48;
        v64 = v47.i64[0];
        std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v64);
        goto LABEL_78;
      }
LABEL_82:
      abort();
    }
    v35 = 0;
    do
    {
      v36 = *((_DWORD *)v33 + 26);
      if ((v36 & 0x40000) == 0 && (((v36 & 0x2000000) == 0) & v35) != 0)
        goto LABEL_59;
      KB::Word::capitalized_string(v33, (uint64_t)&v64);
      KB::Word::capitalized_string((KB::Word *)&__n, (uint64_t)v55);
      v37 = KB::String::equal((KB::String *)&v64, (const KB::String *)v55, 1);
      if (v56 && v55[6] == 1)
        free(v56);
      if (v65.i64[0] && BYTE6(v64) == 1)
        free((void *)v65.i64[0]);
      if (v37)
      {
        v38 = *((_DWORD *)v33 + 26);
        *((float *)v33 + 12) = v27 + *((float *)v33 + 12);
        v39 = v63 + *((_DWORD *)v33 + 31);
        *((_DWORD *)v33 + 31) = v39;
        *((_DWORD *)v33 + 26) = v38 & 0xFFFFDFFF | v25 | ((v39 != 0) << 13);
LABEL_59:
        v35 = 1;
      }
      v33 = (KB::String *)((char *)v33 + 240);
    }
    while (v33 != v34);
    if ((v35 & 1) == 0)
      goto LABEL_62;
LABEL_79:
    KB::Word::~Word((KB::Word *)&__n);
LABEL_80:
    v12 = *a2;
    v22 = ++v23;
  }
  while (v23 < (unint64_t)((a2[1] - *a2) >> 3));
LABEL_81:
  std::vector<KB::Word>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Word*>,std::__wrap_iter<KB::Word*>>((KB::Word *)a1, (uint64_t)a1[1], (const KB::Word *)v53.i64[0], (const KB::Word *)v53.i64[1], 0xEEEEEEEEEEEEEEEFLL * ((v53.i64[1] - v53.i64[0]) >> 4));
  __n = (size_t)&v53;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&__n);
}

void TI::Favonius::DictionaryHypothesis::merge_persistent_custom_words(uint64_t *a1, uint64_t *a2, int a3, int a4, float a5)
{
  uint64_t v10;
  float v11;
  char v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int v18;

  v10 = *a1;
  v11 = 0.0;
  while (v10 != a1[1])
  {
    if ((*(_BYTE *)(v10 + 106) & 4) != 0 && *(_DWORD *)(v10 + 136) == a3)
      v11 = v11 + *(float *)(v10 + 48);
    v10 += 240;
  }
  if (a2[1] != *a2)
  {
    v12 = v11 == 0.0;
    v13 = 1;
    do
    {
      v12 |= LXEntryGetUsageCount() > 5;
      v14 = v13;
      v15 = *a2;
      v16 = a2[1];
      ++v13;
    }
    while (v14 < (v16 - *a2) >> 3);
    if (v16 != v15)
    {
      v17 = 0;
      v18 = 1;
      do
      {
        v11 = v11
            + TI::Favonius::DictionaryHypothesis::merge_persistent_custom_entry(a1, *(_QWORD *)(v15 + 8 * v17), a3, a4, v12 & 1, a5, v11);
        v17 = v18;
        v15 = *a2;
        ++v18;
      }
      while (v17 < (a2[1] - *a2) >> 3);
    }
  }
}

void TI::Favonius::DictionaryHypothesis::merge_named_entity_words(uint64_t *a1, uint64_t **a2, int a3, int a4, int a5, float a6)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v12;
  float v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  int v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  char v24;
  KB::Word *v25;
  unint64_t v26;
  char *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t *v34;
  _BYTE v36[8];
  void *v37;
  _BYTE v38[8];
  void *v39;
  _BYTE v40[8];
  void *v41;
  unsigned __int16 v42[2];
  __int16 v43;
  int v44;
  int v45;
  unint64_t v46;
  char *v47;
  char *v48;
  unint64_t v49;
  uint64_t *v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  v7 = a2[1];
  if (*a2 != v7)
  {
    v34 = a1 + 2;
    while (1)
    {
      v12 = *v6;
      if (*v6)
        break;
LABEL_62:
      if (++v6 == v7)
        return;
    }
    v13 = (float)LXEntryGetUsageCount() * a6;
    TI::Favonius::DictionaryHypothesis::word_from_dynamic_entry(v12, 4, a3, a4, (uint64_t)v42, v13);
    v14 = _os_feature_enabled_impl();
    v16 = *a1;
    v15 = a1[1];
    if (v14)
    {
      while (v16 != v15)
      {
        if (KB::String::equal((KB::String *)v16, (const KB::String *)v42, 0))
          goto LABEL_61;
        v16 += 240;
      }
      goto LABEL_48;
    }
    if (v16 == v15)
    {
      v17 = 0;
      goto LABEL_31;
    }
    v17 = 0;
    while (1)
    {
      KB::Word::capitalized_string((KB::Word *)v16, (uint64_t)&v46);
      KB::Word::capitalized_string((KB::Word *)v42, (uint64_t)v40);
      v18 = *(_DWORD *)(v16 + 104);
      if ((v18 & 0x40000) != 0 || (((v18 & 0x2000000) == 0) & v17) == 0)
      {
        KB::Word::capitalized_string((KB::Word *)v16, (uint64_t)v38);
        KB::Word::capitalized_string((KB::Word *)v42, (uint64_t)v36);
        v19 = KB::String::equal((KB::String *)v38, (const KB::String *)v36, 1);
        if (v37 && v36[6] == 1)
          free(v37);
        if (v39 && v38[6] == 1)
          free(v39);
        if (!v19)
          goto LABEL_21;
        *(float *)(v16 + 48) = v13 + *(float *)(v16 + 48);
        *(_DWORD *)(v16 + 124) += v45;
        *(_DWORD *)(v16 + 104) = *(_DWORD *)(v16 + 104) & 0xFFFFDFFF | ((v45 != 0) << 13);
      }
      v17 = 1;
LABEL_21:
      if (v41 && v40[6] == 1)
        free(v41);
      if (v47 && BYTE6(v46) == 1)
        free(v47);
      v16 += 240;
      if (v16 == v15)
      {
        if ((v17 & 1) != 0)
          goto LABEL_47;
LABEL_31:
        if (!a5 || !v44)
        {
LABEL_47:
          if ((v17 & 1) != 0)
          {
LABEL_61:
            KB::Word::~Word((KB::Word *)v42);
            goto LABEL_62;
          }
LABEL_48:
          v25 = (KB::Word *)a1[1];
          v26 = a1[2];
          if ((unint64_t)v25 >= v26)
          {
            v28 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v25 - *a1) >> 4);
            v29 = v28 + 1;
            if (v28 + 1 > 0x111111111111111)
              abort();
            v30 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v26 - *a1) >> 4);
            if (2 * v30 > v29)
              v29 = 2 * v30;
            if (v30 >= 0x88888888888888)
              v31 = 0x111111111111111;
            else
              v31 = v29;
            v50 = v34;
            if (v31)
              v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v31);
            else
              v32 = 0;
            v33 = (char *)(v31 + 240 * v28);
            v46 = v31;
            v47 = v33;
            v49 = v31 + 240 * v32;
            KB::Word::Word((KB::Word *)v33, (const KB::Word *)v42);
            v48 = v33 + 240;
            std::vector<KB::Word>::__swap_out_circular_buffer(a1, &v46);
            v27 = (char *)a1[1];
            std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v46);
          }
          else
          {
            v27 = (char *)KB::Word::Word(v25, (const KB::Word *)v42) + 240;
          }
          a1[1] = (uint64_t)v27;
          goto LABEL_61;
        }
        v21 = *a1;
        v20 = a1[1];
        while (2)
        {
          if (v21 == v20)
            goto LABEL_47;
          v22 = *(_DWORD *)(v21 + 104);
          if ((v22 & 0x40000) != 0 || (((v22 & 0x2000000) == 0) & v17) == 0)
          {
            if (!KB::String::equal((KB::String *)v21, (const KB::String *)v42, 0))
              goto LABEL_46;
            v23 = *(_DWORD *)(v21 + 104);
            if ((v23 & 0x84) != 0 || *(_DWORD *)(v21 + 120))
            {
              v24 = v43;
              if (!v43)
              {
                KB::String::compute_length(v42);
                v24 = v43;
              }
              if (((-1 << v24) | v44) == 0xFFFFFFFF)
              {
                v23 = *(_DWORD *)(v21 + 104);
                goto LABEL_44;
              }
LABEL_46:
              v21 += 240;
              continue;
            }
LABEL_44:
            *(float *)(v21 + 48) = v13 + *(float *)(v21 + 48);
            *(_DWORD *)(v21 + 124) += v45;
            *(_DWORD *)(v21 + 104) = v23 & 0xFFFFDFFF | ((v45 != 0) << 13);
          }
          break;
        }
        v17 = 1;
        goto LABEL_46;
      }
    }
  }
}

void TI::Favonius::DictionaryHypothesis::merge_supplemental_item_words(uint64_t a1, uint64_t a2, uint64_t **a3, int a4, int a5, float a6)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v13;
  unsigned int UsageCount;
  const KB::String *v15;
  _LXLexicon *v16;
  _LXLexicon *v17;
  uint64_t v18;
  _LXLexicon *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  KB::Word *v24;
  unint64_t v25;
  char *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  KB::Word *v32;
  uint64_t v33;
  _QWORD v34[5];
  _BYTE v35[240];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v6 = *a3;
  v7 = a3[1];
  if (*a3 != v7)
  {
    v33 = a2 + 16;
    do
    {
      v13 = *v6;
      if (*v6)
      {
        UsageCount = LXEntryGetUsageCount();
        TI::Favonius::DictionaryHypothesis::word_from_dynamic_entry(v13, 5, a4, a5, (uint64_t)v35, (float)UsageCount * a6);
        v16 = *(_LXLexicon **)a2;
        v17 = *(_LXLexicon **)(a2 + 8);
        v18 = (uint64_t)v17;
        if (*(_LXLexicon **)a2 != v17)
        {
          while (KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + 72), v16, (const KB::String *)v35, v15))
          {
            v16 = (_LXLexicon *)((char *)v16 + 240);
            if (v16 == v17)
              goto LABEL_14;
          }
        }
        if (v16 != v17)
        {
          v19 = (_LXLexicon *)((char *)v16 + 240);
          v18 = (uint64_t)v16;
          while (v19 != v17)
          {
            if (KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + 72), v19, (const KB::String *)v35, v15))
            {
              KB::String::operator=(v18, (KB::String *)v19);
              KB::ByteString::operator=((unsigned __int16 *)(v18 + 32), (unsigned __int16 *)v19 + 16);
              v20 = *((_QWORD *)v19 + 6);
              *(_DWORD *)(v18 + 56) = *((_DWORD *)v19 + 14);
              *(_QWORD *)(v18 + 48) = v20;
              KB::String::operator=(v18 + 64, (KB::String *)((char *)v19 + 64));
              v21 = *((_OWORD *)v19 + 6);
              v22 = *((_OWORD *)v19 + 7);
              v23 = *((_OWORD *)v19 + 9);
              *(_OWORD *)(v18 + 128) = *((_OWORD *)v19 + 8);
              *(_OWORD *)(v18 + 144) = v23;
              *(_OWORD *)(v18 + 96) = v21;
              *(_OWORD *)(v18 + 112) = v22;
              KB::String::operator=(v18 + 160, (KB::String *)((char *)v19 + 160));
              *(_BYTE *)(v18 + 192) = *((_BYTE *)v19 + 192);
              std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(v18 + 200, (uint64_t *)v19 + 25);
              v18 += 240;
            }
            v19 = (_LXLexicon *)((char *)v19 + 240);
          }
        }
LABEL_14:
        std::vector<KB::Word>::erase(a2, v18, *(KB::Word **)(a2 + 8));
        v24 = *(KB::Word **)(a2 + 8);
        v25 = *(_QWORD *)(a2 + 16);
        if ((unint64_t)v24 >= v25)
        {
          v27 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v24 - *(_QWORD *)a2) >> 4);
          v28 = v27 + 1;
          if (v27 + 1 > 0x111111111111111)
            abort();
          v29 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v25 - *(_QWORD *)a2) >> 4);
          if (2 * v29 > v28)
            v28 = 2 * v29;
          if (v29 >= 0x88888888888888)
            v30 = 0x111111111111111;
          else
            v30 = v28;
          v34[4] = v33;
          if (v30)
            v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v30);
          else
            v31 = 0;
          v32 = (KB::Word *)(v30 + 240 * v27);
          v34[0] = v30;
          v34[1] = v32;
          v34[3] = v30 + 240 * v31;
          KB::Word::Word(v32, (const KB::Word *)v35);
          v34[2] = (char *)v32 + 240;
          std::vector<KB::Word>::__swap_out_circular_buffer((uint64_t *)a2, v34);
          v26 = *(char **)(a2 + 8);
          std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)v34);
        }
        else
        {
          v26 = (char *)KB::Word::Word(v24, (const KB::Word *)v35) + 240;
        }
        *(_QWORD *)(a2 + 8) = v26;
        KB::Word::~Word((KB::Word *)v35);
      }
      ++v6;
    }
    while (v6 != v7);
  }
}

void TI::Favonius::DictionaryHypothesis::word_from_dynamic_entry(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X8>, float a6@<S0>)
{
  unsigned int v11;
  int v12;
  _BYTE v13[16];
  _QWORD *v14;
  int v15;

  KB::Word::Word(a5, a1, a3);
  *(_DWORD *)(a5 + 104) &= 0xFFFFFF79;
  if ((a3 + 1) >= 2 && a3 != a4)
    *(_BYTE *)(a5 + 192) = 1;
  KB::Word::move_capitalization_to_bits((KB::Word *)a5);
  switch(a2)
  {
    case 0:
      v11 = *(_DWORD *)(a5 + 104) & 0xFFFFDFFF | ((*(_DWORD *)(a5 + 124) > 1u) << 13) | 0x2000000;
      goto LABEL_16;
    case 1:
      v11 = *(_DWORD *)(a5 + 104) | 0x20000;
      goto LABEL_16;
    case 2:
      v11 = *(_DWORD *)(a5 + 104) | 0x80000000;
      goto LABEL_16;
    case 3:
      v11 = *(_DWORD *)(a5 + 104) | 0x10000;
      goto LABEL_16;
    case 4:
      v11 = *(_DWORD *)(a5 + 104) | 0x100;
      goto LABEL_16;
    case 5:
      TILXEntryGetSupplementalItemIdentifiers((uint64_t)v13);
      if ((_BYTE *)(a5 + 200) != v13)
      {
        *(_DWORD *)(a5 + 232) = v15;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((_QWORD *)(a5 + 200), v14);
      }
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)v13);
      if (TILXEntryIsPartOfHyphenatedWord())
        v12 = 16;
      else
        v12 = 0;
      v11 = *(_DWORD *)(a5 + 104) & 0xFFFFFFEF | v12;
LABEL_16:
      *(_DWORD *)(a5 + 104) = v11;
      break;
    default:
      break;
  }
  *(float *)(a5 + 48) = a6;
  *(_DWORD *)(a5 + 140) = 0;
}

float TI::Favonius::DictionaryHypothesis::merge_persistent_custom_entry(uint64_t *a1, uint64_t a2, int a3, int a4, int a5, float a6, float a7)
{
  unsigned int UsageCount;
  float v15;
  uint64_t v16;
  const KB::String *v17;
  uint64_t v18;
  float v19;
  int v20;
  _BOOL4 v21;
  unsigned int v23;
  unsigned int MetaFlags;
  int v25;
  unsigned int v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  BOOL v49;
  BOOL v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t *v56;
  _BYTE v57[240];
  _BYTE v58[8];
  void *v59;
  _BYTE v60[136];
  uint64_t v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  UsageCount = LXEntryGetUsageCount();
  v15 = (float)UsageCount * a6;
  KB::Word::Word((uint64_t)v60, a2, a3);
  KB::Word::capitalized_string((KB::Word *)v60, (uint64_t)v58);
  v51 = 0;
  v16 = TI::Favonius::DictionaryHypothesis::best_static_match_for_dynamic_string(a1, (KB::String *)v58, a3, &v51);
  if (a1[1] == v16)
    goto LABEL_19;
  v18 = v16;
  v19 = 0.0;
  if (KB::string_has_only_uppercase_characters((KB *)v58, v17))
    goto LABEL_59;
  v20 = *(_DWORD *)(v18 + 104);
  v21 = v51;
  if ((v20 & 0x84) != 0 && !v51)
  {
LABEL_19:
    if (a7 != 0.0 && !TI::Favonius::DictionaryHypothesis::should_create_word_from_persistent_custom_entry(a2, a5))
    {
      v35 = *a1;
      v36 = a1[1];
      while (v35 != v36)
      {
        if ((*(_BYTE *)(v35 + 106) & 4) != 0 && *(_DWORD *)(v35 + 136) == a3)
          *(float *)(v35 + 48) = *(float *)(v35 + 48) + (float)(v15 * (float)(*(float *)(v35 + 48) / a7));
        v35 += 240;
      }
      goto LABEL_58;
    }
    TI::Favonius::DictionaryHypothesis::word_from_dynamic_entry(a2, 0, a3, a4, (uint64_t)v57, v15);
    v27 = a1[2];
    v28 = a1[1];
    if (v28 >= v27)
    {
      v30 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v28 - *a1) >> 4);
      if (v30 + 1 > 0x111111111111111)
        goto LABEL_66;
      v31 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v27 - *a1) >> 4);
      v32 = 2 * v31;
      if (2 * v31 <= v30 + 1)
        v32 = v30 + 1;
      if (v31 >= 0x88888888888888)
        v33 = 0x111111111111111;
      else
        v33 = v32;
      v56 = a1 + 2;
      if (v33)
        v33 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v33);
      else
        v34 = 0;
      v37 = v33 + 240 * v30;
      v52 = v33;
      v53 = v37;
      v55 = v33 + 240 * v34;
      KB::Word::Word(v37, (uint64_t)v57);
      v54 = v37 + 240;
      std::vector<KB::Word>::__swap_out_circular_buffer(a1, &v52);
      v29 = a1[1];
      std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v52);
    }
    else
    {
      v29 = KB::Word::Word(v28, (uint64_t)v57) + 240;
    }
    a1[1] = v29;
    KB::Word::~Word((KB::Word *)v57);
    v19 = 0.0;
    goto LABEL_59;
  }
  if ((v20 & 0x80) != 0)
    v23 = 2;
  else
    v23 = 1;
  if (a5)
  {
    *(float *)(v18 + 48) = v15 + *(float *)(v18 + 48);
  }
  else
  {
    v38 = *a1;
    v39 = a1[1];
    while (v38 != v39)
    {
      if ((*(_BYTE *)(v38 + 106) & 4) != 0 && *(_DWORD *)(v38 + 136) == a3)
        *(float *)(v38 + 48) = *(float *)(v38 + 48) + (float)(v15 * (float)(*(float *)(v38 + 48) / a7));
      v38 += 240;
    }
  }
  if (v21)
  {
    *(_DWORD *)(v18 + 124) = UsageCount;
    *(_DWORD *)(v18 + 128) = LXEntryGetPenaltyCount();
    MetaFlags = LXEntryGetMetaFlags();
    v25 = *(_DWORD *)(v18 + 104);
    v26 = v25 & 0xFBFFFFFF | (((MetaFlags >> 26) & 1) << 26);
    *(_DWORD *)(v18 + 104) = v26;
    if (!*(_DWORD *)(v18 + 140))
      *(_QWORD *)(v18 + 136) = v61;
    if (UsageCount > v23 && (v25 & 0x2000) == 0)
      *(_DWORD *)(v18 + 104) = v26 | 0x2000;
    goto LABEL_58;
  }
  TI::Favonius::DictionaryHypothesis::word_from_dynamic_entry(a2, 0, a3, a4, (uint64_t)v57, 0.0);
  v40 = a1[2];
  v41 = a1[1];
  if (v41 >= v40)
  {
    v43 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v41 - *a1) >> 4);
    if (v43 + 1 <= 0x111111111111111)
    {
      v44 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v40 - *a1) >> 4);
      v45 = 2 * v44;
      if (2 * v44 <= v43 + 1)
        v45 = v43 + 1;
      if (v44 >= 0x88888888888888)
        v46 = 0x111111111111111;
      else
        v46 = v45;
      v56 = a1 + 2;
      if (v46)
        v46 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v46);
      else
        v47 = 0;
      v48 = v46 + 240 * v43;
      v52 = v46;
      v53 = v48;
      v55 = v46 + 240 * v47;
      KB::Word::Word(v48, (uint64_t)v57);
      v54 = v48 + 240;
      std::vector<KB::Word>::__swap_out_circular_buffer(a1, &v52);
      v42 = a1[1];
      std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v52);
      goto LABEL_57;
    }
LABEL_66:
    abort();
  }
  v42 = KB::Word::Word(v41, (uint64_t)v57) + 240;
LABEL_57:
  a1[1] = v42;
  KB::Word::~Word((KB::Word *)v57);
LABEL_58:
  v19 = v15;
LABEL_59:
  if (v59)
    v49 = v58[6] == 1;
  else
    v49 = 0;
  if (v49)
    free(v59);
  KB::Word::~Word((KB::Word *)v60);
  return v19;
}

uint64_t TI::Favonius::DictionaryHypothesis::best_static_match_for_dynamic_string(uint64_t *a1, KB::String *a2, int a3, BOOL *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  void *v14;
  _BYTE v15[8];
  void *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v7 = a1[1];
  if (*a1 != v7)
  {
    v10 = a1[1];
    while (1)
    {
      if ((*(_BYTE *)(v6 + 106) & 4) != 0
        && (a3 == -2 || *(_DWORD *)(v6 + 136) == a3)
        && KB::String::equal((KB::String *)v6, a2, 0))
      {
        KB::Word::capitalized_string((KB::Word *)v6, (uint64_t)v15);
        if (v15 == (_BYTE *)a2)
        {
          v14 = (void *)*((_QWORD *)a2 + 1);
          if (v14 && *((_BYTE *)a2 + 6) == 1)
            free(v14);
          goto LABEL_18;
        }
        v11 = KB::String::equal((KB::String *)v15, a2, 1);
        if (v16 && v15[6] == 1)
          free(v16);
        if (v11)
          goto LABEL_18;
        if (!*(_DWORD *)(v6 + 120))
          v10 = v6;
      }
      v6 += 240;
      if (v6 == a1[1])
        goto LABEL_17;
    }
  }
  v10 = a1[1];
LABEL_17:
  v6 = v7;
LABEL_18:
  v12 = a1[1];
  if (a4)
    *a4 = v6 != v12;
  if (v6 == v12)
    return v10;
  else
    return v6;
}

BOOL TI::Favonius::DictionaryHypothesis::should_create_word_from_persistent_custom_entry(uint64_t a1, char a2)
{
  int UsageCount;
  _BOOL8 v4;
  const __CFString *v5;
  const KB::String *v6;
  _BYTE v8[8];
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  UsageCount = LXEntryGetUsageCount();
  if ((a2 & 1) == 0 && UsageCount < 3)
    return 0;
  v5 = (const __CFString *)LXEntryCopyStoredString();
  KB::utf8_string(v5, (uint64_t)v8);
  v4 = !KB::string_has_word_medial_punctuation((KB *)v8, v6);
  if (v9 && v8[6] == 1)
    free(v9);
  if (v5)
    CFRelease(v5);
  return v4;
}

uint64_t TI::Favonius::DictionaryHypothesis::decapitalize_word_matching_previous_words(KB::String *a1, KB::String *a2, KB::String *a3, int a4)
{
  KB::String *v5;
  int v7;
  _QWORD v9[2];
  BOOL (*v10)(uint64_t, KB::String *);
  void *v11;
  KB::String *v12;
  int v13;

  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v10 = ___ZN2TI8Favonius20DictionaryHypothesis41decapitalize_word_matching_previous_wordsERN2KB4WordENSt3__111__wrap_iterIPKS3_EES9_NS2_16DynamicEntryTypeE_block_invoke;
  v11 = &__block_descriptor_tmp_2_13519;
  v13 = a4;
  v12 = a1;
  if (a2 == a3)
    return 0;
  v5 = a2;
  while ((((uint64_t (*)(_QWORD *, KB::String *))v10)(v9, v5) & 1) == 0)
  {
    v5 = (KB::String *)((char *)v5 + 240);
    if (v5 == a3)
      return 0;
  }
  if (v5 == a3)
    return 0;
  *((_DWORD *)a1 + 30) = 0;
  *((_DWORD *)a1 + 26) &= ~1u;
  KB::String::operator=(a1, v5);
  v7 = *((_DWORD *)v5 + 30);
  *((_DWORD *)a1 + 30) = v7;
  *((_DWORD *)a1 + 26) = *((_DWORD *)a1 + 26) & 0xFFFFFFFE | (v7 == 1);
  return 1;
}

KB::String *TI::Favonius::DictionaryHypothesis::decapitalize_previous_words_matching_word(KB::String *this, KB::String *a2, KB::String *a3)
{
  KB::String *v5;

  if (this != a2)
  {
    v5 = this;
    do
    {
      if (*(_WORD *)v5)
      {
        this = (KB::String *)KB::String::equal(v5, a3, 0);
        if ((_DWORD)this)
        {
          *((_DWORD *)v5 + 30) = 0;
          *((_DWORD *)v5 + 26) &= ~1u;
          this = KB::String::operator=(v5, a3);
        }
      }
      v5 = (KB::String *)((char *)v5 + 240);
    }
    while (v5 != a2);
  }
  return this;
}

BOOL ___ZN2TI8Favonius20DictionaryHypothesis41decapitalize_word_matching_previous_wordsERN2KB4WordENSt3__111__wrap_iterIPKS3_EES9_NS2_16DynamicEntryTypeE_block_invoke(uint64_t a1, KB::String *this)
{
  return *(_WORD *)this
      && (!*((_DWORD *)this + 30) || (*(_DWORD *)(a1 + 40) - 1) <= 1)
      && (*((_DWORD *)this + 26) & 2) == 0
      && (*((_DWORD *)this + 26) & 0x2080) != 0x80
      && KB::String::equal(this, *(const KB::String **)(a1 + 32), 0);
}

void TI::Favonius::DictionaryHypothesis::words(uint64_t a1, uint64_t *a2, char a3, int a4)
{
  TI::Favonius::DictionaryHypothesis::_words(a1, a2, a4, 1, a3);
}

void TI::Favonius::DictionaryHypothesis::static_words(uint64_t a1, uint64_t *a2)
{
  TI::Favonius::DictionaryHypothesis::_words(a1, a2, 0, 0, 0);
}

void TI::Favonius::DictionaryHypothesis::affix_sentinel(TI::Favonius::DictionaryHypothesis *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  int v7;
  BOOL v8;

  if (*(_QWORD *)(*((_QWORD *)this + 1) + 32))
  {
    v4 = *((_QWORD *)this + 7);
    if (v4)
    {
      v5 = 8 * v4 - 8;
      v6 = (char *)this + 16;
      do
      {
        v6 += 8;
        v7 = LXCursorTerminatesWordStem();
        if (v7)
          v8 = 1;
        else
          v8 = v5 == 0;
        v5 -= 8;
      }
      while (!v8);
      if (v7)
        KB::StaticDictionaryCursor::derive_word_ids((uint64_t)this + 16);
    }
  }
  *(_DWORD *)a2 = 0x100000;
  *(_WORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 6) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 16) = 0;
}

TI::Favonius::DictionaryHypothesis *TI::Favonius::DictionaryHypothesis::extend@<X0>(TI::Favonius::DictionaryHypothesis *this@<X0>, unsigned int a2@<W1>, TI::Favonius::DictionaryHypothesis **a3@<X8>)
{
  TI::Favonius::DictionaryHypothesis *v6;
  TI::Favonius::DictionaryHypothesis *result;

  v6 = (TI::Favonius::DictionaryHypothesis *)operator new();
  result = TI::Favonius::DictionaryHypothesis::DictionaryHypothesis(v6, this, a2);
  *a3 = result;
  return result;
}

TI::Favonius::DictionaryHypothesis *TI::Favonius::DictionaryHypothesis::DictionaryHypothesis(TI::Favonius::DictionaryHypothesis *this, const TI::Favonius::DictionaryHypothesis *a2, unsigned int a3)
{
  unsigned int *v6;
  unsigned int v7;
  KB::DictionaryCursors *v8;
  float v9;
  float v10;

  *(_DWORD *)this = 1;
  v6 = (unsigned int *)*((_QWORD *)a2 + 1);
  *((_QWORD *)this + 1) = v6;
  if (v6)
  {
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
  }
  v8 = KB::DictionaryCursors::DictionaryCursors((TI::Favonius::DictionaryHypothesis *)((char *)this + 16), (const TI::Favonius::DictionaryHypothesis *)((char *)a2 + 16));
  v9 = KB::DictionaryCursors::advance(v8, *((const KB::DictionaryContainer **)this + 1), a3);
  v10 = v9 * *((float *)a2 + 25);
  *((float *)this + 24) = v9;
  *((float *)this + 25) = v10;
  return this;
}

void TI::Favonius::DictionaryHypothesis::extensions(uint64_t *a1, unint64_t *a2)
{
  char *v4;
  uint64_t v5;
  unsigned int v6;
  TI::Favonius::DictionaryHypothesis *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v14;
  char *v15;
  uint64_t v16;

  v14 = 0;
  v15 = 0;
  v16 = 0;
  if (!KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix)
    KB::DictionaryCursors::fill_vector_with_static_trie_children((KB::StaticDictionaryCursor *)(a1 + 2), (uint64_t *)&v14, a1[1]);
  KB::DictionaryCursors::merge_dynamic_children_with_static_siblings((KB::DictionaryCursors *)(a1 + 2), &v14, (const KB::DictionaryContainer *)a1[1]);
  WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(a2, *a2 - 0x3333333333333333 * ((v15 - v14) >> 4));
  v4 = v15;
  if (v15 != v14)
  {
    v5 = 0;
    v6 = 1;
    while (1)
    {
      v7 = (TI::Favonius::DictionaryHypothesis *)operator new();
      TI::Favonius::DictionaryHypothesis::DictionaryHypothesis(v7, (const TI::Favonius::DictionaryHypothesis *)a1, (const KB::DictionaryCursors *)&v14[80 * v5]);
      v8 = *a2;
      if (*a2 == a2[2])
      {
        v9 = v8 + (v8 >> 1);
        if (v8 < 0x100)
          v9 = 2 * v8;
        if (v9 <= v8 + 1)
          v10 = v8 + 1;
        else
          v10 = v9;
        WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(a2, v10);
        v11 = a2[1];
        if (!v11)
        {
          WTF::RefCounted<TI::Favonius::DictionaryHypothesis>::deref((uint64_t)v7);
          goto LABEL_15;
        }
        v8 = *a2;
      }
      else
      {
        v11 = a2[1];
      }
      *(_QWORD *)(v11 + 8 * v8) = v7;
      *a2 = v8 + 1;
LABEL_15:
      v5 = v6;
      v12 = (uint64_t)v14;
      v4 = v15;
      if (0xCCCCCCCCCCCCCCCDLL * ((v15 - v14) >> 4) <= v6++)
        goto LABEL_19;
    }
  }
  v12 = (uint64_t)v15;
LABEL_19:
  if (v12)
  {
    if (v4 != (char *)v12)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<KB::DictionaryCursors,0>((uint64_t)v4);
      }
      while (v4 != (char *)v12);
      v4 = v14;
    }
    v15 = (char *)v12;
    operator delete(v4);
  }
}

TI::Favonius::DictionaryHypothesis *TI::Favonius::DictionaryHypothesis::DictionaryHypothesis(TI::Favonius::DictionaryHypothesis *this, const TI::Favonius::DictionaryHypothesis *a2, const KB::DictionaryCursors *a3)
{
  unsigned int *v5;
  unsigned int v6;
  KB::DictionaryCursors *v7;
  uint64_t v8;
  float v9;
  float v10;
  double v11;
  float v12;
  float v13;

  *(_DWORD *)this = 1;
  v5 = (unsigned int *)*((_QWORD *)a2 + 1);
  *((_QWORD *)this + 1) = v5;
  if (v5)
  {
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 + 1, v5));
  }
  v7 = KB::DictionaryCursors::DictionaryCursors((TI::Favonius::DictionaryHypothesis *)((char *)this + 16), a3);
  v8 = *((_QWORD *)a2 + 1);
  v9 = *((float *)this + 21);
  v10 = KB::StaticDictionaryCursor::conditional_probability(v7);
  if (*((_DWORD *)this + 20))
    v11 = (float)((float)(*(unsigned int (**)(_QWORD, _QWORD))(**((_QWORD **)this + 9) + 80))(*((_QWORD *)this + 9), *(_QWORD *)(v8 + 24))/ (float)*((unsigned int *)this + 20));
  else
    v11 = 0.0;
  v12 = (float)(v9 * v10) + (1.0 - v9) * v11;
  v13 = *((float *)a2 + 25) * v12;
  *((float *)this + 24) = v12;
  *((float *)this + 25) = v13;
  return this;
}

uint64_t TI::Favonius::DictionaryHypothesis::merge_probability_into_static_words(uint64_t result, uint64_t a2, int a3, float a4, float a5)
{
  while (result != a2)
  {
    if ((*(_BYTE *)(result + 106) & 4) != 0 && *(_DWORD *)(result + 136) == a3)
      *(float *)(result + 48) = *(float *)(result + 48) + (float)((float)(*(float *)(result + 48) / a5) * a4);
    result += 240;
  }
  return result;
}

KB::DictionaryContainer *KB::DictionaryContainer::create@<X0>(uint64_t *a1@<X0>, int a2@<W1>, int a3@<W2>, KB::DictionaryContainer **a4@<X8>)
{
  uint64_t v8;
  KB::DictionaryContainer *result;

  v8 = operator new();
  result = KB::DictionaryContainer::DictionaryContainer(v8, a1, 0, a2, a3);
  *a4 = result;
  return result;
}

KB::DictionaryContainer *KB::DictionaryContainer::DictionaryContainer(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  uint64_t *v9;
  const void ****v10;
  uint64_t *v11;
  __n128 v12;
  uint64_t v13;
  KB::DynamicDictionarySingle *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  const void ***v18;
  uint64_t v19;
  KB::DictionaryContainer *v20;
  uint64_t v21;
  _DWORD *v22;
  const KB::String *v23;
  const void ***v24;
  _DWORD *v25;
  uint64_t v26;
  CFStringRef v27;
  uint64_t *v30;
  KB::DictionaryContainer *v31;
  const void ****v32;
  CFStringRef v33;
  _BYTE v34[8];
  void *v35;
  _BYTE v36[8];
  void *v37;
  _BYTE v38[8];
  void *v39;
  _BYTE v40[8];
  void *v41;
  _BYTE v42[8];
  void *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  void *v47;
  unsigned __int16 v48[3];
  char v49;
  void *v50;
  int v51;
  __int16 v52;
  char v53;
  void *v54;
  char v55;
  int v56;
  __int16 v57;
  char v58;
  void *v59;
  char v60;
  int v61;
  __int16 v62;
  char v63;
  void *v64;
  char v65;
  uint64_t v66;
  int v67;
  _BYTE v68[8];
  void *v69;
  _BYTE v70[8];
  void *v71;
  _BYTE v72[8];
  void *v73;
  _BYTE v74[8];
  void *v75;
  _BYTE v76[8];
  void *v77;
  uint64_t v78;
  int v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a1 = 1;
  v9 = (uint64_t *)(a1 + 16);
  v10 = (const void ****)(a1 + 8);
  KB::StaticDictionary::create((uint64_t *)(a1 + 8));
  v32 = (const void ****)v9;
  KB::StaticDictionary::create(v9);
  v31 = (KB::DictionaryContainer *)a1;
  *(_OWORD *)(a1 + 24) = 0u;
  v11 = (uint64_t *)(a1 + 24);
  v11[4] = 0;
  *((_OWORD *)v11 + 1) = 0u;
  std::vector<KB::LexiconInfo>::__init_with_size[abi:nn180100]<KB::LexiconInfo*,KB::LexiconInfo*>(v11 + 2, *a2, a2[1], 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 4));
  *((_WORD *)v11 + 20) = 0;
  if (a5)
  {
    if (a3)
    {
      v12.n128_f64[0] = KB::DynamicDictionaryContainer::create(&v46);
      v13 = v46;
    }
    else
    {
      v14 = (KB::DynamicDictionarySingle *)operator new();
      *(_OWORD *)v14 = 0u;
      *((_OWORD *)v14 + 1) = 0u;
      *((_OWORD *)v14 + 2) = 0u;
      *((_OWORD *)v14 + 3) = 0u;
      *((_OWORD *)v14 + 4) = 0u;
      *((_OWORD *)v14 + 5) = 0u;
      *((_OWORD *)v14 + 6) = 0u;
      *((_OWORD *)v14 + 7) = 0u;
      *((_OWORD *)v14 + 8) = 0u;
      *((_OWORD *)v14 + 9) = 0u;
      *((_OWORD *)v14 + 10) = 0u;
      *((_OWORD *)v14 + 11) = 0u;
      *((_OWORD *)v14 + 12) = 0u;
      *((_OWORD *)v14 + 13) = 0u;
      *((_OWORD *)v14 + 14) = 0u;
      *((_OWORD *)v14 + 15) = 0u;
      *((_OWORD *)v14 + 16) = 0u;
      *((_OWORD *)v14 + 17) = 0u;
      *((_OWORD *)v14 + 18) = 0u;
      v12.n128_f64[0] = KB::DynamicDictionarySingle::DynamicDictionarySingle(v14);
    }
    v15 = *v11;
    *v11 = v13;
    if (v15)
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v15 + 8))(v15, v12);
  }
  v30 = a2;
  v16 = *a2;
  for (i = a2[1]; v16 != i; v16 += 176)
  {
    if (*(_WORD *)(v16 + 32))
    {
      v18 = *v10;
      KB::String::String((KB::String *)v68, (const KB::String *)v16);
      KB::String::String((KB::String *)v70, (const KB::String *)(v16 + 32));
      KB::String::String((KB::String *)v72, (const KB::String *)(v16 + 64));
      KB::String::String((KB::String *)v74, (const KB::String *)(v16 + 96));
      KB::String::String((KB::String *)v76, (const KB::String *)(v16 + 128));
      v19 = *(_QWORD *)(v16 + 160);
      v79 = *(_DWORD *)(v16 + 168);
      v78 = v19;
      KB::StaticDictionary::load(v18, (uint64_t)v68);
      if (v77 && v76[6] == 1)
        free(v77);
      if (v75 && v74[6] == 1)
        free(v75);
      if (v73 && v72[6] == 1)
        free(v73);
      if (v71 && v70[6] == 1)
        free(v71);
      if (v69 && v68[6] == 1)
        free(v69);
    }
  }
  v20 = v31;
  if (**v10 != (*v10)[1])
  {
    v21 = *v30;
    v22 = (_DWORD *)v30[1];
    if ((_DWORD *)*v30 != v22)
    {
      v23 = (const KB::String *)(v21 + 96);
      do
      {
        if (*(_WORD *)v23)
        {
          KB::String::String((KB::String *)&v46, (const KB::String *)((char *)v23 - 96));
          KB::String::String((KB::String *)v48, v23);
          v51 = 0x100000;
          v52 = 0;
          v53 = 0;
          v54 = 0;
          v55 = 0;
          v56 = 0x100000;
          v57 = 0;
          v58 = 0;
          v59 = 0;
          v60 = 0;
          v61 = 0x100000;
          v62 = 0;
          v63 = 0;
          v64 = 0;
          v65 = 0;
          LODWORD(v66) = *((_DWORD *)v23 + 16);
          BYTE4(v66) = 0;
          v67 = *((_DWORD *)v23 + 18);
          v24 = *v32;
          KB::String::String((KB::String *)v34, (const KB::String *)&v46);
          KB::String::String((KB::String *)v36, (const KB::String *)v48);
          KB::String::String((KB::String *)v38, (const KB::String *)&v51);
          KB::String::String((KB::String *)v40, (const KB::String *)&v56);
          KB::String::String((KB::String *)v42, (const KB::String *)&v61);
          v44 = v66;
          v45 = v67;
          KB::StaticDictionary::load(v24, (uint64_t)v34);
          if (v43 && v42[6] == 1)
            free(v43);
          if (v41 && v40[6] == 1)
            free(v41);
          if (v39 && v38[6] == 1)
            free(v39);
          if (v37 && v36[6] == 1)
            free(v37);
          if (v35 && v34[6] == 1)
            free(v35);
          if (v64 && v63 == 1)
            free(v64);
          if (v59 && v58 == 1)
            free(v59);
          if (v54 && v53 == 1)
            free(v54);
          if (v50 && v49 == 1)
            free(v50);
          if (v47 && BYTE6(v46) == 1)
            free(v47);
        }
        v25 = (_DWORD *)((char *)v23 + 80);
        v23 = (const KB::String *)((char *)v23 + 176);
      }
      while (v25 != v22);
      v20 = v31;
      v21 = *v30;
    }
    KB::String::String((KB::String *)&v46, (const KB::String *)v21);
    KB::String::String((KB::String *)v48, (const KB::String *)(v21 + 32));
    KB::String::String((KB::String *)&v51, (const KB::String *)(v21 + 64));
    KB::String::String((KB::String *)&v56, (const KB::String *)(v21 + 96));
    KB::String::String((KB::String *)&v61, (const KB::String *)(v21 + 128));
    v26 = *(_QWORD *)(v21 + 160);
    v67 = *(_DWORD *)(v21 + 168);
    v66 = v26;
    KB::cf_string_impl<KB::String>(&v33, v48);
    v27 = v33;
    *((_QWORD *)v20 + 4) = LMLexiconIDConverterCreateWithUnigramsPath();
    if (v27)
      CFRelease(v27);
    if (v64 && v63 == 1)
      free(v64);
    if (v59 && v58 == 1)
      free(v59);
    if (v54 && v53 == 1)
      free(v54);
    if (v50 && v49 == 1)
      free(v50);
    if (v47 && BYTE6(v46) == 1)
      free(v47);
  }
  if (a4)
    KB::DictionaryContainer::load_dynamic_dict(v20, 0);
  return v20;
}

void KB::DictionaryContainer::load_dynamic_dict(KB::DictionaryContainer *this, uint64_t a2)
{
  char *v2;
  uint64_t v4;

  v2 = (char *)this + 40;
  if (*((_QWORD *)this + 5) != *((_QWORD *)this + 6))
  {
    v4 = *((_QWORD *)this + 3);
    if (v4)
    {
      if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 32))(v4) & 1) == 0)
      {
        (*(void (**)(_QWORD, char *, uint64_t))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3), v2, a2);
        KB::DynamicDictionary::load_address_book(*((KB::DynamicDictionary **)this + 3));
        KB::DynamicDictionary::load_app_names(*((KB::DynamicDictionary **)this + 3));
        TITransientLexiconManagerLoad();
      }
      KB::DynamicDictionary::load_user_dictionary(*((KB::DynamicDictionary **)this + 3));
    }
  }
}

KB::DictionaryContainer *KB::DictionaryContainer::create_multilexicon@<X0>(uint64_t *a1@<X0>, int a2@<W1>, int a3@<W2>, KB::DictionaryContainer **a4@<X8>)
{
  uint64_t v8;
  KB::DictionaryContainer *result;

  v8 = operator new();
  result = KB::DictionaryContainer::DictionaryContainer(v8, a1, 1, a2, a3);
  *a4 = result;
  return result;
}

void KB::DictionaryContainer::~DictionaryContainer(KB::DictionaryContainer *this)
{
  uint64_t v2;
  void **v3;

  if (*((_QWORD *)this + 4))
  {
    LMLexiconIDConverterDestroy();
    *((_QWORD *)this + 4) = 0;
  }
  v3 = (void **)((char *)this + 40);
  std::vector<KB::LexiconInfo>::__destroy_vector::operator()[abi:nn180100](&v3);
  v2 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  std::unique_ptr<KB::StaticDictionary>::reset[abi:nn180100]((const void ****)this + 2, 0);
  std::unique_ptr<KB::StaticDictionary>::reset[abi:nn180100]((const void ****)this + 1, 0);
}

void KB::DictionaryContainer::suspend_dynamic_dict(KB::DynamicDictionary **this)
{
  KB::DynamicDictionary::unload_user_dictionary(this[3]);
}

uint64_t KB::DictionaryContainer::lookup@<X0>(uint64_t this@<X0>, const KB::String *a2@<X1>, char a3@<W2>, int a4@<W3>, uint64_t *a5@<X8>)
{
  unsigned int v9;
  uint64_t v10;
  unsigned int *v11;

  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  if (**(_QWORD **)(this + 8) != *(_QWORD *)(*(_QWORD *)(this + 8) + 8))
  {
    v11 = (unsigned int *)this;
    do
      v9 = __ldaxr((unsigned int *)this);
    while (__stlxr(v9 + 1, (unsigned int *)this));
    v10 = operator new();
    TI::Favonius::DictionaryHypothesis::DictionaryHypothesis(v10, &v11, a2);
    if (v11)
      WTF::RefCounted<KB::DictionaryContainer>::deref(v11);
    TI::Favonius::DictionaryHypothesis::_words(v10, a5, a4, 1, a3);
    return WTF::RefCounted<TI::Favonius::DictionaryHypothesis>::deref(v10);
  }
  return this;
}

float KB::DictionaryContainer::_probability_of_word_with_string_and_id(KB::DictionaryContainer *this, const KB::String *a2, const TITokenID *a3, int a4)
{
  unsigned int v7;
  unsigned int *v8;
  uint64_t v9;
  char v10;
  char v11;
  unsigned int *v12;
  unsigned int *v13;
  float v14;
  float v15;
  _QWORD v17[2];
  BOOL (*v18)(uint64_t, uint64_t);
  void *v19;
  const TITokenID *v20;
  unsigned int *v21;
  unsigned int *v22;
  uint64_t v23;
  unsigned int **v24;

  v21 = (unsigned int *)this;
  if (this)
  {
    do
      v7 = __ldaxr((unsigned int *)this);
    while (__stlxr(v7 + 1, (unsigned int *)this));
    v8 = v21;
  }
  else
  {
    v8 = 0;
  }
  v9 = operator new();
  TI::Favonius::DictionaryHypothesis::DictionaryHypothesis(v9, &v21, a2);
  if (v8)
    WTF::RefCounted<KB::DictionaryContainer>::deref(v8);
  v21 = 0;
  v22 = 0;
  v23 = 0;
  if (a4)
  {
    v10 = 1;
    v11 = 1;
  }
  else
  {
    v10 = 0;
    v11 = 0;
  }
  TI::Favonius::DictionaryHypothesis::_words(v9, (uint64_t *)&v21, 0, v10, v11);
  v12 = v21;
  v13 = v22;
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 0x40000000;
  v18 = ___ZNK2KB19DictionaryContainer39_probability_of_word_with_string_and_idERKNS_6StringERK9TITokenIDb_block_invoke;
  v19 = &__block_descriptor_tmp_13542;
  v20 = a3;
  if (v21 == v22)
    goto LABEL_15;
  while ((((uint64_t (*)(_QWORD *, unsigned int *))v18)(v17, v12) & 1) == 0)
  {
    v12 += 60;
    if (v12 == v13)
    {
      v12 = v13;
      break;
    }
  }
  if (v12 == v22)
  {
LABEL_15:
    v24 = &v21;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v24);
    v15 = 0.0;
  }
  else
  {
    v14 = *(float *)(v9 + 100);
    v15 = (float)(v14
                * KB::DictionaryCursors::termination_probability((KB::DictionaryCursors *)(v9 + 16), *(const KB::DictionaryContainer **)(v9 + 8)))* *((float *)v12 + 12);
    v24 = &v21;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v24);
  }
  WTF::RefCounted<TI::Favonius::DictionaryHypothesis>::deref(v9);
  return v15;
}

BOOL ___ZNK2KB19DictionaryContainer39_probability_of_word_with_string_and_idERKNS_6StringERK9TITokenIDb_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 136) == **(_QWORD **)(a1 + 32);
}

float KB::DictionaryContainer::probability_of_word_with_string_and_id(KB::DictionaryContainer *this, const KB::String *a2, const TITokenID *a3)
{
  return KB::DictionaryContainer::_probability_of_word_with_string_and_id(this, a2, a3, 1);
}

float KB::DictionaryContainer::static_probability_of_word_with_string_and_id(KB::DictionaryContainer *this, const KB::String *a2, const TITokenID *a3)
{
  return KB::DictionaryContainer::_probability_of_word_with_string_and_id(this, a2, a3, 0);
}

uint64_t KB::DictionaryContainer::is_word_in_supplemental_lexicon(KB::DynamicDictionary **this, const KB::String *a2)
{
  return KB::DynamicDictionary::is_word_in_supplemental_lexicon(this[3], a2);
}

void KB::DictionaryContainer::word_with_string(KB::StaticDictionary **this@<X0>, const KB::String *a2@<X1>, int a3@<W2>, KB::Word *a4@<X8>)
{
  double v7;
  _QWORD v8[30];
  _WORD v9[120];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v7 = KB::StaticDictionary::word_with_string(this[1], a2, a3, (KB::Word *)v9);
  (*(void (**)(_QWORD *__return_ptr, KB::StaticDictionary *, const KB::String *, double))(*(_QWORD *)this[3] + 56))(v8, this[3], a2, v7);
  combine_words(a4, v9, (KB::Word *)v8);
  KB::Word::~Word((KB::Word *)v8);
  KB::Word::~Word((KB::Word *)v9);
}

double combine_words(KB::Word *this, _WORD *a2, KB::Word *a3)
{
  int v5;
  double result;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;

  v5 = *(unsigned __int16 *)a3;
  if (*a2)
  {
    KB::Word::Word((uint64_t)this, (uint64_t)a2);
    if (!v5)
      return result;
    result = *(double *)((char *)a3 + 124);
    *(double *)((char *)this + 124) = result;
    *((_DWORD *)this + 26) = *((_DWORD *)this + 26) & 0x7DFCFEFF | *((_DWORD *)a3 + 26) & 0x82030100;
    if (this != a3)
    {
      *((_DWORD *)this + 58) = *((_DWORD *)a3 + 58);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((_QWORD *)this + 25, *((_QWORD **)a3 + 27));
    }
    if (*((_QWORD *)a3 + 28))
      return result;
    v8 = *((_DWORD *)a3 + 31);
    v7 = *((_DWORD *)a3 + 32);
    v9 = v8 >= v7;
    v10 = v8 - v7;
    if (!v9 || v10 < 3)
      return result;
LABEL_15:
    *((_DWORD *)this + 26) |= 0x2000u;
    return result;
  }
  if (!*(_WORD *)a3)
  {
    *((_OWORD *)this + 13) = 0u;
    *((_OWORD *)this + 14) = 0u;
    *((_OWORD *)this + 11) = 0u;
    *((_OWORD *)this + 12) = 0u;
    *((_OWORD *)this + 9) = 0u;
    *((_OWORD *)this + 10) = 0u;
    *((_OWORD *)this + 7) = 0u;
    *((_OWORD *)this + 8) = 0u;
    *((_OWORD *)this + 5) = 0u;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 3) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 1) = 0u;
    *((_OWORD *)this + 2) = 0u;
    *(_OWORD *)this = 0u;
    return KB::Word::Word(this);
  }
  KB::Word::Word((uint64_t)this, (uint64_t)a3);
  if (!*((_QWORD *)this + 28))
  {
    v12 = *((_DWORD *)this + 31);
    v11 = *((_DWORD *)this + 32);
    v9 = v12 >= v11;
    v13 = v12 - v11;
    if (v9 && v13 >= 2)
      goto LABEL_15;
  }
  return result;
}

void KB::DictionaryContainer::word_with_string_exhaustive(KB::StaticDictionary **this@<X0>, const KB::String *a2@<X1>, int a3@<W2>, KB::Word *a4@<X8>)
{
  __n128 v7;
  _QWORD v8[4];
  __int128 v9;
  uint64_t v10;
  int v11;
  _OWORD v12[6];
  _BYTE v13[40];
  uint64_t v14[5];
  _WORD v15[16];
  __int128 v16;
  uint64_t v17;
  int v18;
  _OWORD v19[6];
  _BYTE v20[40];
  _QWORD v21[6];

  v21[5] = *MEMORY[0x1E0C80C00];
  v7.n128_f64[0] = KB::StaticDictionary::word_with_string(this[1], a2, a3, (KB::Word *)v15);
  if (!v15[0])
  {
    KB::DictionaryContainer::closest_static_match((KB::DictionaryContainer *)this, a2, (KB::Word *)v8);
    KB::String::operator=((uint64_t)v15, (KB::String *)v8);
    if ((unsigned __int16)v16 >= 0xFu && *((_QWORD *)&v16 + 1))
      MEMORY[0x1DF0A212C](*((_QWORD *)&v16 + 1), 0x1000C8077774924);
    v16 = v9;
    if ((unsigned __int16)v9 >= 0xFu)
      LOWORD(v9) = 0;
    v17 = v10;
    v18 = v11;
    KB::String::operator=((uint64_t)v19, (KB::String *)v12);
    v19[2] = v12[2];
    v19[3] = v12[3];
    v19[4] = v12[4];
    v19[5] = v12[5];
    KB::String::operator=((uint64_t)v20, (KB::String *)v13);
    v20[32] = v13[32];
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign((uint64_t)v21, v14);
    KB::Word::~Word((KB::Word *)v8);
  }
  (*(void (**)(_QWORD *__return_ptr, KB::StaticDictionary *, const KB::String *, __n128))(*(_QWORD *)this[3] + 56))(v8, this[3], a2, v7);
  combine_words(a4, v15, (KB::Word *)v8);
  KB::Word::~Word((KB::Word *)v8);
  KB::Word::~Word((KB::Word *)v15);
}

void KB::DictionaryContainer::closest_static_match(KB::DictionaryContainer *this@<X0>, const KB::String *a2@<X1>, KB::Word *a3@<X8>)
{
  char *v5;
  char *v6;
  char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  _BYTE buf[12];
  __int16 v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  unint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v12 = 0;
  v13 = 0;
  KB::DictionaryContainer::derive_static_words(this, (uint64_t *)&v11, (unsigned __int16 *)a2);
  v5 = v11;
  v6 = v12;
  if (v11 == v12)
  {
LABEL_7:
    *((_OWORD *)a3 + 13) = 0u;
    *((_OWORD *)a3 + 14) = 0u;
    *((_OWORD *)a3 + 11) = 0u;
    *((_OWORD *)a3 + 12) = 0u;
    *((_OWORD *)a3 + 9) = 0u;
    *((_OWORD *)a3 + 10) = 0u;
    *((_OWORD *)a3 + 7) = 0u;
    *((_OWORD *)a3 + 8) = 0u;
    *((_OWORD *)a3 + 5) = 0u;
    *((_OWORD *)a3 + 6) = 0u;
    *((_OWORD *)a3 + 3) = 0u;
    *((_OWORD *)a3 + 4) = 0u;
    *((_OWORD *)a3 + 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *(_OWORD *)a3 = 0u;
    KB::Word::Word(a3);
  }
  else
  {
    while (!KB::String::equal((KB::String *)v5, a2, 0))
    {
      v5 += 240;
      if (v5 == v6)
      {
        v5 = v11;
        v7 = v12;
        if (v11 == v12)
          goto LABEL_7;
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
        {
          v8 = (char *)a2 + 16;
          if (*((_QWORD *)a2 + 1))
            v8 = (const char *)*((_QWORD *)a2 + 1);
          v9 = "";
          if (*(_WORD *)a2)
            v10 = v8;
          else
            v10 = "";
          if (*(_WORD *)v5)
          {
            v9 = (const char *)*((_QWORD *)v5 + 1);
            if (!v9)
              v9 = v5 + 16;
          }
          *(_QWORD *)&buf[4] = "closest_static_match";
          *(_DWORD *)buf = 136315906;
          v15 = 2080;
          v16 = v10;
          v17 = 2080;
          v18 = v9;
          v19 = 2048;
          v20 = 0xEEEEEEEEEEEEEEEFLL * ((v7 - v5) >> 4);
          _os_log_debug_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "%s  DictionaryContainer::closest_static_match: \"%s\" has only diacritic-insensitive matches, returning the first one (\"%s\") out of %zu", buf, 0x2Au);
          v5 = v11;
        }
        break;
      }
    }
    KB::Word::Word(a3, (const KB::Word *)v5);
  }
  *(_QWORD *)buf = &v11;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
}

void KB::DictionaryContainer::derive_static_words(KB::DictionaryContainer *a1, uint64_t *a2, unsigned __int16 *a3)
{
  const KB::StaticDictionary *v4;
  uint64_t v8;
  int v9;
  int v10;
  float v11;
  unsigned int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  BOOL v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t i;
  const void *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  uint64_t v43[3];
  _OWORD v44[2];
  int v45;
  uint64_t v46;
  int v47;
  void **v48;
  void *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v4 = (const KB::StaticDictionary *)*((_QWORD *)a1 + 1);
  if (*(_QWORD *)v4 != *((_QWORD *)v4 + 1) && *a3 != 0)
  {
    v46 = 0;
    v47 = 0;
    memset(v44, 0, sizeof(v44));
    v45 = 0;
    KB::StaticDictionaryCursor::reset((KB::StaticDictionaryCursor *)v44, v4);
    memset(v43, 0, sizeof(v43));
    if (*((_QWORD *)a3 + 1))
      v8 = *((_QWORD *)a3 + 1);
    else
      v8 = (uint64_t)(a3 + 8);
    v38 = v8;
    v9 = *a3;
    v39 = 0;
    v40 = v9;
    v41 = 0;
    KB::String::iterator::initialize(&v38);
    v42 = 0;
    v34 = v8;
    v35 = v9;
    v36 = v9;
    v37 = 0;
    KB::String::iterator::initialize(&v34);
    v10 = v35;
    if (v39 != v35)
    {
      v11 = 1.0;
      do
      {
        if (!KB::StaticDictionaryCursor::valid((KB::StaticDictionaryCursor *)v44))
          break;
        v12 = v41;
        ++v42;
        KB::String::iterator::operator++(&v38);
        v11 = v11 * KB::StaticDictionaryCursor::advance((KB::StaticDictionaryCursor *)v44, v12);
        if (*((_QWORD *)a1 + 4))
        {
          v13 = v42;
          v14 = a3[2];
          if (!a3[2])
          {
            KB::String::compute_length(a3);
            v14 = a3[2];
          }
          if (v13 < v14 && v46)
          {
            v15 = 0;
            v16 = 8 * v46 - 8;
            do
            {
              v17 = LXCursorTerminatesWordStem();
              if (v17)
                v18 = 1;
              else
                v18 = v16 == v15;
              v15 += 8;
            }
            while (!v18);
            if (v17)
            {
              v31 = 0;
              v32 = 0;
              v33 = 0;
              KB::StaticDictionaryCursor::derive_words((KB::StaticDictionaryCursor *)v44, (uint64_t)&v31);
              v19 = *a3;
              v20 = *((_QWORD *)a3 + 1);
              if (!v20)
                v20 = (uint64_t)(a3 + 8);
              v27 = v20;
              v28 = v19;
              v29 = v19;
              v30 = 0;
              KB::String::iterator::initialize(&v27);
              KB::String::String((KB::String *)&v48, (const KB::String::iterator *)&v38, (const KB::String::iterator *)&v27);
              v21 = v31;
              v22 = v32;
              while (v21 != v22)
              {
                *(float *)(v21 + 52) = v11;
                KB::DictionaryContainer::derive_combined_words(a1, v43, (TITokenID *)v21, (const KB::String *)&v48);
                v21 += 240;
              }
              if (v49)
                v23 = BYTE6(v48) == 1;
              else
                v23 = 0;
              if (v23)
                free(v49);
              v48 = (void **)&v31;
              std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v48);
            }
          }
        }
      }
      while (v39 != v10);
    }
    KB::StaticDictionaryCursor::derive_words((KB::StaticDictionaryCursor *)v44, (uint64_t)a2);
    if (*((_QWORD *)a1 + 4))
    {
      v24 = std::remove_if[abi:nn180100]<std::__wrap_iter<KB::Word *>,BOOL({block_pointer})(KB::Word const&)>(*a2, a2[1], (uint64_t)&__block_literal_global_13552);
      std::vector<KB::Word>::erase((uint64_t)a2, v24, (KB::Word *)a2[1]);
      KB::StaticDictionary::merge_words((uint64_t)a2, v43);
    }
    v48 = (void **)v43;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v48);
    for (i = 16; i != -8; i -= 8)
    {
      v26 = *(const void **)((char *)v44 + i);
      if (v26)
        CFRelease(v26);
      *(_QWORD *)((char *)v44 + i) = 0;
    }
  }
}

void KB::DictionaryContainer::derive_combined_words(KB::DictionaryContainer *a1, uint64_t *a2, TITokenID *a3, const KB::String *a4)
{
  const KB::StaticDictionary *v8;
  TITokenID *v9;
  TITokenID *i;
  TITokenID v11;
  TITokenID v12;
  unint64_t v13;
  TITokenID v14;
  TITokenID v15;
  KB::Word *v16;
  unint64_t v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  KB::Word *v24;
  uint64_t j;
  const void *v26;
  BOOL v27;
  TITokenID *v28;
  TITokenID *v29;
  uint64_t v30;
  _OWORD v31[2];
  int v32;
  uint64_t v33;
  int v34;
  unsigned __int16 v35[4];
  char *v36;
  _QWORD v37[5];
  void **v38[30];
  _BYTE v39[8];
  void *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v35 = 0;
  v36 = 0;
  if (*((_QWORD *)a1 + 4) && LMLexiconIDConverterGetStemData())
  {
    KB::String::String((KB::String *)v39, v36, v35[0]);
    v8 = (const KB::StaticDictionary *)*((_QWORD *)a1 + 1);
    v33 = 0;
    v34 = 0;
    memset(v31, 0, sizeof(v31));
    v32 = 0;
    KB::StaticDictionaryCursor::reset((KB::StaticDictionaryCursor *)v31, v8);
    KB::StaticDictionaryCursor::advance((KB::StaticDictionaryCursor *)v31, (const KB::String *)v39);
    KB::StaticDictionaryCursor::advance((KB::StaticDictionaryCursor *)v31, a4);
    v28 = 0;
    v29 = 0;
    v30 = 0;
    KB::StaticDictionaryCursor::derive_words((KB::StaticDictionaryCursor *)v31, (uint64_t)&v28);
    v9 = v28;
    for (i = v29; v9 != i; v9 += 30)
    {
      v11 = a3[17];
      v12 = v9[17];
      v13 = KB::DictionaryContainer::combined_word_id(a1, v11, v12);
      if (HIDWORD(v13)
        && (v9[16].word_id & (a3[16].word_id >> 12) & 0xFFF) != 0
        && *(uint64_t *)v35 <= LOWORD(v9->lexicon_id))
      {
        v14 = (TITokenID)v13;
        KB::Word::Word((KB::Word *)v38, (const KB::Word *)a3);
        v15 = v14;
        KB::Word::append_suffix((KB::Word *)v38, (const KB::Word *)v9, v35[0], v15);
        v16 = (KB::Word *)a2[1];
        v17 = a2[2];
        if ((unint64_t)v16 >= v17)
        {
          v19 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v16 - *a2) >> 4);
          v20 = v19 + 1;
          if (v19 + 1 > 0x111111111111111)
            abort();
          v21 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v17 - *a2) >> 4);
          if (2 * v21 > v20)
            v20 = 2 * v21;
          if (v21 >= 0x88888888888888)
            v22 = 0x111111111111111;
          else
            v22 = v20;
          v37[4] = a2 + 2;
          if (v22)
            v22 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v22);
          else
            v23 = 0;
          v24 = (KB::Word *)(v22 + 240 * v19);
          v37[0] = v22;
          v37[1] = v24;
          v37[3] = v22 + 240 * v23;
          KB::Word::Word(v24, (const KB::Word *)v38);
          v37[2] = (char *)v24 + 240;
          std::vector<KB::Word>::__swap_out_circular_buffer(a2, v37);
          v18 = (char *)a2[1];
          std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)v37);
        }
        else
        {
          v18 = (char *)KB::Word::Word(v16, (const KB::Word *)v38) + 240;
        }
        a2[1] = (uint64_t)v18;
        KB::Word::~Word((KB::Word *)v38);
      }
    }
    v38[0] = (void **)&v28;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](v38);
    for (j = 16; j != -8; j -= 8)
    {
      v26 = *(const void **)((char *)v31 + j);
      if (v26)
        CFRelease(v26);
      *(_QWORD *)((char *)v31 + j) = 0;
    }
    if (v40)
      v27 = v39[6] == 1;
    else
      v27 = 0;
    if (v27)
      free(v40);
  }
}

uint64_t ___ZNK2KB19DictionaryContainer19derive_static_wordsERNSt3__16vectorINS_4WordENS1_9allocatorIS3_EEEERKNS_6StringE_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 135) >> 5) & 1;
}

uint64_t KB::DictionaryContainer::combined_word_id(KB::DictionaryContainer *this, TITokenID a2, TITokenID a3)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;

  v3 = *((_QWORD *)this + 1);
  if (*(_QWORD *)v3 == *(_QWORD *)(v3 + 8))
    v4 = -1;
  else
    v4 = **(_DWORD **)(v3 + 48);
  if (*((_QWORD *)this + 4))
    v5 = v4 == a2.lexicon_id;
  else
    v5 = 0;
  if (v5 && v4 == a3.lexicon_id)
    LMLexiconIDConverterGetStemSuffixTokenID();
  return v4;
}

uint64_t KB::DictionaryContainer::affix_sentinel@<X0>(KB::DictionaryContainer *this@<X0>, TITokenID a2@<0:X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  int v6;
  uint64_t result;
  BOOL v8;

  v5 = *((_QWORD *)this + 1);
  if (*(_QWORD *)v5 == *(_QWORD *)(v5 + 8))
    v6 = -1;
  else
    v6 = **(_DWORD **)(v5 + 48);
  result = *((_QWORD *)this + 4);
  if (result)
    v8 = v6 == a2.lexicon_id;
  else
    v8 = 0;
  if (!v8)
    goto LABEL_11;
  if (a3)
  {
    result = LMLexiconIDConverterGetSuffixData();
    if ((result & 1) == 0)
    {
LABEL_11:
      *(_DWORD *)a4 = 0x100000;
      *(_WORD *)(a4 + 4) = 0;
      *(_BYTE *)(a4 + 6) = 0;
      *(_QWORD *)(a4 + 8) = 0;
      *(_BYTE *)(a4 + 16) = 0;
      return result;
    }
  }
  else
  {
    result = LMLexiconIDConverterGetStemData();
    if (!(_DWORD)result)
      goto LABEL_11;
  }
  return (uint64_t)KB::String::String((KB::String *)a4, 0, 0);
}

void options_with_word_locale(char *a1@<X0>, CFMutableDictionaryRef *a2@<X8>)
{
  const __CFAllocator *v4;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v6;
  CFLocaleIdentifier v7;
  CFLocaleRef v8;
  void *__p[2];
  char v10;
  CFLocaleIdentifier localeIdentifier;

  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
  *a2 = Mutable;
  if (a1)
  {
    v6 = Mutable;
    std::string::basic_string[abi:nn180100]<0>(__p, a1);
    KB::cf_string((const UInt8 *)__p, &localeIdentifier);
    v7 = localeIdentifier;
    v8 = CFLocaleCreate(v4, localeIdentifier);
    if (v7)
      CFRelease(v7);
    if (v10 < 0)
      operator delete(__p[0]);
    CFDictionarySetValue(v6, (const void *)*MEMORY[0x1E0D437F0], v8);
    if (v8)
      CFRelease(v8);
  }
}

TI::VulgarWordUsageDatabaseWrapper *TI::VulgarWordUsageDatabaseWrapper::VulgarWordUsageDatabaseWrapper(TI::VulgarWordUsageDatabaseWrapper *this)
{
  const __CFString *v2;
  std::string *v3;
  std::string::size_type v4;
  const void *v5;
  std::string v7;
  void *__p[2];
  std::string::size_type v9;

  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  if (simular_swear_word_policy_v2_setting)
  {
    if ((objc_msgSend((id)simular_swear_word_policy_v2_setting, "BOOLValue") & 1) == 0)
      return this;
  }
  else if (!_os_feature_enabled_impl())
  {
    return this;
  }
  v2 = (const __CFString *)TI_KB_USER_DIRECTORY();
  KB::std_string(v2, &v7);
  v3 = std::string::append(&v7, "/VulgarWordUsage.db", 0x13uLL);
  v4 = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v9 = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
  KB::cf_string((const UInt8 *)__p, (CFStringRef *)&v7);
  v5 = (const void *)v7.__r_.__value_.__r.__words[0];
  *(_QWORD *)this = LXVulgarWordUsageDatabaseCreate();
  if (v5)
    CFRelease(v5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
  return this;
}

void TI::VulgarWordUsageDatabaseWrapper::~VulgarWordUsageDatabaseWrapper(const void **this)
{
  const void *v2;
  void **v3;

  v2 = *this;
  if (v2)
    CFRelease(v2);
  v3 = (void **)(this + 2);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v3);
}

uint64_t TI::VulgarWordUsageDatabaseWrapper::increment_usage_count(uint64_t a1, char *a2, char *a3, uint64_t *a4, char *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CFMutableDictionaryRef v8;
  CFStringRef v9;
  int v10;
  void *v11;
  std::string *v12;
  CFStringRef v13;
  CFMutableDictionaryRef v14;
  int v15;
  const UInt8 *v16;
  const void *v17;
  const void *v18;
  CFMutableDictionaryRef v19;
  CFMutableDictionaryRef v24;
  void *v25[2];
  char v26;
  CFStringRef v27;
  void *v28[2];
  char v29;
  CFStringRef v30;
  CFMutableDictionaryRef v31;
  void *__p[2];
  char v33;
  std::string v34;

  if (a3)
  {
    v5 = *a4;
    v6 = a4[1];
    if (v6 != *a4)
    {
      LOBYTE(v7) = 1;
      while (1)
      {
        if (*(char *)(v5 + 23) < 0)
          std::string::__init_copy_ctor_external(&v34, *(const std::string::value_type **)v5, *(_QWORD *)(v5 + 8));
        else
          v34 = *(std::string *)v5;
        std::string::basic_string[abi:nn180100]<0>(__p, a2);
        KB::cf_string((const UInt8 *)__p, (CFStringRef *)&v31);
        v8 = v31;
        std::string::basic_string[abi:nn180100]<0>(v28, a3);
        KB::cf_string((const UInt8 *)v28, &v30);
        v9 = v30;
        v10 = SHIBYTE(v34.__r_.__value_.__r.__words[2]);
        v11 = (void *)v34.__r_.__value_.__r.__words[0];
        if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v12 = &v34;
        else
          v12 = (std::string *)v34.__r_.__value_.__r.__words[0];
        std::string::basic_string[abi:nn180100]<0>(v25, (char *)v12);
        KB::cf_string((const UInt8 *)v25, &v27);
        v13 = v27;
        options_with_word_locale(a5, &v24);
        v14 = v24;
        v15 = LXVulgarWordUsageDatabaseIncrementUsageCount();
        if (v14)
          CFRelease(v14);
        if (v13)
          CFRelease(v13);
        if ((v26 & 0x80000000) == 0)
          break;
        operator delete(v25[0]);
        if (v9)
          goto LABEL_16;
LABEL_17:
        if (v29 < 0)
        {
          operator delete(v28[0]);
          if (!v8)
            goto LABEL_20;
LABEL_19:
          CFRelease(v8);
          goto LABEL_20;
        }
        if (v8)
          goto LABEL_19;
LABEL_20:
        if (v33 < 0)
          operator delete(__p[0]);
        if (v10 < 0)
          operator delete(v11);
        v7 = v7 & (v15 != 0);
        v5 += 24;
        if (v5 == v6)
          return v7;
      }
      if (!v9)
        goto LABEL_17;
LABEL_16:
      CFRelease(v9);
      goto LABEL_17;
    }
    v16 = (const UInt8 *)std::string::basic_string[abi:nn180100]<0>(&v34, a2);
    KB::cf_string(v16, (CFStringRef *)v28);
    v17 = v28[0];
    std::string::basic_string[abi:nn180100]<0>(__p, a3);
    KB::cf_string((const UInt8 *)__p, (CFStringRef *)v25);
    v18 = v25[0];
    options_with_word_locale(a5, &v31);
    v19 = v31;
    v7 = LXVulgarWordUsageDatabaseIncrementUsageCount() != 0;
    if (v19)
      CFRelease(v19);
    if (v18)
      CFRelease(v18);
    if (v33 < 0)
      operator delete(__p[0]);
    if (v17)
      CFRelease(v17);
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v34.__r_.__value_.__l.__data_);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v34.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Cannot increment the usage count because app_id is NULL", (uint8_t *)&v34, 2u);
    }
    return 0;
  }
  return v7;
}

uint64_t TI::VulgarWordUsageDatabaseWrapper::decrement_usage_count(uint64_t a1, char *a2, char *a3, uint64_t *a4, char *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CFMutableDictionaryRef v8;
  CFStringRef v9;
  int v10;
  void *v11;
  std::string *v12;
  CFStringRef v13;
  CFMutableDictionaryRef v14;
  int v15;
  const UInt8 *v16;
  const void *v17;
  const void *v18;
  CFMutableDictionaryRef v19;
  CFMutableDictionaryRef v24;
  void *v25[2];
  char v26;
  CFStringRef v27;
  void *v28[2];
  char v29;
  CFStringRef v30;
  CFMutableDictionaryRef v31;
  void *__p[2];
  char v33;
  std::string v34;

  if (a3)
  {
    v5 = *a4;
    v6 = a4[1];
    if (v6 != *a4)
    {
      LOBYTE(v7) = 1;
      while (1)
      {
        if (*(char *)(v5 + 23) < 0)
          std::string::__init_copy_ctor_external(&v34, *(const std::string::value_type **)v5, *(_QWORD *)(v5 + 8));
        else
          v34 = *(std::string *)v5;
        std::string::basic_string[abi:nn180100]<0>(__p, a2);
        KB::cf_string((const UInt8 *)__p, (CFStringRef *)&v31);
        v8 = v31;
        std::string::basic_string[abi:nn180100]<0>(v28, a3);
        KB::cf_string((const UInt8 *)v28, &v30);
        v9 = v30;
        v10 = SHIBYTE(v34.__r_.__value_.__r.__words[2]);
        v11 = (void *)v34.__r_.__value_.__r.__words[0];
        if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v12 = &v34;
        else
          v12 = (std::string *)v34.__r_.__value_.__r.__words[0];
        std::string::basic_string[abi:nn180100]<0>(v25, (char *)v12);
        KB::cf_string((const UInt8 *)v25, &v27);
        v13 = v27;
        options_with_word_locale(a5, &v24);
        v14 = v24;
        v15 = LXVulgarWordUsageDatabaseDecrementUsageCount();
        if (v14)
          CFRelease(v14);
        if (v13)
          CFRelease(v13);
        if ((v26 & 0x80000000) == 0)
          break;
        operator delete(v25[0]);
        if (v9)
          goto LABEL_16;
LABEL_17:
        if (v29 < 0)
        {
          operator delete(v28[0]);
          if (!v8)
            goto LABEL_20;
LABEL_19:
          CFRelease(v8);
          goto LABEL_20;
        }
        if (v8)
          goto LABEL_19;
LABEL_20:
        if (v33 < 0)
          operator delete(__p[0]);
        if (v10 < 0)
          operator delete(v11);
        v7 = v7 & (v15 != 0);
        v5 += 24;
        if (v5 == v6)
          return v7;
      }
      if (!v9)
        goto LABEL_17;
LABEL_16:
      CFRelease(v9);
      goto LABEL_17;
    }
    v16 = (const UInt8 *)std::string::basic_string[abi:nn180100]<0>(&v34, a2);
    KB::cf_string(v16, (CFStringRef *)v28);
    v17 = v28[0];
    std::string::basic_string[abi:nn180100]<0>(__p, a3);
    KB::cf_string((const UInt8 *)__p, (CFStringRef *)v25);
    v18 = v25[0];
    options_with_word_locale(a5, &v31);
    v19 = v31;
    v7 = LXVulgarWordUsageDatabaseDecrementUsageCount() != 0;
    if (v19)
      CFRelease(v19);
    if (v18)
      CFRelease(v18);
    if (v33 < 0)
      operator delete(__p[0]);
    if (v17)
      CFRelease(v17);
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v34.__r_.__value_.__l.__data_);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v34.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Cannot decrement the usage count because app_id is NULL", (uint8_t *)&v34, 2u);
    }
    return 0;
  }
  return v7;
}

BOOL TI::VulgarWordUsageDatabaseWrapper::can_autocorrect(uint64_t a1, char *a2, char *a3, _QWORD *a4, char *a5)
{
  uint64_t v5;
  uint64_t i;
  CFMutableDictionaryRef v7;
  CFStringRef v8;
  int v9;
  void *v10;
  std::string *v11;
  CFStringRef v12;
  CFMutableDictionaryRef v13;
  int CanAutocorrect;
  _BOOL8 v15;
  const UInt8 *v17;
  const void *v18;
  const void *v19;
  CFMutableDictionaryRef v20;
  CFMutableDictionaryRef v25;
  void *__p[2];
  char v27;
  CFStringRef v28;
  void *v29[2];
  char v30;
  CFStringRef v31;
  CFMutableDictionaryRef v32;
  void *v33[2];
  char v34;
  std::string v35;

  if (a3)
  {
    v5 = a4[1];
    if (v5 != *a4)
    {
      for (i = *a4 + 24; ; i += 24)
      {
        if (*(char *)(i - 1) < 0)
          std::string::__init_copy_ctor_external(&v35, *(const std::string::value_type **)(i - 24), *(_QWORD *)(i - 16));
        else
          v35 = *(std::string *)(i - 24);
        std::string::basic_string[abi:nn180100]<0>(v33, a2);
        KB::cf_string((const UInt8 *)v33, (CFStringRef *)&v32);
        v7 = v32;
        std::string::basic_string[abi:nn180100]<0>(v29, a3);
        KB::cf_string((const UInt8 *)v29, &v31);
        v8 = v31;
        v9 = SHIBYTE(v35.__r_.__value_.__r.__words[2]);
        v10 = (void *)v35.__r_.__value_.__r.__words[0];
        if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v11 = &v35;
        else
          v11 = (std::string *)v35.__r_.__value_.__r.__words[0];
        std::string::basic_string[abi:nn180100]<0>(__p, (char *)v11);
        KB::cf_string((const UInt8 *)__p, &v28);
        v12 = v28;
        options_with_word_locale(a5, &v25);
        v13 = v25;
        CanAutocorrect = LXVulgarWordUsageDatabaseCanAutocorrect();
        v15 = CanAutocorrect != 0;
        if (v13)
          CFRelease(v13);
        if (v12)
          CFRelease(v12);
        if ((v27 & 0x80000000) == 0)
          break;
        operator delete(__p[0]);
        if (v8)
          goto LABEL_16;
LABEL_17:
        if ((v30 & 0x80000000) == 0)
        {
          if (!v7)
            goto LABEL_20;
LABEL_19:
          CFRelease(v7);
          goto LABEL_20;
        }
        operator delete(v29[0]);
        if (v7)
          goto LABEL_19;
LABEL_20:
        if (v34 < 0)
        {
          operator delete(v33[0]);
          if (v9 < 0)
          {
LABEL_29:
            operator delete(v10);
            if (!CanAutocorrect)
              return v15;
            goto LABEL_30;
          }
        }
        else if (v9 < 0)
        {
          goto LABEL_29;
        }
        if (!CanAutocorrect)
          return v15;
LABEL_30:
        if (i == v5)
          return v15;
      }
      if (!v8)
        goto LABEL_17;
LABEL_16:
      CFRelease(v8);
      goto LABEL_17;
    }
    v17 = (const UInt8 *)std::string::basic_string[abi:nn180100]<0>(&v35, a2);
    KB::cf_string(v17, (CFStringRef *)v29);
    v18 = v29[0];
    std::string::basic_string[abi:nn180100]<0>(v33, a3);
    KB::cf_string((const UInt8 *)v33, (CFStringRef *)__p);
    v19 = __p[0];
    options_with_word_locale(a5, &v32);
    v20 = v32;
    v15 = LXVulgarWordUsageDatabaseCanAutocorrect() != 0;
    if (v20)
      CFRelease(v20);
    if (v19)
      CFRelease(v19);
    if (v34 < 0)
      operator delete(v33[0]);
    if (v18)
      CFRelease(v18);
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v35.__r_.__value_.__l.__data_);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v35.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Cannot read the usage count because app_id is NULL", (uint8_t *)&v35, 2u);
    }
    return 0;
  }
  return v15;
}

BOOL TI::VulgarWordUsageDatabaseWrapper::can_autocorrect_somewhere(TI::VulgarWordUsageDatabaseWrapper *this, char *a2, char *a3)
{
  CFStringRef v4;
  CFMutableDictionaryRef v5;
  int CanAutocorrectSomewhere;
  CFMutableDictionaryRef v8;
  void *__p[2];
  char v10;
  CFStringRef v11;

  std::string::basic_string[abi:nn180100]<0>(__p, a2);
  KB::cf_string((const UInt8 *)__p, &v11);
  v4 = v11;
  options_with_word_locale(a3, &v8);
  v5 = v8;
  CanAutocorrectSomewhere = LXVulgarWordUsageDatabaseCanAutocorrectSomewhere();
  if (v5)
    CFRelease(v5);
  if (v4)
    CFRelease(v4);
  if (v10 < 0)
    operator delete(__p[0]);
  return CanAutocorrectSomewhere != 0;
}

BOOL TI::VulgarWordUsageDatabaseWrapper::perform_maintenance(TI::VulgarWordUsageDatabaseWrapper *this)
{
  return LXVulgarWordUsageDatabasePerformMaintenance() != 0;
}

BOOL TI::VulgarWordUsageDatabaseWrapper::clear(TI::VulgarWordUsageDatabaseWrapper *this)
{
  return LXVulgarWordUsageDatabaseReset() != 0;
}

uint64_t TI::VulgarWordUsageDatabaseWrapper::set_current_app_id(uint64_t this, const char *a2)
{
  *(_QWORD *)(this + 8) = a2;
  return this;
}

uint64_t TI::VulgarWordUsageDatabaseWrapper::get_current_app_id(TI::VulgarWordUsageDatabaseWrapper *this)
{
  return *((_QWORD *)this + 1);
}

void TI::VulgarWordUsageDatabaseWrapper::set_current_recipient_ids(uint64_t a1, std::string **a2)
{
  std::vector<std::string> *v2;

  v2 = (std::vector<std::string> *)(a1 + 16);
  if (v2 != (std::vector<std::string> *)a2)
    std::vector<std::string>::__assign_with_size[abi:nn180100]<std::string*,std::string*>(v2, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
}

std::string *TI::VulgarWordUsageDatabaseWrapper::get_current_recipient_ids@<X0>(__int128 **this@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  return std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(a2, this[2], this[3], 0xAAAAAAAAAAAAAAABLL * (((char *)this[3] - (char *)this[2]) >> 3));
}

void KB::LanguageModelImplStub::~LanguageModelImplStub(KB::LanguageModelImplStub *this)
{
  KB::LanguageModelImplStub::~LanguageModelImplStub(this);
  JUMPOUT(0x1DF0A2144);
}

{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  const void *v8;
  void *v9;
  void *v10;

  *(_QWORD *)this = &off_1EA103570;
  KB::LanguageModelImplStub::wrapper_cache_mutex(this);
  std::mutex::lock(&KB::LanguageModelImplStub::wrapper_cache_mutex(void)::mutex);
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 20);
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  std::mutex::unlock(&KB::LanguageModelImplStub::wrapper_cache_mutex(void)::mutex);
  std::mutex::~mutex((std::mutex *)((char *)this + 224));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 176));
  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 20);
  if (v5)
  {
    v6 = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  *(_QWORD *)this = off_1EA103830;
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 136);
  v8 = (const void *)*((_QWORD *)this + 16);
  if (v8)
  {
    _Block_release(v8);
    v9 = (void *)*((_QWORD *)this + 16);
  }
  else
  {
    v9 = 0;
  }
  *((_QWORD *)this + 16) = 0;

  v10 = (void *)*((_QWORD *)this + 13);
  if (v10)
  {
    *((_QWORD *)this + 14) = v10;
    operator delete(v10);
  }
  KB::LanguageModelConfig::~LanguageModelConfig((KB::LanguageModelImplStub *)((char *)this + 8));
}

BOOL KB::LanguageModelImplStub::is_valid(KB::LanguageModelImplStub *this)
{
  uint64_t v1;
  unsigned __int8 v2;
  unsigned __int8 *v3;

  if ((*((_BYTE *)this + 169) & 1) == 0)
    return 0;
  v1 = *((_QWORD *)this + 19);
  v2 = atomic_load((unsigned __int8 *)(v1 + 120));
  if ((v2 & 1) == 0 || !*(_QWORD *)v1)
    return 0;
  v3 = (unsigned __int8 *)*((_QWORD *)this + 19);
  atomic_load(v3 + 120);
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)v3 + 16))(*(_QWORD *)v3) != 0;
}

uint64_t KB::LanguageModelImplStub::is_string_based_lm_model(KB::LanguageModelImplStub *this)
{
  return 0;
}

uint64_t KB::LanguageModelImplStub::supports_prediction(KB::LanguageModelImplStub *this)
{
  return 0;
}

void KB::LanguageModelImplStub::active_locale_identifiers_vector(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void KB::LanguageModelImplStub::load(KB::LanguageModelImplStub *this)
{
  KB::LanguageModel *v2;
  unsigned __int8 v3;
  id v4;

  v2 = (KB::LanguageModel *)pthread_main_np();
  if ((_DWORD)v2)
  {
    KB::LanguageModelImplStub::_load_if_necessary(this);
    v3 = atomic_load((unsigned __int8 *)this + 169);
    if ((v3 & 1) == 0)
      KB::LanguageModelImplStub::_wait_for_load(this);
  }
  else
  {
    KB::LanguageModel::background_loading_queue(v2);
    v4 = (id)objc_claimAutoreleasedReturnValue();
    TIDispatchSync();

  }
}

uint64_t KB::LanguageModelImplStub::synchronized_load(KB::LanguageModelImplStub *this)
{
  return (*(uint64_t (**)(KB::LanguageModelImplStub *, uint64_t))(*(_QWORD *)this + 72))(this, 1);
}

BOOL KB::LanguageModelImplStub::is_dynamic_word_id(KB::LanguageModelImplStub *this, unint64_t a2)
{
  return a2 >> 54 == 3;
}

uint64_t KB::LanguageModelImplStub::add_dynamic_word(KB::LanguageModelImplStub *this, const __CFString *a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned __int8 v6;
  KB::MutableLexiconWrapper *v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v11[8];
  void *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (*(uint64_t (**)(KB::LanguageModelImplStub *))(*(_QWORD *)this + 40))(this);
  if ((*(unsigned int (**)(KB::LanguageModelImplStub *))(*(_QWORD *)this + 16))(this))
  {
    KB::utf8_string(a2, (uint64_t)v11);
    if ((*((_BYTE *)this + 169) & 1) != 0
      && (v5 = *((_QWORD *)this + 19), v6 = atomic_load((unsigned __int8 *)(v5 + 120)), (v6 & 1) != 0))
    {
      v7 = *(KB::MutableLexiconWrapper **)v5;
    }
    else
    {
      v7 = 0;
    }
    v9 = KB::MutableLexiconWrapper::add_entry(v7, (const KB::String *)v11);
    if (v12 && v11[6] == 1)
      free(v12);
    v8 = v9 << 32;
  }
  else
  {
    v8 = 0;
  }
  return v8 | v4;
}

void KB::LanguageModelImplStub::increment_usage_count(KB::LanguageModelImplStub *this, const KB::String *a2, const TITokenID *a3, const KB::LanguageModelContext *a4)
{
  uint64_t v8;
  unsigned __int8 v9;
  KB::MutableLexiconWrapper *v10;

  if ((*(unsigned int (**)(KB::LanguageModelImplStub *, const KB::String *, const TITokenID *, const KB::LanguageModelContext *))(*(_QWORD *)this + 16))(this, a2, a3, a4))
  {
    if (a3->word_id >= 0x1F4 && *(_WORD *)a2 != 0)
    {
      if ((*((_BYTE *)this + 169) & 1) != 0
        && (v8 = *((_QWORD *)this + 19), v9 = atomic_load((unsigned __int8 *)(v8 + 120)), (v9 & 1) != 0))
      {
        v10 = *(KB::MutableLexiconWrapper **)v8;
      }
      else
      {
        v10 = 0;
      }
      KB::MutableLexiconWrapper::increment_usage_count(v10, a2);
    }
  }
}

void KB::LanguageModelImplStub::decrement_usage_count(KB::LanguageModelImplStub *this, const KB::String *a2, const TITokenID *a3, const KB::LanguageModelContext *a4)
{
  unint64_t v7;
  uint64_t v9;
  unsigned __int8 v10;
  KB::LexiconWrapperBase *v11;
  uint64_t v12;
  unsigned __int8 v13;
  KB::MutableLexiconWrapper *v14;
  CFTypeRef cf;

  if ((*(unsigned int (**)(KB::LanguageModelImplStub *, const KB::String *, const TITokenID *, const KB::LanguageModelContext *))(*(_QWORD *)this + 16))(this, a2, a3, a4))
  {
    v7 = HIDWORD(*(unint64_t *)a3);
    if (v7)
    {
      if (v7 >= 0x1F4 && *(_WORD *)a2 != 0)
      {
        if ((*((_BYTE *)this + 169) & 1) != 0
          && (v9 = *((_QWORD *)this + 19), v10 = atomic_load((unsigned __int8 *)(v9 + 120)), (v10 & 1) != 0))
        {
          v11 = *(KB::LexiconWrapperBase **)v9;
        }
        else
        {
          v11 = 0;
        }
        KB::LexiconWrapperBase::entry_for_string(v11, a2, &cf);
        if (cf)
        {
          if ((*((_BYTE *)this + 169) & 1) != 0
            && (v12 = *((_QWORD *)this + 19), v13 = atomic_load((unsigned __int8 *)(v12 + 120)), (v13 & 1) != 0))
          {
            v14 = *(KB::MutableLexiconWrapper **)v12;
          }
          else
          {
            v14 = 0;
          }
          KB::MutableLexiconWrapper::increment_usage_count(v14, a2);
          if (cf)
            CFRelease(cf);
        }
      }
    }
  }
}

uint64_t KB::LanguageModelImplStub::register_negative_evidence(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a6 == 1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 328))(result);
  return result;
}

uint64_t KB::LanguageModelImplStub::should_adapt_to_paragraph(KB::LanguageModelImplStub *this, const __CFString *a2)
{
  return 0;
}

uint64_t KB::LanguageModelImplStub::is_swear_word_policy_enabled(KB::LanguageModelImplStub *this)
{
  return 0;
}

float KB::LanguageModelImplStub::marginal_likelihood(KB::LanguageModelImplStub *this, const KB::String *a2, const TITokenID *a3)
{
  return 0.0;
}

void KB::LanguageModelImplStub::conditional_likelihood(KB::LanguageModelImplStub *this@<X0>, const TITokenID *a2@<X2>, float a3@<S0>, __CFString *a4@<X4>, uint64_t a5@<X8>)
{
  BOOL v11;
  const char *v12;
  std::string *v13;

  v11 = KB::LanguageModel::lexicon_id_active(this, a2->lexicon_id);
  if (a2->word_id < 0x1F4 || v11)
  {
    if (a4)
      KB::append_format(a4, (__CFString *)"LMMock - LM_score %f", v12, a3);
    *(float *)a5 = a3;
    *(float *)(a5 + 4) = a3;
    *(_DWORD *)(a5 + 8) = 0;
    std::string::basic_string[abi:nn180100]<0>((_QWORD *)(a5 + 16), "");
  }
  else
  {
    *(_QWORD *)a5 = KB::k_invalid_likelihood_value;
    *(_DWORD *)(a5 + 8) = dword_1F0281A78;
    v13 = (std::string *)(a5 + 16);
    if (byte_1F0281A97 < 0)
    {
      std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)aInvalidLikelih_1, *(std::string::size_type *)&aInvalidLikelih_1[8]);
    }
    else
    {
      *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)aInvalidLikelih_1;
      *(_QWORD *)(a5 + 32) = *(_QWORD *)&aInvalidLikelih_1[16];
    }
  }
}

void KB::LanguageModelImplStub::conditional_likelihood_batched(unsigned int **a1@<X1>, _QWORD *a2@<X2>, int a3@<W5>, _QWORD *a4@<X8>)
{
  unsigned int *v4;
  unsigned int *v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  void **v13;
  void **v14;
  uint64_t v15;
  unsigned int *v16;
  unint64_t v18;
  unsigned int *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t *v24;
  uint64_t v25;
  std::string *v26;
  __int128 v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  __int128 v46;
  int64x2_t v47;
  unint64_t v48;
  void **v49;
  _QWORD *v50;
  char *v51;
  uint64_t v52;
  std::string *v53;
  __int128 v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  int v59;
  __int128 v60;
  int64x2_t v61;
  void **v62;
  __int128 v65;
  __int128 __p;
  uint64_t v67;
  int64x2_t v68;
  char *v69;
  void **v70;
  int64x2_t v71;
  void **v72;
  char **v73;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if (a3)
  {
    v4 = *a1;
    v5 = a1[1];
    if (*a1 != v5)
    {
      do
      {
        std::vector<KB::LikelihoodInfo>::vector(&v65, *v4, (uint64_t)&KB::k_invalid_likelihood_value);
        v6 = (_QWORD *)a4[1];
        v7 = a4[2];
        if ((unint64_t)v6 >= v7)
        {
          v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v6 - *a4) >> 3);
          v10 = v9 + 1;
          if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
            goto LABEL_64;
          v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a4) >> 3);
          if (2 * v11 > v10)
            v10 = 2 * v11;
          if (v11 >= 0x555555555555555)
            v12 = 0xAAAAAAAAAAAAAAALL;
          else
            v12 = v10;
          v73 = (char **)(a4 + 2);
          v13 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v12);
          v14 = &v13[3 * v9];
          v70 = v13;
          v71.i64[0] = (uint64_t)v14;
          v72 = &v13[3 * v15];
          v14[1] = 0;
          v14[2] = 0;
          *v14 = 0;
          *(_OWORD *)v14 = v65;
          v14[2] = (void *)__p;
          v65 = 0uLL;
          *(_QWORD *)&__p = 0;
          v71.i64[1] = (uint64_t)(v14 + 3);
          std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(a4, &v70);
          v8 = (_QWORD *)a4[1];
          std::__split_buffer<std::vector<KB::LikelihoodInfo>>::~__split_buffer((uint64_t)&v70);
        }
        else
        {
          *v6 = 0;
          v6[1] = 0;
          v6[2] = 0;
          *(_OWORD *)v6 = v65;
          v6[2] = __p;
          v65 = 0uLL;
          *(_QWORD *)&__p = 0;
          v8 = v6 + 3;
        }
        a4[1] = v8;
        v70 = (void **)&v65;
        std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100](&v70);
        v4 += 250;
      }
      while (v4 != v5);
    }
  }
  else
  {
    v16 = *a1;
    if (a1[1] != *a1)
    {
      v18 = 0;
      do
      {
        v19 = &v16[250 * v18];
        v68 = 0uLL;
        v69 = 0;
        if (*(_QWORD *)v19)
        {
          v20 = 0;
          do
          {
            if (*(_BYTE *)(*(_QWORD *)(*a2 + 24 * v18) + 2 * v20))
            {
              LODWORD(v65) = *(_DWORD *)(*((_QWORD *)v19 + 1) + 240 * v20 + 52);
              *(_QWORD *)((char *)&v65 + 4) = v65;
              std::string::basic_string[abi:nn180100]<0>(&__p, "");
              v21 = v68.i64[1];
              if (v68.i64[1] >= (unint64_t)v69)
              {
                v28 = 0xCCCCCCCCCCCCCCCDLL * ((v68.i64[1] - v68.i64[0]) >> 3);
                v29 = v28 + 1;
                if (v28 + 1 > 0x666666666666666)
                  goto LABEL_64;
                if (0x999999999999999ALL * ((uint64_t)&v69[-v68.i64[0]] >> 3) > v29)
                  v29 = 0x999999999999999ALL * ((uint64_t)&v69[-v68.i64[0]] >> 3);
                if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v69[-v68.i64[0]] >> 3) >= 0x333333333333333)
                  v30 = 0x666666666666666;
                else
                  v30 = v29;
                v73 = &v69;
                if (v30)
                  v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v30);
                else
                  v31 = 0;
                v38 = v30 + 40 * v28;
                v39 = v65;
                *(_DWORD *)(v38 + 8) = DWORD2(v65);
                *(_QWORD *)v38 = v39;
                v40 = __p;
                *(_QWORD *)(v38 + 32) = v67;
                *(_OWORD *)(v38 + 16) = v40;
                v67 = 0;
                __p = 0uLL;
                v41 = v68.i64[1];
                v42 = v68.i64[0];
                if (v68.i64[1] == v68.i64[0])
                {
                  v47 = vdupq_n_s64(v68.u64[1]);
                  v43 = v30 + 40 * v28;
                }
                else
                {
                  v43 = v30 + 40 * v28;
                  do
                  {
                    v44 = *(_QWORD *)(v41 - 40);
                    v41 -= 40;
                    v45 = *(_DWORD *)(v41 + 8);
                    *(_QWORD *)(v43 - 40) = v44;
                    v43 -= 40;
                    *(_DWORD *)(v43 + 8) = v45;
                    v46 = *(_OWORD *)(v41 + 16);
                    *(_QWORD *)(v43 + 32) = *(_QWORD *)(v41 + 32);
                    *(_OWORD *)(v43 + 16) = v46;
                    *(_QWORD *)(v41 + 24) = 0;
                    *(_QWORD *)(v41 + 32) = 0;
                    *(_QWORD *)(v41 + 16) = 0;
                  }
                  while (v41 != v42);
                  v47 = v68;
                }
                v48 = v38 + 40;
                v68.i64[0] = v43;
                v68.i64[1] = v38 + 40;
                v71 = v47;
                v49 = (void **)v69;
                v69 = (char *)(v30 + 40 * v31);
                v72 = v49;
                v70 = (void **)v47.i64[0];
                std::__split_buffer<KB::LikelihoodInfo>::~__split_buffer((uint64_t)&v70);
                v68.i64[1] = v48;
                if (SHIBYTE(v67) < 0)
                  operator delete((void *)__p);
              }
              else
              {
                v22 = v65;
                *(_DWORD *)(v68.i64[1] + 8) = DWORD2(v65);
                *(_QWORD *)v21 = v22;
                v23 = __p;
                *(_QWORD *)(v21 + 32) = v67;
                *(_OWORD *)(v21 + 16) = v23;
                v68.i64[1] = v21 + 40;
              }
            }
            else
            {
              v24 = (uint64_t *)v68.i64[1];
              if (v68.i64[1] >= (unint64_t)v69)
              {
                v32 = 0xCCCCCCCCCCCCCCCDLL * ((v68.i64[1] - v68.i64[0]) >> 3);
                v33 = v32 + 1;
                if (v32 + 1 > 0x666666666666666)
LABEL_64:
                  abort();
                if (0x999999999999999ALL * ((uint64_t)&v69[-v68.i64[0]] >> 3) > v33)
                  v33 = 0x999999999999999ALL * ((uint64_t)&v69[-v68.i64[0]] >> 3);
                if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v69[-v68.i64[0]] >> 3) >= 0x333333333333333)
                  v34 = 0x666666666666666;
                else
                  v34 = v33;
                v73 = &v69;
                if (v34)
                {
                  v35 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v34);
                  v37 = v36;
                }
                else
                {
                  v35 = 0;
                  v37 = 0;
                }
                v51 = &v35[40 * v32];
                v52 = KB::k_invalid_likelihood_value;
                *((_DWORD *)v51 + 2) = dword_1F0281A78;
                *(_QWORD *)v51 = v52;
                v53 = (std::string *)(v51 + 16);
                if (byte_1F0281A97 < 0)
                {
                  std::string::__init_copy_ctor_external(v53, *(const std::string::value_type **)aInvalidLikelih_1, *(std::string::size_type *)&aInvalidLikelih_1[8]);
                }
                else
                {
                  v54 = *(_OWORD *)aInvalidLikelih_1;
                  *((_QWORD *)v51 + 4) = *(_QWORD *)&aInvalidLikelih_1[16];
                  *(_OWORD *)&v53->__r_.__value_.__l.__data_ = v54;
                }
                v55 = v68.i64[1];
                v56 = v68.i64[0];
                if (v68.i64[1] == v68.i64[0])
                {
                  v61 = vdupq_n_s64(v68.u64[1]);
                  v57 = v51;
                }
                else
                {
                  v57 = v51;
                  do
                  {
                    v58 = *(_QWORD *)(v55 - 40);
                    v55 -= 40;
                    v59 = *(_DWORD *)(v55 + 8);
                    *((_QWORD *)v57 - 5) = v58;
                    v57 -= 40;
                    *((_DWORD *)v57 + 2) = v59;
                    v60 = *(_OWORD *)(v55 + 16);
                    *((_QWORD *)v57 + 4) = *(_QWORD *)(v55 + 32);
                    *((_OWORD *)v57 + 1) = v60;
                    *(_QWORD *)(v55 + 24) = 0;
                    *(_QWORD *)(v55 + 32) = 0;
                    *(_QWORD *)(v55 + 16) = 0;
                  }
                  while (v55 != v56);
                  v61 = v68;
                }
                v50 = v51 + 40;
                v68.i64[0] = (uint64_t)v57;
                v68.i64[1] = (uint64_t)v50;
                v71 = v61;
                v62 = (void **)v69;
                v69 = &v35[40 * v37];
                v72 = v62;
                v70 = (void **)v61.i64[0];
                std::__split_buffer<KB::LikelihoodInfo>::~__split_buffer((uint64_t)&v70);
              }
              else
              {
                v25 = KB::k_invalid_likelihood_value;
                *(_DWORD *)(v68.i64[1] + 8) = dword_1F0281A78;
                *v24 = v25;
                v26 = (std::string *)(v24 + 2);
                if (byte_1F0281A97 < 0)
                {
                  std::string::__init_copy_ctor_external(v26, *(const std::string::value_type **)aInvalidLikelih_1, *(std::string::size_type *)&aInvalidLikelih_1[8]);
                }
                else
                {
                  v27 = *(_OWORD *)aInvalidLikelih_1;
                  v24[4] = *(_QWORD *)&aInvalidLikelih_1[16];
                  *(_OWORD *)&v26->__r_.__value_.__l.__data_ = v27;
                }
                v50 = v24 + 5;
              }
              v68.i64[1] = (uint64_t)v50;
            }
            ++v20;
          }
          while (v20 < *(_QWORD *)v19);
        }
        std::vector<std::vector<KB::LikelihoodInfo>>::emplace_back<std::vector<KB::LikelihoodInfo>&>(a4, (__int128 **)&v68);
        v70 = (void **)&v68;
        std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100](&v70);
        ++v18;
        v16 = *a1;
      }
      while (v18 < 0x1CAC083126E978D5 * (((char *)a1[1] - (char *)*a1) >> 3));
    }
  }
}

void KB::LanguageModelImplStub::predictions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  const void *v9;
  os_signpost_id_t v10;
  os_signpost_id_t v11;
  uint64_t v12;
  NSObject *v13;
  os_signpost_id_t v14;
  os_signpost_id_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  KB::LanguageModelImplStub *v19;
  const KB::LanguageModelContext *v20;
  unsigned int v21;
  void *v22[8];
  char v23;
  void *__p;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  void **v30;

  kdebug_trace();
  kac_get_log();
  v8 = (id)objc_claimAutoreleasedReturnValue();
  v9 = (const void *)(a1 ^ 0xCD);
  v10 = os_signpost_id_make_with_pointer(v8, (const void *)(a1 ^ 0xCD));
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v11 = v10;
    if (os_signpost_enabled(v8))
    {
      LOWORD(v22[0]) = 0;
      _os_signpost_emit_with_name_impl(&dword_1DA6F2000, v8, OS_SIGNPOST_INTERVAL_BEGIN, v11, "kbdManager.languageModel.stubGenerateCompletionsAndPredictions", "", (uint8_t *)v22, 2u);
    }
  }

  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(&v28, a1, a2, a3);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28))
  {
    while (1)
    {
      (*(void (**)(void **__return_ptr))(*(_QWORD *)v28 + 16))(v22);
      v12 = *(_QWORD *)(a4 + 24);
      if (!v12)
        break;
      (*(void (**)(uint64_t, void **))(*(_QWORD *)v12 + 48))(v12, v22);
      v30 = (void **)&v27;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v30);
      v30 = (void **)&v26;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v30);
      if (v25 < 0)
        operator delete(__p);
      if (v23 < 0)
        operator delete(v22[6]);
      if (v22[0])
      {
        v22[1] = v22[0];
        operator delete(v22[0]);
      }
      if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28) & 1) == 0)
        goto LABEL_13;
    }
    std::__throw_bad_function_call[abi:nn180100]();
    KB::LanguageModelImplStub::create_prediction_enumerator(v19, v20, v21);
  }
  else
  {
LABEL_13:
    kdebug_trace();
    kac_get_log();
    v13 = (id)objc_claimAutoreleasedReturnValue();
    v14 = os_signpost_id_make_with_pointer(v13, v9);
    if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v15 = v14;
      if (os_signpost_enabled(v13))
      {
        LOWORD(v22[0]) = 0;
        _os_signpost_emit_with_name_impl(&dword_1DA6F2000, v13, OS_SIGNPOST_INTERVAL_END, v15, "kbdManager.languageModel.stubGenerateCompletionsAndPredictions", "", (uint8_t *)v22, 2u);
      }
    }

    v16 = v29;
    if (v29)
    {
      p_shared_owners = (unint64_t *)&v29->__shared_owners_;
      do
        v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
}

_QWORD *KB::LanguageModelImplStub::create_prediction_enumerator@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x20uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_1EA103A90;
  a1[1] = v4;
  v4[3] = &unk_1EA103AC8;
  result = v4 + 3;
  *a1 = result;
  return result;
}

uint64_t KB::LanguageModelImplStub::is_token_blocklisted()
{
  return 0;
}

BOOL KB::LanguageModelImplStub::predictions(uint64_t a1, const KB::Candidate **a2, KB::LanguageModelContext *a3, uint64_t a4)
{
  const KB::Candidate *v4;
  const KB::Candidate *v5;
  KB::LanguageModel *v8;
  void **v9;
  uint64_t v10;
  BOOL v11;
  TITokenID v12;
  TITokenID v13;
  CFIndex prediction_count;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  char v23[8];
  std::__shared_weak_count *v24;
  void *__p;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  _BYTE v31[24];
  _BYTE *v32;
  int v33;
  __int16 v34;
  char v35;
  void *v36;
  char v37;
  void **v38[127];

  v38[125] = *(void ***)MEMORY[0x1E0C80C00];
  v30 = 0;
  v4 = *a2;
  v5 = a2[1];
  if (*a2 != v5)
  {
    while (1)
    {
      KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v23, a3);
      v8 = KB::Candidate::Candidate((KB::Candidate *)v38, v4);
      if (v38[0])
      {
        v9 = v38[1];
        v10 = 240 * (uint64_t)v38[0];
        do
        {
          if ((*((_BYTE *)v9 + 135) & 4) == 0)
            goto LABEL_10;
          v34 = 0;
          v35 = 0;
          v36 = " ";
          v33 = 1048577;
          v37 = 0;
          if (v9 != (void **)&v33)
          {
            v11 = KB::String::equal((KB::String *)v9, (const KB::String *)&v33, 1);
            v8 = (KB::LanguageModel *)v36;
            if (v36 && v35 == 1)
              free(v36);
            if (!v11)
            {
LABEL_10:
              *((float *)v9 + 24) = (*(float (**)(uint64_t, _QWORD, KB::LanguageModelContext *))(*(_QWORD *)a1 + 432))(a1, *((unsigned int *)v9 + 34), a3);
              v12 = (TITokenID)v9[17];
              KB::Word::capitalized_string((KB::Word *)v9, (uint64_t)&v33);
              v13 = v12;
              KB::LanguageModelContext::append((KB::LanguageModelContext *)v23, v13, (const KB::String *)&v33, 0);
              v8 = (KB::LanguageModel *)v36;
              if (v36 && v35 == 1)
                free(v36);
            }
          }
          v9 += 30;
          v10 -= 240;
        }
        while (v10);
      }
      prediction_count = KB::LanguageModel::get_prediction_count(v8);
      v15 = operator new(0x28uLL);
      *v15 = &off_1EA103B30;
      v15[1] = &v30;
      v15[2] = a4;
      v15[3] = v38;
      v15[4] = v23;
      v32 = v15;
      (*(void (**)(uint64_t, char *, CFIndex, _BYTE *))(*(_QWORD *)a1 + 440))(a1, v23, prediction_count, v31);
      v16 = v32;
      if (v32 == v31)
        break;
      if (v32)
      {
        v17 = 5;
LABEL_18:
        (*(void (**)(void))(*v16 + 8 * v17))();
      }
      KB::Candidate::~Candidate((KB::Candidate *)v38);
      v38[0] = (void **)&v29;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v38);
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v28);
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v27);
      if (__p)
      {
        v26 = __p;
        operator delete(__p);
      }
      v18 = v24;
      if (v24)
      {
        p_shared_owners = (unint64_t *)&v24->__shared_owners_;
        do
          v20 = __ldaxr(p_shared_owners);
        while (__stlxr(v20 - 1, p_shared_owners));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      v4 = (const KB::Candidate *)((char *)v4 + 1000);
      if (v4 == v5)
        return v30 != 0;
    }
    v16 = v31;
    v17 = 4;
    goto LABEL_18;
  }
  return 0;
}

uint64_t KB::LanguageModelImplStub::completions(uint64_t a1, const KB::Candidate **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const KB::Candidate *v5;
  const KB::Candidate *v6;
  int v11;
  KB::Candidate *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  KB::Candidate *v17;
  KB::Candidate *v18;
  char *v19;
  KB::Candidate **v20;
  _BYTE v21[24];
  _BYTE *v22;
  _BYTE v23[1000];
  _QWORD v24[126];

  v24[125] = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  v6 = a2[1];
  if (*a2 != v6)
  {
    v11 = 0;
    while (1)
    {
      KB::Candidate::Candidate((KB::Candidate *)v24, v5);
      KB::Candidate::pop_last_word((KB::Candidate *)v24);
      if (v24[0])
        break;
LABEL_11:
      KB::Candidate::~Candidate((KB::Candidate *)v24);
      v5 = (const KB::Candidate *)((char *)v5 + 1000);
      if (v5 == v6)
        return v11 & 1;
    }
    KB::Candidate::Candidate((KB::Candidate *)v23, (const KB::Candidate *)v24);
    v17 = (KB::Candidate *)operator new(0x3E8uLL);
    v18 = v17;
    v12 = (KB::Candidate *)((char *)v17 + 1000);
    v19 = (char *)v17 + 1000;
    KB::Candidate::Candidate(v17, (const KB::Candidate *)v23);
    v18 = v12;
    std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v21, a4);
    (*(void (**)(uint64_t, KB::Candidate **, uint64_t, _BYTE *, _QWORD))(*(_QWORD *)a1 + 488))(a1, &v17, a3, v21, 0);
    v13 = v22;
    if (v22 == v21)
    {
      v13 = v21;
      v14 = 4;
    }
    else
    {
      if (!v22)
      {
LABEL_9:
        v20 = &v17;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v20);
        KB::Candidate::~Candidate((KB::Candidate *)v23);
        v15 = *(_QWORD *)(a5 + 24);
        if (!v15)
          std::__throw_bad_function_call[abi:nn180100]();
        v11 |= (*(uint64_t (**)(uint64_t, const KB::Candidate *))(*(_QWORD *)v15 + 48))(v15, v5);
        goto LABEL_11;
      }
      v14 = 5;
    }
    (*(void (**)(void))(*v13 + 8 * v14))();
    goto LABEL_9;
  }
  LOBYTE(v11) = 0;
  return v11 & 1;
}

void KB::LanguageModelImplStub::background_load(KB::LanguageModelImplStub *this)
{
  unsigned __int8 v2;

  KB::LanguageModelImplStub::_load_if_necessary(this);
  v2 = atomic_load((unsigned __int8 *)this + 169);
  if ((v2 & 1) == 0)
    KB::LanguageModelImplStub::_wait_for_load(this);
}

uint64_t KB::LanguageModelImplStub::do_store(KB::LanguageModelImplStub *this)
{
  uint64_t result;
  unsigned __int8 *v3;
  unsigned __int8 v4;
  uint64_t v5;

  result = (*(uint64_t (**)(KB::LanguageModelImplStub *))(*(_QWORD *)this + 16))(this);
  if ((_DWORD)result)
  {
    if ((*((_BYTE *)this + 169) & 1) != 0
      && (v3 = (unsigned __int8 *)*((_QWORD *)this + 19), v4 = atomic_load(v3 + 120), (v4 & 1) != 0))
    {
      v5 = *(_QWORD *)v3;
    }
    else
    {
      v5 = 0;
    }
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
    if (result)
      return LXLexiconWrite();
  }
  return result;
}

void KB::LanguageModelImplStub::_load_if_necessary(KB::LanguageModelImplStub *this)
{
  unsigned __int8 *v2;
  unsigned __int8 v3;
  const void *ValueAtIndex;
  const __CFString *v5;
  const void *v6;
  void *v7;
  const __CFString *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t *v17;
  __int128 v18;
  _BYTE v19[8];
  void *v20;
  std::unique_lock<std::mutex> v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = (unsigned __int8 *)this + 168;
  do
    v3 = __ldaxr(v2);
  while (__stlxr(1u, v2));
  if ((v3 & 1) == 0)
  {
    if (*((_QWORD *)this + 5))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 2), 0);
      v5 = (const __CFString *)MEMORY[0x1DF0A08CC](ValueAtIndex);
      KB::utf8_string(v5, (uint64_t)&v21);
      v6 = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 2), 0);
      v7 = (void *)MEMORY[0x1DF0A08CC](v6);
      v8 = (const __CFString *)UIKeyboardDynamicDictionaryFileWithSiriMode(v7, *((void **)this + 5), 0);
      KB::utf8_string(v8, (uint64_t)v19);
      KB::LanguageModelImplStub::get_or_create_shared_handle((KB::LanguageModelImplStub *)&v21, (const KB::String *)v19, (uint64_t)&v18);
      std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100]((uint64_t)this + 152, &v18);
      v9 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
      if (*((_QWORD *)&v18 + 1))
      {
        v10 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      KB::LanguageModelImplStub::WrapperHandle::wait_until_ready(*((KB::LanguageModelImplStub::WrapperHandle **)this + 19));
      if (v20 && v19[6] == 1)
        free(v20);
      if (*(_QWORD *)&v21.__owns_ && BYTE6(v21.__m_) == 1)
        free(*(void **)&v21.__owns_);
    }
    else
    {
      v12 = operator new(0x98uLL);
      v13 = _ZNSt3__120__shared_ptr_emplaceIN2KB21LanguageModelImplStub13WrapperHandleENS_9allocatorIS3_EEEC2B8nn180100IJES5_Li0EEES5_DpOT_((uint64_t)v12);
      v21.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v13 + 24);
      *(_QWORD *)&v21.__owns_ = v13;
      std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100]((uint64_t)this + 152, (__int128 *)&v21);
      v14 = *(std::__shared_weak_count **)&v21.__owns_;
      if (*(_QWORD *)&v21.__owns_)
      {
        v15 = (unint64_t *)(*(_QWORD *)&v21.__owns_ + 8);
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      v17 = (uint64_t *)*((_QWORD *)this + 19);
      v21.__m_ = 0;
      KB::LanguageModelImplStub::WrapperHandle::set(v17, (uint64_t *)&v21);
      if (v21.__m_)
        (*(void (**)(std::unique_lock<std::mutex>::mutex_type *))(v21.__m_->__m_.__sig + 8))(v21.__m_);
    }
    v21.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 224);
    v21.__owns_ = 1;
    std::mutex::lock((std::mutex *)((char *)this + 224));
    atomic_store(1u, (unsigned __int8 *)this + 169);
    std::condition_variable::notify_all((std::condition_variable *)((char *)this + 176));
    std::unique_lock<std::mutex>::unlock(&v21);
    if ((*(unsigned int (**)(KB::LanguageModelImplStub *))(*(_QWORD *)this + 16))(this))
      TILanguageModelScheduleMaintenance();
    if (v21.__owns_)
      std::mutex::unlock(v21.__m_);
  }
}

void KB::LanguageModelImplStub::_wait_for_load(KB::LanguageModelImplStub *this)
{
  KB::LanguageModel *v2;
  void *v3;
  std::mutex *m;
  std::unique_lock<std::mutex> v5;

  if (pthread_main_np())
  {
    v2 = (KB::LanguageModel *)dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, QOS_CLASS_USER_INTERACTIVE, -1, &__block_literal_global_4);
    KB::LanguageModel::background_loading_queue(v2);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    TIDispatchAsync();

  }
  m = (std::mutex *)((char *)this + 224);
  v5.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 224);
  v5.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 224));
  if ((*((_BYTE *)this + 169) & 1) != 0)
    goto LABEL_7;
  do
    std::condition_variable::wait((std::condition_variable *)((char *)this + 176), &v5);
  while ((*((_BYTE *)this + 169) & 1) == 0);
  if (v5.__owns_)
  {
    m = v5.__m_;
LABEL_7:
    std::mutex::unlock(m);
  }
}

void KB::LanguageModelImplStub::get_or_create_shared_handle(KB::LanguageModelImplStub *this@<X0>, const KB::String *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  char *v7;
  char *v8;
  KB::LanguageModelImplStub *v9;
  uint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint8x8_t v15;
  unint64_t v16;
  unint64_t v17;
  unsigned __int8 **v18;
  unsigned __int8 *v19;
  unint64_t v20;
  void *v21;
  uint64_t v22;
  KB::LanguageModelImplStub *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  int v27;
  const std::string::value_type *v28;
  void *v29;
  uint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint8x8_t v35;
  unint64_t v36;
  void **v37;
  char *v38;
  unint64_t v39;
  std::string *v40;
  float v41;
  _BOOL8 v42;
  unint64_t v43;
  unint64_t v44;
  size_t v45;
  uint64_t v46;
  _QWORD *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  unint64_t *v51;
  unint64_t v52;
  std::__shared_weak_count *v53;
  CFTypeRef *v54;
  std::__shared_weak_count *v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  const KB::String *v59;
  KB::LanguageModelImplStub::WrapperHandle *v60;
  const KB::String *v61;
  void *__p[2];
  uint64_t v63;
  std::unique_lock<std::mutex> v64;
  __int128 v65;
  char v66;

  v5 = (unint64_t)this;
  KB::LanguageModelImplStub::wrapper_cache_mutex(this);
  v64.__m_ = &KB::LanguageModelImplStub::wrapper_cache_mutex(void)::mutex;
  v64.__owns_ = 1;
  std::mutex::lock(&KB::LanguageModelImplStub::wrapper_cache_mutex(void)::mutex);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v7 = *(char **)(v5 + 8);
  if (!v7)
    v7 = (char *)(v5 + 16);
  if (*(_WORD *)v5)
    v8 = v7;
  else
    v8 = "";
  v9 = (KB::LanguageModelImplStub *)std::string::basic_string[abi:nn180100]<0>(__p, v8);
  KB::LanguageModelImplStub::wrapper_cache(v9);
  if (v63 >= 0)
    v10 = (uint64_t *)__p;
  else
    v10 = (uint64_t *)__p[0];
  if (v63 >= 0)
    v11 = HIBYTE(v63);
  else
    v11 = (unint64_t)__p[1];
  v12 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v10, v11);
  v13 = *((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1);
  if (!*((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1))
    goto LABEL_28;
  v14 = v12;
  v15 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 8));
  v15.i16[0] = vaddlv_u8(v15);
  v16 = v15.u32[0];
  if (v15.u32[0] > 1uLL)
  {
    v17 = v12;
    if (v12 >= *((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1))
      v17 = v12 % *((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1);
  }
  else
  {
    v17 = (*((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1) - 1) & v12;
  }
  v18 = *(unsigned __int8 ***)(KB::LanguageModelImplStub::wrapper_cache(void)::cache + 8 * v17);
  if (!v18 || (v19 = *v18) == 0)
  {
LABEL_28:
    KB::LanguageModelImplStub::wrapper_cache((KB::LanguageModelImplStub *)v12);
    goto LABEL_29;
  }
  while (1)
  {
    v20 = *((_QWORD *)v19 + 1);
    if (v20 == v14)
      break;
    if (v16 > 1)
    {
      if (v20 >= v13)
        v20 %= v13;
    }
    else
    {
      v20 &= v13 - 1;
    }
    if (v20 != v17)
      goto LABEL_28;
LABEL_27:
    v19 = *(unsigned __int8 **)v19;
    if (!v19)
      goto LABEL_28;
  }
  v12 = std::equal_to<std::string>::operator()[abi:nn180100](v19 + 16, (unsigned __int8 *)__p);
  if ((v12 & 1) == 0)
    goto LABEL_27;
  KB::LanguageModelImplStub::wrapper_cache((KB::LanguageModelImplStub *)v12);
  v65 = 0uLL;
  v55 = (std::__shared_weak_count *)*((_QWORD *)v19 + 6);
  if (v55)
  {
    *((_QWORD *)&v65 + 1) = std::__shared_weak_count::lock(v55);
    if (*((_QWORD *)&v65 + 1))
      *(_QWORD *)&v65 = *((_QWORD *)v19 + 5);
  }
  std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100](a3, &v65);
  v56 = (std::__shared_weak_count *)*((_QWORD *)&v65 + 1);
  if (*((_QWORD *)&v65 + 1))
  {
    v57 = (unint64_t *)(*((_QWORD *)&v65 + 1) + 8);
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
  if (*(_QWORD *)a3)
  {
LABEL_91:
    if (SHIBYTE(v63) < 0)
      operator delete(__p[0]);
    if (v64.__owns_)
      std::mutex::unlock(v64.__m_);
  }
  else
  {
LABEL_29:
    v21 = operator new(0x98uLL);
    v22 = _ZNSt3__120__shared_ptr_emplaceIN2KB21LanguageModelImplStub13WrapperHandleENS_9allocatorIS3_EEEC2B8nn180100IJES5_Li0EEES5_DpOT_((uint64_t)v21);
    *(_QWORD *)&v65 = v22 + 24;
    *((_QWORD *)&v65 + 1) = v22;
    v23 = (KB::LanguageModelImplStub *)std::shared_ptr<std::vector<KB::LanguageModelContext>>::operator=[abi:nn180100](a3, &v65);
    v24 = (std::__shared_weak_count *)*((_QWORD *)&v65 + 1);
    if (*((_QWORD *)&v65 + 1))
    {
      v25 = (unint64_t *)(*((_QWORD *)&v65 + 1) + 8);
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    KB::LanguageModelImplStub::wrapper_cache(v23);
    v27 = SHIBYTE(v63);
    v28 = (const std::string::value_type *)__p[0];
    v29 = __p[1];
    if (v63 >= 0)
      v30 = (uint64_t *)__p;
    else
      v30 = (uint64_t *)__p[0];
    if (v63 >= 0)
      v31 = HIBYTE(v63);
    else
      v31 = (unint64_t)__p[1];
    v32 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v30, v31);
    v33 = v32;
    v34 = *((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1);
    v61 = (const KB::String *)v5;
    if (*((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1))
    {
      v35 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 8));
      v35.i16[0] = vaddlv_u8(v35);
      v36 = v35.u32[0];
      if (v35.u32[0] > 1uLL)
      {
        v5 = v32;
        if (v32 >= *((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1))
          v5 = v32 % *((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1);
      }
      else
      {
        v5 = (*((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1) - 1) & v32;
      }
      v37 = *(void ***)(KB::LanguageModelImplStub::wrapper_cache(void)::cache + 8 * v5);
      if (v37)
      {
        v38 = (char *)*v37;
        if (*v37)
        {
          do
          {
            v39 = *((_QWORD *)v38 + 1);
            if (v39 == v33)
            {
              if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v38 + 16, (unsigned __int8 *)__p))
              {
                v59 = v61;
                goto LABEL_82;
              }
            }
            else
            {
              if (v36 > 1)
              {
                if (v39 >= v34)
                  v39 %= v34;
              }
              else
              {
                v39 &= v34 - 1;
              }
              if (v39 != v5)
                break;
            }
            v38 = *(char **)v38;
          }
          while (v38);
        }
      }
    }
    v38 = (char *)operator new(0x38uLL);
    *(_QWORD *)&v65 = v38;
    *((_QWORD *)&v65 + 1) = &qword_1EDAEE4F0;
    *(_QWORD *)v38 = 0;
    *((_QWORD *)v38 + 1) = v33;
    v40 = (std::string *)(v38 + 16);
    if (v27 < 0)
    {
      std::string::__init_copy_ctor_external(v40, v28, (std::string::size_type)v29);
    }
    else
    {
      *(_OWORD *)&v40->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
      *((_QWORD *)v38 + 4) = v63;
    }
    *((_QWORD *)v38 + 5) = 0;
    *((_QWORD *)v38 + 6) = 0;
    v66 = 1;
    v41 = (float)(unint64_t)(qword_1EDAEE4F8 + 1);
    if (!v34 || (float)(*(float *)&dword_1EDAEE500 * (float)v34) < v41)
    {
      v42 = 1;
      if (v34 >= 3)
        v42 = (v34 & (v34 - 1)) != 0;
      v43 = v42 | (2 * v34);
      v44 = vcvtps_u32_f32(v41 / *(float *)&dword_1EDAEE500);
      if (v43 <= v44)
        v45 = v44;
      else
        v45 = v43;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)&KB::LanguageModelImplStub::wrapper_cache(void)::cache, v45);
      v34 = *((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1);
      if ((v34 & (v34 - 1)) != 0)
      {
        if (v33 >= *((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1))
          v5 = v33 % *((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1);
        else
          v5 = v33;
      }
      else
      {
        v5 = (*((_QWORD *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1) - 1) & v33;
      }
    }
    v46 = KB::LanguageModelImplStub::wrapper_cache(void)::cache;
    v47 = *(_QWORD **)(KB::LanguageModelImplStub::wrapper_cache(void)::cache + 8 * v5);
    if (v47)
    {
      *(_QWORD *)v38 = *v47;
      v59 = v61;
      goto LABEL_80;
    }
    *(_QWORD *)v38 = qword_1EDAEE4F0;
    qword_1EDAEE4F0 = (uint64_t)v38;
    *(_QWORD *)(v46 + 8 * v5) = &qword_1EDAEE4F0;
    v59 = v61;
    if (*(_QWORD *)v38)
    {
      v48 = *(_QWORD *)(*(_QWORD *)v38 + 8);
      if ((v34 & (v34 - 1)) != 0)
      {
        if (v48 >= v34)
          v48 %= v34;
      }
      else
      {
        v48 &= v34 - 1;
      }
      v47 = (_QWORD *)(KB::LanguageModelImplStub::wrapper_cache(void)::cache + 8 * v48);
LABEL_80:
      *v47 = v38;
    }
    *(_QWORD *)&v65 = 0;
    ++qword_1EDAEE4F8;
    std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,void *>>>>::reset[abi:nn180100]((uint64_t)&v65);
LABEL_82:
    v50 = *(uint64_t **)a3;
    v49 = *(_QWORD *)(a3 + 8);
    if (v49)
    {
      v51 = (unint64_t *)(v49 + 16);
      do
        v52 = __ldxr(v51);
      while (__stxr(v52 + 1, v51));
    }
    v53 = (std::__shared_weak_count *)*((_QWORD *)v38 + 6);
    *((_QWORD *)v38 + 5) = v50;
    *((_QWORD *)v38 + 6) = v49;
    if (v53)
      std::__shared_weak_count::__release_weak(v53);
    std::unique_lock<std::mutex>::unlock(&v64);
    v54 = (CFTypeRef *)operator new();
    *(_QWORD *)&v65 = KB::MutableLexiconWrapper::MutableLexiconWrapper(v54, v59, a2);
    if (v64.__m_)
    {
      if (!v64.__owns_)
      {
        std::mutex::lock(v64.__m_);
        v64.__owns_ = 1;
        KB::LanguageModelImplStub::WrapperHandle::set(*(uint64_t **)a3, (uint64_t *)&v65);
        if ((_QWORD)v65)
          (*(void (**)(_QWORD))(*(_QWORD *)v65 + 8))(v65);
        goto LABEL_91;
      }
    }
    else
    {
      std::__throw_system_error(1, "unique_lock::lock: references null mutex");
    }
    std::__throw_system_error(11, "unique_lock::lock: already locked");
    KB::LanguageModelImplStub::WrapperHandle::wait_until_ready(v60);
  }
}

void KB::LanguageModelImplStub::WrapperHandle::wait_until_ready(KB::LanguageModelImplStub::WrapperHandle *this)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  std::unique_lock<std::mutex> v4;

  v4.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 8);
  v4.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 8));
  v2 = atomic_load((unsigned __int8 *)this + 120);
  if ((v2 & 1) == 0)
  {
    do
    {
      std::condition_variable::wait((std::condition_variable *)((char *)this + 72), &v4);
      v3 = atomic_load((unsigned __int8 *)this + 120);
    }
    while ((v3 & 1) == 0);
  }
  if (v4.__owns_)
    std::mutex::unlock(v4.__m_);
}

uint64_t _ZNSt3__120__shared_ptr_emplaceIN2KB21LanguageModelImplStub13WrapperHandleENS_9allocatorIS3_EEEC2B8nn180100IJES5_Li0EEES5_DpOT_(uint64_t a1)
{
  std::mutex *v2;

  *(_QWORD *)a1 = &off_1EA103AF8;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 850045863;
  v2 = (std::mutex *)(a1 + 32);
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 1018212795;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 129) = 0u;
  std::mutex::lock((std::mutex *)(a1 + 32));
  *(_BYTE *)(a1 + 144) = 0;
  std::mutex::unlock(v2);
  return a1;
}

void KB::LanguageModelImplStub::WrapperHandle::set(uint64_t *a1, uint64_t *a2)
{
  std::mutex *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (std::mutex *)(a1 + 1);
  std::mutex::lock((std::mutex *)(a1 + 1));
  v5 = *a2;
  *a2 = 0;
  v6 = *a1;
  *a1 = v5;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  atomic_store(1u, (unsigned __int8 *)a1 + 120);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 9));
  std::mutex::unlock(v4);
}

void std::unique_lock<std::mutex>::unlock(std::unique_lock<std::mutex> *this)
{
  if (this->__owns_)
  {
    std::mutex::unlock(this->__m_);
    this->__owns_ = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    std::__shared_ptr_emplace<KB::LanguageModelImplStub::WrapperHandle>::~__shared_ptr_emplace();
  }
}

void std::__shared_ptr_emplace<KB::LanguageModelImplStub::WrapperHandle>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA103AF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::LanguageModelImplStub::WrapperHandle>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA103AF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::LanguageModelImplStub::WrapperHandle>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 96));
  std::mutex::~mutex((std::mutex *)(a1 + 32));
  result = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void *KB::LanguageModelImplStub::wrapper_cache_mutex(KB::LanguageModelImplStub *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE4AB8], &KB::LanguageModelImplStub::wrapper_cache_mutex(void)::mutex, &dword_1DA6F2000);
  }
  return &KB::LanguageModelImplStub::wrapper_cache_mutex(void)::mutex;
}

__int128 *KB::LanguageModelImplStub::wrapper_cache(KB::LanguageModelImplStub *this)
{
  unsigned __int8 v1;

  {
    KB::LanguageModelImplStub::wrapper_cache(void)::cache = 0u;
    *(_OWORD *)&qword_1EDAEE4F0 = 0u;
    dword_1EDAEE500 = 1065353216;
    __cxa_atexit((void (*)(void *))std::unordered_map<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>::~unordered_map[abi:nn180100], &KB::LanguageModelImplStub::wrapper_cache(void)::cache, &dword_1DA6F2000);
  }
  return &KB::LanguageModelImplStub::wrapper_cache(void)::cache;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,0>((uint64_t)v1 + 16);
    operator delete(v1);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,0>(uint64_t a1)
{
  std::__shared_weak_count *v2;

  v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::__function::__func<KB::LanguageModelImplStub::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelImplStub::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::LanguageModelImplStub::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelImplStub::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1EA103B30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelImplStub::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelImplStub::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA103B30;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::LanguageModelImplStub::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelImplStub::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24);
  if (!v3)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x1DA88C46CLL);
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v3 + 48))(v3, a2, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  **(_BYTE **)(a1 + 8) |= result;
  return result;
}

void KB::LanguageModelImplStub::PredictionEnumeratorStub::~PredictionEnumeratorStub(KB::LanguageModelImplStub::PredictionEnumeratorStub *this)
{
  JUMPOUT(0x1DF0A2144);
}

double KB::LanguageModelImplStub::PredictionEnumeratorStub::get_prediction@<D0>(uint64_t a1@<X8>)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  return result;
}

uint64_t KB::LanguageModelImplStub::PredictionEnumeratorStub::advance(KB::LanguageModelImplStub::PredictionEnumeratorStub *this)
{
  return 0;
}

void std::__shared_ptr_emplace<KB::LanguageModelImplStub::PredictionEnumeratorStub>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA103A90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::LanguageModelImplStub::PredictionEnumeratorStub>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA103A90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::LanguageModelImplStub::PredictionEnumeratorStub>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t ___ZN2KB21LanguageModelImplStub4loadEb_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 560))(*(_QWORD *)(a1 + 32));
}

uint64_t KB::LanguageModelImplStub::LanguageModelImplStub(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  const void *v6;
  __int128 v7;
  __int128 v8;
  CFTypeRef v10;
  CFTypeRef v11;
  CFTypeRef v12;
  CFTypeRef v13[2];
  CFTypeRef cf[2];
  __int128 v15;
  __int128 v16;
  int v17;

  v4 = *(const void **)a2;
  v10 = v4;
  if (v4)
  {
    CFRetain(v4);
    v10 = v4;
  }
  v5 = *(const void **)(a2 + 8);
  v11 = v5;
  if (v5)
  {
    CFRetain(v5);
    v11 = v5;
  }
  v6 = *(const void **)(a2 + 16);
  v12 = v6;
  if (v6)
  {
    CFRetain(v6);
    v12 = v6;
  }
  v7 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)v13 = v7;
  v8 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)cf = v8;
  v15 = *(_OWORD *)(a2 + 56);
  v16 = *(_OWORD *)(a2 + 72);
  v17 = *(_DWORD *)(a2 + 88);
  KB::LanguageModelImplBase::LanguageModelImplBase(a1, (uint64_t)&v10);
  if (cf[1])
    CFRelease(cf[1]);
  if (cf[0])
    CFRelease(cf[0]);
  if (v13[1])
    CFRelease(v13[1]);
  if (v13[0])
    CFRelease(v13[0]);
  if (v12)
    CFRelease(v12);
  if (v11)
    CFRelease(v11);
  if (v10)
    CFRelease(v10);
  *(_QWORD *)a1 = &off_1EA103570;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_WORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 1018212795;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = 850045863;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_QWORD *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_BYTE *)(a1 + 169) = 0;
  return a1;
}

uint64_t KB::LanguageModelImplStub::lexicon_wrapper(KB::LanguageModelImplStub *this)
{
  unsigned __int8 *v1;
  unsigned __int8 v2;

  if ((*((_BYTE *)this + 169) & 1) != 0
    && (v1 = (unsigned __int8 *)*((_QWORD *)this + 19), v2 = atomic_load(v1 + 120), (v2 & 1) != 0))
  {
    return *(_QWORD *)v1;
  }
  else
  {
    return 0;
  }
}

uint64_t KB::LanguageModelImplStub::WrapperHandle::get(KB::LanguageModelImplStub::WrapperHandle *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)this + 120);
  if ((v1 & 1) != 0)
    return *(_QWORD *)this;
  else
    return 0;
}

void KB::LanguageModelImplStub::perform_maintenance(KB::LanguageModelImplStub *this)
{
  KB::LanguageModelImplStub::enumerate_cached_wrappers(&__block_literal_global_13682);
}

void KB::LanguageModelImplStub::enumerate_cached_wrappers(void *a1)
{
  void (**v1)(_QWORD);
  __int128 *i;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::string __p;
  uint64_t v10;
  std::__shared_weak_count *v11;
  _BYTE v12[16];
  __int128 *v13;

  v1 = a1;
  KB::LanguageModelImplStub::copy_wrapper_cache((KB::LanguageModelImplStub *)v1, (uint64_t)v12);
  for (i = v13; i; i = *(__int128 **)i)
  {
    std::pair<std::string const,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>::pair[abi:nn180100](&__p, i + 1);
    if (v11)
    {
      v3 = std::__shared_weak_count::lock(v11);
      if (v3)
      {
        v4 = v3;
        if (v10)
        {
          v5 = atomic_load((unsigned __int8 *)(v10 + 120));
          if ((v5 & 1) != 0)
          {
            if (*(_QWORD *)v10)
            {
              v6 = atomic_load((unsigned __int8 *)(v10 + 120));
              if ((v6 & 1) != 0)
              {
                if (*(_QWORD *)v10)
                  v1[2](v1);
              }
            }
          }
        }
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v8 = __ldaxr(p_shared_owners);
        while (__stlxr(v8 - 1, p_shared_owners));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      if (v11)
        std::__shared_weak_count::__release_weak(v11);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>>>::~__hash_table((uint64_t)v12);

}

void KB::LanguageModelImplStub::copy_wrapper_cache(KB::LanguageModelImplStub *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2;
  KB::LanguageModelImplStub *v4;
  uint64_t v5;
  _QWORD *v6;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *i;
  unint64_t v17;
  char *v18;
  float v19;
  float v20;
  _BOOL8 v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD v28[2];
  char v29;

  KB::LanguageModelImplStub::wrapper_cache_mutex(this);
  std::mutex::lock(&KB::LanguageModelImplStub::wrapper_cache_mutex(void)::mutex);
  KB::LanguageModelImplStub::wrapper_cache(v4);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 32) = dword_1EDAEE500;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a2, *((size_t *)&KB::LanguageModelImplStub::wrapper_cache(void)::cache + 1));
  v5 = qword_1EDAEE4F0;
  if (qword_1EDAEE4F0)
  {
    v6 = (_QWORD *)(a2 + 16);
    do
    {
      v7 = *(char *)(v5 + 39);
      if (v7 >= 0)
        v8 = (uint64_t *)(v5 + 16);
      else
        v8 = *(uint64_t **)(v5 + 16);
      if (v7 >= 0)
        v9 = *(unsigned __int8 *)(v5 + 39);
      else
        v9 = *(_QWORD *)(v5 + 24);
      v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
      v11 = v10;
      v12 = *(_QWORD *)(a2 + 8);
      if (v12)
      {
        v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
        v13.i16[0] = vaddlv_u8(v13);
        v14 = v13.u32[0];
        if (v13.u32[0] > 1uLL)
        {
          v2 = v10;
          if (v10 >= v12)
            v2 = v10 % v12;
        }
        else
        {
          v2 = (v12 - 1) & v10;
        }
        v15 = *(unsigned __int8 ***)(*(_QWORD *)a2 + 8 * v2);
        if (v15)
        {
          for (i = *v15; i; i = *(unsigned __int8 **)i)
          {
            v17 = *((_QWORD *)i + 1);
            if (v17 == v11)
            {
              if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)(v5 + 16)))
                goto LABEL_47;
            }
            else
            {
              if (v14 > 1)
              {
                if (v17 >= v12)
                  v17 %= v12;
              }
              else
              {
                v17 &= v12 - 1;
              }
              if (v17 != v2)
                break;
            }
          }
        }
      }
      v18 = (char *)operator new(0x38uLL);
      v28[1] = a2 + 16;
      *(_QWORD *)v18 = 0;
      *((_QWORD *)v18 + 1) = v11;
      std::pair<std::string const,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>::pair[abi:nn180100]((std::string *)(v18 + 16), (__int128 *)(v5 + 16));
      v29 = 1;
      v19 = (float)(unint64_t)(*(_QWORD *)(a2 + 24) + 1);
      v20 = *(float *)(a2 + 32);
      if (!v12 || (float)(v20 * (float)v12) < v19)
      {
        v21 = (v12 & (v12 - 1)) != 0;
        if (v12 < 3)
          v21 = 1;
        v22 = v21 | (2 * v12);
        v23 = vcvtps_u32_f32(v19 / v20);
        if (v22 <= v23)
          v24 = v23;
        else
          v24 = v22;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a2, v24);
        v12 = *(_QWORD *)(a2 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v11 >= v12)
            v2 = v11 % v12;
          else
            v2 = v11;
        }
        else
        {
          v2 = (v12 - 1) & v11;
        }
      }
      v25 = *(_QWORD *)a2;
      v26 = *(_QWORD **)(*(_QWORD *)a2 + 8 * v2);
      if (v26)
      {
        *(_QWORD *)v18 = *v26;
      }
      else
      {
        *(_QWORD *)v18 = *v6;
        *v6 = v18;
        *(_QWORD *)(v25 + 8 * v2) = v6;
        if (!*(_QWORD *)v18)
          goto LABEL_46;
        v27 = *(_QWORD *)(*(_QWORD *)v18 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v27 >= v12)
            v27 %= v12;
        }
        else
        {
          v27 &= v12 - 1;
        }
        v26 = (_QWORD *)(*(_QWORD *)a2 + 8 * v27);
      }
      *v26 = v18;
LABEL_46:
      v28[0] = 0;
      ++*(_QWORD *)(a2 + 24);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>,void *>>>>::reset[abi:nn180100]((uint64_t)v28);
LABEL_47:
      v5 = *(_QWORD *)v5;
    }
    while (v5);
  }
  std::mutex::unlock(&KB::LanguageModelImplStub::wrapper_cache_mutex(void)::mutex);
}

std::string *std::pair<std::string const,std::weak_ptr<KB::LanguageModelImplStub::WrapperHandle>>::pair[abi:nn180100](std::string *this, __int128 *a2)
{
  __int128 v4;
  std::string::size_type v5;
  unint64_t *v6;
  unint64_t v7;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  v5 = *((_QWORD *)a2 + 4);
  this[1].__r_.__value_.__r.__words[0] = *((_QWORD *)a2 + 3);
  this[1].__r_.__value_.__l.__size_ = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 16);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return this;
}

void ___ZN2KB21LanguageModelImplStub19perform_maintenanceEv_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2))
      LXLexiconWrite();
  }
}

KB::LanguageModelImplStub::WrapperHandle *KB::LanguageModelImplStub::WrapperHandle::WrapperHandle(KB::LanguageModelImplStub::WrapperHandle *this)
{
  std::mutex *v2;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 850045863;
  v2 = (std::mutex *)((char *)this + 8);
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 1018212795;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *(_OWORD *)((char *)this + 105) = 0u;
  std::mutex::lock((std::mutex *)((char *)this + 8));
  *((_BYTE *)this + 120) = 0;
  std::mutex::unlock(v2);
  return this;
}

{
  std::mutex *v2;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 850045863;
  v2 = (std::mutex *)((char *)this + 8);
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 1018212795;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *(_OWORD *)((char *)this + 105) = 0u;
  std::mutex::lock((std::mutex *)((char *)this + 8));
  *((_BYTE *)this + 120) = 0;
  std::mutex::unlock(v2);
  return this;
}

uint64_t KB::LanguageModelImplStub::WrapperHandle::ready(KB::LanguageModelImplStub::WrapperHandle *this)
{
  return *((_BYTE *)this + 120) & 1;
}

TI::Favonius::Key *TI::Favonius::Key::create@<X0>(TI::Favonius::Key *this@<X0>, const void **a2@<X1>, TI::Favonius::Key **a3@<X8>)
{
  TI::Favonius::Key *v7;
  TI::Favonius::Key *result;

  v7 = (TI::Favonius::Key *)operator new();
  result = TI::Favonius::Key::Key(v7, this, a2);
  *a3 = result;
  return result;
}

void TI::Favonius::Key::create(TI::Favonius::Key *this@<X0>, const void **a2@<X1>, TI::Favonius::Key **a3@<X8>)
{
  TI::Favonius::Key *v6;
  BOOL v7;
  _BYTE v8[8];
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  KB::String::String((uint64_t)v8, this);
  v6 = (TI::Favonius::Key *)operator new();
  *a3 = TI::Favonius::Key::Key(v6, (const KB::String *)v8, a2);
  if (v9)
    v7 = v8[6] == 1;
  else
    v7 = 0;
  if (v7)
    free(v9);
}

void TI::Favonius::Key::append_debug_string_for_char(TI::Favonius::Key *this, KB::String *a2)
{
  const char *v2;

  switch((int)a2)
  {
    case 4:
      v2 = "<DISMISS>";
      goto LABEL_11;
    case 5:
    case 6:
    case 7:
    case 9:
    case 11:
    case 12:
    case 13:
      goto LABEL_5;
    case 8:
      v2 = "^H";
      goto LABEL_11;
    case 10:
      v2 = "<RETURN>";
      goto LABEL_11;
    case 14:
      v2 = "<SHIFT>";
      goto LABEL_11;
    case 15:
      v2 = "<GLOBE>";
      goto LABEL_11;
    case 16:
      v2 = "<MORE>";
      goto LABEL_11;
    default:
      if ((_DWORD)a2 == 9100)
      {
        v2 = "<UNDO>";
LABEL_11:
        KB::String::append((unsigned __int16 *)this, v2, 0xFFFFuLL);
      }
      else
      {
LABEL_5:
        KB::String::append(this, a2);
      }
      return;
  }
}

uint64_t *TI::Favonius::Key::append_debug_data(TI::Favonius::Key *this, KB::String *a2)
{
  char *v3;
  int v4;
  uint64_t *result;
  char *v6;
  int v7;
  int v8;
  KB::String *v9;

  v3 = (char *)*((_QWORD *)this + 2);
  if (!v3)
    v3 = (char *)this + 24;
  v6 = v3;
  v4 = *((unsigned __int16 *)this + 4);
  v7 = 0;
  v8 = v4;
  LODWORD(v9) = 0;
  result = KB::String::iterator::initialize((uint64_t *)&v6);
  while ((_DWORD)v9)
  {
    TI::Favonius::Key::append_debug_string_for_char(a2, (KB::String *)v9);
    result = KB::String::iterator::operator++((uint64_t *)&v6);
  }
  return result;
}

uint64_t *TI::Favonius::Key::debug_data@<X0>(TI::Favonius::Key *this@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = 0x100000;
  *(_WORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 6) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  return TI::Favonius::Key::append_debug_data(this, (KB::String *)a2);
}

TI::Favonius::Key *TI::Favonius::KeyFactory::create_key@<X0>(uint64_t a1@<X0>, const KB::String *a2@<X1>, TI::Favonius::Key **a3@<X8>)
{
  uint64_t v3;
  TI::Favonius::Key *v6;
  TI::Favonius::Key *result;
  TI::Favonius::KeyFactory *v8;
  unsigned int v9;
  const void *v10;
  TI::Favonius::Key *v11;

  v3 = *(_QWORD *)(a1 + 24);
  if (v3)
  {
    (*(void (**)(const void **__return_ptr))(*(_QWORD *)v3 + 48))(&v10);
    v6 = (TI::Favonius::Key *)operator new();
    result = TI::Favonius::Key::Key(v6, a2, &v10);
    *a3 = result;
    if ((unsigned __int16)v10 >= 0xFu)
    {
      result = v11;
      if (v11)
        return (TI::Favonius::Key *)MEMORY[0x1DF0A212C](v11, 0x1000C8077774924);
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    return (TI::Favonius::Key *)TI::Favonius::KeyFactory::create_key(v8, v9);
  }
  return result;
}

void TI::Favonius::KeyFactory::create_key(TI::Favonius::KeyFactory *this@<X0>, unsigned int a2@<W1>, unsigned int **a3@<X8>)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  void *i;
  unint64_t v12;
  _QWORD *v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  int8x8_t prime;
  void *v20;
  void *v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  uint8x8_t v25;
  unint64_t v26;
  uint8x8_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  unint64_t v35;
  unsigned int *v36;
  uint64_t v37;
  TI::Favonius::Key *v38;
  uint64_t v39;
  unsigned int v40;
  void *v41;
  const void *v42;
  uint64_t v43;
  _BYTE v44[8];
  void *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v8 = *((_QWORD *)this + 5);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v8 <= a2)
        v3 = a2 % v8;
    }
    else
    {
      v3 = ((_DWORD)v8 - 1) & a2;
    }
    v10 = *(void ***)(*((_QWORD *)this + 4) + 8 * v3);
    if (v10)
    {
      for (i = *v10; i; i = *(void **)i)
      {
        v12 = *((_QWORD *)i + 1);
        if (v12 == a2)
        {
          if (*((_DWORD *)i + 4) == a2)
            goto LABEL_74;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v3)
            break;
        }
      }
    }
  }
  v13 = (_QWORD *)((char *)this + 48);
  i = operator new(0x20uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v7;
  *((_DWORD *)i + 4) = a2;
  *((_QWORD *)i + 3) = 0;
  v14 = (float)(unint64_t)(*((_QWORD *)this + 7) + 1);
  v15 = *((float *)this + 16);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    v16 = 1;
    if (v8 >= 3)
      v16 = (v8 & (v8 - 1)) != 0;
    v17 = v16 | (2 * v8);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      prime = (int8x8_t)v18;
    else
      prime = (int8x8_t)v17;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v8 = *((_QWORD *)this + 5);
    }
    if (*(_QWORD *)&prime > v8)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v8)
    {
      v26 = vcvtps_u32_f32((float)*((unint64_t *)this + 7) / *((float *)this + 16));
      if (v8 < 3 || (v27 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        v26 = std::__next_prime(v26);
      }
      else
      {
        v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2)
          v26 = v28;
      }
      if (*(_QWORD *)&prime <= v26)
        prime = (int8x8_t)v26;
      if (*(_QWORD *)&prime >= v8)
      {
        v8 = *((_QWORD *)this + 5);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            goto LABEL_98;
          v20 = operator new(8 * *(_QWORD *)&prime);
          v21 = (void *)*((_QWORD *)this + 4);
          *((_QWORD *)this + 4) = v20;
          if (v21)
            operator delete(v21);
          v22 = 0;
          *((int8x8_t *)this + 5) = prime;
          do
            *(_QWORD *)(*((_QWORD *)this + 4) + 8 * v22++) = 0;
          while (*(_QWORD *)&prime != v22);
          v23 = (_QWORD *)*v13;
          if (*v13)
          {
            v24 = v23[1];
            v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(_QWORD *)&prime)
                v24 %= *(_QWORD *)&prime;
            }
            else
            {
              v24 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*((_QWORD *)this + 4) + 8 * v24) = v13;
            v29 = (_QWORD *)*v23;
            if (*v23)
            {
              do
              {
                v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(_QWORD *)&prime)
                    v30 %= *(_QWORD *)&prime;
                }
                else
                {
                  v30 &= *(_QWORD *)&prime - 1;
                }
                if (v30 != v24)
                {
                  v31 = *((_QWORD *)this + 4);
                  if (!*(_QWORD *)(v31 + 8 * v30))
                  {
                    *(_QWORD *)(v31 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *v23 = *v29;
                  *v29 = **(_QWORD **)(*((_QWORD *)this + 4) + 8 * v30);
                  **(_QWORD **)(*((_QWORD *)this + 4) + 8 * v30) = v29;
                  v29 = v23;
                }
                v30 = v24;
LABEL_55:
                v23 = v29;
                v29 = (_QWORD *)*v29;
                v24 = v30;
              }
              while (v29);
            }
          }
          v8 = (unint64_t)prime;
          goto LABEL_59;
        }
        v41 = (void *)*((_QWORD *)this + 4);
        *((_QWORD *)this + 4) = 0;
        if (v41)
          operator delete(v41);
        v8 = 0;
        *((_QWORD *)this + 5) = 0;
      }
    }
LABEL_59:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v3 = v7 % v8;
      else
        v3 = v7;
    }
    else
    {
      v3 = ((_DWORD)v8 - 1) & v7;
    }
  }
  v32 = *((_QWORD *)this + 4);
  v33 = *(_QWORD **)(v32 + 8 * v3);
  if (v33)
  {
    *(_QWORD *)i = *v33;
LABEL_72:
    *v33 = i;
    goto LABEL_73;
  }
  v34 = (_QWORD *)*v13;
  *(_QWORD *)i = *v13;
  *v13 = i;
  *(_QWORD *)(v32 + 8 * v3) = v13;
  if (v34)
  {
    v35 = v34[1];
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v35 >= v8)
        v35 %= v8;
    }
    else
    {
      v35 &= v8 - 1;
    }
    v33 = (_QWORD *)(*((_QWORD *)this + 4) + 8 * v35);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)this + 7);
LABEL_74:
  v36 = (unsigned int *)*((_QWORD *)i + 3);
  if (v36)
  {
    *a3 = v36;
    do
LABEL_86:
      v40 = __ldaxr(v36);
    while (__stlxr(v40 + 1, v36));
    return;
  }
  KB::String::String((uint64_t)v44, a2);
  v37 = *((_QWORD *)this + 3);
  if (!v37)
  {
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_98:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  (*(void (**)(const void **__return_ptr, uint64_t, _BYTE *))(*(_QWORD *)v37 + 48))(&v42, v37, v44);
  v38 = (TI::Favonius::Key *)operator new();
  TI::Favonius::Key::Key(v38, (const KB::String *)v44, &v42);
  v39 = *((_QWORD *)i + 3);
  *((_QWORD *)i + 3) = v38;
  if (v39)
    WTF::RefCounted<TI::Favonius::Key>::deref(v39);
  if ((unsigned __int16)v42 >= 0xFu && v43)
    MEMORY[0x1DF0A212C](v43, 0x1000C8077774924);
  if (v45 && v44[6] == 1)
    free(v45);
  v36 = (unsigned int *)*((_QWORD *)i + 3);
  *a3 = v36;
  if (v36)
    goto LABEL_86;
}

void TI::Favonius::KeyFactory::clear_cache(TI::Favonius::KeyFactory *this)
{
  uint64_t v2;
  uint64_t i;

  if (*((_QWORD *)this + 7))
  {
    std::__hash_table<std::__hash_value_type<unsigned int,WTF::RefPtr<TI::Favonius::Key>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,WTF::RefPtr<TI::Favonius::Key>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,WTF::RefPtr<TI::Favonius::Key>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,WTF::RefPtr<TI::Favonius::Key>>>>::__deallocate_node(*((_QWORD **)this + 6));
    *((_QWORD *)this + 6) = 0;
    v2 = *((_QWORD *)this + 5);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*((_QWORD *)this + 4) + 8 * i) = 0;
    }
    *((_QWORD *)this + 7) = 0;
  }
}

TI::Favonius::LayoutKey *TI::Favonius::LayoutKey::create@<X0>(TI::Favonius::LayoutKey *this@<X0>, const void **a2@<X1>, const KB::ByteString *a3@<X2>, CGRect a4@<0:D0, 8:D1, 16:D2, 24:D3>, TI::Favonius::LayoutKey **a5@<X8>)
{
  __int16 v5;
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  TI::Favonius::LayoutKey *v13;
  TI::Favonius::LayoutKey *result;
  CGRect v15;

  v5 = (__int16)a3;
  height = a4.size.height;
  width = a4.size.width;
  y = a4.origin.y;
  x = a4.origin.x;
  v13 = (TI::Favonius::LayoutKey *)operator new();
  v15.origin.x = x;
  v15.origin.y = y;
  v15.size.width = width;
  v15.size.height = height;
  result = TI::Favonius::LayoutKey::LayoutKey(v13, this, a2, v15, v5);
  *a5 = result;
  return result;
}

uint64_t TI::Favonius::KeyMatch::create@<X0>(unsigned int **a1@<X0>, uint64_t *a2@<X8>, double a3@<D0>, double a4@<D1>, float a5@<S2>)
{
  uint64_t result;
  unsigned int *v11;
  unsigned int v12;

  result = operator new();
  *(_DWORD *)result = 1;
  v11 = *a1;
  *(_QWORD *)(result + 8) = *a1;
  if (v11)
  {
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 + 1, v11));
  }
  *(double *)(result + 16) = a3;
  *(double *)(result + 24) = a4;
  *(float *)(result + 32) = a5;
  *a2 = result;
  return result;
}

uint64_t TI::Favonius::KeyMatch::KeyMatch(uint64_t result, unsigned int **a2, double a3, double a4, float a5)
{
  unsigned int *v5;
  unsigned int v6;

  *(_DWORD *)result = 1;
  v5 = *a2;
  *(_QWORD *)(result + 8) = *a2;
  if (v5)
  {
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 + 1, v5));
  }
  *(double *)(result + 16) = a3;
  *(double *)(result + 24) = a4;
  *(float *)(result + 32) = a5;
  return result;
}

{
  unsigned int *v5;
  unsigned int v6;

  *(_DWORD *)result = 1;
  v5 = *a2;
  *(_QWORD *)(result + 8) = *a2;
  if (v5)
  {
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 + 1, v5));
  }
  *(double *)(result + 16) = a3;
  *(double *)(result + 24) = a4;
  *(float *)(result + 32) = a5;
  return result;
}

void *__getSBApplicationStateDisplayIDKeySymbolLoc_block_invoke(uint64_t a1)
{
  void *v2;
  void *result;
  void *v4;

  if (SpringBoardServicesLibraryCore_frameworkLibrary)
  {
    v2 = (void *)SpringBoardServicesLibraryCore_frameworkLibrary;
  }
  else
  {
    SpringBoardServicesLibraryCore_frameworkLibrary = _sl_dlopen();
    v2 = (void *)SpringBoardServicesLibraryCore_frameworkLibrary;
    if (!SpringBoardServicesLibraryCore_frameworkLibrary)
    {
      v4 = (void *)abort_report_np();
      free(v4);
    }
  }
  result = dlsym(v2, "SBApplicationStateDisplayIDKey");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  getSBApplicationStateDisplayIDKeySymbolLoc_ptr = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

id _TILSCLanguageForInputMode(TIInputMode *a1)
{
  void *v1;
  void *v2;

  -[TIInputMode normalizedIdentifier](a1, "normalizedIdentifier");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  TIInputModeGetLanguage();
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

__n128 __Block_byref_object_copy__14226(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__14227(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

id _TISharedLanguageLikelihoodModel()
{
  return +[_TILanguageLikelihoodModel sharedLanguageLikelihoodModel](_TILanguageLikelihoodModel, "sharedLanguageLikelihoodModel");
}

uint64_t KB::CandidateFilterResources::CandidateFilterResources(uint64_t a1, CFTypeRef cf, int a3, uint64_t *a4, uint64_t a5, const void *a6, uint64_t a7, const void *a8)
{
  CFTypeRef v15;
  uint64_t v16;
  CFTypeRef v17;

  if (cf)
    v15 = CFRetain(cf);
  else
    v15 = 0;
  *(_QWORD *)a1 = v15;
  *(_DWORD *)(a1 + 8) = a3;
  v16 = *a4;
  *a4 = 0;
  *(_QWORD *)(a1 + 16) = v16;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)a5;
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(a5 + 8) = 0;
  *(_QWORD *)(a1 + 40) = _Block_copy(a6);
  *(_QWORD *)(a1 + 48) = a7;
  if (a8)
    v17 = CFRetain(a8);
  else
    v17 = 0;
  *(_QWORD *)(a1 + 56) = v17;
  return a1;
}

void KB::CandidateFilterResources::~CandidateFilterResources(KB::CandidateFilterResources *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  unsigned int *v5;

  v2 = *(const void **)this;
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    _Block_release(v3);
  v4 = (const void *)*((_QWORD *)this + 7);
  if (v4)
    CFRelease(v4);
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
  v5 = (unsigned int *)*((_QWORD *)this + 2);
  if (v5)
    WTF::RefCounted<KB::DictionaryContainer>::deref(v5);
}

uint64_t KB::CandidateFilterResources::locale(KB::CandidateFilterResources *this)
{
  return *(_QWORD *)this;
}

uint64_t KB::CandidateFilterResources::primary_lexicon_id(KB::CandidateFilterResources *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t KB::CandidateFilterResources::dictionary@<X0>(uint64_t this@<X0>, unsigned int **a2@<X8>)
{
  unsigned int *v2;
  unsigned int v3;

  v2 = *(unsigned int **)(this + 16);
  *a2 = v2;
  if (v2)
  {
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + 1, v2));
  }
  return this;
}

uint64_t KB::CandidateFilterResources::language_model@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 32);
  *a2 = *(_QWORD *)(this + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

uint64_t KB::CandidateFilterResources::word_medial_punctuation_predicate(KB::CandidateFilterResources *this)
{
  return *((_QWORD *)this + 5);
}

uint64_t KB::CandidateFilterResources::vulgar_word_usage_database(KB::CandidateFilterResources *this)
{
  return *((_QWORD *)this + 6);
}

uint64_t KB::CandidateFilterResources::debug_stream(KB::CandidateFilterResources *this)
{
  return *((_QWORD *)this + 7);
}

_WORD *TI::Favonius::KeyClassification::KeyClassification(_WORD *this)
{
  *this = 1;
  return this;
}

{
  *this = 1;
  return this;
}

BOOL is_nonstop(UChar32 a1)
{
  int8_t v2;
  _BOOL8 result;

  v2 = u_charType(a1);
  result = 1;
  if (((1 << v2) & 0x4000FFE) == 0
    && ((a1 - 38) > 0x3A || ((1 << (a1 - 38)) & 0x400000000000083) == 0))
  {
    return (a1 - 1523) < 2 || a1 == 8217;
  }
  return result;
}

__int16 *TI::Favonius::KeyClassification::add_classifier_flags(__int16 *this, __int16 a2)
{
  __int16 v2;

  v2 = (*this | a2) & 0xFFFE;
  if ((unsigned __int16)(*this | a2) == 1)
    v2 = 1;
  *this = v2;
  return this;
}

float TI::Favonius::SearchParameters::prediction_cost_of_first_predicted_key(TI::Favonius::SearchParameters *this)
{
  unsigned int v1;

  if (this >= 5)
    v1 = 5;
  else
    v1 = this;
  return TI::Favonius::SearchParameters::k_prediction_costs[v1];
}

uint64_t TI::Favonius::ZephyrTypingModel::Hypothesis::parent_hypothesis(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  return *((_QWORD *)this + 4);
}

uint64_t TI::Favonius::ZephyrTypingModel::Hypothesis::typing_model(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t TI::Favonius::ZephyrTypingModel::Hypothesis::key(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  return (uint64_t)this + 24;
}

float TI::Favonius::ZephyrTypingModel::Hypothesis::probability_of_key(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  return *((float *)this + 16);
}

BOOL TI::Favonius::ZephyrTypingModel::Hypothesis::extends_word(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 6);
  return v1 != (**(uint64_t (***)(TI::Favonius::ZephyrTypingModel::Hypothesis *))this)(this);
}

float TI::Favonius::ZephyrTypingModel::Hypothesis::context_score(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  float v2;

  v2 = (*(float (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)this + 96))(this);
  return v2 + (*(float (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)this + 104))(this);
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::typing_score(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  uint64_t v2;
  float v3;
  float v4;

  if ((*((_DWORD *)this + 17) & 0x7FFFFFFFu) >= 0x7F800000)
  {
    v2 = *((_QWORD *)this + 4);
    if (v2)
    {
      v3 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 96))(v2);
      v4 = v3 + logf(*((float *)this + 16));
    }
    else
    {
      v4 = 0.0;
    }
    *((float *)this + 17) = v4;
  }
}

float TI::Favonius::ZephyrTypingModel::Hypothesis::word_score(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  return 0.0;
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::for_each_input_segment(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a1)
  {
    v3 = a1;
    v4 = 0;
    v5 = 0;
    v6 = 0;
    while (((*(uint64_t (**)(_QWORD *))(*v3 + 144))(v3) & 1) == 0)
    {
      if (v5 >= v6)
      {
        v8 = (v5 - v4) >> 3;
        v9 = v8 + 1;
        if ((unint64_t)(v8 + 1) >> 61)
          goto LABEL_33;
        if ((v6 - v4) >> 2 > v9)
          v9 = (v6 - v4) >> 2;
        if ((unint64_t)(v6 - v4) >= 0x7FFFFFFFFFFFFFF8)
          v10 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v10 = v9;
        if (v10)
        {
          if (v10 >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v11 = (char *)operator new(8 * v10);
        }
        else
        {
          v11 = 0;
        }
        v12 = &v11[8 * v8];
        *(_QWORD *)v12 = v3;
        v7 = v12 + 8;
        while (v5 != v4)
        {
          v13 = *((_QWORD *)v5 - 1);
          v5 -= 8;
          *((_QWORD *)v12 - 1) = v13;
          v12 -= 8;
        }
        v6 = &v11[8 * v10];
        if (v4)
          operator delete(v4);
        v4 = v12;
      }
      else
      {
        *(_QWORD *)v5 = v3;
        v7 = v5 + 8;
      }
      v3 = (_QWORD *)v3[6];
      v5 = v7;
      if (!v3)
        goto LABEL_25;
    }
    v7 = v5;
LABEL_25:
    if (v7 != v4)
    {
      while (1)
      {
        v14 = *((_QWORD *)v7 - 1);
        v7 -= 8;
        v16 = v14;
        v15 = *(_QWORD *)(a2 + 24);
        if (!v15)
          break;
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v15 + 48))(v15, &v16);
        if (v7 == v4)
          goto LABEL_30;
      }
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_33:
      abort();
    }
    if (v4)
LABEL_30:
      operator delete(v4);
  }
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::last_typed_input_segment(const TI::Favonius::ZephyrTypingModel::Hypothesis **this@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = 0x100000;
  *(_WORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 6) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  TI::Favonius::ZephyrTypingModel::Hypothesis::append_typed_string((TI::Favonius::ZephyrTypingModel::Hypothesis *)this, (KB::String *)a2, this[6], 0, 0);
}

uint64_t TI::Favonius::ZephyrTypingModel::Hypothesis::input_segment_count(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  TI::Favonius::ZephyrTypingModel::Hypothesis *v1;
  uint64_t i;

  v1 = this;
  for (i = 0;
        (*(uint64_t (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)v1 + 136))(v1);
        i = (i + 1))
  {
    if (((*(uint64_t (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)v1 + 144))(v1) & 1) != 0)
      break;
    v1 = (TI::Favonius::ZephyrTypingModel::Hypothesis *)(*(uint64_t (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)v1 + 136))(v1);
  }
  return i;
}

BOOL TI::Favonius::ZephyrTypingModel::Hypothesis::input_segment_includes_backspace(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  TI::Favonius::ZephyrTypingModel::Hypothesis *v1;
  TI::Favonius::ZephyrTypingModel::Hypothesis *v2;
  uint64_t v3;
  __int16 v4;

  v1 = this;
  do
  {
    v2 = this;
    v3 = (*(uint64_t (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)v1 + 136))(v1);
    if (v2 == (TI::Favonius::ZephyrTypingModel::Hypothesis *)v3)
      break;
    v4 = *(_WORD *)(*(_QWORD *)(*(uint64_t (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)v2 + 16))(v2)
                  + 60);
    this = (TI::Favonius::ZephyrTypingModel::Hypothesis *)(**(uint64_t (***)(TI::Favonius::ZephyrTypingModel::Hypothesis *))v2)(v2);
  }
  while ((v4 & 0x80) == 0);
  return v2 != (TI::Favonius::ZephyrTypingModel::Hypothesis *)v3;
}

BOOL TI::Favonius::ZephyrTypingModel::Hypothesis::is_isomorphic(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  BOOL v6;
  _BOOL8 result;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  for (i = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
        ;
        i = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 32))(v12))
  {
    v5 = i;
    if (v3)
      v6 = i == 0;
    else
      v6 = 1;
    if (v6)
      return v3 == i;
    result = v3 == i;
    if (v3 == v5)
      return result;
    v8 = *(_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    v9 = *(_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
    if (v8 != v9)
    {
      result = KB::String::equal((KB::String *)(v8 + 8), (const KB::String *)(v9 + 8), 1);
      if (!result)
        return result;
    }
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 72))(v3);
    if (v10 != (*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 72))(v5))
      break;
    v11 = (**(uint64_t (***)(uint64_t))v3)(v3);
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 32))(v11);
    v12 = (**(uint64_t (***)(uint64_t))v5)(v5);
  }
  return 0;
}

unint64_t TI::Favonius::ZephyrTypingModel::Hypothesis::isomorphism_hash(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  unint64_t result;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  KB::String *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  result = *((_QWORD *)this + 9);
  if (!result)
  {
    v3 = 2654435769;
    v4 = (_QWORD *)(*(uint64_t (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)this + 32))(this);
    *((_QWORD *)this + 9) = 1;
    v5 = (*(uint64_t (**)(_QWORD *))(*v4 + 16))(v4);
    v6 = *(_QWORD *)v5;
    if (*(_QWORD *)(*(_QWORD *)v5 + 16))
      v7 = *(KB::String **)(*(_QWORD *)v5 + 16);
    else
      v7 = (KB::String *)(*(_QWORD *)v5 + 24);
    *((_QWORD *)this + 9) ^= (*((_QWORD *)this + 9) << 6)
                           + KB::String::hash(v7, (const char *)*(unsigned __int16 *)(v6 + 8))
                           + (*((_QWORD *)this + 9) >> 2)
                           + 2654435769;
    if ((*(unsigned int (**)(_QWORD *))(*v4 + 72))(v4))
      v8 = 2654435770;
    else
      v8 = 2654435769;
    v9 = (v8 + (*((_QWORD *)this + 9) << 6) + (*((_QWORD *)this + 9) >> 2)) ^ *((_QWORD *)this + 9);
    *((_QWORD *)this + 9) = v9;
    v10 = v4[4];
    if (v10)
    {
      v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 192))(v10) + 2654435769;
      v9 = *((_QWORD *)this + 9);
    }
    result = (v3 + (v9 << 6) + (v9 >> 2)) ^ v9;
    *((_QWORD *)this + 9) = result;
  }
  return result;
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::get_input_string_and_key_alignment(TI::Favonius::ZephyrTypingModel::Hypothesis *a1, KB::String *a2, const unsigned int **a3, const TI::Favonius::ZephyrTypingModel::Hypothesis *a4)
{
  unsigned int v4;

  v4 = 0;
  TI::Favonius::ZephyrTypingModel::Hypothesis::append_typed_string(a1, a2, a4, a3, &v4);
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::debug_hypothesis_string(TI::Favonius::ZephyrTypingModel::Hypothesis *this@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = 0x100000;
  *(_WORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 6) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  TI::Favonius::ZephyrTypingModel::Hypothesis::append_debug_string(this, (KB::String *)a2);
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::debug_context_string(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 6) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::append_debug_string(TI::Favonius::ZephyrTypingModel::Hypothesis *this, KB::String *a2)
{
  TI::Favonius::ZephyrTypingModel::Hypothesis *v3;

  v3 = (TI::Favonius::ZephyrTypingModel::Hypothesis *)*((_QWORD *)this + 4);
  if (v3)
  {
    TI::Favonius::ZephyrTypingModel::Hypothesis::append_debug_string(v3, a2);
    if (((*(uint64_t (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)this + 72))(this) & 1) == 0)
      KB::String::append(a2, 0x7Cu);
    TI::Favonius::Key::append_debug_data(*((TI::Favonius::Key **)this + 3), a2);
    if ((*(unsigned int (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)this + 144))(this))
      KB::String::append(a2, 0x23u);
  }
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::append_typed_string(TI::Favonius::ZephyrTypingModel::Hypothesis *this, KB::String *a2, const TI::Favonius::ZephyrTypingModel::Hypothesis *a3, const unsigned int **a4, unsigned int *a5)
{
  KB::String *v7;
  TI::Favonius::ZephyrTypingModel::Hypothesis *v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  const unsigned int *v16;
  uint64_t v17;
  unsigned int v18;
  std::vector<unsigned int>::const_iterator v19;
  unsigned __int16 v20;
  __int16 v21;
  __int16 v22;
  __int16 v23;
  __int16 v24;
  __int16 v25;
  const unsigned int *v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  UChar32 c[2];
  uint64_t v31;
  int v32;
  int v33;
  int v34;

  if (this == a3)
    goto LABEL_5;
  v7 = a2;
  if (!a3)
  {
    if (((*(uint64_t (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)this + 144))(this) & 1) == 0)
    {
      v9 = (TI::Favonius::ZephyrTypingModel::Hypothesis *)*((_QWORD *)this + 4);
      a2 = v7;
      a3 = 0;
      goto LABEL_8;
    }
LABEL_5:
    if (!a5)
      return;
    v10 = 0;
    goto LABEL_46;
  }
  v9 = (TI::Favonius::ZephyrTypingModel::Hypothesis *)*((_QWORD *)this + 4);
LABEL_8:
  TI::Favonius::ZephyrTypingModel::Hypothesis::append_typed_string(v9, a2, a3, (KB::Alignment *)a4, a5);
  v11 = *((_QWORD *)this + 3);
  if ((*(_WORD *)(v11 + 60) & 0x80) != 0 && (v12 = *(unsigned __int16 *)v7, *(_WORD *)v7))
  {
    if (*((_QWORD *)v7 + 1))
      v13 = *((_QWORD *)v7 + 1);
    else
      v13 = (uint64_t)v7 + 16;
    v31 = v13;
    v32 = 0;
    v33 = v12;
    v34 = 0;
    KB::String::iterator::initialize(&v31);
    *(_QWORD *)&v27 = v13;
    DWORD2(v27) = v12;
    HIDWORD(v27) = v12;
    LODWORD(v28) = 0;
    KB::String::iterator::initialize((uint64_t *)&v27);
    v29 = v27;
    *(_QWORD *)c = v28;
    KB::String::iterator::operator--((KB::String::iterator *)&v29);
    v14 = v32;
    v15 = 1;
    if (DWORD2(v29) == v32)
    {
      v14 = DWORD2(v29);
    }
    else
    {
      while (1)
      {
        TI::Favonius::KeyClassification::KeyClassification((TI::Favonius::KeyClassification *)&v27, c[0]);
        if ((v27 & 0x40) == 0)
          break;
        KB::String::iterator::operator--((KB::String::iterator *)&v29);
        ++v15;
        if (DWORD2(v29) == v14)
          goto LABEL_24;
      }
      v14 = DWORD2(v29);
    }
LABEL_24:
    v20 = WORD6(v29);
    if (v14 <= SHIDWORD(v29))
    {
      if (c[0] >= 0x10000u)
        v21 = -4;
      else
        v21 = -3;
      if ((c[0] - 1114112) >= 0xFFEFE000)
        v22 = v21;
      else
        v22 = 0;
      if (c[0] >> 11 >= 0x1B)
        v23 = v22;
      else
        v23 = -3;
      if (c[0] >= 0x800u)
        v24 = v23;
      else
        v24 = -2;
      if (c[0] >= 0x80u)
        v25 = v24;
      else
        v25 = -1;
      v20 = v25 + v14;
    }
    KB::String::resize(v7, v20, 0);
    if (a4)
    {
      if (v15)
      {
        v26 = a4[1];
        a4[1] = &v26[-v15];
      }
    }
  }
  else if ((*(_WORD *)(v11 + 60) & 0xB81) == 0)
  {
    KB::String::append((unsigned __int16 *)v7, (const KB::String *)(v11 + 8));
    if (a4)
    {
      v16 = a4[1];
      v17 = *((_QWORD *)this + 3);
      v18 = *(unsigned __int16 *)(v17 + 12);
      if (!*(_WORD *)(v17 + 12))
      {
        KB::String::compute_length((unsigned __int16 *)(v17 + 8));
        v18 = *(unsigned __int16 *)(v17 + 12);
      }
      v19.__i_ = v16;
      std::vector<unsigned int>::insert((std::vector<unsigned int> *)a4, v19, v18, a5);
    }
  }
  if (a5)
  {
    v10 = *a5 + 1;
LABEL_46:
    *a5 = v10;
  }
}

void TI::Favonius::ZephyrTypingModel::~ZephyrTypingModel(TI::Favonius::ZephyrTypingModel *this)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = &unk_1EA103D70;
  v1 = (unsigned int *)*((_QWORD *)this + 2);
  if (v1)
  {
    v2 = v1 + 2;
    v3 = atomic_load(v1 + 2);
    if (v3 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 8))(v1);
    }
    else
    {
      do
        v4 = __ldaxr(v2);
      while (__stlxr(v4 - 1, v2));
    }
  }
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::~Hypothesis(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;

  *(_QWORD *)this = off_1EA103DB8;
  v2 = (unsigned int *)*((_QWORD *)this + 4);
  if (v2)
  {
    v3 = v2 + 2;
    v4 = atomic_load(v2 + 2);
    if (v4 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 248))(v2);
    }
    else
    {
      do
        v5 = __ldaxr(v3);
      while (__stlxr(v5 - 1, v3));
    }
  }
  v6 = *((_QWORD *)this + 3);
  if (v6)
    WTF::RefCounted<TI::Favonius::Key>::deref(v6);
  v7 = (unsigned int *)*((_QWORD *)this + 2);
  if (v7)
  {
    v8 = v7 + 2;
    v9 = atomic_load(v7 + 2);
    if (v9 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 40))(v7);
    }
    else
    {
      do
        v10 = __ldaxr(v8);
      while (__stlxr(v10 - 1, v8));
    }
  }
}

TI::Favonius::ZephyrTypingModel::Hypothesis **TI::Favonius::ZephyrTypingModel::Hypothesis::probability_of_input_segment(TI::Favonius::ZephyrTypingModel::Hypothesis **this, const TI::Favonius::ZephyrTypingModel::Hypothesis *a2)
{
  const TI::Favonius::ZephyrTypingModel::Hypothesis *v2;
  TI::Favonius::ZephyrTypingModel::Hypothesis **v3;

  v2 = a2;
  v3 = this;
  if (!a2)
  {
    this = (TI::Favonius::ZephyrTypingModel::Hypothesis **)(*((uint64_t (**)(TI::Favonius::ZephyrTypingModel::Hypothesis **))*this
                                                            + 17))(this);
    v2 = (const TI::Favonius::ZephyrTypingModel::Hypothesis *)this;
  }
  if (v2)
  {
    if (v2 != (const TI::Favonius::ZephyrTypingModel::Hypothesis *)v3)
    {
      (*((void (**)(TI::Favonius::ZephyrTypingModel::Hypothesis **, float))*v3 + 3))(v3, 1.0);
      return (TI::Favonius::ZephyrTypingModel::Hypothesis **)TI::Favonius::ZephyrTypingModel::Hypothesis::probability_of_input_segment(v3[4], v2);
    }
  }
  return this;
}

uint64_t TI::Favonius::ZephyrTypingModel::Hypothesis::Hypothesis(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t *v4;
  unsigned __int8 v5;
  uint64_t *v6;
  unsigned int *v7;
  unsigned int v8;
  uint64_t v9;
  int v11;
  TI::Favonius::Key *v12;
  uint64_t *v13;
  const void *v14;
  int v15;
  __int16 v16;
  char v17;
  void *v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = off_1EA103DB8;
  v3 = *a2;
  *a2 = 0;
  *(_QWORD *)(a1 + 16) = v3;
  *(_QWORD *)(a1 + 24) = 0;
  v4 = (uint64_t *)(a1 + 24);
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = a1;
  *(_QWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 56) = 257;
  *(_DWORD *)(a1 + 60) = 1065353216;
  *(_DWORD *)(a1 + 68) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  v6 = &+[TILanguageModelLoaderManager recipientRecords]::__recipientRecords;
  if ((v5 & 1) == 0)
  {
    v13 = (uint64_t *)(a1 + 24);
    v6 = &+[TILanguageModelLoaderManager recipientRecords]::__recipientRecords;
    v4 = v13;
    if (v11)
    {
      v15 = 0x100000;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      LOWORD(v14) = 0;
      v12 = (TI::Favonius::Key *)operator new();
      TI::Favonius::ZephyrTypingModel::Hypothesis::Hypothesis(WTF::PassRefPtr<TI::Favonius::ZephyrTypingModel const>)::blank_key = (uint64_t)TI::Favonius::Key::Key(v12, (const KB::String *)&v15, &v14);
      if (v18 && v17 == 1)
        free(v18);
      __cxa_atexit((void (*)(void *))WTF::RefPtr<TI::Favonius::Key>::~RefPtr, &TI::Favonius::ZephyrTypingModel::Hypothesis::Hypothesis(WTF::PassRefPtr<TI::Favonius::ZephyrTypingModel const>)::blank_key, &dword_1DA6F2000);
      v4 = v13;
      v6 = &+[TILanguageModelLoaderManager recipientRecords]::__recipientRecords;
    }
  }
  v7 = (unsigned int *)v6[186];
  if (v7)
  {
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 + 1, v7));
  }
  v9 = *v4;
  *v4 = (uint64_t)v7;
  if (v9)
    WTF::RefCounted<TI::Favonius::Key>::deref(v9);
  return a1;
}

uint64_t *WTF::RefPtr<TI::Favonius::Key>::~RefPtr(uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  if (v2)
    WTF::RefCounted<TI::Favonius::Key>::deref(v2);
  return a1;
}

uint64_t TI::Favonius::ZephyrTypingModel::Hypothesis::Hypothesis(uint64_t a1, uint64_t a2, unsigned int **a3, int a4)
{
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = off_1EA103DB8;
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  *(_QWORD *)(a1 + 16) = v8;
  if (v8)
  {
    v9 = (unsigned int *)(v8 + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 + 1, v9));
  }
  v11 = *a3;
  *(_QWORD *)(a1 + 24) = *a3;
  if (v11)
  {
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 + 1, v11));
  }
  *(_QWORD *)(a1 + 32) = a2;
  v13 = (unsigned int *)(a2 + 8);
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 + 1, v13));
  v15 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 40) = a1;
  *(_QWORD *)(a1 + 48) = v15;
  *(_WORD *)(a1 + 56) = 256;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 68) = -8388608;
  *(_QWORD *)(a1 + 72) = 0;
  if (a4)
  {
    v16 = *(_QWORD *)(a2 + 48);
    *(_QWORD *)(a1 + 48) = v16;
    *(_BYTE *)(a1 + 57) = *(_BYTE *)(a2 + 57);
    v17 = *(_WORD *)(*(_QWORD *)(a1 + 24) + 60);
    v18 = a1;
    if ((v17 & 0xE) != 0)
    {
      if ((v17 & 0x80) == 0)
        goto LABEL_17;
    }
    else
    {
      v18 = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 40) = v18;
      if ((v17 & 0x80) == 0)
        goto LABEL_17;
    }
    v19 = *(_QWORD *)(v18 + 32);
    if (v19)
    {
      if (!*(_BYTE *)(v18 + 56))
      {
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(v19 + 40);
        if (v16 == v19)
        {
          *(_QWORD *)(a1 + 48) = *(_QWORD *)(v16 + 48);
          *(_BYTE *)(a1 + 57) = *(_BYTE *)(v16 + 57);
        }
      }
    }
  }
LABEL_17:
  TI::Favonius::ZephyrTypingModel::Hypothesis::initialize_probability_of_key((TI::Favonius::ZephyrTypingModel::Hypothesis *)a1);
  return a1;
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::initialize_probability_of_key(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  __int16 v2;
  float v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;

  v2 = *(_WORD *)(*((_QWORD *)this + 3) + 60);
  v3 = 1.0;
  if ((v2 & 0xE) != 0)
  {
    if ((*(_WORD *)(*((_QWORD *)this + 3) + 60) & 0x1000) != 0)
    {
      v4 = *(_QWORD *)(*((_QWORD *)this + 4) + 40);
      goto LABEL_4;
    }
  }
  else
  {
    if ((v2 & 1) != 0)
      goto LABEL_22;
    if ((*(_WORD *)(*((_QWORD *)this + 3) + 60) & 0x400) != 0)
    {
      if (!(*(unsigned int (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)this + 144))(this))
      {
        v6 = *(unsigned int *)(*(_QWORD *)(*((_QWORD *)this + 5) + 24) + 56);
        v7 = *(_QWORD *)((*(uint64_t (**)(TI::Favonius::ZephyrTypingModel::Hypothesis *))(*(_QWORD *)this + 8))(this)
                       + 16);
        if (v7)
        {
          if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v7 + 24))(v7, v6, *(unsigned int *)(*((_QWORD *)this + 3) + 56)) & 1) == 0)goto LABEL_5;
        }
        else if ((combines_with_selective_modifier() & 1) == 0)
        {
          goto LABEL_5;
        }
        goto LABEL_21;
      }
      v2 = *(_WORD *)(*((_QWORD *)this + 3) + 60);
    }
    if ((v2 & 0x40) != 0)
    {
      v4 = *((_QWORD *)this + 5);
LABEL_4:
      if ((*(_WORD *)(*(_QWORD *)(v4 + 24) + 60) & 2) == 0)
      {
LABEL_5:
        *((_BYTE *)this + 57) = 0;
        v3 = 0.0000004;
        goto LABEL_22;
      }
LABEL_21:
      v3 = 0.01;
      goto LABEL_22;
    }
    if ((v2 & 0x80) != 0)
    {
      v8 = *((_QWORD *)this + 4);
      if (v8)
      {
        v3 = flt_1DA90F138[(*(_WORD *)(*(_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8) + 60) & 0x80) == 0];
        v9 = *((_QWORD *)this + 4);
        if (v9 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 144))(v9) & 1) == 0)
        {
          v10 = *(float *)(*(_QWORD *)(*((_QWORD *)this + 4) + 40) + 64);
          if (v10 <= 0.0)
            v10 = 1.0;
          v3 = v3 / v10;
        }
      }
      else
      {
        v3 = 0.008;
      }
    }
    else if ((v2 & 0x30) != 0 && (v2 & 8) == 0)
    {
      v3 = TI::Favonius::ZephyrTypingModel::Hypothesis::typing_probability_of_terminator_key(this);
    }
    else if ((v2 & 0x300) != 0)
    {
      v3 = 0.002;
    }
    else
    {
      v3 = flt_1DA90F140[(v2 & 0x800) == 0];
    }
  }
LABEL_22:
  *((float *)this + 16) = v3;
}

float TI::Favonius::ZephyrTypingModel::Hypothesis::typing_probability_of_terminator_key(TI::Favonius::ZephyrTypingModel::Hypothesis *this)
{
  uint64_t v1;
  __int16 v2;
  float result;
  uint64_t v4;

  v1 = *((_QWORD *)this + 4);
  v2 = *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 40) + 24) + 60);
  result = 1.0;
  if ((v2 & 0xE) == 0)
  {
    if ((*(_WORD *)(*(_QWORD *)(*((_QWORD *)this + 5) + 24) + 60) & 0x20) != 0)
    {
      if ((v2 & 0x20) != 0)
      {
        v4 = *(_QWORD *)(v1 + 32);
        if (v4)
        {
          if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 24) + 60) & 0xE) != 0)
            result = 0.05;
        }
      }
    }
    else
    {
      result = 0.0025;
    }
  }
  if (!s_interface_idiom_is_pad && *(_DWORD *)(*((_QWORD *)this + 3) + 56) == 10)
    return result * 0.005;
  return result;
}

uint64_t TI::Favonius::ZephyrTypingModel::Hypothesis::input_segment_is_extended_by_key(_QWORD *a1, uint64_t a2)
{
  __int16 v2;
  uint64_t v4;
  uint64_t result;
  __int16 v7;
  uint64_t v8;

  v2 = *(_WORD *)(a2 + 60);
  if ((v2 & 0xE) == 0)
    return (v2 & 0xBC1) != 0;
  v4 = *(_QWORD *)(a1[5] + 24);
  if ((*(_WORD *)(v4 + 60) & 0xE) == 0 || ((*(uint64_t (**)(_QWORD *))(*a1 + 144))(a1) & 1) != 0)
    return 0;
  v7 = *(_WORD *)(a2 + 60);
  result = (*(_WORD *)(v4 + 60) & 8) == 0 || (v7 & 8) == 0;
  if ((v7 & 8) == 0 && (*(_WORD *)(v4 + 60) & 8) != 0)
  {
    if ((*(unsigned int (**)(_QWORD *))(*a1 + 168))(a1))
    {
      v8 = (*(uint64_t (**)(_QWORD *))(*a1 + 136))(a1);
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 168))(v8);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t TI::Favonius::ZephyrTypingModel::letter_combines_with_selective_modifier(TI::Favonius::ZephyrTypingModel *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 2);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  else
    return combines_with_selective_modifier();
}

void TI::Favonius::ZephyrTypingModel::Hypothesis::filter_words_for_input_segment(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t *v12;
  _QWORD v13[2];
  uint64_t (*v14)(uint64_t, KB::Word *);
  void *v15;
  uint64_t v16;
  _BYTE v17[8];
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)a1 + 120))(&v19);
  v4 = *(uint64_t **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 1174405120;
  v14 = ___ZNK2TI8Favonius17ZephyrTypingModel10Hypothesis30filter_words_for_input_segmentERNSt3__16vectorIN2KB4WordENS3_9allocatorIS6_EEEE_block_invoke;
  v15 = &__block_descriptor_tmp_14449;
  v16 = a1;
  KB::String::String((KB::String *)v17, (const KB::String *)&v19);
  if (v4 == (uint64_t *)v5)
    goto LABEL_13;
  v6 = v5;
  while ((v14((uint64_t)v13, (KB::Word *)v4) & 1) == 0)
  {
    v4 += 30;
    if (v4 == (uint64_t *)v5)
      goto LABEL_14;
  }
  if (v4 != (uint64_t *)v5)
  {
    if (v4 + 30 != (uint64_t *)v5)
    {
      v7 = v4 + 55;
      v6 = (uint64_t)v4;
      do
      {
        if ((v14((uint64_t)v13, (KB::Word *)(v7 - 25)) & 1) == 0)
        {
          KB::String::operator=(v6, (KB::String *)(v7 - 25));
          KB::ByteString::operator=((unsigned __int16 *)(v6 + 32), (unsigned __int16 *)v7 - 84);
          v8 = *(v7 - 19);
          *(_DWORD *)(v6 + 56) = *((_DWORD *)v7 - 36);
          *(_QWORD *)(v6 + 48) = v8;
          KB::String::operator=(v6 + 64, (KB::String *)(v7 - 17));
          v9 = *(_OWORD *)(v7 - 13);
          v10 = *(_OWORD *)(v7 - 11);
          v11 = *(_OWORD *)(v7 - 7);
          *(_OWORD *)(v6 + 128) = *(_OWORD *)(v7 - 9);
          *(_OWORD *)(v6 + 144) = v11;
          *(_OWORD *)(v6 + 96) = v9;
          *(_OWORD *)(v6 + 112) = v10;
          KB::String::operator=(v6 + 160, (KB::String *)(v7 - 5));
          *(_BYTE *)(v6 + 192) = *((_BYTE *)v7 - 8);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(v6 + 200, v7);
          v6 += 240;
        }
        v12 = v7 + 5;
        v7 += 30;
      }
      while (v12 != (uint64_t *)v5);
      goto LABEL_14;
    }
LABEL_13:
    v6 = (uint64_t)v4;
  }
LABEL_14:
  std::vector<KB::Word>::erase(a2, v6, *(KB::Word **)(a2 + 8));
  if (v18 && v17[6] == 1)
    free(v18);
  if (v20)
  {
    if (BYTE6(v19) == 1)
      free(v20);
  }
}

uint64_t ___ZNK2TI8Favonius17ZephyrTypingModel10Hypothesis30filter_words_for_input_segmentERNSt3__16vectorIN2KB4WordENS3_9allocatorIS6_EEEE_block_invoke(uint64_t a1, KB::Word *a2)
{
  TI::Favonius::ZephyrTypingModel *v4;

  v4 = (TI::Favonius::ZephyrTypingModel *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 8))(*(_QWORD *)(a1 + 32));
  return TI::Favonius::ZephyrTypingModel::word_is_acceptable_for_input(v4, a2, (const KB::String *)(a1 + 40)) ^ 1;
}

KB::String *__copy_helper_block_8_40c17_ZTSKN2KB6StringE(uint64_t a1, uint64_t a2)
{
  return KB::String::String((KB::String *)(a1 + 40), (const KB::String *)(a2 + 40));
}

void __destroy_helper_block_8_40c17_ZTSKN2KB6StringE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 46) == 1)
      free(v2);
  }
}

uint64_t TI::Favonius::ZephyrTypingModel::word_is_acceptable_for_input(TI::Favonius::ZephyrTypingModel *this, KB::Word *a2, const KB::String *a3)
{
  uint64_t v3;
  _QWORD v5[2];

  v3 = *((_QWORD *)this + 2);
  if (v3)
    return (*(uint64_t (**)(uint64_t, KB::Word *, const KB::String *))(*(_QWORD *)v3 + 16))(v3, a2, a3);
  v5[0] = &off_1EA103EF8;
  v5[1] = 1;
  return KB::InputSegmentFilter::word_is_acceptable_for_input((KB::InputSegmentFilter *)v5, a2, a3);
}

BOOL TIStringContainsCharacterFromSet(void *a1, uint64_t a2)
{
  return objc_msgSend(a1, "rangeOfCharacterFromSet:", a2) != 0x7FFFFFFFFFFFFFFFLL;
}

void TI::Favonius::CMTouchHistory::~CMTouchHistory(TI::Favonius::CMTouchHistory *this)
{
  TI::Favonius::CMTouchHistory::~CMTouchHistory(this);
  JUMPOUT(0x1DF0A2144);
}

{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  void *v5;
  uint64_t v6;

  *(_QWORD *)this = &off_1EA104628;
  WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::~Vector((_QWORD *)this + 14);
  WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::~Vector((_QWORD *)this + 11);
  v2 = *((_QWORD *)this + 6);
  if (v2)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v2);
  v3 = (uint64_t *)*((_QWORD *)this + 3);
  if (v3)
  {
    v4 = (uint64_t *)*((_QWORD *)this + 4);
    v5 = (void *)*((_QWORD *)this + 3);
    if (v4 != v3)
    {
      do
      {
        v4 -= 4;
        std::__destroy_at[abi:nn180100]<TI::Favonius::CMTouchHistory::TouchCorrelation,0>(v4);
      }
      while (v4 != v3);
      v5 = (void *)*((_QWORD *)this + 3);
    }
    *((_QWORD *)this + 4) = v3;
    operator delete(v5);
  }
  v6 = *((_QWORD *)this + 2);
  if (v6)
    WTF::RefCounted<TI::Favonius::Touch>::deref(v6);
}

float TI::Favonius::CMTouchHistory::pruning_threshold_for_touch(TI::Favonius::CMTouchHistory *this)
{
  return *((float *)this + 34);
}

float TI::Favonius::CMTouchHistory::transposition_cost_for_touch(TI::Favonius::CMTouchHistory *this)
{
  return *((float *)this + 35);
}

float TI::Favonius::CMTouchHistory::cost_for_inserting_key_before_touch(TI::Favonius::CMTouchHistory *this)
{
  return *((float *)this + 36);
}

float TI::Favonius::CMTouchHistory::cost_for_ignoring_touch(TI::Favonius::CMTouchHistory *this)
{
  return *((float *)this + 37);
}

float TI::Favonius::CMTouchHistory::cost_for_key_substitution(TI::Favonius::CMTouchHistory *this)
{
  return *((float *)this + 38);
}

uint64_t TI::Favonius::CMTouchHistory::touch(TI::Favonius::CMTouchHistory *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t TI::Favonius::CMTouchHistory::nearby_keys(TI::Favonius::CMTouchHistory *this)
{
  return (uint64_t)this + 88;
}

uint64_t TI::Favonius::CMTouchHistory::nearby_key_with_key_code(TI::Favonius::CMTouchHistory *this, int a2)
{
  if (*((_QWORD *)this + 14) <= (unint64_t)a2)
    return 0;
  else
    return *(_QWORD *)(*((_QWORD *)this + 15) + 8 * a2);
}

uint64_t TI::Favonius::CMTouchHistory::history_by_appending_touch@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *a2;
  *a2 = 0;
  v7 = v4;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, _QWORD))(*(_QWORD *)a1 + 112))(&v8, a1, &v7, 0);
  result = v7;
  v6 = v8;
  v8 = 0;
  *a3 = v6;
  if (result)
    return WTF::RefCounted<TI::Favonius::Touch>::deref(result);
  return result;
}

uint64_t TI::Favonius::CMTouchHistory::history_by_accepting_hypothesis@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  unsigned int *v7;
  uint64_t result;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;

  v6 = operator new();
  v7 = *a2;
  *a2 = 0;
  v12 = v7;
  result = TI::Favonius::CMTouchHistory::CMTouchHistory(v6, a1, (uint64_t *)&v12);
  *a3 = result;
  if (v7)
  {
    v9 = v7 + 2;
    v10 = atomic_load(v7 + 2);
    if (v10 == 1)
    {
      return (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
    }
    else
    {
      do
        v11 = __ldaxr(v9);
      while (__stlxr(v11 - 1, v9));
    }
  }
  return result;
}

uint64_t TI::Favonius::CMTouchHistory::root_hypothesis@<X0>(TI::Favonius::CMTouchHistory *this@<X0>, _QWORD *a2@<X8>)
{
  unsigned int *v4;
  unsigned int v5;
  uint64_t result;

  if (this)
  {
    v4 = (unsigned int *)((char *)this + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
  }
  result = operator new();
  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)result = &off_1EA104E00;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = this;
  *(_QWORD *)(result + 32) = 0;
  *a2 = result;
  return result;
}

unsigned __int16 *TI::Favonius::CMTouchHistory::append_debug_data(TI::Favonius::CMTouchHistory *this, KB::String *a2)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unsigned __int16 *result;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;

  KB::String::append((unsigned __int16 *)a2, "TOUCH INTERVAL: ", 0xFFFFuLL);
  v4 = *((double *)this + 7);
  KB::String::append_format(a2, "%.2f", v4);
  KB::String::append((unsigned __int16 *)a2, " (average: ", 0xFFFFuLL);
  v5 = *((double *)this + 8);
  KB::String::append_format(a2, "%.2f", v5);
  KB::String::append((unsigned __int16 *)a2, ")\n", 0xFFFFuLL);
  KB::String::append((unsigned __int16 *)a2, "TOUCH at (", 0xFFFFuLL);
  v6 = *(double *)(*((_QWORD *)this + 2) + 8);
  KB::String::append_format(a2, "%.2f", v6);
  KB::String::append((unsigned __int16 *)a2, ",", 0xFFFFuLL);
  v7 = *(double *)(*((_QWORD *)this + 2) + 16);
  KB::String::append_format(a2, "%.2f", v7);
  KB::String::append((unsigned __int16 *)a2, ") at time ", 0xFFFFuLL);
  v8 = *(double *)(*((_QWORD *)this + 2) + 32);
  KB::String::append_format(a2, "%.2f", v8);
  KB::String::append((unsigned __int16 *)a2, " with radius ", 0xFFFFuLL);
  KB::String::append_format(a2, "%.2f", *(float *)(*((_QWORD *)this + 2) + 24));
  KB::String::append((unsigned __int16 *)a2, "\n", 0xFFFFuLL);
  KB::String::append((unsigned __int16 *)a2, "\tPRUNING THRESHOLD: ", 0xFFFFuLL);
  v9 = (*(float (**)(TI::Favonius::CMTouchHistory *))(*(_QWORD *)this + 16))(this);
  KB::String::append_format(a2, "%.2f", v9);
  KB::String::append((unsigned __int16 *)a2, "\n\tTRANSPOSITION COST: ", 0xFFFFuLL);
  v10 = (*(float (**)(TI::Favonius::CMTouchHistory *))(*(_QWORD *)this + 24))(this);
  KB::String::append_format(a2, "%.2f", v10);
  KB::String::append((unsigned __int16 *)a2, "\n\tINSERTION COST: ", 0xFFFFuLL);
  v11 = (*(float (**)(TI::Favonius::CMTouchHistory *))(*(_QWORD *)this + 32))(this);
  KB::String::append_format(a2, "%.2f", v11);
  KB::String::append((unsigned __int16 *)a2, "\n\tDELETION COST: ", 0xFFFFuLL);
  v12 = (*(float (**)(TI::Favonius::CMTouchHistory *))(*(_QWORD *)this + 40))(this);
  KB::String::append_format(a2, "%.2f", v12);
  KB::String::append((unsigned __int16 *)a2, "\n", 0xFFFFuLL);
  result = KB::String::append((unsigned __int16 *)a2, "KEYS NEAR TOUCH:\n", 0xFFFFuLL);
  if (*((_QWORD *)this + 11))
  {
    v14 = 0;
    v15 = 1;
    do
    {
      v16 = *((_QWORD *)this + 12);
      TI::Favonius::Key::append_debug_data(*(TI::Favonius::Key **)(*(_QWORD *)(v16 + 8 * v14) + 8), a2);
      result = (unsigned __int16 *)KB::String::append_format(a2, ": %7.3f (%6.1f,%6.1f)\n", *(float *)(*(_QWORD *)(v16 + 8 * v14) + 32), *(double *)(*(_QWORD *)(v16 + 8 * v14) + 16), *(double *)(*(_QWORD *)(v16 + 8 * v14) + 24));
      v14 = v15;
    }
    while (*((_QWORD *)this + 11) > (unint64_t)v15++);
  }
  return result;
}

uint64_t TI::Favonius::CMTouchHistory::history_by_appending_touch@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  _BYTE v12[36];

  TI::Favonius::CMGeometryParameters::CMGeometryParameters((uint64_t)v12, (TI::Favonius::KeyboardLayout **)(*a2 + 56));
  v8 = operator new();
  v9 = *a2;
  *a2 = 0;
  v11 = v9;
  *a4 = TI::Favonius::CMTouchHistory::CMTouchHistory(v8, a1, &v11, (uint64_t)v12, a3);
  result = v11;
  if (v11)
    return WTF::RefCounted<TI::Favonius::Touch>::deref(v11);
  return result;
}

uint64_t TI::Favonius::CMTouchHistory::CMTouchHistory(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t *v9;
  double v10;
  double v11;
  double v12;
  uint64_t v13;
  float v14;
  float v15;
  double v16;
  float v17;
  double v18;
  double v19;
  float v20;
  _BOOL4 is_repeated_tap_on_same_key;
  double v22;
  float v23;
  double v24;
  float v25;

  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &off_1EA104628;
  *(_QWORD *)(a1 + 16) = *a3;
  v9 = (uint64_t *)(a1 + 16);
  *a3 = 0;
  TI::Favonius::CMTouchHistory::initialize_history_correlation((uint64_t *)(a1 + 16), (_QWORD *)a2, (unint64_t *)(a1 + 24));
  *(_QWORD *)(a1 + 48) = 0;
  TI::Favonius::CMTouchHistory::initialize_touch_interval((uint64_t)v9, a2);
  v11 = v10;
  *(double *)(a1 + 56) = v10;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 56))(a2))
    v12 = *(double *)(a2 + 64) + (v11 - *(double *)(a2 + 64)) * 0.200000003;
  else
    v12 = 0.35;
  *(double *)(a1 + 64) = v12;
  if (a5)
  {
    v13 = *a5;
    *(_DWORD *)(a1 + 80) = *((_DWORD *)a5 + 2);
    *(_QWORD *)(a1 + 72) = v13;
  }
  else
  {
    TI::Favonius::CMGeometryParametersForTouch::CMGeometryParametersForTouch((float *)(a1 + 72), a4, (uint64_t)v9, v12);
  }
  TI::Favonius::CMTouchHistory::initialize_key_matches(v9, a4, a1 + 72, (_QWORD *)(a1 + 88));
  TI::Favonius::CMTouchHistory::initialize_indexed_key_matches((_QWORD *)(a1 + 88), (unint64_t *)(a1 + 112));
  v14 = *(float *)(a1 + 80) * *(float *)(a1 + 80);
  v15 = v14 * 0.5 * *(float *)(a1 + 76);
  v16 = *(double *)(a1 + 64);
  v17 = *(double *)(a1 + 56) * -8.16326523 * *(double *)(a1 + 56) + -2.0;
  *(float *)(a1 + 136) = (float)(v14 * *(float *)(a1 + 72)) + v15;
  *(float *)(a1 + 140) = v17;
  v18 = 0.15;
  v19 = 0.15;
  if (v16 >= 0.15)
  {
    v19 = v16;
    if (v16 > 0.5)
      v19 = 0.5;
  }
  v20 = v19 * -8.16326523 * v19 + -2.0;
  *(float *)(a1 + 144) = v20;
  is_repeated_tap_on_same_key = TI::Favonius::CMTouchHistory::is_repeated_tap_on_same_key(a1 + 88, a2);
  v22 = v16 * -8.16326523 * v16 + -3.20000005 + -1.10524082;
  if (is_repeated_tap_on_same_key)
    v22 = v16 * -8.16326523 * v16 + -2.24000001;
  v23 = v22;
  *(float *)(a1 + 148) = v23;
  v24 = *(double *)(a1 + 64);
  if (v24 >= 0.15)
  {
    if (v24 > 0.5)
      v18 = 0.5;
    else
      v18 = *(double *)(a1 + 64);
  }
  v25 = v18 * -8.16326523 * v18 + -3.20000005;
  *(float *)(a1 + 152) = v25;
  return a1;
}

void TI::Favonius::CMTouchHistory::initialize_history_correlation(uint64_t *a1@<X0>, _QWORD *a2@<X1>, unint64_t *a3@<X8>)
{
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  __int128 v15;
  int64x2_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _OWORD *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _OWORD *v27;
  unint64_t v28;
  __int128 v29;
  int64x2_t v30;
  unint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  uint64_t v34;
  unint64_t v35;
  unsigned int *v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int *v57;
  unsigned int v58;
  unint64_t v59;
  _OWORD *v60;
  unsigned int *v61;
  unsigned int v62;
  unsigned int *v63;
  unsigned int v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  __int128 v68;
  unint64_t v69;
  __int128 v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  __int128 *v74;
  _OWORD *v75;
  __int128 v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int *v85;
  unsigned int v86;
  uint64_t v87;
  unsigned int *v88;
  unsigned int v89;
  uint64_t v90;
  uint64_t *v91;
  double *v92;
  uint64_t *v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  float v98;
  double v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  double v105;
  double v106;
  char *v107;
  int64x2_t v108;
  unint64_t v109;
  _QWORD *v110;

  a3[2] = 0;
  v6 = a3 + 2;
  *a3 = 0;
  a3[1] = 0;
  v7 = (uint64_t)(a2[4] - a2[3]) >> 5;
  v8 = v7 + 1;
  if (v7 != -1)
  {
    if (v8 >> 59)
      goto LABEL_115;
    v110 = v6;
    v9 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v8);
    v107 = v9;
    v108.i64[0] = (uint64_t)v9;
    v11 = &v9[32 * v10];
    v108.i64[1] = (uint64_t)v9;
    v109 = (unint64_t)v11;
    v13 = *a3;
    v12 = a3[1];
    if (v12 == *a3)
    {
      v16 = vdupq_n_s64(v12);
      v14 = v9;
    }
    else
    {
      v14 = v9;
      do
      {
        v15 = *(_OWORD *)(v12 - 32);
        v12 -= 32;
        *(_QWORD *)v12 = 0;
        *(_QWORD *)(v12 + 8) = 0;
        *((_OWORD *)v14 - 2) = v15;
        v14 -= 32;
        *((_OWORD *)v14 + 1) = *(_OWORD *)(v12 + 16);
      }
      while (v12 != v13);
      v16 = *(int64x2_t *)a3;
      v9 = (char *)v108.i64[1];
      v11 = (char *)v109;
    }
    *a3 = (unint64_t)v14;
    a3[1] = (unint64_t)v9;
    v108 = v16;
    v17 = a3[2];
    a3[2] = (unint64_t)v11;
    v109 = v17;
    v107 = (char *)v16.i64[0];
    std::__split_buffer<TI::Favonius::CMTouchHistory::TouchCorrelation>::~__split_buffer((uint64_t)&v107);
  }
  if (a2[2])
  {
    v18 = a3[1];
    v19 = a3[2];
    if (v18 >= v19)
    {
      v21 = *a3;
      v22 = (uint64_t)(v18 - *a3) >> 5;
      v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 59)
        goto LABEL_115;
      v24 = v19 - v21;
      if (v24 >> 4 > v23)
        v23 = v24 >> 4;
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFE0)
        v25 = 0x7FFFFFFFFFFFFFFLL;
      else
        v25 = v23;
      v110 = v6;
      if (v25)
      {
        v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v25);
        v21 = *a3;
        v18 = a3[1];
      }
      else
      {
        v26 = 0;
      }
      v27 = (_OWORD *)(v25 + 32 * v22);
      v107 = (char *)v25;
      v108.i64[0] = (uint64_t)v27;
      v28 = v25 + 32 * v26;
      v109 = v28;
      v20 = v27 + 2;
      *v27 = 0u;
      v27[1] = 0u;
      v108.i64[1] = (uint64_t)(v27 + 2);
      if (v18 == v21)
      {
        v30 = vdupq_n_s64(v21);
      }
      else
      {
        do
        {
          v29 = *(_OWORD *)(v18 - 32);
          v18 -= 32;
          *(_QWORD *)v18 = 0;
          *(_QWORD *)(v18 + 8) = 0;
          *(v27 - 2) = v29;
          v27 -= 2;
          v27[1] = *(_OWORD *)(v18 + 16);
        }
        while (v18 != v21);
        v30 = *(int64x2_t *)a3;
        v20 = (_OWORD *)v108.i64[1];
        v28 = v109;
      }
      *a3 = (unint64_t)v27;
      a3[1] = (unint64_t)v20;
      v108 = v30;
      v31 = a3[2];
      a3[2] = v28;
      v109 = v31;
      v107 = (char *)v30.i64[0];
      std::__split_buffer<TI::Favonius::CMTouchHistory::TouchCorrelation>::~__split_buffer((uint64_t)&v107);
    }
    else
    {
      v20 = (_OWORD *)(v18 + 32);
      *(_OWORD *)v18 = 0u;
      *(_OWORD *)(v18 + 16) = 0u;
    }
    a3[1] = (unint64_t)v20;
    v32 = (unsigned int *)a2[2];
    if (v32)
    {
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 + 1, v32));
    }
    v34 = *((_QWORD *)v20 - 4);
    *((_QWORD *)v20 - 4) = v32;
    if (v34)
      WTF::RefCounted<TI::Favonius::Touch>::deref(v34);
    v35 = a3[1];
    v36 = (unsigned int *)a2[6];
    if (v36)
    {
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 + 1, v36));
    }
    v38 = *(_QWORD *)(v35 - 24);
    *(_QWORD *)(v35 - 24) = v36;
    if (v38)
      WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v38);
  }
  v40 = a2[3];
  v39 = a2[4];
  if (v39 - v40 < 1)
    goto LABEL_92;
  v41 = (v39 - v40) >> 5;
  v42 = *a3;
  v43 = a3[1];
  v44 = v43 - *a3;
  v45 = v44 >> 5;
  v46 = *a3 + (v44 & 0xFFFFFFFFFFFFFFE0);
  if (v41 > (uint64_t)(*v6 - v43) >> 5)
  {
    v47 = v45 + v41;
    if (!((unint64_t)(v45 + v41) >> 59))
    {
      v48 = *v6 - v42;
      if (v48 >> 4 > v47)
        v47 = v48 >> 4;
      if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFE0)
        v49 = 0x7FFFFFFFFFFFFFFLL;
      else
        v49 = v47;
      v110 = v6;
      if (v49)
        v49 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v49);
      else
        v50 = 0;
      v59 = v49 + 32 * v45;
      v107 = (char *)v49;
      v108.i64[0] = v59;
      v108.i64[1] = v59;
      v109 = v49 + 32 * v50;
      v60 = (_OWORD *)(v59 + 32 * v41);
      do
      {
        v61 = *(unsigned int **)v40;
        *(_QWORD *)v59 = *(_QWORD *)v40;
        if (v61)
        {
          do
            v62 = __ldaxr(v61);
          while (__stlxr(v62 + 1, v61));
        }
        v63 = *(unsigned int **)(v40 + 8);
        *(_QWORD *)(v59 + 8) = v63;
        if (v63)
        {
          do
            v64 = __ldaxr(v63);
          while (__stlxr(v64 + 1, v63));
        }
        *(_OWORD *)(v59 + 16) = *(_OWORD *)(v40 + 16);
        v59 += 32;
        v40 += 32;
      }
      while ((_OWORD *)v59 != v60);
      v108.i64[1] = (uint64_t)v60;
      v65 = v108.i64[0];
      v66 = *a3;
      if (*a3 != v46)
      {
        v67 = v46;
        do
        {
          v68 = *(_OWORD *)(v67 - 32);
          v67 -= 32;
          *(_QWORD *)v67 = 0;
          *(_QWORD *)(v67 + 8) = 0;
          *(_OWORD *)(v65 - 32) = v68;
          v65 -= 32;
          *(_OWORD *)(v65 + 16) = *(_OWORD *)(v67 + 16);
        }
        while (v67 != v66);
        v60 = (_OWORD *)v108.i64[1];
      }
      v108.i64[0] = v65;
      v69 = a3[1];
      if (v69 != v46)
      {
        do
        {
          v70 = *(_OWORD *)v46;
          *(_QWORD *)v46 = 0;
          *(_QWORD *)(v46 + 8) = 0;
          *v60 = v70;
          v60[1] = *(_OWORD *)(v46 + 16);
          v60 += 2;
          v46 += 32;
        }
        while (v46 != v69);
        v65 = v108.i64[0];
        v46 = a3[1];
      }
      v71 = *a3;
      *a3 = v65;
      a3[1] = (unint64_t)v60;
      v72 = a3[2];
      a3[2] = v109;
      v108.i64[1] = v46;
      v109 = v72;
      v107 = (char *)v71;
      v108.i64[0] = v71;
      std::__split_buffer<TI::Favonius::CMTouchHistory::TouchCorrelation>::~__split_buffer((uint64_t)&v107);
      goto LABEL_92;
    }
LABEL_115:
    abort();
  }
  v51 = (uint64_t)(v43 - v46) >> 5;
  if (v51 >= v41)
  {
    v52 = v40 + 32 * v41;
    v54 = a3[1];
LABEL_71:
    v73 = v46 + 32 * v41;
    v74 = (__int128 *)(v54 - 32 * v41);
    v75 = (_OWORD *)v54;
    if ((unint64_t)v74 < v43)
    {
      v75 = (_OWORD *)v54;
      do
      {
        v76 = *v74;
        *(_QWORD *)v74 = 0;
        *((_QWORD *)v74 + 1) = 0;
        *v75 = v76;
        v75[1] = v74[1];
        v75 += 2;
        v74 += 2;
      }
      while ((unint64_t)v74 < v43);
    }
    a3[1] = (unint64_t)v75;
    if (v54 != v73)
    {
      v77 = 32 * ((uint64_t)(v54 - v73) >> 5);
      v78 = v42 + 32 * v45 - 16;
      v79 = v54 - 32;
      do
      {
        v80 = v78 + v77;
        v81 = *(_QWORD *)(v78 + v77 - 16);
        *(_QWORD *)(v78 + v77 - 16) = 0;
        v82 = *(_QWORD *)v79;
        *(_QWORD *)v79 = v81;
        if (v82)
          WTF::RefCounted<TI::Favonius::Touch>::deref(v82);
        v83 = *(_QWORD *)(v80 - 8);
        *(_QWORD *)(v80 - 8) = 0;
        v84 = *(_QWORD *)(v79 + 8);
        *(_QWORD *)(v79 + 8) = v83;
        if (v84)
          WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v84);
        *(_OWORD *)(v79 + 16) = *(_OWORD *)(v78 + v77);
        v79 -= 32;
        v77 -= 32;
      }
      while (v77);
    }
    while (v40 != v52)
    {
      v85 = *(unsigned int **)v40;
      if (*(_QWORD *)v40)
      {
        do
          v86 = __ldaxr(v85);
        while (__stlxr(v86 + 1, v85));
      }
      v87 = *(_QWORD *)v46;
      *(_QWORD *)v46 = v85;
      if (v87)
        WTF::RefCounted<TI::Favonius::Touch>::deref(v87);
      v88 = *(unsigned int **)(v40 + 8);
      if (v88)
      {
        do
          v89 = __ldaxr(v88);
        while (__stlxr(v89 + 1, v88));
      }
      v90 = *(_QWORD *)(v46 + 8);
      *(_QWORD *)(v46 + 8) = v88;
      if (v90)
        WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v90);
      *(_OWORD *)(v46 + 16) = *(_OWORD *)(v40 + 16);
      v40 += 32;
      v46 += 32;
    }
    goto LABEL_92;
  }
  v52 = v40 + 32 * v51;
  if (v52 == v39)
  {
    v54 = a3[1];
  }
  else
  {
    v53 = v40 + 32 * v51;
    v54 = a3[1];
    do
    {
      v55 = *(unsigned int **)v53;
      *(_QWORD *)v54 = *(_QWORD *)v53;
      if (v55)
      {
        do
          v56 = __ldaxr(v55);
        while (__stlxr(v56 + 1, v55));
      }
      v57 = *(unsigned int **)(v53 + 8);
      *(_QWORD *)(v54 + 8) = v57;
      if (v57)
      {
        do
          v58 = __ldaxr(v57);
        while (__stlxr(v58 + 1, v57));
      }
      *(_OWORD *)(v54 + 16) = *(_OWORD *)(v53 + 16);
      v53 += 32;
      v54 += 32;
    }
    while (v53 != v39);
  }
  a3[1] = v54;
  if ((uint64_t)(v43 - v46) >= 1)
    goto LABEL_71;
LABEL_92:
  v92 = (double *)*a3;
  v91 = (uint64_t *)a3[1];
  if ((unint64_t)v91 - *a3 < 0x401)
  {
    v93 = (uint64_t *)a3[1];
  }
  else
  {
    v93 = (uint64_t *)(v92 + 128);
    if (v91 != (uint64_t *)(v92 + 128))
    {
      do
      {
        v91 -= 4;
        std::__destroy_at[abi:nn180100]<TI::Favonius::CMTouchHistory::TouchCorrelation,0>(v91);
      }
      while (v91 != v93);
      v92 = (double *)*a3;
    }
    a3[1] = (unint64_t)v93;
  }
  if (v92 != (double *)v93)
  {
    v94 = v93 - 4;
    if (*(double *)(*a1 + 32) - *(double *)(*(v93 - 4) + 32) <= 40.0)
    {
LABEL_103:
      if (v92 != (double *)v93)
      {
        do
        {
          v96 = *(_QWORD *)v92;
          v97 = *a1;
          v98 = *(double *)(*a1 + 32) - *(double *)(*(_QWORD *)v92 + 32);
          v99 = 0.0;
          if (v98 <= 40.0)
            v99 = (40.0 - v98) / 40.0;
          v100 = *(float *)(v97 + 24);
          v101 = *(float *)(v96 + 24);
          if (v100 >= v101)
            v102 = *(float *)(v97 + 24);
          else
            v102 = *(float *)(v96 + 24);
          v103 = 0.0;
          if (v102 > 0.0)
          {
            if (v100 >= v101)
              v100 = *(float *)(v96 + 24);
            v103 = (float)(v102 - v100) / v102;
          }
          v104 = v99;
          v105 = (float)((float)(1.0 - v103) * v104);
          v92[2] = TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(v96, v97) * v105;
          v92[3] = v106 * v105;
          v92 += 4;
        }
        while (v92 != (double *)a3[1]);
      }
    }
    else
    {
      while (1)
      {
        std::__destroy_at[abi:nn180100]<TI::Favonius::CMTouchHistory::TouchCorrelation,0>(v94);
        a3[1] = (unint64_t)v94;
        v92 = (double *)*a3;
        if (v94 == (uint64_t *)*a3)
          break;
        v95 = *(v94 - 4);
        v94 -= 4;
        if (*(double *)(*a1 + 32) - *(double *)(v95 + 32) <= 40.0)
        {
          v93 = v94 + 4;
          goto LABEL_103;
        }
      }
    }
  }
}

uint64_t TI::Favonius::CMTouchHistory::initialize_touch_interval(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 56))(a2);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 56))(a2);
  return result;
}

_QWORD *TI::Favonius::CMTouchHistory::initialize_key_matches@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  CGRect **v10;
  CGRect **v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  void *v19;
  const void *v20;
  uint64_t v21;
  uint64_t *v22;
  _QWORD v24[2];
  void (*v25)(uint64_t, CGRect **);
  void *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  _QWORD *(*v34)(_QWORD *, _QWORD *);
  _QWORD *(*v35)(uint64_t);
  _QWORD v36[3];
  void *v37;

  v31 = 0;
  v32 = &v31;
  v33 = 0x4002000000;
  v34 = __Block_byref_object_copy__15437;
  v35 = __Block_byref_object_dispose__15438;
  memset(v36, 0, sizeof(v36));
  v8 = *a1;
  WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(v36, ((*(_QWORD *)(*(_QWORD *)(*a1 + 56) + 16) - *(_QWORD *)(*(_QWORD *)(*a1 + 56) + 8)) >> 3));
  v9 = *(_QWORD *)(v8 + 56);
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 0x40000000;
  v25 = ___ZN2TI8Favonius14CMTouchHistory22initialize_key_matchesERKN3WTF6RefPtrINS0_5TouchEEERKNS0_20CMGeometryParametersERKNS0_28CMGeometryParametersForTouchE_block_invoke;
  v26 = &unk_1EA1046C8;
  v29 = a2;
  v30 = a3;
  v27 = &v31;
  v28 = a1;
  v10 = *(CGRect ***)(v9 + 8);
  v11 = *(CGRect ***)(v9 + 16);
  while (v10 != v11)
    v25((uint64_t)v24, v10++);
  v13 = v32[5];
  v12 = v32[6];
  v37 = &__block_literal_global_15440;
  v14 = 126 - 2 * __clz(v13);
  if (v13)
    v15 = v14;
  else
    v15 = 0;
  std::__introsort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::KeyMatch> const&,WTF::RefPtr<TI::Favonius::KeyMatch> const&),WTF::RefPtr<TI::Favonius::KeyMatch>*,false>(v12, (uint64_t *)(v12 + 8 * v13), (uint64_t)&v37, v15, 1);
  v16 = v32;
  v17 = v32[5];
  if (v17 >= 0xE)
  {
    v18 = v32[6];
    v19 = (void *)(v18 + 104);
    v20 = (const void *)(v18 + 8 * v17);
    v21 = 8 * v17 - 104;
    v22 = (uint64_t *)(v18 + 104);
    do
    {
      if (*v22)
        WTF::RefCounted<TI::Favonius::KeyMatch>::deref(*v22);
      ++v22;
      v21 -= 8;
    }
    while (v21);
    memmove(v19, v20, v16[6] + 8 * v16[5] - (_QWORD)v20);
    v16[5] = v16[5] - v17 + 13;
    v16 = v32;
  }
  WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::Vector(a4, v16 + 5);
  _Block_object_dispose(&v31, 8);
  return WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::~Vector(v36);
}

_QWORD *TI::Favonius::CMTouchHistory::initialize_indexed_key_matches@<X0>(_QWORD *result@<X0>, unint64_t *a2@<X8>)
{
  _QWORD *v3;
  unint64_t v4;
  unsigned int **v5;
  unsigned int *v6;
  unint64_t v7;
  unsigned int **v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (*result)
  {
    v3 = result;
    v4 = 0;
    v5 = (unsigned int **)result[1];
    while (1)
    {
      v6 = *v5;
      v7 = *(__int16 *)(*((_QWORD *)*v5 + 1) + 62);
      if (v4 > v7)
        break;
      v9 = v7 + 1;
      if (v4 >= v7 + 1)
      {
        v13 = a2[1];
        if (v4 != v7 + 1)
        {
          v14 = 8 * v4;
          v15 = 8 * v7 + 8;
          do
          {
            v16 = *(_QWORD *)(v13 + v15);
            if (v16)
              WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v16);
            v15 += 8;
          }
          while (v14 != v15);
        }
      }
      else
      {
        v10 = a2[2];
        if (v10 < v9)
        {
          if (v10 >= 0x100)
            v11 = v10 + (v10 >> 1);
          else
            v11 = 2 * v10;
          if (v11 <= v9)
            v12 = v7 + 1;
          else
            v12 = v11;
          WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(a2, v12);
        }
        v13 = a2[1];
        if (v13)
          bzero((void *)(v13 + 8 * *a2), 8 * v9 - 8 * *a2);
      }
      *a2 = v9;
      v6 = *v5;
      v8 = (unsigned int **)(v13 + 8 * v7);
      if (*v5)
        goto LABEL_22;
      v4 = v7 + 1;
LABEL_24:
      result = *v8;
      *v8 = v6;
      if (result)
        result = (_QWORD *)WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)result);
      if (++v5 == (unsigned int **)(v3[1] + 8 * *v3))
        return result;
    }
    v8 = (unsigned int **)(a2[1] + 8 * v7);
    do
LABEL_22:
      v17 = __ldaxr(v6);
    while (__stlxr(v17 + 1, v6));
    v4 = *a2;
    goto LABEL_24;
  }
  return result;
}

BOOL TI::Favonius::CMTouchHistory::is_repeated_tap_on_same_key(uint64_t a1, uint64_t a2)
{
  _BOOL8 v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;

  if (!a2)
    return 0;
  if (!*(_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2) || *(_QWORD *)a1 == 0)
    return 0;
  v6 = *(_QWORD *)(**(_QWORD **)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2) + 8) + 8);
  if (v6)
  {
    do
      v7 = __ldaxr((unsigned int *)v6);
    while (__stlxr(v7 + 1, (unsigned int *)v6));
  }
  v8 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 8);
  if (v8)
  {
    do
      v9 = __ldaxr((unsigned int *)v8);
    while (__stlxr(v9 + 1, (unsigned int *)v8));
  }
  if (*(unsigned __int16 *)(v8 + 62) == *(unsigned __int16 *)(v6 + 62))
    v5 = v8 == v6 || KB::String::equal((KB::String *)(v8 + 8), (const KB::String *)(v6 + 8), 1);
  else
    v5 = 0;
  WTF::RefCounted<TI::Favonius::Key>::deref(v8);
  WTF::RefCounted<TI::Favonius::Key>::deref(v6);
  return v5;
}

_QWORD *__Block_byref_object_copy__15437(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  a2[5] = 0;
  a2[6] = 0;
  v3 = result[7];
  result[7] = a2[7];
  a2[7] = v3;
  return result;
}

_QWORD *__Block_byref_object_dispose__15438(uint64_t a1)
{
  return WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::~Vector((_QWORD *)(a1 + 40));
}

void ___ZN2TI8Favonius14CMTouchHistory22initialize_key_matchesERKN3WTF6RefPtrINS0_5TouchEEERKNS0_20CMGeometryParametersERKNS0_28CMGeometryParametersForTouchE_block_invoke(uint64_t a1, CGRect **a2)
{
  uint64_t v4;
  double v5;
  double v6;
  float Width;
  float v8;
  float v9;
  float v10;
  double v11;
  double v12;
  float v13;
  float v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  CGRect *v18;
  unsigned int v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void **v27;
  unint64_t v28;
  _WORD *v29;
  CGRect *v30;
  size_t v31;
  CGFloat v32;
  CGFloat v33;
  CGFloat v34;
  CGFloat v35;
  __int16 v36;
  TI::Favonius::LayoutKey *v37;
  _QWORD *v38;
  unint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t i;
  void *v48;
  void *v49;
  BOOL v50;
  KB::String *p_y;
  _BOOL8 v52;
  CGRect *v53;
  size_t y_low;
  _BOOL4 v55;
  CGFloat x;
  CGFloat y;
  CGFloat v58;
  CGFloat height;
  __int16 height_high;
  TI::Favonius::LayoutKey *v61;
  _QWORD *v62;
  unint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  __int128 v71;
  _BYTE v72[8];
  void *v73;
  void *v74[2];
  _WORD v75[3];
  char v76;
  void *v77;
  uint64_t v78;
  CGRect v79;
  CGRect v80;

  v78 = *MEMORY[0x1E0C80C00];
  v4 = **(_QWORD **)(a1 + 40);
  v5 = *(double *)(v4 + 8) - (*a2)[3].origin.x;
  v6 = *(double *)(v4 + 16) - (*a2)[3].origin.y;
  Width = CGRectGetWidth((*a2)[2]);
  v8 = Width * 0.5;
  v9 = *(float *)(*(_QWORD *)(a1 + 48) + 4);
  if (v8 <= v9)
  {
    v12 = v5;
  }
  else
  {
    v10 = v8 - v9;
    v11 = v10;
    if (v5 <= v10)
    {
      v12 = 0.0;
      if (v5 < (float)-v10)
        v12 = v5 + v11;
    }
    else
    {
      v12 = v5 - v11;
    }
  }
  v13 = v6 * v6 + v12 * v12;
  v14 = **(float **)(a1 + 56) * v13;
  v15 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
  v16 = operator new();
  v17 = v16;
  *(_DWORD *)v16 = 1;
  v18 = *a2;
  *(_QWORD *)(v16 + 8) = *a2;
  if (v18)
  {
    do
      v19 = __ldaxr((unsigned int *)v18);
    while (__stlxr(v19 + 1, (unsigned int *)v18));
  }
  v20 = v15 + 5;
  *(double *)(v16 + 16) = v12;
  *(double *)(v16 + 24) = v6;
  *(float *)(v16 + 32) = v14;
  v21 = v15[5];
  if (v21 != v15[7])
  {
    v24 = v15[6];
    goto LABEL_18;
  }
  v22 = v21 + (v21 >> 1);
  if (v21 < 0x100)
    v22 = 2 * v21;
  if (v22 <= v21 + 1)
    v23 = v21 + 1;
  else
    v23 = v22;
  WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(v15 + 5, v23);
  v24 = v15[6];
  if (v24)
  {
    v21 = *v20;
LABEL_18:
    *(_QWORD *)(v24 + 8 * v21) = v17;
    *v20 = v21 + 1;
    goto LABEL_19;
  }
  WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v17);
LABEL_19:
  v25 = *(_QWORD *)(a1 + 48);
  if (!*(_BYTE *)(v25 + 1))
  {
    if (!*(_BYTE *)(v25 + 2))
      return;
    p_y = (KB::String *)&(*a2)->origin.y;
    KB::String::String((KB::String *)v74, "");
    v52 = KB::String::equal(p_y, (const KB::String *)v74, 1);
    if (v52)
    {
      KB::String::String((KB::String *)v75, "");
    }
    else
    {
      KB::String::empty_string((KB::String *)v52);
      KB::String::String((KB::String *)v75, (const KB::String *)&KB::String::empty_string(void)::empty_string);
    }
    if (v74[1] && BYTE6(v74[0]) == 1)
      free(v74[1]);
    if (!v75[0])
    {
LABEL_86:
      v49 = v77;
      if (!v77 || v76 != 1)
        return;
LABEL_88:
      free(v49);
      return;
    }
    v53 = *a2;
    y_low = LOWORD((*a2)[1].origin.y);
    if (y_low < 0xF)
    {
      *(_OWORD *)v74 = *(_OWORD *)&(*a2)[1].origin.y;
      v55 = LOWORD(v74[0]) > 0xEu;
    }
    else
    {
      LOWORD(v74[0]) = LOWORD((*a2)[1].origin.y);
      v74[1] = (void *)operator new[]();
      memcpy(v74[1], *(const void **)&v53[1].size.width, y_low);
      v53 = *a2;
      v55 = 1;
    }
    x = v53[2].origin.x;
    y = v53[2].origin.y;
    v58 = v53[2].size.width;
    height = v53[2].size.height;
    height_high = HIWORD(v53[1].size.height);
    v61 = (TI::Favonius::LayoutKey *)operator new();
    v80.origin.x = x;
    v80.origin.y = y;
    v80.size.width = v58;
    v80.size.height = height;
    TI::Favonius::LayoutKey::LayoutKey(v61, (const KB::String *)v75, (const void **)v74, v80, height_high);
    if (v55 && v74[1])
      MEMORY[0x1DF0A212C](v74[1], 0x1000C8077774924);
    v62 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
    v63 = v62 + 5;
    v64 = operator new();
    v65 = v64;
    *(_DWORD *)v64 = 1;
    *(_QWORD *)(v64 + 8) = v61;
    do
      v66 = __ldaxr((unsigned int *)v61);
    while (__stlxr(v66 + 1, (unsigned int *)v61));
    *(double *)(v64 + 16) = v12;
    *(double *)(v64 + 24) = v6;
    *(float *)(v64 + 32) = v14;
    v67 = v62[5];
    if (v67 == v62[7])
    {
      v68 = v67 + (v67 >> 1);
      if (v67 < 0x100)
        v68 = 2 * v67;
      if (v68 <= v67 + 1)
        v69 = v67 + 1;
      else
        v69 = v68;
      WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(v62 + 5, v69);
      v70 = v62[6];
      if (!v70)
      {
        WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v65);
        goto LABEL_85;
      }
      v67 = *v63;
    }
    else
    {
      v70 = v62[6];
    }
    *(_QWORD *)(v70 + 8 * v67) = v65;
    *v63 = v67 + 1;
LABEL_85:
    WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v61);
    goto LABEL_86;
  }
  KB::String::String((KB::String *)v75, (const KB::String *)&(*a2)->origin.y);
  KB::String::String((KB::String *)v72, (const KB::String *)v75);
  TI::IndicUtils::convertVowel((const KB::String *)v72, (uint64_t)v74);
  if (v73 && v72[6] == 1)
    free(v73);
  v26 = 0;
  v27 = v74;
  do
  {
    v28 = (unint64_t)&v74[4 * v26];
    if (*(_WORD *)(v28 + 4) || (v29 = (_WORD *)(v28 | 4), KB::String::compute_length((unsigned __int16 *)v27), *v29))
    {
      if (!KB::String::equal((KB::String *)v27, (const KB::String *)v75, 1))
      {
        v30 = *a2;
        v31 = LOWORD((*a2)[1].origin.y);
        if (v31 < 0xF)
        {
          v71 = *(_OWORD *)&(*a2)[1].origin.y;
          LODWORD(v31) = (unsigned __int16)v71;
        }
        else
        {
          LOWORD(v71) = LOWORD((*a2)[1].origin.y);
          *((_QWORD *)&v71 + 1) = operator new[]();
          memcpy(*((void **)&v71 + 1), *(const void **)&v30[1].size.width, v31);
          v30 = *a2;
        }
        v32 = v30[2].origin.x;
        v33 = v30[2].origin.y;
        v34 = v30[2].size.width;
        v35 = v30[2].size.height;
        v36 = HIWORD(v30[1].size.height);
        v37 = (TI::Favonius::LayoutKey *)operator new();
        v79.origin.x = v32;
        v79.origin.y = v33;
        v79.size.width = v34;
        v79.size.height = v35;
        TI::Favonius::LayoutKey::LayoutKey(v37, (const KB::String *)v27, (const void **)&v71, v79, v36);
        if (v31 >= 0xF && *((_QWORD *)&v71 + 1))
          MEMORY[0x1DF0A212C](*((_QWORD *)&v71 + 1), 0x1000C8077774924);
        v38 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
        v39 = v38 + 5;
        v40 = operator new();
        v41 = v40;
        *(_DWORD *)v40 = 1;
        *(_QWORD *)(v40 + 8) = v37;
        do
          v42 = __ldaxr((unsigned int *)v37);
        while (__stlxr(v42 + 1, (unsigned int *)v37));
        *(double *)(v40 + 16) = v12;
        *(double *)(v40 + 24) = v6;
        *(float *)(v40 + 32) = v14;
        v43 = v38[5];
        if (v43 == v38[7])
        {
          v44 = v43 + (v43 >> 1);
          if (v43 < 0x100)
            v44 = 2 * v43;
          if (v44 <= v43 + 1)
            v45 = v43 + 1;
          else
            v45 = v44;
          WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(v38 + 5, v45);
          v46 = v38[6];
          if (!v46)
          {
            WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v41);
            goto LABEL_45;
          }
          v43 = *v39;
        }
        else
        {
          v46 = v38[6];
        }
        *(_QWORD *)(v46 + 8 * v43) = v41;
        *v39 = v43 + 1;
LABEL_45:
        WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v37);
      }
    }
    ++v26;
    v27 = &v74[4 * v26];
  }
  while (v26 != 3);
  for (i = 0; i != -12; i -= 4)
  {
    v48 = v74[i + 9];
    if (v48 && BYTE6(v74[i + 8]) == 1)
      free(v48);
  }
  v49 = v77;
  if (v77)
    v50 = v76 == 1;
  else
    v50 = 0;
  if (v50)
    goto LABEL_88;
}

BOOL ___ZN2TI8Favonius14CMTouchHistory22initialize_key_matchesERKN3WTF6RefPtrINS0_5TouchEEERKNS0_20CMGeometryParametersERKNS0_28CMGeometryParametersForTouchE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(float *)(*(_QWORD *)a2 + 32) > *(float *)(*(_QWORD *)a3 + 32);
}

uint64_t std::__split_buffer<TI::Favonius::CMTouchHistory::TouchCorrelation>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    std::__destroy_at[abi:nn180100]<TI::Favonius::CMTouchHistory::TouchCorrelation,0>((uint64_t *)(i - 32));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__destroy_at[abi:nn180100]<TI::Favonius::CMTouchHistory::TouchCorrelation,0>(uint64_t *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = a1[1];
  if (v2)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v2);
  result = *a1;
  if (*a1)
    return WTF::RefCounted<TI::Favonius::Touch>::deref(result);
  return result;
}

double TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(uint64_t a1, uint64_t a2)
{
  float v2;
  double v3;
  unsigned __int8 v4;
  float v5;
  unsigned __int8 v6;
  double v7;
  int v8;
  int v9;
  float v10;
  float v11;
  unsigned __int8 v12;
  __objc2_prot_list **p_prots;
  float v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  int v19;
  float v20;
  float v21;
  int v22;
  int v23;
  float v24;
  int v25;
  float v26;
  int v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float v33;
  float v34;

  v2 = *(double *)(a2 + 16) - *(double *)(a1 + 16);
  v3 = vabdd_f64(*(double *)(a2 + 8), *(double *)(a1 + 8)) + fabsf(v2) * 0.6;
  if ((v4 & 1) == 0)
  {
    v29 = a2;
    v31 = a1;
    a2 = v29;
    a1 = v31;
    if (v19)
    {
      v20 = 26.5;
      if (!s_interface_idiom_is_pad)
        v20 = 31.5;
      TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::min_sep_x = LODWORD(v20);
      a2 = v29;
      a1 = v31;
    }
  }
  v5 = v3;
  if ((v6 & 1) == 0)
  {
    v30 = a2;
    v32 = a1;
    v21 = v3;
    v5 = v21;
    v23 = v22;
    a2 = v30;
    a1 = v32;
    if (v23)
    {
      TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::max_sep_x = dword_1DA90F178[s_interface_idiom_is_pad == 0];
      v5 = v21;
      a2 = v30;
      a1 = v32;
    }
  }
  v7 = 1.0;
  if (*(float *)&TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::min_sep_x <= v5)
  {
    v7 = 0.0;
    if (*(float *)&TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::max_sep_x > v5)
      v7 = (float)((float)(*(float *)&TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::max_sep_x
                         - v5)
                 / (float)(*(float *)&TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::max_sep_x
                         - *(float *)&TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::min_sep_x));
  }
  if (*(_BYTE *)(*(_QWORD *)(a2 + 56) + 112))
  {
    v8 = *(_DWORD *)(a2 + 52);
    if (v8 && (v9 = *(_DWORD *)(a1 + 52)) != 0)
    {
      if (v8 != v9)
        v7 = v7 * 0.5;
    }
    else
    {
      v10 = (*(double *)(a1 + 8) + *(double *)(a2 + 8)) * -0.5;
      v11 = TI::Favonius::KeyboardLayout::get_horizontal_center(*(TI::Favonius::KeyboardLayout **)(a2 + 56)) + v10;
      p_prots = &OBJC_PROTOCOL___TITrialManager.prots;
      if ((v12 & 1) == 0)
      {
        v33 = v11;
        v11 = v33;
        p_prots = &OBJC_PROTOCOL___TITrialManager.prots;
        if (v25)
        {
          v26 = 53.0;
          if (!s_interface_idiom_is_pad)
            v26 = 63.0;
          TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::min_center_distance = LODWORD(v26);
          v11 = v33;
          p_prots = (__objc2_prot_list **)(&OBJC_PROTOCOL___TITrialManager + 16);
        }
      }
      v14 = fabsf(v11);
      if ((v15 & 1) == 0)
      {
        v34 = v14;
        v14 = v34;
        p_prots = (__objc2_prot_list **)(&OBJC_PROTOCOL___TITrialManager + 16);
        if (v27)
        {
          v28 = 106.0;
          if (!s_interface_idiom_is_pad)
            v28 = 126.0;
          TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::max_center_distance = LODWORD(v28);
          v14 = v34;
          p_prots = (__objc2_prot_list **)(&OBJC_PROTOCOL___TITrialManager + 16);
        }
      }
      if (v14 < *((float *)p_prots + 666))
        v7 = v7
           * ((float)(v14
                    / *(float *)&TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::max_center_distance)
            + 0.5);
    }
  }
  if ((v16 & 1) == 0
  {
    v24 = 26.5;
    if (!s_interface_idiom_is_pad)
      v24 = 31.5;
    TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::min_sep_y = LODWORD(v24);
  }
  if ((v17 & 1) == 0
  {
    TI::Favonius::CMTouchHistory::estimate_inter_finger_zone_correlation(TI::Favonius::Touch const*,TI::Favonius::Touch const*)::max_sep_y = dword_1DA90F180[s_interface_idiom_is_pad == 0];
  }
  return v7;
}

uint64_t TI::Favonius::CMTouchHistory::CMTouchHistory(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  uint64_t v30;
  _QWORD v32[2];
  BOOL (*v33)(uint64_t, _QWORD *);
  void *v34;
  uint64_t v35;

  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &off_1EA104628;
  v6 = *(unsigned int **)(a2 + 16);
  *(_QWORD *)(a1 + 16) = v6;
  if (v6)
  {
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
  }
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(_QWORD *)(a2 + 32);
  v10 = v9 - v8;
  if (v9 != v8)
  {
    if (v10 < 0)
      abort();
    v11 = std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v10 >> 5);
    *(_QWORD *)(a1 + 24) = v11;
    *(_QWORD *)(a1 + 32) = v11;
    *(_QWORD *)(a1 + 40) = &v11[4 * v12];
    do
    {
      v13 = *(unsigned int **)v8;
      *v11 = *(_QWORD *)v8;
      if (v13)
      {
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 + 1, v13));
      }
      v15 = *(unsigned int **)(v8 + 8);
      v11[1] = v15;
      if (v15)
      {
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 + 1, v15));
      }
      *((_OWORD *)v11 + 1) = *(_OWORD *)(v8 + 16);
      v8 += 32;
      v11 += 4;
    }
    while (v8 != v9);
    *(_QWORD *)(a1 + 32) = v11;
  }
  v17 = *(unsigned int **)(a2 + 48);
  *(_QWORD *)(a1 + 48) = v17;
  if (v17)
  {
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 + 1, v17));
  }
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  v19 = *(_QWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 72) = v19;
  WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::Vector((_QWORD *)(a1 + 88), (_QWORD *)(a2 + 88));
  WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::Vector((_QWORD *)(a1 + 112), (_QWORD *)(a2 + 112));
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  v20 = *a3;
  if (v20)
  {
    v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
    if (*(_QWORD *)(a1 + 16) != (*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 56))(v21))
      goto LABEL_21;
    v22 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 32))(v20);
    if (v22)
    {
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 + 1, v22));
    }
    v24 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 48) = v22;
    if (v24)
      WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v24);
    v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 40))(v20);
    if (v20)
    {
LABEL_21:
      v25 = *(_QWORD *)(a1 + 24);
      v26 = MEMORY[0x1E0C809B0];
      do
      {
        v27 = *(_QWORD *)(a1 + 32);
        v32[0] = v26;
        v32[1] = 0x40000000;
        v33 = ___ZN2TI8Favonius14CMTouchHistoryC2EPKS1_N3WTF10PassRefPtrINS0_18GeometryHypothesisEEE_block_invoke;
        v34 = &__block_descriptor_tmp_15460;
        v35 = v20;
        if (v25 == v27)
          break;
        while ((((uint64_t (*)(_QWORD *, uint64_t))v33)(v32, v25) & 1) == 0)
        {
          v25 += 32;
          if (v25 == v27)
          {
            v25 = v27;
            break;
          }
        }
        if (v25 == *(_QWORD *)(a1 + 32))
          break;
        v28 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 32))(v20);
        if (v28)
        {
          do
            v29 = __ldaxr(v28);
          while (__stlxr(v29 + 1, v28));
        }
        v30 = *(_QWORD *)(v25 + 8);
        *(_QWORD *)(v25 + 8) = v28;
        if (v30)
          WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v30);
        v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 40))(v20);
      }
      while (v20);
    }
  }
  return a1;
}

BOOL ___ZN2TI8Favonius14CMTouchHistoryC2EPKS1_N3WTF10PassRefPtrINS0_18GeometryHypothesisEEE_block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
  return *a2 == (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
}

double TI::Favonius::CMTouchHistory::empty_history@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v3;
  double result;

  v3 = operator new();
  *(_DWORD *)(v3 + 8) = 1;
  *(_QWORD *)v3 = &off_1EA104628;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 56) = xmmword_1DA911110;
  *(_QWORD *)(v3 + 72) = 0x7F0000007FLL;
  *(_DWORD *)(v3 + 80) = 0;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_OWORD *)(v3 + 104) = 0u;
  *(_OWORD *)(v3 + 120) = 0u;
  *(_DWORD *)(v3 + 136) = 0;
  *(_QWORD *)(v3 + 140) = 0x7F0000007FLL;
  *(_DWORD *)(v3 + 148) = -8388608;
  *a1 = v3;
  return result;
}

double TI::Favonius::CMTouchHistory::CMTouchHistory(TI::Favonius::CMTouchHistory *this)
{
  double result;

  *((_DWORD *)this + 2) = 1;
  *(_QWORD *)this = &off_1EA104628;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  *(_OWORD *)((char *)this + 56) = xmmword_1DA911110;
  *((_QWORD *)this + 9) = 0x7F0000007FLL;
  *((_DWORD *)this + 20) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_DWORD *)this + 34) = 0;
  *(_QWORD *)((char *)this + 140) = 0x7F0000007FLL;
  *((_DWORD *)this + 37) = -8388608;
  return result;
}

{
  double result;

  *((_DWORD *)this + 2) = 1;
  *(_QWORD *)this = &off_1EA104628;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  *(_OWORD *)((char *)this + 56) = xmmword_1DA911110;
  *((_QWORD *)this + 9) = 0x7F0000007FLL;
  *((_DWORD *)this + 20) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_DWORD *)this + 34) = 0;
  *(_QWORD *)((char *)this + 140) = 0x7F0000007FLL;
  *((_DWORD *)this + 37) = -8388608;
  return result;
}

uint64_t TI::Favonius::CMTouchHistory::initialize_average_touch_interval(TI::Favonius::CMTouchHistory *this, double a2, const TI::Favonius::CMTouchHistory *a3)
{
  return (*(uint64_t (**)(TI::Favonius::CMTouchHistory *, const TI::Favonius::CMTouchHistory *))(*(_QWORD *)this + 56))(this, a3);
}

float TI::Favonius::CMTouchHistory::initialize_pruning_threshold(TI::Favonius::CMTouchHistory *this, const TI::Favonius::CMGeometryParametersForTouch *a2)
{
  float v2;
  float v3;
  float v4;

  v2 = *((float *)this + 2) * *((float *)this + 2);
  v3 = v2 * *(float *)this;
  v4 = v2 * 0.5 * *((float *)this + 1);
  return v3 + v4;
}

float TI::Favonius::CMTouchHistory::initialize_transposition_cost(TI::Favonius::CMTouchHistory *this, double a2)
{
  return a2 * -8.16326523 * a2 + -2.0;
}

float TI::Favonius::CMTouchHistory::initialize_insertion_cost(TI::Favonius::CMTouchHistory *this, double a2)
{
  double v2;

  v2 = 0.15;
  if (a2 >= 0.15)
  {
    v2 = 0.5;
    if (a2 <= 0.5)
      v2 = a2;
  }
  return v2 * -8.16326523 * v2 + -2.0;
}

float TI::Favonius::CMTouchHistory::initialize_deletion_cost(uint64_t a1, uint64_t a2, double a3, double a4)
{
  _BOOL4 is_repeated_tap_on_same_key;
  double v6;

  is_repeated_tap_on_same_key = TI::Favonius::CMTouchHistory::is_repeated_tap_on_same_key(a1, a2);
  v6 = a4 * -8.16326523 * a4 + -3.20000005 + -1.10524082;
  if (is_repeated_tap_on_same_key)
    return a4 * -8.16326523 * a4 + -2.24000001;
  return v6;
}

float TI::Favonius::CMTouchHistory::initialize_substitution_cost(TI::Favonius::CMTouchHistory *this, double a2)
{
  double v2;

  v2 = 0.15;
  if (a2 >= 0.15)
  {
    v2 = 0.5;
    if (a2 <= 0.5)
      v2 = a2;
  }
  return v2 * -8.16326523 * v2 + -3.20000005;
}

float TI::Favonius::CMTouchHistory::initialize_geometry_parameters_for_touch(uint64_t a1, double *a2, uint64_t a3)
{
  double v6;
  double v7;
  double v8;
  float v10;

  TI::Favonius::CMTouchHistory::initialize_touch_interval(a1, (uint64_t)a2);
  v7 = v6;
  if ((*(uint64_t (**)(double *))(*(_QWORD *)a2 + 56))(a2))
    v8 = a2[8] + (v7 - a2[8]) * 0.200000003;
  else
    v8 = 0.35;
  TI::Favonius::CMGeometryParametersForTouch::CMGeometryParametersForTouch(&v10, a3, a1, v8);
  return v10;
}

const char *TILanguageModelCacheStrategyAsString(unsigned int a1)
{
  if (a1 > 2)
    return "cache-strategy: unknown";
  else
    return off_1EA104728[a1];
}

void AppTrieLoaderImpl::~AppTrieLoaderImpl(AppTrieLoaderImpl *this)
{
  AppTrieLoaderImpl::~AppTrieLoaderImpl(this);
  JUMPOUT(0x1DF0A2144);
}

{
  NSObject *v2;
  void *v3;
  void *v4;
  const void *v5;
  std::__shared_weak_count *v6;
  uint8_t buf[4];
  void *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  TIPersonalizationAppNamesOSLogFacility();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Removing contact observer for app names"), "~AppTrieLoaderImpl");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    v8 = v3;
    _os_log_impl(&dword_1DA6F2000, v2, OS_LOG_TYPE_INFO, "%@", buf, 0xCu);

  }
  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "removeContactObserver:", *((_QWORD *)this + 6));

  v5 = (const void *)*((_QWORD *)this + 5);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 5) = 0;
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

uint64_t AppTrieLoaderImpl::handle@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 32);
  *a2 = *(_QWORD *)(this + 24);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

void AppTrieLoaderImpl::AppTrieLoaderImpl(AppTrieLoaderImpl *this)
{
  uint64_t View;
  _QWORD *v3;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1EA104790;
  View = LXLexiconRepositoryCreateView();
  v3 = operator new(0x20uLL);
  v3[1] = 0;
  v3[2] = 0;
  v3[3] = View;
  *v3 = &off_1EA1061A8;
  *((_QWORD *)this + 3) = v3 + 3;
  *((_QWORD *)this + 4) = v3;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
}

void std::__shared_ptr_emplace<KB::LexiconHandle>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1061A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::LexiconHandle>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1061A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

void std::__shared_ptr_emplace<KB::LexiconHandle>::__on_zero_shared(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)(a1 + 24) = 0;
}

id AppTrieLoaderImpl::app_name_loading_queue(AppTrieLoaderImpl *this)
{
  if (AppTrieLoaderImpl::app_name_loading_queue(void)::once_token != -1)
    dispatch_once(&AppTrieLoaderImpl::app_name_loading_queue(void)::once_token, &__block_literal_global_15495);
  return (id)AppTrieLoaderImpl::app_name_loading_queue(void)::queue;
}

void ___ZN17AppTrieLoaderImpl22app_name_loading_queueEv_block_invoke()
{
  dispatch_queue_t v0;
  void *v1;
  NSObject *v2;

  dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  v2 = objc_claimAutoreleasedReturnValue();
  v0 = dispatch_queue_create("com.apple.TextInput.appNameLoading", v2);
  v1 = (void *)AppTrieLoaderImpl::app_name_loading_queue(void)::queue;
  AppTrieLoaderImpl::app_name_loading_queue(void)::queue = (uint64_t)v0;

}

void AppTrieLoaderImpl::static_dictionary_for_filtering(AppTrieLoaderImpl *this@<X0>, const KB::String *a2@<X1>, const KB::String *a3@<X2>, uint64_t *a4@<X8>)
{
  char *v9;
  char *v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  const char *v15;
  void *v16;
  uint8_t buf[4];
  void *v18;
  _BYTE v19[8];
  void *v20;
  _BYTE v21[8];
  void *v22;
  _BYTE v23[8];
  void *v24;
  _BYTE v25[8];
  void *v26;
  _BYTE v27[8];
  void *v28;
  uint64_t v29;
  int v30;
  _BYTE v31[8];
  void *v32;
  _BYTE v33[8];
  void *v34;
  _BYTE v35[8];
  void *v36;
  int v37;
  __int16 v38;
  char v39;
  void *v40;
  char v41;
  int v42;
  __int16 v43;
  char v44;
  void *v45;
  char v46;
  uint64_t v47;
  int v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  KB::StaticDictionary::create(a4);
  v9 = (char *)*((_QWORD *)this + 1);
  if (!v9)
    v9 = (char *)this + 16;
  if (*(_WORD *)this)
    v10 = v9;
  else
    v10 = "";
  v11 = TILexiconIDForLocaleIdentifier(v10);
  KB::String::String((KB::String *)v31, this);
  KB::String::String((KB::String *)v33, a2);
  KB::String::String((KB::String *)v35, a3);
  v37 = 0x100000;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0x100000;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  LODWORD(v47) = v11;
  BYTE4(v47) = 0;
  v48 = 1065353216;
  v12 = *a4;
  KB::String::String((KB::String *)v19, (const KB::String *)v31);
  KB::String::String((KB::String *)v21, (const KB::String *)v33);
  KB::String::String((KB::String *)v23, (const KB::String *)v35);
  KB::String::String((KB::String *)v25, (const KB::String *)&v37);
  KB::String::String((KB::String *)v27, (const KB::String *)&v42);
  v29 = v47;
  v30 = v48;
  KB::StaticDictionary::load((const void ***)v12, (uint64_t)v19);
  if (v28 && v27[6] == 1)
    free(v28);
  if (v26 && v25[6] == 1)
    free(v26);
  if (v24 && v23[6] == 1)
    free(v24);
  if (v22 && v21[6] == 1)
    free(v22);
  if (v20 && v19[6] == 1)
    free(v20);
  if (*(_QWORD *)v12 == *(_QWORD *)(v12 + 8))
  {
    TIPersonalizationAppNamesOSLogFacility();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = (const char *)*((_QWORD *)a2 + 1);
      if (!v14)
        v14 = (char *)a2 + 16;
      if (*(_WORD *)a2)
        v15 = v14;
      else
        v15 = "";
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Failed to open app filtering dictionary at %s"), "static_dictionary_for_filtering", v15);
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      v18 = v16;
      _os_log_error_impl(&dword_1DA6F2000, v13, OS_LOG_TYPE_ERROR, "%@", buf, 0xCu);

    }
  }
  if (v45 && v44 == 1)
    free(v45);
  if (v40 && v39 == 1)
    free(v40);
  if (v36 && v35[6] == 1)
    free(v36);
  if (v34 && v33[6] == 1)
    free(v34);
  if (v32)
  {
    if (v31[6] == 1)
      free(v32);
  }
}

void AppTrieLoaderImpl::create_empty_transient_lexicon(AppTrieLoaderImpl *this@<X0>, uint64_t *a2@<X8>)
{
  __CFDictionary *Mutable;
  const void *v6;
  const void *v7;
  void *value[4];

  value[3] = *(void **)MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v6 = (const void *)*MEMORY[0x1E0D437B8];
  KB::cf_string_impl<KB::String>((CFStringRef *)value, (unsigned __int16 *)this);
  v7 = value[0];
  CFDictionaryAddValue(Mutable, v6, value[0]);
  if (v7)
    CFRelease(v7);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0D437C8], CFSTR("TextInput-AppNames"));
  *a2 = LXLexiconCreateTransient();
  if (Mutable)
    CFRelease(Mutable);
}

void AppTrieLoaderImpl::register_as_contact_observer(_QWORD *a1, const KB::String *a2, const KB::String *a3, const KB::String *a4)
{
  NSObject *v8;
  void *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_weak_owners;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  void *v18;
  unint64_t v19;
  uint64_t v20;
  void *v21;
  _QWORD v22[5];
  std::__shared_weak_count *v23;
  _BYTE v24[8];
  void *v25;
  _BYTE v26[8];
  void *v27;
  _BYTE v28[8];
  void *v29;
  uint8_t buf[4];
  void *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  TIPersonalizationAppNamesOSLogFacility();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Adding contact observer for app names"), "register_as_contact_observer");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    v31 = v9;
    _os_log_impl(&dword_1DA6F2000, v8, OS_LOG_TYPE_INFO, "%@", buf, 0xCu);

  }
  v10 = (std::__shared_weak_count *)a1[2];
  if (!v10 || (v11 = a1[1], (v12 = std::__shared_weak_count::lock(v10)) == 0))
    std::__throw_bad_weak_ptr[abi:nn180100]();
  v13 = v12;
  p_shared_weak_owners = (unint64_t *)&v12->__shared_weak_owners_;
  do
    v15 = __ldxr(p_shared_weak_owners);
  while (__stxr(v15 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v13);
  }
  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 3321888768;
  v22[2] = ___ZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1__block_invoke;
  v22[3] = &__block_descriptor_144_a8_32c42_ZTSNSt3__18weak_ptrI17AppTrieLoaderImplEE48c17_ZTSKN2KB6StringE80c17_ZTSKN2KB6StringE112c17_ZTSKN2KB6StringE_e22_v16__0__NSDictionary_8l;
  v22[4] = v11;
  v23 = v13;
  do
    v19 = __ldxr(p_shared_weak_owners);
  while (__stxr(v19 + 1, p_shared_weak_owners));
  KB::String::String((KB::String *)v24, a2);
  KB::String::String((KB::String *)v26, a3);
  KB::String::String((KB::String *)v28, a4);
  objc_msgSend(v18, "addContactObserver:", v22);
  v20 = objc_claimAutoreleasedReturnValue();
  v21 = (void *)a1[6];
  a1[6] = v20;

  if (v29 && v28[6] == 1)
    free(v29);
  if (v27 && v26[6] == 1)
    free(v27);
  if (v25 && v24[6] == 1)
    free(v25);
  if (v23)
    std::__shared_weak_count::__release_weak(v23);
  std::__shared_weak_count::__release_weak(v13);
}

void ___ZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1__block_invoke(_QWORD *a1, void *a2)
{
  id v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  const void *v8;
  NSObject *v9;
  void *v10;
  unint64_t *p_shared_weak_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  CFTypeRef v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  const void *v18;
  __int128 buf;
  CFTypeRef cf;
  _BYTE v21[8];
  void *v22;
  _BYTE v23[8];
  void *v24;
  _BYTE v25[8];
  void *v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(uint64_t);
  void *v30;
  __int128 v31;
  CFTypeRef v32;
  _BYTE v33[8];
  void *v34;
  _BYTE v35[8];
  void *v36;
  _BYTE v37[8];
  void *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = (std::__shared_weak_count *)a1[5];
  if (v4)
  {
    v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      v6 = v5;
      v7 = a1[4];
      if (v7)
      {
        AppTrieLoaderImpl::create_empty_transient_lexicon((AppTrieLoaderImpl *)(a1 + 6), (uint64_t *)&v18);
        v8 = v18;
        if (v18)
        {
          TIPersonalizationAppNamesOSLogFacility();
          v9 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Installing app lexicon on main thread"), "register_as_contact_observer_block_invoke");
            v10 = (void *)objc_claimAutoreleasedReturnValue();
            LODWORD(buf) = 138412290;
            *(_QWORD *)((char *)&buf + 4) = v10;
            _os_log_impl(&dword_1DA6F2000, v9, OS_LOG_TYPE_INFO, "%@", (uint8_t *)&buf, 0xCu);

          }
          v27 = MEMORY[0x1E0C809B0];
          v28 = 3321888768;
          v29 = ___ZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1__block_invoke_14;
          v30 = &__block_descriptor_152_a8_32c85_ZTSKZZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1_EUb_E3__0_e5_v8__0l;
          *(_QWORD *)&buf = v7;
          *((_QWORD *)&buf + 1) = v6;
          p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
          do
            v12 = __ldxr(p_shared_weak_owners);
          while (__stxr(v12 + 1, p_shared_weak_owners));
          CFRetain(v8);
          cf = v8;
          KB::String::String((KB::String *)v21, (const KB::String *)(a1 + 6));
          KB::String::String((KB::String *)v23, (const KB::String *)(a1 + 10));
          KB::String::String((KB::String *)v25, (const KB::String *)(a1 + 14));
          v31 = buf;
          if (*((_QWORD *)&buf + 1))
          {
            v13 = (unint64_t *)(*((_QWORD *)&buf + 1) + 16);
            do
              v14 = __ldxr(v13);
            while (__stxr(v14 + 1, v13));
          }
          v15 = cf;
          v32 = cf;
          if (cf)
          {
            CFRetain(cf);
            v32 = v15;
          }
          KB::String::String((KB::String *)v33, (const KB::String *)v21);
          KB::String::String((KB::String *)v35, (const KB::String *)v23);
          KB::String::String((KB::String *)v37, (const KB::String *)v25);
          TIDispatchAsync();
          if (v26 && v25[6] == 1)
            free(v26);
          if (v24 && v23[6] == 1)
            free(v24);
          if (v22 && v21[6] == 1)
            free(v22);
          if (cf)
            CFRelease(cf);
          cf = 0;
          if (*((_QWORD *)&buf + 1))
            std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&buf + 1));
          if (v38 && v37[6] == 1)
            free(v38);
          if (v36 && v35[6] == 1)
            free(v36);
          if (v34 && v33[6] == 1)
            free(v34);
          if (v32)
            CFRelease(v32);
          v32 = 0;
          if (*((_QWORD *)&v31 + 1))
            std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v31 + 1));
          CFRelease(v8);
        }
      }
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

}

KB::String *__copy_helper_block_a8_32c42_ZTSNSt3__18weak_ptrI17AppTrieLoaderImplEE48c17_ZTSKN2KB6StringE80c17_ZTSKN2KB6StringE112c17_ZTSKN2KB6StringE(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v4 = a2[5];
  a1[4] = a2[4];
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  KB::String::String((KB::String *)(a1 + 6), (const KB::String *)(a2 + 6));
  KB::String::String((KB::String *)(a1 + 10), (const KB::String *)(a2 + 10));
  return KB::String::String((KB::String *)(a1 + 14), (const KB::String *)(a2 + 14));
}

void __destroy_helper_block_a8_32c42_ZTSNSt3__18weak_ptrI17AppTrieLoaderImplEE48c17_ZTSKN2KB6StringE80c17_ZTSKN2KB6StringE112c17_ZTSKN2KB6StringE(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  std::__shared_weak_count *v5;

  v2 = *(void **)(a1 + 120);
  if (v2 && *(_BYTE *)(a1 + 118) == 1)
    free(v2);
  v3 = *(void **)(a1 + 88);
  if (v3 && *(_BYTE *)(a1 + 86) == 1)
    free(v3);
  v4 = *(void **)(a1 + 56);
  if (v4 && *(_BYTE *)(a1 + 54) == 1)
    free(v4);
  v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

void ___ZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1__block_invoke_14(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  const void *v6;
  void *v7;
  void *v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  const void *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  uint64_t v16;
  CFTypeRef cf;
  _BYTE v18[8];
  void *v19;
  _BYTE v20[8];
  void *v21;
  _BYTE v22[8];
  void *v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t);
  void *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  CFTypeRef v30;
  _BYTE v31[8];
  void *v32;
  _BYTE v33[8];
  void *v34;
  _BYTE v35[8];
  void *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        v6 = *(const void **)(a1 + 48);
        if (v6)
        {
          CFRetain(*(CFTypeRef *)(a1 + 48));
          LXLexiconRepositoryAddOrUpdate();
          KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(v5 + 40), v6);
          CFRelease(v6);
        }
        else
        {
          LXLexiconRepositoryAddOrUpdate();
          v7 = *(void **)(v5 + 40);
          if (v7)
          {
            CFRelease(v7);
            *(_QWORD *)(v5 + 40) = 0;
          }
        }
        AppTrieLoaderImpl::app_name_loading_queue((AppTrieLoaderImpl *)v7);
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        v24 = MEMORY[0x1E0C809B0];
        v25 = 3321888768;
        v26 = ___ZZZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1_EUb_ENK3__0clEv_block_invoke;
        v27 = &__block_descriptor_152_a8_32c98_ZTSKZZZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1_EUb_ENK3__0clEvEUlvE__e5_v8__0l;
        v16 = v5;
        p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
        do
          v10 = __ldxr(p_shared_weak_owners);
        while (__stxr(v10 + 1, p_shared_weak_owners));
        v11 = *(const void **)(a1 + 48);
        cf = v11;
        if (v11)
        {
          CFRetain(v11);
          cf = v11;
        }
        KB::String::String((KB::String *)v18, (const KB::String *)(a1 + 56));
        KB::String::String((KB::String *)v20, (const KB::String *)(a1 + 88));
        KB::String::String((KB::String *)v22, (const KB::String *)(a1 + 120));
        v28 = v16;
        v29 = v4;
        v12 = (unint64_t *)&v4->__shared_weak_owners_;
        do
          v13 = __ldxr(v12);
        while (__stxr(v13 + 1, v12));
        v30 = cf;
        if (cf)
        {
          CFRetain(cf);
          v30 = cf;
        }
        KB::String::String((KB::String *)v31, (const KB::String *)v18);
        KB::String::String((KB::String *)v33, (const KB::String *)v20);
        KB::String::String((KB::String *)v35, (const KB::String *)v22);
        TIDispatchAsync();
        if (v23 && v22[6] == 1)
          free(v23);
        if (v21 && v20[6] == 1)
          free(v21);
        if (v19 && v18[6] == 1)
          free(v19);
        if (cf)
          CFRelease(cf);
        std::__shared_weak_count::__release_weak(v4);

        if (v36 && v35[6] == 1)
          free(v36);
        if (v34 && v33[6] == 1)
          free(v34);
        if (v32 && v31[6] == 1)
          free(v32);
        if (v30)
          CFRelease(v30);
        v30 = 0;
        if (v29)
          std::__shared_weak_count::__release_weak(v29);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

KB::String *__copy_helper_block_a8_32c85_ZTSKZZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1_EUb_E3__0(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  const void *v7;

  v4 = a2[5];
  a1[4] = a2[4];
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (const void *)a2[6];
  a1[6] = v7;
  if (v7)
  {
    CFRetain(v7);
    a1[6] = v7;
  }
  KB::String::String((KB::String *)(a1 + 7), (const KB::String *)(a2 + 7));
  KB::String::String((KB::String *)(a1 + 11), (const KB::String *)(a2 + 11));
  return KB::String::String((KB::String *)(a1 + 15), (const KB::String *)(a2 + 15));
}

void __destroy_helper_block_a8_32c85_ZTSKZZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1_EUb_E3__0(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  const void *v5;
  std::__shared_weak_count *v6;

  v2 = *(void **)(a1 + 128);
  if (v2 && *(_BYTE *)(a1 + 126) == 1)
    free(v2);
  v3 = *(void **)(a1 + 96);
  if (v3 && *(_BYTE *)(a1 + 94) == 1)
    free(v3);
  v4 = *(void **)(a1 + 64);
  if (v4 && *(_BYTE *)(a1 + 62) == 1)
    free(v4);
  v5 = *(const void **)(a1 + 48);
  if (v5)
    CFRelease(v5);
  *(_QWORD *)(a1 + 48) = 0;
  v6 = *(std::__shared_weak_count **)(a1 + 40);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void ___ZZZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1_EUb_ENK3__0clEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  NSObject *v5;
  void *v6;
  const void *v7;
  const void ***v8;
  NSObject *v9;
  NSObject *v10;
  void *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  void *v14;
  const void ***v15;
  __int128 buf;
  void (*v17)(uint64_t, void *);
  void *v18;
  CFTypeRef cf;
  const void ***v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      if (*(_QWORD *)(a1 + 32))
      {
        TIPersonalizationAppNamesOSLogFacility();
        v5 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Adding app names to app lexicon"), "operator()");
          v6 = (void *)objc_claimAutoreleasedReturnValue();
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v6;
          _os_log_impl(&dword_1DA6F2000, v5, OS_LOG_TYPE_INFO, "%@", (uint8_t *)&buf, 0xCu);

        }
        AppTrieLoaderImpl::static_dictionary_for_filtering((AppTrieLoaderImpl *)(a1 + 56), (const KB::String *)(a1 + 88), (const KB::String *)(a1 + 120), (uint64_t *)&v15);
        v7 = *(const void **)(a1 + 48);
        if (v7)
          CFRetain(*(CFTypeRef *)(a1 + 48));
        v8 = v15;
        TIPersonalizationAppNamesOSLogFacility();
        v9 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Adding app names entries to dynamic trie and vocabulary"), "background_append_app_names");
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v14;
          _os_log_debug_impl(&dword_1DA6F2000, v9, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&buf, 0xCu);

        }
        *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
        *((_QWORD *)&buf + 1) = 3321888768;
        v17 = ___ZL27background_append_app_namesN2KB10retain_ptrIP10_LXLexiconEERKNS_16StaticDictionaryE_block_invoke;
        v18 = &__block_descriptor_48_a8_32c36_ZTSN2KB10retain_ptrIP10_LXLexiconEE_e22_v24__0__NSString_8_B16l;
        cf = v7;
        if (v7)
        {
          CFRetain(v7);
          cf = v7;
        }
        v20 = v8;
        +[TILaunchServicesLookup enumerateInstalledApplicationNames:](TILaunchServicesLookup, "enumerateInstalledApplicationNames:", &buf);
        if (cf)
          CFRelease(cf);
        if (v7)
          CFRelease(v7);
        TIPersonalizationAppNamesOSLogFacility();
        v10 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Done loading app names"), "operator()");
          v11 = (void *)objc_claimAutoreleasedReturnValue();
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v11;
          _os_log_impl(&dword_1DA6F2000, v10, OS_LOG_TYPE_INFO, "%@", (uint8_t *)&buf, 0xCu);

        }
        if (v8)
        {
          KB::StaticDictionary::~StaticDictionary(v8);
          MEMORY[0x1DF0A2144]();
        }
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

KB::String *__copy_helper_block_a8_32c98_ZTSKZZZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1_EUb_ENK3__0clEvEUlvE_(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  const void *v7;

  v4 = a2[5];
  a1[4] = a2[4];
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (const void *)a2[6];
  a1[6] = v7;
  if (v7)
  {
    CFRetain(v7);
    a1[6] = v7;
  }
  KB::String::String((KB::String *)(a1 + 7), (const KB::String *)(a2 + 7));
  KB::String::String((KB::String *)(a1 + 11), (const KB::String *)(a2 + 11));
  return KB::String::String((KB::String *)(a1 + 15), (const KB::String *)(a2 + 15));
}

void __destroy_helper_block_a8_32c98_ZTSKZZZN17AppTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1_EUb_ENK3__0clEvEUlvE_(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  const void *v5;
  std::__shared_weak_count *v6;

  v2 = *(void **)(a1 + 128);
  if (v2 && *(_BYTE *)(a1 + 126) == 1)
    free(v2);
  v3 = *(void **)(a1 + 96);
  if (v3 && *(_BYTE *)(a1 + 94) == 1)
    free(v3);
  v4 = *(void **)(a1 + 64);
  if (v4 && *(_BYTE *)(a1 + 62) == 1)
    free(v4);
  v5 = *(const void **)(a1 + 48);
  if (v5)
    CFRelease(v5);
  *(_QWORD *)(a1 + 48) = 0;
  v6 = *(std::__shared_weak_count **)(a1 + 40);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void ___ZL27background_append_app_namesN2KB10retain_ptrIP10_LXLexiconEERKNS_16StaticDictionaryE_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  KB::StaticDictionary *v5;
  __CFString *v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unsigned int v9;
  void **v10;
  void *v11;
  _QWORD v12[3];
  void **v13;
  unsigned __int16 v14[3];
  char v15;
  void *v16;
  uint8_t buf[4];
  _BYTE v18[12];
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  TIPersonalizationAppNamesOSLogFacility();
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s AppName=%@"), "background_append_app_names_block_invoke", v3);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)v18 = v11;
    _os_log_debug_impl(&dword_1DA6F2000, v4, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);

  }
  v5 = *(KB::StaticDictionary **)(a1 + 40);
  v6 = (__CFString *)v3;
  if (-[__CFString length](v6, "length"))
  {
    *(_WORD *)v18 = 0;
    v18[2] = 0;
    *(_QWORD *)&v18[4] = " ,:;";
    *(_DWORD *)buf = 1048580;
    v19 = 0;
    KB::utf8_string(v6, (uint64_t)v14);
    KB::sbs_string_tokenize(v14, (const KB::String *)buf, v12);
    v7 = (unsigned __int16 *)v12[0];
    v8 = (unsigned __int16 *)v12[1];
    while (v7 != v8)
    {
      v9 = v7[2];
      if (!v7[2])
      {
        KB::String::compute_length(v7);
        v9 = v7[2];
      }
      if (v9 >= 3 && !KB::StaticDictionary::contains(v5, (const KB::String *)v7, 2, 0.0))
      {
        KB::cf_string_impl<KB::String>((CFStringRef *)&v13, v7);
        v10 = v13;
        if (LXLexiconAdd())
          LXLexiconIncrementUsageCount();
        if (v10)
          CFRelease(v10);
      }
      v7 += 16;
    }
    v13 = (void **)v12;
    std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v13);
    if (v16 && v15 == 1)
      free(v16);
    if (*(_QWORD *)&v18[4] && v18[2] == 1)
      free(*(void **)&v18[4]);
  }

}

_QWORD *__copy_helper_block_a8_32c36_ZTSN2KB10retain_ptrIP10_LXLexiconEE(_QWORD *result, uint64_t a2)
{
  const void *v2;
  _QWORD *v3;

  v2 = *(const void **)(a2 + 32);
  result[4] = v2;
  if (v2)
  {
    v3 = result;
    result = CFRetain(v2);
    v3[4] = v2;
  }
  return result;
}

void __destroy_helper_block_a8_32c36_ZTSN2KB10retain_ptrIP10_LXLexiconEE(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)(a1 + 32) = 0;
}

const void **AppTrieLoaderImpl::set_lexicon(uint64_t a1, CFTypeRef *a2)
{
  LXLexiconRepositoryAddOrUpdate();
  return KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(a1 + 40), *a2);
}

__n128 KB::AppTrieLoader::create@<Q0>(__n128 *a1@<X8>)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  __n128 result;

  v3 = (_QWORD *)operator new();
  *v3 = &off_1EA104898;
  v4 = operator new(0x20uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_1EA1061A8;
  v3[2] = v4;
  v4[3] = 0;
  v3[1] = v4 + 3;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1EA1048C0;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v3;
  result.n128_u64[0] = (unint64_t)v3;
  result.n128_u64[1] = (unint64_t)v5;
  *a1 = result;
  return result;
}

void std::__shared_ptr_pointer<AppTrieLoaderStub *,std::shared_ptr<AppTrieLoaderStub>::__shared_ptr_default_delete<AppTrieLoaderStub,AppTrieLoaderStub>,std::allocator<AppTrieLoaderStub>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_pointer<AppTrieLoaderStub *,std::shared_ptr<AppTrieLoaderStub>::__shared_ptr_default_delete<AppTrieLoaderStub,AppTrieLoaderStub>,std::allocator<AppTrieLoaderStub>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](v1 + 8);
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

void AppTrieLoaderStub::~AppTrieLoaderStub(AppTrieLoaderStub *this)
{
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

{
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  JUMPOUT(0x1DF0A2144);
}

uint64_t AppTrieLoaderStub::handle@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 16);
  *a2 = *(_QWORD *)(this + 8);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

__n128 KB::AppTrieLoader::create@<Q0>(const KB::String *a1@<X0>, const KB::String *a2@<X1>, const KB::String *a3@<X2>, __n128 *a4@<X8>)
{
  AppTrieLoaderImpl *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v11;
  unint64_t v12;
  unint64_t *p_shared_weak_owners;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  __n128 result;
  _BYTE v20[8];
  void *v21;
  _BYTE v22[8];
  void *v23;
  _BYTE v24[8];
  void *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v8 = (AppTrieLoaderImpl *)operator new();
  AppTrieLoaderImpl::AppTrieLoaderImpl(v8);
  v9 = (std::__shared_weak_count *)operator new();
  v9->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1048F8;
  v9->__shared_weak_owners_ = 0;
  v9[1].__vftable = (std::__shared_weak_count_vtbl *)v8;
  v11 = (std::__shared_weak_count *)*((_QWORD *)v8 + 2);
  if (v11)
  {
    if (v11->__shared_owners_ != -1)
      goto LABEL_14;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v14 = __ldxr(p_shared_weak_owners);
    while (__stxr(v14 + 1, p_shared_weak_owners));
    *((_QWORD *)v8 + 1) = v8;
    *((_QWORD *)v8 + 2) = v9;
    std::__shared_weak_count::__release_weak(v11);
  }
  else
  {
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    v16 = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    *((_QWORD *)v8 + 1) = v8;
    *((_QWORD *)v8 + 2) = v9;
  }
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_14:
  KB::String::String((KB::String *)v24, a1);
  KB::String::String((KB::String *)v22, a2);
  KB::String::String((KB::String *)v20, a3);
  AppTrieLoaderImpl::register_as_contact_observer(v8, (const KB::String *)v24, (const KB::String *)v22, (const KB::String *)v20);
  if (v21 && v20[6] == 1)
    free(v21);
  if (v23 && v22[6] == 1)
    free(v23);
  if (v25 && v24[6] == 1)
    free(v25);
  result.n128_u64[0] = (unint64_t)v8;
  result.n128_u64[1] = (unint64_t)v9;
  *a4 = result;
  return result;
}

void std::__shared_ptr_pointer<AppTrieLoaderImpl *,std::shared_ptr<AppTrieLoaderImpl>::__shared_ptr_default_delete<AppTrieLoaderImpl,AppTrieLoaderImpl>,std::allocator<AppTrieLoaderImpl>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

AppTrieLoaderImpl *std::__shared_ptr_pointer<AppTrieLoaderImpl *,std::shared_ptr<AppTrieLoaderImpl>::__shared_ptr_default_delete<AppTrieLoaderImpl,AppTrieLoaderImpl>,std::allocator<AppTrieLoaderImpl>>::__on_zero_shared(uint64_t a1)
{
  AppTrieLoaderImpl *result;

  result = *(AppTrieLoaderImpl **)(a1 + 24);
  if (result)
  {
    AppTrieLoaderImpl::~AppTrieLoaderImpl(result);
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

uint64_t KB::TIAssetPathRegistry::createPathForMatchingFile()
{
  uint64_t v0;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t);
  void (*v6)(uint64_t);
  CFTypeRef cf;

  v2 = 0;
  v3 = &v2;
  v4 = 0x3002000000;
  v5 = __Block_byref_object_copy__15530;
  v6 = __Block_byref_object_dispose__15531;
  cf = 0;
  LDEnumerateAssetDataItems();
  v0 = v3[5];
  v3[5] = 0;
  _Block_object_dispose(&v2, 8);
  if (cf)
    CFRelease(cf);
  return v0;
}

uint64_t __Block_byref_object_copy__15530(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(result + 40) = v2;
  return result;
}

void __Block_byref_object_dispose__15531(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 40);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)(a1 + 40) = 0;
}

void ___ZN2KB19TIAssetPathRegistry25createPathForMatchingFileEPK10__CFLocaleRKNSt3__18functionIFbPK7__CFURLPK10__CFStringEEE_block_invoke(uint64_t a1, const __CFURL *a2, uint64_t a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v11;
  CFStringRef v12;
  const void *v13;
  uint64_t v14;
  const __CFURL *v15;

  v7 = *(_QWORD *)(a1 + 40);
  v14 = a5;
  v15 = a2;
  v8 = *(_QWORD *)(v7 + 24);
  if (v8)
  {
    if ((*(unsigned int (**)(uint64_t, const __CFURL **, uint64_t *))(*(_QWORD *)v8 + 48))(v8, &v15, &v14))
    {
      v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v12 = CFURLCopyFileSystemPath(a2, kCFURLPOSIXPathStyle);
      v13 = *(const void **)(v11 + 40);
      if (v13)
        CFRelease(v13);
      *(_QWORD *)(v11 + 40) = v12;
      *a6 = 1;
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    KB::TIAssetPathRegistry::createPathsForMatchingBundles();
  }
}

CFMutableArrayRef KB::TIAssetPathRegistry::createPathsForMatchingBundles()
{
  CFMutableArrayRef Mutable;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  LDEnumerateAssetDataItems();
  return Mutable;
}

void ___ZN2KB19TIAssetPathRegistry29createPathsForMatchingBundlesEPK10__CFLocaleRKNSt3__18functionIFbPK7__CFURLPK10__CFString17LDAssetBundleTypeEEEb_block_invoke(uint64_t a1, const __CFURL *a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  CFStringRef v9;
  _QWORD *v10;
  int v11;
  uint64_t v12;
  const __CFURL *v13;

  v6 = *(_QWORD *)(a1 + 32);
  v12 = a5;
  v13 = a2;
  v11 = a3;
  v7 = *(_QWORD *)(v6 + 24);
  if (v7)
  {
    if ((*(unsigned int (**)(uint64_t, const __CFURL **, uint64_t *, int *))(*(_QWORD *)v7 + 48))(v7, &v13, &v12, &v11))
    {
      v9 = CFURLCopyFileSystemPath(a2, kCFURLPOSIXPathStyle);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v9);
      if (v9)
        CFRelease(v9);
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    KB::TIAssetPathRegistry::unigramLexiconPredicate(v10);
  }
}

void KB::TIAssetPathRegistry::unigramLexiconPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104978;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::unigramLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::unigramLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::unigramLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::unigramLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104978;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::unigramLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::unigramLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104978;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::unigramLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::unigramLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::operator()(uint64_t a1, KB **a2, CFStringRef *a3)
{
  KB *v3;
  const __CFString *v4;
  const __CFString *v5;

  v3 = *a2;
  return CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43860], 0) == kCFCompareEqualTo
      && KB::fileNameMatches(v3, CFSTR("Unigrams"), v4, v5);
}

BOOL KB::fileNameMatches(KB *this, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  const __CFString *PathComponent;
  _BOOL8 v7;
  const __CFString *v8;

  PathComponent = CFURLCopyLastPathComponent(this);
  if ((unint64_t)CFStringFind(PathComponent, a2, 0).location)
  {
    v7 = 0;
  }
  else
  {
    v8 = CFURLCopyPathExtension(this);
    v7 = CFStringCompare(CFSTR("dat"), v8, 0) == kCFCompareEqualTo;
    if (v8)
      CFRelease(v8);
  }
  if (PathComponent)
    CFRelease(PathComponent);
  return v7;
}

void KB::TIAssetPathRegistry::TransliterationLexiconPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA1049C0;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::TransliterationLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::TransliterationLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::TransliterationLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::TransliterationLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA1049C0;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::TransliterationLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::TransliterationLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA1049C0;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::TransliterationLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::TransliterationLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::operator()(uint64_t a1, uint64_t a2, CFStringRef *a3)
{
  return CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D438A0], 0) == kCFCompareEqualTo;
}

void KB::TIAssetPathRegistry::siriUnigramLexiconPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104A08;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::siriUnigramLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriUnigramLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::siriUnigramLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriUnigramLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104A08;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::siriUnigramLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriUnigramLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104A08;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::siriUnigramLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriUnigramLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::operator()(uint64_t a1, KB **a2, CFStringRef *a3)
{
  KB *v3;
  const __CFString *v4;
  const __CFString *v5;

  v3 = *a2;
  return CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43890], 0) == kCFCompareEqualTo
      && KB::fileNameMatches(v3, CFSTR("Siri-Unigrams"), v4, v5);
}

void KB::TIAssetPathRegistry::phraseLexiconPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104A50;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::phraseLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::phraseLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::phraseLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::phraseLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104A50;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::phraseLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::phraseLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104A50;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::phraseLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::phraseLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::operator()(uint64_t a1, KB **a2, CFStringRef *a3)
{
  KB *v3;
  const __CFString *v4;
  const __CFString *v5;

  v3 = *a2;
  return CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43860], 0) == kCFCompareEqualTo
      && KB::fileNameMatches(v3, CFSTR("Phrases"), v4, v5);
}

void KB::TIAssetPathRegistry::siriPhraseLexiconPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104A98;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::siriPhraseLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriPhraseLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::siriPhraseLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriPhraseLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104A98;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::siriPhraseLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriPhraseLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104A98;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::siriPhraseLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriPhraseLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::operator()(uint64_t a1, KB **a2, CFStringRef *a3)
{
  KB *v3;
  const __CFString *v4;
  const __CFString *v5;

  v3 = *a2;
  return CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43890], 0) == kCFCompareEqualTo
      && KB::fileNameMatches(v3, CFSTR("Siri-Phrases"), v4, v5);
}

void KB::TIAssetPathRegistry::deltaLexiconPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104AE0;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::deltaLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::deltaLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::deltaLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::deltaLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104AE0;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::deltaLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::deltaLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104AE0;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::deltaLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::deltaLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::operator()(uint64_t a1, KB **a2, CFStringRef *a3)
{
  KB *v3;
  const __CFString *v4;
  const __CFString *v5;

  v3 = *a2;
  return CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43840], 0) == kCFCompareEqualTo
      && KB::fileNameMatches(v3, CFSTR("Delta"), v4, v5);
}

void KB::TIAssetPathRegistry::siriDeltaLexiconPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104B28;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::siriDeltaLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriDeltaLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::siriDeltaLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriDeltaLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104B28;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::siriDeltaLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriDeltaLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104B28;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::siriDeltaLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriDeltaLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::operator()(uint64_t a1, KB **a2, CFStringRef *a3)
{
  KB *v3;
  const __CFString *v4;
  const __CFString *v5;

  v3 = *a2;
  return CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43898], 0) == kCFCompareEqualTo
      && KB::fileNameMatches(v3, CFSTR("Siri-Delta"), v4, v5);
}

void KB::TIAssetPathRegistry::morphemeLexiconPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104B70;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::morphemeLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::morphemeLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::morphemeLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::morphemeLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104B70;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::morphemeLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::morphemeLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104B70;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::morphemeLexiconPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::morphemeLexiconPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*)>::operator()(uint64_t a1, const __CFURL **a2, CFStringRef *a3)
{
  const __CFURL *v3;
  const __CFURL *v5;
  int IsReachable;
  CFErrorRef error;

  v3 = *a2;
  if (CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43868], 0))
    return 0;
  v5 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v3, CFSTR("morpheme.dat"), 0);
  error = 0;
  IsReachable = CFURLResourceIsReachable(v5, &error);
  if (error)
    CFRelease(error);
  if (v5)
    CFRelease(v5);
  return IsReachable != 0;
}

void KB::TIAssetPathRegistry::requiredAssetLanguageModelPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104BB8;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::requiredAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::requiredAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::requiredAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::requiredAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104BB8;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::requiredAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::requiredAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104BB8;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::requiredAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::requiredAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::operator()(uint64_t a1, uint64_t a2, CFStringRef *a3, int *a4)
{
  const __CFString *v4;
  int v5;

  v4 = *a3;
  v5 = *a4;
  return (CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43850], 0) == kCFCompareEqualTo
       || CFStringCompare(v4, (CFStringRef)*MEMORY[0x1E0D43870], 0) == kCFCompareEqualTo)
      && v5 == 0;
}

void KB::TIAssetPathRegistry::siriRequiredAssetLanguageModelPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104C00;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::siriRequiredAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriRequiredAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::siriRequiredAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriRequiredAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104C00;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::siriRequiredAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriRequiredAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104C00;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::siriRequiredAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriRequiredAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::operator()(uint64_t a1, uint64_t a2, CFStringRef *a3, int *a4)
{
  int v4;
  CFComparisonResult v5;

  v4 = *a4;
  v5 = CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43888], 0);
  return !v4 && v5 == kCFCompareEqualTo;
}

void KB::TIAssetPathRegistry::mobileAssetLanguageModelPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104C48;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::mobileAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::mobileAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::mobileAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::mobileAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104C48;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::mobileAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::mobileAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104C48;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::mobileAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::mobileAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::operator()(uint64_t a1, uint64_t a2, CFStringRef *a3, int *a4)
{
  const __CFString *v4;
  int v5;

  v4 = *a3;
  v5 = *a4;
  return (CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43850], 0) == kCFCompareEqualTo
       || CFStringCompare(v4, (CFStringRef)*MEMORY[0x1E0D43870], 0) == kCFCompareEqualTo)
      && v5 != 0;
}

void KB::TIAssetPathRegistry::siriMobileAssetLanguageModelPredicate(_QWORD *a1@<X8>)
{
  *a1 = &off_1EA104C90;
  a1[3] = a1;
}

void std::__function::__func<KB::TIAssetPathRegistry::siriMobileAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriMobileAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::TIAssetPathRegistry::siriMobileAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriMobileAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA104C90;
  return result;
}

void std::__function::__func<KB::TIAssetPathRegistry::siriMobileAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriMobileAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA104C90;
}

BOOL std::__function::__func<KB::TIAssetPathRegistry::siriMobileAssetLanguageModelPredicate(void)::$_0,std::allocator<KB::TIAssetPathRegistry::siriMobileAssetLanguageModelPredicate(void)::$_0>,BOOL ()(__CFURL const*,__CFString const*,LDAssetBundleType)>::operator()(uint64_t a1, uint64_t a2, CFStringRef *a3, int *a4)
{
  int v4;
  CFComparisonResult v5;

  v4 = *a4;
  v5 = CFStringCompare(*a3, (CFStringRef)*MEMORY[0x1E0D43888], 0);
  return v4 && v5 == kCFCompareEqualTo;
}

__n128 __Block_byref_object_copy__15698(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__15699(uint64_t a1)
{
  return std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t __Block_byref_object_copy__99(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__100(uint64_t a1)
{

}

void TI::Favonius::CMGeometryHypothesis::~CMGeometryHypothesis(TI::Favonius::CMGeometryHypothesis *this)
{
  TI::Favonius::CMGeometryHypothesis::~CMGeometryHypothesis(this);
  JUMPOUT(0x1DF0A2144);
}

{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *(_QWORD *)this = &off_1EA104E00;
  v2 = (unsigned int *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2 + 2;
    v4 = atomic_load(v2 + 2);
    if (v4 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
    else
    {
      do
        v5 = __ldaxr(v3);
      while (__stlxr(v5 - 1, v3));
    }
  }
  v6 = (unsigned int *)*((_QWORD *)this + 2);
  if (v6)
  {
    v7 = v6 + 2;
    v8 = atomic_load(v6 + 2);
    if (v8 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
    else
    {
      do
        v9 = __ldaxr(v7);
      while (__stlxr(v9 - 1, v7));
    }
  }
}

float TI::Favonius::CMGeometryHypothesis::log_likelihood(TI::Favonius::CMGeometryHypothesis *this)
{
  return 0.0;
}

uint64_t TI::Favonius::CMGeometryHypothesis::touch_history(TI::Favonius::CMGeometryHypothesis *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t TI::Favonius::CMGeometryHypothesis::matched_key(TI::Favonius::CMGeometryHypothesis *this)
{
  return 0;
}

uint64_t TI::Favonius::CMGeometryHypothesis::parent_hypothesis(TI::Favonius::CMGeometryHypothesis *this)
{
  return *((_QWORD *)this + 2);
}

unsigned int *TI::Favonius::CMGeometryHypothesis::extension_with_matched_key@<X0>(unsigned int *a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  unsigned int *result;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;

  v8 = operator new();
  v9 = *a2;
  *a2 = 0;
  v10 = *a3;
  *a3 = 0;
  v15 = v10;
  v16 = v9;
  *a4 = TI::Favonius::CMMatchedKeyHypothesis::CMMatchedKeyHypothesis(v8, a1, (uint64_t *)&v16, &v15);
  if (v15)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v15);
  result = v16;
  if (v16)
  {
    v12 = v16 + 2;
    v13 = atomic_load(v16 + 2);
    if (v13 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v16 + 8))();
    }
    else
    {
      do
        v14 = __ldaxr(v12);
      while (__stlxr(v14 - 1, v12));
    }
  }
  return result;
}

unsigned int *TI::Favonius::CMGeometryHypothesis::extension_with_transposed_key@<X0>(unsigned int *a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  unsigned int *v9;
  uint64_t v10;
  unsigned int *result;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;

  v8 = (_QWORD *)operator new();
  v9 = *a2;
  *a2 = 0;
  v10 = *a3;
  *a3 = 0;
  v15 = v10;
  v16 = v9;
  *a4 = TI::Favonius::CMTranspositionHypothesis::CMTranspositionHypothesis(v8, a1, &v16, &v15);
  if (v15)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v15);
  result = v16;
  if (v16)
  {
    v12 = v16 + 2;
    v13 = atomic_load(v16 + 2);
    if (v13 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v16 + 8))();
    }
    else
    {
      do
        v14 = __ldaxr(v12);
      while (__stlxr(v14 - 1, v12));
    }
  }
  return result;
}

uint64_t TI::Favonius::CMGeometryHypothesis::extension_with_arbitrary_key_substitution@<X0>(unsigned int *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t result;

  v8 = operator new();
  v9 = (_QWORD *)v8;
  v10 = *a2;
  *a2 = 0;
  v11 = *a3;
  *a3 = 0;
  *(_DWORD *)(v8 + 8) = 1;
  *(_QWORD *)v8 = &off_1EA104E00;
  *(_QWORD *)(v8 + 16) = a1;
  if (a1)
  {
    v12 = a1 + 2;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
  }
  *(_QWORD *)(v8 + 24) = v10;
  result = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)a1 + 104))(a1);
  if ((result & 1) == 0)
    a1 = (unsigned int *)*((_QWORD *)a1 + 4);
  v9[4] = a1;
  *v9 = &off_1EA104F80;
  *a4 = v9;
  if (v11)
    return WTF::RefCounted<TI::Favonius::Key>::deref(v11);
  return result;
}

uint64_t TI::Favonius::CMGeometryHypothesis::extension_with_unmatched_key@<X0>(unsigned int *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;

  v8 = operator new();
  v9 = *a2;
  *a2 = 0;
  result = TI::Favonius::CMUnmatchedKeyHypothesis::CMUnmatchedKeyHypothesis(v8, a1, v10, a3);
  *a4 = result;
  if (v9)
    return WTF::RefCounted<TI::Favonius::Key>::deref(v9);
  return result;
}

unsigned int *TI::Favonius::CMGeometryHypothesis::extension_with_unmatched_touch@<X0>(unsigned int *a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  unsigned int *v7;
  unsigned int *result;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;

  v6 = operator new();
  v7 = *a2;
  *a2 = 0;
  v12 = v7;
  *a3 = TI::Favonius::CMUnmatchedTouchHypothesis::CMUnmatchedTouchHypothesis(v6, a1, (uint64_t *)&v12);
  result = v12;
  if (v12)
  {
    v9 = v12 + 2;
    v10 = atomic_load(v12 + 2);
    if (v10 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v12 + 8))();
    }
    else
    {
      do
        v11 = __ldaxr(v9);
      while (__stlxr(v11 - 1, v9));
    }
  }
  return result;
}

void TI::Favonius::CMGeometryHypothesis::get_key_touch_alignment(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v5;
  unint64_t v6;
  int *v7;
  _DWORD *v8;
  int v9;
  int *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  unint64_t v15;
  uint64_t v16;
  int *v17;
  unint64_t v18;
  int v19;

  v5 = *(_QWORD *)(a1 + 16);
  if (v5)
  {
    (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)v5 + 88))(v5, a2, a3);
    v7 = *(int **)(a2 + 8);
    v6 = *(_QWORD *)(a2 + 16);
    if ((unint64_t)v7 >= v6)
    {
      v10 = *(int **)a2;
      v11 = ((uint64_t)v7 - *(_QWORD *)a2) >> 2;
      v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 62)
        abort();
      v13 = v6 - (_QWORD)v10;
      if (v13 >> 1 > v12)
        v12 = v13 >> 1;
      v14 = (unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL;
      v15 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v14)
        v15 = v12;
      if (v15)
      {
        v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v15);
        v10 = *(int **)a2;
        v7 = *(int **)(a2 + 8);
      }
      else
      {
        v16 = 0;
      }
      v17 = (int *)(v15 + 4 * v11);
      v18 = v15 + 4 * v16;
      *v17 = *a3;
      v8 = v17 + 1;
      while (v7 != v10)
      {
        v19 = *--v7;
        *--v17 = v19;
      }
      *(_QWORD *)a2 = v17;
      *(_QWORD *)(a2 + 8) = v8;
      *(_QWORD *)(a2 + 16) = v18;
      if (v10)
        operator delete(v10);
    }
    else
    {
      *v7 = *a3;
      v8 = v7 + 1;
    }
    *(_QWORD *)(a2 + 8) = v8;
    v9 = *a3 + 1;
  }
  else
  {
    v9 = 0;
    *(_QWORD *)(a2 + 8) = *(_QWORD *)a2;
  }
  *a3 = v9;
}

uint64_t TI::Favonius::CMGeometryHypothesis::instance_error_correction_type(TI::Favonius::CMGeometryHypothesis *this)
{
  return 0;
}

uint64_t TI::Favonius::CMGeometryHypothesis::is_key_match(TI::Favonius::CMGeometryHypothesis *this)
{
  return 0;
}

uint64_t TI::Favonius::CMUnmatchedTouchHypothesis::CMUnmatchedTouchHypothesis(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  char v8;
  unsigned int *v9;
  float v10;

  v5 = *a3;
  *a3 = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &off_1EA104E00;
  *(_QWORD *)(a1 + 16) = a2;
  if (a2)
  {
    v6 = a2 + 2;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
  }
  *(_QWORD *)(a1 + 24) = v5;
  v8 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)a2 + 104))(a2);
  v9 = a2;
  if ((v8 & 1) == 0)
    v9 = (unsigned int *)*((_QWORD *)a2 + 4);
  *(_QWORD *)(a1 + 32) = v9;
  *(_QWORD *)a1 = &off_1EA105080;
  v10 = (*(float (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24));
  *(float *)(a1 + 40) = v10 + (*(float (**)(unsigned int *))(*(_QWORD *)a2 + 16))(a2);
  return a1;
}

void TI::Favonius::CMUnmatchedTouchHypothesis::~CMUnmatchedTouchHypothesis(TI::Favonius::CMUnmatchedTouchHypothesis *this)
{
  TI::Favonius::CMGeometryHypothesis::~CMGeometryHypothesis(this);
  JUMPOUT(0x1DF0A2144);
}

float TI::Favonius::CMUnmatchedTouchHypothesis::log_likelihood(TI::Favonius::CMUnmatchedTouchHypothesis *this)
{
  return *((float *)this + 10);
}

uint64_t TI::Favonius::CMUnmatchedTouchHypothesis::get_key_touch_alignment(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t result;

  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  result = (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))(*(_QWORD *)v5 + 88))(v5, a2, a3);
  ++*a3;
  return result;
}

uint64_t TI::Favonius::CMUnmatchedTouchHypothesis::instance_error_correction_type(TI::Favonius::CMUnmatchedTouchHypothesis *this)
{
  return 8;
}

uint64_t TI::Favonius::CMUnmatchedKeyHypothesis::CMUnmatchedKeyHypothesis(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  char v12;
  unsigned int *v13;
  float v14;

  v7 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)a2 + 24))(a2);
  if (v7)
  {
    v8 = (unsigned int *)(v7 + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
  }
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &off_1EA104E00;
  *(_QWORD *)(a1 + 16) = a2;
  v10 = a2 + 2;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  *(_QWORD *)(a1 + 24) = v7;
  v12 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)a2 + 104))(a2);
  v13 = a2;
  if ((v12 & 1) == 0)
    v13 = (unsigned int *)*((_QWORD *)a2 + 4);
  *(_QWORD *)(a1 + 32) = v13;
  *(_QWORD *)a1 = &off_1EA105000;
  v14 = (*(float (**)(uint64_t))(*(_QWORD *)a4 + 32))(a4);
  *(float *)(a1 + 40) = v14 + (*(float (**)(unsigned int *))(*(_QWORD *)a2 + 16))(a2);
  return a1;
}

void TI::Favonius::CMUnmatchedKeyHypothesis::~CMUnmatchedKeyHypothesis(TI::Favonius::CMUnmatchedKeyHypothesis *this)
{
  TI::Favonius::CMGeometryHypothesis::~CMGeometryHypothesis(this);
  JUMPOUT(0x1DF0A2144);
}

float TI::Favonius::CMUnmatchedKeyHypothesis::log_likelihood(TI::Favonius::CMUnmatchedKeyHypothesis *this)
{
  return *((float *)this + 10);
}

void TI::Favonius::CMUnmatchedKeyHypothesis::get_key_touch_alignment(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  _DWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  unint64_t v17;
  int v18;

  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 88))(v5, a2, a3);
  v7 = *(_DWORD **)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  if ((unint64_t)v7 >= v6)
  {
    v9 = *(_DWORD **)a2;
    v10 = ((uint64_t)v7 - *(_QWORD *)a2) >> 2;
    v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 62)
      abort();
    v12 = v6 - (_QWORD)v9;
    if (v12 >> 1 > v11)
      v11 = v12 >> 1;
    v13 = (unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL;
    v14 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v13)
      v14 = v11;
    if (v14)
    {
      v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v14);
      v9 = *(_DWORD **)a2;
      v7 = *(_DWORD **)(a2 + 8);
    }
    else
    {
      v15 = 0;
    }
    v16 = (_DWORD *)(v14 + 4 * v10);
    v17 = v14 + 4 * v15;
    *v16 = -1;
    v8 = v16 + 1;
    while (v7 != v9)
    {
      v18 = *--v7;
      *--v16 = v18;
    }
    *(_QWORD *)a2 = v16;
    *(_QWORD *)(a2 + 8) = v8;
    *(_QWORD *)(a2 + 16) = v17;
    if (v9)
      operator delete(v9);
  }
  else
  {
    *v7 = -1;
    v8 = v7 + 1;
  }
  *(_QWORD *)(a2 + 8) = v8;
}

uint64_t TI::Favonius::CMUnmatchedKeyHypothesis::instance_error_correction_type(TI::Favonius::CMUnmatchedKeyHypothesis *this)
{
  return 4;
}

void TI::Favonius::CMSubstitutionHypothesis::~CMSubstitutionHypothesis(TI::Favonius::CMSubstitutionHypothesis *this)
{
  TI::Favonius::CMGeometryHypothesis::~CMGeometryHypothesis(this);
  JUMPOUT(0x1DF0A2144);
}

float TI::Favonius::CMSubstitutionHypothesis::log_likelihood(TI::Favonius::CMSubstitutionHypothesis *this)
{
  uint64_t v2;
  float v3;
  uint64_t v4;

  v2 = (*(uint64_t (**)(TI::Favonius::CMSubstitutionHypothesis *))(*(_QWORD *)this + 24))(this);
  v3 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v4 = (*(uint64_t (**)(TI::Favonius::CMSubstitutionHypothesis *))(*(_QWORD *)this + 40))(this);
  return v3 + (*(float (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
}

uint64_t TI::Favonius::CMSubstitutionHypothesis::instance_error_correction_type(TI::Favonius::CMSubstitutionHypothesis *this)
{
  return 32;
}

_QWORD *TI::Favonius::CMTranspositionHypothesis::CMTranspositionHypothesis(_QWORD *a1, unsigned int *a2, unsigned int **a3, uint64_t *a4)
{
  unsigned int *v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v11;
  unsigned int *v12;

  v5 = *a3;
  *a3 = 0;
  v6 = *a4;
  *a4 = 0;
  v11 = v6;
  v12 = v5;
  TI::Favonius::CMMatchedKeyHypothesis::CMMatchedKeyHypothesis((uint64_t)a1, a2, (uint64_t *)&v12, &v11);
  if (v11)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v11);
  if (v12)
  {
    v7 = v12 + 2;
    v8 = atomic_load(v12 + 2);
    if (v8 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v12 + 8))();
    }
    else
    {
      do
        v9 = __ldaxr(v7);
      while (__stlxr(v9 - 1, v7));
    }
  }
  *a1 = &off_1EA104F00;
  return a1;
}

uint64_t TI::Favonius::CMMatchedKeyHypothesis::CMMatchedKeyHypothesis(uint64_t a1, unsigned int *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  char v10;
  unsigned int *v11;
  uint64_t v12;
  float v13;

  v7 = *a3;
  *a3 = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &off_1EA104E00;
  *(_QWORD *)(a1 + 16) = a2;
  if (a2)
  {
    v8 = a2 + 2;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
  }
  *(_QWORD *)(a1 + 24) = v7;
  v10 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)a2 + 104))(a2);
  v11 = a2;
  if ((v10 & 1) == 0)
    v11 = (unsigned int *)*((_QWORD *)a2 + 4);
  *(_QWORD *)a1 = &off_1EA104E80;
  v12 = *a4;
  *a4 = 0;
  *(_QWORD *)(a1 + 32) = v11;
  *(_QWORD *)(a1 + 40) = v12;
  v13 = (*(float (**)(unsigned int *))(*(_QWORD *)a2 + 16))(a2);
  *(float *)(a1 + 48) = v13
                      + TI::Favonius::CMMatchedKeyHypothesis::partial_log_likelihood(a2, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 40));
  return a1;
}

void TI::Favonius::CMTranspositionHypothesis::~CMTranspositionHypothesis(TI::Favonius::CMTranspositionHypothesis *this)
{
  TI::Favonius::CMMatchedKeyHypothesis::~CMMatchedKeyHypothesis(this);
  JUMPOUT(0x1DF0A2144);
}

float TI::Favonius::CMTranspositionHypothesis::log_likelihood(TI::Favonius::CMTranspositionHypothesis *this)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(TI::Favonius::CMTranspositionHypothesis *))(*(_QWORD *)this + 24))(this);
  return (*(float (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2) + *((float *)this + 12);
}

uint64_t TI::Favonius::CMMatchedKeyHypothesis::matched_key(TI::Favonius::CMMatchedKeyHypothesis *this)
{
  return *((_QWORD *)this + 5);
}

int32x2_t TI::Favonius::CMTranspositionHypothesis::get_key_touch_alignment(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v4;
  int32x2_t result;

  TI::Favonius::CMGeometryHypothesis::get_key_touch_alignment(a1, a2, a3);
  v4 = *(_QWORD *)(a2 + 8);
  result = vrev64_s32(*(int32x2_t *)(v4 - 8));
  *(int32x2_t *)(v4 - 8) = result;
  return result;
}

uint64_t TI::Favonius::CMTranspositionHypothesis::instance_error_correction_type(TI::Favonius::CMTranspositionHypothesis *this)
{
  return 2;
}

uint64_t TI::Favonius::CMMatchedKeyHypothesis::is_key_match(TI::Favonius::CMMatchedKeyHypothesis *this)
{
  return 1;
}

void TI::Favonius::CMMatchedKeyHypothesis::~CMMatchedKeyHypothesis(TI::Favonius::CMMatchedKeyHypothesis *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1EA104E80;
  v2 = *((_QWORD *)this + 5);
  if (v2)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v2);
  TI::Favonius::CMGeometryHypothesis::~CMGeometryHypothesis(this);
}

{
  TI::Favonius::CMMatchedKeyHypothesis::~CMMatchedKeyHypothesis(this);
  JUMPOUT(0x1DF0A2144);
}

float TI::Favonius::CMMatchedKeyHypothesis::log_likelihood(TI::Favonius::CMMatchedKeyHypothesis *this)
{
  return *((float *)this + 12);
}

uint64_t TI::Favonius::CMMatchedKeyHypothesis::instance_error_correction_type(TI::Favonius::CMMatchedKeyHypothesis *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;

  v2 = (unsigned int *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2 + 2;
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 + 1, v3));
  }
  v5 = **(_QWORD **)((*(uint64_t (**)(unsigned int *))(*(_QWORD *)v2 + 64))(v2) + 8);
  if (v5)
  {
    do
      v6 = __ldaxr((unsigned int *)v5);
    while (__stlxr(v6 + 1, (unsigned int *)v5));
  }
  v7 = *(unsigned __int16 *)(*(_QWORD *)(v5 + 8) + 62);
  v8 = *(unsigned __int16 *)(*(_QWORD *)((*(uint64_t (**)(TI::Favonius::CMMatchedKeyHypothesis *))(*(_QWORD *)this + 32))(this)
                                       + 8)
                           + 62);
  WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v5);
  v9 = v2 + 2;
  v10 = atomic_load(v2 + 2);
  if (v10 == 1)
  {
    (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
  }
  else
  {
    do
      v11 = __ldaxr(v9);
    while (__stlxr(v11 - 1, v9));
  }
  return 16 * (v7 != v8);
}

float TI::Favonius::CMMatchedKeyHypothesis::partial_log_likelihood(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int16 v15;
  float64x2_t v16;
  float64x2_t v17;
  float v23;
  float64x2_t v25;
  float64x2_t v26;

  v6 = a1;
  if (((*(uint64_t (**)(_QWORD *))(*a1 + 104))(a1) & 1) == 0)
    v6 = (_QWORD *)a1[4];
  v7 = *(_QWORD *)(a2 + 24);
  if (v7 != *(_QWORD *)(a2 + 32))
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v25 = 0u;
    v26 = 0u;
    while (1)
    {
      v12 = *(_QWORD *)(v7 + 8);
      if (v6
        && (v13 = (*(uint64_t (**)(_QWORD *))(*v6 + 24))(v6),
            *(_QWORD *)v7 == (*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 56))(v13)))
      {
        v12 = (*(uint64_t (**)(_QWORD *))(*v6 + 32))(v6);
        v6 = (_QWORD *)v6[4];
        if (!v12)
          goto LABEL_20;
      }
      else if (!v12)
      {
        goto LABEL_20;
      }
      v14 = *(_QWORD *)(v12 + 8);
      v15 = *(_WORD *)(v14 + 60);
      if (v11 & 1 | ((v15 & 0xB81) != 0))
      {
        if ((v15 & 0x80) != 0)
        {
          if (++v8 > 3)
            goto LABEL_23;
          ++v9;
          goto LABEL_20;
        }
      }
      else
      {
        if (v9)
        {
          v11 = 0;
          --v9;
          if (*(unsigned __int16 *)(v14 + 62) == *(unsigned __int16 *)(*(_QWORD *)(a3 + 8) + 62))
            ++v10;
          goto LABEL_20;
        }
        v11 = 1;
      }
      v16 = vsubq_f64(*(float64x2_t *)(v12 + 16), *(float64x2_t *)(a3 + 16));
      v17 = *(float64x2_t *)(v7 + 16);
      v25 = vaddq_f64(v25, v17);
      v26 = vmlaq_f64(v26, v16, vmulq_f64(v16, v17));
LABEL_20:
      v7 += 32;
      if (v7 == *(_QWORD *)(a2 + 32))
        goto LABEL_23;
    }
  }
  v10 = 0;
  v25 = 0u;
  v26 = 0u;
LABEL_23:
  __asm { FMOV            V0.2D, #2.0 }
  *(float *)_Q0.f64 = vaddvq_f64(vdivq_f64(v26, (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(_Q0, v25), (int8x16_t)_Q0, (int8x16_t)v25)));
  v23 = (float)(*(float *)(a2 + 76) * *(float *)_Q0.f64) + *(float *)(a3 + 32);
  return (float)(v23 + TI::Favonius::CMMatchedKeyHypothesis::penalty_for_different_key_in_clustered_touches(a1, a2, a3))
       + (float)((float)v10 * -0.1625);
}

float TI::Favonius::CMMatchedKeyHypothesis::penalty_for_different_key_in_clustered_touches(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  float v6;
  uint64_t v7;
  double *v8;
  double *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  __int16 v19;
  float v20;
  float v22;
  int v23;
  int v24;

  v5 = a1;
  if (((*(uint64_t (**)(_QWORD *))(*a1 + 104))(a1) & 1) == 0)
  {
    v5 = (_QWORD *)v5[4];
    if (!v5)
      return 0.0;
  }
  v6 = 0.0;
  if ((*(uint64_t (**)(_QWORD *))(*v5 + 32))(v5))
  {
    v7 = (*(uint64_t (**)(_QWORD *))(*v5 + 24))(v5);
    v8 = (double *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 56))(v7);
    v9 = (double *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 56))(a2);
    v10 = v8[1];
    v11 = v8[2];
    v12 = v8[4];
    v13 = v9[1];
    v14 = v9[2];
    v15 = v9[4];
    v16 = (*(uint64_t (**)(_QWORD *))(*v5 + 32))(v5);
    v17 = v15 - v12;
    v18 = *(_QWORD *)(v16 + 8);
    v19 = *(_WORD *)(v18 + 60);
    v20 = 4.0;
    if ((v19 & 0x80) != 0)
      v20 = 8.0;
    if (v17 != 0.0 && v17 <= 0.5)
    {
      v22 = sqrt((v11 - v14) * (v11 - v14) + (v10 - v13) * (v10 - v13));
      if ((float)(flt_1DA90F0D0[s_interface_idiom_is_pad == 0] * v20) >= v22)
      {
        v23 = *(unsigned __int16 *)(*(_QWORD *)(a3 + 8) + 62);
        v24 = *(unsigned __int16 *)(v18 + 62);
        if (v23 == v24)
          v6 = 0.0;
        else
          v6 = -3.5;
        if (v23 != v24 && (v19 & 0x80) == 0)
        {
          if ((v19 & 0x20) != 0)
            return -3.5;
          else
            return 0.0;
        }
      }
    }
  }
  return v6;
}

uint64_t TI::Favonius::CMGeometryHypothesis::root_hypothesis@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result;
  uint64_t v5;

  result = operator new();
  v5 = *a1;
  *a1 = 0;
  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)result = &off_1EA104E00;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = v5;
  *(_QWORD *)(result + 32) = 0;
  *a2 = result;
  return result;
}

uint64_t TI::Favonius::CMGeometryHypothesis::CMGeometryHypothesis(uint64_t result, uint64_t *a2)
{
  uint64_t v2;

  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)result = &off_1EA104E00;
  v2 = *a2;
  *a2 = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = v2;
  *(_QWORD *)(result + 32) = 0;
  return result;
}

{
  uint64_t v2;

  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)result = &off_1EA104E00;
  v2 = *a2;
  *a2 = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = v2;
  *(_QWORD *)(result + 32) = 0;
  return result;
}

uint64_t TI::Favonius::CMGeometryHypothesis::CMGeometryHypothesis(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  unsigned int *v3;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;

  v3 = a2;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &off_1EA104E00;
  *(_QWORD *)(a1 + 16) = a2;
  if (a2)
  {
    v5 = a2 + 2;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 + 1, v5));
  }
  v7 = *a3;
  *a3 = 0;
  *(_QWORD *)(a1 + 24) = v7;
  if (((*(uint64_t (**)(unsigned int *))(*(_QWORD *)a2 + 104))(a2) & 1) == 0)
    v3 = (unsigned int *)*((_QWORD *)v3 + 4);
  *(_QWORD *)(a1 + 32) = v3;
  return a1;
}

{
  unsigned int *v3;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;

  v3 = a2;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &off_1EA104E00;
  *(_QWORD *)(a1 + 16) = a2;
  if (a2)
  {
    v5 = a2 + 2;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 + 1, v5));
  }
  v7 = *a3;
  *a3 = 0;
  *(_QWORD *)(a1 + 24) = v7;
  if (((*(uint64_t (**)(unsigned int *))(*(_QWORD *)a2 + 104))(a2) & 1) == 0)
    v3 = (unsigned int *)*((_QWORD *)v3 + 4);
  *(_QWORD *)(a1 + 32) = v3;
  return a1;
}

uint64_t TI::Favonius::CMSubstitutionHypothesis::CMSubstitutionHypothesis(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  unsigned int *v3;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;

  v3 = a2;
  v5 = *a3;
  *a3 = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &off_1EA104E00;
  *(_QWORD *)(a1 + 16) = a2;
  if (a2)
  {
    v6 = a2 + 2;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
  }
  *(_QWORD *)(a1 + 24) = v5;
  if (((*(uint64_t (**)(unsigned int *))(*(_QWORD *)a2 + 104))(a2) & 1) == 0)
    v3 = (unsigned int *)*((_QWORD *)v3 + 4);
  *(_QWORD *)(a1 + 32) = v3;
  *(_QWORD *)a1 = &off_1EA104F80;
  return a1;
}

{
  unsigned int *v3;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;

  v3 = a2;
  v5 = *a3;
  *a3 = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &off_1EA104E00;
  *(_QWORD *)(a1 + 16) = a2;
  if (a2)
  {
    v6 = a2 + 2;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
  }
  *(_QWORD *)(a1 + 24) = v5;
  if (((*(uint64_t (**)(unsigned int *))(*(_QWORD *)a2 + 104))(a2) & 1) == 0)
    v3 = (unsigned int *)*((_QWORD *)v3 + 4);
  *(_QWORD *)(a1 + 32) = v3;
  *(_QWORD *)a1 = &off_1EA104F80;
  return a1;
}

BOOL TI::Favonius::CMMatchedKeyHypothesis::is_time_matching(TI::Favonius::CMMatchedKeyHypothesis *this, double a2, double a3)
{
  float v3;

  v3 = a2 - a3;
  return v3 <= 0.5 && v3 != 0.0;
}

BOOL TI::Favonius::CMMatchedKeyHypothesis::is_space_matching(TI::Favonius::CMMatchedKeyHypothesis *this, CGPoint a2, CGPoint a3)
{
  float v3;
  float v4;

  v3 = 4.0;
  if ((_DWORD)this)
    v3 = 8.0;
  v4 = sqrt((a3.y - a2.y) * (a3.y - a2.y) + (a3.x - a2.x) * (a3.x - a2.x));
  return (float)(flt_1DA90F0D0[s_interface_idiom_is_pad == 0] * v3) >= v4;
}

uint64_t KB::DynamicDictionaryCursor::copy(KB::DynamicDictionaryCursor *this)
{
  return (*(uint64_t (**)(KB::DynamicDictionaryCursor *))(*(_QWORD *)this + 64))(this);
}

float KB::DynamicDictionaryCursor::do_advance(KB::DynamicDictionaryCursor *this, const KB::DynamicDictionary *a2, const KB::String *a3, unsigned int a4)
{
  float v6;
  float v7;
  uint64_t v8;
  const void *v9;
  int v10;
  uint64_t v11;
  const void *v12;
  int v13;
  float v14;
  float v15;
  uint64_t v16;
  const void *v17;
  int v18;
  uint64_t v19;
  const void *v20;
  int v21;
  float v22;
  uint64_t v23;
  const void *v24;
  int v25;

  v6 = 0.0;
  v7 = 0.0;
  if (*((_QWORD *)this + 5))
  {
    v8 = LXCursorCreateByAdvancingWithUTF8();
    v9 = (const void *)*((_QWORD *)this + 5);
    if (v9)
      CFRelease(v9);
    *((_QWORD *)this + 5) = v8;
    if (v8)
    {
      v10 = LXCursorUsageCountRecursive();
      if (a4)
        v7 = (float)((float)v10 / (float)a4) + 0.0;
    }
  }
  if (*((_QWORD *)this + 1))
  {
    v11 = LXCursorCreateByAdvancingWithUTF8();
    v12 = (const void *)*((_QWORD *)this + 1);
    if (v12)
      CFRelease(v12);
    *((_QWORD *)this + 1) = v11;
    if (v11)
    {
      v13 = LXCursorUsageCountRecursive();
      if (a4)
        v6 = (float)v13 / (float)a4;
    }
  }
  v14 = 0.0;
  v15 = 0.0;
  if (*((_QWORD *)this + 2))
  {
    v16 = LXCursorCreateByAdvancingWithUTF8();
    v17 = (const void *)*((_QWORD *)this + 2);
    if (v17)
      CFRelease(v17);
    *((_QWORD *)this + 2) = v16;
    if (v16)
    {
      v18 = LXCursorUsageCountRecursive();
      if (a4)
        v15 = (float)v18 / (float)a4;
    }
  }
  if (*((_QWORD *)this + 3))
  {
    v19 = LXCursorCreateByAdvancingWithUTF8();
    v20 = (const void *)*((_QWORD *)this + 3);
    if (v20)
      CFRelease(v20);
    *((_QWORD *)this + 3) = v19;
    if (v19)
    {
      v21 = LXCursorUsageCountRecursive();
      if (a4)
        v14 = (float)v21 / (float)a4;
    }
  }
  v22 = 0.0;
  if (*((_QWORD *)this + 4))
  {
    v23 = LXCursorCreateByAdvancingWithUTF8();
    v24 = (const void *)*((_QWORD *)this + 4);
    if (v24)
      CFRelease(v24);
    *((_QWORD *)this + 4) = v23;
    if (v23)
    {
      v25 = LXCursorUsageCountRecursive();
      if (a4)
        v22 = (float)v25 / (float)a4;
    }
  }
  return (float)((float)((float)(v7 + v6) + v15) + v14) + v22;
}

void KB::DynamicDictionarySingleCursor::~DynamicDictionarySingleCursor(KB::DynamicDictionarySingleCursor *this)
{
  KB::DynamicDictionarySingleCursor::~DynamicDictionarySingleCursor(this);
  JUMPOUT(0x1DF0A2144);
}

{
  const void *v2;

  *(_QWORD *)this = &off_1EA105288;
  v2 = (const void *)*((_QWORD *)this + 6);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 6) = 0;
  KB::DynamicDictionaryCursor::~DynamicDictionaryCursor(this);
}

uint64_t KB::DynamicDictionarySingleCursor::get_mutable_persistent_custom_node(KB::DynamicDictionarySingleCursor *this)
{
  return (uint64_t)this + 48;
}

uint64_t KB::DynamicDictionarySingleCursor::get_persistent_custom_node(KB::DynamicDictionarySingleCursor *this)
{
  return (uint64_t)this + 48;
}

uint64_t KB::DynamicDictionarySingleCursor::do_for_each_dynamic_trie_node(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = (_QWORD *)result;
  if (*(_QWORD *)(result + 48))
    result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a2 + 16))(a2, result + 48, 0, 0);
  if (v3[1])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 1, 1, 0);
  if (v3[2])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 2, 2, 0);
  if (v3[3])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 3, 3, 0);
  if (v3[4])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 4, 4, 0);
  v5 = v3[5];
  v4 = v3 + 5;
  if (v5)
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v4, 5, 0);
  return result;
}

uint64_t KB::DynamicDictionarySingleCursor::do_for_each_mutable_dynamic_trie_node(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = (_QWORD *)result;
  if (*(_QWORD *)(result + 48))
    result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a2 + 16))(a2, result + 48, 0, 0);
  if (v3[1])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 1, 1, 0);
  if (v3[2])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 2, 2, 0);
  if (v3[3])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 3, 3, 0);
  if (v3[4])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 4, 4, 0);
  v5 = v3[5];
  v4 = v3 + 5;
  if (v5)
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v4, 5, 0);
  return result;
}

float KB::DynamicDictionarySingleCursor::do_advance(KB::DynamicDictionarySingleCursor *this, const KB::DynamicDictionary *a2, const KB::String *a3, unsigned int a4)
{
  float v6;
  uint64_t v7;
  const void *v8;
  int v9;
  float v10;

  v6 = KB::DynamicDictionaryCursor::do_advance(this, a2, a3, a4) + 0.0;
  if (*((_QWORD *)this + 6))
  {
    v7 = LXCursorCreateByAdvancingWithUTF8();
    v8 = (const void *)*((_QWORD *)this + 6);
    if (v8)
      CFRelease(v8);
    *((_QWORD *)this + 6) = v7;
    if (v7)
    {
      v9 = LXCursorUsageCountRecursive();
      if (a4)
        v10 = (float)v9 / (float)a4;
      else
        v10 = 0.0;
      return v6 + v10;
    }
  }
  return v6;
}

_QWORD *KB::DynamicDictionarySingleCursor::do_copy@<X0>(KB::DynamicDictionarySingleCursor *this@<X0>, KB::DynamicDictionaryCursor **a2@<X8>)
{
  KB::DynamicDictionaryCursor *v4;
  _QWORD *result;
  const void *v6;

  v4 = (KB::DynamicDictionaryCursor *)operator new();
  result = KB::DynamicDictionaryCursor::DynamicDictionaryCursor(v4, this);
  *result = &off_1EA105288;
  v6 = (const void *)*((_QWORD *)this + 6);
  result[6] = v6;
  if (v6)
  {
    result = CFRetain(v6);
    *((_QWORD *)v4 + 6) = v6;
  }
  *a2 = v4;
  return result;
}

float KB::DynamicDictionarySingleCursor::get_termination_probability(KB::DynamicDictionarySingleCursor *this, const KB::DynamicDictionary *a2)
{
  unsigned int v2;
  float v3;
  _QWORD v5[6];
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v6 = 0;
  v7 = (unsigned int *)&v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = ___ZNK2KB29DynamicDictionarySingleCursor27get_termination_probabilityERKNS_17DynamicDictionaryE_block_invoke;
  v5[3] = &unk_1EA1052F0;
  v5[4] = &v10;
  v5[5] = &v6;
  (*(void (**)(KB::DynamicDictionarySingleCursor *, _QWORD *))(*(_QWORD *)this + 40))(this, v5);
  v2 = *((_DWORD *)v11 + 6);
  if (v2)
    v3 = (float)v7[6] / (float)v2;
  else
    v3 = 0.0;
  _Block_object_dispose(&v6, 8);
  _Block_object_dispose(&v10, 8);
  return v3;
}

uint64_t KB::DynamicDictionarySingleCursor::get_subtree_usage_count(KB::DynamicDictionarySingleCursor *this, const KB::DynamicDictionary *a2)
{
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK2KB29DynamicDictionarySingleCursor23get_subtree_usage_countERKNS_17DynamicDictionaryE_block_invoke;
  v4[3] = &unk_1EA105318;
  v4[4] = &v5;
  (*(void (**)(KB::DynamicDictionarySingleCursor *, _QWORD *))(*(_QWORD *)this + 40))(this, v4);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t KB::DynamicDictionarySingleCursor::get_entry_count(KB::DynamicDictionarySingleCursor *this, const KB::DynamicDictionary *a2)
{
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK2KB29DynamicDictionarySingleCursor15get_entry_countERKNS_17DynamicDictionaryE_block_invoke;
  v4[3] = &unk_1EA105340;
  v4[4] = &v5;
  (*(void (**)(KB::DynamicDictionarySingleCursor *, _QWORD *))(*(_QWORD *)this + 40))(this, v4);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___ZNK2KB29DynamicDictionarySingleCursor15get_entry_countERKNS_17DynamicDictionaryE_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
  {
    result = LXCursorUsageCount();
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += result;
  }
  return result;
}

uint64_t ___ZNK2KB29DynamicDictionarySingleCursor23get_subtree_usage_countERKNS_17DynamicDictionaryE_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
  {
    result = LXCursorUsageCountRecursive();
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += result;
  }
  return result;
}

uint64_t ___ZNK2KB29DynamicDictionarySingleCursor27get_termination_probabilityERKNS_17DynamicDictionaryE_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (*a2)
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += LXCursorUsageCountRecursive();
    result = LXCursorUsageCount();
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += result;
  }
  return result;
}

KB::DynamicDictionaryCursor *KB::DynamicDictionaryCursor::DynamicDictionaryCursor(KB::DynamicDictionaryCursor *this, const KB::DynamicDictionaryCursor *a2)
{
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  v4 = (const void *)*((_QWORD *)a2 + 1);
  *(_QWORD *)this = &off_1EA105100;
  *((_QWORD *)this + 1) = v4;
  if (v4)
  {
    CFRetain(v4);
    *((_QWORD *)this + 1) = v4;
  }
  v5 = (const void *)*((_QWORD *)a2 + 2);
  *((_QWORD *)this + 2) = v5;
  if (v5)
  {
    CFRetain(v5);
    *((_QWORD *)this + 2) = v5;
  }
  v6 = (const void *)*((_QWORD *)a2 + 3);
  *((_QWORD *)this + 3) = v6;
  if (v6)
  {
    CFRetain(v6);
    *((_QWORD *)this + 3) = v6;
  }
  v7 = (const void *)*((_QWORD *)a2 + 4);
  *((_QWORD *)this + 4) = v7;
  if (v7)
  {
    CFRetain(v7);
    *((_QWORD *)this + 4) = v7;
  }
  v8 = (const void *)*((_QWORD *)a2 + 5);
  *((_QWORD *)this + 5) = v8;
  if (v8)
  {
    CFRetain(v8);
    *((_QWORD *)this + 5) = v8;
  }
  return this;
}

void KB::DynamicDictionaryCursor::~DynamicDictionaryCursor(KB::DynamicDictionaryCursor *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  *(_QWORD *)this = &off_1EA105100;
  v2 = (const void *)*((_QWORD *)this + 5);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 5) = 0;
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 4) = 0;
  v4 = (const void *)*((_QWORD *)this + 3);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 3) = 0;
  v5 = (const void *)*((_QWORD *)this + 2);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 2) = 0;
  v6 = (const void *)*((_QWORD *)this + 1);
  if (v6)
    CFRelease(v6);
  *((_QWORD *)this + 1) = 0;
}

void KB::DynamicDictionaryContainerCursor::~DynamicDictionaryContainerCursor(KB::DynamicDictionaryContainerCursor *this)
{
  void **v2;

  *(_QWORD *)this = &off_1EA105370;
  v2 = (void **)((char *)this + 48);
  std::vector<KB::retain_ptr<__CFString const*>>::__destroy_vector::operator()[abi:nn180100](&v2);
  KB::DynamicDictionaryCursor::~DynamicDictionaryCursor(this);
}

{
  void **v2;

  *(_QWORD *)this = &off_1EA105370;
  v2 = (void **)((char *)this + 48);
  std::vector<KB::retain_ptr<__CFString const*>>::__destroy_vector::operator()[abi:nn180100](&v2);
  KB::DynamicDictionaryCursor::~DynamicDictionaryCursor(this);
  JUMPOUT(0x1DF0A2144);
}

uint64_t KB::DynamicDictionaryContainerCursor::get_mutable_persistent_custom_node(KB::DynamicDictionaryContainerCursor *this, uint64_t a2)
{
  return *((_QWORD *)this + 6) + 8 * a2;
}

uint64_t KB::DynamicDictionaryContainerCursor::get_persistent_custom_node(KB::DynamicDictionaryContainerCursor *this, uint64_t a2)
{
  return *((_QWORD *)this + 6) + 8 * a2;
}

uint64_t KB::DynamicDictionaryContainerCursor::do_for_each_dynamic_trie_node(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;
  _QWORD *v9;
  uint64_t v10;

  v3 = (_QWORD *)result;
  v4 = *(_QWORD *)(result + 56) - *(_QWORD *)(result + 48);
  if (v4)
  {
    v5 = 0;
    v6 = v4 >> 3;
    v7 = 1;
    do
    {
      if (*(_QWORD *)(v3[6] + 8 * v5))
        result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
      v5 = v7;
    }
    while (v6 > v7++);
  }
  if (v3[1])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 1, 1, 0);
  if (v3[2])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 2, 2, 0);
  if (v3[3])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 3, 3, 0);
  if (v3[4])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 4, 4, 0);
  v10 = v3[5];
  v9 = v3 + 5;
  if (v10)
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v9, 5, 0);
  return result;
}

uint64_t KB::DynamicDictionaryContainerCursor::do_for_each_mutable_dynamic_trie_node(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;
  _QWORD *v9;
  uint64_t v10;

  v3 = (_QWORD *)result;
  v4 = *(_QWORD *)(result + 56) - *(_QWORD *)(result + 48);
  if (v4)
  {
    v5 = 0;
    v6 = v4 >> 3;
    v7 = 1;
    do
    {
      if (*(_QWORD *)(v3[6] + 8 * v5))
        result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
      v5 = v7;
    }
    while (v6 > v7++);
  }
  if (v3[1])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 1, 1, 0);
  if (v3[2])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 2, 2, 0);
  if (v3[3])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 3, 3, 0);
  if (v3[4])
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v3 + 4, 4, 0);
  v10 = v3[5];
  v9 = v3 + 5;
  if (v10)
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(a2 + 16))(a2, v9, 5, 0);
  return result;
}

float KB::DynamicDictionaryContainerCursor::do_advance(KB::DynamicDictionaryContainerCursor *this, const KB::DynamicDictionary *a2, const KB::String *a3, unsigned int a4)
{
  float v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  float v13;
  uint64_t v14;
  const void *v15;
  int v16;
  float v17;

  v7 = KB::DynamicDictionaryCursor::do_advance(this, a2, a3, a4) + 0.0;
  v8 = *((_QWORD *)a2 + 15) - *((_QWORD *)a2 + 14);
  v9 = *((_QWORD *)this + 6);
  if ((*((_QWORD *)this + 7) - v9) >> 3 >= (unint64_t)(v8 >> 3))
    v10 = v8 >> 3;
  else
    v10 = (*((_QWORD *)this + 7) - v9) >> 3;
  if (v10)
  {
    for (i = 0; i != v10; ++i)
    {
      v12 = *((_QWORD *)this + 6);
      if (*(_QWORD *)(v12 + 8 * i))
      {
        v13 = *(float *)(*((_QWORD *)a2 + 21) + 4 * i);
        v14 = LXCursorCreateByAdvancingWithUTF8();
        v15 = *(const void **)(v12 + 8 * i);
        if (v15)
          CFRelease(v15);
        *(_QWORD *)(v12 + 8 * i) = v14;
        if (v14)
        {
          v16 = LXCursorUsageCountRecursive();
          if (a4)
            v17 = (float)v16 / (float)a4;
          else
            v17 = 0.0;
          v7 = v7 + (float)(v13 * v17);
        }
      }
    }
  }
  return v7;
}

_QWORD *KB::DynamicDictionaryContainerCursor::do_copy@<X0>(const void ***this@<X0>, KB::DynamicDictionaryCursor **a2@<X8>)
{
  KB::DynamicDictionaryCursor *v4;
  KB::DynamicDictionaryCursor *v5;
  _QWORD *result;
  const void **v7;
  const void **v8;
  const void **v9;
  const void *v10;

  v4 = (KB::DynamicDictionaryCursor *)operator new();
  v5 = KB::DynamicDictionaryCursor::DynamicDictionaryCursor(v4, (const KB::DynamicDictionaryCursor *)this);
  *((_QWORD *)v5 + 6) = 0;
  result = (_QWORD *)((char *)v5 + 48);
  *(_QWORD *)v4 = &off_1EA105370;
  *((_QWORD *)v4 + 7) = 0;
  *((_QWORD *)v4 + 8) = 0;
  v7 = this[6];
  v8 = this[7];
  if (v8 != v7)
  {
    result = std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](result, v8 - v7);
    v9 = (const void **)*((_QWORD *)v4 + 7);
    do
    {
      v10 = *v7;
      *v9 = *v7;
      if (v10)
      {
        result = CFRetain(v10);
        *v9 = v10;
      }
      ++v7;
      ++v9;
    }
    while (v7 != v8);
    *((_QWORD *)v4 + 7) = v9;
  }
  *a2 = v4;
  return result;
}

float KB::DynamicDictionaryContainerCursor::get_termination_probability(KB::DynamicDictionaryContainerCursor *this, const KB::DynamicDictionary *a2)
{
  float v2;
  float v3;
  _QWORD v5[7];
  uint64_t v6;
  float *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  float *v11;
  uint64_t v12;
  int v13;

  v10 = 0;
  v11 = (float *)&v10;
  v12 = 0x2000000000;
  v13 = 0;
  v6 = 0;
  v7 = (float *)&v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = ___ZNK2KB32DynamicDictionaryContainerCursor27get_termination_probabilityERKNS_17DynamicDictionaryE_block_invoke;
  v5[3] = &unk_1EA1053D8;
  v5[5] = &v6;
  v5[6] = a2;
  v5[4] = &v10;
  (*(void (**)(KB::DynamicDictionaryContainerCursor *, _QWORD *))(*(_QWORD *)this + 40))(this, v5);
  v2 = v11[6];
  v3 = 0.0;
  if (v2 > 0.0)
    v3 = v7[6] / v2;
  _Block_object_dispose(&v6, 8);
  _Block_object_dispose(&v10, 8);
  return v3;
}

unint64_t KB::DynamicDictionaryContainerCursor::get_subtree_usage_count(KB::DynamicDictionaryContainerCursor *this, const KB::DynamicDictionary *a2)
{
  unint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  float *v6;
  uint64_t v7;
  int v8;

  v5 = 0;
  v6 = (float *)&v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK2KB32DynamicDictionaryContainerCursor23get_subtree_usage_countERKNS_17DynamicDictionaryE_block_invoke;
  v4[3] = &unk_1EA105400;
  v4[4] = &v5;
  v4[5] = a2;
  (*(void (**)(KB::DynamicDictionaryContainerCursor *, _QWORD *))(*(_QWORD *)this + 40))(this, v4);
  v2 = llroundf(ceilf(v6[6]));
  _Block_object_dispose(&v5, 8);
  return v2;
}

unint64_t KB::DynamicDictionaryContainerCursor::get_entry_count(KB::DynamicDictionaryContainerCursor *this, const KB::DynamicDictionary *a2)
{
  unint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  float *v6;
  uint64_t v7;
  int v8;

  v5 = 0;
  v6 = (float *)&v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK2KB32DynamicDictionaryContainerCursor15get_entry_countERKNS_17DynamicDictionaryE_block_invoke;
  v4[3] = &unk_1EA105428;
  v4[4] = &v5;
  v4[5] = a2;
  (*(void (**)(KB::DynamicDictionaryContainerCursor *, _QWORD *))(*(_QWORD *)this + 40))(this, v4);
  v2 = llroundf(ceilf(v6[6]));
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___ZNK2KB32DynamicDictionaryContainerCursor15get_entry_countERKNS_17DynamicDictionaryE_block_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  float v7;
  float v8;

  if (a3)
  {
    result = LXCursorUsageCount();
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(float *)(v6 + 24) + (float)(int)result;
  }
  else
  {
    v8 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 168) + 4 * a4);
    result = LXCursorUsageCount();
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(float *)(v6 + 24) + (float)(v8 * (float)(int)result);
  }
  *(float *)(v6 + 24) = v7;
  return result;
}

uint64_t ___ZNK2KB32DynamicDictionaryContainerCursor23get_subtree_usage_countERKNS_17DynamicDictionaryE_block_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  float v7;
  float v8;

  if (a3)
  {
    result = LXCursorUsageCountRecursive();
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(float *)(v6 + 24) + (float)(int)result;
  }
  else
  {
    v8 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 168) + 4 * a4);
    result = LXCursorUsageCountRecursive();
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(float *)(v6 + 24) + (float)(v8 * (float)(int)result);
  }
  *(float *)(v6 + 24) = v7;
  return result;
}

uint64_t ___ZNK2KB32DynamicDictionaryContainerCursor27get_termination_probabilityERKNS_17DynamicDictionaryE_block_invoke(_QWORD *a1, uint64_t *a2, int a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  float v7;
  float v8;

  result = *a2;
  if (a3)
  {
    if (!result)
      return result;
    *(float *)(*(_QWORD *)(a1[4] + 8) + 24) = *(float *)(*(_QWORD *)(a1[4] + 8) + 24)
                                                + (float)(int)LXCursorUsageCountRecursive();
    result = LXCursorUsageCount();
    v6 = *(_QWORD *)(a1[5] + 8);
    v7 = *(float *)(v6 + 24) + (float)(int)result;
  }
  else
  {
    if (!result)
      return result;
    v8 = *(float *)(*(_QWORD *)(a1[6] + 168) + 4 * a4);
    *(float *)(*(_QWORD *)(a1[4] + 8) + 24) = *(float *)(*(_QWORD *)(a1[4] + 8) + 24)
                                                + (float)(v8 * (float)(int)LXCursorUsageCountRecursive());
    result = LXCursorUsageCount();
    v6 = *(_QWORD *)(a1[5] + 8);
    v7 = *(float *)(v6 + 24) + (float)(v8 * (float)(int)result);
  }
  *(float *)(v6 + 24) = v7;
  return result;
}

double KB::DynamicDictionaryCursor::DynamicDictionaryCursor(KB::DynamicDictionaryCursor *this, const KB::DynamicDictionary *a2)
{
  double result;

  *(_QWORD *)this = &off_1EA105100;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 5) = 0;
  return result;
}

void KB::DynamicDictionaryCursor::set_to_root(KB::DynamicDictionaryCursor *this, const KB::DynamicDictionary *a2)
{
  uint64_t RootCursor;
  const void *v5;
  uint64_t v6;
  const void *v7;
  _QWORD **v8;
  _QWORD *v9;
  uint64_t v10;
  const void *v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  const void *v15;

  if (*((_QWORD *)a2 + 1))
    RootCursor = LXLexiconCreateRootCursor();
  else
    RootCursor = 0;
  v5 = (const void *)*((_QWORD *)this + 1);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 1) = RootCursor;
  if (*((_QWORD *)a2 + 2))
    v6 = LXLexiconCreateRootCursor();
  else
    v6 = 0;
  v7 = (const void *)*((_QWORD *)this + 2);
  if (v7)
    CFRelease(v7);
  *((_QWORD *)this + 2) = v6;
  v8 = (_QWORD **)*((_QWORD *)a2 + 3);
  if (v8 && (v9 = *v8) != 0 && *v9)
    v10 = LXLexiconCreateRootCursor();
  else
    v10 = 0;
  v11 = (const void *)*((_QWORD *)this + 3);
  if (v11)
    CFRelease(v11);
  *((_QWORD *)this + 3) = v10;
  if (KB::DynamicDictionary::named_entity_lexicon(a2))
    v12 = LXLexiconCreateRootCursor();
  else
    v12 = 0;
  v13 = (const void *)*((_QWORD *)this + 4);
  if (v13)
    CFRelease(v13);
  *((_QWORD *)this + 4) = v12;
  if (TITransientLexiconManagerGetActiveSupplementalLexiconWords())
    v14 = LXLexiconCreateRootCursor();
  else
    v14 = 0;
  v15 = (const void *)*((_QWORD *)this + 5);
  if (v15)
    CFRelease(v15);
  *((_QWORD *)this + 5) = v14;
}

uint64_t KB::DynamicDictionaryCursor::invalidate(KB::DynamicDictionaryCursor *this)
{
  return (*(uint64_t (**)(KB::DynamicDictionaryCursor *, void *))(*(_QWORD *)this + 48))(this, &__block_literal_global_15828);
}

void ___ZN2KB23DynamicDictionaryCursor10invalidateEv_block_invoke(uint64_t a1, CFTypeRef *a2)
{
  if (*a2)
    CFRelease(*a2);
  *a2 = 0;
}

uint64_t KB::DynamicDictionaryCursor::valid(KB::DynamicDictionaryCursor *this)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ___ZNK2KB23DynamicDictionaryCursor5validEv_block_invoke;
  v3[3] = &unk_1EA1051A8;
  v3[4] = &v4;
  (*(void (**)(KB::DynamicDictionaryCursor *, _QWORD *))(*(_QWORD *)this + 40))(this, v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK2KB23DynamicDictionaryCursor5validEv_block_invoke(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  BOOL v3;
  char v4;

  v2 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  if (*(_BYTE *)(v2 + 24))
    v3 = 0;
  else
    v3 = *a2 == 0;
  v4 = !v3;
  *(_BYTE *)(v2 + 24) = v4;
  return result;
}

uint64_t KB::DynamicDictionaryCursor::has_entries(KB::DynamicDictionaryCursor *this)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ___ZNK2KB23DynamicDictionaryCursor11has_entriesEv_block_invoke;
  v3[3] = &unk_1EA1051D0;
  v3[4] = &v4;
  (*(void (**)(KB::DynamicDictionaryCursor *, _QWORD *))(*(_QWORD *)this + 40))(this, v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK2KB23DynamicDictionaryCursor11has_entriesEv_block_invoke(uint64_t result)
{
  uint64_t v1;
  BOOL v2;

  v1 = result;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24))
  {
    v2 = 1;
  }
  else
  {
    result = LXCursorHasEntries();
    if ((_DWORD)result)
    {
      result = LXCursorUsageCount();
      v2 = (int)result > 0;
    }
    else
    {
      v2 = 0;
    }
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24) = v2;
  return result;
}

uint64_t KB::DynamicDictionaryCursor::has_children(KB::DynamicDictionaryCursor *this)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ___ZNK2KB23DynamicDictionaryCursor12has_childrenEv_block_invoke;
  v3[3] = &unk_1EA1051F8;
  v3[4] = &v4;
  (*(void (**)(KB::DynamicDictionaryCursor *, _QWORD *))(*(_QWORD *)this + 40))(this, v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t ___ZNK2KB23DynamicDictionaryCursor12has_childrenEv_block_invoke(uint64_t result)
{
  uint64_t v1;
  BOOL v2;
  uint64_t v3;

  v1 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  if (*(_BYTE *)(v1 + 24))
  {
    v2 = 1;
  }
  else
  {
    v3 = result;
    result = LXCursorHasChildren();
    v2 = (_DWORD)result != 0;
    v1 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8);
  }
  *(_BYTE *)(v1 + 24) = v2;
  return result;
}

uint64_t KB::DynamicDictionaryCursor::merge_children_with_static_siblings(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v5[7];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = ___ZNK2KB23DynamicDictionaryCursor35merge_children_with_static_siblingsERNSt3__16vectorINS_17DictionaryCursorsENS1_9allocatorIS3_EEEERKNS_16StaticDictionaryERKNS_17DynamicDictionaryE_block_invoke;
  v5[3] = &__block_descriptor_tmp_9_15842;
  v5[4] = a2;
  v5[5] = a3;
  v5[6] = a4;
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 40))(a1, v5);
}

uint64_t ___ZNK2KB23DynamicDictionaryCursor35merge_children_with_static_siblingsERNSt3__16vectorINS_17DictionaryCursorsENS1_9allocatorIS3_EEEERKNS_16StaticDictionaryERKNS_17DynamicDictionaryE_block_invoke(uint64_t a1, uint64_t *a2, int a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  _QWORD v7[4];
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t);
  void *v15;
  _QWORD *v16;

  result = *a2;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = ___ZNK2KB23DynamicDictionaryCursor35merge_children_with_static_siblingsERNSt3__16vectorINS_17DictionaryCursorsENS1_9allocatorIS3_EEEERKNS_16StaticDictionaryERKNS_17DynamicDictionaryE_block_invoke_2;
  v7[3] = &__block_descriptor_tmp_8_15843;
  v8 = *(_OWORD *)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 48);
  v11 = a3;
  v9 = v6;
  v10 = a4;
  if (result)
  {
    v12 = MEMORY[0x1E0C809B0];
    v13 = 0x40000000;
    v14 = ___ZL34enumerate_whole_character_childrenPK9_LXCursorU13block_pointerFvS1_jE_block_invoke;
    v15 = &unk_1EA105450;
    v16 = v7;
    return LXCursorEnumerateChildren();
  }
  return result;
}

void ___ZNK2KB23DynamicDictionaryCursor35merge_children_with_static_siblingsERNSt3__16vectorINS_17DictionaryCursorsENS1_9allocatorIS3_EEEERKNS_16StaticDictionaryERKNS_17DynamicDictionaryE_block_invoke_2(uint64_t a1, const void *a2, int a3)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  char *v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  char *v50;
  uint64_t v51;
  uint64_t i;
  const void *v53;
  const void **v54;
  int v55;
  uint64_t v56;
  const void *v57;
  uint64_t v58;
  _OWORD v59[2];
  int v60;
  uint64_t v61;
  int v62;
  _QWORD v63[2];
  BOOL (*v64)(uint64_t, uint64_t);
  void *v65;
  int v66;
  char *v67;
  unint64_t v68;
  uint64_t v69;
  char *v70;
  _QWORD *v71;
  char *v72;
  int64x2_t v73;
  char *v74;
  _QWORD *v75;
  _QWORD *v76;

  if (a3 != 65533)
  {
    v5 = a1;
    v6 = *(uint64_t **)(a1 + 32);
    v8 = *v6;
    v7 = v6[1];
    v63[0] = MEMORY[0x1E0C809B0];
    v63[1] = 0x40000000;
    v64 = ___ZNK2KB23DynamicDictionaryCursor35merge_children_with_static_siblingsERNSt3__16vectorINS_17DictionaryCursorsENS1_9allocatorIS3_EEEERKNS_16StaticDictionaryERKNS_17DynamicDictionaryE_block_invoke_3;
    v65 = &__block_descriptor_tmp_6_15847;
    v66 = a3;
    v9 = v7 - v8;
    if (v9)
    {
      v10 = 0xCCCCCCCCCCCCCCCDLL * (v9 >> 4);
      do
      {
        v11 = v8 + 80 * (v10 >> 1);
        v12 = ((uint64_t (*)(_QWORD *, unint64_t))v64)(v63, v11);
        if (v12)
          v10 += ~(v10 >> 1);
        else
          v10 >>= 1;
        if (v12)
          v8 = v11 + 80;
      }
      while (v10);
      v13 = v8;
      v6 = *(uint64_t **)(v5 + 32);
      v8 = v6[1];
    }
    else
    {
      v13 = v8;
    }
    if (v8 == v13 || (v14 = v13, *(_DWORD *)(v13 + 72) != a3))
    {
      v55 = a3;
      v56 = v5;
      v57 = a2;
      v15 = *(_QWORD *)(v5 + 48);
      v16 = ((*(_QWORD *)(*(_QWORD *)(v5 + 40) + 8) - **(_QWORD **)(v5 + 40)) >> 3);
      memset(v59, 0, sizeof(v59));
      v60 = 0;
      v61 = v16;
      v62 = 0;
      (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v15 + 24))(&v58);
      v18 = *v6;
      v17 = v6[1];
      v19 = v13 - *v6;
      v20 = v19 / 80;
      v14 = *v6 + 80 * (v19 / 80);
      v21 = v6[2];
      if (v17 >= v21)
      {
        v28 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v17 - v18) >> 4) + 1;
        if (v28 > 0x333333333333333)
          abort();
        v29 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v21 - v18) >> 4);
        if (2 * v29 > v28)
          v28 = 2 * v29;
        if (v29 >= 0x199999999999999)
          v30 = 0x333333333333333;
        else
          v30 = v28;
        v71 = v6 + 2;
        if (v30)
        {
          v32 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::DictionaryCursors>>(v30);
        }
        else
        {
          v32 = 0;
          v31 = 0;
        }
        v33 = (unint64_t)&v32[80 * v20];
        v67 = v32;
        v68 = v33;
        v34 = &v32[80 * v31];
        v69 = v33;
        v70 = v34;
        if (v20 == v31)
        {
          if (v19 < 1)
          {
            if (v13 == v18)
              v37 = 1;
            else
              v37 = 2 * v20;
            v38 = v37 >> 2;
            v75 = v6 + 2;
            v39 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::DictionaryCursors>>(v37);
            v40 = &v39[80 * v38];
            v72 = v32;
            v67 = v39;
            v68 = (unint64_t)v40;
            v73 = vdupq_n_s64(v33);
            v69 = (uint64_t)v40;
            v70 = &v39[80 * v41];
            v74 = v34;
            std::__split_buffer<KB::DictionaryCursors>::~__split_buffer((uint64_t)&v72);
            v33 = (unint64_t)v40;
          }
          else
          {
            v35 = v20 + 2;
            if (v20 >= -1)
              v35 = v20 + 1;
            v33 -= 80 * (v35 >> 1);
            v68 = v33;
            v69 = v33;
          }
        }
        KB::DictionaryCursors::DictionaryCursors(v33, (uint64_t)v59, &v58);
        v42 = v68;
        v43 = v69 + 80;
        v69 += 80;
        v44 = *v6;
        if (*v6 == v14)
        {
          v46 = v68;
          v5 = v56;
        }
        else
        {
          v45 = v14;
          v46 = v68;
          v5 = v56;
          do
          {
            v46 -= 80;
            v45 -= 80;
            KB::DictionaryCursors::DictionaryCursors(v46, v45);
          }
          while (v45 != v44);
          v43 = v69;
        }
        v47 = v6[1];
        if (v47 != v14)
        {
          do
          {
            v48 = KB::DictionaryCursors::DictionaryCursors(v43, v14);
            v14 += 80;
            v43 = v48 + 80;
          }
          while (v14 != v47);
          v14 = v6[1];
        }
        v49 = (char *)*v6;
        *v6 = v46;
        v67 = v49;
        v68 = (unint64_t)v49;
        v6[1] = v43;
        v69 = v14;
        v50 = (char *)v6[2];
        v6[2] = (uint64_t)v70;
        v70 = v50;
        std::__split_buffer<KB::DictionaryCursors>::~__split_buffer((uint64_t)&v67);
        v14 = v42;
      }
      else
      {
        if (v14 == v17)
        {
          KB::DictionaryCursors::DictionaryCursors(*v6 + 80 * (v19 / 80), (uint64_t)v59, &v58);
          v6[1] = v14 + 80;
        }
        else
        {
          v76 = v6 + 2;
          KB::DictionaryCursors::DictionaryCursors((uint64_t)&v72, (uint64_t)v59, &v58);
          v22 = v6[1];
          v23 = v14 + 80;
          v24 = v22 - 80;
          if (v22 < 0x50)
          {
            v26 = v6[1];
          }
          else
          {
            v25 = v22 - 80;
            v26 = v6[1];
            do
            {
              v27 = KB::DictionaryCursors::DictionaryCursors(v26, v25);
              v25 += 80;
              v26 = v27 + 80;
            }
            while (v25 < v22);
          }
          v6[1] = v26;
          if (v22 != v23)
          {
            v36 = 16 * ((uint64_t)(v22 - v23) >> 4);
            do
            {
              KB::DictionaryCursors::operator=(v24, v18 + 80 * v20 - 80 + v36);
              v24 -= 80;
              v36 -= 80;
            }
            while (v36);
          }
          KB::DictionaryCursors::operator=(v14, (uint64_t)&v72);
          std::__destroy_at[abi:nn180100]<KB::DictionaryCursors,0>((uint64_t)&v72);
        }
        v5 = v56;
        a2 = v57;
      }
      v51 = v58;
      v58 = 0;
      if (v51)
        (*(void (**)(uint64_t))(*(_QWORD *)v51 + 16))(v51);
      for (i = 16; i != -8; i -= 8)
      {
        v53 = *(const void **)((char *)v59 + i);
        if (v53)
          CFRelease(v53);
        *(_QWORD *)((char *)v59 + i) = 0;
      }
      *(_DWORD *)(v14 + 72) = v55;
    }
    switch(*(_DWORD *)(v5 + 64))
    {
      case 0:
        v54 = (const void **)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v14 + 56) + 24))(*(_QWORD *)(v14 + 56), *(_QWORD *)(v5 + 56));
        goto LABEL_68;
      case 1:
        v54 = (const void **)(*(_QWORD *)(v14 + 56) + 8);
        goto LABEL_68;
      case 2:
        v54 = (const void **)(*(_QWORD *)(v14 + 56) + 16);
        goto LABEL_68;
      case 3:
        v54 = (const void **)(*(_QWORD *)(v14 + 56) + 24);
        goto LABEL_68;
      case 4:
        v54 = (const void **)(*(_QWORD *)(v14 + 56) + 32);
        goto LABEL_68;
      case 5:
        v54 = (const void **)(*(_QWORD *)(v14 + 56) + 40);
LABEL_68:
        KB::retain_ptr<__CFDictionary const*>::operator=(v54, a2);
        break;
      default:
        return;
    }
  }
}

uint64_t ___ZL34enumerate_whole_character_childrenPK9_LXCursorU13block_pointerFvS1_jE_block_invoke(uint64_t a1)
{
  LXCursorLastTraversedCharacter();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

BOOL ___ZNK2KB23DynamicDictionaryCursor35merge_children_with_static_siblingsERNSt3__16vectorINS_17DictionaryCursorsENS1_9allocatorIS3_EEEERKNS_16StaticDictionaryERKNS_17DynamicDictionaryE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 72) < *(_DWORD *)(a1 + 32);
}

void KB::DynamicDictionarySingleCursor::create_root_cursor(KB::DynamicDictionarySingleCursor *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5;

  v5 = operator new();
  *(_OWORD *)(v5 + 8) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_QWORD *)(v5 + 40) = 0;
  *(_QWORD *)(v5 + 48) = 0;
  *(_QWORD *)v5 = &off_1EA105288;
  *a2 = v5;
  KB::DynamicDictionarySingleCursor::set_to_root((KB::DynamicDictionarySingleCursor *)v5, this);
}

void KB::DynamicDictionarySingleCursor::set_to_root(KB::DynamicDictionarySingleCursor *this, const KB::DynamicDictionarySingle *a2)
{
  uint64_t RootCursor;
  const void *v5;

  KB::DynamicDictionaryCursor::set_to_root(this, a2);
  if ((*(uint64_t (**)(const KB::DynamicDictionarySingle *, _QWORD))(*(_QWORD *)a2 + 88))(a2, 0))
  {
    (*(void (**)(const KB::DynamicDictionarySingle *, _QWORD))(*(_QWORD *)a2 + 88))(a2, 0);
    RootCursor = LXLexiconCreateRootCursor();
  }
  else
  {
    RootCursor = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 6);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 6) = RootCursor;
}

double KB::DynamicDictionarySingleCursor::DynamicDictionarySingleCursor(KB::DynamicDictionarySingleCursor *this, const KB::DynamicDictionarySingle *a2)
{
  double result;

  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_QWORD *)this = &off_1EA105288;
  return result;
}

{
  double result;

  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_QWORD *)this = &off_1EA105288;
  return result;
}

double KB::DynamicDictionarySingleCursor::create_invalid_cursor@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v4;
  double result;

  v4 = operator new();
  result = 0.0;
  *(_OWORD *)(v4 + 8) = 0u;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_QWORD *)(v4 + 40) = 0;
  *(_QWORD *)(v4 + 48) = 0;
  *(_QWORD *)v4 = &off_1EA105288;
  *a1 = v4;
  return result;
}

KB::DynamicDictionaryContainerCursor *KB::DynamicDictionaryContainerCursor::DynamicDictionaryContainerCursor(KB::DynamicDictionaryContainerCursor *this, const KB::DynamicDictionaryContainer *a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  char *v8;

  *((_QWORD *)this + 5) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_QWORD *)this = &off_1EA105370;
  v4 = *((_QWORD *)a2 + 14);
  v3 = *((_QWORD *)a2 + 15);
  *((_QWORD *)this + 6) = 0;
  v5 = (_QWORD *)((char *)this + 48);
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  v6 = v3 - v4;
  if (v3 != v4)
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](v5, v6 >> 3);
    v7 = (_QWORD *)*((_QWORD *)this + 7);
    v8 = (char *)v7 + v6;
    do
    {
      *v7++ = 0;
      v6 -= 8;
    }
    while (v6);
    *((_QWORD *)this + 7) = v8;
  }
  return this;
}

void KB::DynamicDictionaryContainerCursor::create_root_cursor(KB::DynamicDictionaryContainerCursor *this@<X0>, KB::DynamicDictionaryContainerCursor **a2@<X8>)
{
  KB::DynamicDictionaryContainerCursor *v5;
  KB::DynamicDictionaryContainerCursor *v6;

  v5 = (KB::DynamicDictionaryContainerCursor *)operator new();
  v6 = KB::DynamicDictionaryContainerCursor::DynamicDictionaryContainerCursor(v5, this);
  *a2 = v6;
  KB::DynamicDictionaryContainerCursor::set_to_root(v6, this);
}

void KB::DynamicDictionaryContainerCursor::set_to_root(KB::DynamicDictionaryContainerCursor *this, const KB::DynamicDictionaryContainer *a2)
{
  unint64_t v4;
  uint64_t RootCursor;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  const void *v9;

  KB::DynamicDictionaryCursor::set_to_root(this, a2);
  if (*((_QWORD *)a2 + 15) != *((_QWORD *)a2 + 14))
  {
    v4 = 0;
    do
    {
      if ((*(uint64_t (**)(const KB::DynamicDictionaryContainer *, unint64_t))(*(_QWORD *)a2 + 88))(a2, v4))
      {
        RootCursor = LXLexiconCreateRootCursor();
        v6 = *((_QWORD *)this + 6);
        v7 = *(const void **)(v6 + 8 * v4);
        if (v7)
          CFRelease(v7);
        *(_QWORD *)(v6 + 8 * v4) = RootCursor;
      }
      else
      {
        v8 = *((_QWORD *)this + 6);
        v9 = *(const void **)(v8 + 8 * v4);
        if (v9)
          CFRelease(v9);
        *(_QWORD *)(v8 + 8 * v4) = 0;
      }
      ++v4;
    }
    while (v4 < (uint64_t)(*((_QWORD *)a2 + 15) - *((_QWORD *)a2 + 14)) >> 3);
  }
}

KB::DynamicDictionaryContainerCursor *KB::DynamicDictionaryContainerCursor::create_invalid_cursor@<X0>(KB::DynamicDictionaryContainerCursor *this@<X0>, KB::DynamicDictionaryContainerCursor **a2@<X8>)
{
  KB::DynamicDictionaryContainerCursor *v5;
  KB::DynamicDictionaryContainerCursor *result;

  v5 = (KB::DynamicDictionaryContainerCursor *)operator new();
  result = KB::DynamicDictionaryContainerCursor::DynamicDictionaryContainerCursor(v5, this);
  *a2 = result;
  return result;
}

__int128 *lmContextOrEmpty(TIContextTokens *a1)
{
  TIContextTokens *v1;
  unsigned __int8 v2;
  __int128 *v3;
  KB::LanguageModelContext *v5;

  v1 = a1;
  if ((v2 & 1) == 0)
  {
    if ((_DWORD)v5)
    {
      KB::LanguageModelContext::LanguageModelContext(v5);
      __cxa_atexit((void (*)(void *))KB::LanguageModelContext::~LanguageModelContext, &lmContextOrEmpty(TIContextTokens const*)::emptyContext, &dword_1DA6F2000);
    }
  }
  if (v1)
    v3 = -[TIContextTokens lmContext](v1, "lmContext");
  else
    v3 = &lmContextOrEmpty(TIContextTokens const*)::emptyContext;

  return v3;
}

uint64_t KB::LanguageModelContext::LanguageModelContext(KB::LanguageModelContext *this)
{
  uint64_t result;

  xmmword_1EDAEE038 = 0u;
  unk_1EDAEE048 = 0u;
  lmContextOrEmpty(TIContextTokens const*)::emptyContext = 0u;
  unk_1EDAEE028 = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&unk_1EDAEE058);
  result = language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&unk_1EDAEE060);
  qword_1EDAEE068 = 0;
  unk_1EDAEE070 = 0;
  qword_1EDAEE078 = 0;
  return result;
}

void KB::LanguageModelContext::~LanguageModelContext(KB::LanguageModelContext *this)
{
  void *v2;
  void **v3;

  v3 = (void **)((char *)this + 80);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v3);
  language_modeling::v1::LinguisticContext::~LinguisticContext((KB::LanguageModelContext *)((char *)this + 72));
  language_modeling::v1::LinguisticContext::~LinguisticContext((KB::LanguageModelContext *)((char *)this + 64));
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this);
}

uint64_t __Block_byref_object_copy__16096(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(result + 48) = v2;
  return result;
}

unsigned int *__Block_byref_object_dispose__16097(uint64_t a1)
{
  unsigned int *result;

  result = *(unsigned int **)(a1 + 48);
  if (result)
    return WTF::RefCounted<KB::DictionaryContainer>::deref(result);
  return result;
}

uint64_t __copy_helper_block_a8_80c43_ZTSNSt3__18weak_ptrIN2KB13LanguageModelEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(result + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(result + 88) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_a8_80c43_ZTSNSt3__18weak_ptrIN2KB13LanguageModelEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 88);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

BOOL onlyChangesCaseDiacriticsPunctuation(NSString *a1, NSString *a2)
{
  NSString *v3;
  NSString *v4;
  void *v5;
  void *v6;
  _BOOL8 v7;

  v3 = a2;
  v4 = a1;
  -[NSString _stringByReplacingCharactersInSet:withString:](v4, "_stringByReplacingCharactersInSet:withString:", CFCharacterSetGetPredefined(kCFCharacterSetPunctuation), &stru_1EA1081D0);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  -[NSString _stringByReplacingCharactersInSet:withString:](v3, "_stringByReplacingCharactersInSet:withString:", CFCharacterSetGetPredefined(kCFCharacterSetPunctuation), &stru_1EA1081D0);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v7 = objc_msgSend(v5, "compare:options:", v6, 129) == 0;
  return v7;
}

uint64_t SensorKitLibrary()
{
  uint64_t v0;
  void *v2;

  if (SensorKitLibraryCore_frameworkLibrary)
    return SensorKitLibraryCore_frameworkLibrary;
  SensorKitLibraryCore_frameworkLibrary = _sl_dlopen();
  v0 = SensorKitLibraryCore_frameworkLibrary;
  if (!SensorKitLibraryCore_frameworkLibrary)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

uint64_t genConvert(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v9;
  int v10;
  int v12;
  int v13;

  (**(void (***)(uint64_t))a1)(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a3 + 80))(a3))
    return 0;
  v12 = 0;
  v9 = 1;
  do
  {
    v13 = 0;
    if (!(*(unsigned int (**)(uint64_t, uint64_t, int *, int *))(*(_QWORD *)a1 + 16))(a1, a3, &v13, &v12))
      break;
    v10 = v13;
    if (v13 != -1)
    {
      if (*(_DWORD *)(VnCharsetLibObj + 100))
      {
        if ((v13 & 1) == 0 && (v13 - 0x10000) < 0xBA)
          v10 = v13 + 1;
LABEL_15:
        v13 = v10;
      }
      else if (*(_DWORD *)(VnCharsetLibObj + 96))
      {
        v10 = v13 & ~((v13 - 0x10000) < 0xBA);
        goto LABEL_15;
      }
      if (*(_DWORD *)(VnCharsetLibObj + 104))
      {
        if ((v10 - 0x10000) <= 0xD4)
          v10 = StdVnRootChar[v10 - 0x10000] + 0x10000;
        v13 = v10;
      }
      v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 24))(a2, a4);
    }
  }
  while (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a3 + 80))(a3));
  if (v9)
    return 0;
  else
    return 5;
}

uint64_t VnConvert(int a1, int a2, _DWORD *a3, uint64_t a4, int *a5, int *a6)
{
  int v6;
  uint64_t result;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  int v19;
  _BOOL4 v20;
  int v21;
  BOOL v22;
  _QWORD v23[3];
  int v24;
  int v25;
  int v26;
  void (**v27)(StringBIStream *__hidden);
  _BOOL4 v28;
  _DWORD *v29;
  _DWORD *v30;
  int v31;
  int v32;
  int v33;

  v6 = *a5;
  if (*a5 < -1)
    return 0xFFFFFFFFLL;
  v13 = *a6;
  CVnCharsetLib::getVnCharset((CVnCharsetLib *)VnCharsetLibObj, a1);
  v15 = v14;
  CVnCharsetLib::getVnCharset((CVnCharsetLib *)VnCharsetLibObj, a2);
  if (v15)
    v17 = v16 == 0;
  else
    v17 = 1;
  if (v17)
    return 2;
  v18 = v16;
  v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 32))(v15);
  v29 = a3;
  v30 = a3;
  v27 = &off_1EA0FFA98;
  v31 = v6;
  v32 = v6;
  if (v6 == -1)
  {
    if (v19 == 4)
    {
      v22 = *a3 == 4;
    }
    else
    {
      if (v19 == 2)
        v21 = *(unsigned __int16 *)a3;
      else
        v21 = *(unsigned __int8 *)a3;
      v22 = v21 == 0;
    }
    v20 = v22;
  }
  else
  {
    v20 = v6 < 1;
  }
  v28 = v20;
  v33 = 0;
  v23[0] = &off_1EA0FFB08;
  v23[1] = a4;
  v23[2] = a4;
  v24 = 0;
  v25 = v13;
  v26 = 0;
  result = genConvert(v15, v18, (uint64_t)&v27, (uint64_t)v23);
  *a6 = v24;
  *a5 = v32;
  return result;
}

char *VnConvErrMsg(unsigned int a1)
{
  int v1;

  if (a1 > 6)
    v1 = 1;
  else
    v1 = a1;
  return ErrTable[v1];
}

uint64_t KB::CandidateFilterConfiguration::CandidateFilterConfiguration(uint64_t a1, int a2, int a3, KB::String *this, __int128 *a5, int a6, uint64_t a7)
{
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 8) = 0x100000;
  *(_WORD *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  KB::String::operator=(a1 + 8, this);
  v11 = *a5;
  *(_OWORD *)(a1 + 56) = a5[1];
  *(_OWORD *)(a1 + 40) = v11;
  v12 = a5[2];
  v13 = a5[3];
  v14 = a5[4];
  *(_OWORD *)(a1 + 120) = a5[5];
  *(_OWORD *)(a1 + 104) = v14;
  *(_OWORD *)(a1 + 88) = v13;
  *(_OWORD *)(a1 + 72) = v12;
  *(_DWORD *)(a1 + 136) = a6;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 144) = *(_OWORD *)a7;
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a7 + 16);
  *(_QWORD *)a7 = 0;
  *(_QWORD *)(a7 + 8) = 0;
  *(_QWORD *)(a7 + 16) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 184) = 0x10000;
  *(_BYTE *)(a1 + 188) = 0;
  return a1;
}

{
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 8) = 0x100000;
  *(_WORD *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  KB::String::operator=(a1 + 8, this);
  v11 = *a5;
  *(_OWORD *)(a1 + 56) = a5[1];
  *(_OWORD *)(a1 + 40) = v11;
  v12 = a5[2];
  v13 = a5[3];
  v14 = a5[4];
  *(_OWORD *)(a1 + 120) = a5[5];
  *(_OWORD *)(a1 + 104) = v14;
  *(_OWORD *)(a1 + 88) = v13;
  *(_OWORD *)(a1 + 72) = v12;
  *(_DWORD *)(a1 + 136) = a6;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 144) = *(_OWORD *)a7;
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a7 + 16);
  *(_QWORD *)a7 = 0;
  *(_QWORD *)(a7 + 8) = 0;
  *(_QWORD *)(a7 + 16) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 184) = 0x10000;
  *(_BYTE *)(a1 + 188) = 0;
  return a1;
}

unsigned int *KB::CandidateFilterConfiguration::word_suggestion_policy@<X0>(unsigned int *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  char *v3;
  int v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;

  v2 = *this;
  if (*((_BYTE *)this + 184))
  {
    if (v2 >= 7)
      return this;
    v3 = (char *)&unk_1DA90FA08 + 4 * v2;
    v4 = dword_1DA90FA24[v2];
    v5 = &unk_1DA90FA60;
  }
  else
  {
    if (v2 >= 7)
      return this;
    v3 = (char *)&unk_1DA90F9B0 + 4 * v2;
    v4 = 402653186;
    v5 = &unk_1DA90F9D0;
  }
  v6 = dword_1DA90FA40[(int)v2];
  v7 = v5[(int)v2];
  *(_QWORD *)a2 = *(unsigned int *)v3;
  *(_DWORD *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 12) = v6;
  *(_QWORD *)(a2 + 16) = v7;
  return this;
}

void TI::CP::SearchParameters::set_values_from_dictionary(TI::CP::SearchParameters *this, CFDictionaryRef theDict)
{
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)TI::CP::SearchParameters::set_values_from_dictionary(__CFDictionary const*)::$_0::__invoke, this);
}

void TI::CP::SearchParameters::set_values_from_dictionary(__CFDictionary const*)::$_0::__invoke(const __CFString *a1, const void *a2, char *a3)
{
  void *v6;
  int v7;
  const char *v8;
  __int16 v9;
  const __CFString *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (CFStringCompare(a1, CFSTR("GeometryWeight"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    CFNumberGetValue((CFNumberRef)a2, kCFNumberDoubleType, a3);
    return;
  }
  if (CFStringCompare(a1, CFSTR("LanguageWeight"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 8;
LABEL_36:
    CFNumberGetValue((CFNumberRef)a2, kCFNumberDoubleType, v6);
    return;
  }
  if (CFStringCompare(a1, CFSTR("PathDeviationPower"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 16;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("PathDeviationWeight"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 24;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("KeyDeviationPower"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 32;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("KeyDeviationWeight"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 40;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("FirstKeyDeviationWeight"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 48;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("InflectionPointKeyDeviationWeight"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 56;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("FarKeyDistance"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 64;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("SkippedKeyCost"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 72;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("SkippedInflectionPointCost"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 96;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("OvershootPower"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 80;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("OvershootWeight"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 88;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("TranspositionCost"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 128;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("FirstKeyPredictionCost"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 144;
    goto LABEL_36;
  }
  if (CFStringCompare(a1, CFSTR("NonFirstKeyPredictionCost"), 0) == kCFCompareEqualTo)
  {
    CFGetTypeID(a2);
    CFBooleanGetTypeID();
    v6 = a3 + 152;
    goto LABEL_36;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v7 = 136315394;
    v8 = "operator()";
    v9 = 2112;
    v10 = a1;
    _os_log_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s  SearchParameters initializer: unhandled search parameter %@", (uint8_t *)&v7, 0x16u);
  }
}

TI::CP::SearchParameters *TI::CP::SearchParameters::SearchParameters(TI::CP::SearchParameters *this, CFDictionaryRef theDict)
{
  *(_OWORD *)this = xmmword_1DA911160;
  *((_OWORD *)this + 1) = xmmword_1DA911170;
  *((_OWORD *)this + 2) = xmmword_1DA911180;
  *((_OWORD *)this + 3) = xmmword_1DA911190;
  *((_OWORD *)this + 4) = xmmword_1DA9111A0;
  *((_OWORD *)this + 5) = xmmword_1DA9111B0;
  *((_OWORD *)this + 6) = xmmword_1DA9111C0;
  *((_OWORD *)this + 7) = xmmword_1DA9110E0;
  *((_QWORD *)this + 16) = 0x403E000000000000;
  *((_QWORD *)this + 17) = 1;
  __asm { FMOV            V0.2D, #10.0 }
  *((_OWORD *)this + 9) = _Q0;
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)TI::CP::SearchParameters::set_values_from_dictionary(__CFDictionary const*)::$_0::__invoke, this);
  return this;
}

{
  *(_OWORD *)this = xmmword_1DA911160;
  *((_OWORD *)this + 1) = xmmword_1DA911170;
  *((_OWORD *)this + 2) = xmmword_1DA911180;
  *((_OWORD *)this + 3) = xmmword_1DA911190;
  *((_OWORD *)this + 4) = xmmword_1DA9111A0;
  *((_OWORD *)this + 5) = xmmword_1DA9111B0;
  *((_OWORD *)this + 6) = xmmword_1DA9111C0;
  *((_OWORD *)this + 7) = xmmword_1DA9110E0;
  *((_QWORD *)this + 16) = 0x403E000000000000;
  *((_QWORD *)this + 17) = 1;
  __asm { FMOV            V0.2D, #10.0 }
  *((_OWORD *)this + 9) = _Q0;
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)TI::CP::SearchParameters::set_values_from_dictionary(__CFDictionary const*)::$_0::__invoke, this);
  return this;
}

void TI::CP::Search::~Search(TI::CP::Search *this)
{
  TI::CP::Search::~Search(this);
  JUMPOUT(0x1DF0A2144);
}

{
  void *v2;
  void **v3;
  void **v4;
  void *v5;
  void **v6;
  void **v7;
  void *v8;
  void *v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  void **v23;

  *(_QWORD *)this = &off_1EA1055A8;
  v2 = (void *)*((_QWORD *)this + 51);
  if (v2 && *((_BYTE *)this + 406) == 1)
    free(v2);
  v3 = (void **)*((_QWORD *)this + 47);
  if (v3)
  {
    v4 = (void **)*((_QWORD *)this + 48);
    v5 = (void *)*((_QWORD *)this + 47);
    if (v4 != v3)
    {
      do
      {
        v4 -= 3;
        v23 = v4;
        std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>::__destroy_vector::operator()[abi:nn180100](&v23);
      }
      while (v4 != v3);
      v5 = (void *)*((_QWORD *)this + 47);
    }
    *((_QWORD *)this + 48) = v3;
    operator delete(v5);
  }
  v23 = (void **)((char *)this + 352);
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v23);
  v6 = (void **)*((_QWORD *)this + 41);
  if (v6)
  {
    v7 = (void **)*((_QWORD *)this + 42);
    v8 = (void *)*((_QWORD *)this + 41);
    if (v7 != v6)
    {
      do
      {
        v7 -= 3;
        v23 = v7;
        std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v23);
      }
      while (v7 != v6);
      v8 = (void *)*((_QWORD *)this + 41);
    }
    *((_QWORD *)this + 42) = v6;
    operator delete(v8);
  }
  v23 = (void **)((char *)this + 288);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v23);
  language_modeling::v1::LinguisticContext::~LinguisticContext((TI::CP::Search *)((char *)this + 280));
  language_modeling::v1::LinguisticContext::~LinguisticContext((TI::CP::Search *)((char *)this + 272));
  v9 = (void *)*((_QWORD *)this + 28);
  if (v9)
  {
    *((_QWORD *)this + 29) = v9;
    operator delete(v9);
  }
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 208);
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 192);
  v10 = (unsigned int *)*((_QWORD *)this + 23);
  if (v10)
  {
    v11 = v10 + 2;
    v12 = atomic_load(v10 + 2);
    if (v12 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v10 + 8))(v10);
    }
    else
    {
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 - 1, v11));
    }
  }
  v14 = (unsigned int *)*((_QWORD *)this + 22);
  if (v14)
  {
    v15 = v14 + 2;
    v16 = atomic_load(v14 + 2);
    if (v16 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v14 + 40))(v14);
    }
    else
    {
      do
        v17 = __ldaxr(v15);
      while (__stlxr(v17 - 1, v15));
    }
  }
  v18 = (void *)*((_QWORD *)this + 16);
  if (v18)
  {
    *((_QWORD *)this + 17) = v18;
    operator delete(v18);
  }
  v19 = (void *)*((_QWORD *)this + 13);
  if (v19)
  {
    *((_QWORD *)this + 14) = v19;
    operator delete(v19);
  }
  v20 = (void *)*((_QWORD *)this + 10);
  if (v20)
  {
    *((_QWORD *)this + 11) = v20;
    operator delete(v20);
  }
  v21 = (void *)*((_QWORD *)this + 7);
  if (v21)
  {
    *((_QWORD *)this + 8) = v21;
    operator delete(v21);
  }
  *(_QWORD *)this = off_1EA1056B8;
  v22 = *((_QWORD *)this + 1);
  if (v22)
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v22);
}

uint64_t TI::CP::Search::get_recognizer_type(TI::CP::Search *this)
{
  return 0;
}

uint64_t TI::CP::Search::recognitionSources(TI::CP::Search *this)
{
  return 1;
}

void TI::CP::Search::add_touch(TI::CP::Search *this, int a2, CGFloat a3, CGFloat a4, double a5, double a6)
{
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  char **v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  int v25;
  _QWORD v26[5];
  CGPoint v27;

  if (!a2 && *((_BYTE *)this + 152))
    (*(void (**)(TI::CP::Search *))(*(_QWORD *)this + 56))(this);
  if (*((_QWORD *)this + 41) == *((_QWORD *)this + 42))
    TI::CP::Search::initialize_search(this);
  v27.x = a3;
  v27.y = a4;
  v12 = TI::CP::PathResampler::append_and_resample((TI::CP::Search *)((char *)this + 16), v27, a5, a6, 0.0);
  if (a2 == 2)
  {
    v13 = TI::CP::PathResampler::finalize((TI::CP::Search *)((char *)this + 16));
    if (v13 < v12)
      v12 = v13;
  }
  v25 = a2;
  v14 = v12 + 1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 42) - *((_QWORD *)this + 41)) >> 3) > v14)
  {
    std::vector<std::vector<std::shared_ptr<TI::CP::SearchNode const>>>::resize((uint64_t *)this + 41, v14);
    std::vector<std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>>::resize((uint64_t *)this + 47, v12);
  }
  v15 = (_QWORD *)((char *)this + 344);
  while (1)
  {
    v17 = *((_QWORD *)this + 41);
    v16 = (_QWORD *)*((_QWORD *)this + 42);
    v18 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v16 - v17) >> 3);
    if (v18 >= 1 - 0x5555555555555555 * ((uint64_t)(*((_QWORD *)this + 8) - *((_QWORD *)this + 7)) >> 4))
      break;
    if ((unint64_t)v16 >= *v15)
    {
      v20 = v18 + 1;
      if (v18 + 1 > 0xAAAAAAAAAAAAAAALL)
        abort();
      v21 = 0xAAAAAAAAAAAAAAABLL * ((*v15 - v17) >> 3);
      if (2 * v21 > v20)
        v20 = 2 * v21;
      if (v21 >= 0x555555555555555)
        v22 = 0xAAAAAAAAAAAAAAALL;
      else
        v22 = v20;
      v26[4] = (char *)this + 344;
      if (v22)
        v22 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v22);
      else
        v23 = 0;
      v24 = (_QWORD *)(v22 + 24 * v18);
      v26[0] = v22;
      v26[1] = v24;
      v26[3] = v22 + 24 * v23;
      *v24 = 0;
      v24[1] = 0;
      v24[2] = 0;
      v26[2] = v24 + 3;
      std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer((_QWORD *)this + 41, v26);
      v19 = (char **)*((_QWORD *)this + 42);
      std::__split_buffer<std::vector<std::shared_ptr<TI::CP::SearchNode const>>>::~__split_buffer((uint64_t)v26);
    }
    else
    {
      *v16 = 0;
      v16[1] = 0;
      v19 = (char **)(v16 + 3);
      v16[2] = 0;
    }
    *((_QWORD *)this + 42) = v19;
    TI::CP::Search::step_search((uint64_t)this, (const TI::CP::SearchNode *)(v18 - 1), 0, v19 - 3);
  }
  *((_DWORD *)this + 42) = v25;
}

uint64_t TI::CP::Search::touch_stage(TI::CP::Search *this)
{
  return *((unsigned int *)this + 42);
}

double TI::CP::Search::last_touch(TI::CP::Search *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 14);
  if (*((_QWORD *)this + 13) == v1)
    v2 = MEMORY[0x1E0C9D538];
  else
    v2 = v1 - 48;
  return *(double *)v2;
}

void TI::CP::Search::reset_path(TI::CP::Search *this)
{
  void **v2;
  void **v3;
  uint64_t i;
  uint64_t v5;
  void **v6;
  void **v7;
  void **v8;

  *((_QWORD *)this + 8) = *((_QWORD *)this + 7);
  *((_QWORD *)this + 11) = *((_QWORD *)this + 10);
  *((_QWORD *)this + 14) = *((_QWORD *)this + 13);
  *((_QWORD *)this + 17) = *((_QWORD *)this + 16);
  *((_BYTE *)this + 152) = 0;
  *((_DWORD *)this + 39) = 0;
  *((_DWORD *)this + 40) = 0;
  v2 = (void **)*((_QWORD *)this + 41);
  v3 = (void **)*((_QWORD *)this + 42);
  while (v3 != v2)
  {
    v3 -= 3;
    v8 = v3;
    std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v8);
  }
  *((_QWORD *)this + 42) = v2;
  v5 = *((_QWORD *)this + 44);
  for (i = *((_QWORD *)this + 45);
        i != v5;
  *((_QWORD *)this + 45) = v5;
  v6 = (void **)*((_QWORD *)this + 47);
  v7 = (void **)*((_QWORD *)this + 48);
  while (v7 != v6)
  {
    v7 -= 3;
    v8 = v7;
    std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>::__destroy_vector::operator()[abi:nn180100](&v8);
  }
  *((_QWORD *)this + 48) = v6;
  *((_DWORD *)this + 42) = 7;
}

unsigned int *TI::CP::Search::set_typing_model(uint64_t a1, uint64_t *a2)
{
  unsigned int *result;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;

  result = *(unsigned int **)(a1 + 176);
  v4 = *a2;
  *a2 = 0;
  *(_QWORD *)(a1 + 176) = v4;
  if (result)
  {
    v5 = result + 2;
    v6 = atomic_load(result + 2);
    if (v6 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)result + 40))(result);
    }
    else
    {
      do
        v7 = __ldaxr(v5);
      while (__stlxr(v7 - 1, v5));
    }
  }
  return result;
}

double TI::CP::Search::path_length(TI::CP::Search *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 14);
  if (*((_QWORD *)this + 13) == v1)
    return 0.0;
  else
    return *(double *)(v1 - 16);
}

void TI::CP::Search::generate_candidates(uint64_t a1, uint64_t *a2, int a3)
{
  TI::CP::PathResampler *v5;
  __int128 v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char **v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  const TI::CP::SearchNode *v21;
  uint64_t i;
  uint64_t v23;
  double **v24;
  double **j;
  double *v26;
  unsigned int *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  __int128 v33;
  unsigned int v34;
  TI::CP::PathResampler *v36;
  char **v37;
  unsigned int *v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  void *v42[3];
  std::vector<unsigned int> v43;
  void *v44[3];
  std::vector<unsigned int> __p;
  uint64_t v46;
  int v47;
  _QWORD v48[6];

  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56)) >> 4) >= 2)
  {
    v5 = (TI::CP::PathResampler *)(a1 + 16);
    v6 = *(_OWORD *)(a1 + 32);
    v39 = *(_OWORD *)(a1 + 16);
    v40 = v6;
    v41 = *(_QWORD *)(a1 + 48);
    v37 = (char **)(a1 + 56);
    std::vector<TI::CP::PathSample>::vector(v42, a1 + 56);
    std::vector<unsigned int>::vector(&v43, (const std::vector<unsigned int> *)(a1 + 80));
    std::vector<TI::CP::PathSample>::vector(v44, a1 + 104);
    std::vector<unsigned int>::vector(&__p, (const std::vector<unsigned int> *)(a1 + 128));
    v46 = *(_QWORD *)(a1 + 152);
    v47 = *(_DWORD *)(a1 + 160);
    v36 = v5;
    v7 = TI::CP::PathResampler::finalize(v5);
    v8 = -1431655765 * ((*(_QWORD *)(a1 + 336) - *(_QWORD *)(a1 + 328)) >> 3) - 1;
    if (v7 < v8)
    {
      v9 = v7;
      std::vector<std::vector<std::shared_ptr<TI::CP::SearchNode const>>>::resize((uint64_t *)(a1 + 328), v7 + 1);
      std::vector<std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>>::resize((uint64_t *)(a1 + 376), v9);
      v8 = v9;
    }
    v34 = v8;
    v10 = (_QWORD *)(a1 + 344);
    while (1)
    {
      v12 = *(_QWORD *)(a1 + 328);
      v11 = *(_QWORD **)(a1 + 336);
      v13 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v11 - v12) >> 3);
      v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56)) >> 4);
      if (v13 - 1 >= v14 - 1)
        break;
      if ((unint64_t)v11 >= *v10)
      {
        v16 = v13 + 1;
        if (v13 + 1 > 0xAAAAAAAAAAAAAAALL)
          abort();
        v17 = 0xAAAAAAAAAAAAAAABLL * ((*v10 - v12) >> 3);
        if (2 * v17 > v16)
          v16 = 2 * v17;
        if (v17 >= 0x555555555555555)
          v18 = 0xAAAAAAAAAAAAAAALL;
        else
          v18 = v16;
        v48[4] = a1 + 344;
        if (v18)
          v18 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v18);
        else
          v19 = 0;
        v20 = (_QWORD *)(v18 + 24 * v13);
        v48[0] = v18;
        v48[1] = v20;
        v48[3] = v18 + 24 * v19;
        *v20 = 0;
        v20[1] = 0;
        v20[2] = 0;
        v48[2] = v20 + 3;
        std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer((_QWORD *)(a1 + 328), v48);
        v15 = *(char ***)(a1 + 336);
        std::__split_buffer<std::vector<std::shared_ptr<TI::CP::SearchNode const>>>::~__split_buffer((uint64_t)v48);
      }
      else
      {
        *v11 = 0;
        v11[1] = 0;
        v15 = (char **)(v11 + 3);
        v11[2] = 0;
      }
      *(_QWORD *)(a1 + 336) = v15;
      TI::CP::Search::step_search(a1, (const TI::CP::SearchNode *)(v13 - 1), 0, v15 - 3);
    }
    v21 = (const TI::CP::SearchNode *)(v14 - 1);
    v23 = *(_QWORD *)(a1 + 352);
    for (i = *(_QWORD *)(a1 + 360);
          i != v23;
    *(_QWORD *)(a1 + 360) = v23;
    TI::CP::Search::step_search(a1, v21, 1, (char **)(a1 + 352));
    v24 = *(double ***)(a1 + 352);
    for (j = *(double ***)(a1 + 360); v24 != j; v24 += 2)
    {
      if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)*v24 + 8) + 64))(*((_QWORD *)*v24 + 8)))
      {
        v26 = *v24;
        v27 = *(unsigned int **)(a1 + 184);
        v38 = v27;
        if (v27)
        {
          v28 = v27 + 2;
          do
            v29 = __ldaxr(v28);
          while (__stlxr(v29 + 1, v28));
        }
        TI::CP::SearchNode::generate_candidates(v26, &v38, a1 + 208, a2, a3);
        if (v38)
        {
          v30 = v38 + 2;
          v31 = atomic_load(v38 + 2);
          if (v31 == 1)
          {
            (*(void (**)(void))(*(_QWORD *)v38 + 8))();
          }
          else
          {
            do
              v32 = __ldaxr(v30);
            while (__stlxr(v32 - 1, v30));
          }
        }
      }
    }
    std::vector<std::vector<std::shared_ptr<TI::CP::SearchNode const>>>::resize((uint64_t *)(a1 + 328), v34 + 1);
    std::vector<std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>>::resize((uint64_t *)(a1 + 376), v34);
    v33 = v40;
    *(_OWORD *)v36 = v39;
    *((_OWORD *)v36 + 1) = v33;
    *((_BYTE *)v36 + 32) = v41;
    TI::CP::Path::operator=(v37, (const void **)v42);
    TI::CP::Path::operator=((char **)(a1 + 104), (const void **)v44);
    *(_QWORD *)(a1 + 152) = v46;
    *(_DWORD *)(a1 + 160) = v47;
    if (__p.__begin_)
    {
      __p.__end_ = __p.__begin_;
      operator delete(__p.__begin_);
    }
    if (v44[0])
    {
      v44[1] = v44[0];
      operator delete(v44[0]);
    }
    if (v43.__begin_)
    {
      v43.__end_ = v43.__begin_;
      operator delete(v43.__begin_);
    }
    if (v42[0])
    {
      v42[1] = v42[0];
      operator delete(v42[0]);
    }
  }
}

_QWORD *TI::CP::Search::set_candidate_refinery(uint64_t a1, uint64_t *a2)
{
  return std::shared_ptr<KB::LanguageModel>::operator=[abi:nn180100]((_QWORD *)(a1 + 192), *a2, a2[1]);
}

uint64_t TI::CP::Search::set_context(TI::CP::Search *this, const KB::LanguageModelContext *a2)
{
  return KB::LanguageModelContext::operator=((uint64_t)this + 208, (uint64_t *)a2);
}

KB::String *TI::CP::Search::set_input_stem(TI::CP::Search *this, const KB::String *a2)
{
  return KB::String::operator=((TI::CP::Search *)((char *)this + 400), a2);
}

double TI::CP::Search::key_layout_did_update(TI::Favonius::KeyboardLayout **this)
{
  double result;

  result = TI::Favonius::KeyboardLayout::median_key_half_width(this[1]);
  *((double *)this + 39) = result;
  *((double *)this + 40) = 1.0 / result;
  return result;
}

void std::vector<std::vector<std::shared_ptr<TI::CP::SearchNode const>>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  void **v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  void **v11;
  void **v12;
  uint64_t v13;
  size_t v14;
  void **v15;
  size_t v16;
  void **v17[5];

  v3 = *a1;
  v4 = (void **)a1[1];
  v5 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *a1) >> 3);
  v6 = a2 - v5;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      v15 = (void **)(v3 + 24 * a2);
      while (v4 != v15)
      {
        v4 -= 3;
        v17[0] = v4;
        std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](v17);
      }
      a1[1] = (uint64_t)v15;
    }
  }
  else
  {
    v7 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v7 - (uint64_t)v4) >> 3) >= v6)
    {
      v16 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero((void *)a1[1], v16);
      a1[1] = (uint64_t)v4 + v16;
    }
    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL)
        abort();
      v17[4] = (void **)(a1 + 2);
      v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v3) >> 3);
      v9 = 2 * v8;
      if (2 * v8 <= a2)
        v9 = a2;
      if (v8 >= 0x555555555555555)
        v10 = 0xAAAAAAAAAAAAAAALL;
      else
        v10 = v9;
      v11 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v10);
      v12 = &v11[3 * v5];
      v17[0] = v11;
      v17[1] = v12;
      v17[3] = &v11[3 * v13];
      v14 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(v12, v14);
      v17[2] = (void **)((char *)v12 + v14);
      std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(a1, v17);
      std::__split_buffer<std::vector<std::shared_ptr<TI::CP::SearchNode const>>>::~__split_buffer((uint64_t)v17);
    }
  }
}

void std::vector<std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  void **v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  void **v11;
  void **v12;
  uint64_t v13;
  size_t v14;
  void **v15;
  size_t v16;
  void **v17[5];

  v3 = *a1;
  v4 = (void **)a1[1];
  v5 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *a1) >> 3);
  v6 = a2 - v5;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      v15 = (void **)(v3 + 24 * a2);
      while (v4 != v15)
      {
        v4 -= 3;
        v17[0] = v4;
        std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>::__destroy_vector::operator()[abi:nn180100](v17);
      }
      a1[1] = (uint64_t)v15;
    }
  }
  else
  {
    v7 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v7 - (uint64_t)v4) >> 3) >= v6)
    {
      v16 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero((void *)a1[1], v16);
      a1[1] = (uint64_t)v4 + v16;
    }
    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL)
        abort();
      v17[4] = (void **)(a1 + 2);
      v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v3) >> 3);
      v9 = 2 * v8;
      if (2 * v8 <= a2)
        v9 = a2;
      if (v8 >= 0x555555555555555)
        v10 = 0xAAAAAAAAAAAAAAALL;
      else
        v10 = v9;
      v11 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v10);
      v12 = &v11[3 * v5];
      v17[0] = v11;
      v17[1] = v12;
      v17[3] = &v11[3 * v13];
      v14 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(v12, v14);
      v17[2] = (void **)((char *)v12 + v14);
      std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(a1, v17);
      std::__split_buffer<std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>>::~__split_buffer((uint64_t)v17);
    }
  }
}

uint64_t std::__split_buffer<std::vector<std::shared_ptr<TI::CP::SearchNode const>>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void **v4;
  void **v6;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = (void **)(i - 24);
    *(_QWORD *)(a1 + 16) = v4;
    v6 = v4;
    std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v6);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void TI::CP::Search::step_search(uint64_t a1, const TI::CP::SearchNode *a2, int a3, char **a4)
{
  uint64_t v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  uint64_t v12;
  unint64_t n128_u64;
  TI::CP::SearchNode **v14;
  char v15;
  char v16;
  TI::CP::SearchNode *v17;
  TI::CP::SearchNode *v18;
  unint64_t *v19;
  unint64_t v20;
  unsigned int v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  int has_extensions;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  std::__shared_weak_count *v36;
  std::__shared_weak_count *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  _OWORD *v46;
  uint64_t v47;
  unint64_t v48;
  __int128 v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t v53;
  char *v54;
  _QWORD *v55;
  _QWORD *v56;
  char *v57;
  __int128 v58;
  int64x2_t v59;
  char *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  std::__shared_weak_count *v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t v70;
  unint64_t *v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t *v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  _OWORD *v78;
  uint64_t v79;
  unint64_t v80;
  __int128 v81;
  uint64_t v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  char *v86;
  _QWORD *v87;
  _QWORD *v88;
  char *v89;
  __int128 v90;
  int64x2_t v91;
  char *v92;
  std::__shared_weak_count *v93;
  TI::CP::SearchNode *v94;
  unint64_t *p_shared_owners;
  unint64_t v96;
  std::__shared_weak_count *v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t *v100;
  unint64_t v101;
  unint64_t *v102;
  unint64_t v103;
  std::__shared_weak_count *v104;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v106;
  unint64_t *p_shared_weak_owners;
  unint64_t v108;
  unint64_t v109;
  unint64_t *v110;
  unint64_t v111;
  unint64_t v112;
  uint64_t v113;
  _OWORD *v114;
  uint64_t v115;
  unint64_t v116;
  __int128 v117;
  uint64_t v118;
  unint64_t v119;
  char *v120;
  uint64_t v121;
  char *v122;
  _QWORD *v123;
  _QWORD *v124;
  char *v125;
  __int128 v126;
  int64x2_t v127;
  char *v128;
  std::__shared_weak_count *v129;
  unint64_t *v130;
  unint64_t v131;
  std::__shared_weak_count *v132;
  unint64_t *v133;
  std::__shared_weak_count *v134;
  unint64_t *v135;
  unint64_t v136;
  std::__shared_weak_count *v137;
  unint64_t v138;
  unint64_t *v139;
  unint64_t v140;
  unint64_t v141;
  unint64_t *v142;
  unint64_t v143;
  unint64_t v144;
  uint64_t v145;
  _OWORD *v146;
  uint64_t v147;
  unint64_t v148;
  __int128 v149;
  uint64_t v150;
  unint64_t v151;
  char *v152;
  uint64_t v153;
  char *v154;
  _QWORD *v155;
  _QWORD *v156;
  char *v157;
  __int128 v158;
  int64x2_t v159;
  char *v160;
  TI::CP::SearchNode *v161;
  std::__shared_weak_count *v162;
  unint64_t *v163;
  unint64_t v164;
  __int128 v165;
  std::__shared_weak_count *v166;
  unint64_t *v167;
  std::__shared_weak_count *v168;
  unint64_t *v169;
  unint64_t v170;
  std::__shared_weak_count *v171;
  unint64_t v172;
  unint64_t *v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t *v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  _OWORD *v180;
  uint64_t v181;
  unint64_t v182;
  __int128 v183;
  uint64_t v184;
  unint64_t v185;
  char *v186;
  uint64_t v187;
  char *v188;
  _QWORD *v189;
  _QWORD *v190;
  char *v191;
  __int128 v192;
  int64x2_t v193;
  char *v194;
  TI::CP::SearchNode *v195;
  unint64_t *v196;
  unint64_t v197;
  std::__shared_weak_count *v198;
  unint64_t *v199;
  unint64_t v200;
  std::__shared_weak_count *v201;
  unint64_t *v202;
  unint64_t v203;
  int v204;
  TI::CP::SearchNode *v205;
  std::__shared_weak_count *v206;
  unint64_t *v207;
  unint64_t v208;
  __int128 v209;
  std::__shared_weak_count *v210;
  unint64_t *v211;
  std::__shared_weak_count *v212;
  unint64_t *v213;
  unint64_t v214;
  std::__shared_weak_count *v215;
  unint64_t v216;
  unint64_t *v217;
  unint64_t v218;
  unint64_t v219;
  unint64_t *v220;
  unint64_t v221;
  unint64_t v222;
  uint64_t v223;
  _OWORD *v224;
  uint64_t v225;
  unint64_t v226;
  __int128 v227;
  uint64_t v228;
  unint64_t v229;
  char *v230;
  uint64_t v231;
  char *v232;
  _QWORD *v233;
  _QWORD *v234;
  char *v235;
  __int128 v236;
  int64x2_t v237;
  char *v238;
  char v239;
  TI::CP::SearchNode *v240;
  std::__shared_weak_count *v241;
  unint64_t *v242;
  unint64_t v243;
  unint64_t *v244;
  std::__shared_weak_count *v245;
  unint64_t *v246;
  unint64_t v247;
  std::__shared_weak_count *v248;
  unint64_t *v249;
  unint64_t v250;
  unint64_t *v251;
  uint64_t v252;
  unsigned int v253;
  char **v254;
  _QWORD *v255;
  int v256;
  double v257;
  uint64_t v258;
  int64_t v259;
  __n128 v260;
  int v261;
  std::__shared_weak_count *v262;
  unint64_t *v263;
  unint64_t v264;
  uint64_t v265;
  __int128 v266;
  uint64_t v267;
  uint64_t v268;
  std::__shared_weak_count *v269;
  unint64_t *v270;
  unint64_t v271;
  int64x2_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  unint64_t v276;
  unint64_t v277;
  unint64_t v278;
  char *v279;
  uint64_t v280;
  __n128 *v281;
  _QWORD *v282;
  _QWORD *v283;
  char *v284;
  __int128 v285;
  int64x2_t v286;
  char *v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  uint8x8_t v291;
  unint64_t v292;
  _QWORD *v293;
  _QWORD *v294;
  unint64_t v295;
  _QWORD *v296;
  _QWORD *v297;
  float v298;
  _BOOL8 v299;
  unint64_t v300;
  unint64_t v301;
  size_t v302;
  uint64_t v303;
  _QWORD *v304;
  unint64_t v305;
  __int128 *v306;
  double *v307;
  double v308;
  unint64_t *v309;
  unint64_t v310;
  char *v311;
  uint64_t v312;
  unint64_t v313;
  uint64_t v314;
  unint64_t v315;
  char *v316;
  uint64_t v317;
  __int128 *v318;
  unint64_t *v319;
  unint64_t v320;
  char *v321;
  char *v322;
  char *v323;
  __int128 v324;
  int64x2_t v325;
  char *v326;
  int v327;
  uint64_t v328;
  unint64_t *v329;
  unint64_t v330;
  unsigned int v331;
  std::__shared_weak_count *v332;
  unint64_t *v333;
  unint64_t v334;
  unsigned int *v335;
  unsigned int v336;
  unsigned int v337;
  std::__shared_weak_count *v338;
  unint64_t *v339;
  unint64_t v340;
  unint64_t *v341;
  unint64_t v342;
  std::__shared_weak_count *v343;
  unint64_t *v344;
  unint64_t v345;
  std::__shared_weak_count *v346;
  unint64_t *v347;
  unint64_t v348;
  unint64_t *v349;
  unint64_t v350;
  _QWORD *v351;
  _QWORD *v352;
  void *v353;
  uint64_t v354;
  uint64_t v355;
  void *v356;
  uint64_t v357;
  double *v358;
  int v360;
  __int128 v361;
  __int128 v362;
  __int128 v363;
  __int128 v364;
  __int128 v365;
  __int128 v366;
  __int128 v367;
  __int128 v368;
  __int128 v369;
  __int128 v370;
  __int128 v371;
  char v372;
  int v373;
  char v374;
  __int128 v375;
  uint64_t v376;
  __n128 v377;
  __n128 v378;
  __n128 v379;
  __int128 v380;
  unsigned int *v381;
  uint64_t v382;
  __int128 v383;
  uint64_t v384;
  TI::CP::SearchNode *v385;
  std::__shared_weak_count *v386;
  uint64_t v387;
  __int128 v388;
  __int128 v389;
  unsigned int *v390;
  unsigned int *v391;
  __int128 v392;
  __int128 v393;
  __int128 v394;
  float v395;
  int64x2_t v396;
  _QWORD v397[2];
  _BYTE v398[24];
  char *v399;
  _QWORD *v400;
  int v401[5];

  v396 = 0uLL;
  v397[0] = 0;
  v393 = 0u;
  v394 = 0u;
  v395 = 1.0;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)&v393, 0x28uLL);
  TI::CP::Search::compute_keys_near_sample((_QWORD *)a1, a2);
  v360 = a3;
  if ((a3 & 1) != 0)
  {
    TI::Favonius::KeyboardLayout::key_for_char(*(_QWORD *)(a1 + 8), 0x20u, v398);
    v7 = *(_QWORD *)v398;
    v8 = a2;
    TI::Favonius::KeyboardLayout::find_nearest_key(*(unsigned int **)(a1 + 8), *(CGPoint *)(*(_QWORD *)(a1 + 56) + 48 * a2), (unsigned int **)v398);
    v9 = *(unsigned int **)v398;
    v357 = v7;
    if (*(_QWORD *)v398)
    {
      if (memchr(".,?!", *(_DWORD *)(*(_QWORD *)v398 + 56), 5uLL))
      {
        do
          v10 = __ldaxr(v9);
        while (__stlxr(v10 + 1, v9));
        v11 = v9;
      }
      else
      {
        v11 = 0;
      }
      WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v9);
    }
    else
    {
      v11 = 0;
    }
  }
  else
  {
    v11 = 0;
    v357 = 0;
    v8 = a2;
  }
  v12 = *(_QWORD *)(a1 + 328) + 24 * v8;
  v14 = *(TI::CP::SearchNode ***)v12;
  n128_u64 = *(_QWORD *)(v12 + 8);
  if (*(_QWORD *)v12 != n128_u64)
  {
    if ((_DWORD)a2)
      v15 = v360;
    else
      v15 = 1;
    v16 = v360 ^ 1;
    if (!(_DWORD)a2)
      v16 = 1;
    v372 = v16;
    v374 = v15;
    while (1)
    {
      v17 = *v14;
      if (v11)
      {
        if (!(*(unsigned int (**)(_QWORD *))(**((_QWORD **)v17 + 8) + 64))(*((_QWORD **)v17 + 8)))
          goto LABEL_306;
        v18 = v14[1];
        *(_QWORD *)&v392 = *v14;
        *((_QWORD *)&v392 + 1) = v18;
        if (v18)
        {
          v19 = (unint64_t *)((char *)v18 + 8);
          do
            v20 = __ldxr(v19);
          while (__stxr(v20 + 1, v19));
        }
        v391 = v11;
        do
          v21 = __ldaxr(v11);
        while (__stlxr(v21 + 1, v11));
        v390 = 0;
        v401[0] = (int)a2;
        std::allocate_shared[abi:nn180100]<TI::CP::SearchNodeKeyMatch,std::allocator<TI::CP::SearchNodeKeyMatch>,TI::CP::Search const*&,std::shared_ptr<TI::CP::SearchNode const>,unsigned int &,WTF::PassRefPtr<TI::Favonius::LayoutKey> &,WTF::PassRefPtr<TI::Favonius::TypingHypothesis> &,void>(v398, (std::__shared_weak_count_vtbl *)a1, &v392, v401, (uint64_t *)&v391, (uint64_t *)&v390);
        TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::push<std::shared_ptr<TI::CP::SearchNodeKeyMatch>>(v396.i64, (__int128 *)v398, 0);
        v22 = *(std::__shared_weak_count **)&v398[8];
        if (*(_QWORD *)&v398[8])
        {
          v23 = (unint64_t *)(*(_QWORD *)&v398[8] + 8);
          do
            v24 = __ldaxr(v23);
          while (__stlxr(v24 - 1, v23));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
        if (v390)
        {
          v25 = v390 + 2;
          v26 = atomic_load(v390 + 2);
          if (v26 == 1)
          {
            (*(void (**)(void))(*(_QWORD *)v390 + 248))();
          }
          else
          {
            do
              v27 = __ldaxr(v25);
            while (__stlxr(v27 - 1, v25));
          }
        }
        if (v391)
          WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v391);
        v28 = (std::__shared_weak_count *)*((_QWORD *)&v392 + 1);
        if (!*((_QWORD *)&v392 + 1))
          goto LABEL_306;
        v29 = (unint64_t *)(*((_QWORD *)&v392 + 1) + 8);
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        goto LABEL_38;
      }
      has_extensions = TI::CP::SearchNode::has_extensions(v17);
      if (has_extensions)
        break;
LABEL_107:
      if ((v374 & 1) != 0)
        goto LABEL_183;
      v94 = *v14;
      v93 = (std::__shared_weak_count *)v14[1];
      if (v93)
      {
        p_shared_owners = (unint64_t *)&v93->__shared_owners_;
        do
          v96 = __ldxr(p_shared_owners);
        while (__stxr(v96 + 1, p_shared_owners));
      }
      v97 = (std::__shared_weak_count *)operator new(0x58uLL);
      v98 = v97;
      v97->__shared_owners_ = 0;
      v99 = (unint64_t *)&v97->__shared_owners_;
      v97->__shared_weak_owners_ = 0;
      v97->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105848;
      if (v93)
      {
        v100 = (unint64_t *)&v93->__shared_owners_;
        do
          v101 = __ldxr(v100);
        while (__stxr(v101 + 1, v100));
      }
      v97[1].__shared_weak_owners_ = 0;
      v97[2].__vftable = (std::__shared_weak_count_vtbl *)a1;
      v97[2].__shared_owners_ = (uint64_t)v94;
      v97[2].__shared_weak_owners_ = (uint64_t)v93;
      LODWORD(v97[3].__vftable) = (_DWORD)a2;
      v97[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FE640;
      v97[1].__shared_owners_ = 0;
      *(double *)&v97[3].__shared_owners_ = TI::CP::SearchNode::score_at_sample_index(v94, a2);
      if (v93)
      {
        v102 = (unint64_t *)&v93->__shared_owners_;
        do
          v103 = __ldaxr(v102);
        while (__stlxr(v103 - 1, v102));
        if (!v103)
        {
          ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
          std::__shared_weak_count::__release_weak(v93);
        }
      }
      v104 = v98 + 1;
      shared_weak_owners = (std::__shared_weak_count *)v98[1].__shared_weak_owners_;
      if (shared_weak_owners)
      {
        if (shared_weak_owners->__shared_owners_ != -1)
          goto LABEL_132;
        do
          v106 = __ldxr(v99);
        while (__stxr(v106 + 1, v99));
        p_shared_weak_owners = (unint64_t *)&v98->__shared_weak_owners_;
        do
          v108 = __ldxr(p_shared_weak_owners);
        while (__stxr(v108 + 1, p_shared_weak_owners));
        v98[1].__shared_owners_ = (uint64_t)v104;
        v98[1].__shared_weak_owners_ = (uint64_t)v98;
        std::__shared_weak_count::__release_weak(shared_weak_owners);
      }
      else
      {
        do
          v109 = __ldxr(v99);
        while (__stxr(v109 + 1, v99));
        v110 = (unint64_t *)&v98->__shared_weak_owners_;
        do
          v111 = __ldxr(v110);
        while (__stxr(v111 + 1, v110));
        v98[1].__shared_owners_ = (uint64_t)v104;
        v98[1].__shared_weak_owners_ = (uint64_t)v98;
      }
      do
        v112 = __ldaxr(v99);
      while (__stlxr(v112 - 1, v99));
      if (!v112)
      {
        ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
        std::__shared_weak_count::__release_weak(v98);
      }
LABEL_132:
      v113 = v396.i64[1];
      if (v396.i64[1] >= v397[0])
      {
        v115 = (v396.i64[1] - v396.i64[0]) >> 4;
        v116 = v115 + 1;
        if ((unint64_t)(v115 + 1) >> 60)
          goto LABEL_491;
        *(_QWORD *)&v117 = v98 + 1;
        *((_QWORD *)&v117 + 1) = v98;
        v365 = v117;
        v118 = v397[0] - v396.i64[0];
        if ((v397[0] - v396.i64[0]) >> 3 > v116)
          v116 = v118 >> 3;
        if ((unint64_t)v118 >= 0x7FFFFFFFFFFFFFF0)
          v119 = 0xFFFFFFFFFFFFFFFLL;
        else
          v119 = v116;
        v400 = v397;
        v120 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v119);
        v122 = &v120[16 * v115];
        *(_OWORD *)v122 = v365;
        v123 = (_QWORD *)v396.i64[1];
        v124 = (_QWORD *)v396.i64[0];
        if (v396.i64[1] == v396.i64[0])
        {
          v127 = vdupq_n_s64(v396.u64[1]);
          v125 = &v120[16 * v115];
        }
        else
        {
          v125 = &v120[16 * v115];
          do
          {
            v126 = *((_OWORD *)v123 - 1);
            v123 -= 2;
            *((_OWORD *)v125 - 1) = v126;
            v125 -= 16;
            *v123 = 0;
            v123[1] = 0;
          }
          while (v123 != v124);
          v127 = v396;
        }
        v114 = v122 + 16;
        v396.i64[0] = (uint64_t)v125;
        v396.i64[1] = (uint64_t)(v122 + 16);
        *(int64x2_t *)&v398[8] = v127;
        v128 = (char *)v397[0];
        v397[0] = &v120[16 * v121];
        v399 = v128;
        *(_QWORD *)v398 = v127.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)v398);
      }
      else
      {
        *(_QWORD *)v396.i64[1] = v104;
        *(_QWORD *)(v113 + 8) = v98;
        v114 = (_OWORD *)(v113 + 16);
      }
      v396.i64[1] = (uint64_t)v114;
      if (((*(uint64_t (**)(TI::CP::SearchNode *))(*(_QWORD *)*v14 + 80))(*v14) & 1) != 0)
        goto LABEL_183;
      v366 = *(_OWORD *)v14;
      v129 = (std::__shared_weak_count *)v14[1];
      if (v129)
      {
        v130 = (unint64_t *)((char *)v14[1] + 8);
        do
          v131 = __ldxr(v130);
        while (__stxr(v131 + 1, v130));
      }
      v132 = (std::__shared_weak_count *)operator new(0xA0uLL);
      v132->__shared_owners_ = 0;
      v133 = (unint64_t *)&v132->__shared_owners_;
      v132->__shared_weak_owners_ = 0;
      v132->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105880;
      v134 = v132 + 1;
      *(_OWORD *)v398 = v366;
      TI::CP::SearchNodeSkippedKey::SearchNodeSkippedKey((TI::CP::SearchNode *)&v132[1], a1, (uint64_t *)v398, (int)a2);
      if (v129)
      {
        v135 = (unint64_t *)&v129->__shared_owners_;
        do
          v136 = __ldaxr(v135);
        while (__stlxr(v136 - 1, v135));
        if (!v136)
        {
          ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
          std::__shared_weak_count::__release_weak(v129);
        }
      }
      v137 = (std::__shared_weak_count *)v132[1].__shared_weak_owners_;
      if (!v137)
      {
        do
          v141 = __ldxr(v133);
        while (__stxr(v141 + 1, v133));
        v142 = (unint64_t *)&v132->__shared_weak_owners_;
        do
          v143 = __ldxr(v142);
        while (__stxr(v143 + 1, v142));
        v132[1].__shared_owners_ = (uint64_t)v134;
        v132[1].__shared_weak_owners_ = (uint64_t)v132;
        do
LABEL_165:
          v144 = __ldaxr(v133);
        while (__stlxr(v144 - 1, v133));
        if (!v144)
        {
          ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
          std::__shared_weak_count::__release_weak(v132);
        }
        goto LABEL_168;
      }
      if (v137->__shared_owners_ == -1)
      {
        do
          v138 = __ldxr(v133);
        while (__stxr(v138 + 1, v133));
        v139 = (unint64_t *)&v132->__shared_weak_owners_;
        do
          v140 = __ldxr(v139);
        while (__stxr(v140 + 1, v139));
        v132[1].__shared_owners_ = (uint64_t)v134;
        v132[1].__shared_weak_owners_ = (uint64_t)v132;
        std::__shared_weak_count::__release_weak(v137);
        goto LABEL_165;
      }
LABEL_168:
      v145 = v396.i64[1];
      if (v396.i64[1] >= v397[0])
      {
        v147 = (v396.i64[1] - v396.i64[0]) >> 4;
        v148 = v147 + 1;
        if ((unint64_t)(v147 + 1) >> 60)
          goto LABEL_491;
        *(_QWORD *)&v149 = v132 + 1;
        *((_QWORD *)&v149 + 1) = v132;
        v367 = v149;
        v150 = v397[0] - v396.i64[0];
        if ((v397[0] - v396.i64[0]) >> 3 > v148)
          v148 = v150 >> 3;
        if ((unint64_t)v150 >= 0x7FFFFFFFFFFFFFF0)
          v151 = 0xFFFFFFFFFFFFFFFLL;
        else
          v151 = v148;
        v400 = v397;
        v152 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v151);
        v154 = &v152[16 * v147];
        *(_OWORD *)v154 = v367;
        v155 = (_QWORD *)v396.i64[1];
        v156 = (_QWORD *)v396.i64[0];
        if (v396.i64[1] == v396.i64[0])
        {
          v159 = vdupq_n_s64(v396.u64[1]);
          v157 = &v152[16 * v147];
        }
        else
        {
          v157 = &v152[16 * v147];
          do
          {
            v158 = *((_OWORD *)v155 - 1);
            v155 -= 2;
            *((_OWORD *)v157 - 1) = v158;
            v157 -= 16;
            *v155 = 0;
            v155[1] = 0;
          }
          while (v155 != v156);
          v159 = v396;
        }
        v146 = v154 + 16;
        v396.i64[0] = (uint64_t)v157;
        v396.i64[1] = (uint64_t)(v154 + 16);
        *(int64x2_t *)&v398[8] = v159;
        v160 = (char *)v397[0];
        v397[0] = &v152[16 * v153];
        v399 = v160;
        *(_QWORD *)v398 = v159.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)v398);
      }
      else
      {
        *(_QWORD *)v396.i64[1] = v134;
        *(_QWORD *)(v145 + 8) = v132;
        v146 = (_OWORD *)(v145 + 16);
      }
      v396.i64[1] = (uint64_t)v146;
LABEL_183:
      if ((v372 & 1) != 0)
      {
        if (!has_extensions)
          goto LABEL_306;
        goto LABEL_239;
      }
      if (((*(uint64_t (**)(TI::CP::SearchNode *))(*(_QWORD *)*v14 + 72))(*v14) & 1) == 0)
      {
        v161 = *v14;
        if (*((_DWORD *)*v14 + 12))
        {
          v162 = (std::__shared_weak_count *)v14[1];
          if (v162)
          {
            v163 = (unint64_t *)&v162->__shared_owners_;
            do
              v164 = __ldxr(v163);
            while (__stxr(v164 + 1, v163));
          }
          *(_QWORD *)&v165 = v161;
          *((_QWORD *)&v165 + 1) = v162;
          v368 = v165;
          v166 = (std::__shared_weak_count *)operator new(0xA0uLL);
          v166->__shared_owners_ = 0;
          v167 = (unint64_t *)&v166->__shared_owners_;
          v166->__shared_weak_owners_ = 0;
          v166->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1058B8;
          v168 = v166 + 1;
          *(_OWORD *)v398 = v368;
          TI::CP::SearchNodeOvershoot::SearchNodeOvershoot((TI::CP::SearchNode *)&v166[1], a1, (uint64_t *)v398, (int)a2);
          if (v162)
          {
            v169 = (unint64_t *)&v162->__shared_owners_;
            do
              v170 = __ldaxr(v169);
            while (__stlxr(v170 - 1, v169));
            if (!v170)
            {
              ((void (*)(std::__shared_weak_count *))v162->__on_zero_shared)(v162);
              std::__shared_weak_count::__release_weak(v162);
            }
          }
          v171 = (std::__shared_weak_count *)v166[1].__shared_weak_owners_;
          if (v171)
          {
            if (v171->__shared_owners_ == -1)
            {
              do
                v172 = __ldxr(v167);
              while (__stxr(v172 + 1, v167));
              v173 = (unint64_t *)&v166->__shared_weak_owners_;
              do
                v174 = __ldxr(v173);
              while (__stxr(v174 + 1, v173));
              v166[1].__shared_owners_ = (uint64_t)v168;
              v166[1].__shared_weak_owners_ = (uint64_t)v166;
              std::__shared_weak_count::__release_weak(v171);
              do
LABEL_206:
                v178 = __ldaxr(v167);
              while (__stlxr(v178 - 1, v167));
              if (!v178)
              {
                ((void (*)(std::__shared_weak_count *))v166->__on_zero_shared)(v166);
                std::__shared_weak_count::__release_weak(v166);
              }
            }
            v179 = v396.i64[1];
            if (v396.i64[1] >= v397[0])
            {
              v181 = (v396.i64[1] - v396.i64[0]) >> 4;
              v182 = v181 + 1;
              if ((unint64_t)(v181 + 1) >> 60)
                goto LABEL_491;
              *(_QWORD *)&v183 = v166 + 1;
              *((_QWORD *)&v183 + 1) = v166;
              v369 = v183;
              v184 = v397[0] - v396.i64[0];
              if ((v397[0] - v396.i64[0]) >> 3 > v182)
                v182 = v184 >> 3;
              if ((unint64_t)v184 >= 0x7FFFFFFFFFFFFFF0)
                v185 = 0xFFFFFFFFFFFFFFFLL;
              else
                v185 = v182;
              v400 = v397;
              v186 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v185);
              v188 = &v186[16 * v181];
              *(_OWORD *)v188 = v369;
              v189 = (_QWORD *)v396.i64[1];
              v190 = (_QWORD *)v396.i64[0];
              if (v396.i64[1] == v396.i64[0])
              {
                v193 = vdupq_n_s64(v396.u64[1]);
                v191 = &v186[16 * v181];
              }
              else
              {
                v191 = &v186[16 * v181];
                do
                {
                  v192 = *((_OWORD *)v189 - 1);
                  v189 -= 2;
                  *((_OWORD *)v191 - 1) = v192;
                  v191 -= 16;
                  *v189 = 0;
                  v189[1] = 0;
                }
                while (v189 != v190);
                v193 = v396;
              }
              v180 = v188 + 16;
              v396.i64[0] = (uint64_t)v191;
              v396.i64[1] = (uint64_t)(v188 + 16);
              *(int64x2_t *)&v398[8] = v193;
              v194 = (char *)v397[0];
              v397[0] = &v186[16 * v187];
              v399 = v194;
              *(_QWORD *)v398 = v193.i64[0];
              std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)v398);
            }
            else
            {
              *(_QWORD *)v396.i64[1] = v168;
              *(_QWORD *)(v179 + 8) = v166;
              v180 = (_OWORD *)(v179 + 16);
            }
            v396.i64[1] = (uint64_t)v180;
            goto LABEL_224;
          }
          do
            v175 = __ldxr(v167);
          while (__stxr(v175 + 1, v167));
          v176 = (unint64_t *)&v166->__shared_weak_owners_;
          do
            v177 = __ldxr(v176);
          while (__stxr(v177 + 1, v176));
          v166[1].__shared_owners_ = (uint64_t)v168;
          v166[1].__shared_weak_owners_ = (uint64_t)v166;
          goto LABEL_206;
        }
      }
LABEL_224:
      if (!has_extensions)
        goto LABEL_306;
      if (*(_BYTE *)(a1 + 568))
      {
        v195 = v14[1];
        *(_QWORD *)&v389 = *v14;
        *((_QWORD *)&v389 + 1) = v195;
        if (v195)
        {
          v196 = (unint64_t *)((char *)v195 + 8);
          do
            v197 = __ldxr(v196);
          while (__stxr(v197 + 1, v196));
        }
        v401[0] = (int)a2;
        std::allocate_shared[abi:nn180100]<TI::CP::SearchNodeKeyPredictionExtensions,std::allocator<TI::CP::SearchNodeKeyPredictionExtensions>,TI::CP::Search const*&,std::shared_ptr<TI::CP::SearchNode const>,unsigned int &,void>(v398, (TI::CP::SearchNodeKeyPredictionExtensions *)a1, &v389, (unsigned int *)v401);
        TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::push<std::shared_ptr<TI::CP::SearchNodeKeyMatch>>(v396.i64, (__int128 *)v398, 0);
        v198 = *(std::__shared_weak_count **)&v398[8];
        if (*(_QWORD *)&v398[8])
        {
          v199 = (unint64_t *)(*(_QWORD *)&v398[8] + 8);
          do
            v200 = __ldaxr(v199);
          while (__stlxr(v200 - 1, v199));
          if (!v200)
          {
            ((void (*)(std::__shared_weak_count *))v198->__on_zero_shared)(v198);
            std::__shared_weak_count::__release_weak(v198);
          }
        }
        v201 = (std::__shared_weak_count *)*((_QWORD *)&v389 + 1);
        if (*((_QWORD *)&v389 + 1))
        {
          v202 = (unint64_t *)(*((_QWORD *)&v389 + 1) + 8);
          do
            v203 = __ldaxr(v202);
          while (__stlxr(v203 - 1, v202));
          if (!v203)
          {
            ((void (*)(std::__shared_weak_count *))v201->__on_zero_shared)(v201);
            std::__shared_weak_count::__release_weak(v201);
          }
        }
      }
LABEL_239:
      v204 = (*(uint64_t (**)(TI::CP::SearchNode *))(*(_QWORD *)*v14 + 104))(*v14);
      v205 = *v14;
      if (!v204 || *((_DWORD *)v205 + 12) + 1 >= a2)
        goto LABEL_277;
      v206 = (std::__shared_weak_count *)v14[1];
      if (v206)
      {
        v207 = (unint64_t *)&v206->__shared_owners_;
        do
          v208 = __ldxr(v207);
        while (__stxr(v208 + 1, v207));
      }
      *(_QWORD *)&v209 = v205;
      *((_QWORD *)&v209 + 1) = v206;
      v370 = v209;
      v210 = (std::__shared_weak_count *)operator new(0xA0uLL);
      v210->__shared_owners_ = 0;
      v211 = (unint64_t *)&v210->__shared_owners_;
      v210->__shared_weak_owners_ = 0;
      v210->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105928;
      v212 = v210 + 1;
      *(_OWORD *)v398 = v370;
      TI::CP::SearchNodeLoop::SearchNodeLoop((TI::CP::SearchNode *)&v210[1], a1, (uint64_t *)v398, (int)a2);
      if (v206)
      {
        v213 = (unint64_t *)&v206->__shared_owners_;
        do
          v214 = __ldaxr(v213);
        while (__stlxr(v214 - 1, v213));
        if (!v214)
        {
          ((void (*)(std::__shared_weak_count *))v206->__on_zero_shared)(v206);
          std::__shared_weak_count::__release_weak(v206);
        }
      }
      v215 = (std::__shared_weak_count *)v210[1].__shared_weak_owners_;
      if (!v215)
      {
        do
          v219 = __ldxr(v211);
        while (__stxr(v219 + 1, v211));
        v220 = (unint64_t *)&v210->__shared_weak_owners_;
        do
          v221 = __ldxr(v220);
        while (__stxr(v221 + 1, v220));
        v210[1].__shared_owners_ = (uint64_t)v212;
        v210[1].__shared_weak_owners_ = (uint64_t)v210;
        do
LABEL_259:
          v222 = __ldaxr(v211);
        while (__stlxr(v222 - 1, v211));
        if (!v222)
        {
          ((void (*)(std::__shared_weak_count *))v210->__on_zero_shared)(v210);
          std::__shared_weak_count::__release_weak(v210);
        }
        goto LABEL_262;
      }
      if (v215->__shared_owners_ == -1)
      {
        do
          v216 = __ldxr(v211);
        while (__stxr(v216 + 1, v211));
        v217 = (unint64_t *)&v210->__shared_weak_owners_;
        do
          v218 = __ldxr(v217);
        while (__stxr(v218 + 1, v217));
        v210[1].__shared_owners_ = (uint64_t)v212;
        v210[1].__shared_weak_owners_ = (uint64_t)v210;
        std::__shared_weak_count::__release_weak(v215);
        goto LABEL_259;
      }
LABEL_262:
      v223 = v396.i64[1];
      if (v396.i64[1] >= v397[0])
      {
        v225 = (v396.i64[1] - v396.i64[0]) >> 4;
        v226 = v225 + 1;
        if ((unint64_t)(v225 + 1) >> 60)
          goto LABEL_491;
        *(_QWORD *)&v227 = v210 + 1;
        *((_QWORD *)&v227 + 1) = v210;
        v371 = v227;
        v228 = v397[0] - v396.i64[0];
        if ((v397[0] - v396.i64[0]) >> 3 > v226)
          v226 = v228 >> 3;
        if ((unint64_t)v228 >= 0x7FFFFFFFFFFFFFF0)
          v229 = 0xFFFFFFFFFFFFFFFLL;
        else
          v229 = v226;
        v400 = v397;
        v230 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v229);
        v232 = &v230[16 * v225];
        *(_OWORD *)v232 = v371;
        v233 = (_QWORD *)v396.i64[1];
        v234 = (_QWORD *)v396.i64[0];
        if (v396.i64[1] == v396.i64[0])
        {
          v237 = vdupq_n_s64(v396.u64[1]);
          v235 = &v230[16 * v225];
        }
        else
        {
          v235 = &v230[16 * v225];
          do
          {
            v236 = *((_OWORD *)v233 - 1);
            v233 -= 2;
            *((_OWORD *)v235 - 1) = v236;
            v235 -= 16;
            *v233 = 0;
            v233[1] = 0;
          }
          while (v233 != v234);
          v237 = v396;
        }
        v224 = v232 + 16;
        v396.i64[0] = (uint64_t)v235;
        v396.i64[1] = (uint64_t)(v232 + 16);
        *(int64x2_t *)&v398[8] = v237;
        v238 = (char *)v397[0];
        v397[0] = &v230[16 * v231];
        v399 = v238;
        *(_QWORD *)v398 = v237.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)v398);
      }
      else
      {
        *(_QWORD *)v396.i64[1] = v212;
        *(_QWORD *)(v223 + 8) = v210;
        v224 = (_OWORD *)(v223 + 16);
      }
      v396.i64[1] = (uint64_t)v224;
      v205 = *v14;
LABEL_277:
      v239 = (*(uint64_t (**)(TI::CP::SearchNode *))(*(_QWORD *)v205 + 72))(v205);
      v240 = *v14;
      if (a2 >= 2 && (v239 & 1) != 0 || *((_DWORD *)v240 + 12) + 2 <= a2)
      {
        if ((*(unsigned int (**)(TI::CP::SearchNode *))(*(_QWORD *)v240 + 80))(v240))
        {
          TI::CP::SearchNode::shared_from_this(*((TI::CP::SearchNode **)*v14 + 4), &v388);
          v387 = 0;
          v401[0] = (int)a2;
          std::allocate_shared[abi:nn180100]<TI::CP::SearchNodeTranspositionExtensions,std::allocator<TI::CP::SearchNodeTranspositionExtensions>,TI::CP::Search const*&,std::shared_ptr<TI::CP::SearchNode const>,unsigned int &,WTF::PassRefPtr<TI::Favonius::LayoutKey> &,void>(v398, a1, (uint64_t *)&v388, v401, &v387);
          TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::push<std::shared_ptr<TI::CP::SearchNodeTranspositionExtensions>>(&v396, (__int128 *)v398);
          v241 = *(std::__shared_weak_count **)&v398[8];
          if (*(_QWORD *)&v398[8])
          {
            v242 = (unint64_t *)(*(_QWORD *)&v398[8] + 8);
            do
              v243 = __ldaxr(v242);
            while (__stlxr(v243 - 1, v242));
            if (!v243)
            {
              ((void (*)(std::__shared_weak_count *))v241->__on_zero_shared)(v241);
              std::__shared_weak_count::__release_weak(v241);
            }
          }
          if (v387)
            WTF::RefCounted<TI::Favonius::Key>::deref(v387);
          v28 = (std::__shared_weak_count *)*((_QWORD *)&v388 + 1);
          if (!*((_QWORD *)&v388 + 1))
            goto LABEL_306;
          v244 = (unint64_t *)(*((_QWORD *)&v388 + 1) + 8);
          do
            v30 = __ldaxr(v244);
          while (__stlxr(v30 - 1, v244));
        }
        else
        {
          v245 = (std::__shared_weak_count *)v14[1];
          v385 = *v14;
          v386 = v245;
          if (v245)
          {
            v246 = (unint64_t *)&v245->__shared_owners_;
            do
              v247 = __ldxr(v246);
            while (__stxr(v247 + 1, v246));
          }
          v384 = 0;
          v401[0] = (int)a2;
          std::allocate_shared[abi:nn180100]<TI::CP::SearchNodeTranspositionExtensions,std::allocator<TI::CP::SearchNodeTranspositionExtensions>,TI::CP::Search const*&,std::shared_ptr<TI::CP::SearchNode const>,unsigned int &,WTF::PassRefPtr<TI::Favonius::LayoutKey> &,void>(v398, a1, (uint64_t *)&v385, v401, &v384);
          TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::push<std::shared_ptr<TI::CP::SearchNodeTranspositionExtensions>>(&v396, (__int128 *)v398);
          v248 = *(std::__shared_weak_count **)&v398[8];
          if (*(_QWORD *)&v398[8])
          {
            v249 = (unint64_t *)(*(_QWORD *)&v398[8] + 8);
            do
              v250 = __ldaxr(v249);
            while (__stlxr(v250 - 1, v249));
            if (!v250)
            {
              ((void (*)(std::__shared_weak_count *))v248->__on_zero_shared)(v248);
              std::__shared_weak_count::__release_weak(v248);
            }
          }
          if (v384)
            WTF::RefCounted<TI::Favonius::Key>::deref(v384);
          v28 = v386;
          if (!v386)
            goto LABEL_306;
          v251 = (unint64_t *)&v386->__shared_owners_;
          do
            v30 = __ldaxr(v251);
          while (__stlxr(v30 - 1, v251));
        }
LABEL_38:
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
LABEL_306:
      v14 += 2;
      if (v14 == (TI::CP::SearchNode **)n128_u64)
        goto LABEL_307;
    }
    v361 = *(_OWORD *)v14;
    if (v14[1])
    {
      v32 = (unint64_t *)((char *)v14[1] + 8);
      do
        v33 = __ldxr(v32);
      while (__stxr(v33 + 1, v32));
    }
    v34 = (std::__shared_weak_count *)operator new(0x80uLL);
    v34->__shared_owners_ = 0;
    v35 = (unint64_t *)&v34->__shared_owners_;
    v34->__shared_weak_owners_ = 0;
    v34->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1057D8;
    v34[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FE4C0;
    v36 = v34 + 1;
    v34[1].__shared_owners_ = 0;
    v34[1].__shared_weak_owners_ = 0;
    v34[2].__vftable = (std::__shared_weak_count_vtbl *)a1;
    *(_OWORD *)&v34[2].__shared_owners_ = v361;
    LODWORD(v34[3].__vftable) = (_DWORD)a2;
    v34[3].__shared_weak_owners_ = 0;
    v34[4].__vftable = 0;
    v34[3].__shared_owners_ = 0;
    LOBYTE(v34[4].__shared_owners_) = 0;
    *(long double *)&v34[4].__shared_weak_owners_ = TI::CP::SearchNodeLanguageExtensions::bound_on_score((TI::CP::SearchNodeLanguageExtensions *)a1, (const TI::CP::Search *)v361, a2);
    TI::CP::SearchNodeLanguageExtensions::compute_bound_on_score((TI::CP::SearchNodeLanguageExtensions *)&v34[1]);
    v37 = (std::__shared_weak_count *)v34[1].__shared_weak_owners_;
    if (v37)
    {
      if (v37->__shared_owners_ != -1)
        goto LABEL_57;
      do
        v38 = __ldxr(v35);
      while (__stxr(v38 + 1, v35));
      v39 = (unint64_t *)&v34->__shared_weak_owners_;
      do
        v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
      v34[1].__shared_owners_ = (uint64_t)v36;
      v34[1].__shared_weak_owners_ = (uint64_t)v34;
      std::__shared_weak_count::__release_weak(v37);
    }
    else
    {
      do
        v41 = __ldxr(v35);
      while (__stxr(v41 + 1, v35));
      v42 = (unint64_t *)&v34->__shared_weak_owners_;
      do
        v43 = __ldxr(v42);
      while (__stxr(v43 + 1, v42));
      v34[1].__shared_owners_ = (uint64_t)v36;
      v34[1].__shared_weak_owners_ = (uint64_t)v34;
    }
    do
      v44 = __ldaxr(v35);
    while (__stlxr(v44 - 1, v35));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
LABEL_57:
    v45 = v396.i64[1];
    if (v396.i64[1] >= v397[0])
    {
      v47 = (v396.i64[1] - v396.i64[0]) >> 4;
      v48 = v47 + 1;
      if ((unint64_t)(v47 + 1) >> 60)
        goto LABEL_491;
      *(_QWORD *)&v49 = v34 + 1;
      *((_QWORD *)&v49 + 1) = v34;
      v362 = v49;
      v50 = v397[0] - v396.i64[0];
      if ((v397[0] - v396.i64[0]) >> 3 > v48)
        v48 = v50 >> 3;
      if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF0)
        v51 = 0xFFFFFFFFFFFFFFFLL;
      else
        v51 = v48;
      v400 = v397;
      v52 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v51);
      v54 = &v52[16 * v47];
      *(_OWORD *)v54 = v362;
      v55 = (_QWORD *)v396.i64[1];
      v56 = (_QWORD *)v396.i64[0];
      if (v396.i64[1] == v396.i64[0])
      {
        v59 = vdupq_n_s64(v396.u64[1]);
        v57 = &v52[16 * v47];
      }
      else
      {
        v57 = &v52[16 * v47];
        do
        {
          v58 = *((_OWORD *)v55 - 1);
          v55 -= 2;
          *((_OWORD *)v57 - 1) = v58;
          v57 -= 16;
          *v55 = 0;
          v55[1] = 0;
        }
        while (v55 != v56);
        v59 = v396;
      }
      v46 = v54 + 16;
      v396.i64[0] = (uint64_t)v57;
      v396.i64[1] = (uint64_t)(v54 + 16);
      *(int64x2_t *)&v398[8] = v59;
      v60 = (char *)v397[0];
      v397[0] = &v52[16 * v53];
      v399 = v60;
      *(_QWORD *)v398 = v59.i64[0];
      std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)v398);
    }
    else
    {
      *(_QWORD *)v396.i64[1] = v36;
      *(_QWORD *)(v45 + 8) = v34;
      v46 = (_OWORD *)(v45 + 16);
    }
    v396.i64[1] = (uint64_t)v46;
    v363 = *(_OWORD *)v14;
    if (v14[1])
    {
      v61 = (unint64_t *)((char *)v14[1] + 8);
      do
        v62 = __ldxr(v61);
      while (__stxr(v62 + 1, v61));
    }
    v63 = (std::__shared_weak_count *)operator new(0x60uLL);
    v63->__shared_owners_ = 0;
    v64 = (unint64_t *)&v63->__shared_owners_;
    v63->__shared_weak_owners_ = 0;
    v63->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105810;
    v65 = v63 + 1;
    *(_OWORD *)v398 = v363;
    TI::CP::SearchNodeGeometryExtensions::SearchNodeGeometryExtensions((__n128 *)&v63[1], (TI::CP::Search *)a1, (__n128 *)v398, a2);
    v66 = *(std::__shared_weak_count **)&v398[8];
    if (*(_QWORD *)&v398[8])
    {
      v67 = (unint64_t *)(*(_QWORD *)&v398[8] + 8);
      do
        v68 = __ldaxr(v67);
      while (__stlxr(v68 - 1, v67));
      if (!v68)
      {
        ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
        std::__shared_weak_count::__release_weak(v66);
      }
    }
    v69 = (std::__shared_weak_count *)v63[1].__shared_weak_owners_;
    if (v69)
    {
      if (v69->__shared_owners_ != -1)
      {
LABEL_92:
        v77 = v396.i64[1];
        if (v396.i64[1] >= v397[0])
        {
          v79 = (v396.i64[1] - v396.i64[0]) >> 4;
          v80 = v79 + 1;
          if ((unint64_t)(v79 + 1) >> 60)
            goto LABEL_491;
          *(_QWORD *)&v81 = v63 + 1;
          *((_QWORD *)&v81 + 1) = v63;
          v364 = v81;
          v82 = v397[0] - v396.i64[0];
          if ((v397[0] - v396.i64[0]) >> 3 > v80)
            v80 = v82 >> 3;
          if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF0)
            v83 = 0xFFFFFFFFFFFFFFFLL;
          else
            v83 = v80;
          v400 = v397;
          v84 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v83);
          v86 = &v84[16 * v79];
          *(_OWORD *)v86 = v364;
          v87 = (_QWORD *)v396.i64[1];
          v88 = (_QWORD *)v396.i64[0];
          if (v396.i64[1] == v396.i64[0])
          {
            v91 = vdupq_n_s64(v396.u64[1]);
            v89 = &v84[16 * v79];
          }
          else
          {
            v89 = &v84[16 * v79];
            do
            {
              v90 = *((_OWORD *)v87 - 1);
              v87 -= 2;
              *((_OWORD *)v89 - 1) = v90;
              v89 -= 16;
              *v87 = 0;
              v87[1] = 0;
            }
            while (v87 != v88);
            v91 = v396;
          }
          v78 = v86 + 16;
          v396.i64[0] = (uint64_t)v89;
          v396.i64[1] = (uint64_t)(v86 + 16);
          *(int64x2_t *)&v398[8] = v91;
          v92 = (char *)v397[0];
          v397[0] = &v84[16 * v85];
          v399 = v92;
          *(_QWORD *)v398 = v91.i64[0];
          std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)v398);
        }
        else
        {
          *(_QWORD *)v396.i64[1] = v65;
          *(_QWORD *)(v77 + 8) = v63;
          v78 = (_OWORD *)(v77 + 16);
        }
        v396.i64[1] = (uint64_t)v78;
        goto LABEL_107;
      }
      do
        v70 = __ldxr(v64);
      while (__stxr(v70 + 1, v64));
      v71 = (unint64_t *)&v63->__shared_weak_owners_;
      do
        v72 = __ldxr(v71);
      while (__stxr(v72 + 1, v71));
      v63[1].__shared_owners_ = (uint64_t)v65;
      v63[1].__shared_weak_owners_ = (uint64_t)v63;
      std::__shared_weak_count::__release_weak(v69);
    }
    else
    {
      do
        v73 = __ldxr(v64);
      while (__stxr(v73 + 1, v64));
      v74 = (unint64_t *)&v63->__shared_weak_owners_;
      do
        v75 = __ldxr(v74);
      while (__stxr(v75 + 1, v74));
      v63[1].__shared_owners_ = (uint64_t)v65;
      v63[1].__shared_weak_owners_ = (uint64_t)v63;
    }
    do
      v76 = __ldaxr(v64);
    while (__stlxr(v76 - 1, v64));
    if (!v76)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
    goto LABEL_92;
  }
LABEL_307:
  v252 = ((unint64_t)(v396.i64[1] - v396.i64[0]) >> 5) & 0x7FFFFFFF;
  if ((_DWORD)v252)
  {
    v253 = v252 - 1;
    do
      TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::_downheapify(v396.i64, v253--);
    while (v253 != -1);
  }
  v254 = a4;
  v255 = a4 + 2;
  v256 = v360;
  if (!(_DWORD)a2)
    v256 = 0;
  v373 = v256;
  v257 = -INFINITY;
  v358 = (double *)a1;
  do
  {
    if (v396.i64[0] == v396.i64[1] || (unint64_t)(v254[1] - *v254) > 0x27F)
      break;
    v258 = *(_QWORD *)v396.i64[0];
    v259 = COERCE_UNSIGNED_INT64((*(double (**)(_QWORD))(**(_QWORD **)v396.i64[0] + 56))(*(_QWORD *)v396.i64[0])) & 0x7FFFFFFFFFFFFFFFLL;
    v260 = 0uLL;
    if (v259 > 0x7FEFFFFFFFFFFFFFLL)
    {
      v261 = 5;
      goto LABEL_319;
    }
    if ((*(double (**)(uint64_t, __n128))(*(_QWORD *)v258 + 56))(v258, (__n128)0) < v257)
    {
      v261 = 5;
      v260 = 0uLL;
      goto LABEL_319;
    }
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)v258 + 40))(v398, v258);
    v377 = *(__n128 *)v398;
    v265 = *(_QWORD *)v398;
    v266 = 0uLL;
    if (!*(_QWORD *)v398)
    {
      (*(void (**)(_BYTE *__return_ptr, uint64_t, __n128))(*(_QWORD *)v258 + 32))(v398, v258, (__n128)0);
      v266 = *(_OWORD *)v398;
      if (!*(_QWORD *)v398)
      {
        v376 = *(_QWORD *)&v398[8];
        (*(void (**)(uint64_t))(*(_QWORD *)v258 + 48))(v258);
        *((_QWORD *)&v266 + 1) = v376;
        *(_QWORD *)&v266 = 0;
      }
    }
    v375 = v266;
    if ((COERCE_UNSIGNED_INT64((*(double (**)(uint64_t))(*(_QWORD *)v258 + 56))(v258)) & 0x7FFFFFFFFFFFFFFFLL) >= 0x7FF0000000000000)
    {
      if (!v265)
      {
        v272 = v396;
        if (((v396.i64[1] - v396.i64[0]) & 0xFFFFFFFE0) != 0)
        {
          v273 = *(_QWORD *)v396.i64[0];
          *(_QWORD *)v396.i64[0] = *(_QWORD *)(v396.i64[1] - 16);
          *(_QWORD *)(v272.i64[1] - 16) = v273;
          v274 = *(_QWORD *)(v272.i64[0] + 8);
          *(_QWORD *)(v272.i64[0] + 8) = *(_QWORD *)(v272.i64[1] - 8);
          *(_QWORD *)(v272.i64[1] - 8) = v274;
          v396.i64[1] = std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](v396.i64[1] - 16);
          TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::_downheapify(v396.i64, 0);
        }
        else
        {
          v396.i64[1] = std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](v396.i64[1] - 16);
        }
LABEL_353:
        v260 = v377;
        goto LABEL_358;
      }
      v269 = *(std::__shared_weak_count **)(v396.i64[0] + 8);
      *(__n128 *)v396.i64[0] = v377;
      if (v269)
      {
        v270 = (unint64_t *)&v269->__shared_owners_;
        do
          v271 = __ldaxr(v270);
        while (__stlxr(v271 - 1, v270));
        if (!v271)
        {
          ((void (*)(std::__shared_weak_count *))v269->__on_zero_shared)(v269);
          std::__shared_weak_count::__release_weak(v269);
        }
      }
      TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::_downheapify(v396.i64, 0);
    }
    else
    {
      TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::_downheapify(v396.i64, 0);
      if (!v265)
        goto LABEL_353;
      v267 = v396.i64[1];
      v268 = v396.i64[1] - v396.i64[0];
      if (v396.i64[1] >= v397[0])
      {
        v276 = (v268 >> 4) + 1;
        if (v276 >> 60)
          goto LABEL_491;
        v277 = (v397[0] - v396.i64[0]) >> 3;
        if (v277 <= v276)
          v277 = (v268 >> 4) + 1;
        if (v397[0] - v396.i64[0] >= 0x7FFFFFFFFFFFFFF0uLL)
          v278 = 0xFFFFFFFFFFFFFFFLL;
        else
          v278 = v277;
        v400 = v397;
        v279 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v278);
        v275 = v268 >> 4;
        v281 = (__n128 *)&v279[16 * (v268 >> 4)];
        *v281 = v377;
        v282 = (_QWORD *)v396.i64[1];
        v283 = (_QWORD *)v396.i64[0];
        if (v396.i64[1] == v396.i64[0])
        {
          v286 = vdupq_n_s64(v396.u64[1]);
          v284 = &v279[16 * v275];
        }
        else
        {
          v284 = &v279[16 * v275];
          do
          {
            v285 = *((_OWORD *)v282 - 1);
            v282 -= 2;
            *((_OWORD *)v284 - 1) = v285;
            v284 -= 16;
            *v282 = 0;
            v282[1] = 0;
          }
          while (v282 != v283);
          v286 = v396;
        }
        n128_u64 = (unint64_t)v281[1].n128_u64;
        v396.i64[0] = (uint64_t)v284;
        v396.i64[1] = (uint64_t)&v281[1];
        *(int64x2_t *)&v398[8] = v286;
        v287 = (char *)v397[0];
        v397[0] = &v279[16 * v280];
        v399 = v287;
        *(_QWORD *)v398 = v286.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)v398);
      }
      else
      {
        *(__n128 *)v396.i64[1] = v377;
        n128_u64 = v267 + 16;
      }
      v396.i64[1] = n128_u64;
      TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::_upheapify(v396.i64, (unint64_t)v268 >> 4);
    }
    v260 = 0uLL;
LABEL_358:
    if (!(_QWORD)v375)
      goto LABEL_470;
    if (v360 && *(_DWORD *)(v375 + 48) < a2)
    {
      v261 = 4;
      if (*((_QWORD *)&v375 + 1))
        goto LABEL_471;
      goto LABEL_319;
    }
    v378 = v260;
    v288 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v375 + 64) + 192))(*(_QWORD *)(v375 + 64));
    v289 = v288;
    v290 = *((_QWORD *)&v393 + 1);
    if (!*((_QWORD *)&v393 + 1))
      goto LABEL_379;
    v291 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v393 + 8));
    v291.i16[0] = vaddlv_u8(v291);
    v292 = v291.u32[0];
    if (v291.u32[0] > 1uLL)
    {
      n128_u64 = v288;
      v260 = v378;
      if (v288 >= *((_QWORD *)&v393 + 1))
        n128_u64 = v288 % *((_QWORD *)&v393 + 1);
    }
    else
    {
      n128_u64 = (*((_QWORD *)&v393 + 1) - 1) & v288;
      v260 = v378;
    }
    v293 = *(_QWORD **)(v393 + 8 * n128_u64);
    if (!v293 || (v294 = (_QWORD *)*v293) == 0)
    {
LABEL_379:
      v296 = v255;
      v297 = operator new(0x18uLL);
      *v297 = 0;
      v297[1] = v289;
      v297[2] = v289;
      v298 = (float)(unint64_t)(*((_QWORD *)&v394 + 1) + 1);
      if (!v290 || (float)(v395 * (float)v290) < v298)
      {
        v299 = (v290 & (v290 - 1)) != 0;
        if (v290 < 3)
          v299 = 1;
        v300 = v299 | (2 * v290);
        v301 = vcvtps_u32_f32(v298 / v395);
        if (v300 <= v301)
          v302 = v301;
        else
          v302 = v300;
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)&v393, v302);
        v290 = *((_QWORD *)&v393 + 1);
        if ((v290 & (v290 - 1)) != 0)
        {
          if (v289 >= *((_QWORD *)&v393 + 1))
            n128_u64 = v289 % *((_QWORD *)&v393 + 1);
          else
            n128_u64 = v289;
        }
        else
        {
          n128_u64 = (*((_QWORD *)&v393 + 1) - 1) & v289;
        }
      }
      v303 = v393;
      v304 = *(_QWORD **)(v393 + 8 * n128_u64);
      if (v304)
      {
        *v297 = *v304;
        goto LABEL_399;
      }
      *v297 = v394;
      *(_QWORD *)&v394 = v297;
      *(_QWORD *)(v303 + 8 * n128_u64) = &v394;
      if (*v297)
      {
        v305 = *(_QWORD *)(*v297 + 8);
        if ((v290 & (v290 - 1)) != 0)
        {
          if (v305 >= v290)
            v305 %= v290;
        }
        else
        {
          v305 &= v290 - 1;
        }
        v304 = (_QWORD *)(v393 + 8 * v305);
LABEL_399:
        *v304 = v297;
      }
      ++*((_QWORD *)&v394 + 1);
      if (v360 && !(*(unsigned int (**)(_QWORD))(**(_QWORD **)(v375 + 64) + 64))(*(_QWORD *)(v375 + 64)))
      {
        v255 = v296;
        v307 = v358;
        v254 = a4;
        goto LABEL_426;
      }
      v254 = a4;
      n128_u64 = (unint64_t)*a4;
      v306 = (__int128 *)a4[1];
      v255 = v296;
      v307 = v358;
      if (*a4 == (char *)v306)
      {
        v308 = TI::CP::SearchNode::score_at_sample_index((TI::CP::SearchNode *)v375, a2);
        v257 = v308
             + TI::CP::Search::key_substitution_cost((TI::CP::Search *)v358, a2)
             + v358[55] * -5.99146455;
      }
      if ((unint64_t)v306 < *v255)
      {
        *v306 = v375;
        if (*((_QWORD *)&v375 + 1))
        {
          v309 = (unint64_t *)(*((_QWORD *)&v375 + 1) + 8);
          do
            v310 = __ldxr(v309);
          while (__stxr(v310 + 1, v309));
        }
        v311 = (char *)(v306 + 1);
        goto LABEL_425;
      }
      v312 = (uint64_t)((uint64_t)v306 - n128_u64) >> 4;
      v313 = v312 + 1;
      if (!((unint64_t)(v312 + 1) >> 60))
      {
        v314 = *v255 - n128_u64;
        if (v314 >> 3 > v313)
          v313 = v314 >> 3;
        if ((unint64_t)v314 >= 0x7FFFFFFFFFFFFFF0)
          v315 = 0xFFFFFFFFFFFFFFFLL;
        else
          v315 = v313;
        v400 = v255;
        v316 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v315);
        v318 = (__int128 *)&v316[16 * v312];
        *v318 = v375;
        if (*((_QWORD *)&v375 + 1))
        {
          v319 = (unint64_t *)(*((_QWORD *)&v375 + 1) + 8);
          do
            v320 = __ldxr(v319);
          while (__stxr(v320 + 1, v319));
        }
        v322 = *a4;
        v321 = a4[1];
        if (v321 == *a4)
        {
          v325 = vdupq_n_s64((unint64_t)v321);
          v323 = &v316[16 * v312];
        }
        else
        {
          v323 = &v316[16 * v312];
          do
          {
            v324 = *((_OWORD *)v321 - 1);
            v321 -= 16;
            *((_OWORD *)v323 - 1) = v324;
            v323 -= 16;
            *(_QWORD *)v321 = 0;
            *((_QWORD *)v321 + 1) = 0;
          }
          while (v321 != v322);
          v325 = *(int64x2_t *)a4;
        }
        v311 = (char *)(v318 + 1);
        *a4 = v323;
        a4[1] = (char *)(v318 + 1);
        *(int64x2_t *)&v398[8] = v325;
        v326 = a4[2];
        a4[2] = &v316[16 * v317];
        v399 = v326;
        *(_QWORD *)v398 = v325.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)v398);
LABEL_425:
        a4[1] = v311;
LABEL_426:
        v327 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v375 + 104))(v375);
        v260 = v378;
        if (v327)
        {
          v328 = *(_QWORD *)(v375 + 56);
          if ((*(_WORD *)(v328 + 60) & 2) != 0 && *(_DWORD *)(v375 + 48) == (_DWORD)a2)
          {
            v383 = v375;
            if (*((_QWORD *)&v375 + 1))
            {
              v329 = (unint64_t *)(*((_QWORD *)&v375 + 1) + 8);
              do
                v330 = __ldxr(v329);
              while (__stxr(v330 + 1, v329));
              v328 = *(_QWORD *)(v375 + 56);
              v382 = v328;
              if (!v328)
              {
LABEL_438:
                v381 = 0;
                v401[0] = (int)a2;
                std::allocate_shared[abi:nn180100]<TI::CP::SearchNodeKeyMatch,std::allocator<TI::CP::SearchNodeKeyMatch>,TI::CP::Search const*&,std::shared_ptr<TI::CP::SearchNode const>,unsigned int &,WTF::PassRefPtr<TI::Favonius::LayoutKey> &,WTF::PassRefPtr<TI::Favonius::TypingHypothesis> &,void>(v398, (std::__shared_weak_count_vtbl *)v307, &v383, v401, &v382, (uint64_t *)&v381);
                TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::push<std::shared_ptr<TI::CP::SearchNodeKeyMatch>>(v396.i64, (__int128 *)v398, 1);
                v332 = *(std::__shared_weak_count **)&v398[8];
                if (*(_QWORD *)&v398[8])
                {
                  v333 = (unint64_t *)(*(_QWORD *)&v398[8] + 8);
                  do
                    v334 = __ldaxr(v333);
                  while (__stlxr(v334 - 1, v333));
                  if (!v334)
                  {
                    ((void (*)(std::__shared_weak_count *))v332->__on_zero_shared)(v332);
                    std::__shared_weak_count::__release_weak(v332);
                  }
                }
                if (v381)
                {
                  v335 = v381 + 2;
                  v336 = atomic_load(v381 + 2);
                  if (v336 == 1)
                  {
                    (*(void (**)(void))(*(_QWORD *)v381 + 248))();
                  }
                  else
                  {
                    do
                      v337 = __ldaxr(v335);
                    while (__stlxr(v337 - 1, v335));
                  }
                }
                if (v382)
                  WTF::RefCounted<TI::Favonius::Key>::deref(v382);
                v338 = (std::__shared_weak_count *)*((_QWORD *)&v383 + 1);
                v260 = v378;
                if (*((_QWORD *)&v383 + 1))
                {
                  v339 = (unint64_t *)(*((_QWORD *)&v383 + 1) + 8);
                  do
                    v340 = __ldaxr(v339);
                  while (__stlxr(v340 - 1, v339));
                  if (!v340)
                  {
                    ((void (*)(std::__shared_weak_count *, __n128))v338->__on_zero_shared)(v338, v378);
                    std::__shared_weak_count::__release_weak(v338);
                    v260 = v378;
                  }
                }
                goto LABEL_454;
              }
            }
            else
            {
              v382 = v328;
            }
            do
              v331 = __ldaxr((unsigned int *)v328);
            while (__stlxr(v331 + 1, (unsigned int *)v328));
            goto LABEL_438;
          }
        }
LABEL_454:
        if (v373 && *((_BYTE *)v307 + 568))
        {
          if (!TI::CP::SearchNode::has_extensions((TI::CP::SearchNode *)v375))
          {
            v261 = 0;
            v260 = v378;
            if (!*((_QWORD *)&v375 + 1))
              goto LABEL_319;
            goto LABEL_471;
          }
          v380 = v375;
          if (*((_QWORD *)&v375 + 1))
          {
            v341 = (unint64_t *)(*((_QWORD *)&v375 + 1) + 8);
            do
              v342 = __ldxr(v341);
            while (__stxr(v342 + 1, v341));
          }
          v401[0] = (int)a2;
          std::allocate_shared[abi:nn180100]<TI::CP::SearchNodeKeyPredictionExtensions,std::allocator<TI::CP::SearchNodeKeyPredictionExtensions>,TI::CP::Search const*&,std::shared_ptr<TI::CP::SearchNode const>,unsigned int &,void>(v398, (TI::CP::SearchNodeKeyPredictionExtensions *)v307, &v380, (unsigned int *)v401);
          TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::push<std::shared_ptr<TI::CP::SearchNodeKeyMatch>>(v396.i64, (__int128 *)v398, 1);
          v343 = *(std::__shared_weak_count **)&v398[8];
          v260 = v378;
          if (*(_QWORD *)&v398[8])
          {
            v344 = (unint64_t *)(*(_QWORD *)&v398[8] + 8);
            do
              v345 = __ldaxr(v344);
            while (__stlxr(v345 - 1, v344));
            if (!v345)
            {
              ((void (*)(std::__shared_weak_count *, __n128))v343->__on_zero_shared)(v343, v378);
              std::__shared_weak_count::__release_weak(v343);
              v260 = v378;
            }
          }
          v346 = (std::__shared_weak_count *)*((_QWORD *)&v380 + 1);
          if (*((_QWORD *)&v380 + 1))
          {
            v347 = (unint64_t *)(*((_QWORD *)&v380 + 1) + 8);
            do
              v348 = __ldaxr(v347);
            while (__stlxr(v348 - 1, v347));
            if (!v348)
            {
              ((void (*)(std::__shared_weak_count *, __n128))v346->__on_zero_shared)(v346, v260);
              std::__shared_weak_count::__release_weak(v346);
              v260 = v378;
            }
          }
        }
LABEL_470:
        v261 = 0;
        if (*((_QWORD *)&v375 + 1))
          goto LABEL_471;
        goto LABEL_319;
      }
LABEL_491:
      abort();
    }
    while (1)
    {
      v295 = v294[1];
      if (v295 == v288)
        break;
      if (v292 > 1)
      {
        if (v295 >= *((_QWORD *)&v393 + 1))
          v295 %= *((_QWORD *)&v393 + 1);
      }
      else
      {
        v295 &= *((_QWORD *)&v393 + 1) - 1;
      }
      if (v295 != n128_u64)
        goto LABEL_379;
LABEL_378:
      v294 = (_QWORD *)*v294;
      if (!v294)
        goto LABEL_379;
    }
    if (v294[2] != v288)
      goto LABEL_378;
    v261 = 4;
    v254 = a4;
    if (!*((_QWORD *)&v375 + 1))
      goto LABEL_319;
LABEL_471:
    v349 = (unint64_t *)(*((_QWORD *)&v375 + 1) + 8);
    do
      v350 = __ldaxr(v349);
    while (__stlxr(v350 - 1, v349));
    if (!v350)
    {
      v379 = v260;
      (*(void (**)(_QWORD))(**((_QWORD **)&v375 + 1) + 16))(*((_QWORD *)&v375 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v375 + 1));
      v260 = v379;
    }
LABEL_319:
    v262 = (std::__shared_weak_count *)v260.n128_u64[1];
    if (v260.n128_u64[1])
    {
      v263 = (unint64_t *)(v260.n128_u64[1] + 8);
      do
        v264 = __ldaxr(v263);
      while (__stlxr(v264 - 1, v263));
      if (!v264)
      {
        (*(void (**)(unint64_t, __n128))(*(_QWORD *)v260.n128_u64[1] + 16))(v260.n128_u64[1], v260);
        std::__shared_weak_count::__release_weak(v262);
      }
    }
  }
  while (v261 != 5);
  if (v11)
    WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v11);
  if (v357)
    WTF::RefCounted<TI::Favonius::Key>::deref(v357);
  v351 = (_QWORD *)v394;
  if ((_QWORD)v394)
  {
    do
    {
      v352 = (_QWORD *)*v351;
      operator delete(v351);
      v351 = v352;
    }
    while (v352);
  }
  v353 = (void *)v393;
  *(_QWORD *)&v393 = 0;
  if (v353)
    operator delete(v353);
  v354 = v396.i64[0];
  if (v396.i64[0])
  {
    v355 = v396.i64[1];
    v356 = (void *)v396.i64[0];
    if (v396.i64[1] != v396.i64[0])
    {
      do
        v355 = std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](v355 - 16);
      while (v355 != v354);
      v356 = (void *)v396.i64[0];
    }
    v396.i64[1] = v354;
    operator delete(v356);
  }
}

_QWORD *TI::CP::Search::compute_keys_near_sample(_QWORD *this, unsigned int a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  _QWORD *v6;
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD v24[5];
  unsigned int v25;
  _QWORD v26[2];
  void (*v27)(uint64_t, uint64_t *);
  void *v28;
  _QWORD *v29;
  __int128 v30;
  _QWORD *v31;
  unsigned int v32;
  __int128 v33;
  _QWORD *v34;
  char *v35;
  _QWORD *v36;
  _QWORD *v37;

  v3 = this[47];
  v2 = (_QWORD *)this[48];
  v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v2 - v3) >> 3);
  if (v4 <= a2)
  {
    v6 = this;
    v8 = this[49];
    if ((unint64_t)v2 >= v8)
    {
      v36 = this + 49;
      v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - v3) >> 3);
      v11 = 0x5555555555555556 * ((uint64_t)(v8 - v3) >> 3);
      if (v11 <= v4 + 1)
        v11 = v4 + 1;
      if (v10 >= 0x555555555555555)
        v12 = 0xAAAAAAAAAAAAAAALL;
      else
        v12 = v11;
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v12);
      v14 = &v13[24 * v4];
      *(_QWORD *)&v33 = v13;
      *((_QWORD *)&v33 + 1) = v14;
      v35 = &v13[24 * v15];
      *((_QWORD *)v14 + 1) = 0;
      *((_QWORD *)v14 + 2) = 0;
      *(_QWORD *)v14 = 0;
      v34 = v14 + 24;
      std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(v6 + 47, &v33);
      v9 = (_QWORD *)v6[48];
      std::__split_buffer<std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>>::~__split_buffer((uint64_t)&v33);
    }
    else
    {
      *v2 = 0;
      v2[1] = 0;
      v9 = v2 + 3;
      v2[2] = 0;
    }
    v6[48] = v9;
    v33 = *(_OWORD *)(v6[7] + 48 * a2);
    v16 = MEMORY[0x1E0C809B0];
    v17 = v6[1];
    v26[0] = MEMORY[0x1E0C809B0];
    v26[1] = 0x40000000;
    v27 = ___ZN2TI2CP6Search24compute_keys_near_sampleEj_block_invoke;
    v28 = &__block_descriptor_tmp_16413;
    v29 = v6;
    v32 = a2;
    v30 = v33;
    v31 = v9 - 3;
    v18 = *(uint64_t **)(v17 + 8);
    v19 = *(uint64_t **)(v17 + 16);
    while (v18 != v19)
      v27((uint64_t)v26, v18++);
    v20 = *(v9 - 3);
    v21 = (uint64_t *)*(v9 - 2);
    v24[0] = v16;
    v22 = 126 - 2 * __clz(((uint64_t)v21 - v20) >> 3);
    v24[1] = 0x40000000;
    v24[2] = ___ZN2TI2CP6Search24compute_keys_near_sampleEj_block_invoke_2;
    v24[3] = &__block_descriptor_tmp_2_16414;
    v24[4] = v6;
    v25 = a2;
    v37 = v24;
    if (v21 == (uint64_t *)v20)
      v23 = 0;
    else
      v23 = v22;
    return (_QWORD *)std::__introsort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::LayoutKey> const&,WTF::RefPtr<TI::Favonius::LayoutKey> const&),WTF::RefPtr<TI::Favonius::LayoutKey>*,false>(v20, v21, (uint64_t)&v37, v23, 1);
  }
  return this;
}

void TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::_downheapify(uint64_t *a1, unsigned int a2)
{
  unsigned int v2;
  uint64_t v3;
  unint64_t v4;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  double v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;

  v2 = (2 * a2) | 1;
  v3 = *a1;
  v4 = (unint64_t)(a1[1] - *a1) >> 4;
  if (v2 < v4)
  {
    v6 = 2 * a2;
    do
    {
      v7 = (v6 + 2);
      v8 = a2;
      v9 = 16 * a2;
      v10 = (*(double (**)(_QWORD))(**(_QWORD **)(v3 + 16 * v2) + 56))(*(_QWORD *)(v3 + 16 * v2));
      v11 = (*(double (**)(_QWORD))(**(_QWORD **)(v3 + v9) + 56))(*(_QWORD *)(v3 + v9));
      v12 = v11;
      if (v7 >= v4)
      {
        if (v10 <= v11)
          return;
        v20 = (uint64_t *)(*a1 + 16 * v8);
        v21 = (uint64_t *)(*a1 + 16 * v2);
        v18 = *v20;
        *v20 = *v21;
        v19 = v20 + 1;
      }
      else
      {
        v13 = *a1;
        v14 = *(_QWORD *)(*a1 + 16 * v7);
        v15 = (*(double (**)(uint64_t))(*(_QWORD *)v14 + 56))(v14);
        if (v10 <= v12)
        {
          if (v15 <= (*(double (**)(_QWORD))(**(_QWORD **)(v13 + 16 * v8) + 56))(*(_QWORD *)(v13 + 16 * v8)))
            return;
          v16 = (uint64_t *)(*a1 + 16 * v8);
          v17 = (uint64_t *)(*a1 + 16 * v7);
          v18 = *v16;
          *v16 = *v17;
          v19 = v16 + 1;
          goto LABEL_13;
        }
        v22 = (*(double (**)(_QWORD))(**(_QWORD **)(v13 + 16 * v2) + 56))(*(_QWORD *)(v13 + 16 * v2));
        v23 = *a1;
        v24 = (uint64_t *)(*a1 + 16 * v8);
        v19 = v24 + 1;
        v18 = *v24;
        if (v15 > v22)
        {
          v17 = (uint64_t *)(v23 + 16 * v7);
          *v24 = *v17;
LABEL_13:
          *v17 = v18;
          v25 = v17 + 1;
          v2 = v7;
          goto LABEL_14;
        }
        v21 = (uint64_t *)(v23 + 16 * v2);
        *v24 = *v21;
      }
      *v21 = v18;
      v25 = v21 + 1;
LABEL_14:
      a2 = v2;
      v26 = *v19;
      *v19 = *v25;
      *v25 = v26;
      v6 = 2 * v2;
      v2 = (2 * v2) | 1;
      v3 = *a1;
      v4 = (unint64_t)(a1[1] - *a1) >> 4;
    }
    while (v2 < v4);
  }
}

void TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::push<std::shared_ptr<TI::CP::SearchNodeKeyMatch>>(uint64_t *a1, __int128 *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  _OWORD *v8;
  uint64_t *v9;
  unint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  _QWORD *v19;
  _QWORD *v20;
  char *v21;
  __int128 v22;
  int64x2_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  int64x2_t v27;
  uint64_t v28;
  uint64_t *v29;

  v6 = *a1;
  v5 = a1[1];
  v7 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v8 = (_OWORD *)a1[1];
  v9 = a1 + 2;
  v10 = a1[2];
  if ((unint64_t)v8 >= v10)
  {
    v25 = v7;
    v12 = ((uint64_t)v8 - *a1) >> 4;
    if ((unint64_t)(v12 + 1) >> 60)
      abort();
    v13 = v10 - *a1;
    v14 = v13 >> 3;
    if (v13 >> 3 <= (unint64_t)(v12 + 1))
      v14 = v12 + 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v14;
    v29 = v9;
    v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v15);
    v18 = &v16[16 * v12];
    *(_OWORD *)v18 = v25;
    v20 = (_QWORD *)*a1;
    v19 = (_QWORD *)a1[1];
    if (v19 == (_QWORD *)*a1)
    {
      v23 = vdupq_n_s64((unint64_t)v19);
      v21 = &v16[16 * v12];
    }
    else
    {
      v21 = &v16[16 * v12];
      do
      {
        v22 = *((_OWORD *)v19 - 1);
        v19 -= 2;
        *((_OWORD *)v21 - 1) = v22;
        v21 -= 16;
        *v19 = 0;
        v19[1] = 0;
      }
      while (v19 != v20);
      v23 = *(int64x2_t *)a1;
    }
    v11 = v18 + 16;
    *a1 = (uint64_t)v21;
    a1[1] = (uint64_t)(v18 + 16);
    v27 = v23;
    v24 = a1[2];
    a1[2] = (uint64_t)&v16[16 * v17];
    v28 = v24;
    v26 = v23.i64[0];
    std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v26);
  }
  else
  {
    *v8 = v7;
    v11 = v8 + 1;
  }
  a1[1] = (uint64_t)v11;
  if (a3)
    TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::_upheapify(a1, (unint64_t)(v5 - v6) >> 4);
}

uint64_t TI::CP::SearchNode::has_extensions(TI::CP::SearchNode *this)
{
  if (((*(uint64_t (**)(TI::CP::SearchNode *))(*(_QWORD *)this + 128))(this) & 1) != 0
    || ((*(uint64_t (**)(TI::CP::SearchNode *))(*(_QWORD *)this + 88))(this) & 1) != 0)
  {
    return 0;
  }
  if ((*(unsigned int (**)(TI::CP::SearchNode *))(*(_QWORD *)this + 104))(this))
  {
    if ((*(_WORD *)(*((_QWORD *)this + 7) + 60) & 0x30) != 0 && (*(_WORD *)(*((_QWORD *)this + 7) + 60) & 8) == 0)
      return 0;
  }
  if (((*(uint64_t (**)(TI::CP::SearchNode *))(*(_QWORD *)this + 72))(this) & 1) != 0)
    return 1;
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 160))(*((_QWORD *)this + 8));
}

void std::allocate_shared[abi:nn180100]<TI::CP::SearchNodeKeyPredictionExtensions,std::allocator<TI::CP::SearchNodeKeyPredictionExtensions>,TI::CP::Search const*&,std::shared_ptr<TI::CP::SearchNode const>,unsigned int &,void>(_QWORD *a1, TI::CP::SearchNodeKeyPredictionExtensions *a2, __int128 *a3, unsigned int *a4)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v10;
  __int128 v11;
  const TI::CP::SearchNode *v12;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v14;
  unint64_t *p_shared_weak_owners;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;

  v8 = (std::__shared_weak_count *)operator new(0x80uLL);
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1058F0;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1EA0FE5F0;
  v10 = v8 + 1;
  v11 = *a3;
  *(_QWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = 0;
  v12 = (const TI::CP::SearchNode *)*a4;
  v8[1].__shared_owners_ = 0;
  v8[1].__shared_weak_owners_ = 0;
  v8[2].__vftable = (std::__shared_weak_count_vtbl *)a2;
  *(_OWORD *)&v8[2].__shared_owners_ = v11;
  LODWORD(v8[3].__vftable) = (_DWORD)v12;
  v8[3].__shared_weak_owners_ = 0;
  v8[4].__vftable = 0;
  v8[3].__shared_owners_ = 0;
  LOBYTE(v8[4].__shared_owners_) = 0;
  *(double *)&v8[4].__shared_weak_owners_ = TI::CP::SearchNodeKeyPredictionExtensions::bound_on_score(a2, (const TI::CP::Search *)v11, v12);
  TI::CP::SearchNodeKeyPredictionExtensions::compute_bound_on_score((TI::CP::SearchNodeKeyPredictionExtensions *)&v8[1]);
  shared_weak_owners = (std::__shared_weak_count *)v8[1].__shared_weak_owners_;
  *a1 = v8 + 1;
  a1[1] = v8;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1)
      return;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v16 = __ldxr(p_shared_weak_owners);
    while (__stxr(v16 + 1, p_shared_weak_owners));
    v8[1].__shared_owners_ = (uint64_t)v10;
    v8[1].__shared_weak_owners_ = (uint64_t)v8;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
    v18 = (unint64_t *)&v8->__shared_weak_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
    v8[1].__shared_owners_ = (uint64_t)v10;
    v8[1].__shared_weak_owners_ = (uint64_t)v8;
  }
  do
    v20 = __ldaxr(p_shared_owners);
  while (__stlxr(v20 - 1, p_shared_owners));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

_QWORD *TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::push<std::shared_ptr<TI::CP::SearchNodeTranspositionExtensions>>(_QWORD *result, __int128 *a2)
{
  char **v2;
  __int128 v3;
  _QWORD *v4;
  unint64_t v5;
  _OWORD *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  __int128 v18;
  int64x2_t v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  int64x2_t v23;
  char *v24;
  _QWORD *v25;

  v2 = (char **)result;
  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = result + 2;
  v5 = result[2];
  v6 = (_OWORD *)result[1];
  if ((unint64_t)v6 >= v5)
  {
    v21 = v3;
    v8 = ((uint64_t)v6 - *result) >> 4;
    if ((unint64_t)(v8 + 1) >> 60)
      abort();
    v9 = v5 - *result;
    v10 = v9 >> 3;
    if (v9 >> 3 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v25 = v4;
    v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v11);
    v14 = &v12[16 * v8];
    *(_OWORD *)v14 = v21;
    v16 = *v2;
    v15 = v2[1];
    if (v15 == *v2)
    {
      v19 = vdupq_n_s64((unint64_t)v15);
      v17 = &v12[16 * v8];
    }
    else
    {
      v17 = &v12[16 * v8];
      do
      {
        v18 = *((_OWORD *)v15 - 1);
        v15 -= 16;
        *((_OWORD *)v17 - 1) = v18;
        v17 -= 16;
        *(_QWORD *)v15 = 0;
        *((_QWORD *)v15 + 1) = 0;
      }
      while (v15 != v16);
      v19 = *(int64x2_t *)v2;
    }
    v7 = v14 + 16;
    *v2 = v17;
    v2[1] = v14 + 16;
    v23 = v19;
    v20 = v2[2];
    v2[2] = &v12[16 * v13];
    v24 = v20;
    v22 = v19.i64[0];
    result = (_QWORD *)std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    *v6 = v3;
    v7 = (char *)(v6 + 1);
  }
  v2[1] = v7;
  return result;
}

void TI::CP::Heap<std::shared_ptr<TI::CP::SearchNodeSource>,TI::CP::Search::step_search(unsigned int,BOOL,std::vector<std::shared_ptr<TI::CP::SearchNode const>> &)::SearchNodeCompare>::_upheapify(uint64_t *a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  __int128 v10;

  if (a2)
  {
    v2 = a2;
    do
    {
      v4 = v2 - 1;
      v5 = (v2 - 1) >> 1;
      v6 = *a1;
      v7 = *(_QWORD *)(*a1 + 16 * v2);
      v8 = (*(double (**)(uint64_t))(*(_QWORD *)v7 + 56))(v7);
      if (v8 <= (*(double (**)(_QWORD))(**(_QWORD **)(v6 + 16 * v5) + 56))(*(_QWORD *)(v6 + 16 * v5)))
        break;
      v9 = *a1;
      v10 = *(_OWORD *)(*a1 + 16 * v5);
      *(_OWORD *)(*a1 + 16 * v5) = *(_OWORD *)(*a1 + 16 * v2);
      *(_OWORD *)(v9 + 16 * v2) = v10;
      v2 = v4 >> 1;
    }
    while (v4 > 1);
  }
}

long double TI::CP::Search::key_substitution_cost(TI::CP::Search *this, unsigned int a2)
{
  long double v3;
  long double v4;
  double *v5;

  v3 = *((double *)this + 62);
  v4 = *((double *)this + 58);
  if (a2)
  {
    if (TI::CP::Path::inflection_point_count((TI::CP::Search *)((char *)this + 56), a2, a2))
      v5 = (double *)((char *)this + 488);
    else
      v5 = (double *)((char *)this + 472);
  }
  else
  {
    v5 = (double *)((char *)this + 480);
  }
  return -(pow(v3, v4) * *v5) * *((double *)this + 54);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeLoop>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105928;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeLoop>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105928;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<TI::CP::SearchNodeLoop>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeKeyPredictionExtensions>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1058F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeKeyPredictionExtensions>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1058F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<TI::CP::SearchNodeKeyPredictionExtensions>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeOvershoot>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1058B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeOvershoot>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1058B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<TI::CP::SearchNodeOvershoot>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeSkippedKey>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105880;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeSkippedKey>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105880;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<TI::CP::SearchNodeSkippedKey>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeForward>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105848;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeForward>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105848;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<TI::CP::SearchNodeForward>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeGeometryExtensions>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105810;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeGeometryExtensions>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105810;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<TI::CP::SearchNodeGeometryExtensions>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeLanguageExtensions>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1057D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeLanguageExtensions>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1057D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<TI::CP::SearchNodeLanguageExtensions>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__split_buffer<std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void **v4;
  void **v6;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = (void **)(i - 24);
    *(_QWORD *)(a1 + 16) = v4;
    v6 = v4;
    std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>::__destroy_vector::operator()[abi:nn180100](&v6);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void ___ZN2TI2CP6Search24compute_keys_near_sampleEj_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  __int16 v3;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  size_t v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  __int16 v15;
  TI::Favonius::LayoutKey *v16;
  uint64_t j;
  void *v18;
  BOOL v19;
  __int128 v20;
  _BYTE v21[96];
  _BYTE v22[8];
  void *v23;
  _BYTE v24[8];
  void *v25;
  uint64_t v26;
  CGRect v27;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  v3 = *(_WORD *)(*a2 + 60);
  if ((v3 & 0x20) == 0 && ((v3 & 0x30) == 0 || (v3 & 8) != 0))
  {
    v7 = *(_QWORD *)(a1 + 32);
    if (((*(_WORD *)(*a2 + 60) & 0xB81) == 0 || (*(_WORD *)(*a2 + 60) & 0x100) != 0 && !*(_DWORD *)(a1 + 64))
      && hypot(*(double *)(v2 + 96) - *(double *)(a1 + 40), *(double *)(v2 + 104) - *(double *)(a1 + 48))
       * *(double *)(v7 + 320) <= *(double *)(v7 + 496))
    {
      std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>::push_back[abi:nn180100](*(unsigned int ****)(a1 + 56), (unsigned int *)v2);
      if (TI::Favonius::KeyboardLayout::is_indic_alphabetic(*(TI::Favonius::KeyboardLayout **)(v7 + 8)))
      {
        KB::String::String((KB::String *)v24, (const KB::String *)(*a2 + 8));
        KB::String::String((KB::String *)v22, (const KB::String *)v24);
        TI::IndicUtils::convertVowel((const KB::String *)v22, (uint64_t)v21);
        if (v23 && v22[6] == 1)
          free(v23);
        for (i = 0; i != 96; i += 32)
        {
          if (!*(_WORD *)&v21[i + 4])
          {
            KB::String::compute_length((unsigned __int16 *)&v21[i]);
            if (!*(_WORD *)&v21[i + 4])
              continue;
          }
          if (!KB::String::equal((KB::String *)&v21[i], (const KB::String *)v24, 1))
          {
            v9 = *a2;
            v10 = *(unsigned __int16 *)(*a2 + 40);
            if (v10 < 0xF)
            {
              v20 = *(_OWORD *)(*a2 + 40);
              LODWORD(v10) = (unsigned __int16)v20;
            }
            else
            {
              LOWORD(v20) = *(_WORD *)(*a2 + 40);
              *((_QWORD *)&v20 + 1) = operator new[]();
              memcpy(*((void **)&v20 + 1), *(const void **)(v9 + 48), v10);
              v9 = *a2;
            }
            v11 = *(double *)(v9 + 64);
            v12 = *(double *)(v9 + 72);
            v13 = *(double *)(v9 + 80);
            v14 = *(double *)(v9 + 88);
            v15 = *(_WORD *)(v9 + 62);
            v16 = (TI::Favonius::LayoutKey *)operator new();
            v27.origin.x = v11;
            v27.origin.y = v12;
            v27.size.width = v13;
            v27.size.height = v14;
            TI::Favonius::LayoutKey::LayoutKey(v16, (const KB::String *)&v21[i], (const void **)&v20, v27, v15);
            if (v10 > 0xE && *((_QWORD *)&v20 + 1))
              MEMORY[0x1DF0A212C](*((_QWORD *)&v20 + 1), 0x1000C8077774924);
            std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>::push_back[abi:nn180100](*(unsigned int ****)(a1 + 56), (unsigned int *)v16);
            WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v16);
          }
        }
        for (j = 0; j != -96; j -= 32)
        {
          v18 = *(void **)&v21[j + 72];
          if (v18 && v21[j + 70] == 1)
            free(v18);
        }
        if (v25)
          v19 = v24[6] == 1;
        else
          v19 = 0;
        if (v19)
          free(v25);
      }
    }
  }
}

BOOL ___ZN2TI2CP6Search24compute_keys_near_sampleEj_block_invoke_2(uint64_t a1, CGRect **a2, CGRect **a3)
{
  uint64_t v5;
  double v6;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = TI::CP::Search::key_deviation_cost(v5, *(_DWORD *)(a1 + 40), *a2);
  return v6 > TI::CP::Search::key_deviation_cost(v5, *(_DWORD *)(a1 + 40), *a3);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::LayoutKey> const&,WTF::RefPtr<TI::Favonius::LayoutKey> const&),WTF::RefPtr<TI::Favonius::LayoutKey>*,false>(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t *v27;
  int v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  BOOL v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t i;
  uint64_t *v44;
  uint64_t v45;
  uint64_t *v46;
  int64_t v47;
  int64_t v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t *v77;
  uint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t v81;
  BOOL v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t *v88;
  uint64_t *v89;
  uint64_t v90;
  uint64_t *v91;
  int64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;

  v9 = (uint64_t *)result;
LABEL_2:
  v89 = a2;
  v91 = a2 - 1;
  v87 = a2 - 3;
  v88 = a2 - 2;
  v10 = v9;
  while (2)
  {
    v9 = v10;
    v11 = (char *)a2 - (char *)v10;
    v12 = a2 - v10;
    switch(v12)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        result = (*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))();
        if ((_DWORD)result)
        {
          v35 = *v10;
          *v10 = *v91;
          *v91 = v35;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(v10, v10 + 1, v91, a3);
      case 4uLL:
        return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(v10, v10 + 1, v10 + 2, v91, a3);
      case 5uLL:
        return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(v10, v10 + 1, v10 + 2, v10 + 3, v91, a3);
      default:
        if (v11 <= 191)
        {
          v36 = v10 + 1;
          v38 = v10 == a2 || v36 == a2;
          if ((a5 & 1) != 0)
          {
            if (!v38)
            {
              v39 = 0;
              do
              {
                v40 = v36;
                result = (*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))();
                if ((_DWORD)result)
                {
                  v41 = 0;
                  v42 = *v40;
                  *v40 = 0;
                  v95 = v42;
                  for (i = v39; ; i -= 8)
                  {
                    v44 = (uint64_t *)((char *)v10 + i);
                    v45 = *(uint64_t *)((char *)v10 + i);
                    *v44 = 0;
                    v44[1] = v45;
                    if (v41)
                      WTF::RefCounted<TI::Favonius::Key>::deref(v41);
                    if (!i)
                      break;
                    v46 = (uint64_t *)((char *)v10 + i);
                    if (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) == 0)
                      goto LABEL_80;
                    v41 = *v44;
                  }
                  v46 = v10;
LABEL_80:
                  result = *v46;
                  *v46 = v95;
                  a2 = v89;
                  if (result)
                  {
                    WTF::RefCounted<TI::Favonius::Key>::deref(result);
                    result = 0;
                  }
                }
                v36 = v40 + 1;
                v39 += 8;
              }
              while (v40 + 1 != a2);
            }
          }
          else if (!v38)
          {
            do
            {
              v83 = v36;
              result = (*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))();
              if ((_DWORD)result)
              {
                v84 = 0;
                v85 = *v83;
                *v83 = 0;
                v98 = v85;
                while (1)
                {
                  v86 = *v9;
                  *v9 = 0;
                  v9[1] = v86;
                  if (v84)
                    WTF::RefCounted<TI::Favonius::Key>::deref(v84);
                  if (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) == 0)
                    break;
                  v84 = *v9--;
                }
                result = *v9;
                *v9 = v98;
                if (result)
                {
                  WTF::RefCounted<TI::Favonius::Key>::deref(result);
                  result = 0;
                }
              }
              v36 = v83 + 1;
              v9 = v83;
            }
            while (v83 + 1 != a2);
          }
          return result;
        }
        if (!a4)
        {
          if (v10 != a2)
          {
            v47 = (v12 - 2) >> 1;
            v92 = v47;
            do
            {
              v48 = v47;
              if (v92 >= v47)
              {
                v49 = (2 * v47) | 1;
                v50 = &v9[v49];
                if (2 * v47 + 2 < (uint64_t)v12 && (*(unsigned int (**)(void))(*(_QWORD *)a3 + 16))())
                {
                  ++v50;
                  v49 = 2 * v48 + 2;
                }
                v51 = &v9[v48];
                a2 = v89;
                if (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) == 0)
                {
                  v52 = *v51;
                  *v51 = 0;
                  v96 = v52;
                  do
                  {
                    v53 = v50;
                    v54 = *v50;
                    *v50 = 0;
                    v55 = *v51;
                    *v51 = v54;
                    if (v55)
                      WTF::RefCounted<TI::Favonius::Key>::deref(v55);
                    if (v92 < v49)
                      break;
                    v56 = (2 * v49) | 1;
                    v50 = &v9[v56];
                    v57 = 2 * v49 + 2;
                    if (v57 < (uint64_t)v12 && (*(unsigned int (**)(void))(*(_QWORD *)a3 + 16))())
                    {
                      ++v50;
                      v56 = v57;
                    }
                    v51 = v53;
                    v49 = v56;
                  }
                  while (!(*(unsigned int (**)(void))(*(_QWORD *)a3 + 16))());
                  v58 = *v53;
                  *v53 = v96;
                  if (v58)
                    WTF::RefCounted<TI::Favonius::Key>::deref(v58);
                  a2 = v89;
                }
              }
              v47 = v48 - 1;
            }
            while (v48);
            v59 = (unint64_t)v11 >> 3;
            do
            {
              v60 = a2;
              v61 = 0;
              v62 = *v9;
              *v9 = 0;
              v63 = v59 - 2;
              v90 = v62;
              if (v59 < 2)
                v63 = v59 - 1;
              v64 = v63 >> 1;
              v65 = v9;
              do
              {
                v66 = &v65[v61 + 1];
                v67 = 2 * v61;
                v61 = (2 * v61) | 1;
                v68 = v67 + 2;
                if (v67 + 2 < v59 && (*(unsigned int (**)(void))(*(_QWORD *)a3 + 16))())
                {
                  ++v66;
                  v61 = v68;
                }
                v69 = *v66;
                *v66 = 0;
                v70 = *v65;
                *v65 = v69;
                if (v70)
                  WTF::RefCounted<TI::Favonius::Key>::deref(v70);
                v65 = v66;
              }
              while (v61 <= v64);
              v71 = v60 - 1;
              if (v66 == v71)
              {
                v74 = v71;
                result = *v66;
                *v66 = v90;
                if (result)
                  result = WTF::RefCounted<TI::Favonius::Key>::deref(result);
              }
              else
              {
                v72 = *v71;
                *v71 = 0;
                v73 = *v66;
                *v66 = v72;
                if (v73)
                  WTF::RefCounted<TI::Favonius::Key>::deref(v73);
                result = *v71;
                v74 = v71;
                *v71 = v90;
                if (result)
                  result = WTF::RefCounted<TI::Favonius::Key>::deref(result);
                v75 = (char *)(v66 + 1) - (char *)v9;
                if (v75 >= 9)
                {
                  v76 = (unint64_t)((v75 >> 3) - 2) >> 1;
                  v77 = &v9[v76];
                  result = (*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))();
                  if ((_DWORD)result)
                  {
                    v78 = *v66;
                    *v66 = 0;
                    v97 = v78;
                    do
                    {
                      v79 = v77;
                      v80 = *v77;
                      *v77 = 0;
                      v81 = *v66;
                      *v66 = v80;
                      if (v81)
                        WTF::RefCounted<TI::Favonius::Key>::deref(v81);
                      if (!v76)
                        break;
                      v76 = (v76 - 1) >> 1;
                      v77 = &v9[v76];
                      v66 = v79;
                    }
                    while (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) != 0);
                    result = *v79;
                    *v79 = v97;
                    if (result)
                    {
                      WTF::RefCounted<TI::Favonius::Key>::deref(result);
                      result = 0;
                    }
                  }
                }
              }
              v82 = v59-- <= 2;
              a2 = v74;
            }
            while (!v82);
          }
          return result;
        }
        v13 = &v10[v12 >> 1];
        if ((unint64_t)v11 < 0x401)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(&v10[v12 >> 1], v10, v91, a3);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(v10, &v10[v12 >> 1], v91, a3);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(v10 + 1, v13 - 1, v88, a3);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(v10 + 2, &v10[(v12 >> 1) + 1], v87, a3);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(v13 - 1, &v10[v12 >> 1], &v10[(v12 >> 1) + 1], a3);
          v14 = *v10;
          *v10 = *v13;
          *v13 = v14;
        }
        --a4;
        a2 = v89;
        if ((a5 & 1) == 0 && ((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) == 0)
        {
          v26 = *v10;
          *v10 = 0;
          v94 = v26;
          if (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) != 0)
          {
            do
              ++v10;
            while (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) == 0);
          }
          else
          {
            v27 = v10 + 1;
            do
            {
              v10 = v27;
              if (v27 >= v89)
                break;
              v28 = (*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))();
              v27 = v10 + 1;
            }
            while (!v28);
          }
          v29 = v89;
          if (v10 < v89)
          {
            v29 = v89;
            do
              --v29;
            while (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) != 0);
          }
          while (v10 < v29)
          {
            v30 = *v10;
            *v10 = *v29;
            *v29 = v30;
            do
              ++v10;
            while (!(*(unsigned int (**)(void))(*(_QWORD *)a3 + 16))());
            do
              --v29;
            while (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) != 0);
          }
          v31 = v10 - 1;
          if (v10 - 1 != v9)
          {
            v32 = *v31;
            *v31 = 0;
            v33 = *v9;
            *v9 = v32;
            if (v33)
              WTF::RefCounted<TI::Favonius::Key>::deref(v33);
          }
          v34 = *v31;
          *v31 = v94;
          if (v34)
            WTF::RefCounted<TI::Favonius::Key>::deref(v34);
          result = 0;
          a5 = 0;
          continue;
        }
        v15 = *v10;
        *v10 = 0;
        v93 = v15;
        v16 = v10;
        do
          v17 = v16++;
        while (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) != 0);
        v18 = v89;
        if (v17 == v10)
        {
          v18 = v89;
          do
          {
            if (v16 >= v18)
              break;
            --v18;
          }
          while (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) == 0);
        }
        else
        {
          do
            --v18;
          while (!(*(unsigned int (**)(void))(*(_QWORD *)a3 + 16))());
        }
        if (v16 < v18)
        {
          v19 = v16;
          v20 = v18;
          do
          {
            v21 = *v19;
            *v19 = *v20;
            *v20 = v21;
            do
              v17 = v19++;
            while (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) != 0);
            do
              --v20;
            while (!(*(unsigned int (**)(void))(*(_QWORD *)a3 + 16))());
          }
          while (v19 < v20);
        }
        if (v17 != v9)
        {
          v22 = *v17;
          *v17 = 0;
          v23 = *v9;
          *v9 = v22;
          if (v23)
            WTF::RefCounted<TI::Favonius::Key>::deref(v23);
        }
        v24 = *v17;
        *v17 = v93;
        if (v24)
          WTF::RefCounted<TI::Favonius::Key>::deref(v24);
        if (v16 < v18)
        {
LABEL_33:
          result = std::__introsort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::LayoutKey> const&,WTF::RefPtr<TI::Favonius::LayoutKey> const&),WTF::RefPtr<TI::Favonius::LayoutKey>*,false>(v9, v17, a3, a4, a5 & 1);
          a5 = 0;
          v10 = v17 + 1;
          continue;
        }
        v25 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::LayoutKey> const&,WTF::RefPtr<TI::Favonius::LayoutKey> const&),WTF::RefPtr<TI::Favonius::LayoutKey>*>(v9, v17, a3);
        v10 = v17 + 1;
        result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::LayoutKey> const&,WTF::RefPtr<TI::Favonius::LayoutKey> const&),WTF::RefPtr<TI::Favonius::LayoutKey>*>(v17 + 1, v89, a3);
        if (!(_DWORD)result)
        {
          if (v25)
            continue;
          goto LABEL_33;
        }
        a2 = v17;
        if (!v25)
          goto LABEL_2;
        return result;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::LayoutKey> const&,WTF::RefPtr<TI::Favonius::LayoutKey> const&),WTF::RefPtr<TI::Favonius::LayoutKey>*>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  _BOOL8 result;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  char *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;

  v6 = a2 - a1;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 1;
      if ((*(unsigned int (**)(void))(*(_QWORD *)a3 + 16))())
      {
        v9 = *a1;
        *a1 = *v8;
        *v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::TypingHypothesis> const&,WTF::RefPtr<TI::Favonius::TypingHypothesis> const&),WTF::RefPtr<TI::Favonius::TypingHypothesis>*>(a1, a1 + 1, a1 + 2, a3);
      v10 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    if ((*(unsigned int (**)(void))(*(_QWORD *)a3 + 16))())
    {
      v13 = 0;
      v14 = *v10;
      *v10 = 0;
      v20 = v14;
      for (i = v11; ; i -= 8)
      {
        v16 = (char *)a1 + i;
        v17 = *(uint64_t *)((char *)a1 + i + 16);
        *((_QWORD *)v16 + 2) = 0;
        *((_QWORD *)v16 + 3) = v17;
        if (v13)
          WTF::RefCounted<TI::Favonius::Key>::deref(v13);
        if (i == -16)
        {
          v18 = a1;
          goto LABEL_15;
        }
        if (((*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))() & 1) == 0)
          break;
        v13 = *((_QWORD *)v16 + 2);
      }
      v18 = (uint64_t *)((char *)a1 + i + 16);
LABEL_15:
      v19 = *v18;
      *v18 = v20;
      if (v19)
        WTF::RefCounted<TI::Favonius::Key>::deref(v19);
      if (++v12 == 8)
        return v10 + 1 == a2;
    }
    v11 += 8;
    if (++v10 == a2)
      return 1;
  }
}

long double TI::CP::Search::key_deviation_cost(uint64_t a1, unsigned int a2, CGRect *a3)
{
  TI::CP::Path *v6;
  double *v7;
  double v8;
  double v9;
  double y;
  double x;
  double v12;
  double v13;
  double v14;
  double v15;
  long double v16;
  double *v17;
  long double v18;

  v6 = (TI::CP::Path *)(a1 + 56);
  v7 = (double *)(*(_QWORD *)(a1 + 56) + 48 * a2);
  v8 = *v7;
  v9 = v7[1];
  x = a3[3].origin.x;
  y = a3[3].origin.y;
  if (CGRectGetWidth(a3[2]) > *(double *)(a1 + 312) * 3.0)
  {
    v12 = CGRectGetMinX(a3[2]) + *(double *)(a1 + 312);
    v13 = CGRectGetMaxX(a3[2]) - *(double *)(a1 + 312);
    if (v8 <= v13)
      v13 = v8;
    if (v8 >= v12)
      x = v13;
    else
      x = v12;
  }
  v14 = *(double *)(a1 + 320);
  v15 = *(double *)(a1 + 496);
  v16 = *(double *)(a1 + 464);
  if (a2)
  {
    if (TI::CP::Path::inflection_point_count(v6, a2, a2))
      v17 = (double *)(a1 + 488);
    else
      v17 = (double *)(a1 + 472);
  }
  else
  {
    v17 = (double *)(a1 + 480);
  }
  v18 = v14 * hypot(x - v8, y - v9);
  if (v15 < v18)
    v18 = v15;
  return *(double *)(a1 + 432) * -(pow(v18, v16) * *v17);
}

void (***TI::CP::Search::initialize_search(TI::CP::Search *this))(_QWORD, uint64_t *, char *)
{
  unint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  void (***result)(_QWORD, uint64_t *, char *);
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  char *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  char *v22;
  __int128 v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t v37;
  char *v38;
  _QWORD *v39;
  _QWORD *v40;
  char *v41;
  __int128 v42;
  _QWORD *v43;
  unint64_t v44;
  __int128 v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  unint64_t v49;
  _QWORD *v50;
  _QWORD *v51;
  unint64_t v52;
  char *v53;

  v3 = (_QWORD *)*((_QWORD *)this + 42);
  v2 = *((_QWORD *)this + 43);
  if ((unint64_t)v3 >= v2)
  {
    v5 = *((_QWORD *)this + 41);
    v6 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - v5) >> 3);
    v7 = v6 + 1;
    if (v6 + 1 > 0xAAAAAAAAAAAAAAALL)
LABEL_44:
      abort();
    v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v2 - v5) >> 3);
    if (2 * v8 > v7)
      v7 = 2 * v8;
    if (v8 >= 0x555555555555555)
      v9 = 0xAAAAAAAAAAAAAAALL;
    else
      v9 = v7;
    v53 = (char *)this + 344;
    if (v9)
      v9 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v9);
    else
      v10 = 0;
    v11 = (_QWORD *)(v9 + 24 * v6);
    v49 = v9;
    v50 = v11;
    v52 = v9 + 24 * v10;
    *v11 = 0;
    v11[1] = 0;
    v11[2] = 0;
    v51 = v11 + 3;
    std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer((_QWORD *)this + 41, &v49);
    v4 = (_QWORD *)*((_QWORD *)this + 42);
    std::__split_buffer<std::vector<std::shared_ptr<TI::CP::SearchNode const>>>::~__split_buffer((uint64_t)&v49);
  }
  else
  {
    *v3 = 0;
    v3[1] = 0;
    v4 = v3 + 3;
    v3[2] = 0;
  }
  *((_QWORD *)this + 42) = v4;
  result = (void (***)(_QWORD, uint64_t *, char *))*((_QWORD *)this + 22);
  if (result)
  {
    v46 = 0;
    v47 = 0;
    v48 = 0;
    (**result)(result, &v46, (char *)this + 400);
    if (v46)
    {
      v13 = v47;
      v14 = &v47[v46];
      do
      {
        v15 = *((_QWORD *)this + 42);
        v16 = *v13;
        if (*v13)
        {
          v17 = (unsigned int *)(v16 + 8);
          do
            v18 = __ldaxr(v17);
          while (__stlxr(v18 + 1, v17));
        }
        v19 = (char *)operator new(0xA0uLL);
        v20 = (std::__shared_weak_count *)v19;
        *((_QWORD *)v19 + 1) = 0;
        v21 = (unint64_t *)(v19 + 8);
        *((_QWORD *)v19 + 2) = 0;
        *(_QWORD *)v19 = &off_1EA105768;
        *((_QWORD *)v19 + 3) = &off_1EA0FE690;
        v22 = v19 + 24;
        *((_QWORD *)v19 + 4) = 0;
        *((_QWORD *)v19 + 5) = 0;
        *((_QWORD *)v19 + 7) = 0;
        *((_QWORD *)v19 + 8) = 0;
        *((_QWORD *)v19 + 6) = this;
        *((_DWORD *)v19 + 18) = -1;
        *((_QWORD *)v19 + 10) = 0;
        *((_QWORD *)v19 + 11) = v16;
        *(_WORD *)(v19 + 105) = 1;
        *((_QWORD *)v19 + 14) = 0;
        *((_QWORD *)v19 + 15) = 0;
        *((_QWORD *)v19 + 12) = 0;
        *((_QWORD *)v19 + 16) = 0;
        *((_QWORD *)v19 + 17) = 0;
        *((_QWORD *)v19 + 18) = 0;
        *((_QWORD *)v19 + 19) = 0;
        v19[104] = 1;
        *(_QWORD *)&v23 = v19 + 24;
        *((_QWORD *)&v23 + 1) = v19;
        v45 = v23;
        do
          v24 = __ldxr(v21);
        while (__stxr(v24 + 1, v21));
        v25 = (unint64_t *)(v19 + 16);
        do
          v26 = __ldxr(v25);
        while (__stxr(v26 + 1, v25));
        *((_QWORD *)v19 + 4) = v22;
        *((_QWORD *)v19 + 5) = v19;
        do
          v27 = __ldaxr(v21);
        while (__stlxr(v27 - 1, v21));
        if (!v27)
        {
          (*(void (**)(char *))(*(_QWORD *)v19 + 16))(v19);
          std::__shared_weak_count::__release_weak(v20);
        }
        v28 = *(_QWORD *)(v15 - 8);
        v29 = *(_QWORD **)(v15 - 16);
        if ((unint64_t)v29 >= v28)
        {
          v31 = *(_QWORD *)(v15 - 24);
          v32 = ((uint64_t)v29 - v31) >> 4;
          v33 = v32 + 1;
          if ((unint64_t)(v32 + 1) >> 60)
            goto LABEL_44;
          v34 = v28 - v31;
          if (v34 >> 3 > v33)
            v33 = v34 >> 3;
          if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0)
            v35 = 0xFFFFFFFFFFFFFFFLL;
          else
            v35 = v33;
          v53 = (char *)(v15 - 8);
          v36 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v35);
          v38 = &v36[16 * v32];
          *(_OWORD *)v38 = v45;
          v40 = *(_QWORD **)(v15 - 24);
          v39 = *(_QWORD **)(v15 - 16);
          if (v39 == v40)
          {
            v43 = *(_QWORD **)(v15 - 16);
            v41 = &v36[16 * v32];
          }
          else
          {
            v41 = &v36[16 * v32];
            do
            {
              v42 = *((_OWORD *)v39 - 1);
              v39 -= 2;
              *((_OWORD *)v41 - 1) = v42;
              v41 -= 16;
              *v39 = 0;
              v39[1] = 0;
            }
            while (v39 != v40);
            v43 = *(_QWORD **)(v15 - 24);
            v39 = *(_QWORD **)(v15 - 16);
          }
          v30 = v38 + 16;
          *(_QWORD *)(v15 - 24) = v41;
          v50 = v43;
          *(_QWORD *)(v15 - 16) = v38 + 16;
          v51 = v39;
          v44 = *(_QWORD *)(v15 - 8);
          *(_QWORD *)(v15 - 8) = &v36[16 * v37];
          v52 = v44;
          v49 = (unint64_t)v43;
          std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v49);
        }
        else
        {
          *v29 = v22;
          v29[1] = v20;
          v30 = v29 + 2;
        }
        *(_QWORD *)(v15 - 16) = v30;
        ++v13;
      }
      while (v13 != v14);
    }
    return (void (***)(_QWORD, uint64_t *, char *))WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::~Vector((uint64_t)&v46);
  }
  return result;
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeRoot>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105768;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TI::CP::SearchNodeRoot>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105768;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<TI::CP::SearchNodeRoot>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t TI::CP::Search::Search(uint64_t a1, uint64_t *a2, uint64_t *a3, __int128 *a4)
{
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  *(_QWORD *)a1 = &off_1EA1055A8;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = *a4;
  v9 = a4[1];
  *(_QWORD *)(a1 + 48) = *((_QWORD *)a4 + 4);
  *(_OWORD *)(a1 + 16) = v8;
  *(_OWORD *)(a1 + 32) = v9;
  std::vector<TI::CP::PathSample>::vector((_QWORD *)(a1 + 56), (uint64_t)a4 + 40);
  std::vector<unsigned int>::vector((std::vector<unsigned int> *)(a1 + 80), (const std::vector<unsigned int> *)(a4 + 4));
  std::vector<TI::CP::PathSample>::vector((_QWORD *)(a1 + 104), (uint64_t)a4 + 88);
  std::vector<unsigned int>::vector((std::vector<unsigned int> *)(a1 + 128), (const std::vector<unsigned int> *)(a4 + 7));
  v10 = *((_QWORD *)a4 + 17);
  *(_DWORD *)(a1 + 160) = *((_DWORD *)a4 + 36);
  *(_QWORD *)(a1 + 152) = v10;
  *(_DWORD *)(a1 + 168) = 7;
  v11 = *a2;
  *a2 = 0;
  v12 = *a3;
  *a3 = 0;
  *(_QWORD *)(a1 + 176) = v11;
  *(_QWORD *)(a1 + 184) = v12;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 272));
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 280));
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 386) = 0u;
  *(_DWORD *)(a1 + 402) = 16;
  *(_BYTE *)(a1 + 406) = 0;
  *(_QWORD *)(a1 + 408) = 0;
  *(_BYTE *)(a1 + 416) = 0;
  *(_OWORD *)(a1 + 432) = xmmword_1DA911160;
  *(_OWORD *)(a1 + 448) = xmmword_1DA911170;
  *(_OWORD *)(a1 + 464) = xmmword_1DA911180;
  *(_OWORD *)(a1 + 480) = xmmword_1DA911190;
  *(_OWORD *)(a1 + 496) = xmmword_1DA9111A0;
  *(_OWORD *)(a1 + 512) = xmmword_1DA9111B0;
  *(_OWORD *)(a1 + 528) = xmmword_1DA9111C0;
  *(_OWORD *)(a1 + 544) = xmmword_1DA9110E0;
  *(_QWORD *)(a1 + 560) = 0x403E000000000000;
  *(_BYTE *)(a1 + 568) = 1;
  __asm { FMOV            V0.2D, #10.0 }
  *(_OWORD *)(a1 + 576) = _Q0;
  return a1;
}

uint64_t TI::CP::Search::keys_near_sample(TI::CP::Search *this, unsigned int a2)
{
  return *((_QWORD *)this + 47) + 24 * a2;
}

uint64_t TI::CP::Search::extend_typing@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, unsigned int a4@<W3>, unsigned int **a5@<X8>)
{
  uint64_t v8;
  uint64_t v10;
  unsigned int **v11;
  uint64_t v12;
  unsigned int **v13;
  unsigned int **v14;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int *v18;
  int v19;
  unsigned int *v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int *v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int *v39;
  unsigned int *v40;
  unsigned int v41;
  unsigned int *v42;
  unsigned int *v43;
  unsigned int **v44;
  uint64_t v45;
  unsigned int *v46;
  _QWORD v47[2];
  uint64_t (*v48)(_QWORD *, unsigned int **);
  void *v49;
  uint64_t *v50;

  v8 = result;
  if (*(_BYTE *)(a2 + 82))
  {
    v10 = *(_QWORD *)(a2 + 88);
    v11 = *(unsigned int ***)(a2 + 96);
    v47[0] = MEMORY[0x1E0C809B0];
    v47[1] = 0x40000000;
    v48 = (uint64_t (*)(_QWORD *, unsigned int **))___ZNK2TI2CP6Search13extend_typingEPKNS0_10SearchNodeERKN3WTF6RefPtrINS_8Favonius9LayoutKeyEEEj_block_invoke;
    v49 = &__block_descriptor_tmp_5_16427;
    v50 = a3;
    if (v10)
    {
      v12 = 8 * v10;
      v13 = &v11[v10];
      while (1)
      {
        result = v48(v47, v11);
        if ((result & 1) != 0)
          break;
        ++v11;
        v12 -= 8;
        if (!v12)
        {
          v11 = v13;
          break;
        }
      }
      v14 = v11;
      v11 = *(unsigned int ***)(a2 + 96);
    }
    else
    {
      v14 = v11;
    }
    if (v14 == &v11[*(_QWORD *)(a2 + 88)])
    {
      if (*(_WORD *)(*a3 + 40))
      {
        *a5 = 0;
        return result;
      }
    }
    else
    {
      v15 = *v14;
      *a5 = v15;
      if (v15)
      {
        v16 = v15 + 2;
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 + 1, v16));
        v18 = *a5;
      }
      else
      {
        v18 = 0;
      }
      v19 = *(unsigned __int16 *)(*a3 + 40);
      if (v19 == *(unsigned __int16 *)(*(_QWORD *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v18 + 16))(v18)
                                      + 40))
      {
        result = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v18 + 16))(v18);
        if (*(_QWORD *)result != *a3)
        {
          result = KB::String::equal((KB::String *)(*(_QWORD *)result + 8), (const KB::String *)(*a3 + 8), 1);
          if ((result & 1) == 0)
          {
            v20 = (unsigned int *)*a3;
            v46 = v20;
            v21 = v18;
            if (v20)
            {
              do
                v22 = __ldaxr(v20);
              while (__stlxr(v22 + 1, v20));
              v21 = *a5;
            }
            (*(void (**)(unsigned int **__return_ptr, unsigned int *, unsigned int **))(*(_QWORD *)v18 + 216))(&v43, v18, &v46);
            v23 = v43;
            v43 = 0;
            *a5 = v23;
            if (v21)
            {
              v24 = v21 + 2;
              v25 = atomic_load(v21 + 2);
              if (v25 == 1)
              {
                (*(void (**)(unsigned int *))(*(_QWORD *)v21 + 248))(v21);
              }
              else
              {
                do
                  v26 = __ldaxr(v24);
                while (__stlxr(v26 - 1, v24));
              }
              if (v43)
              {
                v27 = v43 + 2;
                v28 = atomic_load(v43 + 2);
                if (v28 == 1)
                {
                  (*(void (**)(void))(*(_QWORD *)v43 + 248))();
                }
                else
                {
                  do
                    v29 = __ldaxr(v27);
                  while (__stlxr(v29 - 1, v27));
                }
              }
            }
            result = (uint64_t)v46;
            if (v46)
              return WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v46);
          }
        }
        return result;
      }
      v30 = v18 + 2;
      v31 = atomic_load(v18 + 2);
      if (v31 == 1)
      {
        (*(void (**)(unsigned int *))(*(_QWORD *)v18 + 248))(v18);
      }
      else
      {
        do
          v32 = __ldaxr(v30);
        while (__stlxr(v32 - 1, v30));
      }
    }
  }
  result = TI::CP::Search::find_clone_in_prev_beam(v8, *(_QWORD *)(a2 + 64), *a3, a4);
  if (result)
  {
    v33 = *(unsigned int **)(result + 64);
    *a5 = v33;
    if (v33)
    {
      v34 = v33 + 2;
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 + 1, v34));
    }
  }
  else
  {
    v43 = 0;
    v44 = 0;
    v45 = 0;
    v36 = *(_QWORD *)(a2 + 64);
    v37 = (unsigned int *)*a3;
    v42 = v37;
    if (v37)
    {
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 + 1, v37));
    }
    (*(void (**)(uint64_t, unsigned int **, unsigned int **))(*(_QWORD *)v36 + 40))(v36, &v43, &v42);
    if (v42)
      WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v42);
    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)*v44 + 160))(*v44))
    {
      v39 = *v44;
      *a5 = *v44;
      if (v39)
      {
        v40 = v39 + 2;
        do
          v41 = __ldaxr(v40);
        while (__stlxr(v41 + 1, v40));
      }
    }
    else
    {
      *a5 = 0;
    }
    return WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::~Vector((uint64_t)&v43);
  }
  return result;
}

BOOL ___ZNK2TI2CP6Search13extend_typingEPKNS0_10SearchNodeERKN3WTF6RefPtrINS_8Favonius9LayoutKeyEEEj_block_invoke(uint64_t a1, _QWORD *a2)
{
  KB::ByteString *v2;
  const ByteString *v3;

  v2 = (KB::ByteString *)(**(_QWORD **)(a1 + 32) + 40);
  v3 = (const ByteString *)(*(_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 16))(*a2) + 40);
  return KB::ByteString::starts_with(v2, v3);
}

uint64_t TI::CP::Search::find_clone_in_prev_beam(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v9;
  uint64_t result;

  if (!a3)
    return 0;
  v4 = *(_QWORD *)(a1 + 328) + 24 * a4;
  v5 = *(_QWORD **)v4;
  v6 = *(_QWORD **)(v4 + 8);
  if (*(_QWORD **)v4 == v6)
    return 0;
  while (1)
  {
    v9 = *(_QWORD *)(*v5 + 32);
    if (v9)
    {
      if (*(_QWORD *)(v9 + 64) == a2)
      {
        if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)*v5 + 104))(*v5))
        {
          result = *v5;
          if (*(_QWORD *)(*v5 + 56) == a3)
            break;
        }
      }
    }
    v5 += 2;
    if (v5 == v6)
      return 0;
  }
  return result;
}

double TI::CP::Search::top_score(TI::CP::Search *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 42);
  if (*((_QWORD *)this + 41) == v1)
    return -INFINITY;
  else
    return *(double *)(**(_QWORD **)(v1 - 24) + 72);
}

double TI::CP::Search::path_deviation_cost(TI::CP::Search *this, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v8;
  double *v9;
  double *v10;
  double v11;
  long double v12;
  double v13;
  double v14;

  v8 = *((_QWORD *)this + 7);
  v9 = (double *)(v8 + 48 * a2);
  v10 = (double *)(v8 + 48 * a3);
  v11 = v10[4] - v9[4];
  v12 = hypot(*v10 - *v9, v10[1] - v9[1]);
  v13 = pow((v11 - v12) * *((double *)this + 40), *((long double *)this + 56));
  v14 = *((double *)this + 57);
  return *((double *)this + 54)
       * (-(*((double *)this + 66)
          * (double)TI::CP::Search::skipped_inflection_point_count(this, a2, a3, a4))
        - v13 * v14);
}

unint64_t TI::CP::Search::skipped_inflection_point_count(TI::CP::Search *this, int a2, unsigned int a3, int a4)
{
  unint64_t v7;

  if (a2 + 2 > a3)
  {
    v7 = 0;
    if (!a4)
      return v7;
    return TI::CP::Path::inflection_point_count((TI::CP::Search *)((char *)this + 56), a3, a3)
         + v7;
  }
  v7 = TI::CP::Path::inflection_point_count((TI::CP::Search *)((char *)this + 56), a2 + 1, a3 - 1);
  if (a4)
    return TI::CP::Path::inflection_point_count((TI::CP::Search *)((char *)this + 56), a3, a3)
         + v7;
  return v7;
}

double TI::CP::Search::extended_path_deviation_cost(TI::CP::Search *this, unsigned int a2, unsigned int a3, CGPoint a4)
{
  double y;
  double x;
  uint64_t v9;
  double *v10;
  double *v11;
  double v12;
  long double v13;
  long double v14;
  double v15;
  double v16;

  y = a4.y;
  x = a4.x;
  v9 = *((_QWORD *)this + 7);
  v10 = (double *)(v9 + 48 * a3);
  v11 = (double *)(v9 + 48 * a2);
  v12 = v10[4] - v11[4];
  v13 = v12 + hypot(a4.x - *v10, a4.y - v10[1]);
  v14 = hypot(x - *v11, y - v11[1]);
  v15 = pow((v13 - v14) * *((double *)this + 40), *((long double *)this + 56));
  v16 = *((double *)this + 57);
  return *((double *)this + 54)
       * (-(*((double *)this + 66)
          * (double)TI::CP::Search::skipped_inflection_point_count(this, a2, a3, 1))
        - v15 * v16);
}

double TI::CP::Search::key_deviation_weight(TI::CP::Search *this, unsigned int a2)
{
  int v3;
  char *v4;

  if (a2)
  {
    v3 = TI::CP::Path::inflection_point_count((TI::CP::Search *)((char *)this + 56), a2, a2);
    v4 = (char *)this + 472;
    if (v3)
      v4 = (char *)this + 488;
  }
  else
  {
    v4 = (char *)this + 480;
  }
  return *(double *)v4;
}

double TI::CP::Search::skipped_key_cost(TI::CP::Search *this, unsigned int a2)
{
  double v3;
  int v4;
  double *v5;

  v3 = *((double *)this + 63);
  if (a2)
  {
    v4 = TI::CP::Path::inflection_point_count((TI::CP::Search *)((char *)this + 56), a2, a2);
    v5 = (double *)((char *)this + 472);
    if (v4)
      v5 = (double *)((char *)this + 488);
  }
  else
  {
    v5 = (double *)((char *)this + 480);
  }
  return -(v3 * *v5) * *((double *)this + 54);
}

double TI::CP::Search::overshoot_cost(TI::CP::Search *this, unsigned int a2, unsigned int a3)
{
  double v6;
  double v7;

  v6 = pow((*(double *)(*((_QWORD *)this + 7) + 48 * a3 + 32) - *(double *)(*((_QWORD *)this + 7) + 48 * a2 + 32))* *((double *)this + 40), *((long double *)this + 64));
  v7 = *((double *)this + 65);
  return *((double *)this + 54)
       * (-(*((double *)this + 66)
          * (double)TI::CP::Search::skipped_inflection_point_count(this, a2, a3, 1))
        - v6 * v7);
}

void TI::CP::Search::loop_cost(TI::CP::Search *this, unsigned int a2, unsigned int a3)
{
  double v3;
  double v4;
  uint64_t v5;
  double v6;
  double v7;

  v3 = *((double *)this + 39);
  v4 = *((double *)this + 67) * v3;
  v5 = *((_QWORD *)this + 7);
  v6 = *(double *)(v5 + 48 * a3 + 32) - *(double *)(v5 + 48 * a2 + 32);
  v7 = v3 * *((double *)this + 68);
  if (v6 >= v4 && v6 <= v7)
    hypot(*(double *)(v5 + 48 * a3) - *(double *)(v5 + 48 * a2), *(double *)(v5 + 48 * a3 + 8) - *(double *)(v5 + 48 * a2 + 8));
}

double TI::CP::Search::language_cost(uint64_t a1, uint64_t a2)
{
  float v3;

  v3 = (*(float (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
  return *(double *)(a1 + 440) * logf(v3);
}

double TI::CP::Search::language_termination_cost(uint64_t a1, uint64_t a2)
{
  float v3;

  v3 = (*(float (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2);
  return *(double *)(a1 + 440) * logf(v3);
}

double TI::CP::Search::language_extension_cost(uint64_t a1, uint64_t a2)
{
  float v3;

  v3 = (*(float (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2);
  return *(double *)(a1 + 440) * logf(1.0 - v3);
}

double TI::CP::Search::transposition_cost(TI::CP::Search *this)
{
  return -(*((double *)this + 70) * *((double *)this + 54));
}

double TI::CP::Search::key_prediction_cost(TI::CP::Search *this, int a2)
{
  uint64_t v2;

  v2 = 584;
  if (!a2)
    v2 = 576;
  return -(*(double *)((char *)this + v2) * *((double *)this + 54));
}

void TI::CP::Search::append_debug_data_for_sample(uint64_t a1, __CFString *a2, uint64_t a3, TI::CP::SearchNode ***a4, int a5)
{
  uint64_t v9;
  TI::CP::Path *v10;
  CGFloat *v11;
  double v12;
  double v13;
  double v14;
  double *v15;
  int v16;
  double v17;
  double v18;
  const char *v19;
  const char *v20;
  const char *v21;
  const char *v22;
  const char *v23;
  TI::CP::SearchNode **v24;
  TI::CP::SearchNode **v25;
  void *p_p;
  double v27;
  const char *v28;
  void *__p;
  void *v30;
  char v31;
  char v32;
  uint64_t v33;
  CGPoint v34;

  v33 = *MEMORY[0x1E0C80C00];
  v10 = (TI::CP::Path *)(a1 + 56);
  v9 = *(_QWORD *)(a1 + 56);
  v11 = (CGFloat *)(v9 + 48 * a3);
  v12 = *v11;
  v13 = v11[1];
  v14 = v11[2] - *(double *)(v9 + 16);
  v34.x = *v11;
  v34.y = v13;
  TI::Favonius::KeyboardLayout::find_nearest_key(*(unsigned int **)(a1 + 8), v34, (unsigned int **)&__p);
  v15 = (double *)__p;
  v16 = TI::CP::Path::inflection_point_count(v10, a3, a3);
  v17 = v12 - v15[12];
  v18 = v13 - v15[13];
  LODWORD(__p) = 0x100000;
  WORD2(__p) = 0;
  BYTE6(__p) = 0;
  v30 = 0;
  v31 = 0;
  TI::Favonius::Key::append_debug_data((TI::Favonius::Key *)v15, (KB::String *)&__p);
  v20 = (const char *)v30;
  if (!v30)
    v20 = &v31;
  if ((_WORD)__p)
    v21 = v20;
  else
    v21 = "";
  v22 = "true";
  if (v16)
    v23 = "true";
  else
    v23 = "false";
  if (!a5)
    v22 = "false";
  KB::append_format(a2, (__CFString *)"search %u @ (%.2f, %.2f) = '%s' + (%.2f, %.2f), t = %.2f, inflection_point = %s, final = %s:\n", v19, a3, *(_QWORD *)&v12, *(_QWORD *)&v13, v21, *(_QWORD *)&v17, *(_QWORD *)&v18, *(_QWORD *)&v14, v23, v22);
  if (v30 && BYTE6(__p) == 1)
    free(v30);
  v24 = *a4;
  v25 = a4[1];
  if (*a4 == v25)
    goto LABEL_22;
  do
  {
    (*(void (**)(void **__return_ptr))(*(_QWORD *)*v24 + 64))(&__p);
    if (v32 >= 0)
      p_p = &__p;
    else
      p_p = __p;
    v27 = TI::CP::SearchNode::score_at_sample_index(*v24, a3);
    KB::append_format(a2, (__CFString *)"    %s (s=%g here)\n", v28, p_p, *(_QWORD *)&v27);
    if (v32 < 0)
      operator delete(__p);
    v24 += 2;
  }
  while (v24 != v25);
  if (v15)
LABEL_22:
    WTF::RefCounted<TI::Favonius::Key>::deref((uint64_t)v15);
}

void TI::CP::Search::append_debug_data(TI::CP::Search *this, __CFString *a2, const char *a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int v9;

  KB::append_format(a2, (__CFString *)"CONTINUOUS PATH SEARCH STATE:\n", a3);
  v5 = *((_QWORD *)this + 8) - *((_QWORD *)this + 7);
  if (v5)
  {
    v6 = 0;
    v7 = 0xAAAAAAAAAAAAAAABLL * (v5 >> 4);
    do
    {
      v8 = (v6 + 1);
      v9 = v7 > v8 && *((_BYTE *)this + 152) != 0;
      TI::CP::Search::append_debug_data_for_sample((uint64_t)this, a2, v6, (TI::CP::SearchNode ***)(*((_QWORD *)this + 41) + 24 * v8), v9);
      v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 8) - *((_QWORD *)this + 7)) >> 4);
      v6 = v8;
    }
    while (v7 > v8);
  }
}

void KB::TypologyLogger::~TypologyLogger(KB::TypologyLogger *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1EA105998;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 1) = 0;
}

{
  const void *v2;

  *(_QWORD *)this = &off_1EA105998;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x1DF0A2144);
}

{
  const void *v2;

  *(_QWORD *)this = &off_1EA105998;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 1) = 0;
}

void KB::TypologyLogger::log_autocorrection_engine_state(KB::TypologyLogger *this, const TI::Favonius::StrokeBuildManager *a2)
{
  (*(void (**)(const TI::Favonius::StrokeBuildManager *, _QWORD))(*(_QWORD *)a2 + 256))(a2, *((_QWORD *)this + 1));
  CFStringAppend(*((CFMutableStringRef *)this + 1), CFSTR("------------------------------\n"));
}

void KB::TypologyLogger::log_candidates(CFMutableStringRef *a1, uint64_t a2, unsigned int a3, uint64_t a4, KB::Candidate **a5, const __CFString *a6, KB::Candidate **a7, CFStringRef *a8)
{
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  const char *v19;
  KB::Candidate *v20;
  KB::Candidate *v21;
  __int128 v22;
  std::string::size_type size;
  char v24;
  __CFString *v25;
  std::string *v26;
  const __CFString *v27;
  std::string v28;
  int v29;
  __int16 v30;
  char v31;
  void *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v29 = 0x100000;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v13 = *(const char **)(a2 + 8);
  if (!v13)
    v13 = (const char *)(a2 + 16);
  if (*(_WORD *)a2)
    v14 = v13;
  else
    v14 = "";
  if (a3 > 5)
    v15 = "Unknown";
  else
    v15 = off_1EA1059B8[a3];
  v16 = *(const char **)(a4 + 8);
  if (!v16)
    v16 = (const char *)(a4 + 16);
  if (*(_WORD *)a4)
    v17 = v16;
  else
    v17 = "";
  KB::String::append_format((KB::String *)&v29, "Typed String: \"%s\"  Lookup Type: %s  State Description: \"%s\"\n", v14, v15, v17);
  v18 = (const char *)v32;
  if (!v32)
    v18 = &v33;
  if ((_WORD)v29)
    v19 = v18;
  else
    v19 = "";
  CFStringAppendCString(a1[1], v19, 0x8000100u);
  KB::TypologyLogger::build_debug_candidate(a1, a5, "Raw Candidates", 1);
  if (a6)
  {
    CFStringAppend(a1[1], CFSTR("\n"));
    CFStringAppend(a1[1], a6);
  }
  KB::TypologyLogger::build_debug_candidate(a1, a7, "Candidates", 0);
  if (*a8)
  {
    CFStringAppend(a1[1], CFSTR("\n"));
    CFStringAppend(a1[1], *a8);
  }
  v20 = *a5;
  v21 = a5[1];
  if (*a5 != v21)
  {
    do
    {
      if (*((char *)v20 + 943) < 0)
      {
        std::string::__init_copy_ctor_external(&v28, *((const std::string::value_type **)v20 + 115), *((_QWORD *)v20 + 116));
      }
      else
      {
        v22 = *(_OWORD *)((char *)v20 + 920);
        v28.__r_.__value_.__r.__words[2] = *((_QWORD *)v20 + 117);
        *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v22;
      }
      size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
      v24 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        size = v28.__r_.__value_.__l.__size_;
      if (size)
      {
        CFStringAppend(a1[1], CFSTR("-------------------------------\n"));
        CFStringAppend(a1[1], CFSTR("Raw candidate tracelogs from LM\n"));
        CFStringAppend(a1[1], CFSTR("\n"));
        v25 = a1[1];
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = &v28;
        else
          v26 = (std::string *)v28.__r_.__value_.__r.__words[0];
        v27 = CFStringCreateWithCString(0, (const char *)v26, 0x8000100u);
        CFStringAppend(v25, v27);
        CFStringAppend(a1[1], CFSTR("\n"));
        CFStringAppend(a1[1], CFSTR("-------------------------------\n"));
        v24 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
      }
      if (v24 < 0)
        operator delete(v28.__r_.__value_.__l.__data_);
      v20 = (KB::Candidate *)((char *)v20 + 1000);
    }
    while (v20 != v21);
  }
  if (v32)
  {
    if (v31 == 1)
      free(v32);
  }
}

void KB::TypologyLogger::build_debug_candidate(CFMutableStringRef *this, KB::Candidate **a2, const char *a3, int a4)
{
  KB::Candidate *v7;
  KB::Candidate *i;
  __CFString *v9;
  BOOL v10;
  int v11;
  __int16 v12;
  char v13;
  void *v14;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (*a2 != a2[1])
  {
    CFStringAppendFormat(this[1], 0, CFSTR("\n%s\n"), a3);
    v7 = *a2;
    for (i = a2[1]; v7 != i; v7 = (KB::Candidate *)((char *)v7 + 1000))
    {
      v9 = this[1];
      v11 = 0x100000;
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      KB::Candidate::append_debug_data(v7, v9, a4, (const KB::String *)&v11);
      if (v14)
        v10 = v13 == 1;
      else
        v10 = 0;
      if (v10)
        free(v14);
    }
  }
}

KB::TypologyLogger *KB::TypologyLogger::TypologyLogger(KB::TypologyLogger *this)
{
  *(_QWORD *)this = &off_1EA105998;
  *((_QWORD *)this + 1) = CFStringCreateMutable(0, 0);
  return this;
}

{
  *(_QWORD *)this = &off_1EA105998;
  *((_QWORD *)this + 1) = CFStringCreateMutable(0, 0);
  return this;
}

const char *KB::TypologyLogger::description_for_lookup_type(uint64_t a1, unsigned int a2)
{
  if (a2 > 5)
    return "Unknown";
  else
    return off_1EA1059B8[a2];
}

void KB::TypologyLogger::log_string(CFMutableStringRef *this, const __CFString *a2)
{
  if (a2)
    CFStringAppend(this[1], a2);
}

void KB::TypologyLogger::clear(KB::TypologyLogger *this)
{
  CFMutableStringRef Mutable;
  const void *v3;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = (const void *)*((_QWORD *)this + 1);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 1) = Mutable;
}

void *__getSBSSetTypingActiveSymbolLoc_block_invoke(uint64_t a1)
{
  void *v2;
  void *result;
  void *v4;

  if (SpringBoardServicesLibraryCore_frameworkLibrary_16605)
  {
    v2 = (void *)SpringBoardServicesLibraryCore_frameworkLibrary_16605;
  }
  else
  {
    SpringBoardServicesLibraryCore_frameworkLibrary_16605 = _sl_dlopen();
    v2 = (void *)SpringBoardServicesLibraryCore_frameworkLibrary_16605;
    if (!SpringBoardServicesLibraryCore_frameworkLibrary_16605)
    {
      v4 = (void *)abort_report_np();
      free(v4);
    }
  }
  result = dlsym(v2, "SBSSetTypingActive");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  getSBSSetTypingActiveSymbolLoc_ptr = *(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

Class __getPSPointerClientControllerClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!PointerUIServicesLibraryCore_frameworkLibrary)
  {
    PointerUIServicesLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!PointerUIServicesLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("PSPointerClientController");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getPSPointerClientControllerClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __Block_byref_object_copy__16979(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__16980(uint64_t a1)
{

}

id TILanguageModelScheduleMaintenance()
{
  if (objc_msgSend(MEMORY[0x1E0CB3978], "isMainThread"))
    return +[TILanguageModelMaintainer sharedLanguageModelMaintainer](TILanguageModelMaintainer, "sharedLanguageModelMaintainer");
  else
    return (id)TIDispatchAsync();
}

void KB::CompositeCandidateFilter::~CompositeCandidateFilter(KB::CompositeCandidateFilter *this)
{
  void **v1;

  *(_QWORD *)this = &off_1EA105D58;
  v1 = (void **)((char *)this + 8);
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

{
  void **v1;

  *(_QWORD *)this = &off_1EA105D58;
  v1 = (void **)((char *)this + 8);
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v1);
  JUMPOUT(0x1DF0A2144);
}

const char *KB::CompositeCandidateFilter::filter_description(KB::CompositeCandidateFilter *this)
{
  return "CompositeCandidateFilter";
}

void KB::CompositeCandidateFilter::filter_candidates(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v4;
  uint64_t *i;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;

  v4 = *(uint64_t **)(a1 + 8);
  for (i = *(uint64_t **)(a1 + 16); v4 != i; v4 += 2)
  {
    v9 = *v4;
    v10 = (std::__shared_weak_count *)v4[1];
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    if (v9 && (*a2 != a2[1] || a2[6] != a2[7] || a2[9] != a2[10]))
      (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 24))(v9, a2, a3, a4);
    if (v10)
    {
      v13 = (unint64_t *)&v10->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
}

__n128 KB::CompositeCandidateFilter::CompositeCandidateFilter(_QWORD *a1, __n128 *a2)
{
  __n128 result;

  *a1 = &off_1EA105D58;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  result = *a2;
  *(__n128 *)(a1 + 1) = *a2;
  a1[3] = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

{
  __n128 result;

  *a1 = &off_1EA105D58;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  result = *a2;
  *(__n128 *)(a1 + 1) = *a2;
  a1[3] = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

id getSRKeyboardProbabilityMetricClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getSRKeyboardProbabilityMetricClass_softClass;
  v7 = getSRKeyboardProbabilityMetricClass_softClass;
  if (!getSRKeyboardProbabilityMetricClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getSRKeyboardProbabilityMetricClass_block_invoke;
    v3[3] = &unk_1EA107058;
    v3[4] = &v4;
    __getSRKeyboardProbabilityMetricClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

Class __getSRKeyboardProbabilityMetricClass_block_invoke(uint64_t a1)
{
  Class result;

  SensorKitLibrary_17284();
  result = objc_getClass("SRKeyboardProbabilityMetric");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getSRKeyboardProbabilityMetricClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    return (Class)SensorKitLibrary_17284();
  }
  return result;
}

uint64_t SensorKitLibrary_17284()
{
  uint64_t v0;
  void *v2;

  if (SensorKitLibraryCore_frameworkLibrary_17287)
    return SensorKitLibraryCore_frameworkLibrary_17287;
  SensorKitLibraryCore_frameworkLibrary_17287 = _sl_dlopen();
  v0 = SensorKitLibraryCore_frameworkLibrary_17287;
  if (!SensorKitLibraryCore_frameworkLibrary_17287)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

Class __getSRKeyboardMetricsClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;
  SEL v4;

  SensorKitLibrary_17284();
  result = objc_getClass("SRKeyboardMetrics");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getSRKeyboardMetricsClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v3 = (void *)abort_report_np();
    return (Class)+[TISKSessionStats supportsSecureCoding](v3, v4);
  }
  return result;
}

KB::StaticDictionaryCursor *KB::StaticDictionaryCursor::StaticDictionaryCursor(KB::StaticDictionaryCursor *this, const KB::StaticDictionary *a2)
{
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 0;
  KB::StaticDictionaryCursor::reset(this, a2);
  return this;
}

{
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 0;
  KB::StaticDictionaryCursor::reset(this, a2);
  return this;
}

void KB::StaticDictionaryCursor::reset(KB::StaticDictionaryCursor *this, const KB::StaticDictionary *a2)
{
  uint64_t v3;
  unint64_t v5;
  uint64_t RootCursor;
  const void *v7;

  v3 = *((_QWORD *)a2 + 1) - *(_QWORD *)a2;
  *((_QWORD *)this + 5) = v3 >> 3;
  if (v3)
  {
    v5 = 0;
    do
    {
      RootCursor = LXLexiconCreateRootCursor();
      v7 = (const void *)*((_QWORD *)this + v5);
      if (v7)
        CFRelease(v7);
      *((_QWORD *)this + v5) = RootCursor;
      *((_DWORD *)this + v5 + 6) = *(_DWORD *)(*((_QWORD *)a2 + 3) + 4 * v5);
      ++v5;
    }
    while (v5 < *((_QWORD *)this + 5));
  }
  *((_DWORD *)this + 12) = 0;
}

float KB::StaticDictionaryCursor::conditional_probability(KB::StaticDictionaryCursor *this)
{
  unint64_t v1;
  unint64_t v3;
  float v4;
  double v5;

  v1 = *((_QWORD *)this + 5);
  if (!v1)
    return 0.0;
  v3 = 0;
  v4 = 0.0;
  do
  {
    if (*((_QWORD *)this + v3))
    {
      LXCursorConditionalProbability();
      *(float *)&v5 = v5;
      v4 = v4 + (float)(*((float *)this + v3 + 6) * __exp10f(*(float *)&v5));
      v1 = *((_QWORD *)this + 5);
    }
    ++v3;
  }
  while (v3 < v1);
  return v4;
}

float KB::StaticDictionaryCursor::termination_probability(KB::StaticDictionaryCursor *this)
{
  unint64_t v1;
  unint64_t v3;
  float v4;
  double v5;
  float v6;

  v1 = *((_QWORD *)this + 5);
  if (!v1)
    return 0.0;
  v3 = 0;
  v4 = 0.0;
  do
  {
    if (*((_QWORD *)this + v3))
    {
      LXCursorTerminationProbability();
      *(float *)&v5 = v5;
      v6 = __exp10f(*(float *)&v5);
      v4 = v4 + (float)(KB::StaticDictionaryCursor::probability_of_lexicon(this, v3) * v6);
      v1 = *((_QWORD *)this + 5);
    }
    ++v3;
  }
  while (v3 < v1);
  return v4;
}

float KB::StaticDictionaryCursor::probability_of_lexicon(KB::StaticDictionaryCursor *this, uint64_t a2)
{
  float *v3;
  float *v4;
  float v5;
  float v6;
  float v7;
  float v8;
  double v9;

  v3 = (float *)((char *)this + 4 * a2);
  v5 = v3[6];
  v4 = v3 + 6;
  v6 = v5;
  if (!LXCursorIsRoot())
  {
    v7 = KB::StaticDictionaryCursor::conditional_probability(this);
    if (v7 > 0.0)
    {
      v8 = v7;
      LXCursorConditionalProbability();
      *(float *)&v9 = v9;
      return (float)(__exp10f(*(float *)&v9) * *v4) / v8;
    }
  }
  return v6;
}

float KB::StaticDictionaryCursor::probability_of_lexicon_given_termination(KB::StaticDictionaryCursor *this, uint64_t a2)
{
  float v4;
  float v5;
  double v6;

  v4 = KB::StaticDictionaryCursor::termination_probability(this);
  v5 = KB::StaticDictionaryCursor::probability_of_lexicon(this, a2);
  if (v4 > 0.0)
  {
    LXCursorTerminationProbability();
    *(float *)&v6 = v6;
    return (float)(v5 * __exp10f(*(float *)&v6)) / v4;
  }
  return v5;
}

BOOL KB::StaticDictionaryCursor::is_root(KB::StaticDictionaryCursor *this)
{
  return LXCursorIsRoot() != 0;
}

float KB::StaticDictionaryCursor::advance(KB::StaticDictionaryCursor *this, const KB::String *a2)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const void *v11;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78]();
  v5 = (char *)v13 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v6)
  {
    v7 = 0;
    do
    {
      *(float *)&v5[4 * v7] = KB::StaticDictionaryCursor::probability_of_lexicon(this, v7);
      ++v7;
      v8 = *((_QWORD *)this + 5);
    }
    while (v7 < v8);
    if (v8)
    {
      memcpy((char *)this + 24, v5, 4 * v8);
      if (*((_QWORD *)this + 5))
      {
        v9 = 0;
        do
        {
          if (*((_QWORD *)this + v9))
          {
            v10 = LXCursorCreateByAdvancingWithUTF8();
            v11 = (const void *)*((_QWORD *)this + v9);
            if (v11)
              CFRelease(v11);
          }
          else
          {
            v10 = 0;
          }
          *((_QWORD *)this + v9++) = v10;
        }
        while (v9 < *((_QWORD *)this + 5));
      }
    }
  }
  *((_DWORD *)this + 12) = KB::String::last(a2);
  return KB::StaticDictionaryCursor::conditional_probability(this);
}

float KB::StaticDictionaryCursor::advance(KB::StaticDictionaryCursor *this, unsigned int a2)
{
  float v3;
  BOOL v4;
  _BYTE v6[8];
  void *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  KB::String::String((uint64_t)v6, a2);
  v3 = KB::StaticDictionaryCursor::advance(this, (const KB::String *)v6);
  if (v7)
    v4 = v6[6] == 1;
  else
    v4 = 0;
  if (v4)
    free(v7);
  return v3;
}

void KB::StaticDictionaryCursor::children(KB::StaticDictionaryCursor *this@<X0>, _QWORD *a2@<X8>)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t i;
  const void *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  __n128 (*v17)(_QWORD *, uint64_t);
  void (*v18)(uint64_t);
  _QWORD v19[3];
  void **v20;

  v14 = 0;
  v15 = &v14;
  v16 = 0x4002000000;
  v17 = __Block_byref_object_copy__17519;
  v18 = __Block_byref_object_dispose__17520;
  memset(v19, 0, sizeof(v19));
  if (*((_QWORD *)this + 5))
  {
    v4 = 1;
    do
      LXCursorEnumerateChildren();
    while (*((_QWORD *)this + 5) > (unint64_t)v4++);
    v6 = v15[5];
    v7 = v15[6];
    a2[1] = 0;
    a2[2] = 0;
    *a2 = 0;
    if (v7 != v6)
    {
      v8 = 0x6DB6DB6DB6DB6DB7 * ((v7 - v6) >> 3);
      if (v8 >= 0x492492492492493)
        abort();
      v9 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelLexiconGroup>>(v8);
      *a2 = v9;
      a2[2] = &v9[56 * v10];
      do
      {
        for (i = 0; i != 24; i += 8)
        {
          v12 = *(const void **)(v6 + i);
          *(_QWORD *)&v9[i] = v12;
          if (v12)
          {
            CFRetain(v12);
            *(_QWORD *)&v9[i] = v12;
          }
        }
        v13 = *(_OWORD *)(v6 + 24);
        *(_OWORD *)(v9 + 36) = *(_OWORD *)(v6 + 36);
        *(_OWORD *)(v9 + 24) = v13;
        v6 += 56;
        v9 += 56;
      }
      while (v6 != v7);
      a2[1] = v9;
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  _Block_object_dispose(&v14, 8);
  v20 = (void **)v19;
  std::vector<KB::StaticDictionaryCursor>::__destroy_vector::operator()[abi:nn180100](&v20);
}

__n128 __Block_byref_object_copy__17519(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__17520(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 40);
  std::vector<KB::StaticDictionaryCursor>::__destroy_vector::operator()[abi:nn180100](&v1);
}

BOOL ___ZNK2KB22StaticDictionaryCursor8childrenEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 32) <= *(_DWORD *)(a2 + 48);
}

uint64_t std::__split_buffer<KB::StaticDictionaryCursor>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = 0;
    *(_QWORD *)(a1 + 16) = i - 56;
    v5 = i - 40;
    do
    {
      v6 = *(const void **)(v5 + v4);
      if (v6)
        CFRelease(v6);
      *(_QWORD *)(v5 + v4) = 0;
      v4 -= 8;
    }
    while (v4 != -24);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

BOOL KB::StaticDictionaryCursor::has_children(KB::StaticDictionaryCursor *this)
{
  uint64_t v1;
  KB::StaticDictionaryCursor *v2;
  uint64_t v3;
  int HasChildren;
  _BOOL8 result;
  BOOL v6;

  v1 = *((_QWORD *)this + 5);
  if (!v1)
    return 0;
  v2 = this;
  v3 = 8 * v1 - 8;
  do
  {
    v2 = (KB::StaticDictionaryCursor *)((char *)v2 + 8);
    HasChildren = LXCursorHasChildren();
    result = HasChildren != 0;
    if (HasChildren)
      v6 = 1;
    else
      v6 = v3 == 0;
    v3 -= 8;
  }
  while (!v6);
  return result;
}

void KB::StaticDictionaryCursor::derive_words(KB::StaticDictionaryCursor *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __n128 (*v8)(_QWORD *, uint64_t);
  void (*v9)(uint64_t);
  _BYTE v10[24];
  void **v11;

  if (*((_QWORD *)this + 5))
  {
    v4 = 0;
    do
    {
      v5 = 0;
      v6 = &v5;
      v7 = 0x4002000000;
      v8 = __Block_byref_object_copy__5;
      v9 = __Block_byref_object_dispose__6;
      memset(v10, 0, sizeof(v10));
      KB::StaticDictionaryCursor::probability_of_lexicon_given_termination(this, v4);
      LXCursorEnumerateEntries();
      KB::StaticDictionary::merge_words(a2, v6 + 5);
      _Block_object_dispose(&v5, 8);
      v11 = (void **)v10;
      std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v11);
      ++v4;
    }
    while (v4 < *((_QWORD *)this + 5));
  }
}

__n128 __Block_byref_object_copy__5(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 40);
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v1);
}

uint64_t ___ZNK2KB22StaticDictionaryCursor12derive_wordsERNSt3__16vectorINS_4WordENS1_9allocatorIS3_EEEERKNS_16StaticDictionaryE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  int v5;
  uint64_t v6;

  v6 = a2;
  result = std::vector<KB::Word>::emplace_back<_LXEntry const*&,unsigned int const&>((uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), &v6, (int *)(a1 + 40));
  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48);
  *(float *)(v4 - 192) = *(float *)(v4 - 192) * *(float *)(a1 + 44);
  *(_DWORD *)(v4 - 136) |= 0x40000u;
  v5 = *(_DWORD *)(a1 + 40);
  if ((v5 + 1) >= 2 && v5 != *(_DWORD *)(a1 + 48))
    *(_BYTE *)(v4 - 48) = 1;
  return result;
}

uint64_t KB::StaticDictionaryCursor::derive_word_ids(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;

  if (*(_QWORD *)(result + 40))
  {
    v1 = result;
    v2 = 0;
    do
    {
      result = LXCursorEnumerateEntries();
      ++v2;
    }
    while (v2 < *(_QWORD *)(v1 + 40));
  }
  return result;
}

void ___ZNK2KB22StaticDictionaryCursor15derive_word_idsERNSt3__16vectorI9TITokenIDNS1_9allocatorIS3_EEEERKNS_16StaticDictionaryE_block_invoke(_QWORD *a1, uint64_t a2)
{
  void **v2;
  int v3;
  int TokenID;
  int v5;
  unint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v2 = (void **)a1[4];
  v3 = *(_DWORD *)(*(_QWORD *)(a1[5] + 48) + 4 * a1[6]);
  if (a2)
  {
    TokenID = LXEntryGetTokenID();
    if (TokenID)
      v5 = TokenID;
    else
      v5 = 500;
  }
  else
  {
    v5 = 0;
  }
  v7 = v2[1];
  v6 = (unint64_t)v2[2];
  if ((unint64_t)v7 >= v6)
  {
    v9 = ((char *)v7 - (_BYTE *)*v2) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      abort();
    v11 = v6 - (_QWORD)*v2;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v12);
    v14 = &v13[8 * v9];
    v16 = &v13[8 * v15];
    *(_DWORD *)v14 = v3;
    *((_DWORD *)v14 + 1) = v5;
    v8 = v14 + 8;
    v18 = (char *)*v2;
    v17 = (char *)v2[1];
    if (v17 != *v2)
    {
      do
      {
        v19 = *((_QWORD *)v17 - 1);
        v17 -= 8;
        *((_QWORD *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      v17 = (char *)*v2;
    }
    *v2 = v14;
    v2[1] = v8;
    v2[2] = v16;
    if (v17)
      operator delete(v17);
  }
  else
  {
    *v7 = v3;
    v7[1] = v5;
    v8 = v7 + 2;
  }
  v2[1] = v8;
}

BOOL KB::StaticDictionaryCursor::finishes_words(KB::StaticDictionaryCursor *this)
{
  uint64_t v1;
  KB::StaticDictionaryCursor *v2;
  uint64_t v3;
  int HasEntries;
  _BOOL8 result;
  BOOL v6;

  v1 = *((_QWORD *)this + 5);
  if (!v1)
    return 0;
  v2 = this;
  v3 = 8 * v1 - 8;
  do
  {
    v2 = (KB::StaticDictionaryCursor *)((char *)v2 + 8);
    HasEntries = LXCursorHasEntries();
    result = HasEntries != 0;
    if (HasEntries)
      v6 = 1;
    else
      v6 = v3 == 0;
    v3 -= 8;
  }
  while (!v6);
  return result;
}

BOOL KB::StaticDictionaryCursor::allows_restart(KB::StaticDictionaryCursor *this)
{
  uint64_t v1;
  KB::StaticDictionaryCursor *v2;
  uint64_t v3;
  int v4;
  _BOOL8 result;
  BOOL v6;

  v1 = *((_QWORD *)this + 5);
  if (!v1)
    return 0;
  v2 = this;
  v3 = 8 * v1 - 8;
  do
  {
    v2 = (KB::StaticDictionaryCursor *)((char *)v2 + 8);
    v4 = LXCursorTerminatesWordStem();
    result = v4 != 0;
    if (v4)
      v6 = 1;
    else
      v6 = v3 == 0;
    v3 -= 8;
  }
  while (!v6);
  return result;
}

uint64_t KB::StaticDictionaryCursor::valid(KB::StaticDictionaryCursor *this)
{
  uint64_t v1;
  uint64_t v2;
  const void *v3;

  v1 = *((_QWORD *)this + 5);
  if (!v1)
    return 0;
  v2 = 8 * v1;
  while (1)
  {
    v3 = *(const void **)this;
    if (*(_QWORD *)this)
      break;
    this = (KB::StaticDictionaryCursor *)((char *)this + 8);
    v2 -= 8;
    if (!v2)
      return 0;
  }
  CFRetain(*(CFTypeRef *)this);
  CFRelease(v3);
  return 1;
}

void KB::StaticDictionaryCursor::invalidate(KB::StaticDictionaryCursor *this)
{
  unint64_t v2;
  uint64_t v3;
  unsigned int v4;
  const void *v5;

  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = 0;
    v4 = 1;
    do
    {
      v5 = (const void *)*((_QWORD *)this + v3);
      if (v5)
      {
        CFRelease(v5);
        v2 = *((_QWORD *)this + 5);
      }
      *((_QWORD *)this + v3) = 0;
      v3 = v4;
    }
    while (v2 > v4++);
  }
  *((_DWORD *)this + 12) = 0;
}

void TI::Favonius::SearchNodeTranspositionGeometryExtensions::~SearchNodeTranspositionGeometryExtensions(TI::Favonius::SearchNodeTranspositionGeometryExtensions *this)
{
  TI::Favonius::SearchNodeTranspositionGeometryExtensions::~SearchNodeTranspositionGeometryExtensions(this);
  JUMPOUT(0x1DF0A2144);
}

{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;

  *(_QWORD *)this = &off_1EA105E30;
  v2 = *((_QWORD *)this + 11);
  if (v2)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v2);
  v3 = (unsigned int *)*((_QWORD *)this + 10);
  if (v3)
  {
    v4 = v3 + 2;
    v5 = atomic_load(v3 + 2);
    if (v5 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
    }
    else
    {
      do
        v6 = __ldaxr(v4);
      while (__stlxr(v6 - 1, v4));
    }
  }
  WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::~Vector((_QWORD *)this + 5);
  v7 = (unsigned int *)*((_QWORD *)this + 4);
  if (v7)
  {
    v8 = v7 + 2;
    v9 = atomic_load(v7 + 2);
    if (v9 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
    }
    else
    {
      do
        v10 = __ldaxr(v8);
      while (__stlxr(v10 - 1, v8));
    }
  }
  *(_QWORD *)this = off_1EA102A78;
  v11 = (unsigned int *)*((_QWORD *)this + 2);
  if (v11)
  {
    v12 = v11 + 2;
    v13 = atomic_load(v11 + 2);
    if (v13 == 1)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v11 + 8))(v11);
    }
    else
    {
      do
        v14 = __ldaxr(v12);
      while (__stlxr(v14 - 1, v12));
    }
  }
}

unsigned int *TI::Favonius::SearchNodeTranspositionGeometryExtensions::clone_substituting_touch@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  unsigned int *v7;
  unsigned int *result;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;

  v6 = operator new();
  v7 = *a2;
  *a2 = 0;
  v12 = v7;
  *a3 = TI::Favonius::SearchNodeTranspositionGeometryExtensions::SearchNodeTranspositionGeometryExtensions(v6, a1, (uint64_t *)&v12);
  result = v12;
  if (v12)
  {
    v9 = v12 + 2;
    v10 = atomic_load(v12 + 2);
    if (v10 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v12 + 8))();
    }
    else
    {
      do
        v11 = __ldaxr(v9);
      while (__stlxr(v11 - 1, v9));
    }
  }
  return result;
}

unsigned int *TI::Favonius::SearchNodeTranspositionGeometryExtensions::branch_at_current_bound@<X0>(unsigned int *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  float v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int *v28;
  unsigned int *v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int *v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int v40;
  float v41;
  unsigned int *v42;
  unsigned int *v43;
  unsigned int *v44;
  uint64_t v45;

  v3 = *((_QWORD *)this + 5);
  if (!v3)
  {
    *a2 = 0;
    return this;
  }
  v4 = (uint64_t)this;
  v5 = v3 - 1;
  v6 = *(unsigned int **)(*((_QWORD *)this + 6) + 8 * (v3 - 1));
  if (v6)
  {
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
    v5 = *((_QWORD *)this + 5) - 1;
    v8 = *(_QWORD *)(*((_QWORD *)this + 6) + 8 * v5);
    if (v8)
      WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v8);
  }
  *(_QWORD *)(v4 + 40) = v5;
  TI::Favonius::SearchNodeTranspositionGeometryExtensions::set_bound_on_score_with_first_matched_key((TI::Favonius::SearchNodeTranspositionGeometryExtensions *)v4);
  v9 = *(_QWORD *)(v4 + 32);
  v10 = *(unsigned int **)(v4 + 88);
  if (!v10)
  {
    v28 = *(unsigned int **)(v4 + 80);
    v44 = v28;
    if (v28)
    {
      v29 = v28 + 2;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 + 1, v29));
    }
    v43 = v6;
    if (v6)
    {
      do
        v31 = __ldaxr(v6);
      while (__stlxr(v31 + 1, v6));
    }
    v32 = *(unsigned int **)(v4 + 16);
    v42 = v32;
    if (v32)
    {
      v33 = v32 + 2;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 + 1, v33));
    }
    TI::Favonius::SearchNodeTranspositionGeometryExtensions::create_extension(v4, v9, &v44, (uint64_t *)&v43, &v42, &v45, *(float *)(v4 + 64));
    v21 = v45;
    v45 = 0;
    if (v42)
    {
      v35 = v42 + 2;
      v36 = atomic_load(v42 + 2);
      if (v36 == 1)
      {
        (*(void (**)(void))(*(_QWORD *)v42 + 8))();
      }
      else
      {
        do
          v37 = __ldaxr(v35);
        while (__stlxr(v37 - 1, v35));
      }
    }
    if (v43)
      WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v43);
    this = v44;
    if (v44)
    {
      v38 = v44 + 2;
      v39 = atomic_load(v44 + 2);
      if (v39 == 1)
      {
        this = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v44 + 8))(v44);
      }
      else
      {
        do
          v40 = __ldaxr(v38);
        while (__stlxr(v40 - 1, v38));
      }
    }
    goto LABEL_49;
  }
  v11 = *(unsigned int **)(v4 + 80);
  if (!v11)
    goto LABEL_56;
  v12 = v11 + 2;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 + 1, v12));
  v10 = *(unsigned int **)(v4 + 88);
  if (!v10)
  {
    v15 = 1;
  }
  else
  {
LABEL_56:
    do
      v14 = __ldaxr(v10);
    while (__stlxr(v14 + 1, v10));
    v15 = 0;
  }
  v16 = *(unsigned int **)(v4 + 16);
  if (v16)
  {
    v17 = v16 + 2;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 + 1, v17));
  }
  if (v6)
  {
    do
      v19 = __ldaxr(v6);
    while (__stlxr(v19 + 1, v6));
    v20 = *(float *)(v4 + 64);
    v21 = operator new();
    TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(v21, v9, (uint64_t)v11, v10, v16, v6, v20);
    this = (unsigned int *)WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v6);
    if (!v16)
      goto LABEL_22;
    goto LABEL_19;
  }
  v41 = *(float *)(v4 + 64);
  v21 = operator new();
  this = (unsigned int *)TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(v21, v9, (uint64_t)v11, v10, v16, 0, v41);
  if (v16)
  {
LABEL_19:
    v22 = v16 + 2;
    v23 = atomic_load(v16 + 2);
    if (v23 == 1)
    {
      this = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v16 + 8))(v16);
    }
    else
    {
      do
        v24 = __ldaxr(v22);
      while (__stlxr(v24 - 1, v22));
    }
  }
LABEL_22:
  if ((v15 & 1) == 0)
    this = (unsigned int *)WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v10);
  if (v11)
  {
    v25 = v11 + 2;
    v26 = atomic_load(v11 + 2);
    if (v26 == 1)
    {
      this = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v11 + 8))(v11);
    }
    else
    {
      do
        v27 = __ldaxr(v25);
      while (__stlxr(v27 - 1, v25));
    }
  }
LABEL_49:
  *a2 = v21;
  if (v6)
    return (unsigned int *)WTF::RefCounted<TI::Favonius::KeyMatch>::deref((uint64_t)v6);
  return this;
}

uint64_t TI::Favonius::SearchNodeTranspositionGeometryExtensions::set_bound_on_score_with_first_matched_key(TI::Favonius::SearchNodeTranspositionGeometryExtensions *this)
{
  uint64_t result;
  uint64_t v3;
  float v4;

  result = TI::Favonius::SearchNodeTranspositionGeometryExtensions::pop_nonletter_keys((uint64_t)this);
  v3 = *((_QWORD *)this + 5);
  if (v3)
    v4 = *((float *)this + 18) + *(float *)(*(_QWORD *)(*((_QWORD *)this + 6) + 8 * v3 - 8) + 32);
  else
    v4 = -INFINITY;
  *((float *)this + 6) = v4;
  return result;
}

unsigned int *TI::Favonius::SearchNodeTranspositionGeometryExtensions::create_extension@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int **a3@<X2>, uint64_t *a4@<X3>, unsigned int **a5@<X4>, uint64_t *a6@<X8>, float a7@<S0>)
{
  uint64_t v14;
  unsigned int *v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int *result;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int *v25;
  uint64_t v26;
  unsigned int *v27;

  v14 = operator new();
  v15 = *a3;
  *a3 = 0;
  v16 = *a4;
  *a4 = 0;
  v26 = v16;
  v27 = v15;
  v17 = *a5;
  *a5 = 0;
  v25 = v17;
  *a6 = TI::Favonius::SearchNodeTranspositionGeometryExtensions::SearchNodeTranspositionGeometryExtensions(v14, a2, (uint64_t *)&v27, &v26, (uint64_t *)&v25, *(_BYTE *)(a1 + 68), a7, 0.0);
  if (v25)
  {
    v18 = v25 + 2;
    v19 = atomic_load(v25 + 2);
    if (v19 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v25 + 8))();
    }
    else
    {
      do
        v20 = __ldaxr(v18);
      while (__stlxr(v20 - 1, v18));
    }
  }
  if (v26)
    WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v26);
  result = v27;
  if (v27)
  {
    v22 = v27 + 2;
    v23 = atomic_load(v27 + 2);
    if (v23 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v27 + 8))();
    }
    else
    {
      do
        v24 = __ldaxr(v22);
      while (__stlxr(v24 - 1, v22));
    }
  }
  return result;
}

uint64_t TI::Favonius::SearchNodeTranspositionGeometryExtensions::SearchNodeTranspositionGeometryExtensions(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, char a6, float a7, float a8)
{
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unint64_t *v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v9 = *a5;
  *a5 = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = v9;
  *(_DWORD *)(a1 + 24) = -8388608;
  *(_QWORD *)a1 = &off_1EA105E30;
  *(_QWORD *)(a1 + 32) = a2;
  if (a2)
  {
    v10 = (unsigned int *)(a2 + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 + 1, v10));
  }
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v12 = (unint64_t *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = 0;
  *(float *)(a1 + 64) = a7;
  *(_BYTE *)(a1 + 68) = a6;
  v13 = (float)(*(float *)(a2 + 144) + (float)(a7 * *(float *)(a2 + 136))) + a8;
  *(float *)(a1 + 72) = v13;
  v14 = *a3;
  *a3 = 0;
  v15 = *a4;
  *a4 = 0;
  *(_QWORD *)(a1 + 80) = v14;
  *(_QWORD *)(a1 + 88) = v15;
  if ((LODWORD(v13) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    *(float *)(a1 + 72) = *(float *)(a1 + 72)
                        + (float)((*(float (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16))
                                + *(float *)(*(_QWORD *)(a1 + 88) + 32));
    v16 = (unint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 64))(*(_QWORD *)(a1 + 16));
    WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::operator=((unint64_t *)(a1 + 40), v16);
    v17 = *(_QWORD *)(a1 + 40);
    if (v17 < 5)
    {
      if (v17 < 2)
      {
LABEL_18:
        TI::Favonius::SearchNodeTranspositionGeometryExtensions::set_bound_on_score_with_first_matched_key((TI::Favonius::SearchNodeTranspositionGeometryExtensions *)a1);
        return a1;
      }
    }
    else
    {
      v18 = (uint64_t *)(*(_QWORD *)(a1 + 48) + 32);
      v19 = 8 * v17 - 32;
      do
      {
        if (*v18)
          WTF::RefCounted<TI::Favonius::KeyMatch>::deref(*v18);
        ++v18;
        v19 -= 8;
      }
      while (v19);
      v17 = 4;
      *v12 = 4;
    }
    v20 = 0;
    v21 = -1;
    do
    {
      v22 = *(_QWORD *)(a1 + 48);
      v23 = v17 + v21;
      v24 = *(_QWORD *)(v22 + 8 * v20);
      *(_QWORD *)(v22 + 8 * v20) = 0;
      v25 = *(_QWORD *)(v22 + 8 * (v17 + v21));
      *(_QWORD *)(v22 + 8 * v23) = 0;
      v26 = *(_QWORD *)(v22 + 8 * v20);
      *(_QWORD *)(v22 + 8 * v20) = v25;
      if (v26)
        WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v26);
      v27 = *(_QWORD *)(v22 + 8 * v23);
      *(_QWORD *)(v22 + 8 * v23) = v24;
      if (v27)
        WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v27);
      ++v20;
      v17 = *v12;
      --v21;
    }
    while (v20 < *v12 >> 1);
    goto LABEL_18;
  }
  return a1;
}

uint64_t TI::Favonius::SearchNodeTranspositionGeometryExtensions::pop_nonletter_keys(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  __int16 v4;

  v1 = *(_QWORD *)(this + 40);
  if (v1)
  {
    v2 = this;
    v3 = v1 - 1;
    do
    {
      this = *(_QWORD *)(*(_QWORD *)(v2 + 48) + 8 * v3);
      v4 = *(_WORD *)(*(_QWORD *)(this + 8) + 60);
      if ((v4 & 2) != 0 || (v4 & 0x20) != 0 && *(_BYTE *)(v2 + 68))
        break;
      this = WTF::RefCounted<TI::Favonius::KeyMatch>::deref(this);
      *(_QWORD *)(v2 + 40) = v3--;
    }
    while (v3 != -1);
  }
  return this;
}

uint64_t TI::Favonius::SearchNodeTranspositionGeometryExtensions::SearchNodeTranspositionGeometryExtensions(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  unint64_t *v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  uint64_t i;
  uint64_t v24;
  unsigned int *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  void *v36;

  v5 = *a3;
  *a3 = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = -8388608;
  *(_QWORD *)a1 = &off_1EA105E30;
  v6 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = v6;
  if (v6)
  {
    v7 = (unsigned int *)(v6 + 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 + 1, v7));
  }
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v9 = (unint64_t *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 68) = *(_BYTE *)(a2 + 68);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  v10 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 80) = v10;
  if (v10)
  {
    v11 = (unsigned int *)(v10 + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 + 1, v11));
  }
  v13 = *(unsigned int **)(a2 + 88);
  *(_QWORD *)(a1 + 88) = v13;
  if (v13)
  {
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 + 1, v13));
  }
  if ((*(_DWORD *)(a1 + 72) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    v15 = (unint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 64))(*(_QWORD *)(a1 + 16));
    WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity((_QWORD *)(a1 + 40), *v15);
    v16 = *v15;
    while (v16)
    {
      --v16;
      v17 = v15[1] + 8 * v16;
      if (!(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a2 + 16) + 72))(*(_QWORD *)(a2 + 16), *(__int16 *)(*(_QWORD *)(*(_QWORD *)v17 + 8) + 62)))
      {
        v18 = *(_QWORD *)(a1 + 40);
        if (v18 != *(_QWORD *)(a1 + 56))
        {
          v20 = *(_QWORD *)(a1 + 48);
          goto LABEL_16;
        }
        v19 = WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::expandCapacity((_QWORD *)(a1 + 40), v18 + 1, v17);
        v20 = *(_QWORD *)(a1 + 48);
        if (v20)
        {
          v17 = v19;
          v18 = *v9;
LABEL_16:
          v21 = *(unsigned int **)v17;
          *(_QWORD *)(v20 + 8 * v18) = *(_QWORD *)v17;
          if (v21)
          {
            do
              v22 = __ldaxr(v21);
            while (__stlxr(v22 + 1, v21));
            v18 = *v9;
          }
          *v9 = v18 + 1;
        }
      }
    }
    if (*(_QWORD *)(a2 + 40))
    {
      for (i = *(_QWORD *)(a2 + 48); i != *(_QWORD *)(a2 + 48) + 8 * *(_QWORD *)(a2 + 40); i += 8)
      {
        v24 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 80) + 72))(*(_QWORD *)(a1 + 80), *(__int16 *)(*(_QWORD *)(*(_QWORD *)i + 8) + 62));
        if (v24)
        {
          v25 = (unsigned int *)v24;
          v26 = *(_QWORD *)(a1 + 40);
          if (v26 == *(_QWORD *)(a1 + 56))
          {
            v27 = v26 + (v26 >> 1);
            if (v26 < 0x100)
              v27 = 2 * v26;
            if (v27 <= v26 + 1)
              v28 = v26 + 1;
            else
              v28 = v27;
            WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity((_QWORD *)(a1 + 40), v28);
            v29 = *(_QWORD *)(a1 + 48);
            if (!v29)
              continue;
            v26 = *v9;
          }
          else
          {
            v29 = *(_QWORD *)(a1 + 48);
          }
          *(_QWORD *)(v29 + 8 * v26) = v25;
          do
            v30 = __ldaxr(v25);
          while (__stlxr(v30 + 1, v25));
          ++*v9;
        }
      }
    }
    v32 = *(_QWORD *)(a1 + 40);
    v31 = *(_QWORD *)(a1 + 48);
    v36 = &__block_literal_global_17538;
    v33 = 126 - 2 * __clz(v32);
    if (v32)
      v34 = v33;
    else
      v34 = 0;
    std::__introsort<std::_ClassicAlgPolicy,BOOL({block_pointer}&)(WTF::RefPtr<TI::Favonius::KeyMatch> const&,WTF::RefPtr<TI::Favonius::KeyMatch> const&),WTF::RefPtr<TI::Favonius::KeyMatch>*,false>(v31, (uint64_t *)(v31 + 8 * v32), (uint64_t)&v36, v34, 1);
    TI::Favonius::SearchNodeTranspositionGeometryExtensions::set_bound_on_score_with_first_matched_key((TI::Favonius::SearchNodeTranspositionGeometryExtensions *)a1);
  }
  return a1;
}

BOOL ___ZN2TI8Favonius41SearchNodeTranspositionGeometryExtensionsC2ERKS1_N3WTF10PassRefPtrINS0_12TouchHistoryEEE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(float *)(*(_QWORD *)a2 + 32) < *(float *)(*(_QWORD *)a3 + 32);
}

unsigned int *TI::Favonius::SearchNodeTranspositionGeometryExtensions::create@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, unsigned int **a3@<X2>, char a4@<W3>, uint64_t *a5@<X8>, float a6@<S0>)
{
  uint64_t v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int *result;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int *v22;
  unsigned int *v23;

  v12 = operator new();
  v13 = *a2;
  *a2 = 0;
  v14 = *a3;
  *a3 = 0;
  v22 = v14;
  v23 = v13;
  *a5 = TI::Favonius::SearchNodeTranspositionGeometryExtensions::SearchNodeTranspositionGeometryExtensions(v12, a1, (uint64_t *)&v23, (uint64_t *)&v22, a4, a6, 0.0);
  if (v22)
  {
    v15 = v22 + 2;
    v16 = atomic_load(v22 + 2);
    if (v16 == 1)
    {
      (*(void (**)(void))(*(_QWORD *)v22 + 8))();
    }
    else
    {
      do
        v17 = __ldaxr(v15);
      while (__stlxr(v17 - 1, v15));
    }
  }
  result = v23;
  if (v23)
  {
    v19 = v23 + 2;
    v20 = atomic_load(v23 + 2);
    if (v20 == 1)
    {
      return (unsigned int *)(*(uint64_t (**)(void))(*(_QWORD *)v23 + 8))();
    }
    else
    {
      do
        v21 = __ldaxr(v19);
      while (__stlxr(v21 - 1, v19));
    }
  }
  return result;
}

uint64_t TI::Favonius::SearchNodeTranspositionGeometryExtensions::SearchNodeTranspositionGeometryExtensions(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, char a5, float a6, float a7)
{
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unint64_t *v11;
  float v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v8 = *a4;
  *a4 = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 24) = -8388608;
  *(_QWORD *)a1 = &off_1EA105E30;
  *(_QWORD *)(a1 + 32) = a2;
  if (a2)
  {
    v9 = (unsigned int *)(a2 + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 + 1, v9));
  }
  *(_QWORD *)(a1 + 40) = 0;
  v11 = (unint64_t *)(a1 + 40);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(float *)(a1 + 64) = a6;
  *(_BYTE *)(a1 + 68) = a5;
  v12 = (float)(*(float *)(a2 + 144) + (float)(a6 * *(float *)(a2 + 136))) + a7;
  *(float *)(a1 + 72) = v12;
  v13 = *a3;
  *a3 = 0;
  *(_QWORD *)(a1 + 80) = v13;
  *(_QWORD *)(a1 + 88) = 0;
  if ((LODWORD(v12) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    *(float *)(a1 + 72) = (*(float (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16))
                        + *(float *)(a1 + 72);
    v14 = (unint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 80) + 64))(*(_QWORD *)(a1 + 80));
    WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::operator=((unint64_t *)(a1 + 40), v14);
    v15 = *(_QWORD *)(a1 + 40);
    if (v15 < 5)
    {
      if (v15 < 2)
      {
LABEL_18:
        TI::Favonius::SearchNodeTranspositionGeometryExtensions::set_bound_on_score_with_first_matched_key((TI::Favonius::SearchNodeTranspositionGeometryExtensions *)a1);
        return a1;
      }
    }
    else
    {
      v16 = (uint64_t *)(*(_QWORD *)(a1 + 48) + 32);
      v17 = 8 * v15 - 32;
      do
      {
        if (*v16)
          WTF::RefCounted<TI::Favonius::KeyMatch>::deref(*v16);
        ++v16;
        v17 -= 8;
      }
      while (v17);
      v15 = 4;
      *v11 = 4;
    }
    v18 = 0;
    v19 = -1;
    do
    {
      v20 = *(_QWORD *)(a1 + 48);
      v21 = v15 + v19;
      v22 = *(_QWORD *)(v20 + 8 * v18);
      *(_QWORD *)(v20 + 8 * v18) = 0;
      v23 = *(_QWORD *)(v20 + 8 * (v15 + v19));
      *(_QWORD *)(v20 + 8 * v21) = 0;
      v24 = *(_QWORD *)(v20 + 8 * v18);
      *(_QWORD *)(v20 + 8 * v18) = v23;
      if (v24)
        WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v24);
      v25 = *(_QWORD *)(v20 + 8 * v21);
      *(_QWORD *)(v20 + 8 * v21) = v22;
      if (v25)
        WTF::RefCounted<TI::Favonius::KeyMatch>::deref(v25);
      ++v18;
      v15 = *v11;
      --v19;
    }
    while (v18 < *v11 >> 1);
    goto LABEL_18;
  }
  return a1;
}

uint64_t TI::Favonius::SearchNodeTranspositionGeometryExtensions::create_extension@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X2>, unsigned int **a3@<X3>, unsigned int **a4@<X4>, unsigned int **a5@<X5>, uint64_t *a6@<X8>, float a7@<S0>)
{
  uint64_t v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t result;

  v10 = *a2;
  v11 = *a3;
  v12 = *a4;
  v13 = *a5;
  v14 = operator new();
  result = TI::Favonius::SearchNodeTransposition::SearchNodeTransposition(v14, a1, v10, v11, v12, v13, a7);
  *a6 = result;
  return result;
}

_QWORD *KB::UserDictionaryLoader::UserDictionaryLoader(_QWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

id **std::unique_ptr<KB::WeakHolder>::reset[abi:nn180100](id **result, id *a2)
{
  id *v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    objc_destroyWeak(v2);
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

void ___ZN2KB20UserDictionaryLoader14dispatch_queueEv_block_invoke()
{
  NSObject *v0;
  dispatch_queue_t v1;
  void *v2;
  NSObject *attr;

  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v0 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_BACKGROUND, 0);
  attr = objc_claimAutoreleasedReturnValue();

  v1 = dispatch_queue_create("com.apple.textInput.userDictionaryLoader", attr);
  v2 = (void *)KB::UserDictionaryLoader::dispatch_queue(void)::queue;
  KB::UserDictionaryLoader::dispatch_queue(void)::queue = (uint64_t)v1;

}

__n128 __Block_byref_object_copy__17569(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__17570(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void __destroy_helper_block_a8_40c17_ZTSKN2KB6StringE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 46) == 1)
      free(v2);
  }
}

void ___ZN2KB20UserDictionaryLoader15create_and_loadERKNS_6StringE_block_invoke_8(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  KB::UserDictionary *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  uint8_t buf[4];
  void *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  TIUserDictionaryOSLogFacility();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Loading UserDictionary trie..."), "create_and_load_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    v12 = v3;
    _os_log_impl(&dword_1DA6F2000, v2, OS_LOG_TYPE_INFO, "%@", buf, 0xCu);

  }
  v4 = (KB::UserDictionary *)operator new();
  KB::UserDictionary::UserDictionary(v4, (const KB::String *)(a1 + 48), *(const __CFArray **)(a1 + 32));
  v5 = (std::__shared_weak_count *)operator new();
  v5->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  v5->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA105FB8;
  v5->__shared_weak_owners_ = 0;
  v5[1].__vftable = (std::__shared_weak_count_vtbl *)v4;
  do
    v7 = __ldxr(p_shared_owners);
  while (__stxr(v7 + 1, p_shared_owners));
  TIDispatchAsync();
  if (v5)
  {
    v8 = (unint64_t *)&v5->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  do
    v10 = __ldaxr(p_shared_owners);
  while (__stlxr(v10 - 1, p_shared_owners));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void ___ZN2KB20UserDictionaryLoader15create_and_loadERKNS_6StringE_block_invoke_11(_QWORD *a1)
{
  NSObject *v2;
  void *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint8_t buf[4];
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  TIUserDictionaryOSLogFacility();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Done loading UserDictionary trie; installing on main thread."),
      "create_and_load_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    v19 = v3;
    _os_log_impl(&dword_1DA6F2000, v2, OS_LOG_TYPE_INFO, "%@", buf, 0xCu);

  }
  v4 = *(_QWORD *)(a1[4] + 8);
  v5 = *(std::__shared_weak_count **)(v4 + 56);
  if (v5)
  {
    v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      v7 = v6;
      v8 = *(_QWORD **)(v4 + 48);
      if (v8)
      {
        v10 = a1[5];
        v9 = a1[6];
        if (v9)
        {
          v11 = (unint64_t *)(v9 + 8);
          do
            v12 = __ldxr(v11);
          while (__stxr(v12 + 1, v11));
        }
        v13 = (std::__shared_weak_count *)v8[1];
        *v8 = v10;
        v8[1] = v9;
        if (v13)
        {
          p_shared_owners = (unint64_t *)&v13->__shared_owners_;
          do
            v15 = __ldaxr(p_shared_owners);
          while (__stlxr(v15 - 1, p_shared_owners));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
      }
      v16 = (unint64_t *)&v7->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void std::__shared_ptr_pointer<KB::UserDictionary *,std::shared_ptr<KB::UserDictionary>::__shared_ptr_default_delete<KB::UserDictionary,KB::UserDictionary>,std::allocator<KB::UserDictionary>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_pointer<KB::UserDictionary *,std::shared_ptr<KB::UserDictionary>::__shared_ptr_default_delete<KB::UserDictionary,KB::UserDictionary>,std::allocator<KB::UserDictionary>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  void *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  void *v10;
  void **v11;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    v2 = *(_QWORD **)(v1 + 64);
    while (v2)
    {
      v3 = v2;
      v2 = (_QWORD *)*v2;
      v4 = (void *)v3[7];
      if (v4 && *((_BYTE *)v3 + 54) == 1)
        free(v4);
      v5 = (void *)v3[3];
      if (v5 && *((_BYTE *)v3 + 22) == 1)
        free(v5);
      operator delete(v3);
    }
    v6 = *(void **)(v1 + 48);
    *(_QWORD *)(v1 + 48) = 0;
    if (v6)
      operator delete(v6);
    v7 = *(_QWORD **)(v1 + 24);
    while (v7)
    {
      v8 = v7;
      v7 = (_QWORD *)*v7;
      v11 = (void **)(v8 + 6);
      std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v11);
      v9 = (void *)v8[3];
      if (v9 && *((_BYTE *)v8 + 22) == 1)
        free(v9);
      operator delete(v8);
    }
    v10 = *(void **)(v1 + 8);
    *(_QWORD *)(v1 + 8) = 0;
    if (v10)
      operator delete(v10);
    if (*(_QWORD *)v1)
      CFRelease(*(CFTypeRef *)v1);
    *(_QWORD *)v1 = 0;
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

void std::__shared_ptr_pointer<KB::UserDictionaryLoader *,std::shared_ptr<KB::UserDictionaryLoader>::__shared_ptr_default_delete<KB::UserDictionaryLoader,KB::UserDictionaryLoader>,std::allocator<KB::UserDictionaryLoader>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

__n128 __Block_byref_object_copy__17646(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

BOOL KB::character_is_letter_modifier(UChar32 c)
{
  _BOOL8 result;

  result = 1;
  if (c <= 729)
  {
    if ((c - 168) <= 0xC && ((1 << (c + 88)) & 0x1081) != 0)
      return result;
    return u_charType(c) == 4;
  }
  if (c != 730 && c != 732 && c != 901)
    return u_charType(c) == 4;
  return result;
}

void KB::MutableLexiconWrapper::~MutableLexiconWrapper(KB::MutableLexiconWrapper *this)
{
  KB::MutableLexiconWrapper::~MutableLexiconWrapper(this);
  JUMPOUT(0x1DF0A2144);
}

{
  const void *v2;
  void *v3;

  *(_QWORD *)this = &off_1EA106040;
  v2 = (const void *)*((_QWORD *)this + 18);
  if (v2)
    CFRelease(v2);
  v3 = (void *)*((_QWORD *)this + 20);
  if (v3 && *((_BYTE *)this + 158) == 1)
    free(v3);
  KB::LexiconWrapperBase::~LexiconWrapperBase(this);
}

uint64_t KB::MutableLexiconWrapper::lexicon(KB::MutableLexiconWrapper *this)
{
  return *((_QWORD *)this + 18);
}

void KB::LexiconWrapperBase::~LexiconWrapperBase(KB::LexiconWrapperBase *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  KB::LexiconWrapperBase *v5;
  uint64_t v6;
  void *v7;
  const void *v8;
  void *v9;

  *(_QWORD *)this = off_1EA107690;
  v2 = (char *)this + 112;
  v3 = (char *)*((_QWORD *)this + 17);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  v5 = (KB::LexiconWrapperBase *)*((_QWORD *)this + 13);
  if (v5 == (KB::LexiconWrapperBase *)((char *)this + 80))
  {
    v6 = 4;
    v5 = (KB::LexiconWrapperBase *)((char *)this + 80);
    goto LABEL_10;
  }
  if (v5)
  {
    v6 = 5;
LABEL_10:
    (*(void (**)(void))(*(_QWORD *)v5 + 8 * v6))();
  }
  v7 = (void *)*((_QWORD *)this + 7);
  if (v7 && *((_BYTE *)this + 54) == 1)
    free(v7);
  v8 = (const void *)*((_QWORD *)this + 5);
  if (v8)
    CFRelease(v8);
  *((_QWORD *)this + 5) = 0;
  v9 = (void *)*((_QWORD *)this + 2);
  if (v9)
  {
    if (*((_BYTE *)this + 14) == 1)
      free(v9);
  }
}

CFTypeRef *KB::MutableLexiconWrapper::create@<X0>(KB::MutableLexiconWrapper *this@<X0>, const KB::String *a2@<X1>, CFTypeRef **a3@<X8>)
{
  CFTypeRef *v7;
  CFTypeRef *result;

  v7 = (CFTypeRef *)operator new();
  result = KB::MutableLexiconWrapper::MutableLexiconWrapper(v7, this, a2);
  *a3 = result;
  return result;
}

CFTypeRef *KB::MutableLexiconWrapper::MutableLexiconWrapper(CFTypeRef *this, const KB::String *a2, const KB::String *a3)
{
  const KB::String *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  CFTypeRef cf;
  char v13;
  void *v14;
  _BYTE v15[24];
  _BYTE *v16;
  _BYTE v17[24];
  _BYTE *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)KB::LexiconWrapperBase::LexiconWrapperBase((KB::LexiconWrapperBase *)this, a2) = &off_1EA106040;
  this[18] = (CFTypeRef)KB::MutableLexiconWrapper::create_mutable_lexicon(a2, a3, v6);
  KB::String::String((KB::String *)(this + 19), a3);
  KB::CollatorWrapper::CollatorWrapper((KB::CollatorWrapper *)&cf, this[18], a2);
  KB::LexiconWrapperBase::set_collator(this, (uint64_t *)&cf);
  v7 = v18;
  if (v18 == v17)
  {
    v8 = 4;
    v7 = v17;
  }
  else
  {
    if (!v18)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = v16;
  if (v16 == v15)
  {
    v10 = 4;
    v9 = v15;
    goto LABEL_10;
  }
  if (v16)
  {
    v10 = 5;
LABEL_10:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  if (v14 && v13 == 1)
    free(v14);
  if (cf)
    CFRelease(cf);
  return this;
}

uint64_t KB::MutableLexiconWrapper::create_mutable_lexicon(KB::MutableLexiconWrapper *this, const KB::String *a2, const KB::String *a3)
{
  __CFDictionary *Mutable;
  const void *v6;
  void *v7;
  const void *v8;
  void *v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  const char *v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  const char *v19;
  void *v20;
  void *v21;
  char v22;
  void *value;
  void *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (*(_WORD *)this)
  {
    v6 = (const void *)*MEMORY[0x1E0D437B8];
    KB::cf_string_impl<KB::String>((CFStringRef *)&value, (unsigned __int16 *)this);
    v7 = value;
    CFDictionarySetValue(Mutable, v6, value);
    if (v7)
      CFRelease(v7);
  }
  if (*(_WORD *)a2)
  {
    v8 = (const void *)*MEMORY[0x1E0D43798];
    KB::cf_string_impl<KB::String>((CFStringRef *)&value, (unsigned __int16 *)a2);
    v9 = value;
    CFDictionarySetValue(Mutable, v8, value);
    if (v9)
      CFRelease(v9);
  }
  KB::String::String((KB::String *)&value, "TextInput-Dynamic.");
  KB::String::append((unsigned __int16 *)&value, this);
  v10 = (const void *)*MEMORY[0x1E0D437C8];
  KB::cf_string_impl<KB::String>((CFStringRef *)&v20, (unsigned __int16 *)&value);
  v11 = v20;
  CFDictionarySetValue(Mutable, v10, v20);
  if (v11)
    CFRelease(v11);
  v12 = LXLexiconCreateMutable();
  if (!v12)
  {
    LODWORD(v20) = 0x100000;
    WORD2(v20) = 0;
    BYTE6(v20) = 0;
    v21 = 0;
    v22 = 0;
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    v13 = TIOSLogFacility();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v15 = &v22;
      if (v21)
        v15 = (const char *)v21;
      if (!(_WORD)v20)
        v15 = "";
      *(_DWORD *)buf = 136315394;
      v17 = "create_mutable_lexicon";
      v18 = 2080;
      v19 = v15;
      _os_log_debug_impl(&dword_1DA6F2000, v13, OS_LOG_TYPE_DEBUG, "%s Unable to create LXMutableLexicon: %s", buf, 0x16u);
    }
    if (v21 && BYTE6(v20) == 1)
      free(v21);
  }
  LXLexiconRepositoryAddOrUpdate();
  if (v24 && BYTE6(value) == 1)
    free(v24);
  if (Mutable)
    CFRelease(Mutable);
  return v12;
}

_QWORD *KB::LexiconWrapperBase::set_collator(_QWORD *a1, uint64_t *a2)
{
  const void *v4;
  uint64_t v5;

  v4 = (const void *)a1[5];
  if (v4)
    CFRelease(v4);
  a1[5] = 0;
  v5 = *a2;
  *a2 = 0;
  a1[5] = v5;
  KB::String::operator=((uint64_t)(a1 + 6), (KB::String *)(a2 + 1));
  std::__function::__value_func<KB::ByteString ()(KB::String const&)>::operator=[abi:nn180100](a1 + 10, (uint64_t)(a2 + 5));
  return std::__function::__value_func<KB::ByteString ()(KB::String const&)>::operator=[abi:nn180100](a1 + 14, (uint64_t)(a2 + 9));
}

unsigned __int16 *KB::MutableLexiconWrapper::default_lexicon_name@<X0>(KB::MutableLexiconWrapper *this@<X0>, KB::String *a2@<X8>)
{
  unsigned __int16 *v4;

  v4 = (unsigned __int16 *)KB::String::String(a2, "TextInput-Dynamic.");
  return KB::String::append(v4, this);
}

uint64_t KB::MutableLexiconWrapper::store(KB::MutableLexiconWrapper *this)
{
  if ((*(uint64_t (**)(KB::MutableLexiconWrapper *))(*(_QWORD *)this + 16))(this))
    LXLexiconWrite();
  return 1;
}

uint64_t KB::MutableLexiconWrapper::clear(KB::MutableLexiconWrapper *this)
{
  uint64_t result;

  result = (*(uint64_t (**)(KB::MutableLexiconWrapper *))(*(_QWORD *)this + 16))(this);
  if (result)
    return LXLexiconClear();
  return result;
}

void KB::MutableLexiconWrapper::increment_usage_count(KB::MutableLexiconWrapper *this, const KB::String *a2)
{
  CFStringRef v3;
  CFStringRef v4;

  if ((*(uint64_t (**)(KB::MutableLexiconWrapper *))(*(_QWORD *)this + 16))(this))
  {
    KB::cf_string_impl<KB::String>(&v4, (unsigned __int16 *)a2);
    v3 = v4;
    LXLexiconIncrementUsageCount();
    if (v3)
      CFRelease(v3);
  }
}

uint64_t KB::MutableLexiconWrapper::add_entry(KB::MutableLexiconWrapper *this, const KB::String *a2)
{
  CFStringRef v3;
  uint64_t v4;
  CFStringRef v6;

  if (!(*(uint64_t (**)(KB::MutableLexiconWrapper *))(*(_QWORD *)this + 16))(this))
    return 0;
  KB::cf_string_impl<KB::String>(&v6, (unsigned __int16 *)a2);
  v3 = v6;
  v4 = LXLexiconAdd();
  if (v3)
    CFRelease(v3);
  return v4;
}

uint64_t KB::MutableLexiconWrapper::add_entry_with_token_id(KB::MutableLexiconWrapper *this, const KB::String *a2, double a3)
{
  CFStringRef v4;
  const void *Mutable;
  uint64_t v6;
  CFStringRef v8;

  if (!(*(uint64_t (**)(KB::MutableLexiconWrapper *))(*(_QWORD *)this + 16))(this))
    return 0;
  KB::cf_string_impl<KB::String>(&v8, (unsigned __int16 *)a2);
  v4 = v8;
  Mutable = (const void *)LXEntryCreateMutable();
  if (v4)
    CFRelease(v4);
  v6 = LXLexiconAddEntryWithTokenID();
  if (Mutable)
    CFRelease(Mutable);
  return v6;
}

void KB::MutableLexiconWrapper::write_debug_dump(KB::MutableLexiconWrapper *this, const KB::String *a2)
{
  CFStringRef v3;
  CFURLRef v4;
  CFURLRef v5;
  CFStringRef filePath;

  if ((*(uint64_t (**)(KB::MutableLexiconWrapper *))(*(_QWORD *)this + 16))(this))
  {
    KB::cf_string_impl<KB::String>(&filePath, (unsigned __int16 *)a2);
    v3 = filePath;
    v4 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E0C9AE00], filePath, kCFURLPOSIXPathStyle, 0);
    if (v4)
    {
      v5 = v4;
      LXLexiconWriteDebugDump();
      CFRelease(v5);
    }
    if (v3)
      CFRelease(v3);
  }
}

void AddressBookTrieLoaderImpl::~AddressBookTrieLoaderImpl(AddressBookTrieLoaderImpl *this)
{
  AddressBookTrieLoaderImpl::~AddressBookTrieLoaderImpl(this);
  JUMPOUT(0x1DF0A2144);
}

{
  NSObject *v2;
  void *v3;
  void *v4;
  const void *v5;
  std::__shared_weak_count *v6;
  uint8_t buf[4];
  void *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  TIPersonalizationContactOSLogFacility();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Removing contact observer"), "~AddressBookTrieLoaderImpl");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    v8 = v3;
    _os_log_impl(&dword_1DA6F2000, v2, OS_LOG_TYPE_INFO, "%@", buf, 0xCu);

  }
  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "removeContactObserver:", *((_QWORD *)this + 6));

  v5 = (const void *)*((_QWORD *)this + 5);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 5) = 0;
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

float acceptable_threshold_for_locale(_QWORD *a1, uint64_t a2)
{
  float *v3;
  float result;

  v3 = (float *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::find<std::string>(a2, a1);
  result = 0.003;
  if ((float *)(a2 + 8) != v3 && v3[14] != 0.0)
    return v3[14];
  return result;
}

_QWORD *std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::find<std::string>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  char v6;
  _QWORD *v7;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = (_QWORD *)(a1 + 8);
  do
  {
    v6 = std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v3 + 4, a2);
    if (v6 >= 0)
      v7 = v3;
    else
      v7 = v3 + 1;
    if (v6 >= 0)
      v5 = v3;
    v3 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v5 == v2
    || (std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) != 0)
  {
    return v2;
  }
  return v5;
}

void AddressBookTrieLoaderImpl::AddressBookTrieLoaderImpl(AddressBookTrieLoaderImpl *this)
{
  uint64_t View;
  _QWORD *v3;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1EA106120;
  View = LXLexiconRepositoryCreateView();
  v3 = operator new(0x20uLL);
  v3[1] = 0;
  v3[2] = 0;
  v3[3] = View;
  *v3 = &off_1EA1061A8;
  *((_QWORD *)this + 3) = v3 + 3;
  *((_QWORD *)this + 4) = v3;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
}

void AddressBookTrieLoaderImpl::static_dictionary_for_filtering(AddressBookTrieLoaderImpl *this@<X0>, const KB::String *a2@<X1>, const KB::String *a3@<X2>, uint64_t *a4@<X8>)
{
  char *v9;
  char *v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  const char *v15;
  void *v16;
  uint8_t buf[4];
  void *v18;
  _BYTE v19[8];
  void *v20;
  _BYTE v21[8];
  void *v22;
  _BYTE v23[8];
  void *v24;
  _BYTE v25[8];
  void *v26;
  _BYTE v27[8];
  void *v28;
  uint64_t v29;
  int v30;
  _BYTE v31[8];
  void *v32;
  _BYTE v33[8];
  void *v34;
  _BYTE v35[8];
  void *v36;
  int v37;
  __int16 v38;
  char v39;
  void *v40;
  char v41;
  int v42;
  __int16 v43;
  char v44;
  void *v45;
  char v46;
  uint64_t v47;
  int v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  KB::StaticDictionary::create(a4);
  v9 = (char *)*((_QWORD *)this + 1);
  if (!v9)
    v9 = (char *)this + 16;
  if (*(_WORD *)this)
    v10 = v9;
  else
    v10 = "";
  v11 = TILexiconIDForLocaleIdentifier(v10);
  KB::String::String((KB::String *)v31, this);
  KB::String::String((KB::String *)v33, a2);
  KB::String::String((KB::String *)v35, a3);
  v37 = 0x100000;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0x100000;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  LODWORD(v47) = v11;
  BYTE4(v47) = 0;
  v48 = 1065353216;
  v12 = *a4;
  KB::String::String((KB::String *)v19, (const KB::String *)v31);
  KB::String::String((KB::String *)v21, (const KB::String *)v33);
  KB::String::String((KB::String *)v23, (const KB::String *)v35);
  KB::String::String((KB::String *)v25, (const KB::String *)&v37);
  KB::String::String((KB::String *)v27, (const KB::String *)&v42);
  v29 = v47;
  v30 = v48;
  KB::StaticDictionary::load((const void ***)v12, (uint64_t)v19);
  if (v28 && v27[6] == 1)
    free(v28);
  if (v26 && v25[6] == 1)
    free(v26);
  if (v24 && v23[6] == 1)
    free(v24);
  if (v22 && v21[6] == 1)
    free(v22);
  if (v20 && v19[6] == 1)
    free(v20);
  if (*(_QWORD *)v12 == *(_QWORD *)(v12 + 8))
  {
    TIPersonalizationContactOSLogFacility();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = (const char *)*((_QWORD *)a2 + 1);
      if (!v14)
        v14 = (char *)a2 + 16;
      if (*(_WORD *)a2)
        v15 = v14;
      else
        v15 = "";
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Failed to open contact filtering dictionary at %s"), "static_dictionary_for_filtering", v15);
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      v18 = v16;
      _os_log_error_impl(&dword_1DA6F2000, v13, OS_LOG_TYPE_ERROR, "%@", buf, 0xCu);

    }
  }
  if (v45 && v44 == 1)
    free(v45);
  if (v40 && v39 == 1)
    free(v40);
  if (v36 && v35[6] == 1)
    free(v36);
  if (v34 && v33[6] == 1)
    free(v34);
  if (v32)
  {
    if (v31[6] == 1)
      free(v32);
  }
}

void AddressBookTrieLoaderImpl::create_empty_transient_lexicon(AddressBookTrieLoaderImpl *this@<X0>, uint64_t *a2@<X8>)
{
  __CFDictionary *Mutable;
  const void *v6;
  const void *v7;
  void *value[4];

  value[3] = *(void **)MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v6 = (const void *)*MEMORY[0x1E0D437B8];
  KB::cf_string_impl<KB::String>((CFStringRef *)value, (unsigned __int16 *)this);
  v7 = value[0];
  CFDictionaryAddValue(Mutable, v6, value[0]);
  if (v7)
    CFRelease(v7);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0D437C8], CFSTR("TextInput-AddressBook"));
  *a2 = LXLexiconCreateTransient();
  if (Mutable)
    CFRelease(Mutable);
}

void AddressBookTrieLoaderImpl::register_as_contact_observer(_QWORD *a1, const KB::String *a2, const KB::String *a3, const KB::String *a4)
{
  NSObject *v8;
  void *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_weak_owners;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  void *v18;
  unint64_t v19;
  uint64_t v20;
  void *v21;
  _QWORD v22[5];
  std::__shared_weak_count *v23;
  _BYTE v24[8];
  void *v25;
  _BYTE v26[8];
  void *v27;
  _BYTE v28[8];
  void *v29;
  uint8_t buf[4];
  void *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  TIPersonalizationContactOSLogFacility();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Adding contact observer"), "register_as_contact_observer");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    v31 = v9;
    _os_log_impl(&dword_1DA6F2000, v8, OS_LOG_TYPE_INFO, "%@", buf, 0xCu);

  }
  v10 = (std::__shared_weak_count *)a1[2];
  if (!v10 || (v11 = a1[1], (v12 = std::__shared_weak_count::lock(v10)) == 0))
    std::__throw_bad_weak_ptr[abi:nn180100]();
  v13 = v12;
  p_shared_weak_owners = (unint64_t *)&v12->__shared_weak_owners_;
  do
    v15 = __ldxr(p_shared_weak_owners);
  while (__stxr(v15 + 1, p_shared_weak_owners));
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  do
    v17 = __ldaxr(p_shared_owners);
  while (__stlxr(v17 - 1, p_shared_owners));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v13);
  }
  +[TITransientLexiconManager sharedInstance](TITransientLexiconManager, "sharedInstance");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 3321888768;
  v22[2] = ___ZN25AddressBookTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1__block_invoke;
  v22[3] = &__block_descriptor_144_a8_32c50_ZTSNSt3__18weak_ptrI25AddressBookTrieLoaderImplEE48c17_ZTSKN2KB6StringE80c17_ZTSKN2KB6StringE112c17_ZTSKN2KB6StringE_e22_v16__0__NSDictionary_8l;
  v22[4] = v11;
  v23 = v13;
  do
    v19 = __ldxr(p_shared_weak_owners);
  while (__stxr(v19 + 1, p_shared_weak_owners));
  KB::String::String((KB::String *)v24, a2);
  KB::String::String((KB::String *)v26, a3);
  KB::String::String((KB::String *)v28, a4);
  objc_msgSend(v18, "addContactObserver:", v22);
  v20 = objc_claimAutoreleasedReturnValue();
  v21 = (void *)a1[6];
  a1[6] = v20;

  if (v29 && v28[6] == 1)
    free(v29);
  if (v27 && v26[6] == 1)
    free(v27);
  if (v25 && v24[6] == 1)
    free(v25);
  if (v23)
    std::__shared_weak_count::__release_weak(v23);
  std::__shared_weak_count::__release_weak(v13);
}

void ___ZN25AddressBookTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1__block_invoke(_QWORD *a1, void *a2)
{
  id v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  const void *v7;
  NSObject *v8;
  void *v9;
  KB::StaticDictionary *v10;
  id v11;
  uint64_t v12;
  void (**v13)(void *);
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t i;
  void *v19;
  char v20;
  int v21;
  int v22;
  id v23;
  uint64_t **v24;
  uint64_t **v25;
  _OWORD *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t SharedVocabulary;
  char v30;
  uint64_t j;
  void *v32;
  void *v33;
  long double v34;
  void *v35;
  long double v36;
  void *v37;
  long double v38;
  void *v39;
  long double v40;
  void *v41;
  long double v42;
  void *v43;
  long double v44;
  void *v45;
  KB::StaticDictionary *v46;
  uint64_t v47;
  id v48;
  void *v49;
  id v50;
  __CFString *v51;
  void *v52;
  double v53;
  long double v54;
  const __CFString *v55;
  void *v56;
  NSObject *v57;
  void *v58;
  unint64_t *p_shared_weak_owners;
  unint64_t v60;
  unint64_t v61;
  unint64_t *p_shared_owners;
  unint64_t v63;
  void (**v64)(void *);
  std::__shared_weak_count *v65;
  id v66;
  id v67;
  char v68;
  uint64_t v69;
  __CFArray *theArray;
  id v71;
  uint64_t v72;
  id obj;
  id obja;
  char v75;
  KB::StaticDictionary *v76;
  const void *v77;
  _QWORD v78[4];
  id v79;
  CFTypeRef cf;
  KB::StaticDictionary *v81;
  char **v82;
  char *v83[2];
  char v84;
  _QWORD v85[4];
  id v86;
  CFTypeRef v87;
  KB::StaticDictionary *v88;
  char **v89;
  char *v90[2];
  char v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  uint64_t **v100;
  uint64_t *v101;
  uint64_t v102;
  _QWORD aBlock[5];
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  uint64_t (*v107)(uint64_t, uint64_t);
  void (*v108)(uint64_t);
  id v109;
  __int128 __p;
  uint64_t v111;
  int v112;
  uint8_t buf[4];
  void *v114;
  uint64_t v115;

  v115 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = (std::__shared_weak_count *)a1[5];
  if (v4)
  {
    v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      v6 = v5;
      if (a1[4])
      {
        AddressBookTrieLoaderImpl::create_empty_transient_lexicon((AddressBookTrieLoaderImpl *)(a1 + 6), (uint64_t *)&v77);
        v7 = v77;
        if (v77)
        {
          TIPersonalizationContactOSLogFacility();
          v8 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Adding %ld contacts to lexicon"), "register_as_contact_observer_block_invoke", objc_msgSend(v3, "count"));
            v9 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138412290;
            v114 = v9;
            _os_log_impl(&dword_1DA6F2000, v8, OS_LOG_TYPE_INFO, "%@", buf, 0xCu);

          }
          AddressBookTrieLoaderImpl::static_dictionary_for_filtering((AddressBookTrieLoaderImpl *)(a1 + 6), (const KB::String *)(a1 + 10), (const KB::String *)(a1 + 14), (uint64_t *)&v76);
          CFRetain(v7);
          v10 = v76;
          v11 = v3;
          v12 = MEMORY[0x1E0C809B0];
          v71 = v11;
          if (v11)
          {
            theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
            v104 = 0;
            v105 = &v104;
            v106 = 0x3032000000;
            v107 = __Block_byref_object_copy__18211;
            v108 = __Block_byref_object_dispose__18212;
            v109 = 0;
            aBlock[0] = v12;
            aBlock[1] = 3221225472;
            aBlock[2] = ___ZL28background_load_address_bookN2KB10retain_ptrIP10_LXLexiconEERKNS_16StaticDictionaryEP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke;
            aBlock[3] = &unk_1EA107058;
            aBlock[4] = &v104;
            v13 = (void (**)(void *))_Block_copy(aBlock);
            v65 = v6;
            v66 = v3;
            if (objc_msgSend(MEMORY[0x1E0CB3978], "isMainThread"))
              v13[2](v13);
            else
              TIDispatchSync();
            v102 = 0;
            v101 = 0;
            v100 = &v101;
            v98 = 0u;
            v99 = 0u;
            v96 = 0u;
            v97 = 0u;
            obj = (id)v105[5];
            v14 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v96, buf, 16);
            v64 = v13;
            if (v14)
            {
              v15 = v14;
              v16 = 0;
              v75 = 0;
              v17 = *(_QWORD *)v97;
              do
              {
                for (i = 0; i != v15; ++i)
                {
                  if (*(_QWORD *)v97 != v17)
                    objc_enumerationMutation(obj);
                  TIInputModeGetLanguageWithRegion();
                  v19 = (void *)objc_claimAutoreleasedReturnValue();
                  if ((objc_msgSend(v19, "hasPrefix:", CFSTR("zh")) & 1) != 0
                    || objc_msgSend(v19, "hasPrefix:", CFSTR("ja")))
                  {
                    v75 = 1;
                  }
                  v20 = objc_msgSend(v19, "hasPrefix:", CFSTR("en"));
                  CFArrayAppendValue(theArray, v19);
                  TIGetAddressBookThresholdForInputMode();
                  v22 = v21;
                  v23 = objc_retainAutorelease(v19);
                  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)objc_msgSend(v23, "UTF8String"));
                  v112 = v22;
                  v24 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)&v100, v85, &__p);
                  if (!*v24)
                  {
                    v25 = v24;
                    v26 = operator new(0x40uLL);
                    v26[2] = __p;
                    *((_QWORD *)v26 + 6) = v111;
                    __p = 0uLL;
                    v111 = 0;
                    *((_DWORD *)v26 + 14) = v22;
                    v27 = v85[0];
                    *(_QWORD *)v26 = 0;
                    *((_QWORD *)v26 + 1) = 0;
                    *((_QWORD *)v26 + 2) = v27;
                    *v25 = (uint64_t *)v26;
                    if (*v100)
                    {
                      v100 = (uint64_t **)*v100;
                      v28 = *v25;
                    }
                    else
                    {
                      v28 = (uint64_t *)v26;
                    }
                    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v101, v28);
                    ++v102;
                  }
                  if (SHIBYTE(v111) < 0)
                    operator delete((void *)__p);
                  v16 |= v20;

                }
                v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v96, buf, 16);
              }
              while (v15);
            }
            else
            {
              v16 = 0;
              v75 = 0;
            }

            SharedVocabulary = LMVocabularyGetSharedVocabulary();
            LMVocabularyReset();
            obja = (id)SharedVocabulary;
            LMVocabularySetLanguages();
            v92 = 0u;
            v93 = 0u;
            v94 = 0u;
            v95 = 0u;
            objc_msgSend(v71, "allKeys");
            v67 = (id)objc_claimAutoreleasedReturnValue();
            v72 = objc_msgSend(v67, "countByEnumeratingWithState:objects:count:", &v92, &__p, 16);
            if (v72)
            {
              v69 = *(_QWORD *)v93;
              v68 = v16;
              v30 = v16 & 1;
              do
              {
                for (j = 0; j != v72; ++j)
                {
                  if (*(_QWORD *)v93 != v69)
                    objc_enumerationMutation(v67);
                  objc_msgSend(v71, "objectForKey:", *(_QWORD *)(*((_QWORD *)&v92 + 1) + 8 * j));
                  v32 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v32, "lastName");
                  v33 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v32, "score");
                  addName(v33, v34, (uint64_t)v7, (uint64_t)obja, 69, v10, v16 & 1, (uint64_t)&v100);

                  objc_msgSend(v32, "firstName");
                  v35 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v32, "score");
                  addName(v35, v36, (uint64_t)v7, (uint64_t)obja, 68, v10, v16 & 1, (uint64_t)&v100);

                  objc_msgSend(v32, "nickname");
                  v37 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v32, "score");
                  addName(v37, v38, (uint64_t)v7, (uint64_t)obja, 68, v10, v16 & 1, (uint64_t)&v100);

                  objc_msgSend(v32, "middleName");
                  v39 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v32, "score");
                  addName(v39, v40, (uint64_t)v7, 0, 0, v10, v16 & 1, (uint64_t)&v100);

                  objc_msgSend(v32, "organizationName");
                  v41 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v32, "score");
                  addName(v41, v42, (uint64_t)v7, 0, 0, v10, v16 & 1, (uint64_t)&v100);

                  objc_msgSend(v32, "jobTitle");
                  v43 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v32, "score");
                  addName(v43, v44, (uint64_t)v7, 0, 0, v10, v16 & 1, (uint64_t)&v100);

                  objc_msgSend(v32, "relations");
                  v45 = (void *)objc_claimAutoreleasedReturnValue();
                  v46 = v10;
                  v47 = MEMORY[0x1E0C809B0];
                  v85[0] = MEMORY[0x1E0C809B0];
                  v85[1] = 3321888768;
                  v85[2] = ___ZL28background_load_address_bookN2KB10retain_ptrIP10_LXLexiconEERKNS_16StaticDictionaryEP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke_2;
                  v85[3] = &unk_1EA1061D8;
                  v87 = v7;
                  CFRetain(v7);
                  v87 = v7;
                  v88 = v46;
                  v48 = v32;
                  v91 = v30;
                  v90[0] = 0;
                  v90[1] = 0;
                  v86 = v48;
                  v89 = v90;
                  std::map<std::string,float>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,float>,std::__tree_node<std::__value_type<std::string,float>,void *> *,long>>>((uint64_t)&v89, v100, &v101);
                  objc_msgSend(v45, "enumerateObjectsUsingBlock:", v85);

                  objc_msgSend(v48, "cities");
                  v49 = (void *)objc_claimAutoreleasedReturnValue();
                  v78[0] = v47;
                  v10 = v46;
                  v78[1] = 3321888768;
                  v78[2] = ___ZL28background_load_address_bookN2KB10retain_ptrIP10_LXLexiconEERKNS_16StaticDictionaryEP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke_28;
                  v78[3] = &unk_1EA1061D8;
                  cf = v7;
                  CFRetain(v7);
                  cf = v7;
                  v81 = v46;
                  v50 = v48;
                  v84 = v30;
                  v83[0] = 0;
                  v83[1] = 0;
                  v79 = v50;
                  v82 = v83;
                  std::map<std::string,float>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,float>,std::__tree_node<std::__value_type<std::string,float>,void *> *,long>>>((uint64_t)&v82, v100, &v101);
                  objc_msgSend(v49, "enumerateObjectsUsingBlock:", v78);

                  objc_msgSend(v50, "firstName");
                  v51 = (__CFString *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v50, "lastName");
                  v52 = (void *)objc_claimAutoreleasedReturnValue();
                  if ((v75 & (v52 != 0)) == 1)
                  {
                    objc_msgSend(v50, "score");
                    v54 = v53;
                    if ((!v51
                       || (-[__CFString _containsIdeographicCharacters](v51, "_containsIdeographicCharacters") & 1) != 0
                       || -[__CFString _containsHiraganaOrKatakana](v51, "_containsHiraganaOrKatakana"))
                      && ((objc_msgSend(v52, "_containsIdeographicCharacters") & 1) != 0
                       || objc_msgSend(v52, "_containsHiraganaOrKatakana")))
                    {
                      if (v51)
                        v55 = v51;
                      else
                        v55 = &stru_1EA1081D0;
                      objc_msgSend(v52, "stringByAppendingString:", v55);
                      v56 = (void *)objc_claimAutoreleasedReturnValue();
                      log10(v54);
                      LMVocabularyAddLemma();

                    }
                  }

                  std::__tree<std::__value_type<std::string,sqlite3_stmt *>,std::__map_value_compare<std::string,std::__value_type<std::string,sqlite3_stmt *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,sqlite3_stmt *>>>::destroy(v83[0]);
                  if (cf)
                    CFRelease(cf);
                  cf = 0;
                  std::__tree<std::__value_type<std::string,sqlite3_stmt *>,std::__map_value_compare<std::string,std::__value_type<std::string,sqlite3_stmt *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,sqlite3_stmt *>>>::destroy(v90[0]);

                  v16 = v68;
                  if (v87)
                    CFRelease(v87);
                  v87 = 0;

                }
                v72 = objc_msgSend(v67, "countByEnumeratingWithState:objects:count:", &v92, &__p, 16);
              }
              while (v72);
            }

            std::__tree<std::__value_type<std::string,sqlite3_stmt *>,std::__map_value_compare<std::string,std::__value_type<std::string,sqlite3_stmt *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,sqlite3_stmt *>>>::destroy((char *)v101);
            _Block_object_dispose(&v104, 8);

            v6 = v65;
            v3 = v66;
            if (theArray)
              CFRelease(theArray);
          }

          CFRelease(v7);
          TIPersonalizationContactOSLogFacility();
          v57 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s Installing contact lexicon on main thread"), "register_as_contact_observer_block_invoke");
            v58 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138412290;
            v114 = v58;
            _os_log_impl(&dword_1DA6F2000, v57, OS_LOG_TYPE_INFO, "%@", buf, 0xCu);

          }
          p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
          do
            v60 = __ldxr(p_shared_weak_owners);
          while (__stxr(v60 + 1, p_shared_weak_owners));
          CFRetain(v7);
          do
            v61 = __ldxr(p_shared_weak_owners);
          while (__stxr(v61 + 1, p_shared_weak_owners));
          CFRetain(v7);
          TIDispatchAsync();
          CFRelease(v7);
          std::__shared_weak_count::__release_weak(v6);
          if (v7)
            CFRelease(v7);
          std::__shared_weak_count::__release_weak(v6);
          if (v10)
          {
            KB::StaticDictionary::~StaticDictionary((const void ***)v10);
            MEMORY[0x1DF0A2144]();
          }
          CFRelease(v7);
        }
      }
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v63 = __ldaxr(p_shared_owners);
      while (__stlxr(v63 - 1, p_shared_owners));
      if (!v63)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

}

KB::String *__copy_helper_block_a8_32c50_ZTSNSt3__18weak_ptrI25AddressBookTrieLoaderImplEE48c17_ZTSKN2KB6StringE80c17_ZTSKN2KB6StringE112c17_ZTSKN2KB6StringE(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v4 = a2[5];
  a1[4] = a2[4];
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  KB::String::String((KB::String *)(a1 + 6), (const KB::String *)(a2 + 6));
  KB::String::String((KB::String *)(a1 + 10), (const KB::String *)(a2 + 10));
  return KB::String::String((KB::String *)(a1 + 14), (const KB::String *)(a2 + 14));
}

void __destroy_helper_block_a8_32c50_ZTSNSt3__18weak_ptrI25AddressBookTrieLoaderImplEE48c17_ZTSKN2KB6StringE80c17_ZTSKN2KB6StringE112c17_ZTSKN2KB6StringE(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  std::__shared_weak_count *v5;

  v2 = *(void **)(a1 + 120);
  if (v2 && *(_BYTE *)(a1 + 118) == 1)
    free(v2);
  v3 = *(void **)(a1 + 88);
  if (v3 && *(_BYTE *)(a1 + 86) == 1)
    free(v3);
  v4 = *(void **)(a1 + 56);
  if (v4 && *(_BYTE *)(a1 + 54) == 1)
    free(v4);
  v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

uint64_t __Block_byref_object_copy__18211(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__18212(uint64_t a1)
{

}

void ___ZL28background_load_address_bookN2KB10retain_ptrIP10_LXLexiconEERKNS_16StaticDictionaryEP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  id v5;

  objc_msgSend(MEMORY[0x1E0DBDBA8], "sharedInputModeController");
  v5 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "enabledInputModeIdentifiers");
  v2 = objc_claimAutoreleasedReturnValue();
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

}

void addName(void *a1, long double a2, uint64_t a3, uint64_t a4, uint64_t a5, KB::StaticDictionary *a6, int a7, uint64_t a8)
{
  __CFString *v12;
  __CFString *v13;
  const KB::String *v14;
  const KB::String *v15;
  BOOL v16;
  char v17;
  float v18;
  const KB::String *v19;
  unsigned int v20;
  const USet *v21;
  CFStringRef v22;
  const __CFString *v23;
  float v25;
  char *v26;
  float *v27;
  float v28;
  BOOL v29;
  unsigned int v30;
  char v31;
  const void *v32;
  CFStringRef v33;
  int v34;
  int v35;
  char v36;
  const KB::String *v38;
  const KB::String *v39;
  CFStringRef v40;
  const __CFString *v41;
  float v42;
  void *__p[2];
  char v44;
  const KB::String **v45;
  void *v46;
  unsigned __int16 v47[3];
  char v48;
  void *v49;
  int v50;
  __int16 v51;
  char v52;
  char *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v12;
  if (v12 && (unint64_t)-[__CFString length](v12, "length") <= 0x100)
  {
    v35 = a7;
    v51 = 0;
    v52 = 0;
    v53 = " ,:;";
    v50 = 1048580;
    v54 = 0;
    KB::utf8_string(v13, (uint64_t)v47);
    KB::sbs_string_tokenize(v47, (const KB::String *)&v50, &v38);
    v15 = v38;
    v14 = v39;
    if (v38 != v39)
    {
      if (a4)
        v16 = (unint64_t)(v39 - v38) > 0x3F;
      else
        v16 = 1;
      v17 = v16;
      v36 = v17;
      log10(a2);
      do
      {
        KB::String::String((KB::String *)&v45, v15);
        v42 = 0.0;
        KB::StaticDictionary::candidates_for_string(a6, (const KB::String *)&v45, &v42, &v40);
        v18 = v42;
        if ((KB::StaticDictionary::contains_surfaceform_insertion_with_candidates((uint64_t *)&v40, 0, v42) & 1) == 0)
        {
          v20 = KB::count_letters_if_word((KB *)&v45, v19);
          if (v20 == 2)
          {
            v22 = v40;
            v23 = v41;
            if (v18 > 0.002 && v41 != v40)
              goto LABEL_41;
          }
          else
          {
            if (v20 < 2)
              goto LABEL_41;
            v22 = v40;
            v23 = v41;
          }
          v25 = v42;
          if (v23 == v22)
          {
            v29 = v42 > 0.0;
          }
          else
          {
            v26 = (char *)TILocaleIdentifierForLexiconID(v22[4].info);
            std::string::basic_string[abi:nn180100]<0>(__p, v26);
            v27 = (float *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::find<std::string>(a8, __p);
            v28 = 0.003;
            if ((float *)(a8 + 8) != v27)
            {
              v28 = 0.003;
              if (v27[14] != 0.0)
                v28 = v27[14];
            }
            if (v44 < 0)
              operator delete(__p[0]);
            if (v25 > v28 && v41 != v40)
              goto LABEL_41;
            v29 = v25 > 0.0;
            if (v25 > 0.0 && v41 != v40)
            {
              v30 = WORD2(v45);
              if (!WORD2(v45))
              {
                KB::String::compute_length((unsigned __int16 *)&v45);
                v30 = WORD2(v45);
              }
              if (v30 < 3)
                goto LABEL_41;
            }
          }
          if (_unacceptable_confusable_characters(void)::once_token != -1)
            dispatch_once(&_unacceptable_confusable_characters(void)::once_token, &__block_literal_global_18224);
          if (!KB::any_of_string_characters_in_set((KB *)&v45, (const KB::String *)_unacceptable_confusable_characters(void)::excluded_set, v21))goto LABEL_47;
          v31 = !v29;
          if (v41 == v40)
            v31 = 1;
          if ((v31 & 1) != 0)
          {
LABEL_47:
            __p[0] = &v40;
            std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
            KB::cf_string_impl<KB::String>((CFStringRef *)__p, (unsigned __int16 *)&v45);
            v32 = __p[0];
            if (LXLexiconAdd())
              LXLexiconIncrementUsageCount();
            if ((v36 & 1) == 0)
            {
              KB::cf_string_impl<KB::String>(&v40, (unsigned __int16 *)&v45);
              v33 = v40;
              v34 = LMVocabularyAddLemma();
              if (v33)
                CFRelease(v33);
              if (v34 && v35)
                LMVocabularyEnumerateInflectionsOfLemma();
            }
            if (v32)
              CFRelease(v32);
            goto LABEL_42;
          }
        }
LABEL_41:
        __p[0] = &v40;
        std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
LABEL_42:
        if (v46 && BYTE6(v45) == 1)
          free(v46);
        v15 = (const KB::String *)((char *)v15 + 32);
      }
      while (v15 != v14);
    }
    v45 = &v38;
    std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v45);
    if (v49 && v48 == 1)
      free(v49);
    if (v53 && v52 == 1)
      free(v53);
  }

}

void ___ZL28background_load_address_bookN2KB10retain_ptrIP10_LXLexiconEERKNS_16StaticDictionaryEP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke_2(uint64_t a1, void *a2)
{
  KB::StaticDictionary *v3;
  uint64_t v4;
  void *v5;
  long double v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 40);
  v3 = *(KB::StaticDictionary **)(a1 + 48);
  v5 = *(void **)(a1 + 32);
  v7 = a2;
  objc_msgSend(v5, "score");
  addName(v7, v6, v4, 0, 0, v3, *(unsigned __int8 *)(a1 + 80), a1 + 56);

}

uint64_t std::map<std::string,float>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,float>,std::__tree_node<std::__value_type<std::string,float>,void *> *,long>>>(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  BOOL v13;
  uint64_t **v14;
  char *v15;
  std::string *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20[11];

  if (a2 != a3)
  {
    v20[9] = v3;
    v20[10] = v4;
    v6 = a2;
    v7 = result;
    v8 = result + 8;
    do
    {
      v9 = *(_QWORD *)(v7 + 8);
      v10 = (_QWORD *)v8;
      if (*(_QWORD *)v7 == v8)
        goto LABEL_10;
      v11 = *(_QWORD **)(v7 + 8);
      v12 = (_QWORD *)v8;
      if (v9)
      {
        do
        {
          v10 = v11;
          v11 = (_QWORD *)v11[1];
        }
        while (v11);
      }
      else
      {
        do
        {
          v10 = (_QWORD *)v12[2];
          v13 = *v10 == (_QWORD)v12;
          v12 = v10;
        }
        while (v13);
      }
      result = std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v10 + 4, v6 + 4);
      if ((result & 0x80) != 0)
      {
LABEL_10:
        if (!v9)
        {
          v20[0] = v8;
          v14 = (uint64_t **)v8;
LABEL_15:
          v15 = (char *)operator new(0x40uLL);
          v16 = (std::string *)(v15 + 32);
          if (*((char *)v6 + 55) < 0)
          {
            std::string::__init_copy_ctor_external(v16, (const std::string::value_type *)v6[4], v6[5]);
          }
          else
          {
            v17 = *((_OWORD *)v6 + 2);
            *((_QWORD *)v15 + 6) = v6[6];
            *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v17;
          }
          *((_DWORD *)v15 + 14) = *((_DWORD *)v6 + 14);
          result = (uint64_t)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at((uint64_t **)v7, v20[0], v14, (uint64_t *)v15);
          goto LABEL_19;
        }
        v20[0] = (uint64_t)v10;
        v14 = (uint64_t **)(v10 + 1);
      }
      else
      {
        result = (uint64_t)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(v7, v20, v6 + 4);
        v14 = (uint64_t **)result;
      }
      if (!*v14)
        goto LABEL_15;
LABEL_19:
      v18 = (_QWORD *)v6[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (_QWORD *)v6[2];
          v13 = *v19 == (_QWORD)v6;
          v6 = v19;
        }
        while (!v13);
      }
      v6 = v19;
    }
    while (v19 != a3);
  }
  return result;
}

void ___ZL28background_load_address_bookN2KB10retain_ptrIP10_LXLexiconEERKNS_16StaticDictionaryEP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke_28(uint64_t a1, void *a2)
{
  KB::StaticDictionary *v3;
  uint64_t v4;
  void *v5;
  long double v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 40);
  v3 = *(KB::StaticDictionary **)(a1 + 48);
  v5 = *(void **)(a1 + 32);
  v7 = a2;
  objc_msgSend(v5, "score");
  addName(v7, v6, v4, 0, 0, v3, *(unsigned __int8 *)(a1 + 80), a1 + 56);

}

void ___ZN25AddressBookTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1__block_invoke_14(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v2 = (std::__shared_weak_count *)a1[5];
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = a1[4];
      if (v5)
      {
        v6 = (const void *)a1[6];
        if (v6)
        {
          CFRetain(v6);
          LXLexiconRepositoryAddOrUpdate();
          KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(v5 + 40), v6);
          CFRelease(v6);
        }
        else
        {
          LXLexiconRepositoryAddOrUpdate();
          v7 = *(const void **)(v5 + 40);
          if (v7)
          {
            CFRelease(v7);
            *(_QWORD *)(v5 + 40) = 0;
          }
        }
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

_QWORD *__copy_helper_block_a8_32c93_ZTSKZZN25AddressBookTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1_EUb_E3__0(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  const void *v6;

  v2 = result;
  v3 = a2[5];
  result[4] = a2[4];
  result[5] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (const void *)a2[6];
  result[6] = v6;
  if (v6)
  {
    result = CFRetain(v6);
    v2[6] = v6;
  }
  return result;
}

void __destroy_helper_block_a8_32c93_ZTSKZZN25AddressBookTrieLoaderImpl28register_as_contact_observerEN2KB6StringES1_S1_EUb_E3__0(uint64_t a1)
{
  const void *v2;
  std::__shared_weak_count *v3;

  v2 = *(const void **)(a1 + 48);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)(a1 + 48) = 0;
  v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

uint64_t __copy_helper_block_a8_40c36_ZTSN2KB10retain_ptrIP10_LXLexiconEE56c114_ZTSNSt3__13mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEfNS_4lessIS6_EENS4_INS_4pairIKS6_fEEEEEE(_QWORD *a1, uint64_t a2)
{
  const void *v4;
  uint64_t v5;

  v4 = *(const void **)(a2 + 40);
  a1[5] = v4;
  if (v4)
  {
    CFRetain(v4);
    a1[5] = v4;
  }
  a1[8] = 0;
  a1[7] = a1 + 8;
  v5 = (uint64_t)(a1 + 7);
  *(_QWORD *)(v5 + 16) = 0;
  return std::map<std::string,float>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,float>,std::__tree_node<std::__value_type<std::string,float>,void *> *,long>>>(v5, *(_QWORD **)(a2 + 56), (_QWORD *)(a2 + 64));
}

void __destroy_helper_block_a8_40c36_ZTSN2KB10retain_ptrIP10_LXLexiconEE56c114_ZTSNSt3__13mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEfNS_4lessIS6_EENS4_INS_4pairIKS6_fEEEEEE(uint64_t a1)
{
  const void *v2;

  std::__tree<std::__value_type<std::string,sqlite3_stmt *>,std::__map_value_compare<std::string,std::__value_type<std::string,sqlite3_stmt *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,sqlite3_stmt *>>>::destroy(*(char **)(a1 + 64));
  v2 = *(const void **)(a1 + 40);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)(a1 + 40) = 0;
}

void ___ZL7addNameP8NSStringP10_LXLexiconPvjRKN2KB16StaticDictionaryEdbRKNSt3__13mapINS8_12basic_stringIcNS8_11char_traitsIcEENS8_9allocatorIcEEEEfNS8_4lessISF_EENSD_INS8_4pairIKSF_fEEEEEE_block_invoke(int a1, id a2)
{
  CFStringRef v2;
  CFStringRef v3;
  unsigned __int16 v4[3];
  char v5;
  void *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  KB::String::String((KB::String *)v4, (const char *)objc_msgSend(objc_retainAutorelease(a2), "UTF8String"));
  KB::cf_string_impl<KB::String>(&v3, v4);
  v2 = v3;
  if (LXLexiconAdd())
    LXLexiconIncrementUsageCount();
  if (v2)
    CFRelease(v2);
  if (v6)
  {
    if (v5 == 1)
      free(v6);
  }
}

uint64_t ___ZL35_unacceptable_confusable_charactersv_block_invoke()
{
  uint64_t result;

  result = uset_openEmpty();
  _unacceptable_confusable_characters(void)::excluded_set = result;
  if (result)
  {
    MEMORY[0x1DF0A2DD4](result, 119808, 120831);
    MEMORY[0x1DF0A2DD4](_unacceptable_confusable_characters(void)::excluded_set, 688, 696);
    MEMORY[0x1DF0A2DD4](_unacceptable_confusable_characters(void)::excluded_set, 736, 739);
    MEMORY[0x1DF0A2DD4](_unacceptable_confusable_characters(void)::excluded_set, 7468, 7615);
    MEMORY[0x1DF0A2DD4](_unacceptable_confusable_characters(void)::excluded_set, 8305, 8348);
    MEMORY[0x1DF0A2DD4](_unacceptable_confusable_characters(void)::excluded_set, 11388, 11389);
    MEMORY[0x1DF0A2DD4](_unacceptable_confusable_characters(void)::excluded_set, 8448, 8527);
    MEMORY[0x1DF0A2DD4](_unacceptable_confusable_characters(void)::excluded_set, 127232, 127405);
    MEMORY[0x1DF0A2DD4](_unacceptable_confusable_characters(void)::excluded_set, 127462, 127487);
    JUMPOUT(0x1DF0A2DF8);
  }
  return result;
}

const void **AddressBookTrieLoaderImpl::set_lexicon(uint64_t a1, CFTypeRef *a2)
{
  LXLexiconRepositoryAddOrUpdate();
  return KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(a1 + 40), *a2);
}

__n128 KB::AddressBookTrieLoader::create@<Q0>(__n128 *a1@<X8>)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  __n128 result;

  v3 = (_QWORD *)operator new();
  *v3 = &off_1EA106258;
  v4 = operator new(0x20uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_1EA1061A8;
  v3[2] = v4;
  v4[3] = 0;
  v3[1] = v4 + 3;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1EA106280;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v3;
  result.n128_u64[0] = (unint64_t)v3;
  result.n128_u64[1] = (unint64_t)v5;
  *a1 = result;
  return result;
}

void std::__shared_ptr_pointer<AddressBookTrieLoaderStub *,std::shared_ptr<AddressBookTrieLoaderStub>::__shared_ptr_default_delete<AddressBookTrieLoaderStub,AddressBookTrieLoaderStub>,std::allocator<AddressBookTrieLoaderStub>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_pointer<AddressBookTrieLoaderStub *,std::shared_ptr<AddressBookTrieLoaderStub>::__shared_ptr_default_delete<AddressBookTrieLoaderStub,AddressBookTrieLoaderStub>,std::allocator<AddressBookTrieLoaderStub>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100](v1 + 8);
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

void AddressBookTrieLoaderStub::~AddressBookTrieLoaderStub(AddressBookTrieLoaderStub *this)
{
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

{
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  JUMPOUT(0x1DF0A2144);
}

uint64_t AddressBookTrieLoaderStub::handle@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(this + 16);
  *a2 = *(_QWORD *)(this + 8);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return this;
}

__n128 KB::AddressBookTrieLoader::create@<Q0>(const KB::String *a1@<X0>, const KB::String *a2@<X1>, const KB::String *a3@<X2>, __n128 *a4@<X8>)
{
  AddressBookTrieLoaderImpl *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  std::__shared_weak_count *v11;
  unint64_t v12;
  unint64_t *p_shared_weak_owners;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  __n128 result;
  _BYTE v20[8];
  void *v21;
  _BYTE v22[8];
  void *v23;
  _BYTE v24[8];
  void *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v8 = (AddressBookTrieLoaderImpl *)operator new();
  AddressBookTrieLoaderImpl::AddressBookTrieLoaderImpl(v8);
  v9 = (std::__shared_weak_count *)operator new();
  v9->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1062B8;
  v9->__shared_weak_owners_ = 0;
  v9[1].__vftable = (std::__shared_weak_count_vtbl *)v8;
  v11 = (std::__shared_weak_count *)*((_QWORD *)v8 + 2);
  if (v11)
  {
    if (v11->__shared_owners_ != -1)
      goto LABEL_14;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v14 = __ldxr(p_shared_weak_owners);
    while (__stxr(v14 + 1, p_shared_weak_owners));
    *((_QWORD *)v8 + 1) = v8;
    *((_QWORD *)v8 + 2) = v9;
    std::__shared_weak_count::__release_weak(v11);
  }
  else
  {
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    v16 = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    *((_QWORD *)v8 + 1) = v8;
    *((_QWORD *)v8 + 2) = v9;
  }
  do
    v18 = __ldaxr(p_shared_owners);
  while (__stlxr(v18 - 1, p_shared_owners));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_14:
  KB::String::String((KB::String *)v24, a1);
  KB::String::String((KB::String *)v22, a2);
  KB::String::String((KB::String *)v20, a3);
  AddressBookTrieLoaderImpl::register_as_contact_observer(v8, (const KB::String *)v24, (const KB::String *)v22, (const KB::String *)v20);
  if (v21 && v20[6] == 1)
    free(v21);
  if (v23 && v22[6] == 1)
    free(v23);
  if (v25 && v24[6] == 1)
    free(v25);
  result.n128_u64[0] = (unint64_t)v8;
  result.n128_u64[1] = (unint64_t)v9;
  *a4 = result;
  return result;
}

void std::__shared_ptr_pointer<AddressBookTrieLoaderImpl *,std::shared_ptr<AddressBookTrieLoaderImpl>::__shared_ptr_default_delete<AddressBookTrieLoaderImpl,AddressBookTrieLoaderImpl>,std::allocator<AddressBookTrieLoaderImpl>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

AddressBookTrieLoaderImpl *std::__shared_ptr_pointer<AddressBookTrieLoaderImpl *,std::shared_ptr<AddressBookTrieLoaderImpl>::__shared_ptr_default_delete<AddressBookTrieLoaderImpl,AddressBookTrieLoaderImpl>,std::allocator<AddressBookTrieLoaderImpl>>::__on_zero_shared(uint64_t a1)
{
  AddressBookTrieLoaderImpl *result;

  result = *(AddressBookTrieLoaderImpl **)(a1 + 24);
  if (result)
  {
    AddressBookTrieLoaderImpl::~AddressBookTrieLoaderImpl(result);
    JUMPOUT(0x1DF0A2144);
  }
  return result;
}

void TIFitAffineHand::~TIFitAffineHand(TIFitAffineHand *this)
{
  TIFitAffineHand::~TIFitAffineHand(this);
  JUMPOUT(0x1DF0A2144);
}

{
  uint64_t v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = &off_1EA1062F0;
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)(v2 + 24));
    MEMORY[0x1DF0A2144](v2, 0x1020C40FAF5D19FLL);
  }
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
  {
    *((_QWORD *)this + 5) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 1);
  if (v4)
  {
    *((_QWORD *)this + 2) = v4;
    operator delete(v4);
  }
}

void TIFitAffineHand::TIFitAffineHand(TIFitAffineHand *this)
{
  *(_QWORD *)this = &off_1EA1062F0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_QWORD *)this + 9) = 0x7FF0000000000000;
  *((_QWORD *)this + 10) = 0;
}

{
  *(_QWORD *)this = &off_1EA1062F0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_QWORD *)this + 9) = 0x7FF0000000000000;
  *((_QWORD *)this + 10) = 0;
}

void TIFitAffineHand::TIFitAffineHand(TIFitAffineHand *this, const TIFitAffineHand *a2)
{
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_1EA1062F0;
  std::vector<CGRect>::vector((_QWORD *)this + 1, (uint64_t)a2 + 8);
  std::vector<CGRect>::vector((_QWORD *)this + 4, (uint64_t)a2 + 32);
  *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
  *((_QWORD *)this + 9) = *((_QWORD *)a2 + 9);
  *((_QWORD *)this + 10) = 0;
  if (*((_QWORD *)a2 + 10))
  {
    v4 = operator new();
    v5 = *((_QWORD *)a2 + 10);
    *(_OWORD *)v4 = *(_OWORD *)v5;
    *(_QWORD *)(v4 + 24) = 0;
    *(_QWORD *)(v4 + 32) = 0;
    *(_QWORD *)(v4 + 16) = v4 + 24;
    std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)(v4 + 16), *(_QWORD **)(v5 + 16), (_QWORD *)(v5 + 24));
    *((_QWORD *)this + 10) = v4;
  }
}

_QWORD *std::vector<CGRect>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<CGRect>::__vallocate[abi:nn180100](a1, v5 >> 5);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<CGRect>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;

  if (a2 >> 59)
    abort();
  result = (char *)operator new(32 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * a2];
  return result;
}

void TIFitAffineHand::resetKeyRects(TIFitAffineHand *this, uint64_t a2)
{
  char *v4;
  uint64_t v5;

  v4 = (char *)this + 8;
  if (v4 != (char *)a2)
    std::vector<CGRect>::__assign_with_size[abi:nn180100]<CGRect*,CGRect*>(v4, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 5);
  if ((TIFitAffineHand *)((char *)this + 32) != (TIFitAffineHand *)a2)
    std::vector<CGRect>::__assign_with_size[abi:nn180100]<CGRect*,CGRect*>((char *)this + 32, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 5);
  v5 = *((_QWORD *)this + 10);
  if (v5)
  {
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)(v5 + 24));
    MEMORY[0x1DF0A2144](v5, 0x1020C40FAF5D19FLL);
  }
  *((_QWORD *)this + 10) = 0;
  TIFitAffineHand::updateMean(this);
}

char *std::vector<CGRect>::__assign_with_size[abi:nn180100]<CGRect*,CGRect*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 5)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 59)
      abort();
    v10 = v8 >> 4;
    if (v8 >> 4 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0)
      v11 = 0x7FFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<CGRect>::__vallocate[abi:nn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 5;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[32 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

void TIFitAffineHand::updateMean(TIFitAffineHand *this)
{
  CGRect *v1;
  CGRect *v2;
  double MidX;
  CGFloat MidY;
  double v6;
  double v7;
  double v8;
  uint64_t v9;
  double v10;

  *(_OWORD *)((char *)this + 56) = *MEMORY[0x1E0C9D538];
  *((_QWORD *)this + 9) = 0;
  v2 = (CGRect *)*((_QWORD *)this + 4);
  v1 = (CGRect *)*((_QWORD *)this + 5);
  if (v1 != v2)
  {
    do
    {
      MidX = CGRectGetMidX(*v2);
      MidY = CGRectGetMidY(*v2);
      v6 = MidX + *((double *)this + 7);
      v7 = MidY + *((double *)this + 8);
      *((double *)this + 7) = v6;
      *((double *)this + 8) = v7;
      v8 = *((double *)this + 9) + v2->size.width + v2->size.height;
      *((double *)this + 9) = v8;
      ++v2;
    }
    while (v2 != v1);
    v9 = *((_QWORD *)this + 5) - *((_QWORD *)this + 4);
    v10 = (double)(unint64_t)(v9 >> 5);
    *((double *)this + 7) = v6 / v10;
    *((double *)this + 8) = v7 / v10;
    *((double *)this + 9) = v8 / (double)(unint64_t)(v9 >> 4);
  }
}

BOOL TIFitAffineHand::findClosestKeyRectForPoint(TIFitAffineHand *this, CGPoint a2, CGRect *a3)
{
  CGRect *v3;
  CGRect *v4;
  double y;
  double x;
  int v8;
  double v9;
  char v10;
  double MidX;
  CGFloat MidY;
  double v13;
  CGPoint origin;
  CGSize size;
  CGPoint v17;
  CGSize v18;

  v4 = (CGRect *)*((_QWORD *)this + 4);
  v3 = (CGRect *)*((_QWORD *)this + 5);
  if (v3 == v4)
  {
LABEL_9:
    v8 = 0;
  }
  else
  {
    y = a2.y;
    x = a2.x;
    v8 = 0;
    v9 = *((double *)this + 9) * *((double *)this + 9);
    v17 = (CGPoint)*MEMORY[0x1E0C9D648];
    v18 = *(CGSize *)(MEMORY[0x1E0C9D648] + 16);
    v10 = 1;
    do
    {
      while (1)
      {
        MidX = CGRectGetMidX(*v4);
        MidY = CGRectGetMidY(*v4);
        v13 = (MidY - y) * (MidY - y) + (MidX - x) * (MidX - x);
        if (v13 >= v9)
          break;
        v10 = 0;
        origin = v4->origin;
        size = v4->size;
        ++v4;
        v17 = origin;
        v18 = size;
        v8 = 1;
        v9 = v13;
        if (v4 == v3)
          goto LABEL_10;
      }
      ++v4;
    }
    while (v4 != v3);
    if ((v10 & 1) != 0)
      goto LABEL_9;
LABEL_10:
    a3->origin = v17;
    a3->size = v18;
  }
  return v8 != 0;
}

double TIFitAffineHand::keyRectForIndex(TIFitAffineHand *this, uint64_t a2)
{
  return *(double *)(*((_QWORD *)this + 4) + 32 * a2);
}

void TIFitAffineHand::updateFromMatrix(TIFitAffineHand *this, const TIFitAffineMLLMatrix *a2, double a3)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17[5];
  _QWORD v18[3];
  _QWORD *v19[2];

  v6 = (uint64_t *)*((_QWORD *)this + 1);
  v5 = *((_QWORD *)this + 2);
  v19[0] = 0;
  v19[1] = 0;
  v7 = v5 - (_QWORD)v6;
  v8 = v7 >> 5;
  v18[0] = v7 >> 5;
  v18[1] = 3;
  v18[2] = v19;
  if (v7)
  {
    v10 = 0;
    do
    {
      v11 = *v6;
      *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v18, 0, v10) = v11;
      v12 = v6[1];
      *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v18, 1uLL, v10) = v12;
      *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v18, 2uLL, v10++) = a3;
      v6 += 4;
    }
    while (v8 != v10);
  }
  TIFitAffineMLLMatrix::operator*(a2, (TIFitAffineMLLMatrix *)v18, (TIFitAffineMLLMatrix *)v17);
  v13 = *((_QWORD *)this + 2) - *((_QWORD *)this + 1);
  if (v13)
  {
    v14 = 0;
    v15 = v13 >> 5;
    v16 = (_QWORD *)*((_QWORD *)this + 4);
    do
    {
      *v16 = *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v17, 0, v14);
      v16[1] = *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v17, 1uLL, v14++);
      v16 += 4;
    }
    while (v15 != v14);
  }
  TIFitAffineHand::updateMean(this);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v17[3]);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v19[0]);
}

void TIFitAffineHand::setCovar(TIFitAffineHand *this, const TIFitAffineMLLMatrix *a2)
{
  uint64_t v4;
  uint64_t v5;
  _BYTE v6[24];
  _QWORD *v7;

  v4 = *((_QWORD *)this + 10);
  if (v4)
  {
    TIFitAffineMLLMatrix::operator=(v4, (uint64_t)a2, (uint64_t)v6);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v7);
  }
  else
  {
    v5 = operator new();
    *(_OWORD *)v5 = *(_OWORD *)a2;
    *(_QWORD *)(v5 + 24) = 0;
    *(_QWORD *)(v5 + 32) = 0;
    *(_QWORD *)(v5 + 16) = v5 + 24;
    std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)(v5 + 16), *((_QWORD **)a2 + 2), (_QWORD *)a2 + 3);
    *((_QWORD *)this + 10) = v5;
  }
}

BOOL TIFitAffineHand::containsKeyRect(TIFitAffineHand *this, const CGRect *a2)
{
  CGRect *v2;
  CGRect *v3;
  CGRect *v6;

  v2 = (CGRect *)*((_QWORD *)this + 4);
  v3 = (CGRect *)*((_QWORD *)this + 5);
  if (v2 == v3)
  {
    v6 = (CGRect *)*((_QWORD *)this + 4);
  }
  else
  {
    while (!CGRectEqualToRect(*v2, *a2))
    {
      if (++v2 == v3)
      {
        v2 = v3;
        break;
      }
    }
    v6 = v2;
    v2 = (CGRect *)*((_QWORD *)this + 5);
  }
  return v6 != v2;
}

uint64_t UnicodeCharset::nextInput(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4)
{
  uint64_t result;
  unsigned __int16 *v8;
  int v9;
  int __key;
  unsigned __int16 v11;

  v11 = 0;
  result = (*(uint64_t (**)(uint64_t, unsigned __int16 *))(*(_QWORD *)a2 + 40))(a2, &v11);
  if ((_DWORD)result)
  {
    *a4 = 2;
    __key = v11;
    v8 = (unsigned __int16 *)bsearch(&__key, (const void *)(a1 + 8), 0xD5uLL, 4uLL, (int (__cdecl *)(const void *, const void *))wideCharCompare);
    if (v8)
      v9 = v8[1] | 0x10000;
    else
      v9 = v11;
    *a3 = v9;
    return 1;
  }
  else
  {
    *a4 = 0;
  }
  return result;
}

uint64_t UnicodeCharset::putChar(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4)
{
  *a4 = 2;
  if (a3 >= 0x10000)
    LOWORD(a3) = *(_WORD *)(*(_QWORD *)(a1 + 864) + 2 * (a3 - 0x10000));
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, (unsigned __int16)a3);
}

uint64_t UnicodeCharset::elementSize(UnicodeCharset *this)
{
  return 2;
}

void UnicodeCharset::~UnicodeCharset(UnicodeCharset *this)
{
  JUMPOUT(0x1DF0A2144);
}

uint64_t wideCharCompare(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  v2 = *a1;
  v3 = *a2;
  v4 = v2 == v3;
  if (v2 > v3)
    v5 = 1;
  else
    v5 = -1;
  if (v4)
    return 0;
  else
    return v5;
}

uint64_t UnicodeCompCharset::nextInput(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result;
  _DWORD *v9;
  _DWORD *v10;
  unsigned __int16 v11;
  int __key;

  v11 = 0;
  result = (*(uint64_t (**)(uint64_t, unsigned __int16 *))(*(_QWORD *)a2 + 40))(a2, &v11);
  if ((_DWORD)result)
  {
    __key = v11;
    *a4 = 2;
    v9 = bsearch(&__key, (const void *)(a1 + 8), *(int *)(a1 + 3424), 8uLL, (int (__cdecl *)(const void *, const void *))uniCompInfoCompare);
    if (v9)
    {
      *a3 = v9[1] + 0x10000;
      if ((*(unsigned int (**)(uint64_t, unsigned __int16 *))(*(_QWORD *)a2 + 48))(a2, &v11) && v11)
      {
        __key += v11 << 16;
        v10 = bsearch(&__key, (const void *)(a1 + 8), *(int *)(a1 + 3424), 8uLL, (int (__cdecl *)(const void *, const void *))uniCompInfoCompare);
        if (v10)
        {
          *a3 = v10[1] + 0x10000;
          *a4 += 2;
          (*(void (**)(uint64_t, unsigned __int16 *))(*(_QWORD *)a2 + 40))(a2, &v11);
        }
      }
    }
    else
    {
      *a3 = __key;
    }
    return 1;
  }
  else
  {
    *a4 = 0;
  }
  return result;
}

uint64_t UnicodeCompCharset::putChar(uint64_t a1, uint64_t a2, unsigned int a3, int *a4)
{
  int v6;
  unsigned int v7;
  uint64_t result;

  v6 = 2;
  if (a3 >= 0x10000)
  {
    v7 = *(_DWORD *)(*(_QWORD *)(a1 + 3416) + 4 * (a3 - 0x10000));
    *a4 = 2;
    result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, (unsigned __int16)v7);
    if (v7 < 0x10000)
      return result;
    a3 = HIWORD(v7);
    v6 = *a4 + 2;
  }
  *a4 = v6;
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, (unsigned __int16)a3);
}

uint64_t UnicodeCompCharset::elementSize(UnicodeCompCharset *this)
{
  return 2;
}

void UnicodeCompCharset::~UnicodeCompCharset(UnicodeCompCharset *this)
{
  JUMPOUT(0x1DF0A2144);
}

uint64_t uniCompInfoCompare(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2;

  if (*a1 > *a2)
    v2 = 1;
  else
    v2 = -1;
  if (*a1 == *a2)
    return 0;
  else
    return v2;
}

uint64_t VnCharset::elementSize(VnCharset *this)
{
  return 1;
}

BOOL VnInternalCharset::nextInput(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  _BOOL8 result;

  result = (*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 56))(a2, a3) != 0;
  *a4 = 4 * result;
  return result;
}

uint64_t VnInternalCharset::putChar(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v5;

  v5 = HIWORD(a3);
  *a4 = 4;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, (unsigned __int16)a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 24))(a2, v5);
}

uint64_t VnInternalCharset::elementSize(VnInternalCharset *this)
{
  return 4;
}

void VnInternalCharset::~VnInternalCharset(VnInternalCharset *this)
{
  JUMPOUT(0x1DF0A2144);
}

uint64_t UnicodeUTF8Charset::nextInput(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4)
{
  uint64_t result;
  unsigned __int16 v9;
  int v10;
  unsigned __int16 *v11;
  int __key;
  char v13;
  __int16 v14;

  v14 = 0;
  v13 = 0;
  *a4 = 0;
  result = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)a2 + 16))(a2, (char *)&v14 + 1);
  if ((_DWORD)result)
  {
    *a4 = 1;
    v9 = HIBYTE(v14);
    if ((v14 & 0x8000u) == 0)
    {
LABEL_3:
      v10 = v9;
      __key = v9;
      v11 = (unsigned __int16 *)bsearch(&__key, (const void *)(a1 + 8), 0xD5uLL, 4uLL, (int (__cdecl *)(const void *, const void *))wideCharCompare);
      if (v11)
        v10 = v11[1] | 0x10000;
      *a3 = v10;
      return 1;
    }
    if ((HIBYTE(v14) & 0xE0) == 0xC0)
    {
      result = (*(uint64_t (**)(uint64_t, __int16 *))(*(_QWORD *)a2 + 24))(a2, &v14);
      if (!(_DWORD)result)
        return result;
      if ((v14 & 0xC0) == 0x80)
      {
        (*(void (**)(uint64_t, __int16 *))(*(_QWORD *)a2 + 16))(a2, &v14);
        *a4 = 2;
        v9 = v14 & 0x3F | ((HIBYTE(v14) & 0x1F) << 6);
        goto LABEL_3;
      }
    }
    else if ((HIBYTE(v14) & 0xF0) == 0xE0)
    {
      result = (*(uint64_t (**)(uint64_t, __int16 *))(*(_QWORD *)a2 + 24))(a2, &v14);
      if (!(_DWORD)result)
        return result;
      if ((v14 & 0xC0) == 0x80)
      {
        (*(void (**)(uint64_t, __int16 *))(*(_QWORD *)a2 + 16))(a2, &v14);
        *a4 = 2;
        result = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)a2 + 24))(a2, &v13);
        if (!(_DWORD)result)
          return result;
        if ((v13 & 0xC0) == 0x80)
        {
          (*(void (**)(uint64_t, char *))(*(_QWORD *)a2 + 16))(a2, &v13);
          *a4 = 3;
          v9 = (HIBYTE(v14) << 12) | ((v14 & 0x3F) << 6) | v13 & 0x3F;
          goto LABEL_3;
        }
      }
    }
    *a3 = -1;
    return 1;
  }
  return result;
}

uint64_t UnicodeUTF8Charset::putChar(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4)
{
  unsigned int v4;

  v4 = a3;
  if (HIWORD(a3))
    v4 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 864) + 2 * (a3 - 0x10000));
  if ((unsigned __int16)v4 > 0x7Fu)
  {
    if ((unsigned __int16)v4 > 0x7FFu)
    {
      *a4 = 3;
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, ((unsigned __int16)v4 >> 12) | 0xE0u);
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, (v4 >> 6) & 0x3F | 0x80);
    }
    else
    {
      *a4 = 2;
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, (v4 >> 6) | 0xC0u);
    }
    LOBYTE(v4) = v4 & 0x3F | 0x80;
  }
  else
  {
    *a4 = 1;
  }
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, v4);
}

void UnicodeUTF8Charset::~UnicodeUTF8Charset(UnicodeUTF8Charset *this)
{
  JUMPOUT(0x1DF0A2144);
}

uint64_t UnicodeRefCharset::nextInput(uint64_t a1, uint64_t *a2, int *a3, _DWORD *a4)
{
  uint64_t result;
  unsigned __int16 v9;
  int v10;
  unsigned __int16 v11;
  uint64_t v12;
  unsigned int v13;
  unsigned __int16 v14;
  uint64_t v15;
  unsigned int v16;
  __int16 v17;
  __int16 v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  unsigned __int16 *v22;
  int __key;
  unsigned __int8 v24;

  v24 = 0;
  *a4 = 0;
  result = (*(uint64_t (**)(uint64_t *, unsigned __int8 *))(*a2 + 16))(a2, &v24);
  if (!(_DWORD)result)
    return result;
  *a4 = 1;
  v9 = v24;
  if (v24 != 38)
  {
LABEL_31:
    v11 = v9;
    goto LABEL_32;
  }
  v10 = (*(uint64_t (**)(uint64_t *, unsigned __int8 *))(*a2 + 24))(a2, &v24);
  v11 = 38;
  if (v10 && v24 == 35)
  {
    (*(void (**)(uint64_t *, unsigned __int8 *))(*a2 + 16))(a2, &v24);
    ++*a4;
    if ((*(unsigned int (**)(uint64_t *))(*a2 + 80))(a2))
    {
      v11 = 38;
      goto LABEL_32;
    }
    (*(void (**)(uint64_t *, unsigned __int8 *))(*a2 + 24))(a2, &v24);
    v12 = *a2;
    if ((v24 & 0xDF) == 0x58)
    {
      (*(void (**)(uint64_t *, unsigned __int8 *))(v12 + 16))(a2, &v24);
      ++*a4;
      if ((*(unsigned int (**)(uint64_t *, unsigned __int8 *))(*a2 + 24))(a2, &v24))
      {
        v13 = 0;
        v14 = 0;
        v15 = MEMORY[0x1E0C80978];
        do
        {
          if ((*(_DWORD *)(v15 + 4 * v24 + 60) & 0x10000) == 0 || v13 > 3)
            break;
          (*(void (**)(uint64_t *, unsigned __int8 *))(*a2 + 16))(a2, &v24);
          ++*a4;
          v16 = v24 - 48;
          if (v16 >= 0xA)
            LOWORD(v16) = 0;
          if (v24 - 65 <= 5)
            v17 = v24 - 55;
          else
            v17 = v16;
          v18 = v24 - 87;
          if (v24 - 97 > 5)
            v18 = v17;
          v14 = v18 | (16 * v14);
          ++v13;
        }
        while ((*(unsigned int (**)(uint64_t *, unsigned __int8 *))(*a2 + 24))(a2, &v24));
LABEL_28:
        if ((*(unsigned int (**)(uint64_t *, unsigned __int8 *))(*a2 + 24))(a2, &v24))
        {
          v11 = v9;
          if (v24 == 59)
          {
            (*(void (**)(uint64_t *, unsigned __int8 *))(*a2 + 16))(a2, &v24);
            ++*a4;
            v11 = v14;
          }
          goto LABEL_32;
        }
        goto LABEL_31;
      }
    }
    else if ((*(unsigned int (**)(uint64_t *, unsigned __int8 *))(v12 + 24))(a2, &v24))
    {
      v19 = 0;
      v14 = 0;
      v20 = MEMORY[0x1E0C80978];
      do
      {
        if ((*(_DWORD *)(v20 + 4 * v24 + 60) & 0x400) == 0)
          break;
        if (v19 > 4)
          break;
        (*(void (**)(uint64_t *, unsigned __int8 *))(*a2 + 16))(a2, &v24);
        ++*a4;
        v14 = v24 + 10 * v14 - 48;
        ++v19;
      }
      while ((*(unsigned int (**)(uint64_t *, unsigned __int8 *))(*a2 + 24))(a2, &v24));
      goto LABEL_28;
    }
    v14 = 0;
    goto LABEL_28;
  }
LABEL_32:
  v21 = v11;
  __key = v11;
  v22 = (unsigned __int16 *)bsearch(&__key, (const void *)(a1 + 8), 0xD5uLL, 4uLL, (int (__cdecl *)(const void *, const void *))wideCharCompare);
  if (v22)
    v21 = v22[1] | 0x10000;
  *a3 = v21;
  return 1;
}

uint64_t UnicodeRefCharset::putChar(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4)
{
  unsigned __int16 v5;
  uint64_t result;
  int v8;
  int v9;
  int v10;
  int v11;

  v5 = a3;
  if (HIWORD(a3))
    v5 = *(_WORD *)(*(_QWORD *)(a1 + 864) + 2 * (a3 - 0x10000));
  if (v5 > 0x7Fu)
  {
    *a4 = 2;
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, 38);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, 35);
    v8 = 0;
    v9 = 10000;
    v10 = 5;
    do
    {
      v11 = v5 / v9;
      v8 |= v11;
      if (v8)
      {
        ++*a4;
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, (v11 + 48));
        v8 = 1;
      }
      v5 %= v9;
      v9 /= 10;
      --v10;
    }
    while (v10);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, 59);
    ++*a4;
  }
  else
  {
    *a4 = 1;
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, v5);
  }
  return result;
}

void UnicodeRefCharset::~UnicodeRefCharset(UnicodeRefCharset *this)
{
  JUMPOUT(0x1DF0A2144);
}

uint64_t UnicodeHexCharset::putChar(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4)
{
  unsigned int v6;
  uint64_t result;
  int v8;
  int i;
  unsigned int v10;
  uint64_t v11;

  if (HIWORD(a3))
    LOWORD(a3) = *(_WORD *)(*(_QWORD *)(a1 + 864) + 2 * (a3 - 0x10000));
  v6 = (unsigned __int16)a3;
  if ((unsigned __int16)a3 > 0xFFu)
  {
    *a4 = 3;
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, 38);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, 35);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, 120);
    v8 = 0;
    for (i = 12; i != -4; i -= 4)
    {
      v10 = (v6 >> i) & 0xF;
      v8 |= v10;
      if (v8)
      {
        ++*a4;
        if (v10 >= 0xA)
          v11 = v10 + 55;
        else
          v11 = v10 | 0x30;
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v11);
        v8 = 1;
      }
    }
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, 59);
    ++*a4;
  }
  else
  {
    *a4 = 1;
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, a3);
  }
  return result;
}

void UnicodeHexCharset::~UnicodeHexCharset(UnicodeHexCharset *this)
{
  JUMPOUT(0x1DF0A2144);
}

uint64_t UnicodeCStringCharset::startInput(uint64_t this)
{
  *(_DWORD *)(this + 872) = 0;
  return this;
}

uint64_t UnicodeCStringCharset::nextInput(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4)
{
  uint64_t result;
  unsigned __int16 v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  __int16 v13;
  __int16 v14;
  int v15;
  unsigned __int16 *v16;
  int __key;
  unsigned __int8 v18;

  v18 = 0;
  *a4 = 0;
  result = (*(uint64_t (**)(uint64_t, unsigned __int8 *))(*(_QWORD *)a2 + 16))(a2, &v18);
  if ((_DWORD)result)
  {
    *a4 = 1;
    v9 = v18;
    if (v18 == 92)
    {
      if ((*(unsigned int (**)(uint64_t, unsigned __int8 *))(*(_QWORD *)a2 + 24))(a2, &v18)
        && (v18 & 0xDF) == 0x58)
      {
        (*(void (**)(uint64_t, unsigned __int8 *))(*(_QWORD *)a2 + 16))(a2, &v18);
        ++*a4;
        if ((*(unsigned int (**)(uint64_t, unsigned __int8 *))(*(_QWORD *)a2 + 24))(a2, &v18))
        {
          v10 = 0;
          v9 = 0;
          v11 = MEMORY[0x1E0C80978];
          do
          {
            if ((*(_DWORD *)(v11 + 4 * v18 + 60) & 0x10000) == 0 || v10 > 3)
              break;
            (*(void (**)(uint64_t, unsigned __int8 *))(*(_QWORD *)a2 + 16))(a2, &v18);
            ++*a4;
            v12 = v18 - 48;
            if (v12 >= 0xA)
              LOWORD(v12) = 0;
            if (v18 - 65 <= 5)
              v13 = v18 - 55;
            else
              v13 = v12;
            v14 = v18 - 87;
            if (v18 - 97 > 5)
              v14 = v13;
            v9 = v14 | (16 * v9);
            ++v10;
          }
          while ((*(unsigned int (**)(uint64_t, unsigned __int8 *))(*(_QWORD *)a2 + 24))(a2, &v18));
        }
        else
        {
          v9 = 0;
        }
      }
      else
      {
        v9 = 92;
      }
    }
    v15 = v9;
    __key = v9;
    v16 = (unsigned __int16 *)bsearch(&__key, (const void *)(a1 + 8), 0xD5uLL, 4uLL, (int (__cdecl *)(const void *, const void *))wideCharCompare);
    if (v16)
      v15 = v16[1] | 0x10000;
    *a3 = v15;
    return 1;
  }
  return result;
}

uint64_t UnicodeCStringCharset::putChar(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4)
{
  unsigned int v7;
  BOOL v8;
  int v9;
  int i;
  unsigned int v11;
  uint64_t v12;
  uint64_t result;

  if (HIWORD(a3))
    LOWORD(a3) = *(_WORD *)(*(_QWORD *)(a1 + 864) + 2 * (a3 - 0x10000));
  v7 = (unsigned __int16)a3;
  if ((unsigned __int16)a3 <= 0x7Fu
    && ((a3 & 0xFFDF) != 0x58
      ? (v8 = (*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (unsigned __int16)a3 + 60) & 0x10000) == 0)
      : (v8 = 0),
        v8))
  {
    *a4 = 1;
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, a3);
  }
  else
  {
    *a4 = 2;
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, 92);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, 120);
    v9 = 0;
    for (i = 12; i != -4; i -= 4)
    {
      v11 = (v7 >> i) & 0xF;
      v9 |= v11;
      if (v9)
      {
        ++*a4;
        if (v11 >= 0xA)
          v12 = v11 + 55;
        else
          v12 = v11 | 0x30;
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v12);
        v9 = 1;
      }
    }
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
    *(_DWORD *)(a1 + 872) = 1;
  }
  return result;
}

void UnicodeCStringCharset::~UnicodeCStringCharset(UnicodeCStringCharset *this)
{
  JUMPOUT(0x1DF0A2144);
}

double _createGlobalVnCharsetIfNeeded(void)
{
  uint64_t v0;
  double result;

  if (!VnCharsetLibObj)
  {
    v0 = operator new();
    *(_DWORD *)(v0 + 64) = 0;
    *(_QWORD *)(v0 + 56) = 0;
    *(_DWORD *)(v0 + 80) = 0;
    *(_QWORD *)(v0 + 72) = 0;
    unk_1F028492C = 0u;
    unk_1F028493C = 0u;
    *(_OWORD *)&algn_1F028494C[16] = 0u;
    unk_1F028496C = 0u;
    xmmword_1F0284978 = 0u;
    *(_OWORD *)algn_1F028494C = 0u;
    LoVowel = 1;
    dword_1F0284938 = 1;
    dword_1F0284948 = 1;
    dword_1F0284960 = 1;
    LODWORD(xmmword_1F0284978) = 1;
    dword_1F0284988 = 1;
    *(_OWORD *)algn_1F0284994 = 0u;
    *(_OWORD *)algn_1F02849A4 = 0u;
    unk_1F02849B4 = 0u;
    unk_1F02849C4 = 0u;
    *(_OWORD *)&algn_1F02849CC[8] = 0u;
    xmmword_1F02849E0 = 0u;
    HiVowel = 1;
    dword_1F02849A0 = 1;
    dword_1F02849B0 = 1;
    dword_1F02849C8 = 1;
    LODWORD(xmmword_1F02849E0) = 1;
    dword_1F02849F0 = 1;
    *(_QWORD *)(v0 + 32) = 0;
    *(_OWORD *)v0 = 0u;
    *(_OWORD *)(v0 + 16) = 0u;
    *(_OWORD *)(v0 + 88) = xmmword_1DA9111D0;
    *(_QWORD *)&result = 0x100000000;
    *(_QWORD *)(v0 + 104) = 0x100000000;
    VnCharsetLibObj = v0;
  }
  return result;
}

void CVnCharsetLib::CVnCharsetLib(CVnCharsetLib *this)
{
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_QWORD *)this + 9) = 0;
  unk_1F028492C = 0u;
  unk_1F028493C = 0u;
  *(_OWORD *)&algn_1F028494C[16] = 0u;
  unk_1F028496C = 0u;
  xmmword_1F0284978 = 0u;
  *(_OWORD *)algn_1F028494C = 0u;
  LoVowel = 1;
  dword_1F0284938 = 1;
  dword_1F0284948 = 1;
  dword_1F0284960 = 1;
  LODWORD(xmmword_1F0284978) = 1;
  dword_1F0284988 = 1;
  *(_OWORD *)algn_1F0284994 = 0u;
  *(_OWORD *)algn_1F02849A4 = 0u;
  unk_1F02849B4 = 0u;
  xmmword_1F02849E0 = 0u;
  *(_OWORD *)&algn_1F02849CC[8] = 0u;
  unk_1F02849C4 = 0u;
  HiVowel = 1;
  dword_1F02849A0 = 1;
  dword_1F02849B0 = 1;
  dword_1F02849C8 = 1;
  LODWORD(xmmword_1F02849E0) = 1;
  dword_1F02849F0 = 1;
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)((char *)this + 88) = xmmword_1DA9111D0;
  *((_QWORD *)this + 13) = 0x100000000;
}

{
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_QWORD *)this + 9) = 0;
  unk_1F028492C = 0u;
  unk_1F028493C = 0u;
  *(_OWORD *)&algn_1F028494C[16] = 0u;
  unk_1F028496C = 0u;
  xmmword_1F0284978 = 0u;
  *(_OWORD *)algn_1F028494C = 0u;
  LoVowel = 1;
  dword_1F0284938 = 1;
  dword_1F0284948 = 1;
  dword_1F0284960 = 1;
  LODWORD(xmmword_1F0284978) = 1;
  dword_1F0284988 = 1;
  *(_OWORD *)algn_1F0284994 = 0u;
  *(_OWORD *)algn_1F02849A4 = 0u;
  unk_1F02849B4 = 0u;
  xmmword_1F02849E0 = 0u;
  *(_OWORD *)&algn_1F02849CC[8] = 0u;
  unk_1F02849C4 = 0u;
  HiVowel = 1;
  dword_1F02849A0 = 1;
  dword_1F02849B0 = 1;
  dword_1F02849C8 = 1;
  LODWORD(xmmword_1F02849E0) = 1;
  dword_1F02849F0 = 1;
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)((char *)this + 88) = xmmword_1DA9111D0;
  *((_QWORD *)this + 13) = 0x100000000;
}

void UnicodeCharset::UnicodeCharset(UnicodeCharset *this, const unsigned __int16 *a2)
{
  int v2;
  uint64_t v3;

  v2 = 0;
  v3 = 0;
  *(_QWORD *)this = off_1EA106310;
  *((_QWORD *)this + 108) = a2;
  do
  {
    *((_DWORD *)this + v3 + 2) = v2 + a2[v3];
    ++v3;
    v2 += 0x10000;
  }
  while (v3 != 213);
  qsort((char *)this + 8, 0xD5uLL, 4uLL, (int (__cdecl *)(const void *, const void *))wideCharCompare);
}

void UnicodeCompCharset::UnicodeCompCharset(UnicodeCompCharset *this, const unsigned __int16 *a2, const unsigned int *a3)
{
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  int v6;
  int v7;
  char *v8;

  v3 = 0;
  *(_QWORD *)this = off_1EA106358;
  *((_QWORD *)this + 427) = a3;
  *((_DWORD *)this + 856) = 0;
  v4 = (_DWORD *)((char *)this + 12);
  do
  {
    *(v4 - 1) = a3[v3];
    *v4 = v3++;
    *((_DWORD *)this + 856) = v3;
    v4 += 2;
  }
  while (v3 != 213);
  v5 = 0;
  v6 = 213;
  do
  {
    v7 = a2[v5];
    if (a3[v5] != v7)
    {
      v8 = (char *)this + 8 * v6;
      *((_DWORD *)v8 + 2) = v7;
      *((_DWORD *)v8 + 3) = v5;
      LODWORD(v3) = v3 + 1;
      *((_DWORD *)this + 856) = v3;
      ++v6;
    }
    ++v5;
  }
  while (v5 != 213);
  qsort((char *)this + 8, (int)v3, 8uLL, (int (__cdecl *)(const void *, const void *))uniCompInfoCompare);
}

double VnConvResetOptions(uint64_t a1)
{
  double result;

  *(_OWORD *)a1 = xmmword_1DA9111D0;
  *(_QWORD *)&result = 0x100000000;
  *(_QWORD *)(a1 + 16) = 0x100000000;
  return result;
}

void CVnCharsetLib::~CVnCharsetLib(CVnCharsetLib *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD *)this;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v3 = *((_QWORD *)this + 2);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
  v4 = *((_QWORD *)this + 3);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
  v5 = *((_QWORD *)this + 4);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
  v6 = *((_QWORD *)this + 5);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
  v7 = *((_QWORD *)this + 6);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
  v8 = *((_QWORD *)this + 9);
  if (v8)
    MEMORY[0x1DF0A212C](v8, 0x1000C809243D869);
  v9 = *((_QWORD *)this + 7);
  if (v9)
    MEMORY[0x1DF0A212C](v9, 0x1000C809243D869);
}

void CVnCharsetLib::getVnCharset(CVnCharsetLib *this, int a2)
{
  UnicodeCharset *v4;
  _QWORD *v5;
  UnicodeCharset *v6;
  uint64_t v7;
  UnicodeCharset *v8;
  _QWORD *v9;
  UnicodeCharset *v10;
  _QWORD *v11;
  UnicodeCompCharset *v12;
  uint64_t v13;
  UnicodeCharset *v14;
  _QWORD *v15;
  _QWORD *v16;

  _createGlobalVnCharsetIfNeeded();
  switch(a2)
  {
    case 0:
      if (!*(_QWORD *)this)
      {
        v6 = (UnicodeCharset *)operator new();
        UnicodeCharset::UnicodeCharset(v6, UnicodeTable);
        *(_QWORD *)this = v7;
      }
      break;
    case 1:
    case 12:
      if (!*((_QWORD *)this + 2))
        goto LABEL_3;
      break;
    case 2:
      if (!*((_QWORD *)this + 3))
      {
        v8 = (UnicodeCharset *)operator new();
        UnicodeCharset::UnicodeCharset(v8, UnicodeTable);
        *v9 = off_1EA106478;
        *((_QWORD *)this + 3) = v9;
      }
      break;
    case 3:
      if (!*((_QWORD *)this + 4))
      {
        v10 = (UnicodeCharset *)operator new();
        UnicodeCharset::UnicodeCharset(v10, UnicodeTable);
        *v11 = off_1EA1064C0;
        *((_QWORD *)this + 4) = v11;
      }
      break;
    case 4:
      if (!*((_QWORD *)this + 1))
      {
        v12 = (UnicodeCompCharset *)operator new();
        UnicodeCompCharset::UnicodeCompCharset(v12, UnicodeTable, UnicodeComposite);
        *((_QWORD *)this + 1) = v13;
      }
      break;
    case 6:
      if (!*((_QWORD *)this + 5))
      {
        v14 = (UnicodeCharset *)operator new();
        UnicodeCharset::UnicodeCharset(v14, UnicodeTable);
        *v15 = off_1EA106508;
        *((_QWORD *)this + 5) = v15;
      }
      break;
    case 7:
      if (!*((_QWORD *)this + 6))
      {
        v16 = (_QWORD *)operator new();
        *v16 = off_1EA1063E8;
        *((_QWORD *)this + 6) = v16;
      }
      break;
    default:
LABEL_3:
      v4 = (UnicodeCharset *)operator new();
      UnicodeCharset::UnicodeCharset(v4, UnicodeTable);
      *v5 = off_1EA106430;
      *((_QWORD *)this + 2) = v5;
      break;
  }
}

__n128 VnConvSetOptions(__n128 *a1)
{
  uint64_t v1;
  unint64_t v2;
  __n128 result;

  v1 = VnCharsetLibObj;
  v2 = a1[1].n128_u64[0];
  result = *a1;
  *(__n128 *)(VnCharsetLibObj + 88) = *a1;
  *(_QWORD *)(v1 + 104) = v2;
  return result;
}

__n128 VnConvGetOptions(__n128 *a1)
{
  unint64_t v1;
  __n128 result;

  v1 = *(_QWORD *)(VnCharsetLibObj + 104);
  result = *(__n128 *)(VnCharsetLibObj + 88);
  *a1 = result;
  a1[1].n128_u64[0] = v1;
  return result;
}

uint64_t StdVnToUpper(int a1)
{
  return a1 & ~((a1 - 0x10000) < 0xBA);
}

uint64_t StdVnToLower(uint64_t result)
{
  if ((result & 1) != 0 || (result - 0x10000) >= 0xBA)
    return result;
  else
    return (result + 1);
}

uint64_t StdVnGetRoot(uint64_t result)
{
  if ((result - 0x10000) <= 0xD4)
    return (StdVnRootChar[(result - 0x10000)] + 0x10000);
  return result;
}

id createAutoshiftRegularExpression(NSString *a1, NSString *a2, NSString *a3)
{
  NSString *v5;
  NSString *v6;
  NSString *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  id v17;
  NSObject *v18;
  void *v20;
  id v21;
  uint8_t buf[4];
  void *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = a2;
  v7 = a1;
  character_set_pattern_from_string(CFSTR(" "));
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = (void *)MEMORY[0x1E0CB3940];
  character_set_pattern_from_string(v7);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  character_set_pattern_from_string(v6);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v9, "stringWithFormat:", CFSTR("\\A|\\n|(?:%@){3}|((?:\\b\\w++(?:\\.\\w++)*)?(?:%@))(?:%@)*(?:%@)"), v8, v10, v11, v8);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  v13 = (void *)MEMORY[0x1E0CB3940];
  character_set_pattern_from_string(v5);
  v14 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v13, "stringWithFormat:", CFSTR("(?:%@)(?:%@)*(?:%@)*\\Z"), v12, v8, v14);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  v21 = 0;
  v16 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB38E8]), "initWithPattern:options:error:", v15, 16, &v21);
  v17 = v21;
  if (!v16)
  {
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    TIOSLogFacility();
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s failed: %@"), "createAutoshiftRegularExpression", v17);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      v23 = v20;
      _os_log_debug_impl(&dword_1DA6F2000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);

    }
  }

  return v16;
}

id character_set_pattern_from_string(NSString *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v1 = (void *)MEMORY[0x1E0CB3940];
  objc_msgSend(MEMORY[0x1E0CB38E8], "escapedPatternForString:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "stringWithFormat:", CFSTR("[%@]"), v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v3, "stringByReplacingOccurrencesOfString:withString:", CFSTR("-"), CFSTR("\\-"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void TIFitAffineTransform::TIFitAffineTransform(TIFitAffineTransform *this, double a2)
{
  double v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  uint64_t v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  __int128 v16;
  uint64_t v17;
  TIFitAffineMLLMatrix *v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  double v22[3];
  _BYTE v23[24];
  __int128 v24;
  __int128 v25;
  _BYTE v26[32];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)this = xmmword_1DA9111E0;
  *((_OWORD *)this + 1) = xmmword_1DA9111F0;
  *((_OWORD *)this + 2) = xmmword_1DA911200;
  *((_OWORD *)this + 3) = xmmword_1DA911210;
  *((int64x2_t *)this + 4) = vdupq_n_s64(0x3FC999999999999AuLL);
  *((_OWORD *)this + 5) = xmmword_1DA911220;
  *((_QWORD *)this + 12) = 0x4054000000000000;
  v4 = log1p(2.71828182);
  *((double *)this + 13) = -v4;
  *((double *)this + 14) = 0.999999998 - v4;
  *((long double *)this + 15) = exp(0.999999998 - v4);
  *((long double *)this + 16) = exp(-v4);
  *((double *)this + 17) = -1.14472989 - v4 + -8.76405327;
  *((_QWORD *)this + 18) = 0x4080000000000000;
  v5 = operator new();
  *(_QWORD *)v5 = &off_1EA1062F0;
  *(_OWORD *)(v5 + 8) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_OWORD *)(v5 + 40) = 0u;
  *(_OWORD *)(v5 + 56) = 0u;
  *(_QWORD *)(v5 + 72) = 0x7FF0000000000000;
  *(_QWORD *)(v5 + 80) = 0;
  v6 = (std::__shared_weak_count *)operator new();
  v6->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA106550;
  v6->__shared_weak_owners_ = 0;
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)v5;
  v8 = operator new();
  *(_QWORD *)v8 = &off_1EA1062F0;
  *(_OWORD *)(v8 + 8) = 0u;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_QWORD *)(v8 + 72) = 0x7FF0000000000000;
  *(_QWORD *)(v8 + 80) = 0;
  v9 = (std::__shared_weak_count *)operator new();
  v10 = v9;
  v9->__shared_owners_ = 0;
  v11 = (unint64_t *)&v9->__shared_owners_;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA106550;
  v9->__shared_weak_owners_ = 0;
  v9[1].__vftable = (std::__shared_weak_count_vtbl *)v8;
  *((_QWORD *)this + 19) = v5;
  *((_QWORD *)this + 20) = v6;
  do
    v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  *((_QWORD *)this + 21) = v8;
  *((_QWORD *)this + 22) = v9;
  do
    v13 = __ldxr(v11);
  while (__stxr(v13 + 1, v11));
  do
    v14 = __ldaxr(v11);
  while (__stlxr(v14 - 1, v11));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v10);
  }
  do
    v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *(_OWORD *)((char *)this + 184) = xmmword_1DA911230;
  v25 = xmmword_1DA910E50;
  *(_OWORD *)v26 = unk_1DA910E60;
  *(_OWORD *)&v26[16] = xmmword_1DA910E70;
  TIFitAffineMLLMatrix::TIFitAffineMLLMatrix((_QWORD *)this + 25, 2, 3, (uint64_t)&v25, 6);
  v16 = *((_OWORD *)this + 4);
  *(_QWORD *)v23 = *((_QWORD *)this + 8);
  *(_OWORD *)&v23[8] = v16;
  TIFitAffineMLLMatrix::diag((char *)3, (uint64_t)v23, 3, (char **)&v25);
  TIFitAffineMLLMatrix::operator*(&v25, (TIFitAffineTransform *)((char *)this + 240), *((double *)this + 18) * *((double *)this + 18));
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[8]);
  TIFitAffineMLLMatrix::operator*((TIFitAffineTransform *)((char *)this + 200), (TIFitAffineTransform *)((char *)this + 240), (TIFitAffineTransform *)((char *)this + 280));
  TIFitAffineMLLMatrix::operator*((TIFitAffineTransform *)((char *)this + 200), (TIFitAffineTransform *)((char *)this + 240), (TIFitAffineMLLMatrix *)&v25);
  TIFitAffineMLLMatrix::transform((int8x16_t *)((char *)this + 200), (int8x16_t *)v23);
  TIFitAffineMLLMatrix::operator*((TIFitAffineMLLMatrix *)&v25, (TIFitAffineMLLMatrix *)v23, (TIFitAffineTransform *)((char *)this + 320));
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy((_QWORD *)v24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[8]);
  v17 = *((_QWORD *)this + 10);
  *((double *)this + 45) = *((double *)this + 11) + (double)*((unint64_t *)this + 23);
  *((double *)this + 46) = a2;
  *(_QWORD *)&v25 = v17;
  *((_QWORD *)&v25 + 1) = v17;
  v18 = (TIFitAffineMLLMatrix *)TIFitAffineMLLMatrix::TIFitAffineMLLMatrix((_QWORD *)this + 47, 1, 2, (uint64_t)&v25, 2);
  TIFitAffineMLLMatrix::pow(v18, 2.0, &v25);
  TIFitAffineMLLMatrix::diag((char *)&v25, (unint64_t *)this + 52);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[8]);
  TIFitAffineMLLMatrix::operator*((_QWORD *)this + 52, (TIFitAffineTransform *)((char *)this + 456), *((double *)this + 45) - (double)*((unint64_t *)this + 23) + -1.0);
  *((_OWORD *)this + 31) = *((_OWORD *)this + 26);
  *(_OWORD *)((char *)this + 520) = 0u;
  *((_QWORD *)this + 64) = (char *)this + 520;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 64, *((_QWORD **)this + 54), (_QWORD *)this + 55);
  *(_OWORD *)((char *)this + 536) = *((_OWORD *)this + 26);
  *((_OWORD *)this + 35) = 0u;
  *((_QWORD *)this + 69) = (char *)this + 560;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 69, *((_QWORD **)this + 54), (_QWORD *)this + 55);
  *((_OWORD *)this + 36) = *(_OWORD *)((char *)this + 200);
  *(_OWORD *)((char *)this + 600) = 0u;
  *((_QWORD *)this + 74) = (char *)this + 600;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 74, *((_QWORD **)this + 27), (_QWORD *)this + 28);
  *(_OWORD *)((char *)this + 616) = *(_OWORD *)((char *)this + 200);
  *((_OWORD *)this + 40) = 0u;
  *((_QWORD *)this + 79) = (char *)this + 640;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 79, *((_QWORD **)this + 27), (_QWORD *)this + 28);
  *(_OWORD *)v22 = *(_OWORD *)(*((_QWORD *)this + 19) + 56);
  Translate_A((const TIFitAffineMLLMatrix *)&v25, (CGPoint *)this + 36, v22);
  v21 = *(_OWORD *)(*((_QWORD *)this + 21) + 56);
  Translate_A((const TIFitAffineMLLMatrix *)v23, (CGPoint *)((char *)this + 616), (double *)&v21);
  *((_OWORD *)this + 41) = v25;
  *(_OWORD *)((char *)this + 680) = 0u;
  *((_QWORD *)this + 84) = (char *)this + 680;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 84, *(_QWORD **)v26, &v26[8]);
  *(_OWORD *)((char *)this + 696) = *(_OWORD *)v23;
  *((_OWORD *)this + 45) = 0u;
  *((_QWORD *)this + 89) = (char *)this + 720;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 89, *(_QWORD **)&v23[16], &v24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy((_QWORD *)v24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[8]);
  *(_QWORD *)&v25 = *((_QWORD *)this + 24);
  *((_QWORD *)&v25 + 1) = v25;
  *(_OWORD *)&v26[8] = 0u;
  *(_QWORD *)v26 = &v26[8];
  *(_QWORD *)v23 = v25;
  *(_QWORD *)&v23[8] = v25;
  v24 = 0u;
  *(_QWORD *)&v23[16] = &v24;
  v19 = v25;
  *((_OWORD *)this + 46) = 0u;
  *((_OWORD *)this + 47) = v19;
  *(_OWORD *)((char *)this + 776) = 0u;
  *((_QWORD *)this + 96) = (char *)this + 776;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 96, &v26[8], &v26[8]);
  *(_OWORD *)((char *)this + 792) = *(_OWORD *)v23;
  *((_OWORD *)this + 51) = 0u;
  *((_QWORD *)this + 101) = (char *)this + 816;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 101, *(_QWORD **)&v23[16], &v24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy((_QWORD *)v24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[8]);
  *(_QWORD *)&v25 = *((_QWORD *)this + 23);
  *((_QWORD *)&v25 + 1) = v25;
  *(_OWORD *)&v26[8] = 0u;
  *(_QWORD *)v26 = &v26[8];
  *(_QWORD *)v23 = v25;
  *(_QWORD *)&v23[8] = v25;
  v24 = 0u;
  *(_QWORD *)&v23[16] = &v24;
  *((_OWORD *)this + 52) = v25;
  *(_OWORD *)((char *)this + 856) = 0u;
  *((_QWORD *)this + 106) = (char *)this + 856;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 106, &v26[8], &v26[8]);
  *(_OWORD *)((char *)this + 872) = *(_OWORD *)v23;
  *((_OWORD *)this + 56) = 0u;
  *((_QWORD *)this + 111) = (char *)this + 896;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 111, *(_QWORD **)&v23[16], &v24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy((_QWORD *)v24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[8]);
  v20 = *((_QWORD *)this + 23);
  *(_QWORD *)&v25 = *((_QWORD *)this + 24);
  *((_QWORD *)&v25 + 1) = v20;
  *(_OWORD *)&v26[8] = 0u;
  *(_QWORD *)v26 = &v26[8];
  *(_QWORD *)v23 = v25;
  *(_QWORD *)&v23[8] = v20;
  v24 = 0u;
  *(_QWORD *)&v23[16] = &v24;
  *((_OWORD *)this + 57) = v25;
  *(_OWORD *)((char *)this + 936) = 0u;
  *((_QWORD *)this + 116) = (char *)this + 936;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 116, &v26[8], &v26[8]);
  *(_OWORD *)((char *)this + 952) = *(_OWORD *)v23;
  *((_OWORD *)this + 61) = 0u;
  *((_QWORD *)this + 121) = (char *)this + 976;
  std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)this + 121, *(_QWORD **)&v23[16], &v24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy((_QWORD *)v24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[8]);
  *((double *)this + 124) = 1.0 - *((double *)this + 7);
  *(_OWORD *)((char *)this + 1000) = 0u;
}

void Translate_A(const TIFitAffineMLLMatrix *a1, CGPoint *a2, double *a3)
{
  unint64_t v5;
  double v6;
  double v7;
  unint64_t v8;
  double v9;
  double v10;
  _QWORD *v11[5];
  _QWORD v12[3];
  _QWORD *v13;
  int64x2_t v14;
  _QWORD **v15;
  _QWORD *v16[2];
  uint64_t v17[5];
  int64x2_t v18;
  uint64_t v19;
  _QWORD *v20[3];

  v20[2] = *(_QWORD **)MEMORY[0x1E0C80C00];
  v18 = (int64x2_t)xmmword_1DA910E80;
  v19 = 0x3FF0000000000000;
  TIFitAffineMLLMatrix::addRow((uint64_t *)a2, (uint64_t)&v18, 3, v17);
  v5 = 0;
  v18 = vdupq_n_s64(3uLL);
  v20[0] = 0;
  v20[1] = 0;
  v19 = (uint64_t)v20;
  do
  {
    *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v18, v5, v5) = 0x3FF0000000000000;
    ++v5;
  }
  while (v5 != 3);
  v6 = *a3 * -0.001953125;
  *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v18, 0, 2uLL) = v6;
  v7 = a3[1] * -0.001953125;
  *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v18, 1uLL, 2uLL) = v7;
  v8 = 0;
  *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v18, 2uLL, 2uLL) = 0x3FF0000000000000;
  v14 = vdupq_n_s64(3uLL);
  v16[0] = 0;
  v16[1] = 0;
  v15 = v16;
  do
  {
    *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v14, v8, v8) = 0x3FF0000000000000;
    ++v8;
  }
  while (v8 != 3);
  v9 = *a3 * 0.001953125;
  *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v14, 0, 2uLL) = v9;
  v10 = a3[1] * 0.001953125;
  *(double *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v14, 1uLL, 2uLL) = v10;
  *(_QWORD *)TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)&v14, 2uLL, 2uLL) = 0x3FF0000000000000;
  TIFitAffineMLLMatrix::operator*((TIFitAffineMLLMatrix *)&v14, (TIFitAffineMLLMatrix *)v17, (TIFitAffineMLLMatrix *)v12);
  TIFitAffineMLLMatrix::operator*((TIFitAffineMLLMatrix *)v12, (TIFitAffineMLLMatrix *)&v18, a1);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v13);
  TIFitAffineMLLMatrix::deleteRow(a1, 2, v12);
  TIFitAffineMLLMatrix::operator=((uint64_t)a1, (uint64_t)v12, (uint64_t)v11);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v11[3]);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v13);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v16[0]);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v20[0]);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy((_QWORD *)v17[3]);
}

void std::__shared_ptr_pointer<TIFitAffineHand *,std::shared_ptr<TIFitAffineHand>::__shared_ptr_default_delete<TIFitAffineHand,TIFitAffineHand>,std::allocator<TIFitAffineHand>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_pointer<TIFitAffineHand *,std::shared_ptr<TIFitAffineHand>::__shared_ptr_default_delete<TIFitAffineHand,TIFitAffineHand>,std::allocator<TIFitAffineHand>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void TIFitAffineTransform::resetState(TIFitAffineTransform *this)
{
  double v2;
  __int128 v3;
  uint64_t v4;
  _QWORD *v5[5];
  _BYTE v6[24];
  _QWORD *v7;
  _BYTE v8[24];
  _QWORD *v9;
  _BYTE v10[24];
  _QWORD *v11;
  _BYTE v12[24];
  _QWORD *v13;
  _BYTE v14[24];
  _QWORD *v15;
  _BYTE v16[24];
  _QWORD *v17;
  int8x16_t v18;
  _QWORD *v19;
  __int128 v20;
  _QWORD *v21;
  _BYTE v22[24];
  _QWORD *v23;
  _BYTE v24[24];
  _QWORD *v25;
  _BYTE v26[32];
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)this = xmmword_1DA9111E0;
  *((_OWORD *)this + 1) = xmmword_1DA9111F0;
  *((_OWORD *)this + 2) = xmmword_1DA911200;
  *((_OWORD *)this + 3) = xmmword_1DA911210;
  *((int64x2_t *)this + 4) = vdupq_n_s64(0x3FC999999999999AuLL);
  *((_OWORD *)this + 5) = xmmword_1DA911220;
  *((_QWORD *)this + 12) = 0x4054000000000000;
  v2 = log1p(2.71828182);
  *((double *)this + 13) = -v2;
  *((double *)this + 14) = 0.999999998 - v2;
  *((long double *)this + 15) = exp(0.999999998 - v2);
  *((long double *)this + 16) = exp(-v2);
  *((double *)this + 17) = -1.14472989 - v2 + -8.76405327;
  *((_QWORD *)this + 18) = 0x4080000000000000;
  *(_OWORD *)((char *)this + 184) = xmmword_1DA911230;
  *(_OWORD *)v26 = xmmword_1DA910E50;
  *(_OWORD *)&v26[16] = unk_1DA910E60;
  v27 = xmmword_1DA910E70;
  TIFitAffineMLLMatrix::setValues((uint64_t)this + 200, (uint64_t)v26, 6);
  v3 = *((_OWORD *)this + 4);
  *(_QWORD *)v26 = *((_QWORD *)this + 8);
  *(_OWORD *)&v26[8] = v3;
  TIFitAffineMLLMatrix::setDiagValues((uint64_t)this + 240, (uint64_t)v26, 3);
  TIFitAffineMLLMatrix::operator*=((TIFitAffineTransform *)((char *)this + 240), *((double *)this + 18) * *((double *)this + 18));
  TIFitAffineMLLMatrix::operator*((TIFitAffineTransform *)((char *)this + 200), (TIFitAffineTransform *)((char *)this + 240), (TIFitAffineMLLMatrix *)v26);
  TIFitAffineMLLMatrix::operator=((uint64_t)this + 280, (uint64_t)v26, (uint64_t)v24);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v25);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[24]);
  TIFitAffineMLLMatrix::operator*((TIFitAffineTransform *)((char *)this + 200), (TIFitAffineTransform *)((char *)this + 240), (TIFitAffineMLLMatrix *)&v20);
  TIFitAffineMLLMatrix::transform((int8x16_t *)((char *)this + 200), &v18);
  TIFitAffineMLLMatrix::operator*((TIFitAffineMLLMatrix *)&v20, (TIFitAffineMLLMatrix *)&v18, (TIFitAffineMLLMatrix *)v26);
  TIFitAffineMLLMatrix::operator=((uint64_t)this + 320, (uint64_t)v26, (uint64_t)v22);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v23);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[24]);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v19);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v21);
  v4 = *((_QWORD *)this + 10);
  *((double *)this + 45) = *((double *)this + 11) + (double)*((unint64_t *)this + 23);
  *(_QWORD *)v26 = v4;
  *(_QWORD *)&v26[8] = v4;
  TIFitAffineMLLMatrix::setValues((uint64_t)this + 376, (uint64_t)v26, 2);
  TIFitAffineMLLMatrix::pow((TIFitAffineTransform *)((char *)this + 376), 2.0, v26);
  TIFitAffineMLLMatrix::values((TIFitAffineMLLMatrix *)v26, (double **)&v20);
  TIFitAffineMLLMatrix::setDiagValues((uint64_t)this + 416, (uint64_t *)&v20);
  if ((_QWORD)v20)
    operator delete((void *)v20);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[24]);
  TIFitAffineMLLMatrix::operator*((_QWORD *)this + 52, (TIFitAffineMLLMatrix *)v26, *((double *)this + 45) - (double)*((unint64_t *)this + 23) + -1.0);
  TIFitAffineMLLMatrix::operator=((uint64_t)this + 456, (uint64_t)v26, (uint64_t)v16);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v17);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[24]);
  TIFitAffineMLLMatrix::operator=((uint64_t)this + 496, (uint64_t)this + 416, (uint64_t)v14);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v15);
  TIFitAffineMLLMatrix::operator=((uint64_t)this + 536, (uint64_t)this + 416, (uint64_t)v12);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v13);
  TIFitAffineMLLMatrix::operator=((uint64_t)this + 576, (uint64_t)this + 200, (uint64_t)v10);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v11);
  TIFitAffineMLLMatrix::operator=((uint64_t)this + 616, (uint64_t)this + 200, (uint64_t)v8);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v9);
  v20 = *(_OWORD *)(*((_QWORD *)this + 19) + 56);
  Translate_A((const TIFitAffineMLLMatrix *)v26, (CGPoint *)this + 36, (double *)&v20);
  TIFitAffineMLLMatrix::operator=((uint64_t)this + 656, (uint64_t)v26, (uint64_t)v6);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v7);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[24]);
  v20 = *(_OWORD *)(*((_QWORD *)this + 21) + 56);
  Translate_A((const TIFitAffineMLLMatrix *)v26, (CGPoint *)((char *)this + 616), (double *)&v20);
  TIFitAffineMLLMatrix::operator=((uint64_t)this + 696, (uint64_t)v26, (uint64_t)v5);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v5[3]);
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v26[24]);
  *((_OWORD *)this + 46) = 0u;
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*((_QWORD **)this + 97));
  *((_QWORD *)this + 96) = (char *)this + 776;
  *(_OWORD *)((char *)this + 776) = 0u;
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*((_QWORD **)this + 102));
  *((_QWORD *)this + 101) = (char *)this + 816;
  *((_OWORD *)this + 51) = 0u;
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*((_QWORD **)this + 107));
  *((_QWORD *)this + 106) = (char *)this + 856;
  *(_OWORD *)((char *)this + 856) = 0u;
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*((_QWORD **)this + 112));
  *((_QWORD *)this + 111) = (char *)this + 896;
  *((_OWORD *)this + 56) = 0u;
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*((_QWORD **)this + 117));
  *((_QWORD *)this + 116) = (char *)this + 936;
  *(_OWORD *)((char *)this + 936) = 0u;
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*((_QWORD **)this + 122));
  *((_QWORD *)this + 121) = (char *)this + 976;
  *((_OWORD *)this + 61) = 0u;
  *((double *)this + 124) = 1.0 - *((double *)this + 7);
  *(_OWORD *)((char *)this + 1000) = 0u;
}

void TIFitAffineTransform::processLocation(TIFitAffineHand **this, const CGPoint *a2)
{
  int v4;
  CGRect v5;

  if (TIFitAffineHand::findClosestKeyRectForPoint(this[19], *a2, &v5))
  {
    v4 = 1;
  }
  else
  {
    if (!TIFitAffineHand::findClosestKeyRectForPoint(this[21], *a2, &v5))
      return;
    v4 = 2;
  }
  TIFitAffineTransform::processLocation((uint64_t)this, &a2->x, v4, &v5);
}

void TIFitAffineTransform::processLocation(uint64_t a1, double *a2, int a3, CGRect *a4)
{
  double v8;
  __int128 *v9;
  double v10;
  TIFitAffineMLLMatrix *v11;
  double v12;
  TIFitAffineMLLMatrix *v13;
  double MidX;
  double MidY;
  uint64_t *v16;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  TIFitAffineMLLMatrix *v21;
  uint64_t v22;
  CGPoint *v23;
  TIFitAffineMLLMatrix *v24;
  _QWORD *v25;
  uint64_t v26;
  double *v27;
  double v28;
  double v29;
  CGPoint *v30;
  TIFitAffineMLLMatrix *v31;
  double v32;
  unint64_t v33;
  double v34;
  double v35;
  double v36;
  double v37;
  long double v38;
  long double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  TIFitAffineMLLMatrix *v44;
  double v45;
  double v46;
  double v47;
  long double v48;
  long double v49;
  const TIFitAffineMLLMatrix *v50;
  uint64_t v51;
  TIFitAffineHand **v52;
  TIFitAffineHand *v53;
  const TIFitAffineMLLMatrix *v54;
  TIFitAffineHand *v55;
  TIFitAffineHand *v56;
  TIFitAffineHand **v57;
  _BYTE v58[24];
  _QWORD *v59;
  _BYTE v60[24];
  _QWORD *v61;
  int8x16_t v62;
  _QWORD *v63;
  _QWORD *v64;
  _QWORD v65[5];
  _BYTE v66[24];
  _QWORD *v67;
  _BYTE v68[24];
  _QWORD *v69;
  _QWORD v70[5];
  __int128 v71;
  _QWORD *v72;
  _BYTE v73[24];
  _QWORD *v74;
  __int128 v75;
  _QWORD *v76;
  int8x16_t v77;
  _QWORD *v78;
  _BYTE v79[24];
  _QWORD *v80;
  int8x16_t v81;
  _QWORD *v82;
  int8x16_t v83;
  _QWORD *v84;
  _QWORD v85[5];
  _BYTE v86[24];
  _QWORD *v87;
  double v88[5];
  int8x16_t v89;
  _QWORD *v90;
  int8x16_t v91;
  _QWORD *v92;
  int8x16_t v93;
  _QWORD **v94;
  _QWORD *v95[5];

  v95[3] = *(_QWORD **)MEMORY[0x1E0C80C00];
  v8 = *(double *)(a1 + 992);
  *(double *)(a1 + 736) = v8 * *(double *)(a1 + 736);
  *(double *)(a1 + 744) = v8 * *(double *)(a1 + 744);
  v9 = (__int128 *)(a1 + 752);
  TIFitAffineMLLMatrix::operator*=((TIFitAffineMLLMatrix *)(a1 + 752), v8);
  TIFitAffineMLLMatrix::operator*=((TIFitAffineMLLMatrix *)(a1 + 792), v8);
  v10 = *(double *)(a1 + 992);
  v11 = (TIFitAffineMLLMatrix *)(a1 + 832);
  TIFitAffineMLLMatrix::operator*=((TIFitAffineMLLMatrix *)(a1 + 832), v10);
  TIFitAffineMLLMatrix::operator*=((TIFitAffineMLLMatrix *)(a1 + 872), v10);
  v12 = *(double *)(a1 + 992);
  v13 = (TIFitAffineMLLMatrix *)(a1 + 912);
  TIFitAffineMLLMatrix::operator*=((TIFitAffineMLLMatrix *)(a1 + 912), v12);
  TIFitAffineMLLMatrix::operator*=((TIFitAffineMLLMatrix *)(a1 + 952), v12);
  if (a3)
  {
    MidX = CGRectGetMidX(*a4);
    MidY = CGRectGetMidY(*a4);
    v16 = (uint64_t *)(a1 + 152);
    v57 = (TIFitAffineHand **)(a1 + 152);
    if (a3 != 1)
      v16 = (uint64_t *)(a1 + 168);
    v17 = *v16;
    v18 = *(double *)(v17 + 56);
    v19 = *(double *)(v17 + 64);
    *(double *)v93.i64 = MidX - v18;
    *(double *)&v93.i64[1] = MidY - v19;
    v94 = *(_QWORD ***)(a1 + 144);
    TIFitAffineMLLMatrix::TIFitAffineMLLMatrix(&v83, 3, 1, (uint64_t)&v93, 3);
    v20 = a2[1] - v19;
    *(double *)v93.i64 = *a2 - v18;
    *(double *)&v93.i64[1] = v20;
    TIFitAffineMLLMatrix::TIFitAffineMLLMatrix(&v81, 2, 1, (uint64_t)&v93, 2);
    if (a3 == 1)
    {
      TIFitAffineMLLMatrix::operator+(v9, a1 + 240, (uint64_t)v79);
      TIFitAffineMLLMatrix::operator+((__int128 *)(a1 + 912), a1 + 280, (uint64_t)&v77);
      TIFitAffineMLLMatrix::operator+((__int128 *)(a1 + 832), a1 + 320, (uint64_t)&v75);
      TIFitAffineMLLMatrix::operator/((TIFitAffineMLLMatrix *)v79, (TIFitAffineMLLMatrix *)&v77, (TIFitAffineMLLMatrix *)&v93);
      v21 = (TIFitAffineMLLMatrix *)(a1 + 576);
      v22 = a1 + 576;
    }
    else
    {
      TIFitAffineMLLMatrix::operator+((__int128 *)(a1 + 792), a1 + 240, (uint64_t)v79);
      TIFitAffineMLLMatrix::operator+((__int128 *)(a1 + 952), a1 + 280, (uint64_t)&v77);
      TIFitAffineMLLMatrix::operator+((__int128 *)(a1 + 872), a1 + 320, (uint64_t)&v75);
      TIFitAffineMLLMatrix::operator/((TIFitAffineMLLMatrix *)v79, (TIFitAffineMLLMatrix *)&v77, (TIFitAffineMLLMatrix *)&v93);
      v21 = (TIFitAffineMLLMatrix *)(a1 + 576);
      v22 = a1 + 616;
    }
    TIFitAffineMLLMatrix::operator=(v22, (uint64_t)&v93, (uint64_t)v73);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v74);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v95[0]);
    v23 = (CGPoint *)v21;
    if (a3 == 1)
      v24 = v21;
    else
      v24 = (TIFitAffineMLLMatrix *)(a1 + 616);
    TIFitAffineMLLMatrix::transform(&v77, &v91);
    TIFitAffineMLLMatrix::operator*(v24, (TIFitAffineMLLMatrix *)&v91, (TIFitAffineMLLMatrix *)&v93);
    TIFitAffineMLLMatrix::operator-(&v75, (uint64_t)&v93, (uint64_t)&v71);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v95[0]);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v92);
    TIFitAffineMLLMatrix::operator+(&v71, a1 + 456, (uint64_t)v70);
    if (a3 == 1)
    {
      TIFitAffineMLLMatrix::operator/(v70, (TIFitAffineMLLMatrix *)&v93, *(double *)(a1 + 736) + *(double *)(a1 + 360) - (double)*(unint64_t *)(a1 + 184) + -1.0);
      v25 = (_QWORD *)(a1 + 496);
      v26 = a1 + 496;
    }
    else
    {
      TIFitAffineMLLMatrix::operator/(v70, (TIFitAffineMLLMatrix *)&v93, *(double *)(a1 + 744) + *(double *)(a1 + 360) - (double)*(unint64_t *)(a1 + 184) + -1.0);
      v25 = (_QWORD *)(a1 + 496);
      v26 = a1 + 536;
    }
    v27 = (double *)(a1 + 736);
    TIFitAffineMLLMatrix::operator=(v26, (uint64_t)&v93, (uint64_t)v68);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v69);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v95[0]);
    v88[0] = 1.0;
    TIFitAffineMLLMatrix::transform(&v83, &v89);
    TIFitAffineMLLMatrix::operator/((TIFitAffineMLLMatrix *)v79, (TIFitAffineMLLMatrix *)&v89, (TIFitAffineMLLMatrix *)&v91);
    TIFitAffineMLLMatrix::operator*((TIFitAffineMLLMatrix *)&v91, (TIFitAffineMLLMatrix *)&v83, (TIFitAffineMLLMatrix *)&v93);
    operator+((TIFitAffineMLLMatrix *)&v93, v88, (TIFitAffineMLLMatrix *)v66);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v95[0]);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v92);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v90);
    v28 = 1.0 / TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v66, 0, 0);
    if (a3 == 1)
    {
      v29 = *v27 + *(double *)(a1 + 360);
      TIFitAffineMLLMatrix::operator/(v25, (TIFitAffineMLLMatrix *)v65, v28);
      v30 = v23;
      v31 = (TIFitAffineMLLMatrix *)v23;
    }
    else
    {
      v29 = *(double *)(a1 + 744) + *(double *)(a1 + 360);
      TIFitAffineMLLMatrix::operator/((_QWORD *)(a1 + 536), (TIFitAffineMLLMatrix *)v65, v28);
      v31 = (TIFitAffineMLLMatrix *)(a1 + 616);
      v30 = v23;
    }
    v32 = v29 + 1.0;
    TIFitAffineMLLMatrix::operator*(v31, (TIFitAffineMLLMatrix *)&v83, (TIFitAffineMLLMatrix *)v60);
    TIFitAffineMLLMatrix::operator-((__int128 *)v81.i8, (uint64_t)v60, (uint64_t)&v62);
    v93 = v62;
    v95[0] = 0;
    v95[1] = 0;
    v94 = v95;
    std::map<unsigned long,double>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned long,double>,std::__tree_node<std::__value_type<unsigned long,double>,void *> *,long>>>((uint64_t *)&v94, v63, &v64);
    v33 = v93.u64[1];
    if (v65[1] == v93.i64[1])
    {
      TIFitAffineMLLMatrix::transform(&v93, &v89);
      TIFitAffineMLLMatrix::operator=((uint64_t)&v93, (uint64_t)&v89, (uint64_t)&v91);
      std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v92);
      std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v90);
    }
    else
    {
      v33 = v93.i64[0];
    }
    TIFitAffineMLLMatrix::determinant((TIFitAffineMLLMatrix *)v65);
    v35 = v34;
    TIFitAffineMLLMatrix::cholesky((TIFitAffineMLLMatrix *)v65, (uint64_t)&v89);
    TIFitAffineMLLMatrix::operator/((TIFitAffineMLLMatrix *)&v89, (TIFitAffineMLLMatrix *)&v93, (TIFitAffineMLLMatrix *)v88);
    v36 = log(sqrt(v35));
    TIFitAffineMLLMatrix::pow((TIFitAffineMLLMatrix *)v88, 2.0, v85);
    TIFitAffineMLLMatrix::sumRows((char *)v85, (TIFitAffineMLLMatrix *)v86);
    v37 = TIFitAffineMLLMatrix::valueAt((TIFitAffineMLLMatrix *)v86, 0, 0);
    v38 = (v32 + (double)v33) * 0.5 * log(v37 / v32 + 1.0);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v87);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy((_QWORD *)v85[3]);
    v39 = v36 + (double)(v33 >> 1) * log(v32 * 3.14159265);
    v40 = gammaln((v32 + (double)v33) * 0.5);
    v41 = v40 - gammaln(v32 * 0.5) - v38 - v39;
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(_QWORD **)&v88[3]);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v90);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v95[0]);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v64);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v61);
    v42 = *(double *)(a1 + 120);
    v43 = v42 / (exp(*(double *)(a1 + 136) - v41) + 1.0);
    v88[0] = v43;
    if (a3 != 1)
      v27 = (double *)(a1 + 744);
    *v27 = v43 + *v27;
    operator*((uint64_t)v88, &v83, (TIFitAffineMLLMatrix *)&v91);
    TIFitAffineMLLMatrix::transform(&v83, &v89);
    TIFitAffineMLLMatrix::operator*((TIFitAffineMLLMatrix *)&v91, (TIFitAffineMLLMatrix *)&v89, (TIFitAffineMLLMatrix *)&v93);
    if (a3 == 1)
      v44 = (TIFitAffineMLLMatrix *)v9;
    else
      v44 = (TIFitAffineMLLMatrix *)(a1 + 792);
    TIFitAffineMLLMatrix::operator+=(v44, (uint64_t)&v93);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v95[0]);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v90);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v92);
    operator*((uint64_t)v88, &v81, (TIFitAffineMLLMatrix *)&v91);
    TIFitAffineMLLMatrix::transform(&v81, &v89);
    TIFitAffineMLLMatrix::operator*((TIFitAffineMLLMatrix *)&v91, (TIFitAffineMLLMatrix *)&v89, (TIFitAffineMLLMatrix *)&v93);
    if (a3 != 1)
      v11 = (TIFitAffineMLLMatrix *)(a1 + 872);
    TIFitAffineMLLMatrix::operator+=(v11, (uint64_t)&v93);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v95[0]);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v90);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v92);
    operator*((uint64_t)v88, &v81, (TIFitAffineMLLMatrix *)&v91);
    TIFitAffineMLLMatrix::transform(&v83, &v89);
    TIFitAffineMLLMatrix::operator*((TIFitAffineMLLMatrix *)&v91, (TIFitAffineMLLMatrix *)&v89, (TIFitAffineMLLMatrix *)&v93);
    if (a3 != 1)
      v13 = (TIFitAffineMLLMatrix *)(a1 + 952);
    TIFitAffineMLLMatrix::operator+=(v13, (uint64_t)&v93);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v95[0]);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v90);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v92);
    v45 = v41 + *(double *)(a1 + 112);
    v46 = *(double *)(a1 + 136);
    if (v45 >= v46)
      v47 = v41 + *(double *)(a1 + 112);
    else
      v47 = *(double *)(a1 + 136);
    if (v45 >= v46)
      v45 = *(double *)(a1 + 136);
    v48 = exp(v45 - v47);
    v49 = log1p(v48) + v47;
    *(long double *)(a1 + 1000) = *(double *)(a1 + 1000) + v49;
    *(long double *)(a1 + 1008) = *(double *)(a1 + 1008) + v88[0] * (v49 * v49);
    if (a3 == 1)
    {
      v91 = *(int8x16_t *)(*(_QWORD *)(a1 + 152) + 56);
      Translate_A((const TIFitAffineMLLMatrix *)&v93, v30, (double *)v91.i64);
      v50 = (const TIFitAffineMLLMatrix *)(a1 + 656);
      v51 = a1 + 656;
    }
    else
    {
      v91 = *(int8x16_t *)(*(_QWORD *)(a1 + 168) + 56);
      Translate_A((const TIFitAffineMLLMatrix *)&v93, (CGPoint *)(a1 + 616), (double *)v91.i64);
      v50 = (const TIFitAffineMLLMatrix *)(a1 + 656);
      v51 = a1 + 696;
    }
    TIFitAffineMLLMatrix::operator=(v51, (uint64_t)&v93, (uint64_t)v58);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v59);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v95[0]);
    if (a3 == 1)
    {
      v52 = (TIFitAffineHand **)(a1 + 152);
      v53 = *v57;
      v54 = v50;
    }
    else
    {
      v55 = *(TIFitAffineHand **)(a1 + 168);
      v52 = (TIFitAffineHand **)(a1 + 168);
      v53 = v55;
      v54 = (const TIFitAffineMLLMatrix *)(v52 + 66);
    }
    TIFitAffineHand::updateFromMatrix(v53, v54, 512.0);
    v56 = *v52;
    TIFitAffineMLLMatrix::operator*(v65, (TIFitAffineMLLMatrix *)&v93, v32 / (v32 + -2.0));
    TIFitAffineHand::setCovar(v56, (const TIFitAffineMLLMatrix *)&v93);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v95[0]);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy((_QWORD *)v65[3]);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v67);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy((_QWORD *)v70[3]);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v72);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v76);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v78);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v80);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v82);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v84);
  }
}

long double gammaln(long double a1)
{
  uint64_t v2;
  double v3;
  double v4;
  double v5;
  uint64_t i;
  _BYTE v8[24];
  uint64_t v9;

  v2 = 0;
  v9 = *MEMORY[0x1E0C80C00];
  v3 = a1 * a1;
  v4 = a1;
  do
  {
    *(double *)&v8[v2 * 8] = *(double *)&gammaln_asy_exp(long double)::B[v2] / v4;
    v4 = v3 * v4;
    ++v2;
  }
  while (v2 != 3);
  v5 = 0.0;
  for (i = 16; i != -8; i -= 8)
    v5 = v5 + *(double *)&v8[i];
  return 0.918938533 - a1 + (a1 + -0.5) * log(a1) + v5;
}

void TIFitAffineTransform::processLocation(TIFitAffineHand **this, const CGPoint *a2, CGRect *a3)
{
  int HandEnumForKeyRect;

  HandEnumForKeyRect = TIFitAffineTransform::getHandEnumForKeyRect(this, a3);
  TIFitAffineTransform::processLocation((uint64_t)this, &a2->x, HandEnumForKeyRect, a3);
}

uint64_t TIFitAffineTransform::getHandEnumForKeyRect(TIFitAffineHand **this, const CGRect *a2)
{
  if (TIFitAffineHand::containsKeyRect(this[19], a2))
    return 1;
  if (TIFitAffineHand::containsKeyRect(this[21], a2))
    return 2;
  return 0;
}

uint64_t __Block_byref_object_copy__18630(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__18631(uint64_t a1)
{

}

void KB::NgramCandidateRefinery::~NgramCandidateRefinery(KB::NgramCandidateRefinery *this)
{
  KB::NgramCandidateRefinery::~NgramCandidateRefinery(this);
  JUMPOUT(0x1DF0A2144);
}

{
  unsigned int *v2;
  std::__shared_weak_count *v3;

  *(_QWORD *)this = &off_1EA1065F8;
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
  v2 = (unsigned int *)*((_QWORD *)this + 3);
  if (v2)
    WTF::RefCounted<KB::DictionaryContainer>::deref(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

uint64_t KB::NgramCandidateRefinery::uses_document_context(KB::NgramCandidateRefinery *this)
{
  int v2;

  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4));
  return v2 & (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 4) + 32))(*((_QWORD *)this + 4));
}

uint64_t KB::NgramCandidateRefinery::does_language_model_provide_inline_completions(KB::NgramCandidateRefinery *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 4);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2))
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 144))(*((_QWORD *)this + 4));
  else
    return 0;
}

uint64_t KB::NgramCandidateRefinery::does_language_model_support_multilingual(KB::NgramCandidateRefinery *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 4);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2))
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 160))(*((_QWORD *)this + 4));
  else
    return 0;
}

uint64_t KB::NgramCandidateRefinery::does_language_model_support_fragment_conditional_prob(KB::NgramCandidateRefinery *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 4);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2))
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 168))(*((_QWORD *)this + 4));
  else
    return 0;
}

uint64_t KB::NgramCandidateRefinery::does_language_model_support_completions(KB::NgramCandidateRefinery *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 4);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2))
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 128))(*((_QWORD *)this + 4));
  else
    return 0;
}

void KB::NgramCandidateRefinery::refine_candidates(KB::NgramCandidateRefinery *a1, unsigned int **a2, uint64_t a3)
{
  unsigned int *v5;
  unsigned int *v6;
  uint64_t v7;
  float *v8;
  float v9;
  float v10;
  uint64_t v11;
  unsigned int *v12;
  unint64_t v13;
  uint64_t v14;
  float v15;

  KB::NgramCandidateRefinery::add_context_weights_batched(a1, a2);
  v5 = *a2;
  v6 = a2[1];
  if (*a2 == v6)
  {
    v12 = *a2;
LABEL_11:
    v13 = 126 - 2 * __clz(0x1CAC083126E978D5 * (((char *)v5 - (char *)v12) >> 3));
    if (v5 == v12)
      v14 = 0;
    else
      v14 = v13;
    std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,false>((uint64_t *)v12, (KB::Candidate *)v5, v14, 1);
  }
  else
  {
    while (1)
    {
      if (*(_QWORD *)v5)
      {
        v7 = 240 * *(_QWORD *)v5;
        v8 = (float *)(*((_QWORD *)v5 + 1) + 52);
        v9 = 1.0;
        do
        {
          v10 = *v8;
          v8 += 60;
          v9 = v9 * v10;
          v7 -= 240;
        }
        while (v7);
      }
      else
      {
        v9 = 1.0;
      }
      v15 = v9;
      v11 = *(_QWORD *)(a3 + 24);
      if (!v11)
        break;
      (*(void (**)(uint64_t, unsigned int *, float *))(*(_QWORD *)v11 + 48))(v11, v5, &v15);
      v5 += 250;
      if (v5 == v6)
      {
        v12 = *a2;
        v5 = a2[1];
        goto LABEL_11;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    KB::NgramCandidateRefinery::set_text_blocklisted_flag();
  }
}

void KB::NgramCandidateRefinery::set_text_blocklisted_flag(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  unsigned __int16 *v7;
  uint64_t v8;
  int v9;
  const char *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  KB::Word *v19;
  KB::NgramCandidateRefinery *v20;
  uint64_t v21;
  TITokenID v22;
  TITokenID v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  BOOL v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _QWORD *v31;
  void **v32;
  void *v33;
  const char *v34;
  void *v35;
  void *__p;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD v40[5];

  v40[3] = *MEMORY[0x1E0C80C00];
  if ((*(unsigned int (**)(_QWORD *))(*a1 + 16))(a1))
  {
    v6 = *(_QWORD **)a2;
    v31 = *(_QWORD **)(a2 + 8);
    if (*(_QWORD **)a2 != v31)
    {
      do
      {
        if (*v6)
        {
          v7 = (unsigned __int16 *)v6[1];
          v8 = 240 * *v6;
          do
          {
            if ((*((_BYTE *)v7 + 135) & 4) == 0)
              goto LABEL_14;
            v9 = v7[2];
            if (!v7[2])
            {
              KB::String::compute_length(v7);
              v9 = v7[2];
            }
            if (v9 == 1
              && (*((_QWORD *)v7 + 1) ? (v10 = (const char *)*((_QWORD *)v7 + 1)) : (v10 = (const char *)(v7 + 8)),
                  strcmp(v10, " ")))
            {
              v11 = a1[4];
              v34 = v10;
              LODWORD(v35) = 0;
              HIDWORD(v35) = *v7;
              LODWORD(__p) = 0;
              KB::String::iterator::initialize((uint64_t *)&v34);
              *((_QWORD *)v7 + 17) = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 280))(v11, __p);
            }
            else
            {
LABEL_14:
              v12 = *((_DWORD *)v7 + 26);
              if ((v12 & 0x40000) == 0
                && (*((_BYTE *)v7 + 135) & 4) == 0
                && (v12 & 0x800000) == 0
                && *v7
                && ((*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[4] + 24))(a1[4]) & 1) == 0)
              {
                v13 = a1[4];
                KB::Word::capitalized_string((KB::Word *)v7, (uint64_t)&v34);
                v14 = KB::LanguageModel::id_for_dynamic_engine_word(v13, (unsigned __int16 *)&v34, (uint64_t)(a1 + 3));
                if (v35 && BYTE6(v34) == 1)
                  free(v35);
                *((_QWORD *)v7 + 17) = v14;
                if (!HIDWORD(v14))
                {
                  v15 = *((_DWORD *)v7 + 26);
                  if ((v15 & 0x80020100) == 0 && !*((_QWORD *)v7 + 28))
                    *((_DWORD *)v7 + 26) = v15 | 4;
                }
              }
            }
            v7 += 120;
            v8 -= 240;
          }
          while (v8);
        }
        KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v34, (const KB::LanguageModelContext *)(v6 + 98));
        if (*(_DWORD *)v6)
        {
          v16 = 0;
          v17 = 0;
          do
          {
            if (v16)
            {
              v18 = v6[1];
              v19 = (KB::Word *)(v18 + v16 - 240);
              v20 = (KB::NgramCandidateRefinery *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[4] + 128))(a1[4]);
              if ((_DWORD)v20)
              {
                if (!KB::Word::is_linguistically_void((KB::Word *)(v18 + v16 - 240)))
                {
                  v21 = v18 + v16;
                  v22 = *(TITokenID *)(v21 - 104);
                  KB::Word::capitalized_string(v19, (uint64_t)&v32);
                  v23 = v22;
                  KB::LanguageModelContext::append((KB::LanguageModelContext *)&v34, v23, (const KB::String *)&v32, (*(_DWORD *)(v21 - 136) >> 1) & 1);
                  if (v33)
                  {
                    if (BYTE6(v32) == 1)
                      free(v33);
                  }
                }
              }
              else
              {
                KB::NgramCandidateRefinery::update_context(v20, (KB::LanguageModelContext *)&v34, (const KB::Word *)(v18 + v16 - 240));
              }
            }
            v24 = v6[1];
            v25 = a1[4];
            KB::Word::capitalized_string((KB::Word *)(v24 + v16), (uint64_t)&v32);
            v26 = (*(uint64_t (**)(uint64_t, void ***, _QWORD, const char **, uint64_t))(*(_QWORD *)v25 + 464))(v25, &v32, *(_QWORD *)(v24 + v16 + 136), &v34, a3);
            if (v33)
              v27 = BYTE6(v32) == 1;
            else
              v27 = 0;
            if (v27)
              free(v33);
            if (v26)
              *(_DWORD *)(v24 + v16 + 104) |= 0x40000000u;
            ++v17;
            v16 += 240;
          }
          while (v17 < *(unsigned int *)v6);
        }
        v32 = (void **)v40;
        std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v32);
        language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v39);
        language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v38);
        if (__p)
        {
          v37 = __p;
          operator delete(__p);
        }
        v28 = (std::__shared_weak_count *)v35;
        if (v35)
        {
          v29 = (unint64_t *)((char *)v35 + 8);
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
        v6 += 125;
      }
      while (v6 != v31);
    }
  }
}

void KB::NgramCandidateRefinery::completions_for_completion_stems(KB::NgramCandidateRefinery *a1, const KB::Candidate **a2, uint64_t a3, uint64_t *a4, uint64_t a5, float a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  unsigned int *v15;
  unsigned int *v16;
  uint64_t v17;
  unsigned int **v18;

  v15 = 0;
  v16 = 0;
  v17 = 0;
  std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate *)&v15, *a2, a2[1], 0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3));
  if (((*(uint64_t (**)(KB::NgramCandidateRefinery *))(*(_QWORD *)a1 + 48))(a1) & 1) == 0)
    KB::NgramCandidateRefinery::add_context_weights_batched(a1, &v15);
  v12 = *a4;
  v11 = a4[1];
  v13 = 0x1CAC083126E978D5 * ((v11 - *a4) >> 3);
  if (v16 != v15)
  {
    KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(a1, (uint64_t)&v15, a3, a4, a5, a6);
    v12 = *a4;
    v11 = a4[1];
  }
  for (i = v12 + 1000 * v13; i != v11; i += 1000)
    *(_DWORD *)(i + 992) = 7;
  v18 = &v15;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v18);
}

void KB::NgramCandidateRefinery::predictions_for_prediction_stems(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t **a4, uint64_t a5)
{
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  float *v13;
  float v14;
  float v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  float v20;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
  {
    if (a2[1] != *a2)
      KB::NgramCandidateRefinery::predictions_from_candidate_string_based_lm(a1, (uint64_t)a2, a3, (uint64_t)a4);
    v10 = *a4;
    v11 = a4[1];
    if (*a4 == v11)
    {
      v17 = *a4;
LABEL_14:
      v18 = 126 - 2 * __clz(0x1CAC083126E978D5 * (v10 - v17));
      if (v10 == v17)
        v19 = 0;
      else
        v19 = v18;
      std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,false>(v17, (KB::Candidate *)v10, v19, 1);
    }
    else
    {
      while (1)
      {
        if (*v10)
        {
          v12 = 240 * *v10;
          v13 = (float *)(v10[1] + 52);
          v14 = 1.0;
          do
          {
            v15 = *v13;
            v13 += 60;
            v14 = v14 * v15;
            v12 -= 240;
          }
          while (v12);
        }
        else
        {
          v14 = 1.0;
        }
        v20 = v14;
        v16 = *(_QWORD *)(a5 + 24);
        if (!v16)
          break;
        (*(void (**)(uint64_t, uint64_t *, float *))(*(_QWORD *)v16 + 48))(v16, v10, &v20);
        v10 += 125;
        if (v10 == v11)
        {
          v17 = *a4;
          v10 = a4[1];
          goto LABEL_14;
        }
      }
      std::__throw_bad_function_call[abi:nn180100]();
      KB::NgramCandidateRefinery::inline_predictions_for_completion_stems();
    }
  }
}

void KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(_QWORD *a1@<X0>, const KB::Candidate **a2@<X1>, const KB::LanguageModelContext *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_weak_owners;
  unint64_t v17;
  _QWORD *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  uint64_t *v21;
  unint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t *v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  char *v29;
  _BYTE *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  _OWORD v39[2];
  __int128 v40;
  _OWORD v41[2];
  uint64_t v42;
  int32x2_t *v43[3];
  unsigned __int8 v44;
  void **v45;
  std::__shared_weak_count *v46[2];
  _QWORD v47[3];
  _QWORD *v48;
  _BYTE v49[24];
  _BYTE *v50;
  std::__shared_weak_count *v51;
  std::__shared_weak_count *v52;
  _QWORD v53[3];
  _QWORD *v54;
  std::__shared_weak_count *v55;
  std::__shared_weak_count *v56;
  _QWORD v57[3];
  _QWORD *v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v8 = (std::__shared_weak_count *)a1[2];
  if (!v8 || (v13 = (std::__shared_weak_count *)a1[1], (v14 = std::__shared_weak_count::lock(v8)) == 0))
    std::__throw_bad_weak_ptr[abi:nn180100]();
  v15 = v14;
  v55 = v13;
  v56 = v14;
  p_shared_weak_owners = (unint64_t *)&v14->__shared_weak_owners_;
  do
    v17 = __ldxr(p_shared_weak_owners);
  while (__stxr(v17 + 1, p_shared_weak_owners));
  v18 = v57;
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v57, a5);
  p_shared_owners = (unint64_t *)&v15->__shared_owners_;
  do
    v20 = __ldaxr(p_shared_owners);
  while (__stlxr(v20 - 1, p_shared_owners));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  v51 = v55;
  v52 = v56;
  v21 = &v56->__shared_weak_owners_;
  do
    v22 = __ldxr((unint64_t *)v21);
  while (__stxr(v22 + 1, (unint64_t *)v21));
  v23 = v53;
  if (v58)
  {
    if (v58 == v57)
    {
      v54 = v53;
      (*(void (**)(_QWORD *, _QWORD *))(v57[0] + 24))(v57, v53);
    }
    else
    {
      v54 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v58 + 16))(v58);
    }
  }
  else
  {
    v54 = 0;
  }
  v24 = a1[4];
  v46[0] = v51;
  v46[1] = v52;
  v25 = &v52->__shared_weak_owners_;
  do
    v26 = __ldxr((unint64_t *)v25);
  while (__stxr(v26 + 1, (unint64_t *)v25));
  v27 = v47;
  if (v54)
  {
    if (v54 == v53)
    {
      v48 = v47;
      (*(void (**)(_QWORD *, _QWORD *))(v53[0] + 24))(v53, v47);
      v28 = v48;
    }
    else
    {
      v28 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v54 + 16))(v54);
      v48 = v28;
    }
  }
  else
  {
    v28 = 0;
    v48 = 0;
  }
  v29 = (char *)operator new(0x38uLL);
  v30 = v29;
  *(_QWORD *)v29 = &off_1EA106770;
  *(_OWORD *)(v29 + 8) = *(_OWORD *)v46;
  v46[0] = 0;
  v46[1] = 0;
  if (v28)
  {
    if (v28 == v47)
    {
      *((_QWORD *)v29 + 6) = v29 + 24;
      (*(void (**)(_QWORD *))(v47[0] + 24))(v47);
    }
    else
    {
      *((_QWORD *)v29 + 6) = v28;
      v48 = 0;
    }
  }
  else
  {
    *((_QWORD *)v29 + 6) = 0;
  }
  v50 = v30;
  (*(void (**)(int32x2_t **__return_ptr, uint64_t, const KB::Candidate **, const KB::LanguageModelContext *, uint64_t, _BYTE *))(*(_QWORD *)v24 + 512))(v43, v24, a2, a3, a4, v49);
  v31 = v50;
  if (v50 == v49)
  {
    v32 = 4;
    v31 = v49;
  }
  else
  {
    if (!v50)
      goto LABEL_35;
    v32 = 5;
  }
  (*(void (**)(void))(*v31 + 8 * v32))();
LABEL_35:
  if (v48 == v47)
  {
    v33 = 4;
  }
  else
  {
    if (!v48)
      goto LABEL_40;
    v33 = 5;
    v27 = v48;
  }
  (*(void (**)(_QWORD *))(*v27 + 8 * v33))(v27);
LABEL_40:
  if (v46[1])
    std::__shared_weak_count::__release_weak(v46[1]);
  if (v44)
  {
    HIDWORD(v42) = 0;
    v38 = 0u;
    memset(v39, 0, sizeof(v39));
    v40 = 0u;
    memset(v41, 0, sizeof(v41));
    KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_0::operator()((uint64_t)&v55, v43, *a2, a3, (KB::CandidateCollection *)&v38, 0);
    *(_OWORD *)a6 = v38;
    *(_QWORD *)(a6 + 16) = *(_QWORD *)&v39[0];
    v38 = 0uLL;
    *(_OWORD *)(a6 + 24) = *(_OWORD *)((char *)v39 + 8);
    *(_QWORD *)(a6 + 40) = *((_QWORD *)&v39[1] + 1);
    memset(v39, 0, sizeof(v39));
    *(_OWORD *)(a6 + 48) = v40;
    *(_QWORD *)(a6 + 64) = *(_QWORD *)&v41[0];
    v40 = 0uLL;
    *(_OWORD *)(a6 + 72) = *(_OWORD *)((char *)v41 + 8);
    memset(v41, 0, sizeof(v41));
    v34 = v42;
    *(_QWORD *)(a6 + 88) = *((_QWORD *)&v41[1] + 1);
    *(_QWORD *)(a6 + 96) = v34;
    v45 = (void **)v41 + 1;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v45);
    v45 = (void **)&v40;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v45);
    v45 = (void **)v39 + 1;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v45);
    v45 = (void **)&v38;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v45);
    v35 = v44;
    *(_BYTE *)(a6 + 104) = 1;
    if (v35)
    {
      *(_QWORD *)&v38 = v43;
      std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&v38);
    }
  }
  else
  {
    *(_BYTE *)a6 = 0;
    *(_BYTE *)(a6 + 104) = 0;
  }
  if (v54 == v53)
  {
    v36 = 4;
  }
  else
  {
    if (!v54)
      goto LABEL_51;
    v36 = 5;
    v23 = v54;
  }
  (*(void (**)(_QWORD *))(*v23 + 8 * v36))(v23);
LABEL_51:
  if (v52)
    std::__shared_weak_count::__release_weak(v52);
  if (v58 == v57)
  {
    v37 = 4;
  }
  else
  {
    if (!v58)
      goto LABEL_58;
    v37 = 5;
    v18 = v58;
  }
  (*(void (**)(_QWORD *))(*v18 + 8 * v37))(v18);
LABEL_58:
  if (v56)
    std::__shared_weak_count::__release_weak(v56);
}

uint64_t KB::NgramCandidateRefinery::register_inline_completion_acceptance_rejection(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 520))(*(_QWORD *)(a1 + 32));
}

uint64_t KB::NgramCandidateRefinery::get_num_candidates@<X0>(uint64_t result@<X0>, int a2@<W1>, _BYTE *a3@<X8>)
{
  uint64_t v4;

  if (a2 == 5)
  {
    v4 = result;
    result = *(_QWORD *)(result + 32);
    if (result)
    {
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
      if ((result & 1) != 0)
        return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 32) + 200))(*(_QWORD *)(v4 + 32), 5);
    }
  }
  *a3 = 0;
  a3[16] = 0;
  return result;
}

uint64_t KB::NgramCandidateRefinery::dictionary(KB::NgramCandidateRefinery *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t KB::NgramCandidateRefinery::lexicon_id_vector(KB::NgramCandidateRefinery *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 48))(*((_QWORD *)this + 4));
}

void KB::NgramCandidateRefinery::clean_favonius_generated_candidates(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v6;
  uint64_t *v7;

  v3 = *(uint64_t **)a2;
  v4 = *(uint64_t **)(a2 + 8);
  if (*(uint64_t **)a2 == v4)
    goto LABEL_13;
  v6 = *(uint64_t **)(a2 + 8);
  while ((*(unsigned int (**)(_QWORD, uint64_t *))(**(_QWORD **)(a1 + 32) + 176))(*(_QWORD *)(a1 + 32), v3))
  {
    v3 += 125;
    if (v3 == v4)
      goto LABEL_14;
  }
  if (v3 != v4)
  {
    v7 = v3 + 125;
    if (v3 + 125 != v4)
    {
      v6 = v3;
      do
      {
        if ((*(unsigned int (**)(_QWORD, uint64_t *))(**(_QWORD **)(a1 + 32) + 176))(*(_QWORD *)(a1 + 32), v7))
        {
          KB::Candidate::operator=(v6, v7);
          v6 += 125;
        }
        v7 += 125;
      }
      while (v7 != v4);
      goto LABEL_14;
    }
LABEL_13:
    v6 = v3;
  }
LABEL_14:
  std::vector<KB::Candidate>::erase(a2, v6, *(KB::Candidate **)(a2 + 8));
}

void KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_0::operator()(uint64_t a1, int32x2_t **a2, const KB::Candidate *a3, const KB::LanguageModelContext *a4, KB::CandidateCollection *a5, char a6)
{
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v13;
  KB::NgramCandidateRefinery *v14;
  int32x2_t *v15;
  int32x2_t *i;
  uint64_t v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  _QWORD v20[127];

  v20[125] = *MEMORY[0x1E0C80C00];
  v11 = *(std::__shared_weak_count **)(a1 + 8);
  if (v11)
  {
    v13 = std::__shared_weak_count::lock(v11);
    if (v13)
    {
      v14 = *(KB::NgramCandidateRefinery **)a1;
      if (*(_QWORD *)a1)
      {
        v15 = *a2;
        for (i = a2[1]; v15 != i; v15 += 20)
        {
          KB::Candidate::Candidate((KB::Candidate *)v20, a3);
          while (v20[0] && !KB::Word::is_linguistically_void((KB::Word *)(v20[1] + 240 * v20[0] - 240)))
            KB::Candidate::pop_last_word((KB::Candidate *)v20);
          KB::NgramCandidateRefinery::post_processing_predictions(v14, v15, (const KB::Candidate *)v20, a4, a5);
          KB::Candidate::~Candidate((KB::Candidate *)v20);
        }
      }
    }
  }
  else
  {
    v13 = 0;
  }
  LOBYTE(v20[0]) = a6;
  v17 = *(_QWORD *)(a1 + 40);
  if (!v17)
    std::__throw_bad_function_call[abi:nn180100]();
  (*(void (**)(uint64_t, KB::CandidateCollection *, const KB::Candidate *, const KB::LanguageModelContext *, _QWORD *))(*(_QWORD *)v17 + 48))(v17, a5, a3, a4, v20);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

uint64_t KB::NgramCandidateRefinery::post_processing_predictions(KB::NgramCandidateRefinery *this, int32x2_t *a2, const KB::Candidate *a3, const KB::LanguageModelContext *a4, KB::CandidateCollection *a5)
{
  uint64_t v8;
  unint64_t i;
  KB::StaticDictionary **v10;
  const char *v11;
  int v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unsigned __int16 *v19;
  uint64_t v20;
  int v21;
  TITokenID v22;
  TITokenID v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  void **v33;
  std::__shared_weak_count *v34;
  unint64_t *p_shared_owners;
  unint64_t v36;
  _BYTE v39[8];
  std::__shared_weak_count *v40;
  void *__p;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  unsigned int v48;
  int v49;
  __int16 v50;
  char v51;
  void *v52;
  char v53;
  int v54;
  void **v55[6];
  int v56;
  _DWORD v57[10];
  unsigned int v58;
  int v59;
  TITokenID v60;
  uint64_t v61;
  uint64_t v62;
  char v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  KB::Candidate::Candidate((KB::Candidate *)&v61, a3);
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v39, a4);
  if (a2[18].i8[4])
    v63 = 1;
  if (*(_QWORD *)&a2[13] != *(_QWORD *)&a2[12])
  {
    v8 = 0;
    for (i = 0; 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)&a2[13] - *(_QWORD *)&a2[12]) >> 3) > i; ++i)
    {
      v10 = (KB::StaticDictionary **)(*(uint64_t (**)(KB::NgramCandidateRefinery *))(*(_QWORD *)this + 120))(this);
      v11 = (const char *)(*(_QWORD *)&a2[12] + v8);
      if (v11[23] < 0)
        v11 = *(const char **)v11;
      KB::String::String((KB::String *)&v49, v11);
      if (a2[18].i8[4])
        v12 = 0;
      else
        v12 = a2[18].i32[0];
      KB::DictionaryContainer::word_with_string_exhaustive(v10, (const KB::String *)&v49, v12, (KB::Word *)v55);
      if (v52 && v51 == 1)
        free(v52);
      if (v60.lexicon_id == -2)
        v60.lexicon_id = a2[18].u32[0];
      v13 = a2[18].u8[6];
      if (!LOWORD(v55[0]) && !a2[18].i8[6])
      {
        KB::Word::~Word((KB::Word *)v55);
LABEL_58:
        v27 = 0;
        goto LABEL_70;
      }
      if (a2[18].i8[5])
        v58 = v58 & 0xFFFBFE7B | 0x100;
      if (v13)
        v58 |= 0x200u;
      v14 = (const char *)(*(_QWORD *)&a2[15] + v8);
      if (v14[23] < 0)
        v14 = *(const char **)v14;
      KB::String::String((KB::String *)&v49, v14);
      KB::String::operator=((KB::String *)v55, (KB::String *)&v49);
      if (v52 && v51 == 1)
        free(v52);
      v58 = v58 & 0xFAFFFFFF | ((a2[5].i32[0] & 1) << 24) & 0xFBFFFFFF | ((((unsigned __int32)a2[5].i32[0] >> 1) & 1) << 26);
      if (a2[11].i8[7] >= 0)
        v15 = (const char *)&a2[9];
      else
        v15 = (const char *)a2[9];
      KB::String::String((KB::String *)&v49, v15);
      KB::String::operator=((KB::String *)v57, (KB::String *)&v49);
      if (v52 && v51 == 1)
        free(v52);
      v57[8] = (*(float (**)(_QWORD, _QWORD, _BYTE *))(**((_QWORD **)this + 4) + 432))(*((_QWORD *)this + 4), v60.lexicon_id, v39);
      v16 = *((_QWORD *)this + 4);
      KB::Word::capitalized_string((KB::Word *)v55, (uint64_t)&v49);
      v17 = (*(uint64_t (**)(uint64_t, int *, uint64_t, _BYTE *, char *, uint64_t))(*(_QWORD *)v16 + 472))(v16, &v49, 0xFFFFFFFFLL, v39, (char *)this + 24, 1);
      if (v52 && v51 == 1)
        free(v52);
      if (v17)
        v58 |= 0x40000000u;
      v18 = (*(uint64_t (**)(KB::NgramCandidateRefinery *))(*(_QWORD *)this + 120))(this);
      v50 = 0;
      v51 = 0;
      v52 = ".,;:!?";
      v49 = 1048582;
      v53 = 0;
      if (v61)
      {
        if ((*(_BYTE *)(v62 + 240 * (v61 - 1) + 135) & 4) != 0)
        {
          if ((v59 & 0x4000000) != 0)
            goto LABEL_50;
          v19 = (unsigned __int16 *)(v62 + 240 * (v61 - 1));
          v20 = *((_QWORD *)v19 + 1);
          if (!v20)
            v20 = (uint64_t)(v19 + 8);
          v46 = v20;
          v21 = *v19;
          LODWORD(v47) = 0;
          HIDWORD(v47) = v21;
          v48 = 0;
          KB::String::iterator::initialize(&v46);
          if (!KB::String::contains((KB::String *)&v49, v48))
            goto LABEL_50;
LABEL_46:
          WORD2(v46) = 0;
          BYTE6(v46) = 0;
          v47 = " ";
          LODWORD(v46) = 1048577;
          BYTE1(v48) = 0;
          KB::Word::Word((KB::Word *)&v49, (const KB::String *)&v46, &kTITokenIDUNK, 0);
          if (v47 && BYTE6(v46) == 1)
            free(v47);
          v54 |= 0x4000000u;
          KB::Candidate::append((unsigned __int16 *)&v61, (const KB::Word *)&v49);
          KB::Word::~Word((KB::Word *)&v49);
          goto LABEL_50;
        }
        if ((v59 & 0x4000000) == 0 && !*(_BYTE *)(v18 + 64))
          goto LABEL_46;
      }
LABEL_50:
      v56 = 1065353216;
      KB::Candidate::append((unsigned __int16 *)&v61, (const KB::Word *)v55);
      v22 = v60;
      KB::Word::capitalized_string((KB::Word *)v55, (uint64_t)&v49);
      v23 = v22;
      KB::LanguageModelContext::append((KB::LanguageModelContext *)v39, v23, (const KB::String *)&v49, (v58 >> 1) & 1);
      if (v52 && v51 == 1)
        free(v52);
      KB::Word::~Word((KB::Word *)v55);
      v8 += 24;
    }
  }
  if (!v61)
    goto LABEL_58;
  *(int32x2_t *)(v62 + 240 * v61 - 188) = vdup_lane_s32(a2[3], 0);
  v24 = *((_QWORD *)a5 + 2);
  v25 = *((_QWORD *)a5 + 1);
  if (v25 >= v24)
  {
    v28 = 0x1CAC083126E978D5 * ((uint64_t)(v25 - *(_QWORD *)a5) >> 3);
    if ((unint64_t)(v28 + 1) > 0x4189374BC6A7EFLL)
      abort();
    v29 = 0x1CAC083126E978D5 * ((uint64_t)(v24 - *(_QWORD *)a5) >> 3);
    v30 = 2 * v29;
    if (2 * v29 <= v28 + 1)
      v30 = v28 + 1;
    if (v29 >= 0x20C49BA5E353F7)
      v31 = 0x4189374BC6A7EFLL;
    else
      v31 = v30;
    v55[4] = (void **)((char *)a5 + 16);
    if (v31)
      v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v31);
    else
      v32 = 0;
    v33 = (void **)(v31 + 1000 * v28);
    v55[0] = (void **)v31;
    v55[1] = v33;
    v55[3] = (void **)(v31 + 1000 * v32);
    KB::Candidate::Candidate((uint64_t)v33, (uint64_t)&v61);
    v55[2] = v33 + 125;
    std::vector<KB::Candidate>::__swap_out_circular_buffer((uint64_t *)a5, v55);
    v26 = *((_QWORD *)a5 + 1);
    std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)v55);
  }
  else
  {
    v26 = KB::Candidate::Candidate(v25, (uint64_t)&v61) + 1000;
  }
  *((_QWORD *)a5 + 1) = v26;
  v27 = 1;
LABEL_70:
  v55[0] = (void **)&v45;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v55);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v44);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v43);
  if (__p)
  {
    v42 = __p;
    operator delete(__p);
  }
  v34 = v40;
  if (v40)
  {
    p_shared_owners = (unint64_t *)&v40->__shared_owners_;
    do
      v36 = __ldaxr(p_shared_owners);
    while (__stlxr(v36 - 1, p_shared_owners));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  KB::Candidate::~Candidate((KB::Candidate *)&v61);
  return v27;
}

_QWORD *std::__function::__func<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1,std::allocator<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1>,void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  *a1 = &off_1EA106770;
  v2 = a1 + 3;
  v3 = (_QWORD *)a1[6];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  return a1;
}

void std::__function::__func<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1,std::allocator<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1>,void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  *a1 = &off_1EA106770;
  v2 = a1 + 3;
  v3 = (_QWORD *)a1[6];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1,std::allocator<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1>,void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = operator new(0x38uLL);
  v3 = v2;
  v5 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  *v2 = &off_1EA106770;
  v2[1] = v5;
  v2[2] = v4;
  if (v4)
  {
    v6 = (unint64_t *)(v4 + 16);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)(v2 + 3), a1 + 24);
  return v3;
}

uint64_t std::__function::__func<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1,std::allocator<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1>,void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  *a2 = &off_1EA106770;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)(a2 + 3), a1 + 24);
}

void std::__function::__func<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1,std::allocator<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1>,void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::destroy(uint64_t a1)
{
  std::__function::__alloc_func<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1,std::allocator<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1>,void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::destroy[abi:nn180100](a1 + 8);
}

void std::__function::__func<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1,std::allocator<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1>,void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::destroy_deallocate(void *a1)
{
  std::__function::__alloc_func<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1,std::allocator<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1>,void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::destroy[abi:nn180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1,std::allocator<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1>,void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::operator()(uint64_t a1, int32x2_t **a2, const KB::Candidate *a3, const KB::LanguageModelContext *a4)
{
  _OWORD v4[3];
  _OWORD v5[3];
  int v6;
  void **v7;

  v6 = 0;
  memset(v4, 0, sizeof(v4));
  memset(v5, 0, sizeof(v5));
  KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_0::operator()(a1 + 8, a2, a3, a4, (KB::CandidateCollection *)v4, 1);
  v7 = (void **)&v5[1] + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v7);
  v7 = (void **)v5;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v7);
  v7 = (void **)&v4[1] + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v7);
  v7 = (void **)v4;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v7);
}

void std::__function::__alloc_func<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1,std::allocator<KB::NgramCandidateRefinery::inline_predictions_for_completion_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>)::$_1>,void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::destroy[abi:nn180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  v2 = (_QWORD *)(a1 + 16);
  v3 = *(_QWORD **)(a1 + 40);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

_QWORD *KB::NgramCandidateRefinery::predictions_from_candidate_string_based_lm(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *result;
  uint64_t v6;
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  v7[0] = &off_1EA1067B8;
  v7[1] = a1;
  v7[2] = a4;
  v8 = v7;
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD *, uint64_t))(*(_QWORD *)v4 + 488))(v4, a2, a3, v7, 1);
  result = v8;
  if (v8 == v7)
  {
    v6 = 4;
    result = v7;
  }
  else
  {
    if (!v8)
      return result;
    v6 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v6))();
}

void std::__function::__func<KB::NgramCandidateRefinery::predictions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<KB::NgramCandidateRefinery::predictions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::NgramCandidateRefinery::predictions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<KB::NgramCandidateRefinery::predictions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA1067B8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::NgramCandidateRefinery::predictions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<KB::NgramCandidateRefinery::predictions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA1067B8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::NgramCandidateRefinery::predictions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<KB::NgramCandidateRefinery::predictions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::operator()(uint64_t a1, int32x2_t *a2, const KB::Candidate *a3, const KB::LanguageModelContext *a4)
{
  return KB::NgramCandidateRefinery::post_processing_predictions(*(KB::NgramCandidateRefinery **)(a1 + 8), a2, a3, a4, *(KB::CandidateCollection **)(a1 + 16));
}

void KB::NgramCandidateRefinery::add_context_weights_batched(KB::NgramCandidateRefinery *a1, unsigned int **a2)
{
  unsigned int *v2;
  char *v4;
  char *v5;
  unint64_t v6;
  KB::Word *v7;
  KB::Word *v8;
  __int16 v9;
  uint64_t v10;
  _BOOL4 is_linguistically_void;
  _BOOL4 v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  char *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  char *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  int64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  __int128 v41;
  char *v42;
  char *v43;
  void *v44;
  void *v45;
  const __CFString *Mutable;
  unsigned int *v47;
  unsigned int *v48;
  uint64_t v49;
  unsigned int *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  int v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  unsigned int *v63;
  _QWORD v64[3];
  char *v65;
  char *v66;
  char *v67;
  void **v68;
  void *v69;
  char **v70;
  void *v71;
  void *__p;
  void *v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD v76[5];

  v76[3] = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  v63 = a2[1];
  if (*a2 == v63)
    return;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  do
  {
    if (*(_QWORD *)v2)
    {
      v4 = 0;
      v5 = 0;
      v6 = 0;
      v7 = (KB::Word *)*((_QWORD *)v2 + 1);
      v8 = (KB::Word *)((char *)v7 + 240 * *(_QWORD *)v2);
      do
      {
        if (v2[248] == 7)
        {
          v9 = 0;
          v2[248] = 1;
        }
        else if ((KB::NgramCandidateRefinery::should_not_score_token(a1, v7) & 1) != 0)
        {
          v9 = 0;
        }
        else
        {
          v10 = *((_QWORD *)a1 + 4);
          KB::Word::capitalized_string(v7, (uint64_t)&v70);
          v68 = (void **)*((_QWORD *)v7 + 17);
          v9 = (*(uint64_t (**)(uint64_t, char ***, void ***))(*(_QWORD *)v10 + 384))(v10, &v70, &v68);
          if (v71 && BYTE6(v70) == 1)
            free(v71);
        }
        is_linguistically_void = KB::Word::is_linguistically_void(v7);
        v12 = is_linguistically_void;
        if ((unint64_t)v5 >= v6)
        {
          v14 = v5 - v4;
          if (v5 - v4 <= -3)
            goto LABEL_108;
          v15 = v14 >> 1;
          if (v6 - (unint64_t)v4 <= (v14 >> 1) + 1)
            v16 = v15 + 1;
          else
            v16 = v6 - (_QWORD)v4;
          if (v6 - (unint64_t)v4 >= 0x7FFFFFFFFFFFFFFELL)
            v17 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v17 = v16;
          if (v17)
            v17 = (uint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(v17);
          else
            v18 = 0;
          v19 = (char *)(v17 + 2 * v15);
          if (v12)
            v20 = 256;
          else
            v20 = 0;
          *(_WORD *)v19 = v20 | v9;
          v21 = v19 + 2;
          while (v5 != v4)
          {
            v22 = *((_WORD *)v5 - 1);
            v5 -= 2;
            *((_WORD *)v19 - 1) = v22;
            v19 -= 2;
          }
          v6 = v17 + 2 * v18;
          if (v4)
            operator delete(v4);
          v4 = v19;
          v5 = v21;
        }
        else
        {
          if (is_linguistically_void)
            v13 = 256;
          else
            v13 = 0;
          *(_WORD *)v5 = v13 | v9;
          v5 += 2;
        }
        v7 = (KB::Word *)((char *)v7 + 240);
      }
      while (v7 != v8);
      v24 = v66;
      v23 = v67;
      if (v66 < v67)
      {
        *(_QWORD *)v66 = 0;
        *((_QWORD *)v24 + 1) = 0;
        *((_QWORD *)v24 + 2) = 0;
        v25 = v5 - v4;
        if (v5 != v4)
        {
          std::vector<language_modeling::v1::TokenMetadata>::__vallocate[abi:nn180100](v24, v25 >> 1);
          v26 = (char *)*((_QWORD *)v24 + 1);
          memmove(v26, v4, v5 - v4);
          *((_QWORD *)v24 + 1) = &v26[v25];
        }
        goto LABEL_42;
      }
    }
    else
    {
      v24 = v66;
      v23 = v67;
      if (v66 < v67)
      {
        v4 = 0;
        *(_QWORD *)v66 = 0;
        *((_QWORD *)v24 + 1) = 0;
        *((_QWORD *)v24 + 2) = 0;
LABEL_42:
        v27 = v24 + 24;
        goto LABEL_65;
      }
      v5 = 0;
      v4 = 0;
    }
    v28 = 0xAAAAAAAAAAAAAAABLL * ((v24 - v65) >> 3);
    v29 = v28 + 1;
    if (v28 + 1 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_108;
    v30 = 0xAAAAAAAAAAAAAAABLL * ((v23 - v65) >> 3);
    if (2 * v30 > v29)
      v29 = 2 * v30;
    if (v30 >= 0x555555555555555)
      v31 = 0xAAAAAAAAAAAAAAALL;
    else
      v31 = v29;
    if (v31)
    {
      v32 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v31);
      v34 = v33;
    }
    else
    {
      v32 = 0;
      v34 = 0;
    }
    v35 = &v32[8 * ((v24 - v65) >> 3)];
    *(_QWORD *)v35 = 0;
    *((_QWORD *)v35 + 1) = 0;
    *((_QWORD *)v35 + 2) = 0;
    v36 = v5 - v4;
    if (v36)
    {
      v37 = &v32[24 * v28];
      std::vector<language_modeling::v1::TokenMetadata>::__vallocate[abi:nn180100](v35, v36 >> 1);
      v38 = (char *)*((_QWORD *)v37 + 1);
      memmove(v38, v4, v36);
      *((_QWORD *)v37 + 1) = &v38[v36];
    }
    v27 = v35 + 24;
    v40 = v65;
    v39 = v66;
    if (v66 == v65)
    {
      v65 = v35;
      v66 = v35 + 24;
      v67 = &v32[24 * v34];
      if (v39)
        goto LABEL_64;
    }
    else
    {
      do
      {
        *((_QWORD *)v35 - 3) = 0;
        *((_QWORD *)v35 - 2) = 0;
        v35 -= 24;
        *((_QWORD *)v35 + 2) = 0;
        v41 = *(_OWORD *)(v39 - 24);
        v39 -= 24;
        *(_OWORD *)v35 = v41;
        *((_QWORD *)v35 + 2) = *((_QWORD *)v39 + 2);
        *(_QWORD *)v39 = 0;
        *((_QWORD *)v39 + 1) = 0;
        *((_QWORD *)v39 + 2) = 0;
      }
      while (v39 != v40);
      v42 = v65;
      v39 = v66;
      v65 = v35;
      v66 = v27;
      v67 = &v32[24 * v34];
      if (v39 != v42)
      {
        v43 = v39;
        do
        {
          v45 = (void *)*((_QWORD *)v43 - 3);
          v43 -= 24;
          v44 = v45;
          if (v45)
          {
            *((_QWORD *)v39 - 2) = v44;
            operator delete(v44);
          }
          v39 = v43;
        }
        while (v43 != v42);
        v39 = v42;
      }
      if (v39)
LABEL_64:
        operator delete(v39);
    }
LABEL_65:
    v66 = v27;
    if (v4)
      operator delete(v4);
    v2 += 250;
  }
  while (v2 != v63);
  if (a2[1] == *a2)
LABEL_108:
    abort();
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v70, (const KB::LanguageModelContext *)(*a2 + 196));
  if (s_trace_logging_enabled)
    Mutable = CFStringCreateMutable(0, 0);
  else
    Mutable = 0;
  KB::NgramCandidateRefinery::context_probability_of_batched_word((uint64_t)a1, a2, (uint64_t)&v65, (uint64_t)&v70, (uint64_t)Mutable, v64);
  v48 = *a2;
  v47 = a2[1];
  if (v47 == *a2)
    goto LABEL_97;
  v49 = 0;
  while (2)
  {
    v50 = &v48[250 * v49];
    if (!*(_QWORD *)v50)
      goto LABEL_96;
    v51 = 0;
    v52 = 0;
    v53 = 0;
    v54 = 0;
    while (2)
    {
      if (*(_BYTE *)(*(_QWORD *)&v65[24 * v49] + v51))
      {
        v55 = *((_QWORD *)v50 + 1);
        v56 = *(_QWORD *)(v64[0] + 24 * v49) + v52;
        *(_QWORD *)(v55 + v53 + 52) = *(_QWORD *)v56;
        v57 = (const char *)(v56 + 16);
        if (*(char *)(v56 + 39) < 0)
          v57 = *(const char **)v57;
        KB::String::String((KB::String *)&v68, v57);
        KB::String::operator=((KB::String *)(v55 + v53 + 64), (KB::String *)&v68);
        if (v69 && BYTE6(v68) == 1)
          free(v69);
        v58 = *(_DWORD *)(*(_QWORD *)(v64[0] + 24 * v49) + v52 + 8);
        if ((v58 & 1) != 0)
        {
          *(_DWORD *)(v55 + v53 + 104) |= 0x1000000u;
          if ((v58 & 2) != 0)
            goto LABEL_90;
LABEL_87:
          if (Mutable)
          {
LABEL_91:
            KB::utf8_string(Mutable, (uint64_t)&v68);
            KB::String::operator=((KB::String *)(v55 + v53 + 160), (KB::String *)&v68);
            if (v69 && BYTE6(v68) == 1)
              free(v69);
          }
        }
        else
        {
          if ((v58 & 2) == 0)
            goto LABEL_87;
LABEL_90:
          *(_DWORD *)(v55 + v53 + 104) |= 0x4000000u;
          if (Mutable)
            goto LABEL_91;
        }
      }
      ++v54;
      v53 += 240;
      v52 += 40;
      v51 += 2;
      if (v54 < *(_QWORD *)v50)
        continue;
      break;
    }
    v48 = *a2;
    v47 = a2[1];
LABEL_96:
    if (++v49 < (unint64_t)(0x1CAC083126E978D5 * (((char *)v47 - (char *)v48) >> 3)))
      continue;
    break;
  }
LABEL_97:
  v68 = (void **)v64;
  std::vector<std::vector<KB::LikelihoodInfo>>::__destroy_vector::operator()[abi:nn180100](&v68);
  if (Mutable)
    CFRelease(Mutable);
  v68 = (void **)v76;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v68);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v75);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v74);
  if (__p)
  {
    v73 = __p;
    operator delete(__p);
  }
  v59 = (std::__shared_weak_count *)v71;
  if (v71)
  {
    v60 = (unint64_t *)((char *)v71 + 8);
    do
      v61 = __ldaxr(v60);
    while (__stlxr(v61 - 1, v60));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }
  v70 = &v65;
  std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v70);
}

_QWORD *KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, float a6)
{
  _QWORD *result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  _BYTE v21[24];
  _BYTE *v22;
  _QWORD v23[3];
  _QWORD *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v20 = a6;
  result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
  if (!(_DWORD)result)
    return result;
  v19 = 0x1CAC083126E978D5 * ((uint64_t)(a4[1] - *a4) >> 3);
  v12 = (*(uint64_t (**)(_QWORD *))(*a1 + 120))(a1);
  v13 = a1[4];
  v14 = *(_QWORD *)(v12 + 8) + 112;
  v23[0] = &off_1EA106800;
  v23[1] = a1;
  v23[2] = a4;
  v24 = v23;
  v15 = operator new(0x30uLL);
  *v15 = &off_1EA106848;
  v15[1] = v14;
  v15[2] = a4;
  v15[3] = &v19;
  v15[4] = a1;
  v15[5] = &v20;
  v22 = v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD *, _BYTE *, uint64_t))(*(_QWORD *)v13 + 496))(v13, a2, a3, v23, v21, a5);
  v16 = v22;
  if (v22 == v21)
  {
    v17 = 4;
    v16 = v21;
    goto LABEL_6;
  }
  if (v22)
  {
    v17 = 5;
LABEL_6:
    (*(void (**)(void))(*v16 + 8 * v17))();
  }
  result = v24;
  if (v24 == v23)
  {
    v18 = 4;
    result = v23;
  }
  else
  {
    if (!v24)
      return result;
    v18 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v18))();
}

void std::__function::__func<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0,std::allocator<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0>,BOOL ()(KB::Candidate const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0,std::allocator<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0>,BOOL ()(KB::Candidate const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1EA106848;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0,std::allocator<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0>,BOOL ()(KB::Candidate const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1EA106848;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0,std::allocator<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0>,BOOL ()(KB::Candidate const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  KB::Candidate *v8;
  KB::Candidate *v9;
  uint64_t *i;
  uint64_t *v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  int v18;
  unsigned int v19;
  int v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  uint64_t v27;
  float *v28;
  float v29;
  float v30;
  float v31;
  uint64_t *v32;
  unint64_t v33;
  uint64_t v35;
  KB::Candidate *v36;
  uint64_t v37;
  int v38;
  _QWORD v39[4];
  uint64_t v40;
  uint64_t v41;
  int v42;

  v42 = *(_QWORD *)a2;
  v4 = *(_QWORD *)(a1 + 8);
  if (!*(_WORD *)(a2 + 888))
    KB::Candidate::compute_string((KB::Candidate *)a2);
  v5 = *(_QWORD *)(v4 + 24);
  if (v5)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v5 + 48))(&v40, v5, a2 + 888);
    v6 = *(_QWORD **)(a1 + 16);
    v7 = *(_QWORD *)(a1 + 8);
    v8 = (KB::Candidate *)v6[1];
    v9 = (KB::Candidate *)(*v6 + 1000 * **(_QWORD **)(a1 + 24));
    v39[0] = a2;
    v39[1] = v7;
    v39[2] = &v40;
    v39[3] = &v42;
    if (v9 != v8)
    {
      while ((KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0::operator() const(KB::Candidate const&)::{lambda(KB::Candidate const&)#1}::operator()((uint64_t)v39, v9) & 1) == 0)
      {
        v9 = (KB::Candidate *)((char *)v9 + 1000);
        if (v9 == v8)
        {
          v9 = v8;
          goto LABEL_14;
        }
      }
      if (v9 != v8)
      {
        for (i = (uint64_t *)((char *)v9 + 1000); i != (uint64_t *)v8; i += 125)
        {
          if ((KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0::operator() const(KB::Candidate const&)::{lambda(KB::Candidate const&)#1}::operator()((uint64_t)v39, (KB::Candidate *)i) & 1) == 0)
          {
            KB::Candidate::operator=((uint64_t *)v9, i);
            v9 = (KB::Candidate *)((char *)v9 + 1000);
          }
        }
      }
    }
LABEL_14:
    std::vector<KB::Candidate>::erase((uint64_t)v6, (uint64_t *)v9, *(KB::Candidate **)(*(_QWORD *)(a1 + 16) + 8));
    v11 = *(uint64_t **)(a1 + 16);
    v12 = *(unint64_t **)(a1 + 24);
    v13 = *v11;
    v14 = v11[1];
    v15 = *v12;
    v16 = *v12 + 10;
    if (0x1CAC083126E978D5 * ((v14 - *v11) >> 3) > v16)
    {
      std::vector<KB::Candidate>::resize(v11, v16);
      v17 = *(uint64_t **)(a1 + 16);
      v12 = *(unint64_t **)(a1 + 24);
      v15 = *v12;
      v13 = *v17;
      v14 = v17[1];
    }
    if (v13 + 1000 * v15 != v14)
    {
      v14 = v13 + 1000 * v15;
      while (1)
      {
        if (!*(_WORD *)(v14 + 888))
          KB::Candidate::compute_string((KB::Candidate *)v14);
        v18 = *(unsigned __int16 *)(v14 + 892);
        if (!*(_WORD *)(v14 + 892))
        {
          KB::String::compute_length((unsigned __int16 *)(v14 + 888));
          v18 = *(unsigned __int16 *)(v14 + 892);
        }
        if (!*(_WORD *)(a2 + 888))
          KB::Candidate::compute_string((KB::Candidate *)a2);
        v19 = *(unsigned __int16 *)(a2 + 892);
        if (!*(_WORD *)(a2 + 892))
        {
          KB::String::compute_length((unsigned __int16 *)(a2 + 888));
          v19 = *(unsigned __int16 *)(a2 + 892);
        }
        v20 = v18 - v19;
        *(_DWORD *)(*(_QWORD *)(v14 + 8) + 240 * *(_QWORD *)v14 - 96) = v20;
        *(_BYTE *)(v14 + 960) = 1;
        v21 = *(float *)(a2 + 748);
        v22 = *(float *)(a2 + 756);
        v23 = *(float *)(a2 + 760);
        v37 = *(_QWORD *)(a2 + 764);
        v38 = *(_DWORD *)(a2 + 772);
        if (*(_WORD *)(a2 + 888))
        {
          if (!v19)
            goto LABEL_34;
        }
        else
        {
          KB::Candidate::compute_string((KB::Candidate *)a2);
          v19 = *(unsigned __int16 *)(a2 + 892);
          if (!*(_WORD *)(a2 + 892))
          {
LABEL_34:
            KB::String::compute_length((unsigned __int16 *)(a2 + 888));
            v19 = *(unsigned __int16 *)(a2 + 892);
          }
        }
        v24 = **(float **)(a1 + 40);
        if (v20 < 1)
        {
          v25 = 0.0;
        }
        else
        {
          if (v19 >= 5)
            v19 = 5;
          v25 = logf(TI::Favonius::SearchParameters::k_prediction_costs[v19]) + 0.0;
          if (v20 != 1)
            v25 = v25 + (float)((float)(v20 - 1) * -0.22314);
        }
        v26 = 1.0;
        if (*(_QWORD *)v14)
        {
          v27 = 240 * *(_QWORD *)v14;
          v28 = (float *)(*(_QWORD *)(v14 + 8) + 52);
          do
          {
            v29 = *v28;
            v28 += 60;
            v26 = v26 * v29;
            v27 -= 240;
          }
          while (v27);
        }
        v30 = v21 + (float)((float)(1.0 - v24) * (float)(v25 * v23));
        v31 = logf(v26);
        *(float *)(v14 + 748) = v30;
        *(float *)(v14 + 752) = v31;
        *(float *)(v14 + 756) = v22;
        *(float *)(v14 + 760) = v23;
        *(_DWORD *)(v14 + 772) = v38;
        *(_QWORD *)(v14 + 764) = v37;
        *(float *)(v14 + 744) = v30 + (float)(v23 * (float)(v22 + v31));
        v14 += 1000;
        v32 = *(uint64_t **)(a1 + 16);
        if (v14 == v32[1])
        {
          v12 = *(unint64_t **)(a1 + 24);
          v15 = *v12;
          v13 = *v32;
          break;
        }
      }
    }
    v33 = 0x1CAC083126E978D5 * ((v14 - v13) >> 3);
    *v12 = v33;
    if ((unsigned __int16)v40 >= 0xFu)
    {
      if (v41)
        MEMORY[0x1DF0A212C](v41, 0x1000C8077774924);
    }
    return v15 < v33;
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    return KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0::operator() const(KB::Candidate const&)::{lambda(KB::Candidate const&)#1}::operator()(v35, v36);
  }
}

uint64_t KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_0::operator() const(KB::Candidate const&)::{lambda(KB::Candidate const&)#1}::operator()(uint64_t a1, KB::Candidate *a2)
{
  uint64_t v3;
  KB::Candidate *v4;
  const ByteString *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  _BOOL8 v10;
  KB::NgramCandidateRefinery *v12;
  int v13;
  int v14;
  float v15;
  float v16;
  uint64_t v17;
  void *v18;
  _BYTE v19[6];
  char v20;
  void *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = *(KB::Candidate **)a1;
  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(const ByteString **)(a1 + 16);
  v6 = **(unsigned int **)(a1 + 24);
  if (!*((_WORD *)a2 + 444))
  {
    KB::Candidate::compute_string(a2);
    if (!*((_WORD *)a2 + 444))
      return 1;
  }
  KB::Candidate::capitalized_string(a2, (uint64_t)v19);
  KB::Candidate::capitalized_string(v4, (uint64_t)&v17);
  v7 = KB::string_preserves_surface_form_features_of_prefix((const KB::String *)v19, (const KB::String *)&v17, v5, v3);
  if (v18 && BYTE6(v17) == 1)
    free(v18);
  if (v21 && v20 == 1)
    free(v21);
  if (!v7)
    return 1;
  KB::Candidate::capitalized_string(a2, (uint64_t)v19);
  v8 = *(_QWORD *)(v3 + 24);
  if (v8)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t, _BYTE *))(*(_QWORD *)v8 + 48))(&v17, v8, v19);
    if (v21 && v20 == 1)
      free(v21);
    v10 = (unsigned __int16)v17 <= v5->var0.var0.var0 && (unint64_t)(v6 + 1) >= *(_QWORD *)a2;
    if ((unsigned __int16)v17 >= 0xFu)
    {
      if (v18)
        MEMORY[0x1DF0A212C](v18, 0x1000C8077774924);
    }
    return v10;
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return KB::NgramCandidateRefinery::long_prediction_geometric_log_likelihood(v12, v13, v14, v15, v16);
}

float KB::NgramCandidateRefinery::long_prediction_geometric_log_likelihood(KB::NgramCandidateRefinery *this, unsigned int a2, int a3, float a4, float a5)
{
  int v8;
  float v9;

  if (a3 < 1)
  {
    v9 = 0.0;
  }
  else
  {
    if (a2 >= 5)
      v8 = 5;
    else
      v8 = a2;
    v9 = logf(TI::Favonius::SearchParameters::k_prediction_costs[v8]) + 0.0;
    if (a3 != 1)
      v9 = v9 + (float)((float)(a3 - 1) * -0.22314);
  }
  return (float)(1.0 - a5) * (float)(v9 * a4);
}

void std::__function::__func<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_1,std::allocator<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

__n128 std::__function::__func<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_1,std::allocator<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1EA106800;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_1,std::allocator<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1EA106800;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_1,std::allocator<KB::NgramCandidateRefinery::completions_from_candidate_string_based_lm(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,KB::CandidateCollection &,float,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::operator()(uint64_t a1, int32x2_t *a2, const KB::Candidate *a3, const KB::LanguageModelContext *a4)
{
  return KB::NgramCandidateRefinery::post_processing_predictions(*(KB::NgramCandidateRefinery **)(a1 + 8), a2, a3, a4, *(KB::CandidateCollection **)(a1 + 16));
}

uint64_t KB::NgramCandidateRefinery::should_not_score_token(KB::NgramCandidateRefinery *this, const KB::Word *a2)
{
  uint64_t result;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v9;
  _BYTE v10[8];
  void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  result = (*(uint64_t (**)(KB::NgramCandidateRefinery *))(*(_QWORD *)this + 16))(this);
  if ((_DWORD)result)
  {
    v5 = *((_QWORD *)this + 4);
    KB::Word::capitalized_string(a2, (uint64_t)v10);
    v9 = *((_QWORD *)a2 + 17);
    v6 = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t *))(*(_QWORD *)v5 + 384))(v5, v10, &v9);
    if (v11 && v10[6] == 1)
      free(v11);
    v7 = *((_DWORD *)a2 + 26);
    if (!v6)
      return (v7 & 0x2040000) == 0x2000000;
    result = 0;
    if ((v7 & 0x80022100) == 0x2000 && !*((_QWORD *)a2 + 28))
      return *((_DWORD *)a2 + 31) == 0;
  }
  return result;
}

void KB::NgramCandidateRefinery::context_probability_of_batched_word(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _QWORD *a6@<X8>)
{
  unsigned int *v11;
  unsigned int *v12;
  unint64_t v13;
  unsigned int *v14;
  unint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  _QWORD *v18;
  unint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  void **v25;
  void **v26;
  uint64_t v27;
  __int128 v29;
  void *v30;
  void **v31[5];

  v12 = *a2;
  v11 = a2[1];
  if (v11 != *a2)
  {
    v13 = 0;
    do
    {
      v14 = &v12[250 * v13];
      if (*(_QWORD *)v14)
      {
        v15 = 0;
        do
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
          ++v15;
        }
        while (v15 < *(_QWORD *)v14);
        v12 = *a2;
        v11 = a2[1];
      }
      ++v13;
    }
    while (v13 < 0x1CAC083126E978D5 * (((char *)v11 - (char *)v12) >> 3));
  }
  if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32)) & 1) != 0)
  {
    (*(void (**)(_QWORD, unsigned int **, uint64_t, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(a1 + 32) + 408))(*(_QWORD *)(a1 + 32), a2, a3, a4, a5, 0);
  }
  else
  {
    *a6 = 0;
    a6[1] = 0;
    a6[2] = 0;
    v16 = *a2;
    v17 = a2[1];
    if (*a2 != v17)
    {
      do
      {
        std::vector<KB::LikelihoodInfo>::vector(&v29, *v16, (uint64_t)&KB::k_invalid_likelihood_value);
        v18 = (_QWORD *)a6[1];
        v19 = a6[2];
        if ((unint64_t)v18 >= v19)
        {
          v21 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v18 - *a6) >> 3);
          v22 = v21 + 1;
          if (v21 + 1 > 0xAAAAAAAAAAAAAAALL)
            abort();
          v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - *a6) >> 3);
          if (2 * v23 > v22)
            v22 = 2 * v23;
          if (v23 >= 0x555555555555555)
            v24 = 0xAAAAAAAAAAAAAAALL;
          else
            v24 = v22;
          v31[4] = (void **)(a6 + 2);
          v25 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v24);
          v26 = &v25[3 * v21];
          v31[0] = v25;
          v31[1] = v26;
          v31[3] = &v25[3 * v27];
          v26[1] = 0;
          v26[2] = 0;
          *v26 = 0;
          *(_OWORD *)v26 = v29;
          v26[2] = v30;
          v29 = 0uLL;
          v30 = 0;
          v31[2] = v26 + 3;
          std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(a6, v31);
          v20 = (_QWORD *)a6[1];
          std::__split_buffer<std::vector<KB::LikelihoodInfo>>::~__split_buffer((uint64_t)v31);
        }
        else
        {
          *v18 = 0;
          v18[1] = 0;
          v18[2] = 0;
          *(_OWORD *)v18 = v29;
          v18[2] = v30;
          v29 = 0uLL;
          v30 = 0;
          v20 = v18 + 3;
        }
        a6[1] = v20;
        v31[0] = (void **)&v29;
        std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100](v31);
        v16 += 250;
      }
      while (v16 != v17);
    }
  }
}

void KB::NgramCandidateRefinery::update_context(KB::NgramCandidateRefinery *this, KB::LanguageModelContext *a2, const KB::Word *a3)
{
  TITokenID v5;
  TITokenID v6;
  _BYTE v7[8];
  void *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (!KB::Word::is_linguistically_void(a3))
  {
    v5 = (TITokenID)*((_QWORD *)a3 + 17);
    KB::Word::capitalized_string(a3, (uint64_t)v7);
    v6 = v5;
    KB::LanguageModelContext::append(a2, v6, (const KB::String *)v7, (*((_DWORD *)a3 + 26) >> 1) & 1);
    if (v8)
    {
      if (v7[6] == 1)
        free(v8);
    }
  }
}

void KB::UnigramCandidateRefinery::~UnigramCandidateRefinery(KB::UnigramCandidateRefinery *this)
{
  unsigned int *v1;

  *(_QWORD *)this = &off_1EA106698;
  v1 = (unsigned int *)*((_QWORD *)this + 1);
  if (v1)
    WTF::RefCounted<KB::DictionaryContainer>::deref(v1);
}

{
  unsigned int *v1;

  *(_QWORD *)this = &off_1EA106698;
  v1 = (unsigned int *)*((_QWORD *)this + 1);
  if (v1)
    WTF::RefCounted<KB::DictionaryContainer>::deref(v1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t KB::UnigramCandidateRefinery::uses_document_context(KB::UnigramCandidateRefinery *this)
{
  return 0;
}

uint64_t KB::UnigramCandidateRefinery::does_language_model_provide_inline_completions(KB::UnigramCandidateRefinery *this)
{
  return 0;
}

uint64_t KB::UnigramCandidateRefinery::does_language_model_support_multilingual(KB::UnigramCandidateRefinery *this)
{
  return 0;
}

uint64_t KB::UnigramCandidateRefinery::does_language_model_support_fragment_conditional_prob(KB::UnigramCandidateRefinery *this)
{
  return 0;
}

uint64_t KB::UnigramCandidateRefinery::does_language_model_support_completions(KB::UnigramCandidateRefinery *this)
{
  return 0;
}

void KB::UnigramCandidateRefinery::refine_candidates(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  KB::Candidate *v3;
  unint64_t v4;
  uint64_t v5;

  v2 = *(uint64_t **)a2;
  v3 = *(KB::Candidate **)(a2 + 8);
  v4 = 126 - 2 * __clz(0x1CAC083126E978D5 * ((v3 - (KB::Candidate *)v2) >> 3));
  if (v3 == (KB::Candidate *)v2)
    v5 = 0;
  else
    v5 = v4;
  std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,false>(v2, v3, v5, 1);
}

void KB::UnigramCandidateRefinery::completions_for_completion_stems(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  KB::Candidate *v4;
  unint64_t v5;
  uint64_t v6;

  v4 = *(KB::Candidate **)(a4 + 8);
  v5 = 126 - 2 * __clz(0x1CAC083126E978D5 * (((uint64_t)v4 - *(_QWORD *)a4) >> 3));
  if (v4 == *(KB::Candidate **)a4)
    v6 = 0;
  else
    v6 = v5;
  std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,false>(*(uint64_t **)a4, v4, v6, 1);
}

void KB::UnigramCandidateRefinery::predictions_for_prediction_stems(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  KB::Candidate *v4;
  unint64_t v5;
  uint64_t v6;

  v4 = *(KB::Candidate **)(a4 + 8);
  v5 = 126 - 2 * __clz(0x1CAC083126E978D5 * (((uint64_t)v4 - *(_QWORD *)a4) >> 3));
  if (v4 == *(KB::Candidate **)a4)
    v6 = 0;
  else
    v6 = v5;
  std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,false>(*(uint64_t **)a4, v4, v6, 1);
}

void KB::UnigramCandidateRefinery::inline_predictions_for_completion_stems(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[104] = 0;
}

void KB::UnigramCandidateRefinery::get_num_candidates(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[16] = 0;
}

uint64_t KB::UnigramCandidateRefinery::dictionary(KB::UnigramCandidateRefinery *this)
{
  return *((_QWORD *)this + 1);
}

void KB::UnigramCandidateRefinery::lexicon_id_vector(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void KB::CandidateRefinery::sort_candidate_collection(KB::CandidateRefinery *this, KB::CandidateCollection *a2)
{
  KB::Candidate *v2;
  unint64_t v3;
  uint64_t v4;

  v2 = (KB::Candidate *)*((_QWORD *)this + 1);
  v3 = 126 - 2 * __clz(0x1CAC083126E978D5 * (((uint64_t)v2 - *(_QWORD *)this) >> 3));
  if (v2 == *(KB::Candidate **)this)
    v4 = 0;
  else
    v4 = v3;
  std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,false>(*(uint64_t **)this, v2, v4, 1);
}

void KB::NgramCandidateRefinery::create(unsigned int **a1@<X0>, uint64_t *a2@<X1>, int a3@<W2>, int a4@<W3>, std::__shared_weak_count **a5@<X8>)
{
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unsigned int v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *shared_weak_owners;
  unint64_t v25;
  unint64_t *p_shared_weak_owners;
  unint64_t v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t v31;

  v10 = (std::__shared_weak_count *)operator new(0x50uLL);
  v10->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  v10->__shared_weak_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA106738;
  v12 = *a1;
  if (v12)
  {
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
  }
  v14 = *a2;
  v15 = (std::__shared_weak_count *)a2[1];
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v10[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1EA1065F8;
  v10[1].__shared_owners_ = 0;
  v10[1].__shared_weak_owners_ = 0;
  v10[2].__vftable = (std::__shared_weak_count_vtbl *)v12;
  if (v12)
  {
    do
      v18 = __ldaxr(v12);
    while (__stlxr(v18 + 1, v12));
  }
  v10[2].__shared_owners_ = v14;
  v10[2].__shared_weak_owners_ = (uint64_t)v15;
  if (v15)
  {
    v19 = (unint64_t *)&v15->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }
  LODWORD(v10[3].__vftable) = a3;
  if (a4)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 96))(v14);
  v21 = v10 + 1;
  if (v15)
  {
    v22 = (unint64_t *)&v15->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v12)
    WTF::RefCounted<KB::DictionaryContainer>::deref(v12);
  *a5 = v21;
  a5[1] = v10;
  shared_weak_owners = (std::__shared_weak_count *)v10[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1)
      return;
    do
      v25 = __ldxr(p_shared_owners);
    while (__stxr(v25 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
    do
      v27 = __ldxr(p_shared_weak_owners);
    while (__stxr(v27 + 1, p_shared_weak_owners));
    v10[1].__shared_owners_ = (uint64_t)v21;
    v10[1].__shared_weak_owners_ = (uint64_t)v10;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    do
      v28 = __ldxr(p_shared_owners);
    while (__stxr(v28 + 1, p_shared_owners));
    v29 = (unint64_t *)&v10->__shared_weak_owners_;
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
    v10[1].__shared_owners_ = (uint64_t)v21;
    v10[1].__shared_weak_owners_ = (uint64_t)v10;
  }
  do
    v31 = __ldaxr(p_shared_owners);
  while (__stlxr(v31 - 1, p_shared_owners));
  if (!v31)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void std::__shared_ptr_emplace<KB::NgramCandidateRefinery>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA106738;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KB::NgramCandidateRefinery>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1EA106738;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_emplace<KB::NgramCandidateRefinery>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t KB::NgramCandidateRefinery::NgramCandidateRefinery(uint64_t a1, unsigned int **a2, _QWORD *a3, int a4, int a5)
{
  unsigned int *v6;
  unsigned int v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &off_1EA1065F8;
  v6 = *a2;
  *(_QWORD *)(a1 + 24) = *a2;
  if (v6)
  {
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
  }
  v8 = a3[1];
  *(_QWORD *)(a1 + 32) = *a3;
  *(_QWORD *)(a1 + 40) = v8;
  if (v8)
  {
    v9 = (unint64_t *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  *(_DWORD *)(a1 + 48) = a4;
  if (a5)
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 96))(*(_QWORD *)(a1 + 32));
  return a1;
}

void KB::NgramCandidateRefinery::context_probability_of_word(KB::NgramCandidateRefinery *this@<X0>, const KB::String *a2@<X1>, const KB::LanguageModelContext *a3@<X2>, const TITokenID *a4@<X3>, float a5@<S0>, __CFString *a6@<X4>, uint64_t a7@<X8>)
{
  std::string *v14;

  (*(void (**)(_QWORD))(**((_QWORD **)this + 4) + 24))(*((_QWORD *)this + 4));
  if (((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4)) & 1) != 0)
  {
    (*(void (**)(_QWORD, const KB::String *, const TITokenID *, const KB::LanguageModelContext *, __CFString *, float))(**((_QWORD **)this + 4) + 400))(*((_QWORD *)this + 4), a2, a4, a3, a6, a5);
  }
  else
  {
    *(_QWORD *)a7 = KB::k_invalid_likelihood_value;
    *(_DWORD *)(a7 + 8) = dword_1F0282058;
    v14 = (std::string *)(a7 + 16);
    if (byte_1F0282077 < 0)
    {
      std::string::__init_copy_ctor_external(v14, *(const std::string::value_type **)aInvalidLikelih_2, *(std::string::size_type *)&aInvalidLikelih_2[8]);
    }
    else
    {
      *(_OWORD *)&v14->__r_.__value_.__l.__data_ = *(_OWORD *)aInvalidLikelih_2;
      *(_QWORD *)(a7 + 32) = *(_QWORD *)&aInvalidLikelih_2[16];
    }
  }
}

void KB::NgramCandidateRefinery::add_context_weight(KB::NgramCandidateRefinery *this, KB::Word *a2, const KB::LanguageModelContext *a3)
{
  uint64_t v6;
  int v7;
  CFMutableStringRef Mutable;
  int v9;
  float v10;
  const char *p_p;
  char v12;
  TITokenID v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  void *__p;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (KB::NgramCandidateRefinery::should_not_score_token(this, a2))
  {
    *((_DWORD *)a2 + 12) = 0;
    return;
  }
  v6 = *((_QWORD *)this + 4);
  KB::Word::capitalized_string(a2, (uint64_t)&v16);
  v14 = *((_QWORD *)a2 + 17);
  v7 = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v6 + 384))(v6, &v16, &v14);
  if (v17 && BYTE6(v16) == 1)
    free(v17);
  if (v7)
  {
    if (s_trace_logging_enabled)
      Mutable = CFStringCreateMutable(0, 0);
    else
      Mutable = 0;
    KB::Word::capitalized_string(a2, (uint64_t)&v14);
    v13 = (TITokenID)*((_QWORD *)a2 + 17);
    KB::NgramCandidateRefinery::context_probability_of_word(this, (const KB::String *)&v14, a3, &v13, *((float *)a2 + 13), Mutable, (uint64_t)&v16);
    if (v15 && BYTE6(v14) == 1)
      free(v15);
    *(_QWORD *)((char *)a2 + 52) = v16;
    v9 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4));
    v10 = 1.0;
    if (v9)
      v10 = (*(float (**)(_QWORD, _QWORD, const KB::LanguageModelContext *, float))(**((_QWORD **)this + 4)
                                                                                             + 432))(*((_QWORD *)this + 4), *((unsigned int *)a2 + 34), a3, 1.0);
    *((float *)a2 + 24) = v10;
    if (v19 >= 0)
      p_p = (const char *)&__p;
    else
      p_p = (const char *)__p;
    KB::String::String((KB::String *)&v14, p_p);
    KB::String::operator=((KB::Word *)((char *)a2 + 64), (KB::String *)&v14);
    if (v15 && BYTE6(v14) == 1)
      free(v15);
    v12 = (char)v17;
    if ((v17 & 1) != 0)
    {
      *((_DWORD *)a2 + 26) |= 0x1000000u;
      if ((v12 & 2) == 0)
      {
LABEL_23:
        if (!Mutable)
          goto LABEL_30;
        goto LABEL_27;
      }
    }
    else if ((v17 & 2) == 0)
    {
      goto LABEL_23;
    }
    *((_DWORD *)a2 + 26) |= 0x4000000u;
    if (!Mutable)
    {
LABEL_30:
      if (v19 < 0)
        operator delete(__p);
      if (Mutable)
        CFRelease(Mutable);
      return;
    }
LABEL_27:
    KB::utf8_string(Mutable, (uint64_t)&v14);
    KB::String::operator=((KB::Word *)((char *)a2 + 160), (KB::String *)&v14);
    if (v15 && BYTE6(v14) == 1)
      free(v15);
    goto LABEL_30;
  }
}

void KB::ChooseTopQualityAutocorrection::~ChooseTopQualityAutocorrection(KB::ChooseTopQualityAutocorrection *this)
{
  JUMPOUT(0x1DF0A2144);
}

const char *KB::ChooseTopQualityAutocorrection::filter_description(KB::ChooseTopQualityAutocorrection *this)
{
  return "ChooseTopQualityAutocorrection";
}

void KB::ChooseTopQualityAutocorrection::filter_candidates(KB::ChooseTopQualityAutocorrection *this, const KB::Candidate **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  float v8;
  char v9;
  void **v10;
  void **v11;
  void **v12;
  uint64_t v13;
  char v14;
  const KB::Candidate *v15;
  KB::Candidate *v16;
  const KB::Candidate *v17;
  const KB::Candidate *v18;
  void **v19;
  void **v20;
  void **v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  void **v27;
  uint64_t *v28;
  void **v29;
  void **v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const KB::Candidate *v34[3];
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void **v38[6];

  if (*a2 != a2[1])
  {
    KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v34, a2);
    v8 = expf(*((float *)*a2 + 186));
    KB::ChooseTopQualityAutocorrection::filter_candidates_subset(this, a2, a3, a4, v8);
    if (*a2 != a2[1])
    {
      v9 = 0;
      v10 = (void **)&v33;
      v11 = (void **)&v32;
      v12 = (void **)&v31;
      v28 = (uint64_t *)(a2 + 3);
      v13 = 1;
      while (1)
      {
        v14 = v9;
        KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)&v29, v34);
        std::vector<KB::Candidate>::erase((uint64_t)&v29, (uint64_t *)v29, (KB::Candidate *)&v29[125 * v13]);
        if (v29 == v30)
          break;
        KB::ChooseTopQualityAutocorrection::filter_candidates_subset(this, (KB::Candidate **)&v29, a3, a4, v8);
        v15 = (const KB::Candidate *)v29;
        if (v29 == v30)
          break;
        v16 = a2[4];
        v17 = a2[5];
        if (v16 >= v17)
        {
          v19 = v10;
          v20 = v11;
          v21 = v12;
          v22 = 0x1CAC083126E978D5 * (((uint64_t)v16 - *v28) >> 3);
          v23 = v22 + 1;
          if ((unint64_t)(v22 + 1) > 0x4189374BC6A7EFLL)
            abort();
          v24 = 0x1CAC083126E978D5 * (((uint64_t)v17 - *v28) >> 3);
          if (2 * v24 > v23)
            v23 = 2 * v24;
          if (v24 >= 0x20C49BA5E353F7)
            v25 = 0x4189374BC6A7EFLL;
          else
            v25 = v23;
          v38[4] = (void **)(a2 + 5);
          if (v25)
            v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v25);
          else
            v26 = 0;
          v27 = (void **)(v25 + 1000 * v22);
          v38[0] = (void **)v25;
          v38[1] = v27;
          v38[3] = (void **)(v25 + 1000 * v26);
          KB::Candidate::Candidate((KB::Candidate *)v27, v15);
          v38[2] = v27 + 125;
          std::vector<KB::Candidate>::__swap_out_circular_buffer(v28, v38);
          v18 = a2[4];
          std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)v38);
          v12 = v21;
          v11 = v20;
          v10 = v19;
        }
        else
        {
          v18 = (KB::Candidate *)((char *)KB::Candidate::Candidate(v16, (const KB::Candidate *)v29) + 1000);
        }
        a2[4] = v18;
        v38[0] = v10;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v38);
        v38[0] = v11;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v38);
        v38[0] = v12;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v38);
        v38[0] = (void **)&v29;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v38);
        v9 = 1;
        v13 = 2;
        if ((v14 & 1) != 0)
          goto LABEL_21;
      }
      v38[0] = v10;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v38);
      v38[0] = v11;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v38);
      v38[0] = v12;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v38);
      v38[0] = (void **)&v29;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v38);
    }
LABEL_21:
    v29 = (void **)&v37;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v29);
    v29 = (void **)&v36;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v29);
    v29 = (void **)&v35;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v29);
    v29 = (void **)v34;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v29);
  }
}

void KB::ChooseTopQualityAutocorrection::filter_candidates_subset(KB::ChooseTopQualityAutocorrection *this, KB::Candidate **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4, float a5)
{
  BOOL v10;
  const char *v11;
  _BOOL4 v12;
  char v13;
  const KB::Candidate *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  KB::Candidate *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int64x2_t v24;
  unint64_t v25;
  __CFString *v26;
  const char *v27;
  const char *v28;
  const char *v29;
  char *v30;
  const KB::Candidate *v31;
  __CFString *v32;
  const char *v33;
  const char *v34;
  KB::ChooseTopQualityAutocorrection *v35;
  char v36;
  const KB::Candidate *v37[3];
  _OWORD v38[3];
  __int128 v39;
  uint64_t v40;
  int v41;
  _OWORD v42[3];
  _OWORD v43[3];
  int v44;
  const KB::Candidate **v45;
  void **v46;
  int64x2_t v47;
  unint64_t v48;
  char *v49;
  _WORD v50[3];
  char v51;
  char *v52;
  _QWORD v53[5];

  v53[2] = *MEMORY[0x1E0C80C00];
  if (*a2 != a2[1])
  {
    KB::Candidate::capitalized_string(*a2, (uint64_t)v50);
    KB::Candidate::capitalized_string(a3, (uint64_t)&v46);
    v10 = KB::String::equal((KB::String *)&v46, (const KB::String *)v50, 1);
    if (v47.i64[0] && BYTE6(v46) == 1)
      free((void *)v47.i64[0]);
    KB::Candidate::capitalized_string((const KB::CandidateFilterLookupContext *)((char *)a3 + 2168), (uint64_t)&v46);
    v36 = KB::String::equal((KB::String *)&v46, (const KB::String *)v50, 1);
    if (v47.i64[0] && BYTE6(v46) == 1)
      free((void *)v47.i64[0]);
    v44 = 0;
    memset(v42, 0, sizeof(v42));
    memset(v43, 0, sizeof(v43));
    std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)v43, 0, a2[6], a2[7], 0x1CAC083126E978D5 * ((a2[7] - a2[6]) >> 3));
    std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)&v42[1] + 1, 0, a2[3], a2[4], 0x1CAC083126E978D5 * ((a2[4] - a2[3]) >> 3));
    KB::Candidate::capitalized_string(a3, (uint64_t)&v46);
    v12 = KB::String::equal((KB::String *)&v46, (const KB::String *)v50, 0);
    if (v47.i64[0] && BYTE6(v46) == 1)
      free((void *)v47.i64[0]);
    v13 = (*((_BYTE *)a2 + 100) & 1) == 0 || v12;
    if ((v13 & 1) == 0)
      v44 |= 1u;
    if (v12)
    {
      v35 = this;
      v14 = *a2;
      if (*(_QWORD *)&v43[2] >= *((_QWORD *)&v43[2] + 1))
      {
        v16 = 0x1CAC083126E978D5 * ((uint64_t)(*(_QWORD *)&v43[2] - *((_QWORD *)&v43[1] + 1)) >> 3);
        if ((unint64_t)(v16 + 1) > 0x4189374BC6A7EFLL)
          abort();
        v17 = 0x395810624DD2F1AALL * ((uint64_t)(*((_QWORD *)&v43[2] + 1) - *((_QWORD *)&v43[1] + 1)) >> 3);
        if (v17 <= v16 + 1)
          v17 = v16 + 1;
        if ((unint64_t)(0x1CAC083126E978D5
                              * ((uint64_t)(*((_QWORD *)&v43[2] + 1) - *((_QWORD *)&v43[1] + 1)) >> 3)) >= 0x20C49BA5E353F7)
          v18 = 0x4189374BC6A7EFLL;
        else
          v18 = v17;
        v49 = (char *)&v43[2] + 8;
        if (v18)
          v18 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v18);
        else
          v19 = 0;
        v20 = (KB::Candidate *)(v18 + 1000 * v16);
        v46 = (void **)v18;
        v47.i64[0] = (uint64_t)v20;
        v48 = v18 + 1000 * v19;
        KB::Candidate::Candidate(v20, v14);
        v15 = (char *)v20 + 1000;
        v47.i64[1] = (uint64_t)v15;
        v21 = *((_QWORD *)&v43[1] + 1);
        v22 = *(_QWORD *)&v43[2];
        v23 = v47.i64[0];
        if (*(_QWORD *)&v43[2] == *((_QWORD *)&v43[1] + 1))
        {
          v24 = vdupq_n_s64(*(unint64_t *)&v43[2]);
        }
        else
        {
          do
          {
            v22 -= 1000;
            v23 = KB::Candidate::Candidate(v23 - 1000, v22);
          }
          while (v22 != v21);
          v24 = *(int64x2_t *)((char *)&v43[1] + 8);
          v15 = (char *)v47.i64[1];
        }
        *((_QWORD *)&v43[1] + 1) = v23;
        *(_QWORD *)&v43[2] = v15;
        v47 = v24;
        v25 = *((_QWORD *)&v43[2] + 1);
        *((_QWORD *)&v43[2] + 1) = v48;
        v48 = v25;
        v46 = (void **)v24.i64[0];
        std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v46);
      }
      else
      {
        v15 = (char *)KB::Candidate::Candidate(*(KB::Candidate **)&v43[2], *a2) + 1000;
      }
      *(_QWORD *)&v43[2] = v15;
      this = v35;
    }
    if (v10)
    {
      v26 = (__CFString *)*((_QWORD *)a4 + 7);
      if (v26)
      {
        v27 = v52;
        if (!v52)
          v27 = (const char *)v53;
        if (v50[0])
          v28 = v27;
        else
          v28 = "";
        KB::append_format(v26, (__CFString *)"[%s] matches the input string - ignoring\n", v11, v28);
      }
    }
    else if (KB::ChooseTopQualityAutocorrection::is_first_candidate_significantly_better((uint64_t)this, a2, v36, a3, (uint64_t *)a4, a5))
    {
      KB::Candidate::Candidate((KB::Candidate *)&v46, *a2);
      v30 = (char *)operator new(0x3E8uLL);
      v31 = (const KB::Candidate *)(v30 + 1000);
      v37[0] = (const KB::Candidate *)v30;
      v37[2] = (const KB::Candidate *)(v30 + 1000);
      KB::Candidate::Candidate((KB::Candidate *)v30, (const KB::Candidate *)&v46);
      v37[1] = v31;
      v41 = 0;
      memset(v38, 0, sizeof(v38));
      v39 = 0u;
      v40 = 0;
      KB::CandidateCollection::add((KB::CandidateCollection *)v42, v37);
      v45 = (const KB::Candidate **)&v39;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v45);
      v45 = (const KB::Candidate **)&v38[1] + 1;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v45);
      v45 = (const KB::Candidate **)v38;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v45);
      v45 = v37;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v45);
      KB::Candidate::~Candidate((KB::Candidate *)&v46);
    }
    else
    {
      v32 = (__CFString *)*((_QWORD *)a4 + 7);
      if (v32)
      {
        v33 = v52;
        if (!v52)
          v33 = (const char *)v53;
        if (v50[0])
          v34 = v33;
        else
          v34 = "";
        KB::append_format(v32, (__CFString *)"[%s] not significantly better than input - rejecting\n", v29, v34);
      }
    }
    KB::CandidateCollection::operator=((uint64_t)a2, (uint64_t)v42);
    v46 = (void **)&v43[1] + 1;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v46);
    v46 = (void **)v43;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v46);
    v46 = (void **)&v42[1] + 1;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v46);
    v46 = (void **)v42;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v46);
    if (v52)
    {
      if (v51 == 1)
        free(v52);
    }
  }
}

uint64_t KB::ChooseTopQualityAutocorrection::is_first_candidate_significantly_better(uint64_t a1, KB::Candidate **a2, char a3, _BYTE *a4, uint64_t *a5, float a6)
{
  KB::Candidate **v9;
  KB::Candidate *v10;
  _QWORD *v11;
  const KB::Candidate *difference;
  int v13;
  int v14;
  _BYTE *v15;
  int v16;
  const KB::String *v17;
  const KB::String *v18;
  const KB::Candidate *v19;
  _BOOL4 v20;
  const KB::CandidateFilterResources *v21;
  __CFString *v22;
  const char *v23;
  const char *v24;
  const char *v25;
  float v26;
  const KB::CandidateFilterResources *v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  int v31;
  _BOOL4 v32;
  int v33;
  _BOOL4 v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  BOOL v38;
  BOOL v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  const char *v43;
  _DWORD *v44;
  KB::Candidate *v45;
  uint64_t v46;
  unint64_t v47;
  float v48;
  _BOOL4 v49;
  KB::Candidate **v50;
  int v51;
  int v52;
  int v53;
  float v54;
  int v55;
  int v56;
  __CFString *v57;
  const char *v58;
  const char *v59;
  const char *v60;
  char v61;
  const char *v62;
  const char *v63;
  const char *v64;
  KB::String *v66;
  __CFString *v67;
  const char *v68;
  const char *v69;
  const char *v70;
  const char *v71;
  const char *v72;
  KB::Candidate *v73;
  KB::Candidate *v74;
  unsigned int v75;
  const char *v76;
  const char *v77;
  _BOOL4 v78;
  uint64_t v79;
  uint64_t v80;
  int *v81;
  int v82;
  _BOOL4 v83;
  BOOL v84;
  float v85;
  __CFString *v86;
  const char *v87;
  const char *v88;
  const char *v89;
  const char *v90;
  const char *v91;
  __CFString *v92;
  const char *v93;
  const char *v94;
  const char *v95;
  const char *v96;
  const char *v97;
  _BOOL4 v98;
  int v99;
  int v100;
  uint64_t *v102;
  _BYTE *v104;
  int v105;
  int v106;
  int v107;
  void *v108[2];
  _QWORD v109[2];
  void *v110[2];
  _QWORD v111[2];
  unsigned __int16 v112[3];
  char v113;
  void *v114;
  _WORD v115[3];
  char v116;
  void *v117;
  _BYTE v118[16];
  unsigned __int16 v119[2];
  unsigned __int16 v120;
  char v121;
  char *v122;
  _QWORD v123[4];

  v9 = a2;
  v123[2] = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = a4 + 2008;
  KB::Candidate::capitalized_string((KB::Candidate *)a4, (uint64_t)v119);
  KB::Candidate::capitalized_string(v10, (uint64_t)v115);
  difference = (const KB::Candidate *)KB::ChooseTopQualityAutocorrection::case_sens_position_of_first_difference((KB::String *)v119, v11, (KB::String *)v115);
  v100 = KB::Candidate::length((KB::Candidate *)a4);
  v99 = KB::ChooseTopQualityAutocorrection::inactive_prefix_length_for_candidate((KB::ChooseTopQualityAutocorrection *)a4, v10, difference);
  v13 = KB::Candidate::length(v10);
  v14 = KB::Candidate::length((KB::Candidate *)a4);
  if (v117)
    v15 = v117;
  else
    v15 = v118;
  v108[0] = v15;
  v16 = v115[0];
  LODWORD(v108[1]) = 0;
  HIDWORD(v108[1]) = v115[0];
  LODWORD(v109[0]) = 0;
  KB::String::iterator::initialize((uint64_t *)v108);
  *(_OWORD *)v110 = *(_OWORD *)v108;
  v111[0] = v109[0];
  std::__advance[abi:nn180100]<KB::String::iterator>((KB::String::iterator *)v110, (int)difference);
  v104 = v15;
  v105 = v16;
  v106 = v16;
  v107 = 0;
  KB::String::iterator::initialize((uint64_t *)&v104);
  KB::String::String((KB::String *)v112, (const KB::String::iterator *)v110, (const KB::String::iterator *)&v104);
  v20 = KB::string_has_precomposed_diacritic_letters((KB *)v112, v17)
     || KB::string_has_separated_diacritics((KB *)v112, v18)
     || KB::ChooseTopQualityAutocorrection::string_contains_word_medial_punctuation(v112, a5[5]);
  if (KB::ChooseTopQualityAutocorrection::does_candidate_extend_one_letter_word((KB::ChooseTopQualityAutocorrection *)a4, v10, v19)&& !a4[3175])
  {
    v22 = (__CFString *)a5[7];
    if (!v22)
    {
LABEL_91:
      v40 = 0;
      goto LABEL_92;
    }
    KB::Candidate::capitalized_string(*v9, (uint64_t)v110);
    v24 = (const char *)v110[1];
    if (!v110[1])
      v24 = (const char *)v111;
    if (LOWORD(v110[0]))
      v25 = v24;
    else
      v25 = "";
    KB::append_format(v22, (__CFString *)"[%s] prediction skipped for single-character input\n", v23, v25);
LABEL_88:
    if (v110[1] && BYTE6(v110[0]) == 1)
      free(v110[1]);
    goto LABEL_91;
  }
  v26 = *(float *)(a1 + 8);
  if (KB::ChooseTopQualityAutocorrection::candidate_is_complex((KB::ChooseTopQualityAutocorrection *)a4, v10, (const KB::Candidate *)a5, v21)&& !KB::ChooseTopQualityAutocorrection::should_allow_complex_candidate((KB::ChooseTopQualityAutocorrection *)a4, v10, (const KB::Candidate *)a5, v26, v27))
  {
    v40 = a5[7];
    if (v40)
    {
      KB::Candidate::capitalized_string(v10, (uint64_t)v110);
      v42 = (const char *)v110[1];
      if (!v110[1])
        v42 = (const char *)v111;
      if (LOWORD(v110[0]))
        v43 = v42;
      else
        v43 = "";
      KB::append_format((__CFString *)v40, (__CFString *)"[%s] skipped complex candidate with insufficient linguistic support\n", v41, v43);
      goto LABEL_88;
    }
  }
  else
  {
    if (v119[0] <= v115[0])
    {
      if (v117)
        v29 = (const char *)v117;
      else
        v29 = v118;
      if (v122)
        v30 = v122;
      else
        v30 = (const char *)v123;
      v28 = strncasecmp(v29, v30, v119[0]) == 0;
    }
    else
    {
      v28 = 0;
    }
    v31 = v120;
    if (!v120)
    {
      v32 = v28;
      KB::String::compute_length(v119);
      v28 = v32;
      v31 = v120;
    }
    v33 = v13 - v14;
    v98 = v20;
    if (v20)
    {
      v34 = 0;
    }
    else
    {
      if (*(_QWORD *)v10)
      {
        v35 = 240 * *(_QWORD *)v10 - 240;
        v36 = (uint64_t *)(*((_QWORD *)v10 + 1) + 224);
        do
        {
          v37 = *v36;
          v36 += 30;
          v38 = v37 != 0;
          if (v37)
            v39 = 1;
          else
            v39 = v35 == 0;
          v35 -= 240;
        }
        while (!v39);
      }
      else
      {
        v38 = 0;
      }
      v34 = 0;
      if (!v38 && (_DWORD)difference == v31 && (a3 & 1) == 0)
      {
        v44 = (_DWORD *)(a1 + 24);
        if (v33 == 2)
          v44 = (_DWORD *)(a1 + 20);
        if (v33 <= 1)
          v44 = (_DWORD *)(a1 + 16);
        v34 = (v100 - v99) < *v44;
      }
    }
    v45 = *v9;
    v46 = v9[1] - *v9;
    v47 = 0x1CAC083126E978D5 * (v46 >> 3);
    v48 = 0.0;
    if (v47 >= 2)
    {
      v49 = v28;
      v102 = a5;
      v50 = v9;
      v51 = v33;
      v52 = (int)difference;
      v53 = v31;
      v54 = expf(*((float *)v45 + 436));
      v31 = v53;
      LODWORD(difference) = v52;
      v33 = v51;
      v9 = v50;
      a5 = v102;
      v28 = v49;
      v48 = v54;
    }
    v55 = v46 != 1000 || v34;
    if ((v55 & v28) != 1)
      goto LABEL_66;
    v56 = v98;
    if (v33 < 1)
      v56 = 1;
    if ((_DWORD)difference != v31 && v56)
    {
LABEL_66:
      v57 = (__CFString *)a5[7];
      if (v57)
      {
        KB::Candidate::capitalized_string(v45, (uint64_t)v110);
        v59 = (const char *)v110[1];
        if (!v110[1])
          v59 = (const char *)v111;
        if (LOWORD(v110[0]))
          v60 = v59;
        else
          v60 = "";
        KB::append_format(v57, (__CFString *)"[%s] dominant due to mismatch with typed string\n", v58, v60);
LABEL_73:
        if (v110[1] && BYTE6(v110[0]) == 1)
          free(v110[1]);
      }
LABEL_76:
      v40 = 1;
      goto LABEL_92;
    }
    v61 = v47 < 2 || v34;
    if ((v61 & 1) == 0)
    {
      v66 = (KB::Candidate *)((char *)v45 + 888);
      if (!*((_WORD *)v45 + 444))
      {
        KB::Candidate::compute_string(v45);
        v45 = *v9;
      }
      if (!*((_WORD *)v45 + 944))
        KB::Candidate::compute_string((KB::Candidate *)((char *)v45 + 1000));
      if (KB::String::equal(v66, (KB::Candidate *)((char *)v45 + 1888), 0))
      {
        v67 = (__CFString *)a5[7];
        if (!v67)
          goto LABEL_76;
        KB::Candidate::capitalized_string(*v9, (uint64_t)v110);
        v68 = (const char *)v110[1];
        if (!v110[1])
          v68 = (const char *)v111;
        if (LOWORD(v110[0]))
          v69 = v68;
        else
          v69 = "";
        KB::Candidate::capitalized_string((KB::Candidate *)((char *)*v9 + 1000), (uint64_t)v108);
        v71 = (const char *)v108[1];
        if (!v108[1])
          v71 = (const char *)v109;
        if (LOWORD(v108[0]))
          v72 = v71;
        else
          v72 = "";
        KB::append_format(v67, (__CFString *)"[%s] candidate is dominant as second candidate [%s] is a duplicate as well\n", v70, v69, v72);
      }
      else
      {
        v73 = *v9;
        v74 = *v9;
        if (!*((_WORD *)*v9 + 944))
        {
          KB::Candidate::compute_string((KB::Candidate *)((char *)v73 + 1000));
          v74 = *v9;
        }
        v75 = *((unsigned __int16 *)v74 + 444);
        if (!*((_WORD *)v74 + 444))
        {
          KB::Candidate::compute_string(v74);
          v75 = *((unsigned __int16 *)v74 + 444);
        }
        if (v75 > *((unsigned __int16 *)v73 + 944)
          || (*((_QWORD *)v73 + 237) ? (v76 = (const char *)*((_QWORD *)v73 + 237)) : (v76 = (char *)v73 + 1904),
              *((_QWORD *)v74 + 112) ? (v77 = (const char *)*((_QWORD *)v74 + 112)) : (v77 = (char *)v74 + 904),
              strncasecmp(v76, v77, v75)))
        {
          if (a4[3172])
            v78 = v98;
          else
            v78 = 0;
          if (v78 && (v79 = *((_QWORD *)*v9 + 125)) != 0)
          {
            v80 = 240 * v79 - 240;
            v81 = (int *)(*((_QWORD *)*v9 + 126) + 120);
            do
            {
              v82 = *v81;
              v81 += 60;
              v83 = v82 != 0;
              if (v82)
                v84 = 1;
              else
                v84 = v80 == 0;
              v80 -= 240;
            }
            while (!v84);
          }
          else
          {
            v83 = 0;
          }
          v85 = v48 * *(float *)(a1 + 12);
          v86 = (__CFString *)a5[7];
          if (v86)
          {
            KB::Candidate::capitalized_string(*v9, (uint64_t)v110);
            v88 = (const char *)v110[1];
            if (!v110[1])
              v88 = (const char *)v111;
            if (LOWORD(v110[0]))
              v89 = v88;
            else
              v89 = "";
            v90 = "false";
            if (v85 >= a6)
              v91 = "false";
            else
              v91 = "true";
            if (v83)
              v90 = "true";
            KB::append_format(v86, (__CFString *)"[%s] dominant=%s (p0=%g,p1=%g) (competing_variants=%s)\n", v87, v89, v91, a6, v48, v90);
            if (v110[1] && BYTE6(v110[0]) == 1)
              free(v110[1]);
          }
          v40 = v85 < a6 && !v83;
          goto LABEL_92;
        }
        v92 = (__CFString *)a5[7];
        if (!v92)
          goto LABEL_76;
        KB::Candidate::capitalized_string(*v9, (uint64_t)v110);
        v93 = (const char *)v110[1];
        if (!v110[1])
          v93 = (const char *)v111;
        if (LOWORD(v110[0]))
          v94 = v93;
        else
          v94 = "";
        KB::Candidate::capitalized_string((KB::Candidate *)((char *)*v9 + 1000), (uint64_t)v108);
        v96 = (const char *)v108[1];
        if (!v108[1])
          v96 = (const char *)v109;
        if (LOWORD(v108[0]))
          v97 = v96;
        else
          v97 = "";
        KB::append_format(v92, (__CFString *)"[%s] candidate is dominant as it is a subset (prefix) of the second candidate [%s]\n", v95, v94, v97);
      }
      if (v108[1] && BYTE6(v108[0]) == 1)
        free(v108[1]);
      goto LABEL_73;
    }
    v40 = a5[7];
    if (v40)
    {
      KB::Candidate::capitalized_string(v45, (uint64_t)v110);
      v63 = (const char *)v110[1];
      if (!v110[1])
        v63 = (const char *)v111;
      if (LOWORD(v110[0]))
        v64 = v63;
      else
        v64 = "";
      KB::append_format((__CFString *)v40, (__CFString *)"[%s] skipped as length gain from autocorrection does not produce a viable candidate\n", v62, v64);
      goto LABEL_88;
    }
  }
LABEL_92:
  if (v114 && v113 == 1)
    free(v114);
  if (v117 && v116 == 1)
    free(v117);
  if (v122 && v121 == 1)
    free(v122);
  return v40;
}

uint64_t KB::ChooseTopQualityAutocorrection::case_sens_position_of_first_difference(KB::String *this, _QWORD *a2, KB::String *a3)
{
  uint64_t v6;
  unsigned int v7;
  char *v8;
  int v9;
  char *v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  _QWORD v15[2];
  BOOL (*v16)(uint64_t, UChar32 *, UChar32 *);
  void *v17;
  __int128 *v18;
  _QWORD *v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  int v23;
  unsigned int v24;
  __int128 v25;
  int v26;
  int v27;
  __int128 v28;
  uint64_t v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  uint64_t (*v31)();
  uint64_t v32;
  _BYTE v33[24];
  __int128 v34;
  int v35;
  int v36;

  LODWORD(v6) = *((unsigned __int16 *)this + 2);
  if (!*((_WORD *)this + 2))
  {
    KB::String::compute_length((unsigned __int16 *)this);
    LODWORD(v6) = *((unsigned __int16 *)this + 2);
  }
  v7 = *((unsigned __int16 *)a3 + 2);
  if (!*((_WORD *)a3 + 2))
  {
    KB::String::compute_length((unsigned __int16 *)a3);
    v7 = *((unsigned __int16 *)a3 + 2);
  }
  if (v7 >= v6)
    v6 = v6;
  else
    v6 = v7;
  v8 = (char *)*((_QWORD *)this + 1);
  if (!v8)
    v8 = (char *)this + 16;
  *(_QWORD *)&v28 = v8;
  v9 = *(unsigned __int16 *)this;
  DWORD2(v28) = 0;
  HIDWORD(v28) = v9;
  LODWORD(v29) = 0;
  KB::String::iterator::initialize((uint64_t *)&v28);
  v34 = v28;
  v35 = v29;
  v10 = (char *)*((_QWORD *)a3 + 1);
  if (!v10)
    v10 = (char *)a3 + 16;
  *(_QWORD *)v33 = v10;
  v11 = *(unsigned __int16 *)a3;
  *(_DWORD *)&v33[8] = 0;
  *(_QWORD *)&v33[12] = v11;
  KB::String::iterator::initialize((uint64_t *)v33);
  *(_QWORD *)&v28 = 0;
  *((_QWORD *)&v28 + 1) = &v28;
  v29 = 0x3002000000;
  v30 = __Block_byref_object_copy__18663;
  v31 = __Block_byref_object_dispose__18664;
  v32 = *a2;
  v25 = v34;
  v26 = v35;
  v27 = 0;
  std::__advance[abi:nn180100]<KB::String::iterator>((KB::String::iterator *)&v25, v6);
  v12 = 0;
  v13 = DWORD2(v25);
  v22 = v34;
  v23 = v35;
  v24 = 0;
  v20 = *(_OWORD *)v33;
  v21 = *(_QWORD *)&v33[16];
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 0x40000000;
  v16 = ___ZN2KB30ChooseTopQualityAutocorrection38case_sens_position_of_first_differenceERKNS_6StringERKNSt3__16vectorIjNS4_9allocatorIjEEEES3__block_invoke;
  v17 = &unk_1EA106888;
  v18 = &v28;
  v19 = a2;
  if (DWORD2(v34) != DWORD2(v25))
  {
    do
    {
      LODWORD(v25) = v23;
      v36 = v21;
      if (!((unsigned int (*)(_QWORD *, __int128 *, int *))v16)(v15, &v25, &v36))
        break;
      ++v24;
      KB::String::iterator::operator++((uint64_t *)&v22);
      KB::String::iterator::operator++((uint64_t *)&v20);
    }
    while (DWORD2(v22) != v13);
    v12 = v24;
  }
  _Block_object_dispose(&v28, 8);
  return v12;
}

uint64_t KB::ChooseTopQualityAutocorrection::inactive_prefix_length_for_candidate(KB::ChooseTopQualityAutocorrection *this, const KB::Candidate *a2, const KB::Candidate *a3)
{
  int v3;
  unsigned int v6;

  v3 = (int)a3;
  v6 = KB::Candidate::index_of_word_containing_position(this, a3);
  if (KB::Candidate::does_word_begin_at_position(this, v3))
    v6 -= !KB::Candidate::does_word_begin_at_position(a2, v3);
  return KB::Candidate::length_to_word(this, v6);
}

BOOL KB::ChooseTopQualityAutocorrection::string_contains_word_medial_punctuation(unsigned __int16 *a1, uint64_t a2)
{
  unsigned __int16 *v3;
  uint64_t v4;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  BOOL v12;
  int v14;
  uint64_t v15;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;

  v3 = a1 + 8;
  if (*((_QWORD *)a1 + 1))
    v4 = *((_QWORD *)a1 + 1);
  else
    v4 = (uint64_t)(a1 + 8);
  if (a2)
  {
    v33 = v4;
    v6 = *a1;
    v34 = 0;
    v35 = v6;
    KB::String::iterator::initialize(&v33);
    v29 = v4;
    v30 = v6;
    v31 = v6;
    v32 = 0;
    KB::String::iterator::initialize(&v29);
    v7 = v34;
    v8 = v30;
    if (v34 != v30)
    {
      while (!(*(unsigned int (**)(uint64_t, _QWORD))(a2 + 16))(a2, HIDWORD(v35)))
      {
        KB::String::iterator::operator++(&v33);
        if (v34 == v8)
        {
          v7 = v8;
          goto LABEL_19;
        }
      }
      v7 = v34;
    }
LABEL_19:
    v14 = *a1;
    v15 = *((_QWORD *)a1 + 1);
    if (!v15)
      v15 = (uint64_t)v3;
    v25 = v15;
    v26 = v14;
    v27 = v14;
    v28 = 0;
    KB::String::iterator::initialize(&v25);
    v12 = v7 == v26;
  }
  else
  {
    v21 = v4;
    v9 = *a1;
    v22 = 0;
    v23 = v9;
    v24 = 0;
    KB::String::iterator::initialize(&v21);
    v17 = v4;
    v18 = v9;
    v19 = v9;
    v20 = 0;
    KB::String::iterator::initialize(&v17);
    v10 = v22;
    v11 = v18;
    if (v22 != v18)
    {
      while ((v24 - 38) >= 2)
      {
        if ((v24 - 1523) < 2 || v24 == 8217)
          break;
        KB::String::iterator::operator++(&v21);
        v10 = v22;
        if (v22 == v11)
        {
          v10 = v11;
          break;
        }
      }
    }
    v25 = v4;
    v26 = v9;
    v27 = v9;
    v28 = 0;
    KB::String::iterator::initialize(&v25);
    v12 = v10 == v26;
  }
  return !v12;
}

BOOL KB::ChooseTopQualityAutocorrection::does_candidate_extend_one_letter_word(KB::ChooseTopQualityAutocorrection *this, const KB::Candidate *a2, const KB::Candidate *a3)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v5 = KB::Candidate::length(a2);
  v6 = KB::Candidate::length(this);
  v7 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    v8 = 0;
    v9 = *((_QWORD *)a2 + 1);
    v10 = 240 * v7;
    do
    {
      if ((*(_BYTE *)(v9 + 135) & 4) == 0)
      {
        v11 = *(unsigned __int16 *)(v9 + 4);
        if (!*(_WORD *)(v9 + 4))
        {
          KB::String::compute_length((unsigned __int16 *)v9);
          v11 = *(unsigned __int16 *)(v9 + 4);
        }
        if (v11 == 1)
          ++v8;
      }
      v9 += 240;
      v10 -= 240;
    }
    while (v10);
  }
  else
  {
    v8 = 0;
  }
  v12 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v13 = *((_QWORD *)this + 1);
    v14 = 240 * v12;
    do
    {
      if ((*(_BYTE *)(v13 + 135) & 4) == 0)
      {
        v15 = *(unsigned __int16 *)(v13 + 4);
        if (!*(_WORD *)(v13 + 4))
        {
          KB::String::compute_length((unsigned __int16 *)v13);
          v15 = *(unsigned __int16 *)(v13 + 4);
        }
        v8 -= v15 == 1;
      }
      v13 += 240;
      v14 -= 240;
    }
    while (v14);
  }
  return v5 > v6 && v8 < 0;
}

BOOL KB::ChooseTopQualityAutocorrection::candidate_is_complex(KB::ChooseTopQualityAutocorrection *this, const KB::Candidate *a2, const KB::Candidate *a3, const KB::CandidateFilterResources *a4)
{
  BOOL v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  KB::String *v11;
  KB::String *v12;
  uint64_t v13;
  unint64_t v14;
  const KB::String *v15;
  const KB::String *v16;
  uint64_t v17;
  int8x8_t *v18;
  unint64_t v19;
  uint64_t v20;
  int8x8_t *v21;
  int8x8_t v22;
  uint8x8_t v23;
  uint8x8_t v24;
  uint64_t v25;
  _BOOL8 v26;
  unint64_t v27;
  unsigned int v28;
  unsigned int v29;
  int8x8_t *v31;
  unint64_t v32;
  KB::String *v33;
  uint64_t v34;
  KB::String *v35;
  KB::String *v36;
  int v37;
  __int16 v38;
  char v39;
  void *v40;
  char v41;
  char v42;
  KB::String **v43;
  void *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  KB::Candidate::capitalized_string(this, (uint64_t)&v43);
  v38 = 0;
  v39 = 0;
  v40 = " \t\n";
  v37 = 1048579;
  v42 = 0;
  KB::string_split_after((unsigned __int16 *)&v43, (const KB::String *)&v37, &v35);
  if (v40)
    v7 = v39 == 1;
  else
    v7 = 0;
  if (v7)
    free(v40);
  if (v44 && BYTE6(v43) == 1)
    free(v44);
  KB::Candidate::capitalized_string(a2, (uint64_t)&v43);
  v38 = 0;
  v39 = 0;
  v40 = " \t\n";
  v37 = 1048579;
  v42 = 0;
  KB::string_split_after((unsigned __int16 *)&v43, (const KB::String *)&v37, &v33);
  if (v40 && v39 == 1)
    free(v40);
  if (v44 && BYTE6(v43) == 1)
    free(v44);
  v8 = *((_QWORD *)a3 + 2);
  if (v8)
  {
    do
      v9 = __ldaxr((unsigned int *)v8);
    while (__stlxr(v9 + 1, (unsigned int *)v8));
  }
  v10 = *(_QWORD *)(v8 + 8);
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v8);
  LOBYTE(v43) = 0;
  std::vector<BOOL>::vector(&v31, (v36 - v35) >> 5, (unsigned __int8 *)&v43);
  v11 = v35;
  v12 = v36;
  if (v36 == v35)
  {
    v11 = v36;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    do
    {
      if (v14 >= (v34 - (uint64_t)v33) >> 5)
        break;
      if (v11 == v33)
        goto LABEL_26;
      v15 = (KB::String *)((char *)v11 + v13);
      v16 = (KB::String *)((char *)v33 + v13);
      if (KB::String::equal((KB::String *)((char *)v11 + v13), (KB::String *)((char *)v33 + v13), 1))
        goto LABEL_26;
      v17 = *(_QWORD *)(v10 + 168);
      if (!v17)
        std::__throw_bad_function_call[abi:nn180100]();
      if ((*(unsigned int (**)(uint64_t, const KB::String *, const KB::String *))(*(_QWORD *)v17 + 48))(v17, v16, v15))
      {
        v43 = (KB::String **)&off_1EA103EF8;
        v44 = (void *)1;
        if (KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)&v43, v16, v15, 0, 0))LABEL_26:*(_QWORD *)((char *)v31 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v14;
      }
      ++v14;
      v11 = v35;
      v12 = v36;
      v13 += 32;
    }
    while (v14 < (v36 - v35) >> 5);
  }
  v18 = v31;
  v19 = v32;
  if (v32 < 0x40)
  {
    v20 = 0;
    v21 = v31;
    if (v32)
    {
LABEL_34:
      v24 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)v21 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v19)));
      v24.i16[0] = vaddlv_u8(v24);
      v20 += v24.u32[0];
    }
  }
  else
  {
    v20 = 0;
    v21 = v31;
    do
    {
      v22 = *v21++;
      v23 = (uint8x8_t)vcnt_s8(v22);
      v23.i16[0] = vaddlv_u8(v23);
      v20 += v23.u32[0];
      v19 -= 64;
    }
    while (v19 > 0x3F);
    if (v19)
      goto LABEL_34;
  }
  v25 = v12 - v11;
  if (v20 == v25 >> 5)
  {
LABEL_36:
    v26 = 0;
    goto LABEL_51;
  }
  v27 = v25 >> 5;
  if (v20 + 1 == v27)
  {
    if (v27 >= (v34 - (uint64_t)v33) >> 5)
      goto LABEL_36;
    v28 = KB::Candidate::length(this);
    v37 = 0x100000;
    v38 = 0;
    v39 = 0;
    v40 = 0;
    v41 = 0;
    KB::string_join((unsigned __int16 *)v33, (unsigned __int16 *)((char *)v33 + v36 - v35), (const KB::String *)&v37, (uint64_t)&v43);
    if (v40 && v39 == 1)
      free(v40);
    v29 = WORD2(v43);
    if (!WORD2(v43))
    {
      KB::String::compute_length((unsigned __int16 *)&v43);
      v29 = WORD2(v43);
    }
    v26 = v28 >= v29;
    if (v44 && BYTE6(v43) == 1)
      free(v44);
    v18 = v31;
  }
  else
  {
    v26 = 1;
  }
LABEL_51:
  if (v18)
    operator delete(v18);
  v43 = &v33;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v43);
  v43 = &v35;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v43);
  return v26;
}

BOOL KB::ChooseTopQualityAutocorrection::should_allow_complex_candidate(KB::ChooseTopQualityAutocorrection *this, const KB::Candidate *a2, const KB::Candidate *a3, float a4, const KB::CandidateFilterResources *a5)
{
  unsigned int *v6;
  unsigned int v10;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  float v17;
  float v18;
  unint64_t v19;
  uint64_t v20;
  KB::Word *v21;
  unsigned int *v22;
  unsigned int v23;
  float v24;
  TITokenID v25;
  _BYTE v26[8];
  void *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v6 = (unsigned int *)*((_QWORD *)a3 + 2);
  if (!v6)
    return 1;
  do
    v10 = __ldaxr(v6);
  while (__stlxr(v10 + 1, v6));
  WTF::RefCounted<KB::DictionaryContainer>::deref(v6);
  if (*(_QWORD *)a2 < 2uLL)
    return 1;
  v12 = *((_QWORD *)a3 + 2);
  if (v12)
  {
    do
      v13 = __ldaxr((unsigned int *)v12);
    while (__stlxr(v13 + 1, (unsigned int *)v12));
  }
  v14 = *(_QWORD *)(v12 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v12);
  v15 = KB::Candidate::num_words_preserving_input(a2, this, v14);
  v16 = *(_QWORD *)a2;
  v17 = 1.0;
  v18 = 1.0;
  if (*(_QWORD *)a2 <= (unint64_t)v15)
    return (float)(v18 / v17) >= a4;
  v19 = v15;
  do
  {
    v20 = *((_QWORD *)a2 + 1);
    v21 = (KB::Word *)(v20 + 240 * v19);
    if ((*((_BYTE *)v21 + 135) & 4) == 0 && (*(_BYTE *)(v20 + 240 * v19 + 106) & 4) != 0)
    {
      v22 = (unsigned int *)*((_QWORD *)a3 + 2);
      if (v22)
      {
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 + 1, v22));
      }
      KB::Word::capitalized_string(v21, (uint64_t)v26);
      v25 = *(TITokenID *)(v20 + 240 * v19 + 136);
      v24 = KB::DictionaryContainer::_probability_of_word_with_string_and_id((KB::DictionaryContainer *)v22, (const KB::String *)v26, &v25, 0);
      if (v27 && v26[6] == 1)
        free(v27);
      if (v22)
        WTF::RefCounted<KB::DictionaryContainer>::deref(v22);
      v17 = v17 * v24;
      v18 = v18 * *(float *)(v20 + 240 * v19 + 56);
      v16 = *(_QWORD *)a2;
    }
    ++v19;
  }
  while (v19 < v16);
  return v17 <= 0.0 || (float)(v18 / v17) >= a4;
}

uint64_t __Block_byref_object_copy__18663(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

BOOL ___ZN2KB30ChooseTopQualityAutocorrection38case_sens_position_of_first_differenceERKNS_6StringERKNSt3__16vectorIjNS4_9allocatorIjEEEES3__block_invoke(uint64_t a1, UChar32 *a2, UChar32 *a3)
{
  _BOOL8 result;
  int v7;
  _BYTE *v8;

  if (*a2 != *a3)
  {
    v7 = MEMORY[0x1DF0A2D20]();
    if (v7 != MEMORY[0x1DF0A2D20](*a2) || u_isupper(*a3) && u_islower(*a2))
    {
      result = 0;
      goto LABEL_7;
    }
    if (u_islower(*a3))
    {
      if (u_isupper(*a2))
      {
        v8 = *(_BYTE **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
        if ((unint64_t)v8 < *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8))
        {
          result = (*v8 & 0x10) == 0;
          goto LABEL_7;
        }
      }
    }
  }
  result = 1;
LABEL_7:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) += 4;
  return result;
}

uint64_t KB::ChooseTopQualityAutocorrection::min_stem_length_for_predicting_num_letters(KB::ChooseTopQualityAutocorrection *this, int a2)
{
  char *v2;

  v2 = (char *)this + 24;
  if (a2 == 2)
    v2 = (char *)this + 20;
  if (a2 <= 1)
    v2 = (char *)this + 16;
  return *(unsigned int *)v2;
}

uint64_t fieldName(void *a1, const char *a2)
{
  return objc_msgSend(a1, "stringByAppendingString:", a2);
}

uint64_t bucketedLength(unsigned int a1)
{
  int v1;
  int v2;
  unsigned int v3;

  if (a1 >= 9)
    v1 = 9;
  else
    v1 = 7;
  if (a1 >= 7)
    v2 = v1;
  else
    v2 = 5;
  if (a1 < 5)
    v2 = a1;
  if (a1 >= 3)
    v3 = v2;
  else
    v3 = 1;
  if ((int)a1 >= 1)
    return v3;
  else
    return 0;
}

const __CFString *capitalization(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char v6;
  const __CFString *v7;
  void *v8;
  char v9;
  void *v10;
  int v11;

  v3 = a1;
  v4 = a2;
  objc_msgSend(v3, "capitalizedStringWithLocale:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "isEqualToString:", v3);

  if ((v6 & 1) != 0)
  {
    v7 = CFSTR("initial");
  }
  else
  {
    objc_msgSend(v3, "uppercaseStringWithLocale:", v4);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = objc_msgSend(v8, "isEqualToString:", v3);

    if ((v9 & 1) != 0)
    {
      v7 = CFSTR("upper");
    }
    else
    {
      objc_msgSend(v3, "lowercaseStringWithLocale:", v4);
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      v11 = objc_msgSend(v10, "isEqualToString:", v3);

      if (v11)
        v7 = CFSTR("lower");
      else
        v7 = CFSTR("other");
    }
  }

  return v7;
}

uint64_t diacritics(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  int v5;

  v3 = a1;
  objc_msgSend(v3, "stringByFoldingWithOptions:locale:", 128, a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "isEqualToString:", v3);

  return v5 ^ 1u;
}

BOOL medialPunctuation(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v3;
  void *v4;
  uint64_t v5;

  v1 = a1;
  if ((unint64_t)objc_msgSend(v1, "length") >= 3)
  {
    objc_msgSend(v1, "substringWithRange:", 1, objc_msgSend(v1, "length") - 2);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3500], "punctuationCharacterSet");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = objc_msgSend(v3, "rangeOfCharacterFromSet:", v4);

    v2 = v5 != 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v2 = 0;
  }

  return v2;
}

BOOL containsWhitespace(void *a1)
{
  void *v1;
  id v2;
  void *v3;
  uint64_t v4;

  v1 = (void *)MEMORY[0x1E0CB3500];
  v2 = a1;
  objc_msgSend(v1, "whitespaceCharacterSet");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(v2, "rangeOfCharacterFromSet:", v3);

  return v4 != 0x7FFFFFFFFFFFFFFFLL;
}

double clip(double a1, double a2, double a3)
{
  if (a1 >= a2)
    a2 = a1;
  if (a1 <= a3)
    return a2;
  else
    return a3;
}

unsigned int bucketedScore(double a1)
{
  double v1;
  BOOL v2;
  double v3;

  v1 = a1 * 10.0;
  if (a1 < -10.0)
    v1 = -100.0;
  v2 = a1 <= 0.0;
  v3 = 0.0;
  if (v2)
    v3 = v1;
  return vcvtmd_s64_f64(v3);
}

uint64_t biggestBit(uint64_t a1, uint64_t a2)
{
  if ((int)a1 < (int)a2)
  {
    do
    {
      a2 = a1;
      a1 = ((_DWORD)a1 - 1) & a1;
    }
    while ((_DWORD)a1);
  }
  return a2;
}

id alignmentConfidence(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  if (alignmentConfidence_onceToken != -1)
    dispatch_once(&alignmentConfidence_onceToken, &__block_literal_global_18982);
  v2 = (void *)alignmentConfidence_map;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKeyedSubscript:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void __alignmentConfidence_block_invoke()
{
  uint64_t v0;
  void *v1;
  _QWORD v2[4];
  _QWORD v3[5];

  v3[4] = *MEMORY[0x1E0C80C00];
  v2[0] = &unk_1EA1407E0;
  v2[1] = &unk_1EA1407F8;
  v3[0] = CFSTR("none");
  v3[1] = CFSTR("low");
  v2[2] = &unk_1EA140810;
  v2[3] = &unk_1EA140828;
  v3[2] = CFSTR("mid");
  v3[3] = CFSTR("high");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v3, v2, 4);
  v0 = objc_claimAutoreleasedReturnValue();
  v1 = (void *)alignmentConfidence_map;
  alignmentConfidence_map = v0;

}

id payloadForText(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v26;
  void *v27;
  _QWORD v28[5];
  _QWORD v29[6];

  v29[5] = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  v7 = a2;
  objc_msgSend(CFSTR("length"), "stringByAppendingString:", v7);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28[0] = v27;
  v8 = (void *)MEMORY[0x1E0CB37E8];
  v9 = objc_msgSend(v5, "length");
  if (v9 >= 9)
    v10 = 9;
  else
    v10 = 7;
  if (v9 >= 7)
    v11 = v10;
  else
    v11 = 5;
  if (v9 < 5)
    v11 = v9;
  if (v9 >= 3)
    v12 = v11;
  else
    v12 = 1;
  if ((int)v9 >= 1)
    v13 = v12;
  else
    v13 = 0;
  objc_msgSend(v8, "numberWithInt:", v13);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v29[0] = v26;
  objc_msgSend(CFSTR("capitalization"), "stringByAppendingString:", v7);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v28[1] = v14;
  capitalization(v5, v6);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v29[1] = v15;
  objc_msgSend(CFSTR("diacritics"), "stringByAppendingString:", v7);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v28[2] = v16;
  v17 = (void *)MEMORY[0x1E0CB37E8];
  v18 = diacritics(v5, (uint64_t)v6);

  objc_msgSend(v17, "numberWithBool:", v18);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v29[2] = v19;
  objc_msgSend(CFSTR("punctuation"), "stringByAppendingString:", v7);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v28[3] = v20;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", medialPunctuation(v5));
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v29[3] = v21;
  objc_msgSend(CFSTR("multiword"), "stringByAppendingString:", v7);
  v22 = (void *)objc_claimAutoreleasedReturnValue();

  v28[4] = v22;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", containsWhitespace(v5));
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v29[4] = v23;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v29, v28, 5);
  v24 = (void *)objc_claimAutoreleasedReturnValue();

  return v24;
}

id mergeDicts(void *a1)
{
  id v1;
  void *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v3 = v1;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v11;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v11 != v6)
          objc_enumerationMutation(v3);
        objc_msgSend(v2, "addEntriesFromDictionary:", *(_QWORD *)(*((_QWORD *)&v10 + 1) + 8 * v7++), (_QWORD)v10);
      }
      while (v5 != v7);
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
    }
    while (v5);
  }

  v8 = (void *)objc_msgSend(v2, "copy");
  return v8;
}

float KB::ContinuousPathDetector::Parameters::user_value_for_key(const __CFString *this, const __CFString *a2, float a3, float a4, float a5)
{
  const __CFNumber *v8;
  const __CFNumber *v9;
  float v10;
  float valuePtr;

  v8 = (const __CFNumber *)CFPreferencesCopyAppValue(this, CFSTR("com.apple.keyboard"));
  v9 = v8;
  valuePtr = a3;
  if (v8 && CFNumberGetValue(v8, kCFNumberFloatType, &valuePtr))
    a3 = valuePtr;
  if (a3 > a5)
    v10 = a5;
  else
    v10 = a3;
  if (a3 >= a4)
    a4 = v10;
  if (v9)
    CFRelease(v9);
  return a4;
}

void KB::ContinuousPathDetector::Parameters::user_parameters(const __CFString *a1@<X1>, uint64_t a2@<X8>)
{
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  float v7;
  const __CFString *v8;
  float v9;
  const __CFString *v10;
  float v11;
  float v12;

  *(_OWORD *)a2 = xmmword_1DA911000;
  *(_QWORD *)(a2 + 16) = 0x40A0000040000000;
  if (TI_IS_INTERNAL_INSTALL::once_token != -1)
    dispatch_once(&TI_IS_INTERNAL_INSTALL::once_token, &__block_literal_global_3460);
  if (TI_IS_INTERNAL_INSTALL::is_internal_install)
  {
    *(float *)a2 = KB::ContinuousPathDetector::Parameters::user_value_for_key(CFSTR("CPDetectorDecayRate"), a1, -0.347, -10.0, -0.001);
    *(float *)(a2 + 4) = KB::ContinuousPathDetector::Parameters::user_value_for_key(CFSTR("CPDetectorPathWeight"), v4, 5.0, 0.01, 100.0);
    *(float *)(a2 + 8) = KB::ContinuousPathDetector::Parameters::user_value_for_key(CFSTR("CPDetectorTotalPseudoWeight"), v5, 5.0, 0.01, 100.0);
    v7 = KB::ContinuousPathDetector::Parameters::user_value_for_key(CFSTR("CPDetectorMinThreshold"), v6, 1.0, 0.01, 100.0);
    *(float *)(a2 + 12) = v7;
    v9 = KB::ContinuousPathDetector::Parameters::user_value_for_key(CFSTR("CPDetectorNeutralThreshold"), v8, 2.0, 0.01, 100.0);
    *(float *)(a2 + 16) = v9;
    v11 = KB::ContinuousPathDetector::Parameters::user_value_for_key(CFSTR("CPDetectorMaxThreshold"), v10, 5.0, 0.01, 100.0);
    *(float *)(a2 + 20) = v11;
    if (v9 < v7 || v11 < v9)
    {
      v12 = v9 * 0.5;
      if ((float)(v9 * 0.5) >= v7)
        v12 = v7;
      *(float *)(a2 + 12) = v12;
      if (v11 < (float)(v9 + v9))
        v11 = v9 + v9;
      *(float *)(a2 + 20) = v11;
    }
  }
}

float KB::ContinuousPathDetector::AnnotatedPath::horizontal_scale(KB::ContinuousPathDetector::AnnotatedPath *this)
{
  TI::Favonius::KeyboardLayout *v1;

  v1 = (TI::Favonius::KeyboardLayout *)*((_QWORD *)this + 6);
  if (v1)
    return TI::Favonius::KeyboardLayout::median_key_half_width(v1);
  else
    return 15.0;
}

float KB::ContinuousPathDetector::AnnotatedPath::vertical_scale(KB::ContinuousPathDetector::AnnotatedPath *this)
{
  TI::Favonius::KeyboardLayout *v1;

  v1 = (TI::Favonius::KeyboardLayout *)*((_QWORD *)this + 6);
  if (v1)
    return TI::Favonius::KeyboardLayout::median_key_half_height(v1);
  else
    return 22.0;
}

float KB::ContinuousPathDetector::AnnotatedPath::normalized_length(KB::ContinuousPathDetector::AnnotatedPath *this)
{
  float v2;
  TI::Favonius::KeyboardLayout *v3;
  float v4;
  float v5;

  v2 = *((float *)this + 15);
  v3 = (TI::Favonius::KeyboardLayout *)*((_QWORD *)this + 6);
  if (v3)
  {
    v4 = TI::Favonius::KeyboardLayout::median_key_half_width(*((TI::Favonius::KeyboardLayout **)this + 6));
    v5 = TI::Favonius::KeyboardLayout::median_key_half_height(v3);
  }
  else
  {
    v5 = 22.0;
    v4 = 15.0;
  }
  return hypotf(v2 / v4, *((float *)this + 16) / v5);
}

double KB::ContinuousPathDetector::AnnotatedPath::add_touch_event(TI::CP::Path *this, uint64_t a2)
{
  uint64_t v4;
  CGPoint v5;
  CGFloat y;
  double result;

  v4 = *((_QWORD *)this + 1);
  v5 = *(CGPoint *)(a2 + 8);
  if (*(_QWORD *)this != v4)
    *(float32x2_t *)((char *)this + 60) = vcvt_f32_f64(vaddq_f64(vabdq_f64(*(float64x2_t *)(v4 - 48), (float64x2_t)v5), vcvtq_f64_f32(*(float32x2_t *)((char *)this + 60))));
  y = v5.y;
  TI::CP::Path::append(this, v5, *(CGFloat *)(a2 + 32), 1.0, -1.0, 0.0);
  result = *(double *)(a2 + 40);
  *(double *)((char *)this + 68) = result;
  return result;
}

int *KB::ContinuousPathDetector::AnnotatedPath::key_string(KB::ContinuousPathDetector::AnnotatedPath *this)
{
  uint64_t v1;
  unsigned int **v2;
  unsigned int **v3;
  uint64_t v4;
  int *v5;
  unsigned __int8 v6;
  _QWORD v8[2];
  uint64_t (*v9)(uint64_t, unsigned int **);
  void *v10;
  uint64_t *v11;
  KB::ContinuousPathDetector::AnnotatedPath *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t (*v16)(uint64_t, uint64_t);
  uint64_t (*v17)(uint64_t);
  uint64_t v18;

  v13 = 0;
  v14 = &v13;
  v15 = 0x3002000000;
  v16 = __Block_byref_object_copy__19015;
  v17 = __Block_byref_object_dispose__19016;
  v18 = 0;
  v1 = *((_QWORD *)this + 6);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v9 = ___ZNK2KB22ContinuousPathDetector13AnnotatedPath10key_stringEv_block_invoke;
  v10 = &unk_1EA1069A0;
  v11 = &v13;
  v12 = this;
  v2 = *(unsigned int ***)(v1 + 8);
  v3 = *(unsigned int ***)(v1 + 16);
  if (v2 == v3)
    goto LABEL_5;
  do
    v9((uint64_t)v8, v2++);
  while (v2 != v3);
  v4 = v14[5];
  if (!v4)
  {
LABEL_5:
    if ((v6 & 1) != 0)
    {
      v5 = &KB::ContinuousPathDetector::AnnotatedPath::key_string(void)const::empty_string;
    }
    else
    {
      v5 = &KB::ContinuousPathDetector::AnnotatedPath::key_string(void)const::empty_string;
      {
        KB::ContinuousPathDetector::AnnotatedPath::key_string(void)const::empty_string = 0x100000;
        word_1F0282DEC = 0;
        byte_1F0282DEE = 0;
        qword_1F0282DF0 = 0;
        byte_1F0282DF8 = 0;
        __cxa_atexit((void (*)(void *))KB::String::~String, &KB::ContinuousPathDetector::AnnotatedPath::key_string(void)const::empty_string, &dword_1DA6F2000);
      }
    }
  }
  else
  {
    v5 = (int *)(v4 + 8);
  }
  _Block_object_dispose(&v13, 8);
  if (v18)
    WTF::RefCounted<TI::Favonius::Key>::deref(v18);
  return v5;
}

uint64_t __Block_byref_object_copy__19015(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(result + 40) = v2;
  return result;
}

uint64_t __Block_byref_object_dispose__19016(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 40);
  if (result)
    return WTF::RefCounted<TI::Favonius::Key>::deref(result);
  return result;
}

uint64_t ___ZNK2KB22ContinuousPathDetector13AnnotatedPath10key_stringEv_block_invoke(uint64_t result, unsigned int **a2)
{
  unsigned int *v2;
  uint64_t v3;
  unsigned int v4;

  v2 = *a2;
  if (*(_DWORD *)(*(_QWORD *)(result + 40) + 76) == *((__int16 *)*a2 + 31))
  {
    v3 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
    do
      v4 = __ldaxr(v2);
    while (__stlxr(v4 + 1, v2));
    result = *(_QWORD *)(v3 + 40);
    *(_QWORD *)(v3 + 40) = v2;
    if (result)
      return WTF::RefCounted<TI::Favonius::Key>::deref(result);
  }
  return result;
}

uint64_t KB::ContinuousPathDetector::ContinuousPathDetector(uint64_t this, const KB::ContinuousPathDetector::Parameters *a2, double a3)
{
  __int128 v3;

  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)this = this + 8;
  v3 = *(_OWORD *)a2;
  *(_QWORD *)(this + 40) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(this + 24) = v3;
  *(double *)(this + 48) = a3;
  *(_QWORD *)(this + 56) = 0;
  return this;
}

{
  __int128 v3;

  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)this = this + 8;
  v3 = *(_OWORD *)a2;
  *(_QWORD *)(this + 40) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(this + 24) = v3;
  *(double *)(this + 48) = a3;
  *(_QWORD *)(this + 56) = 0;
  return this;
}

BOOL KB::ContinuousPathDetector::looks_like_continuous_path(KB::ContinuousPathDetector *this, int a2)
{
  uint64_t v2;
  _DWORD *v4;
  int v5;
  BOOL v6;
  uint64_t *v7;
  float v9;
  float v10;
  float v11;
  float v12;

  v2 = *((_QWORD *)this + 1);
  if (!v2)
    return 0;
  v4 = (_DWORD *)((char *)this + 8);
  do
  {
    v5 = *(_DWORD *)(v2 + 32);
    v6 = v5 < a2;
    if (v5 >= a2)
      v7 = (uint64_t *)v2;
    else
      v7 = (uint64_t *)(v2 + 8);
    if (!v6)
      v4 = (_DWORD *)v2;
    v2 = *v7;
  }
  while (*v7);
  if (v4 == (_DWORD *)((char *)this + 8) || v4[8] > a2)
    return 0;
  if (v4[29] == -2)
    return 1;
  v9 = KB::ContinuousPathDetector::AnnotatedPath::normalized_length((KB::ContinuousPathDetector::AnnotatedPath *)(v4 + 10));
  v10 = *((float *)this + 11);
  v11 = *((float *)this + 9);
  v12 = (float)(*((float *)this + 14)
              + (float)(*((float *)this + 8)
                      * (float)(1.0 - (float)((float)(v10 - *((float *)this + 10)) / (float)(v10 - v11)))))
      / (float)((float)(*((float *)this + 14) + *((float *)this + 8))
              + (float)(*((float *)this + 7) * *((float *)this + 15)));
  return v9 > (float)((float)(v10 * v12) + (float)((float)(1.0 - v12) * v11)) && v4[28] == 3;
}

float KB::ContinuousPathDetector::detection_threshold(KB::ContinuousPathDetector *this)
{
  float v1;
  float v2;
  float v3;

  v1 = *((float *)this + 11);
  v2 = *((float *)this + 9);
  v3 = (float)(*((float *)this + 14)
             + (float)(*((float *)this + 8)
                     * (float)(1.0 - (float)((float)(v1 - *((float *)this + 10)) / (float)(v1 - v2)))))
     / (float)((float)(*((float *)this + 8) + *((float *)this + 14))
             + (float)(*((float *)this + 7) * *((float *)this + 15)));
  return (float)(v1 * v3) + (float)((float)(1.0 - v3) * v2);
}

void KB::ContinuousPathDetector::observe_touch_event(_QWORD **a1, uint64_t *a2, int a3, int a4)
{
  uint64_t v4;
  double v8;
  double v9;
  float v10;
  float32x2_t v11;
  int v12;
  uint64_t **v13;
  _QWORD *v14;
  _QWORD *v15;
  unsigned int *v16;
  unsigned int v17;
  uint64_t *v18;
  uint64_t **v19;
  int v20;
  int v21;
  _QWORD *v22;
  uint64_t *v23;
  _QWORD *v24;
  uint64_t *v25;
  int v26;
  BOOL v27;
  _QWORD *v28;
  const KB::ContinuousPathDetector::AnnotatedPath *v29;
  int v30;
  int v31;

  v4 = *a2;
  if (!*a2)
    return;
  v8 = *(double *)(v4 + 32);
  v9 = v8 - *((double *)a1 + 6);
  if (v9 < 0.0)
    v9 = 0.0;
  v10 = v9 * *((float *)a1 + 6);
  v11 = vmul_n_f32((float32x2_t)a1[7], expf(v10));
  *((double *)a1 + 6) = v8;
  a1[7] = (_QWORD *)v11;
  v12 = *(_DWORD *)(v4 + 48);
  v31 = v12;
  if (!*(_DWORD *)(v4 + 40))
  {
    v24 = a1[1];
    if (v24)
    {
      v25 = (uint64_t *)(a1 + 1);
      do
      {
        v26 = *((_DWORD *)v24 + 8);
        v27 = v26 < v12;
        if (v26 >= v12)
          v28 = v24;
        else
          v28 = v24 + 1;
        if (!v27)
          v25 = v24;
        v24 = (_QWORD *)*v28;
      }
      while (*v28);
      if (v25 != (uint64_t *)(a1 + 1) && v12 >= *((_DWORD *)v25 + 8))
      {
        std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::__remove_node_pointer(a1, v25);
        std::__destroy_at[abi:nn180100]<std::pair<int const,KB::ContinuousPathDetector::AnnotatedPath>,0>(v25 + 4);
        operator delete(v25);
      }
    }
  }
  v13 = a1 + 1;
  v14 = operator new(0x78uLL);
  *((_DWORD *)v14 + 8) = v12;
  v15 = v14 + 4;
  *(_OWORD *)(v14 + 5) = 0u;
  *(_OWORD *)(v14 + 7) = 0u;
  *(_OWORD *)(v14 + 9) = 0u;
  v16 = *(unsigned int **)(v4 + 56);
  v14[11] = v16;
  if (v16)
  {
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 + 1, v16));
  }
  *((_DWORD *)v14 + 25) = 0;
  *((_DWORD *)v14 + 26) = 0;
  *((_DWORD *)v14 + 24) = v12;
  *(_QWORD *)((char *)v14 + 108) = 7;
  *((_DWORD *)v14 + 29) = -1;
  v18 = *v13;
  v19 = a1 + 1;
  if (*v13)
  {
    v20 = *(_DWORD *)v15;
    while (1)
    {
      while (1)
      {
        v19 = (uint64_t **)v18;
        v21 = *((_DWORD *)v18 + 8);
        if (v20 >= v21)
          break;
        v18 = *v19;
        v13 = v19;
        if (!*v19)
          goto LABEL_15;
      }
      if (v21 >= v20)
        break;
      v18 = v19[1];
      if (!v18)
      {
        v13 = v19 + 1;
        goto LABEL_15;
      }
    }
    std::__destroy_at[abi:nn180100]<std::pair<int const,KB::ContinuousPathDetector::AnnotatedPath>,0>(v15);
    operator delete(v14);
    v14 = v19;
  }
  else
  {
LABEL_15:
    *v14 = 0;
    v14[1] = 0;
    v14[2] = v19;
    *v13 = v14;
    v22 = (_QWORD *)**a1;
    v23 = v14;
    if (v22)
    {
      *a1 = v22;
      v23 = *v13;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v23);
    a1[2] = (_QWORD *)((char *)a1[2] + 1);
  }
  KB::ContinuousPathDetector::AnnotatedPath::add_touch_event((TI::CP::Path *)(v14 + 5), v4);
  if (a4 != -1)
    goto LABEL_33;
  if (KB::ContinuousPathDetector::looks_like_continuous_path((KB::ContinuousPathDetector *)a1, v31))
  {
    a4 = -2;
LABEL_33:
    *((_DWORD *)v14 + 29) = a4;
  }
  if (*((_DWORD *)v14 + 27) != 2)
    return;
  v30 = *((_DWORD *)v14 + 29);
  if ((a3 & 0x80000000) == 0 && v30 == -1)
  {
    *((_DWORD *)v14 + 29) = a3;
LABEL_41:
    if (KB::ContinuousPathDetector::should_count_tap((KB::ContinuousPathDetector *)(v14 + 5), v29))
      *((float *)a1 + 14) = *((float *)a1 + 14) + 1.0;
    return;
  }
  if (v30 == -2)
  {
    *((float *)a1 + 15) = *((float *)a1 + 15) + 1.0;
    return;
  }
  if ((v30 & 0x80000000) == 0)
    goto LABEL_41;
}

BOOL KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector *this, const KB::ContinuousPathDetector::AnnotatedPath *a2)
{
  unsigned __int8 v3;
  unsigned __int8 v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  int *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  KB::String *v12;

  if ((v3 & 1) == 0
  {
    word_1EDAEE56C = 0;
    byte_1EDAEE56E = 0;
    qword_1EDAEE570 = (uint64_t)" ";
    KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::space_key = 1048577;
    byte_1EDAEE579 = 0;
    __cxa_atexit((void (*)(void *))KB::String::~String, &KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::space_key, &dword_1DA6F2000);
  }
  if ((v4 & 1) == 0
  {
    word_1EDAEE52C = 0;
    byte_1EDAEE52E = 0;
    qword_1EDAEE530 = (uint64_t)"\b";
    KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::backspace_key = 1048577;
    byte_1EDAEE539 = 0;
    __cxa_atexit((void (*)(void *))KB::String::~String, &KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::backspace_key, &dword_1DA6F2000);
  }
  if ((v5 & 1) == 0
  {
    word_1EDAEE50C = 0;
    byte_1EDAEE50E = 0;
    qword_1EDAEE510 = (uint64_t)"\n";
    KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::return_key = 1048577;
    byte_1EDAEE519 = 0;
    __cxa_atexit((void (*)(void *))KB::String::~String, &KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::return_key, &dword_1DA6F2000);
  }
  if ((v6 & 1) == 0
  {
    word_1EDAEE54C = 0;
    byte_1EDAEE54E = 0;
    qword_1EDAEE550 = (uint64_t)"\x0E";
    KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::shift_key = 1048577;
    byte_1EDAEE559 = 0;
    __cxa_atexit((void (*)(void *))KB::String::~String, &KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::shift_key, &dword_1DA6F2000);
  }
  v7 = KB::ContinuousPathDetector::AnnotatedPath::key_string(this);
  v8 = *((_QWORD *)this + 6);
  v9 = *(unsigned int *)(v8 + 200);
  v10 = (unint64_t)((uint64_t)(*(_QWORD *)(v8 + 16) - *(_QWORD *)(v8 + 8)) >> 3) >> 1;
  if (v9 <= 0xB && v10 >= v9)
    return 0;
  v12 = (KB::String *)v7;
  return !KB::String::equal((KB::String *)v7, (const KB::String *)&KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::space_key, 1)&& !KB::String::equal(v12, (const KB::String *)&KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::return_key, 1)&& !KB::String::equal(v12, (const KB::String *)&KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::backspace_key, 1)&& !KB::String::equal(v12, (const KB::String *)&KB::ContinuousPathDetector::should_count_tap(KB::ContinuousPathDetector::AnnotatedPath const&)::shift_key, 1);
}

uint64_t *std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

float32x2_t KB::ContinuousPathDetector::update_clock_and_decay_counts(KB::ContinuousPathDetector *this, double a2)
{
  double v4;
  float v5;
  float32x2_t result;

  v4 = a2 - *((double *)this + 6);
  if (v4 < 0.0)
    v4 = 0.0;
  v5 = v4 * *((float *)this + 6);
  result = vmul_n_f32(*(float32x2_t *)((char *)this + 56), expf(v5));
  *((double *)this + 6) = a2;
  *((float32x2_t *)this + 7) = result;
  return result;
}

uint64_t KB::ContinuousPathDetector::num_touch_paths(KB::ContinuousPathDetector *this)
{
  return *((_QWORD *)this + 2);
}

void KB::ContinuousPathDetector::clear_completed_paths(uint64_t **this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t *v4;
  uint64_t *v5;
  BOOL v6;

  v2 = (uint64_t *)(this + 1);
  v1 = *this;
  if (*this != (uint64_t *)(this + 1))
  {
    do
    {
      if ((*((_DWORD *)v1 + 27) - 2) > 3)
      {
        v5 = (uint64_t *)v1[1];
        if (v5)
        {
          do
          {
            v4 = v5;
            v5 = (uint64_t *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            v4 = (uint64_t *)v1[2];
            v6 = *v4 == (_QWORD)v1;
            v1 = v4;
          }
          while (!v6);
        }
      }
      else
      {
        v4 = std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::__remove_node_pointer(this, v1);
        std::__destroy_at[abi:nn180100]<std::pair<int const,KB::ContinuousPathDetector::AnnotatedPath>,0>(v1 + 4);
        operator delete(v1);
      }
      v1 = v4;
    }
    while (v4 != v2);
  }
}

BOOL KB::ContinuousPathDetector::touch_stage_finishes_path(int a1)
{
  return (a1 - 2) < 4;
}

float KB::ContinuousPathDetector::prior_probability_of_tap(KB::ContinuousPathDetector *this)
{
  return (float)(*((float *)this + 14)
               + (float)(*((float *)this + 8)
                       * (float)(1.0
                               - (float)((float)(*((float *)this + 11) - *((float *)this + 10))
                                       / (float)(*((float *)this + 11) - *((float *)this + 9))))))
       / (float)((float)(*((float *)this + 8) + *((float *)this + 14))
               + (float)(*((float *)this + 7) * *((float *)this + 15)));
}

float KB::ContinuousPathDetector::prior_probability_of_path(KB::ContinuousPathDetector *this)
{
  return 1.0
       - (float)((float)(*((float *)this + 14)
                       + (float)(*((float *)this + 8)
                               * (float)(1.0
                                       - (float)((float)(*((float *)this + 11) - *((float *)this + 10))
                                               / (float)(*((float *)this + 11) - *((float *)this + 9))))))
               / (float)((float)(*((float *)this + 8) + *((float *)this + 14))
                       + (float)(*((float *)this + 7) * *((float *)this + 15))));
}

void KB::ContinuousPathDetector::description(KB::ContinuousPathDetector *this@<X0>, uint64_t a2@<X8>)
{
  float v4;
  float v5;
  float v6;
  KB::ContinuousPathDetector *v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  float v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  KB::String *v19;
  KB::String *v20;
  char *v21;
  char *v22;
  int64x2_t v23;
  unint64_t v24;
  KB::ContinuousPathDetector *v25;
  KB::ContinuousPathDetector *v26;
  BOOL v27;
  const KB::String *v28;
  const KB::String *v29;
  const char *v30;
  int64x2_t v31;
  unint64_t v32;
  _BYTE v33[8];
  void *v34;
  int64x2_t *v35;
  void *v36[2];
  unint64_t v37;
  unint64_t *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a2 = 0x100000;
  *(_WORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 6) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  v4 = *((float *)this + 11);
  v5 = *((float *)this + 9);
  v6 = (float)(*((float *)this + 14)
             + (float)(*((float *)this + 8)
                     * (float)(1.0 - (float)((float)(v4 - *((float *)this + 10)) / (float)(v4 - v5)))))
     / (float)((float)(*((float *)this + 8) + *((float *)this + 14))
             + (float)(*((float *)this + 7) * *((float *)this + 15)));
  KB::String::append_format((KB::String *)a2, "<ContinuousPathDetector: clock=%.2f Pr(Tap)=%.3g Pr(Path)=%.3g threshold=%.3g", *((double *)this + 6), v6, (float)(1.0 - v6), (float)((float)(v4 * v6) + (float)((float)(1.0 - v6) * v5)));
  v31 = 0uLL;
  v32 = 0;
  v7 = *(KB::ContinuousPathDetector **)this;
  if (*(KB::ContinuousPathDetector **)this == (KB::ContinuousPathDetector *)((char *)this + 8))
  {
    v29 = 0;
    v28 = 0;
  }
  else
  {
    do
    {
      v8 = *((unsigned int *)v7 + 27);
      v9 = "?";
      if (v8 <= 3)
        v9 = off_1EA1069C0[v8];
      if (*((_DWORD *)v7 + 29) == -2)
        v10 = "yes";
      else
        v10 = "no";
      v11 = *((unsigned int *)v7 + 24);
      v12 = KB::ContinuousPathDetector::AnnotatedPath::normalized_length((KB::ContinuousPathDetector *)((char *)v7 + 40));
      KB::String::format((KB::String *)"%d{len=%.3g,stg=%s,cp=%s}", (uint64_t)v33, v11, v12, v9, v10);
      if (v31.i64[1] >= v32)
      {
        v14 = (v31.i64[1] - v31.i64[0]) >> 5;
        if ((unint64_t)(v14 + 1) >> 59)
          abort();
        v15 = (uint64_t)(v32 - v31.i64[0]) >> 4;
        if (v15 <= v14 + 1)
          v15 = v14 + 1;
        if (v32 - v31.i64[0] >= 0x7FFFFFFFFFFFFFE0)
          v16 = 0x7FFFFFFFFFFFFFFLL;
        else
          v16 = v15;
        v38 = &v32;
        if (v16)
          v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v16);
        else
          v17 = 0;
        v18 = (char *)(v16 + 32 * v14);
        v35 = (int64x2_t *)v16;
        v36[0] = v18;
        v37 = v16 + 32 * v17;
        KB::String::String((KB::String *)v18, (const KB::String *)v33);
        v13 = v18 + 32;
        v36[1] = v18 + 32;
        v19 = (KB::String *)v31.i64[1];
        v20 = (KB::String *)v31.i64[0];
        v21 = (char *)v36[0];
        if (v31.i64[1] == v31.i64[0])
        {
          v23 = vdupq_n_s64(v31.u64[1]);
        }
        else
        {
          v22 = (char *)v36[0] - 32;
          do
          {
            *(_DWORD *)v22 = 0x100000;
            v19 = (KB::String *)((char *)v19 - 32);
            *((_WORD *)v22 + 2) = 0;
            v22[6] = 0;
            *((_QWORD *)v22 + 1) = 0;
            v21 = (char *)KB::String::operator=((uint64_t)v22, v19);
            v22 = v21 - 32;
          }
          while (v19 != v20);
          v23 = v31;
          v13 = (char *)v36[1];
        }
        v31.i64[0] = (uint64_t)v21;
        v31.i64[1] = (uint64_t)v13;
        *(int64x2_t *)v36 = v23;
        v24 = v32;
        v32 = v37;
        v37 = v24;
        v35 = (int64x2_t *)v23.i64[0];
        std::__split_buffer<KB::String>::~__split_buffer((uint64_t)&v35);
      }
      else
      {
        v13 = (char *)KB::String::String((KB::String *)v31.i64[1], (const KB::String *)v33) + 32;
      }
      v31.i64[1] = (uint64_t)v13;
      if (v34 && v33[6] == 1)
        free(v34);
      v25 = (KB::ContinuousPathDetector *)*((_QWORD *)v7 + 1);
      if (v25)
      {
        do
        {
          v26 = v25;
          v25 = *(KB::ContinuousPathDetector **)v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          v26 = (KB::ContinuousPathDetector *)*((_QWORD *)v7 + 2);
          v27 = *(_QWORD *)v26 == (_QWORD)v7;
          v7 = v26;
        }
        while (!v27);
      }
      v7 = v26;
    }
    while (v26 != (KB::ContinuousPathDetector *)((char *)this + 8));
    v29 = (const KB::String *)v31.i64[1];
    v28 = (const KB::String *)v31.i64[0];
  }
  LODWORD(v35) = 0x100000;
  WORD2(v35) = 0;
  BYTE6(v35) = 0;
  v36[0] = 0;
  LOBYTE(v36[1]) = 0;
  if (v28 == v29)
    goto LABEL_42;
  do
  {
    if ((_WORD)v35)
      KB::String::append((unsigned __int16 *)&v35, ", ", 0xFFFFuLL);
    KB::String::append((unsigned __int16 *)&v35, v28);
    v28 = (const KB::String *)((char *)v28 + 32);
  }
  while (v28 != v29);
  v30 = (const char *)v36[0];
  if (!v36[0])
    v30 = (const char *)&v36[1];
  if (!(_WORD)v35)
LABEL_42:
    v30 = "";
  KB::String::append_format((KB::String *)a2, "; path=[%s]", v30);
  KB::String::append((unsigned __int16 *)a2, ">", 0xFFFFuLL);
  if (v36[0] && BYTE6(v35) == 1)
    free(v36[0]);
  v35 = &v31;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
}

id mecabraCreationQueue()
{
  if (mecabraCreationQueue_onceToken != -1)
    dispatch_once(&mecabraCreationQueue_onceToken, &__block_literal_global_19432);
  return (id)mecabraCreationQueue___queue;
}

void __mecabraCreationQueue_block_invoke()
{
  dispatch_queue_t v0;
  void *v1;
  NSObject *v2;

  dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  v2 = objc_claimAutoreleasedReturnValue();
  v0 = dispatch_queue_create("com.apple.TextInput.mecabra.creation", v2);
  v1 = (void *)mecabraCreationQueue___queue;
  mecabraCreationQueue___queue = (uint64_t)v0;

}

uint64_t _wordEntryInputStringContainsOnlyWordSeparatorFromSession(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;

  v3 = a1;
  objc_msgSend(a2, "sessionParams");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "wordSeparator");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v3, "acceptedCandidate");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v6, "input");
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = objc_msgSend(v5, "isEqualToString:", v7);
  return v8;
}

BOOL _wordEntryAcceptedStringWasEmpty(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  _BOOL8 v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t i;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(v1, "acceptedString");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "length");

  if (v3)
  {
    v4 = 0;
  }
  else
  {
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    objc_msgSend(v1, "allKeyboardInputs", 0);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
    if (v6)
    {
      v7 = v6;
      v8 = 0;
      v9 = *(_QWORD *)v13;
      do
      {
        for (i = 0; i != v7; ++i)
        {
          if (*(_QWORD *)v13 != v9)
            objc_enumerationMutation(v5);
          if (objc_msgSend(*(id *)(*((_QWORD *)&v12 + 1) + 8 * i), "isBackspace"))
            --v8;
          else
            ++v8;
        }
        v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      }
      while (v7);
      v4 = v8 < 1;
    }
    else
    {
      v4 = 1;
    }

  }
  return v4;
}

uint64_t _doesWordEntryContainDiacritics(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t doesStringContainDiacritics;
  void *v8;
  void *v9;

  v3 = a1;
  objc_msgSend(v3, "keyboardState");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "inputMode");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  TIInputModeGetLanguageWithRegion();
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  if ((objc_msgSend(&unk_1EA1401B0, "containsObject:", v6) & 1) != 0)
  {
    doesStringContainDiacritics = 0;
  }
  else
  {
    if ((a2 & 1) != 0)
    {
      objc_msgSend(v3, "acceptedCandidate");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "input");
      v9 = (void *)objc_claimAutoreleasedReturnValue();

    }
    else
    {
      objc_msgSend(v3, "acceptedString");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
    }
    doesStringContainDiacritics = _doesStringContainDiacritics(v9);

  }
  return doesStringContainDiacritics;
}

uint64_t _doesStringContainDiacritics(void *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  objc_msgSend(a1, "decomposedStringWithCanonicalMapping");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "stringByApplyingTransform:reverse:", *MEMORY[0x1E0C99880], 0);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v1, "isEqualToString:", v2) ^ 1;

  return v3;
}

BOOL _doesWordEntryContainApostrophe(void *a1, char a2)
{
  void *v2;
  void *v3;
  _BOOL8 doesStringContainApostrophe;

  if ((a2 & 1) != 0)
  {
    objc_msgSend(a1, "acceptedCandidate");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "input");
    v3 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    objc_msgSend(a1, "acceptedString");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
  }
  doesStringContainApostrophe = _doesStringContainApostrophe(v3);

  return doesStringContainApostrophe;
}

BOOL _doesStringContainApostrophe(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;

  v1 = a1;
  objc_msgSend(MEMORY[0x1E0CB3500], "characterSetWithCharactersInString:", CFSTR("'"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
    v3 = objc_msgSend(v1, "rangeOfCharacterFromSet:", v2) != 0x7FFFFFFFFFFFFFFFLL;
  else
    v3 = 0;

  return v3;
}

uint64_t _doesWordEntryHaveLeftHandContext(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;

  v1 = a1;
  objc_msgSend(v1, "documentState");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "contextBeforeInput");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  if (v3)
  {
    objc_msgSend(v1, "documentState");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "contextBeforeInput");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    if (v5)
    {
      objc_msgSend(v1, "documentState");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "contextBeforeInput");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      v8 = objc_msgSend(v7, "isEqualToString:", &stru_1EA1081D0) ^ 1;

    }
    else
    {
      v8 = 0;
    }

  }
  else
  {
    v8 = 0;
  }

  return v8;
}

__CFString *_capitalizationForStringUsingLocale(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  __CFString **v6;
  void *v7;
  int v8;
  __CFString *v9;

  v3 = a2;
  objc_msgSend(a1, "decomposedStringWithCanonicalMapping");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "lowercaseStringWithLocale:", v3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v4, "isEqualToString:", v5) & 1) != 0)
  {
    v6 = kTIACRACapitalizationLower;
  }
  else
  {
    objc_msgSend(v4, "capitalizedStringWithLocale:", v3);
    v7 = (void *)objc_claimAutoreleasedReturnValue();

    if ((objc_msgSend(v4, "isEqualToString:", v7) & 1) != 0)
    {
      v6 = kTIACRACapitalizationTitle;
      v5 = v7;
    }
    else
    {
      objc_msgSend(v4, "uppercaseStringWithLocale:", v3);
      v5 = (void *)objc_claimAutoreleasedReturnValue();

      v8 = objc_msgSend(v4, "isEqualToString:", v5);
      v6 = kTIACRACapitalizationMixed;
      if (v8)
        v6 = kTIACRACapitalizationUpper;
    }
  }
  v9 = *v6;

  return v9;
}

uint64_t _editDistanceForOriginalAndRevisedStrings(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "_editDistanceFrom:", a1);
}

unint64_t _wordLengthBucketForString(void *a1, void *a2)
{
  id v3;
  unint64_t v4;
  void *v5;
  int v6;

  v3 = a2;
  v4 = objc_msgSend(a1, "length");
  if (!v3
    || (objc_msgSend(v3, "languageCode"),
        v5 = (void *)objc_claimAutoreleasedReturnValue(),
        v6 = objc_msgSend(v5, "hasPrefix:", CFSTR("zh")),
        v5,
        !v6))
  {
    if (v4 < 2)
    {
      v4 = 0;
      goto LABEL_16;
    }
    if (v4 == 2)
    {
      v4 = 1;
      goto LABEL_16;
    }
    if (v4 != 3)
      goto LABEL_5;
LABEL_11:
    v4 = 2;
    goto LABEL_16;
  }
  if (v4 < 2)
    goto LABEL_16;
  if (v4 < 4)
    goto LABEL_11;
LABEL_5:
  if (v4 >= 6)
  {
    if (v4 >= 8)
      v4 = 5;
    else
      v4 = 4;
  }
  else
  {
    v4 = 3;
  }
LABEL_16:

  return v4;
}

uint64_t _revisionCountBucketForWordEntry(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  unsigned int v4;

  v1 = a1;
  objc_msgSend(v1, "allEdits");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "count");

  v4 = objc_msgSend(v1, "deleted");
  if (v3 + (unint64_t)v4 >= 5)
    return 5;
  else
    return v3 + v4;
}

id _primaryInputModeForTypingSession(void *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  objc_msgSend(a1, "sessionParams");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "activeInputModes");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectAtIndexedSubscript:", 0);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "normalizedIdentifier");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id _secondaryInputModeForTypingSession(void *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  objc_msgSend(a1, "sessionParams");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "activeInputModes");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  if (objc_msgSend(v2, "count") == 1)
  {
    v3 = 0;
  }
  else
  {
    objc_msgSend(v2, "objectAtIndexedSubscript:", 1);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "normalizedIdentifier");
    v3 = (void *)objc_claimAutoreleasedReturnValue();

  }
  return v3;
}

id _capitalizationForWordEntry(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  NSObject *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v13;
  uint8_t buf[4];
  void *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  objc_msgSend(v3, "keyboardState");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "inputMode");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  TIInputModeGetLanguageWithRegion();
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x1E0C99DC8], "localeWithLocaleIdentifier:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v7)
  {
    IXADefaultLogFacility();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s A valid locale could not be determined from the keyboard state in context for the supplied word entry."), "_capitalizationForWordEntry");
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      v15 = v13;
      _os_log_error_impl(&dword_1DA6F2000, v8, OS_LOG_TYPE_ERROR, "%@", buf, 0xCu);

    }
  }
  if ((a2 & 1) != 0)
  {
    objc_msgSend(v3, "acceptedCandidate");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "input");
    v10 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    objc_msgSend(v3, "acceptedString");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
  }
  _capitalizationForStringUsingLocale(v10, v7);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  return v11;
}

id _editDistanceBucketForOriginalAndRevisedWordEntries(void *a1, void *a2, char a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  __CFString *v9;
  unint64_t v10;
  id *v11;
  __CFString **v12;
  __CFString **v13;
  id v14;

  v5 = a1;
  v6 = a2;
  if ((a3 & 1) != 0)
  {
    objc_msgSend(v5, "acceptedCandidate");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "input");
    v8 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    objc_msgSend(v5, "acceptedString");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
  }
  if ((objc_msgSend(v6, "deleted") & 1) != 0)
  {
    v9 = &stru_1EA1081D0;
  }
  else
  {
    objc_msgSend(v6, "acceptedString");
    v9 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  v10 = -[__CFString _editDistanceFrom:](v9, "_editDistanceFrom:", v8);
  v11 = (id *)kTIACRAEditDistanceBucketNone;
  v12 = kTIACRAEditDistanceBucketShort;
  v13 = kTIACRAEditDistanceBucketLong;
  if (v10 < 6)
    v13 = kTIACRAEditDistanceBucketMedium;
  if (v10 >= 3)
    v12 = v13;
  if (v10)
    v11 = (id *)v12;
  v14 = *v11;

  return v14;
}

id _payloadTextForWordEntry(void *a1)
{
  id v1;
  uint64_t v2;
  void *v3;
  __CFString *v4;
  __CFString *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  __CFString *v9;
  __CFString *v10;
  void *v11;

  v1 = a1;
  objc_msgSend(v1, "acceptedString");
  v2 = objc_claimAutoreleasedReturnValue();
  v3 = (void *)v2;
  if (v2)
    v4 = (__CFString *)v2;
  else
    v4 = CFSTR("<NIL>");
  v5 = v4;

  objc_msgSend(v1, "acceptedCandidate");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v6, "input");
  v7 = objc_claimAutoreleasedReturnValue();
  v8 = (void *)v7;
  if (v7)
    v9 = (__CFString *)v7;
  else
    v9 = CFSTR("<NIL>");
  v10 = v9;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("|%@|%@|"), v5, v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  return v11;
}

id _textForWordEntry(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v6;

  v3 = a1;
  if ((objc_msgSend(v3, "wordEntryType") & 4) != 0
    || (objc_msgSend(v3, "wordEntryType") & 0xC0) != 0
    || (objc_msgSend(v3, "wordEntryType") & 0x100) != 0
    || (a2 & 1) == 0)
  {
    objc_msgSend(v3, "acceptedString");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    objc_msgSend(v3, "acceptedCandidate");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "input");
    v4 = (void *)objc_claimAutoreleasedReturnValue();

  }
  return v4;
}

unint64_t _wordLengthBucketForWordEntry(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  unint64_t v9;

  v3 = a1;
  objc_msgSend(v3, "keyboardState");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "inputMode");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  TIInputModeGetNormalizedIdentifier();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  _textForWordEntry(v3, a2);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x1E0C99DC8], "localeWithLocaleIdentifier:", v6);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = _wordLengthBucketForString(v7, v8);

  return v9;
}

uint64_t _doesWordHaveBackspace(void *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  _BYTE v10[128];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v6 = 0u;
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  objc_msgSend(a1, "allKeyboardInputsM", 0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v6, v10, 16);
  if (v2)
  {
    v3 = *(_QWORD *)v7;
    while (2)
    {
      for (i = 0; i != v2; ++i)
      {
        if (*(_QWORD *)v7 != v3)
          objc_enumerationMutation(v1);
        if ((objc_msgSend(*(id *)(*((_QWORD *)&v6 + 1) + 8 * i), "isBackspace") & 1) != 0)
        {
          v2 = 1;
          goto LABEL_11;
        }
      }
      v2 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v6, v10, 16);
      if (v2)
        continue;
      break;
    }
  }
LABEL_11:

  return v2;
}

__CFString *_inputModalityForWordEntry(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  __CFString **v6;
  __CFString *v7;

  v3 = a1;
  objc_msgSend(v3, "acceptedCandidate");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "isContinuousPathConversion");

  if ((v5 & 1) != 0)
  {
    v6 = kTIACRAModalityPathed;
  }
  else if ((objc_msgSend(v3, "wordEntryType") & 4) != 0)
  {
    v6 = kTIACRAModalityCandidateBar;
  }
  else if ((objc_msgSend(v3, "wordEntryType") & 0xC0) != 0)
  {
    v6 = kTIACRAModalityRevisionBubble;
  }
  else if ((objc_msgSend(v3, "wordEntryType") & 0x100) != 0)
  {
    v6 = kTIACRAModalityInlineCompletion;
  }
  else if (a2 && _doesWordHaveBackspace(v3) && !objc_msgSend(v3, "cancelled"))
  {
    v6 = kTIACRAModalityTappedWithBackspace;
  }
  else
  {
    v6 = kTIACRAModalityTapped;
  }
  v7 = *v6;

  return v7;
}

__CFString *_sourceForWordEntry(void *a1)
{
  id v1;
  __CFString *v2;
  __CFString *v3;
  void *v4;
  void *v5;

  v1 = a1;
  if (objc_msgSend(v1, "cancelled"))
  {
    v2 = CFSTR("Uncommitted");
    v3 = CFSTR("Uncommitted");
  }
  else
  {
    objc_msgSend(v1, "acceptedCandidate");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    if (v4)
    {
      objc_msgSend(v1, "acceptedCandidate");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "sourceMask");

    }
    TIStatisticCandidateSourceAsString();
    v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }

  return v2;
}

id _correctedOperationForWordEntry(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  int v4;
  void *v5;
  void *v6;
  void *v7;

  v1 = a1;
  objc_msgSend(v1, "acceptedCandidate");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    objc_msgSend(v1, "acceptedCandidate");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = objc_msgSend(v3, "usageTrackingMask");

  }
  else
  {
    v4 = 1;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v5;
  if ((v4 & 0x400) != 0)
  {
    objc_msgSend(v5, "addObject:", CFSTR("KeyTransposition"));
    if ((v4 & 0x800) == 0)
    {
LABEL_6:
      if ((v4 & 0x1000) == 0)
        goto LABEL_7;
      goto LABEL_17;
    }
  }
  else if ((v4 & 0x800) == 0)
  {
    goto LABEL_6;
  }
  objc_msgSend(v6, "addObject:", CFSTR("KeyInsertion"));
  if ((v4 & 0x1000) == 0)
  {
LABEL_7:
    if ((v4 & 0x4000) == 0)
      goto LABEL_8;
    goto LABEL_18;
  }
LABEL_17:
  objc_msgSend(v6, "addObject:", CFSTR("KeyDeletion"));
  if ((v4 & 0x4000) == 0)
  {
LABEL_8:
    if ((v4 & 0x8000) == 0)
      goto LABEL_9;
    goto LABEL_19;
  }
LABEL_18:
  objc_msgSend(v6, "addObject:", CFSTR("AdjacentKeySubstitution"));
  if ((v4 & 0x8000) == 0)
  {
LABEL_9:
    if ((v4 & 0x10) == 0)
      goto LABEL_10;
    goto LABEL_20;
  }
LABEL_19:
  objc_msgSend(v6, "addObject:", CFSTR("FarKeySubstitution"));
  if ((v4 & 0x10) == 0)
  {
LABEL_10:
    if ((v4 & 0x200000) == 0)
      goto LABEL_12;
    goto LABEL_11;
  }
LABEL_20:
  objc_msgSend(v6, "addObject:", CFSTR("WordSplit"));
  if ((v4 & 0x200000) != 0)
LABEL_11:
    objc_msgSend(v6, "addObject:", CFSTR("WordJoin"));
LABEL_12:
  if (!objc_msgSend(v6, "count"))
    objc_msgSend(v6, "addObject:", CFSTR("Unknown"));
  objc_msgSend(v6, "componentsJoinedByString:", CFSTR(","));
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  return v7;
}

id _addGenericMetadataToPayloadFromKeyboardSession(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  TIKBAnalyticsMetricsContext *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  TIKBAnalyticsMetricsContext *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  __CFString *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;

  v3 = a1;
  v4 = a2;
  objc_msgSend(v4, "userActionHistory");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "lastObject");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "keyboardState");
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = [TIKBAnalyticsMetricsContext alloc];
  objc_msgSend(v4, "sessionParams");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "activeInputModes");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "sessionParams");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "testingParameters");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = -[TIKBAnalyticsMetricsContext initWithKeyboardState:activeInputModes:testingParameters:](v8, "initWithKeyboardState:activeInputModes:testingParameters:", v7, v10, v12);

  -[TIAnalyticsMetricsContext inputLanguage](v13, "inputLanguage");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v14, kFeatureStringKeyboardLanguage);

  -[TIAnalyticsMetricsContext inputRegion](v13, "inputRegion");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v15, kFeatureStringKeyboardRegion);

  -[TIKBAnalyticsMetricsContext inputVariant](v13, "inputVariant");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v16, kFeatureStringKeyboardVariant);

  -[TIKBAnalyticsMetricsContext secondaryLanguage](v13, "secondaryLanguage");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v17, kFeatureStringKeyboardSecondaryLanguage);

  -[TIKBAnalyticsMetricsContext secondaryRegion](v13, "secondaryRegion");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v18, kFeatureStringKeyboardSecondaryRegion);

  -[TIKBAnalyticsMetricsContext layoutName](v13, "layoutName");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v19, kFeatureStringKeyboardLayout);

  +[TIKBAnalyticsMetricsContext keyboardTypeEnumToString:](TIKBAnalyticsMetricsContext, "keyboardTypeEnumToString:", -[TIKBAnalyticsMetricsContext keyboardType](v13, "keyboardType"));
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v20, kFeatureStringKeyboardType);

  objc_msgSend(v4, "sessionParams");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = objc_msgSend(v21, "assetAvailabilityStatus");
  v23 = CFSTR("Installed");
  if (!v22)
    v23 = CFSTR("Unavailable");
  v24 = v23;
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v24, kFeatureStringAssetAvailabilityStatus);

  objc_msgSend(v4, "featureUsageMetricsCache");
  v25 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v25, "featureUsageMetricFromName:forContext:", kFeatureKeyboardUsage, v13);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v26, kFeatureKeyboardUsage);

  objc_msgSend(v25, "featureUsageMetricFromName:forContext:", kFeatureContinuousPathUsage, v13);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v27, kFeatureContinuousPathUsage);

  objc_msgSend(v25, "featureUsageMetricFromName:forContext:", kFeatureCandidateBarUsage, v13);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v28, kFeatureCandidateBarUsage);

  objc_msgSend(v25, "featureUsageMetricFromName:forContext:", kFeatureAutocorrectionUsage, v13);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v29, kFeatureAutocorrectionUsage);

  objc_msgSend(v25, "featureUsageMetricFromName:forContext:", kFeatureMultilingualUsage, v13);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v30, kFeatureMultilingualUsage);

  objc_msgSend(v25, "featureUsageMetricFromName:forContext:", kFeatureStringTypingSpeed, v13);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v31, kFeatureStringTypingSpeed);

  return v3;
}

id _revisionMetricPayloadFromOriginalAndRevisedWordEntries(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  _BOOL4 v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  NSObject *v24;
  void *v25;
  int v26;
  char v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  id v36;
  void *v37;
  NSObject *v38;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  uint8_t buf[4];
  void *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  if (objc_msgSend(v3, "origin") == 1)
  {
    v6 = 1;
    if (v4)
      goto LABEL_7;
  }
  else
  {
    v6 = objc_msgSend(v3, "origin") == 3;
    if (v4)
      goto LABEL_7;
  }
  if (v6)
    v4 = v3;
LABEL_7:
  if (v6)
  {
    objc_msgSend(v5, "setObject:forKeyedSubscript:", CFSTR("OriginalText"), CFSTR("enteredModality"));
  }
  else
  {
    _inputModalityForWordEntry(v3, 1);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v7, CFSTR("enteredModality"));

    _sourceForWordEntry(v3);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v8, CFSTR("enteredSource"));

    _capitalizationForWordEntry(v3, 1);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v9, CFSTR("enteredCapitalization"));

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", _doesWordEntryContainDiacritics(v3, 1));
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v10, CFSTR("enteredDiacritics"));

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", _doesWordEntryContainApostrophe(v3, 1));
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v11, CFSTR("enteredApostrophe"));

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", _wordLengthBucketForWordEntry(v3, 1));
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v12, CFSTR("enteredWordLength"));

  }
  v13 = objc_msgSend(v3, "wordEntryType") & !v6;
  if ((_DWORD)v13 == 1)
  {
    _sourceForWordEntry(v3);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v14, CFSTR("correctedSource"));

    _capitalizationForWordEntry(v3, 0);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v15, CFSTR("correctedCapitalization"));

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", _doesWordEntryContainDiacritics(v3, 0));
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v16, CFSTR("correctedDiacritics"));

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", _doesWordEntryContainApostrophe(v3, 0));
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v17, CFSTR("correctedApostrophe"));

    _editDistanceBucketForOriginalAndRevisedWordEntries(v3, v3, 1);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v18, CFSTR("correctedEditDistance"));

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", _wordLengthBucketForWordEntry(v3, 0));
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v19, CFSTR("correctedWordLength"));

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", _doesWordEntryHaveLeftHandContext(v3));
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v20, CFSTR("correctedHasLeftHandContext"));

    _correctedOperationForWordEntry(v3);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v21, CFSTR("correctedOperationType"));

    objc_msgSend(v3, "acceptedCandidate");
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v22, "typingEngine");
    TIKeyboardCandidateTypingEngineTypeToString();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v23, kFeatureStringTypingEngine);

    if (IXACanLogMessageAtLevel())
    {
      IXADefaultLogFacility();
      v24 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        v41 = (void *)MEMORY[0x1E0CB3940];
        objc_msgSend(v3, "acceptedCandidate");
        v42 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v42, "input");
        v43 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v41, "stringWithFormat:", CFSTR("%s Autocorrection of %@ -> %@"), "_revisionMetricPayloadFromOriginalAndRevisedWordEntries", v3, v43);
        v44 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412290;
        v46 = v44;
        _os_log_debug_impl(&dword_1DA6F2000, v24, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);

      }
    }
  }
  v25 = v3;
  if (v4)
  {
    if ((objc_msgSend(v3, "isEqual:", v4) & 1) != 0)
    {
      v25 = v4;
      if (!v6)
        goto LABEL_22;
    }
    else
    {
      v26 = objc_msgSend(v3, "wasRevised");
      v25 = v4;
      if (((v6 | v26) & 1) == 0)
        goto LABEL_22;
    }
    v27 = objc_msgSend(v4, "deleted");
    v25 = v4;
    if ((v27 & 1) == 0)
    {
      _inputModalityForWordEntry(v4, 0);
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v28, CFSTR("revisedModality"));

      _sourceForWordEntry(v4);
      v29 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v29, CFSTR("revisedSource"));

      _capitalizationForWordEntry(v4, 1);
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v30, CFSTR("revisedCapitalization"));

      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", _doesWordEntryContainDiacritics(v4, 1));
      v31 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v31, CFSTR("revisedDiacritics"));

      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", _doesWordEntryContainApostrophe(v4, 1));
      v32 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v32, CFSTR("revisedApostrophe"));

      _editDistanceBucketForOriginalAndRevisedWordEntries(v3, v4, 1);
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v33, CFSTR("revisedEditDistance"));

      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", _wordLengthBucketForWordEntry(v4, 1));
      v34 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v34, CFSTR("revisedWordLength"));

      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", _revisionCountBucketForWordEntry(v3));
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v35, CFSTR("revisedWordRevisionCount"));

      v25 = v4;
    }
  }
LABEL_22:
  v36 = v25;
  if (objc_msgSend(v36, "deleted"))
  {
    objc_msgSend(v5, "setObject:forKeyedSubscript:", CFSTR("Deleted"), CFSTR("revisedModality"));
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", _revisionCountBucketForWordEntry(v3));
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v37, CFSTR("revisedWordRevisionCount"));

  }
  if (IXACanLogMessageAtLevel())
  {
    IXADefaultLogFacility();
    v38 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s originalWordEntry: %@, revisedWordEntry:%@, isAutocorrected: %d, isDeleted: %d, payload: %@"), "_revisionMetricPayloadFromOriginalAndRevisedWordEntries", v3, v4, v13, objc_msgSend(v36, "deleted"), v5);
      v40 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138412290;
      v46 = v40;
      _os_log_debug_impl(&dword_1DA6F2000, v38, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);

    }
  }

  return v5;
}

id _allUserCursorMovementEditEventsAndAssociatedWordEntriesForSession(void *a1)
{
  void *v1;
  unint64_t v2;
  uint64_t v3;
  void *v4;
  id v5;
  void *v6;
  uint64_t v7;
  void *v8;
  id v9;
  void *v10;
  int v11;
  id v12;
  int v13;
  unint64_t v14;
  void *v15;
  void *v16;
  id v17;
  id v18;
  void *v19;
  id v21;
  id v22;
  id v23;
  void *v24;
  id v25;
  void *v26;

  v21 = a1;
  objc_msgSend(v21, "userActionHistory");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  if (objc_msgSend(v1, "count"))
  {
    v2 = 0;
    v3 = -1;
    do
    {
      objc_msgSend(v1, "objectAtIndexedSubscript:", v2);
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v5 = v4;
        objc_msgSend(v5, "inWord");
        v26 = (void *)objc_claimAutoreleasedReturnValue();
        if (v26)
        {
          v23 = v5;
          v24 = v4;
          v25 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
          v6 = 0;
          v7 = v3;
          do
          {
            if (v7 < 0)
              break;
            objc_msgSend(v1, "objectAtIndexedSubscript:", v7);
            v8 = (void *)objc_claimAutoreleasedReturnValue();
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              v9 = v8;
              objc_msgSend(v9, "acceptedString");
              v10 = (void *)objc_claimAutoreleasedReturnValue();
              v11 = objc_msgSend(v26, "isEqualToString:", v10);

              if (v11)
              {
                v12 = v9;

                v13 = 5;
                v6 = v12;
              }
              else
              {
                v13 = 7;
              }

            }
            else
            {
              v13 = 7;
            }

            --v7;
          }
          while (v13 == 7);
          v14 = v2 + 1;
          if (v2 + 1 >= objc_msgSend(v1, "count"))
          {
            v15 = 0;
          }
          else
          {
            v15 = 0;
            do
            {
              objc_msgSend(v1, "objectAtIndexedSubscript:", v14);
              v16 = (void *)objc_claimAutoreleasedReturnValue();
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                v17 = v16;

                v15 = v17;
              }

              ++v14;
            }
            while (v14 < objc_msgSend(v1, "count"));
            if (v6 && v15)
            {
              objc_msgSend(v25, "addObject:", v6);
              objc_msgSend(v25, "addObject:", v15);
              objc_msgSend(v22, "addObject:", v25);

              v18 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
              v6 = 0;
              v15 = 0;
              v25 = v18;
            }
          }

          v5 = v23;
          v4 = v24;
        }

      }
      ++v2;
      ++v3;
    }
    while (v2 < objc_msgSend(v1, "count"));
  }
  v19 = (void *)objc_msgSend(v22, "copy");

  return v19;
}

uint64_t __Block_byref_object_copy__19480(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__19481(uint64_t a1)
{

}

void ___analyzeEditEvents_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  id v9;

  objc_msgSend(*(id *)(a1 + 32), "objectAtIndexedSubscript:", a2);
  v3 = objc_claimAutoreleasedReturnValue();
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40), "editedEntry");
  v6 = objc_claimAutoreleasedReturnValue();
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
  v8 = *(void **)(v7 + 40);
  *(_QWORD *)(v7 + 40) = v6;

  _revisionMetricPayloadFromOriginalAndRevisedWordEntries(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40), *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 40));
  v9 = (id)objc_claimAutoreleasedReturnValue();
  _addGenericMetadataToPayloadFromKeyboardSession(v9, *(void **)(a1 + 40));
  objc_claimAutoreleasedReturnValue();

  objc_msgSend(v9, "addEntriesFromDictionary:", *(_QWORD *)(a1 + 48));
  objc_msgSend(*(id *)(a1 + 56), "addObject:", v9);

}

void ___analyzeNonEditEvents_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  id v6;

  objc_msgSend(*(id *)(a1 + 32), "objectAtIndexedSubscript:", a2);
  v3 = objc_claimAutoreleasedReturnValue();
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

  _revisionMetricPayloadFromOriginalAndRevisedWordEntries(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40), 0);
  v6 = (id)objc_claimAutoreleasedReturnValue();
  _addGenericMetadataToPayloadFromKeyboardSession(v6, *(void **)(a1 + 40));
  objc_claimAutoreleasedReturnValue();

  objc_msgSend(v6, "addEntriesFromDictionary:", *(_QWORD *)(a1 + 48));
  objc_msgSend(*(id *)(a1 + 56), "addObject:", v6);

}

id _analyzeUserCursorMovementEditEvents(void *a1)
{
  void *v1;
  id v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  _allUserCursorMovementEditEventsAndAssociatedWordEntriesForSession(a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v3 = v1;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v15;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v15 != v6)
          objc_enumerationMutation(v3);
        v8 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * i);
        if (objc_msgSend(v8, "count", (_QWORD)v14) == 2)
        {
          objc_msgSend(v8, "objectAtIndexedSubscript:", 0);
          v9 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v8, "objectAtIndexedSubscript:", 1);
          v10 = (void *)objc_claimAutoreleasedReturnValue();
          _revisionMetricPayloadFromOriginalAndRevisedWordEntries(v9, v10);
          v11 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v2, "addObject:", v11);

        }
      }
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
    }
    while (v5);
  }

  v12 = (void *)objc_msgSend(v2, "copy");
  return v12;
}

double CMacroTable::init(CMacroTable *this)
{
  double result;

  *(_QWORD *)&result = 0x2000000000000;
  *((_QWORD *)this + 17408) = 0x2000000000000;
  *((_DWORD *)this + 34818) = 0;
  return result;
}

char *CMacroTable::lookup(CMacroTable *this, unsigned int *__key)
{
  char *v2;
  char *result;

  v2 = (char *)this + 0x2000;
  MacCompareStartMem = (uint64_t)this + 0x2000;
  result = (char *)bsearch(__key, this, *((int *)this + 34816), 8uLL, (int (__cdecl *)(const void *, const void *))macKeyCompare);
  if (result)
    return &v2[*((int *)result + 1)];
  return result;
}

uint64_t macKeyCompare(unsigned int *a1, int *a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;

  v2 = MacCompareStartMem + *a2;
  v3 = *a1;
  if (*a1)
  {
    v4 = 0;
    while (1)
    {
      v5 = *(_DWORD *)(v2 + 4 * v4);
      if (v3 > v5)
        return 1;
      if (v3 < v5)
        return 0xFFFFFFFFLL;
      v6 = v4 + 1;
      v3 = a1[++v4];
      if (!v3)
        goto LABEL_9;
    }
  }
  else
  {
    v6 = 0;
LABEL_9:
    if (*(_DWORD *)(v2 + 4 * v6))
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
}

uint64_t CMacroTable::readHeader(CMacroTable *this, __sFILE *a2, int *a3)
{
  size_t v5;
  BOOL v8;
  uint64_t v9;
  char *v10;
  const char *v11;
  int v12;
  uint64_t result;
  char __s[1040];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!fgets(__s, 1040, a2))
  {
    result = feof(a2);
    if (!(_DWORD)result)
      return result;
    goto LABEL_19;
  }
  v5 = strlen(__s);
  v8 = __s[2] == 191 && __s[1] == 187 && __s[0] == 239 && v5 > 2;
  v9 = 3;
  if (!v8)
    v9 = 0;
  v10 = strstr(&__s[v9], "***");
  if (!v10)
    goto LABEL_19;
  v11 = v10 + 2;
  do
    v12 = *(unsigned __int8 *)++v11;
  while (v12 == 32);
  result = sscanf(v11, "version=%d", a3);
  if ((_DWORD)result != 1)
  {
LABEL_19:
    fseek(a2, 0, 0);
    *a3 = 0;
    return 1;
  }
  return result;
}

uint64_t CMacroTable::writeHeader(CMacroTable *this, __sFILE *a2)
{
  return fprintf(a2, "DO NOT DELETE THIS LINE*** version=%d ***\n", 1);
}

FILE *CMacroTable::loadFromFile(CMacroTable *this, const char *__filename)
{
  FILE *result;
  FILE *v5;
  size_t v6;
  size_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  char __s[1040];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  result = fopen(__filename, "r");
  if (result)
  {
    v5 = result;
    *((_DWORD *)this + 34818) = 0;
    *((_DWORD *)this + 34816) = 0;
    v12 = 0;
    if ((CMacroTable::readHeader((CMacroTable *)result, result, &v12) & 1) == 0)
      v12 = 0;
    while (fgets(__s, 1040, v5))
    {
      v6 = strlen(__s);
      if (v6)
      {
        if (__s[v6 - 1] == 10)
          __s[v6 - 1] = 0;
        v7 = v6 - 2;
        if (v6 >= 2 && __s[v7] == 13)
          __s[v7] = 0;
      }
      if (v12 == 1)
        v8 = 1;
      else
        v8 = 10;
      CMacroTable::addItem(this, __s, v8);
    }
    fclose(v5);
    MacCompareStartMem = (uint64_t)this + 0x2000;
    qsort(this, *((int *)this + 34816), 8uLL, (int (__cdecl *)(const void *, const void *))macCompare);
    if (v12 != 1)
      CMacroTable::writeToFile(this, __filename, v9, v10, v11);
    return (FILE *)1;
  }
  return result;
}

uint64_t CMacroTable::addItem(CMacroTable *this, char *__s, int a3)
{
  char *v6;
  char *v7;
  int v8;
  char __dst[16];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v6 = strchr(__s, 58);
  if (!v6)
    return 0xFFFFFFFFLL;
  v7 = v6;
  if ((int)v6 - (int)__s >= 15)
    v8 = 15;
  else
    v8 = (_DWORD)v6 - (_DWORD)__s;
  strncpy(__dst, __s, v8);
  __dst[v8] = 0;
  return CMacroTable::addItem(this, __dst, v7 + 1, a3);
}

uint64_t macCompare(int *a1, int *a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;

  v2 = *a1;
  v3 = MacCompareStartMem + *a2;
  v4 = *(_DWORD *)(MacCompareStartMem + v2);
  if (v4)
  {
    v5 = 0;
    v6 = v2 + MacCompareStartMem + 4;
    while (1)
    {
      v7 = *(_DWORD *)(v3 + 4 * v5);
      if (v4 > v7)
        return 1;
      if (v4 < v7)
        return 0xFFFFFFFFLL;
      v8 = v5 + 1;
      v4 = *(_DWORD *)(v6 + 4 * v5++);
      if (!v4)
        goto LABEL_9;
    }
  }
  else
  {
    v8 = 0;
LABEL_9:
    if (*(_DWORD *)(v3 + 4 * v8))
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
}

uint64_t CMacroTable::writeToFile(CMacroTable *this, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  const char *v6;
  uint64_t result;
  FILE *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  _DWORD *v13;
  _DWORD *v14;
  int v15;
  int v16;
  _BYTE v17[3072];
  _BYTE v18[48];
  char __str[3121];
  uint64_t v20;

  v5 = MEMORY[0x1E0C80A78](this, a2, a3, a4, a5);
  v20 = *MEMORY[0x1E0C80C00];
  result = (uint64_t)fopen(v6, "w");
  if (result)
  {
    v8 = (FILE *)result;
    fprintf((FILE *)result, "DO NOT DELETE THIS LINE*** version=%d ***\n", 1);
    v9 = (int *)(v5 + 139264);
    if (*(int *)(v5 + 139264) >= 1)
    {
      v10 = 0;
      v11 = v5 + 0x2000;
      v12 = (int *)(v5 + 4);
      do
      {
        v13 = (_DWORD *)(v11 + *(v12 - 1));
        v15 = 48;
        v16 = -1;
        if (!VnConvert(7, 1, v13, (uint64_t)v18, &v16, &v15))
        {
          v14 = (_DWORD *)(v11 + *v12);
          v15 = 3072;
          v16 = -1;
          if (!VnConvert(7, 1, v14, (uint64_t)v17, &v16, &v15))
          {
            if (v10 >= *v9 - 1)
              snprintf(__str, 0xC31uLL, "%s:%s");
            else
              snprintf(__str, 0xC31uLL, "%s:%s\n");
            fputs(__str, v8);
          }
        }
        ++v10;
        v12 += 2;
      }
      while (v10 < *v9);
    }
    fclose(v8);
    return 1;
  }
  return result;
}

uint64_t CMacroTable::addItem(CMacroTable *this, _DWORD *a2, _DWORD *a3, int a4)
{
  unsigned int *v5;
  uint64_t v6;
  uint64_t result;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;

  v5 = (unsigned int *)((char *)this + 139264);
  v6 = *((int *)this + 34816);
  result = 0xFFFFFFFFLL;
  if ((int)v6 <= 1023)
  {
    v10 = v5[1];
    v11 = (int)v5[2];
    *((_DWORD *)this + 2 * v6) = v11;
    v12 = (char *)this + v11 + 0x2000;
    v17 = 64;
    v18 = -1;
    if ((int)v11 + 64 > v10)
      v17 = v10 - v11;
    v13 = VnConvert(a4, 7, a2, (uint64_t)this + v11 + 0x2000, &v18, &v17);
    result = 0xFFFFFFFFLL;
    if (!v13)
    {
      v14 = v17 + v11;
      v15 = (uint64_t)&v12[v17];
      v16 = v5[1];
      *((_DWORD *)this + 2 * (int)*v5 + 1) = v14;
      v17 = 4096;
      v18 = -1;
      if (v14 + 4096 > v16)
        v17 = v16 - v14;
      if (VnConvert(a4, 7, a3, v15, &v18, &v17))
      {
        return 0xFFFFFFFFLL;
      }
      else
      {
        v5[2] = v17 + v14;
        result = *v5;
        *v5 = result + 1;
      }
    }
  }
  return result;
}

uint64_t CMacroTable::resetContent(uint64_t this)
{
  *(_DWORD *)(this + 139272) = 0;
  *(_DWORD *)(this + 139264) = 0;
  return this;
}

uint64_t CMacroTable::getKey(CMacroTable *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 34816) <= (signed int)a2)
    return 0;
  else
    return (uint64_t)this + *((int *)this + 2 * a2) + 0x2000;
}

uint64_t CMacroTable::getText(CMacroTable *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 34816) <= (signed int)a2)
    return 0;
  else
    return (uint64_t)this + *((int *)this + 2 * a2 + 1) + 0x2000;
}

unint64_t TIIsLexiconIDEnglish(int a1)
{
  unint64_t result;

  _TISharedLexiconIDManager();
  result = atomic_load((unint64_t *)&_TISharedLexiconIDManager(void)::lexicon_id_manager);
  if (result)
  {
    while (*(_DWORD *)(result + 24) != a1)
    {
      result = *(_QWORD *)(result + 32);
      if (!result)
        return result;
    }
    if ((*(char *)(result + 23) & 0x80000000) == 0)
      return strncmp((const char *)result, "en", 2uLL) == 0;
    result = *(_QWORD *)result;
    if (result)
      return strncmp((const char *)result, "en", 2uLL) == 0;
  }
  return result;
}

const char *TIIsLocaleEnglish(const char *result)
{
  if (result)
    return (const char *)(strncmp(result, "en", 2uLL) == 0);
  return result;
}

_DWORD *TITokenIDsToWordIDs(_DWORD *result, uint64_t a2, int a3, unsigned int *a4, _QWORD *a5)
{
  uint64_t v5;
  _DWORD *v6;
  unsigned int *v7;
  unsigned int v8;

  *a5 = 0;
  if (a2 >= 1)
  {
    v5 = 0;
    v6 = &result[2 * a2];
    v7 = a4;
    do
    {
      v8 = result[1];
      if (*result == a3 || v8 <= 0x1F3)
      {
        *v7++ = v8;
        ++v5;
      }
      else
      {
        v5 = 0;
        v7 = a4;
      }
      *a5 = v5;
      result += 2;
    }
    while (result < v6);
  }
  return result;
}

void KB::InputSegmentFilter::~InputSegmentFilter(KB::InputSegmentFilter *this)
{
  JUMPOUT(0x1DF0A2144);
}

uint64_t KB::InputSegmentFilter::word_is_acceptable_for_input(KB::InputSegmentFilter *this, KB::Word *a2, const KB::String *a3)
{
  uint64_t result;
  BOOL v5;

  v5 = 0;
  LODWORD(result) = KB::InputSegmentFilter::string_preserves_surface_form_features(this, a2, a3, &v5, 0);
  if (*((float *)a2 + 12) > 0.0)
    result = result;
  else
    result = 0;
  if ((_DWORD)result == 1)
    *((_DWORD *)a2 + 26) = *((_DWORD *)a2 + 26) & 0xFFDFFFFF | (v5 << 21);
  return result;
}

uint64_t KB::InputSegmentFilter::letter_combines_with_selective_modifier(KB::InputSegmentFilter *this)
{
  return combines_with_selective_modifier();
}

BOOL KB::InputSegmentFilter::allows_substitution(KB::InputSegmentFilter *this, KB *a2, uint64_t a3, BOOL *a4)
{
  return KB::substitution_allowed(a2, a3, a4, a4);
}

BOOL KB::InputSegmentFilter::allows_composed_substitution(KB::InputSegmentFilter *this, KB *a2, unsigned int a3, int a4)
{
  return KB::character_has_diacritic(a2, a4);
}

uint64_t KB::InputSegmentFilter::character_is_digraph(KB::InputSegmentFilter *this, KB *a2)
{
  return KB::character_is_digraph(a2);
}

BOOL KB::InputSegmentFilter::character_is_letter_modifier(KB::InputSegmentFilter *this, UChar32 c)
{
  _BOOL8 result;

  result = 1;
  if (c <= 729)
  {
    if ((c - 168) <= 0xC && ((1 << (c + 88)) & 0x1081) != 0)
      return result;
    return u_charType(c) == 4;
  }
  if (c != 730 && c != 732 && c != 901)
    return u_charType(c) == 4;
  return result;
}

BOOL KB::InputSegmentFilter::character_is_precomposed_diacritic_letter(KB::InputSegmentFilter *this, KB *a2)
{
  return KB::character_is_precomposed_diacritic_letter(a2);
}

uint64_t KB::InputSegmentFilter::string_preserves_surface_form_features(KB::InputSegmentFilter *this, const KB::String *a2, const KB::String *a3, BOOL *a4, std::vector<unsigned int> *a5)
{
  char *v10;
  int v11;
  char *v12;
  int v13;
  unsigned int v14;
  UChar32 v15;
  UChar32 v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  UChar32 v20;
  unsigned int *v21;
  std::vector<unsigned int>::pointer v22;
  unsigned int *v23;
  UChar32 v24;
  unsigned int *v25;
  std::vector<unsigned int>::pointer v26;
  unsigned int *v27;
  unsigned int *value;
  std::vector<unsigned int>::pointer end;
  unsigned int *v30;
  std::vector<unsigned int>::pointer v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  BOOL v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  UChar32 v40;
  unsigned int *v41;
  std::vector<unsigned int>::pointer v42;
  unsigned int *v43;
  std::vector<unsigned int>::pointer begin;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unsigned int *v50;
  unsigned int v51;
  uint64_t *v52;
  UChar32 v53;
  unsigned int *v54;
  std::vector<unsigned int>::pointer v55;
  unsigned int *v56;
  std::vector<unsigned int>::pointer v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int *v65;
  std::vector<unsigned int>::pointer v66;
  unsigned int *v67;
  uint64_t v68;
  UChar32 v69;
  unsigned int *v70;
  std::vector<unsigned int>::pointer v71;
  unsigned int *v72;
  unsigned int *v73;
  unsigned int v74;
  UChar32 v75;
  unsigned int *v76;
  std::vector<unsigned int>::pointer v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unsigned int *v83;
  unsigned int v84;
  unint64_t i;
  std::vector<unsigned int>::pointer v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  std::vector<unsigned int>::pointer v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  std::vector<unsigned int>::pointer v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  std::vector<unsigned int>::pointer v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  unsigned int *v110;
  unsigned int v111;
  unint64_t k;
  unsigned int *v113;
  unsigned int v114;
  unint64_t j;
  unsigned int *v116;
  unsigned int v117;
  int v118;
  unsigned int *v119;
  unsigned int v120;
  UChar32 v121;
  uint64_t v122;
  _BOOL4 is_free_insertion;
  unsigned int *v124;
  std::vector<unsigned int>::pointer v125;
  unsigned int *v126;
  std::vector<unsigned int>::pointer v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  unsigned int *v133;
  unsigned int v134;
  NSObject *v135;
  const char *v137;
  const char *v138;
  const char *v139;
  const char *v140;
  const char *v141;
  __int128 v142;
  uint64_t v143;
  __int128 v144;
  UChar32 v145[2];
  __int128 v146;
  UChar32 c[2];
  _BYTE buf[24];
  const char *v149;
  __int16 v150;
  int v151;
  uint64_t v152;

  v152 = *MEMORY[0x1E0C80C00];
  v10 = (char *)*((_QWORD *)a2 + 1);
  v141 = (char *)a2 + 16;
  if (!v10)
    v10 = (char *)a2 + 16;
  *(_QWORD *)&v146 = v10;
  v11 = *(unsigned __int16 *)a2;
  DWORD2(v146) = 0;
  HIDWORD(v146) = v11;
  c[0] = 0;
  KB::String::iterator::initialize((uint64_t *)&v146);
  v12 = (char *)*((_QWORD *)a3 + 1);
  if (!v12)
    v12 = (char *)a3 + 16;
  *(_QWORD *)buf = v12;
  v13 = *(unsigned __int16 *)a3;
  *(_DWORD *)&buf[8] = 0;
  *(_DWORD *)&buf[12] = v13;
  *(_DWORD *)&buf[16] = 0;
  KB::String::iterator::initialize((uint64_t *)buf);
  v145[0] = *(_DWORD *)&buf[16];
  v144 = *(_OWORD *)buf;
  v145[1] = 0;
  if (a5)
  {
    v14 = *((unsigned __int16 *)a3 + 2);
    if (!*((_WORD *)a3 + 2))
    {
      KB::String::compute_length((unsigned __int16 *)a3);
      v14 = *((unsigned __int16 *)a3 + 2);
    }
    std::vector<unsigned int>::reserve(a5, v14);
  }
  v15 = v145[0];
  if (v145[0])
  {
    v16 = c[0];
    if (!c[0])
    {
      v17 = 0;
      goto LABEL_197;
    }
    v17 = 0;
    while (1)
    {
      if (v17 == 100)
      {
        v17 = 101;
        goto LABEL_197;
      }
      if (KB::character_is_free_insertion(v16)
        && ((*(uint64_t (**)(KB::InputSegmentFilter *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 32))(this, c[0], v145[0], 0) & 1) == 0)
      {
        KB::String::iterator::operator++((uint64_t *)&v146);
        if (a5)
        {
          end = a5->__end_;
          value = a5->__end_cap_.__value_;
          if (end >= value)
          {
            begin = a5->__begin_;
            v45 = end - a5->__begin_;
            v46 = v45 + 1;
            if ((unint64_t)(v45 + 1) >> 62)
              goto LABEL_240;
            v47 = (char *)value - (char *)begin;
            if (v47 >> 1 > v46)
              v46 = v47 >> 1;
            v35 = (unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL;
            v48 = 0x3FFFFFFFFFFFFFFFLL;
            if (!v35)
              v48 = v46;
            if (v48)
            {
              v48 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v48);
              begin = a5->__begin_;
              end = a5->__end_;
            }
            else
            {
              v49 = 0;
            }
            v63 = (unsigned int *)(v48 + 4 * v45);
            *v63 = -1;
            v30 = v63 + 1;
            while (end != begin)
            {
              v64 = *--end;
              *--v63 = v64;
            }
            a5->__begin_ = v63;
            a5->__end_ = v30;
            a5->__end_cap_.__value_ = (unsigned int *)(v48 + 4 * v49);
            if (begin)
              operator delete(begin);
          }
          else
          {
            *end = -1;
            v30 = end + 1;
          }
          a5->__end_ = v30;
        }
        if (a4)
          *a4 = 1;
        goto LABEL_124;
      }
      if ((*(unsigned int (**)(KB::InputSegmentFilter *, _QWORD))(*(_QWORD *)this + 64))(this, v145[0]))
      {
        *(_OWORD *)buf = v146;
        *(_QWORD *)&buf[16] = *(_QWORD *)c;
        KB::String::iterator::operator++((uint64_t *)buf);
        if ((*(unsigned int (**)(KB::InputSegmentFilter *, _QWORD))(*(_QWORD *)this + 56))(this, *(unsigned int *)&buf[16]))
        {
          v18 = v145[0];
          v19 = c[0];
          v142 = v146;
          v143 = *(_QWORD *)c;
          KB::String::iterator::operator++((uint64_t *)&v142);
          if ((*(unsigned int (**)(KB::InputSegmentFilter *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)this
                                                                                                  + 40))(this, v18, v19, v143))
          {
            if (a5)
            {
              v20 = v145[1];
              v22 = a5->__end_;
              v21 = a5->__end_cap_.__value_;
              if (v22 >= v21)
              {
                v57 = a5->__begin_;
                v58 = v22 - a5->__begin_;
                v59 = v58 + 1;
                if ((unint64_t)(v58 + 1) >> 62)
                  goto LABEL_240;
                v60 = (char *)v21 - (char *)v57;
                if (v60 >> 1 > v59)
                  v59 = v60 >> 1;
                v35 = (unint64_t)v60 >= 0x7FFFFFFFFFFFFFFCLL;
                v61 = 0x3FFFFFFFFFFFFFFFLL;
                if (!v35)
                  v61 = v59;
                if (v61)
                {
                  v61 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v61);
                  v57 = a5->__begin_;
                  v22 = a5->__end_;
                }
                else
                {
                  v62 = 0;
                }
                v73 = (unsigned int *)(v61 + 4 * v58);
                *v73 = v20;
                v23 = v73 + 1;
                while (v22 != v57)
                {
                  v74 = *--v22;
                  *--v73 = v74;
                }
                v21 = (unsigned int *)(v61 + 4 * v62);
                a5->__begin_ = v73;
                a5->__end_ = v23;
                a5->__end_cap_.__value_ = v21;
                if (v57)
                {
                  operator delete(v57);
                  v21 = a5->__end_cap_.__value_;
                }
              }
              else
              {
                *v22 = v145[1];
                v23 = v22 + 1;
              }
              a5->__end_ = v23;
              v75 = v145[1];
              if (v23 >= v21)
              {
                v77 = a5->__begin_;
                v78 = v23 - a5->__begin_;
                v79 = v78 + 1;
                if ((unint64_t)(v78 + 1) >> 62)
                  goto LABEL_240;
                v80 = (char *)v21 - (char *)v77;
                if (v80 >> 1 > v79)
                  v79 = v80 >> 1;
                v35 = (unint64_t)v80 >= 0x7FFFFFFFFFFFFFFCLL;
                v81 = 0x3FFFFFFFFFFFFFFFLL;
                if (!v35)
                  v81 = v79;
                if (v81)
                {
                  v81 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v81);
                  v77 = a5->__begin_;
                  v23 = a5->__end_;
                }
                else
                {
                  v82 = 0;
                }
                v83 = (unsigned int *)(v81 + 4 * v78);
                *v83 = v75;
                v76 = v83 + 1;
                while (v23 != v77)
                {
                  v84 = *--v23;
                  *--v83 = v84;
                }
                a5->__begin_ = v83;
                a5->__end_ = v76;
                a5->__end_cap_.__value_ = (unsigned int *)(v81 + 4 * v82);
                if (v77)
                  operator delete(v77);
              }
              else
              {
                *v23 = v145[1];
                v76 = v23 + 1;
              }
              a5->__end_ = v76;
            }
            ++v145[1];
            KB::String::iterator::operator++((uint64_t *)&v144);
            for (i = 3; i > 1; --i)
              KB::String::iterator::operator++((uint64_t *)&v146);
            goto LABEL_124;
          }
        }
      }
      if (KB::character_is_free_insertion(v145[0])
        || ((*(uint64_t (**)(KB::InputSegmentFilter *, _QWORD))(*(_QWORD *)this + 64))(this, v145[0]) & 1) != 0|| (*(unsigned int (**)(KB::InputSegmentFilter *, _QWORD))(*(_QWORD *)this + 48))(this, v145[0]))
      {
        buf[0] = 0;
        if (!(*(unsigned int (**)(KB::InputSegmentFilter *, _QWORD, _QWORD, _BYTE *))(*(_QWORD *)this + 32))(this, c[0], v145[0], buf))return 0;
        if (a4 && buf[0])
          *a4 = 1;
        KB::String::iterator::operator++((uint64_t *)&v146);
        if (a5)
        {
          v24 = v145[1];
          v26 = a5->__end_;
          v25 = a5->__end_cap_.__value_;
          if (v26 >= v25)
          {
            v31 = a5->__begin_;
            v32 = v26 - a5->__begin_;
            v33 = v32 + 1;
            if ((unint64_t)(v32 + 1) >> 62)
              goto LABEL_240;
            v34 = (char *)v25 - (char *)v31;
            if (v34 >> 1 > v33)
              v33 = v34 >> 1;
            v35 = (unint64_t)v34 >= 0x7FFFFFFFFFFFFFFCLL;
            v36 = 0x3FFFFFFFFFFFFFFFLL;
            if (!v35)
              v36 = v33;
            if (v36)
            {
              v36 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v36);
              v31 = a5->__begin_;
              v26 = a5->__end_;
            }
            else
            {
              v37 = 0;
            }
            v50 = (unsigned int *)(v36 + 4 * v32);
            *v50 = v24;
            v27 = v50 + 1;
            while (v26 != v31)
            {
              v51 = *--v26;
              *--v50 = v51;
            }
            a5->__begin_ = v50;
            a5->__end_ = v27;
            a5->__end_cap_.__value_ = (unsigned int *)(v36 + 4 * v37);
            if (v31)
              operator delete(v31);
          }
          else
          {
            *v26 = v145[1];
            v27 = v26 + 1;
          }
          a5->__end_ = v27;
        }
      }
      else
      {
        *(_OWORD *)buf = v144;
        *(_QWORD *)&buf[16] = *(_QWORD *)v145;
        KB::String::iterator::operator++((uint64_t *)buf);
        if (((*(uint64_t (**)(KB::InputSegmentFilter *, _QWORD))(*(_QWORD *)this + 56))(this, *(unsigned int *)&buf[16]) & 1) != 0|| (v142 = v144, v143 = *(_QWORD *)v145, KB::String::iterator::operator++((uint64_t *)&v142), (_DWORD)v143 == 39)|| (_DWORD)v143 == 8217)
        {
          if ((*(unsigned int (**)(KB::InputSegmentFilter *, _QWORD))(*(_QWORD *)this + 64))(this, c[0]))
          {
            v38 = c[0];
            v39 = v145[0];
            *(_OWORD *)buf = v144;
            *(_QWORD *)&buf[16] = *(_QWORD *)v145;
            KB::String::iterator::operator++((uint64_t *)buf);
            if ((*(unsigned int (**)(KB::InputSegmentFilter *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)this + 40))(this, v38, v39, *(unsigned int *)&buf[16]))
            {
              KB::String::iterator::operator++((uint64_t *)&v146);
              if (a5)
              {
                v40 = v145[1];
                v42 = a5->__end_;
                v41 = a5->__end_cap_.__value_;
                if (v42 >= v41)
                {
                  v92 = a5->__begin_;
                  v93 = v42 - a5->__begin_;
                  v94 = v93 + 1;
                  if ((unint64_t)(v93 + 1) >> 62)
                    goto LABEL_240;
                  v95 = (char *)v41 - (char *)v92;
                  if (v95 >> 1 > v94)
                    v94 = v95 >> 1;
                  v35 = (unint64_t)v95 >= 0x7FFFFFFFFFFFFFFCLL;
                  v96 = 0x3FFFFFFFFFFFFFFFLL;
                  if (!v35)
                    v96 = v94;
                  if (v96)
                  {
                    v96 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v96);
                    v92 = a5->__begin_;
                    v42 = a5->__end_;
                  }
                  else
                  {
                    v97 = 0;
                  }
                  v113 = (unsigned int *)(v96 + 4 * v93);
                  *v113 = v40;
                  v43 = v113 + 1;
                  while (v42 != v92)
                  {
                    v114 = *--v42;
                    *--v113 = v114;
                  }
                  a5->__begin_ = v113;
                  a5->__end_ = v43;
                  a5->__end_cap_.__value_ = (unsigned int *)(v96 + 4 * v97);
                  if (v92)
                    operator delete(v92);
                }
                else
                {
                  *v42 = v145[1];
                  v43 = v42 + 1;
                }
                a5->__end_ = v43;
              }
              for (j = 3; j > 1; --j)
              {
                ++v145[1];
                KB::String::iterator::operator++((uint64_t *)&v144);
              }
              goto LABEL_124;
            }
          }
        }
        if ((c[0] | 0x20) != 0x20)
        {
LABEL_68:
          if ((*(unsigned int (**)(KB::InputSegmentFilter *))(*(_QWORD *)this + 48))(this))
          {
            if (a5)
            {
              v53 = v145[1];
              v55 = a5->__end_;
              v54 = a5->__end_cap_.__value_;
              if (v55 >= v54)
              {
                v86 = a5->__begin_;
                v87 = v55 - a5->__begin_;
                v88 = v87 + 1;
                if ((unint64_t)(v87 + 1) >> 62)
                  goto LABEL_240;
                v89 = (char *)v54 - (char *)v86;
                if (v89 >> 1 > v88)
                  v88 = v89 >> 1;
                v35 = (unint64_t)v89 >= 0x7FFFFFFFFFFFFFFCLL;
                v90 = 0x3FFFFFFFFFFFFFFFLL;
                if (!v35)
                  v90 = v88;
                if (v90)
                {
                  v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v90);
                  v86 = a5->__begin_;
                  v55 = a5->__end_;
                }
                else
                {
                  v91 = 0;
                }
                v110 = (unsigned int *)(v90 + 4 * v87);
                *v110 = v53;
                v56 = v110 + 1;
                while (v55 != v86)
                {
                  v111 = *--v55;
                  *--v110 = v111;
                }
                a5->__begin_ = v110;
                a5->__end_ = v56;
                a5->__end_cap_.__value_ = (unsigned int *)(v90 + 4 * v91);
                if (v86)
                  operator delete(v86);
              }
              else
              {
                *v55 = v145[1];
                v56 = v55 + 1;
              }
              a5->__end_ = v56;
            }
            for (k = 3; k > 1; --k)
            {
              ++v145[1];
              KB::String::iterator::operator++((uint64_t *)&v144);
            }
            if (!a4)
              goto LABEL_193;
          }
          else
          {
            buf[0] = 0;
            if (!(*(unsigned int (**)(KB::InputSegmentFilter *, _QWORD, _QWORD, _BYTE *))(*(_QWORD *)this + 32))(this, c[0], v145[0], buf))return 0;
            if (a4 && buf[0])
              *a4 = 1;
            v68 = c[0];
            if (a5 && c[0])
            {
              v69 = v145[1];
              v71 = a5->__end_;
              v70 = a5->__end_cap_.__value_;
              if (v71 >= v70)
              {
                v98 = a5->__begin_;
                v99 = v71 - a5->__begin_;
                v100 = v99 + 1;
                if ((unint64_t)(v99 + 1) >> 62)
                  goto LABEL_240;
                v101 = (char *)v70 - (char *)v98;
                if (v101 >> 1 > v100)
                  v100 = v101 >> 1;
                v35 = (unint64_t)v101 >= 0x7FFFFFFFFFFFFFFCLL;
                v102 = 0x3FFFFFFFFFFFFFFFLL;
                if (!v35)
                  v102 = v100;
                if (v102)
                {
                  v102 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v102);
                  v98 = a5->__begin_;
                  v71 = a5->__end_;
                }
                else
                {
                  v103 = 0;
                }
                v116 = (unsigned int *)(v102 + 4 * v99);
                *v116 = v69;
                v72 = v116 + 1;
                while (v71 != v98)
                {
                  v117 = *--v71;
                  *--v116 = v117;
                }
                a5->__begin_ = v116;
                a5->__end_ = v72;
                a5->__end_cap_.__value_ = (unsigned int *)(v102 + 4 * v103);
                if (v98)
                  operator delete(v98);
              }
              else
              {
                *v71 = v145[1];
                v72 = v71 + 1;
              }
              a5->__end_ = v72;
              v68 = c[0];
            }
            ++v145[1];
            KB::String::iterator::operator++((uint64_t *)&v144);
            v118 = (*(uint64_t (**)(KB::InputSegmentFilter *, uint64_t))(*(_QWORD *)this + 64))(this, v68);
            if (!a4 || !v118)
              goto LABEL_193;
          }
          *a4 = 1;
LABEL_193:
          v52 = (uint64_t *)&v146;
          goto LABEL_64;
        }
        if (v145[0] == 32)
        {
          if (c[0])
            goto LABEL_68;
        }
        else
        {
          *(_OWORD *)buf = v144;
          *(_QWORD *)&buf[16] = *(_QWORD *)v145;
          KB::String::iterator::operator++((uint64_t *)buf);
          if (*(_DWORD *)&buf[16] != 32)
          {
            if (a5)
            {
              v66 = a5->__end_;
              v65 = a5->__end_cap_.__value_;
              if (v66 >= v65)
              {
                v104 = a5->__begin_;
                v105 = v66 - a5->__begin_;
                v106 = v105 + 1;
                if ((unint64_t)(v105 + 1) >> 62)
LABEL_240:
                  abort();
                v107 = (char *)v65 - (char *)v104;
                if (v107 >> 1 > v106)
                  v106 = v107 >> 1;
                v35 = (unint64_t)v107 >= 0x7FFFFFFFFFFFFFFCLL;
                v108 = 0x3FFFFFFFFFFFFFFFLL;
                if (!v35)
                  v108 = v106;
                if (v108)
                {
                  v108 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v108);
                  v104 = a5->__begin_;
                  v66 = a5->__end_;
                }
                else
                {
                  v109 = 0;
                }
                v119 = (unsigned int *)(v108 + 4 * v105);
                *v119 = -1;
                v67 = v119 + 1;
                while (v66 != v104)
                {
                  v120 = *--v66;
                  *--v119 = v120;
                }
                a5->__begin_ = v119;
                a5->__end_ = v67;
                a5->__end_cap_.__value_ = (unsigned int *)(v108 + 4 * v109);
                if (v104)
                  operator delete(v104);
              }
              else
              {
                *v66 = -1;
                v67 = v66 + 1;
              }
              a5->__end_ = v67;
            }
            goto LABEL_193;
          }
        }
      }
      ++v145[1];
      v52 = (uint64_t *)&v144;
LABEL_64:
      KB::String::iterator::operator++(v52);
LABEL_124:
      ++v17;
      v15 = v145[0];
      if (!v145[0])
        goto LABEL_199;
      v16 = c[0];
      if (!c[0])
      {
LABEL_197:
        while (!KB::character_is_free_insertion(v15))
        {
          ++v145[1];
          KB::String::iterator::operator++((uint64_t *)&v144);
          v15 = v145[0];
          if (!v145[0])
            goto LABEL_199;
        }
        return 0;
      }
    }
  }
  v17 = 0;
LABEL_199:
  v121 = c[0];
  v122 = 1;
  if (c[0])
  {
    do
    {
      is_free_insertion = KB::character_is_free_insertion(v121);
      if (a4 && is_free_insertion)
        *a4 = 1;
      if (a5)
      {
        v125 = a5->__end_;
        v124 = a5->__end_cap_.__value_;
        if (v125 >= v124)
        {
          v127 = a5->__begin_;
          v128 = v125 - a5->__begin_;
          v129 = v128 + 1;
          if ((unint64_t)(v128 + 1) >> 62)
            goto LABEL_240;
          v130 = (char *)v124 - (char *)v127;
          if (v130 >> 1 > v129)
            v129 = v130 >> 1;
          if ((unint64_t)v130 >= 0x7FFFFFFFFFFFFFFCLL)
            v131 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v131 = v129;
          if (v131)
          {
            v131 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v131);
            v127 = a5->__begin_;
            v125 = a5->__end_;
          }
          else
          {
            v132 = 0;
          }
          v133 = (unsigned int *)(v131 + 4 * v128);
          *v133 = -1;
          v126 = v133 + 1;
          while (v125 != v127)
          {
            v134 = *--v125;
            *--v133 = v134;
          }
          a5->__begin_ = v133;
          a5->__end_ = v126;
          a5->__end_cap_.__value_ = (unsigned int *)(v131 + 4 * v132);
          if (v127)
            operator delete(v127);
        }
        else
        {
          *v125 = -1;
          v126 = v125 + 1;
        }
        a5->__end_ = v126;
      }
      KB::String::iterator::operator++((uint64_t *)&v146);
      v121 = c[0];
    }
    while (c[0]);
    if (v145[0])
    {
      if (TICanLogMessageAtLevel_onceToken != -1)
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
      v135 = TIOSLogFacility();
      if (os_log_type_enabled(v135, OS_LOG_TYPE_DEBUG))
      {
        v137 = (const char *)*((_QWORD *)a2 + 1);
        if (!v137)
          v137 = v141;
        if (*(_WORD *)a2)
          v138 = v137;
        else
          v138 = "";
        v139 = (const char *)*((_QWORD *)a3 + 1);
        if (!v139)
          v139 = (char *)a3 + 16;
        if (*(_WORD *)a3)
          v140 = v139;
        else
          v140 = "";
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "string_preserves_surface_form_features";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v138;
        *(_WORD *)&buf[22] = 2080;
        v149 = v140;
        v150 = 1024;
        v151 = v17;
        _os_log_debug_impl(&dword_1DA6F2000, v135, OS_LOG_TYPE_DEBUG, "%s warning: string_preserves_surface_form_features([%s], [%s]) iterated %d times without reaching end of input", buf, 0x26u);
      }
    }
    return 1;
  }
  return v122;
}

void KB::LayoutBasedInputSegmentFilter::~LayoutBasedInputSegmentFilter(KB::LayoutBasedInputSegmentFilter *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_1EA106DA0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v1);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_1EA106DA0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v1);
  JUMPOUT(0x1DF0A2144);
}

BOOL KB::LayoutBasedInputSegmentFilter::allows_substitution(KB::LayoutBasedInputSegmentFilter *this, KB *a2, uint64_t a3, BOOL *a4)
{
  _BOOL8 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  BOOL *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v17;
  uint64_t v18;

  if ((_DWORD)a2 != (_DWORD)a3
    && (*(unsigned int (**)(KB::LayoutBasedInputSegmentFilter *, uint64_t))(*(_QWORD *)this + 72))(this, a3) != (_DWORD)a2)
  {
    TI::Favonius::KeyboardLayout::key_for_char(*((_QWORD *)this + 2), a2, &v17);
    v9 = v17;
    v10 = *((_QWORD *)this + 2);
    if (!v17)
    {
      v11 = (*(uint64_t (**)(KB::LayoutBasedInputSegmentFilter *, KB *))(*(_QWORD *)this + 72))(this, a2);
      TI::Favonius::KeyboardLayout::key_for_char(v10, v11, &v18);
      v9 = v18;
      v10 = *((_QWORD *)this + 2);
    }
    TI::Favonius::KeyboardLayout::key_for_char(v10, a3, &v17);
    v13 = v17;
    if (v17)
    {
      if (v9)
      {
LABEL_8:
        if (v13)
        {
          v8 = (v9 == v13
             || !KB::operator==((unsigned __int16 *)(v9 + 40), (unsigned __int16 *)(v13 + 40))
             || (*(unsigned int (**)(KB::LayoutBasedInputSegmentFilter *, KB *, uint64_t))(*(_QWORD *)this + 80))(this, a2, a3))&& KB::substitution_allowed(a2, a3, a4, v12);
          WTF::RefCounted<TI::Favonius::Key>::deref(v13);
        }
        else
        {
          v8 = KB::substitution_allowed(a2, a3, a4, v12);
        }
        v13 = v9;
LABEL_19:
        WTF::RefCounted<TI::Favonius::Key>::deref(v13);
        return v8;
      }
    }
    else
    {
      v14 = *((_QWORD *)this + 2);
      v15 = (*(uint64_t (**)(KB::LayoutBasedInputSegmentFilter *, uint64_t))(*(_QWORD *)this + 72))(this, a3);
      TI::Favonius::KeyboardLayout::key_for_char(v14, v15, &v18);
      v13 = v18;
      if (v9)
        goto LABEL_8;
    }
    v8 = KB::substitution_allowed(a2, a3, a4, v12);
    if (!v13)
      return v8;
    goto LABEL_19;
  }
  return 1;
}

void KB::LayoutBasedInputSegmentFilter::swap_case(KB::LayoutBasedInputSegmentFilter *this, UChar32 c)
{
  if (u_isupper(c))
    JUMPOUT(0x1DF0A2D20);
  JUMPOUT(0x1DF0A2D38);
}

uint64_t KB::LayoutBasedInputSegmentFilter::allows_sortkey_equivalent_substitution(KB::LayoutBasedInputSegmentFilter *this)
{
  return 0;
}

void KB::AccentKeyInputSegmentFilter::~AccentKeyInputSegmentFilter(KB::AccentKeyInputSegmentFilter *this)
{
  void *v2;

  *(_QWORD *)this = &off_1EA106E08;
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    if (*((_BYTE *)this + 22) == 1)
      free(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_1EA106E08;
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    if (*((_BYTE *)this + 22) == 1)
      free(v2);
  }
  JUMPOUT(0x1DF0A2144);
}

uint64_t KB::AccentKeyInputSegmentFilter::letter_combines_with_selective_modifier(KB::AccentKeyInputSegmentFilter *this, unsigned int a2, unsigned int a3)
{
  if (KB::String::contains((KB::AccentKeyInputSegmentFilter *)((char *)this + 16), a3))
    return 1;
  else
    return combines_with_selective_modifier();
}

BOOL KB::AccentKeyInputSegmentFilter::allows_substitution(KB::AccentKeyInputSegmentFilter *this, KB *a2, uint64_t a3, BOOL *a4)
{
  KB::String *v7;
  BOOL *v8;

  v7 = (KB::AccentKeyInputSegmentFilter *)((char *)this + 16);
  return KB::String::contains((KB::AccentKeyInputSegmentFilter *)((char *)this + 16), a2)
      && KB::String::contains(v7, a3)
      || KB::substitution_allowed(a2, a3, a4, v8);
}

BOOL KB::AccentKeyInputSegmentFilter::allows_composed_substitution(KB::AccentKeyInputSegmentFilter *this, KB *a2, unsigned int a3, unsigned int a4)
{
  return KB::String::contains((KB::AccentKeyInputSegmentFilter *)((char *)this + 16), a4)
      && KB::AccentKeyInputSegmentFilter::character_has_accent_key_accent(this, a2)
      || KB::character_has_diacritic(a2, a4);
}

BOOL KB::AccentKeyInputSegmentFilter::character_has_accent_key_accent(KB::AccentKeyInputSegmentFilter *this, KB *a2)
{
  char *v3;
  int v4;
  _BOOL8 has_diacritic;
  int v6;
  int v7;
  char *v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  int v14;
  int v15;
  unsigned int v16;

  if (*((_QWORD *)this + 3))
    v3 = (char *)*((_QWORD *)this + 3);
  else
    v3 = (char *)this + 32;
  v13 = v3;
  v4 = *((unsigned __int16 *)this + 8);
  v14 = 0;
  v15 = v4;
  v16 = 0;
  KB::String::iterator::initialize((uint64_t *)&v13);
  v9 = v3;
  v10 = v4;
  v11 = v4;
  v12 = 0;
  KB::String::iterator::initialize((uint64_t *)&v9);
  has_diacritic = 0;
  v6 = v14;
  v7 = v10;
  while (v6 != v7)
  {
    has_diacritic = KB::character_has_diacritic(a2, v16);
    if (has_diacritic)
      break;
    KB::String::iterator::operator++((uint64_t *)&v13);
    v6 = v14;
  }
  return has_diacritic;
}

BOOL KB::AccentKeyInputSegmentFilter::is_accent_key_char(KB::AccentKeyInputSegmentFilter *this, unsigned int a2)
{
  return KB::String::contains((KB::AccentKeyInputSegmentFilter *)((char *)this + 16), a2);
}

uint64_t __Block_byref_object_copy__20544(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20545(uint64_t a1)
{

}

id wordEntryDetailForLog(void *a1, uint64_t a2)
{
  id v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  void *v30;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;

  v30 = (void *)MEMORY[0x1E0CB3940];
  v2 = a1;
  objc_msgSend(v2, "candidatesOffered");
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = objc_msgSend(v43, "count");
  objc_msgSend(v2, "allKeyboardInputs");
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = objc_msgSend(v42, "count");
  objc_msgSend(v2, "allTouches");
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = objc_msgSend(v41, "count");
  objc_msgSend(v2, "touchLayouts");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v23 = objc_msgSend(v40, "count");
  objc_msgSend(v2, "acceptedCandidate");
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v39, "candidate");
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v38);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "acceptedCandidate");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v37, "input");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v36);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "acceptedCandidate");
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v35, "rawInput");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v34);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "inputContext");
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v33);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "inputStem");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v29);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "documentState");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v26, "contextBeforeInput");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v25);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "documentState");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v22, "selectedText");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v21);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "documentState");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v20, "contextAfterInput");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v19);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "keyboardState");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v18, "documentState");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v17, "contextBeforeInput");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v15);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "keyboardState");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v14, "documentState");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "selectedText");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "keyboardState");
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v8, "documentState");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "contextAfterInput");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  formatStringForLog(v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v30, "stringWithFormat:", CFSTR("CA detail %d n:<%lu|%lu|%lu|%lu> c:<%@|%@|%@> s:<%@|%@> d:<%@|%@|%@> k:<%@|%@|%@>"), a2, v28, v27, v24, v23, v48, v47, v46, v45, v16, v44, v3, v13, v4, v7, v11);
  v32 = (void *)objc_claimAutoreleasedReturnValue();

  return v32;
}

__CFString *formatStringForLog(void *a1)
{
  void *v1;
  __CFString *v2;

  if (a1)
  {
    objc_msgSend(a1, "stringByReplacingOccurrencesOfString:withString:", CFSTR(" "), CFSTR(""));
    v1 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v1, "stringByReplacingOccurrencesOfString:withString:", CFSTR("\n"), CFSTR(""));
    v2 = (__CFString *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v2 = CFSTR("");
  }
  return v2;
}

uint64_t __Block_byref_object_copy__20681(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20682(uint64_t a1)
{

}

uint64_t __Block_byref_object_copy__20834(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20835(uint64_t a1)
{

}

uint64_t __Block_byref_object_copy__20977(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20978(uint64_t a1)
{

}

const __CFData *TICryptographerCreateStringDigest(const __CFString *a1, const __CFData *a2)
{
  const __CFData *Mutable;
  const char *CStringPtr;
  const char *v5;
  CC_LONG v6;
  CFIndex Length;
  CFIndex v8;
  CFIndex v9;
  CFIndex Bytes;
  BOOL v11;
  const UInt8 *BytePtr;
  CC_LONG v13;
  uint64_t i;
  CFIndex usedBufLen;
  CC_SHA1_CTX c;
  UInt8 buffer[512];
  uint64_t v19;
  CFRange v20;

  Mutable = a2;
  v19 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    memset(&c, 0, sizeof(c));
    CC_SHA1_Init(&c);
    CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    if (CStringPtr)
    {
      v5 = CStringPtr;
      v6 = strlen(CStringPtr);
      CC_SHA1_Update(&c, v5, v6);
    }
    else
    {
      Length = CFStringGetLength(a1);
      if (Length >= 1)
      {
        v8 = Length;
        v9 = 0;
        do
        {
          usedBufLen = 0;
          v20.location = v9;
          v20.length = v8;
          Bytes = CFStringGetBytes(a1, v20, 0x8000100u, 0, 0, buffer, 512, &usedBufLen);
          CC_SHA1_Update(&c, buffer, usedBufLen);
          v9 += Bytes;
          v11 = v8 <= Bytes;
          v8 -= Bytes;
        }
        while (!v11);
      }
    }
    BytePtr = CFDataGetBytePtr(Mutable);
    v13 = CFDataGetLength(Mutable);
    CC_SHA1_Update(&c, BytePtr, v13);
    CC_SHA1_Final(buffer, &c);
    Mutable = (const __CFData *)CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 40);
    for (i = 0; i != 20; ++i)
      CFStringAppendFormat((CFMutableStringRef)Mutable, 0, CFSTR("%x"), buffer[i]);
  }
  return Mutable;
}

CFDataRef TICryptographerCreateSalt()
{
  UInt8 __buf[20];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  arc4random_buf(__buf, 0x14uLL);
  return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __buf, 20);
}

std::vector<unsigned int> *KB::Alignment::operator*@<X0>(std::vector<unsigned int> *__x@<X0>, uint64_t *a2@<X1>, std::vector<unsigned int> *a3@<X8>)
{
  std::vector<unsigned int> *result;
  std::vector<unsigned int>::pointer begin;
  unsigned int *end;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = std::vector<unsigned int>::vector(a3, __x);
  begin = result->__begin_;
  end = result->__end_;
  v7 = (char *)end - (char *)result->__begin_;
  if (end != result->__begin_)
  {
    v8 = 0;
    v9 = v7 >> 2;
    v10 = *a2;
    do
    {
      v11 = begin[v8];
      if ((_DWORD)v11 != -1)
        begin[v8] = *(_DWORD *)(v10 + 4 * v11);
      ++v8;
    }
    while (v9 > v8);
  }
  return result;
}

uint64_t *KB::Alignment::operator*=(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *result;
  v3 = result[1];
  v4 = v3 - *result;
  if (v3 != *result)
  {
    v5 = 0;
    v6 = v4 >> 2;
    v7 = *a2;
    do
    {
      v8 = *(unsigned int *)(v2 + 4 * v5);
      if ((_DWORD)v8 != -1)
        *(_DWORD *)(v2 + 4 * v5) = *(_DWORD *)(v7 + 4 * v8);
      ++v5;
    }
    while (v6 > v5);
  }
  return result;
}

uint64_t KB::Alignment::range_contains_domain(unsigned int **a1, _QWORD *a2)
{
  unsigned int *v2;
  unsigned int *v3;
  uint64_t v4;

  v2 = *a1;
  v3 = a1[1];
  if (*a1 == v3)
    return 1;
  while (1)
  {
    v4 = *v2;
    if ((_DWORD)v4 != -1 && *(_DWORD *)(*a2 + 4 * v4) == -1)
      break;
    if (++v2 == v3)
      return 1;
  }
  return 0;
}

void KB::Alignment::inverse(KB::Alignment *this@<X0>, std::vector<unsigned int>::size_type __n@<X1>, uint64_t a3@<X8>)
{
  std::vector<unsigned int>::const_iterator v6;
  uint64_t v7;
  unsigned int *begin;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  std::vector<unsigned int>::size_type v13;
  std::vector<unsigned int>::value_type __x;
  std::vector<unsigned int> v16;

  memset(&v16, 0, sizeof(v16));
  __x = -1;
  v6.__i_ = 0;
  std::vector<unsigned int>::insert(&v16, v6, __n, &__x);
  v7 = *(_QWORD *)this;
  begin = v16.__begin_;
  v9 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (!v9)
  {
LABEL_8:
    *(_QWORD *)a3 = begin;
    *(_OWORD *)(a3 + 8) = *(_OWORD *)&v16.__end_;
    return;
  }
  v10 = 0;
  v11 = v9 >> 2;
  v12 = 1;
  while (1)
  {
    v13 = *(unsigned int *)(v7 + 4 * v10);
    if ((_DWORD)v13 != -1)
      break;
LABEL_7:
    v10 = v12;
    if (v11 <= v12++)
      goto LABEL_8;
  }
  if (v13 < __n)
  {
    if (begin[v13] == -1)
      begin[v13] = v12 - 1;
    goto LABEL_7;
  }
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  if (begin)
  {
    v16.__end_ = begin;
    operator delete(begin);
  }
}

void KB::Alignment::description(KB::Alignment *this@<X0>, unsigned __int16 *a2@<X8>)
{
  unsigned __int16 *v3;
  uint64_t v4;
  unint64_t v6;
  unsigned int v7;
  int v8;
  int v9;
  unsigned __int16 *v10;
  unsigned __int16 v11;
  __int16 v12;
  __int16 v13;
  __int16 v14;
  __int16 v15;
  __int16 v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;

  *(_DWORD *)a2 = 0x100000;
  a2[2] = 0;
  *((_BYTE *)a2 + 6) = 0;
  *((_QWORD *)a2 + 1) = 0;
  *((_BYTE *)a2 + 16) = 0;
  v3 = a2 + 8;
  v4 = *(_QWORD *)this;
  if (*((_QWORD *)this + 1) != *(_QWORD *)this)
  {
    v6 = 0;
    v7 = 1;
    do
    {
      v8 = *(_DWORD *)(v4 + 4 * v6);
      if (v8 == -1)
        KB::String::append(a2, "x ", 0xFFFFuLL);
      else
        KB::String::append_format((KB::String *)a2, "%d ", v8);
      v6 = v7;
      v4 = *(_QWORD *)this;
      ++v7;
    }
    while (v6 < (uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 2);
    v9 = *a2;
    if (*a2)
    {
      v10 = (unsigned __int16 *)*((_QWORD *)a2 + 1);
      if (!v10)
        v10 = v3;
      *(_QWORD *)&v17 = v10;
      DWORD2(v17) = v9;
      HIDWORD(v17) = v9;
      LODWORD(v18) = 0;
      KB::String::iterator::initialize((uint64_t *)&v17);
      v19 = v17;
      v20 = v18;
      KB::String::iterator::operator--((KB::String::iterator *)&v19);
      v11 = WORD6(v19);
      if (SDWORD2(v19) <= SHIDWORD(v19))
      {
        if (v20 >= 0x10000)
          v12 = -4;
        else
          v12 = -3;
        if ((v20 - 1114112) >= 0xFFEFE000)
          v13 = v12;
        else
          v13 = 0;
        if (v20 >> 11 >= 0x1B)
          v14 = v13;
        else
          v14 = -3;
        if (v20 >= 0x800)
          v15 = v14;
        else
          v15 = -2;
        if (v20 >= 0x80)
          v16 = v15;
        else
          v16 = -1;
        v11 = v16 + WORD4(v19);
      }
      KB::String::resize((KB::String *)a2, v11, 0);
    }
  }
}

BOOL TICanLogMessageAtLevel(unsigned int a1)
{
  if (TICanLogMessageAtLevel_onceToken != -1)
    dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
  return TICanLogMessageAtLevel_logLevel >= a1;
}

id TIOSLogFacility()
{
  if (TIOSLogFacility_onceToken != -1)
    dispatch_once(&TIOSLogFacility_onceToken, &__block_literal_global_28);
  return (id)TIOSLogFacility_logFacility;
}

id TIProactiveQuickTypeOSLogFacility()
{
  if (TIProactiveQuickTypeOSLogFacility_onceToken != -1)
    dispatch_once(&TIProactiveQuickTypeOSLogFacility_onceToken, &__block_literal_global_31_21196);
  return (id)TIProactiveQuickTypeOSLogFacility_logFacility;
}

id TIPersonalizationNamedEntityOSLogFacility()
{
  if (TIPersonalizationNamedEntityOSLogFacility_onceToken != -1)
    dispatch_once(&TIPersonalizationNamedEntityOSLogFacility_onceToken, &__block_literal_global_32_21198);
  return (id)TIPersonalizationNamedEntityOSLogFacility_logFacility;
}

id TIPersonalizationContactOSLogFacility()
{
  if (TIPersonalizationContactOSLogFacility_onceToken != -1)
    dispatch_once(&TIPersonalizationContactOSLogFacility_onceToken, &__block_literal_global_33_21202);
  return (id)TIPersonalizationContactOSLogFacility_logFacility;
}

id TIPersonalizationAppNamesOSLogFacility()
{
  if (TIPersonalizationAppNamesOSLogFacility_onceToken != -1)
    dispatch_once(&TIPersonalizationAppNamesOSLogFacility_onceToken, &__block_literal_global_34);
  return (id)TIPersonalizationAppNamesOSLogFacility_logFacility;
}

id TIInlineCompletionsOSLogFacility()
{
  if (TIInlineCompletionsOSLogFacility_onceToken != -1)
    dispatch_once(&TIInlineCompletionsOSLogFacility_onceToken, &__block_literal_global_36);
  return (id)TIInlineCompletionsOSLogFacility_logFacility;
}

id TISupplementalLexiconOSLogFacility()
{
  if (TISupplementalLexiconOSLogFacility_onceToken != -1)
    dispatch_once(&TISupplementalLexiconOSLogFacility_onceToken, &__block_literal_global_48);
  return (id)TISupplementalLexiconOSLogFacility_logFacility;
}

id TIAppAutofillOSLogFacility()
{
  if (TIAppAutofillOSLogFacility_onceToken != -1)
    dispatch_once(&TIAppAutofillOSLogFacility_onceToken, &__block_literal_global_50);
  return (id)TIAppAutofillOSLogFacility_logFacility;
}

id TIStickerCandidateGeneratorOSLogFacility()
{
  if (TIStickerCandidateGeneratorOSLogFacility_onceToken != -1)
    dispatch_once(&TIStickerCandidateGeneratorOSLogFacility_onceToken, &__block_literal_global_54);
  return (id)TIStickerCandidateGeneratorOSLogFacility_logFacility;
}

id UnicodeScalar.__ivar_initializer()
{
  if (TISceneTaxonomyGeneratorOSLogFacility_onceToken != -1)
    dispatch_once(&TISceneTaxonomyGeneratorOSLogFacility_onceToken, &__block_literal_global_56);
  return (id)TISceneTaxonomyGeneratorOSLogFacility_logFacility;
}

void TIAddressBookFindRecordsMatchingRecipientsAsync(void *a1, void *a2)
{
  id v3;
  objc_class *v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  id v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;

  v3 = a2;
  v4 = (objc_class *)MEMORY[0x1E0C99E20];
  v5 = a1;
  v6 = (void *)objc_msgSend([v4 alloc], "initWithCapacity:", objc_msgSend(v5, "count"));
  v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E20]), "initWithCapacity:", objc_msgSend(v5, "count"));
  divideRecipientsIntoEmailAddressesAndPhoneNumbers(v5, v6, v7);

  __GetAddressBookLookupQueue();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = v6;
  v13 = v7;
  v14 = v3;
  v9 = v3;
  v10 = v7;
  v11 = v6;
  TIDispatchAsync();

}

void divideRecipientsIntoEmailAddressesAndPhoneNumbers(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  void *v12;
  char v13;
  void *v14;
  char v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[128];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v8 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
  if (v8)
  {
    v9 = v8;
    v10 = *(_QWORD *)v17;
    do
    {
      for (i = 0; i != v9; ++i)
      {
        if (*(_QWORD *)v17 != v10)
          objc_enumerationMutation(v5);
        v12 = *(void **)(*((_QWORD *)&v16 + 1) + 8 * i);
        v13 = objc_msgSend(v12, "hasPrefix:", CFSTR("mailto:"));
        v14 = v6;
        if ((v13 & 1) == 0)
        {
          v15 = objc_msgSend(v12, "hasPrefix:", CFSTR("tel:"));
          v14 = v7;
          if ((v15 & 1) == 0)
          {
            if (objc_msgSend(v12, "rangeOfString:", CFSTR("@")) == 0x7FFFFFFFFFFFFFFFLL)
              v14 = v7;
            else
              v14 = v6;
          }
        }
        objc_msgSend(v14, "addObject:", v12);
      }
      v9 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
    }
    while (v9);
  }

}

id __GetAddressBookLookupQueue()
{
  if (__GetAddressBookLookupQueue_onceToken != -1)
    dispatch_once(&__GetAddressBookLookupQueue_onceToken, &__block_literal_global_21275);
  return (id)__GetAddressBookLookupQueue___queueSingleton;
}

id recordsFromAddressBookMatchingRecipients(void *a1, void *a2, void *a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  id v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  id v29;
  void *v30;
  void *v31;
  void *v32;
  id v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  id v40;
  id v41;
  id obj;
  id v43;
  id v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  _BYTE v54[128];
  _BYTE v55[128];
  _QWORD v56[3];

  v56[1] = *MEMORY[0x1E0C80C00];
  v44 = a1;
  v5 = a2;
  v40 = a3;
  v43 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", objc_msgSend(v40, "count") + objc_msgSend(v5, "count"));
  v49 = 0u;
  v50 = 0u;
  v51 = 0u;
  v52 = 0u;
  obj = v5;
  v6 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v49, v55, 16);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)v50;
    v9 = *MEMORY[0x1E0C966E8];
    do
    {
      v10 = 0;
      do
      {
        if (*(_QWORD *)v50 != v8)
          objc_enumerationMutation(obj);
        v11 = *(id *)(*((_QWORD *)&v49 + 1) + 8 * v10);
        v12 = v11;
        if (objc_msgSend(v11, "hasPrefix:", CFSTR("mailto:")))
        {
          objc_msgSend(v11, "substringFromIndex:", objc_msgSend(CFSTR("mailto:"), "length"));
          v12 = (void *)objc_claimAutoreleasedReturnValue();

        }
        v13 = objc_msgSend(v11, "rangeOfString:options:", CFSTR(">"), 14);
        if (v13 != 0x7FFFFFFFFFFFFFFFLL)
        {
          v14 = v13;
          v15 = objc_msgSend(v11, "rangeOfString:options:", CFSTR("<"), 6);
          if (v15 != 0x7FFFFFFFFFFFFFFFLL)
          {
            objc_msgSend(v11, "substringWithRange:", v15 + v16, v14 - (v15 + v16));
            v17 = objc_claimAutoreleasedReturnValue();

            v12 = (void *)v17;
          }
        }

        v18 = (void *)MEMORY[0x1E0C97200];
        v19 = v44;
        objc_msgSend(v18, "predicateForContactsMatchingEmailAddress:", v12);
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        v56[0] = v9;
        objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v56, 1);
        v21 = (void *)objc_claimAutoreleasedReturnValue();
        v53 = 0;
        objc_msgSend(v19, "unifiedContactsMatchingPredicate:keysToFetch:error:", v20, v21, &v53);
        v22 = (void *)objc_claimAutoreleasedReturnValue();

        recordsFromAddressBookUIDs(v19, v22);
        v23 = (void *)objc_claimAutoreleasedReturnValue();

        if (v23)
          objc_msgSend(v43, "setObject:forKey:", v23, v11);

        ++v10;
      }
      while (v7 != v10);
      v7 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v49, v55, 16);
    }
    while (v7);
  }

  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v41 = v40;
  v24 = objc_msgSend(v41, "countByEnumeratingWithState:objects:count:", &v45, v54, 16);
  if (v24)
  {
    v25 = v24;
    v26 = *(_QWORD *)v46;
    v27 = *MEMORY[0x1E0C966E8];
    do
    {
      v28 = 0;
      do
      {
        if (*(_QWORD *)v46 != v26)
          objc_enumerationMutation(v41);
        v29 = *(id *)(*((_QWORD *)&v45 + 1) + 8 * v28);
        v30 = v29;
        if (objc_msgSend(v29, "hasPrefix:", CFSTR("tel:")))
        {
          objc_msgSend(v29, "substringFromIndex:", objc_msgSend(CFSTR("tel:"), "length"));
          v30 = (void *)objc_claimAutoreleasedReturnValue();

        }
        v31 = (void *)MEMORY[0x1E0C97200];
        v32 = (void *)MEMORY[0x1E0C97398];
        v33 = v44;
        objc_msgSend(v32, "phoneNumberWithStringValue:", v30);
        v34 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v31, "predicateForContactsMatchingPhoneNumber:", v34);
        v35 = (void *)objc_claimAutoreleasedReturnValue();

        v56[0] = v27;
        objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v56, 1);
        v36 = (void *)objc_claimAutoreleasedReturnValue();
        v53 = 0;
        objc_msgSend(v33, "unifiedContactsMatchingPredicate:keysToFetch:error:", v35, v36, &v53);
        v37 = (void *)objc_claimAutoreleasedReturnValue();

        recordsFromAddressBookUIDs(v33, v37);
        v38 = (void *)objc_claimAutoreleasedReturnValue();

        if (v38)
          objc_msgSend(v43, "setObject:forKey:", v38, v29);

        ++v28;
      }
      while (v25 != v28);
      v25 = objc_msgSend(v41, "countByEnumeratingWithState:objects:count:", &v45, v54, 16);
    }
    while (v25);
  }

  return v43;
}

id recordsFromAddressBookUIDs(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t i;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void *v21;
  id v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[128];
  _QWORD v29[3];

  v29[1] = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  objc_msgSend(MEMORY[0x1E0C97218], "descriptorForRequiredKeysForStyle:", 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v29[0] = v5;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v29, 1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v7 = v4;
  v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
  if (v8)
  {
    v9 = v8;
    v10 = 0;
    v11 = *(_QWORD *)v25;
    while (2)
    {
      for (i = 0; i != v9; ++i)
      {
        if (*(_QWORD *)v25 != v11)
          objc_enumerationMutation(v7);
        objc_msgSend(*(id *)(*((_QWORD *)&v24 + 1) + 8 * i), "identifier");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        v23 = 0;
        objc_msgSend(v3, "unifiedContactWithIdentifier:keysToFetch:error:", v13, v6, &v23);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        v15 = v23;

        if (v14)
        {
          if (!v10)
          {
            objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
            v10 = (void *)objc_claimAutoreleasedReturnValue();
          }
          objc_msgSend(v14, "givenName");
          v16 = (void *)objc_claimAutoreleasedReturnValue();

          if (v16)
          {
            objc_msgSend(v14, "givenName");
            v17 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v10, "setObject:forKey:", v17, CFSTR("firstName"));

          }
          objc_msgSend(v14, "familyName");
          v18 = (void *)objc_claimAutoreleasedReturnValue();

          if (v18)
          {
            objc_msgSend(v14, "familyName");
            v19 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v10, "setObject:forKey:", v19, CFSTR("lastName"));

          }
          objc_msgSend(MEMORY[0x1E0C97218], "stringFromContact:style:", v14, 0);
          v20 = objc_claimAutoreleasedReturnValue();
          if (v20)
          {
            v21 = (void *)v20;
            objc_msgSend(v10, "setObject:forKey:", v20, CFSTR("compositeName"));

            goto LABEL_19;
          }
        }

      }
      v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
      if (v9)
        continue;
      break;
    }
  }
  else
  {
    v10 = 0;
  }
LABEL_19:

  return v10;
}

id TIAddressBookFindRecordsMatchingRecipients(void *a1)
{
  id v1;
  uint64_t *v2;
  NSObject *v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  unint64_t v15;
  NSObject *v16;
  id v17;
  id v18;
  uint64_t *v19;
  unint64_t v20;
  void *v21;
  void *v22;
  id v23;
  _QWORD v24[4];
  id v25;
  id v26;
  id v27;
  id v28;
  uint64_t *v29;
  __int128 *v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  char v34;
  uint8_t buf[4];
  void *v36;
  __int128 v37;
  uint64_t v38;
  uint64_t (*v39)(uint64_t, uint64_t);
  void (*v40)(uint64_t);
  id v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = &+[TILanguageModelLoaderManager recipientRecords]::__recipientRecords;
  if (TICanLogMessageAtLevel_onceToken != -1)
    dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
  if (TICanLogMessageAtLevel_logLevel >= 2)
  {
    TIOSLogFacility();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s CONTACTS: Lookup record(s) for %lu recipient(s)"), "TIAddressBookFindRecordsMatchingRecipients", objc_msgSend(v1, "count"));
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(v37) = 138412290;
      *(_QWORD *)((char *)&v37 + 4) = v22;
      _os_log_debug_impl(&dword_1DA6F2000, v3, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&v37, 0xCu);

    }
  }
  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E20]), "initWithCapacity:", objc_msgSend(v1, "count"));
  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E20]), "initWithCapacity:", objc_msgSend(v1, "count"));
  divideRecipientsIntoEmailAddressesAndPhoneNumbers(v1, v4, v5);
  v6 = objc_alloc_init(MEMORY[0x1E0CB3530]);
  *(_QWORD *)&v37 = 0;
  *((_QWORD *)&v37 + 1) = &v37;
  v38 = 0x3032000000;
  v39 = __Block_byref_object_copy__21283;
  v40 = __Block_byref_object_dispose__21284;
  v41 = 0;
  v31 = 0;
  v32 = &v31;
  v33 = 0x2020000000;
  v34 = 0;
  v7 = objc_alloc_init(MEMORY[0x1E0C97298]);
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 3221225472;
  v24[2] = __TIAddressBookFindRecordsMatchingRecipients_block_invoke;
  v24[3] = &unk_1EA1073C0;
  v8 = v7;
  v25 = v8;
  v9 = v4;
  v26 = v9;
  v10 = v5;
  v27 = v10;
  v11 = v6;
  v28 = v11;
  v29 = &v31;
  v30 = &v37;
  objc_msgSend(v8, "requestAccessForEntityType:completionHandler:", 0, v24);
  objc_msgSend(MEMORY[0x1E0C99D68], "dateWithTimeIntervalSinceNow:", 120.0);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "lock");
  if (!*((_BYTE *)v32 + 24))
  {
    v15 = 0x1E0CB3000uLL;
    do
    {
      if ((objc_msgSend(v11, "waitUntilDate:", v12) & 1) == 0)
      {
        *((_BYTE *)v32 + 24) = 1;
        if (v2[77] != -1)
          dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
        TIOSLogFacility();
        v16 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(*(id *)(v15 + 2368), "stringWithFormat:", CFSTR("%s CONTACTS: Timeout while waiting for access to database"), "TIAddressBookFindRecordsMatchingRecipients");
          v23 = v10;
          v17 = v9;
          v18 = v1;
          v19 = v2;
          v20 = v15;
          v21 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138412290;
          v36 = v21;
          _os_log_debug_impl(&dword_1DA6F2000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);

          v15 = v20;
          v2 = v19;
          v1 = v18;
          v9 = v17;
          v10 = v23;
        }

      }
    }
    while (!*((_BYTE *)v32 + 24));
  }
  objc_msgSend(v11, "unlock");
  v13 = *(id *)(*((_QWORD *)&v37 + 1) + 40);

  _Block_object_dispose(&v31, 8);
  _Block_object_dispose(&v37, 8);

  return v13;
}

uint64_t __Block_byref_object_copy__21283(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__21284(uint64_t a1)
{

}

id TIAddressBookFindRecordsMatchingRecipientsOnMainThread(void *a1)
{
  objc_class *v1;
  id v2;
  void *v3;
  void *v4;
  id v5;
  dispatch_semaphore_t v6;
  NSObject *v7;
  id v8;
  id v9;
  id v10;
  dispatch_time_t v11;
  id v12;
  _QWORD v14[4];
  id v15;
  id v16;
  id v17;
  dispatch_semaphore_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t, uint64_t);
  void (*v24)(uint64_t);
  id v25;

  v20 = 0;
  v21 = &v20;
  v22 = 0x3032000000;
  v23 = __Block_byref_object_copy__21283;
  v24 = __Block_byref_object_dispose__21284;
  v25 = 0;
  v1 = (objc_class *)MEMORY[0x1E0C99E20];
  v2 = a1;
  v3 = (void *)objc_msgSend([v1 alloc], "initWithCapacity:", objc_msgSend(v2, "count"));
  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E20]), "initWithCapacity:", objc_msgSend(v2, "count"));
  divideRecipientsIntoEmailAddressesAndPhoneNumbers(v2, v3, v4);

  v5 = objc_alloc_init(MEMORY[0x1E0C97298]);
  v6 = dispatch_semaphore_create(0);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3221225472;
  v14[2] = __TIAddressBookFindRecordsMatchingRecipientsOnMainThread_block_invoke;
  v14[3] = &unk_1EA1073E8;
  v18 = v6;
  v19 = &v20;
  v15 = v5;
  v16 = v3;
  v17 = v4;
  v7 = v6;
  v8 = v4;
  v9 = v3;
  v10 = v5;
  objc_msgSend(v10, "requestAccessForEntityType:completionHandler:", 0, v14);
  v11 = dispatch_time(0, 5000000000);
  dispatch_semaphore_wait(v7, v11);
  v12 = (id)v21[5];

  _Block_object_dispose(&v20, 8);
  return v12;
}

id TIAddressBookGetMeCardWithKeys(void *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = 0;
  objc_msgSend(a1, "_ios_meContactWithKeysToFetch:error:", a2, &v3);
  return (id)objc_claimAutoreleasedReturnValue();
}

id TIAddressBookGetMeCard(void *a1)
{
  void *v1;
  id v2;
  void *v3;
  void *v4;
  void *v5;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x1E0C80C00];
  v1 = (void *)MEMORY[0x1E0C972A8];
  v2 = a1;
  objc_msgSend(v1, "descriptorForRequiredKeys");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v7[0] = v3;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v7, 1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  TIAddressBookGetMeCardWithKeys(v2, (uint64_t)v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

id TIAddressBookGetArrayOfMeCardEmailAddresses(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v17[0] = *MEMORY[0x1E0C966A8];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v17, 1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  TIAddressBookGetMeCardWithKeys(v1, (uint64_t)v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  objc_msgSend(v3, "emailAddresses", 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)v13;
    do
    {
      v9 = 0;
      do
      {
        if (*(_QWORD *)v13 != v8)
          objc_enumerationMutation(v5);
        objc_msgSend(*(id *)(*((_QWORD *)&v12 + 1) + 8 * v9), "value");
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v4, "addObject:", v10);

        ++v9;
      }
      while (v7 != v9);
      v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
    }
    while (v7);
  }

  return v4;
}

void TIGetMeCardAsync(void *a1)
{
  id v1;
  void *v2;
  id v3;
  void *v4;

  v1 = a1;
  __GetAddressBookLookupQueue();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v1;
  v3 = v1;
  TIDispatchAsync();

}

void KB::CollatorWrapper::sortkey_for_string_with_root_collator(KB::CollatorWrapper *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5;

  v5 = _icu_root_collator();
  _sortkey_for_string_with_collator(a2, this, v5);
}

uint64_t _icu_root_collator(void)
{
  unsigned __int8 v0;

  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<UCollator>::~shared_ptr[abi:nn180100], &_icu_root_collator(void)::root_collator, &dword_1DA6F2000);
  }
  if (_icu_root_collator(void)::once != -1)
    dispatch_once(&_icu_root_collator(void)::once, &__block_literal_global_21306);
  return _icu_root_collator(void)::root_collator;
}

void _sortkey_for_string_with_collator(uint64_t a1, KB::String *this, uint64_t a3)
{
  unsigned int v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  const char *v11;
  const char *v12;
  UErrorCode v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  __int16 v20;
  const char *v21;
  const char *v22;
  uint64_t v23;
  size_t v24;
  unint64_t v25;
  char *v26;
  unsigned int SortKey;
  size_t v28;
  unint64_t v29;
  uint64_t v30;
  size_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char v35;
  size_t v36;
  void *v37;
  UErrorCode pErrorCode[2];

  if (!*(_WORD *)this)
  {
    *(_WORD *)a1 = 0;
    return;
  }
  v6 = *((unsigned __int16 *)this + 2);
  if (*((_WORD *)this + 2)
    || (KB::String::compute_length((unsigned __int16 *)this), v6 = *((unsigned __int16 *)this + 2), *((_WORD *)this + 2)))
  {
    v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(v6);
    v9 = &v7[2 * v8];
    bzero(v7, 2 * v6);
    v10 = &v7[2 * v6];
  }
  else
  {
    v7 = 0;
    v10 = 0;
    v9 = 0;
  }
  *(_QWORD *)pErrorCode = 0;
  v11 = (const char *)*((_QWORD *)this + 1);
  if (!v11)
    v11 = (char *)this + 16;
  if (*(_WORD *)this)
    v12 = v11;
  else
    v12 = "";
  u_strFromUTF8((UChar *)v7, (unint64_t)(v10 - v7) >> 1, (int32_t *)pErrorCode, v12, *(unsigned __int16 *)this, &pErrorCode[1]);
  v13 = pErrorCode[1];
  if (pErrorCode[1] == U_BUFFER_OVERFLOW_ERROR)
  {
    v14 = pErrorCode[0];
    v15 = (v10 - v7) >> 1;
    if ((int)pErrorCode[0] <= v15)
    {
      if ((int)pErrorCode[0] >= v15)
        v19 = v10;
      else
        v19 = &v7[2 * pErrorCode[0]];
    }
    else
    {
      v16 = (int)pErrorCode[0] - v15;
      if (v16 <= (v9 - v10) >> 1)
      {
        bzero(v10, 2 * v16);
        v19 = &v10[2 * v16];
      }
      else
      {
        if (pErrorCode[0] < 0)
          goto LABEL_71;
        if (v9 - v7 > (unint64_t)(int)pErrorCode[0])
          v14 = v9 - v7;
        if ((unint64_t)(v9 - v7) >= 0x7FFFFFFFFFFFFFFELL)
          v17 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v17 = v14;
        v18 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(v17)
            + 2 * v15;
        bzero(v18, 2 * v16);
        v19 = &v18[2 * v16];
        while (v10 != v7)
        {
          v20 = *((_WORD *)v10 - 1);
          v10 -= 2;
          *((_WORD *)v18 - 1) = v20;
          v18 -= 2;
        }
        if (v7)
          operator delete(v7);
        v7 = v18;
      }
    }
    pErrorCode[1] = U_ZERO_ERROR;
    v21 = (const char *)*((_QWORD *)this + 1);
    if (!v21)
      v21 = (char *)this + 16;
    if (*(_WORD *)this)
      v22 = v21;
    else
      v22 = "";
    u_strFromUTF8((UChar *)v7, (unint64_t)(v19 - v7) >> 1, (int32_t *)pErrorCode, v22, *(unsigned __int16 *)this, &pErrorCode[1]);
    v13 = pErrorCode[1];
  }
  if (v13 < U_ILLEGAL_ARGUMENT_ERROR && a3)
  {
    v23 = pErrorCode[0];
    if (pErrorCode[0] == U_ZERO_ERROR)
    {
      v25 = 0;
      v26 = 0;
LABEL_47:
      SortKey = ucol_getSortKey();
      v28 = SortKey - (_QWORD)&v26[-v25];
      if (SortKey <= (unint64_t)&v26[-v25])
      {
        v32 = v25;
LABEL_63:
        v36 = SortKey - 1;
        *(_WORD *)a1 = SortKey - 1;
        if ((unsigned __int16)(SortKey - 1) < 0xFu)
        {
          if (SortKey != 1)
            memmove((void *)(a1 + 2), (const void *)v32, v36);
        }
        else
        {
          v37 = (void *)operator new[]();
          *(_QWORD *)(a1 + 8) = v37;
          memcpy(v37, (const void *)v32, v36);
        }
        if (v32)
          operator delete((void *)v32);
        goto LABEL_39;
      }
      v29 = (unint64_t)&v26[-v25];
      v30 = SortKey;
      if (2 * (uint64_t)&v26[-v25] > (unint64_t)SortKey)
        v30 = 2 * v29;
      if (v29 >= 0x3FFFFFFFFFFFFFFFLL)
        v31 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v31 = v30;
      if (v31)
        v32 = (unint64_t)operator new(v31);
      else
        v32 = 0;
      v33 = (char *)(v32 + v29);
      bzero(v33, v28);
      if (v26 == (char *)v25)
      {
        v32 = (unint64_t)v33;
        if (!v25)
          goto LABEL_62;
      }
      else
      {
        v34 = &v26[~v25];
        do
        {
          v35 = *--v26;
          (v34--)[v32] = v35;
        }
        while (v26 != (char *)v25);
        if (!v25)
          goto LABEL_62;
      }
      operator delete((void *)v25);
LABEL_62:
      SortKey = ucol_getSortKey();
      goto LABEL_63;
    }
    if ((pErrorCode[0] & 0x80000000) == 0)
    {
      v24 = 3 * (int)pErrorCode[0];
      v25 = (unint64_t)operator new(v24);
      v26 = (char *)(v25 + v24);
      bzero((void *)v25, 3 * v23);
      goto LABEL_47;
    }
LABEL_71:
    abort();
  }
  *(_WORD *)a1 = 0;
LABEL_39:
  if (v7)
    operator delete(v7);
}

uint64_t std::shared_ptr<UCollator>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void ___ZL18_icu_root_collatorv_block_invoke()
{
  uint64_t v0;
  _QWORD *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v0 = ucol_open();
  v1 = (_QWORD *)operator new();
  *v1 = &off_1EA1074E8;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = v0;
  v1[4] = MEMORY[0x1E0DE5F70];
  v2 = (std::__shared_weak_count *)qword_1F0282F18;
  _icu_root_collator(void)::root_collator = v0;
  qword_1F0282F18 = (uint64_t)v1;
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

void std::__shared_ptr_pointer<UCollator *,void (*)(UCollator *),std::allocator<UCollator>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1DF0A2144);
}

uint64_t std::__shared_ptr_pointer<UCollator *,void (*)(UCollator *),std::allocator<UCollator>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 24));
}

uint64_t KB::CollatorWrapper::sortkey_compare_strings_with_root_collator(KB::CollatorWrapper *this, const KB::String *a2, const KB::String *a3)
{
  _icu_root_collator();
  return _sortkey_compare_strings_with_collator();
}

uint64_t _sortkey_compare_strings_with_collator()
{
  int v0;
  unsigned int v1;

  v0 = ucol_strcollUTF8();
  if (v0)
    v1 = -1;
  else
    v1 = 0;
  if (v0 == 1)
    return 1;
  else
    return v1;
}

KB::CollatorWrapper *KB::CollatorWrapper::CollatorWrapper(KB::CollatorWrapper *this)
{
  *(_QWORD *)this = 0;
  KB::String::String((KB::CollatorWrapper *)((char *)this + 8), "");
  *((_QWORD *)this + 5) = &off_1EA107520;
  *((_QWORD *)this + 8) = (char *)this + 40;
  *((_QWORD *)this + 9) = &off_1EA107568;
  *((_QWORD *)this + 12) = (char *)this + 72;
  return this;
}

{
  *(_QWORD *)this = 0;
  KB::String::String((KB::CollatorWrapper *)((char *)this + 8), "");
  *((_QWORD *)this + 5) = &off_1EA107520;
  *((_QWORD *)this + 8) = (char *)this + 40;
  *((_QWORD *)this + 9) = &off_1EA107568;
  *((_QWORD *)this + 12) = (char *)this + 72;
  return this;
}

void std::__function::__func<KB::CollatorWrapper::CollatorWrapper(void)::$_1,std::allocator<KB::CollatorWrapper::CollatorWrapper(void)::$_1>,int ()(KB::String const&,KB::String const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::CollatorWrapper::CollatorWrapper(void)::$_1,std::allocator<KB::CollatorWrapper::CollatorWrapper(void)::$_1>,int ()(KB::String const&,KB::String const&)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA107568;
  return result;
}

void std::__function::__func<KB::CollatorWrapper::CollatorWrapper(void)::$_1,std::allocator<KB::CollatorWrapper::CollatorWrapper(void)::$_1>,int ()(KB::String const&,KB::String const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA107568;
}

BOOL std::__function::__func<KB::CollatorWrapper::CollatorWrapper(void)::$_1,std::allocator<KB::CollatorWrapper::CollatorWrapper(void)::$_1>,int ()(KB::String const&,KB::String const&)>::operator()()
{
  _icu_root_collator();
  return _sortkey_compare_strings_with_collator() == 0;
}

void std::__function::__func<KB::CollatorWrapper::CollatorWrapper(void)::$_0,std::allocator<KB::CollatorWrapper::CollatorWrapper(void)::$_0>,KB::ByteString ()(KB::String const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::CollatorWrapper::CollatorWrapper(void)::$_0,std::allocator<KB::CollatorWrapper::CollatorWrapper(void)::$_0>,KB::ByteString ()(KB::String const&)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1EA107520;
  return result;
}

void std::__function::__func<KB::CollatorWrapper::CollatorWrapper(void)::$_0,std::allocator<KB::CollatorWrapper::CollatorWrapper(void)::$_0>,KB::ByteString ()(KB::String const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA107520;
}

void std::__function::__func<KB::CollatorWrapper::CollatorWrapper(void)::$_0,std::allocator<KB::CollatorWrapper::CollatorWrapper(void)::$_0>,KB::ByteString ()(KB::String const&)>::operator()(KB::String *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v4;

  v4 = _icu_root_collator();
  _sortkey_for_string_with_collator(a2, a1, v4);
}

KB::CollatorWrapper *KB::CollatorWrapper::CollatorWrapper(KB::CollatorWrapper *this, CFTypeRef cf, const KB::String *a3)
{
  *(_QWORD *)this = cf;
  if (cf)
  {
    CFRetain(cf);
    *(_QWORD *)this = cf;
  }
  KB::String::String((KB::CollatorWrapper *)((char *)this + 8), a3);
  *((_QWORD *)this + 5) = &off_1EA1075B0;
  *((_QWORD *)this + 6) = cf;
  *((_QWORD *)this + 8) = (char *)this + 40;
  *((_QWORD *)this + 9) = &off_1EA1075F8;
  *((_QWORD *)this + 10) = cf;
  *((_QWORD *)this + 12) = (char *)this + 72;
  return this;
}

void std::__function::__func<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_1,std::allocator<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_1>,int ()(KB::String const&,KB::String const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_1,std::allocator<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_1>,int ()(KB::String const&,KB::String const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA1075F8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_1,std::allocator<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_1>,int ()(KB::String const&,KB::String const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA1075F8;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_1,std::allocator<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_1>,int ()(KB::String const&,KB::String const&)>::operator()(uint64_t a1, _LXLexicon *a2, const KB::String *a3, const KB::String *a4)
{
  return KB::CollatorWrapper::_sortkey_compare_strings(*(KB::CollatorWrapper **)(a1 + 8), a2, a3, a4) == 0;
}

uint64_t KB::CollatorWrapper::_sortkey_compare_strings(KB::CollatorWrapper *this, _LXLexicon *a2, const KB::String *a3, const KB::String *a4)
{
  CFStringRef v5;
  CFStringRef v6;
  uint64_t v7;
  CFStringRef v9;
  CFStringRef v10;

  KB::cf_string_impl<KB::String>(&v10, (unsigned __int16 *)a2);
  v5 = v10;
  KB::cf_string_impl<KB::String>(&v9, (unsigned __int16 *)a3);
  v6 = v9;
  v7 = LXLexiconCompareStrings();
  if (v6)
    CFRelease(v6);
  if (v5)
    CFRelease(v5);
  return v7;
}

void std::__function::__func<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_0,std::allocator<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_0>,KB::ByteString ()(KB::String const&)>::~__func()
{
  JUMPOUT(0x1DF0A2144);
}

_QWORD *std::__function::__func<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_0,std::allocator<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_0>,KB::ByteString ()(KB::String const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1EA1075B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_0,std::allocator<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_0>,KB::ByteString ()(KB::String const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1EA1075B0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_0,std::allocator<KB::CollatorWrapper::CollatorWrapper(_LXLexicon const*,KB::String const&)::$_0>,KB::ByteString ()(KB::String const&)>::operator()(_LXLexicon *a1@<X1>, _WORD *a2@<X8>)
{
  KB::CollatorWrapper::_sortkey_for_string(a1, a2);
}

BOOL KB::CollatorWrapper::sortkey_equal_strings(KB::CollatorWrapper **this, _LXLexicon *a2, const KB::String *a3, const KB::String *a4)
{
  return KB::CollatorWrapper::sortkey_compare_strings(this, a2, a3, a4) == 0;
}

uint64_t KB::CollatorWrapper::sortkey_compare_strings(KB::CollatorWrapper **this, _LXLexicon *a2, const KB::String *a3, const KB::String *a4)
{
  KB::CollatorWrapper *v4;

  v4 = *this;
  if (v4)
    return KB::CollatorWrapper::_sortkey_compare_strings(v4, a2, a3, a4);
  _icu_root_collator();
  return _sortkey_compare_strings_with_collator();
}

BOOL KB::CollatorWrapper::sortkey_starts_with(KB::CollatorWrapper *this, _LXLexicon *a2, _LXLexicon *a3)
{
  _BOOL8 v5;
  ByteString v7;
  unsigned __int16 v8;
  uint64_t v9;

  KB::CollatorWrapper::sortkey_for_string(this, a2, &v8);
  KB::CollatorWrapper::sortkey_for_string(this, a3, &v7);
  v5 = KB::ByteString::starts_with((KB::ByteString *)&v8, &v7);
  if (v7.var0.var0.var0 >= 0xFu && v7.var0.var0.var1)
    MEMORY[0x1DF0A212C](v7.var0.var0.var1, 0x1000C8077774924);
  if (v8 >= 0xFu && v9)
    MEMORY[0x1DF0A212C](v9, 0x1000C8077774924);
  return v5;
}

char *get_file_path_for_bundle_resource(const __CFString *a1, const __CFString *a2)
{
  CFBundleRef BundleWithIdentifier;
  __CFBundle *v5;
  const __CFURL *v6;
  const __CFString *v7;
  CFIndex v8;
  char *v9;
  CFStringEncoding SystemEncoding;

  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.TextInputCore"));
  v5 = BundleWithIdentifier;
  if (BundleWithIdentifier)
    CFRetain(BundleWithIdentifier);
  v6 = CFBundleCopyResourceURL(v5, a1, a2, 0);
  v7 = CFURLCopyFileSystemPath(v6, kCFURLPOSIXPathStyle);
  v8 = CFStringGetLength(v7) + 1;
  v9 = (char *)malloc_type_malloc(v8, 0x49DACD06uLL);
  SystemEncoding = CFStringGetSystemEncoding();
  if (CFStringGetCString(v7, v9, v8, SystemEncoding))
  {
    if (!v7)
      goto LABEL_6;
    goto LABEL_5;
  }
  free(v9);
  v9 = 0;
  if (v7)
LABEL_5:
    CFRelease(v7);
LABEL_6:
  if (v6)
    CFRelease(v6);
  if (v5)
    CFRelease(v5);
  return v9;
}

CFPropertyListRef CreatePropertyListFromFile(const __CFString *a1, CFStringRef bundleID)
{
  CFBundleRef BundleWithIdentifier;
  __CFBundle *v4;
  const __CFURL *v5;
  const __CFAllocator *v6;
  __CFReadStream *v7;
  __CFReadStream *v8;
  CFPropertyListRef v9;
  const __CFString *v10;
  const char *v11;
  CFErrorRef error;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  const char *v17;
  _WORD v18[3];
  char v19;
  void *v20;
  _QWORD v21[3];

  v21[2] = *MEMORY[0x1E0C80C00];
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(bundleID);
  v4 = BundleWithIdentifier;
  if (BundleWithIdentifier)
    CFRetain(BundleWithIdentifier);
  v5 = CFBundleCopyResourceURL(v4, a1, CFSTR("plist"), 0);
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFReadStreamCreateWithFile((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5);
  if (v7)
  {
    v8 = v7;
    if (CFReadStreamOpen(v7))
    {
      error = 0;
      v9 = CFPropertyListCreateWithStream(v6, v8, 0, 0, 0, &error);
      if (error)
      {
        v10 = CFErrorCopyDescription(error);
        KB::utf8_string(v10, (uint64_t)v18);
        if (v10)
        {
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          {
            v11 = (const char *)v20;
            if (!v20)
              v11 = (const char *)v21;
            if (!v18[0])
              v11 = "";
            *(_DWORD *)buf = 136315394;
            v15 = "CreatePropertyListFromFile";
            v16 = 2080;
            v17 = v11;
            _os_log_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%s  Error! reading plist file: %s \n", buf, 0x16u);
          }
          CFRelease(v10);
        }
        CFRelease(error);
        if (v20 && v19 == 1)
          free(v20);
      }
      CFReadStreamClose(v8);
    }
    else
    {
      v9 = 0;
    }
    CFRelease(v8);
    if (v5)
      goto LABEL_22;
  }
  else
  {
    v9 = 0;
    if (v5)
LABEL_22:
      CFRelease(v5);
  }
  if (v4)
    CFRelease(v4);
  return v9;
}

void TI::CP::ScoreComponentSerializer::serialize_point(CGPoint a1@<0:D0, 8:D1>, uint64_t *a2@<X8>)
{
  double y;
  void *v5;
  void *v6;
  uint64_t v7;
  _QWORD v8[2];
  _QWORD v9[3];

  y = a1.y;
  v9[2] = *MEMORY[0x1E0C80C00];
  v8[0] = CFSTR("x");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", a1.x);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v8[1] = CFSTR("y");
  v9[0] = v5;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", y);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v9[1] = v6;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v9, v8, 2);
  v7 = objc_claimAutoreleasedReturnValue();

  *a2 = v7;
}

void TI::CP::ScoreComponentSerializer::serialize_score_component(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  void *v4;
  void *v5;
  void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  void *v13;
  void *v14;
  const void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  const __CFString *v22;
  const void *v23;
  _QWORD v24[2];
  _QWORD v25[3];

  v25[2] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *(double *)(a1 + 48));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "setObject:forKeyedSubscript:", v5, CFSTR("score"));

  switch(*(_DWORD *)a1)
  {
    case 0:
      objc_msgSend(v4, "setObject:forKeyedSubscript:", CFSTR("KeyDeviation"), CFSTR("type"));
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)(a1 + 4));
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v6, CFSTR("sample"));

      TI::CP::ScoreComponentSerializer::serialize_point(*(CGPoint *)(a1 + 16), (uint64_t *)&v23);
      v7 = v23;
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v23, CFSTR("point"));
      if (v7)
        CFRelease(v7);
      TI::CP::ScoreComponentSerializer::serialize_point(*(CGPoint *)(a1 + 32), (uint64_t *)&v23);
      v8 = v23;
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v23, CFSTR("keyPoint"));
      if (v8)
        CFRelease(v8);
      TI::CP::ScoreComponentSerializer::serialize_point(*(CGPoint *)(a1 + 32), (uint64_t *)&v23);
      v9 = v23;
      v10 = CFSTR("keyPoint");
      goto LABEL_18;
    case 1:
      v11 = CFSTR("PathDeviation");
      goto LABEL_15;
    case 2:
      v11 = CFSTR("Loop");
      goto LABEL_15;
    case 3:
      v11 = CFSTR("Overshoot");
      goto LABEL_15;
    case 4:
      v12 = CFSTR("SkippedKey");
      goto LABEL_13;
    case 5:
      v12 = CFSTR("KeySubstitution");
      goto LABEL_13;
    case 6:
      v12 = CFSTR("KeyPrediction");
LABEL_13:
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v12, CFSTR("type"));
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)(a1 + 4));
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v13, CFSTR("sample"));

      TI::CP::ScoreComponentSerializer::serialize_point(*(CGPoint *)(a1 + 16), (uint64_t *)&v23);
      v9 = v23;
      v10 = CFSTR("point");
      goto LABEL_18;
    case 7:
      v11 = CFSTR("Transposition");
LABEL_15:
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v11, CFSTR("type"));
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)(a1 + 4));
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v14, CFSTR("sample1"));

      TI::CP::ScoreComponentSerializer::serialize_point(*(CGPoint *)(a1 + 16), (uint64_t *)&v23);
      v15 = v23;
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v23, CFSTR("point1"));
      if (v15)
        CFRelease(v15);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)(a1 + 8));
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v16, CFSTR("sample2"));

      TI::CP::ScoreComponentSerializer::serialize_point(*(CGPoint *)(a1 + 32), (uint64_t *)&v23);
      v9 = v23;
      v10 = CFSTR("point2");
LABEL_18:
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v9, v10);
      if (v9)
        CFRelease(v9);
      break;
    case 8:
      objc_msgSend(v4, "setObject:forKeyedSubscript:", CFSTR("LanguageCharacter"), CFSTR("type"));
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *(unsigned int *)(a1 + 4));
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v17, CFSTR("sample"));

      v24[0] = CFSTR("x");
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *(double *)(a1 + 16));
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      v24[1] = CFSTR("y");
      v25[0] = v18;
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *(double *)(a1 + 24));
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      v25[1] = v19;
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v25, v24, 2);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v20, CFSTR("point"));

      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%C"), *(unsigned __int16 *)(a1 + 8));
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v21, CFSTR("character"));

      break;
    case 9:
      v22 = CFSTR("LanguageTermination");
      goto LABEL_23;
    case 0xA:
      v22 = CFSTR("LanguagePartialProb");
LABEL_23:
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v22, CFSTR("type"));
      break;
    default:
      break;
  }
  *a2 = v4;
}

void TI::CP::ScoreComponentSerializer::serialize_score_components(uint64_t *a1@<X0>, double *a2@<X1>, _QWORD *a3@<X8>)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  void *v10;
  id v11;

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *a2 = 0.0;
  v7 = *a1;
  v8 = a1[1];
  while (v7 != v8)
  {
    TI::CP::ScoreComponentSerializer::serialize_score_component(v7, &v11);
    v9 = v11;
    v10 = v9;
    if (v9)
      CFRelease(v9);
    *a2 = *(double *)(v7 + 48) + *a2;
    objc_msgSend(v6, "addObject:", v10);

    v7 += 56;
  }
  *a3 = v6;
}

void KB::LexiconWrapper::~LexiconWrapper(KB::LexiconWrapper *this)
{
  KB::LexiconWrapper::~LexiconWrapper(this);
  JUMPOUT(0x1DF0A2144);
}

{
  const void *v2;
  void *v3;

  *(_QWORD *)this = &off_1EA1076E0;
  v2 = (const void *)*((_QWORD *)this + 18);
  if (v2)
    CFRelease(v2);
  v3 = (void *)*((_QWORD *)this + 20);
  if (v3 && *((_BYTE *)this + 158) == 1)
    free(v3);
  KB::LexiconWrapperBase::~LexiconWrapperBase(this);
}

uint64_t KB::LexiconWrapper::lexicon(KB::LexiconWrapper *this)
{
  return *((_QWORD *)this + 18);
}

KB::LexiconWrapperBase *KB::LexiconWrapperBase::LexiconWrapperBase(KB::LexiconWrapperBase *this, const KB::String *a2)
{
  *(_QWORD *)this = off_1EA107690;
  KB::String::String((KB::LexiconWrapperBase *)((char *)this + 8), a2);
  *((_QWORD *)this + 5) = 0;
  KB::String::String((KB::LexiconWrapperBase *)((char *)this + 48), a2);
  *((_QWORD *)this + 10) = &off_1EA1075B0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 13) = (char *)this + 80;
  *((_QWORD *)this + 14) = &off_1EA1075F8;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 17) = (char *)this + 112;
  return this;
}

void KB::LexiconWrapperBase::enumerate_entries(uint64_t a1)
{
  const void *RootCursor;

  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    RootCursor = (const void *)LXLexiconCreateRootCursor();
    LXCursorEnumerateEntriesRecursively();
    if (RootCursor)
      CFRelease(RootCursor);
  }
}

void KB::LexiconWrapperBase::enumerate_entries_for_string(uint64_t a1, unsigned __int16 *a2)
{
  CFStringRef v4;
  CFStringRef v5;

  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    KB::cf_string_impl<KB::String>(&v5, a2);
    v4 = v5;
    LXLexiconEnumerateEntriesForString();
    if (v4)
      CFRelease(v4);
  }
}

void KB::LexiconWrapperBase::entry_for_string(KB::LexiconWrapperBase *this@<X0>, const KB::String *a2@<X1>, _QWORD *a3@<X8>)
{
  char *v6;
  CFStringRef v7;
  const void *v8;
  CFStringRef v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  void (*v14)(uint64_t);
  CFTypeRef cf;

  if (*((_WORD *)this + 4))
  {
    if (*((_QWORD *)this + 2))
      v6 = (char *)*((_QWORD *)this + 2);
    else
      v6 = (char *)this + 24;
  }
  else
  {
    v6 = "";
  }
  TILexiconIDForLocaleIdentifier(v6);
  v10 = 0;
  v11 = &v10;
  v12 = 0x3002000000;
  v13 = __Block_byref_object_copy__21476;
  v14 = __Block_byref_object_dispose__21477;
  cf = 0;
  (*(void (**)(KB::LexiconWrapperBase *))(*(_QWORD *)this + 16))(this);
  KB::cf_string_impl<KB::String>(&v9, (unsigned __int16 *)a2);
  v7 = v9;
  LXLexiconEnumerateEntriesForString();
  if (v7)
    CFRelease(v7);
  v8 = (const void *)v11[5];
  *a3 = v8;
  if (v8)
  {
    CFRetain(v8);
    *a3 = v8;
  }
  _Block_object_dispose(&v10, 8);
  if (cf)
    CFRelease(cf);
}

uint64_t __Block_byref_object_copy__21476(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(result + 40) = v2;
  return result;
}

void __Block_byref_object_dispose__21477(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 40);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)(a1 + 40) = 0;
}

void ___ZNK2KB18LexiconWrapperBase16entry_for_stringERKNS_6StringE_block_invoke(uint64_t a1, const void *a2, _BYTE *a3)
{
  _BOOL4 v6;
  BOOL v7;
  _BYTE v8[8];
  void *v9;
  _BYTE v10[240];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  KB::Word::Word((uint64_t)v10, (uint64_t)a2, *(_DWORD *)(a1 + 48));
  KB::Word::capitalized_string((KB::Word *)v10, (uint64_t)v8);
  v6 = KB::String::equal((KB::String *)v8, *(const KB::String **)(a1 + 40), 1);
  if (v9)
    v7 = v8[6] == 1;
  else
    v7 = 0;
  if (v7)
    free(v9);
  if (v6)
  {
    KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), a2);
    *a3 = 1;
  }
  KB::Word::~Word((KB::Word *)v10);
}

uint64_t KB::LexiconWrapperBase::total_usage_count(KB::LexiconWrapperBase *this)
{
  uint64_t RootCursor;
  const void *v3;
  uint64_t v4;

  if (!(*(uint64_t (**)(KB::LexiconWrapperBase *))(*(_QWORD *)this + 16))(this))
    return 0;
  (*(void (**)(KB::LexiconWrapperBase *))(*(_QWORD *)this + 16))(this);
  RootCursor = LXLexiconCreateRootCursor();
  if (!RootCursor)
    return 0;
  v3 = (const void *)RootCursor;
  v4 = LXCursorUsageCountRecursive();
  CFRelease(v3);
  return v4;
}

uint64_t KB::LexiconWrapperBase::usage_count_for_string(KB::LexiconWrapperBase *this, const KB::String *a2)
{
  const void *v2;
  uint64_t UsageCount;
  const void *v5;

  KB::LexiconWrapperBase::entry_for_string(this, a2, &v5);
  v2 = v5;
  if (!v5)
    return 0;
  UsageCount = LXEntryGetUsageCount();
  CFRelease(v2);
  return UsageCount;
}

KB::LexiconWrapper *KB::LexiconWrapper::LexiconWrapper(KB::LexiconWrapper *this, const KB::String *a2, const KB::String *a3)
{
  const KB::String *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  CFTypeRef cf;
  char v13;
  void *v14;
  _BYTE v15[24];
  _BYTE *v16;
  _BYTE v17[24];
  _BYTE *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = off_1EA107690;
  KB::String::String((KB::LexiconWrapper *)((char *)this + 8), a2);
  *((_QWORD *)this + 5) = 0;
  KB::String::String((KB::LexiconWrapper *)((char *)this + 48), a2);
  *((_QWORD *)this + 10) = &off_1EA1075B0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 14) = &off_1EA1075F8;
  *((_QWORD *)this + 13) = (char *)this + 80;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 17) = (char *)this + 112;
  *(_QWORD *)this = &off_1EA1076E0;
  *((_QWORD *)this + 18) = KB::LexiconWrapper::create_lexicon(a2, a3, v6);
  KB::String::String((KB::LexiconWrapper *)((char *)this + 152), a3);
  KB::CollatorWrapper::CollatorWrapper((KB::CollatorWrapper *)&cf, *((CFTypeRef *)this + 18), a2);
  KB::LexiconWrapperBase::set_collator(this, (uint64_t *)&cf);
  v7 = v18;
  if (v18 == v17)
  {
    v8 = 4;
    v7 = v17;
  }
  else
  {
    if (!v18)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = v16;
  if (v16 == v15)
  {
    v10 = 4;
    v9 = v15;
    goto LABEL_10;
  }
  if (v16)
  {
    v10 = 5;
LABEL_10:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  if (v14 && v13 == 1)
    free(v14);
  if (cf)
    CFRelease(cf);
  return this;
}

uint64_t KB::LexiconWrapper::create_lexicon(KB::LexiconWrapper *this, const KB::String *a2, const KB::String *a3)
{
  __CFDictionary *Mutable;
  const void *v6;
  void *v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  const char *v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  const char *v17;
  void *value;
  void *v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (*(_WORD *)this)
  {
    v6 = (const void *)*MEMORY[0x1E0D437B8];
    KB::cf_string_impl<KB::String>((CFStringRef *)&value, (unsigned __int16 *)this);
    v7 = value;
    CFDictionarySetValue(Mutable, v6, value);
    if (v7)
      CFRelease(v7);
  }
  if (*(_WORD *)a2)
  {
    v8 = (const void *)*MEMORY[0x1E0D43798];
    KB::cf_string_impl<KB::String>((CFStringRef *)&value, (unsigned __int16 *)a2);
    v9 = value;
    CFDictionarySetValue(Mutable, v8, value);
    if (v9)
      CFRelease(v9);
  }
  v10 = LXLexiconCreate();
  if (!v10)
  {
    LODWORD(value) = 0x100000;
    WORD2(value) = 0;
    BYTE6(value) = 0;
    v19 = 0;
    v20 = 0;
    if (TICanLogMessageAtLevel_onceToken != -1)
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_21185);
    if (TICanLogMessageAtLevel_logLevel >= 2)
    {
      v11 = TIOSLogFacility();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v13 = &v20;
        if (v19)
          v13 = (const char *)v19;
        if (!(_WORD)value)
          v13 = "";
        *(_DWORD *)buf = 136315394;
        v15 = "create_lexicon";
        v16 = 2080;
        v17 = v13;
        _os_log_debug_impl(&dword_1DA6F2000, v11, OS_LOG_TYPE_DEBUG, "%s Unable to create LXLexicon: %s", buf, 0x16u);
      }
    }
    if (v19 && BYTE6(value) == 1)
      free(v19);
  }
  if (Mutable)
    CFRelease(Mutable);
  return v10;
}

KB::Candidate *KB::Candidate::Candidate(KB::Candidate *this, const KB::Candidate *a2, const KB::Word *a3)
{
  _QWORD *v6;
  std::string *v7;
  __int128 v8;

  v6 = WTF::Vector<KB::Word,3ul>::Vector(this, a2);
  *(_OWORD *)(v6 + 93) = xmmword_1DA910F30;
  v6[95] = 0xFF8000003F800000;
  *(_OWORD *)(v6 + 97) = 0u;
  *(_OWORD *)(v6 + 99) = 0u;
  *(_OWORD *)(v6 + 101) = 0u;
  *(_OWORD *)(v6 + 103) = 0u;
  *((_QWORD *)this + 105) = 0;
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)(v6 + 106));
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 856));
  *((_QWORD *)this + 109) = 0;
  *((_QWORD *)this + 108) = 0;
  *((_QWORD *)this + 110) = 0;
  if (!*((_WORD *)a2 + 444))
    KB::Candidate::compute_string(a2);
  KB::String::String((KB::Candidate *)((char *)this + 888), (const KB::Candidate *)((char *)a2 + 888));
  v7 = (std::string *)((char *)this + 920);
  if (*((char *)a2 + 943) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *((const std::string::value_type **)a2 + 115), *((_QWORD *)a2 + 116));
  }
  else
  {
    v8 = *(_OWORD *)((char *)a2 + 920);
    *((_QWORD *)this + 117) = *((_QWORD *)a2 + 117);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  *((_WORD *)this + 472) = 0;
  *((_DWORD *)this + 240) = 0;
  *((_BYTE *)this + 964) = 0;
  *((_OWORD *)this + 61) = 0u;
  *((_DWORD *)this + 248) = 0;
  KB::Candidate::append((unsigned __int16 *)this, a3);
  return this;
}

void KB::Candidate::compute_string(KB::Candidate *this)
{
  unsigned __int16 *v2;
  uint64_t v3;
  const KB::String *v4;
  uint64_t v5;

  v2 = (unsigned __int16 *)((char *)this + 888);
  KB::String::clear((KB::Candidate *)((char *)this + 888));
  v3 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v4 = (const KB::String *)*((_QWORD *)this + 1);
    v5 = 240 * v3;
    do
    {
      KB::String::append(v2, v4);
      v4 = (const KB::String *)((char *)v4 + 240);
      v5 -= 240;
    }
    while (v5);
  }
}

unsigned __int16 *KB::Candidate::append(unsigned __int16 *this, const KB::Word *a2)
{
  uint64_t v3;
  unsigned __int16 *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  const KB::Word *v12;
  unint64_t v13;
  unint64_t v14;

  if (!*(_WORD *)a2)
    return this;
  v3 = (uint64_t)this;
  v4 = this + 444;
  if (!this[444])
    KB::Candidate::compute_string((KB::Candidate *)this);
  v5 = *(_QWORD *)v3;
  if (*(_QWORD *)v3 != *(_QWORD *)(v3 + 16))
  {
    v11 = *(_QWORD *)(v3 + 8);
    v12 = a2;
LABEL_24:
    KB::Word::Word((KB::Word *)(v11 + 240 * v5), v12);
    ++*(_QWORD *)v3;
    goto LABEL_25;
  }
  v6 = v5 + 1;
  v7 = *(_QWORD *)(v3 + 8);
  if (v7 <= (unint64_t)a2 && v7 + 240 * v5 > (unint64_t)a2)
  {
    v8 = (char *)a2 - v7;
    if (v5 >= 0x100)
      v9 = v5 + (v5 >> 1);
    else
      v9 = 2 * v5;
    if (v9 <= v6)
      v10 = v6;
    else
      v10 = v9;
    WTF::Vector<KB::Word,3ul>::reserveCapacity((_QWORD *)v3, v10);
    v11 = *(_QWORD *)(v3 + 8);
    v12 = (const KB::Word *)&v8[v11];
    if (!v11)
      goto LABEL_25;
    goto LABEL_23;
  }
  if (v5 >= 0x100)
    v13 = v5 + (v5 >> 1);
  else
    v13 = 2 * v5;
  if (v13 <= v6)
    v14 = v6;
  else
    v14 = v13;
  WTF::Vector<KB::Word,3ul>::reserveCapacity((_QWORD *)v3, v14);
  v11 = *(_QWORD *)(v3 + 8);
  v12 = a2;
  if (v11)
  {
LABEL_23:
    v5 = *(_QWORD *)v3;
    goto LABEL_24;
  }
LABEL_25:
  this = KB::String::append(v4, a2);
  if (*(unsigned __int16 *)(v3 + 944) >= 0xFu)
  {
    this = *(unsigned __int16 **)(v3 + 952);
    if (this)
      this = (unsigned __int16 *)MEMORY[0x1DF0A212C](this, 0x1000C8077774924);
  }
  *(_WORD *)(v3 + 944) = 0;
  return this;
}

char *KB::Candidate::string(KB::Candidate *this)
{
  char *v1;

  v1 = (char *)this + 888;
  if (!*((_WORD *)this + 444))
    KB::Candidate::compute_string(this);
  return v1;
}

KB::Candidate *KB::Candidate::Candidate(KB::Candidate *this, const __CFDictionary *a2, const KB::LanguageModelContext *a3)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = (char *)this + 24;
  *((_QWORD *)this + 2) = 3;
  *(_OWORD *)((char *)this + 744) = xmmword_1DA910F30;
  *((_QWORD *)this + 95) = 0xFF8000003F800000;
  *((_QWORD *)this + 97) = 0;
  KB::LanguageModelContext::LanguageModelContext((KB::Candidate *)((char *)this + 784), a3);
  *((_DWORD *)this + 222) = 0x100000;
  *((_WORD *)this + 446) = 0;
  *((_BYTE *)this + 894) = 0;
  *((_QWORD *)this + 112) = 0;
  *((_BYTE *)this + 904) = 0;
  *((_QWORD *)this + 115) = 0;
  *((_QWORD *)this + 117) = 0;
  *((_QWORD *)this + 116) = 0;
  *((_WORD *)this + 472) = 0;
  *((_DWORD *)this + 240) = 0;
  *((_BYTE *)this + 964) = 0;
  *((_QWORD *)this + 122) = a2;
  if (a2)
  {
    CFRetain(a2);
    *((_QWORD *)this + 122) = a2;
  }
  *((_QWORD *)this + 123) = 0;
  *((_DWORD *)this + 248) = 0;
  return this;
}

void KB::Candidate::~Candidate(KB::Candidate *this)
{
  const void *v2;
  const void *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  KB::Word *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  void **v11;

  v2 = (const void *)*((_QWORD *)this + 123);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 123) = 0;
  v3 = (const void *)*((_QWORD *)this + 122);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 122) = 0;
  if (*((unsigned __int16 *)this + 472) >= 0xFu)
  {
    v4 = *((_QWORD *)this + 119);
    if (v4)
      MEMORY[0x1DF0A212C](v4, 0x1000C8077774924);
  }
  if (*((char *)this + 943) < 0)
    operator delete(*((void **)this + 115));
  v5 = (void *)*((_QWORD *)this + 112);
  if (v5 && *((_BYTE *)this + 894) == 1)
    free(v5);
  v11 = (void **)((char *)this + 864);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v11);
  language_modeling::v1::LinguisticContext::~LinguisticContext((KB::Candidate *)((char *)this + 856));
  language_modeling::v1::LinguisticContext::~LinguisticContext((KB::Candidate *)((char *)this + 848));
  v6 = (void *)*((_QWORD *)this + 100);
  if (v6)
  {
    *((_QWORD *)this + 101) = v6;
    operator delete(v6);
  }
  std::shared_ptr<language_modeling::v1::LanguageModel>::~shared_ptr[abi:nn180100]((uint64_t)this + 784);
  if (*(_QWORD *)this)
  {
    v7 = (KB::Word *)*((_QWORD *)this + 1);
    v8 = 240 * *(_QWORD *)this;
    do
    {
      KB::Word::~Word(v7);
      v7 = (KB::Word *)(v9 + 240);
      v8 -= 240;
    }
    while (v8);
    *(_QWORD *)this = 0;
  }
  v10 = (char *)*((_QWORD *)this + 1);
  if ((char *)this + 24 != v10)
  {
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    free(v10);
  }
}

KB::Candidate *KB::Candidate::Candidate(KB::Candidate *this, const KB::String *a2, unsigned int a3)
{
  char *v6;
  int v7;
  unint64_t *v8;
  unint64_t *v9;
  unsigned int v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v16;
  int v17;
  char *v18;
  unint64_t *__p;
  TITokenID v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  unsigned int v25[2];
  unint64_t *v26;
  unint64_t *v27;
  _BYTE v28[6];
  char v29;
  void *v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = (char *)this + 24;
  *((_QWORD *)this + 2) = 3;
  *(_OWORD *)((char *)this + 744) = xmmword_1DA910F30;
  *((_QWORD *)this + 95) = 0xFF8000003F800000;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  *((_QWORD *)this + 105) = 0;
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 848));
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 856));
  *((_QWORD *)this + 109) = 0;
  *((_QWORD *)this + 108) = 0;
  *((_QWORD *)this + 110) = 0;
  *((_DWORD *)this + 222) = 0x100000;
  *((_WORD *)this + 446) = 0;
  *((_BYTE *)this + 894) = 0;
  *((_QWORD *)this + 112) = 0;
  *((_BYTE *)this + 904) = 0;
  *((_QWORD *)this + 115) = 0;
  *((_OWORD *)this + 58) = 0u;
  *((_WORD *)this + 472) = 0;
  *((_DWORD *)this + 240) = 0;
  *((_BYTE *)this + 964) = 0;
  *((_OWORD *)this + 61) = 0u;
  *((_DWORD *)this + 248) = 0;
  KB::word_ranges(a2, (const KB::String *)1, &v26);
  v6 = (char *)*((_QWORD *)a2 + 1);
  if (!v6)
    v6 = (char *)a2 + 16;
  *(_QWORD *)&v31 = v6;
  v7 = *(unsigned __int16 *)a2;
  DWORD2(v31) = 0;
  HIDWORD(v31) = v7;
  LODWORD(v32) = 0;
  KB::String::iterator::initialize((uint64_t *)&v31);
  v25[0] = v32;
  v24 = v31;
  v25[1] = 0;
  v8 = v27;
  __p = v26;
  if (v26 != v27)
  {
    v9 = v26;
    do
    {
      v10 = *(_DWORD *)v9;
      v11 = *((int *)v9 + 1);
      while (v25[1] < v10)
      {
        KB::String::String((uint64_t)v28, v25[0]);
        KB::Word::Word((KB::Word *)&v31, (const KB::String *)v28, &kTITokenIDUNK, 0);
        KB::Candidate::append((unsigned __int16 *)this, (const KB::Word *)&v31);
        KB::Word::~Word((KB::Word *)&v31);
        if (v30)
          v12 = v29 == 1;
        else
          v12 = 0;
        if (v12)
          free(v30);
        v13 = *((_QWORD *)this + 1) + 240 * *(_QWORD *)this;
        *(_DWORD *)(v13 - 108) |= 0x4000000u;
        ++v25[1];
        KB::String::iterator::operator++((uint64_t *)&v24);
      }
      v22 = v24;
      v23 = *(_QWORD *)v25;
      std::__advance[abi:nn180100]<KB::String::iterator>((KB::String::iterator *)&v22, v11);
      KB::String::String((KB::String *)v28, (const KB::String::iterator *)&v24, (const KB::String::iterator *)&v22);
      v21.lexicon_id = a3;
      v21.word_id = 0;
      KB::Word::Word((KB::Word *)&v31, (const KB::String *)v28, &v21, 0);
      KB::Candidate::append((unsigned __int16 *)this, (const KB::Word *)&v31);
      KB::Word::~Word((KB::Word *)&v31);
      if (v30 && v29 == 1)
        free(v30);
      if ((v11 & 0x80000000) != 0)
      {
        do
        {
          --v25[1];
          KB::String::iterator::operator--((KB::String::iterator *)&v24);
        }
        while (!__CFADD__(v11++, 1));
      }
      else if ((_DWORD)v11)
      {
        v14 = v11 + 1;
        do
        {
          ++v25[1];
          KB::String::iterator::operator++((uint64_t *)&v24);
          --v14;
        }
        while (v14 > 1);
      }
      ++v9;
    }
    while (v9 != v8);
  }
  while (1)
  {
    v17 = *(unsigned __int16 *)a2;
    v18 = (char *)*((_QWORD *)a2 + 1);
    if (!v18)
      v18 = (char *)a2 + 16;
    *(_QWORD *)&v31 = v18;
    DWORD2(v31) = v17;
    HIDWORD(v31) = v17;
    LODWORD(v32) = 0;
    KB::String::iterator::initialize((uint64_t *)&v31);
    if (DWORD2(v24) == DWORD2(v31))
      break;
    KB::String::String((uint64_t)v28, v25[0]);
    KB::Word::Word((KB::Word *)&v31, (const KB::String *)v28, &kTITokenIDUNK, 0);
    KB::Candidate::append((unsigned __int16 *)this, (const KB::Word *)&v31);
    KB::Word::~Word((KB::Word *)&v31);
    if (v30 && v29 == 1)
      free(v30);
    v16 = *((_QWORD *)this + 1) + 240 * *(_QWORD *)this;
    *(_DWORD *)(v16 - 108) |= 0x4000000u;
    ++v25[1];
    KB::String::iterator::operator++((uint64_t *)&v24);
  }
  if (__p)
    operator delete(__p);
  return this;
}

void KB::Candidate::clear(KB::Candidate *this)
{
  uint64_t v2;

  WTF::Vector<KB::Word,3ul>::shrinkCapacity(this);
  KB::String::clear((KB::Candidate *)((char *)this + 888));
  if (*((unsigned __int16 *)this + 472) >= 0xFu)
  {
    v2 = *((_QWORD *)this + 119);
    if (v2)
      MEMORY[0x1DF0A212C](v2, 0x1000C8077774924);
  }
  *((_WORD *)this + 472) = 0;
}

std::string *KB::Candidate::append(KB::Candidate *this, const KB::Candidate *a2)
{
  const KB::Word *v4;
  uint64_t v5;
  int v6;
  const std::string::value_type *v7;
  std::string::size_type v8;

  if (*(_QWORD *)a2)
  {
    v4 = (const KB::Word *)*((_QWORD *)a2 + 1);
    v5 = 240 * *(_QWORD *)a2;
    do
    {
      KB::Candidate::append((unsigned __int16 *)this, v4);
      v4 = (const KB::Word *)((char *)v4 + 240);
      v5 -= 240;
    }
    while (v5);
  }
  v6 = *((char *)a2 + 943);
  if (v6 >= 0)
    v7 = (char *)a2 + 920;
  else
    v7 = (const std::string::value_type *)*((_QWORD *)a2 + 115);
  if (v6 >= 0)
    v8 = *((unsigned __int8 *)a2 + 943);
  else
    v8 = *((_QWORD *)a2 + 116);
  return std::string::append((std::string *)((char *)this + 920), v7, v8);
}

void KB::Candidate::pop_last_word(KB::Candidate *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)this - 1;
  KB::Word::~Word((KB::Word *)(*((_QWORD *)this + 1) + 240 * v2));
  *(_QWORD *)this = v2;
  KB::String::clear((KB::Candidate *)((char *)this + 888));
  if (*((unsigned __int16 *)this + 472) >= 0xFu)
  {
    v3 = *((_QWORD *)this + 119);
    if (v3)
      MEMORY[0x1DF0A212C](v3, 0x1000C8077774924);
  }
  *((_WORD *)this + 472) = 0;
}

uint64_t KB::Candidate::length(KB::Candidate *this)
{
  uint64_t result;

  if (!*((_WORD *)this + 444))
    KB::Candidate::compute_string(this);
  result = *((unsigned __int16 *)this + 446);
  if (!*((_WORD *)this + 446))
  {
    KB::String::compute_length((unsigned __int16 *)this + 444);
    return *((unsigned __int16 *)this + 446);
  }
  return result;
}

void KB::Candidate::capitalized_string(KB::Candidate *this@<X0>, uint64_t a2@<X8>)
{
  KB::Word *v3;
  uint64_t v4;
  BOOL v5;
  _BYTE v6[8];
  void *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a2 = 0x100000;
  *(_WORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 6) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  if (*(_QWORD *)this)
  {
    v3 = (KB::Word *)*((_QWORD *)this + 1);
    v4 = 240 * *(_QWORD *)this;
    do
    {
      KB::Word::capitalized_string(v3, (uint64_t)v6);
      KB::String::append((unsigned __int16 *)a2, (const KB::String *)v6);
      if (v7)
        v5 = v6[6] == 1;
      else
        v5 = 0;
      if (v5)
        free(v7);
      v3 = (KB::Word *)((char *)v3 + 240);
      v4 -= 240;
    }
    while (v4);
  }
}

BOOL KB::Candidate::sort_key(KB::Candidate *this, uint64_t a2)
{
  unsigned __int16 *v2;
  uint64_t v5;
  uint64_t v6;
  KB::Candidate *v8;
  __int128 v9;

  v2 = (unsigned __int16 *)((char *)this + 944);
  if (*((_WORD *)this + 472))
    return (BOOL)v2;
  if (!*((_WORD *)this + 444))
    KB::Candidate::compute_string(this);
  v5 = *(_QWORD *)(a2 + 24);
  if (v5)
  {
    (*(void (**)(__int128 *__return_ptr, uint64_t, char *))(*(_QWORD *)v5 + 48))(&v9, v5, (char *)this + 888);
    if (*v2 >= 0xFu)
    {
      v6 = *((_QWORD *)this + 119);
      if (v6)
        MEMORY[0x1DF0A212C](v6, 0x1000C8077774924);
    }
    *(_OWORD *)v2 = v9;
    return (BOOL)v2;
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return KB::Candidate::has_custom_capitalization(v8);
}

BOOL KB::Candidate::has_custom_capitalization(KB::Candidate *this)
{
  uint64_t v1;
  int *v2;
  int v3;
  _BOOL8 result;
  BOOL v5;

  if (!*(_QWORD *)this)
    return 0;
  v1 = 240 * *(_QWORD *)this - 240;
  v2 = (int *)(*((_QWORD *)this + 1) + 120);
  do
  {
    v3 = *v2;
    v2 += 60;
    result = v3 != 0;
    if (v3)
      v5 = 1;
    else
      v5 = v1 == 0;
    v1 -= 240;
  }
  while (!v5);
  return result;
}

void KB::Candidate::custom_capitalization(std::vector<unsigned int>::size_type *this@<X0>, std::vector<unsigned int> *a2@<X8>)
{
  std::vector<unsigned int>::size_type v4;
  std::vector<unsigned int>::size_type v5;
  char *end;
  unsigned int *value;
  std::vector<unsigned int>::pointer begin;
  unsigned int v9;
  unsigned int *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;

  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  std::vector<unsigned int>::reserve(a2, *this);
  if (*this)
  {
    v4 = this[1];
    v5 = v4 + 240 * *this;
    end = (char *)a2->__end_;
    value = a2->__end_cap_.__value_;
    begin = a2->__begin_;
    do
    {
      v9 = *(_DWORD *)(v4 + 120);
      if (end >= (char *)value)
      {
        v11 = (end - (char *)begin) >> 2;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 62)
          abort();
        if (((char *)value - (char *)begin) >> 1 > v12)
          v12 = ((char *)value - (char *)begin) >> 1;
        if ((unint64_t)((char *)value - (char *)begin) >= 0x7FFFFFFFFFFFFFFCLL)
          v13 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v13 = v12;
        if (v13)
          v13 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v13);
        else
          v14 = 0;
        v15 = (unsigned int *)(v13 + 4 * v11);
        *v15 = v9;
        v10 = v15 + 1;
        while (end != (char *)begin)
        {
          v16 = *((_DWORD *)end - 1);
          end -= 4;
          *--v15 = v16;
        }
        value = (unsigned int *)(v13 + 4 * v14);
        a2->__begin_ = v15;
        a2->__end_ = v10;
        a2->__end_cap_.__value_ = value;
        if (begin)
          operator delete(begin);
        begin = v15;
      }
      else
      {
        *(_DWORD *)end = v9;
        v10 = (unsigned int *)(end + 4);
      }
      a2->__end_ = v10;
      v4 += 240;
      end = (char *)v10;
    }
    while (v4 != v5);
  }
}

_QWORD *KB::Candidate::clear_custom_capitalization(_QWORD *this)
{
  _DWORD *v1;
  uint64_t v2;

  if (*this)
  {
    v1 = (_DWORD *)(this[1] + 104);
    v2 = 240 * *this;
    do
    {
      v1[4] = 0;
      *v1 &= ~1u;
      v1 += 60;
      v2 -= 240;
    }
    while (v2);
  }
  return this;
}

void KB::Candidate::commit_custom_capitalization(KB::Candidate *this)
{
  KB::Word *v2;
  uint64_t v3;
  BOOL v4;
  _BYTE v5[8];
  void *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)this)
  {
    v2 = (KB::Word *)*((_QWORD *)this + 1);
    v3 = 240 * *(_QWORD *)this;
    do
    {
      if (*((_DWORD *)v2 + 30))
      {
        KB::Word::capitalized_string(v2, (uint64_t)v5);
        KB::String::operator=(v2, (KB::String *)v5);
        if (v6)
          v4 = v5[6] == 1;
        else
          v4 = 0;
        if (v4)
          free(v6);
      }
      v2 = (KB::Word *)((char *)v2 + 240);
      v3 -= 240;
    }
    while (v3);
  }
  KB::String::clear((KB::Candidate *)((char *)this + 888));
}

float KB::Candidate::partial_prob(KB::Candidate *this)
{
  uint64_t v1;
  float *v2;
  float result;
  float v4;

  if (!*(_QWORD *)this)
    return 1.0;
  v1 = 240 * *(_QWORD *)this;
  v2 = (float *)(*((_QWORD *)this + 1) + 48);
  result = 1.0;
  do
  {
    v4 = *v2;
    v2 += 60;
    result = result * v4;
    v1 -= 240;
  }
  while (v1);
  return result;
}

float KB::Candidate::linguistic_likelihood(KB::Candidate *this)
{
  uint64_t v1;
  float *v2;
  float result;
  float v4;

  if (!*(_QWORD *)this)
    return 1.0;
  v1 = 240 * *(_QWORD *)this;
  v2 = (float *)(*((_QWORD *)this + 1) + 52);
  result = 1.0;
  do
  {
    v4 = *v2;
    v2 += 60;
    result = result * v4;
    v1 -= 240;
  }
  while (v1);
  return result;
}

float KB::Candidate::static_linguistic_likelihood(KB::Candidate *this)
{
  uint64_t v1;
  float *v2;
  float result;
  float v4;

  if (!*(_QWORD *)this)
    return 1.0;
  v1 = 240 * *(_QWORD *)this;
  v2 = (float *)(*((_QWORD *)this + 1) + 56);
  result = 1.0;
  do
  {
    v4 = *v2;
    v2 += 60;
    result = result * v4;
    v1 -= 240;
  }
  while (v1);
  return result;
}

float KB::Candidate::stem_suffix_correction_factor(KB::Candidate *this)
{
  uint64_t v1;
  float *v2;
  float result;
  float v4;

  if (!*(_QWORD *)this)
    return 1.0;
  v1 = 240 * *(_QWORD *)this;
  v2 = (float *)(*((_QWORD *)this + 1) + 100);
  result = 1.0;
  do
  {
    v4 = *v2;
    v2 += 60;
    result = result * v4;
    v1 -= 240;
  }
  while (v1);
  return result;
}

BOOL KB::Candidate::should_suggest(KB::Candidate *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;

  v2 = *(_QWORD *)this;
  v1 = *((_QWORD *)this + 1);
  if (*(_QWORD *)this)
  {
    v3 = *((_QWORD *)this + 1);
    v4 = 240 * v2;
    while (1)
    {
      v5 = *(_DWORD *)(v3 + 104);
      if ((v5 & 0x800012) != 0)
        break;
      v6 = v5 & 0x2042000;
      if ((*(_DWORD *)(v3 + 104) & 0x2080) == 0x80 || v6 == 0x2000000)
        break;
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v1 + 240 * v2;
        return v3 == v1 + 240 * v2;
      }
    }
  }
  else
  {
    v3 = *((_QWORD *)this + 1);
  }
  return v3 == v1 + 240 * v2;
}

BOOL KB::Candidate::should_predict(KB::Candidate *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *((_QWORD *)this + 1);
  v2 = v1 + 240 * *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v3 = 240 * *(_QWORD *)this;
    while ((*(_DWORD *)(v1 + 104) & 0x800000) == 0 && (*(_DWORD *)(v1 + 104) & 0x2004) != 4)
    {
      v1 += 240;
      v3 -= 240;
      if (!v3)
      {
        v1 = v2;
        return v1 == v2;
      }
    }
  }
  return v1 == v2;
}

uint64_t KB::Candidate::num_words_matching_input(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  unsigned int v6;
  uint64_t v7;
  char v8;

  v6 = 0;
  do
  {
    v7 = v6;
    if (*a2 <= (unint64_t)v6)
      break;
    if (*a1 <= (unint64_t)v6)
      break;
    v8 = KB::Word::matches_input((KB::String *)(a1[1] + 240 * v6), (const KB::String *)(a2[1] + 240 * v6), a3);
    v6 = v7 + 1;
  }
  while ((v8 & 1) != 0);
  return v7;
}

uint64_t KB::Candidate::num_words_preserving_input(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  unsigned int v6;
  uint64_t v7;
  char v8;

  v6 = 0;
  do
  {
    v7 = v6;
    if (*a2 <= (unint64_t)v6)
      break;
    if (*a1 <= (unint64_t)v6)
      break;
    v8 = KB::Word::preserves_input((KB::String *)(a1[1] + 240 * v6), (KB::String *)(a2[1] + 240 * v6), a3);
    v6 = v7 + 1;
  }
  while ((v8 & 1) != 0);
  return v7;
}

uint64_t KB::Candidate::space_count(KB::Candidate *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  const char *v4;

  if (!*(_QWORD *)this)
    return 0;
  LODWORD(v1) = 0;
  v2 = 240 * *(_QWORD *)this;
  v3 = *((_QWORD *)this + 1) + 16;
  do
  {
    if (*(_QWORD *)(v3 - 8))
      v4 = *(const char **)(v3 - 8);
    else
      v4 = (const char *)v3;
    if (!strcmp(v4, " "))
      v1 = (v1 + 1);
    else
      v1 = v1;
    v3 += 240;
    v2 -= 240;
  }
  while (v2);
  return v1;
}

BOOL KB::Candidate::candidate_is_capitalization(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while (!*(_DWORD *)(v3 + 120) || (*(_DWORD *)(v3 + 104) & 0x100000) != 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::candidate_has_sort_key_preserving_insertion(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 106) & 0x20) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::is_spell_correction(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 105) & 0x80) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_static(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 106) & 4) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_primary_static(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 106) & 4) == 0 || *(_BYTE *)(v3 + 192))
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_secondary_static(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 106) & 4) == 0 || !*(_BYTE *)(v3 + 192))
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_dynamic(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_DWORD *)(v3 + 104) & 0x80032000) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_primary_dynamic(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_DWORD *)(v3 + 104) & 0x80032000) == 0 || *(_BYTE *)(v3 + 192) != 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_secondary_dynamic(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_DWORD *)(v3 + 104) & 0x80032000) == 0 || *(_BYTE *)(v3 + 192) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_learned(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 105) & 0x20) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_dynamic_contribution(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 107) & 1) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_secondary_lexicon_contribution(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while (!*(_BYTE *)(v3 + 192))
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_user_dictionary_word(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 106) & 1) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_recency_contribution(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 107) & 4) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_novel_learned_word(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_DWORD *)(v3 + 104) & 0x2040000) != 0x2000000)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_error_correction_type(KB::Candidate *this, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[2];
  BOOL (*v12)(uint64_t, uint64_t);
  void *v13;
  uint64_t v14;

  v3 = a2;
  v5 = *(_QWORD *)this;
  v4 = *((_QWORD *)this + 1);
  v6 = v4 + 240 * a2;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v12 = ___ZNK2KB9Candidate25has_error_correction_typeEjm_block_invoke;
  v13 = &__block_descriptor_tmp_36;
  v14 = a3;
  if (v5 != a2)
  {
    v8 = v4 + 240 * v5;
    v9 = 240 * v5 - 240 * a2;
    while ((((uint64_t (*)(_QWORD *, uint64_t))v12)(v11, v6) & 1) == 0)
    {
      v6 += 240;
      v9 -= 240;
      if (!v9)
      {
        v6 = v8;
        break;
      }
    }
    v3 = *(_QWORD *)this;
    v4 = *((_QWORD *)this + 1);
  }
  return v6 != v4 + 240 * v3;
}

BOOL ___ZNK2KB9Candidate25has_error_correction_typeEjm_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(_QWORD *)(a2 + 152) & *(_QWORD *)(a1 + 32)) != 0;
}

BOOL KB::Candidate::has_from_supplemental_lexicon(KB::Candidate *this, unsigned int a2)
{
  _BOOL8 result;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  BOOL v6;

  if (*(_QWORD *)this == a2)
    return 0;
  v3 = -240 * a2 + 240 * *(_QWORD *)this - 240;
  v4 = (uint64_t *)(240 * a2 + *((_QWORD *)this + 1) + 224);
  do
  {
    v5 = *v4;
    v4 += 30;
    result = v5 != 0;
    if (v5)
      v6 = 1;
    else
      v6 = v3 == 0;
    v3 -= 240;
  }
  while (!v6);
  return result;
}

uint64_t KB::Candidate::is_phrase_from_supplemental_lexicon(KB::Candidate *this)
{
  unint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  int8x8_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  uint64_t result;
  unint64_t v13;

  v1 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    return 0;
  v2 = *((_QWORD *)this + 1);
  if (!*(_QWORD *)(v2 + 224))
    return 0;
  if (v1 < 2)
    return 1;
  v3 = 1;
  while (1)
  {
    if ((*(_BYTE *)(v2 + 240 * v3 + 135) & 4) == 0)
    {
      v4 = *(_QWORD *)(v2 + 240 * v3 + 224);
      if (!v4)
        return 0;
      v5 = v2 + 240 * (v3 - 1);
      if (v4 != *(_QWORD *)(v5 + 224))
        return 0;
      v6 = (_QWORD *)(v5 + 200);
      v7 = (_QWORD *)(v2 + 240 * v3 + 216);
LABEL_9:
      v7 = (_QWORD *)*v7;
      if (v7)
        break;
    }
    v3 = (v3 + 1);
    result = 1;
    if (v1 <= v3)
      return result;
  }
  v8 = (int8x8_t)v6[1];
  if (!*(_QWORD *)&v8)
    return 0;
  v9 = v7[2];
  v10 = (uint8x8_t)vcnt_s8(v8);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    v11 = v7[2];
    if (v9 >= *(_QWORD *)&v8)
      v11 = v9 % *(_QWORD *)&v8;
  }
  else
  {
    v11 = (*(_QWORD *)&v8 - 1) & v9;
  }
  result = *(_QWORD *)(*v6 + 8 * v11);
  if (result)
  {
    for (result = *(_QWORD *)result; result; result = *(_QWORD *)result)
    {
      v13 = *(_QWORD *)(result + 8);
      if (v9 == v13)
      {
        if (*(_QWORD *)(result + 16) == v9)
          goto LABEL_9;
      }
      else
      {
        if (v10.u32[0] > 1uLL)
        {
          if (v13 >= *(_QWORD *)&v8)
            v13 %= *(_QWORD *)&v8;
        }
        else
        {
          v13 &= *(_QWORD *)&v8 - 1;
        }
        if (v13 != v11)
          return 0;
      }
    }
  }
  return result;
}

BOOL KB::Candidate::has_from_named_entities(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 105) & 1) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_from_user_dictionary(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 106) & 1) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_from_address_book(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 106) & 2) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_from_app_names(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_DWORD *)(v3 + 104) & 0x80000000) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_from_transient_lexicon(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_DWORD *)(v3 + 104) & 0x80020100) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_oov(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 106) & 0x80) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_persisted_custom_word(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 107) & 2) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_offensive_word(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 107) & 0x10) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_vulgar_word(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 107) & 8) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::every_vulgar_word_is_allowlisted(_QWORD *a1, uint64_t a2, _QWORD *a3, unsigned int a4)
{
  uint64_t v6;
  int v12;
  _QWORD *v13;
  _QWORD *v14;
  __int128 v15;
  __int128 v16;
  char *v17;
  int *v18;
  char *v19;
  char *v20;
  char *v21;
  _BOOL4 can_autocorrect;
  uint64_t v23;
  _BOOL8 result;
  std::string v26;
  std::string v27;
  std::string *v28;
  __int128 v29;
  uint64_t v30;
  uint8_t buf[4];
  _BYTE v32[12];
  char v33;
  unsigned __int16 v34[8];
  uint64_t v35;
  int v36;
  int v37;
  __int16 v38;
  char v39;
  uint64_t v40;
  char v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  int v46;
  __int16 v47;
  char v48;
  uint64_t v49;
  char v50;
  char v51;
  _QWORD v52[4];
  int v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (*a1 == a4)
      return 1;
    v6 = a1[1] + 240 * a4 + 136;
    __asm { FMOV            V9.2S, #1.0 }
    while (1)
    {
      *(_DWORD *)buf = 0x100000;
      *(_WORD *)v32 = 0;
      v32[2] = 0;
      *(_QWORD *)&v32[4] = 0;
      v33 = 0;
      v34[0] = 0;
      v35 = 0x3F80000000000000;
      v36 = 1065353216;
      v37 = 0x100000;
      v38 = 0;
      v39 = 0;
      v40 = 0;
      v41 = 0;
      *(_QWORD *)&v42 = _D9;
      DWORD2(v42) = 0;
      *((_QWORD *)&v45 + 1) = 0;
      v43 = 0u;
      v44 = 0u;
      LODWORD(v45) = 0;
      v46 = 0x100000;
      v47 = 0;
      v48 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      memset(v52, 0, sizeof(v52));
      v53 = 1065353216;
      v12 = *(_DWORD *)(v6 - 32);
      KB::Word::lowercased_string((KB::Word *)(v6 - 136), (KB::String *)&v29);
      v13 = std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::find<KB::String>(a3, &v29);
      if (*((_QWORD *)&v29 + 1) && BYTE6(v29) == 1)
        free(*((void **)&v29 + 1));
      if (v13)
      {
        KB::Word::lowercased_string((KB::Word *)(v6 - 136), (KB::String *)&v29);
        v27.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
        v14 = std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>((uint64_t)a3, &v29, (KB::String **)&v27);
        KB::String::operator=((KB::String *)buf, (KB::String *)(v14 + 6));
        KB::ByteString::operator=(v34, (const void **)v14 + 10);
        v35 = v14[12];
        v36 = *((_DWORD *)v14 + 26);
        KB::String::operator=((KB::String *)&v37, (KB::String *)(v14 + 14));
        v15 = *((_OWORD *)v14 + 10);
        v42 = *((_OWORD *)v14 + 9);
        v43 = v15;
        v16 = *((_OWORD *)v14 + 12);
        v44 = *((_OWORD *)v14 + 11);
        v45 = v16;
        KB::String::operator=((KB::String *)&v46, (KB::String *)(v14 + 26));
        v51 = *((_BYTE *)v14 + 240);
        if (buf != (uint8_t *)(v14 + 6))
        {
          v53 = *((_DWORD *)v14 + 70);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(v52, (_QWORD *)v14[33]);
        }
        if (*((_QWORD *)&v29 + 1) && BYTE6(v29) == 1)
          free(*((void **)&v29 + 1));
        if ((v12 & 0x8000000) != 0 && (*(_BYTE *)(v6 - 29) & 0x40) != 0 || (BYTE11(v42) & 0x40) != 0)
          goto LABEL_37;
      }
      else
      {
        if ((v12 & 0x8000000) == 0)
          goto LABEL_31;
        if ((*(_BYTE *)(v6 - 29) & 0x40) != 0)
          goto LABEL_37;
      }
      v17 = *(char **)(a2 + 8);
      if (!v17)
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          LODWORD(v29) = 136315138;
          *(_QWORD *)((char *)&v29 + 4) = "every_vulgar_word_is_allowlisted";
          _os_log_error_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s  Cannot read vulgar word usage database because current app ID is NULL", (uint8_t *)&v29, 0xCu);
        }
LABEL_37:
        KB::Word::~Word((KB::Word *)buf);
        return 0;
      }
      memset(&v27, 0, sizeof(v27));
      std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(&v27, *(__int128 **)(a2 + 16), *(__int128 **)(a2 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3));
      v18 = (int *)&v44 + 2;
      if ((v12 & 0x8000000) != 0)
        v18 = (int *)v6;
      v19 = (char *)TILocaleIdentifierForLexiconID(*v18);
      KB::Word::capitalized_string((KB::Word *)(v6 - 136), (uint64_t)&v29);
      v20 = (char *)*((_QWORD *)&v29 + 1);
      if (!*((_QWORD *)&v29 + 1))
        v20 = (char *)&v30;
      if ((_WORD)v29)
        v21 = v20;
      else
        v21 = "";
      memset(&v26, 0, sizeof(v26));
      std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(&v26, (__int128 *)v27.__r_.__value_.__l.__data_, (__int128 *)v27.__r_.__value_.__l.__size_, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27.__r_.__value_.__l.__size_ - v27.__r_.__value_.__r.__words[0]) >> 3));
      can_autocorrect = TI::VulgarWordUsageDatabaseWrapper::can_autocorrect(a2, v21, v17, &v26, v19);
      v28 = &v26;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v28);
      if (*((_QWORD *)&v29 + 1))
      {
        if (BYTE6(v29) == 1)
          free(*((void **)&v29 + 1));
      }
      *(_QWORD *)&v29 = &v27;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v29);
      if (!can_autocorrect)
        goto LABEL_37;
LABEL_31:
      KB::Word::~Word((KB::Word *)buf);
      v23 = v6 + 104;
      v6 += 240;
      if (v23 == a1[1] + 240 * *a1)
        return 1;
    }
  }
  result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)v32 = "every_vulgar_word_is_allowlisted";
    _os_log_error_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s  Cannot read vulgar word usage database because it has not been provided", buf, 0xCu);
    return 0;
  }
  return result;
}

BOOL KB::Candidate::every_vulgar_word_is_allowlisted_somewhere(_QWORD *a1, TI::VulgarWordUsageDatabaseWrapper *a2, _QWORD *a3, unsigned int a4)
{
  uint64_t v6;
  int v12;
  _QWORD *v13;
  _QWORD *v14;
  __int128 v15;
  __int128 v16;
  int *v17;
  char v18;
  char *v19;
  char *v20;
  char *v21;
  _BOOL4 can_autocorrect_somewhere;
  uint64_t v23;
  _BOOL8 result;
  KB::String *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint8_t buf[4];
  _BYTE v31[12];
  char v32;
  unsigned __int16 v33[8];
  uint64_t v34;
  int v35;
  int v36;
  __int16 v37;
  char v38;
  uint64_t v39;
  char v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  int v45;
  __int16 v46;
  char v47;
  uint64_t v48;
  char v49;
  char v50;
  _QWORD v51[4];
  int v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (*a1 == a4)
      return 1;
    v6 = a1[1] + 240 * a4 + 136;
    __asm { FMOV            V9.2S, #1.0 }
    while (1)
    {
      *(_DWORD *)buf = 0x100000;
      *(_WORD *)v31 = 0;
      v31[2] = 0;
      *(_QWORD *)&v31[4] = 0;
      v32 = 0;
      v33[0] = 0;
      v34 = 0x3F80000000000000;
      v35 = 1065353216;
      v36 = 0x100000;
      v37 = 0;
      v38 = 0;
      v39 = 0;
      v40 = 0;
      *(_QWORD *)&v41 = _D9;
      DWORD2(v41) = 0;
      *((_QWORD *)&v44 + 1) = 0;
      v42 = 0u;
      v43 = 0u;
      LODWORD(v44) = 0;
      v45 = 0x100000;
      v46 = 0;
      v47 = 0;
      v48 = 0;
      v49 = 0;
      v50 = 0;
      memset(v51, 0, sizeof(v51));
      v52 = 1065353216;
      v12 = *(_DWORD *)(v6 - 32);
      KB::Word::lowercased_string((KB::Word *)(v6 - 136), (KB::String *)&v27);
      v13 = std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::find<KB::String>(a3, &v27);
      if (v28 && BYTE6(v27) == 1)
        free(v28);
      if (v13)
      {
        KB::Word::lowercased_string((KB::Word *)(v6 - 136), (KB::String *)&v27);
        v26 = (KB::String *)&v27;
        v14 = std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>((uint64_t)a3, &v27, &v26);
        KB::String::operator=((KB::String *)buf, (KB::String *)(v14 + 6));
        KB::ByteString::operator=(v33, (const void **)v14 + 10);
        v34 = v14[12];
        v35 = *((_DWORD *)v14 + 26);
        KB::String::operator=((KB::String *)&v36, (KB::String *)(v14 + 14));
        v15 = *((_OWORD *)v14 + 10);
        v41 = *((_OWORD *)v14 + 9);
        v42 = v15;
        v16 = *((_OWORD *)v14 + 12);
        v43 = *((_OWORD *)v14 + 11);
        v44 = v16;
        KB::String::operator=((KB::String *)&v45, (KB::String *)(v14 + 26));
        v50 = *((_BYTE *)v14 + 240);
        if (buf != (uint8_t *)(v14 + 6))
        {
          v52 = *((_DWORD *)v14 + 70);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(v51, (_QWORD *)v14[33]);
        }
        if (v28 && BYTE6(v27) == 1)
          free(v28);
        if ((v12 & 0x8000000) == 0)
        {
          v17 = (int *)&v43 + 2;
          if ((BYTE11(v41) & 0x40) != 0)
            goto LABEL_34;
          goto LABEL_21;
        }
        if ((*(_BYTE *)(v6 - 29) & 0x40) != 0)
          goto LABEL_34;
        v18 = BYTE11(v41);
      }
      else
      {
        if ((v12 & 0x8000000) == 0)
          goto LABEL_30;
        v18 = *(_BYTE *)(v6 - 29);
      }
      v17 = (int *)v6;
      if ((v18 & 0x40) != 0)
        goto LABEL_34;
LABEL_21:
      v19 = (char *)TILocaleIdentifierForLexiconID(*v17);
      KB::Word::capitalized_string((KB::Word *)(v6 - 136), (uint64_t)&v27);
      v20 = (char *)v28;
      if (!v28)
        v20 = (char *)&v29;
      if ((_WORD)v27)
        v21 = v20;
      else
        v21 = "";
      can_autocorrect_somewhere = TI::VulgarWordUsageDatabaseWrapper::can_autocorrect_somewhere(a2, v21, v19);
      if (v28)
      {
        if (BYTE6(v27) == 1)
          free(v28);
      }
      if (!can_autocorrect_somewhere)
      {
LABEL_34:
        KB::Word::~Word((KB::Word *)buf);
        return 0;
      }
LABEL_30:
      KB::Word::~Word((KB::Word *)buf);
      v23 = v6 + 104;
      v6 += 240;
      if (v23 == a1[1] + 240 * *a1)
        return 1;
    }
  }
  result = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)v31 = "every_vulgar_word_is_allowlisted_somewhere";
    _os_log_error_impl(&dword_1DA6F2000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s  Cannot read vulgar word usage database because it has not been provided", buf, 0xCu);
    return 0;
  }
  return result;
}

BOOL KB::Candidate::has_sensitive_word(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_BYTE *)(v3 + 107) & 0x20) == 0)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

BOOL KB::Candidate::has_no_suggest_entries(KB::Candidate *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 + 240 * a2;
  if (*(_QWORD *)this != a2)
  {
    v4 = 240 * *(_QWORD *)this - 240 * a2;
    while ((*(_DWORD *)(v3 + 104) & 0x40000002) != 2)
    {
      v3 += 240;
      v4 -= 240;
      if (!v4)
      {
        v3 = v2 + 240 * *(_QWORD *)this;
        return v3 != v2 + 240 * *(_QWORD *)this;
      }
    }
  }
  return v3 != v2 + 240 * *(_QWORD *)this;
}

uint64_t KB::Candidate::has_part_of_hyphenated_word(KB::Candidate *this, unsigned int a2)
{
  uint64_t result;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  uint64_t v6;

  if (*(_QWORD *)this == a2)
    return 0;
  v3 = -240 * a2 + 240 * *(_QWORD *)this - 240;
  v4 = (unsigned int *)(240 * a2 + *((_QWORD *)this + 1) + 104);
  do
  {
    v5 = *v4;
    v4 += 60;
    result = (v5 >> 4) & 1;
    if ((v5 & 0x10) != 0)
      break;
    v6 = v3;
    v3 -= 240;
  }
  while (v6);
  return result;
}

CFStringRef KB::Candidate::named_entity_timestamp(KB::Candidate *this)
{
  uint64_t v1;
  uint64_t i;
  unint64_t v3;
  CFStringRef v4;
  uint64_t v5;
  const void *v6;
  CFStringRef v7;
  CFStringRef v9;

  if (*(_QWORD *)this)
  {
    v1 = *((_QWORD *)this + 1);
    for (i = 240 * *(_QWORD *)this; i; i -= 240)
    {
      if ((*(_BYTE *)(v1 + 105) & 1) != 0)
      {
        v3 = TILocaleIdentifierForLexiconID(*(_DWORD *)(v1 + 136));
        if (TITransientLexiconManagerGetNamedEntitiesForLocale(v3))
        {
          KB::cf_string_impl<KB::String>(&v9, (unsigned __int16 *)v1);
          v4 = v9;
          LXLexiconGetFirstTokenIDForString();
          if (v4)
            CFRelease(v4);
          v5 = LXLexiconCopyEntryForTokenID();
          if (v5)
          {
            v6 = (const void *)v5;
            v9 = 0;
            if ((LXEntryGetTimestamp() & 1) != 0)
            {
              v7 = v9;
              CFRelease(v6);
              return v7;
            }
            CFRelease(v6);
          }
        }
      }
      v1 += 240;
    }
  }
  return 0;
}

uint64_t KB::Candidate::length_to_word(KB::Candidate *this, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  if (!a2)
    return 0;
  v3 = 0;
  LODWORD(v4) = 0;
  v5 = 240 * a2;
  do
  {
    v6 = *((_QWORD *)this + 1) + v3;
    v7 = *(unsigned __int16 *)(v6 + 4);
    if (!*(_WORD *)(v6 + 4))
    {
      KB::String::compute_length((unsigned __int16 *)(*((_QWORD *)this + 1) + v3));
      v7 = *(unsigned __int16 *)(v6 + 4);
    }
    v4 = (v4 + v7);
    v3 += 240;
  }
  while (v5 != v3);
  return v4;
}

unint64_t KB::Candidate::index_of_word_containing_position(KB::Candidate *this, unsigned int a2)
{
  unint64_t result;
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  int v8;

  if (!*(_QWORD *)this)
    return 0;
  result = 0;
  v5 = 0;
  v6 = 0;
  while (1)
  {
    v7 = *((_QWORD *)this + 1) + 240 * result;
    v8 = *(unsigned __int16 *)(v7 + 4);
    if (!*(_WORD *)(v7 + 4))
    {
      KB::String::compute_length((unsigned __int16 *)(*((_QWORD *)this + 1) + 240 * result));
      v8 = *(unsigned __int16 *)(v7 + 4);
    }
    v5 += v8;
    if (v5 > a2)
      break;
    result = (v6 + 1);
    v6 = result;
    if (*(_QWORD *)this <= result)
      return result;
  }
  return v6;
}

BOOL KB::Candidate::does_word_begin_at_position(KB::Candidate *this, int a2)
{
  int v3;
  unsigned __int16 *v4;
  uint64_t v5;
  int v6;
  _BOOL8 result;
  BOOL v8;

  if (!a2)
    return 1;
  if (!*(_QWORD *)this)
    return 0;
  v3 = 0;
  v4 = (unsigned __int16 *)*((_QWORD *)this + 1);
  v5 = 240 * *(_QWORD *)this - 240;
  do
  {
    v6 = v4[2];
    if (!v4[2])
    {
      KB::String::compute_length(v4);
      v6 = v4[2];
    }
    v3 += v6;
    result = v3 == a2;
    v8 = v3 == a2 || v5 == 0;
    v5 -= 240;
    v4 += 120;
  }
  while (!v8);
  return result;
}

void KB::Candidate::append_debug_data(KB::Candidate *this, __CFString *a2, int a3, const KB::String *a4)
{
  uint64_t v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *size;
  const char *v13;
  float v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  const char *v23;
  const char *v24;
  float v25;
  double v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  const char *v30;
  void *v31;
  const char *v32;
  const char *v33;
  const char *v34;
  const char *v35;
  KB::Word *v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  const char *v40;
  const char *v41;
  char *v42;
  _WORD v43[3];
  char v44;
  void *v45;
  _BYTE v46[16];
  std::string v47;
  int v48;
  __int16 v49;
  char v50;
  void *v51;
  char v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v48 = 0x100000;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  if (*(_QWORD *)this)
    v8 = *(_QWORD *)(*((_QWORD *)this + 1) + 240 * *(_QWORD *)this - 88);
  else
    v8 = 0;
  v9 = (const char *)*((_QWORD *)a4 + 1);
  v10 = (char *)a4 + 16;
  if (!v9)
    v9 = (char *)a4 + 16;
  if (*(_WORD *)a4)
    v11 = v9;
  else
    v11 = "";
  if (a3)
  {
    v42 = (char *)a4 + 16;
    KB::Candidate::capitalized_string(this, (uint64_t)&v47);
    size = (const char *)v47.__r_.__value_.__l.__size_;
    if (!v47.__r_.__value_.__l.__size_)
      size = &v47.__r_.__value_.__s.__data_[16];
    if (LOWORD(v47.__r_.__value_.__l.__data_))
      v13 = size;
    else
      v13 = "";
    v14 = expf(*((float *)this + 186));
    v15 = logf(v14);
    v16 = *((float *)this + 190);
    v17 = *((float *)this + 188);
    v18 = *((float *)this + 189);
    v19 = *((float *)this + 187);
    if (*((_BYTE *)this + 960))
      v20 = "completion";
    else
      v20 = "";
    v21 = *((unsigned int *)this + 248);
    if (v21 > 6)
      v22 = "Unknown";
    else
      v22 = (&off_1EA107718)[v21];
    KB::String::String((KB::String *)v43, v22);
    v29 = (const char *)v45;
    if (!v45)
      v29 = v46;
    if (v43[0])
      v30 = v29;
    else
      v30 = "";
    KB::String::append_format((KB::String *)&v48, "%s[%s] ln(omega) %.3f = [%.3f*(W %.3f + T %.3f) + G %.3f] %s %lu %s\n", v11, v13, v15, v16, v17, v18, v19, v20, v8, v30);
    if (v45 && v44 == 1)
      free(v45);
    v31 = (void *)v47.__r_.__value_.__l.__size_;
    v10 = v42;
    if (!v47.__r_.__value_.__l.__size_)
      goto LABEL_50;
LABEL_48:
    if (v47.__r_.__value_.__s.__data_[6] == 1)
      free(v31);
    goto LABEL_50;
  }
  KB::Candidate::capitalized_string(this, (uint64_t)&v47);
  v23 = (const char *)v47.__r_.__value_.__l.__size_;
  if (!v47.__r_.__value_.__l.__size_)
    v23 = &v47.__r_.__value_.__s.__data_[16];
  if (LOWORD(v47.__r_.__value_.__l.__data_))
    v24 = v23;
  else
    v24 = "";
  v25 = expf(*((float *)this + 186));
  v26 = logf(v25);
  v27 = *((unsigned int *)this + 248);
  if (v27 > 6)
    v28 = "Unknown";
  else
    v28 = (&off_1EA107718)[v27];
  KB::String::String((KB::String *)v43, v28);
  v32 = (const char *)v45;
  if (!v45)
    v32 = v46;
  if (v43[0])
    v33 = v32;
  else
    v33 = "";
  KB::String::append_format((KB::String *)&v48, "%s[%s] ln(omega) %.3f %lu %s\n", v11, v24, v26, v8, v33);
  if (v45 && v44 == 1)
    free(v45);
  v31 = (void *)v47.__r_.__value_.__l.__size_;
  if (v47.__r_.__value_.__l.__size_)
    goto LABEL_48;
LABEL_50:
  v34 = (const char *)v51;
  if (!v51)
    v34 = &v52;
  if ((_WORD)v48)
    v35 = v34;
  else
    v35 = "";
  CFStringAppendCString(a2, v35, 0x8000100u);
  if (a3)
  {
    if (*(_QWORD *)this)
    {
      v36 = (KB::Word *)*((_QWORD *)this + 1);
      v37 = 240 * *(_QWORD *)this;
      do
      {
        KB::String::String((KB::String *)&v47, a4);
        KB::String::append((unsigned __int16 *)&v47, "\t", 0xFFFFuLL);
        KB::Word::append_debug_data(v36, a2, (const KB::String *)&v47);
        if (v47.__r_.__value_.__l.__size_)
          v38 = v47.__r_.__value_.__s.__data_[6] == 1;
        else
          v38 = 0;
        if (v38)
          free((void *)v47.__r_.__value_.__l.__size_);
        v36 = (KB::Word *)((char *)v36 + 240);
        v37 -= 240;
      }
      while (v37);
    }
    v39 = *((unsigned int *)this + 195);
    if ((_DWORD)v39)
    {
      v40 = (const char *)*((_QWORD *)a4 + 1);
      if (!v40)
        v40 = v10;
      if (*(_WORD *)a4)
        v41 = v40;
      else
        v41 = "";
      CFStringAppendFormat(a2, 0, CFSTR("%s\tunshift mask: %#x\n"), v41, v39);
    }
  }
  if (*((char *)this + 943) < 0)
    std::string::__init_copy_ctor_external(&v47, *((const std::string::value_type **)this + 115), *((_QWORD *)this + 116));
  else
    v47 = *(std::string *)((char *)this + 920);
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v47.__r_.__value_.__l.__data_);
  if (v51)
  {
    if (v50 == 1)
      free(v51);
  }
}

void KB::Candidate::token_ids_as_string(KB::Candidate *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  const char *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  void **v11;
  _DWORD *v12;
  uint64_t v13;
  KB::String *v14;
  KB::String *v15;
  char *v16;
  char *v17;
  int64x2_t v18;
  void **v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  uint64_t v22;
  int64x2_t v23;
  void **v24;
  _BYTE v25[8];
  void *v26;
  void **v27;
  void *v28[2];
  void **v29;
  void ***v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v23 = 0uLL;
  v24 = 0;
  if (*(_QWORD *)this)
  {
    v22 = a2;
    v2 = *((_QWORD *)this + 1);
    v3 = v2 + 240 * *(_QWORD *)this;
    do
    {
      v4 = TILocaleIdentifierForLexiconID(*(_DWORD *)(v2 + 136));
      if (v4)
        v5 = (const char *)v4;
      else
        v5 = "";
      KB::String::format((KB::String *)"%s:%d", (uint64_t)v25, v5, *(unsigned int *)(v2 + 140));
      v6 = v23.i64[1];
      if (v23.i64[1] >= (unint64_t)v24)
      {
        v8 = (v23.i64[1] - v23.i64[0]) >> 5;
        if ((unint64_t)(v8 + 1) >> 59)
          abort();
        v9 = ((uint64_t)v24 - v23.i64[0]) >> 4;
        if (v9 <= v8 + 1)
          v9 = v8 + 1;
        if ((unint64_t)v24 - v23.i64[0] >= 0x7FFFFFFFFFFFFFE0)
          v10 = 0x7FFFFFFFFFFFFFFLL;
        else
          v10 = v9;
        v30 = &v24;
        v11 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v10);
        v12 = &v11[4 * v8];
        v27 = v11;
        v28[0] = v12;
        v29 = &v11[4 * v13];
        *v12 = 0x100000;
        *((_WORD *)v12 + 2) = 0;
        *((_BYTE *)v12 + 6) = 0;
        *((_QWORD *)v12 + 1) = 0;
        KB::String::operator=((uint64_t)v12, (KB::String *)v25);
        v7 = v12 + 8;
        v28[1] = v12 + 8;
        v14 = (KB::String *)v23.i64[1];
        v15 = (KB::String *)v23.i64[0];
        v16 = (char *)v28[0];
        if (v23.i64[1] == v23.i64[0])
        {
          v18 = vdupq_n_s64(v23.u64[1]);
        }
        else
        {
          v17 = (char *)v28[0] - 32;
          do
          {
            *(_DWORD *)v17 = 0x100000;
            v14 = (KB::String *)((char *)v14 - 32);
            *((_WORD *)v17 + 2) = 0;
            v17[6] = 0;
            *((_QWORD *)v17 + 1) = 0;
            v16 = (char *)KB::String::operator=((uint64_t)v17, v14);
            v17 = v16 - 32;
          }
          while (v14 != v15);
          v18 = v23;
          v7 = v28[1];
        }
        v23.i64[0] = (uint64_t)v16;
        v23.i64[1] = (uint64_t)v7;
        *(int64x2_t *)v28 = v18;
        v19 = v24;
        v24 = v29;
        v29 = v19;
        v27 = (void **)v18.i64[0];
        std::__split_buffer<KB::String>::~__split_buffer((uint64_t)&v27);
      }
      else
      {
        *(_DWORD *)v23.i64[1] = 0x100000;
        *(_WORD *)(v6 + 4) = 0;
        *(_BYTE *)(v6 + 6) = 0;
        *(_QWORD *)(v6 + 8) = 0;
        v7 = (void *)(KB::String::operator=(v6, (KB::String *)v25) + 32);
      }
      v23.i64[1] = (uint64_t)v7;
      if (v26 && v25[6] == 1)
        free(v26);
      v2 += 240;
    }
    while (v2 != v3);
    v21 = (unsigned __int16 *)v23.i64[1];
    v20 = (unsigned __int16 *)v23.i64[0];
    a2 = v22;
  }
  else
  {
    v21 = 0;
    v20 = 0;
  }
  WORD2(v27) = 0;
  BYTE6(v27) = 0;
  v28[0] = ", ";
  LODWORD(v27) = 1048578;
  BYTE1(v28[1]) = 0;
  KB::string_join(v20, v21, (const KB::String *)&v27, a2);
  if (v28[0] && BYTE6(v27) == 1)
    free(v28[0]);
  v27 = (void **)&v23;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v27);
}

void KB::Candidate::add_sources_info(KB::Candidate *this, const __CFString *a2, const __CFDictionary *a3)
{
  const void *v6;
  __CFDictionary *Mutable;
  const void *v8;

  v6 = (const void *)*((_QWORD *)this + 123);
  if (v6)
  {
    CFRetain(*((CFTypeRef *)this + 123));
    CFRelease(v6);
    Mutable = (__CFDictionary *)*((_QWORD *)this + 123);
  }
  else
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v8 = (const void *)*((_QWORD *)this + 123);
    if (v8)
      CFRelease(v8);
    *((_QWORD *)this + 123) = Mutable;
  }
  CFDictionarySetValue(Mutable, a2, a3);
}

uint64_t *KB::CandidateCollection::scale_scores(uint64_t *this, float a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *this;
  v3 = this[1];
  while (v2 != v3)
  {
    *(float32x4_t *)(v2 + 744) = vmulq_n_f32(*(float32x4_t *)(v2 + 744), a2);
    v2 += 1000;
  }
  return this;
}

BOOL KB::CandidateCollection::contains_secondary_language_candidates(KB::CandidateCollection *this, int *a2, unsigned int a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *(_QWORD *)this;
  v4 = 0x1CAC083126E978D5 * ((uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3);
  if (v4 <= (int)a3)
    v4 = v4;
  else
    v4 = a3;
  if ((int)v4 < 1)
  {
    return 0;
  }
  else
  {
    v5 = 0;
    v6 = 1;
    while (1)
    {
      v7 = *(_QWORD *)(v3 + 1000 * v5);
      if (v7)
      {
        v8 = 240 * v7;
        v9 = *(_QWORD *)(v3 + 1000 * v5 + 8);
        while (!*(_BYTE *)(v9 + 192))
        {
          v9 += 240;
          v8 -= 240;
          if (!v8)
            goto LABEL_13;
        }
      }
      else
      {
        v9 = *(_QWORD *)(v3 + 1000 * v5 + 8);
      }
      if (v9 != *(_QWORD *)(v3 + 1000 * v5 + 8) + 240 * v7)
        break;
LABEL_13:
      v6 = ++v5 < v4;
      if (v5 == v4)
        return v6;
    }
    *a2 = v5;
  }
  return v6;
}

void KB::CandidateCollection::sort(KB::CandidateCollection *this)
{
  KB::Candidate *v1;
  unint64_t v2;
  uint64_t v3;

  v1 = (KB::Candidate *)*((_QWORD *)this + 1);
  v2 = 126 - 2 * __clz(0x1CAC083126E978D5 * (((uint64_t)v1 - *(_QWORD *)this) >> 3));
  if (v1 == *(KB::Candidate **)this)
    v3 = 0;
  else
    v3 = v2;
  std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,false>(*(uint64_t **)this, v1, v3, 1);
}

void std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,false>(uint64_t *a1, KB::Candidate *a2, uint64_t a3, char a4)
{
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  KB::Candidate *v11;
  uint64_t v12;
  float v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  char v22;
  char v23;
  double v24;
  char v25;
  float v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  KB::Candidate *v30;
  KB::Candidate *v31;
  float v32;
  float v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  char v40;
  char v41;
  double v42;
  char v43;
  uint64_t v44;
  KB::Candidate *v45;
  float v46;
  float v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  double v53;
  char v54;
  char v55;
  double v56;
  char v57;
  KB::Candidate *v58;
  float v59;
  float v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  double v66;
  char v67;
  char v68;
  double v69;
  char v70;
  BOOL v71;
  uint64_t *v72;
  unint64_t v73;
  float v74;
  float v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  double v81;
  char v82;
  char v83;
  double v84;
  char v85;
  uint64_t *v86;
  float v87;
  float v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  double v94;
  char v95;
  char v96;
  double v97;
  char v98;
  BOOL v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  double v103;
  char v104;
  char v105;
  double v106;
  char v107;
  uint64_t *v108;
  unint64_t v109;
  float v110;
  float v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  double v117;
  char v118;
  char v119;
  double v120;
  char v121;
  unint64_t v122;
  float v123;
  float v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  double v130;
  char v131;
  char v132;
  double v133;
  char v134;
  KB::Candidate *v135;
  KB::Candidate *v136;
  float v137;
  float v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  double v144;
  char v145;
  char v146;
  double v147;
  char v148;
  unint64_t v149;
  float v150;
  float v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  double v157;
  char v158;
  char v159;
  double v160;
  char v161;
  KB::Candidate *v162;
  float v163;
  float v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  double v170;
  char v171;
  char v172;
  double v173;
  char v174;
  float v175;
  float v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  KB::Candidate *v180;
  uint64_t v181;
  uint64_t v182;
  float v183;
  float v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  double v191;
  char v192;
  char v193;
  double v194;
  char v195;
  uint64_t *v196;
  uint64_t *v197;
  float v198;
  float v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  double v205;
  char v206;
  char v207;
  double v208;
  char v209;
  KB::Candidate *v210;
  uint64_t *v211;
  float v212;
  float v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  double v220;
  char v221;
  char v222;
  double v223;
  char v224;
  uint64_t *v225;
  uint64_t *v226;
  float v227;
  float v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  double v234;
  char v235;
  char v236;
  double v237;
  char v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  double v242;
  char v243;
  char v244;
  double v245;
  char v246;
  uint64_t *v247;
  float *v248;
  float *v249;
  KB::Candidate *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  float v255;
  uint64_t v256;

  v256 = *MEMORY[0x1E0C80C00];
LABEL_2:
  v251 = (KB::Candidate *)((char *)a2 - 1000);
  v248 = (float *)((char *)a2 - 3000);
  v249 = (float *)((char *)a2 - 2000);
  v247 = (uint64_t *)((char *)a2 - 992);
  v7 = (unint64_t)a1;
  while (2)
  {
    a1 = (uint64_t *)v7;
    v8 = (uint64_t)a2 - v7;
    v9 = 0x1CAC083126E978D5 * ((uint64_t)((uint64_t)a2 - v7) >> 3);
    switch(v9)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v175 = *((float *)a2 - 64);
        v176 = *(float *)(v7 + 744);
        if (v175 != v176)
          goto LABEL_420;
        v177 = *(_QWORD *)v251;
        if (*(_QWORD *)v251)
        {
          v178 = 240 * v177;
          v179 = *v247;
          while ((*(_BYTE *)(v179 + 105) & 1) == 0)
          {
            v179 += 240;
            v178 -= 240;
            if (!v178)
              goto LABEL_420;
          }
        }
        else
        {
          v179 = *v247;
        }
        if (v179 == *v247 + 240 * v177)
          goto LABEL_420;
        v239 = *(_QWORD *)v7;
        if (*(_QWORD *)v7)
        {
          v240 = 240 * v239;
          v241 = *(_QWORD *)(v7 + 8);
          while ((*(_BYTE *)(v241 + 105) & 1) == 0)
          {
            v241 += 240;
            v240 -= 240;
            if (!v240)
              goto LABEL_420;
          }
        }
        else
        {
          v241 = *(_QWORD *)(v7 + 8);
        }
        if (v241 != *(_QWORD *)(v7 + 8) + 240 * v239)
        {
          v242 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(v251));
          v244 = v243;
          v245 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v7));
          if (v244 && v246)
          {
            if (v242 <= v245)
              return;
            goto LABEL_421;
          }
          v175 = *((float *)a2 - 64);
          v176 = *(float *)(v7 + 744);
        }
LABEL_420:
        if (v175 <= v176)
          return;
LABEL_421:
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v7, (uint64_t *)v251);
        return;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(v7, (KB::Candidate *)(v7 + 1000), (float *)v251);
        return;
      case 4uLL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(v7, (float *)(v7 + 1000), (float *)(v7 + 2000), (float *)v251);
        return;
      case 5uLL:
        std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,0>(v7, (float *)(v7 + 1000), (float *)(v7 + 2000), (float *)(v7 + 3000), (float *)v251);
        return;
      default:
        if (v8 <= 23999)
        {
          if ((a4 & 1) == 0)
          {
            if ((KB::Candidate *)v7 == a2)
              return;
            v210 = (KB::Candidate *)(v7 + 1000);
            if ((KB::Candidate *)(v7 + 1000) == a2)
              return;
            while (1)
            {
              v211 = a1;
              a1 = (uint64_t *)v210;
              v212 = *((float *)v211 + 436);
              v213 = *((float *)v211 + 186);
              if (v212 == v213)
              {
                v214 = *(_QWORD *)v210;
                if (*(_QWORD *)v210)
                {
                  v215 = 240 * v214;
                  v216 = v211[126];
                  while ((*(_BYTE *)(v216 + 105) & 1) == 0)
                  {
                    v216 += 240;
                    v215 -= 240;
                    if (!v215)
                      goto LABEL_380;
                  }
                }
                else
                {
                  v216 = v211[126];
                }
                if (v216 != v211[126] + 240 * v214)
                {
                  v217 = *v211;
                  if (*v211)
                  {
                    v218 = 240 * v217;
                    v219 = v211[1];
                    while ((*(_BYTE *)(v219 + 105) & 1) == 0)
                    {
                      v219 += 240;
                      v218 -= 240;
                      if (!v218)
                        goto LABEL_380;
                    }
                  }
                  else
                  {
                    v219 = v211[1];
                  }
                  if (v219 != v211[1] + 240 * v217)
                  {
                    v220 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(v210));
                    v222 = v221;
                    v223 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v211));
                    if (v222 && v224)
                    {
                      if (v220 <= v223)
                        goto LABEL_404;
LABEL_381:
                      KB::Candidate::Candidate((uint64_t)&v253, (uint64_t)a1);
                      v225 = a1;
                      while (1)
                      {
                        v226 = v225;
                        v225 = v211;
                        KB::Candidate::operator=(v226, v211);
                        v211 -= 125;
                        v227 = v255;
                        v228 = *((float *)v225 - 64);
                        if (v255 == v228)
                        {
                          if (v253)
                          {
                            v229 = 240 * v253;
                            v230 = v254;
                            while ((*(_BYTE *)(v230 + 105) & 1) == 0)
                            {
                              v230 += 240;
                              v229 -= 240;
                              if (!v229)
                                goto LABEL_402;
                            }
                          }
                          else
                          {
                            v230 = v254;
                          }
                          if (v230 != v254 + 240 * v253)
                          {
                            v231 = *v211;
                            if (*v211)
                            {
                              v232 = 240 * v231;
                              v233 = *(v225 - 124);
                              while ((*(_BYTE *)(v233 + 105) & 1) == 0)
                              {
                                v233 += 240;
                                v232 -= 240;
                                if (!v232)
                                  goto LABEL_402;
                              }
                            }
                            else
                            {
                              v233 = *(v225 - 124);
                            }
                            if (v233 != *(v225 - 124) + 240 * v231)
                            {
                              v234 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
                              v236 = v235;
                              v237 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v211));
                              if (v236 && v238)
                              {
                                if (v234 <= v237)
                                  goto LABEL_403;
                                continue;
                              }
                              v227 = v255;
                              v228 = *((float *)v225 - 64);
                            }
                          }
                        }
LABEL_402:
                        if (v227 <= v228)
                        {
LABEL_403:
                          KB::Candidate::operator=(v225, &v253);
                          KB::Candidate::~Candidate((KB::Candidate *)&v253);
                          goto LABEL_404;
                        }
                      }
                    }
                    v212 = *((float *)v211 + 436);
                    v213 = *((float *)v211 + 186);
                  }
                }
              }
LABEL_380:
              if (v212 > v213)
                goto LABEL_381;
LABEL_404:
              v210 = (KB::Candidate *)(a1 + 125);
              if (a1 + 125 == (uint64_t *)a2)
                return;
            }
          }
          if ((KB::Candidate *)v7 == a2)
            return;
          v180 = (KB::Candidate *)(v7 + 1000);
          if ((KB::Candidate *)(v7 + 1000) == a2)
            return;
          v181 = v7;
LABEL_308:
          v182 = v181;
          v181 = (uint64_t)v180;
          v183 = *(float *)(v182 + 1744);
          v184 = *(float *)(v182 + 744);
          if (v183 == v184)
          {
            v185 = *(_QWORD *)v180;
            if (*(_QWORD *)v180)
            {
              v186 = 240 * v185;
              v187 = *(_QWORD *)(v182 + 1008);
              while ((*(_BYTE *)(v187 + 105) & 1) == 0)
              {
                v187 += 240;
                v186 -= 240;
                if (!v186)
                  goto LABEL_328;
              }
            }
            else
            {
              v187 = *(_QWORD *)(v182 + 1008);
            }
            if (v187 != *(_QWORD *)(v182 + 1008) + 240 * v185)
            {
              v188 = *(_QWORD *)v182;
              if (*(_QWORD *)v182)
              {
                v189 = 240 * v188;
                v190 = *(_QWORD *)(v182 + 8);
                while ((*(_BYTE *)(v190 + 105) & 1) == 0)
                {
                  v190 += 240;
                  v189 -= 240;
                  if (!v189)
                    goto LABEL_328;
                }
              }
              else
              {
                v190 = *(_QWORD *)(v182 + 8);
              }
              if (v190 != *(_QWORD *)(v182 + 8) + 240 * v188)
              {
                v191 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(v180));
                v193 = v192;
                v194 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v182));
                if (v193 && v195)
                {
                  if (v191 <= v194)
                    goto LABEL_355;
LABEL_329:
                  KB::Candidate::Candidate((uint64_t)&v253, v181);
                  v196 = (uint64_t *)v181;
                  while (1)
                  {
                    while (1)
                    {
                      v197 = v196;
                      v196 = (uint64_t *)v182;
                      KB::Candidate::operator=(v197, (uint64_t *)v182);
                      if (v182 == v7)
                      {
                        v196 = (uint64_t *)v7;
LABEL_354:
                        KB::Candidate::operator=(v196, &v253);
                        KB::Candidate::~Candidate((KB::Candidate *)&v253);
LABEL_355:
                        v180 = (KB::Candidate *)(v181 + 1000);
                        if ((KB::Candidate *)(v181 + 1000) == a2)
                          return;
                        goto LABEL_308;
                      }
                      v182 -= 1000;
                      v198 = v255;
                      v199 = *((float *)v196 - 64);
                      if (v255 == v199)
                      {
                        if (v253)
                        {
                          v200 = 240 * v253;
                          v201 = v254;
                          while ((*(_BYTE *)(v201 + 105) & 1) == 0)
                          {
                            v201 += 240;
                            v200 -= 240;
                            if (!v200)
                              goto LABEL_351;
                          }
                        }
                        else
                        {
                          v201 = v254;
                        }
                        if (v201 != v254 + 240 * v253)
                        {
                          v202 = *(_QWORD *)v182;
                          if (*(_QWORD *)v182)
                          {
                            v203 = 240 * v202;
                            v204 = *(v196 - 124);
                            while ((*(_BYTE *)(v204 + 105) & 1) == 0)
                            {
                              v204 += 240;
                              v203 -= 240;
                              if (!v203)
                                goto LABEL_351;
                            }
                          }
                          else
                          {
                            v204 = *(v196 - 124);
                          }
                          if (v204 != *(v196 - 124) + 240 * v202)
                            break;
                        }
                      }
LABEL_351:
                      if (v198 <= v199)
                        goto LABEL_354;
                    }
                    v205 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
                    v207 = v206;
                    v208 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)(v196 - 125)));
                    if (!v207 || !v209)
                    {
                      v198 = v255;
                      v199 = *((float *)v196 - 64);
                      goto LABEL_351;
                    }
                    if (v205 <= v208)
                      goto LABEL_354;
                  }
                }
                v183 = *(float *)(v182 + 1744);
                v184 = *(float *)(v182 + 744);
              }
            }
          }
LABEL_328:
          if (v183 <= v184)
            goto LABEL_355;
          goto LABEL_329;
        }
        if (!a3)
        {
          std::__partial_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,KB::Candidate *>((KB::Candidate *)v7, a2, (uint64_t *)a2);
          return;
        }
        v10 = v9 >> 1;
        v11 = (KB::Candidate *)(v7 + 1000 * (v9 >> 1));
        if ((unint64_t)v8 < 0x1F401)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>((uint64_t)v11, (KB::Candidate *)v7, (float *)v251);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(v7, v11, (float *)v251);
          v12 = 1000 * v10;
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(v7 + 1000, (KB::Candidate *)(v12 + v7 - 1000), v249);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(v7 + 2000, (KB::Candidate *)(v7 + 1000 + v12), v248);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(v12 + v7 - 1000, v11, (float *)(v7 + 1000 + v12));
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v7, (uint64_t *)v11);
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v13 = *(float *)(v7 - 256);
          v14 = *(float *)(v7 + 744);
          if (v13 != v14)
            goto LABEL_35;
          v15 = *(_QWORD *)(v7 - 1000);
          if (v15)
          {
            v16 = 240 * v15;
            v17 = *(_QWORD *)(v7 - 992);
            while ((*(_BYTE *)(v17 + 105) & 1) == 0)
            {
              v17 += 240;
              v16 -= 240;
              if (!v16)
                goto LABEL_35;
            }
          }
          else
          {
            v17 = *(_QWORD *)(v7 - 992);
          }
          if (v17 == *(_QWORD *)(v7 - 992) + 240 * v15)
            goto LABEL_35;
          v18 = *(_QWORD *)v7;
          if (*(_QWORD *)v7)
          {
            v19 = 240 * v18;
            v20 = *(_QWORD *)(v7 + 8);
            while ((*(_BYTE *)(v20 + 105) & 1) == 0)
            {
              v20 += 240;
              v19 -= 240;
              if (!v19)
                goto LABEL_35;
            }
          }
          else
          {
            v20 = *(_QWORD *)(v7 + 8);
          }
          if (v20 == *(_QWORD *)(v7 + 8) + 240 * v18)
            goto LABEL_35;
          v21 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)(v7 - 1000)));
          v23 = v22;
          v24 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v7));
          if (!v23 || !v25)
          {
            v13 = *(float *)(v7 - 256);
            v14 = *(float *)(v7 + 744);
LABEL_35:
            if (v13 > v14)
              goto LABEL_36;
            goto LABEL_28;
          }
          if (v21 > v24)
            goto LABEL_36;
LABEL_28:
          KB::Candidate::Candidate((uint64_t)&v253, v7);
          v26 = v255;
          v27 = *((float *)a2 - 64);
          if (v255 != v27)
            goto LABEL_199;
          if (v253)
          {
            v28 = 240 * v253;
            v29 = v254;
            while ((*(_BYTE *)(v29 + 105) & 1) == 0)
            {
              v29 += 240;
              v28 -= 240;
              if (!v28)
                goto LABEL_199;
            }
          }
          else
          {
            v29 = v254;
          }
          if (v29 == v254 + 240 * v253)
            goto LABEL_199;
          v100 = *(_QWORD *)v251;
          if (*(_QWORD *)v251)
          {
            v101 = 240 * v100;
            v102 = *v247;
            while ((*(_BYTE *)(v102 + 105) & 1) == 0)
            {
              v102 += 240;
              v101 -= 240;
              if (!v101)
                goto LABEL_199;
            }
          }
          else
          {
            v102 = *v247;
          }
          if (v102 == *v247 + 240 * v100)
            goto LABEL_199;
          v103 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
          v105 = v104;
          v106 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(v251));
          if (!v105 || !v107)
          {
            v26 = v255;
            v27 = *((float *)a2 - 64);
LABEL_199:
            if (v26 > v27)
              goto LABEL_200;
LABEL_173:
            v7 += 1000;
            v108 = a1;
            while (2)
            {
              if (v7 >= (unint64_t)a2)
                goto LABEL_221;
              v109 = v7;
              v110 = v255;
              v111 = *((float *)v108 + 436);
              if (v255 == v111)
              {
                if (v253)
                {
                  v112 = 240 * v253;
                  v113 = v254;
                  while ((*(_BYTE *)(v113 + 105) & 1) == 0)
                  {
                    v113 += 240;
                    v112 -= 240;
                    if (!v112)
                      goto LABEL_195;
                  }
                }
                else
                {
                  v113 = v254;
                }
                if (v113 != v254 + 240 * v253)
                {
                  v114 = *(_QWORD *)v7;
                  if (*(_QWORD *)v7)
                  {
                    v115 = 240 * v114;
                    v116 = v108[126];
                    while ((*(_BYTE *)(v116 + 105) & 1) == 0)
                    {
                      v116 += 240;
                      v115 -= 240;
                      if (!v115)
                        goto LABEL_195;
                    }
                  }
                  else
                  {
                    v116 = v108[126];
                  }
                  if (v116 != v108[126] + 240 * v114)
                  {
                    v117 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
                    v119 = v118;
                    v120 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v7));
                    if (v119 && v121)
                    {
                      if (v117 > v120)
                        goto LABEL_221;
LABEL_196:
                      v7 += 1000;
                      v108 = (uint64_t *)v109;
                      continue;
                    }
                    v110 = v255;
                    v111 = *((float *)v108 + 436);
                  }
                }
              }
              break;
            }
LABEL_195:
            if (v110 > v111)
              goto LABEL_221;
            goto LABEL_196;
          }
          if (v103 <= v106)
            goto LABEL_173;
          do
          {
LABEL_200:
            while (1)
            {
              v122 = v7;
              v7 += 1000;
              v123 = v255;
              v124 = *(float *)(v122 + 1744);
              if (v255 != v124)
                break;
              if (v253)
              {
                v125 = 240 * v253;
                v126 = v254;
                while ((*(_BYTE *)(v126 + 105) & 1) == 0)
                {
                  v126 += 240;
                  v125 -= 240;
                  if (!v125)
                    goto LABEL_220;
                }
              }
              else
              {
                v126 = v254;
              }
              if (v126 == v254 + 240 * v253)
                break;
              v127 = *(_QWORD *)(v122 + 1000);
              if (v127)
              {
                v128 = 240 * v127;
                v129 = *(_QWORD *)(v122 + 1008);
                while ((*(_BYTE *)(v129 + 105) & 1) == 0)
                {
                  v129 += 240;
                  v128 -= 240;
                  if (!v128)
                    goto LABEL_220;
                }
              }
              else
              {
                v129 = *(_QWORD *)(v122 + 1008);
              }
              if (v129 == *(_QWORD *)(v122 + 1008) + 240 * v127)
                break;
              v130 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
              v132 = v131;
              v133 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v7));
              if (!v132 || !v134)
              {
                v123 = v255;
                v124 = *(float *)(v122 + 1744);
                break;
              }
              if (v130 > v133)
                goto LABEL_221;
            }
LABEL_220:
            ;
          }
          while (v123 <= v124);
LABEL_221:
          v135 = a2;
          if (v7 < (unint64_t)a2)
          {
            v135 = a2;
            while (1)
            {
              v136 = v135;
              v135 = (KB::Candidate *)((char *)v135 - 1000);
              v137 = v255;
              v138 = *((float *)v136 - 64);
              if (v255 != v138)
                goto LABEL_243;
              if (v253)
              {
                v139 = 240 * v253;
                v140 = v254;
                while ((*(_BYTE *)(v140 + 105) & 1) == 0)
                {
                  v140 += 240;
                  v139 -= 240;
                  if (!v139)
                    goto LABEL_243;
                }
              }
              else
              {
                v140 = v254;
              }
              if (v140 == v254 + 240 * v253)
                goto LABEL_243;
              v141 = *(_QWORD *)v135;
              if (*(_QWORD *)v135)
              {
                v142 = 240 * v141;
                v143 = *((_QWORD *)v136 - 124);
                while ((*(_BYTE *)(v143 + 105) & 1) == 0)
                {
                  v143 += 240;
                  v142 -= 240;
                  if (!v142)
                    goto LABEL_243;
                }
              }
              else
              {
                v143 = *((_QWORD *)v136 - 124);
              }
              if (v143 == *((_QWORD *)v136 - 124) + 240 * v141)
                goto LABEL_243;
              v144 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
              v146 = v145;
              v147 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(v135));
              if (v146 && v148)
              {
                if (v144 <= v147)
                  break;
              }
              else
              {
                v137 = v255;
                v138 = *((float *)v136 - 64);
LABEL_243:
                if (v137 <= v138)
                  break;
              }
            }
          }
LABEL_288:
          if (v7 < (unint64_t)v135)
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v7, (uint64_t *)v135);
            do
            {
              while (2)
              {
                v149 = v7;
                v7 += 1000;
                v150 = v255;
                v151 = *(float *)(v149 + 1744);
                if (v255 == v151)
                {
                  if (v253)
                  {
                    v152 = 240 * v253;
                    v153 = v254;
                    while ((*(_BYTE *)(v153 + 105) & 1) == 0)
                    {
                      v153 += 240;
                      v152 -= 240;
                      if (!v152)
                        goto LABEL_266;
                    }
                  }
                  else
                  {
                    v153 = v254;
                  }
                  if (v153 != v254 + 240 * v253)
                  {
                    v154 = *(_QWORD *)(v149 + 1000);
                    if (v154)
                    {
                      v155 = 240 * v154;
                      v156 = *(_QWORD *)(v149 + 1008);
                      while ((*(_BYTE *)(v156 + 105) & 1) == 0)
                      {
                        v156 += 240;
                        v155 -= 240;
                        if (!v155)
                          goto LABEL_266;
                      }
                    }
                    else
                    {
                      v156 = *(_QWORD *)(v149 + 1008);
                    }
                    if (v156 != *(_QWORD *)(v149 + 1008) + 240 * v154)
                    {
                      v157 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
                      v159 = v158;
                      v160 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v7));
                      if (v159 && v161)
                      {
                        if (v157 > v160)
                          goto LABEL_267;
                        continue;
                      }
                      v150 = v255;
                      v151 = *(float *)(v149 + 1744);
                    }
                  }
                }
                break;
              }
LABEL_266:
              ;
            }
            while (v150 <= v151);
            while (1)
            {
LABEL_267:
              v162 = v135;
              v135 = (KB::Candidate *)((char *)v135 - 1000);
              v163 = v255;
              v164 = *((float *)v162 - 64);
              if (v255 == v164)
              {
                if (v253)
                {
                  v165 = 240 * v253;
                  v166 = v254;
                  while ((*(_BYTE *)(v166 + 105) & 1) == 0)
                  {
                    v166 += 240;
                    v165 -= 240;
                    if (!v165)
                      goto LABEL_287;
                  }
                }
                else
                {
                  v166 = v254;
                }
                if (v166 != v254 + 240 * v253)
                {
                  v167 = *(_QWORD *)v135;
                  if (*(_QWORD *)v135)
                  {
                    v168 = 240 * v167;
                    v169 = *((_QWORD *)v162 - 124);
                    while ((*(_BYTE *)(v169 + 105) & 1) == 0)
                    {
                      v169 += 240;
                      v168 -= 240;
                      if (!v168)
                        goto LABEL_287;
                    }
                  }
                  else
                  {
                    v169 = *((_QWORD *)v162 - 124);
                  }
                  if (v169 != *((_QWORD *)v162 - 124) + 240 * v167)
                  {
                    v170 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
                    v172 = v171;
                    v173 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(v135));
                    if (v172 && v174)
                    {
                      if (v170 <= v173)
                        goto LABEL_288;
                      continue;
                    }
                    v163 = v255;
                    v164 = *((float *)v162 - 64);
                  }
                }
              }
LABEL_287:
              if (v163 <= v164)
                goto LABEL_288;
            }
          }
          if ((uint64_t *)(v7 - 1000) != a1)
            KB::Candidate::operator=(a1, (uint64_t *)(v7 - 1000));
          KB::Candidate::operator=((uint64_t *)(v7 - 1000), &v253);
          KB::Candidate::~Candidate((KB::Candidate *)&v253);
          a4 = 0;
          continue;
        }
LABEL_36:
        v252 = a3;
        KB::Candidate::Candidate((uint64_t)&v253, v7);
        v30 = (KB::Candidate *)v7;
        while (2)
        {
          while (1)
          {
            v31 = v30;
            v30 = (KB::Candidate *)((char *)v30 + 1000);
            v32 = *((float *)v31 + 436);
            v33 = v255;
            if (v32 != v255)
              break;
            v34 = *((_QWORD *)v31 + 125);
            if (v34)
            {
              v35 = 240 * v34;
              v36 = *((_QWORD *)v31 + 126);
              while ((*(_BYTE *)(v36 + 105) & 1) == 0)
              {
                v36 += 240;
                v35 -= 240;
                if (!v35)
                  goto LABEL_57;
              }
            }
            else
            {
              v36 = *((_QWORD *)v31 + 126);
            }
            if (v36 == *((_QWORD *)v31 + 126) + 240 * v34)
              break;
            if (v253)
            {
              v37 = 240 * v253;
              v38 = v254;
              while ((*(_BYTE *)(v38 + 105) & 1) == 0)
              {
                v38 += 240;
                v37 -= 240;
                if (!v37)
                  goto LABEL_57;
              }
            }
            else
            {
              v38 = v254;
            }
            if (v38 == v254 + 240 * v253)
              break;
            v39 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(v30));
            v41 = v40;
            v42 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
            if (!v41 || !v43)
            {
              v32 = *((float *)v31 + 436);
              v33 = v255;
              break;
            }
            if (v39 <= v42)
              goto LABEL_58;
          }
LABEL_57:
          if (v32 > v33)
            continue;
          break;
        }
LABEL_58:
        v44 = (uint64_t)a2;
        if (v31 != (KB::Candidate *)v7)
        {
          while (1)
          {
            v45 = a2;
            a2 = (KB::Candidate *)((char *)a2 - 1000);
            v46 = *((float *)v45 - 64);
            v47 = v255;
            if (v46 == v255)
            {
              v48 = *(_QWORD *)a2;
              if (*(_QWORD *)a2)
              {
                v49 = 240 * v48;
                v50 = *((_QWORD *)v45 - 124);
                while ((*(_BYTE *)(v50 + 105) & 1) == 0)
                {
                  v50 += 240;
                  v49 -= 240;
                  if (!v49)
                    goto LABEL_79;
                }
              }
              else
              {
                v50 = *((_QWORD *)v45 - 124);
              }
              if (v50 != *((_QWORD *)v45 - 124) + 240 * v48)
              {
                if (v253)
                {
                  v51 = 240 * v253;
                  v52 = v254;
                  while ((*(_BYTE *)(v52 + 105) & 1) == 0)
                  {
                    v52 += 240;
                    v51 -= 240;
                    if (!v51)
                      goto LABEL_79;
                  }
                }
                else
                {
                  v52 = v254;
                }
                if (v52 != v254 + 240 * v253)
                {
                  v53 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(a2));
                  v55 = v54;
                  v56 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
                  if (v55 && v57)
                  {
                    if (v53 > v56)
                      goto LABEL_108;
                    continue;
                  }
                  v46 = *((float *)v45 - 64);
                  v47 = v255;
                }
              }
            }
LABEL_79:
            if (v46 > v47)
              goto LABEL_108;
          }
        }
        if (v30 < a2)
        {
          do
          {
LABEL_82:
            v58 = a2;
            a2 = (KB::Candidate *)((char *)a2 - 1000);
            v59 = *((float *)v58 - 64);
            v60 = v255;
            if (v59 == v255)
            {
              v61 = *(_QWORD *)a2;
              if (*(_QWORD *)a2)
              {
                v62 = 240 * v61;
                v63 = *((_QWORD *)v58 - 124);
                while ((*(_BYTE *)(v63 + 105) & 1) == 0)
                {
                  v63 += 240;
                  v62 -= 240;
                  if (!v62)
                    goto LABEL_103;
                }
              }
              else
              {
                v63 = *((_QWORD *)v58 - 124);
              }
              if (v63 != *((_QWORD *)v58 - 124) + 240 * v61)
              {
                if (v253)
                {
                  v64 = 240 * v253;
                  v65 = v254;
                  while ((*(_BYTE *)(v65 + 105) & 1) == 0)
                  {
                    v65 += 240;
                    v64 -= 240;
                    if (!v64)
                      goto LABEL_103;
                  }
                }
                else
                {
                  v65 = v254;
                }
                if (v65 != v254 + 240 * v253)
                {
                  v66 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(a2));
                  v68 = v67;
                  v69 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
                  if (v68 && v70)
                  {
                    if (v66 > v69 || v30 >= a2)
                      break;
                    goto LABEL_82;
                  }
                  v59 = *((float *)v58 - 64);
                  v60 = v255;
                }
              }
            }
LABEL_103:
            v71 = v59 > v60 || v30 >= a2;
          }
          while (!v71);
        }
LABEL_108:
        v7 = (unint64_t)v30;
        if (v30 >= a2)
          goto LABEL_154;
        v72 = (uint64_t *)a2;
        while (2)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v7, v72);
          do
          {
LABEL_111:
            v73 = v7;
            v7 += 1000;
            v74 = *(float *)(v73 + 1744);
            v75 = v255;
            if (v74 == v255)
            {
              v76 = *(_QWORD *)(v73 + 1000);
              if (v76)
              {
                v77 = 240 * v76;
                v78 = *(_QWORD *)(v73 + 1008);
                while ((*(_BYTE *)(v78 + 105) & 1) == 0)
                {
                  v78 += 240;
                  v77 -= 240;
                  if (!v77)
                    goto LABEL_131;
                }
              }
              else
              {
                v78 = *(_QWORD *)(v73 + 1008);
              }
              if (v78 != *(_QWORD *)(v73 + 1008) + 240 * v76)
              {
                if (v253)
                {
                  v79 = 240 * v253;
                  v80 = v254;
                  while ((*(_BYTE *)(v80 + 105) & 1) == 0)
                  {
                    v80 += 240;
                    v79 -= 240;
                    if (!v79)
                      goto LABEL_131;
                  }
                }
                else
                {
                  v80 = v254;
                }
                if (v80 != v254 + 240 * v253)
                {
                  v81 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v7));
                  v83 = v82;
                  v84 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
                  if (v83 && v85)
                  {
                    if (v81 <= v84)
                      break;
                    goto LABEL_111;
                  }
                  v74 = *(float *)(v73 + 1744);
                  v75 = v255;
                }
              }
            }
LABEL_131:
            ;
          }
          while (v74 > v75);
          while (2)
          {
            while (1)
            {
              v86 = v72;
              v72 -= 125;
              v87 = *((float *)v86 - 64);
              v88 = v255;
              if (v87 != v255)
                break;
              v89 = *v72;
              if (*v72)
              {
                v90 = 240 * v89;
                v91 = *(v86 - 124);
                while ((*(_BYTE *)(v91 + 105) & 1) == 0)
                {
                  v91 += 240;
                  v90 -= 240;
                  if (!v90)
                    goto LABEL_152;
                }
              }
              else
              {
                v91 = *(v86 - 124);
              }
              if (v91 == *(v86 - 124) + 240 * v89)
                break;
              if (v253)
              {
                v92 = 240 * v253;
                v93 = v254;
                while ((*(_BYTE *)(v93 + 105) & 1) == 0)
                {
                  v93 += 240;
                  v92 -= 240;
                  if (!v92)
                    goto LABEL_152;
                }
              }
              else
              {
                v93 = v254;
              }
              if (v93 == v254 + 240 * v253)
                break;
              v94 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v72));
              v96 = v95;
              v97 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v253));
              if (!v96 || !v98)
              {
                v87 = *((float *)v86 - 64);
                v88 = v255;
                break;
              }
              if (v94 > v97)
                goto LABEL_153;
            }
LABEL_152:
            if (v87 <= v88)
              continue;
            break;
          }
LABEL_153:
          if (v7 < (unint64_t)v72)
            continue;
          break;
        }
LABEL_154:
        if ((uint64_t *)(v7 - 1000) != a1)
          KB::Candidate::operator=(a1, (uint64_t *)(v7 - 1000));
        KB::Candidate::operator=((uint64_t *)(v7 - 1000), &v253);
        KB::Candidate::~Candidate((KB::Candidate *)&v253);
        v71 = v30 >= a2;
        a2 = (KB::Candidate *)v44;
        a3 = v252;
        if (!v71)
        {
LABEL_160:
          std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,false>(a1, v7 - 1000, v252, a4 & 1);
          a4 = 0;
          continue;
        }
        v99 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>((uint64_t)a1, v7 - 1000);
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(v7, v44))
        {
          if (v99)
            continue;
          goto LABEL_160;
        }
        a2 = (KB::Candidate *)(v7 - 1000);
        if (!v99)
          goto LABEL_2;
        return;
    }
  }
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(uint64_t a1, KB::Candidate *this, float *a3)
{
  float v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  char v15;
  char v16;
  double v17;
  char v18;
  float v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  double v33;
  char v34;
  char v35;
  double v36;
  char v37;
  double v38;
  char v39;
  char v40;
  double v41;
  char v42;
  float v43;
  float v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  float v51;
  float v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  double v60;
  char v61;
  char v62;
  double v63;
  char v64;
  double v65;
  char v66;
  char v67;
  double v68;
  char v69;
  uint64_t *v70;

  v6 = *((float *)this + 186);
  v7 = *(float *)(a1 + 744);
  if (v6 != v7)
    goto LABEL_33;
  v8 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v9 = 240 * v8;
    v10 = *((_QWORD *)this + 1);
    while ((*(_BYTE *)(v10 + 105) & 1) == 0)
    {
      v10 += 240;
      v9 -= 240;
      if (!v9)
        goto LABEL_33;
    }
  }
  else
  {
    v10 = *((_QWORD *)this + 1);
  }
  if (v10 == *((_QWORD *)this + 1) + 240 * v8)
    goto LABEL_33;
  v11 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    v12 = 240 * v11;
    v13 = *(_QWORD *)(a1 + 8);
    while ((*(_BYTE *)(v13 + 105) & 1) == 0)
    {
      v13 += 240;
      v12 -= 240;
      if (!v12)
        goto LABEL_33;
    }
  }
  else
  {
    v13 = *(_QWORD *)(a1 + 8);
  }
  if (v13 == *(_QWORD *)(a1 + 8) + 240 * v11)
  {
LABEL_33:
    if (v6 <= v7)
      goto LABEL_19;
LABEL_34:
    v26 = a3[186];
    if (v26 == v6)
    {
      v27 = *(_QWORD *)a3;
      if (*(_QWORD *)a3)
      {
        v28 = 240 * v27;
        v29 = *((_QWORD *)a3 + 1);
        while ((*(_BYTE *)(v29 + 105) & 1) == 0)
        {
          v29 += 240;
          v28 -= 240;
          if (!v28)
            goto LABEL_87;
        }
      }
      else
      {
        v29 = *((_QWORD *)a3 + 1);
      }
      if (v29 != *((_QWORD *)a3 + 1) + 240 * v27)
      {
        v30 = *(_QWORD *)this;
        if (*(_QWORD *)this)
        {
          v31 = 240 * v30;
          v32 = *((_QWORD *)this + 1);
          while ((*(_BYTE *)(v32 + 105) & 1) == 0)
          {
            v32 += 240;
            v31 -= 240;
            if (!v31)
              goto LABEL_87;
          }
        }
        else
        {
          v32 = *((_QWORD *)this + 1);
        }
        if (v32 != *((_QWORD *)this + 1) + 240 * v30)
        {
          v38 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a3));
          v40 = v39;
          v41 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(this));
          if (v40 && v42)
          {
            if (v38 <= v41)
            {
LABEL_58:
              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)this);
              v43 = a3[186];
              v44 = *((float *)this + 186);
              if (v43 == v44)
              {
                v45 = *(_QWORD *)a3;
                if (*(_QWORD *)a3)
                {
                  v46 = 240 * v45;
                  v47 = *((_QWORD *)a3 + 1);
                  while ((*(_BYTE *)(v47 + 105) & 1) == 0)
                  {
                    v47 += 240;
                    v46 -= 240;
                    if (!v46)
                      goto LABEL_102;
                  }
                }
                else
                {
                  v47 = *((_QWORD *)a3 + 1);
                }
                if (v47 != *((_QWORD *)a3 + 1) + 240 * v45)
                {
                  v48 = *(_QWORD *)this;
                  if (*(_QWORD *)this)
                  {
                    v49 = 240 * v48;
                    v50 = *((_QWORD *)this + 1);
                    while ((*(_BYTE *)(v50 + 105) & 1) == 0)
                    {
                      v50 += 240;
                      v49 -= 240;
                      if (!v49)
                        goto LABEL_102;
                    }
                  }
                  else
                  {
                    v50 = *((_QWORD *)this + 1);
                  }
                  if (v50 != *((_QWORD *)this + 1) + 240 * v48)
                  {
                    v60 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a3));
                    v62 = v61;
                    v63 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(this));
                    if (v62 && v64)
                    {
                      if (v60 <= v63)
                        return;
                      goto LABEL_103;
                    }
                    v43 = a3[186];
                    v44 = *((float *)this + 186);
                  }
                }
              }
LABEL_102:
              if (v43 <= v44)
                return;
LABEL_103:
              v59 = (uint64_t *)this;
              goto LABEL_104;
            }
LABEL_88:
            v59 = (uint64_t *)a1;
LABEL_104:
            v70 = (uint64_t *)a3;
LABEL_108:
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v59, v70);
            return;
          }
          v26 = a3[186];
          v6 = *((float *)this + 186);
        }
      }
    }
LABEL_87:
    if (v26 <= v6)
      goto LABEL_58;
    goto LABEL_88;
  }
  v14 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(this));
  v16 = v15;
  v17 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a1));
  if (!v16 || !v18)
  {
    v6 = *((float *)this + 186);
    v7 = *(float *)(a1 + 744);
    goto LABEL_33;
  }
  v6 = *((float *)this + 186);
  if (v14 > v17)
    goto LABEL_34;
LABEL_19:
  v19 = a3[186];
  if (v19 != v6)
    goto LABEL_72;
  v20 = *(_QWORD *)a3;
  if (*(_QWORD *)a3)
  {
    v21 = 240 * v20;
    v22 = *((_QWORD *)a3 + 1);
    while ((*(_BYTE *)(v22 + 105) & 1) == 0)
    {
      v22 += 240;
      v21 -= 240;
      if (!v21)
        goto LABEL_72;
    }
  }
  else
  {
    v22 = *((_QWORD *)a3 + 1);
  }
  if (v22 == *((_QWORD *)a3 + 1) + 240 * v20)
    goto LABEL_72;
  v23 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v24 = 240 * v23;
    v25 = *((_QWORD *)this + 1);
    while ((*(_BYTE *)(v25 + 105) & 1) == 0)
    {
      v25 += 240;
      v24 -= 240;
      if (!v24)
        goto LABEL_72;
    }
  }
  else
  {
    v25 = *((_QWORD *)this + 1);
  }
  if (v25 == *((_QWORD *)this + 1) + 240 * v23)
  {
LABEL_72:
    if (v19 <= v6)
      return;
    goto LABEL_73;
  }
  v33 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a3));
  v35 = v34;
  v36 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(this));
  if (!v35 || !v37)
  {
    v19 = a3[186];
    v6 = *((float *)this + 186);
    goto LABEL_72;
  }
  if (v33 <= v36)
    return;
LABEL_73:
  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)this, (uint64_t *)a3);
  v51 = *((float *)this + 186);
  v52 = *(float *)(a1 + 744);
  if (v51 != v52)
    goto LABEL_106;
  v53 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v54 = 240 * v53;
    v55 = *((_QWORD *)this + 1);
    while ((*(_BYTE *)(v55 + 105) & 1) == 0)
    {
      v55 += 240;
      v54 -= 240;
      if (!v54)
        goto LABEL_106;
    }
  }
  else
  {
    v55 = *((_QWORD *)this + 1);
  }
  if (v55 == *((_QWORD *)this + 1) + 240 * v53)
    goto LABEL_106;
  v56 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    v57 = 240 * v56;
    v58 = *(_QWORD *)(a1 + 8);
    while ((*(_BYTE *)(v58 + 105) & 1) == 0)
    {
      v58 += 240;
      v57 -= 240;
      if (!v57)
        goto LABEL_106;
    }
  }
  else
  {
    v58 = *(_QWORD *)(a1 + 8);
  }
  if (v58 == *(_QWORD *)(a1 + 8) + 240 * v56)
  {
LABEL_106:
    if (v51 <= v52)
      return;
    goto LABEL_107;
  }
  v65 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(this));
  v67 = v66;
  v68 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a1));
  if (!v67 || !v69)
  {
    v51 = *((float *)this + 186);
    v52 = *(float *)(a1 + 744);
    goto LABEL_106;
  }
  if (v65 > v68)
  {
LABEL_107:
    v59 = (uint64_t *)a1;
    v70 = (uint64_t *)this;
    goto LABEL_108;
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(uint64_t a1, float *a2, float *a3, float *a4)
{
  float v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  char v17;
  char v18;
  double v19;
  char v20;
  float v21;
  float v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  double v29;
  char v30;
  char v31;
  double v32;
  char v33;
  float v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  double v42;
  char v43;
  char v44;
  double v45;
  char v46;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(a1, (KB::Candidate *)a2, a3);
  v8 = a4[186];
  v9 = a3[186];
  if (v8 == v9)
  {
    v10 = *(_QWORD *)a4;
    if (*(_QWORD *)a4)
    {
      v11 = 240 * v10;
      v12 = *((_QWORD *)a4 + 1);
      while ((*(_BYTE *)(v12 + 105) & 1) == 0)
      {
        v12 += 240;
        v11 -= 240;
        if (!v11)
          goto LABEL_21;
      }
    }
    else
    {
      v12 = *((_QWORD *)a4 + 1);
    }
    if (v12 != *((_QWORD *)a4 + 1) + 240 * v10)
    {
      v13 = *(_QWORD *)a3;
      if (*(_QWORD *)a3)
      {
        v14 = 240 * v13;
        v15 = *((_QWORD *)a3 + 1);
        while ((*(_BYTE *)(v15 + 105) & 1) == 0)
        {
          v15 += 240;
          v14 -= 240;
          if (!v14)
            goto LABEL_21;
        }
      }
      else
      {
        v15 = *((_QWORD *)a3 + 1);
      }
      if (v15 != *((_QWORD *)a3 + 1) + 240 * v13)
      {
        v16 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a4));
        v18 = v17;
        v19 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a3));
        if (v18 && v20)
        {
          if (v16 <= v19)
            return;
          goto LABEL_22;
        }
        v8 = a4[186];
        v9 = a3[186];
      }
    }
  }
LABEL_21:
  if (v8 <= v9)
    return;
LABEL_22:
  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
  v21 = a3[186];
  v22 = a2[186];
  if (v21 == v22)
  {
    v23 = *(_QWORD *)a3;
    if (*(_QWORD *)a3)
    {
      v24 = 240 * v23;
      v25 = *((_QWORD *)a3 + 1);
      while ((*(_BYTE *)(v25 + 105) & 1) == 0)
      {
        v25 += 240;
        v24 -= 240;
        if (!v24)
          goto LABEL_42;
      }
    }
    else
    {
      v25 = *((_QWORD *)a3 + 1);
    }
    if (v25 != *((_QWORD *)a3 + 1) + 240 * v23)
    {
      v26 = *(_QWORD *)a2;
      if (*(_QWORD *)a2)
      {
        v27 = 240 * v26;
        v28 = *((_QWORD *)a2 + 1);
        while ((*(_BYTE *)(v28 + 105) & 1) == 0)
        {
          v28 += 240;
          v27 -= 240;
          if (!v27)
            goto LABEL_42;
        }
      }
      else
      {
        v28 = *((_QWORD *)a2 + 1);
      }
      if (v28 != *((_QWORD *)a2 + 1) + 240 * v26)
      {
        v29 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a3));
        v31 = v30;
        v32 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a2));
        if (v31 && v33)
        {
          if (v29 <= v32)
            return;
          goto LABEL_43;
        }
        v21 = a3[186];
        v22 = a2[186];
      }
    }
  }
LABEL_42:
  if (v21 <= v22)
    return;
LABEL_43:
  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
  v34 = a2[186];
  v35 = *(float *)(a1 + 744);
  if (v34 == v35)
  {
    v36 = *(_QWORD *)a2;
    if (*(_QWORD *)a2)
    {
      v37 = 240 * v36;
      v38 = *((_QWORD *)a2 + 1);
      while ((*(_BYTE *)(v38 + 105) & 1) == 0)
      {
        v38 += 240;
        v37 -= 240;
        if (!v37)
          goto LABEL_63;
      }
    }
    else
    {
      v38 = *((_QWORD *)a2 + 1);
    }
    if (v38 != *((_QWORD *)a2 + 1) + 240 * v36)
    {
      v39 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        v40 = 240 * v39;
        v41 = *(_QWORD *)(a1 + 8);
        while ((*(_BYTE *)(v41 + 105) & 1) == 0)
        {
          v41 += 240;
          v40 -= 240;
          if (!v40)
            goto LABEL_63;
        }
      }
      else
      {
        v41 = *(_QWORD *)(a1 + 8);
      }
      if (v41 != *(_QWORD *)(a1 + 8) + 240 * v39)
      {
        v42 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a2));
        v44 = v43;
        v45 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a1));
        if (v44 && v46)
        {
          if (v42 <= v45)
            return;
LABEL_64:
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
          return;
        }
        v34 = a2[186];
        v35 = *(float *)(a1 + 744);
      }
    }
  }
LABEL_63:
  if (v34 > v35)
    goto LABEL_64;
}

void std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,0>(uint64_t a1, float *a2, float *a3, float *a4, float *a5)
{
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  char v19;
  char v20;
  double v21;
  char v22;
  float v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  char v32;
  char v33;
  double v34;
  char v35;
  float v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  double v44;
  char v45;
  char v46;
  double v47;
  char v48;
  float v49;
  float v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  double v57;
  char v58;
  char v59;
  double v60;
  char v61;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(a1, a2, a3, a4);
  v10 = a5[186];
  v11 = a4[186];
  if (v10 == v11)
  {
    v12 = *(_QWORD *)a5;
    if (*(_QWORD *)a5)
    {
      v13 = 240 * v12;
      v14 = *((_QWORD *)a5 + 1);
      while ((*(_BYTE *)(v14 + 105) & 1) == 0)
      {
        v14 += 240;
        v13 -= 240;
        if (!v13)
          goto LABEL_21;
      }
    }
    else
    {
      v14 = *((_QWORD *)a5 + 1);
    }
    if (v14 != *((_QWORD *)a5 + 1) + 240 * v12)
    {
      v15 = *(_QWORD *)a4;
      if (*(_QWORD *)a4)
      {
        v16 = 240 * v15;
        v17 = *((_QWORD *)a4 + 1);
        while ((*(_BYTE *)(v17 + 105) & 1) == 0)
        {
          v17 += 240;
          v16 -= 240;
          if (!v16)
            goto LABEL_21;
        }
      }
      else
      {
        v17 = *((_QWORD *)a4 + 1);
      }
      if (v17 != *((_QWORD *)a4 + 1) + 240 * v15)
      {
        v18 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a5));
        v20 = v19;
        v21 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a4));
        if (v20 && v22)
        {
          if (v18 <= v21)
            return;
          goto LABEL_22;
        }
        v10 = a5[186];
        v11 = a4[186];
      }
    }
  }
LABEL_21:
  if (v10 <= v11)
    return;
LABEL_22:
  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a4, (uint64_t *)a5);
  v23 = a4[186];
  v24 = a3[186];
  if (v23 == v24)
  {
    v25 = *(_QWORD *)a4;
    if (*(_QWORD *)a4)
    {
      v26 = 240 * v25;
      v27 = *((_QWORD *)a4 + 1);
      while ((*(_BYTE *)(v27 + 105) & 1) == 0)
      {
        v27 += 240;
        v26 -= 240;
        if (!v26)
          goto LABEL_42;
      }
    }
    else
    {
      v27 = *((_QWORD *)a4 + 1);
    }
    if (v27 != *((_QWORD *)a4 + 1) + 240 * v25)
    {
      v28 = *(_QWORD *)a3;
      if (*(_QWORD *)a3)
      {
        v29 = 240 * v28;
        v30 = *((_QWORD *)a3 + 1);
        while ((*(_BYTE *)(v30 + 105) & 1) == 0)
        {
          v30 += 240;
          v29 -= 240;
          if (!v29)
            goto LABEL_42;
        }
      }
      else
      {
        v30 = *((_QWORD *)a3 + 1);
      }
      if (v30 != *((_QWORD *)a3 + 1) + 240 * v28)
      {
        v31 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a4));
        v33 = v32;
        v34 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a3));
        if (v33 && v35)
        {
          if (v31 <= v34)
            return;
          goto LABEL_43;
        }
        v23 = a4[186];
        v24 = a3[186];
      }
    }
  }
LABEL_42:
  if (v23 <= v24)
    return;
LABEL_43:
  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
  v36 = a3[186];
  v37 = a2[186];
  if (v36 == v37)
  {
    v38 = *(_QWORD *)a3;
    if (*(_QWORD *)a3)
    {
      v39 = 240 * v38;
      v40 = *((_QWORD *)a3 + 1);
      while ((*(_BYTE *)(v40 + 105) & 1) == 0)
      {
        v40 += 240;
        v39 -= 240;
        if (!v39)
          goto LABEL_63;
      }
    }
    else
    {
      v40 = *((_QWORD *)a3 + 1);
    }
    if (v40 != *((_QWORD *)a3 + 1) + 240 * v38)
    {
      v41 = *(_QWORD *)a2;
      if (*(_QWORD *)a2)
      {
        v42 = 240 * v41;
        v43 = *((_QWORD *)a2 + 1);
        while ((*(_BYTE *)(v43 + 105) & 1) == 0)
        {
          v43 += 240;
          v42 -= 240;
          if (!v42)
            goto LABEL_63;
        }
      }
      else
      {
        v43 = *((_QWORD *)a2 + 1);
      }
      if (v43 != *((_QWORD *)a2 + 1) + 240 * v41)
      {
        v44 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a3));
        v46 = v45;
        v47 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a2));
        if (v46 && v48)
        {
          if (v44 <= v47)
            return;
          goto LABEL_64;
        }
        v36 = a3[186];
        v37 = a2[186];
      }
    }
  }
LABEL_63:
  if (v36 <= v37)
    return;
LABEL_64:
  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
  v49 = a2[186];
  v50 = *(float *)(a1 + 744);
  if (v49 == v50)
  {
    v51 = *(_QWORD *)a2;
    if (*(_QWORD *)a2)
    {
      v52 = 240 * v51;
      v53 = *((_QWORD *)a2 + 1);
      while ((*(_BYTE *)(v53 + 105) & 1) == 0)
      {
        v53 += 240;
        v52 -= 240;
        if (!v52)
          goto LABEL_84;
      }
    }
    else
    {
      v53 = *((_QWORD *)a2 + 1);
    }
    if (v53 != *((_QWORD *)a2 + 1) + 240 * v51)
    {
      v54 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        v55 = 240 * v54;
        v56 = *(_QWORD *)(a1 + 8);
        while ((*(_BYTE *)(v56 + 105) & 1) == 0)
        {
          v56 += 240;
          v55 -= 240;
          if (!v55)
            goto LABEL_84;
        }
      }
      else
      {
        v56 = *(_QWORD *)(a1 + 8);
      }
      if (v56 != *(_QWORD *)(a1 + 8) + 240 * v54)
      {
        v57 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a2));
        v59 = v58;
        v60 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a1));
        if (v59 && v61)
        {
          if (v57 <= v60)
            return;
LABEL_85:
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
          return;
        }
        v49 = a2[186];
        v50 = *(float *)(a1 + 744);
      }
    }
  }
LABEL_84:
  if (v49 > v50)
    goto LABEL_85;
}

void std::__partial_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,KB::Candidate *>(KB::Candidate *a1, KB::Candidate *this, uint64_t *a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t *i;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CFStringRef v20;
  KB::Candidate *v21;
  double v22;
  char v23;
  char v24;
  double v25;
  char v26;
  BOOL v27;
  int64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  float v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  double v44;
  char v45;
  char v46;
  double v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  float v52;
  float v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  double v60;
  char v61;
  char v62;
  double v63;
  char v64;
  uint64_t *v65;
  float v66;
  float v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  double v73;
  char v74;
  char v75;
  double v76;
  char v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80[125];
  uint64_t v81;
  uint64_t v82;
  float v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  if (a1 != this)
  {
    v4 = (uint64_t *)this;
    v5 = (uint64_t)a1;
    v6 = this - a1;
    v7 = (this - a1) / 1000;
    if (this - a1 >= 1001)
    {
      v8 = (unint64_t)(v7 - 2) >> 1;
      v9 = v8 + 1;
      v10 = (uint64_t)a1 + 1000 * v8;
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(v5, v7, v10);
        v10 -= 1000;
        --v9;
      }
      while (v9);
    }
    v79 = v5;
    if (v4 != a3)
    {
      for (i = v4; i != a3; i += 125)
      {
        v12 = *((float *)i + 186);
        v13 = *(float *)(v5 + 744);
        if (v12 == v13)
        {
          v14 = *i;
          if (*i)
          {
            v15 = 240 * v14;
            v16 = i[1];
            while ((*(_BYTE *)(v16 + 105) & 1) == 0)
            {
              v16 += 240;
              v15 -= 240;
              if (!v15)
                goto LABEL_28;
            }
          }
          else
          {
            v16 = i[1];
          }
          if (v16 != i[1] + 240 * v14)
          {
            v17 = *(_QWORD *)v5;
            if (*(_QWORD *)v5)
            {
              v18 = 240 * v17;
              v19 = *(_QWORD *)(v5 + 8);
              while ((*(_BYTE *)(v19 + 105) & 1) == 0)
              {
                v19 += 240;
                v18 -= 240;
                if (!v18)
                  goto LABEL_28;
              }
            }
            else
            {
              v19 = *(_QWORD *)(v5 + 8);
            }
            if (v19 != *(_QWORD *)(v5 + 8) + 240 * v17)
            {
              v20 = KB::Candidate::named_entity_timestamp((KB::Candidate *)i);
              v21 = (KB::Candidate *)v5;
              v22 = *(double *)&v20;
              v24 = v23;
              v25 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp(v21));
              if (v24 && v26)
              {
                v27 = v22 <= v25;
                v5 = v79;
                if (v27)
                  continue;
LABEL_29:
                std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(i, (uint64_t *)v5);
                std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(v5, v7, v5);
                continue;
              }
              v12 = *((float *)i + 186);
              v5 = v79;
              v13 = *(float *)(v79 + 744);
            }
          }
        }
LABEL_28:
        if (v12 > v13)
          goto LABEL_29;
      }
    }
    if (v6 >= 1001)
    {
      v28 = v6 / 0x3E8uLL;
      do
      {
        v78 = v4;
        KB::Candidate::Candidate((uint64_t)v80, v5);
        v29 = 0;
        v30 = v5;
        do
        {
          v31 = (uint64_t *)v30;
          v32 = v29 + 1;
          v30 += 1000 * (v29 + 1);
          v33 = 2 * v29;
          v29 = (2 * v29) | 1;
          v34 = v33 + 2;
          if (v33 + 2 >= v28)
            goto LABEL_58;
          v35 = &v31[125 * v32];
          v36 = *((float *)v35 + 186);
          v37 = *(float *)(v30 + 1744);
          if (v36 != v37)
            goto LABEL_56;
          v38 = *(_QWORD *)v30;
          if (*(_QWORD *)v30)
          {
            v39 = 240 * v38;
            v40 = *(_QWORD *)(v30 + 8);
            while ((*(_BYTE *)(v40 + 105) & 1) == 0)
            {
              v40 += 240;
              v39 -= 240;
              if (!v39)
                goto LABEL_56;
            }
          }
          else
          {
            v40 = *(_QWORD *)(v30 + 8);
          }
          if (v40 == *(_QWORD *)(v30 + 8) + 240 * v38)
            goto LABEL_56;
          v41 = *(_QWORD *)(v30 + 1000);
          if (v41)
          {
            v42 = 240 * v41;
            v43 = *(_QWORD *)(v30 + 1008);
            while ((*(_BYTE *)(v43 + 105) & 1) == 0)
            {
              v43 += 240;
              v42 -= 240;
              if (!v42)
                goto LABEL_56;
            }
          }
          else
          {
            v43 = *(_QWORD *)(v30 + 1008);
          }
          if (v43 == *(_QWORD *)(v30 + 1008) + 240 * v41)
            goto LABEL_56;
          v44 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v30));
          v46 = v45;
          v47 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)(v30 + 1000)));
          if (!v46 || !v48)
          {
            v36 = *((float *)v35 + 186);
            v37 = *(float *)(v30 + 1744);
            v5 = v79;
LABEL_56:
            if (v36 <= v37)
              goto LABEL_58;
LABEL_57:
            v30 += 1000;
            v29 = v34;
            goto LABEL_58;
          }
          v27 = v44 <= v47;
          v5 = v79;
          if (!v27)
            goto LABEL_57;
LABEL_58:
          KB::Candidate::operator=(v31, (uint64_t *)v30);
        }
        while (v29 <= (uint64_t)((unint64_t)(v28 - 2) >> 1));
        v4 = v78 - 125;
        if ((uint64_t *)v30 == v78 - 125)
        {
          KB::Candidate::operator=((uint64_t *)v30, v80);
          goto LABEL_108;
        }
        KB::Candidate::operator=((uint64_t *)v30, v78 - 125);
        KB::Candidate::operator=(v4, v80);
        v49 = v30 - v5 + 1000;
        if (v49 < 1001)
          goto LABEL_108;
        v50 = (v49 / 0x3E8uLL - 2) >> 1;
        v51 = v5 + 1000 * v50;
        v52 = *(float *)(v51 + 744);
        v53 = *(float *)(v30 + 744);
        if (v52 != v53)
          goto LABEL_82;
        v54 = *(_QWORD *)v51;
        if (*(_QWORD *)v51)
        {
          v55 = 240 * v54;
          v56 = *(_QWORD *)(v51 + 8);
          while ((*(_BYTE *)(v56 + 105) & 1) == 0)
          {
            v56 += 240;
            v55 -= 240;
            if (!v55)
              goto LABEL_82;
          }
        }
        else
        {
          v56 = *(_QWORD *)(v51 + 8);
        }
        if (v56 == *(_QWORD *)(v51 + 8) + 240 * v54)
          goto LABEL_82;
        v57 = *(_QWORD *)v30;
        if (*(_QWORD *)v30)
        {
          v58 = 240 * v57;
          v59 = *(_QWORD *)(v30 + 8);
          while ((*(_BYTE *)(v59 + 105) & 1) == 0)
          {
            v59 += 240;
            v58 -= 240;
            if (!v58)
              goto LABEL_82;
          }
        }
        else
        {
          v59 = *(_QWORD *)(v30 + 8);
        }
        if (v59 == *(_QWORD *)(v30 + 8) + 240 * v57)
          goto LABEL_82;
        v60 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v51));
        v62 = v61;
        v63 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v30));
        if (!v62 || !v64)
        {
          v52 = *(float *)(v51 + 744);
          v53 = *(float *)(v30 + 744);
          v5 = v79;
LABEL_82:
          if (v52 <= v53)
            goto LABEL_108;
LABEL_83:
          KB::Candidate::Candidate((uint64_t)&v81, v30);
          while (1)
          {
            v65 = (uint64_t *)v51;
            KB::Candidate::operator=((uint64_t *)v30, (uint64_t *)v51);
            if (!v50)
            {
LABEL_107:
              KB::Candidate::operator=(v65, &v81);
              KB::Candidate::~Candidate((KB::Candidate *)&v81);
              goto LABEL_108;
            }
            v50 = (v50 - 1) >> 1;
            v51 = v5 + 1000 * v50;
            v66 = *(float *)(v51 + 744);
            v67 = v83;
            if (v66 == v83)
            {
              v68 = *(_QWORD *)v51;
              if (*(_QWORD *)v51)
              {
                v69 = 240 * v68;
                v70 = *(_QWORD *)(v51 + 8);
                while ((*(_BYTE *)(v70 + 105) & 1) == 0)
                {
                  v70 += 240;
                  v69 -= 240;
                  if (!v69)
                    goto LABEL_106;
                }
              }
              else
              {
                v70 = *(_QWORD *)(v51 + 8);
              }
              if (v70 != *(_QWORD *)(v51 + 8) + 240 * v68)
              {
                if (v81)
                {
                  v71 = 240 * v81;
                  v72 = v82;
                  while ((*(_BYTE *)(v72 + 105) & 1) == 0)
                  {
                    v72 += 240;
                    v71 -= 240;
                    if (!v71)
                      goto LABEL_106;
                  }
                }
                else
                {
                  v72 = v82;
                }
                if (v72 != v82 + 240 * v81)
                {
                  v73 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)(v5 + 1000 * v50)));
                  v75 = v74;
                  v76 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v81));
                  if (v75 && v77)
                  {
                    v27 = v73 <= v76;
                    v30 = (uint64_t)v65;
                    v5 = v79;
                    if (v27)
                      goto LABEL_107;
                    continue;
                  }
                  v66 = *(float *)(v51 + 744);
                  v67 = v83;
                  v5 = v79;
                }
              }
            }
LABEL_106:
            v30 = (uint64_t)v65;
            if (v66 <= v67)
              goto LABEL_107;
          }
        }
        v5 = v79;
        if (v60 > v63)
          goto LABEL_83;
LABEL_108:
        KB::Candidate::~Candidate((KB::Candidate *)v80);
        v27 = v28-- <= 2;
      }
      while (!v27);
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(uint64_t a1, uint64_t a2)
{
  _BOOL8 v4;
  uint64_t *v5;
  float v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  char v23;
  char v24;
  double v25;
  char v26;
  uint64_t *v27;
  uint64_t *v28;
  float v29;
  float v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  double v36;
  char v37;
  char v38;
  double v39;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  double v44;
  char v45;
  char v46;
  double v47;
  char v48;
  uint64_t v50;
  uint64_t v51;
  float v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = 1;
  switch(0x1CAC083126E978D5 * ((a2 - a1) >> 3))
  {
    case 0:
    case 1:
      return v4;
    case 2:
      v5 = (uint64_t *)(a2 - 1000);
      v6 = *(float *)(a2 - 256);
      v7 = *(float *)(a1 + 744);
      if (v6 != v7)
        goto LABEL_78;
      v8 = *v5;
      if (*v5)
      {
        v9 = 240 * v8;
        v10 = *(_QWORD *)(a2 - 992);
        while ((*(_BYTE *)(v10 + 105) & 1) == 0)
        {
          v10 += 240;
          v9 -= 240;
          if (!v9)
            goto LABEL_78;
        }
      }
      else
      {
        v10 = *(_QWORD *)(a2 - 992);
      }
      if (v10 == *(_QWORD *)(a2 - 992) + 240 * v8)
        goto LABEL_78;
      v41 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        v42 = 240 * v41;
        v43 = *(_QWORD *)(a1 + 8);
        while ((*(_BYTE *)(v43 + 105) & 1) == 0)
        {
          v43 += 240;
          v42 -= 240;
          if (!v42)
            goto LABEL_78;
        }
      }
      else
      {
        v43 = *(_QWORD *)(a1 + 8);
      }
      if (v43 == *(_QWORD *)(a1 + 8) + 240 * v41)
        goto LABEL_78;
      v44 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)(a2 - 1000)));
      v46 = v45;
      v47 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)a1));
      if (v46 && v48)
      {
        if (v44 <= v47)
          return 1;
      }
      else
      {
        v6 = *(float *)(a2 - 256);
        v7 = *(float *)(a1 + 744);
LABEL_78:
        if (v6 <= v7)
          return 1;
      }
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)(a2 - 1000));
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(a1, (KB::Candidate *)(a1 + 1000), (float *)(a2 - 1000));
      return v4;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(a1, (float *)(a1 + 1000), (float *)(a1 + 2000), (float *)(a2 - 1000));
      return v4;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *,0>(a1, (float *)(a1 + 1000), (float *)(a1 + 2000), (float *)(a1 + 3000), (float *)(a2 - 1000));
      return v4;
    default:
      v11 = a1 + 2000;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(a1, (KB::Candidate *)(a1 + 1000), (float *)(a1 + 2000));
      v12 = a1 + 3000;
      if (a1 + 3000 == a2)
        return 1;
      v13 = 0;
      break;
  }
  while (1)
  {
    v14 = *(float *)(v12 + 744);
    v15 = *(float *)(v11 + 744);
    if (v14 != v15)
      break;
    v16 = *(_QWORD *)v12;
    if (*(_QWORD *)v12)
    {
      v17 = 240 * v16;
      v18 = *(_QWORD *)(v12 + 8);
      while ((*(_BYTE *)(v18 + 105) & 1) == 0)
      {
        v18 += 240;
        v17 -= 240;
        if (!v17)
          goto LABEL_30;
      }
    }
    else
    {
      v18 = *(_QWORD *)(v12 + 8);
    }
    if (v18 == *(_QWORD *)(v12 + 8) + 240 * v16)
      break;
    v19 = *(_QWORD *)v11;
    if (*(_QWORD *)v11)
    {
      v20 = 240 * v19;
      v21 = *(_QWORD *)(v11 + 8);
      while ((*(_BYTE *)(v21 + 105) & 1) == 0)
      {
        v21 += 240;
        v20 -= 240;
        if (!v20)
          goto LABEL_30;
      }
    }
    else
    {
      v21 = *(_QWORD *)(v11 + 8);
    }
    if (v21 == *(_QWORD *)(v11 + 8) + 240 * v19)
      break;
    v22 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v12));
    v24 = v23;
    v25 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v11));
    if (!v24 || !v26)
    {
      v14 = *(float *)(v12 + 744);
      v15 = *(float *)(v11 + 744);
      break;
    }
    if (v22 > v25)
      goto LABEL_31;
LABEL_58:
    v11 = v12;
    v12 += 1000;
    if (v12 == a2)
      return 1;
  }
LABEL_30:
  if (v14 <= v15)
    goto LABEL_58;
LABEL_31:
  KB::Candidate::Candidate((uint64_t)&v50, v12);
  v27 = (uint64_t *)v12;
  while (1)
  {
    v28 = v27;
    v27 = (uint64_t *)v11;
    KB::Candidate::operator=(v28, (uint64_t *)v11);
    if (v11 == a1)
      break;
    v11 -= 1000;
    v29 = v52;
    v30 = *((float *)v27 - 64);
    if (v52 != v30)
      goto LABEL_53;
    if (v50)
    {
      v31 = 240 * v50;
      v32 = v51;
      while ((*(_BYTE *)(v32 + 105) & 1) == 0)
      {
        v32 += 240;
        v31 -= 240;
        if (!v31)
          goto LABEL_53;
      }
    }
    else
    {
      v32 = v51;
    }
    if (v32 == v51 + 240 * v50)
      goto LABEL_53;
    v33 = *(_QWORD *)v11;
    if (*(_QWORD *)v11)
    {
      v34 = 240 * v33;
      v35 = *(v27 - 124);
      while ((*(_BYTE *)(v35 + 105) & 1) == 0)
      {
        v35 += 240;
        v34 -= 240;
        if (!v34)
          goto LABEL_53;
      }
    }
    else
    {
      v35 = *(v27 - 124);
    }
    if (v35 == *(v27 - 124) + 240 * v33)
      goto LABEL_53;
    v36 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v50));
    v38 = v37;
    v39 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)(v27 - 125)));
    if (v38 && v40)
    {
      if (v36 <= v39)
        goto LABEL_56;
    }
    else
    {
      v29 = v52;
      v30 = *((float *)v27 - 64);
LABEL_53:
      if (v29 <= v30)
        goto LABEL_56;
    }
  }
  v27 = (uint64_t *)a1;
LABEL_56:
  KB::Candidate::operator=(v27, &v50);
  if (++v13 != 8)
  {
    KB::Candidate::~Candidate((KB::Candidate *)&v50);
    goto LABEL_58;
  }
  v4 = v12 + 1000 == a2;
  KB::Candidate::~Candidate((KB::Candidate *)&v50);
  return v4;
}

void std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort(void)::$_0 &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v8;
  float *v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  char v21;
  double v22;
  char v23;
  float v24;
  float v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  double v32;
  char v33;
  char v34;
  double v35;
  char v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char v50;
  char v51;
  double v52;
  char v53;
  float v54;
  float v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  double v61;
  char v62;
  char v63;
  double v64;
  char v65;
  BOOL v66;
  double v67;
  double v68;
  uint64_t v69;
  uint64_t v70;
  float v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v3 = a2 - 2;
  if (a2 >= 2)
  {
    v4 = a3;
    v6 = v3 >> 1;
    if ((uint64_t)(v3 >> 1) >= 0x1CAC083126E978D5 * ((a3 - a1) >> 3))
    {
      v8 = (0x395810624DD2F1AALL * ((a3 - a1) >> 3)) | 1;
      v9 = (float *)(a1 + 1000 * v8);
      v10 = 0x395810624DD2F1AALL * ((a3 - a1) >> 3) + 2;
      if (v10 < a2)
      {
        v11 = a1 + 1000 * v8;
        v12 = *(float *)(v11 + 744);
        v13 = v9[436];
        if (v12 == v13)
        {
          v14 = *(_QWORD *)v9;
          if (*(_QWORD *)v9)
          {
            v15 = 240 * v14;
            v16 = *((_QWORD *)v9 + 1);
            while ((*(_BYTE *)(v16 + 105) & 1) == 0)
            {
              v16 += 240;
              v15 -= 240;
              if (!v15)
                goto LABEL_24;
            }
          }
          else
          {
            v16 = *((_QWORD *)v9 + 1);
          }
          if (v16 != *((_QWORD *)v9 + 1) + 240 * v14)
          {
            v17 = *((_QWORD *)v9 + 125);
            if (v17)
            {
              v18 = 240 * v17;
              v19 = *((_QWORD *)v9 + 126);
              while ((*(_BYTE *)(v19 + 105) & 1) == 0)
              {
                v19 += 240;
                v18 -= 240;
                if (!v18)
                  goto LABEL_24;
              }
            }
            else
            {
              v19 = *((_QWORD *)v9 + 126);
            }
            if (v19 != *((_QWORD *)v9 + 126) + 240 * v17)
            {
              v67 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)(a1 + 1000 * v8)));
              v21 = v20;
              v22 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)(v9 + 250)));
              if (v21 && v23)
              {
                if (v67 <= v22)
                  goto LABEL_26;
                goto LABEL_25;
              }
              v12 = *(float *)(v11 + 744);
              v13 = v9[436];
            }
          }
        }
LABEL_24:
        if (v12 > v13)
        {
LABEL_25:
          v9 += 250;
          v8 = v10;
        }
      }
LABEL_26:
      v24 = v9[186];
      v25 = *(float *)(v4 + 744);
      if (v24 == v25)
      {
        v26 = *(_QWORD *)v9;
        if (*(_QWORD *)v9)
        {
          v27 = 240 * v26;
          v28 = *((_QWORD *)v9 + 1);
          while ((*(_BYTE *)(v28 + 105) & 1) == 0)
          {
            v28 += 240;
            v27 -= 240;
            if (!v27)
              goto LABEL_46;
          }
        }
        else
        {
          v28 = *((_QWORD *)v9 + 1);
        }
        if (v28 != *((_QWORD *)v9 + 1) + 240 * v26)
        {
          v29 = *(_QWORD *)v4;
          if (*(_QWORD *)v4)
          {
            v30 = 240 * v29;
            v31 = *(_QWORD *)(v4 + 8);
            while ((*(_BYTE *)(v31 + 105) & 1) == 0)
            {
              v31 += 240;
              v30 -= 240;
              if (!v30)
                goto LABEL_46;
            }
          }
          else
          {
            v31 = *(_QWORD *)(v4 + 8);
          }
          if (v31 != *(_QWORD *)(v4 + 8) + 240 * v29)
          {
            v32 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v9));
            v34 = v33;
            v35 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v4));
            if (v34 && v36)
            {
              if (v32 > v35)
                return;
              goto LABEL_47;
            }
            v24 = v9[186];
            v25 = *(float *)(v4 + 744);
          }
        }
      }
LABEL_46:
      if (v24 > v25)
        return;
LABEL_47:
      KB::Candidate::Candidate((uint64_t)&v69, v4);
      while (1)
      {
        v37 = (uint64_t *)v9;
        KB::Candidate::operator=((uint64_t *)v4, (uint64_t *)v9);
        if (v6 < v8)
        {
LABEL_93:
          KB::Candidate::operator=(v37, &v69);
          KB::Candidate::~Candidate((KB::Candidate *)&v69);
          return;
        }
        v38 = 2 * v8;
        v39 = (2 * v8) | 1;
        v8 = v39;
        v9 = (float *)(a1 + 1000 * v39);
        v40 = v38 + 2;
        if (v38 + 2 < a2)
        {
          v41 = a1 + 1000 * v39;
          v42 = *(float *)(v41 + 744);
          v43 = v9[436];
          if (v42 == v43)
          {
            v44 = *(_QWORD *)v9;
            if (*(_QWORD *)v9)
            {
              v45 = 240 * v44;
              v46 = *((_QWORD *)v9 + 1);
              while ((*(_BYTE *)(v46 + 105) & 1) == 0)
              {
                v46 += 240;
                v45 -= 240;
                if (!v45)
                  goto LABEL_70;
              }
            }
            else
            {
              v46 = *((_QWORD *)v9 + 1);
            }
            if (v46 != *((_QWORD *)v9 + 1) + 240 * v44)
            {
              v47 = *((_QWORD *)v9 + 125);
              if (v47)
              {
                v48 = 240 * v47;
                v49 = *((_QWORD *)v9 + 126);
                while ((*(_BYTE *)(v49 + 105) & 1) == 0)
                {
                  v49 += 240;
                  v48 -= 240;
                  if (!v48)
                    goto LABEL_70;
                }
              }
              else
              {
                v49 = *((_QWORD *)v9 + 126);
              }
              if (v49 != *((_QWORD *)v9 + 126) + 240 * v47)
              {
                v68 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v9));
                v51 = v50;
                v52 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)(v9 + 250)));
                if (v51 && v53)
                {
                  if (v68 <= v52)
                    goto LABEL_72;
LABEL_71:
                  v9 += 250;
                  v8 = v40;
                  goto LABEL_72;
                }
                v42 = *(float *)(v41 + 744);
                v43 = v9[436];
              }
            }
          }
LABEL_70:
          if (v42 > v43)
            goto LABEL_71;
        }
LABEL_72:
        v54 = v9[186];
        v55 = v71;
        if (v54 != v71)
          goto LABEL_91;
        v56 = *(_QWORD *)v9;
        if (*(_QWORD *)v9)
        {
          v57 = 240 * v56;
          v58 = *((_QWORD *)v9 + 1);
          while ((*(_BYTE *)(v58 + 105) & 1) == 0)
          {
            v58 += 240;
            v57 -= 240;
            if (!v57)
              goto LABEL_91;
          }
        }
        else
        {
          v58 = *((_QWORD *)v9 + 1);
        }
        if (v58 == *((_QWORD *)v9 + 1) + 240 * v56)
          goto LABEL_91;
        if (v69)
        {
          v59 = 240 * v69;
          v60 = v70;
          while ((*(_BYTE *)(v60 + 105) & 1) == 0)
          {
            v60 += 240;
            v59 -= 240;
            if (!v59)
              goto LABEL_91;
          }
        }
        else
        {
          v60 = v70;
        }
        if (v60 == v70 + 240 * v69)
          goto LABEL_91;
        v61 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)v9));
        v63 = v62;
        v64 = COERCE_DOUBLE(KB::Candidate::named_entity_timestamp((KB::Candidate *)&v69));
        if (!v63 || !v65)
        {
          v54 = v9[186];
          v55 = v71;
LABEL_91:
          v66 = v54 <= v55;
          goto LABEL_92;
        }
        v66 = v61 <= v64;
LABEL_92:
        v4 = (uint64_t)v37;
        if (!v66)
          goto LABEL_93;
      }
    }
  }
}

void KB::CandidateCollection::sort_by_word_score(KB::CandidateCollection *this)
{
  uint64_t *v1;
  unint64_t v2;
  uint64_t v3;

  v1 = (uint64_t *)*((_QWORD *)this + 1);
  v2 = 126 - 2 * __clz(0x1CAC083126E978D5 * (((uint64_t)v1 - *(_QWORD *)this) >> 3));
  if (v1 == *(uint64_t **)this)
    v3 = 0;
  else
    v3 = v2;
  std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *,false>(*(_QWORD *)this, v1, v3, 1);
}

void std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *,false>(uint64_t a1, uint64_t *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  float v18;
  uint64_t *v19;
  float v20;
  uint64_t *v21;
  uint64_t *v22;
  float v23;
  char v24;
  uint64_t v25;
  float v26;
  unint64_t v27;
  float v28;
  uint64_t *v29;
  uint64_t *v30;
  float v31;
  float v32;
  float v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  float v39;
  float v40;
  uint64_t v41;
  float v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47[94];
  float v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
LABEL_2:
  v8 = a1;
  while (2)
  {
    a1 = v8;
    v9 = (uint64_t)a2 - v8;
    v10 = 0x1CAC083126E978D5 * ((uint64_t)((uint64_t)a2 - v8) >> 3);
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (*((float *)a2 - 62) > *(float *)(v8 + 752))
        {
          v34 = (uint64_t *)v8;
          v35 = a2 - 125;
          goto LABEL_56;
        }
        return;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(v8, v8 + 1000, (uint64_t)(a2 - 125));
        return;
      case 4uLL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(v8, v8 + 1000, v8 + 2000, (uint64_t)(a2 - 125));
        return;
      case 5uLL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(v8, v8 + 1000, v8 + 2000, v8 + 3000);
        if (*((float *)a2 - 62) > *(float *)(v8 + 3752))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)(v8 + 3000), a2 - 125);
          if (*(float *)(v8 + 3752) > *(float *)(v8 + 2752))
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)(v8 + 2000), (uint64_t *)(v8 + 3000));
            if (*(float *)(v8 + 2752) > *(float *)(v8 + 1752))
            {
              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)(v8 + 1000), (uint64_t *)(v8 + 2000));
              if (*(float *)(v8 + 1752) > *(float *)(v8 + 752))
              {
                v34 = (uint64_t *)v8;
                v35 = (uint64_t *)(v8 + 1000);
LABEL_56:
                std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v34, v35);
              }
            }
          }
        }
        return;
      default:
        if (v9 <= 23999)
        {
          if ((a4 & 1) != 0)
          {
            if ((uint64_t *)v8 != a2)
            {
              v36 = v8 + 1000;
              if ((uint64_t *)(v8 + 1000) != a2)
              {
                v37 = 0;
                v38 = v8;
                do
                {
                  v39 = *(float *)(v38 + 1752);
                  v40 = *(float *)(v38 + 752);
                  v38 = v36;
                  if (v39 > v40)
                  {
                    KB::Candidate::Candidate((uint64_t)v47, v36);
                    v41 = v37;
                    while (1)
                    {
                      KB::Candidate::operator=((uint64_t *)(v8 + v41 + 1000), (uint64_t *)(v8 + v41));
                      if (!v41)
                        break;
                      v42 = *(float *)(v8 + v41 - 248);
                      v41 -= 1000;
                      if (v48 <= v42)
                      {
                        v43 = (uint64_t *)(v8 + v41 + 1000);
                        goto LABEL_74;
                      }
                    }
                    v43 = (uint64_t *)v8;
LABEL_74:
                    KB::Candidate::operator=(v43, v47);
                    KB::Candidate::~Candidate((KB::Candidate *)v47);
                  }
                  v36 = v38 + 1000;
                  v37 += 1000;
                }
                while ((uint64_t *)(v38 + 1000) != a2);
              }
            }
          }
          else if ((uint64_t *)v8 != a2)
          {
            v44 = v8 + 1000;
            while ((uint64_t *)v44 != a2)
            {
              v45 = v44;
              if (*(float *)(a1 + 1752) > *(float *)(a1 + 752))
              {
                KB::Candidate::Candidate((uint64_t)v47, v44);
                do
                {
                  v46 = (uint64_t *)a1;
                  KB::Candidate::operator=((uint64_t *)(a1 + 1000), (uint64_t *)a1);
                  a1 -= 1000;
                }
                while (v48 > *((float *)v46 - 62));
                KB::Candidate::operator=(v46, v47);
                KB::Candidate::~Candidate((KB::Candidate *)v47);
              }
              v44 = v45 + 1000;
              a1 = v45;
            }
          }
          return;
        }
        if (!a3)
        {
          std::__partial_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *,KB::Candidate *>(v8, a2, a2);
          return;
        }
        v11 = v10 >> 1;
        v12 = (uint64_t *)(v8 + 1000 * (v10 >> 1));
        if ((unint64_t)v9 < 0x1F401)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>((uint64_t)v12, a1, (uint64_t)(a2 - 125));
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1, (uint64_t)v12, (uint64_t)(a2 - 125));
          v13 = 1000 * v11;
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1 + 1000, v13 + a1 - 1000, (uint64_t)(a2 - 250));
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1 + 2000, a1 + 1000 + v13, (uint64_t)(a2 - 375));
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(v13 + a1 - 1000, (uint64_t)v12, a1 + 1000 + v13);
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, v12);
        }
        --a3;
        if ((a4 & 1) == 0 && *(float *)(a1 - 248) <= *(float *)(a1 + 752))
        {
          KB::Candidate::Candidate((uint64_t)v47, a1);
          if (v48 <= *((float *)a2 - 62))
          {
            v27 = a1 + 1000;
            do
            {
              v8 = v27;
              if (v27 >= (unint64_t)a2)
                break;
              v28 = *(float *)(v27 + 752);
              v27 += 1000;
            }
            while (v48 <= v28);
          }
          else
          {
            v25 = a1;
            do
            {
              v8 = v25 + 1000;
              v26 = *(float *)(v25 + 1752);
              v25 += 1000;
            }
            while (v48 <= v26);
          }
          v29 = a2;
          if (v8 < (unint64_t)a2)
          {
            v30 = a2;
            do
            {
              v29 = v30 - 125;
              v31 = *((float *)v30 - 62);
              v30 -= 125;
            }
            while (v48 > v31);
          }
          while (v8 < (unint64_t)v29)
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v8, v29);
            do
            {
              v32 = *(float *)(v8 + 1752);
              v8 += 1000;
            }
            while (v48 <= v32);
            do
            {
              v33 = *((float *)v29 - 62);
              v29 -= 125;
            }
            while (v48 > v33);
          }
          if (v8 - 1000 != a1)
            KB::Candidate::operator=((uint64_t *)a1, (uint64_t *)(v8 - 1000));
          KB::Candidate::operator=((uint64_t *)(v8 - 1000), v47);
          KB::Candidate::~Candidate((KB::Candidate *)v47);
          a4 = 0;
          continue;
        }
        KB::Candidate::Candidate((uint64_t)v47, a1);
        v14 = (uint64_t *)a1;
        do
        {
          v15 = (uint64_t)v14;
          v14 += 125;
        }
        while (*(float *)(v15 + 1752) > v48);
        v16 = a2;
        if (v15 == a1)
        {
          v19 = a2;
          while (v14 < v19)
          {
            v17 = v19 - 125;
            v20 = *((float *)v19 - 62);
            v19 -= 125;
            if (v20 > v48)
              goto LABEL_21;
          }
          v17 = v19;
        }
        else
        {
          do
          {
            v17 = v16 - 125;
            v18 = *((float *)v16 - 62);
            v16 -= 125;
          }
          while (v18 <= v48);
        }
LABEL_21:
        if (v14 < v17)
        {
          v21 = v17;
          v22 = v14;
          do
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v22, v21);
            do
            {
              v15 = (uint64_t)v22;
              v22 += 125;
            }
            while (*(float *)(v15 + 1752) > v48);
            do
            {
              v23 = *((float *)v21 - 62);
              v21 -= 125;
            }
            while (v23 <= v48);
          }
          while (v22 < v21);
        }
        if (v15 != a1)
          KB::Candidate::operator=((uint64_t *)a1, (uint64_t *)v15);
        KB::Candidate::operator=((uint64_t *)v15, v47);
        KB::Candidate::~Candidate((KB::Candidate *)v47);
        if (v14 < v17)
        {
LABEL_32:
          std::__introsort<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *,false>(a1, v15, a3, a4 & 1);
          a4 = 0;
          v8 = v15 + 1000;
          continue;
        }
        v24 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1, v15);
        v8 = v15 + 1000;
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(v15 + 1000, (uint64_t)a2))
        {
          if ((v24 & 1) != 0)
            continue;
          goto LABEL_32;
        }
        a2 = (uint64_t *)v15;
        if ((v24 & 1) == 0)
          goto LABEL_2;
        return;
    }
  }
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  float v6;
  float v7;
  uint64_t *v8;

  v5 = a1;
  v6 = *(float *)(a2 + 752);
  v7 = *(float *)(a3 + 752);
  if (v6 > *(float *)(a1 + 752))
  {
    if (v7 <= v6)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
      if (*(float *)(a3 + 752) <= *(float *)(a2 + 752))
        return;
      a1 = a2;
    }
    v8 = (uint64_t *)a3;
    goto LABEL_9;
  }
  if (v7 > v6)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
    if (*(float *)(a2 + 752) > *(float *)(v5 + 752))
    {
      a1 = v5;
      v8 = (uint64_t *)a2;
LABEL_9:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, v8);
    }
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1, a2, a3);
  if (*(float *)(a4 + 752) > *(float *)(a3 + 752))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
    if (*(float *)(a3 + 752) > *(float *)(a2 + 752))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
      if (*(float *)(a2 + 752) > *(float *)(a1 + 752))
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
    }
  }
}

void std::__partial_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *,KB::Candidate *>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  int64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t *v21;
  uint64_t v23[125];
  uint64_t v24[94];
  float v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if ((uint64_t *)a1 != a2)
  {
    v4 = a2;
    v6 = (uint64_t)a2 - a1;
    v7 = ((uint64_t)a2 - a1) / 1000;
    if ((uint64_t)a2 - a1 >= 1001)
    {
      v8 = (unint64_t)(v7 - 2) >> 1;
      v9 = v8 + 1;
      v10 = a1 + 1000 * v8;
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1, v7, v10);
        v10 -= 1000;
        --v9;
      }
      while (v9);
    }
    if (v4 != a3)
    {
      v11 = v4;
      do
      {
        if (*((float *)v11 + 188) > *(float *)(a1 + 752))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v11, (uint64_t *)a1);
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1, v7, a1);
        }
        v11 += 125;
      }
      while (v11 != a3);
    }
    if (v6 >= 1001)
    {
      v12 = v6 / 0x3E8uLL;
      do
      {
        KB::Candidate::Candidate((uint64_t)v23, a1);
        v13 = 0;
        v14 = a1;
        do
        {
          v15 = (uint64_t *)v14;
          v16 = v13 + 1;
          v14 += 1000 * (v13 + 1);
          v17 = 2 * v13;
          v13 = (2 * v13) | 1;
          v18 = v17 + 2;
          if (v18 < v12 && *(float *)&v15[125 * v16 + 94] > *(float *)(v14 + 1752))
          {
            v14 += 1000;
            v13 = v18;
          }
          KB::Candidate::operator=(v15, (uint64_t *)v14);
        }
        while (v13 <= (uint64_t)((unint64_t)(v12 - 2) >> 1));
        v4 -= 125;
        if ((uint64_t *)v14 == v4)
        {
          KB::Candidate::operator=((uint64_t *)v14, v23);
        }
        else
        {
          KB::Candidate::operator=((uint64_t *)v14, v4);
          KB::Candidate::operator=(v4, v23);
          v19 = v14 - a1 + 1000;
          if (v19 >= 1001)
          {
            v20 = (v19 / 0x3E8uLL - 2) >> 1;
            if (*(float *)(a1 + 1000 * v20 + 752) > *(float *)(v14 + 752))
            {
              KB::Candidate::Candidate((uint64_t)v24, v14);
              do
              {
                v21 = (uint64_t *)v14;
                v14 = a1 + 1000 * v20;
                KB::Candidate::operator=(v21, (uint64_t *)v14);
                if (!v20)
                  break;
                v20 = (v20 - 1) >> 1;
              }
              while (*(float *)(a1 + 1000 * v20 + 752) > v25);
              KB::Candidate::operator=((uint64_t *)v14, v24);
              KB::Candidate::~Candidate((KB::Candidate *)v24);
            }
          }
        }
        KB::Candidate::~Candidate((KB::Candidate *)v23);
      }
      while (v12-- > 2);
    }
  }
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(uint64_t a1, uint64_t a2)
{
  _BOOL8 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  uint64_t *v11;
  uint64_t v13[94];
  float v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = 1;
  switch(0x1CAC083126E978D5 * ((a2 - a1) >> 3))
  {
    case 0:
    case 1:
      return v4;
    case 2:
      if (*(float *)(a2 - 248) > *(float *)(a1 + 752))
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)(a2 - 1000));
      return v4;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1, a1 + 1000, a2 - 1000);
      return v4;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1, a1 + 1000, a1 + 2000, a2 - 1000);
      return v4;
    case 5:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1, a1 + 1000, a1 + 2000, a1 + 3000);
      if (*(float *)(a2 - 248) > *(float *)(a1 + 3752))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)(a1 + 3000), (uint64_t *)(a2 - 1000));
        if (*(float *)(a1 + 3752) > *(float *)(a1 + 2752))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)(a1 + 2000), (uint64_t *)(a1 + 3000));
          if (*(float *)(a1 + 2752) > *(float *)(a1 + 1752))
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)(a1 + 1000), (uint64_t *)(a1 + 2000));
            if (*(float *)(a1 + 1752) > *(float *)(a1 + 752))
              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)(a1 + 1000));
          }
        }
      }
      return 1;
    default:
      v5 = a1 + 2000;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(a1, a1 + 1000, a1 + 2000);
      v6 = a1 + 3000;
      if (a1 + 3000 == a2)
        return 1;
      v7 = 0;
      v8 = 0;
      break;
  }
  while (*(float *)(v6 + 752) <= *(float *)(v5 + 752))
  {
LABEL_14:
    v5 = v6;
    v7 += 1000;
    v6 += 1000;
    if (v6 == a2)
      return 1;
  }
  KB::Candidate::Candidate((uint64_t)v13, v6);
  v9 = v7;
  while (1)
  {
    KB::Candidate::operator=((uint64_t *)(a1 + v9 + 3000), (uint64_t *)(a1 + v9 + 2000));
    if (v9 == -2000)
      break;
    v10 = *(float *)(a1 + v9 + 1752);
    v9 -= 1000;
    if (v14 <= v10)
    {
      v11 = (uint64_t *)(a1 + v9 + 3000);
      goto LABEL_12;
    }
  }
  v11 = (uint64_t *)a1;
LABEL_12:
  KB::Candidate::operator=(v11, v13);
  if (++v8 != 8)
  {
    KB::Candidate::~Candidate((KB::Candidate *)v13);
    goto LABEL_14;
  }
  v4 = v6 + 1000 == a2;
  KB::Candidate::~Candidate((KB::Candidate *)v13);
  return v4;
}

void std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::CandidateCollection::sort_by_word_score(void)::$_0 &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t *v4;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12[94];
  float v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v3 = a2 - 2;
  if (a2 >= 2)
  {
    v4 = (uint64_t *)a3;
    v6 = v3 >> 1;
    if ((uint64_t)(v3 >> 1) >= 0x1CAC083126E978D5 * ((a3 - a1) >> 3))
    {
      v8 = (0x395810624DD2F1AALL * ((a3 - a1) >> 3)) | 1;
      v9 = a1 + 1000 * v8;
      if (0x395810624DD2F1AALL * ((a3 - a1) >> 3) + 2 < a2 && *(float *)(a1 + 1000 * v8 + 752) > *(float *)(v9 + 1752))
      {
        v9 += 1000;
        v8 = 0x395810624DD2F1AALL * ((a3 - a1) >> 3) + 2;
      }
      if (*(float *)(v9 + 752) <= *(float *)(a3 + 752))
      {
        KB::Candidate::Candidate((uint64_t)v12, a3);
        do
        {
          v10 = (uint64_t *)v9;
          KB::Candidate::operator=(v4, (uint64_t *)v9);
          if (v6 < v8)
            break;
          v11 = (2 * v8) | 1;
          v9 = a1 + 1000 * v11;
          if (2 * v8 + 2 < a2 && *(float *)(a1 + 1000 * v11 + 752) > *(float *)(v9 + 1752))
          {
            v9 += 1000;
            v11 = 2 * v8 + 2;
          }
          v4 = v10;
          v8 = v11;
        }
        while (*(float *)(v9 + 752) <= v13);
        KB::Candidate::operator=(v10, v12);
        KB::Candidate::~Candidate((KB::Candidate *)v12);
      }
    }
  }
}

BOOL KB::CandidateCollection::is_empty(KB::CandidateCollection *this)
{
  return *(_QWORD *)this == *((_QWORD *)this + 1)
      && *((_QWORD *)this + 6) == *((_QWORD *)this + 7)
      && *((_QWORD *)this + 9) == *((_QWORD *)this + 10);
}

void KB::CandidateCollection::normalize_scores(float32x2_t **this)
{
  float32x2_t *v1;
  float32x2_t *v2;
  float v3;
  unint64_t v4;
  float v5;
  unsigned int v6;
  uint64_t v7;
  int32x2_t v9;
  float32x2_t v10;

  v1 = *this;
  v2 = this[1];
  if (*this != v2)
  {
    v3 = v1[93].f32[0];
    v4 = 0x1CAC083126E978D5 * (v2 - v1);
    v5 = 0.0;
    if (v4 >= 2)
    {
      v6 = 2;
      v7 = 1;
      do
      {
        v5 = v5 + expf(v1[125 * v7 + 93].f32[0] - v3);
        v7 = v6;
      }
      while (v4 > v6++);
    }
    *(float *)v9.i32 = v3 + log1pf(v5);
    v10 = (float32x2_t)vdup_lane_s32(v9, 0);
    do
    {
      v1[93] = vsub_f32(v1[93], v10);
      v1 += 125;
    }
    while (v1 != v2);
  }
}

unsigned __int16 *KB::CandidateCollection::debug_data@<X0>(KB::CandidateCollection *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  BOOL v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  BOOL v17;
  unint64_t v18;
  _BYTE v20[6];
  char v21;
  void *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a2 = 0x100000;
  *(_WORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 6) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  KB::String::append((unsigned __int16 *)a2, "{linguistic={", 0xFFFFuLL);
  v4 = *(_QWORD *)this;
  if (*((_QWORD *)this + 1) != *(_QWORD *)this)
  {
    v5 = 0;
    v6 = 1;
    do
    {
      KB::Candidate::capitalized_string((KB::Candidate *)(v4 + 1000 * v5), (uint64_t)v20);
      KB::String::append((unsigned __int16 *)a2, (const KB::String *)v20);
      if (v22)
        v7 = v21 == 1;
      else
        v7 = 0;
      if (v7)
        free(v22);
      v4 = *(_QWORD *)this;
      v8 = 0x1CAC083126E978D5 * ((uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3);
      if (v8 > v6)
      {
        KB::String::append((unsigned __int16 *)a2, ", ", 0xFFFFuLL);
        v4 = *(_QWORD *)this;
        v8 = 0x1CAC083126E978D5 * ((uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3);
      }
      v5 = v6++;
    }
    while (v8 > v5);
  }
  KB::String::append((unsigned __int16 *)a2, "}, proactive={", 0xFFFFuLL);
  v9 = *((_QWORD *)this + 6);
  if (*((_QWORD *)this + 7) != v9)
  {
    v10 = 0;
    v11 = 1;
    do
    {
      KB::Candidate::capitalized_string((KB::Candidate *)(v9 + 1000 * v10), (uint64_t)v20);
      KB::String::append((unsigned __int16 *)a2, (const KB::String *)v20);
      if (v22)
        v12 = v21 == 1;
      else
        v12 = 0;
      if (v12)
        free(v22);
      v9 = *((_QWORD *)this + 6);
      v13 = 0x1CAC083126E978D5 * ((*((_QWORD *)this + 7) - v9) >> 3);
      if (v13 > v11)
      {
        KB::String::append((unsigned __int16 *)a2, ", ", 0xFFFFuLL);
        v9 = *((_QWORD *)this + 6);
        v13 = 0x1CAC083126E978D5 * ((*((_QWORD *)this + 7) - v9) >> 3);
      }
      v10 = v11++;
    }
    while (v13 > v10);
  }
  KB::String::append((unsigned __int16 *)a2, "}, exact_typed={", 0xFFFFuLL);
  v14 = *((_QWORD *)this + 9);
  if (*((_QWORD *)this + 10) != v14)
  {
    v15 = 0;
    v16 = 1;
    do
    {
      KB::Candidate::capitalized_string((KB::Candidate *)(v14 + 1000 * v15), (uint64_t)v20);
      KB::String::append((unsigned __int16 *)a2, (const KB::String *)v20);
      if (v22)
        v17 = v21 == 1;
      else
        v17 = 0;
      if (v17)
        free(v22);
      v14 = *((_QWORD *)this + 9);
      v18 = 0x1CAC083126E978D5 * ((*((_QWORD *)this + 10) - v14) >> 3);
      if (v18 > v16)
      {
        KB::String::append((unsigned __int16 *)a2, ", ", 0xFFFFuLL);
        v14 = *((_QWORD *)this + 9);
        v18 = 0x1CAC083126E978D5 * ((*((_QWORD *)this + 10) - v14) >> 3);
      }
      v15 = v16++;
    }
    while (v18 > v15);
  }
  return KB::String::append((unsigned __int16 *)a2, "}}", 0xFFFFuLL);
}

uint64_t KB::CandidateCollection::addOnlySupplementalCandidates(uint64_t result, uint64_t a2)
{
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t *v52;

  v3 = (uint64_t *)result;
  v4 = *(_QWORD **)a2;
  v5 = *(_QWORD **)(a2 + 8);
  if (*(_QWORD **)a2 != v5)
  {
    do
    {
      if (*v4)
      {
        v6 = (uint64_t *)(v4[1] + 224);
        v7 = 240 * *v4;
        while (1)
        {
          v8 = *v6;
          v6 += 30;
          if (v8)
            break;
          v7 -= 240;
          if (!v7)
            goto LABEL_20;
        }
        v9 = v3[1];
        v10 = v3[2];
        if (v9 >= v10)
        {
          v12 = 0x1CAC083126E978D5 * ((uint64_t)(v9 - *v3) >> 3);
          v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) > 0x4189374BC6A7EFLL)
LABEL_64:
            abort();
          v14 = 0x1CAC083126E978D5 * ((uint64_t)(v10 - *v3) >> 3);
          if (2 * v14 > v13)
            v13 = 2 * v14;
          if (v14 >= 0x20C49BA5E353F7)
            v15 = 0x4189374BC6A7EFLL;
          else
            v15 = v13;
          v52 = v3 + 2;
          if (v15)
            v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v15);
          else
            v16 = 0;
          v17 = v15 + 1000 * v12;
          v48 = v15;
          v49 = v17;
          v51 = v15 + 1000 * v16;
          KB::Candidate::Candidate(v17, (uint64_t)v4);
          v50 = v17 + 1000;
          std::vector<KB::Candidate>::__swap_out_circular_buffer(v3, &v48);
          v11 = v3[1];
          result = std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v48);
        }
        else
        {
          result = KB::Candidate::Candidate(v9, (uint64_t)v4);
          v11 = result + 1000;
        }
        v3[1] = v11;
      }
LABEL_20:
      v4 += 125;
    }
    while (v4 != v5);
  }
  v18 = *(_QWORD **)(a2 + 48);
  v19 = *(_QWORD **)(a2 + 56);
  if (v18 != v19)
  {
    v20 = v3 + 6;
    do
    {
      if (*v18)
      {
        v21 = (uint64_t *)(v18[1] + 224);
        v22 = 240 * *v18;
        while (1)
        {
          v23 = *v21;
          v21 += 30;
          if (v23)
            break;
          v22 -= 240;
          if (!v22)
            goto LABEL_41;
        }
        v24 = v3[7];
        v25 = v3[8];
        if (v24 >= v25)
        {
          v27 = 0x1CAC083126E978D5 * ((uint64_t)(v24 - *v20) >> 3);
          v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) > 0x4189374BC6A7EFLL)
            goto LABEL_64;
          v29 = 0x1CAC083126E978D5 * ((uint64_t)(v25 - *v20) >> 3);
          if (2 * v29 > v28)
            v28 = 2 * v29;
          if (v29 >= 0x20C49BA5E353F7)
            v30 = 0x4189374BC6A7EFLL;
          else
            v30 = v28;
          v52 = v3 + 8;
          if (v30)
            v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v30);
          else
            v31 = 0;
          v32 = v30 + 1000 * v27;
          v48 = v30;
          v49 = v32;
          v51 = v30 + 1000 * v31;
          KB::Candidate::Candidate(v32, (uint64_t)v18);
          v50 = v32 + 1000;
          std::vector<KB::Candidate>::__swap_out_circular_buffer(v3 + 6, &v48);
          v26 = v3[7];
          result = std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v48);
        }
        else
        {
          result = KB::Candidate::Candidate(v24, (uint64_t)v18);
          v26 = result + 1000;
        }
        v3[7] = v26;
      }
LABEL_41:
      v18 += 125;
    }
    while (v18 != v19);
  }
  v33 = *(_QWORD **)(a2 + 72);
  v34 = *(_QWORD **)(a2 + 80);
  if (v33 != v34)
  {
    v35 = v3 + 9;
    do
    {
      if (*v33)
      {
        v36 = (uint64_t *)(v33[1] + 224);
        v37 = 240 * *v33;
        while (1)
        {
          v38 = *v36;
          v36 += 30;
          if (v38)
            break;
          v37 -= 240;
          if (!v37)
            goto LABEL_62;
        }
        v39 = v3[10];
        v40 = v3[11];
        if (v39 >= v40)
        {
          v42 = 0x1CAC083126E978D5 * ((uint64_t)(v39 - *v35) >> 3);
          v43 = v42 + 1;
          if ((unint64_t)(v42 + 1) > 0x4189374BC6A7EFLL)
            goto LABEL_64;
          v44 = 0x1CAC083126E978D5 * ((uint64_t)(v40 - *v35) >> 3);
          if (2 * v44 > v43)
            v43 = 2 * v44;
          if (v44 >= 0x20C49BA5E353F7)
            v45 = 0x4189374BC6A7EFLL;
          else
            v45 = v43;
          v52 = v3 + 11;
          if (v45)
            v45 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v45);
          else
            v46 = 0;
          v47 = v45 + 1000 * v42;
          v48 = v45;
          v49 = v47;
          v51 = v45 + 1000 * v46;
          KB::Candidate::Candidate(v47, (uint64_t)v33);
          v50 = v47 + 1000;
          std::vector<KB::Candidate>::__swap_out_circular_buffer(v3 + 9, &v48);
          v41 = v3[10];
          result = std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v48);
        }
        else
        {
          result = KB::Candidate::Candidate(v39, (uint64_t)v33);
          v41 = result + 1000;
        }
        v3[10] = v41;
      }
LABEL_62:
      v33 += 125;
    }
    while (v33 != v34);
  }
  return result;
}

uint64_t _GLOBAL__sub_I_TIContactNameFilters_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TILanguageModelStr_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

void _GLOBAL__sub_I_TIDynamicLexiconCandidateFilters_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TIKeyboardInputManagerMecabra_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TIKeyboardInputManager_mul_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TISmartSelection_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

uint64_t _GLOBAL__sub_I_TICandidateFilter_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

void _GLOBAL__sub_I_TILanguageModel_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TIKeyboardFeatureSpecialization_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TILanguageResourcesUtil_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

uint64_t _GLOBAL__sub_I_TIRemoveAlternatesIfNoLinguisticCandidate_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

void _GLOBAL__sub_I_TICandidateFilterFactory_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TILanguageModelContainer_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

uint64_t _GLOBAL__sub_I_TIIndicUtils_cpp()
{
  KB::String::String((KB::String *)&kVowelLetterYAPHALAA_beng, "");
  __cxa_atexit((void (*)(void *))KB::String::~String, &kVowelLetterYAPHALAA_beng, &dword_1DA6F2000);
  KB::String::String((KB::String *)&kVowelLetterYAPHALAA_orya, "");
  __cxa_atexit((void (*)(void *))KB::String::~String, &kVowelLetterYAPHALAA_orya, &dword_1DA6F2000);
  KB::String::String((KB::String *)&kVowelSignYAPHALAA_beng, "");
  __cxa_atexit((void (*)(void *))KB::String::~String, &kVowelSignYAPHALAA_beng, &dword_1DA6F2000);
  KB::String::String((KB::String *)&kVowelSignYAPHALAA_orya, "");
  return __cxa_atexit((void (*)(void *))KB::String::~String, &kVowelSignYAPHALAA_orya, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TIInputManagerSpecialization_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TIInputManager_translit_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TIInputManager_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TICandidateFilterLibrary_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_CPSearchNode_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TIContinuousPathCandidateFilters_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

void _GLOBAL__sub_I_TILanguageModelLoader_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

uint64_t _GLOBAL__sub_I_TIMultilingualCandidateFilters_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TIBasicStrokeBuildManager_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TILanguageModelImplBase_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TICandidateFilterFlags_cpp()
{
  KB::String::String((KB::String *)&kGenericFlagDesc, "Generic Filter Stack");
  __cxa_atexit((void (*)(void *))KB::String::~String, &kGenericFlagDesc, &dword_1DA6F2000);
  KB::String::String((KB::String *)&kPreLMFlagDesc, "Pre LM Filter Stack");
  __cxa_atexit((void (*)(void *))KB::String::~String, &kPreLMFlagDesc, &dword_1DA6F2000);
  KB::String::String((KB::String *)&kPostLMFlagDesc, "Post LM Filter Stack");
  return __cxa_atexit((void (*)(void *))KB::String::~String, &kPostLMFlagDesc, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TICandidateFilter_Indic_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_CPContextualShapeRecognizer_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

void _GLOBAL__sub_I_TIKeyboardInputManager_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

uint64_t _GLOBAL__sub_I_TIMutatingCandidateFilters_cpp()
{
  unint64_t v0;
  uint64_t v1;
  uint64_t **v2;
  int v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  unsigned __int8 **v11;
  unsigned __int8 *i;
  unint64_t v13;
  char *v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  int8x8_t prime;
  void *v20;
  void *v21;
  uint64_t v22;
  _QWORD **v23;
  unint64_t v24;
  uint8x8_t v25;
  unint64_t v26;
  uint8x8_t v27;
  uint64_t v28;
  _QWORD *j;
  unint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  void *v34;
  uint64_t k;
  _QWORD *v36;
  _QWORD v38[3];
  _QWORD v39[3];
  _QWORD v40[3];
  _QWORD v41[4];

  v41[3] = *MEMORY[0x1E0C80C00];
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  v0 = (unint64_t)v38;
  std::string::basic_string[abi:nn180100]<0>(v38, "u");
  std::string::basic_string[abi:nn180100]<0>(v39, "you");
  std::string::basic_string[abi:nn180100]<0>(v40, "o");
  std::string::basic_string[abi:nn180100]<0>(v41, "oh");
  v1 = 0;
  KB::RescoreShortWords::short_word_map = 0u;
  *(_OWORD *)&qword_1EDAEE838 = 0u;
  dword_1EDAEE848 = 1065353216;
  do
  {
    v2 = (uint64_t **)&v38[6 * v1];
    v3 = *((char *)v2 + 23);
    if (v3 >= 0)
      v4 = &v38[6 * v1];
    else
      v4 = *v2;
    if (v3 >= 0)
      v5 = *((unsigned __int8 *)v2 + 23);
    else
      v5 = (unint64_t)v2[1];
    v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v4, v5);
    v7 = v6;
    v8 = *((_QWORD *)&KB::RescoreShortWords::short_word_map + 1);
    if (*((_QWORD *)&KB::RescoreShortWords::short_word_map + 1))
    {
      v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&KB::RescoreShortWords::short_word_map + 8));
      v9.i16[0] = vaddlv_u8(v9);
      v10 = v9.u32[0];
      if (v9.u32[0] > 1uLL)
      {
        v0 = v6;
        if (v6 >= *((_QWORD *)&KB::RescoreShortWords::short_word_map + 1))
          v0 = v6 % *((_QWORD *)&KB::RescoreShortWords::short_word_map + 1);
      }
      else
      {
        v0 = (*((_QWORD *)&KB::RescoreShortWords::short_word_map + 1) - 1) & v6;
      }
      v11 = *(unsigned __int8 ***)(KB::RescoreShortWords::short_word_map + 8 * v0);
      if (v11)
      {
        for (i = *v11; i; i = *(unsigned __int8 **)i)
        {
          v13 = *((_QWORD *)i + 1);
          if (v13 == v7)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)&v38[6 * v1]))
              goto LABEL_80;
          }
          else
          {
            if (v10 > 1)
            {
              if (v13 >= v8)
                v13 %= v8;
            }
            else
            {
              v13 &= v8 - 1;
            }
            if (v13 != v0)
              break;
          }
        }
      }
    }
    v14 = (char *)operator new(0x40uLL);
    *(_QWORD *)v14 = 0;
    *((_QWORD *)v14 + 1) = v7;
    std::pair<std::string const,std::string>::pair[abi:nn180100]((std::string *)(v14 + 16), (__int128 *)&v38[6 * v1]);
    v15 = (float)(unint64_t)(qword_1EDAEE840 + 1);
    if (!v8 || (float)(*(float *)&dword_1EDAEE848 * (float)v8) < v15)
    {
      v16 = (v8 & (v8 - 1)) != 0;
      if (v8 < 3)
        v16 = 1;
      v17 = v16 | (2 * v8);
      v18 = vcvtps_u32_f32(v15 / *(float *)&dword_1EDAEE848);
      if (v17 <= v18)
        prime = (int8x8_t)v18;
      else
        prime = (int8x8_t)v17;
      if (*(_QWORD *)&prime == 1)
      {
        prime = (int8x8_t)2;
      }
      else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
      {
        prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      }
      v8 = *((_QWORD *)&KB::RescoreShortWords::short_word_map + 1);
      if (*(_QWORD *)&prime > *((_QWORD *)&KB::RescoreShortWords::short_word_map + 1))
        goto LABEL_36;
      if (*(_QWORD *)&prime < *((_QWORD *)&KB::RescoreShortWords::short_word_map + 1))
      {
        v26 = vcvtps_u32_f32((float)(unint64_t)qword_1EDAEE840 / *(float *)&dword_1EDAEE848);
        if (*((_QWORD *)&KB::RescoreShortWords::short_word_map + 1) < 3uLL
          || (v27 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&KB::RescoreShortWords::short_word_map + 8)),
              v27.i16[0] = vaddlv_u8(v27),
              v27.u32[0] > 1uLL))
        {
          v26 = std::__next_prime(v26);
        }
        else
        {
          v28 = 1 << -(char)__clz(v26 - 1);
          if (v26 >= 2)
            v26 = v28;
        }
        if (*(_QWORD *)&prime <= v26)
          prime = (int8x8_t)v26;
        if (*(_QWORD *)&prime >= v8)
        {
          v8 = *((_QWORD *)&KB::RescoreShortWords::short_word_map + 1);
        }
        else
        {
          if (prime)
          {
LABEL_36:
            if (*(_QWORD *)&prime >> 61)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v20 = operator new(8 * *(_QWORD *)&prime);
            v21 = (void *)KB::RescoreShortWords::short_word_map;
            *(_QWORD *)&KB::RescoreShortWords::short_word_map = v20;
            if (v21)
              operator delete(v21);
            v22 = 0;
            *((int8x8_t *)&KB::RescoreShortWords::short_word_map + 1) = prime;
            do
              *(_QWORD *)(KB::RescoreShortWords::short_word_map + 8 * v22++) = 0;
            while (*(_QWORD *)&prime != v22);
            v23 = (_QWORD **)qword_1EDAEE838;
            if (qword_1EDAEE838)
            {
              v24 = *(_QWORD *)(qword_1EDAEE838 + 8);
              v25 = (uint8x8_t)vcnt_s8(prime);
              v25.i16[0] = vaddlv_u8(v25);
              if (v25.u32[0] > 1uLL)
              {
                if (v24 >= *(_QWORD *)&prime)
                  v24 %= *(_QWORD *)&prime;
              }
              else
              {
                v24 &= *(_QWORD *)&prime - 1;
              }
              *(_QWORD *)(KB::RescoreShortWords::short_word_map + 8 * v24) = &qword_1EDAEE838;
              for (j = *v23; j; v24 = v30)
              {
                v30 = j[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(_QWORD *)&prime)
                    v30 %= *(_QWORD *)&prime;
                }
                else
                {
                  v30 &= *(_QWORD *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(_QWORD *)(KB::RescoreShortWords::short_word_map + 8 * v30))
                  {
                    *(_QWORD *)(KB::RescoreShortWords::short_word_map + 8 * v30) = v23;
                    goto LABEL_61;
                  }
                  *v23 = (_QWORD *)*j;
                  *j = **(_QWORD **)(KB::RescoreShortWords::short_word_map + 8 * v30);
                  **(_QWORD **)(KB::RescoreShortWords::short_word_map + 8 * v30) = j;
                  j = v23;
                }
                v30 = v24;
LABEL_61:
                v23 = (_QWORD **)j;
                j = (_QWORD *)*j;
              }
            }
            v8 = (unint64_t)prime;
            goto LABEL_65;
          }
          v34 = (void *)KB::RescoreShortWords::short_word_map;
          *(_QWORD *)&KB::RescoreShortWords::short_word_map = 0;
          if (v34)
            operator delete(v34);
          v8 = 0;
          *((_QWORD *)&KB::RescoreShortWords::short_word_map + 1) = 0;
        }
      }
LABEL_65:
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v7 >= v8)
          v0 = v7 % v8;
        else
          v0 = v7;
      }
      else
      {
        v0 = (v8 - 1) & v7;
      }
    }
    v31 = KB::RescoreShortWords::short_word_map;
    v32 = *(_QWORD **)(KB::RescoreShortWords::short_word_map + 8 * v0);
    if (v32)
    {
      *(_QWORD *)v14 = *v32;
LABEL_78:
      *v32 = v14;
      goto LABEL_79;
    }
    *(_QWORD *)v14 = qword_1EDAEE838;
    qword_1EDAEE838 = (uint64_t)v14;
    *(_QWORD *)(v31 + 8 * v0) = &qword_1EDAEE838;
    if (*(_QWORD *)v14)
    {
      v33 = *(_QWORD *)(*(_QWORD *)v14 + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v33 >= v8)
          v33 %= v8;
      }
      else
      {
        v33 &= v8 - 1;
      }
      v32 = (_QWORD *)(KB::RescoreShortWords::short_word_map + 8 * v33);
      goto LABEL_78;
    }
LABEL_79:
    ++qword_1EDAEE840;
LABEL_80:
    ++v1;
  }
  while (v1 != 2);
  for (k = 0; k != -12; k -= 6)
  {
    v36 = &v38[k];
    if (SHIBYTE(v41[k + 2]) < 0)
      operator delete((void *)v36[9]);
    if (*((char *)v36 + 71) < 0)
      operator delete((void *)v36[6]);
  }
  return __cxa_atexit((void (*)(void *))std::unordered_map<std::string,std::string>::~unordered_map[abi:nn180100], &KB::RescoreShortWords::short_word_map, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TIInputRecognizer_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TIFavoniusStrokeBuildManager_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TICPathRecognizerEnsemble_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

void _GLOBAL__sub_I_MCDrawInput_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TIKeyboardInputManagerTransliteration_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TILanguageModelImplStub_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TILanguageSelectionController_mm()
{
  void *v0;
  int v1;
  uint64_t v2;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  v1 = _os_feature_enabled_impl();
  v2 = 2;
  if (v1)
    v2 = 3;
  TILSCMaximumActiveInputModes = v2;
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TIKeyboardInputManagerIndic_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

uint64_t _GLOBAL__sub_I_TICandidateFilterResources_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

void _GLOBAL__sub_I_TILanguageModelOfflineLearningTask_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TIKeyboardInputManager_Learning_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

uint64_t _GLOBAL__sub_I_TICandidateFilterConfiguration_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_CPSearch_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

void _GLOBAL__sub_I_TITypologyLogger_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

void _GLOBAL__sub_I_TIKeyboardInputManager_InlineCompletions_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x1DF0A2708]();
  __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
  objc_autoreleasePoolPop(v0);
}

uint64_t _GLOBAL__sub_I_TICompositeCandidateFilter_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TICandidateRefinery_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t _GLOBAL__sub_I_TIChooseTopQualityAutocorrection_cpp()
{
  return __cxa_atexit((void (*)(void *))KB::LikelihoodInfo::~LikelihoodInfo, &KB::k_invalid_likelihood_value, &dword_1DA6F2000);
}

uint64_t BMKeyboardTokenFrequencyTokenTypeAsString()
{
  return MEMORY[0x1E0D01D78]();
}

uint64_t BMKeyboardTokenFrequencyTokenTypeFromString()
{
  return MEMORY[0x1E0D01D80]();
}

uint64_t BiomeLibrary()
{
  return MEMORY[0x1E0D01E18]();
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x1E0C80330](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x1E0C80338](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1E0C80340](c, data, *(_QWORD *)&len);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x1E0C80370](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x1E0C80378](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1E0C80380](c, data, *(_QWORD *)&len);
}

uint64_t CEMCreateEmojiLocaleData()
{
  return MEMORY[0x1E0D15CE8]();
}

uint64_t CEMEmojiLocaleDataCreateEmojiTokensForString()
{
  return MEMORY[0x1E0D15D10]();
}

uint64_t CEMEmojiLocaleDataGetLocaleIdentifier()
{
  return MEMORY[0x1E0D15D20]();
}

uint64_t CEMEmojiTokenCopyRelatedEmoji()
{
  return MEMORY[0x1E0D15D30]();
}

uint64_t CEMEmojiTokenCreateWithString()
{
  return MEMORY[0x1E0D15D58]();
}

uint64_t CEMEmojiTokenGetString()
{
  return MEMORY[0x1E0D15D90]();
}

uint64_t CEMEnumerateEmojiTokensInStringWithBlock()
{
  return MEMORY[0x1E0D15DA8]();
}

uint64_t CEMStringContainsEmoji()
{
  return MEMORY[0x1E0D15DC0]();
}

uint64_t CEMStringIsSingleEmoji()
{
  return MEMORY[0x1E0D15DC8]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  return (CFAllocatorRef)MEMORY[0x1E0C97CC0]();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  MEMORY[0x1E0C97CE8](theArray, otherArray, otherRange.location, otherRange.length);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  MEMORY[0x1E0C97DB8](theArray);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DD0](theArray, idx, value);
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  return (CFAttributedStringRef)MEMORY[0x1E0C97DF0](alloc, str, attributes);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1E0C98080](bundle, resourceName, resourceType, subDirName);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1E0C980E8](bundleID);
}

uint64_t CFBurstTrieContains()
{
  return MEMORY[0x1E0C981D0]();
}

uint64_t CFBurstTrieCreate()
{
  return MEMORY[0x1E0C981E0]();
}

uint64_t CFBurstTrieCreateFromMapBytes()
{
  return MEMORY[0x1E0C981F0]();
}

uint64_t CFBurstTrieGetCount()
{
  return MEMORY[0x1E0C98200]();
}

uint64_t CFBurstTrieRelease()
{
  return MEMORY[0x1E0C98208]();
}

uint64_t CFBurstTrieSerializeWithFileDescriptor()
{
  return MEMORY[0x1E0C98218]();
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982F0](theSetIdentifier);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return MEMORY[0x1E0C98320](theSet, theChar);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x1E0C985A0](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  MEMORY[0x1E0C985D8](theDict);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1E0C98630](err);
}

CFStringRef CFErrorCopyFailureReason(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1E0C98638](err);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x1E0C98770]();
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1E0C98798](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleGetIdentifier(CFLocaleRef locale)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987D8](locale);
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)MEMORY[0x1E0C98800](locale, key);
}

uint64_t CFLog()
{
  return MEMORY[0x1E0C98808]();
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x1E0C988B0](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988B8]();
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  MEMORY[0x1E0C98900](center, observer, name, object);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1E0C989A8](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x1E0C98A30](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A40](key, applicationID);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A70](key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A78](key, applicationID, keyExistsAndHasValidFormat);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
  MEMORY[0x1E0C98A80](key, value, applicationID);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AE0](allocator, stream, streamLength, options, format, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  MEMORY[0x1E0C98B10](stream);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1E0C98B48](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1E0C98B80](stream);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98BF8](rl, source, mode);
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1E0C98C30]();
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x1E0C98ED8](theString, appendedString);
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
  MEMORY[0x1E0C98EE0](theString, cStr, *(_QWORD *)&encoding);
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
  MEMORY[0x1E0C98EE8](theString, chars, numChars);
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  MEMORY[0x1E0C98EF0](theString, formatOptions, format);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1E0C98F68](alloc, theArray, separatorString);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F90](alloc, maxLength);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1E0C98FB8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FC8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99030](alloc, str, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99050](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1E0C99080](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1E0C990B0](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  MEMORY[0x1E0C990C0](theString, range.location, range.length, buffer);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C990E0](string, buffer, maxBufLen);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99118](length, *(_QWORD *)&encoding);
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  return MEMORY[0x1E0C99128](string);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x1E0C99168]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1E0C99180](theString, prefix);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x1E0C991D0](theString, locale);
}

CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(CFStringTokenizerRef tokenizer)
{
  return MEMORY[0x1E0C99208](tokenizer);
}

CFStringRef CFStringTokenizerCopyBestStringLanguage(CFStringRef string, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99210](string, range.location, range.length);
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringTokenizerRef)MEMORY[0x1E0C99220](alloc, string, range.location, range.length, options, locale);
}

CFRange CFStringTokenizerGetCurrentTokenRange(CFStringTokenizerRef tokenizer)
{
  CFIndex v1;
  CFIndex v2;
  CFRange result;

  v1 = MEMORY[0x1E0C99230](tokenizer);
  result.length = v2;
  result.location = v1;
  return result;
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  return MEMORY[0x1E0C99248](string, range, transform, reverse);
}

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x1E0C99260](theString, locale);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1E0C992D8](anURL, pathStyle);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C992F8](url);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C99320](url);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99380](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C993C8](allocator, buffer, bufLen, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99448](allocator, URLString, baseURL);
}

Boolean CFURLResourceIsReachable(CFURLRef url, CFErrorRef *error)
{
  return MEMORY[0x1E0C994D0](url, error);
}

Boolean CFURLSetResourcePropertyForKey(CFURLRef url, CFStringRef key, CFTypeRef propertyValue, CFErrorRef *error)
{
  return MEMORY[0x1E0C994E0](url, key, propertyValue, error);
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  return MEMORY[0x1E0C995A0](userNotification);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return (CFUserNotificationRef)MEMORY[0x1E0C995A8](allocator, flags, error, dictionary, timeout);
}

CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource(CFAllocatorRef allocator, CFUserNotificationRef userNotification, CFUserNotificationCallBack callout, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x1E0C995B8](allocator, userNotification, callout, order);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x1E0C9BB10](data, width, height, bitsPerComponent, bytesPerRow, space, *(_QWORD *)&bitmapInfo);
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  return (CGImageRef)MEMORY[0x1E0C9BB20](context);
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x1E0C9BC78](space, components);
}

void CGColorRelease(CGColorRef color)
{
  MEMORY[0x1E0C9BD60](color);
}

CGColorRef CGColorRetain(CGColorRef color)
{
  return (CGColorRef)MEMORY[0x1E0C9BD68](color);
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BDF0]();
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  MEMORY[0x1E0C9C170](c, image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextRelease(CGContextRef c)
{
  MEMORY[0x1E0C9C340](c);
}

void CGContextRestoreGState(CGContextRef c)
{
  MEMORY[0x1E0C9C370](c);
}

void CGContextSaveGState(CGContextRef c)
{
  MEMORY[0x1E0C9C388](c);
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
  MEMORY[0x1E0C9C390](c, sx, sy);
}

void CGContextSetInterpolationQuality(CGContextRef c, CGInterpolationQuality quality)
{
  MEMORY[0x1E0C9C458](c, *(_QWORD *)&quality);
}

void CGContextSetTextMatrix(CGContextRef c, CGAffineTransform *t)
{
  MEMORY[0x1E0C9C530](c, t);
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9C538](c, x, y);
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
  MEMORY[0x1E0C9C588](c, tx, ty);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9CC20](image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x1E0C9CC60](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x1E0C9CCD0](image);
}

void CGImageRelease(CGImageRef image)
{
  MEMORY[0x1E0C9CDA0](image);
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x1E0CBC568](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithData(CFDataRef data, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x1E0CBC590](data, options);
}

BOOL CGRectContainsPoint(CGRect rect, CGPoint point)
{
  return MEMORY[0x1E0C9D550]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, (__n128)point, *(__n128 *)&point.y);
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1E0C9D570]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D580]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D588]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5A0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5A8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5B0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5C0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5C8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5D0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

BOOL CGRectIsNull(CGRect rect)
{
  return MEMORY[0x1E0C9D618]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D640]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

uint64_t CPSharedResourcesDirectory()
{
  return MEMORY[0x1E0CFA6C0]();
}

CFArrayRef CTFontCopyDefaultCascadeListForLanguages(CTFontRef font, CFArrayRef languagePrefList)
{
  return (CFArrayRef)MEMORY[0x1E0CA7980](font, languagePrefList);
}

CTFontRef CTFontCreateCopyWithAttributes(CTFontRef font, CGFloat size, const CGAffineTransform *matrix, CTFontDescriptorRef attributes)
{
  return (CTFontRef)MEMORY[0x1E0CA7A30](font, matrix, attributes, size);
}

CTFontRef CTFontCreateUIFontForLanguage(CTFontUIFontType uiType, CGFloat size, CFStringRef language)
{
  return (CTFontRef)MEMORY[0x1E0CA7A68](*(_QWORD *)&uiType, language, size);
}

CTFontRef CTFontCreateWithName(CFStringRef name, CGFloat size, const CGAffineTransform *matrix)
{
  return (CTFontRef)MEMORY[0x1E0CA7A88](name, matrix, size);
}

CFTypeRef CTFontDescriptorCopyAttribute(CTFontDescriptorRef descriptor, CFStringRef attribute)
{
  return (CFTypeRef)MEMORY[0x1E0CA7AA0](descriptor, attribute);
}

CTFontDescriptorRef CTFontDescriptorCreateWithAttributes(CFDictionaryRef attributes)
{
  return (CTFontDescriptorRef)MEMORY[0x1E0CA7B00](attributes);
}

uint64_t CTFontDescriptorCreateWithAttributesAndOptions()
{
  return MEMORY[0x1E0CA7B08]();
}

BOOL CTFontGetGlyphsForCharacters(CTFontRef font, const UniChar *characters, CGGlyph *glyphs, CFIndex count)
{
  return MEMORY[0x1E0CA7C08](font, characters, glyphs, count);
}

CGFloat CTFontGetSize(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x1E0CA7C50](font);
  return result;
}

uint64_t CTFontInitializeShapingGlyphs()
{
  return MEMORY[0x1E0CA7CF0]();
}

uint64_t CTFontShapeGlyphs()
{
  return MEMORY[0x1E0CA7D70]();
}

CTLineRef CTLineCreateTruncatedLine(CTLineRef line, double width, CTLineTruncationType truncationType, CTLineRef truncationToken)
{
  return (CTLineRef)MEMORY[0x1E0CA7E70](line, *(_QWORD *)&truncationType, truncationToken, width);
}

CTLineRef CTLineCreateWithAttributedString(CFAttributedStringRef attrString)
{
  return (CTLineRef)MEMORY[0x1E0CA7E88](attrString);
}

uint64_t CTLineCreateWithRunArray()
{
  return MEMORY[0x1E0CA7E90]();
}

void CTLineDraw(CTLineRef line, CGContextRef context)
{
  MEMORY[0x1E0CA7EA8](line, context);
}

CFArrayRef CTLineGetGlyphRuns(CTLineRef line)
{
  return (CFArrayRef)MEMORY[0x1E0CA7ED8](line);
}

double CTLineGetTypographicBounds(CTLineRef line, CGFloat *ascent, CGFloat *descent, CGFloat *leading)
{
  double result;

  MEMORY[0x1E0CA7F18](line, ascent, descent, leading);
  return result;
}

uint64_t CacheDeleteRegisterInfoCallbacks()
{
  return MEMORY[0x1E0D09B98]();
}

uint64_t DDResultGetCategory()
{
  return MEMORY[0x1E0D1CC90]();
}

uint64_t DDResultGetRangeForURLification()
{
  return MEMORY[0x1E0D1CCD8]();
}

uint64_t DMGetUserDataDisposition()
{
  return MEMORY[0x1E0D1CF98]();
}

uint64_t ICLXEntryGetEntities()
{
  return MEMORY[0x1E0D3AB60]();
}

uint64_t ICLXEntryGetTransientLexicon()
{
  return MEMORY[0x1E0D3AB68]();
}

uint64_t ITCandidateCopyPrefix()
{
  return MEMORY[0x1E0D3AB98]();
}

uint64_t ITCandidateGetScore()
{
  return MEMORY[0x1E0D3ABA0]();
}

uint64_t ITCandidateGetString()
{
  return MEMORY[0x1E0D3ABA8]();
}

uint64_t ITCandidateGetStrokedPath()
{
  return MEMORY[0x1E0D3ABB0]();
}

uint64_t ITCandidateGetUnshiftMask()
{
  return MEMORY[0x1E0D3ABB8]();
}

uint64_t ITCandidateIsCompletion()
{
  return MEMORY[0x1E0D3ABC0]();
}

uint64_t ITCandidateIsMultiWord()
{
  return MEMORY[0x1E0D3ABC8]();
}

uint64_t ITCandidateIsValidWord()
{
  return MEMORY[0x1E0D3ABD0]();
}

uint64_t ITTouchTranscoderAddLexicon()
{
  return MEMORY[0x1E0D3ABE0]();
}

uint64_t ITTouchTranscoderCreateSession()
{
  return MEMORY[0x1E0D3ABE8]();
}

uint64_t ITTouchTranscoderCreateWithKeyboardLayout()
{
  return MEMORY[0x1E0D3ABF0]();
}

uint64_t ITTouchTranscoderProvidesCompletionCandidates()
{
  return MEMORY[0x1E0D3ABF8]();
}

uint64_t ITTouchTranscoderRemoveLexicon()
{
  return MEMORY[0x1E0D3AC00]();
}

uint64_t ITTouchTranscoderSessionAddEventWithTouchKeyInfo()
{
  return MEMORY[0x1E0D3AC08]();
}

uint64_t ITTouchTranscoderSessionEnumerateCandidatesWithOptions()
{
  return MEMORY[0x1E0D3AC10]();
}

uint64_t ITTouchTranscoderSupportsConfiguration()
{
  return MEMORY[0x1E0D3AC18]();
}

uint64_t ITTouchTranscoderSupportsLocaleAndLayout()
{
  return MEMORY[0x1E0D3AC20]();
}

uint64_t ITTouchTranscoderUpdateKeyboardLayout()
{
  return MEMORY[0x1E0D3AC28]();
}

uint64_t IXACanLogMessageAtLevel()
{
  return MEMORY[0x1E0DBDAE8]();
}

uint64_t IXADefaultLogFacility()
{
  return MEMORY[0x1E0DBDAF0]();
}

uint64_t IXAFeedbackLogFacility()
{
  return MEMORY[0x1E0DBDAF8]();
}

uint64_t IXASessionDetailsLogFacility()
{
  return MEMORY[0x1E0DBDB00]();
}

uint64_t IXASessionEventsLogFacility()
{
  return MEMORY[0x1E0DBDB08]();
}

uint64_t LDEnumerateAssetDataItems()
{
  return MEMORY[0x1E0D43820]();
}

uint64_t LMLanguageLikelihoodModelAddEvidenceForLanguage()
{
  return MEMORY[0x1E0D42C20]();
}

uint64_t LMLanguageLikelihoodModelGetEmojiUsageCountForApp()
{
  return MEMORY[0x1E0D42C28]();
}

uint64_t LMLanguageLikelihoodModelGetLanguagePriorProbabilities()
{
  return MEMORY[0x1E0D42C30]();
}

uint64_t LMLanguageLikelihoodModelGetLastOfflineAdaptationTime()
{
  return MEMORY[0x1E0D42C38]();
}

uint64_t LMLanguageLikelihoodModelGetUserModel()
{
  return MEMORY[0x1E0D42C40]();
}

uint64_t LMLanguageModelCreateStringForSpecialTokenID()
{
  return MEMORY[0x1E0D42C88]();
}

uint64_t LMLanguageModelPerformMaintenance()
{
  return MEMORY[0x1E0D42CE8]();
}

uint64_t LMLanguageModelRemoveModelBundlesInDirectory()
{
  return MEMORY[0x1E0D42D08]();
}

uint64_t LMLexiconIDConverterCreateWithUnigramsPath()
{
  return MEMORY[0x1E0D42DA0]();
}

uint64_t LMLexiconIDConverterDestroy()
{
  return MEMORY[0x1E0D42DA8]();
}

uint64_t LMLexiconIDConverterGetStemData()
{
  return MEMORY[0x1E0D42DB0]();
}

uint64_t LMLexiconIDConverterGetStemSuffixTokenID()
{
  return MEMORY[0x1E0D42DB8]();
}

uint64_t LMLexiconIDConverterGetSuffixData()
{
  return MEMORY[0x1E0D42DC0]();
}

uint64_t LMStreamTokenizerCopyBestStringLanguage()
{
  return MEMORY[0x1E0D42DF0]();
}

uint64_t LMStreamTokenizerCreate()
{
  return MEMORY[0x1E0D42DF8]();
}

uint64_t LMStreamTokenizerPopBytes()
{
  return MEMORY[0x1E0D42E00]();
}

uint64_t LMStreamTokenizerPushBytes()
{
  return MEMORY[0x1E0D42E08]();
}

uint64_t LMStreamTokenizerRelease()
{
  return MEMORY[0x1E0D42E10]();
}

uint64_t LMStreamTokenizerReset()
{
  return MEMORY[0x1E0D42E18]();
}

uint64_t LMVocabularyAddLemma()
{
  return MEMORY[0x1E0D42E20]();
}

uint64_t LMVocabularyEnumerateInflectionsOfLemma()
{
  return MEMORY[0x1E0D42E38]();
}

uint64_t LMVocabularyGetClassForTokenID()
{
  return MEMORY[0x1E0D42E40]();
}

uint64_t LMVocabularyGetSharedVocabulary()
{
  return MEMORY[0x1E0D42E48]();
}

uint64_t LMVocabularyGetTokenIDForLemma()
{
  return MEMORY[0x1E0D42E50]();
}

uint64_t LMVocabularyReset()
{
  return MEMORY[0x1E0D42E58]();
}

uint64_t LMVocabularySetLanguages()
{
  return MEMORY[0x1E0D42E60]();
}

uint64_t LXCursorConditionalProbability()
{
  return MEMORY[0x1E0D43530]();
}

uint64_t LXCursorCreateByAdvancingWithUTF8()
{
  return MEMORY[0x1E0D43548]();
}

uint64_t LXCursorEnumerateChildren()
{
  return MEMORY[0x1E0D43550]();
}

uint64_t LXCursorEnumerateEntries()
{
  return MEMORY[0x1E0D43558]();
}

uint64_t LXCursorEnumerateEntriesRecursively()
{
  return MEMORY[0x1E0D43560]();
}

uint64_t LXCursorHasChildren()
{
  return MEMORY[0x1E0D43570]();
}

uint64_t LXCursorHasEntries()
{
  return MEMORY[0x1E0D43578]();
}

uint64_t LXCursorIsRoot()
{
  return MEMORY[0x1E0D43588]();
}

uint64_t LXCursorLastTraversedCharacter()
{
  return MEMORY[0x1E0D43590]();
}

uint64_t LXCursorTerminatesWordStem()
{
  return MEMORY[0x1E0D435A0]();
}

uint64_t LXCursorTerminationProbability()
{
  return MEMORY[0x1E0D435A8]();
}

uint64_t LXCursorUsageCount()
{
  return MEMORY[0x1E0D435B0]();
}

uint64_t LXCursorUsageCountRecursive()
{
  return MEMORY[0x1E0D435B8]();
}

uint64_t LXEntryCopyStoredString()
{
  return MEMORY[0x1E0D435C0]();
}

uint64_t LXEntryCopyString()
{
  return MEMORY[0x1E0D435C8]();
}

uint64_t LXEntryCreateMutable()
{
  return MEMORY[0x1E0D435D8]();
}

uint64_t LXEntryGetAffixData()
{
  return MEMORY[0x1E0D435E8]();
}

uint64_t LXEntryGetCategoryFlags()
{
  return MEMORY[0x1E0D435F0]();
}

uint64_t LXEntryGetMetaFlags()
{
  return MEMORY[0x1E0D43600]();
}

uint64_t LXEntryGetPartialProbability()
{
  return MEMORY[0x1E0D43608]();
}

uint64_t LXEntryGetPenaltyCount()
{
  return MEMORY[0x1E0D43610]();
}

uint64_t LXEntryGetTimestamp()
{
  return MEMORY[0x1E0D43620]();
}

uint64_t LXEntryGetTokenID()
{
  return MEMORY[0x1E0D43628]();
}

uint64_t LXEntryGetUsageCount()
{
  return MEMORY[0x1E0D43630]();
}

uint64_t LXLexiconAdd()
{
  return MEMORY[0x1E0D43650]();
}

uint64_t LXLexiconAddEntryWithTokenID()
{
  return MEMORY[0x1E0D43658]();
}

uint64_t LXLexiconAddWithCreationTime()
{
  return MEMORY[0x1E0D43660]();
}

uint64_t LXLexiconClear()
{
  return MEMORY[0x1E0D43668]();
}

uint64_t LXLexiconCompareStrings()
{
  return MEMORY[0x1E0D43670]();
}

uint64_t LXLexiconCopyEntryForTokenID()
{
  return MEMORY[0x1E0D43678]();
}

uint64_t LXLexiconCopyName()
{
  return MEMORY[0x1E0D43680]();
}

uint64_t LXLexiconCreate()
{
  return MEMORY[0x1E0D43690]();
}

uint64_t LXLexiconCreateMutable()
{
  return MEMORY[0x1E0D43698]();
}

uint64_t LXLexiconCreateRootCursor()
{
  return MEMORY[0x1E0D436A0]();
}

uint64_t LXLexiconCreateTransient()
{
  return MEMORY[0x1E0D436A8]();
}

uint64_t LXLexiconEnumerateEntriesForString()
{
  return MEMORY[0x1E0D436B8]();
}

uint64_t LXLexiconGetFirstTokenIDForString()
{
  return MEMORY[0x1E0D436C0]();
}

uint64_t LXLexiconGetSortkeyBytes()
{
  return MEMORY[0x1E0D436C8]();
}

uint64_t LXLexiconGetTokenIDForUTF8String()
{
  return MEMORY[0x1E0D436D0]();
}

uint64_t LXLexiconIncrementUsageCount()
{
  return MEMORY[0x1E0D436E0]();
}

uint64_t LXLexiconRepositoryAddOrUpdate()
{
  return MEMORY[0x1E0D436F8]();
}

uint64_t LXLexiconRepositoryCreateView()
{
  return MEMORY[0x1E0D43700]();
}

uint64_t LXLexiconWrite()
{
  return MEMORY[0x1E0D43728]();
}

uint64_t LXLexiconWriteDebugDump()
{
  return MEMORY[0x1E0D43730]();
}

uint64_t LXVulgarWordUsageDatabaseCanAutocorrect()
{
  return MEMORY[0x1E0D43758]();
}

uint64_t LXVulgarWordUsageDatabaseCanAutocorrectSomewhere()
{
  return MEMORY[0x1E0D43760]();
}

uint64_t LXVulgarWordUsageDatabaseCreate()
{
  return MEMORY[0x1E0D43768]();
}

uint64_t LXVulgarWordUsageDatabaseDecrementUsageCount()
{
  return MEMORY[0x1E0D43770]();
}

uint64_t LXVulgarWordUsageDatabaseIncrementUsageCount()
{
  return MEMORY[0x1E0D43778]();
}

uint64_t LXVulgarWordUsageDatabasePerformMaintenance()
{
  return MEMORY[0x1E0D43780]();
}

uint64_t LXVulgarWordUsageDatabaseReset()
{
  return MEMORY[0x1E0D43788]();
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1E0DE2B20]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1E0DE2B50]();
}

uint64_t MGGetFloat32Answer()
{
  return MEMORY[0x1E0DE2B58]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x1E0DE2B70]();
}

uint64_t MGGetStringAnswer()
{
  return MEMORY[0x1E0DE2B80]();
}

uint64_t MecabraAcceptCandidate()
{
  return MEMORY[0x1E0DE6E18]();
}

uint64_t MecabraAcceptInlineCandidates()
{
  return MEMORY[0x1E0DE6E20]();
}

uint64_t MecabraAdaptToUntokenizedText()
{
  return MEMORY[0x1E0DE6E28]();
}

uint64_t MecabraAnalyzeGesturesWithContext()
{
  return MEMORY[0x1E0DE6E30]();
}

uint64_t MecabraAnalyzeStringWithContext()
{
  return MEMORY[0x1E0DE6E38]();
}

uint64_t MecabraCancelAnalysis()
{
  return MEMORY[0x1E0DE6E40]();
}

uint64_t MecabraCancelLastAcceptedCandidate()
{
  return MEMORY[0x1E0DE6E48]();
}

uint64_t MecabraCandidateCopySyllableLengthArrayInAnalysisString()
{
  return MEMORY[0x1E0DE6E50]();
}

uint64_t MecabraCandidateCreateWordLocaleAtIndex()
{
  return MEMORY[0x1E0DE6E58]();
}

uint64_t MecabraCandidateGetAnalysisString()
{
  return MEMORY[0x1E0DE6E60]();
}

uint64_t MecabraCandidateGetAttributes()
{
  return MEMORY[0x1E0DE6E68]();
}

uint64_t MecabraCandidateGetConvertedAnalysisString()
{
  return MEMORY[0x1E0DE6E70]();
}

uint64_t MecabraCandidateGetDictionaryReading()
{
  return MEMORY[0x1E0DE6E78]();
}

uint64_t MecabraCandidateGetKind()
{
  return MEMORY[0x1E0DE6E80]();
}

uint64_t MecabraCandidateGetNextPhraseBoundary()
{
  return MEMORY[0x1E0DE6E88]();
}

uint64_t MecabraCandidateGetSupplementalLexiconIdentifiers()
{
  return MEMORY[0x1E0DE6E90]();
}

uint64_t MecabraCandidateGetSupplementalLexiconItemPrefix()
{
  return MEMORY[0x1E0DE6E98]();
}

uint64_t MecabraCandidateGetSurface()
{
  return MEMORY[0x1E0DE6EA0]();
}

uint64_t MecabraCandidateGetType()
{
  return MEMORY[0x1E0DE6EA8]();
}

uint64_t MecabraCandidateGetWordCount()
{
  return MEMORY[0x1E0DE6EB0]();
}

uint64_t MecabraCandidateGetWordDictionaryReadingLengthAtIndex()
{
  return MEMORY[0x1E0DE6EB8]();
}

uint64_t MecabraCandidateGetWordLengthAtIndex()
{
  return MEMORY[0x1E0DE6EC0]();
}

uint64_t MecabraCandidateGetWordReadingLengthAtIndex()
{
  return MEMORY[0x1E0DE6EC8]();
}

uint64_t MecabraCandidateGetWubixingType()
{
  return MEMORY[0x1E0DE6ED0]();
}

uint64_t MecabraCandidateIsAutocorrectionCandidate()
{
  return MEMORY[0x1E0DE6EE0]();
}

uint64_t MecabraCandidateIsBilingualCandidate()
{
  return MEMORY[0x1E0DE6EE8]();
}

uint64_t MecabraCandidateIsEmojiCandidate()
{
  return MEMORY[0x1E0DE6EF0]();
}

uint64_t MecabraCandidateIsExtensionCandidate()
{
  return MEMORY[0x1E0DE6EF8]();
}

uint64_t MecabraCandidateIsExtensionForCandidateBar()
{
  return MEMORY[0x1E0DE6F00]();
}

uint64_t MecabraCandidateIsOTAWordlistCandidate()
{
  return MEMORY[0x1E0DE6F08]();
}

uint64_t MecabraCandidateIsPartialCandidate()
{
  return MEMORY[0x1E0DE6F10]();
}

uint64_t MecabraCandidateIsRegionalCandidate()
{
  return MEMORY[0x1E0DE6F20]();
}

uint64_t MecabraCandidateIsSinglePhraseCandidate()
{
  return MEMORY[0x1E0DE6F28]();
}

uint64_t MecabraCandidateIsSupplementalLexiconCandidate()
{
  return MEMORY[0x1E0DE6F30]();
}

uint64_t MecabraCandidateIsUserWordCandidate()
{
  return MEMORY[0x1E0DE6F38]();
}

uint64_t MecabraCandidateRelease()
{
  return MEMORY[0x1E0DE6F40]();
}

uint64_t MecabraCandidateRetain()
{
  return MEMORY[0x1E0DE6F48]();
}

uint64_t MecabraCandidateSetDisplayString()
{
  return MEMORY[0x1E0DE6F50]();
}

uint64_t MecabraClearLearningDictionaries()
{
  return MEMORY[0x1E0DE6F58]();
}

uint64_t MecabraContextAddCandidate()
{
  return MEMORY[0x1E0DE6F60]();
}

uint64_t MecabraContextAddInlineCandidate()
{
  return MEMORY[0x1E0DE6F68]();
}

uint64_t MecabraContextCreateMutable()
{
  return MEMORY[0x1E0DE6F70]();
}

uint64_t MecabraContextGetCandidateAtIndex()
{
  return MEMORY[0x1E0DE6F78]();
}

uint64_t MecabraContextGetCandidateCount()
{
  return MEMORY[0x1E0DE6F80]();
}

uint64_t MecabraContextGetInlineCandidateAtIndex()
{
  return MEMORY[0x1E0DE6F88]();
}

uint64_t MecabraContextGetInlineCandidateCount()
{
  return MEMORY[0x1E0DE6F90]();
}

uint64_t MecabraContextRelease()
{
  return MEMORY[0x1E0DE6F98]();
}

uint64_t MecabraContextRemoveCandidatesInRange()
{
  return MEMORY[0x1E0DE6FA0]();
}

uint64_t MecabraContextRemoveInlineCandidatesInRange()
{
  return MEMORY[0x1E0DE6FA8]();
}

uint64_t MecabraContextSetAppContext()
{
  return MEMORY[0x1E0DE6FB0]();
}

uint64_t MecabraContextSetGeometryModel()
{
  return MEMORY[0x1E0DE6FB8]();
}

uint64_t MecabraContextSetOption()
{
  return MEMORY[0x1E0DE6FC0]();
}

uint64_t MecabraContextSetShuangpinType()
{
  return MEMORY[0x1E0DE6FC8]();
}

uint64_t MecabraContextSetTextContentType()
{
  return MEMORY[0x1E0DE6FD0]();
}

uint64_t MecabraConversionCandidateCreate()
{
  return MEMORY[0x1E0DE6FD8]();
}

uint64_t MecabraCreate()
{
  return MEMORY[0x1E0DE6FE0]();
}

uint64_t MecabraCreateCPGesture()
{
  return MEMORY[0x1E0DE6FE8]();
}

uint64_t MecabraCreateCandidateFromContextString()
{
  return MEMORY[0x1E0DE6FF0]();
}

uint64_t MecabraCreateFacemarkCandidates()
{
  return MEMORY[0x1E0DE6FF8]();
}

uint64_t MecabraCreateLayoutKey()
{
  return MEMORY[0x1E0DE7008]();
}

uint64_t MecabraCreateRemainingGestures()
{
  return MEMORY[0x1E0DE7010]();
}

uint64_t MecabraCreateTypeGesture()
{
  return MEMORY[0x1E0DE7018]();
}

uint64_t MecabraCreateTypeGestureWithTouchEvent()
{
  return MEMORY[0x1E0DE7020]();
}

uint64_t MecabraCreateWithOptions()
{
  return MEMORY[0x1E0DE7028]();
}

uint64_t MecabraCreateWubixingCodesFromSurface()
{
  return MEMORY[0x1E0DE7030]();
}

uint64_t MecabraDeclareEndOfSentence()
{
  return MEMORY[0x1E0DE7038]();
}

uint64_t MecabraFindSupplementalLexiconCandidatesWithinContext()
{
  return MEMORY[0x1E0DE7040]();
}

uint64_t MecabraFlushDynamicData()
{
  return MEMORY[0x1E0DE7048]();
}

uint64_t MecabraGestureAddKeyAndLoglikelihoodPair()
{
  return MEMORY[0x1E0DE7050]();
}

uint64_t MecabraGetLastOfflineAdaptationTime()
{
  return MEMORY[0x1E0DE7058]();
}

uint64_t MecabraGetLengthForContextString()
{
  return MEMORY[0x1E0DE7060]();
}

uint64_t MecabraGetNextCandidate()
{
  return MEMORY[0x1E0DE7068]();
}

uint64_t MecabraHandleMemoryPressure()
{
  return MEMORY[0x1E0DE7070]();
}

uint64_t MecabraPerformMaintenance()
{
  return MEMORY[0x1E0DE7078]();
}

uint64_t MecabraPredictionAcceptCandidateWithContext()
{
  return MEMORY[0x1E0DE7088]();
}

uint64_t MecabraPredictionAnalyzeWithContext()
{
  return MEMORY[0x1E0DE7098]();
}

uint64_t MecabraProactiveCandidateCreate()
{
  return MEMORY[0x1E0DE70A8]();
}

uint64_t MecabraRelease()
{
  return MEMORY[0x1E0DE70B0]();
}

uint64_t MecabraResetLearningDictionaries()
{
  return MEMORY[0x1E0DE70B8]();
}

uint64_t MecabraRevertLearningForCandidate()
{
  return MEMORY[0x1E0DE70C0]();
}

uint64_t MecabraSetAddressBookNamePhoneticPairs()
{
  return MEMORY[0x1E0DE70C8]();
}

uint64_t MecabraSetAssetDataItemsForType()
{
  return MEMORY[0x1E0DE70D0]();
}

uint64_t MecabraSetDebuggingLogEnabled()
{
  return MEMORY[0x1E0DE70D8]();
}

uint64_t MecabraSetDynamicLanguageModelAppContext()
{
  return MEMORY[0x1E0DE70E0]();
}

uint64_t MecabraSetKeyboardLayout()
{
  return MEMORY[0x1E0DE70E8]();
}

uint64_t MecabraSetSupplementalLexiconEntries()
{
  return MEMORY[0x1E0DE70F0]();
}

uint64_t MecabraSetUserWordKeyPairs()
{
  return MEMORY[0x1E0DE70F8]();
}

uint64_t NLEmojiPredictorCreate()
{
  return MEMORY[0x1E0D512E0]();
}

uint64_t NLEmojiPredictorCreateCandidatesForString()
{
  return MEMORY[0x1E0D512E8]();
}

uint64_t NLLanguageIdentifierReleaseInternalBuffers()
{
  return MEMORY[0x1E0D170B0]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1E0CB28A0](aClassName);
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x1E0CB2D88](format);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1E0CB3200](aClass);
}

NSString *__cdecl NSStringFromPoint(NSPoint aPoint)
{
  return (NSString *)MEMORY[0x1E0CB3210]((__n128)aPoint, *(__n128 *)&aPoint.y);
}

NSString *__cdecl NSStringFromRange(NSRange range)
{
  return (NSString *)MEMORY[0x1E0CB3220](range.location, range.length);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x1E0CB3250]();
}

NSRange NSUnionRange(NSRange range1, NSRange range2)
{
  NSUInteger v2;
  NSUInteger v3;
  NSRange result;

  v2 = MEMORY[0x1E0CB3400](range1.location, range1.length, range2.location, range2.length);
  result.length = v3;
  result.location = v2;
  return result;
}

uint64_t PFSceneTaxonomyNodeLocalizedLabel()
{
  return MEMORY[0x1E0D758D8]();
}

uint64_t PFSceneTaxonomyNodeLocalizedSynonyms()
{
  return MEMORY[0x1E0D758E0]();
}

uint64_t PLLogRegisteredEvent()
{
  return MEMORY[0x1E0D7FE28]();
}

uint64_t PLShouldLogRegisteredEvent()
{
  return MEMORY[0x1E0D7FE40]();
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  return MEMORY[0x1E0CD6290](attributes, result);
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return MEMORY[0x1E0CD6298](query, result);
}

CFStringRef SecTaskCopySigningIdentifier(SecTaskRef task, CFErrorRef *error)
{
  return (CFStringRef)MEMORY[0x1E0CD65E0](task, error);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1E0CD65F0](task, entitlement, error);
}

SecTaskRef SecTaskCreateWithAuditToken(CFAllocatorRef allocator, audit_token_t *token)
{
  return (SecTaskRef)MEMORY[0x1E0CD6620](allocator, token);
}

uint64_t TCCAccessCopyBundleIdentifiersForService()
{
  return MEMORY[0x1E0DB0FA8]();
}

uint64_t TIBundleForInputMode()
{
  return MEMORY[0x1E0DBDE10]();
}

uint64_t TICanonicalInputModeName()
{
  return MEMORY[0x1E0DBDE50]();
}

uint64_t TIDispatchAsync()
{
  return MEMORY[0x1E0DBDEF0]();
}

uint64_t TIDispatchSync()
{
  return MEMORY[0x1E0DBDEF8]();
}

uint64_t TIFeatureUsageAllowedValues()
{
  return MEMORY[0x1E0DBDF08]();
}

uint64_t TIGetAddressBookThresholdForInputMode()
{
  return MEMORY[0x1E0DBDF10]();
}

uint64_t TIGetDefaultInputModesForLanguage()
{
  return MEMORY[0x1E0DBDF18]();
}

uint64_t TIGetInputModeProperties()
{
  return MEMORY[0x1E0DBDF28]();
}

uint64_t TIGetStickerTaxonomyIdentifiers()
{
  return MEMORY[0x1E0DBDF38]();
}

uint64_t TIGetStickerTaxonomyIdentifiersAllowListSynonymExclusions()
{
  return MEMORY[0x1E0DBDF40]();
}

uint64_t TIISTypetoSiriMode()
{
  return MEMORY[0x1E0DBDFA0]();
}

uint64_t TIInputManagerClassForInputMode()
{
  return MEMORY[0x1E0DBDFB8]();
}

uint64_t TIInputModeGetBaseLanguage()
{
  return MEMORY[0x1E0DBDFC8]();
}

uint64_t TIInputModeGetComponentsFromIdentifier()
{
  return MEMORY[0x1E0DBDFD0]();
}

uint64_t TIInputModeGetFullInputModeIdentifier()
{
  return MEMORY[0x1E0DBDFD8]();
}

uint64_t TIInputModeGetLanguage()
{
  return MEMORY[0x1E0DBDFE0]();
}

uint64_t TIInputModeGetLanguageWithRegion()
{
  return MEMORY[0x1E0DBDFE8]();
}

uint64_t TIInputModeGetMultilingualID()
{
  return MEMORY[0x1E0DBDFF0]();
}

uint64_t TIInputModeGetMultilingualSet()
{
  return MEMORY[0x1E0DBDFF8]();
}

uint64_t TIInputModeGetMultilingualSetFromInputModesWithPreferredLanguages()
{
  return MEMORY[0x1E0DBE008]();
}

uint64_t TIInputModeGetNormalizedIdentifier()
{
  return MEMORY[0x1E0DBE010]();
}

uint64_t TIInputModeGetNormalizedLevelsFromComponents()
{
  return MEMORY[0x1E0DBE020]();
}

uint64_t TIInputModeGetRegion()
{
  return MEMORY[0x1E0DBE028]();
}

uint64_t TIInputModeGetSWLayout()
{
  return MEMORY[0x1E0DBE030]();
}

uint64_t TIInputModeGetVariant()
{
  return MEMORY[0x1E0DBE038]();
}

uint64_t TIInputModeIsTransliteration()
{
  return MEMORY[0x1E0DBE048]();
}

uint64_t TIInputModeUseMorphemeLevelLexicon()
{
  return MEMORY[0x1E0DBE188]();
}

uint64_t TIIsRegisterLearningModeRejection()
{
  return MEMORY[0x1E0DBE1A0]();
}

uint64_t TIKeyboardCandidateTypingEngineTypeToString()
{
  return MEMORY[0x1E0DBE240]();
}

uint64_t TIKeyboardPopupVariantsForInputMode()
{
  return MEMORY[0x1E0DBE380]();
}

uint64_t TINgramModelPathForInputMode()
{
  return MEMORY[0x1E0DBE468]();
}

uint64_t TIResourcePathForInputMode()
{
  return MEMORY[0x1E0DBE4E0]();
}

uint64_t TIStatisticCandidateSourceAsString()
{
  return MEMORY[0x1E0DBE710]();
}

uint64_t TIStatisticDistributionPushValue()
{
  return MEMORY[0x1E0DBE720]();
}

uint64_t TIStatisticGetKey()
{
  return MEMORY[0x1E0DBE748]();
}

uint64_t TIStatisticGetKeyForCandidateAccepted()
{
  return MEMORY[0x1E0DBE750]();
}

uint64_t TIStatisticGetKeyForInputMode()
{
  return MEMORY[0x1E0DBE760]();
}

uint64_t TIStatisticGetKeyForMultilingual()
{
  return MEMORY[0x1E0DBE768]();
}

uint64_t TIStatisticScalarAddValue()
{
  return MEMORY[0x1E0DBE8D0]();
}

uint64_t TIStatisticScalarIncrement()
{
  return MEMORY[0x1E0DBE8E0]();
}

uint64_t TIStatisticScalarIncrementAutocorrectionKey()
{
  return MEMORY[0x1E0DBE8F0]();
}

uint64_t TIStatisticScalarSetBoolean()
{
  return MEMORY[0x1E0DBE908]();
}

uint64_t TIStatisticScalarSetValue()
{
  return MEMORY[0x1E0DBE910]();
}

uint64_t _AXSFullKeyboardAccessEnabled()
{
  return MEMORY[0x1E0DDD760]();
}

uint64_t _AXSVoiceOverTouchEnabled()
{
  return MEMORY[0x1E0DDDDE0]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

uint64_t _TIQueueBackground()
{
  return MEMORY[0x1E0DBEA78]();
}

uint64_t _TIQueueLow()
{
  return MEMORY[0x1E0DBEA80]();
}

uint64_t _TIQueueUserInitiated()
{
  return MEMORY[0x1E0DBEA88]();
}

uint64_t language_modeling::v1::Prediction::Prediction()
{
  return MEMORY[0x1E0D42E68]();
}

void language_modeling::v1::Prediction::~Prediction(language_modeling::v1::Prediction *this)
{
  MEMORY[0x1E0D42E70](this);
}

void language_modeling::v1::Probability::~Probability(language_modeling::v1::Probability *this)
{
  MEMORY[0x1E0D42E78](this);
}

uint64_t language_modeling::v1::LanguageModel::addLexicon()
{
  return MEMORY[0x1E0D42E80]();
}

uint64_t language_modeling::v1::LanguageModel::wireMemory(language_modeling::v1::LanguageModel *this)
{
  return MEMORY[0x1E0D42E88](this);
}

uint64_t language_modeling::v1::LanguageModel::unwireMemory(language_modeling::v1::LanguageModel *this)
{
  return MEMORY[0x1E0D42E90](this);
}

uint64_t language_modeling::v1::LanguageModel::addVocabulary(language_modeling::v1::LanguageModel *this, void *a2)
{
  return MEMORY[0x1E0D42E98](this, a2);
}

uint64_t language_modeling::v1::LanguageModel::removeLexicon()
{
  return MEMORY[0x1E0D42EA0]();
}

uint64_t language_modeling::v1::LanguageModel::flushDynamicData(language_modeling::v1::LanguageModel *this)
{
  return MEMORY[0x1E0D42EA8](this);
}

uint64_t language_modeling::v1::LanguageModel::reloadWithLocales(language_modeling::v1::LanguageModel *this, const __CFArray *a2)
{
  return MEMORY[0x1E0D42EB0](this, a2);
}

uint64_t language_modeling::v1::LanguageModel::getLanguageLocales(language_modeling::v1::LanguageModel *this)
{
  return MEMORY[0x1E0D42EB8](this);
}

uint64_t language_modeling::v1::LanguageModel::deallocateInternalBuffers(language_modeling::v1::LanguageModel *this)
{
  return MEMORY[0x1E0D42EC0](this);
}

uint64_t language_modeling::v1::LanguageModel::init()
{
  return MEMORY[0x1E0D42ED0]();
}

uint64_t language_modeling::v1::LanguageModel::LanguageModel(language_modeling::v1::LanguageModel *this)
{
  return MEMORY[0x1E0D42ED8](this);
}

void language_modeling::v1::LanguageModel::~LanguageModel(language_modeling::v1::LanguageModel *this)
{
  MEMORY[0x1E0D42EE0](this);
}

uint64_t language_modeling::v1::CompletionStem::set_unique_id(language_modeling::v1::CompletionStem *this)
{
  return MEMORY[0x1E0D42EE8](this);
}

uint64_t language_modeling::v1::CompletionStem::try_push_back()
{
  return MEMORY[0x1E0D42EF0]();
}

uint64_t language_modeling::v1::CompletionStem::set_score(language_modeling::v1::CompletionStem *this, double a2)
{
  return MEMORY[0x1E0D42EF8](this, a2);
}

uint64_t language_modeling::v1::CompletionStem::CompletionStem()
{
  return MEMORY[0x1E0D42F00]();
}

uint64_t language_modeling::v1::CompletionStem::CompletionStem(language_modeling::v1::CompletionStem *this, const language_modeling::v1::CompletionStem *a2)
{
  return MEMORY[0x1E0D42F08](this, a2);
}

uint64_t language_modeling::v1::CompletionStem::CompletionStem(language_modeling::v1::CompletionStem *this)
{
  return MEMORY[0x1E0D42F10](this);
}

void language_modeling::v1::CompletionStem::~CompletionStem(language_modeling::v1::CompletionStem *this)
{
  MEMORY[0x1E0D42F18](this);
}

uint64_t language_modeling::v1::InlineCompletion::InlineCompletion()
{
  return MEMORY[0x1E0D42F28]();
}

{
  return MEMORY[0x1E0D42F30]();
}

void language_modeling::v1::InlineCompletion::~InlineCompletion(language_modeling::v1::InlineCompletion *this)
{
  MEMORY[0x1E0D42F38](this);
}

uint64_t language_modeling::v1::InlineCompletion::operator=()
{
  return MEMORY[0x1E0D42F40]();
}

uint64_t language_modeling::v1::LinguisticContext::remove_first(language_modeling::v1::LinguisticContext *this)
{
  return MEMORY[0x1E0D42F50](this);
}

uint64_t language_modeling::v1::LinguisticContext::try_push_back()
{
  return MEMORY[0x1E0D42F58]();
}

uint64_t language_modeling::v1::LinguisticContext::set_predominant_locale()
{
  return MEMORY[0x1E0D42F60]();
}

uint64_t language_modeling::v1::LinguisticContext::clear(language_modeling::v1::LinguisticContext *this)
{
  return MEMORY[0x1E0D42F68](this);
}

uint64_t language_modeling::v1::LinguisticContext::pop_back(language_modeling::v1::LinguisticContext *this)
{
  return MEMORY[0x1E0D42F70](this);
}

uint64_t language_modeling::v1::LinguisticContext::push_back()
{
  return MEMORY[0x1E0D42F78]();
}

uint64_t language_modeling::v1::LinguisticContext::LinguisticContext()
{
  return MEMORY[0x1E0D42F80]();
}

uint64_t language_modeling::v1::LinguisticContext::LinguisticContext(language_modeling::v1::LinguisticContext *this, const language_modeling::v1::LinguisticContext *a2)
{
  return MEMORY[0x1E0D42F88](this, a2);
}

uint64_t language_modeling::v1::LinguisticContext::LinguisticContext(language_modeling::v1::LinguisticContext *this)
{
  return MEMORY[0x1E0D42F90](this);
}

void language_modeling::v1::LinguisticContext::~LinguisticContext(language_modeling::v1::LinguisticContext *this)
{
  MEMORY[0x1E0D42F98](this);
}

uint64_t language_modeling::v1::LinguisticContext::operator=()
{
  return MEMORY[0x1E0D42FA0]();
}

{
  return MEMORY[0x1E0D42FA8]();
}

uint64_t language_modeling::v1::convertAbsoluteTime(language_modeling::v1 *this, double a2)
{
  return MEMORY[0x1E0D42FC0](this, a2);
}

uint64_t language_modeling::v1::LanguageModelSession::adaptToText()
{
  return MEMORY[0x1E0D42FD0]();
}

uint64_t language_modeling::v1::LanguageModelSession::adaptToToken()
{
  return MEMORY[0x1E0D42FD8]();
}

uint64_t language_modeling::v1::LanguageModelSession::addPriorText()
{
  return MEMORY[0x1E0D42FE0]();
}

uint64_t language_modeling::v1::LanguageModelSession::clearPriorText(language_modeling::v1::LanguageModelSession *this)
{
  return MEMORY[0x1E0D42FE8](this);
}

uint64_t language_modeling::v1::LanguageModelSession::unAdaptToToken()
{
  return MEMORY[0x1E0D42FF0]();
}

uint64_t language_modeling::v1::LanguageModelSession::recordWordRevision()
{
  return MEMORY[0x1E0D42FF8]();
}

uint64_t language_modeling::v1::LanguageModelSession::flushCacheAndRecencyData(language_modeling::v1::LanguageModelSession *this)
{
  return MEMORY[0x1E0D43000](this);
}

uint64_t language_modeling::v1::LanguageModelSession::registerNegativeEvidence()
{
  return MEMORY[0x1E0D43008]();
}

uint64_t language_modeling::v1::LanguageModelSession::clearDynamicLearningCache(language_modeling::v1::LanguageModelSession *this)
{
  return MEMORY[0x1E0D43010](this);
}

uint64_t language_modeling::v1::LanguageModelSession::supportsPrefixCompletions(language_modeling::v1::LanguageModelSession *this)
{
  return MEMORY[0x1E0D43018](this);
}

uint64_t language_modeling::v1::LanguageModelSession::supportsNormalizedNameTokenProbability(language_modeling::v1::LanguageModelSession *this)
{
  return MEMORY[0x1E0D43020](this);
}

uint64_t language_modeling::v1::LanguageModelSession::normalizedNameTokenConditionalProbability()
{
  return MEMORY[0x1E0D43028]();
}

uint64_t language_modeling::v1::LanguageModelSession::supportsFragmentsBasedConditionalProbability(language_modeling::v1::LanguageModelSession *this)
{
  return MEMORY[0x1E0D43030](this);
}

void language_modeling::v1::LanguageModelSession::~LanguageModelSession(language_modeling::v1::LanguageModelSession *this)
{
  MEMORY[0x1E0D43038](this);
}

uint64_t LM::TrialParameters::createWithEncodedRepresentation(LM::TrialParameters *this, const __CFDictionary *a2)
{
  return MEMORY[0x1E0D43190](this, a2);
}

uint64_t language_modeling::v1::Prediction::contextSize(language_modeling::v1::Prediction *this)
{
  return MEMORY[0x1E0D43198](this);
}

uint64_t language_modeling::v1::Prediction::probability(language_modeling::v1::Prediction *this)
{
  return MEMORY[0x1E0D431A0](this);
}

uint64_t language_modeling::v1::Prediction::exactTokenSpan(language_modeling::v1::Prediction *this)
{
  return MEMORY[0x1E0D431A8](this);
}

uint64_t language_modeling::v1::Prediction::log(language_modeling::v1::Prediction *this)
{
  return MEMORY[0x1E0D431B0](this);
}

uint64_t language_modeling::v1::Prediction::source(language_modeling::v1::Prediction *this)
{
  return MEMORY[0x1E0D431B8](this);
}

uint64_t language_modeling::v1::Prediction::string(language_modeling::v1::Prediction *this)
{
  return MEMORY[0x1E0D431C0](this);
}

uint64_t language_modeling::v1::Prediction::tokenSpan(language_modeling::v1::Prediction *this)
{
  return MEMORY[0x1E0D431C8](this);
}

uint64_t language_modeling::v1::Prediction::unique_id(language_modeling::v1::Prediction *this)
{
  return MEMORY[0x1E0D431D0](this);
}

uint64_t language_modeling::v1::Probability::probability()
{
  return MEMORY[0x1E0D431D8]();
}

uint64_t language_modeling::v1::Probability::log(language_modeling::v1::Probability *this)
{
  return MEMORY[0x1E0D431E0](this);
}

uint64_t language_modeling::v1::Probability::flags(language_modeling::v1::Probability *this)
{
  return MEMORY[0x1E0D431E8](this);
}

uint64_t language_modeling::v1::LanguageModel::parameters(language_modeling::v1::LanguageModel *this)
{
  return MEMORY[0x1E0D431F0](this);
}

uint64_t language_modeling::v1::LanguageModel::makeSession()
{
  return MEMORY[0x1E0D431F8]();
}

uint64_t language_modeling::v1::LanguageModel::blocklistStatus()
{
  return MEMORY[0x1E0D43208]();
}

uint64_t language_modeling::v1::LanguageModel::copyLinguisticDataFileInfo(language_modeling::v1::LanguageModel *this)
{
  return MEMORY[0x1E0D43210](this);
}

uint64_t language_modeling::v1::CompletionStem::prefix(language_modeling::v1::CompletionStem *this)
{
  return MEMORY[0x1E0D43218](this);
}

uint64_t language_modeling::v1::InlineCompletion::probability(language_modeling::v1::InlineCompletion *this)
{
  return MEMORY[0x1E0D43220](this);
}

uint64_t language_modeling::v1::InlineCompletion::wordBoundaryAt(language_modeling::v1::InlineCompletion *this)
{
  return MEMORY[0x1E0D43228](this);
}

uint64_t language_modeling::v1::InlineCompletion::log(language_modeling::v1::InlineCompletion *this)
{
  return MEMORY[0x1E0D43230](this);
}

uint64_t language_modeling::v1::InlineCompletion::source(language_modeling::v1::InlineCompletion *this)
{
  return MEMORY[0x1E0D43238](this);
}

uint64_t language_modeling::v1::InlineCompletion::string(language_modeling::v1::InlineCompletion *this)
{
  return MEMORY[0x1E0D43240](this);
}

uint64_t language_modeling::v1::LinguisticContext::tokenSpan(language_modeling::v1::LinguisticContext *this)
{
  return MEMORY[0x1E0D43248](this);
}

uint64_t language_modeling::v1::LanguageModelSession::canReasonAbout()
{
  return MEMORY[0x1E0D43250]();
}

uint64_t language_modeling::v1::LanguageModelSession::extendedPredictions(language_modeling::v1::LanguageModelSession *this, const language_modeling::v1::LinguisticContext *a2)
{
  return MEMORY[0x1E0D43258](this, a2);
}

uint64_t language_modeling::v1::LanguageModelSession::enumeratePredictions()
{
  return MEMORY[0x1E0D43268]();
}

uint64_t language_modeling::v1::LanguageModelSession::conditionalProbability()
{
  return MEMORY[0x1E0D43270]();
}

uint64_t language_modeling::v1::LanguageModelSession::enumerateInlineCompletions()
{
  return MEMORY[0x1E0D43278]();
}

uint64_t language_modeling::v1::LanguageModelSession::detailedConditionalProbability()
{
  return MEMORY[0x1E0D43280]();
}

{
  return MEMORY[0x1E0D43288]();
}

uint64_t LM::TrialParameters::copyEncodedRepresentation(LM::TrialParameters *this)
{
  return MEMORY[0x1E0D43290](this);
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x1E0DE41C8](this, __c, __pos);
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__filename(const std::__fs::filesystem::path *this)
{
  const std::string_view::value_type *v1;
  std::basic_string_view<_CharT, _Traits>::size_type v2;
  std::__fs::filesystem::path::__string_view result;

  v1 = (const std::string_view::value_type *)MEMORY[0x1E0DE4208](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__root_directory(const std::__fs::filesystem::path *this)
{
  const std::string_view::value_type *v1;
  std::basic_string_view<_CharT, _Traits>::size_type v2;
  std::__fs::filesystem::path::__string_view result;

  v1 = (const std::string_view::value_type *)MEMORY[0x1E0DE4220](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1E0DE4248](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1E0DE4258](this);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1E0DE4308](this, a2);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1E0DE43E8](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
  MEMORY[0x1E0DE43F8](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add, __p_new_stuff);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4428](this, __s, __n);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
  MEMORY[0x1E0DE44B0](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
  MEMORY[0x1E0DE44B8](this, __c);
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1E0DE44C8](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1E0DE44D8](this, __str);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x1E0DE4590]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1E0DE45A8]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1E0DE45B0]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1E0DE4628]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x1E0DE46A8]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1E0DE46B0]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1E0DE46B8]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1E0DE46C8]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1E0DE46D0]();
}

{
  return MEMORY[0x1E0DE46E8]();
}

{
  return MEMORY[0x1E0DE4700]();
}

{
  return MEMORY[0x1E0DE4708]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1E0DE47A8]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
  MEMORY[0x1E0DE4890](this);
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
  MEMORY[0x1E0DE48A8](this, __lk);
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
  MEMORY[0x1E0DE48B0](this);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1E0DE48F8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
  MEMORY[0x1E0DE4920](*(_QWORD *)&__ev, __what_arg);
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
  MEMORY[0x1E0DE4930](__format);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA0](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA8](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x1E0DE4AB8](this);
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x1E0DE4B48]();
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x1E0DE4B98](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x1E0DE4C80](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, double __val)
{
  return (std::string *)MEMORY[0x1E0DE4D40](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1E0DE4D58](retstr, *(_QWORD *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x1E0DE4D60](retstr, *(_QWORD *)&__val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x1E0DE4D88]();
}

uint64_t operator delete[]()
{
  return off_1EA0F8F40();
}

void operator delete(void *__p)
{
  off_1EA0F8F48(__p);
}

uint64_t operator delete()
{
  return off_1EA0F8F50();
}

uint64_t operator new[]()
{
  return off_1EA0F8F58();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1EA0F8F60(__sz);
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  return (void *)off_1EA0F8F68(__sz, a2);
}

uint64_t operator new()
{
  return off_1EA0F8F70();
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE5068](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1E0C80A98](lpfunc, obj, lpdso_handle);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1E0DE50B8](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x1E0DE50C0](a1);
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE50D8](a1, lptinfo, a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

float __exp10f(float a1)
{
  float result;

  MEMORY[0x1E0C80AD0](a1);
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1E0C80B50](*(_QWORD *)&a1, a2);
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C70](*(_QWORD *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C78](*(_QWORD *)&a1);
}

uint64_t _os_crash()
{
  return MEMORY[0x1E0C81000]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1E0C81010]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81020](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81040](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C810D0](dso, log, type, spid, name, format, buf, *(_QWORD *)&size);
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1E0DA88F0]();
}

void _tlv_atexit(void (__cdecl *termFunc)(void *), void *objAddr)
{
  MEMORY[0x1E0C81230](termFunc, objAddr);
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x1E0C813B0]();
}

uint64_t analytics_send_event_lazy()
{
  return MEMORY[0x1E0D15470]();
}

uint32_t arc4random(void)
{
  return MEMORY[0x1E0C81570]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
  MEMORY[0x1E0C81580](__buf, __nbytes);
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1E0C81588](*(_QWORD *)&__upper_bound);
}

long double atan2(long double __y, long double __x)
{
  long double result;

  MEMORY[0x1E0C81620](__y, __x);
  return result;
}

int atexit_b(void *a1)
{
  return MEMORY[0x1E0C81650](a1);
}

pid_t audit_token_to_pid(audit_token_t *atoken)
{
  return MEMORY[0x1E0DE40F0](atoken);
}

int audit_token_to_pidversion(audit_token_t *atoken)
{
  return MEMORY[0x1E0DE40F8](atoken);
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x1E0C81738](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

uint64_t character_is_tamil_script()
{
  return MEMORY[0x1E0DBEA90]();
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

uint64_t combine_with_accent()
{
  return MEMORY[0x1E0DBEA98]();
}

uint64_t combines_with_selective_modifier()
{
  return MEMORY[0x1E0DBEAA0]();
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BE8](queue);
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BF8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1E0C82C68](flags, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1E0C82D20]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x1E0C82D28](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x1E0C82D30](group);
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82D38](group, queue, block);
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82D48](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E28](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E38](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

uintptr_t dispatch_source_get_data(dispatch_source_t source)
{
  return MEMORY[0x1E0C82F28](source);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1E0C83038]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x1E0C83280](__x);
  return result;
}

float expf(float a1)
{
  float result;

  MEMORY[0x1E0C83298](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

int feof(FILE *a1)
{
  return MEMORY[0x1E0C83340](a1);
}

int fgetc(FILE *a1)
{
  return MEMORY[0x1E0C83388](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x1E0C833A0](a1, *(_QWORD *)&a2, a3);
}

int fileno(FILE *a1)
{
  return MEMORY[0x1E0C833B0](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1E0C83488](*(_QWORD *)&a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1E0C83490](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x1E0C83530](a1, a2, *(_QWORD *)&a3);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x1E0C83580](a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1E0C83590](*(_QWORD *)&a1, a2);
}

FILE *__cdecl funopen(const void *a1, int (__cdecl *a2)(void *, char *, int), int (__cdecl *a3)(void *, const char *, int), fpos_t (__cdecl *a4)(void *, fpos_t, int), int (__cdecl *a5)(void *))
{
  return (FILE *)MEMORY[0x1E0C835C8](a1, a2, a3, a4, a5);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

int getpagesize(void)
{
  return MEMORY[0x1E0C83740]();
}

pid_t getpid(void)
{
  return MEMORY[0x1E0C83760]();
}

long double hypot(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C838E8](__x, __y);
  return result;
}

float hypotf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C838F0](a1, a2);
  return result;
}

uint64_t isH13ANEPresentOnIOS()
{
  return MEMORY[0x1E0DBEAA8]();
}

uint64_t kac_get_log()
{
  return MEMORY[0x1E0DBEB50]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1E0C83A20]();
}

long double log(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BB8](__x);
  return result;
}

long double log10(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BC0](__x);
  return result;
}

long double log1p(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BD0](__x);
  return result;
}

float log1pf(float a1)
{
  float result;

  MEMORY[0x1E0C83BD8](a1);
  return result;
}

long double log2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BE8](__x);
  return result;
}

float logf(float a1)
{
  float result;

  MEMORY[0x1E0C83C00](a1);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1E0C83C38](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x1E0C83C70]();
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1E0C83CF8](*(_QWORD *)&task, *(_QWORD *)&name);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1E0C84070](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

uint64_t memorystatus_control()
{
  return MEMORY[0x1E0C840A8]();
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x1E0C840B8](__b, __pattern16, __len);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1E0C841D8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int msync(void *a1, size_t a2, int a3)
{
  return MEMORY[0x1E0C84210](a1, a2, *(_QWORD *)&a3);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1E0C84220](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1E0C843D8](*(_QWORD *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1E0C843E8](*(_QWORD *)&token, state64);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x1E0C84400](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7BE8](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1E0DE7BF8]();
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7C38](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x1E0DE7C60](location);
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

id objc_getAssociatedObject(id object, const void *key)
{
  return (id)MEMORY[0x1E0DE7CA8](object, key);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CB0](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1E0DE7CD0](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1E0DE7CE0](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1E0DE7D08](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D20](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1E0DE7D50]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7E58](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E60](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1E0DE7E70](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
  MEMORY[0x1E0DE7F40](object, key, value, policy);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F88](self, _cmd, newValue, offset);
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F90](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7FA0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x1E0DE7FB0](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1E0DE7FB8](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1E0DE7FC8](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1E0DE7FD0](obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7FE0](a1);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x1E0C84488](a1, *(_QWORD *)&a2, *(_QWORD *)&a3, *(_QWORD *)&a4);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1E0C84920](log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return MEMORY[0x1E0C84930](log, ptr);
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1E0C84970]();
}

uint64_t os_variant_has_internal_ui()
{
  return MEMORY[0x1E0C84A00]();
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C84BB8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C84BC0](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1E0C84BD0](a1);
}

int pthread_main_np(void)
{
  return MEMORY[0x1E0C84E08]();
}

int putchar(int a1)
{
  return MEMORY[0x1E0C84F50](*(_QWORD *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x1E0C84F60](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x1E0C84F88](__base, __nel, __width, __compar);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1E0C85030](__ptr, __size);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return MEMORY[0x1E0C850B8](__p, __ec);
}

int setvbuf(FILE *a1, char *a2, int a3, size_t a4)
{
  return MEMORY[0x1E0C85398](a1, a2, *(_QWORD *)&a3, a4);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int sqlite3_bind_blob(sqlite3_stmt *a1, int a2, const void *a3, int n, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1E0DE8580](a1, *(_QWORD *)&a2, a3, *(_QWORD *)&n, a5);
}

int sqlite3_bind_double(sqlite3_stmt *a1, int a2, double a3)
{
  return MEMORY[0x1E0DE8598](a1, *(_QWORD *)&a2, a3);
}

int sqlite3_bind_int(sqlite3_stmt *a1, int a2, int a3)
{
  return MEMORY[0x1E0DE85A0](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int sqlite3_bind_parameter_index(sqlite3_stmt *a1, const char *zName)
{
  return MEMORY[0x1E0DE85C0](a1, zName);
}

int sqlite3_bind_text(sqlite3_stmt *a1, int a2, const char *a3, int a4, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1E0DE85D8](a1, *(_QWORD *)&a2, a3, *(_QWORD *)&a4, a5);
}

int sqlite3_close(sqlite3 *a1)
{
  return MEMORY[0x1E0DE8650](a1);
}

const void *__cdecl sqlite3_column_blob(sqlite3_stmt *a1, int iCol)
{
  return (const void *)MEMORY[0x1E0DE8660](a1, *(_QWORD *)&iCol);
}

int sqlite3_column_bytes(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1E0DE8668](a1, *(_QWORD *)&iCol);
}

double sqlite3_column_double(sqlite3_stmt *a1, int iCol)
{
  double result;

  MEMORY[0x1E0DE8688](a1, *(_QWORD *)&iCol);
  return result;
}

int sqlite3_column_int(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1E0DE8690](a1, *(_QWORD *)&iCol);
}

const unsigned __int8 *__cdecl sqlite3_column_text(sqlite3_stmt *a1, int iCol)
{
  return (const unsigned __int8 *)MEMORY[0x1E0DE86B8](a1, *(_QWORD *)&iCol);
}

const char *__cdecl sqlite3_errmsg(sqlite3 *a1)
{
  return (const char *)MEMORY[0x1E0DE8788](a1);
}

int sqlite3_exec(sqlite3 *a1, const char *sql, int (__cdecl *callback)(void *, int, char **, char **), void *a4, char **errmsg)
{
  return MEMORY[0x1E0DE8798](a1, sql, callback, a4, errmsg);
}

int sqlite3_finalize(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1E0DE87C8](pStmt);
}

int sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs)
{
  return MEMORY[0x1E0DE8870](filename, ppDb, *(_QWORD *)&flags, zVfs);
}

int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return MEMORY[0x1E0DE8880](db, zSql, *(_QWORD *)&nByte, ppStmt, pzTail);
}

int sqlite3_reset(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1E0DE88B0](pStmt);
}

int sqlite3_step(sqlite3_stmt *a1)
{
  return MEMORY[0x1E0DE89A8](a1);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C85498](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x1E0C85500](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C85518](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1E0C85548](*(_QWORD *)&__errnum);
}

uint64_t strip_accent()
{
  return MEMORY[0x1E0DBEB60]();
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85570](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1E0C85590](a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1E0C855B0](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1E0C855C0](__s1, __n);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85610](__s1, __s2);
}

kern_return_t task_generate_corpse(task_read_t task, mach_port_t *corpse_task_port)
{
  return MEMORY[0x1E0C85818](*(_QWORD *)&task, corpse_task_port);
}

int8_t u_charType(UChar32 c)
{
  return MEMORY[0x1E0DE5978](*(_QWORD *)&c);
}

int32_t u_getIntPropertyValue(UChar32 c, UProperty which)
{
  return MEMORY[0x1E0DE59C0](*(_QWORD *)&c, *(_QWORD *)&which);
}

UBool u_isalnum(UChar32 c)
{
  return MEMORY[0x1E0DE5A18](*(_QWORD *)&c);
}

UBool u_isdigit(UChar32 c)
{
  return MEMORY[0x1E0DE5A30](*(_QWORD *)&c);
}

UBool u_islower(UChar32 c)
{
  return MEMORY[0x1E0DE5A38](*(_QWORD *)&c);
}

UBool u_ispunct(UChar32 c)
{
  return MEMORY[0x1E0DE5A48](*(_QWORD *)&c);
}

UBool u_isspace(UChar32 c)
{
  return MEMORY[0x1E0DE5A50](*(_QWORD *)&c);
}

UBool u_istitle(UChar32 c)
{
  return MEMORY[0x1E0DE5A58](*(_QWORD *)&c);
}

UBool u_isupper(UChar32 c)
{
  return MEMORY[0x1E0DE5A60](*(_QWORD *)&c);
}

UChar *__cdecl u_strFromUTF32(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const UChar32 *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  return (UChar *)MEMORY[0x1E0DE5A98](dest, *(_QWORD *)&destCapacity, pDestLength, src, *(_QWORD *)&srcLength, pErrorCode);
}

UChar *__cdecl u_strFromUTF8(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  return (UChar *)MEMORY[0x1E0DE5AA0](dest, *(_QWORD *)&destCapacity, pDestLength, src, *(_QWORD *)&srcLength, pErrorCode);
}

int32_t u_strToLower(UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, const char *locale, UErrorCode *pErrorCode)
{
  return MEMORY[0x1E0DE5AB0](dest, *(_QWORD *)&destCapacity, src, *(_QWORD *)&srcLength, locale, pErrorCode);
}

int32_t u_strToTitle(UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, UBreakIterator *titleIter, const char *locale, UErrorCode *pErrorCode)
{
  return MEMORY[0x1E0DE5AB8](dest, *(_QWORD *)&destCapacity, src, *(_QWORD *)&srcLength, titleIter, locale, pErrorCode);
}

char *__cdecl u_strToUTF8(char *dest, int32_t destCapacity, int32_t *pDestLength, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  return (char *)MEMORY[0x1E0DE5AC0](dest, *(_QWORD *)&destCapacity, pDestLength, src, *(_QWORD *)&srcLength, pErrorCode);
}

UChar32 u_tolower(UChar32 c)
{
  return MEMORY[0x1E0DE5B10](*(_QWORD *)&c);
}

UChar32 u_totitle(UChar32 c)
{
  return MEMORY[0x1E0DE5B18](*(_QWORD *)&c);
}

UChar32 u_toupper(UChar32 c)
{
  return MEMORY[0x1E0DE5B20](*(_QWORD *)&c);
}

uint64_t ubrk_close()
{
  return MEMORY[0x1E0DE5C98]();
}

uint64_t ubrk_open()
{
  return MEMORY[0x1E0DE5CE8]();
}

uint64_t ucol_getSortKey()
{
  return MEMORY[0x1E0DE5FD0]();
}

uint64_t ucol_open()
{
  return MEMORY[0x1E0DE6008]();
}

uint64_t ucol_strcollUTF8()
{
  return MEMORY[0x1E0DE6050]();
}

uint64_t ulocdata_close()
{
  return MEMORY[0x1E0DE6488]();
}

uint64_t ulocdata_getExemplarSet()
{
  return MEMORY[0x1E0DE64A0]();
}

uint64_t ulocdata_open()
{
  return MEMORY[0x1E0DE64B0]();
}

int ungetc(int a1, FILE *a2)
{
  return MEMORY[0x1E0C859A8](*(_QWORD *)&a1, a2);
}

uint64_t uscript_getCode()
{
  return MEMORY[0x1E0DE6880]();
}

uint64_t uset_add()
{
  return MEMORY[0x1E0DE6938]();
}

uint64_t uset_addAll()
{
  return MEMORY[0x1E0DE6940]();
}

uint64_t uset_addRange()
{
  return MEMORY[0x1E0DE6950]();
}

uint64_t uset_close()
{
  return MEMORY[0x1E0DE6988]();
}

uint64_t uset_contains()
{
  return MEMORY[0x1E0DE6998]();
}

uint64_t uset_freeze()
{
  return MEMORY[0x1E0DE69A8]();
}

uint64_t uset_openEmpty()
{
  return MEMORY[0x1E0DE69D8]();
}

uint64_t uset_removeRange()
{
  return MEMORY[0x1E0DE69F8]();
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x1E0C85A68](a1, a2, a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1E0C85D40](*(_QWORD *)&__fd, __buf, __nbyte);
}

xpc_activity_state_t xpc_activity_get_state(xpc_activity_t activity)
{
  return MEMORY[0x1E0C85D90](activity);
}

void xpc_activity_register(const char *identifier, xpc_object_t criteria, xpc_activity_handler_t handler)
{
  MEMORY[0x1E0C85D98](identifier, criteria, handler);
}

void xpc_activity_set_criteria(xpc_activity_t activity, xpc_object_t criteria)
{
  MEMORY[0x1E0C85DB0](activity, criteria);
}

BOOL xpc_activity_set_state(xpc_activity_t activity, xpc_activity_state_t state)
{
  return MEMORY[0x1E0C85DB8](activity, state);
}

BOOL xpc_activity_should_defer(xpc_activity_t activity)
{
  return MEMORY[0x1E0C85DC8](activity);
}

uint64_t xpc_connection_copy_bundle_id()
{
  return MEMORY[0x1E0C85F70]();
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C86208](keys, values, count);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
  MEMORY[0x1E0C86310](xdict, key, value);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
  MEMORY[0x1E0C86360](xdict, key, value);
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x1E0C86390](xdict, key, string);
}

