uint64_t OUTLINED_FUNCTION_6(uint64_t result, uint64_t a2, float a3)
{
  *(float *)a2 = a3;
  *(_QWORD *)(a2 + 4) = result;
  return result;
}

void OUTLINED_FUNCTION_1(unint64_t *a1@<X8>)
{
  unint64_t v1;

  v1 = __ldaxr(a1);
  __stlxr(v1 - 1, a1);
}

uint64_t OUTLINED_FUNCTION_2()
{
  uint64_t v0;

  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v0 + 16))(v0);
}

void OUTLINED_FUNCTION_4_1(uint64_t a1@<X1>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(float *)a1 = a3;
  *(_QWORD *)(a1 + 4) = a2;
}

void OUTLINED_FUNCTION_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void OUTLINED_FUNCTION_0_0(uint64_t a1)
{

}

void OUTLINED_FUNCTION_1_1(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

void OUTLINED_FUNCTION_0_1(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, NSObject *a4@<X8>)
{
  _os_log_error_impl(a1, a4, OS_LOG_TYPE_ERROR, a2, a3, 0xEu);
}

void OUTLINED_FUNCTION_0_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_1_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

void OUTLINED_FUNCTION_1_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void OUTLINED_FUNCTION_1_4(float a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;

  *(float *)a3 = a1;
  *(_DWORD *)(a3 + 4) = a4;
  *(_WORD *)(a3 + 8) = 1024;
  *(_DWORD *)(a3 + 10) = v4;
}

uint64_t OUTLINED_FUNCTION_2_1()
{
  uint64_t v0;

  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v0 + 16))(v0);
}

void OUTLINED_FUNCTION_3_1()
{
  void **v0;

  operator delete(*v0);
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:sn180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::vector<unsigned int>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  std::__compressed_pair<unsigned int *> *p_end_cap;
  unsigned int *value;
  int64_t v5;
  char *v6;
  unsigned int *v7;
  uint64_t v8;
  unsigned int *v9;
  std::vector<unsigned int>::pointer begin;
  unsigned int *end;
  unsigned int *v12;
  unsigned int v13;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62)
      abort();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    v6 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::CompressionType>>((uint64_t)p_end_cap, __n);
    v7 = (unsigned int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = (unsigned int *)&v6[4 * v8];
    begin = this->__begin_;
    end = this->__end_;
    v12 = v7;
    if (end != this->__begin_)
    {
      v12 = v7;
      do
      {
        v13 = *--end;
        *--v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
      operator delete(begin);
  }
}

char *std::vector<unsigned char>::vector(_QWORD *a1, size_t a2)
{
  size_t v3;
  char *result;
  _BYTE *v5;
  _BYTE *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (!a2)
    return (char *)a1;
  v3 = a2;
  result = std::vector<unsigned char>::__vallocate[abi:sn180100](a1, a2);
  v5 = (_BYTE *)a1[1];
  v6 = &v5[v3];
  while (v5)
  {
    *v5++ = 0;
    if (!--v3)
    {
      a1[1] = v6;
      return (char *)a1;
    }
  }
  __break(1u);
  return result;
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, const std::vector<unsigned int> *__x)
{
  unsigned int *end;
  std::vector<unsigned int>::pointer begin;
  int64_t v5;
  std::vector<unsigned int>::pointer v6;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  begin = __x->__begin_;
  end = __x->__end_;
  v5 = (char *)end - (char *)__x->__begin_;
  if (end != __x->__begin_)
  {
    std::vector<Backend::Google::CompressionType>::__vallocate[abi:sn180100](this, v5 >> 2);
    v6 = this->__end_;
    memmove(v6, begin, v5);
    this->__end_ = (std::vector<unsigned int>::pointer)((char *)v6 + v5);
  }
  return this;
}

void sub_1DBCC0270(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBCC0378(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBCC0480(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBCC05B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBCC06E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<SafeBrowsing::DatabaseStatus::Database>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<SafeBrowsing::DatabaseStatus::Database>::__clear[abi:sn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<SafeBrowsing::DatabaseStatus::Database>::__clear[abi:sn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 56)
  {
    if (*(char *)(i - 33) < 0)
      operator delete(*(void **)(i - 56));
  }
  a1[1] = v2;
}

void std::vector<SafeBrowsing::DatabaseStatus::Database>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<SafeBrowsing::DatabaseStatus::Database>::__clear[abi:sn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

uint64_t SSBOSLogDatabase()
{
  if (SSBOSLogDatabase_onceToken != -1)
    dispatch_once(&SSBOSLogDatabase_onceToken, &__block_literal_global);
  return SSBOSLogDatabase_log;
}

uint64_t SSBOSLogDownload()
{
  if (SSBOSLogDownload_onceToken != -1)
    dispatch_once(&SSBOSLogDownload_onceToken, &__block_literal_global_3);
  return SSBOSLogDownload_log;
}

uint64_t SSBOSLogEnabledState()
{
  if (SSBOSLogEnabledState_onceToken != -1)
    dispatch_once(&SSBOSLogEnabledState_onceToken, &__block_literal_global_5);
  return SSBOSLogEnabledState_log;
}

uint64_t SSBOSLogFullHash()
{
  if (SSBOSLogFullHash_onceToken != -1)
    dispatch_once(&SSBOSLogFullHash_onceToken, &__block_literal_global_7);
  return SSBOSLogFullHash_log;
}

uint64_t SSBOSLogLookup()
{
  if (SSBOSLogLookup_onceToken != -1)
    dispatch_once(&SSBOSLogLookup_onceToken, &__block_literal_global_9);
  return SSBOSLogLookup_log;
}

uint64_t SSBOSLogParser()
{
  if (SSBOSLogParser_onceToken != -1)
    dispatch_once(&SSBOSLogParser_onceToken, &__block_literal_global_11);
  return SSBOSLogParser_log;
}

uint64_t SSBOSLogPlatform()
{
  if (SSBOSLogPlatform_onceToken != -1)
    dispatch_once(&SSBOSLogPlatform_onceToken, &__block_literal_global_13);
  return SSBOSLogPlatform_log;
}

uint64_t SSBOSLogRemoteConfiguration()
{
  if (SSBOSLogRemoteConfiguration_onceToken != -1)
    dispatch_once(&SSBOSLogRemoteConfiguration_onceToken, &__block_literal_global_15);
  return SSBOSLogRemoteConfiguration_log;
}

uint64_t SSBOSLogSandbox()
{
  if (SSBOSLogSandbox_onceToken != -1)
    dispatch_once(&SSBOSLogSandbox_onceToken, &__block_literal_global_17);
  return SSBOSLogSandbox_log;
}

uint64_t SSBOSLogService()
{
  if (SSBOSLogService_onceToken != -1)
    dispatch_once(&SSBOSLogService_onceToken, &__block_literal_global_19);
  return SSBOSLogService_log;
}

uint64_t SSBOSLogXPC()
{
  if (SSBOSLogXPC_onceToken != -1)
    dispatch_once(&SSBOSLogXPC_onceToken, &__block_literal_global_21);
  return SSBOSLogXPC_log;
}

uint64_t SSBOSLogDeviceIdentificationToken()
{
  if (SSBOSLogDeviceIdentificationToken_onceToken != -1)
    dispatch_once(&SSBOSLogDeviceIdentificationToken_onceToken, &__block_literal_global_23);
  return SSBOSLogDeviceIdentificationToken_log;
}

void sub_1DBCC0EEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBCC0FD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBCC10E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBCC1194(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<std::string>::__vdeallocate(std::vector<std::string> *this)
{
  if (this->__begin_)
  {
    std::vector<std::string>::__clear[abi:sn180100]((uint64_t *)this);
    operator delete(this->__begin_);
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
  }
}

void std::vector<std::string>::__clear[abi:sn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

void std::vector<SafeBrowsing::ServiceStatus::Connection>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<SafeBrowsing::ServiceStatus::Connection>::__clear[abi:sn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<SafeBrowsing::ServiceStatus::Connection>::__clear[abi:sn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 32)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

__n128 std::vector<SafeBrowsing::ServiceStatus::DatabaseUpdaterStatus>::__move_assign(uint64_t a1, __n128 *a2)
{
  void *v4;
  __n128 result;

  v4 = *(void **)a1;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  result = *a2;
  *(__n128 *)a1 = *a2;
  *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

void std::vector<SafeBrowsing::ServiceStatus::Connection>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<SafeBrowsing::ServiceStatus::Connection>::__clear[abi:sn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:sn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void Platform::encodeBase64(const unsigned __int8 *a1@<X0>, const unsigned __int8 *a2@<X1>, std::string *a3@<X8>)
{
  const unsigned __int8 *v3;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  std::string::value_type *v15;
  unint64_t v16;
  _BYTE v17[4];
  std::string::value_type v18[2];
  __int16 v19;
  std::string::value_type __s[4];

  v3 = a1;
  v5 = a2 - a1;
  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  v6 = (a2 - a1) / 3uLL;
  v7 = (a2 - a1) % 3uLL;
  std::string::reserve(a3, 4 * v6 + 4 * (v7 != 0));
  if (v5 >= 3)
  {
    if (v6 <= 1)
      v6 = 1;
    do
    {
      v8 = *v3;
      __s[0] = aAbcdefghijklmn[v8 >> 2];
      v9 = v3[1];
      v10 = (v9 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v8 & 3));
      v11 = v3[2];
      v12 = (v11 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v9 & 0xF));
      LOBYTE(v9) = aAbcdefghijklmn[v10];
      LOBYTE(v10) = aAbcdefghijklmn[v12];
      __s[1] = v9;
      __s[2] = v10;
      __s[3] = aAbcdefghijklmn[v11 & 0x3F];
      std::string::append(a3, __s, 4uLL);
      v3 += 3;
      --v6;
    }
    while (v6);
  }
  if (v7 == 1)
  {
    v16 = *v3;
    v18[0] = aAbcdefghijklmn[v16 >> 2];
    v18[1] = aAbcdefghijklmn[16 * (v16 & 3)];
    v19 = 15677;
    v15 = v18;
  }
  else
  {
    if (v7 != 2)
      return;
    v13 = *v3;
    v17[0] = aAbcdefghijklmn[v13 >> 2];
    v14 = v3[1];
    v17[1] = aAbcdefghijklmn[(v14 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v13 & 3))];
    v17[2] = aAbcdefghijklmn[4 * (v14 & 0xF)];
    v17[3] = 61;
    v15 = v17;
  }
  std::string::append(a3, v15, 4uLL);
}

void Platform::decodeBase64(const char *a1@<X0>, const char *a2@<X1>, unint64_t *a3@<X8>)
{
  const char *v4;
  unint64_t v6;
  int v7;
  char *v8;
  int v9;
  int v10;
  unint64_t v11;
  _BYTE *v12;
  _BYTE *v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _BYTE *v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  _BYTE *v26;
  _BYTE *v27;
  char v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  size_t v33;
  unint64_t v34;
  char *v35;
  unint64_t v36;
  char v37;
  int v38;
  unint64_t v39;
  _BYTE *v40;
  unint64_t v41;
  unint64_t v42;
  size_t v43;
  _BYTE *v44;
  char v45;
  char __src[3];
  unsigned __int8 v47;
  unsigned __int8 v48;
  unsigned __int8 v49;
  char v50;

  v4 = a1;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, 3 * ((unint64_t)(a2 - a1) >> 2));
  if (a2 != v4)
  {
    v6 = 0;
    do
    {
      v7 = byte_1DBD17890[*v4];
      if (v7 != 255)
      {
        if (v6 >= 4)
          goto LABEL_62;
        *(&v47 + v6) = v7;
        if (v6 == 3)
        {
          v8 = (char *)a3[1];
          __src[0] = (v48 >> 4) | (4 * v47);
          __src[1] = (v49 >> 2) | (16 * v48);
          __src[2] = v50 | (v49 << 6);
          std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)a3, v8, __src, (char *)&v47, 3);
          v6 = 0;
        }
        else
        {
          ++v6;
        }
      }
      ++v4;
    }
    while (v4 != a2);
    if (v6 == 2)
    {
      v14 = (v48 >> 4) | (4 * v47);
      v16 = a3[1];
      v15 = a3[2];
      if (v16 >= v15)
      {
        v29 = *a3;
        v30 = v16 - *a3;
        v31 = v30 + 1;
        if ((uint64_t)(v30 + 1) < 0)
          goto LABEL_63;
        v32 = v15 - v29;
        if (2 * v32 > v31)
          v31 = 2 * v32;
        if (v32 >= 0x3FFFFFFFFFFFFFFFLL)
          v33 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v33 = v31;
        if (v33)
        {
          v34 = (unint64_t)operator new(v33);
          v35 = (char *)(v34 + v33);
          *(_BYTE *)(v34 + v30) = v14;
          v17 = v34 + v30 + 1;
          if (v16 == v29)
          {
            v34 += v30;
          }
          else
          {
            v36 = ~v29 + v16;
            do
            {
              v37 = *(_BYTE *)--v16;
              *(_BYTE *)(v34 + v36--) = v37;
            }
            while (v16 != v29);
            v16 = v29;
          }
          goto LABEL_56;
        }
      }
      else if (v16)
      {
        *(_BYTE *)v16 = v14;
        v17 = v16 + 1;
LABEL_60:
        a3[1] = v17;
        return;
      }
      goto LABEL_62;
    }
    if (v6 != 3)
      return;
    v9 = v48;
    v10 = (v48 >> 4) | (4 * v47);
    v12 = (_BYTE *)a3[1];
    v11 = a3[2];
    if ((unint64_t)v12 >= v11)
    {
      v18 = *a3;
      v19 = &v12[-*a3];
      v20 = (unint64_t)(v19 + 1);
      if ((uint64_t)(v19 + 1) < 0)
        goto LABEL_63;
      v21 = v11 - v18;
      if (2 * v21 > v20)
        v20 = 2 * v21;
      if (v21 >= 0x3FFFFFFFFFFFFFFFLL)
        v22 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v22 = v20;
      if (!v22)
        goto LABEL_62;
      v23 = (unint64_t)operator new(v22);
      v24 = (char *)(v23 + v22);
      v25 = &v19[v23];
      v26 = &v19[v23];
      *v26 = v10;
      v13 = v26 + 1;
      if (v12 == (_BYTE *)v18)
      {
        v23 = (unint64_t)v25;
      }
      else
      {
        v27 = &v12[~v18];
        do
        {
          v28 = *--v12;
          (v27--)[v23] = v28;
        }
        while (v12 != (_BYTE *)v18);
        v12 = (_BYTE *)v18;
      }
      *a3 = v23;
      a3[1] = (unint64_t)v13;
      a3[2] = (unint64_t)v24;
      if (v12)
        operator delete(v12);
    }
    else
    {
      if (!v12)
        goto LABEL_62;
      *v12 = v10;
      v13 = v12 + 1;
    }
    a3[1] = (unint64_t)v13;
    v38 = (v49 >> 2) | (16 * v9);
    v39 = a3[2];
    if ((unint64_t)v13 < v39)
    {
      *v13 = v38;
      v17 = (uint64_t)(v13 + 1);
      goto LABEL_60;
    }
    v16 = *a3;
    v40 = &v13[-*a3];
    v41 = (unint64_t)(v40 + 1);
    if ((uint64_t)(v40 + 1) < 0)
LABEL_63:
      abort();
    v42 = v39 - v16;
    if (2 * v42 > v41)
      v41 = 2 * v42;
    if (v42 >= 0x3FFFFFFFFFFFFFFFLL)
      v43 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v43 = v41;
    if (v43)
    {
      v34 = (unint64_t)operator new(v43);
      v35 = (char *)(v34 + v43);
      v40[v34] = v38;
      v17 = (uint64_t)&v40[v34 + 1];
      if (v13 == (_BYTE *)v16)
      {
        *a3 = (unint64_t)&v40[v34];
        a3[1] = v17;
        v16 = (unint64_t)v13;
        a3[2] = (unint64_t)v35;
LABEL_59:
        operator delete((void *)v16);
        goto LABEL_60;
      }
      v44 = &v13[~v16];
      do
      {
        v45 = *--v13;
        (v44--)[v34] = v45;
      }
      while (v13 != (_BYTE *)v16);
LABEL_56:
      *a3 = v34;
      a3[1] = v17;
      a3[2] = (unint64_t)v35;
      if (!v16)
        goto LABEL_60;
      goto LABEL_59;
    }
LABEL_62:
    __break(1u);
    goto LABEL_63;
  }
}

void std::vector<unsigned char>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2;
  char *v5;
  _BYTE *v6;
  char *v7;
  _BYTE *v8;
  char *v9;
  char v10;

  v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0)
      abort();
    v5 = (char *)a1[1];
    v6 = operator new(__sz);
    v7 = &v5[(_QWORD)v6 - v2];
    v8 = v7;
    if (v5 != (char *)v2)
    {
      v9 = &v5[~v2];
      do
      {
        v10 = *--v5;
        (v9--)[(_QWORD)v6] = v10;
      }
      while (v5 != (char *)v2);
      v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
      operator delete((void *)v2);
  }
}

void Platform::encodeURLSafeBase64(const unsigned __int8 *a1@<X0>, const unsigned __int8 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  char *v5;
  int v6;
  char v7;

  Platform::encodeBase64(a1, a2, (std::string *)a3);
  v4 = *(unsigned __int8 *)(a3 + 23);
  if ((v4 & 0x80u) == 0)
    v5 = (char *)a3;
  else
    v5 = *(char **)a3;
  if ((v4 & 0x80u) != 0)
    v4 = *(_QWORD *)(a3 + 8);
  if (v4)
  {
    while (1)
    {
      v6 = *v5;
      if (v6 == 43)
        break;
      if (v6 == 47)
      {
        v7 = 95;
LABEL_11:
        *v5 = v7;
      }
      ++v5;
      if (!--v4)
        return;
    }
    v7 = 45;
    goto LABEL_11;
  }
}

uint64_t Platform::decodeURLSafeBase64(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  size_t v4;
  char *v6;
  uint64_t v7;
  int v8;
  char v9;
  uint64_t v10;
  void *v11;
  __int128 v13;
  uint64_t v14;

  v4 = a2 - a1;
  if (a2 != a1)
  {
    if (a2 - a1 < 0)
      abort();
    v6 = (char *)operator new(a2 - a1);
    memcpy(v6, a1, v4);
    v7 = 0;
    while (1)
    {
      v8 = v6[v7];
      if (v8 > 46)
      {
        if (v8 == 95)
        {
          v9 = 47;
          goto LABEL_9;
        }
        if (v8 == 47)
        {
LABEL_15:
          v10 = 0;
          goto LABEL_20;
        }
      }
      else
      {
        if (v8 == 45)
        {
          v9 = 43;
LABEL_9:
          v6[v7] = v9;
          goto LABEL_10;
        }
        if (v8 == 43)
          goto LABEL_15;
      }
LABEL_10:
      if (v4 == ++v7)
        goto LABEL_17;
    }
  }
  v6 = 0;
LABEL_17:
  Platform::decodeBase64(v6, &v6[v4], (unint64_t *)&v13);
  v11 = *(void **)a3;
  if (*(_QWORD *)a3)
  {
    *(_QWORD *)(a3 + 8) = v11;
    operator delete(v11);
  }
  *(_OWORD *)a3 = v13;
  *(_QWORD *)(a3 + 16) = v14;
  v10 = 1;
  if (v6)
LABEL_20:
    operator delete(v6);
  return v10;
}

char *std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>(uint64_t a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  char *v18;
  int64_t v19;
  char *v20;
  char *v21;
  char *v22;
  int64_t v23;
  char v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  char v29;
  char *v30;
  char *v31;
  char *v32;
  char v33;
  char *v34;

  v5 = __dst;
  if (a5 < 1)
    return v5;
  v6 = a5;
  v7 = __src;
  v10 = *(char **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  if (v9 - (uint64_t)v10 >= a5)
  {
    v17 = v10 - __dst;
    if (v10 - __dst >= a5)
    {
      v18 = &__src[a5];
      v20 = *(char **)(a1 + 8);
    }
    else
    {
      v18 = &__src[v17];
      v19 = a4 - &__src[v17];
      if (a4 != &__src[v17])
        memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
      v20 = &v10[v19];
      *(_QWORD *)(a1 + 8) = &v10[v19];
      if (v17 < 1)
        return v5;
    }
    v21 = &v20[-v6];
    v22 = v20;
    if (&v20[-v6] >= v10)
    {
LABEL_21:
      *(_QWORD *)(a1 + 8) = v22;
      if (v20 != &v5[v6])
        memmove(&v5[v6], v5, v20 - &v5[v6]);
      if (v18 != v7)
        memmove(v5, v7, v18 - v7);
      return v5;
    }
    v23 = &v10[v6] - v20;
    v22 = v20;
    while (v22)
    {
      v24 = *v21++;
      *v22++ = v24;
      if (!--v23)
        goto LABEL_21;
    }
LABEL_40:
    __break(1u);
LABEL_41:
    abort();
  }
  v11 = *(char **)a1;
  v12 = (uint64_t)&v10[a5 - *(_QWORD *)a1];
  if (v12 < 0)
    goto LABEL_41;
  v13 = (char *)(__dst - v11);
  v14 = v9 - (_QWORD)v11;
  if (2 * v14 > v12)
    v12 = 2 * v14;
  if (v14 >= 0x3FFFFFFFFFFFFFFFLL)
    v15 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v15 = v12;
  if (v15)
    v16 = operator new(v15);
  else
    v16 = 0;
  v25 = &v13[(_QWORD)v16];
  v26 = (char *)v16 + v15;
  v27 = &v25[v6];
  v28 = v25;
  do
  {
    if (!v28)
      goto LABEL_40;
    v29 = *v7++;
    *v28++ = v29;
    --v6;
  }
  while (v6);
  v30 = *(char **)a1;
  if (*(char **)a1 == v5)
  {
    v32 = v25;
  }
  else
  {
    v31 = v5;
    v32 = v25;
    do
    {
      v33 = *--v31;
      *--v32 = v33;
    }
    while (v31 != v30);
    v10 = *(char **)(a1 + 8);
  }
  if (v10 != v5)
    memmove(v27, v5, v10 - v5);
  v34 = *(char **)a1;
  *(_QWORD *)a1 = v32;
  *(_QWORD *)(a1 + 8) = &v27[v10 - v5];
  *(_QWORD *)(a1 + 16) = v26;
  if (v34)
    operator delete(v34);
  return v25;
}

void Platform::toString(CFURLRef *a1@<X0>, _QWORD *a2@<X8>)
{
  CFIndex v4;
  void *__p;
  char *v6;

  v4 = CFURLGetBytes(*a1, 0, 0);
  std::vector<unsigned char>::vector(&__p, v4);
  CFURLGetBytes(*a1, (UInt8 *)__p, v6 - (_BYTE *)__p);
  std::string::__init_with_size[abi:sn180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(a2, (char *)__p, v6, v6 - (_BYTE *)__p);
  if (__p)
  {
    v6 = (char *)__p;
    operator delete(__p);
  }
}

CFURLRef Platform::urlWithString@<X0>(uint64_t a1@<X0>, CFURLRef *a2@<X8>)
{
  int v3;
  const UInt8 *v4;
  CFIndex v5;
  CFURLRef result;

  v3 = *(char *)(a1 + 23);
  if (v3 >= 0)
    v4 = (const UInt8 *)a1;
  else
    v4 = *(const UInt8 **)a1;
  if (v3 >= 0)
    v5 = *(unsigned __int8 *)(a1 + 23);
  else
    v5 = *(_QWORD *)(a1 + 8);
  result = CFURLCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4, v5, 0x600u, 0);
  *a2 = result;
  return result;
}

uint64_t Platform::mutableURLRequestWithURL@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result;

  result = CFURLRequestCreateMutable();
  *a1 = result;
  return result;
}

char *std::vector<unsigned char>::__vallocate[abi:sn180100](_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    abort();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

_QWORD *std::string::__init_with_size[abi:sn180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(_QWORD *result, char *a2, char *a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  if (a4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = result;
  if (a4 > 0x16)
  {
    v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17)
      v8 = a4 | 7;
    v9 = v8 + 1;
    result = operator new(v8 + 1);
    v7[1] = a4;
    v7[2] = v9 | 0x8000000000000000;
    *v7 = result;
    v7 = result;
  }
  else
  {
    *((_BYTE *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    v10 = *a2++;
    *(_BYTE *)v7 = v10;
    v7 = (_QWORD *)((char *)v7 + 1);
  }
  *(_BYTE *)v7 = 0;
  return result;
}

__n128 Backend::Google::ClientInfo::ClientInfo(uint64_t a1, __int128 *a2, __n128 *a3)
{
  __int128 v3;
  __n128 result;

  v3 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v3;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  result = *a3;
  *(_QWORD *)(a1 + 40) = a3[1].n128_u64[0];
  *(__n128 *)(a1 + 24) = result;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  a3->n128_u64[0] = 0;
  return result;
}

void Backend::Google::ClientInfo::~ClientInfo(void **this)
{
  if (*((char *)this + 47) < 0)
    operator delete(this[3]);
  if (*((char *)this + 23) < 0)
    operator delete(*this);
}

uint64_t Backend::Google::Configuration::Configuration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  void *v15;
  void *__p[2];
  uint64_t v18;
  void *v19[2];
  uint64_t v20;

  *(_OWORD *)v19 = *(_OWORD *)a2;
  v20 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_OWORD *)__p = *(_OWORD *)a3;
  v18 = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  Backend::Google::ClientInfo::ClientInfo(a1, (__int128 *)v19, (__n128 *)__p);
  if (SHIBYTE(v18) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v20) < 0)
    operator delete(v19[0]);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  objc_msgSend(MEMORY[0x1E0C92CA0], "ephemeralSessionConfiguration");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C92C98], "sessionWithConfiguration:", v4);
  v5 = objc_claimAutoreleasedReturnValue();
  v6 = *(void **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = v5;

  objc_msgSend(MEMORY[0x1E0C92CA0], "ephemeralSessionConfiguration");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "set_usesNWLoader:", 1);
  objc_msgSend(MEMORY[0x1E0C92C98], "sessionWithConfiguration:", v7);
  v8 = objc_claimAutoreleasedReturnValue();
  v9 = *(void **)(a1 + 64);
  *(_QWORD *)(a1 + 64) = v8;

  objc_msgSend(MEMORY[0x1E0C92C98], "sessionWithConfiguration:", v4);
  v10 = objc_claimAutoreleasedReturnValue();
  v11 = *(void **)(a1 + 80);
  *(_QWORD *)(a1 + 80) = v10;

  objc_msgSend(v4, "setTimeoutIntervalForRequest:", 5.0);
  objc_msgSend(v4, "set_sourceApplicationBundleIdentifier:", CFSTR("com.apple.mobilesafari"));
  objc_msgSend(MEMORY[0x1E0C92C98], "sessionWithConfiguration:", v4);
  v12 = objc_claimAutoreleasedReturnValue();
  v13 = *(void **)(a1 + 56);
  *(_QWORD *)(a1 + 56) = v12;

  objc_msgSend(v4, "set_usesNWLoader:", 1);
  objc_msgSend(MEMORY[0x1E0C92C98], "sessionWithConfiguration:", v4);
  v14 = objc_claimAutoreleasedReturnValue();
  v15 = *(void **)(a1 + 72);
  *(_QWORD *)(a1 + 72) = v14;

  return a1;
}

void sub_1DBCC20E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  id *v21;
  void *v22;

  Backend::Google::ClientInfo::~ClientInfo((Backend::Google::ClientInfo *)v21);
  _Unwind_Resume(a1);
}

void Backend::Google::Configuration::~Configuration(id *this)
{

  Backend::Google::ClientInfo::~ClientInfo((Backend::Google::ClientInfo *)this);
}

id Backend::Google::Configuration::getEncodedFullHashesRequestURLRequest(Backend::Google::Configuration *this, const Backend::Google::FindFullHashesRequestSerializer *a2, ProxyConfiguration *a3)
{
  ProxyConfiguration *v4;
  char *v5;
  void **v6;
  std::string::size_type v7;
  const std::string::value_type *v8;
  void *v9;
  std::string *v10;
  void *v11;
  void *v12;
  void *v13;
  void *__p[2];
  unsigned __int8 v16;
  void *v17;
  const unsigned __int8 *v18;
  std::string v19;

  v4 = a3;
  if (v4)
    v5 = "https://proxy-safebrowsing.googleapis.com/v4/fullHashes:find";
  else
    v5 = "https://safebrowsing.googleapis.com/v4/fullHashes:find";
  std::string::basic_string[abi:sn180100]<0>(&v19.__r_.__value_.__l.__data_, v5);
  Backend::Google::FindFullHashesRequestSerializer::serializedData(a2, (uint64_t)&v17);
  Platform::encodeURLSafeBase64((const unsigned __int8 *)v17, v18, (uint64_t)__p);
  std::string::append(&v19, "?$ct=application%2Fx-protobuf&$req=", 0x23uLL);
  if ((v16 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v16 & 0x80u) == 0)
    v7 = v16;
  else
    v7 = (std::string::size_type)__p[1];
  std::string::append(&v19, (const std::string::value_type *)v6, v7);
  std::string::append(&v19, "&key=", 5uLL);
  if (Backend::Google::apiKeyForGoogle(void)::once != -1)
    dispatch_once(&Backend::Google::apiKeyForGoogle(void)::once, &__block_literal_global_0);
  if (Backend::Google::apiKeyForGoogle(void)::useTestAPIKey)
    v8 = "AIzaSyDpdAf08lCB2h18kkhS4_j1xrHKgayn0R4";
  else
    v8 = "AIzaSyANT-dOXDTNxZS4flEImFNycnoeDh4ehQI";
  std::string::append(&v19, v8);
  v9 = (void *)MEMORY[0x1E0C99E98];
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v10 = &v19;
  else
    v10 = (std::string *)v19.__r_.__value_.__r.__words[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "URLWithString:", v11);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  Backend::Google::makeRequest(v12, 1, v4);
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  if ((char)v16 < 0)
    operator delete(__p[0]);
  if (v17)
  {
    v18 = (const unsigned __int8 *)v17;
    operator delete(v17);
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);

  return v13;
}

void sub_1DBCC2354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  void *v24;
  void *v25;

  if (a15 < 0)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  if (a24 < 0)
    operator delete(a19);

  _Unwind_Resume(a1);
}

id Backend::Google::makeRequest(void *a1, int a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;

  v5 = a1;
  v6 = a3;
  v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C92C28]), "initWithURL:", v5);
  v8 = v7;
  if (!a2)
    objc_msgSend(v7, "setAllowsCellularAccess:", 0);
  objc_msgSend(v8, "setNetworkServiceType:", 5);
  objc_msgSend(v8, "_setNonAppInitiated:", 1);
  objc_msgSend(v8, "setValue:forHTTPHeaderField:", CFSTR("POST"), CFSTR("X-HTTP-Method-Override"));
  objc_msgSend(v6, "applyToRequest:", v8);

  return v8;
}

void sub_1DBCC2470(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id Backend::Google::Configuration::getEncodedUpdatesRequestURLRequest(uint64_t a1, Backend::Google::FetchThreatListUpdatesRequestSerializer *a2, int a3, void *a4)
{
  id v6;
  char *v7;
  void **v8;
  std::string::size_type v9;
  const std::string::value_type *v10;
  void *v11;
  std::string *v12;
  void *v13;
  void *v14;
  void *v15;
  void *__p[2];
  unsigned __int8 v18;
  void *v19;
  const unsigned __int8 *v20;
  std::string v21;

  v6 = a4;
  if (v6)
    v7 = "https://proxy-safebrowsing.googleapis.com/v4/threatListUpdates:fetch";
  else
    v7 = "https://safebrowsing.googleapis.com/v4/threatListUpdates:fetch";
  std::string::basic_string[abi:sn180100]<0>(&v21.__r_.__value_.__l.__data_, v7);
  Backend::Google::FetchThreatListUpdatesRequestSerializer::serializedData(a2, (uint64_t)&v19);
  Platform::encodeURLSafeBase64((const unsigned __int8 *)v19, v20, (uint64_t)__p);
  std::string::append(&v21, "?$ct=application%2Fx-protobuf&$req=", 0x23uLL);
  if ((v18 & 0x80u) == 0)
    v8 = __p;
  else
    v8 = (void **)__p[0];
  if ((v18 & 0x80u) == 0)
    v9 = v18;
  else
    v9 = (std::string::size_type)__p[1];
  std::string::append(&v21, (const std::string::value_type *)v8, v9);
  std::string::append(&v21, "&key=", 5uLL);
  if (Backend::Google::apiKeyForGoogle(void)::once != -1)
    dispatch_once(&Backend::Google::apiKeyForGoogle(void)::once, &__block_literal_global_0);
  if (Backend::Google::apiKeyForGoogle(void)::useTestAPIKey)
    v10 = "AIzaSyDpdAf08lCB2h18kkhS4_j1xrHKgayn0R4";
  else
    v10 = "AIzaSyANT-dOXDTNxZS4flEImFNycnoeDh4ehQI";
  std::string::append(&v21, v10);
  v11 = (void *)MEMORY[0x1E0C99E98];
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &v21;
  else
    v12 = (std::string *)v21.__r_.__value_.__r.__words[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v12);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "URLWithString:", v13);
  v14 = (void *)objc_claimAutoreleasedReturnValue();

  Backend::Google::makeRequest(v14, (a3 - 1) < 2, v6);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  if ((char)v18 < 0)
    operator delete(__p[0]);
  if (v19)
  {
    v20 = (const unsigned __int8 *)v19;
    operator delete(v19);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);

  return v15;
}

void sub_1DBCC2640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  void *v24;
  void *v25;

  if (a15 < 0)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  if (a24 < 0)
    operator delete(a19);

  _Unwind_Resume(a1);
}

id Backend::Google::Configuration::getDeviceIdentificationTokenRequestURLRequest(Backend::Google::Configuration *this)
{
  void *v1;
  void **v2;
  void *v3;
  void *v4;
  void *v5;
  void *__p[2];
  char v8;

  std::string::basic_string[abi:sn180100]<0>((char **)__p, "https://token.safebrowsing.apple/api/v1/google.json");
  v1 = (void *)MEMORY[0x1E0C99E98];
  if (v8 >= 0)
    v2 = __p;
  else
    v2 = (void **)__p[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "URLWithString:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C92C28]), "initWithURL:", v4);
  objc_msgSend(v5, "setNetworkServiceType:", 5);
  objc_msgSend(v5, "_setNonAppInitiated:", 1);

  if (v8 < 0)
    operator delete(__p[0]);
  return v5;
}

void sub_1DBCC2778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;

  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

id Backend::Google::Configuration::getEncodedUpdatesRequestURLRequestForTencent(uint64_t a1, Backend::Google::FetchThreatListUpdatesRequestJSONSerializer *a2, int a3)
{
  void *v5;
  void *v6;
  void *v7;
  void *__p[2];
  char v10;

  std::string::basic_string[abi:sn180100]<0>((char **)__p, "x3dFV-lKdZ-HyfqFgedjQAIzaSyBbT4JTuz7jdG");
  Backend::Google::getURL("https://safebrowsing.urlsec.qq.com/v4/threatListUpdates:fetch", (uint64_t)__p);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (v10 < 0)
    operator delete(__p[0]);
  Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::serializedData(a2);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  Backend::Google::makeRequest(v5, v6, (a3 - 1) < 2, 1, 1);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  return v7;
}

void sub_1DBCC2864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

id Backend::Google::getURL(char *__s, uint64_t a2)
{
  int v3;
  const std::string::value_type *v4;
  std::string::size_type v5;
  void *v6;
  std::string *v7;
  void *v8;
  void *v9;
  std::string v11;

  std::string::basic_string[abi:sn180100]<0>(&v11.__r_.__value_.__l.__data_, __s);
  std::string::append(&v11, "?key=", 5uLL);
  v3 = *(char *)(a2 + 23);
  if (v3 >= 0)
    v4 = (const std::string::value_type *)a2;
  else
    v4 = *(const std::string::value_type **)a2;
  if (v3 >= 0)
    v5 = *(unsigned __int8 *)(a2 + 23);
  else
    v5 = *(_QWORD *)(a2 + 8);
  std::string::append(&v11, v4, v5);
  v6 = (void *)MEMORY[0x1E0C99E98];
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v7 = &v11;
  else
    v7 = (std::string *)v11.__r_.__value_.__r.__words[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "URLWithString:", v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v11.__r_.__value_.__l.__data_);
  return v9;
}

void sub_1DBCC2958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;

  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

id Backend::Google::makeRequest(void *a1, void *a2, int a3, int a4, int a5)
{
  id v9;
  id v10;
  void *v11;
  void *v12;
  const __CFString *v13;

  v9 = a1;
  v10 = a2;
  v11 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C92C28]), "initWithURL:", v9);
  v12 = v11;
  if (!a3)
    objc_msgSend(v11, "setAllowsCellularAccess:", 0);
  if (!a5)
    objc_msgSend(v12, "_setPrivacyProxyFailClosed:", 1);
  objc_msgSend(v12, "setNetworkServiceType:", 5);
  objc_msgSend(v12, "_setNonAppInitiated:", 1);
  objc_msgSend(v12, "setValue:forHTTPHeaderField:", CFSTR("POST"), CFSTR("X-HTTP-Method-Override"));
  if (a4 == 2)
  {
    v13 = CFSTR("application/x-protobuf");
    goto LABEL_9;
  }
  if (a4 == 1)
  {
    v13 = CFSTR("application/json");
LABEL_9:
    objc_msgSend(v12, "setValue:forHTTPHeaderField:", v13, CFSTR("Content-Type"));
  }
  objc_msgSend(v12, "setHTTPMethod:", CFSTR("POST"));
  objc_msgSend(v12, "setHTTPBody:", v10);

  return v12;
}

void sub_1DBCC2A8C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id Backend::Google::Configuration::getEncodedFullHashesRequestURLRequestForTencent(Backend::Google::Configuration *this, const Backend::Google::FindFullHashesRequestJSONSerializer *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *__p[2];
  char v8;

  std::string::basic_string[abi:sn180100]<0>((char **)__p, "x3dFV-lKdZ-HyfqFgedjQAIzaSyBbT4JTuz7jdG");
  Backend::Google::getURL("https://safebrowsing.urlsec.qq.com/v4/fullHashes:find", (uint64_t)__p);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v8 < 0)
    operator delete(__p[0]);
  Backend::Google::FindFullHashesRequestJSONSerializer::serializedData(a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  Backend::Google::makeRequest(v3, v4, 1, 1, 1);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

void sub_1DBCC2B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  void *v16;
  void *v17;

  v17 = v16;

  _Unwind_Resume(a1);
}

id Backend::Google::Configuration::getEncodedUpdatesRequestURLRequestForApple(uint64_t a1, Backend::Google::FetchThreatListUpdatesRequestJSONSerializer *a2, int a3)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v5 = (void *)MEMORY[0x1E0C99E98];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "https://websitereview.corp.apple.com/v4/threatListUpdates:fetch");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "URLWithString:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::serializedData(a2);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  Backend::Google::makeRequest(v7, v8, (a3 - 1) < 2, 1, 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  return v9;
}

void sub_1DBCC2C2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id Backend::Google::Configuration::getEncodedFullHashesRequestURLRequestForApple(Backend::Google::Configuration *this, const Backend::Google::FindFullHashesRequestJSONSerializer *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v3 = (void *)MEMORY[0x1E0C99E98];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "https://websitereview.corp.apple.com/v4/fullHashes:find");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "URLWithString:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  Backend::Google::FindFullHashesRequestJSONSerializer::serializedData(a2);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  Backend::Google::makeRequest(v5, v6, 1, 1, 0);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  return v7;
}

void sub_1DBCC2CF0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id Backend::Google::Configuration::getEncodedUpdatesRequestURLRequestForAppleProtobuf(int a1, Backend::Google::FetchThreatListUpdatesRequestSerializer *this, int a3)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *__p;
  _BYTE *v11;

  Backend::Google::FetchThreatListUpdatesRequestSerializer::serializedData(this, (uint64_t)&__p);
  objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", __p, v11 - (_BYTE *)__p);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = (void *)MEMORY[0x1E0C99E98];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "https://websitereview.corp.apple.com/v4/threatListUpdates:fetch");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "URLWithString:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  Backend::Google::makeRequest(v7, v4, (a3 - 1) < 2, 2, 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  if (__p)
  {
    v11 = __p;
    operator delete(__p);
  }
  return v8;
}

void sub_1DBCC2DEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  void *v11;
  void *v12;

  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

id Backend::Google::Configuration::getEncodedFullHashesRequestURLRequestForAppleProtobuf(Backend::Google::Configuration *this, const Backend::Google::FindFullHashesRequestSerializer *a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *__p;
  _BYTE *v9;

  Backend::Google::FindFullHashesRequestSerializer::serializedData(a2, (uint64_t)&__p);
  objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", __p, v9 - (_BYTE *)__p);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (void *)MEMORY[0x1E0C99E98];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "https://websitereview.corp.apple.com/v4/fullHashes:find");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "URLWithString:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  Backend::Google::makeRequest(v5, v2, 1, 2, 0);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
  return v6;
}

void sub_1DBCC2EF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  void *v11;
  void *v12;
  void *v13;

  v13 = v12;

  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

char **std::string::basic_string[abi:sn180100]<0>(char **a1, char *__s)
{
  size_t v4;
  size_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;

  if (!__s)
    goto LABEL_15;
  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_16;
  v5 = v4;
  if (v4 > 0x16)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = (char *)operator new(v7 + 1);
    a1[1] = (char *)v5;
    a1[2] = (char *)(v8 | 0x8000000000000000);
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = (char *)a1;
  }
  v9 = &v6[v5];
  if (v6 <= __s && v9 > __s)
  {
LABEL_15:
    __break(1u);
LABEL_16:
    abort();
  }
  if (v5)
    memmove(v6, __s, v5);
  *v9 = 0;
  return a1;
}

void ___ZN7Backend6GoogleL15apiKeyForGoogleEv_block_invoke(Backend::Google::SSBUtilities *a1)
{
  void *v1;
  NSObject *v2;
  uint8_t v3[16];

  if (Backend::Google::SSBUtilities::isInternalInstall(a1))
  {
    objc_msgSend(MEMORY[0x1E0C99EA0], "standardUserDefaults");
    v1 = (void *)objc_claimAutoreleasedReturnValue();
    Backend::Google::apiKeyForGoogle(void)::useTestAPIKey = objc_msgSend(v1, "BOOLForKey:", CFSTR("DebugSafeBrowsingShouldUseTestAPIKeyForGoogle"));

    if (Backend::Google::apiKeyForGoogle(void)::useTestAPIKey)
    {
      v2 = SSBOSLogPlatform();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v3 = 0;
        _os_log_impl(&dword_1DBCBE000, v2, OS_LOG_TYPE_DEFAULT, "Using Google Test API Key", v3, 2u);
      }
    }
  }
  else
  {
    Backend::Google::apiKeyForGoogle(void)::useTestAPIKey = 0;
  }
}

void sub_1DBCC3090(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double Backend::Google::Database::Database(Backend::Google::Database *this)
{
  double result;

  *((_BYTE *)this + 48) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 7) = 0;
  result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_BYTE *)this + 32) = 0;
  return result;
}

void Backend::Google::Database::~Database(Backend::Google::Database *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 7);
  if (v2)
  {
    *((_QWORD *)this + 8) = v2;
    operator delete(v2);
  }
}

uint64_t Backend::Google::Database::initialize(Backend::Google::Database *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  *(_QWORD *)a1 = a2;
  *((_QWORD *)a1 + 1) = a3;
  result = Backend::Google::Database::read(a1);
  if ((result & 1) == 0)
  {
    *(_QWORD *)a1 = 0;
    *((_QWORD *)a1 + 1) = 0;
  }
  return result;
}

uint64_t Backend::Google::Database::read(Backend::Google::Database *this)
{
  unint64_t v1;
  unint64_t v3;
  unsigned int v4;
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 *v10;

  v1 = *((_QWORD *)this + 1);
  if ((uint64_t)v1 < 4)
    return 0;
  v3 = *(_QWORD *)this;
  if (bswap32(**(_DWORD **)this) != 1196638788)
    return 0;
  if (v1 < 8)
    return 0;
  v4 = bswap32(*(_DWORD *)(v3 + 4));
  v10 = (unsigned __int8 *)(v3 + 8);
  if (v4 != 2)
    return 0;
  v9 = 0;
  result = Backend::Google::Database::readUInt64(this, (const unsigned __int8 **)&v10, &v9);
  if ((_DWORD)result)
  {
    *((_QWORD *)this + 2) = 1000000 * v9;
    v8 = 0;
    result = Backend::Google::Database::readUInt64(this, (const unsigned __int8 **)&v10, &v8);
    if ((_DWORD)result)
    {
      *((_QWORD *)this + 3) = 1000000 * v8;
      if (v3 > (unint64_t)v10)
        return 0;
      if ((unint64_t)(v10 + 4) > v3 + v1)
        return 0;
      v6 = bswap32(*(_DWORD *)v10);
      if (v1 < v6)
        return 0;
      if ((unint64_t)(v10 + 8) > v3 + v1)
        return 0;
      v7 = bswap32(*((_DWORD *)v10 + 1));
      if (v1 < v7)
        return 0;
      result = Backend::Google::Database::readClientState(this, (const unsigned __int8 *)(v3 + v6));
      if ((_DWORD)result)
        return Backend::Google::Database::readSizeBuckets(this, (const unsigned __int8 *)(v3 + v7));
    }
  }
  return result;
}

uint64_t Backend::Google::Database::readUInt32(Backend::Google::Database *this, const unsigned __int8 **a2, unsigned int *a3)
{
  unint64_t v3;

  v3 = (unint64_t)*a2;
  if (*(_QWORD *)this > (unint64_t)*a2 || v3 + 4 > *(_QWORD *)this + *((_QWORD *)this + 1))
    return 0;
  *a3 = bswap32(*(_DWORD *)v3);
  *a2 = (const unsigned __int8 *)(v3 + 4);
  return 1;
}

uint64_t Backend::Google::Database::readUInt64(Backend::Google::Database *this, const unsigned __int8 **a2, unint64_t *a3)
{
  unsigned __int8 *v3;

  v3 = (unsigned __int8 *)*a2;
  if (*(_QWORD *)this > (unint64_t)*a2 || (unint64_t)(v3 + 8) > *(_QWORD *)this + *((_QWORD *)this + 1))
    return 0;
  *a3 = ((unint64_t)*v3 << 56) | ((unint64_t)v3[1] << 48) | ((unint64_t)v3[2] << 40) | ((unint64_t)v3[3] << 32) | (v3[4] << 24) | ((unint64_t)v3[5] << 16) | ((unint64_t)v3[6] << 8) | v3[7];
  *a2 = v3 + 8;
  return 1;
}

uint64_t Backend::Google::Database::readOffset(Backend::Google::Database *this, unsigned int **a2, const unsigned __int8 **a3)
{
  unsigned int *v3;
  const unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = *a2;
  if (*(_QWORD *)this > (unint64_t)*a2)
    return 0;
  v4 = (const unsigned __int8 *)(v3 + 1);
  v5 = *((_QWORD *)this + 1);
  if ((unint64_t)(v3 + 1) > *(_QWORD *)this + v5)
    return 0;
  v6 = bswap32(*v3);
  *a2 = (unsigned int *)v4;
  if (v5 < v6)
    return 0;
  *a3 = (const unsigned __int8 *)(*(_QWORD *)this + v6);
  return 1;
}

uint64_t Backend::Google::Database::readClientState(Backend::Google::Database *this, const unsigned __int8 *a2)
{
  const unsigned __int8 *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v7;

  if (*(_QWORD *)this > (unint64_t)a2)
    return 0;
  v2 = a2 + 4;
  v3 = *(_QWORD *)this + *((_QWORD *)this + 1);
  if ((unint64_t)(a2 + 4) > v3)
    return 0;
  v4 = bswap32(*(_DWORD *)a2);
  if ((unint64_t)&v2[v4] > v3)
    return 0;
  v7 = *((unsigned __int8 *)this + 48);
  v5 = 1;
  *((_QWORD *)this + 4) = v2;
  *((_QWORD *)this + 5) = v4;
  if (!v7)
    *((_BYTE *)this + 48) = 1;
  return v5;
}

BOOL Backend::Google::Database::readSizeBuckets(Backend::Google::Database *this, const unsigned __int8 *a2)
{
  unint64_t v3;
  const unsigned __int8 *v4;
  _BOOL8 result;
  const unsigned __int8 *v7;
  unsigned __int8 v8;
  unsigned int v9;
  const unsigned __int8 *v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  unsigned __int8 *v22;
  char *v23;
  char *v24;
  unsigned __int8 *v25;

  v3 = *(_QWORD *)this;
  v4 = (const unsigned __int8 *)(*(_QWORD *)this + *((_QWORD *)this + 1));
  result = v4 == a2;
  if (v3 <= (unint64_t)a2 && v4 != a2)
  {
    v7 = a2;
    while (v7 + 4 <= v4)
    {
      v8 = v7[3];
      v9 = _byteswap_ulong(*(_DWORD *)v7);
      if (v9 - 33 < 0xFFFFFFE3)
        break;
      v10 = v7 + 8;
      if (v7 + 8 > v4)
        break;
      v11 = bswap32(*((_DWORD *)v7 + 1));
      v7 = &v10[v11 * v9];
      if (v7 > v4)
        break;
      v12 = *((_QWORD *)this + 8);
      v13 = *((_QWORD *)this + 9);
      if (v12 >= v13)
      {
        v15 = *((_QWORD *)this + 7);
        v16 = (uint64_t)(v12 - v15) >> 4;
        v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 60)
          goto LABEL_35;
        v18 = v13 - v15;
        if (v18 >> 3 > v17)
          v17 = v18 >> 3;
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0)
          v19 = 0xFFFFFFFFFFFFFFFLL;
        else
          v19 = v17;
        if (!v19
          || (v20 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::Database::HashSizeBucket>>((uint64_t)this + 72, v19)) == 0)
        {
LABEL_34:
          __break(1u);
LABEL_35:
          abort();
        }
        v22 = (unsigned __int8 *)&v20[16 * v16];
        *v22 = v8;
        *((_DWORD *)v22 + 1) = v11;
        *((_QWORD *)v22 + 1) = v10;
        v24 = (char *)*((_QWORD *)this + 7);
        v23 = (char *)*((_QWORD *)this + 8);
        v25 = v22;
        if (v23 != v24)
        {
          do
          {
            *((_OWORD *)v25 - 1) = *((_OWORD *)v23 - 1);
            v25 -= 16;
            v23 -= 16;
          }
          while (v23 != v24);
          v23 = (char *)*((_QWORD *)this + 7);
        }
        v14 = (char *)(v22 + 16);
        *((_QWORD *)this + 7) = v25;
        *((_QWORD *)this + 8) = v22 + 16;
        *((_QWORD *)this + 9) = &v20[16 * v21];
        if (v23)
          operator delete(v23);
      }
      else
      {
        if (!v12)
          goto LABEL_34;
        *(_BYTE *)v12 = v8;
        *(_DWORD *)(v12 + 4) = v11;
        v14 = (char *)(v12 + 16);
        *(_QWORD *)(v12 + 8) = v10;
      }
      *((_QWORD *)this + 8) = v14;
      v4 = (const unsigned __int8 *)(*(_QWORD *)this + *((_QWORD *)this + 1));
      result = v7 == v4;
      if (*(_QWORD *)this > (unint64_t)v7 || v7 == v4)
        return result;
    }
    return 0;
  }
  return result;
}

BOOL Backend::Google::Database::isValidPointer(Backend::Google::Database *this, const unsigned __int8 *a2, uint64_t a3)
{
  _BOOL8 result;

  result = 0;
  if ((a3 & 0x8000000000000000) == 0 && *(_QWORD *)this <= (unint64_t)a2)
    return (unint64_t)&a2[a3] <= *(_QWORD *)this + *((_QWORD *)this + 1);
  return result;
}

uint64_t Backend::Google::Database::readOffset(Backend::Google::Database *this, const unsigned __int8 **a2, unsigned int *a3)
{
  uint64_t result;

  result = Backend::Google::Database::readUInt32(this, a2, a3);
  if ((_DWORD)result)
    return *((_QWORD *)this + 1) >= (uint64_t)*a3;
  return result;
}

BOOL Backend::Google::Database::isValidOffset(Backend::Google::Database *this, unsigned int a2)
{
  return *((_QWORD *)this + 1) >= (uint64_t)a2;
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::Database::HashSizeBucket>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(16 * a2);
}

void std::__throw_bad_array_new_length[abi:sn180100]()
{
  abort();
}

uint64_t ReadByteOperation::await_ready(ReadByteOperation *this)
{
  char v1;
  _QWORD *v2;
  int v3;
  uint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;

  v2 = *(_QWORD **)this;
  v3 = *(unsigned __int8 *)(*(_QWORD *)this + 72);
  if (v3 == 2)
  {
    v6 = 1;
LABEL_8:
    *((_QWORD *)this + 2) = v6;
    v1 = 1;
    return v1 & 1;
  }
  if (v3 == 1)
  {
    v6 = 0;
    goto LABEL_8;
  }
  if (!*(_BYTE *)(*(_QWORD *)this + 72))
  {
    v4 = v2[7];
    if (!v4)
    {
      v1 = 0;
      return v1 & 1;
    }
    ++v2[8];
    v5 = (unsigned __int8 *)v2[6];
    v2[6] = v5 + 1;
    v2[7] = v4 - 1;
    v6 = *v5 | 0x100000000;
    goto LABEL_8;
  }
  return v1 & 1;
}

_QWORD *ReadByteOperation::await_suspend(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *result;
  uint64_t v4;
  _QWORD v5[3];
  _QWORD *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v5[0] = off_1EA3EB610;
  v5[1] = a1;
  v5[2] = a2;
  v6 = v5;
  std::__function::__value_func<void ()(std::optional<ReadStatus>)>::operator=[abi:sn180100]((_QWORD *)(v2 + 16), (uint64_t)v5);
  result = v6;
  if (v6 == v5)
  {
    v4 = 4;
    result = v5;
  }
  else
  {
    if (!v6)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

_QWORD *std::__function::__value_func<void ()(std::optional<ReadStatus>)>::operator=[abi:sn180100](_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (_QWORD *)a1[3];
  a1[3] = 0;
  if (v4 == a1)
  {
    v5 = 4;
    v4 = a1;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  v6 = *(_QWORD *)(a2 + 24);
  if (v6)
  {
    if (v6 == a2)
    {
      a1[3] = a1;
      (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v6;
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

__n128 std::__function::__func<ReadByteOperation::await_suspend(std::coroutine_handle<void>)::$_0,std::allocator<ReadByteOperation::await_suspend(std::coroutine_handle<void>)::$_0>,void ()(std::optional<ReadStatus>)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = off_1EA3EB610;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ReadByteOperation::await_suspend(std::coroutine_handle<void>)::$_0,std::allocator<ReadByteOperation::await_suspend(std::coroutine_handle<void>)::$_0>,void ()(std::optional<ReadStatus>)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = off_1EA3EB610;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<ReadByteOperation::await_suspend(std::coroutine_handle<void>)::$_0,std::allocator<ReadByteOperation::await_suspend(std::coroutine_handle<void>)::$_0>,void ()(std::optional<ReadStatus>)>::operator()(uint64_t result, _WORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned int v6;
  uint64_t v7;

  v2 = *(_QWORD **)(result + 8);
  if ((unsigned __int16)*a2 >= 0x100u)
  {
    v7 = 0;
    v6 = *a2 != 0;
  }
  else
  {
    v3 = *v2;
    v4 = *(_QWORD *)(*v2 + 56);
    ++*(_QWORD *)(*v2 + 64);
    if (!v4)
      goto LABEL_8;
    v5 = *(unsigned __int8 **)(v3 + 48);
    *(_QWORD *)(v3 + 48) = v5 + 1;
    *(_QWORD *)(v3 + 56) = v4 - 1;
    v6 = *v5;
    v7 = 0x100000000;
  }
  v2[2] = v7 | v6;
  result = *(_QWORD *)(result + 16);
  if (result && *(_QWORD *)result)
    return (*(uint64_t (**)(void))result)();
LABEL_8:
  __break(1u);
  return result;
}

uint64_t Backend::Google::DatabaseInfo::DatabaseInfo(uint64_t a1, _OWORD *a2)
{
  *(_OWORD *)a1 = *a2;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  Backend::Google::Database::Database((Backend::Google::Database *)(a1 + 32));
  return a1;
}

void sub_1DBCC38D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

void Backend::Google::DatabaseInfo::~DatabaseInfo(Backend::Google::DatabaseInfo *this)
{
  Backend::Google::Database::~Database((Backend::Google::DatabaseInfo *)((char *)this + 32));
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 16);
}

uint64_t std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void sub_1DBCC3D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id location, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, id a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23)
{
  void *v23;
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v28;
  uint64_t v29;

  v28 = *(_QWORD **)(v26 - 80);
  if (v28 == v25)
  {
    v29 = 4;
    v28 = (_QWORD *)(v26 - 104);
  }
  else
  {
    if (!v28)
      goto LABEL_6;
    v29 = 5;
  }
  (*(void (**)(void))(*v28 + 8 * v29))();
LABEL_6:
  -[_SSBDatabaseUpdateFetchDataSessionHandler initWithCompletionHandler:provider:]::$_0::~$_0(&a23);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a15);
  operator delete(v24);
  -[_SSBDatabaseUpdateFetchDataSessionHandler initWithCompletionHandler:provider:]::$_0::~$_0(&a18);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a9);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<ByteProvider>::operator=[abi:sn180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_1DBCC3EC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1DBCC3F5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

_QWORD *ByteProvider::dataReceived(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  __int16 v9;
  _BYTE v10[24];
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return result;
  v3 = result;
  result[6] = a2;
  result[7] = a3;
  v4 = (_QWORD *)result[5];
  if (v4)
  {
    v5 = result + 2;
    if (v4 == result + 2)
    {
      v11 = v10;
      (*(void (**)(_QWORD *, _BYTE *))(result[2] + 24))(result + 2, v10);
      v7 = (_QWORD *)v3[5];
      v3[5] = 0;
      if (v7 == v5)
      {
        v8 = 4;
      }
      else
      {
        if (!v7)
          goto LABEL_7;
        v8 = 5;
        v5 = v7;
      }
      (*(void (**)(_QWORD *))(*v5 + 8 * v8))(v5);
      goto LABEL_7;
    }
    v11 = (_BYTE *)result[5];
  }
  else
  {
    v11 = 0;
  }
  result[5] = 0;
LABEL_7:
  result = v11;
  if (!v11)
    return result;
  v9 = 0;
  (*(void (**)(_BYTE *, __int16 *))(*(_QWORD *)v11 + 48))(v11, &v9);
  result = v11;
  if (v11 == v10)
  {
    v6 = 4;
    result = v10;
  }
  else
  {
    if (!v11)
      return result;
    v6 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v6))();
}

void sub_1DBCC40A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1DBCC4144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void logDataLength(unint64_t a1, int a2)
{
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  unint64_t v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = SSBOSLogDownload();
  v5 = v4;
  if (a1 <= 0x400000)
  {
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      return;
    v9 = 134218240;
    v10 = a1;
    v11 = 1024;
    v12 = a2;
    v6 = "Fetched update: %lu bytes, provider %i";
    v7 = v5;
    v8 = OS_LOG_TYPE_INFO;
  }
  else
  {
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      return;
    v9 = 134218240;
    v10 = a1;
    v11 = 1024;
    v12 = a2;
    v6 = "Fetched large update: %lu bytes, provider %i";
    v7 = v5;
    v8 = OS_LOG_TYPE_DEFAULT;
  }
  _os_log_impl(&dword_1DBCBE000, v7, v8, v6, (uint8_t *)&v9, 0x12u);
}

_QWORD *ByteProvider::readFailedWithError(ByteProvider *this)
{
  ByteProvider *v2;
  _QWORD *v3;
  _QWORD *result;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  __int16 v8;
  _BYTE v9[24];
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = (ByteProvider *)*((_QWORD *)this + 5);
  if (!v2)
  {
    v10 = 0;
    goto LABEL_5;
  }
  v3 = (_QWORD *)((char *)this + 16);
  if (v2 != (ByteProvider *)((char *)this + 16))
  {
    v10 = (_BYTE *)*((_QWORD *)this + 5);
LABEL_5:
    *((_QWORD *)this + 5) = 0;
    goto LABEL_6;
  }
  v10 = v9;
  (*(void (**)(char *, _BYTE *))(*((_QWORD *)this + 2) + 24))((char *)this + 16, v9);
  v6 = (_QWORD *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v6 == v3)
  {
    v7 = 4;
  }
  else
  {
    if (!v6)
      goto LABEL_6;
    v7 = 5;
    v3 = v6;
  }
  (*(void (**)(_QWORD *))(*v3 + 8 * v7))(v3);
LABEL_6:
  result = v10;
  if (v10)
  {
    v8 = 256;
    (*(void (**)(_BYTE *, __int16 *))(*(_QWORD *)v10 + 48))(v10, &v8);
    result = v10;
    if (v10 == v9)
    {
      v5 = 4;
      result = v9;
      goto LABEL_14;
    }
    if (v10)
    {
      v5 = 5;
LABEL_14:
      result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v5))();
    }
  }
  *((_BYTE *)this + 72) = 1;
  return result;
}

void sub_1DBCC4378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *ByteProvider::finishedReadingSuccessfully(ByteProvider *this)
{
  ByteProvider *v2;
  _QWORD *v3;
  _QWORD *result;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  __int16 v8;
  _BYTE v9[24];
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = (ByteProvider *)*((_QWORD *)this + 5);
  if (!v2)
  {
    v10 = 0;
    goto LABEL_5;
  }
  v3 = (_QWORD *)((char *)this + 16);
  if (v2 != (ByteProvider *)((char *)this + 16))
  {
    v10 = (_BYTE *)*((_QWORD *)this + 5);
LABEL_5:
    *((_QWORD *)this + 5) = 0;
    goto LABEL_6;
  }
  v10 = v9;
  (*(void (**)(char *, _BYTE *))(*((_QWORD *)this + 2) + 24))((char *)this + 16, v9);
  v6 = (_QWORD *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v6 == v3)
  {
    v7 = 4;
  }
  else
  {
    if (!v6)
      goto LABEL_6;
    v7 = 5;
    v3 = v6;
  }
  (*(void (**)(_QWORD *))(*v3 + 8 * v7))(v3);
LABEL_6:
  result = v10;
  if (v10)
  {
    v8 = 257;
    (*(void (**)(_BYTE *, __int16 *))(*(_QWORD *)v10 + 48))(v10, &v8);
    result = v10;
    if (v10 == v9)
    {
      v5 = 4;
      result = v9;
      goto LABEL_14;
    }
    if (v10)
    {
      v5 = 5;
LABEL_14:
      result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v5))();
    }
  }
  *((_BYTE *)this + 72) = 2;
  return result;
}

void sub_1DBCC44D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t Backend::Google::DatabaseUpdater::DatabaseUpdater(uint64_t a1, uint64_t a2, void *a3, const Backend::Google::Configuration *a4, __int128 *a5, const Backend::Google::ThreatListDescriptor **a6, uint64_t a7)
{
  id v13;
  id v14;
  __int128 v15;
  unsigned int v16;
  unsigned int v17;
  NSObject *v18;
  dispatch_queue_t v19;
  void *v20;
  const Backend::Google::ThreatListDescriptor *v21;
  const Backend::Google::ThreatListDescriptor *v22;
  unint64_t v23;
  uint64_t v24;
  std::random_device v26;
  __int128 v27;
  uint64_t v28;

  v13 = a3;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = a2;
  v14 = v13;
  *(_QWORD *)(a1 + 24) = v14;
  Backend::Google::Configuration::Configuration((std::string *)(a1 + 32), a4);
  v15 = *a5;
  *(_QWORD *)(a1 + 136) = *((_QWORD *)a5 + 2);
  *(_OWORD *)(a1 + 120) = v15;
  *((_QWORD *)a5 + 1) = 0;
  *((_QWORD *)a5 + 2) = 0;
  *(_QWORD *)a5 = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  std::random_device::random_device[abi:sn180100](&v26);
  v16 = MEMORY[0x1DF0B88FC](&v26);
  v17 = v16 + ((v16 / 0x7FFFFFFF) | ((v16 / 0x7FFFFFFF) << 31));
  if (v17 <= 1)
    v17 = 1;
  *(_DWORD *)(a1 + 176) = v17;
  std::random_device::~random_device(&v26);
  std::string::basic_string[abi:sn180100]<0>((char **)&v27, "Database Update back-off");
  *(_OWORD *)(a1 + 184) = v27;
  *(_QWORD *)(a1 + 200) = v28;
  v28 = 0;
  v27 = 0uLL;
  *(_QWORD *)(a1 + 208) = a1 + 176;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = a7;
  dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  v18 = objc_claimAutoreleasedReturnValue();
  v19 = dispatch_queue_create("com.apple.SafeBrowsing.Backend.Google.DatabaseUpdater", v18);
  v20 = *(void **)(a1 + 168);
  *(_QWORD *)(a1 + 168) = v19;

  v21 = *a6;
  v22 = a6[1];
  while (v21 != v22)
  {
    Backend::Google::DatabaseInfo::DatabaseInfo((Backend::Google::DatabaseInfo *)&v26, v21);
    v23 = *(_QWORD *)(a1 + 152);
    if (v23 >= *(_QWORD *)(a1 + 160))
    {
      v24 = std::vector<Backend::Google::DatabaseInfo>::__push_back_slow_path<Backend::Google::DatabaseInfo>((uint64_t *)(a1 + 144), (uint64_t)&v26);
    }
    else
    {
      std::construct_at[abi:sn180100]<Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo*>(*(_QWORD *)(a1 + 152), (uint64_t)&v26);
      v24 = v23 + 112;
      *(_QWORD *)(a1 + 152) = v23 + 112;
    }
    *(_QWORD *)(a1 + 152) = v24;
    Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)&v26);
    v21 = (const Backend::Google::ThreatListDescriptor *)((char *)v21 + 16);
  }

  return a1;
}

void sub_1DBCC473C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  void *v11;
  Backend::Google::Configuration *v12;
  std::__shared_weak_count *v14;

  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&a10);
  if (*(char *)(v10 + 143) < 0)
    operator delete(*(void **)(v10 + 120));
  Backend::Google::Configuration::~Configuration(v12);

  v14 = *(std::__shared_weak_count **)(v10 + 8);
  if (v14)
    std::__shared_weak_count::__release_weak(v14);

  _Unwind_Resume(a1);
}

std::random_device *std::random_device::random_device[abi:sn180100](std::random_device *a1)
{
  std::string __token;

  std::string::basic_string[abi:sn180100]<0>(&__token.__r_.__value_.__l.__data_, "/dev/urandom");
  std::random_device::random_device(a1, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__token.__r_.__value_.__l.__data_);
  return a1;
}

void sub_1DBCC483C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t Backend::Google::BackoffTracker<std::chrono::system_clock>::~BackoffTracker(uint64_t a1)
{
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)(a1 + 48), 0);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

void Backend::Google::DatabaseUpdater::~DatabaseUpdater(Backend::Google::DatabaseUpdater *this)
{
  std::__shared_weak_count *v2;
  void **v3;

  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 29, 0);
  if (*((char *)this + 207) < 0)
    operator delete(*((void **)this + 23));

  v3 = (void **)((char *)this + 144);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v3);
  if (*((char *)this + 143) < 0)
    operator delete(*((void **)this + 15));
  Backend::Google::Configuration::~Configuration((Backend::Google::DatabaseUpdater *)((char *)this + 32));

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void Backend::Google::DatabaseUpdater::initialize(Backend::Google::DatabaseUpdater *this)
{
  NSObject *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  NSObject *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  _QWORD v23[4];
  uint64_t v24;
  std::__shared_weak_count *v25;
  _QWORD block[4];
  uint64_t v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;

  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v29, this);
  if (*((_QWORD *)this + 19) == *((_QWORD *)this + 18))
  {
    v9 = v29;
    v10 = v30;
    v11 = *(NSObject **)(v29 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZN7Backend6Google15DatabaseUpdater10initializeEv_block_invoke;
    block[3] = &__block_descriptor_48_ea8_32c58_ZTSKZN7Backend6Google15DatabaseUpdater10initializeEvE3__0_e5_v8__0l;
    if (v30)
    {
      p_shared_owners = (unint64_t *)&v30->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
      v27 = v9;
      v28 = v10;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
      dispatch_async(v11, block);
      do
        v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    else
    {
      v27 = v29;
      v28 = 0;
      dispatch_async(v11, block);
    }
    v16 = v28;
    if (v28)
    {
      v19 = (unint64_t *)&v28->__shared_owners_;
      do
        v18 = __ldaxr(v19);
      while (__stlxr(v18 - 1, v19));
LABEL_29:
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  else
  {
    v2 = *((_QWORD *)this + 21);
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 3321888768;
    v23[2] = ___ZN7Backend6Google15DatabaseUpdater10initializeEv_block_invoke_110;
    v23[3] = &__block_descriptor_48_ea8_32c58_ZTSKZN7Backend6Google15DatabaseUpdater10initializeEvE3__1_e5_v8__0l;
    v3 = v29;
    v4 = v30;
    if (v30)
    {
      v5 = (unint64_t *)&v30->__shared_owners_;
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
      v24 = v3;
      v25 = v4;
      do
        v7 = __ldxr(v5);
      while (__stxr(v7 + 1, v5));
      dispatch_async(v2, v23);
      do
        v8 = __ldaxr(v5);
      while (__stlxr(v8 - 1, v5));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    else
    {
      v24 = v29;
      v25 = 0;
      dispatch_async(v2, v23);
    }
    v16 = v25;
    if (v25)
    {
      v17 = (unint64_t *)&v25->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      goto LABEL_29;
    }
  }
  v20 = v30;
  if (v30)
  {
    v21 = (unint64_t *)&v30->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void ___ZN7Backend6Google15DatabaseUpdater10initializeEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v3[3];
  void **v4;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 16);
  memset(v3, 0, sizeof(v3));
  (*(void (**)(uint64_t, uint64_t, _QWORD *, _QWORD, _QWORD))(*(_QWORD *)v2 + 16))(v2, v1, v3, 0, 0);
  v4 = (void **)v3;
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v4);
}

void sub_1DBCC4B98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c58_ZTSKZN7Backend6Google15DatabaseUpdater10initializeEvE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c58_ZTSKZN7Backend6Google15DatabaseUpdater10initializeEvE3__0(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void ___ZN7Backend6Google15DatabaseUpdater10initializeEv_block_invoke_110(uint64_t a1)
{
  uint64_t v2;
  const Backend::Google::DatabaseInfo *v3;
  const Backend::Google::DatabaseInfo *v4;
  int v5;
  Backend::Google::DatabaseUpdater *v6;
  char v7;
  NSObject *v8;
  void **v9;
  NSObject *v10;
  const char *v11;
  uint32_t v12;
  int v13;
  void **v14;
  int v15;
  void **v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v24;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep;
  NSObject *v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *p_shared_owners;
  unint64_t v37;
  void *__p[2];
  void (*v39)(_QWORD *);
  void *v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  _QWORD v43[5];
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  void **v48;
  _BYTE buf[24];
  uint64_t v50;
  uint64_t v51;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(const Backend::Google::DatabaseInfo **)(v2 + 144);
  v4 = *(const Backend::Google::DatabaseInfo **)(v2 + 152);
  if (v3 != v4)
  {
    while (1)
    {
      Backend::Google::DatabaseUpdater::openDatabase(*(Backend::Google::DatabaseUpdater **)(a1 + 32), v3, (int *)&v44);
      v5 = v44;
      if ((_DWORD)v44 != -1)
        break;
      if (*__error() != 2)
      {
        v8 = (id)SSBOSLogDatabase();
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
LABEL_13:

          goto LABEL_14;
        }
        Backend::Google::ThreatListDescriptor::toString(v3, __p);
        v13 = SHIBYTE(v39);
        v14 = (void **)__p[0];
        v15 = *__error();
        if (v13 >= 0)
          v16 = __p;
        else
          v16 = v14;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = v16;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v15;
        v10 = v8;
        v11 = "Failed to open database '%{public}s': %{errno}i";
        v12 = 18;
LABEL_20:
        _os_log_error_impl(&dword_1DBCBE000, v10, OS_LOG_TYPE_ERROR, v11, buf, v12);
        if (SHIBYTE(v39) < 0)
          operator delete(__p[0]);
        goto LABEL_13;
      }
LABEL_14:
      v3 = (const Backend::Google::DatabaseInfo *)((char *)v3 + 112);
      if (v3 == v4)
      {
        v17 = *(_QWORD *)(a1 + 32);
        v18 = *(_QWORD *)(v17 + 144);
        v3 = *(const Backend::Google::DatabaseInfo **)(v17 + 152);
        goto LABEL_23;
      }
    }
    v6 = *(Backend::Google::DatabaseUpdater **)(a1 + 32);
    LODWORD(v44) = -1;
    v47 = v5;
    v7 = Backend::Google::DatabaseUpdater::mapDatabaseIntoMemory(v6, (uint64_t)v3, &v47);
    if (v47 != -1)
      close(v47);
    if ((v7 & 1) != 0)
      goto LABEL_14;
    v8 = (id)SSBOSLogDatabase();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      goto LABEL_13;
    Backend::Google::ThreatListDescriptor::toString(v3, __p);
    if (SHIBYTE(v39) >= 0)
      v9 = __p;
    else
      v9 = (void **)__p[0];
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v9;
    v10 = v8;
    v11 = "Failed to map database '%{public}s' into memory";
    v12 = 12;
    goto LABEL_20;
  }
  v18 = *(_QWORD *)(v2 + 144);
LABEL_23:
  v44 = 0;
  v45 = 0;
  v46 = 0;
  std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(&v44, v18, (uint64_t)v3, 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v3 - v18) >> 4));
  v19 = *(_QWORD **)(a1 + 32);
  v20 = v19[18];
  v21 = v19[19];
  v22 = v20 + 112;
  if (v20 != v21 && v22 != v21)
  {
    do
    {
      if (*(_QWORD *)(v20 + 48) < *(_QWORD *)(v22 + 48))
        v20 = v22;
      v22 += 112;
    }
    while (v22 != v21);
  }
  v24 = *(_QWORD *)(v20 + 56);
  if (!v24)
  {
    *(_OWORD *)__p = xmmword_1DBD179E0;
    rep = std::chrono::system_clock::now().__d_.__rep_;
    v24 = rep
        + 1000000
        * std::uniform_int_distribution<long long>::operator()<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>((uint64_t)__p, *(_QWORD *)(a1 + 32) + 176, __p);
    v19 = *(_QWORD **)(a1 + 32);
  }
  v26 = v19[3];
  __p[0] = (void *)MEMORY[0x1E0C809B0];
  __p[1] = (void *)3321888768;
  v39 = ___ZZN7Backend6Google15DatabaseUpdater10initializeEvENK3__1clEv_block_invoke;
  v40 = &__block_descriptor_80_ea8_32c71_ZTSKZZN7Backend6Google15DatabaseUpdater10initializeEvENK3__1clEvEUlvE__e5_v8__0l;
  v27 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)buf = v19;
  *(_QWORD *)&buf[8] = v27;
  if (v27)
  {
    v28 = (unint64_t *)(v27 + 8);
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  *(_QWORD *)&buf[16] = 0;
  v50 = 0;
  v51 = 0;
  std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(&buf[16], v44, v45, 0x6DB6DB6DB6DB6DB7 * ((v45 - v44) >> 4));
  v52 = v24;
  v41 = *(_QWORD *)buf;
  v42 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v30 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  memset(v43, 0, 24);
  std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(v43, *(uint64_t *)&buf[16], v50, 0x6DB6DB6DB6DB6DB7 * ((v50 - *(_QWORD *)&buf[16]) >> 4));
  v43[3] = v52;
  dispatch_async(v26, __p);
  v48 = (void **)&buf[16];
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v48);
  v32 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
    v33 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  *(_QWORD *)buf = v43;
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100]((void ***)buf);
  v35 = v42;
  if (v42)
  {
    p_shared_owners = (unint64_t *)&v42->__shared_owners_;
    do
      v37 = __ldaxr(p_shared_owners);
    while (__stlxr(v37 - 1, p_shared_owners));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  *(_QWORD *)buf = &v44;
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100]((void ***)buf);
}

void sub_1DBCC5030(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,int a30,int a31,uint64_t a32,char *a33,uint64_t a34)
{
  a33 = &a27;
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100]((void ***)&a33);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c58_ZTSKZN7Backend6Google15DatabaseUpdater10initializeEvE3__1(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c58_ZTSKZN7Backend6Google15DatabaseUpdater10initializeEvE3__1(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void Backend::Google::DatabaseUpdater::update(_QWORD *a1, int a2, void *a3)
{
  id v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  id v11;
  unint64_t v12;
  id v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD v22[4];
  uint64_t v23;
  std::__shared_weak_count *v24;
  int v25;
  id v26;
  uint64_t v27;
  std::__shared_weak_count *v28;

  v5 = a3;
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v27, a1);
  v6 = a1[21];
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 3321888768;
  v22[2] = ___ZN7Backend6Google15DatabaseUpdater6updateENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke;
  v22[3] = &__block_descriptor_64_ea8_32c99_ZTSKZN7Backend6Google15DatabaseUpdater6updateENS0_19DatabaseUpdateStyleEP18ProxyConfigurationE3__0_e5_v8__0l;
  v8 = v27;
  v7 = v28;
  if (v28)
  {
    p_shared_owners = (unint64_t *)&v28->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    v11 = v5;
    v23 = v8;
    v24 = v7;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  else
  {
    v13 = v5;
    v23 = v8;
    v24 = 0;
  }
  v25 = a2;
  v26 = v5;
  dispatch_async(v6, v22);
  if (v7)
  {
    v14 = (unint64_t *)&v7->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  v16 = v24;
  if (v24)
  {
    v17 = (unint64_t *)&v24->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v28;
  if (v28)
  {
    v20 = (unint64_t *)&v28->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

}

void sub_1DBCC52D0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN7Backend6Google15DatabaseUpdater6updateENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  NSObject *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[4];
  uint64_t v15;
  std::__shared_weak_count *v16;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v2 + 240))
  {
    v3 = SSBOSLogDatabase();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14[0]) = 0;
      _os_log_impl(&dword_1DBCBE000, v3, OS_LOG_TYPE_DEFAULT, "We are already in the middle of updating database", (uint8_t *)v14, 2u);
    }
  }
  else
  {
    Backend::Google::DatabaseUpdater::fetchEncodedUpdates(v2, *(_DWORD *)(a1 + 48), *(void **)(a1 + 56));
    v4 = *(_QWORD *)(a1 + 32);
    v5 = *(std::__shared_weak_count **)(a1 + 40);
    v6 = *(NSObject **)(v4 + 24);
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3321888768;
    v14[2] = ___ZZN7Backend6Google15DatabaseUpdater6updateENS0_19DatabaseUpdateStyleEP18ProxyConfigurationENK3__0clEv_block_invoke;
    v14[3] = &__block_descriptor_48_ea8_32c112_ZTSKZZN7Backend6Google15DatabaseUpdater6updateENS0_19DatabaseUpdateStyleEP18ProxyConfigurationENK3__0clEvEUlvE__e5_v8__0l;
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
      v15 = v4;
      v16 = v5;
      do
        v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
      dispatch_async(v6, v14);
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    else
    {
      v15 = v4;
      v16 = 0;
      dispatch_async(v6, v14);
    }
    v11 = v16;
    if (v16)
    {
      v12 = (unint64_t *)&v16->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
}

id __copy_helper_block_ea8_32c99_ZTSKZN7Backend6Google15DatabaseUpdater6updateENS0_19DatabaseUpdateStyleEP18ProxyConfigurationE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  id result;

  v3 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  result = *(id *)(a2 + 56);
  *(_QWORD *)(a1 + 56) = result;
  return result;
}

uint64_t __destroy_helper_block_ea8_32c99_ZTSKZN7Backend6Google15DatabaseUpdater6updateENS0_19DatabaseUpdateStyleEP18ProxyConfigurationE3__0(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;

  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
}

void Backend::Google::DatabaseUpdater::openDatabase(Backend::Google::DatabaseUpdater *this@<X0>, const Backend::Google::DatabaseInfo *a2@<X1>, int *a3@<X8>)
{
  std::string *p_p;
  std::string __p;

  Backend::Google::DatabaseUpdater::databasePath(this, a2, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  *a3 = open((const char *)p_p, 0);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1DBCC550C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Backend::Google::DatabaseUpdater::databasePath(Backend::Google::DatabaseUpdater *this@<X0>, const Backend::Google::DatabaseInfo *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t *v4;
  void *__p[2];
  char v6;

  v4 = (uint64_t *)((char *)this + 120);
  Backend::Google::ThreatListDescriptor::toString(a2, __p);
  Platform::stringByAppendingPathComponent(v4, (uint64_t)__p, a3);
  if (v6 < 0)
    operator delete(__p[0]);
}

void sub_1DBCC557C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t Backend::Google::DatabaseUpdater::mapDatabaseIntoMemory(Backend::Google::DatabaseUpdater *a1, uint64_t a2, int *a3)
{
  int v5;
  uint64_t v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD v12[3];
  int v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  *a3 = -1;
  v13 = v5;
  Platform::SharedMemory::createFileMapping(&v13, &v14);
  if (v13 != -1)
    close(v13);
  if (!(_QWORD)v14)
    goto LABEL_9;
  if ((Backend::Google::Database::initialize((Backend::Google::Database *)(a2 + 32), *(_QWORD *)v14, *(_QWORD *)(v14 + 8)) & 1) == 0)
  {
    v7 = (id)SSBOSLogDatabase();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      Backend::Google::ThreatListDescriptor::toString((Backend::Google::ThreatListDescriptor *)a2, v12);
      Backend::Google::DatabaseUpdater::mapDatabaseIntoMemory();
    }

    Backend::Google::DatabaseUpdater::deleteDatabase(a1, (Backend::Google::DatabaseInfo *)a2);
LABEL_9:
    v6 = 0;
    goto LABEL_10;
  }
  std::shared_ptr<ByteProvider>::operator=[abi:sn180100](a2 + 16, &v14);
  v6 = 1;
LABEL_10:
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v14 + 1);
  if (*((_QWORD *)&v14 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v14 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return v6;
}

void sub_1DBCC56D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  va_list va;

  va_start(va, a5);

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void Backend::Google::DatabaseUpdater::deleteDatabase(Backend::Google::DatabaseUpdater *this, Backend::Google::DatabaseInfo *a2)
{
  void **v3;
  int v4;
  NSObject *v5;
  __int128 v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  int v10;
  void **v11;
  int *v12;
  void **v13;
  int v14;
  void *__p[2];
  __int128 v16;
  __int128 v17;
  char v18;
  char *v19;
  uint64_t v20;
  uint8_t buf[4];
  void **v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  Backend::Google::DatabaseUpdater::databasePath(this, a2, (std::string *)__p);
  if ((SBYTE7(v16) & 0x80u) == 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  v4 = unlink((const char *)v3);
  if (SBYTE7(v16) < 0)
    operator delete(__p[0]);
  if (v4 == -1)
  {
    v5 = (id)SSBOSLogDatabase();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      Backend::Google::ThreatListDescriptor::toString(a2, __p);
      v10 = SBYTE7(v16);
      v11 = (void **)__p[0];
      v12 = __error();
      v13 = __p;
      v14 = *v12;
      if (v10 < 0)
        v13 = v11;
      *(_DWORD *)buf = 136446466;
      v22 = v13;
      v23 = 1024;
      v24 = v14;
      _os_log_error_impl(&dword_1DBCBE000, v5, OS_LOG_TYPE_ERROR, "Failed to delete database '%{public}s': %{errno}i", buf, 0x12u);
      if (SBYTE7(v16) < 0)
        operator delete(__p[0]);
    }

  }
  Backend::Google::Database::Database((Backend::Google::Database *)__p);
  v6 = v16;
  *((_OWORD *)a2 + 2) = *(_OWORD *)__p;
  *((_OWORD *)a2 + 3) = v6;
  *((_OWORD *)a2 + 4) = v17;
  *((_BYTE *)a2 + 80) = v18;
  if ((void **)((char *)a2 + 32) != __p)
    std::vector<Backend::Google::Database::HashSizeBucket>::__assign_with_size[abi:sn180100]<Backend::Google::Database::HashSizeBucket*,Backend::Google::Database::HashSizeBucket*>((char *)a2 + 88, v19, v20, (v20 - (uint64_t)v19) >> 4);
  Backend::Google::Database::~Database((Backend::Google::Database *)__p);
  __p[0] = 0;
  __p[1] = 0;
  std::shared_ptr<ByteProvider>::operator=[abi:sn180100]((uint64_t)a2 + 16, (__int128 *)__p);
  v7 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v8 = (unint64_t *)((char *)__p[1] + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_1DBCC58D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;

  if (a14 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void Backend::Google::DatabaseUpdater::unmapDatabaseFromMemory(Backend::Google::DatabaseUpdater *this, Backend::Google::DatabaseInfo *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7[3];
  char v8;
  char *v9;
  uint64_t v10;

  Backend::Google::Database::Database((Backend::Google::Database *)v7);
  v3 = v7[1];
  *((_OWORD *)a2 + 2) = v7[0];
  *((_OWORD *)a2 + 3) = v3;
  *((_OWORD *)a2 + 4) = v7[2];
  *((_BYTE *)a2 + 80) = v8;
  if ((__int128 *)((char *)a2 + 32) != v7)
    std::vector<Backend::Google::Database::HashSizeBucket>::__assign_with_size[abi:sn180100]<Backend::Google::Database::HashSizeBucket*,Backend::Google::Database::HashSizeBucket*>((char *)a2 + 88, v9, v10, (v10 - (uint64_t)v9) >> 4);
  Backend::Google::Database::~Database((Backend::Google::Database *)v7);
  v7[0] = 0uLL;
  std::shared_ptr<ByteProvider>::operator=[abi:sn180100]((uint64_t)a2 + 16, v7);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v7[0] + 1);
  if (*((_QWORD *)&v7[0] + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v7[0] + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1DBCC59CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  Backend::Google::Database::~Database((Backend::Google::Database *)&a9);
  _Unwind_Resume(a1);
}

void Backend::Google::DatabaseUpdater::fetchEncodedUpdates(uint64_t a1, int a2, void *a3)
{
  id v5;
  id v6;
  int v7;
  void *v8;
  BOOL v9;
  id v10;
  void *v11;
  int v12;
  uint64_t v13;
  void *v14;
  _SSBDatabaseUpdateFetchDataSessionHandler *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  _SSBDatabaseUpdateFetchDataSessionHandler *v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  void *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void (*v34)(uint64_t, void *, void *, void *);
  void *v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  int v40;
  BOOL v41;
  _QWORD v42[4];
  id v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  int v46;
  BOOL v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  _QWORD v50[3];
  _QWORD *v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = *(id *)(a1 + 80);
  v7 = *(_DWORD *)(a1 + 260);
  switch(v7)
  {
    case 3:
      Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::FetchThreatListUpdatesRequestJSONSerializer(v50, (const Backend::Google::ClientInfo *)(a1 + 32));
      Backend::Google::DatabaseUpdater::populateListUpdateRequestsFromDatabases<Backend::Google::FetchThreatListUpdatesRequestSerializer>(a1, (uint64_t)v50);
      Backend::Google::Configuration::getEncodedUpdatesRequestURLRequestForAppleProtobuf(a1 + 32, (Backend::Google::FetchThreatListUpdatesRequestSerializer *)v50, a2);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      v10 = *(id *)(a1 + 96);

      Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::~FetchThreatListUpdatesRequestJSONSerializer((Backend::Google::FetchThreatListUpdatesRequestJSONSerializer *)v50);
      v9 = 0;
      v6 = v10;
      break;
    case 2:
      Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::FetchThreatListUpdatesRequestJSONSerializer(v50, (const Backend::Google::ClientInfo *)(a1 + 32));
      Backend::Google::DatabaseUpdater::populateListUpdateRequestsFromDatabases<Backend::Google::FetchThreatListUpdatesRequestJSONSerializer>(a1, (uint64_t)v50);
      Backend::Google::Configuration::getEncodedUpdatesRequestURLRequestForTencent(a1 + 32, (Backend::Google::FetchThreatListUpdatesRequestJSONSerializer *)v50, a2);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::~FetchThreatListUpdatesRequestJSONSerializer((Backend::Google::FetchThreatListUpdatesRequestJSONSerializer *)v50);
      v9 = 0;
      break;
    case 1:
      Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::FetchThreatListUpdatesRequestJSONSerializer(v50, (const Backend::Google::ClientInfo *)(a1 + 32));
      Backend::Google::DatabaseUpdater::populateListUpdateRequestsFromDatabases<Backend::Google::FetchThreatListUpdatesRequestSerializer>(a1, (uint64_t)v50);
      Backend::Google::Configuration::getEncodedUpdatesRequestURLRequest(a1 + 32, (Backend::Google::FetchThreatListUpdatesRequestSerializer *)v50, a2, v5);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      v9 = v5 != 0;
      Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::~FetchThreatListUpdatesRequestJSONSerializer((Backend::Google::FetchThreatListUpdatesRequestJSONSerializer *)v50);
      break;
    default:
      v9 = 0;
      v8 = 0;
      break;
  }
  v11 = (void *)nw_activity_create();
  nw_activity_activate();
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v48, (_QWORD *)a1);
  v12 = *(_DWORD *)(a1 + 260);
  if (v12 == 1)
    goto LABEL_11;
  if (v12 != 2)
  {
    if (v12 != 3)
      goto LABEL_31;
LABEL_11:
    objc_msgSend(v6, "dataTaskWithRequest:", v8);
    v13 = objc_claimAutoreleasedReturnValue();
    v14 = *(void **)(a1 + 248);
    *(_QWORD *)(a1 + 248) = v13;

    v15 = [_SSBDatabaseUpdateFetchDataSessionHandler alloc];
    v42[0] = MEMORY[0x1E0C809B0];
    v42[1] = 3321888768;
    v42[2] = ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke;
    v42[3] = &unk_1EA3EBD90;
    v44 = v48;
    v45 = v49;
    if (v49)
    {
      p_shared_owners = (unint64_t *)&v49->__shared_owners_;
      do
        v17 = __ldxr(p_shared_owners);
      while (__stxr(v17 + 1, p_shared_owners));
    }
    v46 = a2;
    v47 = v9;
    v43 = v11;
    v50[0] = off_1EA3EB1D8;
    v50[1] = MEMORY[0x1DF0B8E90](v42);
    v51 = v50;
    v18 = -[_SSBDatabaseUpdateFetchDataSessionHandler initWithCompletionHandler:provider:](v15, "initWithCompletionHandler:provider:", v50, *(unsigned int *)(a1 + 260));
    objc_msgSend(*(id *)(a1 + 248), "setDelegate:", v18);

    v19 = v51;
    if (v51 == v50)
    {
      v20 = 4;
      v19 = v50;
    }
    else
    {
      if (!v51)
      {
LABEL_26:

        v25 = v45;
        if (!v45)
          goto LABEL_31;
        v28 = (unint64_t *)&v45->__shared_owners_;
        do
          v27 = __ldaxr(v28);
        while (__stlxr(v27 - 1, v28));
        goto LABEL_29;
      }
      v20 = 5;
    }
    (*(void (**)(void))(*v19 + 8 * v20))();
    goto LABEL_26;
  }
  v32 = MEMORY[0x1E0C809B0];
  v33 = 3321888768;
  v34 = ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke_113;
  v35 = &unk_1EA3EBE58;
  v37 = a1;
  v38 = v48;
  v39 = v49;
  if (v49)
  {
    v21 = (unint64_t *)&v49->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  v41 = v9;
  v40 = a2;
  v36 = v11;
  objc_msgSend(v6, "dataTaskWithRequest:completionHandler:", v8, &v32);
  v23 = objc_claimAutoreleasedReturnValue();
  v24 = *(void **)(a1 + 248);
  *(_QWORD *)(a1 + 248) = v23;

  v25 = v39;
  if (v39)
  {
    v26 = (unint64_t *)&v39->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
LABEL_29:
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
LABEL_31:
  objc_msgSend(*(id *)(a1 + 248), "set_nw_activity:", v11, v32, v33, v34, v35);
  objc_msgSend(*(id *)(a1 + 248), "resume");
  *(_DWORD *)(a1 + 240) = 1;
  v29 = v49;
  if (v49)
  {
    v30 = (unint64_t *)&v49->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

}

void sub_1DBCC5E0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v30);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a26);

  _Unwind_Resume(a1);
}

void Backend::Google::DatabaseUpdater::populateListUpdateRequestsFromDatabases<Backend::Google::FetchThreatListUpdatesRequestSerializer>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t i;
  __int128 v6;
  int v7;
  __int128 v8[2];
  char v9;
  _QWORD v10[2];
  __int128 v11;
  uint64_t v12;
  char v13;
  void *__p[2];
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  char v18;
  _BYTE v19[13];
  __int128 v20;
  uint64_t v21;
  char v22;
  void *v23[2];
  uint64_t v24;
  uint64_t __src;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 144);
  for (i = *(_QWORD *)(a1 + 152); v2 != i; v2 += 112)
  {
    v19[0] = 0;
    v19[4] = 0;
    v19[8] = 0;
    v19[12] = 0;
    LOBYTE(v20) = 0;
    v22 = 0;
    v23[1] = 0;
    v24 = 0;
    v23[0] = 0;
    *(_QWORD *)&v16 = *(_QWORD *)v2;
    DWORD2(v16) = *(_DWORD *)(v2 + 8);
    v6 = *(_OWORD *)(v2 + 64);
    v18 = *(_BYTE *)(v2 + 80);
    v17 = v6;
    v7 = *(_DWORD *)(a1 + 260);
    switch(v7)
    {
      case 3:
        goto LABEL_5;
      case 2:
        LODWORD(__src) = 1;
        std::vector<Backend::Google::CompressionType>::__assign_with_size[abi:sn180100]<Backend::Google::CompressionType const*,Backend::Google::CompressionType const*>((char *)v23, (char *)&__src, (uint64_t)&__src + 4, 1uLL);
        break;
      case 1:
LABEL_5:
        __src = 0x200000001;
        std::vector<Backend::Google::CompressionType>::__assign_with_size[abi:sn180100]<Backend::Google::CompressionType const*,Backend::Google::CompressionType const*>((char *)v23, (char *)&__src, (uint64_t)&v26, 2uLL);
        break;
    }
    v8[0] = v16;
    v8[1] = v17;
    v9 = v18;
    v10[0] = *(_QWORD *)v19;
    *(_QWORD *)((char *)v10 + 5) = *(_QWORD *)&v19[5];
    LOBYTE(v11) = 0;
    v13 = 0;
    if (v22)
    {
      v11 = v20;
      v12 = v21;
      v21 = 0;
      v20 = 0uLL;
      v13 = 1;
    }
    *(_OWORD *)__p = *(_OWORD *)v23;
    v15 = v24;
    v23[1] = 0;
    v24 = 0;
    v23[0] = 0;
    Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::addRequest(a2, v8);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v13 && SHIBYTE(v12) < 0)
      operator delete((void *)v11);
    if (v23[0])
    {
      v23[1] = v23[0];
      operator delete(v23[0]);
    }
    if (v22)
    {
      if (SHIBYTE(v21) < 0)
        operator delete((void *)v20);
    }
  }
}

void sub_1DBCC6134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  Backend::Google::ListUpdateRequest::~ListUpdateRequest((Backend::Google::ListUpdateRequest *)&a26);
  _Unwind_Resume(a1);
}

void Backend::Google::DatabaseUpdater::populateListUpdateRequestsFromDatabases<Backend::Google::FetchThreatListUpdatesRequestJSONSerializer>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t i;
  __int128 v6;
  int v7;
  __int128 v8[2];
  char v9;
  _QWORD v10[2];
  __int128 v11;
  uint64_t v12;
  char v13;
  void *__p[2];
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  char v18;
  _BYTE v19[13];
  __int128 v20;
  uint64_t v21;
  char v22;
  void *v23[2];
  uint64_t v24;
  uint64_t __src;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 144);
  for (i = *(_QWORD *)(a1 + 152); v2 != i; v2 += 112)
  {
    v19[0] = 0;
    v19[4] = 0;
    v19[8] = 0;
    v19[12] = 0;
    LOBYTE(v20) = 0;
    v22 = 0;
    v23[1] = 0;
    v24 = 0;
    v23[0] = 0;
    *(_QWORD *)&v16 = *(_QWORD *)v2;
    DWORD2(v16) = *(_DWORD *)(v2 + 8);
    v6 = *(_OWORD *)(v2 + 64);
    v18 = *(_BYTE *)(v2 + 80);
    v17 = v6;
    v7 = *(_DWORD *)(a1 + 260);
    switch(v7)
    {
      case 3:
        goto LABEL_5;
      case 2:
        LODWORD(__src) = 1;
        std::vector<Backend::Google::CompressionType>::__assign_with_size[abi:sn180100]<Backend::Google::CompressionType const*,Backend::Google::CompressionType const*>((char *)v23, (char *)&__src, (uint64_t)&__src + 4, 1uLL);
        break;
      case 1:
LABEL_5:
        __src = 0x200000001;
        std::vector<Backend::Google::CompressionType>::__assign_with_size[abi:sn180100]<Backend::Google::CompressionType const*,Backend::Google::CompressionType const*>((char *)v23, (char *)&__src, (uint64_t)&v26, 2uLL);
        break;
    }
    v8[0] = v16;
    v8[1] = v17;
    v9 = v18;
    v10[0] = *(_QWORD *)v19;
    *(_QWORD *)((char *)v10 + 5) = *(_QWORD *)&v19[5];
    LOBYTE(v11) = 0;
    v13 = 0;
    if (v22)
    {
      v11 = v20;
      v12 = v21;
      v21 = 0;
      v20 = 0uLL;
      v13 = 1;
    }
    *(_OWORD *)__p = *(_OWORD *)v23;
    v15 = v24;
    v23[1] = 0;
    v24 = 0;
    v23[0] = 0;
    Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::addRequest(a2, v8);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v13 && SHIBYTE(v12) < 0)
      operator delete((void *)v11);
    if (v23[0])
    {
      v23[1] = v23[0];
      operator delete(v23[0]);
    }
    if (v22)
    {
      if (SHIBYTE(v21) < 0)
        operator delete((void *)v20);
    }
  }
}

void sub_1DBCC63A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  Backend::Google::ListUpdateRequest::~ListUpdateRequest((Backend::Google::ListUpdateRequest *)&a26);
  _Unwind_Resume(a1);
}

void ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v3;
  uint64_t v4;
  id v7;
  NSObject *v8;
  int v9;
  id v10;
  int v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  char v16;
  id v17;
  unint64_t *v18;
  unint64_t v19;
  char *v20;
  _QWORD *v21;
  id v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  id v27;
  void *v28;
  unint64_t *v29;
  unint64_t v30;
  void *v31;
  uint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  char v38;
  id v39;
  int v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  char v43;
  id v44;
  __int128 v45;
  uint64_t v46;
  __int128 v47;
  char v48;
  id v49;
  int v50;
  uint64_t v51;
  std::__shared_weak_count *v52;
  char v53;
  id v54;
  void **v55;

  v7 = a3;
  v8 = *(NSObject **)(*(_QWORD *)(a1 + 40) + 168);
  LOBYTE(v34) = 0;
  v38 = 0;
  v9 = *((unsigned __int8 *)a2 + 40);
  if (*((_BYTE *)a2 + 40))
  {
    v3 = a2[1];
    v34 = *a2;
    v35 = v3;
    v4 = a2[2];
    v36 = v4;
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    v37 = *(_OWORD *)(a2 + 3);
    v38 = 1;
  }
  v10 = v7;
  v39 = v10;
  v11 = *(_DWORD *)(a1 + 56);
  v40 = v11;
  v13 = *(_QWORD *)(a1 + 40);
  v12 = *(std::__shared_weak_count **)(a1 + 48);
  v41 = v13;
  v42 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  v16 = *(_BYTE *)(a1 + 60);
  v43 = v16;
  v17 = *(id *)(a1 + 32);
  v44 = v17;
  LOBYTE(v45) = 0;
  v48 = 0;
  if (v9)
  {
    *(_QWORD *)&v45 = v34;
    *((_QWORD *)&v45 + 1) = v3;
    v46 = v4;
    v35 = 0;
    v36 = 0;
    v34 = 0;
    v47 = v37;
    v48 = 1;
  }
  v39 = 0;
  v49 = v10;
  v50 = v11;
  v51 = v13;
  v52 = v12;
  if (v12)
  {
    v18 = (unint64_t *)&v12->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v53 = v16;
  v54 = v17;
  v20 = (char *)malloc_type_malloc(0x80uLL, 0x10E2040AF53DFFEuLL);
  v21 = v20;
  *(_QWORD *)v20 = MEMORY[0x1E0C809A0];
  *((_QWORD *)v20 + 1) = 50331650;
  *((_QWORD *)v20 + 2) = _ZZN8BlockPtrIFvvEE13from_callableIZZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS4_19DatabaseUpdateStyleEP18ProxyConfigurationEUb_E3__1EES1_T_ENUlPvE_8__invokeESB_;
  *((_QWORD *)v20 + 3) = &_ZZN8BlockPtrIFvvEE13from_callableIZZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS4_19DatabaseUpdateStyleEP18ProxyConfigurationEUb_E3__1EES1_T_E10descriptor;
  v20[32] = 0;
  v20[72] = 0;
  if (v48)
  {
    *((_OWORD *)v20 + 2) = v45;
    *((_QWORD *)v20 + 6) = v46;
    v46 = 0;
    v45 = 0uLL;
    *(_OWORD *)(v20 + 56) = v47;
    v20[72] = 1;
  }
  v22 = v49;
  v49 = 0;
  *((_QWORD *)v20 + 10) = v22;
  *((_DWORD *)v20 + 22) = v50;
  v23 = v52;
  *((_QWORD *)v20 + 12) = v51;
  *((_QWORD *)v20 + 13) = v23;
  if (v23)
  {
    v24 = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
    v26 = v52;
  }
  else
  {
    v26 = 0;
  }
  v20[112] = v53;
  v27 = v54;
  v21[15] = v27;
  v28 = (void *)MEMORY[0x1DF0B8E90](v21);

  if (v26)
  {
    v29 = (unint64_t *)&v26->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  if (v48)
  {
    v55 = (void **)&v45;
    std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v55);
  }
  v31 = (void *)MEMORY[0x1DF0B8E90](v28);
  dispatch_async(v8, v31);

  if (v42)
  {
    v32 = &v42->__shared_owners_;
    do
      v33 = __ldaxr((unint64_t *)v32);
    while (__stlxr(v33 - 1, (unint64_t *)v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }

  if (v38)
  {
    *(_QWORD *)&v45 = &v34;
    std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100]((void ***)&v45);
  }

}

void sub_1DBCC66D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,id a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30,uint64_t a31,id a32)
{
  void *v32;
  uint64_t v33;

  if (a30)
    ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke_cold_1(a30);

  if (a26)
  {
    *(_QWORD *)(v33 - 96) = &a21;
    std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100]((void ***)(v33 - 96));
  }
  _ZZZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfigurationEUb_EN3__1D1Ev((uint64_t)&a9);

  _Unwind_Resume(a1);
}

uint64_t _ZZZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfigurationEUb_EN3__1D1Ev(uint64_t a1)
{
  void **v3;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 64);
  if (*(_BYTE *)(a1 + 40))
  {
    v3 = (void **)a1;
    std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v3);
  }
  return a1;
}

uint64_t __copy_helper_block_ea8_40c60_ZTSNSt3__110shared_ptrIN7Backend6Google15DatabaseUpdaterEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_40c60_ZTSNSt3__110shared_ptrIN7Backend6Google15DatabaseUpdaterEEE(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 40);
}

void ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke_113(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  NSObject *v11;
  id v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  id v17;
  id v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD v22[4];
  id v23;
  id v24;
  id v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  int v30;
  char v31;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(NSObject **)(*(_QWORD *)(a1 + 48) + 168);
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 3321888768;
  v22[2] = ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke_2;
  v22[3] = &unk_1EA3EBEF0;
  v27 = v10;
  v31 = *(_BYTE *)(a1 + 68);
  v12 = v9;
  v14 = *(_QWORD *)(a1 + 48);
  v13 = *(std::__shared_weak_count **)(a1 + 56);
  v23 = v12;
  v28 = v14;
  v29 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  v30 = *(_DWORD *)(a1 + 64);
  v17 = v7;
  v24 = v17;
  v18 = v8;
  v25 = v18;
  v26 = *(id *)(a1 + 32);
  dispatch_async(v11, v22);

  v19 = v29;
  if (v29)
  {
    v20 = (unint64_t *)&v29->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

}

void ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  id v13;
  _BYTE v14[40];
  char v15;
  void **v16;

  v2 = *(_QWORD *)(a1 + 64);
  if (*(_BYTE *)(a1 + 92)
    && *(_QWORD *)(a1 + 32)
    && +[ProxyConfiguration shouldRetryForError:](ProxyConfiguration, "shouldRetryForError:"))
  {
    v3 = SSBOSLogDatabase();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke_2_cold_1(v3, v4, v5, v6, v7, v8, v9, v10);
    Backend::Google::DatabaseUpdater::fetchEncodedUpdates(*(_QWORD *)(a1 + 72), *(unsigned int *)(a1 + 88), 0);
  }
  else
  {
    logDataLength(objc_msgSend(*(id *)(a1 + 40), "length"), *(_DWORD *)(v2 + 260));
    if (*(_QWORD *)(a1 + 32) || objc_msgSend(*(id *)(a1 + 48), "statusCode") != 200)
    {
      v12 = *(_QWORD *)(a1 + 72);
      v14[0] = 0;
      v15 = 0;
      Backend::Google::DatabaseUpdater::didFetchEncodedUpdates(v12, (uint64_t)v14, *(void **)(a1 + 56));
      if (v15)
      {
        v16 = (void **)v14;
        std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v16);
      }
    }
    else
    {
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::FetchThreatListUpdatesResponseJSONParser((Backend::Google::FetchThreatListUpdatesResponseJSONParser *)&v13, *(NSData **)(a1 + 40));
      v11 = *(_QWORD *)(a1 + 72);
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::finish((Backend::Google::FetchThreatListUpdatesResponseJSONParser *)&v13, v14);
      Backend::Google::DatabaseUpdater::didFetchEncodedUpdates(v11, (uint64_t)v14, *(void **)(a1 + 56));
      if (v15)
      {
        v16 = (void **)v14;
        std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v16);
      }
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::~FetchThreatListUpdatesResponseJSONParser(&v13);
    }
  }
}

void sub_1DBCC6A18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;

  if (a15)
  {
    *(_QWORD *)(v15 - 24) = &a10;
    std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100]((void ***)(v15 - 24));
  }
  Backend::Google::FetchThreatListUpdatesResponseJSONParser::~FetchThreatListUpdatesResponseJSONParser((id *)&a9);
  _Unwind_Resume(a1);
}

void Backend::Google::DatabaseUpdater::didFetchEncodedUpdates(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  void *v6;
  int v7;
  uint64_t v8;
  std::chrono::system_clock::time_point v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const Backend::Google::DatabaseInfo *v14;
  const Backend::Google::DatabaseInfo *v15;
  NSObject *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD block[4];
  __int128 v36;
  _QWORD v37[4];
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  void **v42;

  v5 = a3;
  v6 = *(void **)(a1 + 248);
  *(_QWORD *)(a1 + 248) = 0;

  *(_DWORD *)(a1 + 240) = 0;
  if (!*(_BYTE *)(a2 + 40))
  {
    Backend::Google::DatabaseUpdater::didFailUpdate((Backend::Google::DatabaseUpdater *)a1);
    nw_activity_complete_with_reason();
LABEL_35:

    return;
  }
  *(_DWORD *)(a1 + 220) = 0;
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)(a1 + 232), 0);
  nw_activity_complete_with_reason();
  if (*(_BYTE *)(a2 + 40))
  {
    v7 = *(unsigned __int8 *)(a2 + 32);
    v8 = 1000000 * *(_QWORD *)(a2 + 24);
    v9.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    v10 = 300000000;
    if (v7)
      v10 = v8;
    if (*(_BYTE *)(a2 + 40))
    {
      v11 = v10 + v9.__d_.__rep_;
      v12 = *(_QWORD *)a2;
      v13 = *(_QWORD *)(a2 + 8);
      while (v12 != v13)
      {
        LODWORD(v30) = *(_DWORD *)v12;
        *(int32x2_t *)((char *)&v30 + 4) = vrev64_s32(*(int32x2_t *)(v12 + 4));
        HIDWORD(v30) = *(_DWORD *)(a1 + 260);
        v14 = *(const Backend::Google::DatabaseInfo **)(a1 + 144);
        v15 = *(const Backend::Google::DatabaseInfo **)(a1 + 152);
        if (v14 != v15)
        {
          while (!Backend::Google::operator==((uint64_t)v14, (uint64_t)&v30))
          {
            v14 = (const Backend::Google::DatabaseInfo *)((char *)v14 + 112);
            if (v14 == v15)
            {
              v14 = v15;
              break;
            }
          }
        }
        Backend::Google::DatabaseUpdater::writeUpdatedDatabase((Backend::Google::DatabaseUpdater *)a1, v14, v12, v11);
        v12 += 120;
      }
      std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v41, (_QWORD *)a1);
      v38 = 0;
      v39 = 0;
      v40 = 0;
      std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(&v38, *(_QWORD *)(a1 + 144), *(_QWORD *)(a1 + 152), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 4));
      v16 = *(NSObject **)(a1 + 24);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3321888768;
      block[2] = ___ZN7Backend6Google15DatabaseUpdater22didFetchEncodedUpdatesEONSt3__18optionalINS0_30FetchThreatListUpdatesResponseEEEPU25objcproto14OS_nw_activity8NSObject_block_invoke;
      block[3] = &__block_descriptor_80_ea8_32c164_ZTSKZN7Backend6Google15DatabaseUpdater22didFetchEncodedUpdatesEONSt3__18optionalINS0_30FetchThreatListUpdatesResponseEEEPU25objcproto14OS_nw_activity8NSObjectE3__0_e5_v8__0l;
      v30 = v41;
      if (*((_QWORD *)&v41 + 1))
      {
        v17 = (unint64_t *)(*((_QWORD *)&v41 + 1) + 8);
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }
      v31 = 0;
      v32 = 0;
      v33 = 0;
      std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(&v31, v38, v39, 0x6DB6DB6DB6DB6DB7 * ((v39 - v38) >> 4));
      v34 = v11;
      v36 = v30;
      if (*((_QWORD *)&v30 + 1))
      {
        v19 = (unint64_t *)(*((_QWORD *)&v30 + 1) + 8);
        do
          v20 = __ldxr(v19);
        while (__stxr(v20 + 1, v19));
      }
      memset(v37, 0, 24);
      std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(v37, v31, v32, 0x6DB6DB6DB6DB6DB7 * ((v32 - v31) >> 4));
      v37[3] = v34;
      dispatch_async(v16, block);
      v42 = (void **)&v31;
      std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v42);
      v21 = (std::__shared_weak_count *)*((_QWORD *)&v30 + 1);
      if (*((_QWORD *)&v30 + 1))
      {
        v22 = (unint64_t *)(*((_QWORD *)&v30 + 1) + 8);
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      *(_QWORD *)&v30 = v37;
      std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100]((void ***)&v30);
      v24 = (std::__shared_weak_count *)*((_QWORD *)&v36 + 1);
      if (*((_QWORD *)&v36 + 1))
      {
        v25 = (unint64_t *)(*((_QWORD *)&v36 + 1) + 8);
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      *(_QWORD *)&v30 = &v38;
      std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100]((void ***)&v30);
      v27 = (std::__shared_weak_count *)*((_QWORD *)&v41 + 1);
      if (*((_QWORD *)&v41 + 1))
      {
        v28 = (unint64_t *)(*((_QWORD *)&v41 + 1) + 8);
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
      goto LABEL_35;
    }
  }
  __break(1u);
}

void sub_1DBCC6DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  void *v9;
  uint64_t v10;
  uint64_t v11;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v10);
  Backend::Google::DatabaseUpdater::didFetchEncodedUpdates(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSObject  {objcproto14OS_nw_activity}*)::$_0::~$_0((uint64_t)&a9);
  a9 = (void **)(v11 - 112);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&a9);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v11 - 88);

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_72c60_ZTSNSt3__110shared_ptrIN7Backend6Google15DatabaseUpdaterEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(result + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(result + 80) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_72c60_ZTSNSt3__110shared_ptrIN7Backend6Google15DatabaseUpdaterEEE(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 72);
}

uint64_t __copy_helper_block_ea8_48c60_ZTSNSt3__110shared_ptrIN7Backend6Google15DatabaseUpdaterEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_48c60_ZTSNSt3__110shared_ptrIN7Backend6Google15DatabaseUpdaterEEE(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 48);
}

void Backend::Google::DatabaseUpdater::didFailUpdate(Backend::Google::DatabaseUpdater *this)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD block[4];
  uint64_t v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;

  Backend::Google::BackoffTracker<std::chrono::system_clock>::didReceiveError((uint64_t)this + 184);
  v2 = *((_QWORD *)this + 28);
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v20, this);
  v3 = *((_QWORD *)this + 3);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN7Backend6Google15DatabaseUpdater13didFailUpdateEv_block_invoke;
  block[3] = &__block_descriptor_56_ea8_32c61_ZTSKZN7Backend6Google15DatabaseUpdater13didFailUpdateEvE3__0_e5_v8__0l;
  v4 = v20;
  v5 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    v17 = v4;
    v18 = v5;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v19 = v2;
    dispatch_async(v3, block);
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    v17 = v20;
    v18 = 0;
    v19 = v2;
    dispatch_async(v3, block);
  }
  v10 = v18;
  if (v18)
  {
    v11 = (unint64_t *)&v18->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v21;
  if (v21)
  {
    v14 = (unint64_t *)&v21->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

uint64_t Backend::Google::DatabaseUpdater::findDatabase(Backend::Google::DatabaseUpdater *this, const Backend::Google::ThreatListDescriptor *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 18);
  v3 = *((_QWORD *)this + 19);
  if (v2 != v3)
  {
    while (!Backend::Google::operator==(v2, (uint64_t)a2))
    {
      v2 += 112;
      if (v2 == v3)
        return v3;
    }
  }
  return v2;
}

void Backend::Google::DatabaseUpdater::writeUpdatedDatabase(Backend::Google::DatabaseUpdater *a1, const Backend::Google::DatabaseInfo *a2, uint64_t a3, uint64_t a4)
{
  size_t size;
  std::string *v9;
  std::string *v10;
  char *v11;
  const std::error_category *v14;
  NSObject *v15;
  std::chrono::system_clock::time_point v16;
  const std::error_category *v17;
  std::error_code *v18;
  const std::__fs::filesystem::path *v19;
  const std::__fs::filesystem::path *v20;
  Backend::Google::DatabaseUpdater *v21;
  char v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  int v26;
  _BYTE *v27;
  _BYTE *v28;
  std::string *v29;
  int v30;
  _BYTE *v31;
  int *v32;
  _BYTE *v33;
  int v34;
  const char *v35;
  int v36;
  _BYTE *v37;
  _BYTE *v38;
  std::string *v39;
  int v40;
  std::string::size_type v41;
  int v42;
  std::string::size_type v43;
  int v44;
  std::string::size_type v45;
  int *v46;
  std::string *v47;
  int v48;
  std::string *v49;
  std::string *v50;
  int v51;
  _BYTE *v52;
  int *v53;
  _BYTE *v54;
  int v55;
  int v56;
  std::error_code v57;
  std::string v58;
  void *v59[5];
  _BYTE v60[152];
  std::string v61;
  std::string v62;
  _BYTE v63[12];
  __int16 v64;
  std::string *v65;
  __int16 v66;
  std::string *v67;
  __int16 v68;
  int v69;
  std::string v70;
  uint8_t buf[4];
  _BYTE *v72;
  __int16 v73;
  std::string *v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  Backend::Google::DatabaseUpdater::databasePath(a1, a2, &v62);
  if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v62.__r_.__value_.__r.__words[2]);
  else
    size = v62.__r_.__value_.__l.__size_;
  std::string::basic_string[abi:sn180100]((uint64_t)&v61, size + 4);
  if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v9 = &v61;
  else
    v9 = (std::string *)v61.__r_.__value_.__r.__words[0];
  if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v10 = &v62;
  else
    v10 = (std::string *)v62.__r_.__value_.__r.__words[0];
  v11 = (char *)v9 + size;
  if (v10 >= v9 && v11 > (char *)v10)
    goto LABEL_91;
  if (size)
    memmove(v9, v10, size);
  if (v11 <= ".tmp" && v11 + 4 > ".tmp")
LABEL_91:
    __break(1u);
  strcpy(v11, ".tmp");
  Backend::Google::DatabaseUpdateWriter::DatabaseUpdateWriter(v60, (char *)a2 + 32, a4, a3);
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v58, v61.__r_.__value_.__l.__data_, v61.__r_.__value_.__l.__size_);
  else
    v58 = v61;
  Platform::FileOutputStream::FileOutputStream((uint64_t)v59, (__n128 *)&v58);
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v58.__r_.__value_.__l.__data_);
  *(_QWORD *)&v57.__val_ = Backend::Google::DatabaseUpdateWriter::writeData((Backend::Google::DatabaseUpdateWriter *)v60, (Platform::OutputStream *)v59);
  v57.__cat_ = v14;
  if (v57.__val_)
  {
    v15 = (id)SSBOSLogDatabase();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_27;
    Backend::Google::ThreatListDescriptor::toString(a2, v63);
    v26 = SHIBYTE(v66);
    v27 = *(_BYTE **)v63;
    std::error_code::message(&v70, &v57);
    v28 = v63;
    if (v26 < 0)
      v28 = v27;
    if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v29 = &v70;
    else
      v29 = (std::string *)v70.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136446466;
    v72 = v28;
    v73 = 2082;
    v74 = v29;
    _os_log_error_impl(&dword_1DBCBE000, v15, OS_LOG_TYPE_ERROR, "Failed to write updated database '%{public}s': %{public}s", buf, 0x16u);
    if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v70.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v66) & 0x80000000) == 0)
      goto LABEL_27;
    goto LABEL_57;
  }
  v16.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  *(_QWORD *)&v57.__val_ = Backend::Google::DatabaseUpdateWriter::finalize((uint64_t)v60, v16.__d_.__rep_);
  v57.__cat_ = v17;
  if (v57.__val_)
  {
    v15 = (id)SSBOSLogDatabase();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_27;
    Backend::Google::ThreatListDescriptor::toString(a2, v63);
    v36 = SHIBYTE(v66);
    v37 = *(_BYTE **)v63;
    std::error_code::message(&v70, &v57);
    v38 = v63;
    if (v36 < 0)
      v38 = v37;
    if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v39 = &v70;
    else
      v39 = (std::string *)v70.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136446466;
    v72 = v38;
    v73 = 2082;
    v74 = v39;
    _os_log_error_impl(&dword_1DBCBE000, v15, OS_LOG_TYPE_ERROR, "Failed to finalize updated database '%{public}s': %{public}s", buf, 0x16u);
    if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v70.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v66) & 0x80000000) == 0)
      goto LABEL_27;
LABEL_57:
    operator delete(*(void **)v63);
LABEL_27:

    goto LABEL_64;
  }
  if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = (const std::__fs::filesystem::path *)&v61;
  else
    v19 = (const std::__fs::filesystem::path *)v61.__r_.__value_.__r.__words[0];
  if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v20 = (const std::__fs::filesystem::path *)&v62;
  else
    v20 = (const std::__fs::filesystem::path *)v62.__r_.__value_.__r.__words[0];
  rename(v19, v20, v18);
  if ((_DWORD)v21 != -1)
  {
    if (*((_QWORD *)a2 + 5))
      Backend::Google::DatabaseUpdater::unmapDatabaseFromMemory(v21, a2);
    Backend::Google::DatabaseUpdater::openDatabase(a1, a2, (int *)buf);
    if (*(_DWORD *)buf == -1)
    {
      v24 = (id)SSBOSLogDatabase();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        goto LABEL_63;
      Backend::Google::ThreatListDescriptor::toString(a2, v63);
      v30 = SHIBYTE(v66);
      v31 = *(_BYTE **)v63;
      v32 = __error();
      v33 = v63;
      v34 = *v32;
      if (v30 < 0)
        v33 = v31;
      LODWORD(v70.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)v70.__r_.__value_.__r.__words + 4) = (std::string::size_type)v33;
      WORD2(v70.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&v70.__r_.__value_.__r.__words[1] + 6) = v34;
      v35 = "Failed to open new database '%{public}s': %{errno}i";
    }
    else
    {
      v56 = *(_DWORD *)buf;
      v22 = Backend::Google::DatabaseUpdater::mapDatabaseIntoMemory(a1, (uint64_t)a2, &v56);
      v23 = v56;
      if (v56 != -1)
        v23 = close(v56);
      if ((v22 & 1) != 0)
      {
        if (Backend::Google::DatabaseUpdater::verifyDatabaseChecksum(v23, (uint64_t)a2, (_QWORD *)(a3 + 88)))
          goto LABEL_64;
        v24 = (id)SSBOSLogDatabase();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
        {
          Backend::Google::ThreatListDescriptor::toString(a2, v63);
          Backend::Google::DatabaseUpdater::writeUpdatedDatabase();
        }
        goto LABEL_63;
      }
      v24 = (id)SSBOSLogDatabase();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
LABEL_63:

        Backend::Google::DatabaseUpdater::deleteDatabase(a1, a2);
        goto LABEL_64;
      }
      Backend::Google::ThreatListDescriptor::toString(a2, v63);
      v51 = SHIBYTE(v66);
      v52 = *(_BYTE **)v63;
      v53 = __error();
      v54 = v63;
      v55 = *v53;
      if (v51 < 0)
        v54 = v52;
      LODWORD(v70.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)v70.__r_.__value_.__r.__words + 4) = (std::string::size_type)v54;
      WORD2(v70.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&v70.__r_.__value_.__r.__words[1] + 6) = v55;
      v35 = "Failed to map new database '%{public}s' into memory: %{errno}i";
    }
    _os_log_error_impl(&dword_1DBCBE000, v24, OS_LOG_TYPE_ERROR, v35, (uint8_t *)&v70, 0x12u);
    if (SHIBYTE(v66) < 0)
      operator delete(*(void **)v63);
    goto LABEL_63;
  }
  v25 = (id)SSBOSLogDatabase();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    Backend::Google::ThreatListDescriptor::toString(a2, &v70);
    v40 = SHIBYTE(v70.__r_.__value_.__r.__words[2]);
    v41 = v70.__r_.__value_.__r.__words[0];
    v42 = SHIBYTE(v61.__r_.__value_.__r.__words[2]);
    v43 = v61.__r_.__value_.__r.__words[0];
    v44 = SHIBYTE(v62.__r_.__value_.__r.__words[2]);
    v45 = v62.__r_.__value_.__r.__words[0];
    v46 = __error();
    v47 = &v62;
    v48 = *v46;
    if (v44 < 0)
      v47 = (std::string *)v45;
    *(_DWORD *)v63 = 136446978;
    v49 = &v61;
    if (v42 < 0)
      v49 = (std::string *)v43;
    v50 = &v70;
    if (v40 < 0)
      v50 = (std::string *)v41;
    *(_QWORD *)&v63[4] = v50;
    v64 = 2080;
    v65 = v49;
    v66 = 2080;
    v67 = v47;
    v68 = 1024;
    v69 = v48;
    _os_log_error_impl(&dword_1DBCBE000, v25, OS_LOG_TYPE_ERROR, "Failed to rename temporary database '%{public}s' from '%s' to '%s': %{errno}i", v63, 0x26u);
    if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v70.__r_.__value_.__l.__data_);
  }

  Backend::Google::DatabaseUpdater::deleteDatabase(a1, a2);
LABEL_64:
  Platform::FileOutputStream::~FileOutputStream(v59);
  Backend::Google::DatabaseUpdateWriter::~DatabaseUpdateWriter((Backend::Google::DatabaseUpdateWriter *)v60);
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v61.__r_.__value_.__l.__data_);
  if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v62.__r_.__value_.__l.__data_);
}

void sub_1DBCC7654(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  void *v50;
  void **v51;
  uint64_t v52;

  Platform::FileOutputStream::~FileOutputStream(&a21);
  Backend::Google::DatabaseUpdateWriter::~DatabaseUpdateWriter((Backend::Google::DatabaseUpdateWriter *)&a26);
  if (a50 < 0)
    operator delete(*v51);
  if (*(char *)(v52 - 209) < 0)
    operator delete(v51[3]);
  _Unwind_Resume(a1);
}

void ___ZN7Backend6Google15DatabaseUpdater22didFetchEncodedUpdatesEONSt3__18optionalINS0_30FetchThreatListUpdatesResponseEEEPU25objcproto14OS_nw_activity8NSObject_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v4[3];
  void **v5;

  v2 = a1[4];
  v3 = *(_QWORD *)(v2 + 16);
  memset(v4, 0, sizeof(v4));
  std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(v4, a1[6], a1[7], 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a1[7] - a1[6]) >> 4));
  (*(void (**)(uint64_t, uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v3 + 32))(v3, v2, v4, a1[9]);
  v5 = (void **)v4;
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v5);
}

void sub_1DBCC7858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100]((void ***)va);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_32c164_ZTSKZN7Backend6Google15DatabaseUpdater22didFetchEncodedUpdatesEONSt3__18optionalINS0_30FetchThreatListUpdatesResponseEEEPU25objcproto14OS_nw_activity8NSObjectE3__0(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *result;

  v4 = a2[5];
  a1[4] = a2[4];
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  result = std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(a1 + 6, a2[6], a2[7], 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a2[7] - a2[6]) >> 4));
  a1[9] = a2[9];
  return result;
}

void sub_1DBCC78F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c164_ZTSKZN7Backend6Google15DatabaseUpdater22didFetchEncodedUpdatesEONSt3__18optionalINS0_30FetchThreatListUpdatesResponseEEEPU25objcproto14OS_nw_activity8NSObjectE3__0(uint64_t a1)
{
  uint64_t v1;
  void **v3;

  v1 = a1 + 32;
  v3 = (void **)(a1 + 48);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v3);
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
}

uint64_t Backend::Google::DatabaseUpdater::didFetchEncodedUpdates(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSObject  {objcproto14OS_nw_activity}*)::$_0::~$_0(uint64_t a1)
{
  void **v3;

  v3 = (void **)(a1 + 16);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v3);
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1);
}

uint64_t Backend::Google::BackoffTracker<std::chrono::system_clock>::didReceiveError(uint64_t a1)
{
  uint64_t v2;
  Platform::Transaction **v3;
  Platform::Transaction *v4;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep;
  uint64_t result;
  std::string __p;

  v3 = (Platform::Transaction **)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 48);
  ++*(_DWORD *)(a1 + 36);
  if (!v2)
  {
    v4 = (Platform::Transaction *)operator new(0x18uLL);
    if (*(char *)(a1 + 23) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    else
      __p = *(std::string *)a1;
    Platform::Transaction::Transaction(v4, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    std::unique_ptr<Platform::Transaction>::reset[abi:sn180100](v3, v4);
  }
  rep = std::chrono::system_clock::now().__d_.__rep_;
  result = Backend::Google::BackoffTracker<std::chrono::system_clock>::computeNextAllowedRequestDuration(a1);
  *(_QWORD *)(a1 + 40) = result + rep;
  return result;
}

void sub_1DBCC7A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;

  operator delete(v14);
  _Unwind_Resume(a1);
}

uint64_t ___ZN7Backend6Google15DatabaseUpdater13didFailUpdateEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 16) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16));
}

_QWORD *__copy_helper_block_ea8_32c61_ZTSKZN7Backend6Google15DatabaseUpdater13didFailUpdateEvE3__0(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  result[6] = a2[6];
  return result;
}

uint64_t __destroy_helper_block_ea8_32c61_ZTSKZN7Backend6Google15DatabaseUpdater13didFailUpdateEvE3__0(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

BOOL Backend::Google::DatabaseUpdater::verifyDatabaseChecksum(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _BOOL8 v7;
  CC_SHA256_CTX v9;
  unsigned __int8 **v10[3];
  unsigned __int8 md[16];
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  Backend::Google::LexicographicallyOrderedHashEnumerator::LexicographicallyOrderedHashEnumerator((Backend::Google::LexicographicallyOrderedHashEnumerator *)v10, (const Backend::Google::Database *)(a2 + 32));
  CC_SHA256_Init(&v9);
  while (1)
  {
    Backend::Google::LexicographicallyOrderedHashEnumerator::next(v10, (uint64_t)md);
    if (!(_BYTE)v12)
      break;
    CC_SHA256_Update(&v9, *(const void **)&md[8], md[0]);
  }
  *(_OWORD *)md = 0u;
  v12 = 0u;
  CC_SHA256_Final(md, &v9);
  v7 = *(_QWORD *)md == *a3 && *(_QWORD *)&md[8] == a3[1] && (_QWORD)v12 == a3[2] && *((_QWORD *)&v12 + 1) == a3[3];
  Backend::Google::LexicographicallyOrderedHashEnumerator::~LexicographicallyOrderedHashEnumerator((Backend::Google::LexicographicallyOrderedHashEnumerator *)v10);
  return v7;
}

void sub_1DBCC7B84(_Unwind_Exception *a1)
{
  uint64_t v1;

  Backend::Google::LexicographicallyOrderedHashEnumerator::~LexicographicallyOrderedHashEnumerator((Backend::Google::LexicographicallyOrderedHashEnumerator *)(v1 - 88));
  _Unwind_Resume(a1);
}

uint64_t Backend::Google::DatabaseUpdater::newestDatabase(Backend::Google::DatabaseUpdater *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  result = *((_QWORD *)this + 18);
  v3 = *((_QWORD *)this + 19);
  v4 = result + 112;
  if (result != v3 && v4 != v3)
  {
    do
    {
      if (*(_QWORD *)(result + 48) < *(_QWORD *)(v4 + 48))
        result = v4;
      v4 += 112;
    }
    while (v4 != v3);
  }
  return result;
}

std::string *std::__throw_bad_function_call[abi:sn180100]()
{
  std::string *v0;
  const Backend::Google::Configuration *v1;

  std::__libcpp_verbose_abort("bad_function_call was thrown in -fno-exceptions mode");
  return Backend::Google::Configuration::Configuration(v0, v1);
}

std::string *Backend::Google::Configuration::Configuration(std::string *this, const Backend::Google::Configuration *a2)
{
  __int128 v4;
  std::string *v5;
  __int128 v6;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *(_OWORD *)a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  v5 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v6 = *(_OWORD *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  this[2].__r_.__value_.__r.__words[0] = (std::string::size_type)*((id *)a2 + 6);
  this[2].__r_.__value_.__l.__size_ = (std::string::size_type)*((id *)a2 + 7);
  this[2].__r_.__value_.__r.__words[2] = (std::string::size_type)*((id *)a2 + 8);
  this[3].__r_.__value_.__r.__words[0] = (std::string::size_type)*((id *)a2 + 9);
  this[3].__r_.__value_.__l.__size_ = (std::string::size_type)*((id *)a2 + 10);
  return this;
}

void sub_1DBCC7CAC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<Backend::Google::DatabaseInfo>::__push_back_slow_path<Backend::Google::DatabaseInfo>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v2 = *a1;
  v3 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 4);
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x249249249249249)
    abort();
  v8 = a1[2];
  v7 = (uint64_t)(a1 + 2);
  v9 = 0x6DB6DB6DB6DB6DB7 * ((v8 - v2) >> 4);
  if (2 * v9 > v4)
    v4 = 2 * v9;
  if (v9 >= 0x124924924924924)
    v10 = 0x249249249249249;
  else
    v10 = v4;
  v18 = v7;
  if (v10)
    v11 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::DatabaseInfo>>(v7, v10);
  else
    v11 = 0;
  v14 = v11;
  v15 = &v11[112 * v3];
  v17 = &v11[112 * v10];
  std::construct_at[abi:sn180100]<Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo*>((uint64_t)v15, a2);
  v16 = v15 + 112;
  std::vector<Backend::Google::DatabaseInfo>::__swap_out_circular_buffer(a1, &v14);
  v12 = a1[1];
  std::__split_buffer<Backend::Google::DatabaseInfo>::~__split_buffer((uint64_t)&v14);
  return v12;
}

void sub_1DBCC7DC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Backend::Google::DatabaseInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:sn180100]<Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo*>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  if (result)
  {
    v2 = result;
    *(_OWORD *)result = *(_OWORD *)a2;
    v3 = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(result + 24) = v3;
    if (v3)
    {
      v4 = (unint64_t *)(v3 + 8);
      do
        v5 = __ldxr(v4);
      while (__stxr(v5 + 1, v4));
    }
    v6 = *(_OWORD *)(a2 + 32);
    v7 = *(_OWORD *)(a2 + 48);
    v8 = *(_OWORD *)(a2 + 64);
    *(_BYTE *)(result + 80) = *(_BYTE *)(a2 + 80);
    *(_OWORD *)(result + 48) = v7;
    *(_OWORD *)(result + 64) = v8;
    *(_OWORD *)(result + 32) = v6;
    std::vector<Backend::Google::Database::HashSizeBucket>::vector((_QWORD *)(result + 88), a2 + 88);
    return v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_1DBCC7E54(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<Backend::Google::Database::HashSizeBucket>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<Backend::Google::Database::HashSizeBucket>::__vallocate[abi:sn180100](a1, v5 >> 4);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<Backend::Google::Database::HashSizeBucket>::__vallocate[abi:sn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    abort();
  result = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::Database::HashSizeBucket>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

uint64_t *std::vector<Backend::Google::DatabaseInfo>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 112;
    v4 -= 112;
    result = (uint64_t *)std::construct_at[abi:sn180100]<Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo*>(v6, v4);
  }
  a2[1] = v6;
  v7 = *v3;
  *v3 = v6;
  a2[1] = v7;
  v8 = v3[1];
  v3[1] = a2[2];
  a2[2] = v8;
  v9 = v3[2];
  v3[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::DatabaseInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(112 * a2);
}

uint64_t std::__split_buffer<Backend::Google::DatabaseInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 112;
    Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)(i - 112));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::unique_ptr<Platform::Transaction>::reset[abi:sn180100](Platform::Transaction **a1, Platform::Transaction *a2)
{
  Platform::Transaction *v3;
  void *v4;

  v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    Platform::Transaction::~Transaction(v3);
    operator delete(v4);
  }
}

void std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)(v4 - 112));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ___ZZN7Backend6Google15DatabaseUpdater10initializeEvENK3__1clEv_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v4[3];
  void **v5;

  v2 = a1[4];
  v3 = *(_QWORD *)(v2 + 16);
  memset(v4, 0, sizeof(v4));
  std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(v4, a1[6], a1[7], 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a1[7] - a1[6]) >> 4));
  (*(void (**)(uint64_t, uint64_t, _QWORD *, _QWORD, uint64_t))(*(_QWORD *)v3 + 16))(v3, v2, v4, a1[9], 1);
  v5 = (void **)v4;
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v5);
}

void sub_1DBCC815C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100]((void ***)va);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_32c71_ZTSKZZN7Backend6Google15DatabaseUpdater10initializeEvENK3__1clEvEUlvE_(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *result;

  v4 = a2[5];
  a1[4] = a2[4];
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  result = std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(a1 + 6, a2[6], a2[7], 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a2[7] - a2[6]) >> 4));
  a1[9] = a2[9];
  return result;
}

void sub_1DBCC81F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c71_ZTSKZZN7Backend6Google15DatabaseUpdater10initializeEvENK3__1clEvEUlvE_(uint64_t a1)
{
  uint64_t v1;
  void **v3;

  v1 = a1 + 32;
  v3 = (void **)(a1 + 48);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v3);
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
}

uint64_t std::uniform_int_distribution<long long>::operator()<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v4;
  unint64_t v5;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _BYTE v10[64];

  result = a3[1];
  v4 = result - *a3;
  if (result != *a3)
  {
    v5 = v4 + 1;
    if (v4 == -1)
    {
      std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long long>::__independent_bits_engine((uint64_t)v10, a2, 0x40uLL);
      return std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long long>::__eval((uint64_t)v10);
    }
    else
    {
      v7 = __clz(v5);
      v8 = 63;
      if (((v5 << v7) & 0x7FFFFFFFFFFFFFFFLL) != 0)
        v8 = 64;
      std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long long>::__independent_bits_engine((uint64_t)v10, a2, v8 - v7);
      do
        v9 = std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long long>::__eval((uint64_t)v10);
      while (v9 >= v5);
      return *a3 + v9;
    }
  }
  return result;
}

uint64_t std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long long>::__independent_bits_engine(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;

  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a3;
  if (a3 % 0x1E)
    v3 = a3 / 0x1E + 1;
  else
    v3 = a3 / 0x1E;
  v4 = a3 / v3;
  *(_QWORD *)(result + 16) = a3 / v3;
  *(_QWORD *)(result + 24) = v3;
  v5 = (-1 << (a3 / v3)) & 0x7FFFFFFE;
  if (a3 / v3 >= 0x40)
    v5 = 0;
  *(_QWORD *)(result + 40) = v5;
  if ((v5 ^ 0x7FFFFFFE) > v5 / v3)
  {
    ++v3;
    v4 = a3 / v3;
    *(_QWORD *)(result + 16) = a3 / v3;
    *(_QWORD *)(result + 24) = v3;
    if (a3 / v3 > 0x3F)
    {
      v6 = 0;
      *(_QWORD *)(result + 32) = v3 + v4 * v3 - a3;
      *(_QWORD *)(result + 40) = 0;
      goto LABEL_13;
    }
    *(_QWORD *)(result + 40) = (-1 << v4) & 0x7FFFFFFE;
  }
  *(_QWORD *)(result + 32) = v3 + a3 / v3 * v3 - a3;
  if (v4 > 0x3E)
    v6 = 0;
  else
    v6 = 0x3FFFFFFFuLL >> v4 << (v4 + 1);
LABEL_13:
  *(_QWORD *)(result + 48) = v6;
  v7 = 0xFFFFFFFF >> -(char)v4;
  if (!v4)
    v7 = 0;
  if (v4 >= 0x1F)
    v8 = -1;
  else
    v8 = 0xFFFFFFFF >> ~(_BYTE)v4;
  *(_DWORD *)(result + 56) = v7;
  *(_DWORD *)(result + 60) = v8;
  return result;
}

uint64_t std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long long>::__eval(uint64_t a1)
{
  unint64_t v2;
  uint64_t result;
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  unint64_t v24;
  uint64_t v25;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    result = 0;
    v4 = 0;
    v5 = *(_QWORD *)(a1 + 16);
    v6 = **(_DWORD **)a1;
    do
    {
      do
      {
        v7 = v6 / 0xADC8;
        v8 = 48271 * (v6 % 0xADC8);
        v7 *= 3399;
        v9 = v8 >= v7;
        v10 = v8 - v7;
        if (v9)
          v11 = 0;
        else
          v11 = 0x7FFFFFFF;
        v6 = v11 + v10;
        v12 = v6 - 1;
      }
      while (*(_QWORD *)(a1 + 40) <= v12);
      v13 = result << v5;
      if (v5 >= 0x40)
        v13 = 0;
      result = v13 + (*(_DWORD *)(a1 + 56) & v12);
      ++v4;
    }
    while (v4 != v2);
    **(_DWORD **)a1 = v6;
  }
  else
  {
    result = 0;
  }
  v14 = *(_QWORD *)(a1 + 24);
  if (v2 < v14)
  {
    v15 = *(unsigned int **)a1;
    v16 = *(_QWORD *)(a1 + 48);
    v17 = *(_QWORD *)(a1 + 16);
    v18 = *(_DWORD *)(a1 + 60);
    v19 = *v15;
    while (1)
    {
      v20 = v19 / 0xADC8;
      v21 = 48271 * (v19 % 0xADC8);
      v20 *= 3399;
      v9 = v21 >= v20;
      v22 = v21 - v20;
      if (v9)
        v23 = 0;
      else
        v23 = 0x7FFFFFFF;
      v19 = v23 + v22;
      v24 = v19 - 1;
      if (v16 > v24)
      {
        v25 = result << (v17 + 1);
        if (v17 >= 0x3F)
          v25 = 0;
        result = v25 + (v18 & v24);
        if (++v2 == v14)
          break;
      }
    }
    *v15 = v19;
  }
  return result;
}

uint64_t ___ZZN7Backend6Google15DatabaseUpdater6updateENS0_19DatabaseUpdateStyleEP18ProxyConfigurationENK3__0clEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 16) + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16));
}

uint64_t __copy_helper_block_ea8_32c112_ZTSKZZN7Backend6Google15DatabaseUpdater6updateENS0_19DatabaseUpdateStyleEP18ProxyConfigurationENK3__0clEvEUlvE_(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c112_ZTSKZZN7Backend6Google15DatabaseUpdater6updateENS0_19DatabaseUpdateStyleEP18ProxyConfigurationENK3__0clEvEUlvE_(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

char *std::vector<Backend::Google::Database::HashSizeBucket>::__assign_with_size[abi:sn180100]<Backend::Google::Database::HashSizeBucket*,Backend::Google::Database::HashSizeBucket*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60)
      abort();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<Backend::Google::Database::HashSizeBucket>::__vallocate[abi:sn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 4;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

void _ZZN8BlockPtrIFvvEE13from_callableIZZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS4_19DatabaseUpdateStyleEP18ProxyConfigurationEUb_E3__1EES1_T_ENUlPKvE_8__invokeESC_(uint64_t a1)
{
  void **v2;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 96);
  if (*(_BYTE *)(a1 + 72))
  {
    v2 = (void **)(a1 + 32);
    std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v2);
  }
}

void _ZZN8BlockPtrIFvvEE13from_callableIZZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS4_19DatabaseUpdateStyleEP18ProxyConfigurationEUb_E3__1EES1_T_ENUlPvE_8__invokeESB_(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*(_BYTE *)(a1 + 112)
    && *(_QWORD *)(a1 + 80)
    && +[ProxyConfiguration shouldRetryForError:](ProxyConfiguration, "shouldRetryForError:"))
  {
    v2 = SSBOSLogDatabase();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke_2_cold_1(v2, v3, v4, v5, v6, v7, v8, v9);
    Backend::Google::DatabaseUpdater::fetchEncodedUpdates(*(_QWORD *)(a1 + 96), *(unsigned int *)(a1 + 88), 0);
  }
  else
  {
    Backend::Google::DatabaseUpdater::didFetchEncodedUpdates(*(_QWORD *)(a1 + 96), a1 + 32, *(void **)(a1 + 120));
  }
}

void std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 120;
        std::__destroy_at[abi:sn180100]<Backend::Google::ListUpdateResponse,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:sn180100]<Backend::Google::ListUpdateResponse,0>(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v4;

  if (a1)
  {
    v2 = *(void **)(a1 + 64);
    if (v2)
    {
      *(_QWORD *)(a1 + 72) = v2;
      operator delete(v2);
    }
    v3 = *(void **)(a1 + 40);
    if (v3)
    {
      *(_QWORD *)(a1 + 48) = v3;
      operator delete(v3);
    }
    v4 = (void **)(a1 + 16);
    std::vector<Backend::Google::ListUpdateResponse::Addition>::__destroy_vector::operator()[abi:sn180100](&v4);
  }
  else
  {
    __break(1u);
  }
}

void std::vector<Backend::Google::ListUpdateResponse::Addition>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<Backend::Google::ListUpdateResponse::Addition>::__clear[abi:sn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<Backend::Google::ListUpdateResponse::Addition>::__clear[abi:sn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 16)
  {
    v4 = *(void **)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      operator delete[](v4);
  }
  a1[1] = v2;
}

_QWORD *std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6;

  if (a4)
  {
    v6 = (uint64_t)result;
    std::vector<Backend::Google::DatabaseInfo>::__vallocate[abi:sn180100](result, a4);
    return (_QWORD *)std::vector<Backend::Google::DatabaseInfo>::__construct_at_end<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(v6, a2, a3);
  }
  return result;
}

char *std::vector<Backend::Google::DatabaseInfo>::__vallocate[abi:sn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x24924924924924ALL)
    abort();
  result = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::DatabaseInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[112 * v4];
  return result;
}

uint64_t std::vector<Backend::Google::DatabaseInfo>::__construct_at_end<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v7;

  v3 = result;
  v4 = *(_QWORD *)(result + 8);
  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      result = std::construct_at[abi:sn180100]<Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo&,Backend::Google::DatabaseInfo*>(v4 + v7, a2 + v7);
      v7 += 112;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  *(_QWORD *)(v3 + 8) = v4;
  return result;
}

void sub_1DBCC8968(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:sn180100]<Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo&,Backend::Google::DatabaseInfo*>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  if (result)
  {
    v2 = result;
    *(_OWORD *)result = *(_OWORD *)a2;
    v3 = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(result + 24) = v3;
    if (v3)
    {
      v4 = (unint64_t *)(v3 + 8);
      do
        v5 = __ldxr(v4);
      while (__stxr(v5 + 1, v4));
    }
    v6 = *(_OWORD *)(a2 + 32);
    v7 = *(_OWORD *)(a2 + 48);
    v8 = *(_OWORD *)(a2 + 64);
    *(_BYTE *)(result + 80) = *(_BYTE *)(a2 + 80);
    *(_OWORD *)(result + 48) = v7;
    *(_OWORD *)(result + 64) = v8;
    *(_OWORD *)(result + 32) = v6;
    std::vector<Backend::Google::Database::HashSizeBucket>::vector((_QWORD *)(result + 88), a2 + 88);
    return v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_1DBCC89E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::string::basic_string[abi:sn180100](uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;
  size_t v9;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_11;
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  v9 = __sz + 1;
  if (v5 <= (std::string *)__s && (char *)v5 + v9 > __s)
  {
    __break(1u);
LABEL_11:
    abort();
  }
  memmove(v5, __s, v9);
}

void std::__shared_ptr_emplace<ByteProvider>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB878;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ByteProvider>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB878;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<ByteProvider>::__on_zero_shared(uint64_t a1)
{
  std::__destroy_at[abi:sn180100]<ByteProvider,0>(a1 + 24);
}

void std::__destroy_at[abi:sn180100]<ByteProvider,0>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  if (!a1)
  {
    __break(1u);
    return;
  }
  v2 = (_QWORD *)(a1 + 16);
  v3 = *(_QWORD **)(a1 + 40);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_7;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_7:
  v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

void std::shared_ptr<ByteProvider>::__enable_weak_this[abi:sn180100]<ByteProvider,ByteProvider,void>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  if (a2)
  {
    v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
        do
          v9 = __ldxr(p_shared_weak_owners);
        while (__stxr(v9 + 1, p_shared_weak_owners));
        v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4)
        std::__shared_weak_count::__release_weak(v4);
      if (v5)
      {
        v10 = (unint64_t *)&v5->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }
}

_QWORD *std::allocate_shared[abi:sn180100]<ReadStream,std::allocator<ReadStream>,std::shared_ptr<ByteProvider> &,void>@<X0>(uint64_t *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x38uLL);
  result = std::__shared_ptr_emplace<ReadStream>::__shared_ptr_emplace[abi:sn180100]<std::shared_ptr<ByteProvider> &,std::allocator<ReadStream>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1DBCC8CAC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<ReadStream>::__shared_ptr_emplace[abi:sn180100]<std::shared_ptr<ByteProvider> &,std::allocator<ReadStream>,0>(_QWORD *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1EA3EB808;
  std::construct_at[abi:sn180100]<ReadStream,std::shared_ptr<ByteProvider> &,ReadStream*>((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1DBCC8CF4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ReadStream>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB808;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ReadStream>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB808;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<ReadStream>::__on_zero_shared(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 24);
}

uint64_t std::construct_at[abi:sn180100]<ReadStream,std::shared_ptr<ByteProvider> &,ReadStream*>(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  if (result)
  {
    v2 = result;
    v3 = *a2;
    v4 = (std::__shared_weak_count *)a2[1];
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
      *(_QWORD *)result = v3;
      *(_QWORD *)(result + 8) = v4;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
      *(_BYTE *)(result + 16) = 0;
      *(_BYTE *)(result + 24) = 0;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    else
    {
      *(_QWORD *)result = v3;
      *(_QWORD *)(result + 8) = 0;
      *(_BYTE *)(result + 16) = 0;
      *(_BYTE *)(result + 24) = 0;
    }
    return v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_1DBCC8EE8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DBCC904C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  void *v15;
  uint64_t v16;

  if (a15)
  {
    *(_QWORD *)(v16 - 40) = &a10;
    std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100]((void ***)(v16 - 40));
  }

  _Unwind_Resume(a1);
}

void sub_1DBCC90B0(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

void std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::operator()(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5;
  id v6;

  v6 = a3;
  v5 = *(_QWORD *)(a1 + 24);
  if (v5)
  {
    (*(void (**)(uint64_t, uint64_t, id *))(*(_QWORD *)v5 + 48))(v5, a2, &v6);

  }
  else
  {
    std::__throw_bad_function_call[abi:sn180100]();
    __break(1u);
  }
}

void sub_1DBCC9184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(_QWORD *a1, _QWORD *a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  v3 = (std::__shared_weak_count *)a2[1];
  *a1 = *a2;
  if (!v3)
  {
    a1[1] = 0;
    goto LABEL_5;
  }
  v4 = std::__shared_weak_count::lock(v3);
  a1[1] = v4;
  if (!v4)
  {
LABEL_5:
    std::__throw_bad_weak_ptr[abi:sn180100]();
    std::__throw_bad_weak_ptr[abi:sn180100]();
  }
}

void std::__throw_bad_weak_ptr[abi:sn180100]()
{
  Backend::Google::ListUpdateRequest *v0;

  std::__libcpp_verbose_abort("bad_weak_ptr was thrown in -fno-exceptions mode");
  Backend::Google::ListUpdateRequest::~ListUpdateRequest(v0);
}

void Backend::Google::ListUpdateRequest::~ListUpdateRequest(Backend::Google::ListUpdateRequest *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    *((_QWORD *)this + 12) = v2;
    operator delete(v2);
  }
  if (*((_BYTE *)this + 80))
  {
    if (*((char *)this + 79) < 0)
      operator delete(*((void **)this + 7));
  }
}

char *std::vector<Backend::Google::CompressionType>::__assign_with_size[abi:sn180100]<Backend::Google::CompressionType const*,Backend::Google::CompressionType const*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62)
      abort();
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<Backend::Google::CompressionType>::__vallocate[abi:sn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *std::vector<Backend::Google::CompressionType>::__vallocate[abi:sn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    abort();
  result = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::CompressionType>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::CompressionType>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(4 * a2);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *),std::allocator<void({block_pointer})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>,NSError *>::~__func(uint64_t a1)
{

  return a1;
}

void std::__function::__func<void({block_pointer} {__strong})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *),std::allocator<void({block_pointer})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>,NSError *>::~__func(id *a1)
{

  operator delete(a1);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *),std::allocator<void({block_pointer})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>,NSError *>::__clone()
{
  return 0;
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *),std::allocator<void({block_pointer})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>,NSError *>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  *a2 = off_1EA3EB1D8;
  result = MEMORY[0x1DF0B8E90](*(_QWORD *)(a1 + 8));
  a2[1] = result;
  return result;
}

void std::__function::__func<void({block_pointer} {__strong})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *),std::allocator<void({block_pointer})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>,NSError *>::destroy(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0;

}

uint64_t std::__function::__func<void({block_pointer} {__strong})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *),std::allocator<void({block_pointer})(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>,NSError *>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
}

uint64_t Backend::Google::BackoffTracker<std::chrono::system_clock>::computeNextAllowedRequestDuration(uint64_t result)
{
  uint64_t v1;

  if (!*(_DWORD *)(result + 32))
  {
    if (*(_DWORD *)(result + 36) <= 7u)
    {
      v1 = (uint64_t)((std::generate_canonical[abi:sn180100]<double,53ul,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(*(unsigned int **)(result + 24))
                    + 0.0
                    + 1.0)
                   * (double)(60 * (15 << (*(_DWORD *)(result + 36) - 1))));
      if (v1 >= 86400)
        v1 = 86400;
      return 1000000 * v1;
    }
    else
    {
      return 86400000000;
    }
  }
  return result;
}

double std::generate_canonical[abi:sn180100]<double,53ul,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  BOOL v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;

  v1 = 48271 * (*a1 % 0xADC8);
  v2 = 3399 * (*a1 / 0xADC8);
  v3 = v1 >= v2;
  v4 = v1 - v2;
  if (v3)
    v5 = 0;
  else
    v5 = 0x7FFFFFFF;
  v6 = v5 + v4;
  v7 = v6 - 1;
  v8 = v6 / 0xADC8;
  v9 = 48271 * (v6 % 0xADC8);
  v8 *= 3399;
  v3 = v9 >= v8;
  v10 = v9 - v8;
  if (v3)
    v11 = 0;
  else
    v11 = 0x7FFFFFFF;
  v12 = v11 + v10;
  *a1 = v12;
  return ((double)v7 + (double)(v12 - 1) * 2147483650.0) / 4.61168601e18;
}

Backend::Google::Database *Backend::Google::DatabaseUpdateWriter::DatabaseUpdateWriter(Backend::Google::Database *this, __int128 *a2, uint64_t a3, uint64_t a4)
{
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  int i;
  Backend::Google::Database *result;
  uint64_t v14;
  unsigned __int8 v15;
  unsigned __int8 v16[8];
  void *__src;
  char v18;
  unsigned __int8 **v19[3];
  unsigned __int8 *v20;

  if (*(_DWORD *)(a4 + 12) == 2)
  {
    Backend::Google::Database::Database(this);
  }
  else
  {
    v8 = *a2;
    v9 = a2[1];
    v10 = a2[2];
    *((_BYTE *)this + 48) = *((_BYTE *)a2 + 48);
    *((_OWORD *)this + 1) = v9;
    *((_OWORD *)this + 2) = v10;
    *(_OWORD *)this = v8;
    std::vector<Backend::Google::Database::HashSizeBucket>::vector((_QWORD *)this + 7, (uint64_t)a2 + 56);
  }
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 10) = a3;
  *((_QWORD *)this + 11) = a4;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 32) = 1065353216;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  if (*(_QWORD *)(a4 + 40) == *(_QWORD *)(a4 + 48))
    return this;
  Backend::Google::LexicographicallyOrderedHashEnumerator::LexicographicallyOrderedHashEnumerator((Backend::Google::LexicographicallyOrderedHashEnumerator *)v19, (const Backend::Google::Database *)a2);
  LODWORD(v11) = 0;
  for (i = 0; ; ++i)
  {
    result = (Backend::Google::Database *)Backend::Google::LexicographicallyOrderedHashEnumerator::next(v19, (uint64_t)v16);
    if (!v18)
    {
LABEL_12:
      Backend::Google::LexicographicallyOrderedHashEnumerator::~LexicographicallyOrderedHashEnumerator((Backend::Google::LexicographicallyOrderedHashEnumerator *)v19);
      return this;
    }
    v14 = *(_QWORD *)(*((_QWORD *)this + 11) + 40);
    if (v11 >= (unint64_t)((*(_QWORD *)(*((_QWORD *)this + 11) + 48) - v14) >> 2))
      goto LABEL_14;
    if (i == *(_DWORD *)(v14 + 4 * v11))
      break;
LABEL_11:
    ;
  }
  v15 = v16[0];
  v20 = &v15;
  result = (Backend::Google::Database *)std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char &&>,std::tuple<>>((uint64_t)this + 96, &v15, (uint64_t)&std::piecewise_construct, &v20);
  if (v18)
  {
    std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)result + 24, *((char **)result + 4), (char *)__src, (char *)__src + v16[0], v16[0]);
    v11 = (v11 + 1);
    if (v11 == (uint64_t)(*(_QWORD *)(*((_QWORD *)this + 11) + 48) - *(_QWORD *)(*((_QWORD *)this + 11) + 40)) >> 2)
      goto LABEL_12;
    goto LABEL_11;
  }
LABEL_14:
  __break(1u);
  return result;
}

void sub_1DBCC96F0(_Unwind_Exception *a1)
{
  Backend::Google::Database *v1;
  uint64_t v2;

  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::~__hash_table(v2);
  Backend::Google::Database::~Database(v1);
  _Unwind_Resume(a1);
}

void Backend::Google::DatabaseUpdateWriter::~DatabaseUpdateWriter(Backend::Google::DatabaseUpdateWriter *this)
{
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::~__hash_table((uint64_t)this + 96);
  Backend::Google::Database::~Database(this);
}

unint64_t Backend::Google::DatabaseUpdateWriter::writeData(Backend::Google::DatabaseUpdateWriter *this, Platform::OutputStream *a2)
{
  unint64_t v3;
  unsigned int v4;

  *((_QWORD *)this + 17) = a2;
  v3 = (*(uint64_t (**)(Platform::OutputStream *))(*(_QWORD *)a2 + 16))(a2);
  if (!(_DWORD)v3)
  {
    v3 = Backend::Google::DatabaseUpdateWriter::writeData(this);
    if (!(_DWORD)v3)
    {
      std::system_category();
      v4 = 0;
      return v3 & 0xFFFFFFFF00000000 | v4;
    }
    (*(void (**)(_QWORD))(**((_QWORD **)this + 17) + 48))(*((_QWORD *)this + 17));
    *((_QWORD *)this + 17) = 0;
  }
  v4 = v3;
  return v3 & 0xFFFFFFFF00000000 | v4;
}

unint64_t Backend::Google::DatabaseUpdateWriter::writeData(Backend::Google::DatabaseUpdateWriter *this)
{
  unint64_t v2;
  unsigned int v3;

  v2 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 17) + 40))(*((_QWORD *)this + 17), 32);
  if ((_DWORD)v2
    || (v2 = Backend::Google::DatabaseUpdateWriter::writeClientState(this), (_DWORD)v2)
    || (v2 = Backend::Google::DatabaseUpdateWriter::writeHashSizeBuckets(this), (_DWORD)v2))
  {
    v3 = v2;
  }
  else
  {
    std::system_category();
    v3 = 0;
  }
  return v2 & 0xFFFFFFFF00000000 | v3;
}

unint64_t Backend::Google::DatabaseUpdateWriter::finalize(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  unsigned int v4;

  v3 = Backend::Google::DatabaseUpdateWriter::writeHeader(a1, a2);
  if ((_DWORD)v3
    || (v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 48))(*(_QWORD *)(a1 + 136)), (_DWORD)v3))
  {
    v4 = v3;
  }
  else
  {
    *(_QWORD *)(a1 + 136) = 0;
    std::system_category();
    v4 = 0;
  }
  return v3 & 0xFFFFFFFF00000000 | v4;
}

unint64_t Backend::Google::DatabaseUpdateWriter::writeHeader(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 136) + 40))(*(_QWORD *)(a1 + 136), 0);
  if ((_DWORD)v4
    || (v4 = Platform::OutputStream::writeUInt32(*(Platform::OutputStream **)(a1 + 136), 0x47534244u), (_DWORD)v4)
    || (v4 = Platform::OutputStream::writeUInt32(*(Platform::OutputStream **)(a1 + 136), 2u), (_DWORD)v4)
    || (v4 = Platform::OutputStream::writeUInt64(*(Platform::OutputStream **)(a1 + 136), a2 / 1000000), (_DWORD)v4)
    || (v4 = Platform::OutputStream::writeUInt64(*(Platform::OutputStream **)(a1 + 136), *(_QWORD *)(a1 + 80) / 1000000), (_DWORD)v4)|| (v4 = Platform::OutputStream::writeUInt32(*(Platform::OutputStream **)(a1 + 136), *(_DWORD *)(a1 + 144)), (_DWORD)v4))
  {
    v5 = v4;
  }
  else
  {
    v4 = Platform::OutputStream::writeUInt32(*(Platform::OutputStream **)(a1 + 136), *(_DWORD *)(a1 + 148));
    v5 = v4;
    if (!(_DWORD)v4)
    {
      std::system_category();
      LODWORD(v4) = 0;
    }
  }
  return v5 & 0xFFFFFFFF00000000 | v4;
}

unint64_t Backend::Google::DatabaseUpdateWriter::writeClientState(Backend::Google::DatabaseUpdateWriter *this)
{
  unint64_t Offset32;
  unsigned int v3;

  Offset32 = Platform::OutputStream::getOffset32(*((Platform::OutputStream **)this + 17), (unsigned int *)this + 36);
  if ((_DWORD)Offset32
    || (Offset32 = Platform::OutputStream::writeUInt32(*((Platform::OutputStream **)this + 17), *(_DWORD *)(*((_QWORD *)this + 11) + 72) - *(_DWORD *)(*((_QWORD *)this + 11) + 64)), (_DWORD)Offset32)|| (Offset32 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 17) + 24))(*((_QWORD *)this + 17), *(_QWORD *)(*((_QWORD *)this + 11) + 64), *(_QWORD *)(*((_QWORD *)this + 11) + 72) - *(_QWORD *)(*((_QWORD *)this + 11) + 64)), (_DWORD)Offset32))
  {
    v3 = Offset32;
  }
  else
  {
    std::system_category();
    v3 = 0;
  }
  return Offset32 & 0xFFFFFFFF00000000 | v3;
}

unint64_t Backend::Google::DatabaseUpdateWriter::writeHashSizeBuckets(Backend::Google::DatabaseUpdateWriter *this)
{
  unint64_t result;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;

  result = Platform::OutputStream::getOffset32(*((Platform::OutputStream **)this + 17), (unsigned int *)this + 37);
  v3 = HIDWORD(result);
  if ((_DWORD)result)
    return result | ((unint64_t)v3 << 32);
  v4 = *(_QWORD *)(*((_QWORD *)this + 11) + 16);
  v5 = *(_QWORD *)(*((_QWORD *)this + 11) + 24);
  v6 = *((_QWORD *)this + 8) - *((_QWORD *)this + 7);
  v7 = v6 >> 4;
  v8 = (v5 - v4) >> 4;
  if (v6)
    v9 = v5 == v4;
  else
    v9 = 1;
  if (!v9)
  {
    v16 = 0;
    v17 = 0;
LABEL_21:
    v18 = 16 * v16;
    while (1)
    {
      v19 = *((_QWORD *)this + 7);
      if (v16 >= (*((_QWORD *)this + 8) - v19) >> 4)
        goto LABEL_38;
      v20 = *(_QWORD *)(*((_QWORD *)this + 11) + 16);
      if (v17 >= (*(_QWORD *)(*((_QWORD *)this + 11) + 24) - v20) >> 4)
        goto LABEL_38;
      v21 = *(unsigned __int8 *)(v19 + v18);
      v22 = *(unsigned __int8 *)(v20 + 16 * v17);
      if (v21 >= v22)
      {
        if (v22 >= v21)
        {
          result = Backend::Google::DatabaseUpdateWriter::writeHashSizeBucket((uint64_t)this, v21, v21, *(unsigned __int8 **)(v19 + v18 + 8), v21, (unsigned __int8 *)(*(_QWORD *)(v19 + v18 + 8) + *(_DWORD *)(v19 + v18 + 4) * v21), v22, *(_QWORD *)(v20 + 16 * v17 + 8), *(_BYTE *)(v20 + 16 * v17), *(_QWORD *)(v20 + 16 * v17 + 8) + *(_DWORD *)(v20 + 16 * v17 + 4) * v22);
          v3 = HIDWORD(result);
          if ((_DWORD)result)
            return result | ((unint64_t)v3 << 32);
          ++v16;
          ++v17;
        }
        else
        {
          result = Backend::Google::DatabaseUpdateWriter::writeHashSizeBucket((uint64_t)this, v22, 4u, 0, 4u, 0, v22, *(_QWORD *)(v20 + 16 * v17 + 8), *(_BYTE *)(v20 + 16 * v17), *(_QWORD *)(v20 + 16 * v17 + 8) + *(_DWORD *)(v20 + 16 * v17 + 4) * v22);
          v3 = HIDWORD(result);
          if ((_DWORD)result)
            return result | ((unint64_t)v3 << 32);
          ++v17;
        }
        if (v16 != v7 && v17 != v8)
          goto LABEL_21;
        goto LABEL_8;
      }
      result = Backend::Google::DatabaseUpdateWriter::writeHashSizeBucket((uint64_t)this, v21, v21, *(unsigned __int8 **)(v19 + v18 + 8), v21, (unsigned __int8 *)(*(_QWORD *)(v19 + v18 + 8) + *(_DWORD *)(v19 + v18 + 4) * v21), 4u, 0, 4u, 0);
      if ((_DWORD)result)
      {
LABEL_36:
        v3 = HIDWORD(result);
        return result | ((unint64_t)v3 << 32);
      }
      ++v16;
      v18 += 16;
      if (v7 == v16)
      {
LABEL_13:
        v3 = HIDWORD(result);
        goto LABEL_14;
      }
    }
  }
  v17 = 0;
  v16 = 0;
LABEL_8:
  if (v16 != v7)
  {
    v10 = 16 * v16;
    while (1)
    {
      v11 = *((_QWORD *)this + 7);
      if (v16 >= (*((_QWORD *)this + 8) - v11) >> 4)
        goto LABEL_38;
      v12 = (unsigned __int8 *)(v11 + v10);
      result = Backend::Google::DatabaseUpdateWriter::writeHashSizeBucket((uint64_t)this, *v12, *v12, *((unsigned __int8 **)v12 + 1), *v12, (unsigned __int8 *)(*((_QWORD *)v12 + 1) + *((_DWORD *)v12 + 1) * *v12), 4u, 0, 4u, 0);
      if ((_DWORD)result)
        goto LABEL_36;
      ++v16;
      v10 += 16;
      if (v7 == v16)
        goto LABEL_13;
    }
  }
LABEL_14:
  if (v17 == v8)
  {
LABEL_20:
    std::system_category();
    LODWORD(result) = 0;
    return result | ((unint64_t)v3 << 32);
  }
  v13 = 16 * v17;
  while (1)
  {
    v14 = *(_QWORD *)(*((_QWORD *)this + 11) + 16);
    if (v17 >= (*(_QWORD *)(*((_QWORD *)this + 11) + 24) - v14) >> 4)
      break;
    v15 = (unsigned __int8 *)(v14 + v13);
    result = Backend::Google::DatabaseUpdateWriter::writeHashSizeBucket((uint64_t)this, *v15, 4u, 0, 4u, 0, *v15, *((_QWORD *)v15 + 1), *v15, *((_QWORD *)v15 + 1) + *((_DWORD *)v15 + 1) * *v15);
    if ((_DWORD)result)
      goto LABEL_36;
    ++v17;
    v13 += 16;
    if (v8 == v17)
    {
      v3 = HIDWORD(result);
      goto LABEL_20;
    }
  }
LABEL_38:
  __break(1u);
  return result;
}

unint64_t Backend::Google::DatabaseUpdateWriter::writeHashSizeBucket(uint64_t a1, char a2, unsigned __int8 a3, unsigned __int8 *a4, unsigned __int8 a5, unsigned __int8 *a6, unsigned __int8 a7, uint64_t a8, unsigned __int8 a9, uint64_t a10)
{
  uint64_t v17;
  uint64_t **v18;
  uint64_t *v19;
  uint64_t *v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 v34[8];
  uint64_t *v35;
  unsigned int v36;

  LOBYTE(v36) = a2;
  v17 = 4;
  v34[0] = 4;
  v35 = 0;
  v18 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::find<unsigned char>((_QWORD *)(a1 + 96), (unsigned __int8 *)&v36);
  if (v18)
  {
    v17 = v36;
    v34[0] = v36;
    v19 = v18[3];
    v20 = v18[4];
    v35 = v19;
  }
  else
  {
    v19 = 0;
    v20 = 0;
  }
  v21 = (a10 - a8) / a9 + (a6 - a4) / a5;
  v22 = ((char *)v20 - (char *)v19) / v17;
  v23 = v21 - v22;
  if (v21 == (_DWORD)v22)
  {
    std::system_category();
    LODWORD(v24) = 0;
    LODWORD(v25) = 0;
  }
  else
  {
    v33 = (uint64_t)v20;
    v24 = Platform::OutputStream::writeUInt32(*(Platform::OutputStream **)(a1 + 136), v36);
    if (!(_DWORD)v24)
    {
      v24 = Platform::OutputStream::writeUInt32(*(Platform::OutputStream **)(a1 + 136), v23);
      v25 = HIDWORD(v24);
      if ((_DWORD)v24)
        return v24 | ((unint64_t)v25 << 32);
      while (a4 != a6 && a8 != a10)
      {
        if (a7)
        {
          v27 = 0;
          while (a3 != v27)
          {
            v28 = a4[v27];
            v29 = *(unsigned __int8 *)(a8 + v27);
            if (v28 < v29)
              break;
            if (v29 < v28 || a7 - 1 == v27++)
              goto LABEL_21;
          }
          v24 = Backend::Google::DatabaseUpdateWriter::writeDatabaseHash(a1, a3, a4, v34, v17, v33);
          v25 = HIDWORD(v24);
          if ((_DWORD)v24)
            return v24 | ((unint64_t)v25 << 32);
          a4 += a3;
        }
        else
        {
LABEL_21:
          v24 = Backend::Google::DatabaseUpdateWriter::writeUpdateHash(a1, a7, a8);
          v25 = HIDWORD(v24);
          if ((_DWORD)v24)
            return v24 | ((unint64_t)v25 << 32);
          a8 += a7;
        }
      }
      if (a4 == a6)
      {
LABEL_32:
        if (a8 == a10)
        {
LABEL_37:
          std::system_category();
          LODWORD(v24) = 0;
          return v24 | ((unint64_t)v25 << 32);
        }
        v32 = 0;
        while (1)
        {
          v24 = Backend::Google::DatabaseUpdateWriter::writeUpdateHash(a1, a7, a8 + v32);
          if ((_DWORD)v24)
            break;
          v32 += a7;
          if (a8 + v32 == a10)
          {
            v25 = HIDWORD(v24);
            goto LABEL_37;
          }
        }
      }
      else
      {
        v31 = 0;
        while (1)
        {
          v24 = Backend::Google::DatabaseUpdateWriter::writeDatabaseHash(a1, a3, &a4[v31], v34, v17, v33);
          if ((_DWORD)v24)
            break;
          v31 += a3;
          if (&a4[v31] == a6)
          {
            v25 = HIDWORD(v24);
            goto LABEL_32;
          }
        }
      }
    }
    v25 = HIDWORD(v24);
  }
  return v24 | ((unint64_t)v25 << 32);
}

unint64_t Backend::Google::DatabaseUpdateWriter::writeDatabaseHash(uint64_t a1, unsigned __int8 a2, void *__s1, unsigned __int8 *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;

  v9 = *((_QWORD *)a4 + 1);
  if (v9 != a6)
  {
    v11 = *a4;
    if ((_DWORD)v11 == a2 && !memcmp(__s1, *((const void **)a4 + 1), a2))
    {
      LODWORD(v13) = 0;
      *((_QWORD *)a4 + 1) = v9 + v11;
LABEL_7:
      std::system_category();
      LODWORD(v12) = 0;
      return v12 | ((unint64_t)v13 << 32);
    }
  }
  v12 = (*(uint64_t (**)(_QWORD, void *, _QWORD))(**(_QWORD **)(a1 + 136) + 24))(*(_QWORD *)(a1 + 136), __s1, a2);
  v13 = HIDWORD(v12);
  if (!(_DWORD)v12)
    goto LABEL_7;
  return v12 | ((unint64_t)v13 << 32);
}

uint64_t Backend::Google::DatabaseUpdateWriter::writeUpdateHash(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  uint64_t v3;

  v3 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 136) + 24))(*(_QWORD *)(a1 + 136), a3, a2);
  if (!(_DWORD)v3)
    std::system_category();
  return v3;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::__deallocate_node(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char &&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, _BYTE **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD *v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = ((_DWORD)v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((unsigned __int8 *)v11 + 16) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v13 = (_QWORD *)(a1 + 16);
  v11 = operator new(0x30uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_BYTE *)v11 + 16) = **a4;
  v11[4] = 0;
  v11[5] = 0;
  v11[3] = 0;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    v16 = 1;
    if (v8 >= 3)
      v16 = (v8 & (v8 - 1)) != 0;
    v17 = v16 | (2 * v8);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::__rehash<true>(a1, v19);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = ((_DWORD)v8 - 1) & v7;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *v11 = *v21;
LABEL_38:
    *v21 = v11;
    goto LABEL_39;
  }
  *v11 = *v13;
  *v13 = v11;
  *(_QWORD *)(v20 + 8 * v4) = v13;
  if (*v11)
  {
    v22 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8)
        v22 %= v8;
    }
    else
    {
      v22 &= v8 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_1DBCCA2D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,void *>>>::operator()[abi:sn180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:sn180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,void *>>>::operator()[abi:sn180100](uint64_t a1, _QWORD *__p)
{
  void *v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t **std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::find<unsigned char>(_QWORD *a1, unsigned __int8 *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t ***v6;
  uint64_t **result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*(_QWORD *)&v2 <= v3)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (v2.i32[0] - 1) & v3;
  }
  v6 = *(uint64_t ****)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  for (result = *v6; result; result = (uint64_t **)*result)
  {
    v8 = (unint64_t)result[1];
    if (v8 == v3)
    {
      if (*((unsigned __int8 *)result + 16) == (_DWORD)v3)
        return result;
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(_QWORD *)&v2)
          v8 %= *(_QWORD *)&v2;
      }
      else
      {
        v8 &= *(_QWORD *)&v2 - 1;
      }
      if (v8 != v5)
        return 0;
    }
  }
  return result;
}

_QWORD *Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::FetchThreatListUpdatesRequestJSONSerializer(_QWORD *this, const Backend::Google::ClientInfo *a2)
{
  *this = a2;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

void Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::~FetchThreatListUpdatesRequestJSONSerializer(Backend::Google::FetchThreatListUpdatesRequestJSONSerializer *this)
{
  void **v1;

  v1 = (void **)((char *)this + 8);
  std::vector<Backend::Google::ListUpdateRequest>::__destroy_vector::operator()[abi:sn180100](&v1);
}

uint64_t Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::addRequest(uint64_t a1, __int128 *a2)
{
  return std::vector<Backend::Google::ListUpdateRequest>::push_back[abi:sn180100]((uint64_t *)(a1 + 8), a2);
}

uint64_t std::vector<Backend::Google::ListUpdateRequest>::push_back[abi:sn180100](uint64_t *a1, __int128 *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - *a1) >> 4);
    if ((unint64_t)(v10 + 1) > 0x249249249249249)
      abort();
    v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v5 - *a1) >> 4);
    v12 = 2 * v11;
    if (2 * v11 <= v10 + 1)
      v12 = v10 + 1;
    if (v11 >= 0x124924924924924)
      v13 = 0x249249249249249;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::DatabaseInfo>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[112 * v10];
    v18 = &v14[112 * v13];
    std::construct_at[abi:sn180100]<Backend::Google::ListUpdateRequest,Backend::Google::ListUpdateRequest,Backend::Google::ListUpdateRequest*>((uint64_t)v16, a2);
    v17 = v16 + 112;
    std::vector<Backend::Google::ListUpdateRequest>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = std::__split_buffer<Backend::Google::ListUpdateRequest>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = std::construct_at[abi:sn180100]<Backend::Google::ListUpdateRequest,Backend::Google::ListUpdateRequest,Backend::Google::ListUpdateRequest*>(*(_QWORD *)(v4 - 8), a2);
    v9 = v7 + 112;
    a1[1] = v7 + 112;
  }
  a1[1] = v9;
  return result;
}

void sub_1DBCCA78C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Backend::Google::ListUpdateRequest>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

id Backend::Google::FetchThreatListUpdatesRequestJSONSerializer::serializedData(Backend::Google::FetchThreatListUpdatesRequestJSONSerializer *this)
{
  void *v2;
  uint64_t *v3;
  uint64_t *v4;
  void *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  id result;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  int *v23;
  int *v24;
  void *v25;
  void *v26;
  void *v27;
  id v28;
  void *v29;
  uint64_t i;
  void *v31;
  void *v32;
  uint64_t v33;

  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = *(uint64_t **)this;
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  if (*((char *)v3 + 23) >= 0)
    v4 = v3;
  else
    v4 = (uint64_t *)*v3;
  v31 = v2;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v29, "setObject:forKeyedSubscript:", v5, CFSTR("clientId"));

  v8 = v3[3];
  v7 = v3 + 3;
  v6 = v8;
  if (*((char *)v7 + 23) >= 0)
    v9 = (uint64_t)v7;
  else
    v9 = v6;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v29, "setObject:forKeyedSubscript:", v10, CFSTR("clientVersion"));

  objc_msgSend(v2, "setObject:forKeyedSubscript:", v29, CFSTR("client"));
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = *((_QWORD *)this + 1);
  for (i = *((_QWORD *)this + 2); v11 != i; v11 += 112)
  {
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    EnumTraits::toNSStringFromEnum<Backend::Google::ThreatType>(*(_DWORD *)v11);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "setObject:forKeyedSubscript:", v13, CFSTR("threatType"));

    EnumTraits::toNSStringFromEnum<Backend::Google::PlatformType>(*(_DWORD *)(v11 + 4));
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "setObject:forKeyedSubscript:", v14, CFSTR("platformType"));

    EnumTraits::toNSStringFromEnum<Backend::Google::ThreatEntryType>(*(_DWORD *)(v11 + 8));
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "setObject:forKeyedSubscript:", v15, CFSTR("threatEntryType"));

    if (*(_BYTE *)(v11 + 32))
    {
      result = objc_alloc(MEMORY[0x1E0C99D50]);
      if (!*(_BYTE *)(v11 + 32))
      {
        __break(1u);
        return result;
      }
      v17 = (void *)objc_msgSend(result, "initWithBytes:length:", *(_QWORD *)(v11 + 16), *(_QWORD *)(v11 + 24));
      objc_msgSend(v17, "base64EncodedStringWithOptions:", 0);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v12, "setObject:forKeyedSubscript:", v18, CFSTR("state"));

    }
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    if ((*(_QWORD *)(v11 + 40) & 0xFF00000000) != 0)
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:");
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v19, "setObject:forKeyedSubscript:", v20, CFSTR("maxUpdateEntries"));

    }
    if ((*(_QWORD *)(v11 + 48) & 0xFF00000000) != 0)
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:");
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v19, "setObject:forKeyedSubscript:", v21, CFSTR("maxDatabaseEntries"));

    }
    objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = *(int **)(v11 + 88);
    v24 = *(int **)(v11 + 96);
    while (v23 != v24)
    {
      EnumTraits::toNSStringFromEnum<Backend::Google::CompressionType>(*v23);
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v22, "addObject:", v25);

      ++v23;
    }
    objc_msgSend(v19, "setObject:forKeyedSubscript:", v22, CFSTR("supportedCompressions"));

    v2 = v31;
    objc_msgSend(v12, "setObject:forKeyedSubscript:", v19, CFSTR("constraints"));

    objc_msgSend(v32, "addObject:", v12);
  }
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v32, CFSTR("listUpdateRequests"));
  v33 = 0;
  objc_msgSend(MEMORY[0x1E0CB36D8], "dataWithJSONObject:options:error:", v2, 0, &v33);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = v26;
  if (v26)
    v28 = v26;

  return v27;
}

void sub_1DBCCAB80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  void *v19;

  _Unwind_Resume(a1);
}

void std::vector<Backend::Google::ListUpdateRequest>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 112;
        std::__destroy_at[abi:sn180100]<Backend::Google::ListUpdateRequest,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:sn180100]<Backend::Google::ListUpdateRequest,0>(uint64_t a1)
{
  void *v2;

  if (a1)
  {
    v2 = *(void **)(a1 + 88);
    if (v2)
    {
      *(_QWORD *)(a1 + 96) = v2;
      operator delete(v2);
    }
    if (*(_BYTE *)(a1 + 80))
    {
      if (*(char *)(a1 + 79) < 0)
        operator delete(*(void **)(a1 + 56));
    }
  }
  else
  {
    __break(1u);
  }
}

uint64_t std::construct_at[abi:sn180100]<Backend::Google::ListUpdateRequest,Backend::Google::ListUpdateRequest,Backend::Google::ListUpdateRequest*>(uint64_t result, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;

  if (result)
  {
    v2 = *a2;
    v3 = a2[1];
    *(_BYTE *)(result + 32) = *((_BYTE *)a2 + 32);
    *(_OWORD *)result = v2;
    *(_OWORD *)(result + 16) = v3;
    v4 = *((_QWORD *)a2 + 5);
    v5 = *(_QWORD *)((char *)a2 + 45);
    *(_BYTE *)(result + 56) = 0;
    *(_QWORD *)(result + 45) = v5;
    *(_QWORD *)(result + 40) = v4;
    *(_BYTE *)(result + 80) = 0;
    if (*((_BYTE *)a2 + 80))
    {
      v6 = *(__int128 *)((char *)a2 + 56);
      *(_QWORD *)(result + 72) = *((_QWORD *)a2 + 9);
      *(_OWORD *)(result + 56) = v6;
      *((_QWORD *)a2 + 8) = 0;
      *((_QWORD *)a2 + 9) = 0;
      *((_QWORD *)a2 + 7) = 0;
      *(_BYTE *)(result + 80) = 1;
    }
    *(_QWORD *)(result + 88) = 0;
    *(_QWORD *)(result + 96) = 0;
    *(_QWORD *)(result + 104) = 0;
    *(_OWORD *)(result + 88) = *(__int128 *)((char *)a2 + 88);
    *(_QWORD *)(result + 104) = *((_QWORD *)a2 + 13);
    *((_QWORD *)a2 + 11) = 0;
    *((_QWORD *)a2 + 12) = 0;
    *((_QWORD *)a2 + 13) = 0;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t *std::vector<Backend::Google::ListUpdateRequest>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  __int128 *v4;
  __int128 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = result;
  v5 = (__int128 *)*result;
  v4 = (__int128 *)result[1];
  v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 112;
    v4 -= 7;
    result = (uint64_t *)std::construct_at[abi:sn180100]<Backend::Google::ListUpdateRequest,Backend::Google::ListUpdateRequest,Backend::Google::ListUpdateRequest*>(v6, v4);
  }
  a2[1] = v6;
  v7 = *v3;
  *v3 = v6;
  a2[1] = v7;
  v8 = v3[1];
  v3[1] = a2[2];
  a2[2] = v8;
  v9 = v3[2];
  v3[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<Backend::Google::ListUpdateRequest>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 112;
    std::__destroy_at[abi:sn180100]<Backend::Google::ListUpdateRequest,0>(i - 112);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void Backend::Google::FetchThreatListUpdatesRequestSerializer::serializedData(Backend::Google::FetchThreatListUpdatesRequestSerializer *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  __n128 v5;
  uint64_t (***v6)();
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __n128 v11;
  uint64_t (***v12)();
  uint64_t v13;
  char *v14[3];
  uint64_t (**v15)();
  uint64_t v16;
  uint64_t (***v17)();
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  Backend::Google::ProtocolMessageWriter::ProtocolMessageWriter(v14);
  v4 = *(_QWORD *)this;
  v15 = off_1EA3EB778;
  v16 = v4;
  v17 = &v15;
  v5.n128_f64[0] = Backend::Google::ProtocolMessageWriter::writeEmbeddedMessageField(v14, 1, (uint64_t)&v15);
  v6 = v17;
  if (v17 == &v15)
  {
    v7 = 4;
    v6 = &v15;
  }
  else
  {
    if (!v17)
      goto LABEL_6;
    v7 = 5;
  }
  ((void (*)(__n128))(*v6)[v7])(v5);
LABEL_6:
  v9 = *((_QWORD *)this + 1);
  v8 = *((_QWORD *)this + 2);
  if (v9 != v8)
  {
    v10 = v9;
    while (1)
    {
      v15 = off_1EA3EA140;
      v16 = v9;
      v17 = &v15;
      v11.n128_f64[0] = Backend::Google::ProtocolMessageWriter::writeEmbeddedMessageField(v14, 3, (uint64_t)&v15);
      v12 = v17;
      if (v17 == &v15)
        break;
      if (v17)
      {
        v13 = 5;
LABEL_12:
        ((void (*)(__n128))(*v12)[v13])(v11);
      }
      v10 += 112;
      v9 += 112;
      if (v10 == v8)
        goto LABEL_14;
    }
    v12 = &v15;
    v13 = 4;
    goto LABEL_12;
  }
LABEL_14:
  Backend::Google::ProtocolMessageWriter::finish((Backend::Google::ProtocolMessageWriter *)v14, a2);
  Backend::Google::LexicographicallyOrderedHashEnumerator::~LexicographicallyOrderedHashEnumerator((Backend::Google::LexicographicallyOrderedHashEnumerator *)v14);
}

void sub_1DBCCAFD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  Backend::Google::LexicographicallyOrderedHashEnumerator::~LexicographicallyOrderedHashEnumerator((Backend::Google::LexicographicallyOrderedHashEnumerator *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<Backend::Google::writeClientInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ClientInfo const&)::$_0,std::allocator<Backend::Google::writeClientInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ClientInfo const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EB778;
  result[1] = v3;
  return result;
}

{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EB7C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Backend::Google::writeClientInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ClientInfo const&)::$_0,std::allocator<Backend::Google::writeClientInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ClientInfo const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EB778;
  a2[1] = v2;
  return result;
}

{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EB7C0;
  a2[1] = v2;
  return result;
}

char *std::__function::__func<Backend::Google::writeClientInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ClientInfo const&)::$_0,std::allocator<Backend::Google::writeClientInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ClientInfo const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::operator()(uint64_t a1, char **a2)
{
  Backend::Google::ProtocolMessageWriter::writeStringField(a2, 1, *(_QWORD *)(a1 + 8));
  return Backend::Google::ProtocolMessageWriter::writeStringField(a2, 2, *(_QWORD *)(a1 + 8) + 24);
}

{
  Backend::Google::ProtocolMessageWriter::writeStringField(a2, 1, *(_QWORD *)(a1 + 8));
  return Backend::Google::ProtocolMessageWriter::writeStringField(a2, 2, *(_QWORD *)(a1 + 8) + 24);
}

_QWORD *std::__function::__func<Backend::Google::writeListUpdateRequest(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest const&)::$_0,std::allocator<Backend::Google::writeListUpdateRequest(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EA140;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Backend::Google::writeListUpdateRequest(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest const&)::$_0,std::allocator<Backend::Google::writeListUpdateRequest(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EA140;
  a2[1] = v2;
  return result;
}

void std::__function::__func<Backend::Google::writeListUpdateRequest(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest const&)::$_0,std::allocator<Backend::Google::writeListUpdateRequest(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::operator()(uint64_t a1, Backend::Google::ProtocolMessageWriter *this)
{
  uint64_t v4;
  __n128 v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  Backend::Google::ProtocolMessageWriter::writeUInt32Field(this, 1, **(_DWORD **)(a1 + 8));
  Backend::Google::ProtocolMessageWriter::writeUInt32Field(this, 2, *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4));
  v4 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v4 + 32))
  {
    Backend::Google::ProtocolMessageWriter::writeBytes((char **)this, 3, *(char **)(v4 + 16), (char *)(*(_QWORD *)(v4 + 16) + *(_QWORD *)(v4 + 24)));
    v4 = *(_QWORD *)(a1 + 8);
  }
  v8[0] = off_1EA3EA0B0;
  v8[1] = v4 + 40;
  v9 = v8;
  v5.n128_f64[0] = Backend::Google::ProtocolMessageWriter::writeEmbeddedMessageField((char **)this, 4, (uint64_t)v8);
  v6 = v9;
  if (v9 == v8)
  {
    v7 = 4;
    v6 = v8;
    goto LABEL_7;
  }
  if (v9)
  {
    v7 = 5;
LABEL_7:
    (*(void (**)(__n128))(*v6 + 8 * v7))(v5);
  }
  Backend::Google::ProtocolMessageWriter::writeUInt32Field(this, 5, *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8));
}

void sub_1DBCCB234(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__func<Backend::Google::writeConstraints(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest::Constraints const&)::$_0,std::allocator<Backend::Google::writeConstraints(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest::Constraints const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EA0B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Backend::Google::writeConstraints(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest::Constraints const&)::$_0,std::allocator<Backend::Google::writeConstraints(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest::Constraints const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EA0B0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<Backend::Google::writeConstraints(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest::Constraints const&)::$_0,std::allocator<Backend::Google::writeConstraints(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::ListUpdateRequest::Constraints const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::operator()(uint64_t a1, Backend::Google::ProtocolMessageWriter *this)
{
  _QWORD *v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;

  v4 = *(_QWORD **)(a1 + 8);
  if ((*v4 & 0xFF00000000) != 0)
  {
    Backend::Google::ProtocolMessageWriter::writeUInt32Field(this, 1, *v4);
    v4 = *(_QWORD **)(a1 + 8);
  }
  v5 = v4[1];
  if ((v5 & 0xFF00000000) != 0)
  {
    Backend::Google::ProtocolMessageWriter::writeUInt32Field(this, 2, v5);
    v4 = *(_QWORD **)(a1 + 8);
  }
  v6 = (unsigned int *)v4[6];
  v7 = (unsigned int *)v4[7];
  while (v6 != v7)
  {
    v8 = *v6++;
    Backend::Google::ProtocolMessageWriter::writeUInt32Field(this, 4, v8);
  }
}

uint64_t SafeBrowsing::DatabaseCoordinator::DatabaseCoordinator(uint64_t this)
{
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)this = off_1EA3EAD98;
  *(_BYTE *)(this + 24) = 0;
  *(_QWORD *)(this + 40) = 0;
  *(_QWORD *)(this + 48) = 0;
  *(_QWORD *)(this + 32) = 0;
  return this;
}

void SafeBrowsing::DatabaseCoordinator::databaseInfo(void *a1@<X1>, _BYTE *a2@<X8>)
{
  id v3;
  void *v4;
  void *v5;
  __int128 v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  __int128 v13;
  _BYTE v14[16];
  __int128 v15;
  uint64_t v16;
  _BYTE v17[20];

  v3 = a1;
  xpc_dictionary_get_value(v3, "threatListDescriptor");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  Backend::Google::ThreatListDescriptor::fromXPC(v4, v17);

  if (v17[16])
  {
    Backend::Google::DatabaseInfo::DatabaseInfo((Backend::Google::DatabaseInfo *)v14, (const Backend::Google::ThreatListDescriptor *)v17);
    xpc_dictionary_get_value(v3, "shmem");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    Platform::mapSharedMemory(v5, &v13);
    v6 = v13;
    v13 = 0uLL;
    v7 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
    v15 = v6;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
    if (*((_QWORD *)&v13 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    if ((_QWORD)v15)
      Backend::Google::Database::initialize((Backend::Google::Database *)&v16, *(_QWORD *)v15, *(_QWORD *)(v15 + 8));
    std::__optional_destruct_base<Backend::Google::DatabaseInfo,false>::__optional_destruct_base[abi:sn180100]<Backend::Google::DatabaseInfo>((uint64_t)a2, (uint64_t)v14);
    Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)v14);
  }
  else
  {
    *a2 = 0;
    a2[112] = 0;
  }

}

void sub_1DBCCB54C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  void *v5;
  va_list va;

  va_start(va, a4);

  Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)va);
  _Unwind_Resume(a1);
}

void SafeBrowsing::DatabaseCoordinator::lookupHashes(char **a1@<X1>, uint64_t *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  char *v9;
  char *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unsigned __int8 v13;
  const void *v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  unsigned __int8 v18[8];
  void *__s2;
  char v20;
  _BYTE v21[72];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v4 = *a2;
  v5 = a2[1];
  if (*a2 != v5)
  {
    do
    {
      v7 = *(unsigned __int8 **)(v4 + 88);
      v8 = *(unsigned __int8 **)(v4 + 96);
      while (v7 != v8)
      {
        v9 = *a1;
        v10 = a1[1];
        while (v9 != v10)
        {
          v18[0] = *v7;
          __s2 = v9;
          v11 = (unsigned __int8 *)*((_QWORD *)v7 + 1);
          v12 = (uint64_t)&v11[*((_DWORD *)v7 + 1) * v18[0]];
          v20 = 0;
          v13 = std::__lower_bound[abi:sn180100]<std::_ClassicAlgPolicy,Backend::Google::HashIterator,Backend::Google::HashIterator,Backend::Google::HashView,std::__identity,std::__less<void,void>>(v18[0], v11, v18[0], v12, v18);
          v15 = *v7;
          if ((const void *)(*((_QWORD *)v7 + 1) + (*((_DWORD *)v7 + 1) * v15)) != v14
            && v18[0] == v13
            && !memcmp(v14, __s2, v13))
          {
            if (!*(_BYTE *)(v4 + 80))
              goto LABEL_19;
            Backend::Google::FullHashRequest::FullHashRequest((uint64_t)v21, v9, v15, (_OWORD *)v4, *(const void **)(v4 + 64), *(_QWORD *)(v4 + 72));
            v16 = *(_QWORD *)(a3 + 8);
            if (v16 >= *(_QWORD *)(a3 + 16))
            {
              v17 = std::vector<Backend::Google::FullHashRequest>::__push_back_slow_path<Backend::Google::FullHashRequest>(a3, (const Backend::Google::FullHashRequest *)v21);
            }
            else
            {
              if (!v16)
LABEL_19:
                __break(1u);
              Backend::Google::FullHashRequest::FullHashRequest(*(Backend::Google::FullHashRequest **)(a3 + 8), (const Backend::Google::FullHashRequest *)v21);
              v17 = v16 + 72;
              *(_QWORD *)(a3 + 8) = v16 + 72;
            }
            *(_QWORD *)(a3 + 8) = v17;
            Backend::Google::FullHashRequest::~FullHashRequest((Backend::Google::FullHashRequest *)v21);
          }
          v9 += 32;
        }
        v7 += 16;
      }
      v4 += 112;
    }
    while (v4 != v5);
  }
}

void sub_1DBCCB720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  uint64_t v13;
  uint64_t v14;

  *(_QWORD *)(v13 + 8) = v14;
  Backend::Google::FullHashRequest::~FullHashRequest((Backend::Google::FullHashRequest *)&a13);
  a13 = (void **)v13;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&a13);
  _Unwind_Resume(a1);
}

void SafeBrowsing::DatabaseCoordinator::addDatabaseInfoToDatabases(uint64_t a1, uint64_t *a2, char **a3)
{
  uint64_t v3;
  uint64_t v4;
  int v6;
  char v7;
  size_t v8;
  std::string *v9;
  void **v10;
  char *v11;
  void **v12;
  std::string::size_type v13;
  std::string *v14;
  void *v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  void *v21[2];
  unsigned __int8 v22;
  std::string v23;
  void *v24[2];
  uint64_t v25;
  void *__p;
  __int128 v27;
  uint64_t v28;
  int v29;
  __int128 v30;
  _QWORD v31[4];

  v31[2] = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = a2[1];
  if (*a2 != v4)
  {
    do
    {
      __p = 0;
      v27 = 0uLL;
      v30 = 0uLL;
      v24[1] = 0;
      v25 = 0;
      v24[0] = 0;
      v6 = *(_DWORD *)(v3 + 12);
      switch(v6)
      {
        case 3:
          v7 = 0;
          HIBYTE(v25) = 5;
          qmemcpy(v24, "apple", 5);
          v8 = 5;
          break;
        case 2:
          v7 = 0;
          HIBYTE(v25) = 7;
          qmemcpy(v24, "tencent", 7);
          v8 = 7;
          break;
        case 1:
          v7 = 0;
          HIBYTE(v25) = 6;
          qmemcpy(v24, "google", 6);
          v8 = 6;
          break;
        default:
          v8 = 0;
          v7 = 1;
          break;
      }
      std::string::basic_string[abi:sn180100]((uint64_t)&v23, v8 + 1);
      if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v9 = &v23;
      else
        v9 = (std::string *)v23.__r_.__value_.__r.__words[0];
      if (v25 >= 0)
        v10 = v24;
      else
        v10 = (void **)v24[0];
      v11 = (char *)v9 + v8;
      if (v10 >= (void **)v9 && v11 > (char *)v10)
        goto LABEL_46;
      if ((v7 & 1) == 0)
        memmove(v9, v10, v8);
      if (v11 <= "," && v11 + 1 > ",")
LABEL_46:
        __break(1u);
      *(_WORD *)v11 = 44;
      Backend::Google::ThreatListDescriptor::toString((Backend::Google::ThreatListDescriptor *)v3, v21);
      if ((v22 & 0x80u) == 0)
        v12 = v21;
      else
        v12 = (void **)v21[0];
      if ((v22 & 0x80u) == 0)
        v13 = v22;
      else
        v13 = (std::string::size_type)v21[1];
      v14 = std::string::append(&v23, (const std::string::value_type *)v12, v13);
      v15 = (void *)v14->__r_.__value_.__r.__words[0];
      v31[0] = v14->__r_.__value_.__l.__size_;
      *(_QWORD *)((char *)v31 + 7) = *(std::string::size_type *)((char *)&v14->__r_.__value_.__r.__words[1] + 7);
      v16 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v27) < 0)
        operator delete(__p);
      __p = v15;
      *(_QWORD *)&v27 = v31[0];
      *(_QWORD *)((char *)&v27 + 7) = *(_QWORD *)((char *)v31 + 7);
      HIBYTE(v27) = v16;
      if ((char)v22 < 0)
        operator delete(v21[0]);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v23.__r_.__value_.__l.__data_);
      v17 = *(_QWORD *)(v3 + 16);
      if (v17)
        v17 = *(_QWORD *)(v17 + 8);
      v28 = v17;
      v18 = *(_QWORD *)(v3 + 88);
      v19 = *(_QWORD *)(v3 + 96);
      if (v18 == v19)
      {
        v20 = 0;
      }
      else
      {
        v20 = 0;
        do
        {
          v20 += *(_DWORD *)(v18 + 4);
          v18 += 16;
        }
        while (v18 != v19);
      }
      v29 = v20;
      v30 = *(_OWORD *)(v3 + 48);
      std::vector<SafeBrowsing::DatabaseStatus::Database>::push_back[abi:sn180100](a3, (__int128 *)&__p);
      if (SHIBYTE(v25) < 0)
        operator delete(v24[0]);
      if (SHIBYTE(v27) < 0)
        operator delete(__p);
      v3 += 112;
    }
    while (v3 != v4);
  }
}

void sub_1DBCCBA2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a26 < 0)
    operator delete(__p);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<SafeBrowsing::DatabaseStatus::Database>::push_back[abi:sn180100](char **a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  __int128 v18;
  __int128 v19;
  unint64_t v20;
  char *v21;
  char *v22;
  __int128 v23;
  __int128 v24;
  int64x2_t v25;
  char *v26;
  uint64_t v27;
  int64x2_t v28;
  char *v29;
  uint64_t v30;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (v7 < v6)
  {
    if (v7)
    {
      v8 = *a2;
      *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
      *(_OWORD *)v7 = v8;
      *((_QWORD *)a2 + 1) = 0;
      *((_QWORD *)a2 + 2) = 0;
      *(_QWORD *)a2 = 0;
      v9 = *(__int128 *)((char *)a2 + 24);
      *(_OWORD *)(v7 + 40) = *(__int128 *)((char *)a2 + 40);
      *(_OWORD *)(v7 + 24) = v9;
      v10 = (char *)(v7 + 56);
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - (_QWORD)*a1) >> 3);
  v12 = v11 + 1;
  if ((unint64_t)(v11 + 1) > 0x492492492492492)
    goto LABEL_20;
  v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v5 - (_QWORD)*a1) >> 3);
  if (2 * v13 > v12)
    v12 = 2 * v13;
  if (v13 >= 0x249249249249249)
    v14 = 0x492492492492492;
  else
    v14 = v12;
  v30 = result;
  if (!v14
    || (v15 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<SafeBrowsing::DatabaseStatus::Database>>(result, v14)) == 0)
  {
LABEL_19:
    __break(1u);
LABEL_20:
    abort();
  }
  v17 = &v15[56 * v11];
  v18 = *a2;
  *((_QWORD *)v17 + 2) = *((_QWORD *)a2 + 2);
  *(_OWORD *)v17 = v18;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  v19 = *(__int128 *)((char *)a2 + 24);
  *(_OWORD *)(v17 + 40) = *(__int128 *)((char *)a2 + 40);
  *(_OWORD *)(v17 + 24) = v19;
  v21 = *a1;
  v20 = (unint64_t)a1[1];
  if ((char *)v20 == *a1)
  {
    v25 = vdupq_n_s64(v20);
    v22 = &v15[56 * v11];
  }
  else
  {
    v22 = &v15[56 * v11];
    do
    {
      v23 = *(_OWORD *)(v20 - 56);
      *((_QWORD *)v22 - 5) = *(_QWORD *)(v20 - 40);
      *(_OWORD *)(v22 - 56) = v23;
      *(_QWORD *)(v20 - 48) = 0;
      *(_QWORD *)(v20 - 40) = 0;
      *(_QWORD *)(v20 - 56) = 0;
      v24 = *(_OWORD *)(v20 - 16);
      *((_OWORD *)v22 - 2) = *(_OWORD *)(v20 - 32);
      *((_OWORD *)v22 - 1) = v24;
      v22 -= 56;
      v20 -= 56;
    }
    while ((char *)v20 != v21);
    v25 = *(int64x2_t *)a1;
  }
  v10 = v17 + 56;
  *a1 = v22;
  a1[1] = v17 + 56;
  v28 = v25;
  v26 = a1[2];
  a1[2] = &v15[56 * v16];
  v29 = v26;
  v27 = v25.i64[0];
  result = std::__split_buffer<SafeBrowsing::DatabaseStatus::Database>::~__split_buffer((uint64_t)&v27);
LABEL_18:
  a1[1] = v10;
  return result;
}

uint64_t SafeBrowsing::DatabaseCoordinator::fromThreatListDescriptor(uint64_t a1, _DWORD *a2)
{
  int v2;

  v2 = *a2 - 1;
  if (v2 > 3)
    return 2;
  else
    return dword_1DBD17A00[v2];
}

uint64_t std::__optional_destruct_base<Backend::Google::DatabaseInfo,false>::__optional_destruct_base[abi:sn180100]<Backend::Google::DatabaseInfo>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  v3 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = *(_OWORD *)(a2 + 32);
  v7 = *(_OWORD *)(a2 + 48);
  v8 = *(_OWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
  *(_OWORD *)(a1 + 48) = v7;
  *(_OWORD *)(a1 + 64) = v8;
  *(_OWORD *)(a1 + 32) = v6;
  std::vector<Backend::Google::Database::HashSizeBucket>::vector((_QWORD *)(a1 + 88), a2 + 88);
  *(_BYTE *)(a1 + 112) = 1;
  return a1;
}

void sub_1DBCCBCD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__lower_bound[abi:sn180100]<std::_ClassicAlgPolicy,Backend::Google::HashIterator,Backend::Google::HashIterator,Backend::Google::HashView,std::__identity,std::__less<void,void>>(uint64_t result, unsigned __int8 *a2, unsigned __int8 a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned int v14;
  unsigned int v15;

  v5 = (a4 - (uint64_t)a2) / a3;
  if ((_DWORD)v5)
  {
    v6 = (unsigned __int8 *)*((_QWORD *)a5 + 1);
    v7 = *a5;
    do
    {
      v8 = v5 >> 1;
      if ((_DWORD)v7)
      {
        v9 = &a2[v8 * result];
        v10 = &v9[result];
        v11 = v7 - 1;
        v12 = result;
        v13 = v6;
        while (v12)
        {
          v14 = *v9;
          v15 = *v13;
          if (v14 < v15)
            break;
          ++v9;
          ++v13;
          --v12;
          if (v15 < v14 || v11-- == 0)
            goto LABEL_14;
        }
        v8 = v5 + ~v8;
        a2 = v10;
      }
LABEL_14:
      LODWORD(v5) = v8;
    }
    while (v8);
  }
  return result;
}

uint64_t std::vector<Backend::Google::FullHashRequest>::__push_back_slow_path<Backend::Google::FullHashRequest>(uint64_t a1, const Backend::Google::FullHashRequest *a2)
{
  const Backend::Google::FullHashRequest *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v2 = *(const Backend::Google::FullHashRequest **)a1;
  v3 = 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  v4 = v3 + 1;
  if (v3 + 1 > 0x38E38E38E38E38ELL)
LABEL_13:
    abort();
  v8 = *(_QWORD *)(a1 + 16);
  v7 = a1 + 16;
  v9 = 0x8E38E38E38E38E39 * ((v8 - (uint64_t)v2) >> 3);
  if (2 * v9 > v4)
    v4 = 2 * v9;
  if (v9 >= 0x1C71C71C71C71C7)
    v10 = 0x38E38E38E38E38ELL;
  else
    v10 = v4;
  v18 = v7;
  if (v10)
    v11 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FullHashRequest>>(v7, v10);
  else
    v11 = 0;
  v14 = v11;
  v15 = &v11[72 * v3];
  v16 = v15;
  v17 = &v11[72 * v10];
  if (!v11)
  {
    __break(1u);
    goto LABEL_13;
  }
  Backend::Google::FullHashRequest::FullHashRequest((Backend::Google::FullHashRequest *)&v11[72 * v3], a2);
  v16 += 72;
  std::vector<Backend::Google::FullHashRequest>::__swap_out_circular_buffer((const Backend::Google::FullHashRequest **)a1, &v14);
  v12 = *(_QWORD *)(a1 + 8);
  std::__split_buffer<Backend::Google::FullHashRequest>::~__split_buffer((uint64_t)&v14);
  return v12;
}

void sub_1DBCCBE84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Backend::Google::FullHashRequest>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

const Backend::Google::FullHashRequest *std::vector<Backend::Google::FullHashRequest>::__swap_out_circular_buffer(const Backend::Google::FullHashRequest **a1, _QWORD *a2)
{
  const Backend::Google::FullHashRequest *v4;
  const Backend::Google::FullHashRequest *v5;
  const Backend::Google::FullHashRequest *result;
  const Backend::Google::FullHashRequest *v7;
  const Backend::Google::FullHashRequest *v8;
  const Backend::Google::FullHashRequest *v9;

  v5 = *a1;
  v4 = a1[1];
  result = (const Backend::Google::FullHashRequest *)a2[1];
  while (v4 != v5)
  {
    v4 = (const Backend::Google::FullHashRequest *)((char *)v4 - 72);
    result = (const Backend::Google::FullHashRequest *)Backend::Google::FullHashRequest::FullHashRequest((const Backend::Google::FullHashRequest *)((char *)result - 72), v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = (const Backend::Google::FullHashRequest *)a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = (const Backend::Google::FullHashRequest *)a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FullHashRequest>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(72 * a2);
}

uint64_t std::__split_buffer<Backend::Google::FullHashRequest>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 72;
    Backend::Google::FullHashRequest::~FullHashRequest((Backend::Google::FullHashRequest *)(i - 72));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        Backend::Google::FullHashRequest::~FullHashRequest((Backend::Google::FullHashRequest *)(v4 - 72));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<SafeBrowsing::DatabaseStatus::Database>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(56 * a2);
}

uint64_t std::__split_buffer<SafeBrowsing::DatabaseStatus::Database>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<SafeBrowsing::DatabaseStatus::Database>::__destruct_at_end[abi:sn180100](a1, *(void ***)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<SafeBrowsing::DatabaseStatus::Database>::__destruct_at_end[abi:sn180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 7;
      *(_QWORD *)(a1 + 16) = v2 - 7;
      if (*((char *)v2 - 33) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

Backend::Google::FetchThreatListUpdatesResponseJSONParser *Backend::Google::FetchThreatListUpdatesResponseJSONParser::FetchThreatListUpdatesResponseJSONParser(Backend::Google::FetchThreatListUpdatesResponseJSONParser *this, NSData *a2)
{
  *(_QWORD *)this = a2;
  return this;
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::~FetchThreatListUpdatesResponseJSONParser(id *this)
{

}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::finish(Backend::Google::FetchThreatListUpdatesResponseJSONParser *this@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v3;
  void *v4;
  id v5;
  objc_object *v6;
  NSObject *v7;
  uint64_t v8;
  id v9;
  _BYTE v10[24];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v9 = 0;
    objc_msgSend(MEMORY[0x1E0CB36D8], "JSONObjectWithData:options:error:", v3, 0, &v9);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = v9;
    if ((Backend::Google::SSBUtilities::isKindOfNSDictionary((Backend::Google::SSBUtilities *)v4, v6) & 1) != 0)
    {
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse(v4, (uint64_t)a2);
    }
    else
    {
      v7 = (id)SSBOSLogParser();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v8 = objc_opt_class();
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::finish(v8, (uint64_t)v10);
      }

      *a2 = 0;
      a2[40] = 0;
    }

  }
  else
  {
    *a2 = 0;
    a2[40] = 0;
  }
}

void sub_1DBCCC234(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3;
  void *v4;
  NSObject *v5;
  id v6;
  objc_object *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  Backend::Google::SSBUtilities *v11;
  Backend::Google::SSBUtilities *v12;
  objc_object *v13;
  Backend::Google::FetchThreatListUpdatesResponseJSONParser *v14;
  unint64_t v15;
  char v16;
  NSObject *v17;
  char v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  __int128 v32;
  void **v33;
  uint8_t buf[120];
  char v35;
  _BYTE v36[128];
  _BYTE v37[24];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  BYTE8(v32) = 0;
  v31 = 0;
  v30 = 0uLL;
  LOBYTE(v32) = 0;
  objc_msgSend(v3, "ssb_arrayForKey:", CFSTR("listUpdateResponses"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v4)
  {
    v19 = SSBOSLogParser();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse();
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 40) = 0;
    goto LABEL_38;
  }
  v5 = (id)SSBOSLogParser();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse((uint64_t)v37, objc_msgSend(v4, "count"), v5);

  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v6 = v4;
  v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v26, v36, 16);
  if (!v8)
    goto LABEL_13;
  v9 = *(_QWORD *)v27;
  while (2)
  {
    for (i = 0; i != v8; ++i)
    {
      if (*(_QWORD *)v27 != v9)
        objc_enumerationMutation(v6);
      v11 = *(Backend::Google::SSBUtilities **)(*((_QWORD *)&v26 + 1) + 8 * i);
      if ((Backend::Google::SSBUtilities::isKindOfNSDictionary(v11, v7) & 1) == 0)
      {
        v20 = (id)SSBOSLogParser();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          v21 = objc_opt_class();
          Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse(v21, (uint64_t)buf);
        }

        *(_BYTE *)a2 = 0;
        *(_BYTE *)(a2 + 40) = 0;
        goto LABEL_30;
      }
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse(v11, buf);
      if (!v35)
      {
        v22 = SSBOSLogParser();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse();
        *(_BYTE *)a2 = 0;
        *(_BYTE *)(a2 + 40) = 0;
        std::__optional_destruct_base<Backend::Google::ListUpdateResponse,false>::~__optional_destruct_base[abi:sn180100]((uint64_t)buf);
LABEL_30:

        goto LABEL_38;
      }
      std::vector<Backend::Google::ListUpdateResponse>::push_back[abi:sn180100]((uint64_t *)&v30, (uint64_t)buf);
      std::__optional_destruct_base<Backend::Google::ListUpdateResponse,false>::~__optional_destruct_base[abi:sn180100]((uint64_t)buf);
    }
    v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v26, v36, 16);
    if (v8)
      continue;
    break;
  }
LABEL_13:

  objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("minimumWaitDuration"), (_QWORD)v26);
  v12 = (Backend::Google::SSBUtilities *)objc_claimAutoreleasedReturnValue();
  v14 = v12;
  if (v12 && (Backend::Google::SSBUtilities::isKindOfNSString(v12, v13) & 1) == 0)
  {
    v23 = (id)SSBOSLogParser();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v24 = objc_opt_class();
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse(v24, (uint64_t)buf);
    }

    goto LABEL_36;
  }
  v15 = Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseDuration(v14, (NSString *)&v13->isa);
  if (!v16)
  {
    v25 = SSBOSLogParser();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse();
LABEL_36:
    v18 = 0;
    *(_BYTE *)a2 = 0;
    goto LABEL_37;
  }
  if (!BYTE8(v32))
    BYTE8(v32) = 1;
  *(_QWORD *)&v32 = v15;
  v17 = SSBOSLogParser();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1DBCBE000, v17, OS_LOG_TYPE_INFO, "Update parsed correctly", buf, 2u);
  }
  *(_OWORD *)a2 = v30;
  *(_QWORD *)(a2 + 16) = v31;
  v31 = 0;
  v30 = 0uLL;
  *(_OWORD *)(a2 + 24) = v32;
  v18 = 1;
LABEL_37:
  *(_BYTE *)(a2 + 40) = v18;

LABEL_38:
  v33 = (void **)&v30;
  std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v33);

}

void sub_1DBCCC5C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void **a23)
{
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  a23 = (void **)&a17;
  std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&a23);

  _Unwind_Resume(a1);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse(void *a1@<X0>, _BYTE *a2@<X8>)
{
  id v2;
  uint64_t v3;
  BOOL v4;
  BOOL v5;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL4 v14;
  _BOOL4 v15;
  _BOOL4 v16;
  _BOOL4 v17;
  _BOOL4 v18;
  _BOOL4 v19;
  unint64_t i;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  unint64_t v25;
  int64_t v26;
  int64_t v27;
  unint64_t v28;
  size_t v29;
  char *v30;
  char *v31;
  char *v32;
  char v33;
  NSObject *v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  NSObject *v38;
  void *v39;
  void *v40;
  char v41;
  Backend::Google::SSBUtilities *v42;
  objc_object *v43;
  NSObject *v44;
  Backend::Google::SSBUtilities *v45;
  objc_object *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t j;
  Backend::Google::SSBUtilities *v50;
  int v51;
  NSObject *v52;
  void *v53;
  Backend::Google::SSBUtilities *v54;
  objc_object *v55;
  Backend::Google::SSBUtilities *v56;
  NSObject *v57;
  Backend::Google::SSBUtilities *v58;
  objc_object *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t k;
  Backend::Google::SSBUtilities *v63;
  void *v64;
  NSObject *v65;
  NSObject *v66;
  NSObject *v67;
  NSObject *v68;
  uint64_t v69;
  NSObject *v70;
  uint64_t v71;
  NSObject *v72;
  uint64_t v73;
  NSObject *v74;
  uint64_t v75;
  NSObject *v76;
  char v77;
  void *v78;
  Backend::Google::SSBUtilities *v79;
  void *v80;
  id v81;
  uint64_t v82;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  uint8_t buf;
  char v93[15];
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  void *v98[2];
  char *v99;
  void *__p[2];
  uint64_t v101;
  __int128 v102;
  uint64_t v103;
  _BYTE v104[64];
  void *v105[2];
  char *v106;
  char v107;
  _OWORD v108[2];
  _BYTE v109[128];
  char v110[16];
  _BYTE v111[128];
  char v112[16];
  _OWORD v113[2];
  uint64_t v114;

  v114 = *MEMORY[0x1E0C80C00];
  v2 = a1;
  v102 = 0uLL;
  v103 = 0;
  __p[0] = 0;
  __p[1] = 0;
  v101 = 0;
  objc_msgSend(v2, "ssb_stringForKey:", CFSTR("threatType"));
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "ssb_stringForKey:", CFSTR("threatEntryType"));
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "ssb_stringForKey:", CFSTR("platformType"));
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "ssb_stringForKey:", CFSTR("responseType"));
  v3 = objc_claimAutoreleasedReturnValue();
  if (v85)
    v4 = v87 == 0;
  else
    v4 = 1;
  v5 = v4 || v86 == 0;
  v84 = (void *)v3;
  if (v5 || v3 == 0)
  {
    if (!v85)
    {
      v7 = SSBOSLogParser();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
    }
    if (!v87)
    {
      v8 = SSBOSLogParser();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
    }
    if (!v86)
    {
      v9 = SSBOSLogParser();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
    }
    if (!v84)
    {
      v10 = SSBOSLogParser();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
    }
    goto LABEL_73;
  }
  v11 = EnumTraits::toEnumFromNSString<Backend::Google::ThreatType>(v85);
  v12 = EnumTraits::toEnumFromNSString<Backend::Google::ThreatEntryType>(v87);
  v13 = EnumTraits::toEnumFromNSString<Backend::Google::PlatformType>(v86);
  v82 = EnumTraits::toEnumFromNSString<Backend::Google::ResponseType>(v84);
  if ((v11 & 0xFF00000000) == 0)
  {
LABEL_151:
    __break(1u);
    return;
  }
  v14 = EnumTraits::isValidEnum<Backend::Google::ThreatType>(v11);
  v15 = (v12 & 0xFF00000000) != 0 && v14;
  if (!v15
    || ((v16 = EnumTraits::isValidEnum<Backend::Google::ThreatEntryType>(v12), (v13 & 0xFF00000000) != 0)
      ? (v17 = v16)
      : (v17 = 0),
        !v17
     || ((v18 = EnumTraits::isValidEnum<Backend::Google::PlatformType>(v13), (v82 & 0xFF00000000) != 0)
       ? (v19 = v18)
       : (v19 = 0),
         !v19 || !EnumTraits::isValidEnum<Backend::Google::CompressionType>(v82))))
  {
    if (!EnumTraits::isValidEnum<Backend::Google::ThreatType>(v11))
    {
      v34 = SSBOSLogParser();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
    }
    if ((v12 & 0xFF00000000) != 0)
    {
      if (!EnumTraits::isValidEnum<Backend::Google::ThreatEntryType>(v12))
      {
        v35 = SSBOSLogParser();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
      }
      if ((v13 & 0xFF00000000) != 0)
      {
        v36 = v82;
        if (!EnumTraits::isValidEnum<Backend::Google::PlatformType>(v13))
        {
          v37 = SSBOSLogParser();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          {
            Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
            v36 = v82;
          }
        }
        if ((v36 & 0xFF00000000) != 0)
        {
          if (!EnumTraits::isValidEnum<Backend::Google::CompressionType>(v36))
          {
            v38 = SSBOSLogParser();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
          }
LABEL_73:
          *a2 = 0;
          a2[120] = 0;
          goto LABEL_74;
        }
      }
    }
    goto LABEL_151;
  }
  objc_msgSend(v2, "ssb_stringForKey:", CFSTR("newClientState"));
  v80 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v80)
  {
    v65 = SSBOSLogParser();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
    *a2 = 0;
    a2[120] = 0;
    goto LABEL_149;
  }
  v98[0] = 0;
  v98[1] = 0;
  v99 = 0;
  v81 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", v80, 1);
  std::vector<unsigned char>::reserve((unint64_t *)v98, objc_msgSend(v81, "length"));
  for (i = 0; i < objc_msgSend(v81, "length"); ++i)
  {
    v21 = objc_msgSend(objc_retainAutorelease(v81), "bytes");
    v22 = v21;
    v23 = (char *)v98[1];
    if (v98[1] >= v99)
    {
      v25 = (unint64_t)v98[0];
      v26 = (char *)v98[1] - (char *)v98[0];
      v27 = (char *)v98[1] - (char *)v98[0] + 1;
      if (v27 < 0)
        abort();
      v28 = v99 - (char *)v98[0];
      if (2 * (v99 - (char *)v98[0]) > (unint64_t)v27)
        v27 = 2 * v28;
      if (v28 >= 0x3FFFFFFFFFFFFFFFLL)
        v29 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v29 = v27;
      if (!v29)
        goto LABEL_151;
      v30 = (char *)operator new(v29);
      v31 = &v30[v26];
      v30[v26] = *(_BYTE *)(v22 + i);
      v24 = &v30[v26 + 1];
      if (v23 != (char *)v25)
      {
        v32 = &v23[~v25];
        do
        {
          v33 = *--v23;
          (v32--)[(_QWORD)v30] = v33;
        }
        while (v23 != (char *)v25);
        v23 = (char *)v25;
        v31 = v30;
      }
      v98[0] = v31;
      v98[1] = &v30[v26 + 1];
      v99 = &v30[v29];
      if (v23)
        operator delete(v23);
    }
    else
    {
      if (!v98[1])
        goto LABEL_151;
      *(_BYTE *)v98[1] = *(_BYTE *)(v21 + i);
      v24 = v23 + 1;
    }
    v98[1] = v24;
  }
  objc_msgSend(v2, "ssb_dictionaryForKey:", CFSTR("checksum"));
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = v39;
  if (!v39)
  {
    v66 = SSBOSLogParser();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
    goto LABEL_127;
  }
  Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseChecksum(v39, (uint64_t)v104);
  if (!v104[32])
  {
    v67 = SSBOSLogParser();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
LABEL_127:
    *a2 = 0;
    a2[120] = 0;
    goto LABEL_146;
  }
  v41 = v104[0];
  v113[0] = *(_OWORD *)&v104[1];
  *(_OWORD *)((char *)v113 + 15) = *(_OWORD *)&v104[16];
  v78 = v40;
  objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("additions"));
  v42 = (Backend::Google::SSBUtilities *)objc_claimAutoreleasedReturnValue();
  v79 = v42;
  if (v42 && (Backend::Google::SSBUtilities::isKindOfNSArray(v42, v43) & 1) == 0)
  {
    v68 = (id)SSBOSLogParser();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
    {
      v69 = objc_opt_class();
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse(v69, (uint64_t)v104);
    }

    *a2 = 0;
    a2[120] = 0;
    goto LABEL_145;
  }
  v77 = v41;
  v44 = (id)SSBOSLogParser();
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
    Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse((uint64_t)v112, -[Backend::Google::SSBUtilities count](v79, "count"), v44);

  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  v45 = v79;
  v47 = -[Backend::Google::SSBUtilities countByEnumeratingWithState:objects:count:](v45, "countByEnumeratingWithState:objects:count:", &v94, v111, 16);
  if (v47)
  {
    v48 = *(_QWORD *)v95;
    do
    {
      for (j = 0; j != v47; ++j)
      {
        if (*(_QWORD *)v95 != v48)
          objc_enumerationMutation(v45);
        v50 = *(Backend::Google::SSBUtilities **)(*((_QWORD *)&v94 + 1) + 8 * j);
        if ((Backend::Google::SSBUtilities::isKindOfNSDictionary(v50, v46) & 1) == 0)
        {
          v70 = (id)SSBOSLogParser();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
          {
            v71 = objc_opt_class();
            Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse(v71, (uint64_t)v104);
          }

          *a2 = 0;
          a2[120] = 0;
LABEL_134:

          goto LABEL_145;
        }
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseAddition(v50, (uint64_t)v104);
        v51 = v104[16];
        if (v104[16])
        {
          std::vector<Backend::Google::ListUpdateResponse::Addition>::push_back[abi:sn180100]((char **)&v102, v104);
        }
        else
        {
          v52 = SSBOSLogParser();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
            Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse(&buf, v93, v52);
          *a2 = 0;
          a2[120] = 0;
        }
        if (v104[16])
        {
          v53 = *(void **)&v104[8];
          *(_QWORD *)&v104[8] = 0;
          if (v53)
            operator delete[](v53);
        }
        if (!v51)
          goto LABEL_134;
      }
      v47 = -[Backend::Google::SSBUtilities countByEnumeratingWithState:objects:count:](v45, "countByEnumeratingWithState:objects:count:", &v94, v111, 16);
    }
    while (v47);
  }

  objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("removals"));
  v54 = (Backend::Google::SSBUtilities *)objc_claimAutoreleasedReturnValue();
  v56 = v54;
  if (v54 && (Backend::Google::SSBUtilities::isKindOfNSArray(v54, v55) & 1) == 0)
  {
    v72 = (id)SSBOSLogParser();
    if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
    {
      v73 = objc_opt_class();
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse(v73, (uint64_t)v104);
    }

    *a2 = 0;
    a2[120] = 0;
    goto LABEL_144;
  }
  v57 = (id)SSBOSLogParser();
  if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
    Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse((uint64_t)v110, -[Backend::Google::SSBUtilities count](v45, "count"), v57);

  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v58 = v56;
  v60 = -[Backend::Google::SSBUtilities countByEnumeratingWithState:objects:count:](v58, "countByEnumeratingWithState:objects:count:", &v88, v109, 16);
  if (!v60)
    goto LABEL_115;
  v61 = *(_QWORD *)v89;
  while (2)
  {
    for (k = 0; k != v60; ++k)
    {
      if (*(_QWORD *)v89 != v61)
        objc_enumerationMutation(v58);
      v63 = *(Backend::Google::SSBUtilities **)(*((_QWORD *)&v88 + 1) + 8 * k);
      if ((Backend::Google::SSBUtilities::isKindOfNSDictionary(v63, v59) & 1) == 0)
      {
        v74 = (id)SSBOSLogParser();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
        {
          v75 = objc_opt_class();
          Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse(v75, (uint64_t)v104);
        }

        goto LABEL_143;
      }
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRemoval(v63, (uint64_t)v104);
      if (!v104[24])
      {
        v76 = SSBOSLogParser();
        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
          Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse();
LABEL_143:
        *a2 = 0;
        a2[120] = 0;

        goto LABEL_144;
      }
      v64 = *(void **)v104;
      std::vector<Backend::Google::CompressionType>::__assign_with_size[abi:sn180100]<Backend::Google::CompressionType const*,Backend::Google::CompressionType const*>((char *)__p, *(char **)v104, *(uint64_t *)&v104[8], (uint64_t)(*(_QWORD *)&v104[8] - *(_QWORD *)v104) >> 2);
      if (v64)
        operator delete(v64);
    }
    v60 = -[Backend::Google::SSBUtilities countByEnumeratingWithState:objects:count:](v58, "countByEnumeratingWithState:objects:count:", &v88, v109, 16);
    if (v60)
      continue;
    break;
  }
LABEL_115:

  v106 = 0;
  *(_OWORD *)v105 = 0u;
  memset(&v104[16], 0, 48);
  *(_DWORD *)v104 = v11;
  *(_DWORD *)&v104[4] = v12;
  *(_DWORD *)&v104[8] = v13;
  *(_DWORD *)&v104[12] = v82;
  std::vector<Backend::Google::ListUpdateResponse::Addition>::__vdeallocate((uint64_t *)&v104[16]);
  *(_OWORD *)&v104[16] = v102;
  *(_QWORD *)&v104[32] = v103;
  v103 = 0;
  v102 = 0uLL;
  if (*(_QWORD *)&v104[40])
  {
    *(_QWORD *)&v104[48] = *(_QWORD *)&v104[40];
    operator delete(*(void **)&v104[40]);
  }
  *(_OWORD *)&v104[40] = *(_OWORD *)__p;
  *(_QWORD *)&v104[56] = v101;
  __p[1] = 0;
  v101 = 0;
  __p[0] = 0;
  if (v105[0])
  {
    v105[1] = v105[0];
    operator delete(v105[0]);
  }
  *(_OWORD *)v105 = *(_OWORD *)v98;
  v106 = v99;
  v98[1] = 0;
  v99 = 0;
  v98[0] = 0;
  v107 = v77;
  v108[0] = v113[0];
  *(_OWORD *)((char *)v108 + 15) = *(_OWORD *)((char *)v113 + 15);
  std::__optional_destruct_base<Backend::Google::ListUpdateResponse,false>::__optional_destruct_base[abi:sn180100]<Backend::Google::ListUpdateResponse>((uint64_t)a2, (uint64_t)v104);
  Backend::Google::ListUpdateResponse::~ListUpdateResponse((Backend::Google::ListUpdateResponse *)v104);
LABEL_144:

LABEL_145:
  v40 = v78;
LABEL_146:

  if (v98[0])
  {
    v98[1] = v98[0];
    operator delete(v98[0]);
  }

LABEL_149:
LABEL_74:

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(_QWORD *)&v113[0] = &v102;
  std::vector<Backend::Google::ListUpdateResponse::Addition>::__destroy_vector::operator()[abi:sn180100]((void ***)v113);

}

void sub_1DBCCD094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char *a51,void *a52,char a53)
{
  void *v53;
  void *v54;
  void *v55;
  void *v56;

  if (__p)
    operator delete(__p);

  if (a43)
    operator delete(a43);
  a51 = &a47;
  std::vector<Backend::Google::ListUpdateResponse::Addition>::__destroy_vector::operator()[abi:sn180100]((void ***)&a51);

  _Unwind_Resume(a1);
}

uint64_t std::vector<Backend::Google::ListUpdateResponse>::push_back[abi:sn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *updated;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v7 - *a1) >> 3);
    if (v10 + 1 > 0x222222222222222)
      abort();
    v11 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v5 - *a1) >> 3);
    v12 = 2 * v11;
    if (2 * v11 <= v10 + 1)
      v12 = v10 + 1;
    if (v11 >= 0x111111111111111)
      v13 = 0x222222222222222;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      updated = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::ListUpdateResponse>>(v4, v13);
    else
      updated = 0;
    v15 = updated;
    v16 = &updated[120 * v10];
    v18 = &updated[120 * v13];
    std::construct_at[abi:sn180100]<Backend::Google::ListUpdateResponse,Backend::Google::ListUpdateResponse,Backend::Google::ListUpdateResponse*>((uint64_t)v16, a2);
    v17 = v16 + 120;
    std::vector<Backend::Google::ListUpdateResponse>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = std::__split_buffer<Backend::Google::ListUpdateResponse>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = std::construct_at[abi:sn180100]<Backend::Google::ListUpdateResponse,Backend::Google::ListUpdateResponse,Backend::Google::ListUpdateResponse*>(*(_QWORD *)(v4 - 8), a2);
    v9 = v7 + 120;
    a1[1] = v7 + 120;
  }
  a1[1] = v9;
  return result;
}

void sub_1DBCCD394(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Backend::Google::ListUpdateResponse>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseDuration(Backend::Google::FetchThreatListUpdatesResponseJSONParser *this, NSString *a2)
{
  Backend::Google::FetchThreatListUpdatesResponseJSONParser *v2;
  Backend::Google::FetchThreatListUpdatesResponseJSONParser *v3;
  NSObject *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  NSObject *v8;

  v2 = this;
  v3 = v2;
  if (v2)
  {
    if ((unint64_t)-[Backend::Google::FetchThreatListUpdatesResponseJSONParser length](v2, "length") <= 1)
    {
      v4 = SSBOSLogParser();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseDuration();
LABEL_10:
      v5 = 0;
      v6 = 0;
      goto LABEL_11;
    }
    if ((-[Backend::Google::FetchThreatListUpdatesResponseJSONParser hasSuffix:](v3, "hasSuffix:", CFSTR("s")) & 1) == 0)
    {
      v8 = SSBOSLogParser();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseDuration();
      goto LABEL_10;
    }
    v7 = -[Backend::Google::FetchThreatListUpdatesResponseJSONParser longLongValue](v3, "longLongValue");
    v6 = v7 & 0xFFFFFFFFFFFFFF00;
    v5 = v7;
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
LABEL_11:

  return v6 | v5;
}

void sub_1DBCCD47C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseChecksum(void *a1@<X0>, uint64_t a2@<X8>)
{
  void *v3;
  void *v4;
  id v5;
  const void *v6;
  size_t v7;
  __int128 v8;
  NSObject *v9;
  NSObject *v10;
  _OWORD __dst[2];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a1, "ssb_stringForKey:", CFSTR("sha256"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3)
  {
    v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", v3, 1);
    if (objc_msgSend(v4, "length") == 32)
    {
      v5 = objc_retainAutorelease(v4);
      v6 = (const void *)objc_msgSend(v5, "bytes");
      v7 = objc_msgSend(v5, "length");
      if (v7)
        memcpy(__dst, v6, v7);
      v8 = __dst[1];
      *(_OWORD *)a2 = __dst[0];
      *(_OWORD *)(a2 + 16) = v8;
      *(_BYTE *)(a2 + 32) = 1;
    }
    else
    {
      v10 = SSBOSLogParser();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseChecksum();
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 32) = 0;
    }

  }
  else
  {
    v9 = SSBOSLogParser();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseChecksum();
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 32) = 0;
  }

}

void sub_1DBCCD5D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseAddition(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  unint64_t v9;
  void *v10;
  void *v11;
  size_t v12;
  void *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  _BYTE v20[8];
  void *v21;
  _BYTE *v22;
  char v23;
  _BYTE v24[8];
  void *__p;
  void *v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v20[0] = 0;
  v23 = 0;
  objc_msgSend(v3, "ssb_stringForKey:", CFSTR("compressionType"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = v4;
  if (!v4)
  {
    v14 = SSBOSLogParser();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseAddition();
    goto LABEL_19;
  }
  v6 = EnumTraits::toEnumFromNSString<Backend::Google::CompressionType>(v4);
  if ((v6 & 0xFF00000000) == 0)
  {
    v15 = SSBOSLogParser();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseAddition();
    goto LABEL_19;
  }
  if ((_DWORD)v6 != 1)
  {
    v16 = SSBOSLogParser();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseAddition();
LABEL_19:
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 16) = 0;
    goto LABEL_20;
  }
  objc_msgSend(v3, "ssb_dictionaryForKey:", CFSTR("rawHashes"));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = v7;
  if (!v7)
  {
    v17 = (id)SSBOSLogParser();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = objc_opt_class();
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseAddition(v18, (uint64_t)v24);
    }

    goto LABEL_29;
  }
  Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawHashes(v7, (uint64_t)v24);
  if (!v27)
  {
    v19 = SSBOSLogParser();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseAddition();
LABEL_29:
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 16) = 0;

    goto LABEL_20;
  }
  std::optional<Backend::Google::RawHashes>::operator=[abi:sn180100]<Backend::Google::RawHashes&,void>((uint64_t)v20, (uint64_t)v24);
  if (v27 && __p)
  {
    v26 = __p;
    operator delete(__p);
  }
  if (!v23)
    __break(1u);
  v9 = v20[0];
  v10 = v21;
  v11 = v22;
  v12 = v22 - (_BYTE *)v21;
  v13 = operator new[](v22 - (_BYTE *)v21);
  bzero(v13, v12);
  if (v11 != v10)
    memmove(v13, v10, v12);

  *(_QWORD *)a2 = v9 | ((v12 / v9) << 32);
  *(_QWORD *)(a2 + 8) = v13;
  *(_BYTE *)(a2 + 16) = 1;
LABEL_20:

  if (v23 && v21)
  {
    v22 = v21;
    operator delete(v21);
  }

}

void sub_1DBCCD860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, char a19)
{
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  if (a14)
  {
    if (__p)
      operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t std::vector<Backend::Google::ListUpdateResponse::Addition>::push_back[abi:sn180100](char **a1, _QWORD *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  int64x2_t v22;
  char *v23;
  uint64_t v24;
  int64x2_t v25;
  char *v26;
  uint64_t v27;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if ((unint64_t)v7 < v6)
  {
    if (v7)
    {
      *(_QWORD *)v7 = *a2;
      v8 = a2[1];
      a2[1] = 0;
      *((_QWORD *)v7 + 1) = v8;
      v9 = v7 + 16;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v10 = (v7 - *a1) >> 4;
  v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 60)
    goto LABEL_19;
  v12 = v5 - (_QWORD)*a1;
  if (v12 >> 3 > v11)
    v11 = v12 >> 3;
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0)
    v13 = 0xFFFFFFFFFFFFFFFLL;
  else
    v13 = v11;
  v27 = result;
  if (!v13
    || (v14 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::Database::HashSizeBucket>>(result, v13)) == 0)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    abort();
  }
  v16 = &v14[16 * v10];
  *(_QWORD *)v16 = *a2;
  v17 = a2[1];
  a2[1] = 0;
  *((_QWORD *)v16 + 1) = v17;
  v9 = v16 + 16;
  v19 = *a1;
  v18 = (unint64_t)a1[1];
  if ((char *)v18 == *a1)
  {
    v22 = vdupq_n_s64(v18);
  }
  else
  {
    do
    {
      v20 = *(_QWORD *)(v18 - 16);
      v18 -= 16;
      *((_QWORD *)v16 - 2) = v20;
      v16 -= 16;
      v21 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 8) = 0;
      *((_QWORD *)v16 + 1) = v21;
    }
    while ((char *)v18 != v19);
    v22 = *(int64x2_t *)a1;
  }
  *a1 = v16;
  a1[1] = v9;
  v25 = v22;
  v23 = a1[2];
  a1[2] = &v14[16 * v15];
  v26 = v23;
  v24 = v22.i64[0];
  result = std::__split_buffer<Backend::Google::ListUpdateResponse::Addition>::~__split_buffer((uint64_t)&v24);
LABEL_17:
  a1[1] = v9;
  return result;
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRemoval(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  std::vector<unsigned int> v15;
  char v16;
  __n128 __p;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  LOBYTE(v15.__begin_) = 0;
  v16 = 0;
  objc_msgSend(v3, "ssb_stringForKey:", CFSTR("compressionType"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = v4;
  if (!v4)
  {
    v9 = SSBOSLogParser();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRemoval();
    goto LABEL_17;
  }
  v6 = EnumTraits::toEnumFromNSString<Backend::Google::CompressionType>(v4);
  if ((v6 & 0xFF00000000) != 0)
  {
    if ((_DWORD)v6 == 1)
    {
      objc_msgSend(v3, "ssb_dictionaryForKey:", CFSTR("rawIndices"));
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      v8 = v7;
      if (v7)
      {
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawIndices(v7, &__p);
        if (v18)
        {
          std::optional<std::vector<unsigned int>>::operator=[abi:sn180100]<std::vector<unsigned int>,void>(&v15, &__p);
          if (v18 && __p.n128_u64[0])
          {
            __p.n128_u64[1] = __p.n128_u64[0];
            operator delete((void *)__p.n128_u64[0]);
          }
          if (!v16)
            __break(1u);
          *(std::vector<unsigned int> *)a2 = v15;
          memset(&v15, 0, sizeof(v15));
          *(_BYTE *)(a2 + 24) = 1;
          goto LABEL_28;
        }
        v14 = SSBOSLogParser();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRemoval();
      }
      else
      {
        v12 = (id)SSBOSLogParser();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          v13 = objc_opt_class();
          Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRemoval(v13, (uint64_t)&__p);
        }

      }
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 24) = 0;
LABEL_28:

      goto LABEL_18;
    }
    v11 = SSBOSLogParser();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      goto LABEL_16;
  }
  else
  {
    v10 = SSBOSLogParser();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
LABEL_16:
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseAddition();
  }
LABEL_17:
  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 24) = 0;
LABEL_18:

  if (v16 && v15.__begin_)
  {
    v15.__end_ = v15.__begin_;
    operator delete(v15.__begin_);
  }

}

void sub_1DBCCDC30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, char a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  if (a12)
  {
    if (__p)
      operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void Backend::Google::ListUpdateResponse::~ListUpdateResponse(Backend::Google::ListUpdateResponse *this)
{
  void *v2;
  void *v3;
  void **v4;

  v2 = (void *)*((_QWORD *)this + 8);
  if (v2)
  {
    *((_QWORD *)this + 9) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 5);
  if (v3)
  {
    *((_QWORD *)this + 6) = v3;
    operator delete(v3);
  }
  v4 = (void **)((char *)this + 16);
  std::vector<Backend::Google::ListUpdateResponse::Addition>::__destroy_vector::operator()[abi:sn180100](&v4);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawHashes(void *a1@<X0>, uint64_t a2@<X8>)
{
  void *v2;
  unsigned int v3;
  NSObject *v4;
  void *v5;
  void *v6;
  unint64_t i;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  unint64_t v12;
  int64_t v13;
  int64_t v14;
  unint64_t v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  char v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  char *v25;
  void *v26;
  id v28;
  void *__p[2];
  char *v30;
  uint8_t buf[4];
  unint64_t v32;
  __int16 v33;
  unsigned int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v28 = a1;
  objc_msgSend(v28, "ssb_numberForKey:", CFSTR("prefixSize"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "unsignedIntValue");

  if (v3 - 33 > 0xFFFFFFE2)
  {
    objc_msgSend(v28, "ssb_stringForKey:", CFSTR("rawHashes"));
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    if (v26)
    {
      v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", v26, 1);
      v6 = v5;
      if (v5)
      {
        __p[0] = 0;
        __p[1] = 0;
        v30 = 0;
        std::vector<unsigned char>::reserve((unint64_t *)__p, objc_msgSend(v5, "length"));
        for (i = 0; i < objc_msgSend(v6, "length"); ++i)
        {
          v8 = objc_msgSend(objc_retainAutorelease(v6), "bytes");
          v9 = v8;
          v10 = (char *)__p[1];
          if (__p[1] >= v30)
          {
            v12 = (unint64_t)__p[0];
            v13 = (char *)__p[1] - (char *)__p[0];
            v14 = (char *)__p[1] - (char *)__p[0] + 1;
            if (v14 < 0)
              abort();
            v15 = v30 - (char *)__p[0];
            if (2 * (v30 - (char *)__p[0]) > (unint64_t)v14)
              v14 = 2 * v15;
            if (v15 >= 0x3FFFFFFFFFFFFFFFLL)
              v16 = 0x7FFFFFFFFFFFFFFFLL;
            else
              v16 = v14;
            if (!v16)
LABEL_44:
              __break(1u);
            v17 = (char *)operator new(v16);
            v18 = &v17[v13];
            v17[v13] = *(_BYTE *)(v9 + i);
            v11 = &v17[v13 + 1];
            if (v10 != (char *)v12)
            {
              v19 = &v10[~v12];
              do
              {
                v20 = *--v10;
                (v19--)[(_QWORD)v17] = v20;
              }
              while (v10 != (char *)v12);
              v10 = (char *)v12;
              v18 = v17;
            }
            __p[0] = v18;
            __p[1] = &v17[v13 + 1];
            v30 = &v17[v16];
            if (v10)
              operator delete(v10);
          }
          else
          {
            if (!__p[1])
              goto LABEL_44;
            *(_BYTE *)__p[1] = *(_BYTE *)(v8 + i);
            v11 = v10 + 1;
          }
          __p[1] = v11;
        }
        if (((char *)__p[1] - (char *)__p[0]) % (unint64_t)v3)
        {
          v21 = SSBOSLogParser();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawHashes();
          *(_BYTE *)a2 = 0;
          *(_BYTE *)(a2 + 32) = 0;
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
        }
        else
        {
          v24 = SSBOSLogParser();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 134218240;
            v32 = ((char *)__p[1] - (char *)__p[0]) / (unint64_t)v3;
            v33 = 1024;
            v34 = v3;
            _os_log_debug_impl(&dword_1DBCBE000, v24, OS_LOG_TYPE_DEBUG, "Parsed %zu hashes (prefix was %i)", buf, 0x12u);
          }
          v25 = v30;
          *(_BYTE *)a2 = v3;
          *(_OWORD *)(a2 + 8) = *(_OWORD *)__p;
          *(_QWORD *)(a2 + 24) = v25;
          *(_BYTE *)(a2 + 32) = 1;
        }
      }
      else
      {
        v23 = SSBOSLogParser();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawHashes();
        *(_BYTE *)a2 = 0;
        *(_BYTE *)(a2 + 32) = 0;
      }

    }
    else
    {
      v22 = SSBOSLogParser();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawHashes();
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 32) = 0;
    }

  }
  else
  {
    v4 = SSBOSLogParser();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawHashes(v3, v4);
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 32) = 0;
  }

}

void sub_1DBCCE074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *__p, uint64_t a14)
{
  void *v14;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

uint64_t std::optional<Backend::Google::RawHashes>::operator=[abi:sn180100]<Backend::Google::RawHashes&,void>(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 32))
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
    if (a1 != a2)
      std::vector<unsigned char>::__assign_with_size[abi:sn180100]<unsigned char *,unsigned char *>((_QWORD *)(a1 + 8), *(char **)(a2 + 8), *(char **)(a2 + 16), *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8));
  }
  else
  {
    std::construct_at[abi:sn180100]<Backend::Google::RawHashes,Backend::Google::RawHashes&,Backend::Google::RawHashes*>(a1, (char *)a2);
    *(_BYTE *)(a1 + 32) = 1;
  }
  return a1;
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawIndices(void *a1@<X0>, _BYTE *a2@<X8>)
{
  Backend::Google::SSBUtilities *v3;
  objc_object *v4;
  Backend::Google::SSBUtilities *v5;
  NSObject *v6;
  Backend::Google::SSBUtilities *v7;
  objc_object *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  Backend::Google::SSBUtilities *v12;
  int v13;
  int v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  _BYTE *v29;
  id v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  char v35[16];
  _BYTE v36[128];
  __int128 v37;
  _QWORD v38[4];

  v38[2] = *MEMORY[0x1E0C80C00];
  v30 = a1;
  objc_msgSend(v30, "objectForKeyedSubscript:", CFSTR("indices"));
  v3 = (Backend::Google::SSBUtilities *)objc_claimAutoreleasedReturnValue();
  v5 = v3;
  if (v3 && (Backend::Google::SSBUtilities::isKindOfNSArray(v3, v4) & 1) == 0)
  {
    v27 = (id)SSBOSLogParser();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v28 = objc_opt_class();
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawIndices(v28, (uint64_t)&v37);
    }

    *a2 = 0;
    a2[24] = 0;
  }
  else
  {
    v29 = a2;
    v37 = 0uLL;
    v38[0] = 0;
    v6 = SSBOSLogParser();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawIndices(&v37, v6);
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v7 = v5;
    v9 = -[Backend::Google::SSBUtilities countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v31, v36, 16);
    if (v9)
    {
      v10 = *(_QWORD *)v32;
      while (2)
      {
        for (i = 0; i != v9; ++i)
        {
          if (*(_QWORD *)v32 != v10)
            objc_enumerationMutation(v7);
          v12 = *(Backend::Google::SSBUtilities **)(*((_QWORD *)&v31 + 1) + 8 * i);
          if ((Backend::Google::SSBUtilities::isKindOfNSNumber(v12, v8) & 1) == 0)
          {
            v25 = (id)SSBOSLogParser();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              v26 = objc_opt_class();
              Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawIndices(v26, (uint64_t)v35);
            }

            *v29 = 0;
            v29[24] = 0;

            if ((_QWORD)v37)
            {
              *((_QWORD *)&v37 + 1) = v37;
              operator delete((void *)v37);
            }
            goto LABEL_37;
          }
          v13 = -[Backend::Google::SSBUtilities unsignedIntValue](v12, "unsignedIntValue");
          v14 = v13;
          v15 = *((_QWORD *)&v37 + 1);
          if (*((_QWORD *)&v37 + 1) >= v38[0])
          {
            v17 = (uint64_t)(*((_QWORD *)&v37 + 1) - v37) >> 2;
            if ((unint64_t)(v17 + 1) >> 62)
              abort();
            v18 = (uint64_t)(v38[0] - v37) >> 1;
            if (v18 <= v17 + 1)
              v18 = v17 + 1;
            if (v38[0] - (_QWORD)v37 >= 0x7FFFFFFFFFFFFFFCuLL)
              v19 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v19 = v18;
            if (!v19
              || (v20 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::CompressionType>>((uint64_t)v38, v19)) == 0)
            {
LABEL_39:
              __break(1u);
            }
            v21 = &v20[4 * v17];
            *(_DWORD *)v21 = v14;
            v16 = v21 + 4;
            v23 = (char *)*((_QWORD *)&v37 + 1);
            v22 = (char *)v37;
            while (v23 != v22)
            {
              v24 = *((_DWORD *)v23 - 1);
              v23 -= 4;
              *((_DWORD *)v21 - 1) = v24;
              v21 -= 4;
            }
            *(_QWORD *)&v37 = v21;
            *((_QWORD *)&v37 + 1) = v16;
            v38[0] = &v20[4 * (_QWORD)v8];
            if (v22)
              operator delete(v22);
          }
          else
          {
            if (!*((_QWORD *)&v37 + 1))
              goto LABEL_39;
            **((_DWORD **)&v37 + 1) = v13;
            v16 = (_DWORD *)(v15 + 4);
          }
          *((_QWORD *)&v37 + 1) = v16;
        }
        v9 = -[Backend::Google::SSBUtilities countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v31, v36, 16);
        if (v9)
          continue;
        break;
      }
    }

    *(_OWORD *)v29 = v37;
    *((_QWORD *)v29 + 2) = v38[0];
    v29[24] = 1;
  }
LABEL_37:

}

void sub_1DBCCE41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

std::vector<unsigned int> *std::optional<std::vector<unsigned int>>::operator=[abi:sn180100]<std::vector<unsigned int>,void>(std::vector<unsigned int> *this, __n128 *a2)
{
  if (LOBYTE(this[1].__begin_))
  {
    std::vector<SafeBrowsing::ServiceStatus::DatabaseUpdaterStatus>::__move_assign((uint64_t)this, a2);
  }
  else
  {
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
    *this = *(std::vector<unsigned int> *)a2->n128_u8;
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    LOBYTE(this[1].__begin_) = 1;
  }
  return this;
}

uint64_t std::construct_at[abi:sn180100]<Backend::Google::ListUpdateResponse,Backend::Google::ListUpdateResponse,Backend::Google::ListUpdateResponse*>(uint64_t result, uint64_t a2)
{
  __int128 v2;

  if (result)
  {
    *(_OWORD *)result = *(_OWORD *)a2;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)(result + 32) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(result + 40) = 0;
    *(_QWORD *)(result + 48) = 0;
    *(_QWORD *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = *(_OWORD *)(a2 + 40);
    *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
    *(_QWORD *)(a2 + 40) = 0;
    *(_QWORD *)(a2 + 48) = 0;
    *(_QWORD *)(a2 + 56) = 0;
    *(_QWORD *)(result + 64) = 0;
    *(_QWORD *)(result + 72) = 0;
    *(_QWORD *)(result + 80) = 0;
    *(_OWORD *)(result + 64) = *(_OWORD *)(a2 + 64);
    *(_QWORD *)(result + 80) = *(_QWORD *)(a2 + 80);
    *(_QWORD *)(a2 + 64) = 0;
    *(_QWORD *)(a2 + 72) = 0;
    *(_QWORD *)(a2 + 80) = 0;
    v2 = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(result + 104) = *(_OWORD *)(a2 + 104);
    *(_OWORD *)(result + 88) = v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t *std::vector<Backend::Google::ListUpdateResponse>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 120;
    v4 -= 120;
    result = (uint64_t *)std::construct_at[abi:sn180100]<Backend::Google::ListUpdateResponse,Backend::Google::ListUpdateResponse,Backend::Google::ListUpdateResponse*>(v6, v4);
  }
  a2[1] = v6;
  v7 = *v3;
  *v3 = v6;
  a2[1] = v7;
  v8 = v3[1];
  v3[1] = a2[2];
  a2[2] = v8;
  v9 = v3[2];
  v3[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::ListUpdateResponse>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(120 * a2);
}

uint64_t std::__split_buffer<Backend::Google::ListUpdateResponse>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 120;
    std::__destroy_at[abi:sn180100]<Backend::Google::ListUpdateResponse,0>(i - 120);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__optional_destruct_base<Backend::Google::ListUpdateResponse,false>::~__optional_destruct_base[abi:sn180100](uint64_t a1)
{
  void *v2;
  void *v3;
  void **v5;

  if (*(_BYTE *)(a1 + 120))
  {
    v2 = *(void **)(a1 + 64);
    if (v2)
    {
      *(_QWORD *)(a1 + 72) = v2;
      operator delete(v2);
    }
    v3 = *(void **)(a1 + 40);
    if (v3)
    {
      *(_QWORD *)(a1 + 48) = v3;
      operator delete(v3);
    }
    v5 = (void **)(a1 + 16);
    std::vector<Backend::Google::ListUpdateResponse::Addition>::__destroy_vector::operator()[abi:sn180100](&v5);
  }
  return a1;
}

uint64_t std::__split_buffer<Backend::Google::ListUpdateResponse::Addition>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<Backend::Google::ListUpdateResponse::Addition>::__destruct_at_end[abi:sn180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<Backend::Google::ListUpdateResponse::Addition>::__destruct_at_end[abi:sn180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;
  void *v5;

  for (i = *(_QWORD *)(a1 + 16); i != a2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    v5 = *(void **)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v5)
      operator delete[](v5);
  }
}

void std::vector<Backend::Google::ListUpdateResponse::Addition>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<Backend::Google::ListUpdateResponse::Addition>::__clear[abi:sn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

__n128 std::__optional_destruct_base<Backend::Google::ListUpdateResponse,false>::__optional_destruct_base[abi:sn180100]<Backend::Google::ListUpdateResponse>(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  result = *(__n128 *)(a2 + 88);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  *(__n128 *)(a1 + 88) = result;
  *(_BYTE *)(a1 + 120) = 1;
  return result;
}

_QWORD *std::vector<unsigned char>::__assign_with_size[abi:sn180100]<unsigned char *,unsigned char *>(_QWORD *result, char *__src, char *a3, unint64_t a4)
{
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  size_t v11;
  _BYTE *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;

  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0)
      abort();
    v10 = 2 * v8;
    if (2 * v8 <= a4)
      v10 = a4;
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned char>::__vallocate[abi:sn180100](v7, v11);
    v9 = (char *)v7[1];
    goto LABEL_17;
  }
  v12 = (_BYTE *)result[1];
  v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    v16 = a3 - __src;
    if (v16)
      result = memmove(v9, __src, v16);
    v15 = &v9[v16];
    goto LABEL_20;
  }
  v14 = &__src[v13];
  if (v12 != v9)
  {
    result = memmove((void *)*result, __src, v13);
    v9 = (char *)v7[1];
  }
  if (a3 != v14)
    result = memmove(v9, v14, a3 - v14);
  v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

uint64_t std::construct_at[abi:sn180100]<Backend::Google::RawHashes,Backend::Google::RawHashes&,Backend::Google::RawHashes*>(uint64_t result, char *a2)
{
  uint64_t v2;
  char v3;
  _QWORD *v4;
  _BYTE *v5;
  _BYTE *v6;
  size_t v7;
  char *v8;

  if (result)
  {
    v2 = result;
    v3 = *a2;
    *(_QWORD *)(result + 8) = 0;
    v4 = (_QWORD *)(result + 8);
    *(_BYTE *)v2 = v3;
    *(_QWORD *)(v2 + 16) = 0;
    *(_QWORD *)(v2 + 24) = 0;
    v6 = (_BYTE *)*((_QWORD *)a2 + 1);
    v5 = (_BYTE *)*((_QWORD *)a2 + 2);
    v7 = v5 - v6;
    if (v5 != v6)
    {
      std::vector<unsigned char>::__vallocate[abi:sn180100](v4, v5 - v6);
      v8 = *(char **)(v2 + 16);
      memmove(v8, v6, v7);
      *(_QWORD *)(v2 + 16) = &v8[v7];
    }
    return v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void OUTLINED_FUNCTION_7(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, a5, 0xCu);
}

_QWORD *Backend::Google::FetchThreatListUpdatesResponseParser::FetchThreatListUpdatesResponseParser(_QWORD *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = a2[1];
  v13 = *a2;
  v14 = (std::__shared_weak_count *)v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v15[0] = off_1EA3EB730;
  v15[1] = a3;
  v16 = v15;
  CoroutineCaller<std::shared_ptr<ReadStream>>::CoroutineCaller(a1, &v13, (uint64_t)v15);
  v7 = v16;
  if (v16 == v15)
  {
    v8 = 4;
    v7 = v15;
    goto LABEL_8;
  }
  if (v16)
  {
    v8 = 5;
LABEL_8:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  v9 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return a1;
}

void sub_1DBCCEABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a15;
  if (a15 == v15)
  {
    v18 = 4;
    v17 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FetchThreatListUpdatesResponseParser::parseFetchThreatListUpdatesResponse@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x180uLL);
  *result = Backend::Google::FetchThreatListUpdatesResponseParser::parseFetchThreatListUpdatesResponse;
  result[1] = Backend::Google::FetchThreatListUpdatesResponseParser::parseFetchThreatListUpdatesResponse;
  result[40] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 380) = 0;
  return result;
}

uint64_t Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0x120uLL);
  *v6 = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse>;
  v6[1] = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse>;
  v6[31] = a1;
  result = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v6 + 20), a2);
  v6[2] = 0;
  *((_DWORD *)v6 + 6) = 0;
  *a3 = v6;
  *((_BYTE *)v6 + 280) = 0;
  return result;
}

void sub_1DBCCEBB8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FetchThreatListUpdatesResponseParser::parseListUpdateResponse@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x220uLL);
  *result = Backend::Google::FetchThreatListUpdatesResponseParser::parseListUpdateResponse;
  result[1] = Backend::Google::FetchThreatListUpdatesResponseParser::parseListUpdateResponse;
  result[44] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 523) = 0;
  return result;
}

uint64_t Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::chrono::duration<long long,std::ratio<1l,1l>>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0xB0uLL);
  *v6 = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::chrono::duration<long long,std::ratio<1l,1l>>>;
  v6[1] = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::chrono::duration<long long,std::ratio<1l,1l>>>;
  v6[17] = a1;
  result = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v6 + 6), a2);
  v6[2] = 0;
  *((_DWORD *)v6 + 6) = 0;
  *a3 = v6;
  *((_BYTE *)v6 + 168) = 0;
  return result;
}

void sub_1DBCCEC84(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FetchThreatListUpdatesResponseParser::parseDuration@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x90uLL);
  *result = Backend::Google::FetchThreatListUpdatesResponseParser::parseDuration;
  result[1] = Backend::Google::FetchThreatListUpdatesResponseParser::parseDuration;
  result[7] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 136) = 0;
  return result;
}

uint64_t Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse::Addition>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0xB8uLL);
  *v6 = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse::Addition>;
  v6[1] = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse::Addition>;
  v6[18] = a1;
  result = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v6 + 7), a2);
  v6[2] = 0;
  *((_DWORD *)v6 + 6) = 0;
  *a3 = v6;
  *((_BYTE *)v6 + 176) = 0;
  return result;
}

void sub_1DBCCED50(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FetchThreatListUpdatesResponseParser::parseAddition@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x120uLL);
  *result = Backend::Google::FetchThreatListUpdatesResponseParser::parseAddition;
  result[1] = Backend::Google::FetchThreatListUpdatesResponseParser::parseAddition;
  result[24] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 280) = 0;
  return result;
}

uint64_t Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<unsigned int>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0xC0uLL);
  *v6 = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<unsigned int>>;
  v6[1] = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<unsigned int>>;
  v6[19] = a1;
  result = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v6 + 8), a2);
  v6[2] = 0;
  *((_DWORD *)v6 + 6) = 0;
  *a3 = v6;
  *((_BYTE *)v6 + 184) = 0;
  return result;
}

void sub_1DBCCEE1C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FetchThreatListUpdatesResponseParser::parseRemoval@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x110uLL);
  *result = Backend::Google::FetchThreatListUpdatesResponseParser::parseRemoval;
  result[1] = Backend::Google::FetchThreatListUpdatesResponseParser::parseRemoval;
  result[25] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 264) = 0;
  return result;
}

uint64_t Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::array<unsigned char,32ul>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0xC8uLL);
  *v6 = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::array<unsigned char,32ul>>;
  v6[1] = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::array<unsigned char,32ul>>;
  v6[20] = a1;
  result = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v6 + 9), a2);
  v6[2] = 0;
  *((_DWORD *)v6 + 6) = 0;
  *a3 = v6;
  *((_BYTE *)v6 + 192) = 0;
  return result;
}

void sub_1DBCCEEE8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FetchThreatListUpdatesResponseParser::parseChecksum@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0xA0uLL);
  *result = Backend::Google::FetchThreatListUpdatesResponseParser::parseChecksum;
  result[1] = Backend::Google::FetchThreatListUpdatesResponseParser::parseChecksum;
  result[10] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 155) = 0;
  return result;
}

uint64_t Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::RawHashes>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0xC8uLL);
  *v6 = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::RawHashes>;
  v6[1] = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::RawHashes>;
  v6[20] = a1;
  result = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v6 + 9), a2);
  v6[2] = 0;
  *((_DWORD *)v6 + 6) = 0;
  *a3 = v6;
  *((_BYTE *)v6 + 192) = 0;
  return result;
}

void sub_1DBCCEFB4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FetchThreatListUpdatesResponseParser::parseRawHashes@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0xB8uLL);
  *result = Backend::Google::FetchThreatListUpdatesResponseParser::parseRawHashes;
  result[1] = Backend::Google::FetchThreatListUpdatesResponseParser::parseRawHashes;
  result[14] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 176) = 0;
  return result;
}

_QWORD *Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *result;
  uint64_t v9;
  _QWORD v10[3];
  _QWORD *v11;
  _BYTE v12[24];
  _BYTE *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v5 = (_QWORD *)a2[3];
  if (v5)
  {
    if (v5 == a2)
    {
      v11 = v10;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v10);
    }
    else
    {
      v11 = (_QWORD *)a2[3];
      a2[3] = 0;
    }
  }
  else
  {
    v11 = 0;
  }
  std::__function::__value_func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::__value_func[abi:sn180100]<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1},std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}>>((uint64_t)v12, v10);
  Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse::Addition>(a1, (uint64_t)v12, a3);
  v6 = v13;
  if (v13 == v12)
  {
    v7 = 4;
    v6 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_11;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_11:
  result = v11;
  if (v11 == v10)
  {
    v9 = 4;
    result = v10;
  }
  else
  {
    if (!v11)
      return result;
    v9 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v9))();
}

void sub_1DBCCF138(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  char *v17;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;

  v19 = a17;
  if (a17 == v17)
  {
    v20 = 4;
    v19 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_6:
  v21 = a13;
  if (a13 == &a10)
  {
    v22 = 4;
    v21 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v22 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_11:
  _Unwind_Resume(exception_object);
}

_QWORD *Backend::Google::readAdditions@<X0>(uint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;

  result = operator new(0x78uLL);
  *result = Backend::Google::readAdditions;
  result[1] = Backend::Google::readAdditions;
  *((_DWORD *)result + 28) = a2;
  v7 = *a1;
  v8 = a1[1];
  result[9] = *a1;
  result[10] = v8;
  result[7] = v7;
  result[8] = v8;
  *a1 = 0;
  a1[1] = 0;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a3 = result;
  *((_BYTE *)result + 116) = 0;
  return result;
}

_QWORD *Backend::Google::FetchThreatListUpdatesResponseParser::parseRawIndices@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x98uLL);
  *result = Backend::Google::FetchThreatListUpdatesResponseParser::parseRawIndices;
  result[1] = Backend::Google::FetchThreatListUpdatesResponseParser::parseRawIndices;
  result[13] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 148) = 0;
  return result;
}

_QWORD *Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *result;
  uint64_t v9;
  _QWORD v10[3];
  _QWORD *v11;
  _BYTE v12[24];
  _BYTE *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v5 = (_QWORD *)a2[3];
  if (v5)
  {
    if (v5 == a2)
    {
      v11 = v10;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v10);
    }
    else
    {
      v11 = (_QWORD *)a2[3];
      a2[3] = 0;
    }
  }
  else
  {
    v11 = 0;
  }
  std::__function::__value_func<Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::__value_func[abi:sn180100]<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1},std::allocator<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}>>((uint64_t)v12, v10);
  Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<unsigned int>>(a1, (uint64_t)v12, a3);
  v6 = v13;
  if (v13 == v12)
  {
    v7 = 4;
    v6 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_11;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_11:
  result = v11;
  if (v11 == v10)
  {
    v9 = 4;
    result = v10;
  }
  else
  {
    if (!v11)
      return result;
    v9 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v9))();
}

void sub_1DBCCF384(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  char *v17;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;

  v19 = a17;
  if (a17 == v17)
  {
    v20 = 4;
    v19 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_6:
  v21 = a13;
  if (a13 == &a10)
  {
    v22 = 4;
    v21 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v22 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_11:
  _Unwind_Resume(exception_object);
}

_QWORD *Backend::Google::readRemovalIndices@<X0>(uint64_t *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;

  result = operator new(0x90uLL);
  *result = Backend::Google::readRemovalIndices;
  result[1] = Backend::Google::readRemovalIndices;
  *((_DWORD *)result + 34) = a2;
  v7 = *a1;
  v8 = a1[1];
  result[13] = *a1;
  result[14] = v8;
  result[11] = v7;
  result[12] = v8;
  *a1 = 0;
  a1[1] = 0;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a3 = result;
  *((_BYTE *)result + 140) = 0;
  return result;
}

void detail::lazy_promise<ReadResult<unsigned int>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF4A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF560(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<BOOL>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF5BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<Backend::Google::ThreatType>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<Backend::Google::ThreatEntryType>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<Backend::Google::PlatformType>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF6D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<Backend::Google::ResponseType>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF72C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<std::vector<unsigned int>>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF7E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

std::vector<unsigned int> *std::__optional_copy_base<std::vector<unsigned int>,false>::__optional_copy_base[abi:sn180100](std::vector<unsigned int> *this, uint64_t a2)
{
  LOBYTE(this->__begin_) = 0;
  LOBYTE(this[1].__begin_) = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    std::vector<unsigned int>::vector(this, (const std::vector<unsigned int> *)a2);
    LOBYTE(this[1].__begin_) = 1;
  }
  return this;
}

void sub_1DBCCF838(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 24))
    std::__optional_copy_base<std::vector<unsigned int>,false>::__optional_copy_base[abi:sn180100](v1);
  _Unwind_Resume(exception_object);
}

void detail::lazy_promise<std::optional<std::vector<unsigned char>>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF89C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void std::__optional_storage_base<std::vector<unsigned char>,false>::__assign_from[abi:sn180100]<std::__optional_copy_assign_base<std::vector<unsigned char>,false> const&>(uint64_t a1, uint64_t a2)
{
  void *v3;

  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2)
    {
      if (*(_BYTE *)(a1 + 24))
        std::vector<unsigned char>::__assign_with_size[abi:sn180100]<unsigned char *,unsigned char *>((_QWORD *)a1, *(char **)a2, *(char **)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
    }
  }
  else if (*(_BYTE *)(a1 + 24))
  {
    v3 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v3;
      operator delete(v3);
    }
    *(_BYTE *)(a1 + 24) = 0;
  }
  else
  {
    std::construct_at[abi:sn180100]<std::vector<unsigned char>,std::vector<unsigned char> const&,std::vector<unsigned char>*>((_QWORD *)a1, a2);
    *(_BYTE *)(a1 + 24) = 1;
  }
}

_QWORD *std::construct_at[abi:sn180100]<std::vector<unsigned char>,std::vector<unsigned char> const&,std::vector<unsigned char>*>(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  const void *v4;
  size_t v5;
  char *v6;

  if (result)
  {
    v2 = result;
    *result = 0;
    result[1] = 0;
    result[2] = 0;
    v4 = *(const void **)a2;
    v3 = *(_QWORD *)(a2 + 8);
    v5 = v3 - *(_QWORD *)a2;
    if (v3 != *(_QWORD *)a2)
    {
      std::vector<unsigned char>::__vallocate[abi:sn180100](result, v3 - *(_QWORD *)a2);
      v6 = (char *)v2[1];
      memmove(v6, v4, v5);
      v2[1] = &v6[v5];
    }
    return v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void detail::lazy_promise<std::optional<std::array<unsigned char,32ul>>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCF9E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<Backend::Google::CompressionType>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCFA40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<Backend::Google::RawHashes>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCFA9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

_BYTE *std::__optional_copy_base<Backend::Google::RawHashes,false>::__optional_copy_base[abi:sn180100](_BYTE *a1, char *a2)
{
  *a1 = 0;
  a1[32] = 0;
  if (a2[32])
  {
    std::construct_at[abi:sn180100]<Backend::Google::RawHashes,Backend::Google::RawHashes&,Backend::Google::RawHashes*>((uint64_t)a1, a2);
    a1[32] = 1;
  }
  return a1;
}

void sub_1DBCCFAF0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 32))
    std::__optional_copy_base<Backend::Google::RawHashes,false>::__optional_copy_base[abi:sn180100](v1);
  _Unwind_Resume(exception_object);
}

void ByteProvider::readByteOperationForReadStream(ByteProvider *this@<X0>, uint64_t a2@<X8>)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v9, this);
  v3 = v10;
  *(_QWORD *)a2 = v9;
  *(_QWORD *)(a2 + 8) = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    v6 = v10;
    *(_BYTE *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 0;
    if (v6)
    {
      v7 = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  else
  {
    *(_BYTE *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 0;
  }
}

void detail::lazy_promise<ReadResult<unsigned char>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCFBF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__throw_bad_variant_access[abi:sn180100]()
{
  std::__libcpp_verbose_abort("bad_variant_access was thrown in -fno-exceptions mode");
  return detail::lazy_promise<ReadResult<BOOL>>::result();
}

void detail::lazy_promise<ReadResult<BOOL>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCFC60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void detail::lazy_promise<std::optional<unsigned int>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCFCBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

uint64_t Backend::Google::readAdditions(std::shared_ptr<RiceDecompressor>,unsigned int)::$_1::__invoke(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  _BOOL4 v5;
  int v6;

  v2 = bswap32(*a1);
  v3 = bswap32(*a2);
  v4 = v2 >= v3;
  v5 = v2 > v3;
  v6 = !v4;
  return (v5 - v6);
}

void std::__optional_storage_base<Backend::Google::ListUpdateResponse::Addition,false>::__assign_from[abi:sn180100]<std::__optional_move_assign_base<Backend::Google::ListUpdateResponse::Addition,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;

  if (*(unsigned __int8 *)(a1 + 16) == *(unsigned __int8 *)(a2 + 16))
  {
    if (*(_BYTE *)(a1 + 16))
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v3 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 8) = 0;
      v4 = *(void **)(a1 + 8);
      *(_QWORD *)(a1 + 8) = v3;
      if (v4)
        operator delete[](v4);
    }
  }
  else if (*(_BYTE *)(a1 + 16))
  {
    v5 = *(void **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = 0;
    if (v5)
      operator delete[](v5);
    *(_BYTE *)(a1 + 16) = 0;
  }
  else
  {
    *(_QWORD *)a1 = *(_QWORD *)a2;
    v6 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a1 + 8) = v6;
    *(_BYTE *)(a1 + 16) = 1;
  }
}

void std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:sn180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>(uint64_t a1, uint64_t a2)
{
  void *v3;

  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2)
    {
      if (*(_BYTE *)(a1 + 24))
        std::vector<Backend::Google::CompressionType>::__assign_with_size[abi:sn180100]<Backend::Google::CompressionType const*,Backend::Google::CompressionType const*>((char *)a1, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
    }
  }
  else if (*(_BYTE *)(a1 + 24))
  {
    v3 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v3;
      operator delete(v3);
    }
    *(_BYTE *)(a1 + 24) = 0;
  }
  else
  {
    std::vector<unsigned int>::vector((std::vector<unsigned int> *)a1, (const std::vector<unsigned int> *)a2);
    *(_BYTE *)(a1 + 24) = 1;
  }
}

__n128 std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:sn180100]<std::__optional_move_assign_base<std::vector<unsigned int>,false>>(std::vector<unsigned int> *this, __n128 *a2)
{
  __n128 result;
  unsigned int *begin;

  if (LOBYTE(this[1].__begin_) == a2[1].n128_u8[8])
  {
    if (LOBYTE(this[1].__begin_))
      result.n128_u64[0] = std::vector<SafeBrowsing::ServiceStatus::DatabaseUpdaterStatus>::__move_assign((uint64_t)this, a2).n128_u64[0];
  }
  else if (LOBYTE(this[1].__begin_))
  {
    begin = this->__begin_;
    if (this->__begin_)
    {
      this->__end_ = begin;
      operator delete(begin);
    }
    LOBYTE(this[1].__begin_) = 0;
  }
  else
  {
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
    result = *a2;
    *this = *(std::vector<unsigned int> *)a2->n128_u8;
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    LOBYTE(this[1].__begin_) = 1;
  }
  return result;
}

void detail::lazy_promise<std::optional<unsigned long long>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCCFED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<Backend::Google::FetchThreatListUpdatesResponseParser::FetchThreatListUpdatesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>)::$_0,std::allocator<std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>>,Task ()(std::shared_ptr<ReadStream>)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EB730;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Backend::Google::FetchThreatListUpdatesResponseParser::FetchThreatListUpdatesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>)::$_0,std::allocator<std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>>,Task ()(std::shared_ptr<ReadStream>)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EB730;
  a2[1] = v2;
  return result;
}

void std::__function::__func<Backend::Google::FetchThreatListUpdatesResponseParser::FetchThreatListUpdatesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>)::$_0,std::allocator<std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>>,Task ()(std::shared_ptr<ReadStream>)>::operator()(uint64_t a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;

  v6 = *a2;
  v5 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  v7 = operator new(0x1E8uLL);
  v8 = v7;
  *v7 = Backend::Google::FetchThreatListUpdatesResponseParser::FetchThreatListUpdatesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>)::$_0::operator()<std::shared_ptr<ReadStream>>;
  v7[1] = Backend::Google::FetchThreatListUpdatesResponseParser::FetchThreatListUpdatesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>)::$_0::operator()<std::shared_ptr<ReadStream>>;
  v9 = v7 + 55;
  v7[58] = v6;
  v7[59] = v5;
  *a3 = v7;
  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(_QWORD *)(v10 + 24);
  if (!v11)
  {
    v7[54] = 0;
    if (v5)
      goto LABEL_6;
LABEL_14:
    *((_DWORD *)v8 + 110) = 0;
    v14 = v8 + 56;
    v8[56] = v6;
    v8[57] = 0;
    goto LABEL_15;
  }
  if (v11 == v10)
  {
    v7[54] = v7 + 51;
    (*(void (**)(_QWORD))(**(_QWORD **)(v10 + 24) + 24))(*(_QWORD *)(v10 + 24));
    if (v5)
      goto LABEL_6;
    goto LABEL_14;
  }
  v7[54] = v11;
  *(_QWORD *)(v10 + 24) = 0;
  if (!v5)
    goto LABEL_14;
LABEL_6:
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  *((_DWORD *)v8 + 110) = 0;
  v14 = v8 + 56;
  v8[56] = v6;
  v8[57] = v5;
  do
    v15 = __ldxr(p_shared_owners);
  while (__stxr(v15 + 1, p_shared_owners));
  do
    v16 = __ldaxr(p_shared_owners);
  while (__stlxr(v16 - 1, p_shared_owners));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_15:
  v8[60] = v14;
  v8[3] = Backend::Google::FetchThreatListUpdatesResponseParser::parseFetchThreatListUpdatesResponse;
  v8[43] = v9;
  *((_DWORD *)v8 + 12) = 0;
  *((_BYTE *)v8 + 404) = 0;
  *((_BYTE *)v8 + 17) = 0;
  v8[4] = Backend::Google::FetchThreatListUpdatesResponseParser::parseFetchThreatListUpdatesResponse;
  v8[5] = v8;
  Backend::Google::FetchThreatListUpdatesResponseParser::parseFetchThreatListUpdatesResponse((uint64_t)(v8 + 3));
}

void sub_1DBCD0088(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;

  if (v1)
    std::__function::__func<Backend::Google::FetchThreatListUpdatesResponseParser::FetchThreatListUpdatesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>)::$_0,std::allocator<std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>>,Task ()(std::shared_ptr<ReadStream>)>::operator()(v1);
  _Unwind_Resume(exception_object);
}

void detail::lazy_promise<std::optional<Backend::Google::FetchThreatListUpdatesResponse>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCD00E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

std::string *CoroutineCaller<std::shared_ptr<ReadStream>>::CoroutineCaller(_QWORD *a1, uint64_t *a2, uint64_t a3)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::string *result;
  uint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;

  v4 = (std::__shared_weak_count *)a2[1];
  v13 = *a2;
  v14 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a3 + 24);
  if (v7)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)v7 + 48))(&v15, v7, &v13);
    v9 = v14;
    v8 = v15;
    v15 = 0;
    *a1 = v8;
    if (v9)
    {
      v10 = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    return (std::string *)a1;
  }
  else
  {
    result = std::__throw_bad_function_call[abi:sn180100]();
    __break(1u);
  }
  return result;
}

void sub_1DBCD01A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t detail::lazy_promise<std::optional<Backend::Google::FetchThreatListUpdatesResponse>>::~lazy_promise(uint64_t a1)
{
  int v2;
  void **v4;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1 && *(_BYTE *)(a1 + 56))
  {
    v4 = (void **)(a1 + 16);
    std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v4);
  }
  return a1;
}

void detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCD0264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::ListUpdateResponse>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EAF50;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::ListUpdateResponse>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EAF50;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::ListUpdateResponse>> ()(Backend::Google::ProtocolMessageReader &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

_QWORD *std::__function::__func<Lazy<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EB0B8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EB0B8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>> ()(Backend::Google::ProtocolMessageReader &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse>>::~lazy_promise(uint64_t a1)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1)
  {
    std::__optional_destruct_base<Backend::Google::ListUpdateResponse,false>::~__optional_destruct_base[abi:sn180100](a1 + 16);
  }
  return a1;
}

_QWORD *std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EAF08;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EAF08;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

_QWORD *std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::vector<unsigned int>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EB190;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::vector<unsigned int>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EB190;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::vector<unsigned int>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

_QWORD *std::__function::__func<Lazy<std::optional<std::array<unsigned char,32ul>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::array<unsigned char,32ul>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::array<unsigned char,32ul>>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EB070;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<std::array<unsigned char,32ul>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::array<unsigned char,32ul>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::array<unsigned char,32ul>>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EB070;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<std::array<unsigned char,32ul>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::array<unsigned char,32ul>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::array<unsigned char,32ul>>> ()(Backend::Google::ProtocolMessageReader &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::~lazy_promise(uint64_t a1)
{
  int v2;
  void *v3;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1)
  {
    if (*(_BYTE *)(a1 + 32))
    {
      v3 = *(void **)(a1 + 24);
      *(_QWORD *)(a1 + 24) = 0;
      if (v3)
        operator delete[](v3);
    }
  }
  return a1;
}

_QWORD *std::__function::__func<Lazy<std::optional<Backend::Google::RawHashes>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::RawHashes>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::RawHashes>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EB028;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::RawHashes>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::RawHashes>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::RawHashes>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EB028;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::RawHashes>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::RawHashes>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::RawHashes>> ()(Backend::Google::ProtocolMessageReader &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t std::__function::__value_func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::__value_func[abi:sn180100]<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1},std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}>>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  *(_QWORD *)(a1 + 24) = 0;
  v4 = operator new(0x28uLL);
  v5 = v4;
  *v4 = &off_1EA3EB658;
  v6 = (_QWORD *)a2[3];
  if (v6)
  {
    if (v6 == a2)
    {
      v4[4] = v4 + 1;
      (*(void (**)(_QWORD *))(*a2 + 24))(a2);
    }
    else
    {
      v4[4] = v6;
      a2[3] = 0;
    }
  }
  else
  {
    v4[4] = 0;
  }
  *(_QWORD *)(a1 + 24) = v5;
  return a1;
}

_QWORD *std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1},std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1EA3EB658;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1},std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::~__func(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  *(_QWORD *)__p = &off_1EA3EB658;
  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

_QWORD *std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1},std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x28uLL);
  *v2 = &off_1EA3EB658;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1DBCD06F0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1},std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA3EB658;
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(a2 + 1), a1 + 8);
}

_QWORD *std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1},std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::destroy(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1},std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

_QWORD *std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1},std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(Backend::Google::ProtocolMessageReader &)>::operator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *result;

  result = operator new(0x120uLL);
  *result = Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}::operator()<Backend::Google::ProtocolMessageReader>;
  result[1] = Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}::operator()<Backend::Google::ProtocolMessageReader>;
  result[18] = a1 + 8;
  result[19] = a2;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a3 = result;
  *((_BYTE *)result + 276) = 0;
  return result;
}

void detail::lazy_promise<std::optional<std::shared_ptr<RiceDecompressor>>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCD084C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<RiceDecompressor>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB8B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<RiceDecompressor>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB8B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<RiceDecompressor>::__on_zero_shared(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

_QWORD *std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int),std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int)>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EAEC0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int),std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int)>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EAEC0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int),std::allocator<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int)>,Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>::operator()(uint64_t a1, __int128 *a2, unsigned int *a3)
{
  std::__invoke_void_return_wrapper<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>>,false>::__call[abi:sn180100]<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*&)(std::shared_ptr<RiceDecompressor>,unsigned int),std::shared_ptr<RiceDecompressor>,unsigned int>((void (**)(__int128 *, _QWORD))(a1 + 8), a2, a3);
}

void std::__invoke_void_return_wrapper<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>>,false>::__call[abi:sn180100]<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*&)(std::shared_ptr<RiceDecompressor>,unsigned int),std::shared_ptr<RiceDecompressor>,unsigned int>(void (**a1)(__int128 *, _QWORD), __int128 *a2, unsigned int *a3)
{
  void (*v3)(__int128 *, _QWORD);
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  v3 = *a1;
  v7 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v3(&v7, *a3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
  if (*((_QWORD *)&v7 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1DBCD0970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
    std::__invoke_void_return_wrapper<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>>,false>::__call[abi:sn180100]<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*&)(std::shared_ptr<RiceDecompressor>,unsigned int),std::shared_ptr<RiceDecompressor>,unsigned int>(a10);
  _Unwind_Resume(exception_object);
}

uint64_t detail::lazy_promise<std::optional<std::vector<unsigned int>>>::~lazy_promise(uint64_t a1)
{
  int v2;
  void *v3;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1)
  {
    if (*(_BYTE *)(a1 + 40))
    {
      v3 = *(void **)(a1 + 16);
      if (v3)
      {
        *(_QWORD *)(a1 + 24) = v3;
        operator delete(v3);
      }
    }
  }
  return a1;
}

uint64_t std::__function::__value_func<Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::__value_func[abi:sn180100]<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1},std::allocator<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}>>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  *(_QWORD *)(a1 + 24) = 0;
  v4 = operator new(0x28uLL);
  v5 = v4;
  *v4 = &off_1EA3EB6A0;
  v6 = (_QWORD *)a2[3];
  if (v6)
  {
    if (v6 == a2)
    {
      v4[4] = v4 + 1;
      (*(void (**)(_QWORD *))(*a2 + 24))(a2);
    }
    else
    {
      v4[4] = v6;
      a2[3] = 0;
    }
  }
  else
  {
    v4[4] = 0;
  }
  *(_QWORD *)(a1 + 24) = v5;
  return a1;
}

_QWORD *std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1},std::allocator<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}>,Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1EA3EB6A0;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1},std::allocator<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}>,Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::~__func(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  *(_QWORD *)__p = &off_1EA3EB6A0;
  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

_QWORD *std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1},std::allocator<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}>,Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x28uLL);
  *v2 = &off_1EA3EB6A0;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1DBCD0B60(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1},std::allocator<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}>,Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1EA3EB6A0;
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(a2 + 1), a1 + 8);
}

_QWORD *std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1},std::allocator<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}>,Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::destroy(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1},std::allocator<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}>,Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

_QWORD *std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1},std::allocator<Lazy<std::optional<std::vector<unsigned int>>> Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}>,Lazy<std::optional<std::vector<unsigned int>>> ()(Backend::Google::ProtocolMessageReader &)>::operator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *result;

  result = operator new(0x130uLL);
  *result = Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}::operator()<Backend::Google::ProtocolMessageReader>;
  result[1] = Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}::operator()<Backend::Google::ProtocolMessageReader>;
  result[20] = a1 + 8;
  result[21] = a2;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a3 = result;
  *((_BYTE *)result + 292) = 0;
  return result;
}

_QWORD *std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int),std::allocator<Lazy<std::optional<std::vector<unsigned int>>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int)>,Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EB148;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int),std::allocator<Lazy<std::optional<std::vector<unsigned int>>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int)>,Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EB148;
  a2[1] = v2;
  return result;
}

void std::__function::__func<Lazy<std::optional<std::vector<unsigned int>>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int),std::allocator<Lazy<std::optional<std::vector<unsigned int>>> (*)(std::shared_ptr<RiceDecompressor>,unsigned int)>,Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>::operator()(uint64_t a1, __int128 *a2, unsigned int *a3)
{
  std::__invoke_void_return_wrapper<Lazy<std::optional<std::vector<unsigned int>>>,false>::__call[abi:sn180100]<Lazy<std::optional<std::vector<unsigned int>>> (*&)(std::shared_ptr<RiceDecompressor>,unsigned int),std::shared_ptr<RiceDecompressor>,unsigned int>((void (**)(__int128 *, _QWORD))(a1 + 8), a2, a3);
}

void std::__invoke_void_return_wrapper<Lazy<std::optional<std::vector<unsigned int>>>,false>::__call[abi:sn180100]<Lazy<std::optional<std::vector<unsigned int>>> (*&)(std::shared_ptr<RiceDecompressor>,unsigned int),std::shared_ptr<RiceDecompressor>,unsigned int>(void (**a1)(__int128 *, _QWORD), __int128 *a2, unsigned int *a3)
{
  void (*v3)(__int128 *, _QWORD);
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;

  v3 = *a1;
  v7 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v3(&v7, *a3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
  if (*((_QWORD *)&v7 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1DBCD0D48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
    std::__invoke_void_return_wrapper<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>>,false>::__call[abi:sn180100]<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*&)(std::shared_ptr<RiceDecompressor>,unsigned int),std::shared_ptr<RiceDecompressor>,unsigned int>(a10);
  _Unwind_Resume(exception_object);
}

uint64_t detail::lazy_promise<std::optional<Backend::Google::RawHashes>>::~lazy_promise(uint64_t a1)
{
  int v2;
  void *v3;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1)
  {
    if (*(_BYTE *)(a1 + 48))
    {
      v3 = *(void **)(a1 + 24);
      if (v3)
      {
        *(_QWORD *)(a1 + 32) = v3;
        operator delete(v3);
      }
    }
  }
  return a1;
}

void detail::lazy_promise<std::optional<std::pair<std::shared_ptr<ReadStream>,unsigned long>>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCD0E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

std::string *Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse>(uint64_t a1)
{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  char *v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  int v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::string *result;

  v3 = (uint64_t *)(a1 + 192);
  v4 = (_QWORD *)(a1 + 216);
  v5 = (char *)(a1 + 280);
  if (*(_BYTE *)(a1 + 280))
  {
    if (*(_BYTE *)(a1 + 280) != 1)
    {
      v6 = *(_QWORD *)(a1 + 272);
LABEL_31:
      detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse>>::result(v6 + 16);
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 152) = 0;
      if (*(_BYTE *)(v19 + 120))
      {
        *(_OWORD *)(a1 + 32) = *(_OWORD *)v19;
        *(_QWORD *)(a1 + 56) = 0;
        *(_QWORD *)(a1 + 64) = 0;
        *(_QWORD *)(a1 + 48) = 0;
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(v19 + 16);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(v19 + 32);
        *(_QWORD *)(v19 + 16) = 0;
        *(_QWORD *)(v19 + 24) = 0;
        *(_QWORD *)(v19 + 32) = 0;
        *(_QWORD *)(a1 + 72) = 0;
        *(_QWORD *)(a1 + 80) = 0;
        *(_QWORD *)(a1 + 88) = 0;
        *(_OWORD *)(a1 + 72) = *(_OWORD *)(v19 + 40);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(v19 + 56);
        *(_QWORD *)(v19 + 40) = 0;
        *(_QWORD *)(v19 + 48) = 0;
        *(_QWORD *)(v19 + 56) = 0;
        *(_QWORD *)(a1 + 96) = 0;
        *(_QWORD *)(a1 + 104) = 0;
        *(_QWORD *)(a1 + 112) = 0;
        *(_OWORD *)(a1 + 96) = *(_OWORD *)(v19 + 64);
        *(_QWORD *)(a1 + 112) = *(_QWORD *)(v19 + 80);
        *(_QWORD *)(v19 + 64) = 0;
        *(_QWORD *)(v19 + 72) = 0;
        *(_QWORD *)(v19 + 80) = 0;
        v20 = *(_OWORD *)(v19 + 88);
        *(_OWORD *)(a1 + 136) = *(_OWORD *)(v19 + 104);
        *(_OWORD *)(a1 + 120) = v20;
        *(_BYTE *)(a1 + 152) = 1;
      }
      *(_DWORD *)(a1 + 24) = 1;
      v21 = *(_QWORD *)(a1 + 240);
      if (v21)
        (*(void (**)(void))(v21 + 8))();
      v22 = *(std::__shared_weak_count **)(a1 + 232);
      if (v22)
      {
        p_shared_owners = (unint64_t *)&v22->__shared_owners_;
        do
          v24 = __ldaxr(p_shared_owners);
        while (__stlxr(v24 - 1, p_shared_owners));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      if (*(_BYTE *)(a1 + 208))
      {
        v25 = *(std::__shared_weak_count **)(a1 + 200);
        if (v25)
        {
          v26 = (unint64_t *)&v25->__shared_owners_;
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
            std::__shared_weak_count::__release_weak(v25);
          }
        }
      }
      goto LABEL_46;
    }
    v6 = *(_QWORD *)(a1 + 256);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 248), v4);
    v6 = *(_QWORD *)(a1 + 216);
    *(_QWORD *)(a1 + 256) = v6;
    if (!v6)
      goto LABEL_48;
    if (*(_QWORD *)v6)
    {
      v7 = 1;
LABEL_30:
      *v5 = v7;
      *(_QWORD *)(v6 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v6)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v6 + 16);
  *(_BYTE *)(a1 + 192) = 0;
  *(_BYTE *)(a1 + 208) = 0;
  v9 = *(unsigned __int8 *)(v8 + 16);
  if (*(_BYTE *)(v8 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v8 + 8);
    *(_QWORD *)(a1 + 192) = *(_QWORD *)v8;
    *(_QWORD *)(a1 + 200) = v1;
    if (v1)
    {
      v10 = (unint64_t *)&v1->__shared_owners_;
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    *(_BYTE *)(a1 + 208) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v9)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 152) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_46:
    *(_QWORD *)a1 = 0;
    *v5 = 3;
    v6 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v6)();
  }
  v12 = *v3;
  if (v1)
  {
    v13 = (unint64_t *)&v1->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    *(_QWORD *)(a1 + 224) = v12;
    v15 = a1 + 224;
    *(_DWORD *)(a1 + 216) = 0;
    *(_QWORD *)(a1 + 232) = v1;
    do
      v16 = __ldxr(v13);
    while (__stxr(v16 + 1, v13));
    do
      v17 = __ldaxr(v13);
    while (__stlxr(v17 - 1, v13));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 224) = v12;
    v15 = a1 + 224;
    *(_DWORD *)(a1 + 216) = 0;
    *(_QWORD *)(a1 + 232) = 0;
  }
  *(_QWORD *)(a1 + 264) = v15;
  v18 = *(_QWORD *)(a1 + 184);
  if (v18)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v18 + 48))(v18, v4);
    v6 = *(_QWORD *)(a1 + 240);
    *(_QWORD *)(a1 + 272) = v6;
    if (v6)
    {
      if (*(_QWORD *)v6)
      {
        v7 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_48:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD1124(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  _BYTE *v2;

  *v1 = 0;
  *v2 = 3;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse>(uint64_t a1)
{
  __asm { BR              X10 }
}

void sub_1DBCD11C4()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = v0[27];
  if (v3)
    (*(void (**)(void))(v3 + 8))();
  detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse>>::~lazy_promise(v2);
  v4 = (_QWORD *)v0[23];
  if (v4 == v1)
  {
    v5 = 4;
    goto LABEL_7;
  }
  if (v4)
  {
    v5 = 5;
    v1 = (_QWORD *)v0[23];
LABEL_7:
    (*(void (**)(_QWORD *))(*v1 + 8 * v5))(v1);
  }
  operator delete(v0);
}

std::string *Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::chrono::duration<long long,std::ratio<1l,1l>>>(uint64_t a1)
{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::string *result;

  v3 = (uint64_t *)(a1 + 80);
  v4 = (_QWORD *)(a1 + 104);
  if (*(_BYTE *)(a1 + 168))
  {
    if (*(_BYTE *)(a1 + 168) != 1)
    {
      v5 = *(_QWORD *)(a1 + 160);
LABEL_31:
      detail::lazy_promise<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>>::result(v5 + 16);
      *(_OWORD *)(a1 + 32) = *v18;
      *(_DWORD *)(a1 + 24) = 1;
      v19 = *(_QWORD *)(a1 + 128);
      if (v19)
        (*(void (**)(void))(v19 + 8))();
      v20 = *(std::__shared_weak_count **)(a1 + 120);
      if (v20)
      {
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          v22 = __ldaxr(p_shared_owners);
        while (__stlxr(v22 - 1, p_shared_owners));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      if (*(_BYTE *)(a1 + 96))
      {
        v23 = *(std::__shared_weak_count **)(a1 + 88);
        if (v23)
        {
          v24 = (unint64_t *)&v23->__shared_owners_;
          do
            v25 = __ldaxr(v24);
          while (__stlxr(v25 - 1, v24));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
      }
      goto LABEL_44;
    }
    v5 = *(_QWORD *)(a1 + 144);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 136), v4);
    v5 = *(_QWORD *)(a1 + 104);
    *(_QWORD *)(a1 + 144) = v5;
    if (!v5)
      goto LABEL_46;
    if (*(_QWORD *)v5)
    {
      v6 = 1;
LABEL_30:
      *(_BYTE *)(a1 + 168) = v6;
      *(_QWORD *)(v5 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v5)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v5 + 16);
  *(_BYTE *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 96) = 0;
  v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(_BYTE *)(v7 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v7 + 8);
    *(_QWORD *)(a1 + 80) = *(_QWORD *)v7;
    *(_QWORD *)(a1 + 88) = v1;
    if (v1)
    {
      v9 = (unint64_t *)&v1->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    *(_BYTE *)(a1 + 96) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v8)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_44:
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 168) = 3;
    v5 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v5)();
  }
  v11 = *v3;
  if (v1)
  {
    v12 = (unint64_t *)&v1->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    *(_QWORD *)(a1 + 112) = v11;
    v14 = a1 + 112;
    *(_DWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 120) = v1;
    do
      v15 = __ldxr(v12);
    while (__stxr(v15 + 1, v12));
    do
      v16 = __ldaxr(v12);
    while (__stlxr(v16 - 1, v12));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 112) = v11;
    v14 = a1 + 112;
    *(_DWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 120) = 0;
  }
  *(_QWORD *)(a1 + 152) = v14;
  v17 = *(_QWORD *)(a1 + 72);
  if (v17)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v4);
    v5 = *(_QWORD *)(a1 + 128);
    *(_QWORD *)(a1 + 160) = v5;
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        v6 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_46:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::string *result;

  v3 = (uint64_t *)(a1 + 80);
  v4 = (_QWORD *)(a1 + 104);
  if (*(_BYTE *)(a1 + 168))
  {
    if (*(_BYTE *)(a1 + 168) != 1)
    {
      v5 = *(_QWORD *)(a1 + 160);
LABEL_31:
      detail::lazy_promise<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>>::result(v5 + 16);
      *(_OWORD *)(a1 + 32) = *v18;
      *(_DWORD *)(a1 + 24) = 1;
      v19 = *(_QWORD *)(a1 + 128);
      if (v19)
        (*(void (**)(void))(v19 + 8))();
      v20 = *(std::__shared_weak_count **)(a1 + 120);
      if (v20)
      {
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          v22 = __ldaxr(p_shared_owners);
        while (__stlxr(v22 - 1, p_shared_owners));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      if (*(_BYTE *)(a1 + 96))
      {
        v23 = *(std::__shared_weak_count **)(a1 + 88);
        if (v23)
        {
          v24 = (unint64_t *)&v23->__shared_owners_;
          do
            v25 = __ldaxr(v24);
          while (__stlxr(v25 - 1, v24));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
      }
      goto LABEL_44;
    }
    v5 = *(_QWORD *)(a1 + 144);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 136), v4);
    v5 = *(_QWORD *)(a1 + 104);
    *(_QWORD *)(a1 + 144) = v5;
    if (!v5)
      goto LABEL_46;
    if (*(_QWORD *)v5)
    {
      v6 = 1;
LABEL_30:
      *(_BYTE *)(a1 + 168) = v6;
      *(_QWORD *)(v5 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v5)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v5 + 16);
  *(_BYTE *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 96) = 0;
  v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(_BYTE *)(v7 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v7 + 8);
    *(_QWORD *)(a1 + 80) = *(_QWORD *)v7;
    *(_QWORD *)(a1 + 88) = v1;
    if (v1)
    {
      v9 = (unint64_t *)&v1->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    *(_BYTE *)(a1 + 96) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v8)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_44:
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 168) = 3;
    v5 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v5)();
  }
  v11 = *v3;
  if (v1)
  {
    v12 = (unint64_t *)&v1->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    *(_QWORD *)(a1 + 112) = v11;
    v14 = a1 + 112;
    *(_DWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 120) = v1;
    do
      v15 = __ldxr(v12);
    while (__stxr(v15 + 1, v12));
    do
      v16 = __ldaxr(v12);
    while (__stlxr(v16 - 1, v12));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 112) = v11;
    v14 = a1 + 112;
    *(_DWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 120) = 0;
  }
  *(_QWORD *)(a1 + 152) = v14;
  v17 = *(_QWORD *)(a1 + 72);
  if (v17)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v4);
    v5 = *(_QWORD *)(a1 + 128);
    *(_QWORD *)(a1 + 160) = v5;
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        v6 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_46:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD1524(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 168) = 3;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::chrono::duration<long long,std::ratio<1l,1l>>>(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X10 }
}

void sub_1DBCD15C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;

  v16 = *(_QWORD *)(v14 + 104);
  if (v16)
    (*(void (**)(void))(v16 + 8))();
  if (*(_DWORD *)(v14 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v14 + 32));
  v17 = *(_QWORD **)(v14 + 72);
  if (v17 == v15)
  {
    v18 = 4;
    goto LABEL_9;
  }
  if (v17)
  {
    v18 = 5;
    v15 = *(_QWORD **)(v14 + 72);
LABEL_9:
    (*(void (**)(_QWORD *))(*v15 + 8 * v18))(v15);
  }
  operator delete((void *)v14);
}

void Backend::Google::FetchThreatListUpdatesResponseParser::parseDuration(uint64_t a1)
{
  __asm { BR              X15 }
}

{
  __asm { BR              X10 }
}

uint64_t sub_1DBCD1700()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  char v10;
  int v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  unsigned __int8 *v17;
  int v18;
  int v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  char v24;
  uint64_t result;

  v2 = *(_QWORD *)(v0 + 88);
  while (1)
  {
    detail::lazy_promise<ReadResult<unsigned int>>::result(v2 + 16);
    v4 = *v3;
    v5 = v3[1];
    *(_BYTE *)(v0 + 134) = HIBYTE(*v3);
    *(_WORD *)(v0 + 132) = v4 >> 8;
    *(_BYTE *)(v0 + 142) = v4;
    v6 = *(_QWORD *)(v0 + 48);
    if (v6)
      (*(void (**)(void))(v6 + 8))();
    if (v5 != 1)
      break;
    if (v4 == 2)
    {
      Backend::Google::ProtocolMessageReader::readVarintField(*(Backend::Google::ProtocolMessageReader **)(v0 + 56), v1);
      v2 = *(_QWORD *)(v0 + 48);
      *(_QWORD *)(v0 + 104) = v2;
      if (!v2)
        goto LABEL_45;
      if (*(_QWORD *)v2)
      {
        v24 = 3;
LABEL_43:
        *(_BYTE *)(v0 + 136) = v24;
        *(_QWORD *)(v2 + 16) = v0;
        return (*(uint64_t (**)(void))v2)();
      }
      detail::lazy_promise<std::optional<unsigned long long>>::result(v2 + 16);
      v16 = *v15;
      v12 = *((unsigned __int8 *)v15 + 8);
      if (*v1)
        (*(void (**)(void))(*v1 + 8))();
      if (!v12)
        goto LABEL_37;
      v13 = *(_BYTE *)(v0 + 141);
      LOBYTE(v9) = *(_BYTE *)(v0 + 138);
      v10 = 1;
      v11 = v16;
      v8 = *(_QWORD *)(v0 + 72);
      v14 = *(_QWORD *)(v0 + 80);
    }
    else
    {
      if (v4 == 1)
      {
        Backend::Google::ProtocolMessageReader::readVarintField(*(Backend::Google::ProtocolMessageReader **)(v0 + 56), v1);
        v2 = *(_QWORD *)(v0 + 48);
        *(_QWORD *)(v0 + 96) = v2;
        if (!v2)
          goto LABEL_45;
        if (*(_QWORD *)v2)
        {
          v24 = 2;
          goto LABEL_43;
        }
        detail::lazy_promise<std::optional<unsigned long long>>::result(v2 + 16);
        v8 = *v7;
        v9 = *((unsigned __int8 *)v7 + 8);
        if (*v1)
          (*(void (**)(void))(*v1 + 8))();
        if (!v9)
          goto LABEL_37;
        v10 = *(_BYTE *)(v0 + 140);
        v11 = *(_DWORD *)(v0 + 128);
        LOBYTE(v12) = *(_BYTE *)(v0 + 137);
        v13 = 1;
        v14 = v8;
      }
      else
      {
        Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v0 + 56), v1);
        v2 = *(_QWORD *)(v0 + 48);
        *(_QWORD *)(v0 + 112) = v2;
        if (!v2)
          goto LABEL_45;
        if (*(_QWORD *)v2)
        {
          v24 = 4;
          goto LABEL_43;
        }
        detail::lazy_promise<BOOL>::result(v2 + 16);
        v18 = *v17;
        if (*v1)
          (*(void (**)(void))(*v1 + 8))();
        if (!v18)
          goto LABEL_37;
        v13 = *(_BYTE *)(v0 + 141);
        v8 = *(_QWORD *)(v0 + 72);
        v14 = *(_QWORD *)(v0 + 80);
        v10 = *(_BYTE *)(v0 + 140);
        v11 = *(_DWORD *)(v0 + 128);
        LOBYTE(v9) = *(_BYTE *)(v0 + 138);
        LOBYTE(v12) = *(_BYTE *)(v0 + 137);
      }
      v16 = *(_QWORD *)(v0 + 64);
    }
    v19 = *(unsigned __int16 *)(v0 + 132) | (*(unsigned __int8 *)(v0 + 134) << 16);
    v20 = *(_BYTE *)(v0 + 142);
    *(_BYTE *)(v0 + 141) = v13;
    *(_QWORD *)(v0 + 72) = v8;
    *(_QWORD *)(v0 + 80) = v14;
    *(_BYTE *)(v0 + 140) = v10;
    *(_DWORD *)(v0 + 128) = v11;
    *(_WORD *)(v0 + 124) = v19;
    *(_BYTE *)(v0 + 126) = BYTE2(v19);
    *(_BYTE *)(v0 + 139) = v20;
    *(_DWORD *)(v0 + 120) = 1;
    *(_BYTE *)(v0 + 138) = v9;
    *(_BYTE *)(v0 + 137) = v12;
    *(_QWORD *)(v0 + 64) = v16;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v0 + 56), v1);
    v2 = *(_QWORD *)(v0 + 48);
    *(_QWORD *)(v0 + 88) = v2;
    if (!v2)
    {
LABEL_45:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*(_QWORD *)v2)
    {
      v24 = 1;
      goto LABEL_43;
    }
  }
  if (!v5)
  {
    if ((_BYTE)v4)
    {
      if (*(_BYTE *)(v0 + 141))
        v21 = *(_QWORD *)(v0 + 80);
      else
        v21 = 0;
      v22 = *(_DWORD *)(v0 + 128) / 1000000000;
      if (!*(_BYTE *)(v0 + 140))
        v22 = 0;
      *(_QWORD *)(v0 + 32) = v22 + v21;
      v23 = 1;
    }
    else
    {
LABEL_37:
      v23 = 0;
      *(_BYTE *)(v0 + 32) = 0;
    }
    *(_BYTE *)(v0 + 40) = v23;
    *(_DWORD *)(v0 + 24) = 1;
    *(_QWORD *)v0 = 0;
    *(_BYTE *)(v0 + 136) = 5;
    v2 = *(_QWORD *)(v0 + 16);
    return (*(uint64_t (**)(void))v2)();
  }
  result = std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD19B8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 136) = 5;
  _Unwind_Resume(exception_object);
}

void sub_1DBCD1A30(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  char v13;
  __int16 v14;
  uint64_t v15;

  v13 = *(_BYTE *)(v12 + 139);
  v14 = *(_WORD *)(v12 + 124);
  *(_BYTE *)(v12 + 134) = *(_BYTE *)(v12 + 126);
  *(_WORD *)(v12 + 132) = v14;
  *(_BYTE *)(v12 + 142) = v13;
  v15 = *(_QWORD *)(v12 + 48);
  if (v15)
    (*(void (**)(void))(v15 + 8))();
  if (*(_DWORD *)(v12 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 + 32));
  operator delete((void *)v12);
}

uint64_t Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatType>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  Backend::Google::ProtocolMessageReader *v7;

  v2 = (_QWORD *)(a1 + 40);
  if (*(_BYTE *)(a1 + 64))
  {
    v3 = *(_QWORD *)(a1 + 56);
    goto LABEL_3;
  }
  v7 = *(Backend::Google::ProtocolMessageReader **)(a1 + 48);
  if (*(_DWORD *)v7 != 1)
    goto LABEL_12;
  Backend::Google::ProtocolMessageReader::readVarintField(v7, v2);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = v3;
  if (!v3)
  {
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  if (!*(_QWORD *)v3)
  {
LABEL_3:
    detail::lazy_promise<std::optional<unsigned long long>>::result(v3 + 16);
    v5 = *(_DWORD *)v4;
    v6 = *(unsigned __int8 *)(v4 + 8);
    if (*v2)
      (*(void (**)(void))(*v2 + 8))();
    if (v6 && EnumTraits::isValidEnum<Backend::Google::ThreatType>(v5))
    {
      *(_DWORD *)(a1 + 32) = v5;
      *(_BYTE *)(a1 + 36) = 1;
LABEL_13:
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 64) = 2;
      v3 = *(_QWORD *)(a1 + 16);
      return (*(uint64_t (**)(void))v3)();
    }
LABEL_12:
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 36) = 0;
    goto LABEL_13;
  }
  *(_BYTE *)(a1 + 64) = 1;
  *(_QWORD *)(v3 + 16) = a1;
  return (*(uint64_t (**)(void))v3)();
}

{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  Backend::Google::ProtocolMessageReader *v7;

  v2 = (_QWORD *)(a1 + 40);
  if (*(_BYTE *)(a1 + 64))
  {
    v3 = *(_QWORD *)(a1 + 56);
    goto LABEL_3;
  }
  v7 = *(Backend::Google::ProtocolMessageReader **)(a1 + 48);
  if (*(_DWORD *)v7 != 1)
    goto LABEL_12;
  Backend::Google::ProtocolMessageReader::readVarintField(v7, v2);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = v3;
  if (!v3)
  {
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  if (!*(_QWORD *)v3)
  {
LABEL_3:
    detail::lazy_promise<std::optional<unsigned long long>>::result(v3 + 16);
    v5 = *(_DWORD *)v4;
    v6 = *(unsigned __int8 *)(v4 + 8);
    if (*v2)
      (*(void (**)(void))(*v2 + 8))();
    if (v6 && EnumTraits::isValidEnum<Backend::Google::ThreatType>(v5))
    {
      *(_DWORD *)(a1 + 32) = v5;
      *(_BYTE *)(a1 + 36) = 1;
LABEL_13:
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 64) = 2;
      v3 = *(_QWORD *)(a1 + 16);
      return (*(uint64_t (**)(void))v3)();
    }
LABEL_12:
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 36) = 0;
    goto LABEL_13;
  }
  *(_BYTE *)(a1 + 64) = 1;
  *(_QWORD *)(v3 + 16) = a1;
  return (*(uint64_t (**)(void))v3)();
}

void sub_1DBCD1B60(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 64) = 2;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatType>(std::exception_ptr *__p)
{
  void (**ptr)(void);

  if (LOBYTE(__p[8].__ptr_) == 1)
  {
    ptr = (void (**)(void))__p[5].__ptr_;
    if (ptr)
      ptr[1]();
  }
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

{
  void (**ptr)(void);

  if (LOBYTE(__p[8].__ptr_) == 1)
  {
    ptr = (void (**)(void))__p[5].__ptr_;
    if (ptr)
      ptr[1]();
  }
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

uint64_t Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatEntryType>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  Backend::Google::ProtocolMessageReader *v7;

  v2 = (_QWORD *)(a1 + 40);
  if (*(_BYTE *)(a1 + 64))
  {
    v3 = *(_QWORD *)(a1 + 56);
    goto LABEL_3;
  }
  v7 = *(Backend::Google::ProtocolMessageReader **)(a1 + 48);
  if (*(_DWORD *)v7 != 1)
    goto LABEL_12;
  Backend::Google::ProtocolMessageReader::readVarintField(v7, v2);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = v3;
  if (!v3)
  {
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  if (!*(_QWORD *)v3)
  {
LABEL_3:
    detail::lazy_promise<std::optional<unsigned long long>>::result(v3 + 16);
    v5 = *(_DWORD *)v4;
    v6 = *(unsigned __int8 *)(v4 + 8);
    if (*v2)
      (*(void (**)(void))(*v2 + 8))();
    if (v6 && EnumTraits::isValidEnum<Backend::Google::ThreatEntryType>(v5))
    {
      *(_DWORD *)(a1 + 32) = v5;
      *(_BYTE *)(a1 + 36) = 1;
LABEL_13:
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 64) = 2;
      v3 = *(_QWORD *)(a1 + 16);
      return (*(uint64_t (**)(void))v3)();
    }
LABEL_12:
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 36) = 0;
    goto LABEL_13;
  }
  *(_BYTE *)(a1 + 64) = 1;
  *(_QWORD *)(v3 + 16) = a1;
  return (*(uint64_t (**)(void))v3)();
}

{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  Backend::Google::ProtocolMessageReader *v7;

  v2 = (_QWORD *)(a1 + 40);
  if (*(_BYTE *)(a1 + 64))
  {
    v3 = *(_QWORD *)(a1 + 56);
    goto LABEL_3;
  }
  v7 = *(Backend::Google::ProtocolMessageReader **)(a1 + 48);
  if (*(_DWORD *)v7 != 1)
    goto LABEL_12;
  Backend::Google::ProtocolMessageReader::readVarintField(v7, v2);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = v3;
  if (!v3)
  {
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  if (!*(_QWORD *)v3)
  {
LABEL_3:
    detail::lazy_promise<std::optional<unsigned long long>>::result(v3 + 16);
    v5 = *(_DWORD *)v4;
    v6 = *(unsigned __int8 *)(v4 + 8);
    if (*v2)
      (*(void (**)(void))(*v2 + 8))();
    if (v6 && EnumTraits::isValidEnum<Backend::Google::ThreatEntryType>(v5))
    {
      *(_DWORD *)(a1 + 32) = v5;
      *(_BYTE *)(a1 + 36) = 1;
LABEL_13:
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 64) = 2;
      v3 = *(_QWORD *)(a1 + 16);
      return (*(uint64_t (**)(void))v3)();
    }
LABEL_12:
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 36) = 0;
    goto LABEL_13;
  }
  *(_BYTE *)(a1 + 64) = 1;
  *(_QWORD *)(v3 + 16) = a1;
  return (*(uint64_t (**)(void))v3)();
}

void sub_1DBCD1CC8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 64) = 2;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatEntryType>(std::exception_ptr *__p)
{
  void (**ptr)(void);

  if (LOBYTE(__p[8].__ptr_) == 1)
  {
    ptr = (void (**)(void))__p[5].__ptr_;
    if (ptr)
      ptr[1]();
  }
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

{
  void (**ptr)(void);

  if (LOBYTE(__p[8].__ptr_) == 1)
  {
    ptr = (void (**)(void))__p[5].__ptr_;
    if (ptr)
      ptr[1]();
  }
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

uint64_t Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::PlatformType>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  Backend::Google::ProtocolMessageReader *v7;

  v2 = (_QWORD *)(a1 + 40);
  if (*(_BYTE *)(a1 + 64))
  {
    v3 = *(_QWORD *)(a1 + 56);
    goto LABEL_3;
  }
  v7 = *(Backend::Google::ProtocolMessageReader **)(a1 + 48);
  if (*(_DWORD *)v7 != 1)
    goto LABEL_12;
  Backend::Google::ProtocolMessageReader::readVarintField(v7, v2);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = v3;
  if (!v3)
  {
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  if (!*(_QWORD *)v3)
  {
LABEL_3:
    detail::lazy_promise<std::optional<unsigned long long>>::result(v3 + 16);
    v5 = *(_DWORD *)v4;
    v6 = *(unsigned __int8 *)(v4 + 8);
    if (*v2)
      (*(void (**)(void))(*v2 + 8))();
    if (v6 && EnumTraits::isValidEnum<Backend::Google::PlatformType>(v5))
    {
      *(_DWORD *)(a1 + 32) = v5;
      *(_BYTE *)(a1 + 36) = 1;
LABEL_13:
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 64) = 2;
      v3 = *(_QWORD *)(a1 + 16);
      return (*(uint64_t (**)(void))v3)();
    }
LABEL_12:
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 36) = 0;
    goto LABEL_13;
  }
  *(_BYTE *)(a1 + 64) = 1;
  *(_QWORD *)(v3 + 16) = a1;
  return (*(uint64_t (**)(void))v3)();
}

{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  Backend::Google::ProtocolMessageReader *v7;

  v2 = (_QWORD *)(a1 + 40);
  if (*(_BYTE *)(a1 + 64))
  {
    v3 = *(_QWORD *)(a1 + 56);
    goto LABEL_3;
  }
  v7 = *(Backend::Google::ProtocolMessageReader **)(a1 + 48);
  if (*(_DWORD *)v7 != 1)
    goto LABEL_12;
  Backend::Google::ProtocolMessageReader::readVarintField(v7, v2);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = v3;
  if (!v3)
  {
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  if (!*(_QWORD *)v3)
  {
LABEL_3:
    detail::lazy_promise<std::optional<unsigned long long>>::result(v3 + 16);
    v5 = *(_DWORD *)v4;
    v6 = *(unsigned __int8 *)(v4 + 8);
    if (*v2)
      (*(void (**)(void))(*v2 + 8))();
    if (v6 && EnumTraits::isValidEnum<Backend::Google::PlatformType>(v5))
    {
      *(_DWORD *)(a1 + 32) = v5;
      *(_BYTE *)(a1 + 36) = 1;
LABEL_13:
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 64) = 2;
      v3 = *(_QWORD *)(a1 + 16);
      return (*(uint64_t (**)(void))v3)();
    }
LABEL_12:
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 36) = 0;
    goto LABEL_13;
  }
  *(_BYTE *)(a1 + 64) = 1;
  *(_QWORD *)(v3 + 16) = a1;
  return (*(uint64_t (**)(void))v3)();
}

void sub_1DBCD1E30(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 64) = 2;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::PlatformType>(std::exception_ptr *__p)
{
  void (**ptr)(void);

  if (LOBYTE(__p[8].__ptr_) == 1)
  {
    ptr = (void (**)(void))__p[5].__ptr_;
    if (ptr)
      ptr[1]();
  }
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

{
  void (**ptr)(void);

  if (LOBYTE(__p[8].__ptr_) == 1)
  {
    ptr = (void (**)(void))__p[5].__ptr_;
    if (ptr)
      ptr[1]();
  }
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

uint64_t Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ResponseType>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  Backend::Google::ProtocolMessageReader *v7;

  v2 = (_QWORD *)(a1 + 40);
  if (*(_BYTE *)(a1 + 64))
  {
    v3 = *(_QWORD *)(a1 + 56);
    goto LABEL_3;
  }
  v7 = *(Backend::Google::ProtocolMessageReader **)(a1 + 48);
  if (*(_DWORD *)v7 != 1)
    goto LABEL_12;
  Backend::Google::ProtocolMessageReader::readVarintField(v7, v2);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = v3;
  if (!v3)
  {
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  if (!*(_QWORD *)v3)
  {
LABEL_3:
    detail::lazy_promise<std::optional<unsigned long long>>::result(v3 + 16);
    v5 = *(_DWORD *)v4;
    v6 = *(unsigned __int8 *)(v4 + 8);
    if (*v2)
      (*(void (**)(void))(*v2 + 8))();
    if (v6 && EnumTraits::isValidEnum<Backend::Google::CompressionType>(v5))
    {
      *(_DWORD *)(a1 + 32) = v5;
      *(_BYTE *)(a1 + 36) = 1;
LABEL_13:
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 64) = 2;
      v3 = *(_QWORD *)(a1 + 16);
      return (*(uint64_t (**)(void))v3)();
    }
LABEL_12:
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 36) = 0;
    goto LABEL_13;
  }
  *(_BYTE *)(a1 + 64) = 1;
  *(_QWORD *)(v3 + 16) = a1;
  return (*(uint64_t (**)(void))v3)();
}

void sub_1DBCD1F98(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 64) = 2;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ResponseType>(std::exception_ptr *__p)
{
  void (**ptr)(void);

  if (LOBYTE(__p[8].__ptr_) == 1)
  {
    ptr = (void (**)(void))__p[5].__ptr_;
    if (ptr)
      ptr[1]();
  }
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

std::string *Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse::Addition>(uint64_t a1)
{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::string *result;

  v3 = (uint64_t *)(a1 + 88);
  v4 = (_QWORD *)(a1 + 112);
  if (*(_BYTE *)(a1 + 176))
  {
    if (*(_BYTE *)(a1 + 176) != 1)
    {
      v5 = *(_QWORD *)(a1 + 168);
LABEL_31:
      detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::result(v5 + 16);
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 48) = 0;
      if (*(_BYTE *)(v18 + 16))
      {
        *(_QWORD *)(a1 + 32) = *(_QWORD *)v18;
        v19 = *(_QWORD *)(v18 + 8);
        *(_QWORD *)(v18 + 8) = 0;
        *(_QWORD *)(a1 + 40) = v19;
        *(_BYTE *)(a1 + 48) = 1;
      }
      *(_DWORD *)(a1 + 24) = 1;
      v20 = *(_QWORD *)(a1 + 136);
      if (v20)
        (*(void (**)(void))(v20 + 8))();
      v21 = *(std::__shared_weak_count **)(a1 + 128);
      if (v21)
      {
        p_shared_owners = (unint64_t *)&v21->__shared_owners_;
        do
          v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      if (*(_BYTE *)(a1 + 104))
      {
        v24 = *(std::__shared_weak_count **)(a1 + 96);
        if (v24)
        {
          v25 = (unint64_t *)&v24->__shared_owners_;
          do
            v26 = __ldaxr(v25);
          while (__stlxr(v26 - 1, v25));
          if (!v26)
          {
            ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
            std::__shared_weak_count::__release_weak(v24);
          }
        }
      }
      goto LABEL_46;
    }
    v5 = *(_QWORD *)(a1 + 152);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 144), v4);
    v5 = *(_QWORD *)(a1 + 112);
    *(_QWORD *)(a1 + 152) = v5;
    if (!v5)
      goto LABEL_48;
    if (*(_QWORD *)v5)
    {
      v6 = 1;
LABEL_30:
      *(_BYTE *)(a1 + 176) = v6;
      *(_QWORD *)(v5 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v5)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v5 + 16);
  *(_BYTE *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 104) = 0;
  v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(_BYTE *)(v7 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v7 + 8);
    *(_QWORD *)(a1 + 88) = *(_QWORD *)v7;
    *(_QWORD *)(a1 + 96) = v1;
    if (v1)
    {
      v9 = (unint64_t *)&v1->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    *(_BYTE *)(a1 + 104) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v8)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_46:
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 176) = 3;
    v5 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v5)();
  }
  v11 = *v3;
  if (v1)
  {
    v12 = (unint64_t *)&v1->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    *(_QWORD *)(a1 + 120) = v11;
    v14 = a1 + 120;
    *(_DWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 128) = v1;
    do
      v15 = __ldxr(v12);
    while (__stxr(v15 + 1, v12));
    do
      v16 = __ldaxr(v12);
    while (__stlxr(v16 - 1, v12));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 120) = v11;
    v14 = a1 + 120;
    *(_DWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  *(_QWORD *)(a1 + 160) = v14;
  v17 = *(_QWORD *)(a1 + 80);
  if (v17)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v4);
    v5 = *(_QWORD *)(a1 + 136);
    *(_QWORD *)(a1 + 168) = v5;
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        v6 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_48:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD22B8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 176) = 3;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse::Addition>(uint64_t a1)
{
  __asm { BR              X10 }
}

void sub_1DBCD2358()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = v0[14];
  if (v3)
    (*(void (**)(void))(v3 + 8))();
  detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::~lazy_promise(v2);
  v4 = (_QWORD *)v0[10];
  if (v4 == v1)
  {
    v5 = 4;
    goto LABEL_7;
  }
  if (v4)
  {
    v5 = 5;
    v1 = (_QWORD *)v0[10];
LABEL_7:
    (*(void (**)(_QWORD *))(*v1 + 8 * v5))(v1);
  }
  operator delete(v0);
}

std::string *Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<unsigned int>>(uint64_t a1)
{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::string *result;

  v3 = (uint64_t *)(a1 + 96);
  v4 = (_QWORD *)(a1 + 120);
  if (*(_BYTE *)(a1 + 184))
  {
    if (*(_BYTE *)(a1 + 184) != 1)
    {
      v5 = *(_QWORD *)(a1 + 176);
LABEL_31:
      detail::lazy_promise<std::optional<std::vector<unsigned int>>>::result(v5 + 16);
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 56) = 0;
      if (*(_BYTE *)(v18 + 24))
      {
        *(_QWORD *)(a1 + 32) = 0;
        *(_QWORD *)(a1 + 40) = 0;
        *(_QWORD *)(a1 + 48) = 0;
        *(_OWORD *)(a1 + 32) = *(_OWORD *)v18;
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(v18 + 16);
        *(_QWORD *)v18 = 0;
        *(_QWORD *)(v18 + 8) = 0;
        *(_QWORD *)(v18 + 16) = 0;
        *(_BYTE *)(a1 + 56) = 1;
      }
      *(_DWORD *)(a1 + 24) = 1;
      v19 = *(_QWORD *)(a1 + 144);
      if (v19)
        (*(void (**)(void))(v19 + 8))();
      v20 = *(std::__shared_weak_count **)(a1 + 136);
      if (v20)
      {
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          v22 = __ldaxr(p_shared_owners);
        while (__stlxr(v22 - 1, p_shared_owners));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      if (*(_BYTE *)(a1 + 112))
      {
        v23 = *(std::__shared_weak_count **)(a1 + 104);
        if (v23)
        {
          v24 = (unint64_t *)&v23->__shared_owners_;
          do
            v25 = __ldaxr(v24);
          while (__stlxr(v25 - 1, v24));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
      }
      goto LABEL_46;
    }
    v5 = *(_QWORD *)(a1 + 160);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 152), v4);
    v5 = *(_QWORD *)(a1 + 120);
    *(_QWORD *)(a1 + 160) = v5;
    if (!v5)
      goto LABEL_48;
    if (*(_QWORD *)v5)
    {
      v6 = 1;
LABEL_30:
      *(_BYTE *)(a1 + 184) = v6;
      *(_QWORD *)(v5 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v5)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v5 + 16);
  *(_BYTE *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 112) = 0;
  v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(_BYTE *)(v7 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v7 + 8);
    *(_QWORD *)(a1 + 96) = *(_QWORD *)v7;
    *(_QWORD *)(a1 + 104) = v1;
    if (v1)
    {
      v9 = (unint64_t *)&v1->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    *(_BYTE *)(a1 + 112) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v8)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_46:
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 184) = 3;
    v5 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v5)();
  }
  v11 = *v3;
  if (v1)
  {
    v12 = (unint64_t *)&v1->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    *(_QWORD *)(a1 + 128) = v11;
    v14 = a1 + 128;
    *(_DWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 136) = v1;
    do
      v15 = __ldxr(v12);
    while (__stxr(v15 + 1, v12));
    do
      v16 = __ldaxr(v12);
    while (__stlxr(v16 - 1, v12));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 128) = v11;
    v14 = a1 + 128;
    *(_DWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 136) = 0;
  }
  *(_QWORD *)(a1 + 168) = v14;
  v17 = *(_QWORD *)(a1 + 88);
  if (v17)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v4);
    v5 = *(_QWORD *)(a1 + 144);
    *(_QWORD *)(a1 + 176) = v5;
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        v6 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_48:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD26EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 184) = 3;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<unsigned int>>(uint64_t a1)
{
  __asm { BR              X10 }
}

void sub_1DBCD278C()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = v0[15];
  if (v3)
    (*(void (**)(void))(v3 + 8))();
  detail::lazy_promise<std::optional<std::vector<unsigned int>>>::~lazy_promise(v2);
  v4 = (_QWORD *)v0[11];
  if (v4 == v1)
  {
    v5 = 4;
    goto LABEL_7;
  }
  if (v4)
  {
    v5 = 5;
    v1 = (_QWORD *)v0[11];
LABEL_7:
    (*(void (**)(_QWORD *))(*v1 + 8 * v5))(v1);
  }
  operator delete(v0);
}

std::string *Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::array<unsigned char,32ul>>(uint64_t a1)
{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  __int128 *v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::string *result;

  v3 = (uint64_t *)(a1 + 104);
  v4 = (_QWORD *)(a1 + 128);
  if (*(_BYTE *)(a1 + 192))
  {
    if (*(_BYTE *)(a1 + 192) != 1)
    {
      v5 = *(_QWORD *)(a1 + 184);
LABEL_31:
      detail::lazy_promise<std::optional<std::array<unsigned char,32ul>>>::result(v5 + 16);
      v19 = *v18;
      v20 = v18[1];
      *(_BYTE *)(a1 + 64) = *((_BYTE *)v18 + 32);
      *(_OWORD *)(a1 + 32) = v19;
      *(_OWORD *)(a1 + 48) = v20;
      *(_DWORD *)(a1 + 24) = 1;
      v21 = *(_QWORD *)(a1 + 152);
      if (v21)
        (*(void (**)(void))(v21 + 8))();
      v22 = *(std::__shared_weak_count **)(a1 + 144);
      if (v22)
      {
        p_shared_owners = (unint64_t *)&v22->__shared_owners_;
        do
          v24 = __ldaxr(p_shared_owners);
        while (__stlxr(v24 - 1, p_shared_owners));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      if (*(_BYTE *)(a1 + 120))
      {
        v25 = *(std::__shared_weak_count **)(a1 + 112);
        if (v25)
        {
          v26 = (unint64_t *)&v25->__shared_owners_;
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
            std::__shared_weak_count::__release_weak(v25);
          }
        }
      }
      goto LABEL_44;
    }
    v5 = *(_QWORD *)(a1 + 168);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 160), v4);
    v5 = *(_QWORD *)(a1 + 128);
    *(_QWORD *)(a1 + 168) = v5;
    if (!v5)
      goto LABEL_46;
    if (*(_QWORD *)v5)
    {
      v6 = 1;
LABEL_30:
      *(_BYTE *)(a1 + 192) = v6;
      *(_QWORD *)(v5 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v5)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v5 + 16);
  *(_BYTE *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(_BYTE *)(v7 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v7 + 8);
    *(_QWORD *)(a1 + 104) = *(_QWORD *)v7;
    *(_QWORD *)(a1 + 112) = v1;
    if (v1)
    {
      v9 = (unint64_t *)&v1->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    *(_BYTE *)(a1 + 120) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v8)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_44:
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 192) = 3;
    v5 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v5)();
  }
  v11 = *v3;
  if (v1)
  {
    v12 = (unint64_t *)&v1->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    *(_QWORD *)(a1 + 136) = v11;
    v14 = a1 + 136;
    *(_DWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 144) = v1;
    do
      v15 = __ldxr(v12);
    while (__stxr(v15 + 1, v12));
    do
      v16 = __ldaxr(v12);
    while (__stlxr(v16 - 1, v12));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 136) = v11;
    v14 = a1 + 136;
    *(_DWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 144) = 0;
  }
  *(_QWORD *)(a1 + 176) = v14;
  v17 = *(_QWORD *)(a1 + 96);
  if (v17)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v4);
    v5 = *(_QWORD *)(a1 + 152);
    *(_QWORD *)(a1 + 184) = v5;
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        v6 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_46:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  __int128 *v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::string *result;

  v3 = (uint64_t *)(a1 + 104);
  v4 = (_QWORD *)(a1 + 128);
  if (*(_BYTE *)(a1 + 192))
  {
    if (*(_BYTE *)(a1 + 192) != 1)
    {
      v5 = *(_QWORD *)(a1 + 184);
LABEL_31:
      detail::lazy_promise<std::optional<std::array<unsigned char,32ul>>>::result(v5 + 16);
      v19 = *v18;
      v20 = v18[1];
      *(_BYTE *)(a1 + 64) = *((_BYTE *)v18 + 32);
      *(_OWORD *)(a1 + 32) = v19;
      *(_OWORD *)(a1 + 48) = v20;
      *(_DWORD *)(a1 + 24) = 1;
      v21 = *(_QWORD *)(a1 + 152);
      if (v21)
        (*(void (**)(void))(v21 + 8))();
      v22 = *(std::__shared_weak_count **)(a1 + 144);
      if (v22)
      {
        p_shared_owners = (unint64_t *)&v22->__shared_owners_;
        do
          v24 = __ldaxr(p_shared_owners);
        while (__stlxr(v24 - 1, p_shared_owners));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      if (*(_BYTE *)(a1 + 120))
      {
        v25 = *(std::__shared_weak_count **)(a1 + 112);
        if (v25)
        {
          v26 = (unint64_t *)&v25->__shared_owners_;
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
            std::__shared_weak_count::__release_weak(v25);
          }
        }
      }
      goto LABEL_44;
    }
    v5 = *(_QWORD *)(a1 + 168);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 160), v4);
    v5 = *(_QWORD *)(a1 + 128);
    *(_QWORD *)(a1 + 168) = v5;
    if (!v5)
      goto LABEL_46;
    if (*(_QWORD *)v5)
    {
      v6 = 1;
LABEL_30:
      *(_BYTE *)(a1 + 192) = v6;
      *(_QWORD *)(v5 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v5)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v5 + 16);
  *(_BYTE *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(_BYTE *)(v7 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v7 + 8);
    *(_QWORD *)(a1 + 104) = *(_QWORD *)v7;
    *(_QWORD *)(a1 + 112) = v1;
    if (v1)
    {
      v9 = (unint64_t *)&v1->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    *(_BYTE *)(a1 + 120) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v8)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_44:
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 192) = 3;
    v5 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v5)();
  }
  v11 = *v3;
  if (v1)
  {
    v12 = (unint64_t *)&v1->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    *(_QWORD *)(a1 + 136) = v11;
    v14 = a1 + 136;
    *(_DWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 144) = v1;
    do
      v15 = __ldxr(v12);
    while (__stxr(v15 + 1, v12));
    do
      v16 = __ldaxr(v12);
    while (__stlxr(v16 - 1, v12));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 136) = v11;
    v14 = a1 + 136;
    *(_DWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 144) = 0;
  }
  *(_QWORD *)(a1 + 176) = v14;
  v17 = *(_QWORD *)(a1 + 96);
  if (v17)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v4);
    v5 = *(_QWORD *)(a1 + 152);
    *(_QWORD *)(a1 + 184) = v5;
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        v6 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_46:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD2AF4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 192) = 3;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::array<unsigned char,32ul>>(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X10 }
}

void sub_1DBCD2B90(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;

  v16 = *(_QWORD *)(v14 + 128);
  if (v16)
    (*(void (**)(void))(v16 + 8))();
  if (*(_DWORD *)(v14 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v14 + 32));
  v17 = *(_QWORD **)(v14 + 96);
  if (v17 == v15)
  {
    v18 = 4;
    goto LABEL_9;
  }
  if (v17)
  {
    v18 = 5;
    v15 = *(_QWORD **)(v14 + 96);
LABEL_9:
    (*(void (**)(_QWORD *))(*v15 + 8 * v18))(v15);
  }
  operator delete((void *)v14);
}

_QWORD *ReadStream::readByte(uint64_t a1)
{
  int v2;
  std::__shared_weak_count *v3;
  unint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;

  v2 = *(unsigned __int8 *)(a1 + 72);
  if (v2 == 2)
    goto LABEL_17;
  if (v2 == 1)
    goto LABEL_3;
  v7 = *(_QWORD **)(a1 + 64);
  if (*((_BYTE *)v7 + 24))
  {
    if (*(_QWORD *)(*v7 + 64) >= v7[2])
    {
      *(_QWORD *)(a1 + 32) = 1;
      *(_DWORD *)(a1 + 24) = 1;
LABEL_23:
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 72) = 3;
      return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
    }
    ByteProvider::readByteOperationForReadStream((ByteProvider *)*v7, a1 + 40);
    if ((ReadByteOperation::await_ready((ReadByteOperation *)(a1 + 40)) & 1) == 0)
    {
      *(_BYTE *)(a1 + 72) = 1;
      return ReadByteOperation::await_suspend((uint64_t *)(a1 + 40), a1);
    }
LABEL_3:
    v3 = *(std::__shared_weak_count **)(a1 + 48);
    v4 = *(_QWORD *)(a1 + 56);
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    if (HIDWORD(v4) == 1)
      *(_QWORD *)(a1 + 32) = v4 | 0x100000000;
    else
      *(_QWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 24) = 1;
    goto LABEL_23;
  }
  ByteProvider::readByteOperationForReadStream((ByteProvider *)*v7, a1 + 40);
  if ((ReadByteOperation::await_ready((ReadByteOperation *)(a1 + 40)) & 1) != 0)
  {
LABEL_17:
    v9 = *(std::__shared_weak_count **)(a1 + 48);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 24) = 1;
    if (v9)
    {
      v10 = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    goto LABEL_23;
  }
  *(_BYTE *)(a1 + 72) = 2;
  return ReadByteOperation::await_suspend((uint64_t *)(a1 + 40), a1);
}

{
  int v2;
  std::__shared_weak_count *v3;
  unint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;

  v2 = *(unsigned __int8 *)(a1 + 72);
  if (v2 == 2)
    goto LABEL_17;
  if (v2 == 1)
    goto LABEL_3;
  v7 = *(_QWORD **)(a1 + 64);
  if (*((_BYTE *)v7 + 24))
  {
    if (*(_QWORD *)(*v7 + 64) >= v7[2])
    {
      *(_QWORD *)(a1 + 32) = 1;
      *(_DWORD *)(a1 + 24) = 1;
LABEL_23:
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 72) = 3;
      return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
    }
    ByteProvider::readByteOperationForReadStream((ByteProvider *)*v7, a1 + 40);
    if ((ReadByteOperation::await_ready((ReadByteOperation *)(a1 + 40)) & 1) == 0)
    {
      *(_BYTE *)(a1 + 72) = 1;
      return ReadByteOperation::await_suspend((uint64_t *)(a1 + 40), a1);
    }
LABEL_3:
    v3 = *(std::__shared_weak_count **)(a1 + 48);
    v4 = *(_QWORD *)(a1 + 56);
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    if (HIDWORD(v4) == 1)
      *(_QWORD *)(a1 + 32) = v4 | 0x100000000;
    else
      *(_QWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 24) = 1;
    goto LABEL_23;
  }
  ByteProvider::readByteOperationForReadStream((ByteProvider *)*v7, a1 + 40);
  if ((ReadByteOperation::await_ready((ReadByteOperation *)(a1 + 40)) & 1) != 0)
  {
LABEL_17:
    v9 = *(std::__shared_weak_count **)(a1 + 48);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 24) = 1;
    if (v9)
    {
      v10 = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    goto LABEL_23;
  }
  *(_BYTE *)(a1 + 72) = 2;
  return ReadByteOperation::await_suspend((uint64_t *)(a1 + 40), a1);
}

{
  int v2;
  std::__shared_weak_count *v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  char v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;

  v2 = *(unsigned __int8 *)(a1 + 72);
  if (v2 == 2)
    goto LABEL_17;
  if (v2 == 1)
    goto LABEL_3;
  v7 = *(_QWORD *)(a1 + 64);
  if (!*(_BYTE *)(v7 + 24))
  {
    ByteProvider::readByteOperationForReadStream(*(ByteProvider **)v7, a1 + 40);
    if (!ReadByteOperation::await_ready((ReadByteOperation *)(a1 + 40)))
    {
      v8 = 2;
      goto LABEL_25;
    }
LABEL_17:
    v9 = *(std::__shared_weak_count **)(a1 + 48);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 24) = 1;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    goto LABEL_23;
  }
  if (*(_QWORD *)(*(_QWORD *)v7 + 64) >= *(_QWORD *)(v7 + 16))
  {
    *(_QWORD *)(a1 + 32) = 1;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_23:
    *(_QWORD *)a1 = 0;
    return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
  }
  ByteProvider::readByteOperationForReadStream(*(ByteProvider **)v7, a1 + 40);
  if (ReadByteOperation::await_ready((ReadByteOperation *)(a1 + 40)))
  {
LABEL_3:
    v3 = *(std::__shared_weak_count **)(a1 + 48);
    v4 = *(_QWORD *)(a1 + 56);
    if (v3)
    {
      v5 = (unint64_t *)&v3->__shared_owners_;
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    if (HIDWORD(v4) == 1)
      *(_QWORD *)(a1 + 32) = v4 | 0x100000000;
    else
      *(_QWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 24) = 1;
    goto LABEL_23;
  }
  v8 = 1;
LABEL_25:
  *(_BYTE *)(a1 + 72) = v8;
  return ReadByteOperation::await_suspend((uint64_t *)(a1 + 40), a1);
}

void sub_1DBCD2E14(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 72) = 3;
  _Unwind_Resume(a1);
}

void ReadStream::readByte(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X10 }
}

{
  __asm { BR              X10 }
}

void sub_1DBCD2E78(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;

  v13 = *(std::__shared_weak_count **)(v12 + 48);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (*(_DWORD *)(v12 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 + 32));
  operator delete((void *)v12);
}

void sub_1DBCD2F20()
{
  uint64_t v0;
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(v0 + 48);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  if (*(_DWORD *)(v0 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v0 + 32));
}

_QWORD *Backend::Google::ProtocolMessageReader::readByteArray<32ul>(uint64_t a1)
{
  uint64_t v1;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;

  if (*(_BYTE *)(a1 + 184))
  {
    if (*(_BYTE *)(a1 + 184) == 2)
    {
      detail::lazy_promise<ReadResult<unsigned char>>::result(*(_QWORD *)(a1 + 144) + 16);
      v4 = *v3;
      ReadStream::readByte(*(_QWORD *)(a1 + 144));
      if (HIDWORD(v4) == 1)
      {
        v5 = *(_QWORD *)(a1 + 136);
        *(_BYTE *)(a1 + 152 + v5) = v4;
        v6 = v5 + 1;
        if (v6 == 32)
        {
          v7 = *(_OWORD *)(a1 + 168);
          *(_OWORD *)(a1 + 32) = *(_OWORD *)(a1 + 152);
          *(_OWORD *)(a1 + 48) = v7;
          v8 = 1;
          goto LABEL_22;
        }
LABEL_20:
        *(_QWORD *)(a1 + 136) = v6;
        v16 = *(_QWORD *)(a1 + 72);
        v17 = operator new(0x50uLL);
        *(_QWORD *)(a1 + 144) = v17;
        *v17 = ReadStream::readByte;
        v17[1] = ReadStream::readByte;
        v17[8] = v16;
        *((_DWORD *)v17 + 6) = 0;
        *((_BYTE *)v17 + 72) = 0;
        *(_BYTE *)(a1 + 184) = 2;
        v17[2] = a1;
        return ReadStream::readByte((uint64_t)v17);
      }
      goto LABEL_21;
    }
    v9 = *(_QWORD *)(a1 + 120);
LABEL_10:
    detail::lazy_promise<std::optional<std::pair<std::shared_ptr<ReadStream>,unsigned long>>>::result(v9 + 16);
    *(_BYTE *)(a1 + 72) = 0;
    *(_BYTE *)(a1 + 96) = 0;
    v12 = *(unsigned __int8 *)(v10 + 24);
    if (*(_BYTE *)(v10 + 24))
    {
      v11 = *(_QWORD *)(v10 + 8);
      *(_QWORD *)(a1 + 72) = *(_QWORD *)v10;
      *(_QWORD *)(a1 + 80) = v11;
      if (v11)
      {
        v13 = (unint64_t *)(v11 + 8);
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      v1 = *(_QWORD *)(v10 + 16);
      *(_QWORD *)(a1 + 88) = v1;
      *(_BYTE *)(a1 + 96) = 1;
    }
    *(_BYTE *)(a1 + 185) = v12 == 0;
    *(_QWORD *)(a1 + 128) = v11;
    v15 = *(_QWORD *)(a1 + 104);
    if (v15)
      (*(void (**)(void))(v15 + 8))();
    if (v12 && v1 == 32)
    {
      v6 = 0;
      goto LABEL_20;
    }
LABEL_21:
    v8 = 0;
    *(_BYTE *)(a1 + 32) = 0;
LABEL_22:
    *(_BYTE *)(a1 + 64) = v8;
    *(_DWORD *)(a1 + 24) = 1;
    if ((*(_BYTE *)(a1 + 185) & 1) == 0)
    {
      v19 = *(_QWORD *)(a1 + 128);
      if (v19)
      {
        v20 = (unint64_t *)(v19 + 8);
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          v22 = *(std::__shared_weak_count **)(a1 + 128);
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
    }
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 184) = 3;
    v9 = *(_QWORD *)(a1 + 16);
    return (_QWORD *)(*(uint64_t (**)(void))v9)();
  }
  Backend::Google::ProtocolMessageReader::byteReaderAndLength(*(Backend::Google::ProtocolMessageReader **)(a1 + 112), (_QWORD *)(a1 + 104));
  v9 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 120) = v9;
  if (!v9)
  {
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  if (!*(_QWORD *)v9)
    goto LABEL_10;
  *(_BYTE *)(a1 + 184) = 1;
  *(_QWORD *)(v9 + 16) = a1;
  return (_QWORD *)(*(uint64_t (**)(void))v9)();
}

{
  uint64_t v1;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;

  if (*(_BYTE *)(a1 + 184))
  {
    if (*(_BYTE *)(a1 + 184) == 2)
    {
      detail::lazy_promise<ReadResult<unsigned char>>::result(*(_QWORD *)(a1 + 144) + 16);
      v4 = *v3;
      ReadStream::readByte(*(_QWORD *)(a1 + 144));
      if (HIDWORD(v4) == 1)
      {
        v5 = *(_QWORD *)(a1 + 136);
        *(_BYTE *)(a1 + 152 + v5) = v4;
        v6 = v5 + 1;
        if (v6 == 32)
        {
          v7 = *(_OWORD *)(a1 + 168);
          *(_OWORD *)(a1 + 32) = *(_OWORD *)(a1 + 152);
          *(_OWORD *)(a1 + 48) = v7;
          v8 = 1;
          goto LABEL_22;
        }
LABEL_20:
        *(_QWORD *)(a1 + 136) = v6;
        v16 = *(_QWORD *)(a1 + 72);
        v17 = operator new(0x50uLL);
        *(_QWORD *)(a1 + 144) = v17;
        *v17 = ReadStream::readByte;
        v17[1] = ReadStream::readByte;
        v17[8] = v16;
        *((_DWORD *)v17 + 6) = 0;
        *((_BYTE *)v17 + 72) = 0;
        *(_BYTE *)(a1 + 184) = 2;
        v17[2] = a1;
        return ReadStream::readByte((uint64_t)v17);
      }
      goto LABEL_21;
    }
    v9 = *(_QWORD *)(a1 + 120);
LABEL_10:
    detail::lazy_promise<std::optional<std::pair<std::shared_ptr<ReadStream>,unsigned long>>>::result(v9 + 16);
    *(_BYTE *)(a1 + 72) = 0;
    *(_BYTE *)(a1 + 96) = 0;
    v12 = *(unsigned __int8 *)(v10 + 24);
    if (*(_BYTE *)(v10 + 24))
    {
      v11 = *(_QWORD *)(v10 + 8);
      *(_QWORD *)(a1 + 72) = *(_QWORD *)v10;
      *(_QWORD *)(a1 + 80) = v11;
      if (v11)
      {
        v13 = (unint64_t *)(v11 + 8);
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      v1 = *(_QWORD *)(v10 + 16);
      *(_QWORD *)(a1 + 88) = v1;
      *(_BYTE *)(a1 + 96) = 1;
    }
    *(_BYTE *)(a1 + 185) = v12 == 0;
    *(_QWORD *)(a1 + 128) = v11;
    v15 = *(_QWORD *)(a1 + 104);
    if (v15)
      (*(void (**)(void))(v15 + 8))();
    if (v12 && v1 == 32)
    {
      v6 = 0;
      goto LABEL_20;
    }
LABEL_21:
    v8 = 0;
    *(_BYTE *)(a1 + 32) = 0;
LABEL_22:
    *(_BYTE *)(a1 + 64) = v8;
    *(_DWORD *)(a1 + 24) = 1;
    if ((*(_BYTE *)(a1 + 185) & 1) == 0)
    {
      v19 = *(_QWORD *)(a1 + 128);
      if (v19)
      {
        v20 = (unint64_t *)(v19 + 8);
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          v22 = *(std::__shared_weak_count **)(a1 + 128);
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
    }
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 184) = 3;
    v9 = *(_QWORD *)(a1 + 16);
    return (_QWORD *)(*(uint64_t (**)(void))v9)();
  }
  Backend::Google::ProtocolMessageReader::byteReaderAndLength(*(Backend::Google::ProtocolMessageReader **)(a1 + 112), (_QWORD *)(a1 + 104));
  v9 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 120) = v9;
  if (!v9)
  {
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  if (!*(_QWORD *)v9)
    goto LABEL_10;
  *(_BYTE *)(a1 + 184) = 1;
  *(_QWORD *)(v9 + 16) = a1;
  return (_QWORD *)(*(uint64_t (**)(void))v9)();
}

void sub_1DBCD31A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1 + 72);
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 184) = 3;
  _Unwind_Resume(a1);
}

void Backend::Google::ProtocolMessageReader::readByteArray<32ul>(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X10 }
}

void sub_1DBCD3224(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  v13 = *(_QWORD *)(v12 + 104);
  if (v13)
    (*(void (**)(void))(v13 + 8))();
  if (*(_DWORD *)(v12 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 + 32));
  operator delete((void *)v12);
}

void Backend::Google::FetchThreatListUpdatesResponseParser::parseChecksum(uint64_t a1)
{
  __asm { BR              X11 }
}

{
  __asm { BR              X10 }
}

_QWORD *sub_1DBCD32F4()
{
  uint64_t v0;
  _QWORD *v1;
  _OWORD *v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned __int8 *v8;
  int v9;
  char v10;
  int v11;
  char v12;
  char v13;
  char v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *result;

  v3 = *(_QWORD *)(v0 + 88);
  while (1)
  {
    detail::lazy_promise<ReadResult<unsigned int>>::result(v3 + 16);
    v5 = *v4;
    v6 = v4[1];
    *(_BYTE *)(v0 + 122) = HIBYTE(*v4);
    *(_WORD *)(v0 + 120) = v5 >> 8;
    *(_BYTE *)(v0 + 159) = v5;
    v7 = *(_QWORD *)(v0 + 72);
    if (v7)
      (*(void (**)(void))(v7 + 8))();
    if (v6 != 1)
      break;
    if (v5 == 1)
    {
      v15 = operator new(0xC0uLL);
      v16 = *(_QWORD *)(v0 + 80);
      *(_QWORD *)(v0 + 96) = v15;
      *v15 = Backend::Google::ProtocolMessageReader::readByteArray<32ul>;
      v15[1] = Backend::Google::ProtocolMessageReader::readByteArray<32ul>;
      v15[14] = v16;
      *((_DWORD *)v15 + 6) = 0;
      *((_BYTE *)v15 + 184) = 0;
      *(_BYTE *)(v0 + 155) = 2;
      v15[2] = v0;
      return Backend::Google::ProtocolMessageReader::readByteArray<32ul>((uint64_t)v15);
    }
    Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v0 + 80), v1);
    v3 = *(_QWORD *)(v0 + 72);
    *(_QWORD *)(v0 + 104) = v3;
    if (!v3)
      goto LABEL_24;
    if (*(_QWORD *)v3)
    {
      v14 = 3;
LABEL_22:
      *(_BYTE *)(v0 + 155) = v14;
      *(_QWORD *)(v3 + 16) = v0;
      return (_QWORD *)(*(uint64_t (**)(void))v3)();
    }
    detail::lazy_promise<BOOL>::result(v3 + 16);
    v9 = *v8;
    if (*v1)
      (*(void (**)(void))(*v1 + 8))();
    if (!v9)
      goto LABEL_17;
    v10 = *(_BYTE *)(v0 + 157);
    v11 = *(unsigned __int16 *)(v0 + 120) | (*(unsigned __int8 *)(v0 + 122) << 16);
    v12 = *(_BYTE *)(v0 + 159);
    *(_BYTE *)(v0 + 158) = *(_BYTE *)(v0 + 158);
    *(_BYTE *)(v0 + 157) = v10;
    *(_WORD *)(v0 + 116) = v11;
    *(_BYTE *)(v0 + 118) = BYTE2(v11);
    *(_BYTE *)(v0 + 156) = v12;
    *(_DWORD *)(v0 + 112) = 1;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v0 + 80), v1);
    v3 = *(_QWORD *)(v0 + 72);
    *(_QWORD *)(v0 + 88) = v3;
    if (!v3)
    {
LABEL_24:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*(_QWORD *)v3)
    {
      v14 = 1;
      goto LABEL_22;
    }
  }
  if (!v6)
  {
    if ((_BYTE)v5)
    {
      *(_BYTE *)(v0 + 32) = *(_BYTE *)(v0 + 157);
      *(_OWORD *)(v0 + 33) = *v2;
      *(_OWORD *)(v0 + 48) = *(_OWORD *)((char *)v2 + 15);
      v13 = *(_BYTE *)(v0 + 158);
    }
    else
    {
LABEL_17:
      v13 = 0;
      *(_BYTE *)(v0 + 32) = 0;
    }
    *(_BYTE *)(v0 + 64) = v13;
    *(_DWORD *)(v0 + 24) = 1;
    *(_QWORD *)v0 = 0;
    *(_BYTE *)(v0 + 155) = 4;
    v3 = *(_QWORD *)(v0 + 16);
    return (_QWORD *)(*(uint64_t (**)(void))v3)();
  }
  result = (_QWORD *)std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD350C()
{
  JUMPOUT(0x1DBCD3538);
}

void sub_1DBCD3520()
{
  _QWORD *v0;

  if (*v0)
    JUMPOUT(0x1DBCD3530);
  JUMPOUT(0x1DBCD3538);
}

void sub_1DBCD3578(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  char v13;
  __int16 v14;
  uint64_t v15;

  v13 = *(_BYTE *)(v12 + 156);
  v14 = *(_WORD *)(v12 + 116);
  *(_BYTE *)(v12 + 122) = *(_BYTE *)(v12 + 118);
  *(_WORD *)(v12 + 120) = v14;
  *(_BYTE *)(v12 + 159) = v13;
  v15 = *(_QWORD *)(v12 + 72);
  if (v15)
    (*(void (**)(void))(v15 + 8))();
  if (*(_DWORD *)(v12 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 + 32));
  operator delete((void *)v12);
}

uint64_t Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::CompressionType>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  Backend::Google::ProtocolMessageReader *v7;

  v2 = (_QWORD *)(a1 + 40);
  if (*(_BYTE *)(a1 + 64))
  {
    v3 = *(_QWORD *)(a1 + 56);
    goto LABEL_3;
  }
  v7 = *(Backend::Google::ProtocolMessageReader **)(a1 + 48);
  if (*(_DWORD *)v7 != 1)
    goto LABEL_12;
  Backend::Google::ProtocolMessageReader::readVarintField(v7, v2);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 56) = v3;
  if (!v3)
  {
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  if (!*(_QWORD *)v3)
  {
LABEL_3:
    detail::lazy_promise<std::optional<unsigned long long>>::result(v3 + 16);
    v5 = *(_DWORD *)v4;
    v6 = *(unsigned __int8 *)(v4 + 8);
    if (*v2)
      (*(void (**)(void))(*v2 + 8))();
    if (v6 && EnumTraits::isValidEnum<Backend::Google::CompressionType>(v5))
    {
      *(_DWORD *)(a1 + 32) = v5;
      *(_BYTE *)(a1 + 36) = 1;
LABEL_13:
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 64) = 2;
      v3 = *(_QWORD *)(a1 + 16);
      return (*(uint64_t (**)(void))v3)();
    }
LABEL_12:
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 36) = 0;
    goto LABEL_13;
  }
  *(_BYTE *)(a1 + 64) = 1;
  *(_QWORD *)(v3 + 16) = a1;
  return (*(uint64_t (**)(void))v3)();
}

void sub_1DBCD36B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 64) = 2;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::CompressionType>(std::exception_ptr *__p)
{
  void (**ptr)(void);

  if (LOBYTE(__p[8].__ptr_) == 1)
  {
    ptr = (void (**)(void))__p[5].__ptr_;
    if (ptr)
      ptr[1]();
  }
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

void Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<std::vector<unsigned int>>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(std::vector<unsigned int>&)#1}::operator()<Backend::Google::ProtocolMessageReader>(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X11 }
}

void sub_1DBCD3798(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::vector<unsigned int> *a13, int a14, int a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  int v27;
  unsigned __int8 *v28;
  uint64_t v29;
  _QWORD *v30;
  int v31;
  int v32;
  _QWORD *v33;
  unint64_t v34;
  int v35;
  uint64_t v36;
  unint64_t v37;
  int v38;
  unsigned __int8 v39;
  int v40;
  int v41;
  int v42;
  __n128 *v43;
  __n128 v44;
  uint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  void (**v49)(__n128);
  unsigned int *v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  unint64_t *v54;
  BOOL v55;
  unint64_t *v56;
  BOOL v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  __n128 *v68;
  std::__shared_weak_count *v69;
  unint64_t *p_shared_owners;
  unint64_t v71;
  int v72;
  int v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t *v77;
  unsigned __int8 *v78;
  int v79;
  std::vector<unsigned int>::pointer begin;
  char v81;
  _QWORD *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  std::vector<unsigned int> *v86;
  int v87;

  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v28[64] = 0;
  v28[88] = 0;
  while (1)
  {
    *((_DWORD *)v28 + 71) = v42;
    *((_DWORD *)v28 + 70) = v41;
    *((_DWORD *)v28 + 69) = v40;
    *(_WORD *)v36 = v27;
    *(_BYTE *)(v36 + 2) = BYTE2(v27);
    v28[296] = v39;
    *((_DWORD *)v28 + 67) = v38;
    v28[295] = v35;
    *((_QWORD *)v28 + 23) = v29;
    *((_QWORD *)v28 + 24) = v37;
    v28[294] = v31;
    v28[293] = v32;
    *((_QWORD *)v28 + 22) = v34;
    Backend::Google::ProtocolMessageReader::nextField(*((Backend::Google::ProtocolMessageReader **)v28 + 21), v30);
    v49 = (void (**)(__n128))*((_QWORD *)v28 + 12);
    *((_QWORD *)v28 + 25) = v49;
    if (!v49)
      goto LABEL_112;
    if (*v49)
    {
      v81 = 1;
      goto LABEL_110;
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result((uint64_t)(v49 + 2));
    v51 = *v50;
    v52 = v50[1];
    *(_BYTE *)(v36 + 18) = HIBYTE(*v50);
    *(_WORD *)(v36 + 16) = v51 >> 8;
    v28[297] = v51;
    v53 = *((_QWORD *)v28 + 12);
    if (v53)
      (*(void (**)(void))(v53 + 8))();
    if (v52 != 1)
      break;
    switch(v51)
    {
      case 1u:
        Backend::Google::ProtocolMessageReader::readVarintField(*((Backend::Google::ProtocolMessageReader **)v28 + 21), v30);
        v49 = (void (**)(__n128))*((_QWORD *)v28 + 12);
        *((_QWORD *)v28 + 26) = v49;
        if (!v49)
          goto LABEL_112;
        if (*v49)
        {
          v81 = 2;
          goto LABEL_110;
        }
        detail::lazy_promise<std::optional<unsigned long long>>::result((uint64_t)(v49 + 2));
        v37 = *v54;
        v35 = *((unsigned __int8 *)v54 + 8);
        if (*v30)
          (*(void (**)(void))(*v30 + 8))();
        if (v35)
          v55 = HIDWORD(v37) == 0;
        else
          v55 = 0;
        if (!v55)
          goto LABEL_90;
        v42 = *((_DWORD *)v28 + 71);
        v40 = *((_DWORD *)v28 + 69);
        LOBYTE(v31) = v28[294];
        LOBYTE(v32) = v28[293];
        v41 = v37;
        goto LABEL_83;
      case 2u:
        Backend::Google::ProtocolMessageReader::readVarintField(*((Backend::Google::ProtocolMessageReader **)v28 + 21), v30);
        v49 = (void (**)(__n128))*((_QWORD *)v28 + 12);
        *((_QWORD *)v28 + 27) = v49;
        if (!v49)
          goto LABEL_112;
        if (*v49)
        {
          v81 = 3;
          goto LABEL_110;
        }
        detail::lazy_promise<std::optional<unsigned long long>>::result((uint64_t)(v49 + 2));
        v29 = *v77;
        v31 = *((unsigned __int8 *)v77 + 8);
        if (*v30)
          (*(void (**)(void))(*v30 + 8))();
        if (!v31 || (unint64_t)(v29 - 29) <= 0xFFFFFFFFFFFFFFE4)
          goto LABEL_90;
        v42 = *((_DWORD *)v28 + 71);
        v41 = *((_DWORD *)v28 + 70);
        LOBYTE(v35) = v28[295];
        v37 = *((_QWORD *)v28 + 24);
        LOBYTE(v32) = v28[293];
        v40 = v29;
        v34 = *((_QWORD *)v28 + 22);
        goto LABEL_84;
      case 3u:
        Backend::Google::ProtocolMessageReader::readVarintField(*((Backend::Google::ProtocolMessageReader **)v28 + 21), v30);
        v49 = (void (**)(__n128))*((_QWORD *)v28 + 12);
        *((_QWORD *)v28 + 28) = v49;
        if (!v49)
          goto LABEL_112;
        if (*v49)
        {
          v81 = 4;
          goto LABEL_110;
        }
        detail::lazy_promise<std::optional<unsigned long long>>::result((uint64_t)(v49 + 2));
        v34 = *v56;
        v32 = *((unsigned __int8 *)v56 + 8);
        if (*v30)
          (*(void (**)(void))(*v30 + 8))();
        if (v32)
          v57 = HIDWORD(v34) == 0;
        else
          v57 = 0;
        if (!v57)
          goto LABEL_90;
        v42 = v34 + 1;
        v41 = *((_DWORD *)v28 + 70);
        v40 = *((_DWORD *)v28 + 69);
        LOBYTE(v35) = v28[295];
        LOBYTE(v31) = v28[294];
        v29 = *((_QWORD *)v28 + 23);
        v37 = *((_QWORD *)v28 + 24);
        goto LABEL_84;
      case 4u:
        Backend::Google::ProtocolMessageReader::riceDecompressor(*((Backend::Google::ProtocolMessageReader **)v28 + 21), *((_DWORD *)v28 + 70), *((_DWORD *)v28 + 69), v33);
        v49 = (void (**)(__n128))*((_QWORD *)v28 + 19);
        *((_QWORD *)v28 + 29) = v49;
        if (!v49)
          goto LABEL_112;
        if (*v49)
        {
          v81 = 5;
          goto LABEL_110;
        }
        detail::lazy_promise<std::optional<std::shared_ptr<RiceDecompressor>>>::result((uint64_t)(v49 + 2));
        v59 = 0;
        v28[96] = 0;
        v28[112] = 0;
        if (*(_BYTE *)(v58 + 16))
        {
          v60 = *(_QWORD *)(v58 + 8);
          *((_QWORD *)v28 + 12) = *(_QWORD *)v58;
          *((_QWORD *)v28 + 13) = v60;
          if (v60)
          {
            v61 = (unint64_t *)(v60 + 8);
            do
              v62 = __ldxr(v61);
            while (__stxr(v62 + 1, v61));
          }
          v59 = 1;
          v28[112] = 1;
        }
        if (*v33)
        {
          (*(void (**)(void))(*v33 + 8))();
          v59 = v28[112];
        }
        if (!v59)
          goto LABEL_61;
        v63 = *((_QWORD *)v28 + 13);
        *((_QWORD *)v28 + 17) = *((_QWORD *)v28 + 12);
        *((_QWORD *)v28 + 18) = v63;
        if (v63)
        {
          v64 = (unint64_t *)(v63 + 8);
          do
            v65 = __ldxr(v64);
          while (__stxr(v65 + 1, v64));
        }
        v66 = *((_QWORD *)v28 + 20);
        *((_DWORD *)v28 + 66) = *((_DWORD *)v28 + 71);
        v67 = *(_QWORD *)(v66 + 24);
        if (!v67)
          goto LABEL_114;
        (*(void (**)(uint64_t))(*(_QWORD *)v67 + 48))(v67);
        v49 = (void (**)(__n128))*((_QWORD *)v28 + 19);
        *((_QWORD *)v28 + 30) = v49;
        if (!v49)
          goto LABEL_112;
        if (*v49)
        {
          v81 = 6;
          goto LABEL_110;
        }
        detail::lazy_promise<std::optional<std::vector<unsigned int>>>::result((uint64_t)(v49 + 2));
        v44 = std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:sn180100]<std::__optional_move_assign_base<std::vector<unsigned int>,false>>(v86, v68);
        if (*v33)
          (*(void (**)(__n128))(*v33 + 8))(v44);
        v69 = (std::__shared_weak_count *)*((_QWORD *)v28 + 18);
        if (v69)
        {
          p_shared_owners = (unint64_t *)&v69->__shared_owners_;
          do
            v71 = __ldaxr(p_shared_owners);
          while (__stlxr(v71 - 1, p_shared_owners));
          if (!v71)
          {
            ((void (*)(std::__shared_weak_count *, __n128))v69->__on_zero_shared)(v69, v44);
            std::__shared_weak_count::__release_weak(v69);
          }
        }
        v72 = 6;
        v73 = 1;
        if (!v28[88])
        {
LABEL_61:
          v73 = 0;
          v28[32] = 0;
          v28[56] = 0;
          *((_DWORD *)v28 + 6) = 1;
          v72 = 3;
        }
        if (v28[112])
        {
          v74 = (std::__shared_weak_count *)*((_QWORD *)v28 + 13);
          if (v74)
          {
            v75 = (unint64_t *)&v74->__shared_owners_;
            do
              v76 = __ldaxr(v75);
            while (__stlxr(v76 - 1, v75));
            if (!v76)
            {
              ((void (*)(std::__shared_weak_count *, __n128))v74->__on_zero_shared)(v74, v44);
              std::__shared_weak_count::__release_weak(v74);
            }
          }
        }
        if (!v73)
          goto LABEL_93;
        goto LABEL_82;
      default:
        Backend::Google::ProtocolMessageReader::skipField(*((Backend::Google::ProtocolMessageReader **)v28 + 21), v30);
        v49 = (void (**)(__n128))*((_QWORD *)v28 + 12);
        *((_QWORD *)v28 + 31) = v49;
        if (!v49)
          goto LABEL_112;
        if (*v49)
        {
          v81 = 7;
LABEL_110:
          *(_BYTE *)(v36 + 20) = v81;
          v49[2] = (void (*)(__n128))v28;
LABEL_111:
          (*v49)(v44);
          return;
        }
        detail::lazy_promise<BOOL>::result((uint64_t)(v49 + 2));
        v79 = *v78;
        if (*v30)
          (*(void (**)(void))(*v30 + 8))();
        if (!v79)
          goto LABEL_90;
LABEL_82:
        v42 = *((_DWORD *)v28 + 71);
        v41 = *((_DWORD *)v28 + 70);
        v40 = *((_DWORD *)v28 + 69);
        LOBYTE(v35) = v28[295];
        v37 = *((_QWORD *)v28 + 24);
        LOBYTE(v31) = v28[294];
        LOBYTE(v32) = v28[293];
LABEL_83:
        v34 = *((_QWORD *)v28 + 22);
        v29 = *((_QWORD *)v28 + 23);
LABEL_84:
        v27 = *(unsigned __int16 *)(v36 + 16) | (*(unsigned __int8 *)(v36 + 18) << 16);
        v39 = v28[297];
        v38 = 1;
        break;
    }
  }
  if (v52)
  {
    std::__throw_bad_variant_access[abi:sn180100]();
    goto LABEL_115;
  }
  if ((_BYTE)v51)
  {
    if (*((_DWORD *)v28 + 71))
    {
      v28[32] = 0;
      v28[56] = 0;
      if (v28[88])
      {
        v44 = *((__n128 *)v28 + 4);
        *((__n128 *)v28 + 2) = v44;
        *((_QWORD *)v28 + 6) = *((_QWORD *)v28 + 10);
        v86->__end_ = 0;
        v86->__end_cap_.__value_ = 0;
        v86->__begin_ = 0;
        v28[56] = 1;
      }
      goto LABEL_91;
    }
    v82 = operator new(0x30uLL);
    v83 = *((_QWORD *)v28 + 20);
    v82[1] = 0;
    v82[2] = 0;
    *v82 = off_1EA3EB8B0;
    v82[3] = *(_QWORD *)(v36 + 4);
    v82[4] = 0;
    v82[5] = 0;
    *((_QWORD *)v28 + 15) = v82 + 3;
    *((_QWORD *)v28 + 16) = v82;
    v87 = 1;
    v84 = *(_QWORD *)(v83 + 24);
    if (v84)
    {
      (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)v84 + 48))(v84, v85, &v87);
      v49 = (void (**)(__n128))*((_QWORD *)v28 + 12);
      *((_QWORD *)v28 + 32) = v49;
      if (!v49)
      {
LABEL_112:
        MEMORY[0xDEADDEAD] = 0;
        std::terminate();
      }
      if (*v49)
      {
        v81 = 8;
        goto LABEL_110;
      }
      detail::lazy_promise<std::optional<std::vector<unsigned int>>>::result((uint64_t)(v49 + 2));
      v28[32] = 0;
      v28[56] = 0;
      if (v43[1].n128_u8[8])
      {
        *((_QWORD *)v28 + 4) = 0;
        *((_QWORD *)v28 + 5) = 0;
        *((_QWORD *)v28 + 6) = 0;
        v44 = *v43;
        *((__n128 *)v28 + 2) = *v43;
        *((_QWORD *)v28 + 6) = v43[1].n128_u64[0];
        v43->n128_u64[0] = 0;
        v43->n128_u64[1] = 0;
        v43[1].n128_u64[0] = 0;
        v28[56] = 1;
      }
      *((_DWORD *)v28 + 6) = 1;
      v45 = *((_QWORD *)v28 + 12);
      if (v45)
        (*(void (**)(void))(v45 + 8))();
      v46 = (std::__shared_weak_count *)*((_QWORD *)v28 + 16);
      if (v46)
      {
        v47 = (unint64_t *)&v46->__shared_owners_;
        do
          v48 = __ldaxr(v47);
        while (__stlxr(v48 - 1, v47));
        if (!v48)
        {
          ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
          std::__shared_weak_count::__release_weak(v46);
        }
      }
      goto LABEL_92;
    }
LABEL_114:
    std::__throw_bad_function_call[abi:sn180100]();
LABEL_115:
    __break(1u);
    return;
  }
LABEL_90:
  v28[32] = 0;
  v28[56] = 0;
LABEL_91:
  *((_DWORD *)v28 + 6) = 1;
LABEL_92:
  v72 = 3;
LABEL_93:
  if (v28[88])
  {
    begin = v86->__begin_;
    if (v86->__begin_)
    {
      *((_QWORD *)v28 + 9) = begin;
      operator delete(begin);
    }
  }
  if (v72 == 3)
  {
    *(_QWORD *)v28 = 0;
    *(_BYTE *)(v36 + 20) = 9;
    v49 = (void (**)(__n128))*((_QWORD *)v28 + 2);
    goto LABEL_111;
  }
  detail::lazy_promise<std::optional<std::vector<unsigned int>>>::~lazy_promise((uint64_t)(v28 + 16));
  operator delete(v28);
}

void sub_1DBCD3EA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a12);
  JUMPOUT(0x1DBCD3EE4);
}

void sub_1DBCD3EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  void *v17;

  if (!*v14)
  {
    if (*(_BYTE *)(v13 + 88))
    {
      v17 = *a13;
      if (*a13)
      {
        *(_QWORD *)(v13 + 72) = v17;
        operator delete(v17);
      }
    }
    *(_QWORD *)v13 = 0;
    *(_BYTE *)(v15 + 20) = 9;
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1DBCD3F08);
}

void sub_1DBCD3F78(__int16 *a1@<X8>)
{
  uint64_t v1;
  char v2;
  __int16 v3;
  uint64_t v4;
  void *v5;

  v2 = *(_BYTE *)(v1 + 296);
  v3 = *a1;
  *((_BYTE *)a1 + 18) = *((_BYTE *)a1 + 2);
  a1[8] = v3;
  *(_BYTE *)(v1 + 297) = v2;
  v4 = *(_QWORD *)(v1 + 96);
  if (v4)
    (*(void (**)(void))(v4 + 8))();
  if (*(_BYTE *)(v1 + 88))
  {
    v5 = *(void **)(v1 + 64);
    if (v5)
    {
      *(_QWORD *)(v1 + 72) = v5;
      operator delete(v5);
    }
  }
  detail::lazy_promise<std::optional<std::vector<unsigned int>>>::~lazy_promise(v1 + 16);
  operator delete((void *)v1);
}

void sub_1DBCD3FD0()
{
  uint64_t v0;

  if (!*(_QWORD *)(v0 + 152))
    JUMPOUT(0x1DBCD3FA0);
  JUMPOUT(0x1DBCD3F98);
}

void sub_1DBCD3FDC()
{
  uint64_t v0;
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  v1 = *(_QWORD *)(v0 + 152);
  if (v1)
    (*(void (**)(void))(v1 + 8))();
  v2 = *(std::__shared_weak_count **)(v0 + 144);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  if (*(_BYTE *)(v0 + 112))
  {
    v5 = *(std::__shared_weak_count **)(v0 + 104);
    if (v5)
    {
      v6 = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  JUMPOUT(0x1DBCD3FA0);
}

_QWORD *BitProvider::nextBit(uint64_t a1)
{
  uint64_t v2;
  unsigned __int8 *v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  char v8;
  uint64_t *v9;
  uint64_t v10;
  _QWORD *result;
  int v12;

  v2 = a1 + 40;
  if (*(_BYTE *)(a1 + 128))
  {
    detail::lazy_promise<ReadResult<unsigned char>>::result(a1 + 56);
    v4 = *v3;
    v5 = *((_DWORD *)v3 + 1);
    ReadStream::readByte(v2);
    if (v5)
    {
      if (v5 != 1)
      {
        result = (_QWORD *)std::__throw_bad_variant_access[abi:sn180100]();
        __break(1u);
        return result;
      }
      v6 = *(_QWORD *)(a1 + 120);
      *(_BYTE *)(v6 + 16) = v4;
      v7 = 1;
      *(_BYTE *)(v6 + 17) = 1;
      v8 = v4 & 1;
    }
    else
    {
      v7 = 0;
      v8 = v4 != 0;
    }
    *(_BYTE *)(a1 + 32) = v8;
  }
  else
  {
    v9 = *(uint64_t **)(a1 + 120);
    switch(*((_BYTE *)v9 + 17))
    {
      case 0:
        v10 = *v9;
        *(_QWORD *)(a1 + 40) = ReadStream::readByte;
        *(_QWORD *)(a1 + 48) = ReadStream::readByte;
        *(_QWORD *)(a1 + 104) = v10;
        *(_DWORD *)(a1 + 64) = 0;
        *(_BYTE *)(a1 + 112) = 0;
        *(_BYTE *)(a1 + 128) = 1;
        *(_QWORD *)(a1 + 56) = a1;
        return ReadStream::readByte(a1 + 40);
      case 1:
        *((_BYTE *)v9 + 17) = 2;
        v12 = (*((unsigned __int8 *)v9 + 16) >> 1) & 1;
        goto LABEL_16;
      case 2:
        *((_BYTE *)v9 + 17) = 3;
        v12 = (*((unsigned __int8 *)v9 + 16) >> 2) & 1;
        goto LABEL_16;
      case 3:
        *((_BYTE *)v9 + 17) = 4;
        v12 = (*((unsigned __int8 *)v9 + 16) >> 3) & 1;
        goto LABEL_16;
      case 4:
        *((_BYTE *)v9 + 17) = 5;
        v12 = (*((unsigned __int8 *)v9 + 16) >> 4) & 1;
        goto LABEL_16;
      case 5:
        *((_BYTE *)v9 + 17) = 6;
        v12 = (*((unsigned __int8 *)v9 + 16) >> 5) & 1;
        goto LABEL_16;
      case 6:
        *((_BYTE *)v9 + 17) = 7;
        v12 = (*((unsigned __int8 *)v9 + 16) >> 6) & 1;
        goto LABEL_16;
      case 7:
        *((_BYTE *)v9 + 17) = 0;
        v12 = *((unsigned __int8 *)v9 + 16) >> 7;
LABEL_16:
        *(_BYTE *)(a1 + 32) = v12;
        v7 = 1;
        break;
      default:
        goto LABEL_18;
    }
  }
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 24) = 1;
LABEL_18:
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 128) = 2;
  return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
}

void sub_1DBCD4238(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 128) = 2;
  _Unwind_Resume(exception_object);
}

void BitProvider::nextBit(void *__p)
{
  if (*((_BYTE *)__p + 128) == 1)
    ReadStream::readByte((uint64_t)__p + 40);
  if (*((_DWORD *)__p + 6) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)__p + 4);
  operator delete(__p);
}

_QWORD *RiceDecompressor::decodeQuotient(uint64_t a1)
{
  int v2;
  unint64_t *v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  _QWORD *v7;
  char v9;

  v2 = *(unsigned __int8 *)(a1 + 60);
  if (!*(_BYTE *)(a1 + 60))
    goto LABEL_5;
  detail::lazy_promise<ReadResult<BOOL>>::result(*(_QWORD *)(a1 + 48) + 16);
  v4 = *v3;
  BitProvider::nextBit(*(void **)(a1 + 48));
  if (HIDWORD(v4) == 1)
  {
    v5 = *(_DWORD *)(a1 + 56);
    if ((_BYTE)v4)
    {
      v2 = v5 + 1;
LABEL_5:
      *(_DWORD *)(a1 + 56) = v2;
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v7 = operator new(0x88uLL);
      *(_QWORD *)(a1 + 48) = v7;
      *v7 = BitProvider::nextBit;
      v7[1] = BitProvider::nextBit;
      v7[15] = v6;
      *((_DWORD *)v7 + 6) = 0;
      *((_BYTE *)v7 + 128) = 0;
      *(_BYTE *)(a1 + 60) = 1;
      v7[2] = a1;
      return BitProvider::nextBit((uint64_t)v7);
    }
    *(_DWORD *)(a1 + 32) = v5;
    v9 = 1;
  }
  else
  {
    v9 = 0;
    *(_BYTE *)(a1 + 32) = 0;
  }
  *(_BYTE *)(a1 + 36) = v9;
  *(_DWORD *)(a1 + 24) = 1;
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 60) = 2;
  return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
}

void sub_1DBCD4388(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 60) = 2;
  _Unwind_Resume(exception_object);
}

void RiceDecompressor::decodeQuotient(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 60) == 1)
    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 8))();
  if (*(_DWORD *)(a1 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 32));
}

_QWORD *RiceDecompressor::decodeRemainder(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  unsigned __int8 v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  char v11;

  if (!*(_BYTE *)(a1 + 64))
  {
    v4 = *(_QWORD *)(a1 + 40);
    v5 = *(_DWORD *)v4;
    if (*(_DWORD *)v4)
    {
      v7 = 0;
      v6 = 0;
      v5 = 0;
      goto LABEL_7;
    }
    goto LABEL_9;
  }
  detail::lazy_promise<ReadResult<BOOL>>::result(*(_QWORD *)(a1 + 48) + 16);
  v3 = *v2;
  BitProvider::nextBit(*(void **)(a1 + 48));
  if (HIDWORD(v3) == 1)
  {
    v4 = *(_QWORD *)(a1 + 40);
    v5 = (v3 << *(_DWORD *)(a1 + 56)) | *(_DWORD *)(a1 + 60);
    v6 = *(_BYTE *)(a1 + 65) + 1;
    if (*(_DWORD *)v4 > v6)
    {
      v7 = (*(_BYTE *)(a1 + 65) + 1);
LABEL_7:
      *(_BYTE *)(a1 + 65) = v6;
      *(_DWORD *)(a1 + 56) = v7;
      *(_DWORD *)(a1 + 60) = v5;
      v8 = *(_QWORD *)(v4 + 8);
      v9 = operator new(0x88uLL);
      *(_QWORD *)(a1 + 48) = v9;
      *v9 = BitProvider::nextBit;
      v9[1] = BitProvider::nextBit;
      v9[15] = v8;
      *((_DWORD *)v9 + 6) = 0;
      *((_BYTE *)v9 + 128) = 0;
      *(_BYTE *)(a1 + 64) = 1;
      v9[2] = a1;
      return BitProvider::nextBit((uint64_t)v9);
    }
LABEL_9:
    *(_DWORD *)(a1 + 32) = v5;
    v11 = 1;
    goto LABEL_10;
  }
  v11 = 0;
  *(_BYTE *)(a1 + 32) = 0;
LABEL_10:
  *(_BYTE *)(a1 + 36) = v11;
  *(_DWORD *)(a1 + 24) = 1;
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 64) = 2;
  return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
}

void sub_1DBCD451C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 64) = 2;
  _Unwind_Resume(exception_object);
}

void RiceDecompressor::decodeRemainder(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64) == 1)
    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 8))();
  if (*(_DWORD *)(a1 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 32));
}

_QWORD *RiceDecompressor::decompress4Bytes(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  char v12;
  uint64_t v13;

  v2 = a1 + 40;
  v3 = *(unsigned __int8 *)(a1 + 192);
  if (v3 != 2)
  {
    if (v3 != 1)
    {
      v13 = *(_QWORD *)(a1 + 176);
      *(_QWORD *)(a1 + 112) = RiceDecompressor::decodeQuotient;
      *(_QWORD *)(a1 + 120) = RiceDecompressor::decodeQuotient;
      *(_QWORD *)(a1 + 152) = v13;
      *(_DWORD *)(a1 + 136) = 0;
      *(_BYTE *)(a1 + 172) = 0;
      *(_BYTE *)(a1 + 192) = 1;
      *(_QWORD *)(a1 + 128) = a1;
      return RiceDecompressor::decodeQuotient(a1 + 112);
    }
    detail::lazy_promise<std::optional<unsigned int>>::result(a1 + 128);
    v5 = *v4;
    *(_QWORD *)(a1 + 184) = *v4;
    if (*(_BYTE *)(a1 + 172) == 1)
      (*(void (**)(void))(*(_QWORD *)(a1 + 160) + 8))();
    if (*(_DWORD *)(a1 + 136) == 2)
      std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 144));
    if ((v5 & 0xFF00000000) != 0)
    {
      v6 = *(_QWORD *)(a1 + 176);
      *(_QWORD *)(a1 + 40) = RiceDecompressor::decodeRemainder;
      *(_QWORD *)(a1 + 48) = RiceDecompressor::decodeRemainder;
      *(_QWORD *)(a1 + 80) = v6;
      *(_DWORD *)(a1 + 64) = 0;
      *(_BYTE *)(a1 + 104) = 0;
      *(_BYTE *)(a1 + 192) = 2;
      *(_QWORD *)(a1 + 56) = a1;
      return RiceDecompressor::decodeRemainder(v2);
    }
    goto LABEL_16;
  }
  detail::lazy_promise<std::optional<unsigned int>>::result(a1 + 56);
  v9 = *v8;
  if (*(_BYTE *)(a1 + 104) == 1)
    (*(void (**)(void))(*(_QWORD *)(a1 + 88) + 8))();
  if (*(_DWORD *)(a1 + 64) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 72));
  if ((v9 & 0xFF00000000) == 0)
  {
LABEL_16:
    v12 = 0;
    *(_BYTE *)(a1 + 32) = 0;
    goto LABEL_17;
  }
  v10 = *(_DWORD **)(a1 + 176);
  v11 = (*(_DWORD *)(a1 + 184) << *v10) + v9 + v10[1];
  v10[1] = v11;
  *(_DWORD *)(a1 + 32) = v11;
  v12 = 1;
LABEL_17:
  *(_BYTE *)(a1 + 36) = v12;
  *(_DWORD *)(a1 + 24) = 1;
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 192) = 3;
  return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
}

void sub_1DBCD4734(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  RiceDecompressor::decodeRemainder(v2);
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 192) = 3;
  _Unwind_Resume(a1);
}

void RiceDecompressor::decompress4Bytes(uint64_t a1)
{
  __asm { BR              X10 }
}

void sub_1DBCD4790(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;

  if (*(_BYTE *)(v12 + 172) == 1)
    (*(void (**)(void))(*(_QWORD *)(v12 + 160) + 8))();
  if (*(_DWORD *)(v12 + 136) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 + 144));
  if (*(_DWORD *)(v12 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 + 32));
  operator delete((void *)v12);
}

_QWORD *Backend::Google::readRemovalIndices(uint64_t a1)
{
  _QWORD *v2;
  uint64_t *v3;
  uint64_t v4;
  _QWORD *result;
  unint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  std::vector<unsigned int>::size_type v9;
  unint64_t v10;
  int v11;
  _DWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  char *v19;
  _DWORD *v20;
  char *v21;
  char *j;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  char *v32;
  _DWORD *v33;
  char *v34;
  char *i;
  int v36;
  unsigned int v37;
  _QWORD *v38;
  uint64_t v39;

  v2 = (_QWORD *)(a1 + 64);
  if (!*(_BYTE *)(a1 + 140))
  {
    v9 = *(unsigned int *)(a1 + 136);
    *(_QWORD *)(a1 + 72) = 0;
    *(_QWORD *)(a1 + 80) = 0;
    *v2 = 0;
    std::vector<unsigned int>::reserve((std::vector<unsigned int> *)(a1 + 64), v9);
    result = (_QWORD *)(a1 + 80);
    v10 = *(_QWORD *)(a1 + 80);
    v11 = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 4);
    v12 = *(_DWORD **)(a1 + 72);
    if ((unint64_t)v12 >= v10)
    {
      v27 = ((uint64_t)v12 - *v2) >> 2;
      if ((unint64_t)(v27 + 1) >> 62)
        abort();
      v28 = v10 - *v2;
      v29 = v28 >> 1;
      if (v28 >> 1 <= (unint64_t)(v27 + 1))
        v29 = v27 + 1;
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL)
        v30 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v30 = v29;
      if (!v30)
        goto LABEL_46;
      result = std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::CompressionType>>((uint64_t)result, v30);
      if (!result)
        goto LABEL_46;
      v32 = (char *)result + 4 * v31;
      v33 = (_DWORD *)result + v27;
      *v33 = v11;
      v8 = v33 + 1;
      v34 = *(char **)(a1 + 64);
      for (i = *(char **)(a1 + 72); i != v34; i -= 4)
      {
        v36 = *((_DWORD *)i - 1);
        *--v33 = v36;
      }
      *(_QWORD *)(a1 + 64) = v33;
      *(_QWORD *)(a1 + 72) = v8;
      *(_QWORD *)(a1 + 80) = v32;
      if (v34)
        operator delete(v34);
    }
    else
    {
      if (!v12)
        goto LABEL_46;
      *v12 = v11;
      v8 = v12 + 1;
    }
    v37 = *(_DWORD *)(a1 + 136);
    *(_QWORD *)(a1 + 72) = v8;
    if (v37 <= 1)
    {
LABEL_42:
      *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 64);
      *(_QWORD *)(a1 + 40) = v8;
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 80);
      *(_BYTE *)(a1 + 56) = 1;
      *(_DWORD *)(a1 + 24) = 1;
LABEL_43:
      *(_QWORD *)a1 = 0;
      *(_BYTE *)(a1 + 140) = 2;
      return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
    }
    v26 = 1;
LABEL_41:
    *(_QWORD *)(a1 + 120) = v26;
    v38 = operator new(0xC8uLL);
    v39 = *(_QWORD *)(a1 + 104);
    *(_QWORD *)(a1 + 128) = v38;
    *v38 = RiceDecompressor::decompress4Bytes;
    v38[1] = RiceDecompressor::decompress4Bytes;
    v38[22] = v39;
    *((_DWORD *)v38 + 6) = 0;
    *((_BYTE *)v38 + 192) = 0;
    *(_BYTE *)(a1 + 140) = 1;
    v38[2] = a1;
    return RiceDecompressor::decompress4Bytes((uint64_t)v38);
  }
  detail::lazy_promise<std::optional<unsigned int>>::result(*(_QWORD *)(a1 + 128) + 16);
  v4 = *v3;
  RiceDecompressor::decompress4Bytes(*(_QWORD *)(a1 + 128));
  if ((v4 & 0xFF00000000) == 0)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 24) = 1;
    v13 = *(void **)(a1 + 64);
    if (v13)
    {
      *(_QWORD *)(a1 + 72) = v13;
      operator delete(v13);
    }
    goto LABEL_43;
  }
  result = (_QWORD *)(a1 + 80);
  v6 = *(_QWORD *)(a1 + 80);
  v7 = *(_DWORD **)(a1 + 72);
  if ((unint64_t)v7 >= v6)
  {
    v14 = ((uint64_t)v7 - *v2) >> 2;
    if ((unint64_t)(v14 + 1) >> 62)
      abort();
    v15 = v6 - *v2;
    v16 = v15 >> 1;
    if (v15 >> 1 <= (unint64_t)(v14 + 1))
      v16 = v14 + 1;
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL)
      v17 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v17 = v16;
    if (v17)
    {
      result = std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::CompressionType>>((uint64_t)result, v17);
      if (result)
      {
        v19 = (char *)result + 4 * v18;
        v20 = (_DWORD *)result + v14;
        *v20 = v4;
        v8 = v20 + 1;
        v21 = *(char **)(a1 + 64);
        for (j = *(char **)(a1 + 72); j != v21; j -= 4)
        {
          v23 = *((_DWORD *)j - 1);
          *--v20 = v23;
        }
        *(_QWORD *)(a1 + 64) = v20;
        *(_QWORD *)(a1 + 72) = v8;
        *(_QWORD *)(a1 + 80) = v19;
        if (v21)
          operator delete(v21);
LABEL_24:
        v24 = *(_QWORD *)(a1 + 120);
        v25 = *(unsigned int *)(a1 + 136);
        *(_QWORD *)(a1 + 72) = v8;
        v26 = v24 + 1;
        if (v26 == v25)
          goto LABEL_42;
        goto LABEL_41;
      }
    }
  }
  else if (v7)
  {
    *v7 = v4;
    v8 = v7 + 1;
    goto LABEL_24;
  }
LABEL_46:
  __break(1u);
  return result;
}

void sub_1DBCD4A98(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 72) = v4;
    operator delete(v4);
  }
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 140) = 2;
  _Unwind_Resume(exception_object);
}

void Backend::Google::readRemovalIndices(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;

  v2 = a1 + 16;
  if (*(_BYTE *)(a1 + 140) == 1)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 128) + 8))();
    v3 = *(void **)(a1 + 64);
    if (v3)
    {
      *(_QWORD *)(a1 + 72) = v3;
      operator delete(v3);
    }
  }
  v4 = *(_QWORD *)(a1 + 112);
  detail::lazy_promise<std::optional<std::vector<unsigned int>>>::~lazy_promise(v2);
  if (v4)
  {
    v5 = (unint64_t *)(*(_QWORD *)(a1 + 112) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      v7 = *(std::__shared_weak_count **)(a1 + 112);
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  operator delete((void *)a1);
}

void Backend::Google::FetchThreatListUpdatesResponseParser::parseRawIndices(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X10 }
}

uint64_t sub_1DBCD4BBC()
{
  int v0;
  uint64_t v1;
  void **v2;
  _QWORD *v3;
  int v4;
  char v5;
  uint64_t (**v6)(void);
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  Backend::Google::ProtocolMessageReader *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  void *v16;
  char v17;
  uint64_t result;

  v4 = 0;
  v5 = 0;
  *(_BYTE *)(v1 + 64) = 0;
  *(_BYTE *)(v1 + 88) = 0;
  while (1)
  {
    *(_WORD *)(v1 + 140) = v0;
    *(_BYTE *)(v1 + 142) = BYTE2(v0);
    *(_BYTE *)(v1 + 149) = v5;
    *(_DWORD *)(v1 + 136) = v4;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v1 + 104), v3);
    v6 = *(uint64_t (***)(void))(v1 + 96);
    *(_QWORD *)(v1 + 112) = v6;
    if (!v6)
    {
LABEL_35:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*v6)
    {
      v17 = 1;
      goto LABEL_33;
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result((uint64_t)(v6 + 2));
    v8 = *v7;
    v9 = v7[1];
    *(_BYTE *)(v1 + 146) = HIBYTE(*v7);
    *(_WORD *)(v1 + 144) = v8 >> 8;
    *(_BYTE *)(v1 + 150) = v8;
    v10 = *(_QWORD *)(v1 + 96);
    if (v10)
      (*(void (**)(void))(v10 + 8))();
    if (v9 != 1)
      break;
    v11 = *(Backend::Google::ProtocolMessageReader **)(v1 + 104);
    if (v8 == 1)
    {
      Backend::Google::ProtocolMessageReader::readRepeatedPackedInt32(v11, v3);
      v6 = *(uint64_t (***)(void))(v1 + 96);
      *(_QWORD *)(v1 + 120) = v6;
      if (!v6)
        goto LABEL_35;
      if (*v6)
      {
        v17 = 2;
LABEL_33:
        *(_BYTE *)(v1 + 148) = v17;
        v6[2] = (uint64_t (*)(void))v1;
        return (*v6)();
      }
      detail::lazy_promise<std::optional<std::vector<unsigned int>>>::result((uint64_t)(v6 + 2));
      std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:sn180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>((uint64_t)v2, v12);
      if (*v3)
        (*(void (**)(void))(*v3 + 8))();
      v13 = *(_BYTE *)(v1 + 88);
      if (!v13)
        goto LABEL_25;
    }
    else
    {
      Backend::Google::ProtocolMessageReader::skipField(v11, v3);
      v6 = *(uint64_t (***)(void))(v1 + 96);
      *(_QWORD *)(v1 + 128) = v6;
      if (!v6)
        goto LABEL_35;
      if (*v6)
      {
        v17 = 3;
        goto LABEL_33;
      }
      detail::lazy_promise<BOOL>::result((uint64_t)(v6 + 2));
      v15 = *v14;
      if (*v3)
        (*(void (**)(void))(*v3 + 8))();
      if (!v15)
        goto LABEL_24;
    }
    v0 = *(unsigned __int16 *)(v1 + 144) | (*(unsigned __int8 *)(v1 + 146) << 16);
    v5 = *(_BYTE *)(v1 + 150);
    v4 = 1;
  }
  if (!v9)
  {
    if ((_BYTE)v8)
    {
      v13 = *(_BYTE *)(v1 + 88);
      if (v13)
      {
        *(_OWORD *)(v1 + 32) = *(_OWORD *)(v1 + 64);
        *(_QWORD *)(v1 + 48) = *(_QWORD *)(v1 + 80);
        v2[1] = 0;
        v2[2] = 0;
        *v2 = 0;
        v13 = 1;
LABEL_26:
        *(_BYTE *)(v1 + 56) = v13;
        *(_DWORD *)(v1 + 24) = 1;
        if (*(_BYTE *)(v1 + 88))
        {
          v16 = *v2;
          if (*v2)
          {
            *(_QWORD *)(v1 + 72) = v16;
            operator delete(v16);
          }
        }
        *(_QWORD *)v1 = 0;
        *(_BYTE *)(v1 + 148) = 4;
        v6 = *(uint64_t (***)(void))(v1 + 16);
        return (*v6)();
      }
    }
    else
    {
LABEL_24:
      v13 = 0;
    }
LABEL_25:
    *(_BYTE *)(v1 + 32) = 0;
    goto LABEL_26;
  }
  result = std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD4DC0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  if (*(_BYTE *)(v1 + 88))
  {
    v4 = *v2;
    if (*v2)
    {
      *(_QWORD *)(v1 + 72) = v4;
      operator delete(v4);
    }
  }
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 148) = 4;
  _Unwind_Resume(exception_object);
}

void sub_1DBCD4E48()
{
  uint64_t v0;
  char v1;
  __int16 v2;
  uint64_t v3;
  void *v4;

  v1 = *(_BYTE *)(v0 + 149);
  v2 = *(_WORD *)(v0 + 140);
  *(_BYTE *)(v0 + 146) = *(_BYTE *)(v0 + 142);
  *(_WORD *)(v0 + 144) = v2;
  *(_BYTE *)(v0 + 150) = v1;
  v3 = *(_QWORD *)(v0 + 96);
  if (v3)
    (*(void (**)(void))(v3 + 8))();
  if (*(_BYTE *)(v0 + 88))
  {
    v4 = *(void **)(v0 + 64);
    if (v4)
    {
      *(_QWORD *)(v0 + 72) = v4;
      operator delete(v4);
    }
  }
  detail::lazy_promise<std::optional<std::vector<unsigned int>>>::~lazy_promise(v0 + 16);
  operator delete((void *)v0);
}

void Backend::Google::FetchThreatListUpdatesResponseParser::parseRemoval(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X11 }
}

void sub_1DBCD4EF4(int a1@<W8>)
{
  int v1;
  uint64_t v2;
  void **v3;
  std::vector<unsigned int> *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned __int16 *v8;
  int v9;
  char v10;
  char v11;
  char v12;
  void (**v13)(void);
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned __int8 *v18;
  int v19;
  uint64_t v20;
  __n128 *v21;
  __n128 v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  int v31;
  std::vector<unsigned int>::pointer begin;
  void *v33;
  char v34;
  _QWORD *v35;
  uint64_t v36;

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  *(_BYTE *)(v2 + 64) = 0;
  *(_BYTE *)(v2 + 88) = 0;
  *(_BYTE *)(v2 + 96) = 0;
  *(_BYTE *)(v2 + 120) = 0;
  while (1)
  {
    *v8 = a1;
    *((_BYTE *)v8 + 2) = BYTE2(a1);
    *(_BYTE *)(v2 + 267) = v12;
    *(_BYTE *)(v2 + 266) = v11;
    *(_WORD *)(v2 + 252) = v1;
    *(_BYTE *)(v2 + 254) = BYTE2(v1);
    *(_BYTE *)(v2 + 265) = v10;
    *(_DWORD *)(v2 + 248) = v9;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v2 + 200), v7);
    v13 = *(void (***)(void))(v2 + 192);
    *(_QWORD *)(v2 + 208) = v13;
    if (!v13)
    {
LABEL_59:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*v13)
    {
      v34 = 1;
      goto LABEL_53;
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result((uint64_t)(v13 + 2));
    v15 = *v14;
    v16 = v14[1];
    *((_BYTE *)v8 + 6) = HIBYTE(*v14);
    v8[2] = v15 >> 8;
    *(_BYTE *)(v2 + 268) = v15;
    v17 = *(_QWORD *)(v2 + 192);
    if (v17)
      (*(void (**)(void))(v17 + 8))();
    if (v16 != 1)
      break;
    switch(v15)
    {
      case 3u:
        v26 = *(_QWORD *)(v2 + 200);
        *(_QWORD *)(v2 + 160) = off_1EA3EB190;
        *(_QWORD *)(v2 + 168) = Backend::Google::FetchThreatListUpdatesResponseParser::parseRawIndices;
        *(_QWORD *)(v2 + 184) = v6;
        Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<unsigned int>>(v26, v6, v7);
        v13 = *(void (***)(void))(v2 + 192);
        *(_QWORD *)(v2 + 224) = v13;
        if (!v13)
          goto LABEL_59;
        if (*v13)
        {
          v34 = 3;
          goto LABEL_53;
        }
        detail::lazy_promise<std::optional<std::vector<unsigned int>>>::result((uint64_t)(v13 + 2));
        std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:sn180100]<std::__optional_copy_assign_base<std::vector<unsigned int>,false> const&>((uint64_t)v3, v27);
        if (*v7)
          (*(void (**)(void))(*v7 + 8))();
        v28 = *(_QWORD *)(v2 + 184);
        v29 = 4;
        v30 = (_QWORD *)v6;
        if (v28 == v6 || (v29 = 5, v30 = *(_QWORD **)(v2 + 184), v28))
          (*(void (**)(void))(*v30 + 8 * v29))();
        if (!*(_BYTE *)(v2 + 88))
          goto LABEL_39;
        break;
      case 5u:
        v20 = *(_QWORD *)(v2 + 200);
        *(_QWORD *)(v2 + 128) = off_1EA3EB148;
        *(_QWORD *)(v2 + 136) = Backend::Google::readRemovalIndices;
        *(_QWORD *)(v2 + 152) = v5;
        Backend::Google::parseRiceDeltaEncoding<std::vector<unsigned int>>(v20, v5, v7);
        v13 = *(void (***)(void))(v2 + 192);
        *(_QWORD *)(v2 + 232) = v13;
        if (!v13)
          goto LABEL_59;
        if (*v13)
        {
          v34 = 4;
LABEL_53:
          *((_BYTE *)v8 + 8) = v34;
          v13[2] = (void (*)(void))v2;
LABEL_54:
          (*v13)();
          return;
        }
        detail::lazy_promise<std::optional<std::vector<unsigned int>>>::result((uint64_t)(v13 + 2));
        v22 = std::__optional_storage_base<std::vector<unsigned int>,false>::__assign_from[abi:sn180100]<std::__optional_move_assign_base<std::vector<unsigned int>,false>>(v4, v21);
        if (*v7)
          (*(void (**)(__n128))(*v7 + 8))(v22);
        v23 = *(_QWORD **)(v2 + 152);
        v24 = 4;
        v25 = v5;
        if (v23 == v5 || (v24 = 5, v25 = *(_QWORD **)(v2 + 152), v23))
          (*(void (**)(__n128))(*v25 + 8 * v24))(v22);
        break;
      case 1u:
        v35 = operator new(0x48uLL);
        v36 = *(_QWORD *)(v2 + 200);
        *(_QWORD *)(v2 + 216) = v35;
        *v35 = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::CompressionType>;
        v35[1] = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::CompressionType>;
        v35[6] = v36;
        *((_DWORD *)v35 + 6) = 0;
        *((_BYTE *)v35 + 64) = 0;
        *((_BYTE *)v8 + 8) = 2;
        v35[2] = v2;
        Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::CompressionType>((uint64_t)v35);
        return;
      default:
        Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v2 + 200), v7);
        v13 = *(void (***)(void))(v2 + 192);
        *(_QWORD *)(v2 + 240) = v13;
        if (!v13)
          goto LABEL_59;
        if (*v13)
        {
          v34 = 5;
          goto LABEL_53;
        }
        detail::lazy_promise<BOOL>::result((uint64_t)(v13 + 2));
        v19 = *v18;
        if (*v7)
          (*(void (**)(void))(*v7 + 8))();
        if (!v19)
          goto LABEL_39;
        break;
    }
    a1 = *v8 | (*((unsigned __int8 *)v8 + 2) << 16);
    v12 = *(_BYTE *)(v2 + 267);
    v11 = *(_BYTE *)(v2 + 266);
    v1 = v8[2] | (*((unsigned __int8 *)v8 + 6) << 16);
    v10 = *(_BYTE *)(v2 + 268);
    v9 = 1;
  }
  if (!v16)
  {
    if ((_BYTE)v15 && *(_BYTE *)(v2 + 266))
    {
      v31 = (*v8 << 8) | (*((unsigned __int8 *)v8 + 2) << 24) | *(unsigned __int8 *)(v2 + 267);
      if (v31 == 1)
      {
        *(_BYTE *)(v2 + 32) = 0;
        *(_BYTE *)(v2 + 56) = 0;
        if (*(_BYTE *)(v2 + 88))
        {
          *(_OWORD *)(v2 + 32) = *(_OWORD *)(v2 + 64);
          *(_QWORD *)(v2 + 48) = *(_QWORD *)(v2 + 80);
          v3[1] = 0;
          v3[2] = 0;
          *v3 = 0;
          goto LABEL_57;
        }
      }
      else
      {
        if (v31 != 2)
        {
LABEL_41:
          if (*(_BYTE *)(v2 + 120))
          {
            begin = v4->__begin_;
            if (v4->__begin_)
            {
              *(_QWORD *)(v2 + 104) = begin;
              operator delete(begin);
            }
          }
          if (*(_BYTE *)(v2 + 88))
          {
            v33 = *v3;
            if (*v3)
            {
              *(_QWORD *)(v2 + 72) = v33;
              operator delete(v33);
            }
          }
          *(_QWORD *)v2 = 0;
          *((_BYTE *)v8 + 8) = 6;
          v13 = *(void (***)(void))(v2 + 16);
          goto LABEL_54;
        }
        *(_BYTE *)(v2 + 32) = 0;
        *(_BYTE *)(v2 + 56) = 0;
        if (*(_BYTE *)(v2 + 120))
        {
          *(_OWORD *)(v2 + 32) = *(_OWORD *)(v2 + 96);
          *(_QWORD *)(v2 + 48) = *(_QWORD *)(v2 + 112);
          v4->__end_ = 0;
          v4->__end_cap_.__value_ = 0;
          v4->__begin_ = 0;
LABEL_57:
          *(_BYTE *)(v2 + 56) = 1;
        }
      }
    }
    else
    {
LABEL_39:
      *(_BYTE *)(v2 + 32) = 0;
      *(_BYTE *)(v2 + 56) = 0;
    }
    *(_DWORD *)(v2 + 24) = 1;
    goto LABEL_41;
  }
  std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
}

void sub_1DBCD5380(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void **v3;
  uint64_t v4;
  void *v6;
  void *v7;

  if (*(_BYTE *)(v1 + 120))
  {
    v6 = *v3;
    if (*v3)
    {
      *(_QWORD *)(v1 + 104) = v6;
      operator delete(v6);
    }
  }
  if (*(_BYTE *)(v1 + 88))
  {
    v7 = *v2;
    if (*v2)
    {
      *(_QWORD *)(v1 + 72) = v7;
      operator delete(v7);
    }
  }
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v4 + 8) = 6;
  _Unwind_Resume(a1);
}

void sub_1DBCD53A8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (*(_QWORD *)v2)
    (*(void (**)(void))(*(_QWORD *)v2 + 8))();
  v3 = *(_QWORD *)(v0 + 152);
  if (v3 != v1 && !v3)
    JUMPOUT(0x1DBCD5444);
  JUMPOUT(0x1DBCD5440);
}

void sub_1DBCD53EC()
{
  _QWORD *v0;

  if (*v0)
    JUMPOUT(0x1DBCD53F8);
  JUMPOUT(0x1DBCD5444);
}

void sub_1DBCD5400()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (*(_QWORD *)v2)
    (*(void (**)(void))(*(_QWORD *)v2 + 8))();
  v3 = *(_QWORD *)(v0 + 184);
  if (v3 != v1 && !v3)
    JUMPOUT(0x1DBCD5444);
  JUMPOUT(0x1DBCD5440);
}

void sub_1DBCD54C4(uint64_t a1@<X8>)
{
  uint64_t v1;
  char v2;
  __int16 v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v2 = *(_BYTE *)(v1 + 265);
  v3 = *(_WORD *)(v1 + 252);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(v1 + 254);
  *(_WORD *)a1 = v3;
  *(_BYTE *)(v1 + 268) = v2;
  v4 = *(_QWORD *)(v1 + 192);
  if (v4)
    (*(void (**)(void))(v4 + 8))();
  if (*(_BYTE *)(v1 + 120))
  {
    v5 = *(void **)(v1 + 96);
    if (v5)
    {
      *(_QWORD *)(v1 + 104) = v5;
      operator delete(v5);
    }
  }
  if (*(_BYTE *)(v1 + 88))
  {
    v6 = *(void **)(v1 + 64);
    if (v6)
    {
      *(_QWORD *)(v1 + 72) = v6;
      operator delete(v6);
    }
  }
  detail::lazy_promise<std::optional<std::vector<unsigned int>>>::~lazy_promise(v1 + 16);
  operator delete((void *)v1);
}

std::string *Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::RawHashes>(uint64_t a1)
{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::string *result;

  v3 = (uint64_t *)(a1 + 104);
  v4 = (_QWORD *)(a1 + 128);
  if (*(_BYTE *)(a1 + 192))
  {
    if (*(_BYTE *)(a1 + 192) != 1)
    {
      v5 = *(_QWORD *)(a1 + 184);
LABEL_31:
      detail::lazy_promise<std::optional<Backend::Google::RawHashes>>::result(v5 + 16);
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 64) = 0;
      if (*(_BYTE *)(v18 + 32))
      {
        *(_BYTE *)(a1 + 32) = *(_BYTE *)v18;
        *(_QWORD *)(a1 + 48) = 0;
        *(_QWORD *)(a1 + 56) = 0;
        *(_QWORD *)(a1 + 40) = 0;
        *(_OWORD *)(a1 + 40) = *(_OWORD *)(v18 + 8);
        *(_QWORD *)(a1 + 56) = *(_QWORD *)(v18 + 24);
        *(_QWORD *)(v18 + 8) = 0;
        *(_QWORD *)(v18 + 16) = 0;
        *(_QWORD *)(v18 + 24) = 0;
        *(_BYTE *)(a1 + 64) = 1;
      }
      *(_DWORD *)(a1 + 24) = 1;
      v19 = *(_QWORD *)(a1 + 152);
      if (v19)
        (*(void (**)(void))(v19 + 8))();
      v20 = *(std::__shared_weak_count **)(a1 + 144);
      if (v20)
      {
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          v22 = __ldaxr(p_shared_owners);
        while (__stlxr(v22 - 1, p_shared_owners));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      if (*(_BYTE *)(a1 + 120))
      {
        v23 = *(std::__shared_weak_count **)(a1 + 112);
        if (v23)
        {
          v24 = (unint64_t *)&v23->__shared_owners_;
          do
            v25 = __ldaxr(v24);
          while (__stlxr(v25 - 1, v24));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
      }
      goto LABEL_46;
    }
    v5 = *(_QWORD *)(a1 + 168);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 160), v4);
    v5 = *(_QWORD *)(a1 + 128);
    *(_QWORD *)(a1 + 168) = v5;
    if (!v5)
      goto LABEL_48;
    if (*(_QWORD *)v5)
    {
      v6 = 1;
LABEL_30:
      *(_BYTE *)(a1 + 192) = v6;
      *(_QWORD *)(v5 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v5)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v5 + 16);
  *(_BYTE *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(_BYTE *)(v7 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v7 + 8);
    *(_QWORD *)(a1 + 104) = *(_QWORD *)v7;
    *(_QWORD *)(a1 + 112) = v1;
    if (v1)
    {
      v9 = (unint64_t *)&v1->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    *(_BYTE *)(a1 + 120) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v8)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_46:
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 192) = 3;
    v5 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v5)();
  }
  v11 = *v3;
  if (v1)
  {
    v12 = (unint64_t *)&v1->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    *(_QWORD *)(a1 + 136) = v11;
    v14 = a1 + 136;
    *(_DWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 144) = v1;
    do
      v15 = __ldxr(v12);
    while (__stxr(v15 + 1, v12));
    do
      v16 = __ldaxr(v12);
    while (__stlxr(v16 - 1, v12));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 136) = v11;
    v14 = a1 + 136;
    *(_DWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 144) = 0;
  }
  *(_QWORD *)(a1 + 176) = v14;
  v17 = *(_QWORD *)(a1 + 96);
  if (v17)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v4);
    v5 = *(_QWORD *)(a1 + 152);
    *(_QWORD *)(a1 + 184) = v5;
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        v6 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_48:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD5870(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 192) = 3;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::RawHashes>(uint64_t a1)
{
  __asm { BR              X10 }
}

void sub_1DBCD5910()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = v0[16];
  if (v3)
    (*(void (**)(void))(v3 + 8))();
  detail::lazy_promise<std::optional<Backend::Google::RawHashes>>::~lazy_promise(v2);
  v4 = (_QWORD *)v0[12];
  if (v4 == v1)
  {
    v5 = 4;
    goto LABEL_7;
  }
  if (v4)
  {
    v5 = 5;
    v1 = (_QWORD *)v0[12];
LABEL_7:
    (*(void (**)(_QWORD *))(*v1 + 8 * v5))(v1);
  }
  operator delete(v0);
}

void Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(Backend::Google::ProtocolMessageReader &,std::function<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> ()(std::shared_ptr<RiceDecompressor>,unsigned int)>)::{lambda(Backend::Google::ListUpdateResponse::Addition&)#1}::operator()<Backend::Google::ProtocolMessageReader>(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X11 }
}

void sub_1DBCD5A5C()
{
  int v0;
  unsigned __int8 *v1;
  _QWORD *v2;
  int v3;
  int v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  unsigned __int8 v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  void (**v22)(void);
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t *v27;
  BOOL v28;
  unint64_t *v29;
  BOOL v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *p_shared_owners;
  unint64_t v44;
  int v45;
  int v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t *v50;
  unsigned __int8 *v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  char v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;

  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v1[80] = 0;
  v1[96] = 0;
  while (1)
  {
    *((_DWORD *)v1 + 67) = v15;
    *((_DWORD *)v1 + 66) = v14;
    *((_DWORD *)v1 + 65) = v13;
    *(_WORD *)v9 = v0;
    *(_BYTE *)(v9 + 2) = BYTE2(v0);
    v1[280] = v12;
    *((_DWORD *)v1 + 63) = v11;
    v1[279] = v8;
    *((_QWORD *)v1 + 21) = v7;
    *((_QWORD *)v1 + 22) = v10;
    v1[278] = v3;
    v1[277] = v4;
    *((_QWORD *)v1 + 20) = v6;
    Backend::Google::ProtocolMessageReader::nextField(*((Backend::Google::ProtocolMessageReader **)v1 + 19), v2);
    v22 = (void (**)(void))*((_QWORD *)v1 + 7);
    *((_QWORD *)v1 + 23) = v22;
    if (!v22)
      goto LABEL_112;
    if (*v22)
    {
      v56 = 1;
      goto LABEL_110;
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result((uint64_t)(v22 + 2));
    v24 = *v23;
    v25 = v23[1];
    *(_BYTE *)(v9 + 18) = HIBYTE(*v23);
    *(_WORD *)(v9 + 16) = v24 >> 8;
    v1[281] = v24;
    v26 = *((_QWORD *)v1 + 7);
    if (v26)
      (*(void (**)(void))(v26 + 8))();
    if (v25 != 1)
      break;
    switch(v24)
    {
      case 1u:
        Backend::Google::ProtocolMessageReader::readVarintField(*((Backend::Google::ProtocolMessageReader **)v1 + 19), v2);
        v22 = (void (**)(void))*((_QWORD *)v1 + 7);
        *((_QWORD *)v1 + 24) = v22;
        if (!v22)
          goto LABEL_112;
        if (*v22)
        {
          v56 = 2;
          goto LABEL_110;
        }
        detail::lazy_promise<std::optional<unsigned long long>>::result((uint64_t)(v22 + 2));
        v10 = *v27;
        v8 = *((unsigned __int8 *)v27 + 8);
        if (*v2)
          (*(void (**)(void))(*v2 + 8))();
        if (v8)
          v28 = HIDWORD(v10) == 0;
        else
          v28 = 0;
        if (!v28)
          goto LABEL_90;
        v15 = *((_DWORD *)v1 + 67);
        v13 = *((_DWORD *)v1 + 65);
        LOBYTE(v3) = v1[278];
        LOBYTE(v4) = v1[277];
        v14 = v10;
        goto LABEL_83;
      case 2u:
        Backend::Google::ProtocolMessageReader::readVarintField(*((Backend::Google::ProtocolMessageReader **)v1 + 19), v2);
        v22 = (void (**)(void))*((_QWORD *)v1 + 7);
        *((_QWORD *)v1 + 25) = v22;
        if (!v22)
          goto LABEL_112;
        if (*v22)
        {
          v56 = 3;
          goto LABEL_110;
        }
        detail::lazy_promise<std::optional<unsigned long long>>::result((uint64_t)(v22 + 2));
        v7 = *v50;
        v3 = *((unsigned __int8 *)v50 + 8);
        if (*v2)
          (*(void (**)(void))(*v2 + 8))();
        if (!v3 || (unint64_t)(v7 - 29) <= 0xFFFFFFFFFFFFFFE4)
          goto LABEL_90;
        v15 = *((_DWORD *)v1 + 67);
        v14 = *((_DWORD *)v1 + 66);
        LOBYTE(v8) = v1[279];
        v10 = *((_QWORD *)v1 + 22);
        LOBYTE(v4) = v1[277];
        v13 = v7;
        v6 = *((_QWORD *)v1 + 20);
        goto LABEL_84;
      case 3u:
        Backend::Google::ProtocolMessageReader::readVarintField(*((Backend::Google::ProtocolMessageReader **)v1 + 19), v2);
        v22 = (void (**)(void))*((_QWORD *)v1 + 7);
        *((_QWORD *)v1 + 26) = v22;
        if (!v22)
          goto LABEL_112;
        if (*v22)
        {
          v56 = 4;
          goto LABEL_110;
        }
        detail::lazy_promise<std::optional<unsigned long long>>::result((uint64_t)(v22 + 2));
        v6 = *v29;
        v4 = *((unsigned __int8 *)v29 + 8);
        if (*v2)
          (*(void (**)(void))(*v2 + 8))();
        if (v4)
          v30 = HIDWORD(v6) == 0;
        else
          v30 = 0;
        if (!v30)
          goto LABEL_90;
        v15 = v6 + 1;
        v14 = *((_DWORD *)v1 + 66);
        v13 = *((_DWORD *)v1 + 65);
        LOBYTE(v8) = v1[279];
        LOBYTE(v3) = v1[278];
        v7 = *((_QWORD *)v1 + 21);
        v10 = *((_QWORD *)v1 + 22);
        goto LABEL_84;
      case 4u:
        Backend::Google::ProtocolMessageReader::riceDecompressor(*((Backend::Google::ProtocolMessageReader **)v1 + 19), *((_DWORD *)v1 + 66), *((_DWORD *)v1 + 65), v5);
        v22 = (void (**)(void))*((_QWORD *)v1 + 17);
        *((_QWORD *)v1 + 27) = v22;
        if (!v22)
          goto LABEL_112;
        if (*v22)
        {
          v56 = 5;
          goto LABEL_110;
        }
        detail::lazy_promise<std::optional<std::shared_ptr<RiceDecompressor>>>::result((uint64_t)(v22 + 2));
        v32 = 0;
        v1[56] = 0;
        v1[72] = 0;
        if (*(_BYTE *)(v31 + 16))
        {
          v33 = *(_QWORD *)(v31 + 8);
          *((_QWORD *)v1 + 7) = *(_QWORD *)v31;
          *((_QWORD *)v1 + 8) = v33;
          if (v33)
          {
            v34 = (unint64_t *)(v33 + 8);
            do
              v35 = __ldxr(v34);
            while (__stxr(v35 + 1, v34));
          }
          v32 = 1;
          v1[72] = 1;
        }
        if (*v5)
        {
          (*(void (**)(void))(*v5 + 8))();
          v32 = v1[72];
        }
        if (!v32)
          goto LABEL_61;
        v36 = *((_QWORD *)v1 + 8);
        *((_QWORD *)v1 + 15) = *((_QWORD *)v1 + 7);
        *((_QWORD *)v1 + 16) = v36;
        if (v36)
        {
          v37 = (unint64_t *)(v36 + 8);
          do
            v38 = __ldxr(v37);
          while (__stxr(v38 + 1, v37));
        }
        v39 = *((_QWORD *)v1 + 18);
        *((_DWORD *)v1 + 62) = *((_DWORD *)v1 + 67);
        v40 = *(_QWORD *)(v39 + 24);
        if (!v40)
          goto LABEL_114;
        (*(void (**)(uint64_t))(*(_QWORD *)v40 + 48))(v40);
        v22 = (void (**)(void))*((_QWORD *)v1 + 17);
        *((_QWORD *)v1 + 28) = v22;
        if (!v22)
          goto LABEL_112;
        if (*v22)
        {
          v56 = 6;
          goto LABEL_110;
        }
        detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::result((uint64_t)(v22 + 2));
        std::__optional_storage_base<Backend::Google::ListUpdateResponse::Addition,false>::__assign_from[abi:sn180100]<std::__optional_move_assign_base<Backend::Google::ListUpdateResponse::Addition,false>>(v61, v41);
        if (*v5)
          (*(void (**)(void))(*v5 + 8))();
        v42 = (std::__shared_weak_count *)*((_QWORD *)v1 + 16);
        if (v42)
        {
          p_shared_owners = (unint64_t *)&v42->__shared_owners_;
          do
            v44 = __ldaxr(p_shared_owners);
          while (__stlxr(v44 - 1, p_shared_owners));
          if (!v44)
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }
        }
        v45 = 6;
        v46 = 1;
        if (!v1[96])
        {
LABEL_61:
          v46 = 0;
          v1[32] = 0;
          v1[48] = 0;
          *((_DWORD *)v1 + 6) = 1;
          v45 = 3;
        }
        if (v1[72])
        {
          v47 = (std::__shared_weak_count *)*((_QWORD *)v1 + 8);
          if (v47)
          {
            v48 = (unint64_t *)&v47->__shared_owners_;
            do
              v49 = __ldaxr(v48);
            while (__stlxr(v49 - 1, v48));
            if (!v49)
            {
              ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
              std::__shared_weak_count::__release_weak(v47);
            }
          }
        }
        if (!v46)
          goto LABEL_93;
        goto LABEL_82;
      default:
        Backend::Google::ProtocolMessageReader::skipField(*((Backend::Google::ProtocolMessageReader **)v1 + 19), v2);
        v22 = (void (**)(void))*((_QWORD *)v1 + 7);
        *((_QWORD *)v1 + 29) = v22;
        if (!v22)
          goto LABEL_112;
        if (*v22)
        {
          v56 = 7;
LABEL_110:
          *(_BYTE *)(v9 + 20) = v56;
          v22[2] = (void (*)(void))v1;
LABEL_111:
          (*v22)();
          return;
        }
        detail::lazy_promise<BOOL>::result((uint64_t)(v22 + 2));
        v52 = *v51;
        if (*v2)
          (*(void (**)(void))(*v2 + 8))();
        if (!v52)
          goto LABEL_90;
LABEL_82:
        v15 = *((_DWORD *)v1 + 67);
        v14 = *((_DWORD *)v1 + 66);
        v13 = *((_DWORD *)v1 + 65);
        LOBYTE(v8) = v1[279];
        v10 = *((_QWORD *)v1 + 22);
        LOBYTE(v3) = v1[278];
        LOBYTE(v4) = v1[277];
LABEL_83:
        v6 = *((_QWORD *)v1 + 20);
        v7 = *((_QWORD *)v1 + 21);
LABEL_84:
        v0 = *(unsigned __int16 *)(v9 + 16) | (*(unsigned __int8 *)(v9 + 18) << 16);
        v12 = v1[281];
        v11 = 1;
        break;
    }
  }
  if (v25)
  {
    std::__throw_bad_variant_access[abi:sn180100]();
    goto LABEL_115;
  }
  if ((_BYTE)v24)
  {
    if (*((_DWORD *)v1 + 67))
    {
      v1[32] = 0;
      v1[48] = 0;
      if (v1[96])
      {
        v53 = *((_QWORD *)v1 + 10);
        v54 = *((_QWORD *)v1 + 11);
        *((_QWORD *)v1 + 11) = 0;
        *((_QWORD *)v1 + 4) = v53;
        *((_QWORD *)v1 + 5) = v54;
        v1[48] = 1;
      }
      goto LABEL_91;
    }
    v57 = operator new(0x30uLL);
    v58 = *((_QWORD *)v1 + 18);
    v57[1] = 0;
    v57[2] = 0;
    *v57 = off_1EA3EB8B0;
    v57[3] = *(_QWORD *)(v9 + 4);
    v57[4] = 0;
    v57[5] = 0;
    *((_QWORD *)v1 + 13) = v57 + 3;
    *((_QWORD *)v1 + 14) = v57;
    v62 = 1;
    v59 = *(_QWORD *)(v58 + 24);
    if (v59)
    {
      (*(void (**)(uint64_t, uint64_t, int *))(*(_QWORD *)v59 + 48))(v59, v60, &v62);
      v22 = (void (**)(void))*((_QWORD *)v1 + 7);
      *((_QWORD *)v1 + 30) = v22;
      if (!v22)
      {
LABEL_112:
        MEMORY[0xDEADDEAD] = 0;
        std::terminate();
      }
      if (*v22)
      {
        v56 = 8;
        goto LABEL_110;
      }
      detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::result((uint64_t)(v22 + 2));
      v1[32] = 0;
      v1[48] = 0;
      if (*(_BYTE *)(v16 + 16))
      {
        *((_QWORD *)v1 + 4) = *(_QWORD *)v16;
        v17 = *(_QWORD *)(v16 + 8);
        *(_QWORD *)(v16 + 8) = 0;
        *((_QWORD *)v1 + 5) = v17;
        v1[48] = 1;
      }
      *((_DWORD *)v1 + 6) = 1;
      v18 = *((_QWORD *)v1 + 7);
      if (v18)
        (*(void (**)(void))(v18 + 8))();
      v19 = (std::__shared_weak_count *)*((_QWORD *)v1 + 14);
      if (v19)
      {
        v20 = (unint64_t *)&v19->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
      goto LABEL_92;
    }
LABEL_114:
    std::__throw_bad_function_call[abi:sn180100]();
LABEL_115:
    __break(1u);
    return;
  }
LABEL_90:
  v1[32] = 0;
  v1[48] = 0;
LABEL_91:
  *((_DWORD *)v1 + 6) = 1;
LABEL_92:
  v45 = 3;
LABEL_93:
  if (v1[96])
  {
    v55 = (void *)*((_QWORD *)v1 + 11);
    *((_QWORD *)v1 + 11) = 0;
    if (v55)
      operator delete[](v55);
  }
  if (v45 == 3)
  {
    *(_QWORD *)v1 = 0;
    *(_BYTE *)(v9 + 20) = 9;
    v22 = (void (**)(void))*((_QWORD *)v1 + 2);
    goto LABEL_111;
  }
  detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::~lazy_promise((uint64_t)(v1 + 16));
  operator delete(v1);
}

void sub_1DBCD6144(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a12);
  JUMPOUT(0x1DBCD6184);
}

void sub_1DBCD618C(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  void *v5;

  if (!*v2)
  {
    if (*(_BYTE *)(v1 + 96))
    {
      v5 = *(void **)(v1 + 88);
      *(_QWORD *)(v1 + 88) = 0;
      if (v5)
        operator delete[](v5);
    }
    *(_QWORD *)v1 = 0;
    *(_BYTE *)(v3 + 20) = 9;
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1DBCD61A8);
}

void sub_1DBCD6214(__int16 *a1@<X8>)
{
  uint64_t v1;
  char v2;
  __int16 v3;
  uint64_t v4;
  void *v5;

  v2 = *(_BYTE *)(v1 + 280);
  v3 = *a1;
  *((_BYTE *)a1 + 18) = *((_BYTE *)a1 + 2);
  a1[8] = v3;
  *(_BYTE *)(v1 + 281) = v2;
  v4 = *(_QWORD *)(v1 + 56);
  if (v4)
    (*(void (**)(void))(v4 + 8))();
  if (*(_BYTE *)(v1 + 96))
  {
    v5 = *(void **)(v1 + 88);
    *(_QWORD *)(v1 + 88) = 0;
    if (v5)
      operator delete[](v5);
  }
  detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::~lazy_promise(v1 + 16);
  operator delete((void *)v1);
}

void sub_1DBCD626C()
{
  uint64_t v0;

  if (!*(_QWORD *)(v0 + 136))
    JUMPOUT(0x1DBCD623CLL);
  JUMPOUT(0x1DBCD6234);
}

void sub_1DBCD6278()
{
  uint64_t v0;
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  v1 = *(_QWORD *)(v0 + 136);
  if (v1)
    (*(void (**)(void))(v1 + 8))();
  v2 = *(std::__shared_weak_count **)(v0 + 128);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  if (*(_BYTE *)(v0 + 72))
  {
    v5 = *(std::__shared_weak_count **)(v0 + 64);
    if (v5)
    {
      v6 = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  JUMPOUT(0x1DBCD623CLL);
}

_QWORD *Backend::Google::readAdditions(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  unsigned int v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v13;
  void *v14;

  if (!*(_BYTE *)(a1 + 116))
  {
    v8 = *(_DWORD *)(a1 + 112);
    v7 = operator new[](4 * v8);
    *(_QWORD *)(a1 + 88) = v7;
    v9 = *(_QWORD *)(a1 + 72);
    bzero(v7, 4 * v8);
    *v7 = *(_DWORD *)(v9 + 4);
    if (v8 < 2)
      goto LABEL_8;
    v6 = 1;
LABEL_7:
    *(_QWORD *)(a1 + 96) = v6;
    v10 = operator new(0xC8uLL);
    v11 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 104) = v10;
    *v10 = RiceDecompressor::decompress4Bytes;
    v10[1] = RiceDecompressor::decompress4Bytes;
    v10[22] = v11;
    *((_DWORD *)v10 + 6) = 0;
    *((_BYTE *)v10 + 192) = 0;
    *(_BYTE *)(a1 + 116) = 1;
    v10[2] = a1;
    return RiceDecompressor::decompress4Bytes((uint64_t)v10);
  }
  detail::lazy_promise<std::optional<unsigned int>>::result(*(_QWORD *)(a1 + 104) + 16);
  v3 = *v2;
  RiceDecompressor::decompress4Bytes(*(_QWORD *)(a1 + 104));
  if ((v3 & 0xFF00000000) == 0)
  {
    v14 = *(void **)(a1 + 88);
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 24) = 1;
    operator delete[](v14);
    goto LABEL_10;
  }
  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(unsigned int *)(a1 + 112);
  *(_DWORD *)(*(_QWORD *)(a1 + 88) + 4 * v4) = v3;
  v6 = v4 + 1;
  if (v6 != v5)
    goto LABEL_7;
  v7 = *(_DWORD **)(a1 + 88);
  v8 = *(_DWORD *)(a1 + 112);
LABEL_8:
  qsort(v7, v8, 4uLL, (int (__cdecl *)(const void *, const void *))Backend::Google::readAdditions(std::shared_ptr<RiceDecompressor>,unsigned int)::$_1::__invoke);
  v13 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 32) = ((unint64_t)*(unsigned int *)(a1 + 112) << 32) | 4;
  *(_QWORD *)(a1 + 40) = v13;
  *(_BYTE *)(a1 + 48) = 1;
  *(_DWORD *)(a1 + 24) = 1;
LABEL_10:
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 116) = 2;
  return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
}

void sub_1DBCD64A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  operator delete[](*(void **)(v1 + 88));
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 116) = 2;
  _Unwind_Resume(a1);
}

void Backend::Google::readAdditions(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;

  v2 = a1 + 16;
  if (*(_BYTE *)(a1 + 116) == 1)
  {
    v3 = *(void **)(a1 + 88);
    (*(void (**)(void))(*(_QWORD *)(a1 + 104) + 8))();
    operator delete[](v3);
  }
  v4 = *(_QWORD *)(a1 + 80);
  detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::~lazy_promise(v2);
  if (v4)
  {
    v5 = (unint64_t *)(*(_QWORD *)(a1 + 80) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      v7 = *(std::__shared_weak_count **)(a1 + 80);
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  operator delete((void *)a1);
}

void Backend::Google::FetchThreatListUpdatesResponseParser::parseRawHashes(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X10 }
}

uint64_t sub_1DBCD65B8()
{
  int v0;
  uint64_t v1;
  void **v2;
  _QWORD *v3;
  uint64_t v4;
  int v5;
  int v6;
  char v7;
  int v8;
  char v9;
  uint64_t (**v10)(void);
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;
  unsigned __int8 *v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  char v24;
  uint64_t result;
  uint64_t v26;

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  *(_BYTE *)(v1 + 72) = 0;
  *(_BYTE *)(v1 + 96) = 0;
  while (1)
  {
    *(_BYTE *)(v1 + 179) = v9;
    *(_DWORD *)(v1 + 168) = v8;
    *(_WORD *)(v1 + 164) = v0;
    *(_BYTE *)(v1 + 166) = BYTE2(v0);
    *(_BYTE *)(v1 + 178) = v7;
    *(_DWORD *)(v1 + 160) = v6;
    *(_BYTE *)(v1 + 177) = v5;
    *(_QWORD *)(v1 + 120) = v4;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v1 + 112), v3);
    v10 = *(uint64_t (***)(void))(v1 + 104);
    *(_QWORD *)(v1 + 128) = v10;
    if (!v10)
    {
LABEL_47:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*v10)
    {
      v24 = 1;
      goto LABEL_44;
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result((uint64_t)(v10 + 2));
    v12 = *v11;
    v13 = v11[1];
    *(_BYTE *)(v1 + 174) = HIBYTE(*v11);
    *(_WORD *)(v1 + 172) = v12 >> 8;
    *(_BYTE *)(v1 + 180) = v12;
    v14 = *(_QWORD *)(v1 + 104);
    if (v14)
      (*(void (**)(void))(v14 + 8))();
    if (v13 != 1)
      break;
    if (v12 == 2)
    {
      Backend::Google::ProtocolMessageReader::readLengthDelimitedField(*(Backend::Google::ProtocolMessageReader **)(v1 + 112), v3);
      v10 = *(uint64_t (***)(void))(v1 + 104);
      *(_QWORD *)(v1 + 144) = v10;
      if (!v10)
        goto LABEL_47;
      if (*v10)
      {
        v24 = 3;
        goto LABEL_44;
      }
      detail::lazy_promise<std::optional<std::vector<unsigned char>>>::result((uint64_t)(v10 + 2));
      std::__optional_storage_base<std::vector<unsigned char>,false>::__assign_from[abi:sn180100]<std::__optional_copy_assign_base<std::vector<unsigned char>,false> const&>((uint64_t)v2, v16);
      if (*v3)
        (*(void (**)(void))(*v3 + 8))();
      v17 = *(_BYTE *)(v1 + 96);
      if (!v17)
        goto LABEL_35;
LABEL_27:
      v9 = *(_BYTE *)(v1 + 179);
      v8 = *(_DWORD *)(v1 + 168);
      LOBYTE(v5) = *(_BYTE *)(v1 + 177);
      v4 = *(_QWORD *)(v1 + 120);
      goto LABEL_28;
    }
    if (v12 != 1)
    {
      Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v1 + 112), v3);
      v10 = *(uint64_t (***)(void))(v1 + 104);
      *(_QWORD *)(v1 + 152) = v10;
      if (!v10)
        goto LABEL_47;
      if (*v10)
      {
        v24 = 4;
LABEL_44:
        *(_BYTE *)(v1 + 176) = v24;
        v10[2] = (uint64_t (*)(void))v1;
        return (*v10)();
      }
      detail::lazy_promise<BOOL>::result((uint64_t)(v10 + 2));
      v19 = *v18;
      if (*v3)
        (*(void (**)(void))(*v3 + 8))();
      if (!v19)
        goto LABEL_34;
      goto LABEL_27;
    }
    Backend::Google::ProtocolMessageReader::readVarintField(*(Backend::Google::ProtocolMessageReader **)(v1 + 112), v3);
    v10 = *(uint64_t (***)(void))(v1 + 104);
    *(_QWORD *)(v1 + 136) = v10;
    if (!v10)
      goto LABEL_47;
    if (*v10)
    {
      v24 = 2;
      goto LABEL_44;
    }
    detail::lazy_promise<std::optional<unsigned long long>>::result((uint64_t)(v10 + 2));
    v4 = *v15;
    v5 = *((unsigned __int8 *)v15 + 8);
    if (*v3)
      (*(void (**)(void))(*v3 + 8))();
    if (!v5 || (unint64_t)(v4 - 33) <= 0xFFFFFFFFFFFFFFE2)
      goto LABEL_34;
    v9 = 1;
    v8 = v4;
LABEL_28:
    v0 = *(unsigned __int16 *)(v1 + 172) | (*(unsigned __int8 *)(v1 + 174) << 16);
    v7 = *(_BYTE *)(v1 + 180);
    v6 = 1;
  }
  if (!v13)
  {
    if (!(_BYTE)v12)
      goto LABEL_34;
    v17 = *(_BYTE *)(v1 + 179);
    if (v17 && (v17 = *(_BYTE *)(v1 + 96)) != 0)
    {
      v20 = *(int *)(v1 + 168);
      v22 = *(_QWORD *)(v1 + 72);
      v21 = *(_QWORD *)(v1 + 80);
      if ((v21 - v22) % v20)
      {
LABEL_34:
        v17 = 0;
        goto LABEL_35;
      }
      v26 = *(_QWORD *)(v1 + 88);
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      *(_BYTE *)(v1 + 32) = v20;
      *(_QWORD *)(v1 + 40) = v22;
      *(_QWORD *)(v1 + 48) = v21;
      *(_QWORD *)(v1 + 56) = v26;
      v17 = 1;
    }
    else
    {
LABEL_35:
      *(_BYTE *)(v1 + 32) = 0;
    }
    *(_BYTE *)(v1 + 64) = v17;
    *(_DWORD *)(v1 + 24) = 1;
    if (*(_BYTE *)(v1 + 96))
    {
      v23 = *v2;
      if (*v2)
      {
        *(_QWORD *)(v1 + 80) = v23;
        operator delete(v23);
      }
    }
    *(_QWORD *)v1 = 0;
    *(_BYTE *)(v1 + 176) = 5;
    v10 = *(uint64_t (***)(void))(v1 + 16);
    return (*v10)();
  }
  result = std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD687C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  if (*(_BYTE *)(v1 + 96))
  {
    v4 = *v2;
    if (*v2)
    {
      *(_QWORD *)(v1 + 80) = v4;
      operator delete(v4);
    }
  }
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 176) = 5;
  _Unwind_Resume(exception_object);
}

void sub_1DBCD690C()
{
  uint64_t v0;
  char v1;
  __int16 v2;
  uint64_t v3;
  void *v4;

  v1 = *(_BYTE *)(v0 + 178);
  v2 = *(_WORD *)(v0 + 164);
  *(_BYTE *)(v0 + 174) = *(_BYTE *)(v0 + 166);
  *(_WORD *)(v0 + 172) = v2;
  *(_BYTE *)(v0 + 180) = v1;
  v3 = *(_QWORD *)(v0 + 104);
  if (v3)
    (*(void (**)(void))(v3 + 8))();
  if (*(_BYTE *)(v0 + 96))
  {
    v4 = *(void **)(v0 + 72);
    if (v4)
    {
      *(_QWORD *)(v0 + 80) = v4;
      operator delete(v4);
    }
  }
  detail::lazy_promise<std::optional<Backend::Google::RawHashes>>::~lazy_promise(v0 + 16);
  operator delete((void *)v0);
}

void Backend::Google::FetchThreatListUpdatesResponseParser::parseAddition(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X11 }
}

void sub_1DBCD69C4(int a1@<W8>)
{
  int v1;
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  int v8;
  char v9;
  uint64_t v10;
  char v11;
  char v12;
  char v13;
  void (**v14)(void);
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned __int8 *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  _BYTE *v32;
  _BYTE *v33;
  void *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  void *v39;
  char v40;
  _QWORD *v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t v46;

  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  *(_BYTE *)(v2 + 160) = 0;
  *(_BYTE *)(v2 + 176) = 0;
  while (1)
  {
    *(_WORD *)(v7 + 4) = a1;
    *(_BYTE *)(v7 + 6) = BYTE2(a1);
    *(_BYTE *)(v2 + 284) = v13;
    *(_BYTE *)(v2 + 283) = v12;
    *(_BYTE *)(v2 + 282) = v11;
    *(_QWORD *)(v2 + 208) = v10;
    *(_QWORD *)(v2 + 216) = v6;
    *(_WORD *)v7 = v1;
    *(_BYTE *)(v7 + 2) = BYTE2(v1);
    *(_BYTE *)(v2 + 281) = v9;
    *(_QWORD *)(v2 + 200) = v5;
    *(_DWORD *)(v2 + 264) = v8;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v2 + 192), v4);
    v14 = *(void (***)(void))(v2 + 56);
    *(_QWORD *)(v2 + 224) = v14;
    if (!v14)
    {
LABEL_70:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*v14)
    {
      v40 = 1;
      goto LABEL_64;
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result((uint64_t)(v14 + 2));
    v16 = *v15;
    v17 = v15[1];
    *(_BYTE *)(v7 + 10) = HIBYTE(*v15);
    *(_WORD *)(v7 + 8) = v16 >> 8;
    *(_BYTE *)(v2 + 285) = v16;
    v18 = *(_QWORD *)(v2 + 56);
    if (v18)
      (*(void (**)(void))(v18 + 8))();
    if (v17 != 1)
      break;
    switch(v16)
    {
      case 2u:
        v26 = *(_QWORD *)(v2 + 192);
        *(_QWORD *)(v2 + 96) = off_1EA3EB028;
        *(_QWORD *)(v2 + 104) = Backend::Google::FetchThreatListUpdatesResponseParser::parseRawHashes;
        *(_QWORD *)(v2 + 120) = v46;
        Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::RawHashes>(v26, v46, v45);
        v14 = *(void (***)(void))(v2 + 184);
        *(_QWORD *)(v2 + 240) = v14;
        if (!v14)
          goto LABEL_70;
        if (*v14)
        {
          v40 = 3;
LABEL_64:
          *(_BYTE *)(v7 + 12) = v40;
          v14[2] = (void (*)(void))v2;
LABEL_65:
          (*v14)();
          return;
        }
        detail::lazy_promise<std::optional<Backend::Google::RawHashes>>::result((uint64_t)(v14 + 2));
        std::__optional_copy_base<Backend::Google::RawHashes,false>::__optional_copy_base[abi:sn180100](v4, v27);
        if (*v45)
          (*(void (**)(void))(*v45 + 8))();
        v28 = *(_QWORD *)(v2 + 120);
        v29 = 4;
        v30 = (_QWORD *)v46;
        if (v28 == v46 || (v29 = 5, v30 = *(_QWORD **)(v2 + 120), v28))
          (*(void (**)(void))(*v30 + 8 * v29))();
        if (!*(_BYTE *)(v2 + 88))
          goto LABEL_50;
        v31 = *(unsigned __int8 *)(v2 + 56);
        v33 = *(_BYTE **)(v2 + 64);
        v32 = *(_BYTE **)(v2 + 72);
        v6 = operator new[](v32 - v33);
        bzero(v6, v32 - v33);
        if (v32 != v33)
          memmove(v6, v33, v32 - v33);
        v5 = *(_QWORD *)(v2 + 200) & 0xFFFFFF00 | (((v32 - v33) / v31) << 32) | v31;
        v11 = 1;
        if (*(_BYTE *)(v2 + 282) && (v34 = *(void **)(v2 + 216), v11 = *(_BYTE *)(v2 + 282), v34))
        {
          operator delete[](v34);
          v11 = *(_BYTE *)(v2 + 282);
          if (*(_BYTE *)(v2 + 88))
          {
            v33 = *(_BYTE **)(v2 + 64);
            goto LABEL_39;
          }
        }
        else
        {
LABEL_39:
          if (v33)
          {
            *(_QWORD *)(v2 + 72) = v33;
            operator delete(v33);
          }
        }
        a1 = *(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16);
        v13 = *(_BYTE *)(v2 + 284);
        v12 = *(_BYTE *)(v2 + 283);
        v10 = v5;
        goto LABEL_42;
      case 4u:
        v21 = *(_QWORD *)(v2 + 192);
        *(_QWORD *)(v2 + 128) = off_1EA3EAEC0;
        *(_QWORD *)(v2 + 136) = Backend::Google::readAdditions;
        *(_QWORD *)(v2 + 152) = v3;
        Backend::Google::parseRiceDeltaEncoding<Backend::Google::ListUpdateResponse::Addition>(v21, v3, v4);
        v14 = *(void (***)(void))(v2 + 56);
        *(_QWORD *)(v2 + 248) = v14;
        if (!v14)
          goto LABEL_70;
        if (*v14)
        {
          v40 = 4;
          goto LABEL_64;
        }
        detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::result((uint64_t)(v14 + 2));
        std::__optional_storage_base<Backend::Google::ListUpdateResponse::Addition,false>::__assign_from[abi:sn180100]<std::__optional_move_assign_base<Backend::Google::ListUpdateResponse::Addition,false>>(v44, v22);
        if (*v4)
          (*(void (**)(void))(*v4 + 8))();
        v23 = *(_QWORD **)(v2 + 152);
        v24 = 4;
        v25 = v3;
        if (v23 == v3 || (v24 = 5, v25 = *(_QWORD **)(v2 + 152), v23))
          (*(void (**)(void))(*v25 + 8 * v24))();
        if (!*(_BYTE *)(v2 + 176))
          goto LABEL_50;
        break;
      case 1u:
        v41 = operator new(0x48uLL);
        v42 = *(_QWORD *)(v2 + 192);
        *(_QWORD *)(v2 + 232) = v41;
        *v41 = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::CompressionType>;
        v41[1] = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::CompressionType>;
        v41[6] = v42;
        *((_DWORD *)v41 + 6) = 0;
        *((_BYTE *)v41 + 64) = 0;
        *(_BYTE *)(v7 + 12) = 2;
        v41[2] = v2;
        Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::CompressionType>((uint64_t)v41);
        return;
      default:
        Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v2 + 192), v4);
        v14 = *(void (***)(void))(v2 + 56);
        *(_QWORD *)(v2 + 256) = v14;
        if (!v14)
          goto LABEL_70;
        if (*v14)
        {
          v40 = 5;
          goto LABEL_64;
        }
        detail::lazy_promise<BOOL>::result((uint64_t)(v14 + 2));
        v20 = *v19;
        if (*v4)
          (*(void (**)(void))(*v4 + 8))();
        if (!v20)
          goto LABEL_50;
        break;
    }
    a1 = *(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16);
    v13 = *(_BYTE *)(v2 + 284);
    v12 = *(_BYTE *)(v2 + 283);
    v11 = *(_BYTE *)(v2 + 282);
    v10 = *(_QWORD *)(v2 + 208);
    v6 = *(void **)(v2 + 216);
    v5 = *(_QWORD *)(v2 + 200);
LABEL_42:
    v1 = *(unsigned __int16 *)(v7 + 8) | (*(unsigned __int8 *)(v7 + 10) << 16);
    v9 = *(_BYTE *)(v2 + 285);
    v8 = 1;
  }
  if (!v17)
  {
    if ((_BYTE)v16 && *(_BYTE *)(v2 + 283))
    {
      v35 = (*(unsigned __int16 *)(v7 + 4) << 8) | (*(unsigned __int8 *)(v7 + 6) << 24) | *(unsigned __int8 *)(v2 + 284);
      if (v35 == 1)
      {
        v43 = *(unsigned __int8 *)(v2 + 282);
        *(_BYTE *)(v2 + 32) = 0;
        *(_BYTE *)(v2 + 48) = 0;
        v38 = *(void **)(v2 + 216);
        if (v43)
        {
          *(_QWORD *)(v2 + 32) = *(_QWORD *)(v2 + 208);
          *(_QWORD *)(v2 + 40) = v38;
          *(_BYTE *)(v2 + 48) = 1;
          v38 = 0;
        }
        *(_DWORD *)(v2 + 24) = 1;
      }
      else if (v35 == 2)
      {
        *(_BYTE *)(v2 + 32) = 0;
        *(_BYTE *)(v2 + 48) = 0;
        if (*(_BYTE *)(v2 + 176))
        {
          v36 = *(_QWORD *)(v2 + 160);
          v37 = *(_QWORD *)(v2 + 168);
          *(_QWORD *)(v2 + 168) = 0;
          *(_QWORD *)(v2 + 32) = v36;
          *(_QWORD *)(v2 + 40) = v37;
          *(_BYTE *)(v2 + 48) = 1;
        }
LABEL_51:
        *(_DWORD *)(v2 + 24) = 1;
        v38 = *(void **)(v2 + 216);
      }
      else
      {
        v38 = *(void **)(v2 + 216);
      }
      if (*(_BYTE *)(v2 + 176))
      {
        v39 = *(void **)(v2 + 168);
        *(_QWORD *)(v2 + 168) = 0;
        if (v39)
          operator delete[](v39);
      }
      if (*(_BYTE *)(v2 + 282))
      {
        if (v38)
          operator delete[](v38);
      }
      *(_QWORD *)v2 = 0;
      *(_BYTE *)(v7 + 12) = 6;
      v14 = *(void (***)(void))(v2 + 16);
      goto LABEL_65;
    }
LABEL_50:
    *(_BYTE *)(v2 + 32) = 0;
    *(_BYTE *)(v2 + 48) = 0;
    goto LABEL_51;
  }
  std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
}

void sub_1DBCD6F24(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;
  void *v8;

  v5 = *(_QWORD **)(v1 + 152);
  if (v5 == v2)
  {
    v6 = 4;
  }
  else
  {
    if (!v5)
    {
LABEL_6:
      if (*(_BYTE *)(v1 + 176))
      {
        v7 = *(void **)(v1 + 168);
        *(_QWORD *)(v1 + 168) = 0;
        if (v7)
          operator delete[](v7);
      }
      if (*(_BYTE *)(v1 + 282))
      {
        v8 = *(void **)(v1 + 216);
        if (v8)
          operator delete[](v8);
      }
      *(_QWORD *)v1 = 0;
      *(_BYTE *)(v3 + 12) = 6;
      _Unwind_Resume(a1);
    }
    v6 = 5;
    v2 = *(_QWORD **)(v1 + 152);
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v6))(v2);
  goto LABEL_6;
}

void sub_1DBCD6F2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  v13 = *(_QWORD *)(v12 + 120);
  if (v13 != a12 && !v13)
    JUMPOUT(0x1DBCD7004);
  JUMPOUT(0x1DBCD7000);
}

void sub_1DBCD6F3C()
{
  uint64_t v0;
  void *v1;

  if (v1)
  {
    *(_QWORD *)(v0 + 72) = v1;
    operator delete(v1);
  }
  JUMPOUT(0x1DBCD7004);
}

void sub_1DBCD6F54()
{
  _QWORD *v0;

  if (*v0)
    JUMPOUT(0x1DBCD6F64);
  JUMPOUT(0x1DBCD7004);
}

void sub_1DBCD6F6C()
{
  JUMPOUT(0x1DBCD7004);
}

void sub_1DBCD6F74()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (*(_QWORD *)v2)
    (*(void (**)(void))(*(_QWORD *)v2 + 8))();
  v3 = *(_QWORD *)(v0 + 152);
  if (v3 != v1 && !v3)
    JUMPOUT(0x1DBCD7004);
  JUMPOUT(0x1DBCD7000);
}

void sub_1DBCD6FB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  if (*(_QWORD *)a11)
    (*(void (**)(void))(*(_QWORD *)a11 + 8))();
  v13 = *(_QWORD *)(v12 + 120);
  if (v13 != a12 && !v13)
    JUMPOUT(0x1DBCD7004);
  JUMPOUT(0x1DBCD7000);
}

void sub_1DBCD7080(__int16 *a1@<X8>)
{
  uint64_t v1;
  char v2;
  __int16 v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v2 = *(_BYTE *)(v1 + 281);
  v3 = *a1;
  *((_BYTE *)a1 + 10) = *((_BYTE *)a1 + 2);
  a1[4] = v3;
  *(_BYTE *)(v1 + 285) = v2;
  v4 = *(_QWORD *)(v1 + 56);
  if (v4)
    (*(void (**)(void))(v4 + 8))();
  v5 = *(void **)(v1 + 216);
  if (*(_BYTE *)(v1 + 176))
  {
    v6 = *(void **)(v1 + 168);
    *(_QWORD *)(v1 + 168) = 0;
    if (v6)
      operator delete[](v6);
  }
  if (*(_BYTE *)(v1 + 282) && v5)
    operator delete[](v5);
  detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::~lazy_promise(v1 + 16);
  operator delete((void *)v1);
}

void Backend::Google::FetchThreatListUpdatesResponseParser::parseListUpdateResponse(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X11 }
}

uint64_t sub_1DBCD7204(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, __int128 a18, __int128 a19, void *__p,uint64_t a21,__int128 a22,void *a23,uint64_t a24,uint64_t a25,__int128 a26,__int128 a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  int v41;
  int v42;
  int v43;
  char v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  char v50;
  char v51;
  char v52;
  uint64_t v53;
  char v54;
  char v55;
  char v56;
  char v57;
  char v58;
  char v59;
  char v60;
  char v61;
  int v62;
  int8x16_t v63;
  uint64_t v64;
  unsigned int *v65;
  unsigned int v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _QWORD *v74;
  void *v75;
  unsigned __int8 *v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  void *v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  __int128 v87;
  uint64_t v88;
  uint64_t v89;
  _QWORD *v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  char v106;
  uint64_t v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;
  __int128 v111;
  void *v112;
  void *v113;
  char v114;
  _QWORD *v116;
  uint64_t v117;
  _QWORD *v118;
  uint64_t v119;
  _QWORD *v120;
  uint64_t v121;
  _QWORD *v122;
  uint64_t v123;
  _OWORD *v124;
  _QWORD *v125;
  uint64_t v126;
  void **v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  uint64_t v137;
  _BYTE v138[32];

  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v61 = 0;
  v62 = v131;
  *(_QWORD *)(v131 + 16) = 0;
  v63 = 0uLL;
  *(_OWORD *)v131 = 0u;
  *(_BYTE *)(v46 + 192) = 0;
  *(_BYTE *)(v46 + 216) = 0;
  while (1)
  {
    *(_WORD *)(v48 + 16) = v62;
    *(_BYTE *)(v48 + 18) = BYTE2(v62);
    *(_BYTE *)(v46 + 536) = v61;
    *(_BYTE *)(v46 + 535) = v60;
    *(_WORD *)(v48 + 12) = v41;
    *(_BYTE *)(v48 + 14) = BYTE2(v41);
    *(_BYTE *)(v46 + 534) = v59;
    *(_BYTE *)(v46 + 533) = v58;
    *(_WORD *)(v48 + 8) = v42;
    *(_BYTE *)(v48 + 10) = BYTE2(v42);
    *(_BYTE *)(v46 + 532) = v57;
    *(_BYTE *)(v46 + 531) = v47;
    *(_BYTE *)(v46 + 530) = v56;
    *(_WORD *)(v48 + 4) = v43;
    *(_BYTE *)(v48 + 6) = BYTE2(v43);
    *(_BYTE *)(v46 + 529) = v55;
    *(_BYTE *)(v46 + 528) = v54;
    *(int8x16_t *)(v46 + 368) = v63;
    *(_QWORD *)(v46 + 360) = v53;
    *(_BYTE *)(v46 + 527) = v44;
    *(_BYTE *)(v46 + 526) = v52;
    *(_BYTE *)(v46 + 525) = v51;
    *(_WORD *)v48 = v45;
    *(_BYTE *)(v48 + 2) = BYTE2(v45);
    *(_BYTE *)(v46 + 524) = v50;
    *(_DWORD *)(v46 + 464) = v49;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v46 + 352), (_QWORD *)v126);
    v64 = *(_QWORD *)(v46 + 160);
    *(_QWORD *)(v46 + 384) = v64;
    if (!v64)
    {
LABEL_88:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*(_QWORD *)v64)
    {
      v114 = 1;
LABEL_77:
      *(_BYTE *)(v48 + 55) = v114;
      *(_QWORD *)(v64 + 16) = v46;
      return (*(uint64_t (**)(uint64_t))v64)(v64);
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result(v64 + 16);
    v66 = *v65;
    v67 = v65[1];
    *(_BYTE *)(v48 + 22) = HIBYTE(*v65);
    *(_WORD *)(v48 + 20) = v66 >> 8;
    *(_BYTE *)(v46 + 537) = v66;
    v68 = *(_QWORD *)(v46 + 160);
    if (v68)
      (*(void (**)(void))(v68 + 8))();
    if (v67 != 1)
      break;
    switch(v66)
    {
      case 1u:
        v116 = operator new(0x48uLL);
        v117 = *(_QWORD *)(v46 + 352);
        *(_QWORD *)(v46 + 392) = v116;
        *v116 = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatType>;
        v116[1] = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatType>;
        v116[6] = v117;
        *((_DWORD *)v116 + 6) = 0;
        *((_BYTE *)v116 + 64) = 0;
        *(_BYTE *)(v48 + 55) = 2;
        v116[2] = v46;
        return Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatType>((uint64_t)v116);
      case 2u:
        v118 = operator new(0x48uLL);
        v119 = *(_QWORD *)(v46 + 352);
        *(_QWORD *)(v46 + 400) = v118;
        *v118 = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatEntryType>;
        v118[1] = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatEntryType>;
        v118[6] = v119;
        *((_DWORD *)v118 + 6) = 0;
        *((_BYTE *)v118 + 64) = 0;
        *(_BYTE *)(v48 + 55) = 3;
        v118[2] = v46;
        return Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatEntryType>((uint64_t)v118);
      case 3u:
        v120 = operator new(0x48uLL);
        v121 = *(_QWORD *)(v46 + 352);
        *(_QWORD *)(v46 + 408) = v120;
        *v120 = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::PlatformType>;
        v120[1] = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::PlatformType>;
        v120[6] = v121;
        *((_DWORD *)v120 + 6) = 0;
        *((_BYTE *)v120 + 64) = 0;
        *(_BYTE *)(v48 + 55) = 4;
        v120[2] = v46;
        return Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::PlatformType>((uint64_t)v120);
      case 4u:
        v122 = operator new(0x48uLL);
        v123 = *(_QWORD *)(v46 + 352);
        *(_QWORD *)(v46 + 416) = v122;
        *v122 = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ResponseType>;
        v122[1] = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ResponseType>;
        v122[6] = v123;
        *((_DWORD *)v122 + 6) = 0;
        *((_BYTE *)v122 + 64) = 0;
        *(_BYTE *)(v48 + 55) = 5;
        v122[2] = v46;
        return Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ResponseType>((uint64_t)v122);
      case 5u:
        v69 = *(_QWORD *)(v46 + 352);
        *(_QWORD *)(v46 + 224) = off_1EA3EAF08;
        *(_QWORD *)(v46 + 232) = Backend::Google::FetchThreatListUpdatesResponseParser::parseAddition;
        *(_QWORD *)(v46 + 248) = v129;
        Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse::Addition>(v69, v129, v125);
        v64 = *(_QWORD *)(v46 + 344);
        *(_QWORD *)(v46 + 424) = v64;
        if (!v64)
          goto LABEL_88;
        if (!*(_QWORD *)v64)
        {
          detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse::Addition>>::result(v64 + 16);
          *(_BYTE *)(v46 + 160) = 0;
          *(_BYTE *)(v46 + 176) = 0;
          if (*(_BYTE *)(v70 + 16))
          {
            *(_QWORD *)(v46 + 160) = *(_QWORD *)v70;
            v71 = *(_QWORD *)(v70 + 8);
            *(_QWORD *)(v70 + 8) = 0;
            *(_QWORD *)(v46 + 168) = v71;
            *(_BYTE *)(v46 + 176) = 1;
          }
          if (*v125)
            (*(void (**)(void))(*v125 + 8))();
          v72 = *(_QWORD *)(v46 + 248);
          v73 = 4;
          v74 = (_QWORD *)v129;
          if (v72 == v129 || (v73 = 5, v74 = *(_QWORD **)(v46 + 248), v72))
            (*(void (**)(void))(*v74 + 8 * v73))();
          if (!*(_BYTE *)(v46 + 176))
            goto LABEL_69;
          std::vector<Backend::Google::ListUpdateResponse::Addition>::push_back[abi:sn180100]((char **)v131, (_QWORD *)v126);
          if (*(_BYTE *)(v46 + 176))
          {
            v75 = *(void **)(v46 + 168);
            *(_QWORD *)(v46 + 168) = 0;
            if (v75)
              operator delete[](v75);
          }
LABEL_43:
          v62 = *(unsigned __int16 *)(v48 + 16) | (*(unsigned __int8 *)(v48 + 18) << 16);
          v61 = *(_BYTE *)(v46 + 536);
          v60 = *(_BYTE *)(v46 + 535);
          v41 = *(unsigned __int16 *)(v48 + 12) | (*(unsigned __int8 *)(v48 + 14) << 16);
          v59 = *(_BYTE *)(v46 + 534);
          v58 = *(_BYTE *)(v46 + 533);
          v42 = *(unsigned __int16 *)(v48 + 8) | (*(unsigned __int8 *)(v48 + 10) << 16);
          v57 = *(_BYTE *)(v46 + 532);
          LOBYTE(v47) = *(_BYTE *)(v46 + 531);
          v56 = *(_BYTE *)(v46 + 530);
          v43 = *(unsigned __int16 *)(v48 + 4) | (*(unsigned __int8 *)(v48 + 6) << 16);
          v55 = *(_BYTE *)(v46 + 529);
          v54 = *(_BYTE *)(v46 + 528);
          v63 = *(int8x16_t *)(v46 + 368);
          v53 = *(_QWORD *)(v46 + 360);
LABEL_44:
          v44 = *(_BYTE *)(v46 + 527);
          v52 = *(_BYTE *)(v46 + 526);
          v51 = *(_BYTE *)(v46 + 525);
          goto LABEL_54;
        }
        v114 = 6;
        goto LABEL_77;
      case 6u:
        v78 = *(_QWORD *)(v46 + 352);
        *(_QWORD *)(v46 + 288) = off_1EA3EB190;
        *(_QWORD *)(v46 + 296) = Backend::Google::FetchThreatListUpdatesResponseParser::parseRemoval;
        *(_QWORD *)(v46 + 312) = v130;
        Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<unsigned int>>(v78, v130, v125);
        v64 = *(_QWORD *)(v46 + 344);
        *(_QWORD *)(v46 + 432) = v64;
        if (!v64)
          goto LABEL_88;
        if (!*(_QWORD *)v64)
        {
          detail::lazy_promise<std::optional<std::vector<unsigned int>>>::result(v64 + 16);
          std::__optional_copy_base<std::vector<unsigned int>,false>::__optional_copy_base[abi:sn180100]((std::vector<unsigned int> *)v126, v79);
          if (*v125)
            (*(void (**)(void))(*v125 + 8))();
          v80 = *(_QWORD *)(v46 + 312);
          v81 = 4;
          v82 = (_QWORD *)v130;
          if (v80 == v130 || (v81 = 5, v82 = *(_QWORD **)(v46 + 312), v80))
            (*(void (**)(void))(*v82 + 8 * v81))();
          if (!*(_BYTE *)(v46 + 184))
            goto LABEL_69;
          v83 = *(void **)(v46 + 376);
          if (v83)
            operator delete(v83);
          v63 = vextq_s8(*(int8x16_t *)(v46 + 160), *(int8x16_t *)(v46 + 160), 8uLL);
          v53 = *(_QWORD *)(v46 + 176);
          *(_QWORD *)v126 = 0;
          *(_QWORD *)(v126 + 8) = 0;
          *(_QWORD *)(v126 + 16) = 0;
          v62 = *(unsigned __int16 *)(v48 + 16) | (*(unsigned __int8 *)(v48 + 18) << 16);
          v61 = *(_BYTE *)(v46 + 536);
          v60 = *(_BYTE *)(v46 + 535);
          v41 = *(unsigned __int16 *)(v48 + 12) | (*(unsigned __int8 *)(v48 + 14) << 16);
          v59 = *(_BYTE *)(v46 + 534);
          v58 = *(_BYTE *)(v46 + 533);
          v42 = *(unsigned __int16 *)(v48 + 8) | (*(unsigned __int8 *)(v48 + 10) << 16);
          v57 = *(_BYTE *)(v46 + 532);
          LOBYTE(v47) = *(_BYTE *)(v46 + 531);
          v56 = *(_BYTE *)(v46 + 530);
          v43 = *(unsigned __int16 *)(v48 + 4) | (*(unsigned __int8 *)(v48 + 6) << 16);
          v55 = *(_BYTE *)(v46 + 529);
          v54 = *(_BYTE *)(v46 + 528);
          goto LABEL_44;
        }
        v114 = 7;
        goto LABEL_77;
      case 7u:
        Backend::Google::ProtocolMessageReader::readLengthDelimitedField(*(Backend::Google::ProtocolMessageReader **)(v46 + 352), (_QWORD *)v126);
        v64 = *(_QWORD *)(v46 + 160);
        *(_QWORD *)(v46 + 440) = v64;
        if (!v64)
          goto LABEL_88;
        if (!*(_QWORD *)v64)
        {
          detail::lazy_promise<std::optional<std::vector<unsigned char>>>::result(v64 + 16);
          std::__optional_storage_base<std::vector<unsigned char>,false>::__assign_from[abi:sn180100]<std::__optional_copy_assign_base<std::vector<unsigned char>,false> const&>((uint64_t)v127, v84);
          if (*(_QWORD *)v126)
            (*(void (**)(void))(*(_QWORD *)v126 + 8))();
          if (!*(_BYTE *)(v46 + 216))
            goto LABEL_69;
          goto LABEL_43;
        }
        v114 = 8;
        goto LABEL_77;
      case 8u:
        v85 = *(_QWORD *)(v46 + 352);
        *(_QWORD *)(v46 + 256) = off_1EA3EB070;
        *(_QWORD *)(v46 + 264) = Backend::Google::FetchThreatListUpdatesResponseParser::parseChecksum;
        *(_QWORD *)(v46 + 280) = v128;
        Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::array<unsigned char,32ul>>(v85, v128, v125);
        v64 = *(_QWORD *)(v46 + 344);
        *(_QWORD *)(v46 + 448) = v64;
        if (!v64)
          goto LABEL_88;
        if (*(_QWORD *)v64)
        {
          v114 = 9;
          goto LABEL_77;
        }
        detail::lazy_promise<std::optional<std::array<unsigned char,32ul>>>::result(v64 + 16);
        v51 = *v86;
        v87 = *(_OWORD *)(v86 + 1);
        *(_OWORD *)(v126 + 15) = *((_OWORD *)v86 + 1);
        *(_OWORD *)v126 = v87;
        v47 = v86[32];
        if (*v125)
          (*(void (**)(void))(*v125 + 8))();
        v88 = *(_QWORD *)(v46 + 280);
        v89 = 4;
        v90 = (_QWORD *)v128;
        if (v88 == v128 || (v89 = 5, v90 = *(_QWORD **)(v46 + 280), v88))
          (*(void (**)(void))(*v90 + 8 * v89))();
        if (!v47)
          goto LABEL_69;
        *v124 = *(_OWORD *)v126;
        *(_OWORD *)((char *)v124 + 15) = *(_OWORD *)(v126 + 15);
        v62 = *(unsigned __int16 *)(v48 + 16) | (*(unsigned __int8 *)(v48 + 18) << 16);
        v61 = *(_BYTE *)(v46 + 536);
        v60 = *(_BYTE *)(v46 + 535);
        v41 = *(unsigned __int16 *)(v48 + 12) | (*(unsigned __int8 *)(v48 + 14) << 16);
        v59 = *(_BYTE *)(v46 + 534);
        v58 = *(_BYTE *)(v46 + 533);
        v42 = *(unsigned __int16 *)(v48 + 8) | (*(unsigned __int8 *)(v48 + 10) << 16);
        v57 = *(_BYTE *)(v46 + 532);
        v56 = *(_BYTE *)(v46 + 530);
        v43 = *(unsigned __int16 *)(v48 + 4) | (*(unsigned __int8 *)(v48 + 6) << 16);
        v55 = *(_BYTE *)(v46 + 529);
        v54 = *(_BYTE *)(v46 + 528);
        v63 = *(int8x16_t *)(v46 + 368);
        v52 = 1;
        v44 = v51;
        v53 = *(_QWORD *)(v46 + 360);
LABEL_54:
        v45 = *(unsigned __int16 *)(v48 + 20) | (*(unsigned __int8 *)(v48 + 22) << 16);
        v50 = *(_BYTE *)(v46 + 537);
        v49 = 1;
        break;
      default:
        Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v46 + 352), (_QWORD *)v126);
        v64 = *(_QWORD *)(v46 + 160);
        *(_QWORD *)(v46 + 456) = v64;
        if (!v64)
          goto LABEL_88;
        if (!*(_QWORD *)v64)
        {
          detail::lazy_promise<BOOL>::result(v64 + 16);
          v77 = *v76;
          if (*(_QWORD *)v126)
            (*(void (**)(void))(*(_QWORD *)v126 + 8))();
          if (!v77)
            goto LABEL_69;
          goto LABEL_43;
        }
        v114 = 10;
        goto LABEL_77;
    }
  }
  if (v67)
  {
    std::__throw_bad_variant_access[abi:sn180100]();
    goto LABEL_90;
  }
  if (!(_BYTE)v66
    || !*(_BYTE *)(v46 + 535)
    || !*(_BYTE *)(v46 + 533)
    || !*(_BYTE *)(v46 + 530)
    || !*(_BYTE *)(v46 + 528)
    || !*(_BYTE *)(v46 + 216)
    || !*(_BYTE *)(v46 + 526))
  {
LABEL_69:
    *(_BYTE *)(v46 + 32) = 0;
    *(_BYTE *)(v46 + 152) = 0;
    *(_DWORD *)(v46 + 24) = 1;
    v112 = *(void **)(v46 + 376);
    goto LABEL_70;
  }
  v91 = *(unsigned __int8 *)(v48 + 18);
  v92 = *(unsigned __int8 *)(v46 + 536);
  v93 = *(unsigned __int8 *)(v48 + 14);
  v94 = *(unsigned __int16 *)(v48 + 12);
  v95 = *(unsigned __int8 *)(v46 + 534);
  v96 = *(unsigned __int8 *)(v48 + 10);
  v97 = *(unsigned __int16 *)(v48 + 8);
  v98 = *(unsigned __int8 *)(v46 + 532);
  v99 = *(unsigned __int8 *)(v48 + 6);
  v100 = *(unsigned __int16 *)(v48 + 4);
  v101 = *(unsigned __int16 *)(v48 + 16) << 8;
  v102 = *(unsigned __int8 *)(v46 + 529);
  v137 = 0;
  v136 = 0u;
  v135 = 0u;
  v134 = 0u;
  v133 = 0u;
  LODWORD(v132) = v101 | (v91 << 24) | v92;
  DWORD1(v132) = (v94 << 8) | (v93 << 24) | v95;
  DWORD2(v132) = (v97 << 8) | (v96 << 24) | v98;
  HIDWORD(v132) = (v100 << 8) | (v99 << 24) | v102;
  std::vector<Backend::Google::ListUpdateResponse::Addition>::__vdeallocate((uint64_t *)&v133);
  v133 = *(_OWORD *)(v46 + 320);
  *(_QWORD *)&v134 = *(_QWORD *)(v46 + 336);
  *(_QWORD *)(v131 + 8) = 0;
  *(_QWORD *)(v131 + 16) = 0;
  *(_QWORD *)v131 = 0;
  if (*((_QWORD *)&v134 + 1))
  {
    *(_QWORD *)&v135 = *((_QWORD *)&v134 + 1);
    operator delete(*((void **)&v134 + 1));
  }
  v104 = *(_QWORD *)(v46 + 368);
  v103 = *(_QWORD *)(v46 + 376);
  v105 = *(_QWORD *)(v46 + 360);
  *((_QWORD *)&v134 + 1) = v103;
  *(_QWORD *)&v135 = v104;
  *((_QWORD *)&v135 + 1) = v105;
  if (!*(_BYTE *)(v46 + 216))
LABEL_90:
    __break(1u);
  if ((_QWORD)v136)
  {
    *((_QWORD *)&v136 + 1) = v136;
    operator delete((void *)v136);
    v103 = *((_QWORD *)&v134 + 1);
    v105 = *((_QWORD *)&v135 + 1);
    v104 = v135;
  }
  v106 = *(_BYTE *)(v46 + 525);
  v107 = *(_QWORD *)(v46 + 208);
  v108 = *(_OWORD *)(v46 + 192);
  *v127 = 0;
  v127[1] = 0;
  v127[2] = 0;
  v138[0] = v106;
  *(_OWORD *)&v138[1] = *v124;
  *(_OWORD *)&v138[16] = *(_OWORD *)((char *)v124 + 15);
  v109 = v133;
  *(_OWORD *)(v46 + 32) = v132;
  *(_OWORD *)(v46 + 48) = v109;
  v110 = v134;
  *(_QWORD *)&v134 = 0;
  v133 = 0uLL;
  *(_QWORD *)(v46 + 64) = v110;
  *(_QWORD *)(v46 + 72) = v103;
  *(_QWORD *)(v46 + 80) = v104;
  *(_QWORD *)(v46 + 88) = v105;
  *((_QWORD *)&v134 + 1) = 0;
  v135 = 0uLL;
  *(_OWORD *)(v46 + 96) = v108;
  *(_QWORD *)(v46 + 112) = v107;
  v136 = 0uLL;
  v137 = 0;
  v111 = *(_OWORD *)v138;
  *(_OWORD *)(v46 + 136) = *(_OWORD *)&v138[16];
  *(_OWORD *)(v46 + 120) = v111;
  *(_BYTE *)(v46 + 152) = 1;
  *(_DWORD *)(v46 + 24) = 1;
  Backend::Google::ListUpdateResponse::~ListUpdateResponse((Backend::Google::ListUpdateResponse *)&v132);
  v112 = 0;
LABEL_70:
  if (*(_BYTE *)(v46 + 216))
  {
    v113 = *v127;
    if (*v127)
    {
      *(_QWORD *)(v46 + 200) = v113;
      operator delete(v113);
    }
  }
  if (v112)
    operator delete(v112);
  *(_QWORD *)&v132 = v131;
  std::vector<Backend::Google::ListUpdateResponse::Addition>::__destroy_vector::operator()[abi:sn180100]((void ***)&v132);
  *(_QWORD *)v46 = 0;
  *(_BYTE *)(v48 + 55) = 11;
  v64 = *(_QWORD *)(v46 + 16);
  return (*(uint64_t (**)(uint64_t))v64)(v64);
}

void sub_1DBCD7DC0()
{
  JUMPOUT(0x1DBCD7F00);
}

void sub_1DBCD7EB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (*(_QWORD *)v17)
    (*(void (**)(void))(*(_QWORD *)v17 + 8))();
  v18 = *(_QWORD *)(v16 + 312);
  if (v18 != a16 && !v18)
    JUMPOUT(0x1DBCD7F00);
  JUMPOUT(0x1DBCD7EFCLL);
}

void sub_1DBCD7F98(__int16 *a1@<X8>)
{
  uint64_t v1;
  void **v2;
  char v3;
  __int16 v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void **v8;

  v3 = *(_BYTE *)(v1 + 524);
  v4 = *a1;
  *((_BYTE *)a1 + 22) = *((_BYTE *)a1 + 2);
  a1[10] = v4;
  *(_BYTE *)(v1 + 537) = v3;
  v5 = *(_QWORD *)(v1 + 160);
  if (v5)
    (*(void (**)(void))(v5 + 8))();
  v6 = *(void **)(v1 + 376);
  if (*(_BYTE *)(v1 + 216))
  {
    v7 = *(void **)(v1 + 192);
    if (v7)
    {
      *(_QWORD *)(v1 + 200) = v7;
      operator delete(v7);
    }
  }
  if (v6)
    operator delete(v6);
  v8 = v2;
  std::vector<Backend::Google::ListUpdateResponse::Addition>::__destroy_vector::operator()[abi:sn180100](&v8);
  detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse>>::~lazy_promise(v1 + 16);
  operator delete((void *)v1);
}

void sub_1DBCD803C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(v0 + 344);
  if (v2)
    (*(void (**)(void))(v2 + 8))();
  v3 = *(_QWORD *)(v0 + 248);
  if (v3 != v1 && !v3)
    JUMPOUT(0x1DBCD7FE0);
  JUMPOUT(0x1DBCD7FDCLL);
}

void Backend::Google::FetchThreatListUpdatesResponseParser::parseFetchThreatListUpdatesResponse(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X11 }
}

{
  __asm { BR              X11 }
}

uint64_t sub_1DBCD8154()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  char v11;
  uint64_t (**v12)(void);
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  unsigned __int8 *v28;
  int v29;
  char v30;
  char v31;
  uint64_t result;
  void **v33;

  v10 = 0;
  v11 = 0;
  *(_BYTE *)(v1 + 240) = 0;
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)v2 = 0;
  *(_BYTE *)(v2 + 24) = 0;
  while (1)
  {
    *(_WORD *)v8 = v0;
    *(_BYTE *)(v8 + 2) = BYTE2(v0);
    *(_BYTE *)(v1 + 382) = v11;
    *(_DWORD *)(v1 + 368) = v10;
    *(_BYTE *)(v1 + 381) = v7;
    *(_QWORD *)(v1 + 328) = v9;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v1 + 320), v5);
    v12 = *(uint64_t (***)(void))(v1 + 80);
    *(_QWORD *)(v1 + 336) = v12;
    if (!v12)
    {
LABEL_51:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*v12)
    {
      v31 = 1;
      goto LABEL_49;
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result((uint64_t)(v12 + 2));
    v14 = *v13;
    v15 = v13[1];
    *(_BYTE *)(v8 + 6) = HIBYTE(*v13);
    *(_WORD *)(v8 + 4) = v14 >> 8;
    *(_BYTE *)(v1 + 383) = v14;
    v16 = *(_QWORD *)(v1 + 80);
    if (v16)
      (*(void (**)(void))(v16 + 8))();
    if (v15 != 1)
      break;
    if (v14 == 2)
    {
      v23 = *(_QWORD *)(v1 + 320);
      *(_QWORD *)(v1 + 280) = off_1EA3EB0B8;
      *(_QWORD *)(v1 + 288) = Backend::Google::FetchThreatListUpdatesResponseParser::parseDuration;
      *(_QWORD *)(v1 + 304) = v4;
      Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::chrono::duration<long long,std::ratio<1l,1l>>>(v23, v4, v5);
      v12 = *(uint64_t (***)(void))(v1 + 80);
      *(_QWORD *)(v1 + 352) = v12;
      if (!v12)
        goto LABEL_51;
      if (*v12)
      {
        v31 = 3;
        goto LABEL_49;
      }
      detail::lazy_promise<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>>::result((uint64_t)(v12 + 2));
      v9 = *v24;
      v7 = *((unsigned __int8 *)v24 + 8);
      if (*v5)
        (*(void (**)(void))(*v5 + 8))();
      v25 = *(_QWORD *)(v1 + 304);
      v26 = 4;
      v27 = (_QWORD *)v4;
      if (v25 == v4 || (v26 = 5, v27 = *(_QWORD **)(v1 + 304), v25))
        (*(void (**)(void))(*v27 + 8 * v26))();
      if (!v7)
        goto LABEL_41;
      if (!*(_BYTE *)(v1 + 240))
        *(_BYTE *)(v1 + 240) = 1;
      *(_QWORD *)(v1 + 232) = v9;
    }
    else
    {
      if (v14 == 1)
      {
        v17 = *(_QWORD *)(v1 + 320);
        *(_QWORD *)(v1 + 248) = off_1EA3EAF50;
        *(_QWORD *)(v1 + 256) = Backend::Google::FetchThreatListUpdatesResponseParser::parseListUpdateResponse;
        *(_QWORD *)(v1 + 272) = v3;
        Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::ListUpdateResponse>(v17, v3, v6);
        v12 = *(uint64_t (***)(void))(v1 + 312);
        *(_QWORD *)(v1 + 344) = v12;
        if (!v12)
          goto LABEL_51;
        if (*v12)
        {
          v31 = 2;
          goto LABEL_49;
        }
        detail::lazy_promise<std::optional<Backend::Google::ListUpdateResponse>>::result((uint64_t)(v12 + 2));
        *(_BYTE *)(v1 + 80) = 0;
        *(_BYTE *)(v1 + 200) = 0;
        if (*(_BYTE *)(v18 + 120))
        {
          *(_OWORD *)v5 = *(_OWORD *)v18;
          *(_QWORD *)(v1 + 104) = 0;
          *(_QWORD *)(v1 + 112) = 0;
          *(_QWORD *)(v1 + 96) = 0;
          *(_OWORD *)(v1 + 96) = *(_OWORD *)(v18 + 16);
          *(_QWORD *)(v1 + 112) = *(_QWORD *)(v18 + 32);
          *(_QWORD *)(v18 + 16) = 0;
          *(_QWORD *)(v18 + 24) = 0;
          *(_QWORD *)(v18 + 32) = 0;
          *(_QWORD *)(v1 + 120) = 0;
          *(_QWORD *)(v1 + 128) = 0;
          *(_QWORD *)(v1 + 136) = 0;
          *(_OWORD *)(v1 + 120) = *(_OWORD *)(v18 + 40);
          *(_QWORD *)(v1 + 136) = *(_QWORD *)(v18 + 56);
          *(_QWORD *)(v18 + 40) = 0;
          *(_QWORD *)(v18 + 48) = 0;
          *(_QWORD *)(v18 + 56) = 0;
          *(_QWORD *)(v1 + 144) = 0;
          *(_QWORD *)(v1 + 152) = 0;
          *(_QWORD *)(v1 + 160) = 0;
          *(_OWORD *)(v1 + 144) = *(_OWORD *)(v18 + 64);
          *(_QWORD *)(v1 + 160) = *(_QWORD *)(v18 + 80);
          *(_QWORD *)(v18 + 64) = 0;
          *(_QWORD *)(v18 + 72) = 0;
          *(_QWORD *)(v18 + 80) = 0;
          v19 = *(_OWORD *)(v18 + 88);
          *(_OWORD *)(v1 + 184) = *(_OWORD *)(v18 + 104);
          *(_OWORD *)(v1 + 168) = v19;
          *(_BYTE *)(v1 + 200) = 1;
        }
        if (*v6)
          (*(void (**)(void))(*v6 + 8))();
        v20 = *(_QWORD *)(v1 + 272);
        v21 = 4;
        v22 = (_QWORD *)v3;
        if (v20 == v3 || (v21 = 5, v22 = *(_QWORD **)(v1 + 272), v20))
          (*(void (**)(void))(*v22 + 8 * v21))();
        if (!*(_BYTE *)(v1 + 200))
        {
          *(_BYTE *)(v1 + 32) = 0;
          *(_BYTE *)(v1 + 72) = 0;
          *(_DWORD *)(v1 + 24) = 1;
          std::__optional_destruct_base<Backend::Google::ListUpdateResponse,false>::~__optional_destruct_base[abi:sn180100]((uint64_t)v5);
          goto LABEL_44;
        }
        std::vector<Backend::Google::ListUpdateResponse>::push_back[abi:sn180100]((uint64_t *)v2, (uint64_t)v5);
        std::__optional_destruct_base<Backend::Google::ListUpdateResponse,false>::~__optional_destruct_base[abi:sn180100]((uint64_t)v5);
      }
      else
      {
        Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v1 + 320), v5);
        v12 = *(uint64_t (***)(void))(v1 + 80);
        *(_QWORD *)(v1 + 360) = v12;
        if (!v12)
          goto LABEL_51;
        if (*v12)
        {
          v31 = 4;
LABEL_49:
          *(_BYTE *)(v8 + 8) = v31;
          v12[2] = (uint64_t (*)(void))v1;
          return (*v12)();
        }
        detail::lazy_promise<BOOL>::result((uint64_t)(v12 + 2));
        v29 = *v28;
        if (*v5)
          (*(void (**)(void))(*v5 + 8))();
        if (!v29)
          goto LABEL_41;
      }
      LOBYTE(v7) = *(_BYTE *)(v1 + 381);
      v9 = *(_QWORD *)(v1 + 328);
    }
    v0 = *(unsigned __int16 *)(v8 + 4) | (*(unsigned __int8 *)(v8 + 6) << 16);
    v11 = *(_BYTE *)(v1 + 383);
    v10 = 1;
  }
  if (!v15)
  {
    if ((_BYTE)v14)
    {
      *(_OWORD *)(v1 + 32) = *(_OWORD *)(v1 + 208);
      *(_QWORD *)(v1 + 48) = *(_QWORD *)(v1 + 224);
      *(_QWORD *)(v2 + 8) = 0;
      *(_QWORD *)(v2 + 16) = 0;
      *(_QWORD *)v2 = 0;
      *(_OWORD *)(v1 + 56) = *(_OWORD *)(v1 + 232);
      v30 = 1;
    }
    else
    {
LABEL_41:
      v30 = 0;
      *(_BYTE *)(v1 + 32) = 0;
    }
    *(_BYTE *)(v1 + 72) = v30;
    *(_DWORD *)(v1 + 24) = 1;
LABEL_44:
    v33 = (void **)v2;
    std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v33);
    *(_QWORD *)v1 = 0;
    *(_BYTE *)(v8 + 8) = 5;
    v12 = *(uint64_t (***)(void))(v1 + 16);
    return (*v12)();
  }
  result = std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCD852C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _QWORD *v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100]((void ***)va);
  *v2 = 0;
  *(_BYTE *)(v3 + 8) = 5;
  _Unwind_Resume(a1);
}

void sub_1DBCD8660(__int16 *a1@<X8>)
{
  uint64_t v1;
  void **v2;
  char v3;
  __int16 v4;
  uint64_t v5;
  void **v6;

  v3 = *(_BYTE *)(v1 + 382);
  v4 = *a1;
  *((_BYTE *)a1 + 6) = *((_BYTE *)a1 + 2);
  a1[2] = v4;
  *(_BYTE *)(v1 + 383) = v3;
  v5 = *(_QWORD *)(v1 + 80);
  if (v5)
    (*(void (**)(void))(v5 + 8))();
  v6 = v2;
  std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v6);
  detail::lazy_promise<std::optional<Backend::Google::FetchThreatListUpdatesResponse>>::~lazy_promise(v1 + 16);
  operator delete((void *)v1);
}

uint64_t sub_1DBCD877C@<X0>(__int16 *a1@<X8>)
{
  uint64_t v1;
  void **v2;
  char v3;
  __int16 v4;
  uint64_t v5;
  void **v7;

  v3 = *(_BYTE *)(v1 + 382);
  v4 = *a1;
  *((_BYTE *)a1 + 6) = *((_BYTE *)a1 + 2);
  a1[2] = v4;
  *(_BYTE *)(v1 + 383) = v3;
  v5 = *(_QWORD *)(v1 + 80);
  if (v5)
    (*(void (**)(void))(v5 + 8))();
  v7 = v2;
  std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v7);
  return detail::lazy_promise<std::optional<Backend::Google::FetchThreatListUpdatesResponse>>::~lazy_promise(v1 + 16);
}

void Backend::Google::FetchThreatListUpdatesResponseParser::FetchThreatListUpdatesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>)::$_0::operator()<std::shared_ptr<ReadStream>>(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  __int128 *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  void **v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  char v15;

  v2 = a1 + 24;
  v3 = (_QWORD *)(a1 + 408);
  detail::lazy_promise<std::optional<Backend::Google::FetchThreatListUpdatesResponse>>::result(a1 + 40);
  LOBYTE(v12) = 0;
  v15 = 0;
  if (*((_BYTE *)v4 + 40))
  {
    v12 = *v4;
    v13 = *((_QWORD *)v4 + 2);
    *((_QWORD *)v4 + 1) = 0;
    *((_QWORD *)v4 + 2) = 0;
    *(_QWORD *)v4 = 0;
    v14 = *(__int128 *)((char *)v4 + 24);
    v15 = 1;
  }
  Backend::Google::FetchThreatListUpdatesResponseParser::parseFetchThreatListUpdatesResponse(v2);
  v5 = *(_QWORD *)(a1 + 432);
  if (v5)
  {
    (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v5 + 48))(v5, &v12);
    if (v15)
    {
      v11 = (void **)&v12;
      std::vector<Backend::Google::ListUpdateResponse>::__destroy_vector::operator()[abi:sn180100](&v11);
    }
    v6 = *(std::__shared_weak_count **)(a1 + 456);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    v9 = *(_QWORD **)(a1 + 432);
    if (v9 == v3)
    {
      v10 = 4;
    }
    else
    {
      if (!v9)
      {
LABEL_16:
        *(_QWORD *)a1 = 0;
        *(_BYTE *)(a1 + 17) = 1;
        return;
      }
      v10 = 5;
      v3 = *(_QWORD **)(a1 + 432);
    }
    (*(void (**)(_QWORD *))(*v3 + 8 * v10))(v3);
    goto LABEL_16;
  }
  std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
}

void sub_1DBCD8974(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v6;
  uint64_t v7;

  v4 = v3;
  Backend::Google::FetchThreatListUpdatesResponseParser::parseFetchThreatListUpdatesResponse(v4);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](*(_QWORD *)(v1 + 480));
  v6 = *(_QWORD **)(v1 + 432);
  if (v6 == v2)
  {
    v7 = 4;
  }
  else
  {
    if (!v6)
      goto LABEL_6;
    v7 = 5;
    v2 = *(_QWORD **)(v1 + 432);
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v7))(v2);
LABEL_6:
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 17) = 1;
  _Unwind_Resume(a1);
}

void Backend::Google::FetchThreatListUpdatesResponseParser::FetchThreatListUpdatesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>)::$_0::operator()<std::shared_ptr<ReadStream>>(_QWORD *__p)
{
  char *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  char *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;

  if ((*((_BYTE *)__p + 17) & 1) == 0)
  {
    v2 = (char *)(__p + 51);
    Backend::Google::FetchThreatListUpdatesResponseParser::parseFetchThreatListUpdatesResponse((uint64_t)(__p + 3));
    v3 = (std::__shared_weak_count *)__p[57];
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v6 = (char *)__p[54];
    if (v6 == v2)
    {
      v7 = 4;
      v6 = (char *)(__p + 51);
      goto LABEL_11;
    }
    if (v6)
    {
      v7 = 5;
LABEL_11:
      (*(void (**)(void))(*(_QWORD *)v6 + 8 * v7))();
    }
  }
  v8 = (std::__shared_weak_count *)__p[59];
  if (v8)
  {
    v9 = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  operator delete(__p);
}

__n128 Platform::FileOutputStream::FileOutputStream(uint64_t a1, __n128 *a2)
{
  __n128 result;

  *(_QWORD *)a1 = off_1EA3EAE78;
  result = *a2;
  *(_QWORD *)(a1 + 24) = a2[1].n128_u64[0];
  *(__n128 *)(a1 + 8) = result;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  a2->n128_u64[0] = 0;
  *(_QWORD *)(a1 + 32) = 0;
  return result;
}

void Platform::FileOutputStream::~FileOutputStream(void **this)
{
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  operator delete(this);
}

uint64_t Platform::FileOutputStream::open(Platform::FileOutputStream *this)
{
  const char *v2;
  FILE *v3;
  uint64_t v4;

  v2 = (char *)this + 8;
  if (*((char *)this + 31) < 0)
    v2 = *(const char **)v2;
  v3 = fopen(v2, "w+");
  *((_QWORD *)this + 4) = v3;
  if (v3)
  {
    std::system_category();
    return 0;
  }
  else
  {
    v4 = *__error();
    std::generic_category();
  }
  return v4;
}

uint64_t Platform::FileOutputStream::writeBytes(FILE **this, const unsigned __int8 *__ptr, size_t a3)
{
  unsigned int v5;

  if (fwrite(__ptr, 1uLL, a3, this[4]) == a3)
  {
    std::system_category();
    return 0;
  }
  else
  {
    v5 = ferror(this[4]);
    std::generic_category();
    return v5;
  }
}

uint64_t Platform::FileOutputStream::getOffset(Platform::FileOutputStream *this, unint64_t *a2)
{
  unint64_t v3;
  uint64_t v4;

  v3 = MEMORY[0x1DF0B8C2C](*((_QWORD *)this + 4));
  *a2 = v3;
  if (v3 == -1)
  {
    v4 = *__error();
    std::generic_category();
  }
  else
  {
    std::system_category();
    return 0;
  }
  return v4;
}

uint64_t Platform::FileOutputStream::seek(FILE **this, uint64_t a2)
{
  uint64_t v2;

  if (fseek(this[4], a2, 0) == -1)
  {
    v2 = *__error();
    std::generic_category();
  }
  else
  {
    std::system_category();
    return 0;
  }
  return v2;
}

uint64_t Platform::FileOutputStream::close(FILE **this)
{
  int v2;
  uint64_t v3;

  v2 = fclose(this[4]);
  this[4] = 0;
  if (v2)
  {
    v3 = *__error();
    std::generic_category();
  }
  else
  {
    std::system_category();
    return 0;
  }
  return v3;
}

_QWORD *Backend::Google::FindFullHashesRequestJSONSerializer::FindFullHashesRequestJSONSerializer(_QWORD *this, const Backend::Google::ClientInfo *a2)
{
  this[2] = 0;
  *this = a2;
  this[1] = this + 2;
  this[5] = 0;
  this[3] = 0;
  this[4] = this + 5;
  this[8] = 0;
  this[6] = 0;
  this[7] = this + 8;
  this[11] = 0;
  this[9] = 0;
  this[10] = this + 11;
  this[15] = 0;
  this[14] = 0;
  this[12] = 0;
  this[13] = this + 14;
  return this;
}

void Backend::Google::FindFullHashesRequestJSONSerializer::~FindFullHashesRequestJSONSerializer(Backend::Google::FindFullHashesRequestJSONSerializer *this)
{
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)this + 104, *((_QWORD **)this + 14));
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)this + 80, *((_QWORD **)this + 11));
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)this + 56, *((_QWORD **)this + 8));
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)this + 32, *((_QWORD **)this + 5));
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)this + 8, *((_QWORD **)this + 2));
}

uint64_t *Backend::Google::FindFullHashesRequestJSONSerializer::addHashPrefix(uint64_t **a1, unsigned __int8 *a2, int *a3, uint64_t a4, uint64_t a5)
{
  __int128 v8;

  *(_QWORD *)&v8 = a4;
  *((_QWORD *)&v8 + 1) = a5;
  std::__tree<Backend::Google::HashView>::__emplace_unique_key_args<Backend::Google::HashView,Backend::Google::HashView const&>(a1 + 1, a2, a2);
  std::__tree<Backend::Google::ThreatType>::__emplace_unique_key_args<Backend::Google::ThreatType,Backend::Google::ThreatType const&>(a1 + 4, a3, a3);
  std::__tree<Backend::Google::ThreatType>::__emplace_unique_key_args<Backend::Google::ThreatType,Backend::Google::ThreatType const&>(a1 + 7, a3 + 1, a3 + 1);
  std::__tree<Backend::Google::ThreatType>::__emplace_unique_key_args<Backend::Google::ThreatType,Backend::Google::ThreatType const&>(a1 + 10, a3 + 2, a3 + 2);
  return std::__tree<Platform::ArrayView<unsigned char>>::__emplace_unique_key_args<Platform::ArrayView<unsigned char>,Platform::ArrayView<unsigned char> const&>(a1 + 13, (unsigned __int8 **)&v8, &v8);
}

id Backend::Google::FindFullHashesRequestJSONSerializer::serializedData(Backend::Google::FindFullHashesRequestJSONSerializer *this)
{
  uint64_t *v2;
  uint64_t *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  Backend::Google::FindFullHashesRequestJSONSerializer *v10;
  void *v11;
  void *v12;
  Backend::Google::FindFullHashesRequestJSONSerializer *v13;
  Backend::Google::FindFullHashesRequestJSONSerializer *v14;
  BOOL v15;
  void *v16;
  Backend::Google::FindFullHashesRequestJSONSerializer *v17;
  void *v18;
  Backend::Google::FindFullHashesRequestJSONSerializer *v19;
  Backend::Google::FindFullHashesRequestJSONSerializer *v20;
  Backend::Google::FindFullHashesRequestJSONSerializer *v21;
  void *v22;
  Backend::Google::FindFullHashesRequestJSONSerializer *v23;
  Backend::Google::FindFullHashesRequestJSONSerializer *v24;
  void *v25;
  Backend::Google::FindFullHashesRequestJSONSerializer *v26;
  void *v27;
  Backend::Google::FindFullHashesRequestJSONSerializer *v28;
  Backend::Google::FindFullHashesRequestJSONSerializer *v29;
  void *v30;
  char *v31;
  char *v32;
  void *v33;
  void *v34;
  void *v35;
  char *v36;
  char *v37;
  void *v38;
  void *v39;
  id v40;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  uint64_t v47;
  const __CFString *v48;
  _QWORD v49[2];

  v49[1] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = *(uint64_t **)this;
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  if (*((char *)v2 + 23) >= 0)
    v3 = v2;
  else
    v3 = (uint64_t *)*v2;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v42, "setObject:forKeyedSubscript:", v4, CFSTR("clientId"));

  v7 = v2[3];
  v6 = v2 + 3;
  v5 = v7;
  if (*((char *)v6 + 23) >= 0)
    v8 = (uint64_t)v6;
  else
    v8 = v5;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v42, "setObject:forKeyedSubscript:", v9, CFSTR("clientVersion"));

  objc_msgSend(v43, "setObject:forKeyedSubscript:", v42, CFSTR("client"));
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)this + 13);
  if (v10 != (Backend::Google::FindFullHashesRequestJSONSerializer *)((char *)this + 112))
  {
    do
    {
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", *((_QWORD *)v10 + 4), *((_QWORD *)v10 + 5));
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "base64EncodedStringWithOptions:", 0);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v46, "addObject:", v12);

      v13 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)v10 + 1);
      if (v13)
      {
        do
        {
          v14 = v13;
          v13 = *(Backend::Google::FindFullHashesRequestJSONSerializer **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          v14 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)v10 + 2);
          v15 = *(_QWORD *)v14 == (_QWORD)v10;
          v10 = v14;
        }
        while (!v15);
      }
      v10 = v14;
    }
    while (v14 != (Backend::Google::FindFullHashesRequestJSONSerializer *)((char *)this + 112));
  }
  objc_msgSend(v43, "setObject:forKeyedSubscript:", v46, CFSTR("clientStates"));
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)this + 4);
  if (v17 != (Backend::Google::FindFullHashesRequestJSONSerializer *)((char *)this + 40))
  {
    do
    {
      EnumTraits::toNSStringFromEnum<Backend::Google::ThreatType>(*((_DWORD *)v17 + 7));
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v45, "addObject:", v18);

      v19 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)v17 + 1);
      if (v19)
      {
        do
        {
          v20 = v19;
          v19 = *(Backend::Google::FindFullHashesRequestJSONSerializer **)v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)v17 + 2);
          v15 = *(_QWORD *)v20 == (_QWORD)v17;
          v17 = v20;
        }
        while (!v15);
      }
      v17 = v20;
    }
    while (v20 != (Backend::Google::FindFullHashesRequestJSONSerializer *)((char *)this + 40));
  }
  objc_msgSend(v16, "setObject:forKeyedSubscript:", v45, CFSTR("threatTypes"));
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v21 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)this + 7);
  if (v21 != (Backend::Google::FindFullHashesRequestJSONSerializer *)((char *)this + 64))
  {
    do
    {
      EnumTraits::toNSStringFromEnum<Backend::Google::PlatformType>(*((_DWORD *)v21 + 7));
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v44, "addObject:", v22);

      v23 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)v21 + 1);
      if (v23)
      {
        do
        {
          v24 = v23;
          v23 = *(Backend::Google::FindFullHashesRequestJSONSerializer **)v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          v24 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)v21 + 2);
          v15 = *(_QWORD *)v24 == (_QWORD)v21;
          v21 = v24;
        }
        while (!v15);
      }
      v21 = v24;
    }
    while (v24 != (Backend::Google::FindFullHashesRequestJSONSerializer *)((char *)this + 64));
  }
  objc_msgSend(v16, "setObject:forKeyedSubscript:", v44, CFSTR("platformTypes"));
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)this + 10);
  if (v26 != (Backend::Google::FindFullHashesRequestJSONSerializer *)((char *)this + 88))
  {
    do
    {
      EnumTraits::toNSStringFromEnum<Backend::Google::ThreatEntryType>(*((_DWORD *)v26 + 7));
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v25, "addObject:", v27);

      v28 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)v26 + 1);
      if (v28)
      {
        do
        {
          v29 = v28;
          v28 = *(Backend::Google::FindFullHashesRequestJSONSerializer **)v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          v29 = (Backend::Google::FindFullHashesRequestJSONSerializer *)*((_QWORD *)v26 + 2);
          v15 = *(_QWORD *)v29 == (_QWORD)v26;
          v26 = v29;
        }
        while (!v15);
      }
      v26 = v29;
    }
    while (v29 != (Backend::Google::FindFullHashesRequestJSONSerializer *)((char *)this + 88));
  }
  objc_msgSend(v16, "setObject:forKeyedSubscript:", v25, CFSTR("threatEntryTypes"));
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = (char *)*((_QWORD *)this + 1);
  v32 = (char *)this + 16;
  if (v31 != (char *)this + 16)
  {
    do
    {
      v33 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBytes:length:", *((_QWORD *)v31 + 5), v31[32]);
      objc_msgSend(v33, "base64EncodedStringWithOptions:", 0);
      v34 = (void *)objc_claimAutoreleasedReturnValue();
      v48 = CFSTR("hash");
      v49[0] = v34;
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v49, &v48, 1);
      v35 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v30, "addObject:", v35);
      v36 = (char *)*((_QWORD *)v31 + 1);
      if (v36)
      {
        do
        {
          v37 = v36;
          v36 = *(char **)v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          v37 = (char *)*((_QWORD *)v31 + 2);
          v15 = *(_QWORD *)v37 == (_QWORD)v31;
          v31 = v37;
        }
        while (!v15);
      }
      v31 = v37;
    }
    while (v37 != v32);
  }
  objc_msgSend(v16, "setObject:forKeyedSubscript:", v30, CFSTR("threatEntries"));

  objc_msgSend(v43, "setObject:forKeyedSubscript:", v16, CFSTR("threatInfo"));
  v47 = 0;
  objc_msgSend(MEMORY[0x1E0CB36D8], "dataWithJSONObject:options:error:", v43, 0, &v47);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v39 = v38;
  if (v38)
    v40 = v38;

  return v39;
}

void sub_1DBCD9370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, void *a14)
{

  _Unwind_Resume(a1);
}

void std::__tree<Backend::Google::HashView>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<Backend::Google::HashView>::destroy(a1, *a2);
    std::__tree<Backend::Google::HashView>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t *std::__tree<Backend::Google::HashView>::__emplace_unique_key_args<Backend::Google::HashView,Backend::Google::HashView const&>(uint64_t **a1, unsigned __int8 *a2, _OWORD *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = std::__tree<Backend::Google::HashView>::__find_equal<Backend::Google::HashView>((uint64_t)a1, &v9, a2);
  v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v6 + 2) = *a3;
    std::__tree<Backend::Google::HashView>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

uint64_t *std::__tree<Backend::Google::HashView>::__find_equal<Backend::Google::HashView>(uint64_t a1, _QWORD *a2, unsigned __int8 *a3)
{
  uint64_t *result;
  uint64_t *v4;
  uint64_t *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  uint64_t *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v18;
  unsigned __int8 *v19;
  unsigned int v20;
  unsigned int v21;

  v5 = *(uint64_t **)(a1 + 8);
  result = (uint64_t *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    v6 = (unsigned __int8 *)*((_QWORD *)a3 + 1);
    v7 = *a3;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (unsigned __int8 *)v4[5];
        v10 = *((unsigned __int8 *)v8 + 32);
        if (*((_BYTE *)v8 + 32))
          break;
LABEL_12:
        if ((_DWORD)v7)
        {
          v18 = v7 - 1;
          v19 = v6;
          while (v10)
          {
            v20 = *v9;
            v21 = *v19;
            if (v20 < v21)
              break;
            ++v9;
            ++v19;
            --v10;
            if (v21 < v20 || v18-- == 0)
              goto LABEL_27;
          }
          result = v8 + 1;
          v4 = (uint64_t *)v8[1];
          if (v4)
            continue;
        }
        goto LABEL_27;
      }
      v11 = v10 - 1;
      v12 = v7;
      v13 = v6;
      v14 = v9;
      while (v12)
      {
        v15 = *v13;
        v16 = *v14;
        if (v15 < v16)
          break;
        ++v13;
        ++v14;
        --v12;
        if (v16 < v15 || v11-- == 0)
          goto LABEL_12;
      }
      v4 = (uint64_t *)*v8;
      result = v8;
    }
    while (*v8);
  }
  else
  {
    v8 = result;
  }
LABEL_27:
  *a2 = v8;
  return result;
}

uint64_t *std::__tree<Backend::Google::HashView>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t **std::__tree<Backend::Google::ThreatType>::__emplace_unique_key_args<Backend::Google::ThreatType,Backend::Google::ThreatType const&>(uint64_t **a1, int *a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  int v7;
  uint64_t **v8;
  int v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    std::__tree<Backend::Google::HashView>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *std::__tree<Platform::ArrayView<unsigned char>>::__emplace_unique_key_args<Platform::ArrayView<unsigned char>,Platform::ArrayView<unsigned char> const&>(uint64_t **a1, unsigned __int8 **a2, _OWORD *a3)
{
  void **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = (void **)std::__tree<Platform::ArrayView<unsigned char>>::__find_equal<Platform::ArrayView<unsigned char>>((uint64_t)a1, &v9, a2);
  v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v6 + 2) = *a3;
    std::__tree<Backend::Google::HashView>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

_QWORD *std::__tree<Platform::ArrayView<unsigned char>>::__find_equal<Platform::ArrayView<unsigned char>>(uint64_t a1, _QWORD *a2, unsigned __int8 **a3)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  _QWORD *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned int v15;
  unsigned int v16;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  unsigned int v20;
  unsigned int v21;

  v5 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    v6 = *a3;
    v7 = a3[1];
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (unsigned __int8 *)v4[4];
        v10 = v8[5];
        if (v10)
          break;
LABEL_12:
        if (v7)
        {
          v18 = v7 - 1;
          v19 = v6;
          while (v10)
          {
            v20 = *v9;
            v21 = *v19;
            if (v20 < v21)
              break;
            ++v9;
            ++v19;
            --v10;
            if (v21 < v20 || v18-- == 0)
              goto LABEL_27;
          }
          result = v8 + 1;
          v4 = (_QWORD *)v8[1];
          if (v4)
            continue;
        }
        goto LABEL_27;
      }
      v11 = v10 - 1;
      v12 = v7;
      v13 = v6;
      v14 = v9;
      while (v12)
      {
        v15 = *v13;
        v16 = *v14;
        if (v15 < v16)
          break;
        ++v13;
        ++v14;
        --v12;
        if (v16 < v15 || v11-- == 0)
          goto LABEL_12;
      }
      v4 = (_QWORD *)*v8;
      result = v8;
    }
    while (*v8);
  }
  else
  {
    v8 = result;
  }
LABEL_27:
  *a2 = v8;
  return result;
}

void Backend::Google::FindFullHashesRequestSerializer::serializedData(Backend::Google::FindFullHashesRequestSerializer *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  __n128 v5;
  _QWORD *v6;
  uint64_t v7;
  Backend::Google::FindFullHashesRequestSerializer *v8;
  Backend::Google::FindFullHashesRequestSerializer *v9;
  Backend::Google::FindFullHashesRequestSerializer *v10;
  BOOL v11;
  _QWORD *v12;
  __n128 v13;
  _QWORD *v14;
  uint64_t v15;
  char *v16[3];
  _QWORD v17[3];
  _QWORD *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  Backend::Google::ProtocolMessageWriter::ProtocolMessageWriter(v16);
  v4 = *(_QWORD *)this;
  v17[0] = off_1EA3EB7C0;
  v17[1] = v4;
  v18 = v17;
  v5.n128_f64[0] = Backend::Google::ProtocolMessageWriter::writeEmbeddedMessageField(v16, 1, (uint64_t)v17);
  v6 = v18;
  if (v18 == v17)
  {
    v7 = 4;
    v6 = v17;
  }
  else
  {
    if (!v18)
      goto LABEL_6;
    v7 = 5;
  }
  (*(void (**)(__n128))(*v6 + 8 * v7))(v5);
LABEL_6:
  v8 = (Backend::Google::FindFullHashesRequestSerializer *)*((_QWORD *)this + 13);
  if (v8 != (Backend::Google::FindFullHashesRequestSerializer *)((char *)this + 112))
  {
    do
    {
      Backend::Google::ProtocolMessageWriter::writeBytes(v16, 2, *((char **)v8 + 4), (char *)(*((_QWORD *)v8 + 4) + *((_QWORD *)v8 + 5)));
      v9 = (Backend::Google::FindFullHashesRequestSerializer *)*((_QWORD *)v8 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *(Backend::Google::FindFullHashesRequestSerializer **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (Backend::Google::FindFullHashesRequestSerializer *)*((_QWORD *)v8 + 2);
          v11 = *(_QWORD *)v10 == (_QWORD)v8;
          v8 = v10;
        }
        while (!v11);
      }
      v8 = v10;
    }
    while (v10 != (Backend::Google::FindFullHashesRequestSerializer *)((char *)this + 112));
  }
  v12 = operator new(0x28uLL);
  *v12 = off_1EA3EA068;
  v12[1] = (char *)this + 32;
  v12[2] = (char *)this + 56;
  v12[3] = (char *)this + 80;
  v12[4] = (char *)this + 8;
  v18 = v12;
  v13.n128_f64[0] = Backend::Google::ProtocolMessageWriter::writeEmbeddedMessageField(v16, 3, (uint64_t)v17);
  v14 = v18;
  if (v18 == v17)
  {
    v15 = 4;
    v14 = v17;
    goto LABEL_17;
  }
  if (v18)
  {
    v15 = 5;
LABEL_17:
    (*(void (**)(__n128))(*v14 + 8 * v15))(v13);
  }
  Backend::Google::ProtocolMessageWriter::finish((Backend::Google::ProtocolMessageWriter *)v16, a2);
  Backend::Google::LexicographicallyOrderedHashEnumerator::~LexicographicallyOrderedHashEnumerator((Backend::Google::LexicographicallyOrderedHashEnumerator *)v16);
}

void sub_1DBCD9BC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a15;
  if (a15 == v15)
  {
    v18 = 4;
    v17 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  Backend::Google::LexicographicallyOrderedHashEnumerator::~LexicographicallyOrderedHashEnumerator((Backend::Google::LexicographicallyOrderedHashEnumerator *)&a9);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<Backend::Google::writeThreatInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,std::set<Backend::Google::ThreatType> const&,std::set<Backend::Google::PlatformType> const&,std::set<Backend::Google::ThreatEntryType> const&,std::set<Backend::Google::HashView> const&)::$_0,std::allocator<Backend::Google::writeThreatInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,std::set<Backend::Google::ThreatType> const&,std::set<Backend::Google::PlatformType> const&,std::set<Backend::Google::ThreatEntryType> const&,std::set<Backend::Google::HashView> const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = off_1EA3EA068;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<Backend::Google::writeThreatInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,std::set<Backend::Google::ThreatType> const&,std::set<Backend::Google::PlatformType> const&,std::set<Backend::Google::ThreatEntryType> const&,std::set<Backend::Google::HashView> const&)::$_0,std::allocator<Backend::Google::writeThreatInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,std::set<Backend::Google::ThreatType> const&,std::set<Backend::Google::PlatformType> const&,std::set<Backend::Google::ThreatEntryType> const&,std::set<Backend::Google::HashView> const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = off_1EA3EA068;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<Backend::Google::writeThreatInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,std::set<Backend::Google::ThreatType> const&,std::set<Backend::Google::PlatformType> const&,std::set<Backend::Google::ThreatEntryType> const&,std::set<Backend::Google::HashView> const&)::$_0,std::allocator<Backend::Google::writeThreatInfo(Backend::Google::ProtocolMessageWriter &,unsigned int,std::set<Backend::Google::ThreatType> const&,std::set<Backend::Google::PlatformType> const&,std::set<Backend::Google::ThreatEntryType> const&,std::set<Backend::Google::HashView> const&)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::operator()(_QWORD *a1, Backend::Google::ProtocolMessageWriter *this)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  __n128 v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  __int128 v32;
  _QWORD v33[3];
  _QWORD *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v4 = (_QWORD *)a1[1];
  v7 = (_QWORD *)*v4;
  v5 = v4 + 1;
  v6 = v7;
  if (v7 != v5)
  {
    do
    {
      Backend::Google::ProtocolMessageWriter::writeUInt32Field(this, 1, *((_DWORD *)v6 + 7));
      v8 = (_QWORD *)v6[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = (_QWORD *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v9 = (_QWORD *)v6[2];
          v10 = *v9 == (_QWORD)v6;
          v6 = v9;
        }
        while (!v10);
      }
      v6 = v9;
    }
    while (v9 != v5);
  }
  v11 = (_QWORD *)a1[2];
  v14 = (_QWORD *)*v11;
  v12 = v11 + 1;
  v13 = v14;
  if (v14 != v12)
  {
    do
    {
      Backend::Google::ProtocolMessageWriter::writeUInt32Field(this, 2, *((_DWORD *)v13 + 7));
      v15 = (_QWORD *)v13[1];
      if (v15)
      {
        do
        {
          v16 = v15;
          v15 = (_QWORD *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          v16 = (_QWORD *)v13[2];
          v10 = *v16 == (_QWORD)v13;
          v13 = v16;
        }
        while (!v10);
      }
      v13 = v16;
    }
    while (v16 != v12);
  }
  v17 = (_QWORD *)a1[3];
  v20 = (_QWORD *)*v17;
  v18 = v17 + 1;
  v19 = v20;
  if (v20 != v18)
  {
    do
    {
      Backend::Google::ProtocolMessageWriter::writeUInt32Field(this, 4, *((_DWORD *)v19 + 7));
      v21 = (_QWORD *)v19[1];
      if (v21)
      {
        do
        {
          v22 = v21;
          v21 = (_QWORD *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          v22 = (_QWORD *)v19[2];
          v10 = *v22 == (_QWORD)v19;
          v19 = v22;
        }
        while (!v10);
      }
      v19 = v22;
    }
    while (v22 != v18);
  }
  v23 = (_QWORD *)a1[4];
  v26 = (_QWORD *)*v23;
  v24 = v23 + 1;
  v25 = v26;
  if (v26 != v24)
  {
    while (1)
    {
      v32 = *((_OWORD *)v25 + 2);
      v33[0] = off_1EA3EA0F8;
      v33[1] = &v32;
      v34 = v33;
      v27.n128_f64[0] = Backend::Google::ProtocolMessageWriter::writeEmbeddedMessageField((char **)this, 3, (uint64_t)v33);
      v28 = v34;
      if (v34 == v33)
        break;
      if (v34)
      {
        v29 = 5;
LABEL_27:
        (*(void (**)(__n128))(*v28 + 8 * v29))(v27);
      }
      v30 = (_QWORD *)v25[1];
      if (v30)
      {
        do
        {
          v31 = v30;
          v30 = (_QWORD *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          v31 = (_QWORD *)v25[2];
          v10 = *v31 == (_QWORD)v25;
          v25 = v31;
        }
        while (!v10);
      }
      v25 = v31;
      if (v31 == v24)
        return;
    }
    v28 = v33;
    v29 = 4;
    goto LABEL_27;
  }
}

void sub_1DBCD9F48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v16;
  uint64_t v17;

  v16 = a15;
  if (a15 == &a12)
  {
    v17 = 4;
    v16 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v16 + 8 * v17))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__func<Backend::Google::writeThreatEntry(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::HashView)::$_0,std::allocator<Backend::Google::writeThreatEntry(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::HashView)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EA0F8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Backend::Google::writeThreatEntry(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::HashView)::$_0,std::allocator<Backend::Google::writeThreatEntry(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::HashView)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EA0F8;
  a2[1] = v2;
  return result;
}

char *std::__function::__func<Backend::Google::writeThreatEntry(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::HashView)::$_0,std::allocator<Backend::Google::writeThreatEntry(Backend::Google::ProtocolMessageWriter &,unsigned int,Backend::Google::HashView)::$_0>,void ()(Backend::Google::ProtocolMessageWriter &)>::operator()(uint64_t a1, char **this)
{
  return Backend::Google::ProtocolMessageWriter::writeBytes(this, 1, *(char **)(*(_QWORD *)(a1 + 8) + 8), (char *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + **(unsigned __int8 **)(a1 + 8)));
}

void Backend::Google::FindFullHashesResponseJSONParser::parseFindFullHashesResponse(Backend::Google::FindFullHashesResponseJSONParser *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  void *v4;
  id v5;
  objc_object *v6;
  Backend::Google::SSBUtilities *v7;
  objc_object *v8;
  Backend::Google::SSBUtilities *v9;
  Backend::Google::SSBUtilities *v10;
  objc_object *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  Backend::Google::SSBUtilities *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  Backend::Google::SSBUtilities *v20;
  objc_object *v21;
  Backend::Google::FindFullHashesResponseJSONParser *v22;
  unint64_t v23;
  char v24;
  char v25;
  unint64_t v26;
  Backend::Google::SSBUtilities *v27;
  objc_object *v28;
  Backend::Google::FindFullHashesResponseJSONParser *v29;
  unint64_t v30;
  char v31;
  unint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  id v38;
  __int128 v39;
  unint64_t v40;
  void **v41;
  __int128 v42;
  _BYTE v43[48];
  uint64_t v44;
  uint64_t v45;
  char v46;
  _BYTE v47[128];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v39 = 0uLL;
  v40 = 0;
  v3 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v38 = 0;
    objc_msgSend(MEMORY[0x1E0CB36D8], "JSONObjectWithData:options:error:", v3, 0, &v38);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = v38;
    if ((Backend::Google::SSBUtilities::isKindOfNSDictionary((Backend::Google::SSBUtilities *)v4, v6) & 1) != 0)
    {
      objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("matches"));
      v7 = (Backend::Google::SSBUtilities *)objc_claimAutoreleasedReturnValue();
      v9 = v7;
      if (v7 && (Backend::Google::SSBUtilities::isKindOfNSArray(v7, v8) & 1) == 0)
      {
        *(_BYTE *)a2 = 0;
        *(_BYTE *)(a2 + 56) = 0;
      }
      else
      {
        v36 = 0u;
        v37 = 0u;
        v34 = 0u;
        v35 = 0u;
        v10 = v9;
        v12 = -[Backend::Google::SSBUtilities countByEnumeratingWithState:objects:count:](v10, "countByEnumeratingWithState:objects:count:", &v34, v47, 16);
        if (v12)
        {
          v13 = *(_QWORD *)v35;
          while (2)
          {
            for (i = 0; i != v12; ++i)
            {
              if (*(_QWORD *)v35 != v13)
                objc_enumerationMutation(v10);
              v15 = *(Backend::Google::SSBUtilities **)(*((_QWORD *)&v34 + 1) + 8 * i);
              if ((Backend::Google::SSBUtilities::isKindOfNSDictionary(v15, v11) & 1) == 0
                || (Backend::Google::FindFullHashesResponseJSONParser::parseThreatMatch(v15, (uint64_t)&v42), !v46))
              {
                *(_BYTE *)a2 = 0;
                *(_BYTE *)(a2 + 56) = 0;

                goto LABEL_35;
              }
              v16 = *((_QWORD *)&v39 + 1);
              if (*((_QWORD *)&v39 + 1) >= v40)
              {
                v19 = std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__push_back_slow_path<Backend::Google::FindFullHashesResponse::ThreatMatch>((uint64_t *)&v39, &v42);
              }
              else
              {
                if (!*((_QWORD *)&v39 + 1))
                  __break(1u);
                v17 = v42;
                v18 = *(_OWORD *)&v43[16];
                *(_OWORD *)(*((_QWORD *)&v39 + 1) + 16) = *(_OWORD *)v43;
                *(_OWORD *)(v16 + 32) = v18;
                *(_OWORD *)v16 = v17;
                *(_QWORD *)(v16 + 56) = 0;
                *(_QWORD *)(v16 + 64) = 0;
                *(_QWORD *)(v16 + 48) = 0;
                *(_OWORD *)(v16 + 48) = *(_OWORD *)&v43[32];
                *(_QWORD *)(v16 + 64) = v44;
                *(_OWORD *)&v43[32] = 0uLL;
                v44 = 0;
                *(_QWORD *)(v16 + 72) = v45;
                v19 = v16 + 80;
              }
              *((_QWORD *)&v39 + 1) = v19;
              if (v46)
              {
                v41 = (void **)&v43[32];
                std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&v41);
              }
            }
            v12 = -[Backend::Google::SSBUtilities countByEnumeratingWithState:objects:count:](v10, "countByEnumeratingWithState:objects:count:", &v34, v47, 16);
            if (v12)
              continue;
            break;
          }
        }

        objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("minimumWaitDuration"), (_QWORD)v34);
        v20 = (Backend::Google::SSBUtilities *)objc_claimAutoreleasedReturnValue();
        v22 = v20;
        if ((!v20 || (Backend::Google::SSBUtilities::isKindOfNSString(v20, v21) & 1) != 0)
          && (v23 = Backend::Google::FindFullHashesResponseJSONParser::parseDuration(v22, (NSString *)&v21->isa),
              (v25 = v24) != 0))
        {
          v26 = v23;
          objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("negativeCacheDuration"));
          v27 = (Backend::Google::SSBUtilities *)objc_claimAutoreleasedReturnValue();
          v29 = v27;
          if ((!v27 || (Backend::Google::SSBUtilities::isKindOfNSString(v27, v28) & 1) != 0)
            && (v30 = Backend::Google::FindFullHashesResponseJSONParser::parseDuration(v29, (NSString *)&v28->isa), v31))
          {
            v32 = v40;
            v33 = v39;
            v40 = 0;
            v39 = 0uLL;
            v43[16] = v25;
            *(_QWORD *)&v43[24] = v30;
            v43[32] = v31;
            *(_OWORD *)a2 = v33;
            *(_QWORD *)(a2 + 16) = v32;
            *(_QWORD *)v43 = 0;
            *(_QWORD *)&v43[8] = v26;
            v42 = 0uLL;
            *(_OWORD *)(a2 + 24) = *(_OWORD *)&v43[8];
            *(_OWORD *)(a2 + 33) = *(_OWORD *)&v43[17];
            *(_BYTE *)(a2 + 56) = 1;
            v41 = (void **)&v42;
            std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v41);
          }
          else
          {
            *(_BYTE *)a2 = 0;
            *(_BYTE *)(a2 + 56) = 0;
          }

        }
        else
        {
          *(_BYTE *)a2 = 0;
          *(_BYTE *)(a2 + 56) = 0;
        }

      }
LABEL_35:

    }
    else
    {
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 56) = 0;
    }

  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 56) = 0;
  }
  *(_QWORD *)&v42 = &v39;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100]((void ***)&v42);
}

void sub_1DBCDA34C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void **a23)
{
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;

  a23 = (void **)&a19;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&a23);
  _Unwind_Resume(a1);
}

void Backend::Google::FindFullHashesResponseJSONParser::parseThreatMatch(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  BOOL v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  BOOL v15;
  Backend::Google::SSBUtilities *v16;
  objc_object *v17;
  char isKindOfNSDictionary;
  Backend::Google::SSBUtilities *v19;
  objc_object *v20;
  Backend::Google::FindFullHashesResponseJSONParser *v21;
  unint64_t v22;
  char v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  char v28;
  __int128 v29;
  uint64_t v30;
  void **v31;
  _BYTE v32[48];
  _QWORD v33[4];
  _OWORD v34[2];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v29 = 0uLL;
  v30 = 0;
  objc_msgSend(v3, "ssb_stringForKey:", CFSTR("threatType"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "ssb_stringForKey:", CFSTR("threatEntryType"));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "ssb_stringForKey:", CFSTR("platformType"));
  v6 = objc_claimAutoreleasedReturnValue();
  v7 = (void *)v6;
  if (v4)
    v8 = v5 == 0;
  else
    v8 = 1;
  v9 = v8 || v6 == 0;
  if (v9
    || ((v10 = EnumTraits::toEnumFromNSString<Backend::Google::ThreatType>(v4),
         v11 = EnumTraits::toEnumFromNSString<Backend::Google::ThreatEntryType>(v5),
         v12 = EnumTraits::toEnumFromNSString<Backend::Google::PlatformType>(v7),
         v13 = v12,
         (v10 & 0xFF00000000) != 0)
      ? (v14 = (v12 & 0xFF00000000) == 0)
      : (v14 = 1),
        !v14 ? (v15 = (v11 & 0xFF00000000) == 0) : (v15 = 1),
        v15))
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 80) = 0;
  }
  else
  {
    objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("threat"));
    v16 = (Backend::Google::SSBUtilities *)objc_claimAutoreleasedReturnValue();
    isKindOfNSDictionary = Backend::Google::SSBUtilities::isKindOfNSDictionary(v16, v17);
    if ((isKindOfNSDictionary & 1) != 0
      && (Backend::Google::FindFullHashesResponseJSONParser::parseThreatEntry(v16, (uint64_t)v32), v32[32]))
    {
      v28 = v32[0];
      v34[0] = *(_OWORD *)&v32[1];
      *(_OWORD *)((char *)v34 + 15) = *(_OWORD *)&v32[16];
      objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("cacheDuration"));
      v19 = (Backend::Google::SSBUtilities *)objc_claimAutoreleasedReturnValue();
      v21 = v19;
      if ((!v19 || (Backend::Google::SSBUtilities::isKindOfNSString(v19, v20) & 1) != 0)
        && (v22 = Backend::Google::FindFullHashesResponseJSONParser::parseDuration(v21, (NSString *)&v20->isa), v23))
      {
        *(_DWORD *)v32 = v10;
        *(_DWORD *)&v32[4] = v13;
        *(_DWORD *)&v32[8] = v11;
        *(_DWORD *)&v32[12] = 2;
        v32[16] = v28;
        *(_OWORD *)&v32[17] = v34[0];
        *(_OWORD *)&v32[32] = *(_OWORD *)((char *)v34 + 15);
        v24 = v30;
        v25 = v29;
        v30 = 0;
        v29 = 0uLL;
        v26 = *(_OWORD *)&v32[16];
        v27 = *(_OWORD *)((char *)v34 + 15);
        *(_OWORD *)a2 = *(_OWORD *)v32;
        *(_OWORD *)(a2 + 16) = v26;
        *(_OWORD *)(a2 + 32) = v27;
        *(_OWORD *)(a2 + 48) = v25;
        memset(v33, 0, 24);
        v33[3] = v22;
        *(_QWORD *)(a2 + 64) = v24;
        *(_QWORD *)(a2 + 72) = v22;
        *(_BYTE *)(a2 + 80) = 1;
        v31 = (void **)v33;
        std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&v31);
      }
      else
      {
        *(_BYTE *)a2 = 0;
        *(_BYTE *)(a2 + 80) = 0;
      }

    }
    else
    {
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 80) = 0;
    }

  }
  *(_QWORD *)v32 = &v29;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100]((void ***)v32);

}

void sub_1DBCDA650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  a15 = (void **)&a11;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&a15);

  _Unwind_Resume(a1);
}

unint64_t Backend::Google::FindFullHashesResponseJSONParser::parseDuration(Backend::Google::FindFullHashesResponseJSONParser *this, NSString *a2)
{
  Backend::Google::FindFullHashesResponseJSONParser *v2;
  Backend::Google::FindFullHashesResponseJSONParser *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = this;
  v3 = v2;
  if (v2)
  {
    if ((unint64_t)-[Backend::Google::FindFullHashesResponseJSONParser length](v2, "length") >= 2
      && -[Backend::Google::FindFullHashesResponseJSONParser hasSuffix:](v3, "hasSuffix:", CFSTR("s")))
    {
      v4 = -[Backend::Google::FindFullHashesResponseJSONParser longLongValue](v3, "longLongValue");
      v5 = v4 & 0xFFFFFFFFFFFFFF00;
      v6 = v4;
    }
    else
    {
      v6 = 0;
      v5 = 0;
    }
  }
  else
  {
    v6 = 0;
    v5 = 0;
  }

  return v5 | v6;
}

void sub_1DBCDA758(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void Backend::Google::FindFullHashesResponseJSONParser::parseThreatEntry(void *a1@<X0>, uint64_t a2@<X8>)
{
  void *v3;
  void *v4;
  id v5;
  const void *v6;
  size_t v7;
  __int128 v8;
  id v9;
  _OWORD __dst[2];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a1, "ssb_stringForKey:", CFSTR("hash"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3)
  {
    v9 = v3;
    v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", v3, 1);
    if (objc_msgSend(v4, "length") == 32)
    {
      v5 = objc_retainAutorelease(v4);
      v6 = (const void *)objc_msgSend(v5, "bytes");
      v7 = objc_msgSend(v5, "length");
      if (v7)
        memcpy(__dst, v6, v7);
      v8 = __dst[1];
      *(_OWORD *)a2 = __dst[0];
      *(_OWORD *)(a2 + 16) = v8;
      *(_BYTE *)(a2 + 32) = 1;
    }
    else
    {
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 32) = 0;
    }

    v3 = v9;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 32) = 0;
  }

}

void sub_1DBCDA86C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  void *v9;

  _Unwind_Resume(a1);
}

uint64_t std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__push_back_slow_path<Backend::Google::FindFullHashesResponse::ThreatMatch>(uint64_t *a1, __int128 *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  __int128 v13;
  __int128 v14;
  char *v15;
  uint64_t v16;
  void *v18[5];

  v2 = *a1;
  v3 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  v4 = v3 + 1;
  if (v3 + 1 > 0x333333333333333)
LABEL_13:
    abort();
  v8 = a1[2];
  v7 = a1 + 2;
  v9 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - v2) >> 4);
  if (2 * v9 > v4)
    v4 = 2 * v9;
  if (v9 >= 0x199999999999999)
    v10 = 0x333333333333333;
  else
    v10 = v4;
  v18[4] = v7;
  if (v10)
    v11 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FindFullHashesResponse::ThreatMatch>>((uint64_t)v7, v10);
  else
    v11 = 0;
  v12 = &v11[80 * v3];
  v18[0] = v11;
  v18[1] = v12;
  v18[3] = &v11[80 * v10];
  if (!v11)
  {
    __break(1u);
    goto LABEL_13;
  }
  v13 = *a2;
  v14 = a2[2];
  *((_OWORD *)v12 + 1) = a2[1];
  *((_OWORD *)v12 + 2) = v14;
  *(_OWORD *)v12 = v13;
  v15 = &v11[80 * v3];
  *((_QWORD *)v15 + 7) = 0;
  *((_QWORD *)v15 + 8) = 0;
  *((_QWORD *)v15 + 6) = 0;
  *((_OWORD *)v15 + 3) = a2[3];
  *((_QWORD *)v15 + 8) = *((_QWORD *)a2 + 8);
  *((_QWORD *)a2 + 6) = 0;
  *((_QWORD *)a2 + 7) = 0;
  *((_QWORD *)a2 + 8) = 0;
  *((_QWORD *)v15 + 9) = *((_QWORD *)a2 + 9);
  v18[2] = v12 + 80;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__swap_out_circular_buffer(a1, v18);
  v16 = a1[1];
  std::__split_buffer<Backend::Google::FindFullHashesResponse::ThreatMatch>::~__split_buffer(v18);
  return v16;
}

void sub_1DBCDA9B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Backend::Google::FindFullHashesResponse::ThreatMatch>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  if (v2 != *result)
  {
    v5 = 0;
    do
    {
      v6 = v4 + v5;
      v7 = v2 + v5;
      v8 = *(_OWORD *)(v2 + v5 - 80);
      v9 = *(_OWORD *)(v2 + v5 - 48);
      *(_OWORD *)(v6 - 64) = *(_OWORD *)(v2 + v5 - 64);
      *(_OWORD *)(v6 - 48) = v9;
      *(_OWORD *)(v6 - 80) = v8;
      *(_QWORD *)(v6 - 24) = 0;
      *(_QWORD *)(v6 - 16) = 0;
      *(_QWORD *)(v6 - 32) = 0;
      *(_OWORD *)(v6 - 32) = *(_OWORD *)(v2 + v5 - 32);
      v10 = *(_QWORD *)(v2 + v5 - 8);
      *(_QWORD *)(v6 - 16) = *(_QWORD *)(v2 + v5 - 16);
      *(_QWORD *)(v7 - 32) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v6 - 8) = v10;
      v5 -= 80;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  v11 = *result;
  *result = v4;
  a2[1] = v11;
  v12 = result[1];
  result[1] = a2[2];
  a2[2] = v12;
  v13 = result[2];
  result[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FindFullHashesResponse::ThreatMatch>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(80 * a2);
}

void **std::__split_buffer<Backend::Google::FindFullHashesResponse::ThreatMatch>::~__split_buffer(void **a1)
{
  std::__split_buffer<Backend::Google::FindFullHashesResponse::ThreatMatch>::clear[abi:sn180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<Backend::Google::FindFullHashesResponse::ThreatMatch>::clear[abi:sn180100](uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 80;
    v4 = (void **)(i - 32);
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&v4);
  }
}

void std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void **v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 80;
        v7 = (void **)(v4 - 32);
        std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&v7);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::__destroy_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,0>(uint64_t a1)
{
  if (a1)
  {
    if (*(char *)(a1 + 47) < 0)
      operator delete(*(void **)(a1 + 24));
    if (*(char *)(a1 + 23) < 0)
      operator delete(*(void **)a1);
  }
  else
  {
    __break(1u);
  }
}

_QWORD *Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(_QWORD *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = a2[1];
  v13 = *a2;
  v14 = (std::__shared_weak_count *)v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v15[0] = off_1EA3EB6E8;
  v15[1] = a3;
  v16 = v15;
  CoroutineCaller<std::shared_ptr<ReadStream>>::CoroutineCaller(a1, &v13, (uint64_t)v15);
  v7 = v16;
  if (v16 == v15)
  {
    v8 = 4;
    v7 = v15;
    goto LABEL_8;
  }
  if (v16)
  {
    v8 = 5;
LABEL_8:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  v9 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return a1;
}

void sub_1DBCDAD60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a15;
  if (a15 == v15)
  {
    v18 = 4;
    v17 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FindFullHashesResponseParser::parseFindFullHashesResponse@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x1A0uLL);
  *result = Backend::Google::FindFullHashesResponseParser::parseFindFullHashesResponse;
  result[1] = Backend::Google::FindFullHashesResponseParser::parseFindFullHashesResponse;
  result[39] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 404) = 0;
  return result;
}

uint64_t Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0xF8uLL);
  *v6 = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch>;
  v6[1] = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch>;
  v6[26] = a1;
  result = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v6 + 15), a2);
  v6[2] = 0;
  *((_DWORD *)v6 + 6) = 0;
  *a3 = v6;
  *((_BYTE *)v6 + 240) = 0;
  return result;
}

void sub_1DBCDAE5C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FindFullHashesResponseParser::parseThreatMatch@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x1B8uLL);
  *result = Backend::Google::FindFullHashesResponseParser::parseThreatMatch;
  result[1] = Backend::Google::FindFullHashesResponseParser::parseThreatMatch;
  result[35] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 423) = 0;
  return result;
}

_QWORD *Backend::Google::FindFullHashesResponseParser::parseDuration@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x90uLL);
  *result = Backend::Google::FindFullHashesResponseParser::parseDuration;
  result[1] = Backend::Google::FindFullHashesResponseParser::parseDuration;
  result[7] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 136) = 0;
  return result;
}

_QWORD *Backend::Google::FindFullHashesResponseParser::parseThreatEntry@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0xA0uLL);
  *result = Backend::Google::FindFullHashesResponseParser::parseThreatEntry;
  result[1] = Backend::Google::FindFullHashesResponseParser::parseThreatEntry;
  result[10] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 155) = 0;
  return result;
}

uint64_t Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0xC0uLL);
  *v6 = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>;
  v6[1] = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>;
  v6[19] = a1;
  result = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v6 + 8), a2);
  v6[2] = 0;
  *((_DWORD *)v6 + 6) = 0;
  *a3 = v6;
  *((_BYTE *)v6 + 184) = 0;
  return result;
}

void sub_1DBCDAFC8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FindFullHashesResponseParser::parseThreatEntryMetadata@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0xE8uLL);
  *result = Backend::Google::FindFullHashesResponseParser::parseThreatEntryMetadata;
  result[1] = Backend::Google::FindFullHashesResponseParser::parseThreatEntryMetadata;
  result[23] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 228) = 0;
  return result;
}

uint64_t Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0xD8uLL);
  *v6 = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>;
  v6[1] = Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>;
  v6[22] = a1;
  result = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(v6 + 11), a2);
  v6[2] = 0;
  *((_DWORD *)v6 + 6) = 0;
  *a3 = v6;
  *((_BYTE *)v6 + 208) = 0;
  return result;
}

void sub_1DBCDB094(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::FindFullHashesResponseParser::parseThreatEntryMetadataEntry@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0xF0uLL);
  *result = Backend::Google::FindFullHashesResponseParser::parseThreatEntryMetadataEntry;
  result[1] = Backend::Google::FindFullHashesResponseParser::parseThreatEntryMetadataEntry;
  result[20] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 135) = 0;
  return result;
}

uint64_t std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::push_back[abi:sn180100](char **a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  __int128 v18;
  __int128 v19;
  unint64_t v20;
  char *v21;
  char *v22;
  __int128 v23;
  __int128 v24;
  int64x2_t v25;
  char *v26;
  uint64_t v27;
  int64x2_t v28;
  char *v29;
  uint64_t v30;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (v7 < v6)
  {
    if (v7)
    {
      v8 = *a2;
      *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
      *(_OWORD *)v7 = v8;
      *((_QWORD *)a2 + 1) = 0;
      *((_QWORD *)a2 + 2) = 0;
      *(_QWORD *)a2 = 0;
      v9 = *(__int128 *)((char *)a2 + 24);
      *(_QWORD *)(v7 + 40) = *((_QWORD *)a2 + 5);
      *(_OWORD *)(v7 + 24) = v9;
      *((_QWORD *)a2 + 4) = 0;
      *((_QWORD *)a2 + 5) = 0;
      *((_QWORD *)a2 + 3) = 0;
      v10 = (char *)(v7 + 48);
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (_QWORD)*a1) >> 4);
  v12 = v11 + 1;
  if (v11 + 1 > 0x555555555555555)
    goto LABEL_20;
  v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (_QWORD)*a1) >> 4);
  if (2 * v13 > v12)
    v12 = 2 * v13;
  if (v13 >= 0x2AAAAAAAAAAAAAALL)
    v14 = 0x555555555555555;
  else
    v14 = v12;
  v30 = result;
  if (!v14
    || (v15 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>(result, v14)) == 0)
  {
LABEL_19:
    __break(1u);
LABEL_20:
    abort();
  }
  v17 = &v15[48 * v11];
  v18 = *a2;
  *((_QWORD *)v17 + 2) = *((_QWORD *)a2 + 2);
  *(_OWORD *)v17 = v18;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  v19 = *(__int128 *)((char *)a2 + 24);
  *((_QWORD *)v17 + 5) = *((_QWORD *)a2 + 5);
  *(_OWORD *)(v17 + 24) = v19;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 5) = 0;
  *((_QWORD *)a2 + 3) = 0;
  v21 = *a1;
  v20 = (unint64_t)a1[1];
  if ((char *)v20 == *a1)
  {
    v25 = vdupq_n_s64(v20);
    v22 = &v15[48 * v11];
  }
  else
  {
    v22 = &v15[48 * v11];
    do
    {
      v23 = *(_OWORD *)(v20 - 48);
      *((_QWORD *)v22 - 4) = *(_QWORD *)(v20 - 32);
      *((_OWORD *)v22 - 3) = v23;
      *(_QWORD *)(v20 - 40) = 0;
      *(_QWORD *)(v20 - 32) = 0;
      *(_QWORD *)(v20 - 48) = 0;
      v24 = *(_OWORD *)(v20 - 24);
      *((_QWORD *)v22 - 1) = *(_QWORD *)(v20 - 8);
      *(_OWORD *)(v22 - 24) = v24;
      v22 -= 48;
      *(_QWORD *)(v20 - 16) = 0;
      *(_QWORD *)(v20 - 8) = 0;
      *(_QWORD *)(v20 - 24) = 0;
      v20 -= 48;
    }
    while ((char *)v20 != v21);
    v25 = *(int64x2_t *)a1;
  }
  v10 = v17 + 48;
  *a1 = v22;
  a1[1] = v17 + 48;
  v28 = v25;
  v26 = a1[2];
  a1[2] = &v15[48 * v16];
  v29 = v26;
  v27 = v25.i64[0];
  result = std::__split_buffer<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::~__split_buffer((uint64_t)&v27);
LABEL_18:
  a1[1] = v10;
  return result;
}

void detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCDB2F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

_BYTE *std::__optional_copy_base<Backend::Google::FindFullHashesResponse::ThreatMatch,false>::__optional_copy_base[abi:sn180100](_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[80] = 0;
  if (*(_BYTE *)(a2 + 80))
  {
    std::construct_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch,Backend::Google::FindFullHashesResponse::ThreatMatch const&,Backend::Google::FindFullHashesResponse::ThreatMatch*>((uint64_t)a1, (__int128 *)a2);
    a1[80] = 1;
  }
  return a1;
}

void sub_1DBCDB350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  if (*(_BYTE *)(v10 + 80))
  {
    a10 = v10 + 48;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100]((void ***)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::construct_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch,Backend::Google::FindFullHashesResponse::ThreatMatch const&,Backend::Google::FindFullHashesResponse::ThreatMatch*>(uint64_t result, __int128 *a2)
{
  uint64_t v3;
  __int128 v4;
  __int128 v5;

  if (result)
  {
    v3 = result;
    v4 = *a2;
    v5 = a2[2];
    *(_OWORD *)(result + 16) = a2[1];
    *(_OWORD *)(result + 32) = v5;
    *(_OWORD *)result = v4;
    *(_QWORD *)(result + 56) = 0;
    *(_QWORD *)(result + 64) = 0;
    *(_QWORD *)(result + 48) = 0;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__init_with_size[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*>((std::string *)(result + 48), *((_QWORD *)a2 + 6), *((_QWORD *)a2 + 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)a2 + 7) - *((_QWORD *)a2 + 6)) >> 4));
    *(_QWORD *)(v3 + 72) = *((_QWORD *)a2 + 9);
    return v3;
  }
  else
  {
    __break(1u);
  }
  return result;
}

std::string *std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__init_with_size[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*>(std::string *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  std::string *v6;

  if (a4)
  {
    v6 = result;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__vallocate[abi:sn180100](result, a4);
    return std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__construct_at_end<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*>(v6, a2, a3);
  }
  return result;
}

char *std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__vallocate[abi:sn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x555555555555556)
    abort();
  result = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

std::string *std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__construct_at_end<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*>(std::string *result, uint64_t a2, uint64_t a3)
{
  std::string *v3;
  std::string::size_type size;
  uint64_t v7;

  v3 = result;
  size = result->__r_.__value_.__l.__size_;
  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      result = std::construct_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry&,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*>((std::string *)(size + v7), (__int128 *)(a2 + v7));
      v7 += 48;
    }
    while (a2 + v7 != a3);
    size += v7;
  }
  v3->__r_.__value_.__l.__size_ = size;
  return result;
}

void sub_1DBCDB4E4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(48 * a2);
}

std::string *std::construct_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry&,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*>(std::string *this, __int128 *a2)
{
  std::string *v3;
  __int128 v4;
  std::string *v5;
  __int128 v6;

  if (this)
  {
    v3 = this;
    if (*((char *)a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    }
    else
    {
      v4 = *a2;
      this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
    }
    v5 = v3 + 1;
    if (*((char *)a2 + 47) < 0)
    {
      std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
    }
    else
    {
      v6 = *(__int128 *)((char *)a2 + 24);
      v3[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
      *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
    }
    return v3;
  }
  else
  {
    __break(1u);
  }
  return this;
}

void sub_1DBCDB5B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void detail::lazy_promise<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCDB614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

std::string *std::__optional_copy_base<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>,false>::__optional_copy_base[abi:sn180100](std::string *a1, uint64_t a2)
{
  a1->__r_.__value_.__s.__data_[0] = 0;
  a1[1].__r_.__value_.__s.__data_[0] = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    std::construct_at[abi:sn180100]<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>,std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry> const&,std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>*>(a1, (uint64_t *)a2);
    a1[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return a1;
}

void sub_1DBCDB670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  if (*(_BYTE *)(v10 + 24))
  {
    a10 = v10;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100]((void ***)&a10);
  }
  _Unwind_Resume(exception_object);
}

std::string *std::construct_at[abi:sn180100]<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>,std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry> const&,std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>*>(std::string *result, uint64_t *a2)
{
  std::string *v2;

  if (result)
  {
    v2 = result;
    result->__r_.__value_.__r.__words[0] = 0;
    result->__r_.__value_.__l.__size_ = 0;
    result->__r_.__value_.__r.__words[2] = 0;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__init_with_size[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*>(result, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4));
    return v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__vdeallocate(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 48;
        std::__destroy_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,0>(v3);
      }
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCDB78C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

std::string *std::__optional_copy_base<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,false>::__optional_copy_base[abi:sn180100](std::string *this, uint64_t a2)
{
  this->__r_.__value_.__s.__data_[0] = 0;
  this[2].__r_.__value_.__s.__data_[0] = 0;
  if (*(_BYTE *)(a2 + 48))
  {
    std::construct_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry const&,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*>(this, (__int128 *)a2);
    this[2].__r_.__value_.__s.__data_[0] = 1;
  }
  return this;
}

void sub_1DBCDB7E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__optional_destruct_base<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,false>::~__optional_destruct_base[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

std::string *std::construct_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry const&,Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry*>(std::string *this, __int128 *a2)
{
  std::string *v3;
  __int128 v4;
  std::string *v5;
  __int128 v6;

  if (this)
  {
    v3 = this;
    if (*((char *)a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    }
    else
    {
      v4 = *a2;
      this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
    }
    v5 = v3 + 1;
    if (*((char *)a2 + 47) < 0)
    {
      std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
    }
    else
    {
      v6 = *(__int128 *)((char *)a2 + 24);
      v3[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
      *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
    }
    return v3;
  }
  else
  {
    __break(1u);
  }
  return this;
}

void sub_1DBCDB874(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__optional_destruct_base<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,false>::~__optional_destruct_base[abi:sn180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 48))
  {
    if (*(char *)(a1 + 47) < 0)
      operator delete(*(void **)(a1 + 24));
    if (*(char *)(a1 + 23) < 0)
      operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 48;
    std::__destroy_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,0>(i - 48);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void detail::lazy_promise<std::optional<std::string>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCDB96C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

std::string *std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100](std::string *this, uint64_t a2)
{
  this->__r_.__value_.__s.__data_[0] = 0;
  this[1].__r_.__value_.__s.__data_[0] = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    std::construct_at[abi:sn180100]<std::string,std::string const&,std::string*>(this, (__int128 *)a2);
    this[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return this;
}

void sub_1DBCDB9C0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 24))
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100](v1);
  _Unwind_Resume(exception_object);
}

std::string *std::construct_at[abi:sn180100]<std::string,std::string const&,std::string*>(std::string *this, __int128 *a2)
{
  std::string *v2;
  __int128 v3;

  if (this)
  {
    v2 = this;
    if (*((char *)a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    }
    else
    {
      v3 = *a2;
      this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
    }
    return v2;
  }
  else
  {
    __break(1u);
  }
  return this;
}

_QWORD *std::__function::__func<Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &&)::$_0,std::allocator<std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &>,Task ()(std::shared_ptr<ReadStream>)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EB6E8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &&)::$_0,std::allocator<std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &>,Task ()(std::shared_ptr<ReadStream>)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EB6E8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &&)::$_0,std::allocator<std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &>,Task ()(std::shared_ptr<ReadStream>)>::operator()(uint64_t a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  std::__shared_weak_count *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;

  v6 = *a2;
  v5 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  v7 = operator new(0x208uLL);
  v8 = v7;
  *v7 = Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &&)::$_0::operator()<std::shared_ptr<ReadStream>>;
  v7[1] = Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &&)::$_0::operator()<std::shared_ptr<ReadStream>>;
  v9 = v7 + 59;
  v7[62] = v6;
  v7[63] = v5;
  *a3 = v7;
  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(_QWORD *)(v10 + 24);
  if (!v11)
  {
    v7[58] = 0;
    if (v5)
      goto LABEL_6;
LABEL_14:
    *((_DWORD *)v8 + 118) = 0;
    v14 = v8 + 60;
    v8[60] = v6;
    v8[61] = 0;
    goto LABEL_15;
  }
  if (v11 == v10)
  {
    v7[58] = v7 + 55;
    (*(void (**)(_QWORD))(**(_QWORD **)(v10 + 24) + 24))(*(_QWORD *)(v10 + 24));
    if (v5)
      goto LABEL_6;
    goto LABEL_14;
  }
  v7[58] = v11;
  *(_QWORD *)(v10 + 24) = 0;
  if (!v5)
    goto LABEL_14;
LABEL_6:
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  *((_DWORD *)v8 + 118) = 0;
  v14 = v8 + 60;
  v8[60] = v6;
  v8[61] = v5;
  do
    v15 = __ldxr(p_shared_owners);
  while (__stxr(v15 + 1, p_shared_owners));
  do
    v16 = __ldaxr(p_shared_owners);
  while (__stlxr(v16 - 1, p_shared_owners));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_15:
  v8[64] = v14;
  v8[3] = Backend::Google::FindFullHashesResponseParser::parseFindFullHashesResponse;
  v8[42] = v9;
  *((_DWORD *)v8 + 12) = 0;
  *((_BYTE *)v8 + 428) = 0;
  *((_BYTE *)v8 + 17) = 0;
  v8[4] = Backend::Google::FindFullHashesResponseParser::parseFindFullHashesResponse;
  v8[5] = v8;
  Backend::Google::FindFullHashesResponseParser::parseFindFullHashesResponse((uint64_t)(v8 + 3));
}

void sub_1DBCDBBD0(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;

  if (v1)
    std::__function::__func<Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &&)::$_0,std::allocator<std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &>,Task ()(std::shared_ptr<ReadStream>)>::operator()(v1);
  _Unwind_Resume(exception_object);
}

void detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse>>::result(uint64_t a1)
{
  std::exception_ptr v1;
  std::exception_ptr v2;

  if (*(_DWORD *)(a1 + 8) == 2)
  {
    std::exception_ptr::exception_ptr(&v2, (const std::exception_ptr *)(a1 + 16));
    v1.__ptr_ = &v2;
    std::rethrow_exception(v1);
    __break(1u);
  }
}

void sub_1DBCDBC30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

uint64_t detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse>>::~lazy_promise(uint64_t a1)
{
  int v2;
  void **v4;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1 && *(_BYTE *)(a1 + 72))
  {
    v4 = (void **)(a1 + 16);
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v4);
  }
  return a1;
}

_BYTE *std::__optional_move_base<Backend::Google::FindFullHashesResponse::ThreatMatch,false>::__optional_move_base[abi:sn180100](_BYTE *a1, __int128 *a2)
{
  *a1 = 0;
  a1[80] = 0;
  std::__optional_storage_base<Backend::Google::FindFullHashesResponse::ThreatMatch,false>::__construct_from[abi:sn180100]<std::__optional_move_base<Backend::Google::FindFullHashesResponse::ThreatMatch,false>>((uint64_t)a1, a2);
  return a1;
}

void sub_1DBCDBCD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  if (*(_BYTE *)(v10 + 80))
  {
    a10 = v10 + 48;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100]((void ***)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__optional_storage_base<Backend::Google::FindFullHashesResponse::ThreatMatch,false>::__construct_from[abi:sn180100]<std::__optional_move_base<Backend::Google::FindFullHashesResponse::ThreatMatch,false>>(uint64_t result, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  uint64_t v4;

  if (*((_BYTE *)a2 + 80))
  {
    if (result)
    {
      v2 = *a2;
      v3 = a2[2];
      *(_OWORD *)(result + 16) = a2[1];
      *(_OWORD *)(result + 32) = v3;
      *(_OWORD *)result = v2;
      *(_QWORD *)(result + 56) = 0;
      *(_QWORD *)(result + 64) = 0;
      *(_QWORD *)(result + 48) = 0;
      *(_OWORD *)(result + 48) = a2[3];
      v4 = *((_QWORD *)a2 + 9);
      *(_QWORD *)(result + 64) = *((_QWORD *)a2 + 8);
      *((_QWORD *)a2 + 7) = 0;
      *((_QWORD *)a2 + 8) = 0;
      *((_QWORD *)a2 + 6) = 0;
      *(_QWORD *)(result + 72) = v4;
      *(_BYTE *)(result + 80) = 1;
    }
    else
    {
      __break(1u);
    }
  }
  return result;
}

_QWORD *std::__function::__func<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EAFE0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EAFE0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>> ()(Backend::Google::ProtocolMessageReader &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>>::~lazy_promise(uint64_t a1)
{
  int v2;
  void **v4;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1 && *(_BYTE *)(a1 + 96))
  {
    v4 = (void **)(a1 + 64);
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&v4);
  }
  return a1;
}

_QWORD *std::__function::__func<Lazy<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EB100;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EB100;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>> ()(Backend::Google::ProtocolMessageReader &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t detail::lazy_promise<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>>::~lazy_promise(uint64_t a1)
{
  int v2;
  void **v4;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1 && *(_BYTE *)(a1 + 40))
  {
    v4 = (void **)(a1 + 16);
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&v4);
  }
  return a1;
}

_QWORD *std::__function::__func<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1EA3EAF98;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>> ()(Backend::Google::ProtocolMessageReader &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1EA3EAF98;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>> (*)(Backend::Google::ProtocolMessageReader &),std::allocator<Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>> (*)(Backend::Google::ProtocolMessageReader &)>,Lazy<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>> ()(Backend::Google::ProtocolMessageReader &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>::~lazy_promise(uint64_t a1)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1)
  {
    std::__optional_destruct_base<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,false>::~__optional_destruct_base[abi:sn180100](a1 + 16);
  }
  return a1;
}

std::string *Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch>(uint64_t a1)
{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  __int128 *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::string *result;

  v3 = (uint64_t *)(a1 + 152);
  v4 = (_QWORD *)(a1 + 176);
  if (*(_BYTE *)(a1 + 240))
  {
    if (*(_BYTE *)(a1 + 240) != 1)
    {
      v5 = *(_QWORD *)(a1 + 232);
LABEL_31:
      detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>>::result(v5 + 16);
      std::__optional_move_base<Backend::Google::FindFullHashesResponse::ThreatMatch,false>::__optional_move_base[abi:sn180100]((_BYTE *)(a1 + 32), v18);
      *(_DWORD *)(a1 + 24) = 1;
      v19 = *(_QWORD *)(a1 + 200);
      if (v19)
        (*(void (**)(void))(v19 + 8))();
      v20 = *(std::__shared_weak_count **)(a1 + 192);
      if (v20)
      {
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          v22 = __ldaxr(p_shared_owners);
        while (__stlxr(v22 - 1, p_shared_owners));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      if (*(_BYTE *)(a1 + 168))
      {
        v23 = *(std::__shared_weak_count **)(a1 + 160);
        if (v23)
        {
          v24 = (unint64_t *)&v23->__shared_owners_;
          do
            v25 = __ldaxr(v24);
          while (__stlxr(v25 - 1, v24));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
      }
      goto LABEL_44;
    }
    v5 = *(_QWORD *)(a1 + 216);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 208), v4);
    v5 = *(_QWORD *)(a1 + 176);
    *(_QWORD *)(a1 + 216) = v5;
    if (!v5)
      goto LABEL_46;
    if (*(_QWORD *)v5)
    {
      v6 = 1;
LABEL_30:
      *(_BYTE *)(a1 + 240) = v6;
      *(_QWORD *)(v5 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v5)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v5 + 16);
  *(_BYTE *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 168) = 0;
  v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(_BYTE *)(v7 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v7 + 8);
    *(_QWORD *)(a1 + 152) = *(_QWORD *)v7;
    *(_QWORD *)(a1 + 160) = v1;
    if (v1)
    {
      v9 = (unint64_t *)&v1->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    *(_BYTE *)(a1 + 168) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v8)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 112) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_44:
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 240) = 3;
    v5 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v5)();
  }
  v11 = *v3;
  if (v1)
  {
    v12 = (unint64_t *)&v1->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    *(_QWORD *)(a1 + 184) = v11;
    v14 = a1 + 184;
    *(_DWORD *)(a1 + 176) = 0;
    *(_QWORD *)(a1 + 192) = v1;
    do
      v15 = __ldxr(v12);
    while (__stxr(v15 + 1, v12));
    do
      v16 = __ldaxr(v12);
    while (__stlxr(v16 - 1, v12));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 184) = v11;
    v14 = a1 + 184;
    *(_DWORD *)(a1 + 176) = 0;
    *(_QWORD *)(a1 + 192) = 0;
  }
  *(_QWORD *)(a1 + 224) = v14;
  v17 = *(_QWORD *)(a1 + 144);
  if (v17)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v4);
    v5 = *(_QWORD *)(a1 + 200);
    *(_QWORD *)(a1 + 232) = v5;
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        v6 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_46:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCDC1FC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 240) = 3;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch>(uint64_t a1)
{
  __asm { BR              X10 }
}

void sub_1DBCDC29C()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = v0[22];
  if (v3)
    (*(void (**)(void))(v3 + 8))();
  detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>>::~lazy_promise(v2);
  v4 = (_QWORD *)v0[18];
  if (v4 == v1)
  {
    v5 = 4;
    goto LABEL_7;
  }
  if (v4)
  {
    v5 = 5;
    v1 = (_QWORD *)v0[18];
LABEL_7:
    (*(void (**)(_QWORD *))(*v1 + 8 * v5))(v1);
  }
  operator delete(v0);
}

void sub_1DBCDC5FC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 168) = 3;
  _Unwind_Resume(exception_object);
}

void sub_1DBCDC698(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;

  v16 = *(_QWORD *)(v14 + 104);
  if (v16)
    (*(void (**)(void))(v16 + 8))();
  if (*(_DWORD *)(v14 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v14 + 32));
  v17 = *(_QWORD **)(v14 + 72);
  if (v17 == v15)
  {
    v18 = 4;
    goto LABEL_9;
  }
  if (v17)
  {
    v18 = 5;
    v15 = *(_QWORD **)(v14 + 72);
LABEL_9:
    (*(void (**)(_QWORD *))(*v15 + 8 * v18))(v15);
  }
  operator delete((void *)v14);
}

void Backend::Google::FindFullHashesResponseParser::parseDuration(uint64_t a1)
{
  __asm { BR              X15 }
}

{
  __asm { BR              X10 }
}

uint64_t sub_1DBCDC7D8()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  char v10;
  int v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  unsigned __int8 *v17;
  int v18;
  int v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  char v24;
  uint64_t result;

  v2 = *(_QWORD *)(v0 + 88);
  while (1)
  {
    detail::lazy_promise<ReadResult<unsigned int>>::result(v2 + 16);
    v4 = *v3;
    v5 = v3[1];
    *(_BYTE *)(v0 + 134) = HIBYTE(*v3);
    *(_WORD *)(v0 + 132) = v4 >> 8;
    *(_BYTE *)(v0 + 142) = v4;
    v6 = *(_QWORD *)(v0 + 48);
    if (v6)
      (*(void (**)(void))(v6 + 8))();
    if (v5 != 1)
      break;
    if (v4 == 2)
    {
      Backend::Google::ProtocolMessageReader::readVarintField(*(Backend::Google::ProtocolMessageReader **)(v0 + 56), v1);
      v2 = *(_QWORD *)(v0 + 48);
      *(_QWORD *)(v0 + 104) = v2;
      if (!v2)
        goto LABEL_45;
      if (*(_QWORD *)v2)
      {
        v24 = 3;
LABEL_43:
        *(_BYTE *)(v0 + 136) = v24;
        *(_QWORD *)(v2 + 16) = v0;
        return (*(uint64_t (**)(void))v2)();
      }
      detail::lazy_promise<std::optional<unsigned long long>>::result(v2 + 16);
      v16 = *v15;
      v12 = *((unsigned __int8 *)v15 + 8);
      if (*v1)
        (*(void (**)(void))(*v1 + 8))();
      if (!v12)
        goto LABEL_37;
      v13 = *(_BYTE *)(v0 + 141);
      LOBYTE(v9) = *(_BYTE *)(v0 + 138);
      v10 = 1;
      v11 = v16;
      v8 = *(_QWORD *)(v0 + 72);
      v14 = *(_QWORD *)(v0 + 80);
    }
    else
    {
      if (v4 == 1)
      {
        Backend::Google::ProtocolMessageReader::readVarintField(*(Backend::Google::ProtocolMessageReader **)(v0 + 56), v1);
        v2 = *(_QWORD *)(v0 + 48);
        *(_QWORD *)(v0 + 96) = v2;
        if (!v2)
          goto LABEL_45;
        if (*(_QWORD *)v2)
        {
          v24 = 2;
          goto LABEL_43;
        }
        detail::lazy_promise<std::optional<unsigned long long>>::result(v2 + 16);
        v8 = *v7;
        v9 = *((unsigned __int8 *)v7 + 8);
        if (*v1)
          (*(void (**)(void))(*v1 + 8))();
        if (!v9)
          goto LABEL_37;
        v10 = *(_BYTE *)(v0 + 140);
        v11 = *(_DWORD *)(v0 + 128);
        LOBYTE(v12) = *(_BYTE *)(v0 + 137);
        v13 = 1;
        v14 = v8;
      }
      else
      {
        Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v0 + 56), v1);
        v2 = *(_QWORD *)(v0 + 48);
        *(_QWORD *)(v0 + 112) = v2;
        if (!v2)
          goto LABEL_45;
        if (*(_QWORD *)v2)
        {
          v24 = 4;
          goto LABEL_43;
        }
        detail::lazy_promise<BOOL>::result(v2 + 16);
        v18 = *v17;
        if (*v1)
          (*(void (**)(void))(*v1 + 8))();
        if (!v18)
          goto LABEL_37;
        v13 = *(_BYTE *)(v0 + 141);
        v8 = *(_QWORD *)(v0 + 72);
        v14 = *(_QWORD *)(v0 + 80);
        v10 = *(_BYTE *)(v0 + 140);
        v11 = *(_DWORD *)(v0 + 128);
        LOBYTE(v9) = *(_BYTE *)(v0 + 138);
        LOBYTE(v12) = *(_BYTE *)(v0 + 137);
      }
      v16 = *(_QWORD *)(v0 + 64);
    }
    v19 = *(unsigned __int16 *)(v0 + 132) | (*(unsigned __int8 *)(v0 + 134) << 16);
    v20 = *(_BYTE *)(v0 + 142);
    *(_BYTE *)(v0 + 141) = v13;
    *(_QWORD *)(v0 + 72) = v8;
    *(_QWORD *)(v0 + 80) = v14;
    *(_BYTE *)(v0 + 140) = v10;
    *(_DWORD *)(v0 + 128) = v11;
    *(_WORD *)(v0 + 124) = v19;
    *(_BYTE *)(v0 + 126) = BYTE2(v19);
    *(_BYTE *)(v0 + 139) = v20;
    *(_DWORD *)(v0 + 120) = 1;
    *(_BYTE *)(v0 + 138) = v9;
    *(_BYTE *)(v0 + 137) = v12;
    *(_QWORD *)(v0 + 64) = v16;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v0 + 56), v1);
    v2 = *(_QWORD *)(v0 + 48);
    *(_QWORD *)(v0 + 88) = v2;
    if (!v2)
    {
LABEL_45:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*(_QWORD *)v2)
    {
      v24 = 1;
      goto LABEL_43;
    }
  }
  if (!v5)
  {
    if ((_BYTE)v4)
    {
      if (*(_BYTE *)(v0 + 141))
        v21 = *(_QWORD *)(v0 + 80);
      else
        v21 = 0;
      v22 = *(_DWORD *)(v0 + 128) / 1000000000;
      if (!*(_BYTE *)(v0 + 140))
        v22 = 0;
      *(_QWORD *)(v0 + 32) = v22 + v21;
      v23 = 1;
    }
    else
    {
LABEL_37:
      v23 = 0;
      *(_BYTE *)(v0 + 32) = 0;
    }
    *(_BYTE *)(v0 + 40) = v23;
    *(_DWORD *)(v0 + 24) = 1;
    *(_QWORD *)v0 = 0;
    *(_BYTE *)(v0 + 136) = 5;
    v2 = *(_QWORD *)(v0 + 16);
    return (*(uint64_t (**)(void))v2)();
  }
  result = std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCDCA90(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 136) = 5;
  _Unwind_Resume(exception_object);
}

void sub_1DBCDCB08(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  char v13;
  __int16 v14;
  uint64_t v15;

  v13 = *(_BYTE *)(v12 + 139);
  v14 = *(_WORD *)(v12 + 124);
  *(_BYTE *)(v12 + 134) = *(_BYTE *)(v12 + 126);
  *(_WORD *)(v12 + 132) = v14;
  *(_BYTE *)(v12 + 142) = v13;
  v15 = *(_QWORD *)(v12 + 48);
  if (v15)
    (*(void (**)(void))(v15 + 8))();
  if (*(_DWORD *)(v12 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 + 32));
  operator delete((void *)v12);
}

void sub_1DBCDCC38(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 64) = 2;
  _Unwind_Resume(exception_object);
}

void sub_1DBCDCDA0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 64) = 2;
  _Unwind_Resume(exception_object);
}

void sub_1DBCDD0A4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 192) = 3;
  _Unwind_Resume(exception_object);
}

void sub_1DBCDD140(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;

  v16 = *(_QWORD *)(v14 + 128);
  if (v16)
    (*(void (**)(void))(v16 + 8))();
  if (*(_DWORD *)(v14 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v14 + 32));
  v17 = *(_QWORD **)(v14 + 96);
  if (v17 == v15)
  {
    v18 = 4;
    goto LABEL_9;
  }
  if (v17)
  {
    v18 = 5;
    v15 = *(_QWORD **)(v14 + 96);
LABEL_9:
    (*(void (**)(_QWORD *))(*v15 + 8 * v18))(v15);
  }
  operator delete((void *)v14);
}

std::string *Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>(uint64_t a1)
{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::string *result;

  v3 = (uint64_t *)(a1 + 96);
  v4 = (_QWORD *)(a1 + 120);
  if (*(_BYTE *)(a1 + 184))
  {
    if (*(_BYTE *)(a1 + 184) != 1)
    {
      v5 = *(_QWORD *)(a1 + 176);
LABEL_31:
      detail::lazy_promise<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>>::result(v5 + 16);
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 56) = 0;
      if (*(_BYTE *)(v18 + 24))
      {
        *(_QWORD *)(a1 + 32) = 0;
        *(_QWORD *)(a1 + 40) = 0;
        *(_QWORD *)(a1 + 48) = 0;
        *(_OWORD *)(a1 + 32) = *(_OWORD *)v18;
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(v18 + 16);
        *(_QWORD *)v18 = 0;
        *(_QWORD *)(v18 + 8) = 0;
        *(_QWORD *)(v18 + 16) = 0;
        *(_BYTE *)(a1 + 56) = 1;
      }
      *(_DWORD *)(a1 + 24) = 1;
      v19 = *(_QWORD *)(a1 + 144);
      if (v19)
        (*(void (**)(void))(v19 + 8))();
      v20 = *(std::__shared_weak_count **)(a1 + 136);
      if (v20)
      {
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          v22 = __ldaxr(p_shared_owners);
        while (__stlxr(v22 - 1, p_shared_owners));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      if (*(_BYTE *)(a1 + 112))
      {
        v23 = *(std::__shared_weak_count **)(a1 + 104);
        if (v23)
        {
          v24 = (unint64_t *)&v23->__shared_owners_;
          do
            v25 = __ldaxr(v24);
          while (__stlxr(v25 - 1, v24));
          if (!v25)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
      }
      goto LABEL_46;
    }
    v5 = *(_QWORD *)(a1 + 160);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 152), v4);
    v5 = *(_QWORD *)(a1 + 120);
    *(_QWORD *)(a1 + 160) = v5;
    if (!v5)
      goto LABEL_48;
    if (*(_QWORD *)v5)
    {
      v6 = 1;
LABEL_30:
      *(_BYTE *)(a1 + 184) = v6;
      *(_QWORD *)(v5 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v5)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v5 + 16);
  *(_BYTE *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 112) = 0;
  v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(_BYTE *)(v7 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v7 + 8);
    *(_QWORD *)(a1 + 96) = *(_QWORD *)v7;
    *(_QWORD *)(a1 + 104) = v1;
    if (v1)
    {
      v9 = (unint64_t *)&v1->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    *(_BYTE *)(a1 + 112) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v8)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_46:
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 184) = 3;
    v5 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v5)();
  }
  v11 = *v3;
  if (v1)
  {
    v12 = (unint64_t *)&v1->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    *(_QWORD *)(a1 + 128) = v11;
    v14 = a1 + 128;
    *(_DWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 136) = v1;
    do
      v15 = __ldxr(v12);
    while (__stxr(v15 + 1, v12));
    do
      v16 = __ldaxr(v12);
    while (__stlxr(v16 - 1, v12));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 128) = v11;
    v14 = a1 + 128;
    *(_DWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 136) = 0;
  }
  *(_QWORD *)(a1 + 168) = v14;
  v17 = *(_QWORD *)(a1 + 88);
  if (v17)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v4);
    v5 = *(_QWORD *)(a1 + 144);
    *(_QWORD *)(a1 + 176) = v5;
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        v6 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_48:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCDD4E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 184) = 3;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>(uint64_t a1)
{
  __asm { BR              X10 }
}

void sub_1DBCDD580()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = v0[15];
  if (v3)
    (*(void (**)(void))(v3 + 8))();
  detail::lazy_promise<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>>::~lazy_promise(v2);
  v4 = (_QWORD *)v0[11];
  if (v4 == v1)
  {
    v5 = 4;
    goto LABEL_7;
  }
  if (v4)
  {
    v5 = 5;
    v1 = (_QWORD *)v0[11];
LABEL_7:
    (*(void (**)(_QWORD *))(*v1 + 8 * v5))(v1);
  }
  operator delete(v0);
}

void sub_1DBCDD74C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 64) = 2;
  _Unwind_Resume(exception_object);
}

std::string *Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>(uint64_t a1)
{
  std::__shared_weak_count *v1;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  int v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  __int128 *v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::string *result;

  v3 = (uint64_t *)(a1 + 120);
  v4 = (_QWORD *)(a1 + 144);
  if (*(_BYTE *)(a1 + 208))
  {
    if (*(_BYTE *)(a1 + 208) != 1)
    {
      v5 = *(_QWORD *)(a1 + 200);
LABEL_31:
      detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>::result(v5 + 16);
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 80) = 0;
      if (*((_BYTE *)v18 + 48))
      {
        v19 = *v18;
        *(_QWORD *)(a1 + 48) = *((_QWORD *)v18 + 2);
        *(_OWORD *)(a1 + 32) = v19;
        *((_QWORD *)v18 + 1) = 0;
        *((_QWORD *)v18 + 2) = 0;
        *(_QWORD *)v18 = 0;
        v20 = *(__int128 *)((char *)v18 + 24);
        *(_QWORD *)(a1 + 72) = *((_QWORD *)v18 + 5);
        *(_OWORD *)(a1 + 56) = v20;
        *((_QWORD *)v18 + 4) = 0;
        *((_QWORD *)v18 + 5) = 0;
        *((_QWORD *)v18 + 3) = 0;
        *(_BYTE *)(a1 + 80) = 1;
      }
      *(_DWORD *)(a1 + 24) = 1;
      v21 = *(_QWORD *)(a1 + 168);
      if (v21)
        (*(void (**)(void))(v21 + 8))();
      v22 = *(std::__shared_weak_count **)(a1 + 160);
      if (v22)
      {
        p_shared_owners = (unint64_t *)&v22->__shared_owners_;
        do
          v24 = __ldaxr(p_shared_owners);
        while (__stlxr(v24 - 1, p_shared_owners));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
      if (*(_BYTE *)(a1 + 136))
      {
        v25 = *(std::__shared_weak_count **)(a1 + 128);
        if (v25)
        {
          v26 = (unint64_t *)&v25->__shared_owners_;
          do
            v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
            std::__shared_weak_count::__release_weak(v25);
          }
        }
      }
      goto LABEL_46;
    }
    v5 = *(_QWORD *)(a1 + 184);
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReader(*(Backend::Google::ProtocolMessageReader **)(a1 + 176), v4);
    v5 = *(_QWORD *)(a1 + 144);
    *(_QWORD *)(a1 + 184) = v5;
    if (!v5)
      goto LABEL_48;
    if (*(_QWORD *)v5)
    {
      v6 = 1;
LABEL_30:
      *(_BYTE *)(a1 + 208) = v6;
      *(_QWORD *)(v5 + 16) = a1;
      return (std::string *)(*(uint64_t (**)(void))v5)();
    }
  }
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(v5 + 16);
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  v8 = *(unsigned __int8 *)(v7 + 16);
  if (*(_BYTE *)(v7 + 16))
  {
    v1 = *(std::__shared_weak_count **)(v7 + 8);
    *(_QWORD *)(a1 + 120) = *(_QWORD *)v7;
    *(_QWORD *)(a1 + 128) = v1;
    if (v1)
    {
      v9 = (unint64_t *)&v1->__shared_owners_;
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    *(_BYTE *)(a1 + 136) = 1;
  }
  if (*v4)
    (*(void (**)(void))(*v4 + 8))();
  if (!v8)
  {
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_46:
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 208) = 3;
    v5 = *(_QWORD *)(a1 + 16);
    return (std::string *)(*(uint64_t (**)(void))v5)();
  }
  v11 = *v3;
  if (v1)
  {
    v12 = (unint64_t *)&v1->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    *(_QWORD *)(a1 + 152) = v11;
    v14 = a1 + 152;
    *(_DWORD *)(a1 + 144) = 0;
    *(_QWORD *)(a1 + 160) = v1;
    do
      v15 = __ldxr(v12);
    while (__stxr(v15 + 1, v12));
    do
      v16 = __ldaxr(v12);
    while (__stlxr(v16 - 1, v12));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 152) = v11;
    v14 = a1 + 152;
    *(_DWORD *)(a1 + 144) = 0;
    *(_QWORD *)(a1 + 160) = 0;
  }
  *(_QWORD *)(a1 + 192) = v14;
  v17 = *(_QWORD *)(a1 + 112);
  if (v17)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v4);
    v5 = *(_QWORD *)(a1 + 168);
    *(_QWORD *)(a1 + 200) = v5;
    if (v5)
    {
      if (*(_QWORD *)v5)
      {
        v6 = 2;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_48:
    MEMORY[0xDEADDEAD] = 0;
    std::terminate();
  }
  result = std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCDDA8C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 208) = 3;
  _Unwind_Resume(exception_object);
}

void Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>(uint64_t a1)
{
  __asm { BR              X10 }
}

void sub_1DBCDDB2C()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = v0[18];
  if (v3)
    (*(void (**)(void))(v3 + 8))();
  detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>::~lazy_promise(v2);
  v4 = (_QWORD *)v0[14];
  if (v4 == v1)
  {
    v5 = 4;
    goto LABEL_7;
  }
  if (v4)
  {
    v5 = 5;
    v1 = (_QWORD *)v0[14];
LABEL_7:
    (*(void (**)(_QWORD *))(*v1 + 8 * v5))(v1);
  }
  operator delete(v0);
}

void Backend::Google::FindFullHashesResponseParser::parseThreatEntryMetadataEntry(uint64_t a1)
{
  __asm { BR              X17 }
}

{
  __asm { BR              X10 }
}

uint64_t sub_1DBCDDC70()
{
  uint64_t v0;
  std::string *v1;
  _QWORD *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t (**v5)(void);
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  char v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  char v21;
  char v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  int v29;
  int v30;
  char v31;
  uint64_t result;

  v5 = *(uint64_t (***)(void))(v0 + 184);
  while (1)
  {
    detail::lazy_promise<ReadResult<unsigned int>>::result((uint64_t)(v5 + 2));
    v7 = *v6;
    v8 = v6[1];
    *(_BYTE *)(v0 + 226) = HIBYTE(*v6);
    *(_WORD *)(v0 + 224) = v7 >> 8;
    *(_BYTE *)(v0 + 232) = v7;
    v9 = *(_QWORD *)(v0 + 88);
    if (v9)
      (*(void (**)(void))(v9 + 8))();
    if (v8 != 1)
      break;
    if (v7 == 2)
    {
      Backend::Google::ProtocolMessageReader::readString(*(Backend::Google::ProtocolMessageReader **)(v0 + 160), v2);
      v5 = *(uint64_t (***)(void))(v0 + 152);
      *(_QWORD *)(v0 + 200) = v5;
      if (!v5)
        goto LABEL_56;
      if (*v5)
      {
        v31 = 3;
        goto LABEL_54;
      }
      detail::lazy_promise<std::optional<std::string>>::result((uint64_t)(v5 + 2));
      std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100](v1, v14);
      if (*v2)
        (*(void (**)(void))(*v2 + 8))();
      if (!*(_BYTE *)(v0 + 112))
        goto LABEL_43;
      v15 = *(_BYTE *)(v0 + 229);
      if (v15)
      {
        if (*(char *)(v0 + 228) < 0)
        {
          operator delete(*(void **)(v0 + 168));
          v15 = *(_BYTE *)(v0 + 229);
        }
        v16 = *(_QWORD *)(v0 + 88);
        *v3 = *(_QWORD *)(v0 + 96);
        *(uint64_t *)((char *)v3 + 7) = *(_QWORD *)(v0 + 103);
        v17 = *(_BYTE *)(v0 + 111);
        *(_BYTE *)(v0 + 111) = 0;
      }
      else
      {
        v16 = *(_QWORD *)(v0 + 88);
        *v3 = *(_QWORD *)(v0 + 96);
        *(uint64_t *)((char *)v3 + 7) = *(_QWORD *)(v0 + 103);
        v17 = *(_BYTE *)(v0 + 111);
        v15 = 1;
      }
      v12 = *(_QWORD *)(v0 + 176);
      v11 = *(_BYTE *)(v0 + 231);
      v13 = *(_BYTE *)(v0 + 230);
    }
    else
    {
      if (v7 == 1)
      {
        Backend::Google::ProtocolMessageReader::readString(*(Backend::Google::ProtocolMessageReader **)(v0 + 160), v2);
        v5 = *(uint64_t (***)(void))(v0 + 152);
        *(_QWORD *)(v0 + 192) = v5;
        if (!v5)
          goto LABEL_56;
        if (*v5)
        {
          v31 = 2;
LABEL_54:
          *(_BYTE *)(v0 + 135) = v31;
          v5[2] = (uint64_t (*)(void))v0;
          return (*v5)();
        }
        detail::lazy_promise<std::optional<std::string>>::result((uint64_t)(v5 + 2));
        std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100](v1, v10);
        if (*v2)
          (*(void (**)(void))(*v2 + 8))();
        if (!*(_BYTE *)(v0 + 112))
          goto LABEL_43;
        v11 = *(_BYTE *)(v0 + 231);
        if (v11)
        {
          if (*(char *)(v0 + 230) < 0)
          {
            operator delete(*(void **)(v0 + 176));
            v11 = *(_BYTE *)(v0 + 231);
          }
          v12 = *(_QWORD *)(v0 + 88);
          *v4 = *(_QWORD *)(v0 + 96);
          *(uint64_t *)((char *)v4 + 7) = *(_QWORD *)(v0 + 103);
          v13 = *(_BYTE *)(v0 + 111);
          *(_BYTE *)(v0 + 111) = 0;
        }
        else
        {
          v12 = *(_QWORD *)(v0 + 88);
          *v4 = *(_QWORD *)(v0 + 96);
          *(uint64_t *)((char *)v4 + 7) = *(_QWORD *)(v0 + 103);
          v13 = *(_BYTE *)(v0 + 111);
          v11 = 1;
        }
      }
      else
      {
        Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v0 + 160), v1);
        v5 = *(uint64_t (***)(void))(v0 + 88);
        *(_QWORD *)(v0 + 208) = v5;
        if (!v5)
          goto LABEL_56;
        if (*v5)
        {
          v31 = 4;
          goto LABEL_54;
        }
        detail::lazy_promise<BOOL>::result((uint64_t)(v5 + 2));
        v19 = *v18;
        if (v1->__r_.__value_.__r.__words[0])
          (*(void (**)(void))(v1->__r_.__value_.__r.__words[0] + 8))();
        if (!v19)
          goto LABEL_43;
        v11 = *(_BYTE *)(v0 + 231);
        v13 = *(_BYTE *)(v0 + 230);
        v12 = *(_QWORD *)(v0 + 176);
      }
      v16 = *(_QWORD *)(v0 + 168);
      v15 = *(_BYTE *)(v0 + 229);
      v17 = *(_BYTE *)(v0 + 228);
    }
    v20 = *(unsigned __int16 *)(v0 + 224) | (*(unsigned __int8 *)(v0 + 226) << 16);
    v21 = *(_BYTE *)(v0 + 232);
    *(_BYTE *)(v0 + 231) = v11;
    *(_BYTE *)(v0 + 230) = v13;
    *(_QWORD *)(v0 + 168) = v16;
    *(_QWORD *)(v0 + 176) = v12;
    *(_BYTE *)(v0 + 229) = v15;
    *(_BYTE *)(v0 + 228) = v17;
    *(_WORD *)(v0 + 220) = v20;
    *(_BYTE *)(v0 + 222) = BYTE2(v20);
    *(_BYTE *)(v0 + 151) = v21;
    *(_DWORD *)(v0 + 216) = 1;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v0 + 160), v1);
    v5 = *(uint64_t (***)(void))(v0 + 88);
    *(_QWORD *)(v0 + 184) = v5;
    if (!v5)
    {
LABEL_56:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*v5)
    {
      v31 = 1;
      goto LABEL_54;
    }
  }
  if (!v8)
  {
    if ((_BYTE)v7 && *(_BYTE *)(v0 + 231) && *(_BYTE *)(v0 + 229))
    {
      v22 = *(_BYTE *)(v0 + 230);
      v23 = *(_QWORD *)(v0 + 168);
      v24 = *(_BYTE *)(v0 + 228);
      v25 = *v4;
      v26 = *(uint64_t *)((char *)v4 + 7);
      *(_QWORD *)(v0 + 32) = *(_QWORD *)(v0 + 176);
      *(_QWORD *)(v0 + 40) = v25;
      *(_QWORD *)(v0 + 47) = v26;
      v27 = *v3;
      *(_QWORD *)(v0 + 56) = v23;
      *(_QWORD *)(v0 + 64) = v27;
      *(_QWORD *)(v0 + 71) = *(uint64_t *)((char *)v3 + 7);
      *(_BYTE *)(v0 + 55) = v22;
      *(_BYTE *)(v0 + 79) = v24;
      *(_BYTE *)(v0 + 80) = 1;
      *(_DWORD *)(v0 + 24) = 1;
    }
    else
    {
LABEL_43:
      *(_BYTE *)(v0 + 32) = 0;
      *(_BYTE *)(v0 + 80) = 0;
      *(_DWORD *)(v0 + 24) = 1;
      v28 = *(void **)(v0 + 176);
      v29 = *(unsigned __int8 *)(v0 + 231);
      v30 = *(char *)(v0 + 230);
      if (*(_BYTE *)(v0 + 229) && *(char *)(v0 + 228) < 0)
        operator delete(*(void **)(v0 + 168));
      if (v29 && v30 < 0)
        operator delete(v28);
    }
    *(_QWORD *)v0 = 0;
    *(_BYTE *)(v0 + 135) = 5;
    v5 = *(uint64_t (***)(void))(v0 + 16);
    return (*v5)();
  }
  result = std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCDDFEC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 229) && *(char *)(v1 + 228) < 0)
    operator delete(*(void **)(v1 + 168));
  if (*(_BYTE *)(v1 + 231))
  {
    if (*(char *)(v1 + 230) < 0)
      operator delete(*(void **)(v1 + 176));
  }
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 135) = 5;
  _Unwind_Resume(exception_object);
}

void sub_1DBCDE0A4()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  int v3;
  void *v4;

  v1 = *(_QWORD *)(v0 + 152);
  if (v1)
    (*(void (**)(void))(v1 + 8))();
  v2 = *(char *)(v0 + 230);
  v3 = *(unsigned __int8 *)(v0 + 231);
  v4 = *(void **)(v0 + 176);
  if (*(_BYTE *)(v0 + 229) && *(char *)(v0 + 228) < 0)
    operator delete(*(void **)(v0 + 168));
  if (v3 && v2 < 0)
    operator delete(v4);
  detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>::~lazy_promise(v0 + 16);
  operator delete((void *)v0);
}

void Backend::Google::FindFullHashesResponseParser::parseThreatEntryMetadata(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X10 }
}

uint64_t sub_1DBCDE174()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  std::string *v4;
  _QWORD *v5;
  int v6;
  char v7;
  uint64_t (**v8)(void);
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  Backend::Google::ProtocolMessageReader *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unsigned __int8 *v18;
  int v19;
  char v20;
  char v21;
  uint64_t result;
  void **v23;

  v6 = 0;
  v7 = 0;
  *(_QWORD *)v2 = 0;
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  while (1)
  {
    *(_WORD *)(v1 + 220) = v0;
    *(_BYTE *)(v1 + 222) = BYTE2(v0);
    *(_BYTE *)(v1 + 229) = v7;
    *(_DWORD *)(v1 + 216) = v6;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v1 + 184), v4);
    v8 = *(uint64_t (***)(void))(v1 + 64);
    *(_QWORD *)(v1 + 192) = v8;
    if (!v8)
    {
LABEL_35:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*v8)
    {
      v21 = 1;
      goto LABEL_33;
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result((uint64_t)(v8 + 2));
    v10 = *v9;
    v11 = v9[1];
    *(_BYTE *)(v1 + 226) = HIBYTE(*v9);
    *(_WORD *)(v1 + 224) = v10 >> 8;
    *(_BYTE *)(v1 + 230) = v10;
    v12 = *(_QWORD *)(v1 + 64);
    if (v12)
      (*(void (**)(void))(v12 + 8))();
    if (v11 != 1)
      break;
    v13 = *(Backend::Google::ProtocolMessageReader **)(v1 + 184);
    if (v10 == 1)
    {
      *(_QWORD *)(v1 + 120) = off_1EA3EAF98;
      *(_QWORD *)(v1 + 128) = Backend::Google::FindFullHashesResponseParser::parseThreatEntryMetadataEntry;
      *(_QWORD *)(v1 + 144) = v3;
      Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>((uint64_t)v13, v3, v5);
      v8 = *(uint64_t (***)(void))(v1 + 176);
      *(_QWORD *)(v1 + 200) = v8;
      if (!v8)
        goto LABEL_35;
      if (*v8)
      {
        v21 = 2;
LABEL_33:
        *(_BYTE *)(v1 + 228) = v21;
        v8[2] = (uint64_t (*)(void))v1;
        return (*v8)();
      }
      detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>::result((uint64_t)(v8 + 2));
      std::__optional_copy_base<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,false>::__optional_copy_base[abi:sn180100](v4, v14);
      if (*v5)
        (*(void (**)(void))(*v5 + 8))();
      v15 = *(_QWORD *)(v1 + 144);
      v16 = 4;
      v17 = (_QWORD *)v3;
      if (v15 == v3 || (v16 = 5, v17 = *(_QWORD **)(v1 + 144), v15))
        (*(void (**)(void))(*v17 + 8 * v16))();
      if (!*(_BYTE *)(v1 + 112))
      {
        *(_BYTE *)(v1 + 32) = 0;
        *(_BYTE *)(v1 + 56) = 0;
        *(_DWORD *)(v1 + 24) = 1;
        std::__optional_destruct_base<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,false>::~__optional_destruct_base[abi:sn180100]((uint64_t)v4);
LABEL_29:
        v23 = (void **)v2;
        std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&v23);
        *(_QWORD *)v1 = 0;
        *(_BYTE *)(v1 + 228) = 4;
        v8 = *(uint64_t (***)(void))(v1 + 16);
        return (*v8)();
      }
      std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::push_back[abi:sn180100]((char **)v2, (__int128 *)v4);
      std::__optional_destruct_base<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry,false>::~__optional_destruct_base[abi:sn180100]((uint64_t)v4);
    }
    else
    {
      Backend::Google::ProtocolMessageReader::skipField(v13, v4);
      v8 = *(uint64_t (***)(void))(v1 + 64);
      *(_QWORD *)(v1 + 208) = v8;
      if (!v8)
        goto LABEL_35;
      if (*v8)
      {
        v21 = 3;
        goto LABEL_33;
      }
      detail::lazy_promise<BOOL>::result((uint64_t)(v8 + 2));
      v19 = *v18;
      if (v4->__r_.__value_.__r.__words[0])
        (*(void (**)(void))(v4->__r_.__value_.__r.__words[0] + 8))();
      if (!v19)
        goto LABEL_26;
    }
    v0 = *(unsigned __int16 *)(v1 + 224) | (*(unsigned __int8 *)(v1 + 226) << 16);
    v7 = *(_BYTE *)(v1 + 230);
    v6 = 1;
  }
  if (!v11)
  {
    if ((_BYTE)v10)
    {
      *(_OWORD *)(v1 + 32) = *(_OWORD *)(v1 + 152);
      *(_QWORD *)(v1 + 48) = *(_QWORD *)(v1 + 168);
      *(_QWORD *)(v2 + 8) = 0;
      *(_QWORD *)(v2 + 16) = 0;
      *(_QWORD *)v2 = 0;
      v20 = 1;
    }
    else
    {
LABEL_26:
      v20 = 0;
      *(_BYTE *)(v1 + 32) = 0;
    }
    *(_BYTE *)(v1 + 56) = v20;
    *(_DWORD *)(v1 + 24) = 1;
    goto LABEL_29;
  }
  result = std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCDE3E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v5;
  uint64_t v6;
  va_list va;

  va_start(va, a2);
  v5 = *(_QWORD **)(v2 + 144);
  if (v5 == v3)
  {
    v6 = 4;
  }
  else
  {
    if (!v5)
      goto LABEL_6;
    v6 = 5;
    v3 = *(_QWORD **)(v2 + 144);
  }
  (*(void (**)(_QWORD *))(*v3 + 8 * v6))(v3);
LABEL_6:
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100]((void ***)va);
  *(_QWORD *)v2 = 0;
  *(_BYTE *)(v2 + 228) = 4;
  _Unwind_Resume(a1);
}

void sub_1DBCDE4C4()
{
  uint64_t v0;
  void **v1;
  char v2;
  __int16 v3;
  uint64_t v4;
  void **v5;

  v2 = *(_BYTE *)(v0 + 229);
  v3 = *(_WORD *)(v0 + 220);
  *(_BYTE *)(v0 + 226) = *(_BYTE *)(v0 + 222);
  *(_WORD *)(v0 + 224) = v3;
  *(_BYTE *)(v0 + 230) = v2;
  v4 = *(_QWORD *)(v0 + 64);
  if (v4)
    (*(void (**)(void))(v4 + 8))();
  v5 = v1;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&v5);
  detail::lazy_promise<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>>::~lazy_promise(v0 + 16);
  operator delete((void *)v0);
}

void sub_1DBCDE6EC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 72) = 3;
  _Unwind_Resume(a1);
}

void sub_1DBCDE750(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;

  v13 = *(std::__shared_weak_count **)(v12 + 48);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (*(_DWORD *)(v12 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 + 32));
  operator delete((void *)v12);
}

void sub_1DBCDE9D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1 + 72);
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 184) = 3;
  _Unwind_Resume(a1);
}

void sub_1DBCDEA50(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  v13 = *(_QWORD *)(v12 + 104);
  if (v13)
    (*(void (**)(void))(v13 + 8))();
  if (*(_DWORD *)(v12 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 + 32));
  operator delete((void *)v12);
}

void Backend::Google::FindFullHashesResponseParser::parseThreatEntry(uint64_t a1)
{
  __asm { BR              X11 }
}

{
  __asm { BR              X10 }
}

_QWORD *sub_1DBCDEB20()
{
  uint64_t v0;
  _QWORD *v1;
  _OWORD *v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned __int8 *v8;
  int v9;
  char v10;
  int v11;
  char v12;
  char v13;
  char v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *result;

  v3 = *(_QWORD *)(v0 + 88);
  while (1)
  {
    detail::lazy_promise<ReadResult<unsigned int>>::result(v3 + 16);
    v5 = *v4;
    v6 = v4[1];
    *(_BYTE *)(v0 + 122) = HIBYTE(*v4);
    *(_WORD *)(v0 + 120) = v5 >> 8;
    *(_BYTE *)(v0 + 159) = v5;
    v7 = *(_QWORD *)(v0 + 72);
    if (v7)
      (*(void (**)(void))(v7 + 8))();
    if (v6 != 1)
      break;
    if (v5 == 1)
    {
      v15 = operator new(0xC0uLL);
      v16 = *(_QWORD *)(v0 + 80);
      *(_QWORD *)(v0 + 96) = v15;
      *v15 = Backend::Google::ProtocolMessageReader::readByteArray<32ul>;
      v15[1] = Backend::Google::ProtocolMessageReader::readByteArray<32ul>;
      v15[14] = v16;
      *((_DWORD *)v15 + 6) = 0;
      *((_BYTE *)v15 + 184) = 0;
      *(_BYTE *)(v0 + 155) = 2;
      v15[2] = v0;
      return Backend::Google::ProtocolMessageReader::readByteArray<32ul>((uint64_t)v15);
    }
    Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v0 + 80), v1);
    v3 = *(_QWORD *)(v0 + 72);
    *(_QWORD *)(v0 + 104) = v3;
    if (!v3)
      goto LABEL_24;
    if (*(_QWORD *)v3)
    {
      v14 = 3;
LABEL_22:
      *(_BYTE *)(v0 + 155) = v14;
      *(_QWORD *)(v3 + 16) = v0;
      return (_QWORD *)(*(uint64_t (**)(void))v3)();
    }
    detail::lazy_promise<BOOL>::result(v3 + 16);
    v9 = *v8;
    if (*v1)
      (*(void (**)(void))(*v1 + 8))();
    if (!v9)
      goto LABEL_17;
    v10 = *(_BYTE *)(v0 + 157);
    v11 = *(unsigned __int16 *)(v0 + 120) | (*(unsigned __int8 *)(v0 + 122) << 16);
    v12 = *(_BYTE *)(v0 + 159);
    *(_BYTE *)(v0 + 158) = *(_BYTE *)(v0 + 158);
    *(_BYTE *)(v0 + 157) = v10;
    *(_WORD *)(v0 + 116) = v11;
    *(_BYTE *)(v0 + 118) = BYTE2(v11);
    *(_BYTE *)(v0 + 156) = v12;
    *(_DWORD *)(v0 + 112) = 1;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v0 + 80), v1);
    v3 = *(_QWORD *)(v0 + 72);
    *(_QWORD *)(v0 + 88) = v3;
    if (!v3)
    {
LABEL_24:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*(_QWORD *)v3)
    {
      v14 = 1;
      goto LABEL_22;
    }
  }
  if (!v6)
  {
    if ((_BYTE)v5)
    {
      *(_BYTE *)(v0 + 32) = *(_BYTE *)(v0 + 157);
      *(_OWORD *)(v0 + 33) = *v2;
      *(_OWORD *)(v0 + 48) = *(_OWORD *)((char *)v2 + 15);
      v13 = *(_BYTE *)(v0 + 158);
    }
    else
    {
LABEL_17:
      v13 = 0;
      *(_BYTE *)(v0 + 32) = 0;
    }
    *(_BYTE *)(v0 + 64) = v13;
    *(_DWORD *)(v0 + 24) = 1;
    *(_QWORD *)v0 = 0;
    *(_BYTE *)(v0 + 155) = 4;
    v3 = *(_QWORD *)(v0 + 16);
    return (_QWORD *)(*(uint64_t (**)(void))v3)();
  }
  result = (_QWORD *)std::__throw_bad_variant_access[abi:sn180100]();
  __break(1u);
  return result;
}

void sub_1DBCDED38()
{
  JUMPOUT(0x1DBCDED64);
}

void sub_1DBCDED4C()
{
  _QWORD *v0;

  if (*v0)
    JUMPOUT(0x1DBCDED5CLL);
  JUMPOUT(0x1DBCDED64);
}

void sub_1DBCDEDA4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  char v13;
  __int16 v14;
  uint64_t v15;

  v13 = *(_BYTE *)(v12 + 156);
  v14 = *(_WORD *)(v12 + 116);
  *(_BYTE *)(v12 + 122) = *(_BYTE *)(v12 + 118);
  *(_WORD *)(v12 + 120) = v14;
  *(_BYTE *)(v12 + 159) = v13;
  v15 = *(_QWORD *)(v12 + 72);
  if (v15)
    (*(void (**)(void))(v15 + 8))();
  if (*(_DWORD *)(v12 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(v12 + 32));
  operator delete((void *)v12);
}

void Backend::Google::FindFullHashesResponseParser::parseThreatMatch(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X11 }
}

uint64_t sub_1DBCDEE78()
{
  int v0;
  int v1;
  char v2;
  int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  char v10;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;
  char v16;
  char v17;
  char v18;
  char v19;
  int v20;
  int64x2_t v21;
  uint64_t v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  unsigned __int8 *v43;
  int v44;
  int v45;
  int v46;
  int v47;
  char v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  char v55;
  _QWORD *v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  _OWORD *v63;
  void ***v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void **v70;
  __int128 v71;
  _BYTE v72[32];
  _BYTE v73[24];
  uint64_t v74;

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = v65;
  *(_QWORD *)v65 = 0;
  *(_QWORD *)(v65 + 8) = 0;
  *(_QWORD *)(v65 + 16) = 0;
  v21 = 0uLL;
  while (1)
  {
    *(_WORD *)(v7 + 12) = v20;
    *(_BYTE *)(v7 + 14) = BYTE2(v20);
    *(_BYTE *)(v4 + 436) = v19;
    *(_BYTE *)(v4 + 435) = v18;
    *(_WORD *)(v7 + 8) = v0;
    *(_BYTE *)(v7 + 10) = BYTE2(v0);
    *(_BYTE *)(v4 + 434) = v17;
    *(_BYTE *)(v4 + 433) = v16;
    *(_WORD *)(v7 + 4) = v1;
    *(_BYTE *)(v7 + 6) = BYTE2(v1);
    *(_BYTE *)(v4 + 432) = v15;
    *(_BYTE *)(v4 + 431) = v14;
    *(_BYTE *)(v4 + 430) = v2;
    *(_BYTE *)(v4 + 429) = v13;
    *(_BYTE *)(v4 + 428) = v12;
    *(_BYTE *)(v4 + 427) = v8;
    *(_BYTE *)(v4 + 426) = v11;
    *(int64x2_t *)(v4 + 288) = v21;
    *(_WORD *)v7 = v3;
    *(_BYTE *)(v7 + 2) = BYTE2(v3);
    *(_BYTE *)(v4 + 425) = v10;
    *(_DWORD *)(v4 + 368) = v9;
    *(_BYTE *)(v4 + 424) = v5;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v4 + 280), (_QWORD *)v6);
    v22 = *(_QWORD *)(v4 + 152);
    *(_QWORD *)(v4 + 304) = v22;
    if (!v22)
    {
LABEL_63:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*(_QWORD *)v22)
    {
      v55 = 1;
LABEL_54:
      *(_BYTE *)(v7 + 51) = v55;
      *(_QWORD *)(v22 + 16) = v4;
      return (*(uint64_t (**)(uint64_t))v22)(v22);
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result(v22 + 16);
    v24 = *v23;
    v25 = v23[1];
    *(_BYTE *)(v7 + 18) = HIBYTE(*v23);
    *(_WORD *)(v7 + 16) = v24 >> 8;
    *(_BYTE *)(v4 + 437) = v24;
    v26 = *(_QWORD *)(v4 + 152);
    if (v26)
      (*(void (**)(void))(v26 + 8))();
    if (v25 != 1)
      break;
    switch(v24)
    {
      case 1u:
        v61 = operator new(0x48uLL);
        v62 = *(_QWORD *)(v4 + 280);
        *(_QWORD *)(v4 + 312) = v61;
        *v61 = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatType>;
        v61[1] = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatType>;
        v61[6] = v62;
        *((_DWORD *)v61 + 6) = 0;
        *((_BYTE *)v61 + 64) = 0;
        *(_BYTE *)(v7 + 51) = 2;
        v61[2] = v4;
        return Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatType>((uint64_t)v61);
      case 2u:
        v59 = operator new(0x48uLL);
        v60 = *(_QWORD *)(v4 + 280);
        *(_QWORD *)(v4 + 320) = v59;
        *v59 = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::PlatformType>;
        v59[1] = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::PlatformType>;
        v59[6] = v60;
        *((_DWORD *)v59 + 6) = 0;
        *((_BYTE *)v59 + 64) = 0;
        *(_BYTE *)(v7 + 51) = 3;
        v59[2] = v4;
        return Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::PlatformType>((uint64_t)v59);
      case 3u:
        v27 = *(_QWORD *)(v4 + 280);
        *(_QWORD *)(v4 + 120) = off_1EA3EB070;
        *(_QWORD *)(v4 + 128) = Backend::Google::FindFullHashesResponseParser::parseThreatEntry;
        *(_QWORD *)(v4 + 144) = v67;
        Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::array<unsigned char,32ul>>(v27, v67, v64);
        v22 = *(_QWORD *)(v4 + 272);
        *(_QWORD *)(v4 + 328) = v22;
        if (!v22)
          goto LABEL_63;
        if (!*(_QWORD *)v22)
        {
          detail::lazy_promise<std::optional<std::array<unsigned char,32ul>>>::result(v22 + 16);
          v12 = *v28;
          v29 = *(_OWORD *)(v28 + 1);
          *(_OWORD *)(v6 + 15) = *((_OWORD *)v28 + 1);
          *(_OWORD *)v6 = v29;
          v5 = v28[32];
          if (*v64)
            ((void (*)(void))(*v64)[1])();
          v30 = *(_QWORD *)(v4 + 144);
          v31 = 4;
          v32 = (_QWORD *)v67;
          if (v30 == v67 || (v31 = 5, v32 = *(_QWORD **)(v4 + 144), v30))
            (*(void (**)(void))(*v32 + 8 * v31))();
          if (!v5)
            goto LABEL_51;
          *v63 = *(_OWORD *)v6;
          *(_OWORD *)((char *)v63 + 15) = *(_OWORD *)(v6 + 15);
          v20 = *(unsigned __int16 *)(v7 + 12) | (*(unsigned __int8 *)(v7 + 14) << 16);
          v19 = *(_BYTE *)(v4 + 436);
          v18 = *(_BYTE *)(v4 + 435);
          v0 = *(unsigned __int16 *)(v7 + 8) | (*(unsigned __int8 *)(v7 + 10) << 16);
          v17 = *(_BYTE *)(v4 + 434);
          v16 = *(_BYTE *)(v4 + 433);
          v1 = *(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16);
          v15 = *(_BYTE *)(v4 + 432);
          v14 = *(_BYTE *)(v4 + 431);
          LOBYTE(v8) = *(_BYTE *)(v4 + 427);
          v11 = *(_BYTE *)(v4 + 426);
          v13 = 1;
          v2 = v12;
          v21 = *(int64x2_t *)(v4 + 288);
          goto LABEL_42;
        }
        v55 = 4;
        goto LABEL_54;
      case 4u:
        v38 = *(_QWORD *)(v4 + 280);
        *(_QWORD *)(v4 + 184) = off_1EA3EB100;
        *(_QWORD *)(v4 + 192) = Backend::Google::FindFullHashesResponseParser::parseThreatEntryMetadata;
        *(_QWORD *)(v4 + 208) = v68;
        Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>(v38, v68, v64);
        v22 = *(_QWORD *)(v4 + 272);
        *(_QWORD *)(v4 + 336) = v22;
        if (!v22)
          goto LABEL_63;
        if (!*(_QWORD *)v22)
        {
          detail::lazy_promise<std::optional<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>>>::result(v22 + 16);
          std::__optional_copy_base<std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>,false>::__optional_copy_base[abi:sn180100]((std::string *)v6, v39);
          if (*v64)
            ((void (*)(void))(*v64)[1])();
          v40 = *(_QWORD *)(v4 + 208);
          v41 = 4;
          v42 = (_QWORD *)v68;
          if (v40 == v68 || (v41 = 5, v42 = *(_QWORD **)(v4 + 208), v40))
            (*(void (**)(void))(*v42 + 8 * v41))();
          if (!*(_BYTE *)(v4 + 176))
            goto LABEL_51;
          std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__vdeallocate((void **)v65);
          *(_OWORD *)(v4 + 248) = *(_OWORD *)(v4 + 152);
          *(_QWORD *)(v4 + 264) = *(_QWORD *)(v4 + 168);
          *(_QWORD *)(v6 + 8) = 0;
          *(_QWORD *)(v6 + 16) = 0;
          *(_QWORD *)v6 = 0;
          if (*(_BYTE *)(v4 + 176))
          {
            *v64 = (void **)v6;
            std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](v64);
          }
LABEL_41:
          v20 = *(unsigned __int16 *)(v7 + 12) | (*(unsigned __int8 *)(v7 + 14) << 16);
          v19 = *(_BYTE *)(v4 + 436);
          v18 = *(_BYTE *)(v4 + 435);
          v0 = *(unsigned __int16 *)(v7 + 8) | (*(unsigned __int8 *)(v7 + 10) << 16);
          v17 = *(_BYTE *)(v4 + 434);
          v16 = *(_BYTE *)(v4 + 433);
          v1 = *(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16);
          v15 = *(_BYTE *)(v4 + 432);
          v14 = *(_BYTE *)(v4 + 431);
          v2 = *(_BYTE *)(v4 + 430);
          v13 = *(_BYTE *)(v4 + 429);
          v12 = *(_BYTE *)(v4 + 428);
          LOBYTE(v8) = *(_BYTE *)(v4 + 427);
          v11 = *(_BYTE *)(v4 + 426);
          v21 = *(int64x2_t *)(v4 + 288);
          LOBYTE(v5) = *(_BYTE *)(v4 + 424);
          goto LABEL_42;
        }
        v55 = 5;
        goto LABEL_54;
      case 5u:
        v33 = *(_QWORD *)(v4 + 280);
        *(_QWORD *)(v4 + 216) = off_1EA3EB0B8;
        *(_QWORD *)(v4 + 224) = Backend::Google::FindFullHashesResponseParser::parseDuration;
        *(_QWORD *)(v4 + 240) = v66;
        Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::chrono::duration<long long,std::ratio<1l,1l>>>(v33, v66, (_QWORD *)v6);
        v22 = *(_QWORD *)(v4 + 152);
        *(_QWORD *)(v4 + 344) = v22;
        if (!v22)
          goto LABEL_63;
        if (*(_QWORD *)v22)
        {
          v55 = 6;
          goto LABEL_54;
        }
        detail::lazy_promise<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>>::result(v22 + 16);
        v69 = *(_QWORD *)v34;
        v8 = *(unsigned __int8 *)(v34 + 8);
        if (*(_QWORD *)v6)
          (*(void (**)(void))(*(_QWORD *)v6 + 8))();
        v35 = *(_QWORD *)(v4 + 240);
        v36 = 4;
        v37 = (_QWORD *)v66;
        if (v35 == v66 || (v36 = 5, v37 = *(_QWORD **)(v4 + 240), v35))
          (*(void (**)(void))(*v37 + 8 * v36))();
        if (!v8)
          goto LABEL_51;
        v20 = *(unsigned __int16 *)(v7 + 12) | (*(unsigned __int8 *)(v7 + 14) << 16);
        v19 = *(_BYTE *)(v4 + 436);
        v18 = *(_BYTE *)(v4 + 435);
        v0 = *(unsigned __int16 *)(v7 + 8) | (*(unsigned __int8 *)(v7 + 10) << 16);
        v17 = *(_BYTE *)(v4 + 434);
        v16 = *(_BYTE *)(v4 + 433);
        v1 = *(unsigned __int16 *)(v7 + 4) | (*(unsigned __int8 *)(v7 + 6) << 16);
        v15 = *(_BYTE *)(v4 + 432);
        v14 = *(_BYTE *)(v4 + 431);
        v2 = *(_BYTE *)(v4 + 430);
        v13 = *(_BYTE *)(v4 + 429);
        v12 = *(_BYTE *)(v4 + 428);
        LOBYTE(v5) = *(_BYTE *)(v4 + 424);
        v11 = 1;
        v21 = vdupq_lane_s64(v69, 0);
LABEL_42:
        v3 = *(unsigned __int16 *)(v7 + 16) | (*(unsigned __int8 *)(v7 + 18) << 16);
        v10 = *(_BYTE *)(v4 + 437);
        v9 = 1;
        break;
      case 6u:
        v57 = operator new(0x48uLL);
        v58 = *(_QWORD *)(v4 + 280);
        *(_QWORD *)(v4 + 352) = v57;
        *v57 = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatEntryType>;
        v57[1] = Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatEntryType>;
        v57[6] = v58;
        *((_DWORD *)v57 + 6) = 0;
        *((_BYTE *)v57 + 64) = 0;
        *(_BYTE *)(v7 + 51) = 7;
        v57[2] = v4;
        return Backend::Google::ProtocolMessageReader::readEnum<Backend::Google::ThreatEntryType>((uint64_t)v57);
      default:
        Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v4 + 280), (_QWORD *)v6);
        v22 = *(_QWORD *)(v4 + 152);
        *(_QWORD *)(v4 + 360) = v22;
        if (!v22)
          goto LABEL_63;
        if (!*(_QWORD *)v22)
        {
          detail::lazy_promise<BOOL>::result(v22 + 16);
          v44 = *v43;
          if (*(_QWORD *)v6)
            (*(void (**)(void))(*(_QWORD *)v6 + 8))();
          if (!v44)
            goto LABEL_51;
          goto LABEL_41;
        }
        v55 = 8;
        goto LABEL_54;
    }
  }
  if (v25)
  {
    std::__throw_bad_variant_access[abi:sn180100]();
    __break(1u);
  }
  if ((_BYTE)v24
    && *(_BYTE *)(v4 + 435)
    && *(_BYTE *)(v4 + 433)
    && *(_BYTE *)(v4 + 431)
    && *(_BYTE *)(v4 + 429)
    && *(_BYTE *)(v4 + 426))
  {
    v45 = *(unsigned __int8 *)(v7 + 6);
    v46 = *(unsigned __int16 *)(v7 + 4);
    v47 = *(unsigned __int8 *)(v4 + 432);
    v48 = *(_BYTE *)(v4 + 428);
    v49 = *(_QWORD *)(v4 + 288);
    v50 = (*(unsigned __int16 *)(v7 + 8) << 8) | (*(unsigned __int8 *)(v7 + 10) << 24) | *(unsigned __int8 *)(v4 + 434);
    LODWORD(v71) = (*(unsigned __int16 *)(v7 + 12) << 8) | (*(unsigned __int8 *)(v7 + 14) << 24) | *(unsigned __int8 *)(v4 + 436);
    DWORD1(v71) = v50;
    DWORD2(v71) = (v46 << 8) | (v45 << 24) | v47;
    HIDWORD(v71) = 1;
    v72[0] = v48;
    *(_OWORD *)&v72[1] = *v63;
    *(_OWORD *)&v72[16] = *(_OWORD *)((char *)v63 + 15);
    v51 = *(_QWORD *)(v4 + 264);
    v52 = *(_OWORD *)(v4 + 248);
    *(_QWORD *)(v65 + 8) = 0;
    *(_QWORD *)(v65 + 16) = 0;
    *(_QWORD *)v65 = 0;
    v53 = *(_OWORD *)v72;
    v54 = *(_OWORD *)&v72[16];
    *(_OWORD *)(v4 + 32) = v71;
    *(_OWORD *)(v4 + 48) = v53;
    *(_OWORD *)(v4 + 64) = v54;
    *(_OWORD *)(v4 + 80) = v52;
    memset(v73, 0, sizeof(v73));
    v74 = v49;
    *(_QWORD *)(v4 + 96) = v51;
    *(_QWORD *)(v4 + 104) = v49;
    *(_BYTE *)(v4 + 112) = 1;
    *(_DWORD *)(v4 + 24) = 1;
    v70 = (void **)v73;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&v70);
  }
  else
  {
LABEL_51:
    *(_BYTE *)(v4 + 32) = 0;
    *(_BYTE *)(v4 + 112) = 0;
    *(_DWORD *)(v4 + 24) = 1;
  }
  *(_QWORD *)&v71 = v65;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100]((void ***)&v71);
  *(_QWORD *)v4 = 0;
  *(_BYTE *)(v7 + 51) = 9;
  v22 = *(_QWORD *)(v4 + 16);
  return (*(uint64_t (**)(uint64_t))v22)(v22);
}

void sub_1DBCDF74C()
{
  JUMPOUT(0x1DBCDF860);
}

void sub_1DBCDF784(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_QWORD *)v14)
    (*(void (**)(void))(*(_QWORD *)v14 + 8))();
  v15 = *(_QWORD *)(v13 + 144);
  if (v15 != a13 && !v15)
    JUMPOUT(0x1DBCDF860);
  JUMPOUT(0x1DBCDF854);
}

void sub_1DBCDF7D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (*(_QWORD *)v13)
    (*(void (**)(void))(*(_QWORD *)v13 + 8))();
  v14 = *(_QWORD *)(v12 + 240);
  if (v14 != a12 && !v14)
    JUMPOUT(0x1DBCDF860);
  JUMPOUT(0x1DBCDF854);
}

void sub_1DBCDF818(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (*(_QWORD *)v15)
    (*(void (**)(void))(*(_QWORD *)v15 + 8))();
  v16 = *(_QWORD *)(v14 + 208);
  if (v16 != a14 && !v16)
    JUMPOUT(0x1DBCDF860);
  JUMPOUT(0x1DBCDF85CLL);
}

void sub_1DBCDF8D0(__int16 *a1@<X8>)
{
  uint64_t v1;
  void **v2;
  char v3;
  __int16 v4;
  uint64_t v5;
  void **v6;

  v3 = *(_BYTE *)(v1 + 425);
  v4 = *a1;
  *((_BYTE *)a1 + 18) = *((_BYTE *)a1 + 2);
  a1[8] = v4;
  *(_BYTE *)(v1 + 437) = v3;
  v5 = *(_QWORD *)(v1 + 152);
  if (v5)
    (*(void (**)(void))(v5 + 8))();
  v6 = v2;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](&v6);
  detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>>::~lazy_promise(v1 + 16);
  operator delete((void *)v1);
}

void Backend::Google::FindFullHashesResponseParser::parseFindFullHashesResponse(uint64_t a1)
{
  __asm { BR              X10 }
}

{
  __asm { BR              X11 }
}

{
  __asm { BR              X11 }
}

_QWORD *sub_1DBCDFA68()
{
  unint64_t v0;
  int v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  int v8;
  int v9;
  unsigned int *v10;
  unint64_t v11;
  int v12;
  char v13;
  char v14;
  char v15;
  char v16;
  char v17;
  unint64_t v18;
  uint64_t (**v19)(void);
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *result;
  unint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  unint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  unsigned __int8 *v43;
  int v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  void ***v58;
  void ***v59;
  void **v60[3];
  _BYTE v61[25];

  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = (unint64_t)v57;
  *v57 = 0;
  v57[1] = 0;
  v57[2] = 0;
  while (1)
  {
    v10[2] = v18;
    *((_BYTE *)v10 + 14) = BYTE6(v18);
    *((_WORD *)v10 + 6) = WORD2(v18);
    *(_BYTE *)(v2 + 411) = v17;
    *(_BYTE *)(v2 + 410) = v16;
    *v10 = v0;
    *((_BYTE *)v10 + 6) = BYTE6(v0);
    *((_WORD *)v10 + 2) = WORD2(v0);
    *(_BYTE *)(v2 + 409) = v15;
    *(_BYTE *)(v2 + 408) = v14;
    *((_WORD *)v10 + 30) = v1;
    *((_BYTE *)v10 + 62) = BYTE2(v1);
    *(_BYTE *)(v2 + 407) = v13;
    *(_BYTE *)(v2 + 406) = v8;
    *(_DWORD *)(v2 + 392) = v12;
    *(_BYTE *)(v2 + 405) = v9;
    *(_QWORD *)(v2 + 320) = v3;
    *(_QWORD *)(v2 + 328) = v11;
    Backend::Google::ProtocolMessageReader::nextField(*(Backend::Google::ProtocolMessageReader **)(v2 + 312), v7);
    v19 = *(uint64_t (***)(void))(v2 + 96);
    *(_QWORD *)(v2 + 352) = v19;
    if (!v19)
    {
LABEL_63:
      MEMORY[0xDEADDEAD] = 0;
      std::terminate();
    }
    if (*v19)
    {
      v48 = 1;
      goto LABEL_56;
    }
    detail::lazy_promise<ReadResult<unsigned int>>::result((uint64_t)(v19 + 2));
    v21 = *v20;
    v22 = v20[1];
    *((_BYTE *)v10 + 66) = HIBYTE(*v20);
    *((_WORD *)v10 + 32) = v21 >> 8;
    *(_BYTE *)(v2 + 412) = v21;
    v23 = *(_QWORD *)(v2 + 96);
    if (v23)
      (*(void (**)(void))(v23 + 8))();
    if (v22 != 1)
      break;
    if (v21 == 3)
    {
      v33 = *(_QWORD *)(v2 + 312);
      *(_QWORD *)(v2 + 216) = off_1EA3EB0B8;
      *(_QWORD *)(v2 + 224) = Backend::Google::FindFullHashesResponseParser::parseDuration;
      *(_QWORD *)(v2 + 240) = v5;
      Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::chrono::duration<long long,std::ratio<1l,1l>>>(v33, v5, v7);
      v19 = *(uint64_t (***)(void))(v2 + 96);
      *(_QWORD *)(v2 + 376) = v19;
      if (!v19)
        goto LABEL_63;
      if (*v19)
      {
        v48 = 4;
        goto LABEL_56;
      }
      detail::lazy_promise<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>>::result((uint64_t)(v19 + 2));
      v11 = *v34;
      v8 = *((unsigned __int8 *)v34 + 8);
      if (*(_QWORD *)v7)
        (*(void (**)(void))(*(_QWORD *)v7 + 8))();
      v35 = *(_QWORD *)(v2 + 240);
      v36 = 4;
      v37 = (_QWORD *)v5;
      if (v35 == v5 || (v36 = 5, v37 = *(_QWORD **)(v2 + 240), v35))
        (*(void (**)(void))(*v37 + 8 * v36))();
      if (!v8)
        goto LABEL_53;
      v0 = v11 >> 8;
      v18 = v10[2] | ((unint64_t)(*((unsigned __int16 *)v10 + 6) | (*((unsigned __int8 *)v10 + 14) << 16)) << 32);
      v17 = *(_BYTE *)(v2 + 411);
      v16 = *(_BYTE *)(v2 + 410);
      LOBYTE(v9) = *(_BYTE *)(v2 + 405);
      v3 = *(_QWORD *)(v2 + 320);
      v14 = v8;
      v15 = v11;
    }
    else if (v21 == 2)
    {
      v38 = *(_QWORD *)(v2 + 312);
      *(_QWORD *)(v2 + 248) = off_1EA3EB0B8;
      *(_QWORD *)(v2 + 256) = Backend::Google::FindFullHashesResponseParser::parseDuration;
      *(_QWORD *)(v2 + 272) = v6;
      Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<std::chrono::duration<long long,std::ratio<1l,1l>>>(v38, v6, v7);
      v19 = *(uint64_t (***)(void))(v2 + 96);
      *(_QWORD *)(v2 + 368) = v19;
      if (!v19)
        goto LABEL_63;
      if (*v19)
      {
        v48 = 3;
        goto LABEL_56;
      }
      detail::lazy_promise<std::optional<std::chrono::duration<long long,std::ratio<1l,1l>>>>::result((uint64_t)(v19 + 2));
      v3 = *v39;
      v9 = *((unsigned __int8 *)v39 + 8);
      if (*(_QWORD *)v7)
        (*(void (**)(void))(*(_QWORD *)v7 + 8))();
      v40 = *(_QWORD *)(v2 + 272);
      v41 = 4;
      v42 = (_QWORD *)v6;
      if (v40 == v6 || (v41 = 5, v42 = *(_QWORD **)(v2 + 272), v40))
        (*(void (**)(void))(*v42 + 8 * v41))();
      if (!v9)
        goto LABEL_53;
      v18 = v3 >> 8;
      v0 = *v10 | ((unint64_t)(*((unsigned __int16 *)v10 + 2) | (*((unsigned __int8 *)v10 + 6) << 16)) << 32);
      v15 = *(_BYTE *)(v2 + 409);
      v14 = *(_BYTE *)(v2 + 408);
      v11 = *(_QWORD *)(v2 + 328);
      LOBYTE(v8) = *(_BYTE *)(v2 + 406);
      v16 = v9;
      v17 = v3;
    }
    else
    {
      if (v21 == 1)
      {
        v24 = *(_QWORD *)(v2 + 312);
        *(_QWORD *)(v2 + 184) = off_1EA3EAFE0;
        *(_QWORD *)(v2 + 192) = Backend::Google::FindFullHashesResponseParser::parseThreatMatch;
        *(_QWORD *)(v2 + 208) = v4;
        Backend::Google::ProtocolMessageReader::readEmbeddedMessageField<Backend::Google::FindFullHashesResponse::ThreatMatch>(v24, v4, v58);
        v19 = *(uint64_t (***)(void))(v2 + 304);
        *(_QWORD *)(v2 + 360) = v19;
        if (!v19)
          goto LABEL_63;
        if (*v19)
        {
          v48 = 2;
          goto LABEL_56;
        }
        detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse::ThreatMatch>>::result((uint64_t)(v19 + 2));
        std::__optional_copy_base<Backend::Google::FindFullHashesResponse::ThreatMatch,false>::__optional_copy_base[abi:sn180100](v7, v25);
        if (*v58)
          ((void (*)(void))(*v58)[1])();
        v26 = *(_QWORD *)(v2 + 208);
        v27 = 4;
        result = (_QWORD *)v4;
        if (v26 == v4 || (v27 = 5, result = *(_QWORD **)(v2 + 208), v26))
          result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v27))();
        if (!*(_BYTE *)(v2 + 176))
          goto LABEL_53;
        v29 = *(_QWORD *)(v2 + 288);
        if (v29 >= *(_QWORD *)(v2 + 296))
        {
          v32 = std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__push_back_slow_path<Backend::Google::FindFullHashesResponse::ThreatMatch>(v57, v7);
        }
        else
        {
          if (!v29)
            goto LABEL_65;
          v30 = *v7;
          v31 = v7[2];
          *(_OWORD *)(v29 + 16) = v7[1];
          *(_OWORD *)(v29 + 32) = v31;
          *(_OWORD *)v29 = v30;
          *(_QWORD *)(v29 + 56) = 0;
          *(_QWORD *)(v29 + 64) = 0;
          *(_QWORD *)(v29 + 48) = 0;
          *(_OWORD *)(v29 + 48) = *(_OWORD *)(v2 + 144);
          *(_QWORD *)(v29 + 64) = *(_QWORD *)(v2 + 160);
          *(_QWORD *)(v2 + 144) = 0;
          *(_QWORD *)(v2 + 152) = 0;
          *(_QWORD *)(v2 + 160) = 0;
          *(_QWORD *)(v29 + 72) = *(_QWORD *)(v2 + 168);
          v32 = v29 + 80;
        }
        *(_QWORD *)(v2 + 288) = v32;
        if (*(_BYTE *)(v2 + 176))
        {
          *(_QWORD *)(v2 + 304) = v2 + 144;
          std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch::MetadataEntry>::__destroy_vector::operator()[abi:sn180100](v58);
        }
      }
      else
      {
        Backend::Google::ProtocolMessageReader::skipField(*(Backend::Google::ProtocolMessageReader **)(v2 + 312), v7);
        v19 = *(uint64_t (***)(void))(v2 + 96);
        *(_QWORD *)(v2 + 384) = v19;
        if (!v19)
          goto LABEL_63;
        if (*v19)
        {
          v48 = 5;
LABEL_56:
          *((_BYTE *)v10 + 68) = v48;
          v19[2] = (uint64_t (*)(void))v2;
          return (_QWORD *)(*v19)();
        }
        detail::lazy_promise<BOOL>::result((uint64_t)(v19 + 2));
        v44 = *v43;
        if (*(_QWORD *)v7)
          (*(void (**)(void))(*(_QWORD *)v7 + 8))();
        if (!v44)
          goto LABEL_53;
      }
      v18 = v10[2] | ((unint64_t)(*((unsigned __int16 *)v10 + 6) | (*((unsigned __int8 *)v10 + 14) << 16)) << 32);
      v17 = *(_BYTE *)(v2 + 411);
      v16 = *(_BYTE *)(v2 + 410);
      v0 = *v10 | ((unint64_t)(*((unsigned __int16 *)v10 + 2) | (*((unsigned __int8 *)v10 + 6) << 16)) << 32);
      v15 = *(_BYTE *)(v2 + 409);
      v14 = *(_BYTE *)(v2 + 408);
      LOBYTE(v8) = *(_BYTE *)(v2 + 406);
      LOBYTE(v9) = *(_BYTE *)(v2 + 405);
      v3 = *(_QWORD *)(v2 + 320);
      v11 = *(_QWORD *)(v2 + 328);
    }
    v1 = *((unsigned __int16 *)v10 + 32) | (*((unsigned __int8 *)v10 + 66) << 16);
    v13 = *(_BYTE *)(v2 + 412);
    v12 = 1;
  }
  if (!v22)
  {
    if ((_BYTE)v21
      && ((v45 = *(_BYTE *)(v2 + 408), v46 = *(_QWORD *)(v2 + 280), v47 = *(_QWORD *)(v2 + 288), v46 != v47)
       || *(_BYTE *)(v2 + 408)))
    {
      v49 = *((unsigned __int16 *)v10 + 6) | (*((unsigned __int8 *)v10 + 14) << 16);
      v50 = v10[2];
      v51 = *(unsigned __int8 *)(v2 + 411);
      v52 = *(_BYTE *)(v2 + 410);
      v53 = *((unsigned __int16 *)v10 + 2) | (*((unsigned __int8 *)v10 + 6) << 16);
      v54 = *v10;
      v55 = *(unsigned __int8 *)(v2 + 409);
      v56 = *(_QWORD *)(v2 + 296);
      *v57 = 0;
      v57[1] = 0;
      v57[2] = 0;
      v61[8] = v52;
      *(_QWORD *)&v61[16] = (v54 << 8) | (v53 << 40) | v55;
      v61[24] = v45;
      *(_QWORD *)(v2 + 32) = v46;
      *(_QWORD *)(v2 + 40) = v47;
      *(_QWORD *)(v2 + 48) = v56;
      *(_QWORD *)v61 = (v50 << 8) | (v49 << 40) | v51;
      memset(v60, 0, sizeof(v60));
      *(_OWORD *)(v2 + 56) = *(_OWORD *)v61;
      *(_OWORD *)(v2 + 65) = *(_OWORD *)&v61[9];
      *(_BYTE *)(v2 + 88) = 1;
      *(_DWORD *)(v2 + 24) = 1;
      v59 = v60;
      std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100]((void ***)&v59);
    }
    else
    {
LABEL_53:
      *(_BYTE *)(v2 + 32) = 0;
      *(_BYTE *)(v2 + 88) = 0;
      *(_DWORD *)(v2 + 24) = 1;
    }
    v60[0] = (void **)v57;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](v60);
    *(_QWORD *)v2 = 0;
    *((_BYTE *)v10 + 68) = 6;
    v19 = *(uint64_t (***)(void))(v2 + 16);
    return (_QWORD *)(*v19)();
  }
  result = (_QWORD *)std::__throw_bad_variant_access[abi:sn180100]();
LABEL_65:
  __break(1u);
  return result;
}

void sub_1DBCE000C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, void **a12)
{
  _QWORD *v12;
  uint64_t v13;

  a12 = a9;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&a12);
  *v12 = 0;
  *(_BYTE *)(v13 + 68) = 6;
  _Unwind_Resume(a1);
}

void sub_1DBCE01AC(__int16 *a1@<X8>)
{
  uint64_t v1;
  void **v2;
  char v3;
  __int16 v4;
  uint64_t v5;
  void **v6;

  v3 = *(_BYTE *)(v1 + 407);
  v4 = *a1;
  *((_BYTE *)a1 + 6) = *((_BYTE *)a1 + 2);
  a1[2] = v4;
  *(_BYTE *)(v1 + 412) = v3;
  v5 = *(_QWORD *)(v1 + 96);
  if (v5)
    (*(void (**)(void))(v5 + 8))();
  v6 = v2;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v6);
  detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse>>::~lazy_promise(v1 + 16);
  operator delete((void *)v1);
}

uint64_t sub_1DBCE0314@<X0>(__int16 *a1@<X8>)
{
  uint64_t v1;
  void **v2;
  char v3;
  __int16 v4;
  uint64_t v5;
  void **v7;

  v3 = *(_BYTE *)(v1 + 407);
  v4 = *a1;
  *((_BYTE *)a1 + 6) = *((_BYTE *)a1 + 2);
  a1[2] = v4;
  *(_BYTE *)(v1 + 412) = v3;
  v5 = *(_QWORD *)(v1 + 96);
  if (v5)
    (*(void (**)(void))(v5 + 8))();
  v7 = v2;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v7);
  return detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse>>::~lazy_promise(v1 + 16);
}

void Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &&)::$_0::operator()<std::shared_ptr<ReadStream>>(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  __int128 *v4;
  __int128 v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void **v12;
  __int128 v13;
  uint64_t v14;
  _BYTE v15[25];
  char v16;

  v2 = a1 + 24;
  v3 = (_QWORD *)(a1 + 440);
  detail::lazy_promise<std::optional<Backend::Google::FindFullHashesResponse>>::result(a1 + 40);
  LOBYTE(v13) = 0;
  v16 = 0;
  if (*((_BYTE *)v4 + 56))
  {
    v13 = *v4;
    v14 = *((_QWORD *)v4 + 2);
    *(_QWORD *)v4 = 0;
    *((_QWORD *)v4 + 1) = 0;
    *((_QWORD *)v4 + 2) = 0;
    v5 = *(__int128 *)((char *)v4 + 24);
    *(_OWORD *)&v15[9] = *(__int128 *)((char *)v4 + 33);
    *(_OWORD *)v15 = v5;
    v16 = 1;
  }
  Backend::Google::FindFullHashesResponseParser::parseFindFullHashesResponse(v2);
  v6 = *(_QWORD *)(a1 + 464);
  if (v6)
  {
    (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v6 + 48))(v6, &v13);
    if (v16)
    {
      v12 = (void **)&v13;
      std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v12);
    }
    v7 = *(std::__shared_weak_count **)(a1 + 488);
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v10 = *(_QWORD **)(a1 + 464);
    if (v10 == v3)
    {
      v11 = 4;
    }
    else
    {
      if (!v10)
      {
LABEL_16:
        *(_QWORD *)a1 = 0;
        *(_BYTE *)(a1 + 17) = 1;
        return;
      }
      v11 = 5;
      v3 = *(_QWORD **)(a1 + 464);
    }
    (*(void (**)(_QWORD *))(*v3 + 8 * v11))(v3);
    goto LABEL_16;
  }
  std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
}

void sub_1DBCE0558(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v6;
  uint64_t v7;

  v4 = v3;
  Backend::Google::FindFullHashesResponseParser::parseFindFullHashesResponse(v4);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](*(_QWORD *)(v1 + 512));
  v6 = *(_QWORD **)(v1 + 464);
  if (v6 == v2)
  {
    v7 = 4;
  }
  else
  {
    if (!v6)
      goto LABEL_6;
    v7 = 5;
    v2 = *(_QWORD **)(v1 + 464);
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v7))(v2);
LABEL_6:
  *(_QWORD *)v1 = 0;
  *(_BYTE *)(v1 + 17) = 1;
  _Unwind_Resume(a1);
}

void Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &&)::$_0::operator()<std::shared_ptr<ReadStream>>(_QWORD *__p)
{
  char *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  char *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;

  if ((*((_BYTE *)__p + 17) & 1) == 0)
  {
    v2 = (char *)(__p + 55);
    Backend::Google::FindFullHashesResponseParser::parseFindFullHashesResponse((uint64_t)(__p + 3));
    v3 = (std::__shared_weak_count *)__p[61];
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    v6 = (char *)__p[58];
    if (v6 == v2)
    {
      v7 = 4;
      v6 = (char *)(__p + 55);
      goto LABEL_11;
    }
    if (v6)
    {
      v7 = 5;
LABEL_11:
      (*(void (**)(void))(*(_QWORD *)v6 + 8 * v7))();
    }
  }
  v8 = (std::__shared_weak_count *)__p[63];
  if (v8)
  {
    v9 = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  operator delete(__p);
}

uint64_t Backend::Google::FullHashCache::FullHashCache(uint64_t a1, void *a2, int a3)
{
  id v5;

  v5 = a2;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 24) = a1 + 32;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 64) = a3;
  return a1;
}

void Backend::Google::FullHashCache::~FullHashCache(Backend::Google::FullHashCache *this)
{
  std::__shared_weak_count *v2;

  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 7, 0);

  std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::destroy((uint64_t)this + 24, *((_QWORD **)this + 4));
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

uint64_t Backend::Google::FullHashCache::lookup(uint64_t a1, _OWORD *a2, _QWORD *a3, unsigned int a4)
{
  _QWORD *v8;
  _QWORD *i;
  _QWORD *j;
  _BYTE __dst[32];
  _BYTE __n[17];
  uint64_t v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  __n[0] = a4;
  if (a4)
  {
    memcpy(__dst, a3, a4);
    *(_OWORD *)&__n[1] = *a2;
    v21 = __n[0];
    if (__n[0])
      memcpy(&v20, __dst, __n[0]);
  }
  else
  {
    *(_OWORD *)&__n[1] = *a2;
    v21 = 0;
  }
  v8 = std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::find<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>(a1 + 24, (uint64_t)&__n[1]);
  if ((_QWORD *)(a1 + 32) == v8)
    return 2;
  for (i = (_QWORD *)v8[13]; i != (_QWORD *)v8[14]; i += 5)
  {
    if (*i == *a3 && i[1] == a3[1] && i[2] == a3[2] && i[3] == a3[3])
      return 1;
  }
  for (j = (_QWORD *)v8[16]; j != (_QWORD *)v8[17]; j += 4)
  {
    if (*j == *a3 && j[1] == a3[1] && j[2] == a3[2] && j[3] == a3[3])
      return 2;
  }
  return 0;
}

void Backend::Google::FullHashCache::addSafePrefix(uint64_t a1, __int128 *a2, _BYTE *a3, uint64_t a4)
{
  uint64_t *v8;
  __int128 *v9;
  __int128 v10;
  uint64_t v11;
  unsigned __int8 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  v10 = *a2;
  v12 = a3[32];
  if (v12)
    memcpy(&v11, a3, v12);
  v9 = &v10;
  v8 = std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::__emplace_unique_key_args<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::piecewise_construct_t const&,std::tuple<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>&&>,std::tuple<>>((uint64_t **)(a1 + 24), (uint64_t)&v10, (uint64_t)&std::piecewise_construct, &v9);
  v8[14] = v8[13];
  v8[17] = v8[16];
  if (!*((_BYTE *)v8 + 96))
    *((_BYTE *)v8 + 96) = 1;
  v8[11] = a4;
  Backend::Google::FullHashCache::updateExpirationTimer((Backend::Google::FullHashCache *)a1);
}

void Backend::Google::FullHashCache::updateExpirationTimer(Backend::Google::FullHashCache *this)
{
  uint64_t CacheExpirationTime;
  char v3;
  uint64_t v4;
  std::chrono::system_clock::time_point v5;
  dispatch_time_t v6;
  NSObject *v7;
  NSObject *v8;
  void *v9;
  dispatch_source_t v10;
  void *v11;
  std::__shared_weak_count *v12;
  void *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  NSObject *v18;
  unint64_t v19;
  unint64_t v20;
  NSObject *v21;
  Platform::Transaction *v22;
  void *v23[2];
  uint64_t v24;
  uint64_t handler;
  uint64_t v26;
  void (*v27)(uint64_t);
  void *v28;
  void *v29;
  std::__shared_weak_count *v30;
  void *__p[2];
  uint64_t v32;

  CacheExpirationTime = Backend::Google::FullHashCache::nextCacheExpirationTime((dispatch_queue_t *)this);
  if (v3)
  {
    v4 = CacheExpirationTime;
    v5.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    v6 = dispatch_walltime(0, 1000 * (v4 - v5.__d_.__rep_));
    v7 = *((_QWORD *)this + 6);
    if (v7)
    {
      dispatch_source_set_timer(v7, v6, 0xFFFFFFFFFFFFFFFFLL, 0);
    }
    else
    {
      v10 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)this + 2));
      v11 = (void *)*((_QWORD *)this + 6);
      *((_QWORD *)this + 6) = v10;

      std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(__p, this);
      v13 = __p[0];
      v12 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        v14 = (unint64_t *)((char *)__p[1] + 16);
        do
          v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v17 = __ldaxr(p_shared_owners);
        while (__stlxr(v17 - 1, p_shared_owners));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
        v18 = *((_QWORD *)this + 6);
        handler = MEMORY[0x1E0C809B0];
        v26 = 3321888768;
        v27 = ___ZN7Backend6Google13FullHashCache21updateExpirationTimerEv_block_invoke;
        v28 = &__block_descriptor_48_ea8_32c67_ZTSKZN7Backend6Google13FullHashCache21updateExpirationTimerEvE3__0_e5_v8__0l;
        do
          v19 = __ldxr(v14);
        while (__stxr(v19 + 1, v14));
        v29 = v13;
        v30 = v12;
        do
          v20 = __ldxr(v14);
        while (__stxr(v20 + 1, v14));
        dispatch_source_set_event_handler(v18, &handler);
        std::__shared_weak_count::__release_weak(v12);
      }
      else
      {
        v21 = *((_QWORD *)this + 6);
        handler = MEMORY[0x1E0C809B0];
        v26 = 3321888768;
        v27 = ___ZN7Backend6Google13FullHashCache21updateExpirationTimerEv_block_invoke;
        v28 = &__block_descriptor_48_ea8_32c67_ZTSKZN7Backend6Google13FullHashCache21updateExpirationTimerEvE3__0_e5_v8__0l;
        v29 = __p[0];
        v30 = 0;
        dispatch_source_set_event_handler(v21, &handler);
      }
      dispatch_source_set_timer(*((dispatch_source_t *)this + 6), v6, 0xFFFFFFFFFFFFFFFFLL, 0);
      dispatch_resume(*((dispatch_object_t *)this + 6));
      std::string::basic_string[abi:sn180100]<0>((char **)v23, off_1EA3EC1A0[*((int *)this + 16) - 1]);
      v22 = (Platform::Transaction *)operator new(0x18uLL);
      *(_OWORD *)__p = *(_OWORD *)v23;
      v32 = v24;
      v23[1] = 0;
      v24 = 0;
      v23[0] = 0;
      Platform::Transaction::Transaction(v22, __p);
      if (SHIBYTE(v32) < 0)
        operator delete(__p[0]);
      std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 7, v22);
      if (SHIBYTE(v24) < 0)
        operator delete(v23[0]);
      if (v30)
        std::__shared_weak_count::__release_weak(v30);
      if (v12)
        std::__shared_weak_count::__release_weak(v12);
    }
  }
  else
  {
    v8 = *((_QWORD *)this + 6);
    if (v8)
    {
      dispatch_source_cancel(v8);
      v9 = (void *)*((_QWORD *)this + 6);
    }
    else
    {
      v9 = 0;
    }
    *((_QWORD *)this + 6) = 0;

    std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 7, 0);
  }
}

void sub_1DBCE0C30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  std::__shared_weak_count *v27;
  void *v28;

  if (a27 < 0)
    operator delete(__p);
  operator delete(v28);
  if (a15 < 0)
    operator delete(a10);
  if (a21)
    std::__shared_weak_count::__release_weak(a21);
  if (v27)
    std::__shared_weak_count::__release_weak(v27);
  _Unwind_Resume(a1);
}

void Backend::Google::FullHashCache::addUnsafeFullHash(uint64_t a1, _OWORD *a2, _OWORD *a3, unsigned int a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t *v14;
  _QWORD *v15;
  __int128 v16;
  unint64_t v17;
  unint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  __int128 v32;
  __int128 v33;
  _OWORD *v34;
  _BYTE __dst[32];
  _BYTE __n[17];
  __int128 v37;
  char v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  __n[0] = a4;
  if (a4)
  {
    memcpy(__dst, a3, a4);
    *(_OWORD *)&__n[1] = *a2;
    v38 = __n[0];
    if (__n[0])
      memcpy(&v37, __dst, __n[0]);
  }
  else
  {
    *(_OWORD *)&__n[1] = *a2;
    v38 = 0;
  }
  v34 = &__n[1];
  v14 = std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::__emplace_unique_key_args<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::piecewise_construct_t const&,std::tuple<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>&&>,std::tuple<>>((uint64_t **)(a1 + 24), (uint64_t)&__n[1], (uint64_t)&std::piecewise_construct, &v34);
  v15 = std::remove[abi:sn180100]<std::__wrap_iter<std::array<unsigned char,32ul> *>,std::array<unsigned char,32ul>>((_QWORD *)v14[16], (_QWORD *)v14[17], a3);
  if (v14[17] < (unint64_t)v15)
    goto LABEL_30;
  if ((_QWORD *)v14[17] != v15)
    v14[17] = (uint64_t)v15;
  v16 = a3[1];
  *(_OWORD *)&__n[1] = *a3;
  v37 = v16;
  v17 = v14[15];
  v18 = v14[14];
  if (v18 < v17)
  {
    if (v18)
    {
      v19 = a3[1];
      *(_OWORD *)v18 = *a3;
      *(_OWORD *)(v18 + 16) = v19;
      *(_QWORD *)(v18 + 32) = a5;
      v20 = v18 + 40;
      goto LABEL_24;
    }
LABEL_30:
    __break(1u);
    JUMPOUT(0x1DBCE0F08);
  }
  v21 = v14[13];
  v22 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v18 - v21) >> 3);
  v23 = v22 + 1;
  if (v22 + 1 > 0x666666666666666)
    abort();
  v24 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v17 - v21) >> 3);
  if (2 * v24 > v23)
    v23 = 2 * v24;
  if (v24 >= 0x333333333333333)
    v25 = 0x666666666666666;
  else
    v25 = v23;
  if (!v25)
    goto LABEL_30;
  v26 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FullHashCache::Value::Entry>>((uint64_t)(v14 + 15), v25);
  if (!v26)
    goto LABEL_30;
  v28 = &v26[40 * v27];
  v29 = &v26[40 * v22];
  *((_OWORD *)v29 + 1) = v37;
  *(_OWORD *)v29 = *(_OWORD *)&__n[1];
  *((_QWORD *)v29 + 4) = a5;
  v20 = (uint64_t)(v29 + 40);
  v31 = (char *)v14[13];
  v30 = (char *)v14[14];
  if (v30 != v31)
  {
    do
    {
      v32 = *(_OWORD *)(v30 - 40);
      v33 = *(_OWORD *)(v30 - 24);
      *((_QWORD *)v29 - 1) = *((_QWORD *)v30 - 1);
      *(_OWORD *)(v29 - 24) = v33;
      *(_OWORD *)(v29 - 40) = v32;
      v29 -= 40;
      v30 -= 40;
    }
    while (v30 != v31);
    v30 = (char *)v14[13];
  }
  v14[13] = (uint64_t)v29;
  v14[14] = v20;
  v14[15] = (uint64_t)v28;
  if (v30)
    operator delete(v30);
LABEL_24:
  v14[14] = v20;
  if (a7)
  {
    if (!*((_BYTE *)v14 + 96))
      *((_BYTE *)v14 + 96) = 1;
    v14[11] = a6;
  }
  Backend::Google::FullHashCache::updateExpirationTimer((Backend::Google::FullHashCache *)a1);
}

_QWORD *std::remove[abi:sn180100]<std::__wrap_iter<std::array<unsigned char,32ul> *>,std::array<unsigned char,32ul>>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *i;
  __int128 v10;

  while (result != a2)
  {
    if (*result == *a3 && result[1] == a3[1] && result[2] == a3[2] && result[3] == a3[3])
      goto LABEL_14;
    result += 4;
  }
  result = a2;
LABEL_14:
  if (result != a2)
  {
    for (i = result + 4; i != a2; i += 4)
    {
      if (*i != *a3 || i[1] != a3[1] || i[2] != a3[2] || i[3] != a3[3])
      {
        v10 = *((_OWORD *)i + 1);
        *(_OWORD *)result = *(_OWORD *)i;
        *((_OWORD *)result + 1) = v10;
        result += 4;
      }
    }
  }
  return result;
}

uint64_t Backend::Google::FullHashCache::nextCacheExpirationTime(dispatch_queue_t *this)
{
  Backend::Google::FullHashCache *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  BOOL v7;
  Backend::Google::FullHashCache *v8;
  Backend::Google::FullHashCache *v9;

  dispatch_assert_queue_V2(this[2]);
  if (!this[5])
    return 0;
  v2 = (Backend::Google::FullHashCache *)this[3];
  result = 0x7FFFFFFFFFFFFFFFLL;
  if (v2 != (Backend::Google::FullHashCache *)(this + 4))
  {
    do
    {
      v4 = *((_QWORD *)v2 + 13);
      v5 = *((_QWORD *)v2 + 14);
      for (i = v4; i != v5; i += 40)
      {
        if (*(_QWORD *)(i + 32) < result)
          result = *(_QWORD *)(i + 32);
      }
      if (*((_BYTE *)v2 + 96))
        v7 = v4 == v5;
      else
        v7 = 0;
      if (v7 && *((_QWORD *)v2 + 11) < result)
        result = *((_QWORD *)v2 + 11);
      v8 = (Backend::Google::FullHashCache *)*((_QWORD *)v2 + 1);
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = *(Backend::Google::FullHashCache **)v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v9 = (Backend::Google::FullHashCache *)*((_QWORD *)v2 + 2);
          v7 = *(_QWORD *)v9 == (_QWORD)v2;
          v2 = v9;
        }
        while (!v7);
      }
      v2 = v9;
    }
    while (v9 != (Backend::Google::FullHashCache *)(this + 4));
  }
  return result;
}

void ___ZN7Backend6Google13FullHashCache21updateExpirationTimerEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  dispatch_queue_t *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(dispatch_queue_t **)(a1 + 32);
      if (v5)
        Backend::Google::FullHashCache::expirationTimerFired(v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1DBCE10D0(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
    ___ZN7Backend6Google13FullHashCache21updateExpirationTimerEv_block_invoke_cold_1(v1);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_ea8_32c67_ZTSKZN7Backend6Google13FullHashCache21updateExpirationTimerEvE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_ea8_32c67_ZTSKZN7Backend6Google13FullHashCache21updateExpirationTimerEvE3__0(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

char **Backend::Google::FullHashCache::transactionDescription@<X0>(Backend::Google::FullHashCache *this@<X0>, char **a2@<X8>)
{
  return std::string::basic_string[abi:sn180100]<0>(a2, off_1EA3EC1A0[*((int *)this + 16) - 1]);
}

void Backend::Google::FullHashCache::expirationTimerFired(dispatch_queue_t *this)
{
  std::chrono::system_clock::time_point v2;
  uint64_t *v3;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep;
  char **v5;
  _OWORD *v6;
  _OWORD *v7;
  _OWORD *v8;
  unint64_t v9;
  unint64_t v10;
  __int128 v11;
  __int128 v12;
  char *v13;
  _OWORD *v14;
  unint64_t v15;
  __int128 v16;
  _OWORD *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  __int128 v25;
  __int128 v26;
  char *v27;
  char *v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  char *v39;
  __int128 v40;
  char *v41;
  char *v42;
  char *v43;
  __int128 v44;
  uint64_t *v45;
  uint64_t *v46;
  BOOL v47;
  Backend::Google::FullHashCache *v48;
  uint64_t **v49;
  uint64_t *v50;

  dispatch_assert_queue_V2(this[2]);
  v2.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  v48 = (Backend::Google::FullHashCache *)this;
  v3 = (uint64_t *)this[3];
  v49 = (uint64_t **)(this + 3);
  v50 = (uint64_t *)(this + 4);
  if (v3 == (uint64_t *)(this + 4))
  {
LABEL_54:
    Backend::Google::FullHashCache::updateExpirationTimer(v48);
    return;
  }
  rep = v2.__d_.__rep_;
  while (1)
  {
    v3[15] = 0;
    v5 = (char **)(v3 + 13);
    v6 = (_OWORD *)v3[13];
    v7 = (_OWORD *)v3[14];
    v3[13] = 0;
    v3[14] = 0;
    if (v6 != v7)
      break;
LABEL_41:
    if (v6)
      operator delete(v6);
    if (v3[13] != v3[14] || *((_BYTE *)v3 + 96) && v3[11] > rep)
    {
      v45 = (uint64_t *)v3[1];
      if (v45)
      {
        do
        {
          v46 = v45;
          v45 = (uint64_t *)*v45;
        }
        while (v45);
      }
      else
      {
        do
        {
          v46 = (uint64_t *)v3[2];
          v47 = *v46 == (_QWORD)v3;
          v3 = v46;
        }
        while (!v47);
      }
    }
    else
    {
      v46 = std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::__remove_node_pointer(v49, v3);
      std::__destroy_at[abi:sn180100]<std::pair<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash> const,Backend::Google::FullHashCache::Value>,0>(v3 + 4);
      operator delete(v3);
    }
    v3 = v46;
    if (v46 == v50)
      goto LABEL_54;
  }
  v8 = v6;
  while (*((_QWORD *)v8 + 4) > rep)
  {
    v9 = v3[14];
    v10 = v3[15];
    if (v9 >= v10)
    {
      v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v9 - (_QWORD)*v5) >> 3);
      v19 = v18 + 1;
      if (v18 + 1 > 0x666666666666666)
        goto LABEL_55;
      v20 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - (_QWORD)*v5) >> 3);
      if (2 * v20 > v19)
        v19 = 2 * v20;
      if (v20 >= 0x333333333333333)
        v21 = 0x666666666666666;
      else
        v21 = v19;
      if (!v21)
        goto LABEL_56;
      v22 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FullHashCache::Value::Entry>>((uint64_t)(v3 + 15), v21);
      if (!v22)
        goto LABEL_56;
      v24 = &v22[40 * v18];
      v25 = *v8;
      v26 = v8[1];
      *((_QWORD *)v24 + 4) = *((_QWORD *)v8 + 4);
      *(_OWORD *)v24 = v25;
      *((_OWORD *)v24 + 1) = v26;
      v28 = (char *)v3[13];
      v27 = (char *)v3[14];
      v29 = v24;
      if (v27 != v28)
      {
        do
        {
          v30 = *(_OWORD *)(v27 - 40);
          v31 = *(_OWORD *)(v27 - 24);
          *((_QWORD *)v29 - 1) = *((_QWORD *)v27 - 1);
          *(_OWORD *)(v29 - 24) = v31;
          *(_OWORD *)(v29 - 40) = v30;
          v29 -= 40;
          v27 -= 40;
        }
        while (v27 != v28);
        v27 = *v5;
      }
      v13 = v24 + 40;
      v3[13] = (uint64_t)v29;
      v3[14] = (uint64_t)(v24 + 40);
      v3[15] = (uint64_t)&v22[40 * v23];
      if (v27)
        operator delete(v27);
    }
    else
    {
      if (!v9)
        goto LABEL_56;
      v11 = *v8;
      v12 = v8[1];
      *(_QWORD *)(v9 + 32) = *((_QWORD *)v8 + 4);
      *(_OWORD *)v9 = v11;
      *(_OWORD *)(v9 + 16) = v12;
      v13 = (char *)(v9 + 40);
    }
    v3[14] = (uint64_t)v13;
LABEL_40:
    v8 = (_OWORD *)((char *)v8 + 40);
    if (v8 == v7)
      goto LABEL_41;
  }
  v14 = (_OWORD *)v3[17];
  v15 = v3[18];
  if ((unint64_t)v14 < v15)
  {
    if (!v14)
      goto LABEL_56;
    v16 = v8[1];
    *v14 = *v8;
    v14[1] = v16;
    v17 = v14 + 2;
    goto LABEL_39;
  }
  v32 = v3[16];
  v33 = ((uint64_t)v14 - v32) >> 5;
  v34 = v33 + 1;
  if ((unint64_t)(v33 + 1) >> 59)
LABEL_55:
    abort();
  v35 = v15 - v32;
  if (v35 >> 4 > v34)
    v34 = v35 >> 4;
  if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFE0)
    v36 = 0x7FFFFFFFFFFFFFFLL;
  else
    v36 = v34;
  if (v36)
  {
    v37 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<std::array<unsigned char,32ul>>>((uint64_t)(v3 + 18), v36);
    if (v37)
    {
      v39 = &v37[32 * v33];
      v40 = v8[1];
      *(_OWORD *)v39 = *v8;
      *((_OWORD *)v39 + 1) = v40;
      v42 = (char *)v3[16];
      v41 = (char *)v3[17];
      v43 = v39;
      if (v41 != v42)
      {
        do
        {
          v44 = *((_OWORD *)v41 - 1);
          *((_OWORD *)v43 - 2) = *((_OWORD *)v41 - 2);
          *((_OWORD *)v43 - 1) = v44;
          v43 -= 32;
          v41 -= 32;
        }
        while (v41 != v42);
        v41 = (char *)v3[16];
      }
      v17 = v39 + 32;
      v3[16] = (uint64_t)v43;
      v3[17] = (uint64_t)(v39 + 32);
      v3[18] = (uint64_t)&v37[32 * v38];
      if (v41)
        operator delete(v41);
LABEL_39:
      v3[17] = (uint64_t)v17;
      goto LABEL_40;
    }
  }
LABEL_56:
  __break(1u);
}

void sub_1DBCE1470(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FullHashCache::Value::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(40 * a2);
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<std::array<unsigned char,32ul>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(32 * a2);
}

void std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:sn180100]<std::pair<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash> const,Backend::Google::FullHashCache::Value>,0>(a2 + 4);
    operator delete(a2);
  }
}

void std::__destroy_at[abi:sn180100]<std::pair<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash> const,Backend::Google::FullHashCache::Value>,0>(_QWORD *a1)
{
  void *v2;
  void *v3;

  if (a1)
  {
    v2 = (void *)a1[12];
    if (v2)
    {
      a1[13] = v2;
      operator delete(v2);
    }
    v3 = (void *)a1[9];
    if (v3)
    {
      a1[10] = v3;
      operator delete(v3);
    }
  }
  else
  {
    __break(1u);
  }
}

_QWORD *std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::find<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  char v6;
  _QWORD *v7;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = (_QWORD *)(a1 + 8);
  do
  {
    v6 = std::operator<=>[abi:sn180100]<Backend::Google::ThreatListDescriptor,Backend::Google::Hash,Backend::Google::ThreatListDescriptor,Backend::Google::Hash>((uint64_t)(v3 + 4), a2);
    if (v6 >= 0)
      v7 = v3;
    else
      v7 = v3 + 1;
    if (v6 >= 0)
      v5 = v3;
    v3 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v5 == v2
    || (std::operator<=>[abi:sn180100]<Backend::Google::ThreatListDescriptor,Backend::Google::Hash,Backend::Google::ThreatListDescriptor,Backend::Google::Hash>(a2, (uint64_t)(v5 + 4)) & 0x80) != 0)
  {
    return v2;
  }
  return v5;
}

uint64_t std::operator<=>[abi:sn180100]<Backend::Google::ThreatListDescriptor,Backend::Google::Hash,Backend::Google::ThreatListDescriptor,Backend::Google::Hash>(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = std::__synth_three_way[abi:sn180100]<Backend::Google::ThreatListDescriptor,Backend::Google::ThreatListDescriptor>((int *)a1, (int *)a2);
  if (!(_BYTE)result)
    return std::__synth_three_way[abi:sn180100]<Backend::Google::Hash,Backend::Google::Hash>((unsigned __int8 *)(a1 + 16), (unsigned __int8 *)(a2 + 16));
  return result;
}

uint64_t std::__synth_three_way[abi:sn180100]<Backend::Google::ThreatListDescriptor,Backend::Google::ThreatListDescriptor>(int *a1, int *a2)
{
  if ((Backend::Google::operator<(a1, a2) & 1) != 0)
    return 255;
  else
    return Backend::Google::operator<(a2, a1);
}

uint64_t std::__synth_three_way[abi:sn180100]<Backend::Google::Hash,Backend::Google::Hash>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;

  v2 = a2[32];
  if (a2[32])
  {
    v3 = v2 - 1;
    v4 = a1[32];
    v5 = a1;
    v6 = a2;
    while (v4)
    {
      v7 = *v5;
      v8 = *v6;
      if (v7 < v8)
        break;
      ++v5;
      ++v6;
      --v4;
      if (v8 < v7 || v3-- == 0)
        goto LABEL_10;
    }
    return 255;
  }
  else
  {
LABEL_10:
    if (a1[32])
    {
      v10 = a1[32] - 1;
      while (v2)
      {
        v11 = *a2;
        v12 = *a1;
        if (v11 < v12)
          break;
        ++a2;
        ++a1;
        --v2;
        if (v12 < v11 || v10-- == 0)
          return 0;
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
}

uint64_t *std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::__emplace_unique_key_args<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::piecewise_construct_t const&,std::tuple<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>&&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t a3, _OWORD **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v9;
  _OWORD *v10;
  _QWORD v12[2];
  char v13;
  uint64_t v14;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::__find_equal<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>((uint64_t)a1, &v14, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    v9 = (uint64_t *)operator new(0x98uLL);
    v7 = v9;
    v12[1] = a1 + 1;
    v10 = *a4;
    *((_OWORD *)v9 + 2) = **a4;
    *((_BYTE *)v9 + 80) = *((_BYTE *)v10 + 48);
    if (*((_BYTE *)v10 + 48))
      memmove(v9 + 6, v10 + 1, *((unsigned __int8 *)v10 + 48));
    *(_OWORD *)(v7 + 17) = 0u;
    *(_OWORD *)(v7 + 15) = 0u;
    *(_OWORD *)(v7 + 13) = 0u;
    *(_OWORD *)(v7 + 11) = 0u;
    v13 = 1;
    std::__tree<Backend::Google::HashView>::__insert_node_at(a1, v14, v8, v7);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,void *>>>>::reset[abi:sn180100]((uint64_t)v12, 0);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::__find_equal<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  uint64_t v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = (uint64_t)(v4 + 4);
        if ((std::operator<=>[abi:sn180100]<Backend::Google::ThreatListDescriptor,Backend::Google::Hash,Backend::Google::ThreatListDescriptor,Backend::Google::Hash>(a3, (uint64_t)(v4 + 4)) & 0x80) == 0)break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if ((std::operator<=>[abi:sn180100]<Backend::Google::ThreatListDescriptor,Backend::Google::Hash,Backend::Google::ThreatListDescriptor,Backend::Google::Hash>(v8, a3) & 0x80) == 0)break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,void *>>>>::reset[abi:sn180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  v2 = *(_QWORD **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:sn180100]<std::pair<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash> const,Backend::Google::FullHashCache::Value>,0>(v2 + 4);
    operator delete(v2);
  }
}

uint64_t *std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

Backend::Google::FullHashChecker *Backend::Google::FullHashChecker::FullHashChecker(Backend::Google::FullHashChecker *this, const Backend::Google::Configuration *a2)
{
  void *v3;
  void *v4;
  char v5;
  Backend::Google::SSBUtilities *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  void *v14;
  char v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  void *v22;
  char v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  int v32;
  __int128 v33;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = dispatch_queue_create("com.apple.Safari.SafeBrowsing.FullHashChecker", 0);
  *((_DWORD *)this + 6) = 1;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 10) = (char *)this + 88;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_QWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 136) = 0u;
  +[RemoteConfigurationController sharedController](RemoteConfigurationController, "sharedController");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "googleProviderConfiguration");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "providerOff");

  if ((v5 & 1) == 0)
  {
    v32 = 1;
    std::allocate_shared[abi:sn180100]<Backend::Google::FullHashFetcher,std::allocator<Backend::Google::FullHashFetcher>,Backend::Google::Configuration const&,Backend::Google::SafeBrowsingProvider,void>((uint64_t)a2, (unsigned int *)&v32, &v33);
    std::shared_ptr<ByteProvider>::operator=[abi:sn180100]((uint64_t)this + 32, &v33);
    v7 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
    if (*((_QWORD *)&v33 + 1))
    {
      v8 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    v32 = 1;
    std::allocate_shared[abi:sn180100]<Backend::Google::FullHashCache,std::allocator<Backend::Google::FullHashCache>,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::SafeBrowsingProvider,void>((void **)this + 2, &v32, &v33);
    v6 = (Backend::Google::SSBUtilities *)std::shared_ptr<ByteProvider>::operator=[abi:sn180100]((uint64_t)this + 104, &v33);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
    if (*((_QWORD *)&v33 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(v6);
  if ((_DWORD)shouldConsultWithTencent)
  {
    objc_msgSend(v3, "tencentProviderConfiguration");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = objc_msgSend(v14, "providerOff");

    if ((v15 & 1) == 0)
    {
      v32 = 2;
      std::allocate_shared[abi:sn180100]<Backend::Google::FullHashFetcher,std::allocator<Backend::Google::FullHashFetcher>,Backend::Google::Configuration const&,Backend::Google::SafeBrowsingProvider,void>((uint64_t)a2, (unsigned int *)&v32, &v33);
      std::shared_ptr<ByteProvider>::operator=[abi:sn180100]((uint64_t)this + 48, &v33);
      v16 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
      if (*((_QWORD *)&v33 + 1))
      {
        v17 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v32 = 2;
      std::allocate_shared[abi:sn180100]<Backend::Google::FullHashCache,std::allocator<Backend::Google::FullHashCache>,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::SafeBrowsingProvider,void>((void **)this + 2, &v32, &v33);
      shouldConsultWithTencent = (Backend::Google::SSBUtilities *)std::shared_ptr<ByteProvider>::operator=[abi:sn180100]((uint64_t)this + 120, &v33);
      v19 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
      if (*((_QWORD *)&v33 + 1))
      {
        v20 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
    }
  }
  if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
  {
    objc_msgSend(v3, "appleProviderConfiguration");
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = objc_msgSend(v22, "providerOff");

    if ((v23 & 1) == 0)
    {
      v32 = 3;
      std::allocate_shared[abi:sn180100]<Backend::Google::FullHashFetcher,std::allocator<Backend::Google::FullHashFetcher>,Backend::Google::Configuration const&,Backend::Google::SafeBrowsingProvider,void>((uint64_t)a2, (unsigned int *)&v32, &v33);
      std::shared_ptr<ByteProvider>::operator=[abi:sn180100]((uint64_t)this + 64, &v33);
      v24 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
      if (*((_QWORD *)&v33 + 1))
      {
        v25 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      v32 = 3;
      std::allocate_shared[abi:sn180100]<Backend::Google::FullHashCache,std::allocator<Backend::Google::FullHashCache>,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::SafeBrowsingProvider,void>((void **)this + 2, &v32, &v33);
      std::shared_ptr<ByteProvider>::operator=[abi:sn180100]((uint64_t)this + 136, &v33);
      v27 = (std::__shared_weak_count *)*((_QWORD *)&v33 + 1);
      if (*((_QWORD *)&v33 + 1))
      {
        v28 = (unint64_t *)(*((_QWORD *)&v33 + 1) + 8);
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }
  }

  return this;
}

void sub_1DBCE2054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v19;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v17);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v16);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v15);
  std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::destroy(a10, *(_QWORD **)(v11 + 88));
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v13);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a11);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v12);

  v19 = *(std::__shared_weak_count **)(v11 + 8);
  if (v19)
    std::__shared_weak_count::__release_weak(v19);
  _Unwind_Resume(a1);
}

void Backend::Google::FullHashChecker::~FullHashChecker(Backend::Google::FullHashChecker *this)
{
  std::__shared_weak_count *v2;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 136);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 120);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 104);
  std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::destroy((uint64_t)this + 80, *((_QWORD **)this + 11));
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 64);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 48);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 32);

  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void Backend::Google::FullHashChecker::checkHashes(_QWORD *a1, uint64_t a2, void *a3, void *a4, void *a5, char a6, uint64_t a7)
{
  id v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  Platform::Transaction *v17;
  void *shared_owners;
  NSObject *v19;
  void *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  id v41;
  id v42;
  _QWORD block[4];
  void *v44;
  std::__shared_weak_count *v45;
  std::__shared_weak_count *v46;
  std::__shared_weak_count *v47;
  std::__shared_weak_count *v48;
  std::__shared_weak_count *v49;
  void *__p;
  std::__shared_weak_count *v51;
  char v52;

  v42 = a3;
  v41 = a4;
  v14 = a5;
  v15 = (std::__shared_weak_count *)operator new(0x78uLL);
  v15->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v15->__shared_owners_;
  v15->__shared_weak_owners_ = 0;
  v15->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBA00;
  v15[1].std::__shared_count = 0u;
  *(_OWORD *)&v15[1].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v15[2].__shared_owners_ = 0u;
  v15[3].std::__shared_count = 0u;
  *(_OWORD *)&v15[3].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v15[4].__shared_owners_ = 0u;
  v48 = v15 + 1;
  v49 = v15;
  std::vector<Backend::Google::FullHashRequest>::__vdeallocate((void **)&v15[1].__vftable);
  v15[1].std::__shared_count = *(std::__shared_count *)a2;
  v15[1].__shared_weak_owners_ = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v17 = (Platform::Transaction *)operator new(0x18uLL);
  std::string::basic_string[abi:sn180100]<0>((char **)&__p, "Full Hash Check");
  Platform::Transaction::Transaction(v17, &__p);
  if (v52 < 0)
    operator delete(__p);
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)&v15[2], v17);
  objc_storeStrong((id *)&v15[2].__shared_owners_, a3);
  objc_storeStrong((id *)&v15[2].__shared_weak_owners_, a4);
  LOBYTE(v15[3].__vftable) = a6;
  shared_owners = (void *)v15[3].__shared_owners_;
  v15[3].__shared_owners_ = (uint64_t)v14;

  std::__function::__value_func<void ()(std::optional<ReadStatus>)>::operator=[abi:sn180100](&v15[3].__shared_weak_owners_, a7);
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&__p, a1);
  v19 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN7Backend6Google15FullHashChecker11checkHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_bNS2_8functionIFvNS3_INS0_20ThreatListDescriptorENS5_ISG_EEEEEEE_block_invoke;
  block[3] = &__block_descriptor_64_ea8_32c274_ZTSKZN7Backend6Google15FullHashChecker11checkHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_bNS2_8functionIFvNS3_INS0_20ThreatListDescriptorENS5_ISG_EEEEEEEE3__0_e5_v8__0l;
  v20 = __p;
  v21 = v51;
  if (v51)
  {
    v22 = (unint64_t *)&v51->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
    v48 = 0;
    v49 = 0;
    v44 = v20;
    v45 = v21;
    do
      v24 = __ldxr(v22);
    while (__stxr(v24 + 1, v22));
  }
  else
  {
    v48 = 0;
    v49 = 0;
    v44 = __p;
    v45 = 0;
  }
  v46 = v15 + 1;
  v47 = v15;
  do
    v25 = __ldxr(p_shared_owners);
  while (__stxr(v25 + 1, p_shared_owners));
  dispatch_async(v19, block);
  do
    v26 = __ldaxr(p_shared_owners);
  while (__stlxr(v26 - 1, p_shared_owners));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (v21)
  {
    v27 = (unint64_t *)&v21->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v29 = v47;
  if (v47)
  {
    v30 = (unint64_t *)&v47->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v45;
  if (v45)
  {
    v33 = (unint64_t *)&v45->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  v35 = v51;
  if (v51)
  {
    v36 = (unint64_t *)&v51->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = v49;
  if (v49)
  {
    v39 = (unint64_t *)&v49->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }

}

void sub_1DBCE249C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a20);

  _Unwind_Resume(a1);
}

void ___ZN7Backend6Google15FullHashChecker11checkHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_bNS2_8functionIFvNS3_INS0_20ThreatListDescriptorENS5_ISG_EEEEEEE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;

  v2 = a1[4];
  v4 = a1[6];
  v3 = (std::__shared_weak_count *)a1[7];
  v10 = v4;
  v11 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  Backend::Google::FullHashChecker::checkHashes(v2, &v10);
  v7 = v11;
  if (v11)
  {
    v8 = (unint64_t *)&v11->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_1DBCE2588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
    ___ZN7Backend6Google15FullHashChecker11checkHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_bNS2_8functionIFvNS3_INS0_20ThreatListDescriptorENS5_ISG_EEEEEEE_block_invoke_cold_1(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *__copy_helper_block_ea8_32c274_ZTSKZN7Backend6Google15FullHashChecker11checkHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_bNS2_8functionIFvNS3_INS0_20ThreatListDescriptorENS5_ISG_EEEEEEEE3__0(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c274_ZTSKZN7Backend6Google15FullHashChecker11checkHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_bNS2_8functionIFvNS3_INS0_20ThreatListDescriptorENS5_ISG_EEEEEEEE3__0(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 48);
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
}

uint64_t Backend::Google::FullHashChecker::checkFullHashRequests(uint64_t a1, unint64_t *a2, uint64_t *a3, int a4, uint64_t **a5, uint64_t a6, void **a7)
{
  uint64_t v7;
  uint64_t v8;
  char v14;
  __int128 *v15;
  int v16;
  __int128 *v17;
  unint64_t v18;
  _OWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  _BYTE __src[32];
  _BYTE __n[17];
  uint64_t v40;
  unsigned __int8 v41;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)*a2;
  v7 = *(_QWORD *)(*a2 + 8);
  if (v8 == v7)
  {
    v14 = 1;
  }
  else
  {
    v37 = a1 + 80;
    v35 = (uint64_t)(a7 + 2);
    v36 = (_QWORD *)(a1 + 88);
    v14 = 1;
    do
    {
      if (*(_DWORD *)(v8 + 48) == a4)
      {
        v15 = (__int128 *)(v8 + 36);
        v16 = Backend::Google::FullHashCache::lookup(*a3, (_OWORD *)(v8 + 36), (_QWORD *)v8, *(unsigned __int8 *)(v8 + 32));
        if (v16 == 2)
        {
          v41 = *(_BYTE *)(v8 + 32);
          if (v41)
            memmove(&__n[1], (const void *)v8, v41);
          v42 = *v15;
          v20 = std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::find<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>(v37, (uint64_t)&__n[1]);
          if (v36 == v20)
          {
            __n[0] = *(_BYTE *)(v8 + 32);
            if (__n[0])
            {
              memcpy(__src, (const void *)v8, __n[0]);
              *(_OWORD *)&__n[1] = *v15;
              BYTE12(v42) = __n[0];
              if (__n[0])
                memcpy(&v40, __src, __n[0]);
            }
            else
            {
              *(_OWORD *)&__n[1] = *v15;
              BYTE12(v42) = 0;
            }
            std::__tree<Backend::Google::FullHashChecker::FetchRequest::Entry>::__emplace_unique_key_args<Backend::Google::FullHashChecker::FetchRequest::Entry,Backend::Google::FullHashChecker::FetchRequest::Entry>(a5, &__n[1], (uint64_t)&__n[1]);
            v31 = *(_QWORD *)(a6 + 8);
            if (v31 >= *(_QWORD *)(a6 + 16))
            {
              v32 = std::vector<Backend::Google::FullHashRequest>::__push_back_slow_path<Backend::Google::FullHashRequest const&>(a6, (const Backend::Google::FullHashRequest *)v8);
            }
            else
            {
              if (!v31)
                goto LABEL_41;
              Backend::Google::FullHashRequest::FullHashRequest(*(Backend::Google::FullHashRequest **)(a6 + 8), (const Backend::Google::FullHashRequest *)v8);
              v32 = v31 + 72;
              *(_QWORD *)(a6 + 8) = v31 + 72;
            }
            v14 = 0;
            *(_QWORD *)(a6 + 8) = v32;
          }
          else
          {
            std::__tree<std::shared_ptr<Backend::Google::FullHashChecker::Check>>::__emplace_unique_key_args<std::shared_ptr<Backend::Google::FullHashChecker::Check>,std::shared_ptr<Backend::Google::FullHashChecker::Check> const&>((uint64_t **)(v20[11] + 24), a2, (uint64_t *)a2);
            v14 = 0;
          }
        }
        else if (v16 == 1)
        {
          v17 = (__int128 *)a7[1];
          v18 = (unint64_t)a7[2];
          if ((unint64_t)v17 >= v18)
          {
            v21 = ((char *)v17 - (_BYTE *)*a7) >> 4;
            v22 = v21 + 1;
            if ((unint64_t)(v21 + 1) >> 60)
              abort();
            v23 = v18 - (_QWORD)*a7;
            if (v23 >> 3 > v22)
              v22 = v23 >> 3;
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0)
              v24 = 0xFFFFFFFFFFFFFFFLL;
            else
              v24 = v22;
            if (!v24
              || (v25 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::Database::HashSizeBucket>>(v35, v24)) == 0)
            {
LABEL_41:
              __break(1u);
            }
            v27 = &v25[16 * v21];
            *(_OWORD *)v27 = *v15;
            v29 = (char *)*a7;
            v28 = (char *)a7[1];
            v30 = v27;
            if (v28 != *a7)
            {
              do
              {
                *((_OWORD *)v30 - 1) = *((_OWORD *)v28 - 1);
                v30 -= 16;
                v28 -= 16;
              }
              while (v28 != v29);
              v28 = (char *)*a7;
            }
            v19 = v27 + 16;
            *a7 = v30;
            a7[1] = v27 + 16;
            a7[2] = &v25[16 * v26];
            if (v28)
              operator delete(v28);
          }
          else
          {
            if (!v17)
              goto LABEL_41;
            *v17 = *v15;
            v19 = v17 + 1;
          }
          a7[1] = v19;
        }
      }
      v8 += 72;
    }
    while (v8 != v7);
  }
  return v14 & 1;
}

void sub_1DBCE28CC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void Backend::Google::FullHashChecker::fetchHashes(uint64_t a1, _QWORD *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, void *a6, void *a7)
{
  id v13;
  id v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  void **v25;
  _QWORD v26[3];
  _QWORD *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v13 = a6;
  v14 = a7;
  v24 = 0;
  v23 = 0uLL;
  std::vector<Backend::Google::FullHashRequest>::__init_with_size[abi:sn180100]<Backend::Google::FullHashRequest*,Backend::Google::FullHashRequest*>((Backend::Google::FullHashRequest *)&v23, *a3, a3[1], 0x8E38E38E38E38E39 * ((a3[1] - *a3) >> 3));
  v15 = *(void **)(a1 + 16);
  v17 = *a4;
  v16 = a4[1];
  *a4 = 0;
  a4[1] = 0;
  v18 = *a5;
  v19 = a5[1];
  *a5 = 0;
  a5[1] = 0;
  v27 = 0;
  v20 = operator new(0x28uLL);
  *v20 = off_1EA3E9FD8;
  v20[1] = v17;
  v20[2] = v16;
  v20[3] = v18;
  v20[4] = v19;
  v27 = v20;
  Backend::Google::FullHashFetcher::fetchHashes(a2, &v23, v13, v14, v15, v26);
  v21 = v27;
  if (v27 == v26)
  {
    v22 = 4;
    v21 = v26;
    goto LABEL_5;
  }
  if (v27)
  {
    v22 = 5;
LABEL_5:
    (*(void (**)(void))(*v21 + 8 * v22))();
  }
  v25 = (void **)&v23;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v25);

}

void sub_1DBCE2A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void **a17, char a18, uint64_t a19, uint64_t a20,char *a21)
{
  void *v21;
  void *v22;
  uint64_t v23;
  char *v24;
  char *v26;
  uint64_t v27;

  v26 = a21;
  if (a21 == v24)
  {
    v27 = 4;
    v26 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_6;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_6:
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v23);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a10);
  a17 = (void **)&a14;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&a17);

  _Unwind_Resume(a1);
}

void Backend::Google::FullHashChecker::checkHashes(uint64_t a1, unint64_t *a2)
{
  id v4;
  void *v5;
  void *v6;
  char v7;
  int v8;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  void *v10;
  char v11;
  int v12;
  void *v13;
  char v14;
  unint64_t v15;
  NSObject *v16;
  void *v17;
  int64_t v18;
  char *v19;
  _QWORD *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t *p_shared_owners;
  _QWORD *v24;
  uint64_t v25;
  void *v26;
  char v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  BOOL v33;
  std::__shared_weak_count *v34;
  uint64_t *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t *v38;
  void *v39;
  char v40;
  void **v41;
  void ***v42;
  uint64_t *v43;
  void **v44;
  void **v45;
  std::__shared_weak_count *v46;
  uint64_t *v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t *v50;
  void *v51;
  char v52;
  void **v53;
  void ***v54;
  uint64_t *v55;
  void **v56;
  void **v57;
  Backend::Google::SSBUtilities *v58;
  _QWORD *v59;
  unint64_t *v60;
  unint64_t v61;
  unint64_t *v62;
  unint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  Backend::Google::SSBUtilities *v70;
  _QWORD *v71;
  unint64_t *v72;
  unint64_t v73;
  unint64_t *v74;
  unint64_t v75;
  std::__shared_weak_count *v76;
  unint64_t *v77;
  unint64_t v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  _QWORD *v82;
  unint64_t *v83;
  unint64_t v84;
  unint64_t *v85;
  unint64_t v86;
  std::__shared_weak_count *v87;
  unint64_t *v88;
  unint64_t v89;
  std::__shared_weak_count *v90;
  unint64_t *v91;
  unint64_t v92;
  std::__shared_weak_count *v93;
  unint64_t *v94;
  unint64_t v95;
  std::__shared_weak_count *v96;
  unint64_t *v97;
  unint64_t v98;
  std::__shared_weak_count *v99;
  unint64_t *v100;
  unint64_t v101;
  std::__shared_weak_count *v102;
  unint64_t *v103;
  unint64_t v104;
  void ***v105;
  uint64_t v106;
  uint64_t v107;
  void *v108;
  void *v109;
  void ***v110;
  std::__shared_weak_count *v111;
  void **v112;
  std::__shared_weak_count *v113;
  void ***v114;
  std::__shared_weak_count *v115;
  void **v116;
  std::__shared_weak_count *v117;
  _QWORD *v118;
  std::__shared_weak_count *v119;
  void **v120;
  std::__shared_weak_count *v121;
  void ***v122;
  std::__shared_weak_count *v123;
  void ***p_dst;
  std::__shared_weak_count *v125;
  _QWORD *v126;
  std::__shared_weak_count *v127;
  void *__p;
  _BYTE *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  std::__shared_weak_count_vtbl *v134;
  _QWORD *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  std::__shared_weak_count_vtbl *v140;
  _QWORD *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  std::__shared_weak_count_vtbl *v146;
  _QWORD *v147;
  uint64_t v148;
  void ***v149;
  void **__dst;
  std::__shared_weak_count *v151;
  void ***v152;
  void *v153[3];
  _QWORD block[4];
  _BYTE v155[24];
  _BYTE *v156;
  void *v157[5];

  v157[3] = *(void **)MEMORY[0x1E0C80C00];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  v147 = 0;
  v148 = 0;
  v145 = 0;
  v146 = (std::__shared_weak_count_vtbl *)&v147;
  v143 = 0;
  v144 = 0;
  v141 = 0;
  v142 = 0;
  v139 = 0;
  v140 = (std::__shared_weak_count_vtbl *)&v141;
  v137 = 0;
  v138 = 0;
  v135 = 0;
  v136 = 0;
  v133 = 0;
  v134 = (std::__shared_weak_count_vtbl *)&v135;
  v131 = 0;
  v132 = 0;
  __p = 0;
  v129 = 0;
  v130 = 0;
  v4 = *(id *)(*a2 + 32);
  +[RemoteConfigurationController sharedController](RemoteConfigurationController, "sharedController");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v109 = v5;
  if (*(_BYTE *)(*a2 + 48)
    && (objc_msgSend(v5, "googleProviderConfiguration"),
        v6 = (void *)objc_claimAutoreleasedReturnValue(),
        v7 = objc_msgSend(v6, "providerOff"),
        v6,
        (v7 & 1) == 0))
  {
    v5 = (void *)Backend::Google::FullHashChecker::checkFullHashRequests(a1, a2, (uint64_t *)(a1 + 104), 1, (uint64_t **)&v146, (uint64_t)&v143, &__p);
    if ((_DWORD)v5)
    {
      v8 = 1;
      Backend::Google::SSBUtilities::reportActivity((Backend::Google::SSBUtilities *)1);
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v8 = 1;
  }
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent((Backend::Google::SSBUtilities *)v5);
  if ((_DWORD)shouldConsultWithTencent)
  {
    objc_msgSend(v109, "tencentProviderConfiguration");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = objc_msgSend(v10, "providerOff");

    if ((v11 & 1) == 0)
    {
      shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::FullHashChecker::checkFullHashRequests(a1, a2, (uint64_t *)(a1 + 120), 2, (uint64_t **)&v140, (uint64_t)&v137, &__p);
      v12 = (int)shouldConsultWithTencent;
      if ((_DWORD)shouldConsultWithTencent)
        Backend::Google::SSBUtilities::reportActivity((Backend::Google::SSBUtilities *)4);
      v8 &= v12;
    }
  }
  if ((Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent) & 1) == 0)
    goto LABEL_17;
  objc_msgSend(v109, "appleProviderConfiguration");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = objc_msgSend(v13, "providerOff");

  if ((v14 & 1) == 0)
  {
    if (!Backend::Google::FullHashChecker::checkFullHashRequests(a1, a2, (uint64_t *)(a1 + 136), 3, (uint64_t **)&v134, (uint64_t)&v131, &__p))goto LABEL_24;
    Backend::Google::SSBUtilities::reportActivity((Backend::Google::SSBUtilities *)7);
LABEL_17:
    if ((v8 & 1) != 0)
      goto LABEL_18;
LABEL_24:
    if (v148 || v142 || v136)
    {
      v108 = v4;
      v22 = (std::__shared_weak_count *)operator new(0x48uLL);
      v22->__shared_owners_ = 0;
      v22->__shared_weak_owners_ = 0;
      v22[1].__shared_owners_ = 0;
      p_shared_owners = &v22[1].__shared_owners_;
      v22->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB9C8;
      v22[1].__vftable = (std::__shared_weak_count_vtbl *)&v22[1].__shared_owners_;
      v22[2].__shared_weak_owners_ = 0;
      v22[2].__shared_owners_ = 0;
      v22[1].__shared_weak_owners_ = 0;
      v22[2].__vftable = (std::__shared_weak_count_vtbl *)&v22[2].__shared_owners_;
      v126 = &v22[1].__vftable;
      v127 = v22;
      std::__tree<Backend::Google::HashView>::destroy((uint64_t)&v22[1], 0);
      v24 = v147;
      v22[1].__vftable = v146;
      v22[1].__shared_owners_ = (uint64_t)v24;
      v25 = v148;
      v22[1].__shared_weak_owners_ = v148;
      if (v25)
      {
        v24[2] = p_shared_owners;
        v146 = (std::__shared_weak_count_vtbl *)&v147;
        v147 = 0;
        v148 = 0;
      }
      else
      {
        v22[1].__vftable = (std::__shared_weak_count_vtbl *)p_shared_owners;
      }
      std::__tree<std::shared_ptr<Backend::Google::FullHashChecker::Check>>::__emplace_unique_key_args<std::shared_ptr<Backend::Google::FullHashChecker::Check>,std::shared_ptr<Backend::Google::FullHashChecker::Check> const&>((uint64_t **)v126 + 3, a2, (uint64_t *)a2);
      if (*(_BYTE *)(*a2 + 48))
      {
        objc_msgSend(v109, "googleProviderConfiguration");
        v26 = (void *)objc_claimAutoreleasedReturnValue();
        v27 = objc_msgSend(v26, "providerOff");

        if ((v27 & 1) == 0)
        {
          v29 = v126 + 1;
          v28 = (uint64_t *)*v126;
          if ((_QWORD *)*v126 != v126 + 1)
          {
            do
            {
              LOBYTE(v153[0]) = *((_BYTE *)v28 + 76);
              if (LOBYTE(v153[0]))
                memmove(&__dst, (char *)v28 + 44, LOBYTE(v153[0]));
              *(_OWORD *)((char *)v153 + 4) = *(_OWORD *)((char *)v28 + 28);
              p_dst = &__dst;
              v30 = std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::__emplace_unique_key_args<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::piecewise_construct_t const&,std::tuple<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>&&>,std::tuple<>>((uint64_t **)(a1 + 80), (uint64_t)&__dst, (uint64_t)&std::piecewise_construct, (uint64_t *)&p_dst);
              std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>::operator=[abi:sn180100](v30 + 11, (uint64_t *)&v126);
              v31 = (uint64_t *)v28[1];
              if (v31)
              {
                do
                {
                  v32 = v31;
                  v31 = (uint64_t *)*v31;
                }
                while (v31);
              }
              else
              {
                do
                {
                  v32 = (uint64_t *)v28[2];
                  v33 = *v32 == (_QWORD)v28;
                  v28 = v32;
                }
                while (!v33);
              }
              v28 = v32;
            }
            while (v32 != v29);
          }
        }
      }
      v34 = (std::__shared_weak_count *)operator new(0x48uLL);
      v34->__shared_owners_ = 0;
      v34->__shared_weak_owners_ = 0;
      v34[1].__shared_owners_ = 0;
      v35 = &v34[1].__shared_owners_;
      v34->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB9C8;
      v34[1].__vftable = (std::__shared_weak_count_vtbl *)&v34[1].__shared_owners_;
      v34[2].__shared_weak_owners_ = 0;
      v34[2].__shared_owners_ = 0;
      v34[1].__shared_weak_owners_ = 0;
      v34[2].__vftable = (std::__shared_weak_count_vtbl *)&v34[2].__shared_owners_;
      p_dst = (void ***)&v34[1];
      v125 = v34;
      std::__tree<Backend::Google::HashView>::destroy((uint64_t)&v34[1], 0);
      v36 = v141;
      v34[1].__vftable = v140;
      v34[1].__shared_owners_ = (uint64_t)v36;
      v37 = v142;
      v34[1].__shared_weak_owners_ = v142;
      if (v37)
      {
        v36[2] = v35;
        v140 = (std::__shared_weak_count_vtbl *)&v141;
        v141 = 0;
        v142 = 0;
      }
      else
      {
        v34[1].__vftable = (std::__shared_weak_count_vtbl *)v35;
      }
      v38 = std::__tree<std::shared_ptr<Backend::Google::FullHashChecker::Check>>::__emplace_unique_key_args<std::shared_ptr<Backend::Google::FullHashChecker::Check>,std::shared_ptr<Backend::Google::FullHashChecker::Check> const&>((uint64_t **)p_dst + 3, a2, (uint64_t *)a2);
      if (Backend::Google::SSBUtilities::shouldConsultWithTencent((Backend::Google::SSBUtilities *)v38))
      {
        objc_msgSend(v109, "tencentProviderConfiguration");
        v39 = (void *)objc_claimAutoreleasedReturnValue();
        v40 = objc_msgSend(v39, "providerOff");

        if ((v40 & 1) == 0)
        {
          v42 = p_dst + 1;
          v41 = *p_dst;
          if (*p_dst != (void **)(p_dst + 1))
          {
            do
            {
              LOBYTE(v153[0]) = *((_BYTE *)v41 + 76);
              if (LOBYTE(v153[0]))
                memmove(&__dst, (char *)v41 + 44, LOBYTE(v153[0]));
              *(_OWORD *)((char *)v153 + 4) = *(_OWORD *)((char *)v41 + 28);
              v122 = &__dst;
              v43 = std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::__emplace_unique_key_args<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::piecewise_construct_t const&,std::tuple<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>&&>,std::tuple<>>((uint64_t **)(a1 + 80), (uint64_t)&__dst, (uint64_t)&std::piecewise_construct, (uint64_t *)&v122);
              std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>::operator=[abi:sn180100](v43 + 11, (uint64_t *)&p_dst);
              v44 = (void **)v41[1];
              if (v44)
              {
                do
                {
                  v45 = v44;
                  v44 = (void **)*v44;
                }
                while (v44);
              }
              else
              {
                do
                {
                  v45 = (void **)v41[2];
                  v33 = *v45 == v41;
                  v41 = v45;
                }
                while (!v33);
              }
              v41 = v45;
            }
            while (v45 != (void **)v42);
          }
        }
      }
      v46 = (std::__shared_weak_count *)operator new(0x48uLL);
      v46->__shared_owners_ = 0;
      v46->__shared_weak_owners_ = 0;
      v46[1].__shared_owners_ = 0;
      v47 = &v46[1].__shared_owners_;
      v46->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB9C8;
      v46[1].__vftable = (std::__shared_weak_count_vtbl *)&v46[1].__shared_owners_;
      v46[2].__shared_weak_owners_ = 0;
      v46[2].__shared_owners_ = 0;
      v46[1].__shared_weak_owners_ = 0;
      v46[2].__vftable = (std::__shared_weak_count_vtbl *)&v46[2].__shared_owners_;
      v122 = (void ***)&v46[1];
      v123 = v46;
      std::__tree<Backend::Google::HashView>::destroy((uint64_t)&v46[1], 0);
      v48 = v135;
      v46[1].__vftable = v134;
      v46[1].__shared_owners_ = (uint64_t)v48;
      v49 = v136;
      v46[1].__shared_weak_owners_ = v136;
      if (v49)
      {
        v48[2] = v47;
        v134 = (std::__shared_weak_count_vtbl *)&v135;
        v135 = 0;
        v136 = 0;
      }
      else
      {
        v46[1].__vftable = (std::__shared_weak_count_vtbl *)v47;
      }
      v50 = std::__tree<std::shared_ptr<Backend::Google::FullHashChecker::Check>>::__emplace_unique_key_args<std::shared_ptr<Backend::Google::FullHashChecker::Check>,std::shared_ptr<Backend::Google::FullHashChecker::Check> const&>((uint64_t **)v122 + 3, a2, (uint64_t *)a2);
      if (Backend::Google::SSBUtilities::shouldConsultWithApple((Backend::Google::SSBUtilities *)v50))
      {
        objc_msgSend(v109, "appleProviderConfiguration");
        v51 = (void *)objc_claimAutoreleasedReturnValue();
        v52 = objc_msgSend(v51, "providerOff");

        if ((v52 & 1) == 0)
        {
          v54 = v122 + 1;
          v53 = *v122;
          if (*v122 != (void **)(v122 + 1))
          {
            do
            {
              LOBYTE(v153[0]) = *((_BYTE *)v53 + 76);
              if (LOBYTE(v153[0]))
                memmove(&__dst, (char *)v53 + 44, LOBYTE(v153[0]));
              *(_OWORD *)((char *)v153 + 4) = *(_OWORD *)((char *)v53 + 28);
              v149 = &__dst;
              v55 = std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::__emplace_unique_key_args<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::piecewise_construct_t const&,std::tuple<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>&&>,std::tuple<>>((uint64_t **)(a1 + 80), (uint64_t)&__dst, (uint64_t)&std::piecewise_construct, (uint64_t *)&v149);
              std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>::operator=[abi:sn180100](v55 + 11, (uint64_t *)&v122);
              v56 = (void **)v53[1];
              if (v56)
              {
                do
                {
                  v57 = v56;
                  v56 = (void **)*v56;
                }
                while (v56);
              }
              else
              {
                do
                {
                  v57 = (void **)v53[2];
                  v33 = *v57 == v53;
                  v53 = v57;
                }
                while (!v33);
              }
              v53 = v57;
            }
            while (v57 != (void **)v54);
          }
        }
      }
      std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&__dst, (_QWORD *)a1);
      v4 = v108;
      if (v143 != v144)
      {
        v59 = *(_QWORD **)(a1 + 32);
        v120 = __dst;
        v121 = v151;
        if (v151)
        {
          v60 = (unint64_t *)&v151->__shared_owners_;
          do
            v61 = __ldxr(v60);
          while (__stxr(v61 + 1, v60));
        }
        v118 = v126;
        v119 = v127;
        if (v127)
        {
          v62 = (unint64_t *)&v127->__shared_owners_;
          do
            v63 = __ldxr(v62);
          while (__stxr(v63 + 1, v62));
        }
        Backend::Google::FullHashChecker::fetchHashes(a1, v59, &v143, (uint64_t *)&v120, (uint64_t *)&v118, v108, *(void **)(*a2 + 40));
        v64 = v119;
        if (v119)
        {
          v65 = (unint64_t *)&v119->__shared_owners_;
          do
            v66 = __ldaxr(v65);
          while (__stlxr(v66 - 1, v65));
          if (!v66)
          {
            ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
            std::__shared_weak_count::__release_weak(v64);
          }
        }
        v67 = v121;
        if (v121)
        {
          v68 = (unint64_t *)&v121->__shared_owners_;
          do
            v69 = __ldaxr(v68);
          while (__stlxr(v69 - 1, v68));
          if (!v69)
          {
            ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
            std::__shared_weak_count::__release_weak(v67);
          }
        }
      }
      v70 = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(v58);
      if ((_DWORD)v70 && v137 != v138)
      {
        v71 = *(_QWORD **)(a1 + 48);
        v116 = __dst;
        v117 = v151;
        if (v151)
        {
          v72 = (unint64_t *)&v151->__shared_owners_;
          do
            v73 = __ldxr(v72);
          while (__stxr(v73 + 1, v72));
        }
        v114 = p_dst;
        v115 = v125;
        if (v125)
        {
          v74 = (unint64_t *)&v125->__shared_owners_;
          do
            v75 = __ldxr(v74);
          while (__stxr(v75 + 1, v74));
        }
        Backend::Google::FullHashChecker::fetchHashes(a1, v71, &v137, (uint64_t *)&v116, (uint64_t *)&v114, v108, 0);
        v76 = v115;
        if (v115)
        {
          v77 = (unint64_t *)&v115->__shared_owners_;
          do
            v78 = __ldaxr(v77);
          while (__stlxr(v78 - 1, v77));
          if (!v78)
          {
            ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
            std::__shared_weak_count::__release_weak(v76);
          }
        }
        v79 = v117;
        if (v117)
        {
          v80 = (unint64_t *)&v117->__shared_owners_;
          do
            v81 = __ldaxr(v80);
          while (__stlxr(v81 - 1, v80));
          if (!v81)
          {
            ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
            std::__shared_weak_count::__release_weak(v79);
          }
        }
      }
      if (Backend::Google::SSBUtilities::shouldConsultWithApple(v70) && v131 != v132)
      {
        v82 = *(_QWORD **)(a1 + 64);
        v112 = __dst;
        v113 = v151;
        if (v151)
        {
          v83 = (unint64_t *)&v151->__shared_owners_;
          do
            v84 = __ldxr(v83);
          while (__stxr(v84 + 1, v83));
        }
        v110 = v122;
        v111 = v123;
        if (v123)
        {
          v85 = (unint64_t *)&v123->__shared_owners_;
          do
            v86 = __ldxr(v85);
          while (__stxr(v86 + 1, v85));
        }
        Backend::Google::FullHashChecker::fetchHashes(a1, v82, &v131, (uint64_t *)&v112, (uint64_t *)&v110, v108, 0);
        v87 = v111;
        if (v111)
        {
          v88 = (unint64_t *)&v111->__shared_owners_;
          do
            v89 = __ldaxr(v88);
          while (__stlxr(v89 - 1, v88));
          if (!v89)
          {
            ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
            std::__shared_weak_count::__release_weak(v87);
          }
        }
        v90 = v113;
        if (v113)
        {
          v91 = (unint64_t *)&v113->__shared_owners_;
          do
            v92 = __ldaxr(v91);
          while (__stlxr(v92 - 1, v91));
          if (!v92)
          {
            ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
            std::__shared_weak_count::__release_weak(v90);
          }
        }
      }
      v93 = v151;
      if (v151)
      {
        v94 = (unint64_t *)&v151->__shared_owners_;
        do
          v95 = __ldaxr(v94);
        while (__stlxr(v95 - 1, v94));
        if (!v95)
        {
          ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
          std::__shared_weak_count::__release_weak(v93);
        }
      }
      v96 = v123;
      if (v123)
      {
        v97 = (unint64_t *)&v123->__shared_owners_;
        do
          v98 = __ldaxr(v97);
        while (__stlxr(v98 - 1, v97));
        if (!v98)
        {
          ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
          std::__shared_weak_count::__release_weak(v96);
        }
      }
      v99 = v125;
      if (v125)
      {
        v100 = (unint64_t *)&v125->__shared_owners_;
        do
          v101 = __ldaxr(v100);
        while (__stlxr(v101 - 1, v100));
        if (!v101)
        {
          ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
          std::__shared_weak_count::__release_weak(v99);
        }
      }
      v102 = v127;
      if (v127)
      {
        v103 = (unint64_t *)&v127->__shared_owners_;
        do
          v104 = __ldaxr(v103);
        while (__stlxr(v104 - 1, v103));
        if (!v104)
        {
          ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
          std::__shared_weak_count::__release_weak(v102);
        }
      }
    }
    goto LABEL_158;
  }
  if (!v8)
    goto LABEL_24;
LABEL_18:
  v15 = *a2;
  v16 = *(NSObject **)(*a2 + 56);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN7Backend6Google15FullHashChecker11checkHashesENSt3__110shared_ptrINS1_5CheckEEE_block_invoke;
  block[3] = &__block_descriptor_88_ea8_32c91_ZTSKZN7Backend6Google15FullHashChecker11checkHashesENSt3__110shared_ptrINS1_5CheckEEEE3__0_e5_v8__0l;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)&__dst, v15 + 64);
  memset(v153, 0, sizeof(v153));
  v17 = __p;
  v18 = v129 - (_BYTE *)__p;
  if (v129 != __p)
  {
    std::vector<Backend::Google::Database::HashSizeBucket>::__vallocate[abi:sn180100](v153, v18 >> 4);
    v19 = (char *)v153[1];
    memmove(v153[1], v17, v18);
    v153[1] = &v19[16 * (v18 >> 4)];
  }
  v20 = v155;
  v21 = (uint64_t)v152;
  if (!v152)
    goto LABEL_23;
  if (v152 != &__dst)
  {
    v21 = ((uint64_t (*)(void))(*v152)[2])();
LABEL_23:
    v156 = (_BYTE *)v21;
    goto LABEL_144;
  }
  v156 = v155;
  ((void (*)(void ***, _BYTE *))__dst[3])(&__dst, v155);
LABEL_144:
  std::vector<Backend::Google::Database::HashSizeBucket>::vector(v157, (uint64_t)v153);
  dispatch_async(v16, block);
  if (v153[0])
  {
    v153[1] = v153[0];
    operator delete(v153[0]);
  }
  v105 = v152;
  if (v152 == &__dst)
  {
    v106 = 4;
    v105 = &__dst;
    goto LABEL_150;
  }
  if (v152)
  {
    v106 = 5;
LABEL_150:
    ((void (*)(void))(*v105)[v106])();
  }
  if (v157[0])
  {
    v157[1] = v157[0];
    operator delete(v157[0]);
  }
  if (v156 == v155)
  {
    v107 = 4;
  }
  else
  {
    if (!v156)
      goto LABEL_158;
    v107 = 5;
    v20 = v156;
  }
  (*(void (**)(_QWORD *))(*v20 + 8 * v107))(v20);
LABEL_158:

  if (__p)
  {
    v129 = __p;
    operator delete(__p);
  }
  __dst = (void **)&v131;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&__dst);
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)&v134, v135);
  __dst = (void **)&v137;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&__dst);
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)&v140, v141);
  __dst = (void **)&v143;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&__dst);
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)&v146, v147);
}

void sub_1DBCE3680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,char a28,uint64_t a29,void *__p,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,char a36,_QWORD *a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,char a42,_QWORD *a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,char a48,_QWORD *a49)
{
  uint64_t v49;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a12);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a14);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v49 - 240);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a24);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a26);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a28);

  if (__p)
  {
    a31 = (uint64_t)__p;
    operator delete(__p);
  }
  *(_QWORD *)(v49 - 240) = &a33;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)(v49 - 240));
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)&a36, a37);
  *(_QWORD *)(v49 - 240) = &a39;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)(v49 - 240));
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)&a42, a43);
  *(_QWORD *)(v49 - 240) = &a45;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)(v49 - 240));
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)&a48, a49);
  _Unwind_Resume(a1);
}

void ___ZN7Backend6Google15FullHashChecker11checkHashesENSt3__110shared_ptrINS1_5CheckEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *__p[3];

  std::vector<Backend::Google::Database::HashSizeBucket>::vector(__p, a1 + 64);
  v2 = *(_QWORD *)(a1 + 56);
  if (v2)
  {
    (*(void (**)(uint64_t, void **))(*(_QWORD *)v2 + 48))(v2, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:sn180100]();
    __break(1u);
  }
}

void sub_1DBCE38F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *__copy_helper_block_ea8_32c91_ZTSKZN7Backend6Google15FullHashChecker11checkHashesENSt3__110shared_ptrINS1_5CheckEEEE3__0(uint64_t a1, uint64_t a2)
{
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 32, a2 + 32);
  return std::vector<Backend::Google::Database::HashSizeBucket>::vector((_QWORD *)(a1 + 64), a2 + 64);
}

void sub_1DBCE3958(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;

  v3 = v2;
  v5 = *(_QWORD **)(v3 + 56);
  if (v5 == v1)
  {
    v6 = 4;
  }
  else
  {
    if (!v5)
      goto LABEL_6;
    v6 = 5;
    v1 = v5;
  }
  (*(void (**)(_QWORD *))(*v1 + 8 * v6))(v1);
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *__destroy_helper_block_ea8_32c91_ZTSKZN7Backend6Google15FullHashChecker11checkHashesENSt3__110shared_ptrINS1_5CheckEEEE3__0(_QWORD *a1)
{
  _QWORD *v2;
  void *v3;
  _QWORD *result;
  uint64_t v5;

  v2 = a1 + 4;
  v3 = (void *)a1[8];
  if (v3)
  {
    a1[9] = v3;
    operator delete(v3);
  }
  result = (_QWORD *)a1[7];
  if (result == v2)
  {
    v5 = 4;
    result = v2;
  }
  else
  {
    if (!result)
      return result;
    v5 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

_QWORD *Backend::Google::FullHashChecker::checkHashes(std::shared_ptr<Backend::Google::FullHashChecker::Check>)::$_0::~$_0(_QWORD *a1)
{
  void *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  v3 = (_QWORD *)a1[3];
  if (v3 == a1)
  {
    v4 = 4;
    v3 = a1;
    goto LABEL_7;
  }
  if (v3)
  {
    v4 = 5;
LABEL_7:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>::operator=[abi:sn180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void Backend::Google::FullHashChecker::handleFetchResult(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  BOOL v16;
  _QWORD *v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  std::chrono::system_clock::time_point v29;
  int v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  _BYTE __dst[32];
  unsigned __int8 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v29.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  v26 = a2;
  v8 = (_QWORD *)*a2;
  v7 = a2 + 1;
  v6 = v8;
  if (v8 != v7)
  {
    v9 = v29.__d_.__rep_ + 1000000 * a3[5];
    v27 = v9;
    if (!*((_BYTE *)a3 + 48))
      v9 = 0;
    v28 = v9;
    v30 = *((unsigned __int8 *)a3 + 48);
    do
    {
      v34 = *((_BYTE *)v6 + 76);
      if (v34)
        memmove(__dst, (char *)v6 + 44, v34);
      v35 = *(_OWORD *)((char *)v6 + 28);
      std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::__erase_unique<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>((uint64_t **)(a1 + 80), (uint64_t)__dst);
      v10 = *((unsigned __int8 *)v6 + 76);
      v11 = *a3;
      v12 = a3[1];
      if (*a3 != v12)
      {
        while (Backend::Google::operator!=((_DWORD *)v11, (_DWORD *)v6 + 7)
             || (_DWORD)v10 != *((unsigned __int8 *)v6 + 76)
             || memcmp((const void *)(v11 + 16), (char *)v6 + 44, v10))
        {
          v11 += 80;
          if (v11 == v12)
          {
            v11 = v12;
            break;
          }
        }
      }
      v13 = *((_DWORD *)v6 + 10);
      if (v13 == 1)
      {
        if (v11 == a3[1])
        {
          if (!v30)
            goto LABEL_49;
          Backend::Google::FullHashCache::addSafePrefix(*(_QWORD *)(a1 + 104), (__int128 *)((char *)v6 + 28), (_BYTE *)v6 + 44, v27);
        }
        else
        {
          Backend::Google::FullHashCache::addUnsafeFullHash(*(_QWORD *)(a1 + 104), (_OWORD *)v11, (_OWORD *)(v11 + 16), v10, v29.__d_.__rep_ + 1000000 * *(_QWORD *)(v11 + 72), v28, v30);
        }
      }
      else if (v13 == 2)
      {
        if (v11 == a3[1])
        {
          if (!v30)
            goto LABEL_49;
          Backend::Google::FullHashCache::addSafePrefix(*(_QWORD *)(a1 + 120), (__int128 *)((char *)v6 + 28), (_BYTE *)v6 + 44, v27);
        }
        else
        {
          Backend::Google::FullHashCache::addUnsafeFullHash(*(_QWORD *)(a1 + 120), (_OWORD *)v11, (_OWORD *)(v11 + 16), v10, v29.__d_.__rep_ + 1000000 * *(_QWORD *)(v11 + 72), v28, v30);
        }
      }
      else if (v11 == a3[1])
      {
        if (!v30)
LABEL_49:
          __break(1u);
        Backend::Google::FullHashCache::addSafePrefix(*(_QWORD *)(a1 + 136), (__int128 *)((char *)v6 + 28), (_BYTE *)v6 + 44, v27);
      }
      else
      {
        Backend::Google::FullHashCache::addUnsafeFullHash(*(_QWORD *)(a1 + 136), (_OWORD *)v11, (_OWORD *)(v11 + 16), v10, v29.__d_.__rep_ + 1000000 * *(_QWORD *)(v11 + 72), v28, v30);
      }
      v14 = (_QWORD *)v6[1];
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v15 = (_QWORD *)v6[2];
          v16 = *v15 == (_QWORD)v6;
          v6 = v15;
        }
        while (!v16);
      }
      v6 = v15;
    }
    while (v15 != v7);
  }
  v17 = (_QWORD *)v26[3];
  if (v17 != v26 + 4)
  {
    do
    {
      v18 = (std::__shared_weak_count *)v17[5];
      v31 = v17[4];
      v32 = v18;
      if (v18)
      {
        p_shared_owners = (unint64_t *)&v18->__shared_owners_;
        do
          v20 = __ldxr(p_shared_owners);
        while (__stxr(v20 + 1, p_shared_owners));
      }
      Backend::Google::FullHashChecker::checkHashes(a1, &v31);
      v21 = v32;
      if (v32)
      {
        v22 = (unint64_t *)&v32->__shared_owners_;
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      v24 = (_QWORD *)v17[1];
      if (v24)
      {
        do
        {
          v25 = v24;
          v24 = (_QWORD *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          v25 = (_QWORD *)v17[2];
          v16 = *v25 == (_QWORD)v17;
          v17 = v25;
        }
        while (!v16);
      }
      v17 = v25;
    }
    while (v25 != v26 + 4);
  }
}

void sub_1DBCE3E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void Backend::Google::FullHashChecker::handleFetchFailure(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _BYTE *v12;
  _BYTE *v13;
  _OWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  __int128 v27;
  uint64_t v28;
  __int128 *v29;
  _BYTE __src[32];
  _BYTE __n[17];
  uint64_t v32;
  unsigned __int8 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v33 = *((_BYTE *)v5 + 76);
      if (v33)
        memmove(&__n[1], (char *)v5 + 44, v33);
      v34 = *(_OWORD *)((char *)v5 + 28);
      std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::__erase_unique<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>((uint64_t **)(a1 + 80), (uint64_t)&__n[1]);
      v6 = (_QWORD *)v5[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v5[2];
          v8 = *v7 == (_QWORD)v5;
          v5 = v7;
        }
        while (!v8);
      }
      v5 = v7;
    }
    while (v7 != v4);
  }
  v9 = (_QWORD *)a2[3];
  v10 = a2 + 4;
  if (v9 != a2 + 4)
  {
    do
    {
      v27 = 0uLL;
      v28 = 0;
      v11 = v9[4];
      v12 = *(_BYTE **)v11;
      v13 = *(_BYTE **)(v11 + 8);
      v29 = &v27;
      if (v12 != v13)
      {
        do
        {
          v14 = v12 + 36;
          __n[0] = v12[32];
          if (__n[0])
          {
            memcpy(__src, v12, __n[0]);
            *(_OWORD *)&__n[1] = *v14;
            BYTE12(v34) = __n[0];
            if (__n[0])
              memcpy(&v32, __src, __n[0]);
          }
          else
          {
            *(_OWORD *)&__n[1] = *v14;
            BYTE12(v34) = 0;
          }
          if (!std::__tree<Backend::Google::FullHashChecker::FetchRequest::Entry>::__count_unique<Backend::Google::FullHashChecker::FetchRequest::Entry>((uint64_t)a2, &__n[1]))std::back_insert_iterator<std::vector<Backend::Google::FullHashRequest>>::operator=[abi:sn180100]((uint64_t *)&v29, (const Backend::Google::FullHashRequest *)v12);
          v12 += 72;
        }
        while (v12 != v13);
        v11 = v9[4];
      }
      std::vector<Backend::Google::FullHashRequest>::__vdeallocate((void **)v11);
      *(_OWORD *)v11 = v27;
      *(_QWORD *)(v11 + 16) = v28;
      v27 = 0uLL;
      v28 = 0;
      *(_QWORD *)&__n[1] = &v27;
      std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)&__n[1]);
      v15 = (_QWORD *)v9[1];
      if (v15)
      {
        do
        {
          v16 = v15;
          v15 = (_QWORD *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          v16 = (_QWORD *)v9[2];
          v8 = *v16 == (_QWORD)v9;
          v9 = v16;
        }
        while (!v8);
      }
      v9 = v16;
    }
    while (v16 != v10);
    v9 = (_QWORD *)a2[3];
  }
  if (v9 != v10)
  {
    do
    {
      v17 = (std::__shared_weak_count *)v9[5];
      v25 = v9[4];
      v26 = v17;
      if (v17)
      {
        p_shared_owners = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldxr(p_shared_owners);
        while (__stxr(v19 + 1, p_shared_owners));
      }
      Backend::Google::FullHashChecker::checkHashes(a1, &v25);
      v20 = v26;
      if (v26)
      {
        v21 = (unint64_t *)&v26->__shared_owners_;
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      v23 = (_QWORD *)v9[1];
      if (v23)
      {
        do
        {
          v24 = v23;
          v23 = (_QWORD *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          v24 = (_QWORD *)v9[2];
          v8 = *v24 == (_QWORD)v9;
          v9 = v24;
        }
        while (!v8);
      }
      v9 = v24;
    }
    while (v24 != v10);
  }
}

void sub_1DBCE40FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::vector<Backend::Google::FullHashRequest>::__vdeallocate(void **a1)
{
  char *v1;
  char *v3;
  void *v4;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
        Backend::Google::FullHashRequest::~FullHashRequest((Backend::Google::FullHashRequest *)(v3 - 72));
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::vector<Backend::Google::FullHashRequest>::__push_back_slow_path<Backend::Google::FullHashRequest const&>(uint64_t a1, const Backend::Google::FullHashRequest *a2)
{
  const Backend::Google::FullHashRequest *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v2 = *(const Backend::Google::FullHashRequest **)a1;
  v3 = 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  v4 = v3 + 1;
  if (v3 + 1 > 0x38E38E38E38E38ELL)
LABEL_13:
    abort();
  v8 = *(_QWORD *)(a1 + 16);
  v7 = a1 + 16;
  v9 = 0x8E38E38E38E38E39 * ((v8 - (uint64_t)v2) >> 3);
  if (2 * v9 > v4)
    v4 = 2 * v9;
  if (v9 >= 0x1C71C71C71C71C7)
    v10 = 0x38E38E38E38E38ELL;
  else
    v10 = v4;
  v18 = v7;
  if (v10)
    v11 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FullHashRequest>>(v7, v10);
  else
    v11 = 0;
  v14 = v11;
  v15 = &v11[72 * v3];
  v16 = v15;
  v17 = &v11[72 * v10];
  if (!v11)
  {
    __break(1u);
    goto LABEL_13;
  }
  Backend::Google::FullHashRequest::FullHashRequest((Backend::Google::FullHashRequest *)&v11[72 * v3], a2);
  v16 += 72;
  std::vector<Backend::Google::FullHashRequest>::__swap_out_circular_buffer((const Backend::Google::FullHashRequest **)a1, &v14);
  v12 = *(_QWORD *)(a1 + 8);
  std::__split_buffer<Backend::Google::FullHashRequest>::~__split_buffer((uint64_t)&v14);
  return v12;
}

void sub_1DBCE4294(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<Backend::Google::FullHashRequest>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

Backend::Google::FullHashRequest *std::vector<Backend::Google::FullHashRequest>::__init_with_size[abi:sn180100]<Backend::Google::FullHashRequest*,Backend::Google::FullHashRequest*>(Backend::Google::FullHashRequest *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  Backend::Google::FullHashRequest *v6;

  if (a4)
  {
    v6 = result;
    std::vector<Backend::Google::FullHashRequest>::__vallocate[abi:sn180100](result, a4);
    return std::vector<Backend::Google::FullHashRequest>::__construct_at_end<Backend::Google::FullHashRequest*,Backend::Google::FullHashRequest*>(v6, a2, a3);
  }
  return result;
}

char *std::vector<Backend::Google::FullHashRequest>::__vallocate[abi:sn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x38E38E38E38E38FLL)
    abort();
  result = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FullHashRequest>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[72 * v4];
  return result;
}

Backend::Google::FullHashRequest *std::vector<Backend::Google::FullHashRequest>::__construct_at_end<Backend::Google::FullHashRequest*,Backend::Google::FullHashRequest*>(Backend::Google::FullHashRequest *result, uint64_t a2, uint64_t a3)
{
  Backend::Google::FullHashRequest *v3;
  uint64_t v4;
  uint64_t v7;

  v3 = result;
  v4 = *((_QWORD *)result + 1);
  if (a2 == a3)
  {
LABEL_6:
    *((_QWORD *)v3 + 1) = v4;
  }
  else
  {
    v7 = 0;
    while (1)
    {
      result = (Backend::Google::FullHashRequest *)(v4 + v7);
      if (!(v4 + v7))
        break;
      result = (Backend::Google::FullHashRequest *)Backend::Google::FullHashRequest::FullHashRequest(result, (const Backend::Google::FullHashRequest *)(a2 + v7));
      v7 += 72;
      if (a2 + v7 == a3)
      {
        v4 += v7;
        goto LABEL_6;
      }
    }
    __break(1u);
  }
  return result;
}

void sub_1DBCE43B8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t *std::back_insert_iterator<std::vector<Backend::Google::FullHashRequest>>::operator=[abi:sn180100](uint64_t *result, const Backend::Google::FullHashRequest *a2)
{
  uint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v2 = result;
  v3 = *result;
  v4 = *(_QWORD *)(*result + 8);
  if (v4 >= *(_QWORD *)(*result + 16))
  {
    v5 = std::vector<Backend::Google::FullHashRequest>::__push_back_slow_path<Backend::Google::FullHashRequest const&>(*result, a2);
    goto LABEL_5;
  }
  if (v4)
  {
    Backend::Google::FullHashRequest::FullHashRequest(*(Backend::Google::FullHashRequest **)(*result + 8), a2);
    v5 = v4 + 72;
    *(_QWORD *)(v3 + 8) = v4 + 72;
LABEL_5:
    *(_QWORD *)(v3 + 8) = v5;
    return v2;
  }
  __break(1u);
  return result;
}

{
  uint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v2 = result;
  v3 = *result;
  v4 = *(_QWORD *)(*result + 8);
  if (v4 >= *(_QWORD *)(*result + 16))
  {
    v5 = std::vector<Backend::Google::FullHashRequest>::__push_back_slow_path<Backend::Google::FullHashRequest>(*result, a2);
    goto LABEL_5;
  }
  if (v4)
  {
    Backend::Google::FullHashRequest::FullHashRequest(*(Backend::Google::FullHashRequest **)(*result + 8), a2);
    v5 = v4 + 72;
    *(_QWORD *)(v3 + 8) = v4 + 72;
LABEL_5:
    *(_QWORD *)(v3 + 8) = v5;
    return v2;
  }
  __break(1u);
  return result;
}

void sub_1DBCE4420(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::__tree<Backend::Google::FullHashChecker::FetchRequest::Entry>::__count_unique<Backend::Google::FullHashChecker::FetchRequest::Entry>(uint64_t a1, char *a2)
{
  _QWORD *v2;
  char *v4;
  uint64_t v5;
  char *v7;
  char *v8;
  char *v9;
  char *v10;

  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    v4 = a2 + 16;
    v5 = 1;
    do
    {
      v9 = a2;
      v10 = v4;
      v7 = (char *)v2 + 28;
      v8 = (char *)v2 + 44;
      if ((std::__tuple_compare_three_way[abi:sn180100]<Backend::Google::ThreatListDescriptor const&,Backend::Google::Hash const&,Backend::Google::ThreatListDescriptor const&,Backend::Google::Hash const&,0ul,1ul>((uint64_t)&v9, (uint64_t)&v7) & 0x80) == 0)
      {
        v9 = (char *)v2 + 28;
        v10 = (char *)v2 + 44;
        v7 = a2;
        v8 = v4;
        if ((std::__tuple_compare_three_way[abi:sn180100]<Backend::Google::ThreatListDescriptor const&,Backend::Google::Hash const&,Backend::Google::ThreatListDescriptor const&,Backend::Google::Hash const&,0ul,1ul>((uint64_t)&v9, (uint64_t)&v7) & 0x80) == 0)return v5;
        ++v2;
      }
      v2 = (_QWORD *)*v2;
    }
    while (v2);
  }
  return 0;
}

uint64_t std::__tuple_compare_three_way[abi:sn180100]<Backend::Google::ThreatListDescriptor const&,Backend::Google::Hash const&,Backend::Google::ThreatListDescriptor const&,Backend::Google::Hash const&,0ul,1ul>(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = std::__synth_three_way[abi:sn180100]<Backend::Google::ThreatListDescriptor,Backend::Google::ThreatListDescriptor>(*(int **)a1, *(int **)a2);
  if (!(_BYTE)result)
    return std::__synth_three_way[abi:sn180100]<Backend::Google::Hash,Backend::Google::Hash>(*(unsigned __int8 **)(a1 + 8), *(unsigned __int8 **)(a2 + 8));
  return result;
}

void std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::destroy(a1, a2[1]);
    std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a2 + 11));
    operator delete(a2);
  }
}

void std::allocate_shared[abi:sn180100]<Backend::Google::FullHashFetcher,std::allocator<Backend::Google::FullHashFetcher>,Backend::Google::Configuration const&,Backend::Google::SafeBrowsingProvider,void>(uint64_t a1@<X1>, unsigned int *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;

  v6 = operator new(0xD0uLL);
  std::__shared_ptr_emplace<Backend::Google::FullHashFetcher>::__shared_ptr_emplace[abi:sn180100]<Backend::Google::Configuration const&,Backend::Google::SafeBrowsingProvider,std::allocator<Backend::Google::FullHashFetcher>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<ByteProvider>::__enable_weak_this[abi:sn180100]<ByteProvider,ByteProvider,void>((uint64_t)a3, v6 + 3, (uint64_t)(v6 + 3));
}

void sub_1DBCE459C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<Backend::Google::FullHashFetcher>::__shared_ptr_emplace[abi:sn180100]<Backend::Google::Configuration const&,Backend::Google::SafeBrowsingProvider,std::allocator<Backend::Google::FullHashFetcher>,0>(_QWORD *a1, uint64_t a2, unsigned int *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1EA3EBA70;
  Backend::Google::FullHashFetcher::FullHashFetcher(a1 + 3, a2, *a3);
  return a1;
}

void sub_1DBCE45E8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashFetcher>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBA70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashFetcher>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBA70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashFetcher>::__on_zero_shared(uint64_t a1)
{
  Backend::Google::FullHashFetcher::~FullHashFetcher((Backend::Google::FullHashFetcher *)(a1 + 24));
}

void std::allocate_shared[abi:sn180100]<Backend::Google::FullHashCache,std::allocator<Backend::Google::FullHashCache>,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::SafeBrowsingProvider,void>(void **a1@<X1>, int *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;

  v6 = operator new(0x60uLL);
  std::__shared_ptr_emplace<Backend::Google::FullHashCache>::__shared_ptr_emplace[abi:sn180100]<NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::SafeBrowsingProvider,std::allocator<Backend::Google::FullHashCache>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<ByteProvider>::__enable_weak_this[abi:sn180100]<ByteProvider,ByteProvider,void>((uint64_t)a3, v6 + 3, (uint64_t)(v6 + 3));
}

void sub_1DBCE468C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<Backend::Google::FullHashCache>::__shared_ptr_emplace[abi:sn180100]<NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::SafeBrowsingProvider,std::allocator<Backend::Google::FullHashCache>,0>(_QWORD *a1, void **a2, int *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1EA3EB958;
  Backend::Google::FullHashCache::FullHashCache((uint64_t)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1DBCE46DC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashCache>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB958;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashCache>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB958;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashCache>::__on_zero_shared(uint64_t a1)
{
  Backend::Google::FullHashCache::~FullHashCache((Backend::Google::FullHashCache *)(a1 + 24));
}

void std::__shared_ptr_emplace<Backend::Google::FullHashChecker::Check>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBA00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashChecker::Check>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBA00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashChecker::Check>::__on_zero_shared(uint64_t a1)
{
  std::__destroy_at[abi:sn180100]<Backend::Google::FullHashChecker::Check,0>(a1 + 24);
}

void std::__destroy_at[abi:sn180100]<Backend::Google::FullHashChecker::Check,0>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;

  if (a1)
  {
    v2 = (_QWORD *)(a1 + 64);
    v3 = *(_QWORD **)(a1 + 88);
    if (v3 == v2)
    {
      v4 = 4;
      v3 = v2;
    }
    else
    {
      if (!v3)
      {
LABEL_7:

        std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)(a1 + 24), 0);
        v5 = (void **)a1;
        std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v5);
        return;
      }
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
    goto LABEL_7;
  }
  __break(1u);
}

_QWORD *std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::find<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  char v6;
  _QWORD *v7;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = (_QWORD *)(a1 + 8);
  do
  {
    v6 = std::operator<=>[abi:sn180100]<Backend::Google::Hash,Backend::Google::ThreatListDescriptor,Backend::Google::Hash,Backend::Google::ThreatListDescriptor>((uint64_t)(v3 + 4), a2);
    if (v6 >= 0)
      v7 = v3;
    else
      v7 = v3 + 1;
    if (v6 >= 0)
      v5 = v3;
    v3 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v5 == v2
    || (std::operator<=>[abi:sn180100]<Backend::Google::Hash,Backend::Google::ThreatListDescriptor,Backend::Google::Hash,Backend::Google::ThreatListDescriptor>(a2, (uint64_t)(v5 + 4)) & 0x80) != 0)
  {
    return v2;
  }
  return v5;
}

uint64_t std::operator<=>[abi:sn180100]<Backend::Google::Hash,Backend::Google::ThreatListDescriptor,Backend::Google::Hash,Backend::Google::ThreatListDescriptor>(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = std::__synth_three_way[abi:sn180100]<Backend::Google::Hash,Backend::Google::Hash>((unsigned __int8 *)a1, (unsigned __int8 *)a2);
  if (!(_BYTE)result)
    return std::__synth_three_way[abi:sn180100]<Backend::Google::ThreatListDescriptor,Backend::Google::ThreatListDescriptor>((int *)(a1 + 36), (int *)(a2 + 36));
  return result;
}

uint64_t *std::__tree<std::shared_ptr<Backend::Google::FullHashChecker::Check>>::__emplace_unique_key_args<std::shared_ptr<Backend::Google::FullHashChecker::Check>,std::shared_ptr<Backend::Google::FullHashChecker::Check> const&>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v16[2];
  char v17;

  v6 = a1 + 1;
  v5 = a1[1];
  v7 = a1 + 1;
  v8 = a1 + 1;
  if (v5)
  {
    v9 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v10 = v5[4];
        if (v9 >= v10)
          break;
        v5 = *v8;
        v7 = v8;
        if (!*v8)
          goto LABEL_9;
      }
      if (v10 >= v9)
        return (uint64_t *)v8;
      v5 = v8[1];
      if (!v5)
      {
        v7 = v8 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    v11 = (uint64_t *)operator new(0x30uLL);
    v16[1] = v6;
    v12 = a3[1];
    v11[4] = *a3;
    v11[5] = v12;
    if (v12)
    {
      v13 = (unint64_t *)(v12 + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v17 = 1;
    std::__tree<Backend::Google::HashView>::__insert_node_at(a1, (uint64_t)v8, v7, v11);
    v16[0] = 0;
    std::unique_ptr<std::__tree_node<std::shared_ptr<Backend::Google::FullHashChecker::Check>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<Backend::Google::FullHashChecker::Check>,void *>>>>::reset[abi:sn180100]((uint64_t)v16, 0);
  }
  return v11;
}

void std::unique_ptr<std::__tree_node<std::shared_ptr<Backend::Google::FullHashChecker::Check>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<Backend::Google::FullHashChecker::Check>,void *>>>>::reset[abi:sn180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

uint64_t *std::__tree<Backend::Google::FullHashChecker::FetchRequest::Entry>::__emplace_unique_key_args<Backend::Google::FullHashChecker::FetchRequest::Entry,Backend::Google::FullHashChecker::FetchRequest::Entry>(uint64_t **a1, char *a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  char *v8;
  size_t v9;
  uint64_t v11;

  v5 = (uint64_t **)std::__tree<Backend::Google::FullHashChecker::FetchRequest::Entry>::__find_equal<Backend::Google::FullHashChecker::FetchRequest::Entry>((uint64_t)a1, &v11, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    v8 = (char *)operator new(0x50uLL);
    v6 = (uint64_t *)v8;
    *(_OWORD *)(v8 + 28) = *(_OWORD *)a3;
    v9 = *(unsigned __int8 *)(a3 + 48);
    v8[76] = v9;
    if (v9)
      memcpy(v8 + 44, (const void *)(a3 + 16), v9);
    std::__tree<Backend::Google::HashView>::__insert_node_at(a1, v11, v7, v6);
  }
  return v6;
}

_QWORD *std::__tree<Backend::Google::FullHashChecker::FetchRequest::Entry>::__find_equal<Backend::Google::FullHashChecker::FetchRequest::Entry>(uint64_t a1, _QWORD *a2, char *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  char *v7;
  _QWORD *v8;
  char *v9;
  char *v10;
  char *v12;
  char *v13;
  char *v14;
  char *v15;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a3 + 16;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (char *)v4 + 28;
        v14 = a3;
        v15 = v7;
        v10 = (char *)v4 + 44;
        v12 = (char *)v4 + 28;
        v13 = (char *)v4 + 44;
        if ((std::__tuple_compare_three_way[abi:sn180100]<Backend::Google::ThreatListDescriptor const&,Backend::Google::Hash const&,Backend::Google::ThreatListDescriptor const&,Backend::Google::Hash const&,0ul,1ul>((uint64_t)&v14, (uint64_t)&v12) & 0x80) == 0)break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      v14 = v9;
      v15 = v10;
      v12 = a3;
      v13 = v7;
      if ((std::__tuple_compare_three_way[abi:sn180100]<Backend::Google::ThreatListDescriptor const&,Backend::Google::Hash const&,Backend::Google::ThreatListDescriptor const&,Backend::Google::Hash const&,0ul,1ul>((uint64_t)&v14, (uint64_t)&v12) & 0x80) == 0)break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

_QWORD *std::__function::__func<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0,std::allocator<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0>,void ()(std::optional<Backend::Google::FindFullHashesResponse>)>::~__func(_QWORD *a1)
{
  *a1 = off_1EA3E9FD8;
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 3));
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 1));
  return a1;
}

void std::__function::__func<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0,std::allocator<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0>,void ()(std::optional<Backend::Google::FindFullHashesResponse>)>::~__func(_QWORD *a1)
{
  *a1 = off_1EA3E9FD8;
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 3));
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 1));
  operator delete(a1);
}

_QWORD *std::__function::__func<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0,std::allocator<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0>,void ()(std::optional<Backend::Google::FindFullHashesResponse>)>::__clone(_QWORD *a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  result = operator new(0x28uLL);
  v4 = a1[1];
  v3 = a1[2];
  *result = off_1EA3E9FD8;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = a1[4];
  result[3] = a1[3];
  result[4] = v7;
  if (v7)
  {
    v8 = (unint64_t *)(v7 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  return result;
}

_QWORD *std::__function::__func<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0,std::allocator<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0>,void ()(std::optional<Backend::Google::FindFullHashesResponse>)>::__clone(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v3 = result[1];
  v2 = result[2];
  *a2 = off_1EA3E9FD8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = result[4];
  a2[3] = result[3];
  a2[4] = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  return result;
}

uint64_t std::__function::__func<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0,std::allocator<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0>,void ()(std::optional<Backend::Google::FindFullHashesResponse>)>::destroy(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 8;
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 24);
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
}

void std::__function::__func<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0,std::allocator<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0>,void ()(std::optional<Backend::Google::FindFullHashesResponse>)>::destroy_deallocate(void *a1)
{
  uint64_t v2;

  v2 = (uint64_t)a1 + 8;
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)a1 + 24);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  operator delete(a1);
}

void std::__function::__func<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0,std::allocator<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0>,void ()(std::optional<Backend::Google::FindFullHashesResponse>)>::operator()(uint64_t a1, __int128 *a2)
{
  NSObject *v3;
  __int128 v4;
  uint64_t v5;
  _OWORD v6[2];
  char v7;
  void **v8;

  LOBYTE(v4) = 0;
  v7 = 0;
  if (*((_BYTE *)a2 + 56))
  {
    v4 = *a2;
    v5 = *((_QWORD *)a2 + 2);
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v6[0] = *(__int128 *)((char *)a2 + 24);
    *(_OWORD *)((char *)v6 + 9) = *(__int128 *)((char *)a2 + 33);
    v7 = 1;
    Backend::Google::FullHashChecker::handleFetchResult(*(_QWORD *)(a1 + 8), *(_QWORD **)(a1 + 24), (uint64_t *)&v4);
  }
  else
  {
    v3 = SSBOSLogFullHash();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      std::__function::__func<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0,std::allocator<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0>,void ()(std::optional<Backend::Google::FindFullHashesResponse>)>::operator()(v3);
    Backend::Google::FullHashChecker::handleFetchFailure(*(_QWORD *)(a1 + 8), *(_QWORD **)(a1 + 24));
  }
  if (v7)
  {
    v8 = (void **)&v4;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v8);
  }
}

void sub_1DBCE4D88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  uint64_t v16;

  if (a16)
  {
    *(_QWORD *)(v16 - 24) = &a9;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100]((void ***)(v16 - 24));
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashChecker::FetchRequest>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB9C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashChecker::FetchRequest>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB9C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashChecker::FetchRequest>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 24;
  std::__tree<std::shared_ptr<Backend::Google::FullHashChecker::Check>>::destroy(a1 + 48, *(_QWORD **)(a1 + 56));
  std::__tree<Backend::Google::HashView>::destroy(v2, *(_QWORD **)(a1 + 32));
}

void std::__tree<std::shared_ptr<Backend::Google::FullHashChecker::Check>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::shared_ptr<Backend::Google::FullHashChecker::Check>>::destroy(a1, *a2);
    std::__tree<std::shared_ptr<Backend::Google::FullHashChecker::Check>>::destroy(a1, a2[1]);
    std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::__emplace_unique_key_args<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::piecewise_construct_t const&,std::tuple<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>&&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t v10;
  _QWORD v12[2];
  char v13;
  uint64_t v14;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::__find_equal<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>((uint64_t)a1, &v14, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    v9 = (uint64_t *)operator new(0x68uLL);
    v7 = v9;
    v12[1] = a1 + 1;
    v10 = *a4;
    *((_BYTE *)v9 + 64) = *(_BYTE *)(v10 + 32);
    if (*(_BYTE *)(v10 + 32))
      memmove(v9 + 4, (const void *)v10, *(unsigned __int8 *)(v10 + 32));
    *(_OWORD *)((char *)v7 + 68) = *(_OWORD *)(v10 + 36);
    v7[11] = 0;
    v7[12] = 0;
    v13 = 1;
    std::__tree<Backend::Google::HashView>::__insert_node_at(a1, v14, v8, v7);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,void *>>>>::reset[abi:sn180100]((uint64_t)v12, 0);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::__find_equal<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  uint64_t v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = (uint64_t)(v4 + 4);
        if ((std::operator<=>[abi:sn180100]<Backend::Google::Hash,Backend::Google::ThreatListDescriptor,Backend::Google::Hash,Backend::Google::ThreatListDescriptor>(a3, (uint64_t)(v4 + 4)) & 0x80) == 0)break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if ((std::operator<=>[abi:sn180100]<Backend::Google::Hash,Backend::Google::ThreatListDescriptor,Backend::Google::Hash,Backend::Google::ThreatListDescriptor>(v8, a3) & 0x80) == 0)break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,void *>>>>::reset[abi:sn180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)v2 + 88);
    operator delete(v2);
  }
}

uint64_t std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::__erase_unique<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;

  v3 = std::__tree<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::__map_value_compare<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>,std::less<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>>>>::find<std::pair<Backend::Google::Hash,Backend::Google::ThreatListDescriptor>>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  v4 = v3;
  std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::__remove_node_pointer(a1, v3);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(v4 + 11));
  operator delete(v4);
  return 1;
}

uint64_t Backend::Google::FullHashFetcher::FullHashFetcher(uint64_t a1, const Backend::Google::Configuration *a2, int a3)
{
  unsigned int v5;
  unsigned int v6;
  __int128 v8;
  uint64_t v9;
  std::random_device v10;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  Backend::Google::Configuration::Configuration((std::string *)(a1 + 16), a2);
  *(_QWORD *)(a1 + 104) = dispatch_queue_create("com.apple.Safari.SafeBrowsing.FullHashFetcher", 0);
  std::random_device::random_device[abi:sn180100](&v10);
  v5 = MEMORY[0x1DF0B88FC](&v10);
  v6 = v5 + ((v5 / 0x7FFFFFFF) | ((v5 / 0x7FFFFFFF) << 31));
  if (v6 <= 1)
    v6 = 1;
  *(_DWORD *)(a1 + 112) = v6;
  std::random_device::~random_device(&v10);
  *(_DWORD *)(a1 + 116) = a3;
  std::string::basic_string[abi:sn180100]<0>((char **)&v8, "Full Hash Fetcher Back-off");
  *(_OWORD *)(a1 + 120) = v8;
  *(_QWORD *)(a1 + 136) = v9;
  *(_QWORD *)(a1 + 144) = a1 + 112;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  return a1;
}

void sub_1DBCE5124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, std::random_device a13, std::random_device a14)
{
  uint64_t v14;
  Backend::Google::Configuration *v15;
  std::__shared_weak_count *v17;

  Backend::Google::Configuration::~Configuration(v15);
  v17 = *(std::__shared_weak_count **)(v14 + 8);
  if (v17)
    std::__shared_weak_count::__release_weak(v17);
  _Unwind_Resume(a1);
}

void Backend::Google::FullHashFetcher::~FullHashFetcher(Backend::Google::FullHashFetcher *this)
{
  std::__shared_weak_count *v2;

  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 21, 0);
  if (*((char *)this + 143) < 0)
    operator delete(*((void **)this + 15));

  Backend::Google::Configuration::~Configuration((Backend::Google::FullHashFetcher *)((char *)this + 16));
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void Backend::Google::FullHashFetcher::fetchHashes(_QWORD *a1, __int128 *a2, void *a3, void *a4, void *a5, _QWORD *a6)
{
  id v11;
  id v12;
  id v13;
  NSObject *v14;
  __int128 v15;
  __int128 v16;
  id v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  __int128 v32;
  void **v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  id v37;
  id v38;
  id v39;
  _BYTE v40[24];
  _BYTE *v41;
  _QWORD block[4];
  uint64_t v43;
  std::__shared_weak_count *v44;
  id v45[6];
  _BYTE v46[24];
  _BYTE *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v11 = a3;
  v12 = a4;
  v13 = a5;
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v32, a1);
  v14 = a1[13];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEE_block_invoke;
  block[3] = &__block_descriptor_128_ea8_32c274_ZTSKZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEE3__0_e5_v8__0l;
  v15 = v32;
  v32 = 0uLL;
  v16 = *a2;
  v34 = v15;
  v35 = v16;
  v36 = *((_QWORD *)a2 + 2);
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  v17 = v11;
  v37 = v17;
  v38 = v12;
  v39 = v13;
  v18 = v40;
  v19 = (_QWORD *)a6[3];
  if (v19)
  {
    if (v19 == a6)
    {
      v41 = v40;
      (*(void (**)(_QWORD *, _BYTE *))(*a6 + 24))(a6, v40);
    }
    else
    {
      v41 = (_BYTE *)a6[3];
      a6[3] = 0;
    }
  }
  else
  {
    v41 = 0;
  }
  Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::$_0(&v43, (uint64_t)&v34);
  dispatch_async(v14, block);
  if (v41 == v40)
  {
    v20 = 4;
    goto LABEL_10;
  }
  if (v41)
  {
    v20 = 5;
    v18 = v41;
LABEL_10:
    (*(void (**)(_QWORD *))(*v18 + 8 * v20))(v18);
  }

  v33 = (void **)&v35;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v33);
  v21 = (std::__shared_weak_count *)*((_QWORD *)&v34 + 1);
  if (*((_QWORD *)&v34 + 1))
  {
    v22 = (unint64_t *)(*((_QWORD *)&v34 + 1) + 8);
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = v47;
  if (v47 == v46)
  {
    v25 = 4;
    v24 = v46;
    goto LABEL_20;
  }
  if (v47)
  {
    v25 = 5;
LABEL_20:
    (*(void (**)(void))(*v24 + 8 * v25))();
  }

  *(_QWORD *)&v34 = v45;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)&v34);
  v26 = v44;
  if (v44)
  {
    p_shared_owners = (unint64_t *)&v44->__shared_owners_;
    do
      v28 = __ldaxr(p_shared_owners);
    while (__stlxr(v28 - 1, p_shared_owners));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = (std::__shared_weak_count *)*((_QWORD *)&v32 + 1);
  if (*((_QWORD *)&v32 + 1))
  {
    v30 = (unint64_t *)(*((_QWORD *)&v32 + 1) + 8);
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

}

void sub_1DBCE549C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  void *v13;

  Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::~$_0((uint64_t)&a13);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void ___ZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  NSObject *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  void ***v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  int v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  void *v17;
  id v18;
  BOOL v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  NSObject *v26;
  int v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  std::__shared_weak_count *v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  _QWORD *v36;
  id v37;
  void *v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  void **v48;
  std::string __p;
  void *v50[2];
  char v51;
  _BYTE v52[48];
  void *v53;
  void **v54;
  void **v55;
  std::__shared_weak_count *v56;
  id v57;
  _QWORD v58[3];
  _QWORD *v59;
  id v60;
  BOOL v61;
  _QWORD v62[3];
  id v63;
  uint8_t buf[8];
  uint64_t v65;
  void *v66;
  void *v67;
  uint64_t v68;
  std::__shared_weak_count *v69;
  id v70;
  _QWORD v71[3];
  _QWORD *v72;
  id v73;
  id v74[5];

  v74[4] = *(id *)MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_QWORD *)(v2 + 176)
    && (!*(_DWORD *)(v2 + 156) || std::chrono::system_clock::now().__d_.__rep_ >= *(_QWORD *)(v2 + 160)))
  {
    Backend::xpcConnectionClientIdentifierFromConnection(&v53);
    Backend::xpcConnectionClientStringFromIdentifier((char **)&v53, (char **)v50);
    v8 = *(_QWORD *)(a1 + 32);
    if (*(char *)(v8 + 63) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v8 + 40), *(_QWORD *)(v8 + 48));
    else
      __p = *(std::string *)(v8 + 40);
    Backend::Google::ClientInfo::ClientInfo((uint64_t)v52, (__int128 *)v50, (__n128 *)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (v51 < 0)
      operator delete(v50[0]);
    v12 = *(id *)(*(_QWORD *)(a1 + 32) + 72);
    v13 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 116);
    switch(v13)
    {
      case 1:
        Backend::Google::FindFullHashesRequestJSONSerializer::FindFullHashesRequestJSONSerializer(buf, (const Backend::Google::ClientInfo *)v52);
        v20 = *(std::__shared_weak_count **)(a1 + 48);
        v21 = *(std::__shared_weak_count **)(a1 + 56);
        if (v20 != v21)
        {
          v22 = *(_QWORD *)(a1 + 48);
          do
          {
            v55 = (void **)*(unsigned __int8 *)(v22 + 32);
            v56 = v20;
            Backend::Google::FindFullHashesRequestJSONSerializer::addHashPrefix((uint64_t **)buf, (unsigned __int8 *)&v55, (int *)(v22 + 36), *(_QWORD *)(v22 + 64), *(_QWORD *)(v22 + 56));
            v22 += 72;
            v20 += 3;
          }
          while ((std::__shared_weak_count *)v22 != v21);
        }
        Backend::Google::Configuration::getEncodedFullHashesRequestURLRequest((Backend::Google::Configuration *)(*(_QWORD *)(a1 + 32) + 16), (const Backend::Google::FindFullHashesRequestSerializer *)buf, *(ProxyConfiguration **)(a1 + 80));
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        v19 = *(_QWORD *)(a1 + 80) != 0;
        Backend::Google::FindFullHashesRequestJSONSerializer::~FindFullHashesRequestJSONSerializer((Backend::Google::FindFullHashesRequestJSONSerializer *)buf);
        break;
      case 2:
        Backend::Google::FindFullHashesRequestJSONSerializer::FindFullHashesRequestJSONSerializer(buf, (const Backend::Google::ClientInfo *)v52);
        v23 = *(std::__shared_weak_count **)(a1 + 48);
        v24 = *(std::__shared_weak_count **)(a1 + 56);
        if (v23 != v24)
        {
          v25 = *(_QWORD *)(a1 + 48);
          do
          {
            v55 = (void **)*(unsigned __int8 *)(v25 + 32);
            v56 = v23;
            Backend::Google::FindFullHashesRequestJSONSerializer::addHashPrefix((uint64_t **)buf, (unsigned __int8 *)&v55, (int *)(v25 + 36), *(_QWORD *)(v25 + 64), *(_QWORD *)(v25 + 56));
            v25 += 72;
            v23 += 3;
          }
          while ((std::__shared_weak_count *)v25 != v24);
        }
        Backend::Google::Configuration::getEncodedFullHashesRequestURLRequestForTencent((Backend::Google::Configuration *)(*(_QWORD *)(a1 + 32) + 16), (const Backend::Google::FindFullHashesRequestJSONSerializer *)buf);
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        Backend::Google::FindFullHashesRequestJSONSerializer::~FindFullHashesRequestJSONSerializer((Backend::Google::FindFullHashesRequestJSONSerializer *)buf);
        v19 = 0;
        break;
      case 3:
        Backend::Google::FindFullHashesRequestJSONSerializer::FindFullHashesRequestJSONSerializer(buf, (const Backend::Google::ClientInfo *)v52);
        v14 = *(std::__shared_weak_count **)(a1 + 48);
        v15 = *(std::__shared_weak_count **)(a1 + 56);
        if (v14 != v15)
        {
          v16 = *(_QWORD *)(a1 + 48);
          do
          {
            v55 = (void **)*(unsigned __int8 *)(v16 + 32);
            v56 = v14;
            Backend::Google::FindFullHashesRequestJSONSerializer::addHashPrefix((uint64_t **)buf, (unsigned __int8 *)&v55, (int *)(v16 + 36), *(_QWORD *)(v16 + 64), *(_QWORD *)(v16 + 56));
            v16 += 72;
            v14 += 3;
          }
          while ((std::__shared_weak_count *)v16 != v15);
        }
        Backend::Google::Configuration::getEncodedFullHashesRequestURLRequestForAppleProtobuf((Backend::Google::Configuration *)(*(_QWORD *)(a1 + 32) + 16), (const Backend::Google::FindFullHashesRequestSerializer *)buf);
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        v18 = *(id *)(*(_QWORD *)(a1 + 32) + 88);

        Backend::Google::FindFullHashesRequestJSONSerializer::~FindFullHashesRequestJSONSerializer((Backend::Google::FindFullHashesRequestJSONSerializer *)buf);
        v19 = 0;
        v12 = v18;
        break;
      default:
        v19 = 0;
        v17 = 0;
        break;
    }
    v26 = SSBOSLogFullHash();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
    {
      v27 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 116);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v27;
      _os_log_impl(&dword_1DBCBE000, v26, OS_LOG_TYPE_INFO, "Initiate request to %d server", buf, 8u);
    }
    if (v53 && (Backend::xpcConnectionClientIsSafari((uint64_t)&v53) & 1) == 0)
    {
      objc_msgSend(v12, "configuration");
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      v29 = v28;
      if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 116) == 3)
        objc_msgSend(v28, "set_usesNWLoader:", 1);
      objc_msgSend(v29, "set_sourceApplicationBundleIdentifier:", 0, *(_OWORD *)&__p.__r_.__value_.__l.__data_, __p.__r_.__value_.__r.__words[2]);
      Backend::xpcConnectionClientAuditTokenDataFromConnection(*(void **)(a1 + 72));
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v29, "set_sourceApplicationAuditTokenData:", v30);

      objc_msgSend(MEMORY[0x1E0C92C98], "sessionWithConfiguration:", v29);
      v31 = objc_claimAutoreleasedReturnValue();

      v12 = (id)v31;
    }
    v32 = (void *)nw_activity_create();
    nw_activity_activate();
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    v65 = 3321888768;
    v66 = ___ZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEv_block_invoke_8;
    v67 = &__block_descriptor_136_ea8_32c319_ZTSKZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvEUlP6NSDataP13NSURLResponseP7NSErrorE__e46_v32__0__NSData_8__NSURLResponse_16__NSError_24l;
    v33 = *(std::__shared_weak_count **)(a1 + 40);
    v55 = *(void ***)(a1 + 32);
    v56 = v33;
    if (v33)
    {
      p_shared_owners = (unint64_t *)&v33->__shared_owners_;
      do
        v35 = __ldxr(p_shared_owners);
      while (__stxr(v35 + 1, p_shared_owners));
    }
    v57 = *(id *)(a1 + 88);
    v36 = v58;
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v58, a1 + 96);
    v37 = v32;
    v60 = v37;
    v61 = v19;
    memset(v62, 0, sizeof(v62));
    std::vector<Backend::Google::FullHashRequest>::__init_with_size[abi:sn180100]<Backend::Google::FullHashRequest*,Backend::Google::FullHashRequest*>((Backend::Google::FullHashRequest *)v62, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48)) >> 3));
    v63 = *(id *)(a1 + 72);
    Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::NSError((uint64_t)&v68, (uint64_t)&v55);
    objc_msgSend(v12, "dataTaskWithRequest:completionHandler:", v17, buf);
    v38 = (void *)objc_claimAutoreleasedReturnValue();

    v54 = (void **)v62;
    std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v54);

    if (v59 == v58)
    {
      v39 = 4;
    }
    else
    {
      if (!v59)
      {
LABEL_59:

        v40 = v56;
        if (v56)
        {
          v41 = (unint64_t *)&v56->__shared_owners_;
          do
            v42 = __ldaxr(v41);
          while (__stlxr(v42 - 1, v41));
          if (!v42)
          {
            ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
            std::__shared_weak_count::__release_weak(v40);
          }
        }
        objc_msgSend(v38, "set_nw_activity:", v37, __p.__r_.__value_.__r.__words[0]);
        objc_msgSend(v38, "resume");

        v55 = v74;
        std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v55);

        v43 = v72;
        if (v72 == v71)
        {
          v44 = 4;
          v43 = v71;
        }
        else
        {
          if (!v72)
            goto LABEL_69;
          v44 = 5;
        }
        (*(void (**)(void))(*v43 + 8 * v44))();
LABEL_69:

        v45 = v69;
        if (v69)
        {
          v46 = (unint64_t *)&v69->__shared_owners_;
          do
            v47 = __ldaxr(v46);
          while (__stlxr(v47 - 1, v46));
          if (!v47)
          {
            ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
            std::__shared_weak_count::__release_weak(v45);
          }
        }

        Backend::Google::ClientInfo::~ClientInfo((Backend::Google::ClientInfo *)v52);
        v48 = (void **)v53;
        v53 = 0;
        if (v48)
          std::default_delete<std::string>::operator()[abi:sn180100]((int)&v53, v48);

        return;
      }
      v39 = 5;
      v36 = v59;
    }
    (*(void (**)(_QWORD *))(*v36 + 8 * v39))(v36);
    goto LABEL_59;
  }
  v3 = SSBOSLogFullHash();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 116);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v4;
    _os_log_impl(&dword_1DBCBE000, v3, OS_LOG_TYPE_DEFAULT, "Cannot issue full hash request to %d server either because we are in wait duration or because we are in backoff interval", buf, 8u);
  }
  v5 = *(NSObject **)(a1 + 88);
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  v65 = 3321888768;
  v66 = ___ZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEv_block_invoke;
  v67 = &__block_descriptor_64_ea8_32c287_ZTSKZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvEUlvE__e5_v8__0l;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)&v55, a1 + 96);
  v6 = &v68;
  v7 = v58[0];
  if (!v58[0])
    goto LABEL_7;
  if ((void ***)v58[0] != &v55)
  {
    v7 = (*(uint64_t (**)(void))(*(_QWORD *)v58[0] + 16))();
LABEL_7:
    v71[0] = v7;
    goto LABEL_13;
  }
  v71[0] = &v68;
  ((void (*)(void ***, uint64_t *))v55[3])(&v55, &v68);
LABEL_13:
  dispatch_async(v5, buf);
  v9 = (void ***)v58[0];
  if ((void ***)v58[0] == &v55)
  {
    v10 = 4;
    v9 = &v55;
    goto LABEL_17;
  }
  if (v58[0])
  {
    v10 = 5;
LABEL_17:
    ((void (*)(void))(*v9)[v10])();
  }
  if ((uint64_t *)v71[0] == &v68)
  {
    v11 = 4;
  }
  else
  {
    if (!v71[0])
      return;
    v11 = 5;
    v6 = (uint64_t *)v71[0];
  }
  (*(void (**)(uint64_t *))(*v6 + 8 * v11))(v6);
}

void sub_1DBCE5C18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void **a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59)
{
  void *v59;
  void **v61;

  Backend::Google::FindFullHashesRequestJSONSerializer::~FindFullHashesRequestJSONSerializer((Backend::Google::FindFullHashesRequestJSONSerializer *)&a43);

  Backend::Google::ClientInfo::~ClientInfo((Backend::Google::ClientInfo *)&a21);
  v61 = a27;
  a27 = 0;
  if (v61)
    std::default_delete<std::string>::operator()[abi:sn180100]((int)&a27, v61);

  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_32c274_ZTSKZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEE3__0(uint64_t a1, uint64_t a2)
{
  return Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::$_0((_QWORD *)(a1 + 32), a2 + 32);
}

_QWORD *Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::$_0(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v4 = *(_QWORD *)(a2 + 8);
  *a1 = *(_QWORD *)a2;
  a1[1] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  std::vector<Backend::Google::FullHashRequest>::__init_with_size[abi:sn180100]<Backend::Google::FullHashRequest*,Backend::Google::FullHashRequest*>((Backend::Google::FullHashRequest *)(a1 + 2), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3));
  a1[5] = *(id *)(a2 + 40);
  a1[6] = *(id *)(a2 + 48);
  a1[7] = *(id *)(a2 + 56);
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(a1 + 8), a2 + 64);
  return a1;
}

void sub_1DBCE5FFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  id *v2;
  va_list va;

  va_start(va, a2);

  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)va);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)v2);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c274_ZTSKZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v6;

  v2 = (_QWORD *)(a1 + 96);
  v3 = *(_QWORD **)(a1 + 120);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  v6 = (void **)(a1 + 48);
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v6);
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

uint64_t Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::~$_0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v6;

  v2 = (_QWORD *)(a1 + 64);
  v3 = *(_QWORD **)(a1 + 88);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  v6 = (void **)(a1 + 16);
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v6);
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1);
}

void Backend::Google::FullHashFetcher::didFetchFullHashes(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6, __int128 *a7)
{
  NSData *v13;
  id v14;
  id v15;
  NSObject *v16;
  NSObject *v17;
  int v18;
  _QWORD *v19;
  __int128 *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 *v28;
  __int128 *v29;
  __int128 *p_buf;
  uint64_t v31;
  uint64_t v32;
  int v33;
  char *v34;
  __int128 v35;
  _QWORD *v36;
  __int128 *v37;
  __int128 *v38;
  _QWORD *v39;
  __int128 v40;
  __int128 *v41;
  uint64_t v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *p_shared_owners;
  unint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  ByteProvider *v50;
  NSData *v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  uint64_t v59;
  std::__shared_weak_count *v60;
  void (**v61)(void);
  ByteProvider *v62;
  std::__shared_weak_count *v63;
  __int128 v64;
  __int128 *v65;
  char v66;
  __int128 v67;
  std::__shared_weak_count *v68;
  __int128 v69;
  _QWORD v70[3];
  _QWORD *v71;
  __int128 buf;
  std::__shared_weak_count *v73;
  __int128 v74;
  _QWORD v75[3];
  _QWORD *v76;
  _QWORD block[4];
  _BYTE v78[24];
  __int128 *v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  v14 = a3;
  v15 = a4;
  v16 = a6;
  v17 = SSBOSLogFullHash();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    v18 = *(_DWORD *)(a1 + 116);
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v18;
    _os_log_impl(&dword_1DBCBE000, v17, OS_LOG_TYPE_INFO, "Received response from %d server", (uint8_t *)&buf, 8u);
  }
  if (a5 || objc_msgSend(v14, "statusCode") != 200)
  {
    v21 = SSBOSLogFullHash();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      Backend::Google::FullHashFetcher::didFetchFullHashes(a1, v21, v22, v23, v24, v25, v26, v27);
    Backend::Google::BackoffTracker<std::chrono::system_clock>::didReceiveError(a1 + 120);
    nw_activity_complete_with_reason();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEE_block_invoke;
    block[3] = &__block_descriptor_64_ea8_32c242_ZTSKZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEE3__0_e5_v8__0l;
    v28 = (__int128 *)v78;
    v29 = (__int128 *)*((_QWORD *)a7 + 3);
    if (v29)
    {
      if (v29 == a7)
      {
        *(_QWORD *)&v74 = &buf;
        (*(void (**)(__int128 *, __int128 *))(*(_QWORD *)a7 + 24))(a7, &buf);
        v29 = (__int128 *)v74;
        if (!(_QWORD)v74)
          goto LABEL_17;
      }
      else
      {
        *(_QWORD *)&v74 = *((_QWORD *)a7 + 3);
        *((_QWORD *)a7 + 3) = 0;
      }
      if (v29 == &buf)
      {
        v79 = (__int128 *)v78;
        (*(void (**)(__int128 *, _BYTE *))(buf + 24))(&buf, v78);
LABEL_19:
        dispatch_async(v16, block);
        p_buf = (__int128 *)v74;
        if ((__int128 *)v74 == &buf)
        {
          v31 = 4;
          p_buf = &buf;
        }
        else
        {
          if (!(_QWORD)v74)
            goto LABEL_24;
          v31 = 5;
        }
        (*(void (**)(void))(*(_QWORD *)p_buf + 8 * v31))();
LABEL_24:
        if (v79 == (__int128 *)v78)
        {
          v32 = 4;
        }
        else
        {
          if (!v79)
            goto LABEL_29;
          v32 = 5;
          v28 = v79;
        }
        (*(void (**)(__int128 *))(*(_QWORD *)v28 + 8 * v32))(v28);
        goto LABEL_29;
      }
      v29 = (__int128 *)(*(uint64_t (**)(__int128 *))(*(_QWORD *)v29 + 16))(v29);
    }
    else
    {
      *(_QWORD *)&v74 = 0;
    }
LABEL_17:
    v79 = v29;
    goto LABEL_19;
  }
  *(_QWORD *)&buf = a1;
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>((_QWORD *)&buf + 1, (_QWORD *)a1);
  *(_QWORD *)&v74 = v16;
  *((_QWORD *)&v74 + 1) = v15;
  v19 = v75;
  v20 = (__int128 *)*((_QWORD *)a7 + 3);
  if (v20)
  {
    if (v20 == a7)
    {
      v76 = v75;
      (*(void (**)(__int128 *, _QWORD *))(*(_QWORD *)a7 + 24))(a7, v75);
    }
    else
    {
      v76 = (_QWORD *)*((_QWORD *)a7 + 3);
      *((_QWORD *)a7 + 3) = 0;
    }
  }
  else
  {
    v76 = 0;
  }
  v33 = *(_DWORD *)(a1 + 116);
  if (v33 == 1)
    goto LABEL_35;
  if (v33 != 2)
  {
    if (v33 != 3)
      goto LABEL_75;
LABEL_35:
    v34 = (char *)operator new(0x68uLL);
    *((_QWORD *)v34 + 1) = 0;
    *((_QWORD *)v34 + 2) = 0;
    *(_QWORD *)v34 = off_1EA3EB878;
    *(_OWORD *)(v34 + 40) = 0u;
    *(_OWORD *)(v34 + 56) = 0u;
    *(_OWORD *)(v34 + 72) = 0u;
    *(_OWORD *)(v34 + 88) = 0u;
    *(_OWORD *)(v34 + 24) = 0u;
    v62 = (ByteProvider *)(v34 + 24);
    v63 = (std::__shared_weak_count *)v34;
    std::shared_ptr<ByteProvider>::__enable_weak_this[abi:sn180100]<ByteProvider,ByteProvider,void>((uint64_t)&v62, v62, (uint64_t)v62);
    std::allocate_shared[abi:sn180100]<ReadStream,std::allocator<ReadStream>,std::shared_ptr<ByteProvider> &,void>((uint64_t *)&v62, &v59);
    v67 = buf;
    v68 = v73;
    *((_QWORD *)&buf + 1) = 0;
    v73 = 0;
    v35 = v74;
    v74 = 0uLL;
    v69 = v35;
    v36 = v70;
    if (v76)
    {
      if (v76 == v75)
      {
        v71 = v70;
        (*(void (**)(_QWORD *, _QWORD *))(v75[0] + 24))(v75, v70);
      }
      else
      {
        v71 = v76;
        v76 = 0;
      }
    }
    else
    {
      v71 = 0;
    }
    v65 = 0;
    v37 = (__int128 *)operator new(0x50uLL);
    v38 = v37;
    *(_QWORD *)v37 = off_1EA3EA020;
    *(__int128 *)((char *)v37 + 8) = v67;
    v39 = v71;
    *((_QWORD *)v37 + 3) = v68;
    *((_QWORD *)&v67 + 1) = 0;
    v68 = 0;
    v40 = v69;
    v69 = 0uLL;
    v37[2] = v40;
    if (v39)
    {
      if (v39 == v70)
      {
        *((_QWORD *)v37 + 9) = v37 + 3;
        (*(void (**)(_QWORD *))(v70[0] + 24))(v70);
      }
      else
      {
        *((_QWORD *)v37 + 9) = v39;
        v71 = 0;
      }
    }
    else
    {
      *((_QWORD *)v37 + 9) = 0;
    }
    v65 = v38;
    Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(&v61, &v59, &v64);
    v41 = v65;
    if (v65 == &v64)
    {
      v42 = 4;
      v41 = &v64;
    }
    else
    {
      if (!v65)
        goto LABEL_53;
      v42 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v41 + 8 * v42))();
LABEL_53:
    if (v71 == v70)
    {
      v43 = 4;
    }
    else
    {
      if (!v71)
        goto LABEL_58;
      v43 = 5;
      v36 = v71;
    }
    (*(void (**)(_QWORD *))(*v36 + 8 * v43))(v36);
LABEL_58:

    v44 = v68;
    if (v68)
    {
      p_shared_owners = (unint64_t *)&v68->__shared_owners_;
      do
        v46 = __ldaxr(p_shared_owners);
      while (__stlxr(v46 - 1, p_shared_owners));
      if (!v46)
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
    }
    v47 = v60;
    if (v60)
    {
      v48 = (unint64_t *)&v60->__shared_owners_;
      do
        v49 = __ldaxr(v48);
      while (__stlxr(v49 - 1, v48));
      if (!v49)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
    v50 = v62;
    v51 = objc_retainAutorelease(v13);
    ByteProvider::dataReceived(v50, (uint64_t)-[NSData bytes](v51, "bytes"), -[NSData length](v51, "length"));
    ByteProvider::finishedReadingSuccessfully(v62);
    if (v61)
      v61[1]();
    v52 = v63;
    if (v63)
    {
      v53 = (unint64_t *)&v63->__shared_owners_;
      do
        v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
    }
    goto LABEL_75;
  }
  Backend::Google::FetchThreatListUpdatesResponseJSONParser::FetchThreatListUpdatesResponseJSONParser((Backend::Google::FetchThreatListUpdatesResponseJSONParser *)&v61, v13);
  Backend::Google::FindFullHashesResponseJSONParser::finish((uint64_t *)&v64, (Backend::Google::FindFullHashesResponseJSONParser *)&v61);
  Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1::operator()((uint64_t *)&buf, &v64);
  if (v66)
  {
    v62 = (ByteProvider *)&v64;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100]((void ***)&v62);
  }
  Backend::Google::FetchThreatListUpdatesResponseJSONParser::~FetchThreatListUpdatesResponseJSONParser((id *)&v61);
LABEL_75:
  if (v76 == v75)
  {
    v55 = 4;
    goto LABEL_79;
  }
  if (v76)
  {
    v55 = 5;
    v19 = v76;
LABEL_79:
    (*(void (**)(_QWORD *))(*v19 + 8 * v55))(v19);
  }

  v56 = v73;
  if (v73)
  {
    v57 = (unint64_t *)&v73->__shared_owners_;
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
LABEL_29:

}

void sub_1DBCE67A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12, void **a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  void *v33;
  void *v34;
  void *v35;
  void *v36;

  if (a22)
  {
    a13 = (void **)&a15;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&a13);
  }
  Backend::Google::FetchThreatListUpdatesResponseJSONParser::~FetchThreatListUpdatesResponseJSONParser(&a12);
  Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1::~$_1((uint64_t)&a33);

  _Unwind_Resume(a1);
}

void ___ZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _BYTE v2[56];
  char v3;
  void **v4;

  v2[0] = 0;
  v3 = 0;
  v1 = *(_QWORD *)(a1 + 56);
  if (v1)
  {
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v1 + 48))(v1, v2);
    if (v3)
    {
      v4 = (void **)v2;
      std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v4);
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:sn180100]();
    __break(1u);
  }
}

void sub_1DBCE6924(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  uint64_t v17;

  if (a17)
  {
    *(_QWORD *)(v17 - 24) = &a10;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100]((void ***)(v17 - 24));
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_ea8_32c242_ZTSKZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEE3__0(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 32, a2 + 32);
}

_QWORD *__destroy_helper_block_ea8_32c242_ZTSKZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEE3__0(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1::~$_1(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 40);
  v3 = *(_QWORD **)(a1 + 64);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 8);
  return a1;
}

void Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1::operator()(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  uint64_t *v5;
  NSObject *v6;
  _BYTE *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  void ***v18;
  uint64_t v19;
  _BYTE *v20;
  void ***v21;
  uint64_t v22;
  uint64_t v23;
  void **v24;
  void **v25[3];
  void ***v26;
  __int128 v27;
  uint64_t v28;
  _OWORD v29[2];
  _QWORD block[4];
  _BYTE v31[24];
  _BYTE *v32;
  _QWORD v33[3];
  _OWORD v34[2];
  _QWORD v35[4];
  _BYTE v36[24];
  _BYTE *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v3 = *a1;
  if (*((_BYTE *)a2 + 56))
  {
    *(_DWORD *)(v3 + 156) = 0;
    std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)(v3 + 168), 0);
    nw_activity_complete_with_reason();
    if (!*((_BYTE *)a2 + 56))
      goto LABEL_36;
    v5 = (uint64_t *)a2 + 3;
    if (*((_BYTE *)a2 + 32))
      Backend::Google::FullHashFetcher::setMinimumWaitDuration(v3, *v5);
    v6 = a1[3];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__1clEOSH__block_invoke_14;
    block[3] = &__block_descriptor_120_ea8_32c259_ZTSKZZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__1clEOSH_EUlvE0__e5_v8__0l;
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v25, (uint64_t)(a1 + 5));
    if (!*((_BYTE *)a2 + 56))
LABEL_36:
      __break(1u);
    v7 = v31;
    v27 = *a2;
    v28 = *((_QWORD *)a2 + 2);
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v29[0] = *(_OWORD *)v5;
    *(_OWORD *)((char *)v29 + 9) = *(__int128 *)((char *)a2 + 33);
    v8 = (uint64_t)v26;
    if (v26)
    {
      if (v26 == v25)
      {
        v32 = v31;
        (*((void (**)(void ***, _BYTE *))v25[0] + 3))(v25, v31);
LABEL_17:
        memset(v33, 0, sizeof(v33));
        std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__init_with_size[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch*,Backend::Google::FindFullHashesResponse::ThreatMatch*>(v33, v27, *((uint64_t *)&v27 + 1), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)&v27 + 1) - v27) >> 4));
        v34[0] = v29[0];
        *(_OWORD *)((char *)v34 + 9) = *(_OWORD *)((char *)v29 + 9);
        dispatch_async(v6, block);
        v24 = (void **)&v27;
        std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v24);
        v18 = v26;
        if (v26 == v25)
        {
          v19 = 4;
          v18 = v25;
        }
        else
        {
          if (!v26)
          {
LABEL_22:
            v25[0] = (void **)v33;
            std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](v25);
            v20 = v32;
            goto LABEL_30;
          }
          v19 = 5;
        }
        ((void (*)(void))(*v18)[v19])();
        goto LABEL_22;
      }
      v8 = ((uint64_t (*)(void))(*v26)[2])();
    }
    v32 = (_BYTE *)v8;
    goto LABEL_17;
  }
  v9 = SSBOSLogFullHash();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1::operator()(v3, v9, v10, v11, v12, v13, v14, v15);
  Backend::Google::BackoffTracker<std::chrono::system_clock>::didReceiveError(v3 + 120);
  nw_activity_complete_with_reason();
  v16 = a1[3];
  v35[0] = MEMORY[0x1E0C809B0];
  v35[1] = 3321888768;
  v35[2] = ___ZZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__1clEOSH__block_invoke;
  v35[3] = &__block_descriptor_64_ea8_32c258_ZTSKZZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__1clEOSH_EUlvE__e5_v8__0l;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v25, (uint64_t)(a1 + 5));
  v7 = v36;
  v17 = (uint64_t)v26;
  if (!v26)
    goto LABEL_15;
  if (v26 != v25)
  {
    v17 = ((uint64_t (*)(void))(*v26)[2])();
LABEL_15:
    v37 = (_BYTE *)v17;
    goto LABEL_24;
  }
  v37 = v36;
  (*((void (**)(void ***, _BYTE *))v25[0] + 3))(v25, v36);
LABEL_24:
  dispatch_async(v16, v35);
  v21 = v26;
  if (v26 == v25)
  {
    v22 = 4;
    v21 = v25;
    goto LABEL_28;
  }
  if (v26)
  {
    v22 = 5;
LABEL_28:
    ((void (*)(void))(*v21)[v22])();
  }
  v20 = v37;
LABEL_30:
  if (v20 == v7)
  {
    v23 = 4;
  }
  else
  {
    if (!v20)
      return;
    v23 = 5;
    v7 = v20;
  }
  (*(void (**)(_BYTE *))(*(_QWORD *)v7 + 8 * v23))(v7);
}

void sub_1DBCE6D2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  char *v29;
  uint64_t v30;

  v29 = a13;
  if (a13 == &a10)
  {
    v30 = 4;
    v29 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v30 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v29 + 8 * v30))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void Backend::Google::FullHashFetcher::setMinimumWaitDuration(uint64_t a1, uint64_t a2)
{
  dispatch_source_t v4;
  void *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t v14;
  NSObject *v15;
  NSObject *v16;
  dispatch_time_t v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t);
  void *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
  v4 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(a1 + 104));
  v5 = *(void **)(a1 + 176);
  *(_QWORD *)(a1 + 176) = v4;

  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v24, (_QWORD *)a1);
  v7 = v24;
  v6 = v25;
  if (v25)
  {
    p_shared_weak_owners = (unint64_t *)&v25->__shared_weak_owners_;
    do
      v9 = __ldxr(p_shared_weak_owners);
    while (__stxr(v9 + 1, p_shared_weak_owners));
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    v12 = *(NSObject **)(a1 + 176);
    v18 = MEMORY[0x1E0C809B0];
    v19 = 3321888768;
    v20 = ___ZN7Backend6Google15FullHashFetcher22setMinimumWaitDurationENSt3__16chrono8durationIxNS2_5ratioILl1ELl1EEEEE_block_invoke;
    v21 = &__block_descriptor_48_ea8_32c117_ZTSKZN7Backend6Google15FullHashFetcher22setMinimumWaitDurationENSt3__16chrono8durationIxNS2_5ratioILl1ELl1EEEEEE3__0_e5_v8__0l;
    do
      v13 = __ldxr(p_shared_weak_owners);
    while (__stxr(v13 + 1, p_shared_weak_owners));
    v22 = v7;
    v23 = v6;
    do
      v14 = __ldxr(p_shared_weak_owners);
    while (__stxr(v14 + 1, p_shared_weak_owners));
    dispatch_source_set_event_handler(v12, &v18);
    std::__shared_weak_count::__release_weak(v6);
  }
  else
  {
    v15 = *(NSObject **)(a1 + 176);
    v18 = MEMORY[0x1E0C809B0];
    v19 = 3321888768;
    v20 = ___ZN7Backend6Google15FullHashFetcher22setMinimumWaitDurationENSt3__16chrono8durationIxNS2_5ratioILl1ELl1EEEEE_block_invoke;
    v21 = &__block_descriptor_48_ea8_32c117_ZTSKZN7Backend6Google15FullHashFetcher22setMinimumWaitDurationENSt3__16chrono8durationIxNS2_5ratioILl1ELl1EEEEEE3__0_e5_v8__0l;
    v22 = v24;
    v23 = 0;
    dispatch_source_set_event_handler(v15, &v18);
  }
  v16 = *(NSObject **)(a1 + 176);
  v17 = dispatch_walltime(0, 1000000000 * a2);
  dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(*(dispatch_object_t *)(a1 + 176));
  if (v23)
    std::__shared_weak_count::__release_weak(v23);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void ___ZN7Backend6Google15FullHashFetcher22setMinimumWaitDurationENSt3__16chrono8durationIxNS2_5ratioILl1ELl1EEEEE_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  dispatch_queue_t *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(dispatch_queue_t **)(a1 + 32);
      if (v5)
        Backend::Google::FullHashFetcher::waitTimerFired(v5);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1DBCE6FD8(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
    ___ZN7Backend6Google13FullHashCache21updateExpirationTimerEv_block_invoke_cold_1(v1);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_ea8_32c117_ZTSKZN7Backend6Google15FullHashFetcher22setMinimumWaitDurationENSt3__16chrono8durationIxNS2_5ratioILl1ELl1EEEEEE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_ea8_32c117_ZTSKZN7Backend6Google15FullHashFetcher22setMinimumWaitDurationENSt3__16chrono8durationIxNS2_5ratioILl1ELl1EEEEEE3__0(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void Backend::Google::FullHashFetcher::waitTimerFired(dispatch_queue_t *this)
{
  dispatch_queue_t v2;

  dispatch_assert_queue_V2(this[13]);
  dispatch_source_cancel(this[22]);
  v2 = this[22];
  this[22] = 0;

}

void ___ZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _BYTE v2[56];
  char v3;
  void **v4;

  v2[0] = 0;
  v3 = 0;
  v1 = *(_QWORD *)(a1 + 56);
  if (v1)
  {
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v1 + 48))(v1, v2);
    if (v3)
    {
      v4 = (void **)v2;
      std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v4);
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:sn180100]();
    __break(1u);
  }
}

void sub_1DBCE70CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  uint64_t v17;

  if (a17)
  {
    *(_QWORD *)(v17 - 24) = &a10;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100]((void ***)(v17 - 24));
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_ea8_32c287_ZTSKZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvEUlvE_(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 32, a2 + 32);
}

_QWORD *__destroy_helper_block_ea8_32c287_ZTSKZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvEUlvE_(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void ___ZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEv_block_invoke_8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  unint64_t *v16;
  unint64_t v17;
  id v18;
  id v19;
  id v20;
  _QWORD v21[3];
  _QWORD v22[8];
  char v23;
  _QWORD v24[4];
  _QWORD block[4];
  _QWORD v26[18];

  v26[16] = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = v7;
  v11 = v8;
  v12 = v9;
  block[0] = MEMORY[0x1E0C809B0];
  block[2] = ___ZZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clESN_SP_SR__block_invoke;
  block[3] = &__block_descriptor_160_ea8_32c340_ZTSKZZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clESN_SP_SR_EUlvE__e5_v8__0l;
  v14 = *(_QWORD *)(a1 + 32);
  v13 = *(_QWORD *)(a1 + 40);
  v15 = *(NSObject **)(v14 + 104);
  block[1] = 3321888768;
  v21[0] = v14;
  v21[1] = v13;
  if (v13)
  {
    v16 = (unint64_t *)(v13 + 8);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v21[2] = *(id *)(a1 + 48);
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v22, a1 + 56);
  v22[4] = *(id *)(a1 + 88);
  v18 = v10;
  v22[5] = v18;
  v19 = v11;
  v22[6] = v19;
  v20 = v12;
  v22[7] = v20;
  v23 = *(_BYTE *)(a1 + 96);
  memset(v24, 0, 24);
  std::vector<Backend::Google::FullHashRequest>::__init_with_size[abi:sn180100]<Backend::Google::FullHashRequest*,Backend::Google::FullHashRequest*>((Backend::Google::FullHashRequest *)v24, *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112), 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 104)) >> 3));
  v24[3] = *(id *)(a1 + 128);
  Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::operator() const(NSData *,NSURLResponse *,NSError *)::{lambda(void)#1}::((uint64_t)v26, (uint64_t)v21);
  dispatch_async(v15, block);
  Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::operator() const(NSData *,NSURLResponse *,NSError *)::{lambda(void)#1}::~((uint64_t)v21);
  Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::operator() const(NSData *,NSURLResponse *,NSError *)::{lambda(void)#1}::~((uint64_t)v26);

}

void sub_1DBCE7304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;
  void *v10;
  void *v11;

  Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::operator() const(NSData *,NSURLResponse *,NSError *)::{lambda(void)#1}::~((uint64_t)&a9);

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c319_ZTSKZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvEUlP6NSDataP13NSURLResponseP7NSErrorE_(uint64_t a1, uint64_t a2)
{
  return Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::NSError(a1 + 32, a2 + 32);
}

uint64_t Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::NSError(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  id v7;
  char v8;

  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  *(_QWORD *)(a1 + 16) = *(id *)(a2 + 16);
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 24, a2 + 24);
  v7 = *(id *)(a2 + 56);
  v8 = *(_BYTE *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 56) = v7;
  *(_BYTE *)(a1 + 64) = v8;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  std::vector<Backend::Google::FullHashRequest>::__init_with_size[abi:sn180100]<Backend::Google::FullHashRequest*,Backend::Google::FullHashRequest*>((Backend::Google::FullHashRequest *)(a1 + 72), *(_QWORD *)(a2 + 72), *(_QWORD *)(a2 + 80), 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a2 + 80) - *(_QWORD *)(a2 + 72)) >> 3));
  *(_QWORD *)(a1 + 96) = *(id *)(a2 + 96);
  return a1;
}

void sub_1DBCE7470(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v4;
  uint64_t v5;

  v4 = *(_QWORD **)(v1 + 48);
  if (v4 == v2)
  {
    v5 = 4;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
    v2 = *(_QWORD **)(v1 + 48);
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v5))(v2);
LABEL_6:

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c319_ZTSKZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvEUlP6NSDataP13NSURLResponseP7NSErrorE_(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void **v5;

  v5 = (void **)(a1 + 104);
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v5);

  v2 = *(_QWORD **)(a1 + 80);
  if (v2 == (_QWORD *)(a1 + 56))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 56);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }

  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void ___ZZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clESN_SP_SR__block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  __int128 *v15;
  uint64_t v16;
  _QWORD v17[3];
  void **v18;
  __int128 v19;
  __int128 *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 120)
    && *(_QWORD *)(a1 + 112)
    && +[ProxyConfiguration shouldRetryForError:](ProxyConfiguration, "shouldRetryForError:"))
  {
    v2 = SSBOSLogDatabase();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ___ZZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clESN_SP_SR__block_invoke_cold_1(v2);
    v3 = *(_QWORD *)(a1 + 32);
    memset(v17, 0, sizeof(v17));
    std::vector<Backend::Google::FullHashRequest>::__init_with_size[abi:sn180100]<Backend::Google::FullHashRequest*,Backend::Google::FullHashRequest*>((Backend::Google::FullHashRequest *)v17, *(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 136), 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a1 + 136) - *(_QWORD *)(a1 + 128)) >> 3));
    v4 = *(_QWORD *)(a1 + 152);
    v5 = *(_QWORD *)(a1 + 48);
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)&v19, a1 + 56);
    Backend::Google::FullHashFetcher::fetchHashes(v3, v17, v4, 0, v5, &v19);
    v6 = v20;
    if (v20 == &v19)
    {
      v7 = 4;
      v6 = &v19;
    }
    else
    {
      if (!v20)
      {
LABEL_16:
        v18 = (void **)v17;
        std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v18);
        return;
      }
      v7 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v6 + 8 * v7))();
    goto LABEL_16;
  }
  v8 = *(_QWORD *)(a1 + 32);
  v10 = *(void **)(a1 + 88);
  v9 = *(void **)(a1 + 96);
  v12 = *(void **)(a1 + 104);
  v11 = *(_QWORD *)(a1 + 112);
  v13 = a1 + 56;
  v14 = *(void **)(a1 + 48);
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)&v19, v13);
  Backend::Google::FullHashFetcher::didFetchFullHashes(v8, v9, v12, v10, v11, v14, &v19);
  v15 = v20;
  if (v20 == &v19)
  {
    v16 = 4;
    v15 = &v19;
  }
  else
  {
    if (!v20)
      return;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
}

void sub_1DBCE770C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  char *v17;
  char *v19;
  uint64_t v20;

  v19 = a17;
  if (a17 == v17)
  {
    v20 = 4;
    v19 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_6:
  a13 = (void **)&a10;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&a13);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c340_ZTSKZZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clESN_SP_SR_EUlvE_(uint64_t a1, uint64_t a2)
{
  return Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::operator() const(NSData *,NSURLResponse *,NSError *)::{lambda(void)#1}::(a1 + 32, a2 + 32);
}

uint64_t Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::operator() const(NSData *,NSURLResponse *,NSError *)::{lambda(void)#1}::(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  id v7;
  char v8;

  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  *(_QWORD *)(a1 + 16) = *(id *)(a2 + 16);
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 24, a2 + 24);
  *(_QWORD *)(a1 + 56) = *(id *)(a2 + 56);
  *(_QWORD *)(a1 + 64) = *(id *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = *(id *)(a2 + 72);
  v7 = *(id *)(a2 + 80);
  v8 = *(_BYTE *)(a2 + 88);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 80) = v7;
  *(_BYTE *)(a1 + 88) = v8;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  std::vector<Backend::Google::FullHashRequest>::__init_with_size[abi:sn180100]<Backend::Google::FullHashRequest*,Backend::Google::FullHashRequest*>((Backend::Google::FullHashRequest *)(a1 + 96), *(_QWORD *)(a2 + 96), *(_QWORD *)(a2 + 104), 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a2 + 104) - *(_QWORD *)(a2 + 96)) >> 3));
  *(_QWORD *)(a1 + 120) = *(id *)(a2 + 120);
  return a1;
}

void sub_1DBCE7884(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v4;
  uint64_t v5;

  v4 = *(_QWORD **)(v1 + 48);
  if (v4 == v2)
  {
    v5 = 4;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
    v2 = *(_QWORD **)(v1 + 48);
  }
  (*(void (**)(_QWORD *))(*v2 + 8 * v5))(v2);
LABEL_6:

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c340_ZTSKZZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clESN_SP_SR_EUlvE_(uint64_t a1)
{
  return Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::operator() const(NSData *,NSURLResponse *,NSError *)::{lambda(void)#1}::~(a1 + 32);
}

uint64_t Backend::Google::FullHashFetcher::fetchHashes(std::vector<Backend::Google::FullHashRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_0::operator() const(void)::{lambda(NSData *,NSURLResponse *,NSError *)#1}::operator() const(NSData *,NSURLResponse *,NSError *)::{lambda(void)#1}::~(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void **v5;

  v5 = (void **)(a1 + 96);
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v5);

  v2 = *(_QWORD **)(a1 + 48);
  if (v2 == (_QWORD *)(a1 + 24))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 24);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }

  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1);
}

void std::default_delete<std::string>::operator()[abi:sn180100](int a1, void **__p)
{
  if (__p)
  {
    if (*((char *)__p + 23) < 0)
      operator delete(*__p);
    operator delete(__p);
  }
}

void ___ZZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__1clEOSH__block_invoke(uint64_t a1)
{
  uint64_t v1;
  _BYTE v2[56];
  char v3;
  void **v4;

  v2[0] = 0;
  v3 = 0;
  v1 = *(_QWORD *)(a1 + 56);
  if (v1)
  {
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v1 + 48))(v1, v2);
    if (v3)
    {
      v4 = (void **)v2;
      std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v4);
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:sn180100]();
    __break(1u);
  }
}

void sub_1DBCE7A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  uint64_t v17;

  if (a17)
  {
    *(_QWORD *)(v17 - 24) = &a10;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100]((void ***)(v17 - 24));
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_ea8_32c258_ZTSKZZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__1clEOSH_EUlvE_(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 32, a2 + 32);
}

_QWORD *__destroy_helper_block_ea8_32c258_ZTSKZZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__1clEOSH_EUlvE_(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void ___ZZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__1clEOSH__block_invoke_14(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[3];
  _OWORD v4[2];
  char v5;
  void **v6;

  memset(v3, 0, sizeof(v3));
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__init_with_size[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch*,Backend::Google::FindFullHashesResponse::ThreatMatch*>(v3, *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 72) - *(_QWORD *)(a1 + 64)) >> 4));
  v4[0] = *(_OWORD *)(a1 + 88);
  *(_OWORD *)((char *)v4 + 9) = *(_OWORD *)(a1 + 97);
  v5 = 1;
  v2 = *(_QWORD *)(a1 + 56);
  if (v2)
  {
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 48))(v2, v3);
    if (v5)
    {
      v6 = (void **)v3;
      std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v6);
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:sn180100]();
    __break(1u);
  }
}

void sub_1DBCE7B34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  uint64_t v17;

  if (a17)
  {
    *(_QWORD *)(v17 - 24) = &a10;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100]((void ***)(v17 - 24));
  }
  _Unwind_Resume(exception_object);
}

__n128 __copy_helper_block_ea8_32c259_ZTSKZZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__1clEOSH_EUlvE0_(uint64_t a1, uint64_t a2)
{
  __n128 result;

  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 32, a2 + 32);
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__init_with_size[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch*,Backend::Google::FindFullHashesResponse::ThreatMatch*>((_QWORD *)(a1 + 64), *(_QWORD *)(a2 + 64), *(_QWORD *)(a2 + 72), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 72) - *(_QWORD *)(a2 + 64)) >> 4));
  result = *(__n128 *)(a2 + 88);
  *(_OWORD *)(a1 + 97) = *(_OWORD *)(a2 + 97);
  *(__n128 *)(a1 + 88) = result;
  return result;
}

void sub_1DBCE7BC8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;

  v4 = *(_QWORD **)(v2 + 56);
  if (v4 == v1)
  {
    v5 = 4;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
    v1 = *(_QWORD **)(v2 + 56);
  }
  (*(void (**)(_QWORD *))(*v1 + 8 * v5))(v1);
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *__destroy_helper_block_ea8_32c259_ZTSKZZN7Backend6Google15FullHashFetcher18didFetchFullHashesEP6NSDataP17NSHTTPURLResponsePU25objcproto14OS_nw_activity8NSObjectP7NSErrorPU28objcproto17OS_dispatch_queueS6_NSt3__18functionIFvNSD_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__1clEOSH_EUlvE0_(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *result;
  uint64_t v4;
  void **v5;

  v2 = (_QWORD *)(a1 + 32);
  v5 = (void **)(a1 + 64);
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v5);
  result = *(_QWORD **)(a1 + 56);
  if (result == v2)
  {
    v4 = 4;
    result = v2;
  }
  else
  {
    if (!result)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

uint64_t Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1::operator() const(std::optional<Backend::Google::FindFullHashesResponse>&&)::{lambda(void)#2}::~(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void **v5;

  v5 = (void **)(a1 + 32);
  std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__destroy_vector::operator()[abi:sn180100](&v5);
  v2 = *(_QWORD **)(a1 + 24);
  if (v2 == (_QWORD *)a1)
  {
    v3 = 4;
    v2 = (_QWORD *)a1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

_QWORD *std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__init_with_size[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch*,Backend::Google::FindFullHashesResponse::ThreatMatch*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6;

  if (a4)
  {
    v6 = (uint64_t)result;
    std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__vallocate[abi:sn180100](result, a4);
    return (_QWORD *)std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__construct_at_end<Backend::Google::FindFullHashesResponse::ThreatMatch*,Backend::Google::FindFullHashesResponse::ThreatMatch*>(v6, a2, a3);
  }
  return result;
}

char *std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__vallocate[abi:sn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x333333333333334)
    abort();
  result = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::FindFullHashesResponse::ThreatMatch>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[80 * v4];
  return result;
}

uint64_t std::vector<Backend::Google::FindFullHashesResponse::ThreatMatch>::__construct_at_end<Backend::Google::FindFullHashesResponse::ThreatMatch*,Backend::Google::FindFullHashesResponse::ThreatMatch*>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v7;

  v3 = result;
  v4 = *(_QWORD *)(result + 8);
  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      result = std::construct_at[abi:sn180100]<Backend::Google::FindFullHashesResponse::ThreatMatch,Backend::Google::FindFullHashesResponse::ThreatMatch const&,Backend::Google::FindFullHashesResponse::ThreatMatch*>(v4 + v7, (__int128 *)(a2 + v7));
      v7 += 80;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  *(_QWORD *)(v3 + 8) = v4;
  return result;
}

void sub_1DBCE7DD0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,std::allocator<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1>,void ()(std::optional<Backend::Google::FindFullHashesResponse>&&)>::~__func(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_1EA3EA020;
  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 16);
  return a1;
}

void std::__function::__func<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,std::allocator<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1>,void ()(std::optional<Backend::Google::FindFullHashesResponse>&&)>::~__func(char *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_1EA3EA020;
  v2 = a1 + 48;
  v3 = (_QWORD *)*((_QWORD *)a1 + 9);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 16));
  operator delete(a1);
}

_QWORD *std::__function::__func<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,std::allocator<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1>,void ()(std::optional<Backend::Google::FindFullHashesResponse>&&)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x50uLL);
  *v2 = off_1EA3EA020;
  std::__compressed_pair_elem<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,0,false>::__compressed_pair_elem[abi:sn180100]<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1 const&,0ul>((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1DBCE7F00(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,std::allocator<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1>,void ()(std::optional<Backend::Google::FindFullHashesResponse>&&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1EA3EA020;
  return std::__compressed_pair_elem<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,0,false>::__compressed_pair_elem[abi:sn180100]<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1 const&,0ul>((uint64_t)(a2 + 1), a1 + 8);
}

uint64_t std::__function::__func<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,std::allocator<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1>,void ()(std::optional<Backend::Google::FindFullHashesResponse>&&)>::destroy(uint64_t a1)
{
  return std::__function::__alloc_func<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,std::allocator<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1>,void ()(std::optional<Backend::Google::FindFullHashesResponse>&&)>::destroy[abi:sn180100](a1 + 8);
}

void std::__function::__func<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,std::allocator<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1>,void ()(std::optional<Backend::Google::FindFullHashesResponse>&&)>::destroy_deallocate(void *a1)
{
  std::__function::__alloc_func<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,std::allocator<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1>,void ()(std::optional<Backend::Google::FindFullHashesResponse>&&)>::destroy[abi:sn180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,std::allocator<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1>,void ()(std::optional<Backend::Google::FindFullHashesResponse>&&)>::operator()(uint64_t a1, __int128 *a2)
{
  Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1::operator()((uint64_t *)(a1 + 8), a2);
}

uint64_t std::__compressed_pair_elem<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,0,false>::__compressed_pair_elem[abi:sn180100]<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1 const&,0ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  v4 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 16) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  *(_QWORD *)(a1 + 24) = *(id *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = *(id *)(a2 + 32);
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 40, a2 + 40);
  return a1;
}

void sub_1DBCE7FE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1 + 8);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__alloc_func<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1,std::allocator<Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1>,void ()(std::optional<Backend::Google::FindFullHashesResponse>&&)>::destroy[abi:sn180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 40);
  v3 = *(_QWORD **)(a1 + 64);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 8);
}

uint64_t Backend::Google::FullHashRequest::FullHashRequest(uint64_t a1, _OWORD *a2, char a3, _OWORD *a4, const void *a5, size_t __sz)
{
  __int128 v9;
  void *v10;

  v9 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v9;
  *(_BYTE *)(a1 + 32) = a3;
  *(_OWORD *)(a1 + 36) = *a4;
  *(_QWORD *)(a1 + 56) = __sz;
  v10 = operator new[](__sz);
  bzero(v10, __sz);
  *(_QWORD *)(a1 + 64) = v10;
  if (__sz)
    memmove(v10, a5, __sz);
  return a1;
}

uint64_t Backend::Google::FullHashRequest::FullHashRequest(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  size_t v5;
  void *v6;

  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
  v5 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 56) = v5;
  v6 = operator new[](v5);
  bzero(v6, v5);
  *(_QWORD *)(a1 + 64) = v6;
  if (v5)
    memmove(v6, *(const void **)(a2 + 64), v5);
  return a1;
}

void Backend::Google::FullHashRequest::~FullHashRequest(Backend::Google::FullHashRequest *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (v2)
    operator delete[](v2);
}

id Backend::Google::FullHashRequest::toXPC(Backend::Google::FullHashRequest *this)
{
  xpc_object_t v2;
  void *v3;

  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_data(v2, "fullHash", this, 0x20uLL);
  xpc_dictionary_set_uint64(v2, "prefixSize", *((unsigned __int8 *)this + 32));
  Backend::Google::ThreatListDescriptor::toXPC((Backend::Google::FullHashRequest *)((char *)this + 36));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  xpc_dictionary_set_value(v2, "threatListDescriptor", v3);

  xpc_dictionary_set_data(v2, "clientState", *((const void **)this + 8), *((_QWORD *)this + 7));
  return v2;
}

void sub_1DBCE82BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void Backend::Google::FullHashRequest::fromXPC(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t value;
  char v11;
  void *v12;
  uint64_t v13;
  void *v14;
  const void *bytes_ptr;
  size_t length;
  size_t v17;
  void *v18;
  __int128 v19;
  void *v20;
  __int128 v21;
  char v22;
  _OWORD buffer[2];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  xpc_dictionary_get_value(v3, "fullHash");
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)v4;
  if (!v4
    || (v6 = MEMORY[0x1DF0B91F0](v4), v7 = MEMORY[0x1E0C812E8], v6 != MEMORY[0x1E0C812E8])
    || xpc_data_get_bytes(v5, buffer, 0, 0x20uLL) != 32
    || xpc_data_get_length(v5) != 32)
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 72) = 0;
LABEL_13:

    return;
  }
  xpc_dictionary_get_value(v3, "prefixSize");
  v8 = objc_claimAutoreleasedReturnValue();
  v9 = (void *)v8;
  if (!v8
    || MEMORY[0x1DF0B91F0](v8) != MEMORY[0x1E0C81398]
    || (value = xpc_uint64_get_value(v9), v11 = value, value >= 0x21)
    || (xpc_dictionary_get_value(v3, "threatListDescriptor"),
        v12 = (void *)objc_claimAutoreleasedReturnValue(),
        Backend::Google::ThreatListDescriptor::fromXPC(v12, &v21),
        v12,
        !v22))
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 72) = 0;
LABEL_15:

    goto LABEL_13;
  }
  xpc_dictionary_get_value(v3, "clientState");
  v13 = objc_claimAutoreleasedReturnValue();
  v14 = (void *)v13;
  if (!v13 || MEMORY[0x1DF0B91F0](v13) != v7)
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 72) = 0;
LABEL_22:

    goto LABEL_15;
  }
  bytes_ptr = xpc_data_get_bytes_ptr(v14);
  length = xpc_data_get_length(v14);
  if (v22)
  {
    v17 = length;
    v18 = operator new[](length);
    bzero(v18, v17);
    if (v17)
      memmove(v18, bytes_ptr, v17);
    v19 = buffer[1];
    *(_OWORD *)a2 = buffer[0];
    *(_OWORD *)(a2 + 16) = v19;
    *(_BYTE *)(a2 + 32) = v11;
    *(_OWORD *)(a2 + 36) = v21;
    *(_QWORD *)(a2 + 56) = v17;
    v20 = operator new[](v17);
    bzero(v20, v17);
    *(_QWORD *)(a2 + 64) = v20;
    if (v17)
      memcpy(v20, v18, v17);
    *(_BYTE *)(a2 + 72) = 1;
    operator delete[](v18);
    goto LABEL_22;
  }
  __break(1u);
}

void sub_1DBCE8520(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  operator delete[](v5);

  _Unwind_Resume(a1);
}

void Backend::Google::LexicographicallyOrderedHashEnumerator::LexicographicallyOrderedHashEnumerator(Backend::Google::LexicographicallyOrderedHashEnumerator *this, const Backend::Google::Database *a2)
{
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  unsigned __int8 **v5;
  _QWORD *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  unsigned __int8 **v14;
  char *v15;
  char *v16;
  unsigned __int8 **v17;
  __int128 v18;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v3 = (unsigned __int8 *)*((_QWORD *)a2 + 7);
  v4 = (unsigned __int8 *)*((_QWORD *)a2 + 8);
  if (v3 != v4)
  {
    v5 = 0;
    v6 = (_QWORD *)((char *)this + 16);
    do
    {
      if (*((_DWORD *)v3 + 1))
      {
        v7 = (unsigned __int8 *)*v3;
        v8 = (unsigned __int8 *)*((_QWORD *)v3 + 1);
        if ((unint64_t)v5 >= *v6)
        {
          v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *(_QWORD *)this) >> 3);
          v10 = v9 + 1;
          if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
            abort();
          if (0x5555555555555556 * ((uint64_t)(*v6 - *(_QWORD *)this) >> 3) > v10)
            v10 = 0x5555555555555556 * ((uint64_t)(*v6 - *(_QWORD *)this) >> 3);
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v6 - *(_QWORD *)this) >> 3) >= 0x555555555555555)
            v11 = 0xAAAAAAAAAAAAAAALL;
          else
            v11 = v10;
          if (!v11
            || (v12 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::LexicographicallyOrderedHashEnumerator::Position>>((uint64_t)this + 16, v11)) == 0)
          {
LABEL_24:
            __break(1u);
            return;
          }
          v14 = (unsigned __int8 **)&v12[24 * v9];
          *v14 = v3;
          v14[1] = v7;
          v14[2] = v8;
          v16 = *(char **)this;
          v15 = (char *)*((_QWORD *)this + 1);
          v17 = v14;
          if (v15 != *(char **)this)
          {
            do
            {
              v18 = *(_OWORD *)(v15 - 24);
              *(v17 - 1) = (unsigned __int8 *)*((_QWORD *)v15 - 1);
              *(_OWORD *)(v17 - 3) = v18;
              v17 -= 3;
              v15 -= 24;
            }
            while (v15 != v16);
            v15 = *(char **)this;
          }
          v5 = v14 + 3;
          *(_QWORD *)this = v17;
          *((_QWORD *)this + 1) = v14 + 3;
          *((_QWORD *)this + 2) = &v12[24 * v13];
          if (v15)
            operator delete(v15);
        }
        else
        {
          if (!v5)
            goto LABEL_24;
          *v5 = v3;
          v5[1] = v7;
          v5[2] = v8;
          v5 += 3;
        }
        *((_QWORD *)this + 1) = v5;
      }
      v3 += 16;
    }
    while (v3 != v4);
  }
}

void sub_1DBCE8700(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Backend::Google::LexicographicallyOrderedHashEnumerator::~LexicographicallyOrderedHashEnumerator(Backend::Google::LexicographicallyOrderedHashEnumerator *this)
{
  void *v2;

  v2 = *(void **)this;
  if (v2)
  {
    *((_QWORD *)this + 1) = v2;
    operator delete(v2);
  }
}

unsigned __int8 ***Backend::Google::LexicographicallyOrderedHashEnumerator::next@<X0>(unsigned __int8 ***this@<X0>, uint64_t a2@<X8>)
{
  unsigned __int8 **v3;
  unsigned __int8 **v4;
  unsigned __int8 ***v5;
  unsigned __int8 **v6;
  unsigned __int8 **v7;
  unsigned __int8 **v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned int v13;
  unsigned int v14;
  char v16;
  uint64_t v17;
  unsigned __int8 *v18;
  int64_t v19;

  v4 = *this;
  v3 = this[1];
  if (*this == v3)
  {
    v16 = 0;
    *(_BYTE *)a2 = 0;
LABEL_25:
    *(_BYTE *)(a2 + 16) = v16;
    return this;
  }
  v5 = this;
  v6 = v4 + 3;
  if (v4 + 3 == v3)
  {
    v7 = *this;
  }
  else
  {
    v7 = *this;
    do
    {
      v8 = v4;
      v4 = v6;
      if (*((_BYTE *)v7 + 8))
      {
        v9 = *((unsigned __int8 *)v8 + 32);
        v10 = v8[5];
        v11 = *((unsigned __int8 *)v7 + 8) - 1;
        v12 = v7[2];
        while (v9)
        {
          v13 = *v10;
          v14 = *v12;
          if (v13 < v14)
            break;
          ++v10;
          ++v12;
          --v9;
          if (v14 < v13 || v11-- == 0)
            goto LABEL_15;
        }
        v7 = v4;
      }
LABEL_15:
      v6 = v4 + 3;
    }
    while (v4 + 3 != v3);
  }
  v17 = *((unsigned __int8 *)v7 + 8);
  v18 = v7[2];
  v7[2] = &v18[v17];
  if (&v18[v17] != (unsigned __int8 *)(*((_QWORD *)*v7 + 1) + *((_DWORD *)*v7 + 1) * **v7))
  {
LABEL_24:
    *(_QWORD *)a2 = v17;
    *(_QWORD *)(a2 + 8) = v18;
    v16 = 1;
    goto LABEL_25;
  }
  if (v3 != v7)
  {
    v19 = (char *)v3 - (char *)(v7 + 3);
    if (v3 != v7 + 3)
      this = (unsigned __int8 ***)memmove(v7, v7 + 3, (char *)v3 - (char *)(v7 + 3));
    v5[1] = (unsigned __int8 **)((char *)v7 + v19);
    goto LABEL_24;
  }
  __break(1u);
  return this;
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::LexicographicallyOrderedHashEnumerator::Position>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(24 * a2);
}

SafeBrowsing::LookupContext *SafeBrowsing::LookupContext::LookupContext(SafeBrowsing::LookupContext *this)
{
  dispatch_queue_t v2;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  v2 = dispatch_queue_create("com.apple.Safari.SafeBrowsing.LookupContext", 0);
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = v2;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 18) = 1;
  *((_DWORD *)this + 28) = 1065353216;
  *((_OWORD *)this + 6) = 0u;
  _ZNSt3__115allocate_sharedB8sn180100IN12SafeBrowsing27BrowsingDatabaseCoordinatorENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((_QWORD *)this + 15);
  *((_DWORD *)this + 34) = 0;
  *((_QWORD *)this + 18) = std::system_category();
  *((_QWORD *)this + 19) = 0;
  *((_DWORD *)this + 40) = 65792;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 21) = 0;
  return this;
}

void sub_1DBCE896C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  uint64_t v11;
  void **v12;
  void **v13;
  std::__shared_weak_count *v15;

  v13 = v12;
  std::__hash_table<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>>>::~__hash_table(v11);
  a10 = v13;
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&a10);

  v15 = *(std::__shared_weak_count **)(v10 + 8);
  if (v15)
    std::__shared_weak_count::__release_weak(v15);
  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::~LookupContext(SafeBrowsing::LookupContext *this)
{
  int v2;
  int v3;
  int v4;
  std::__shared_weak_count *v5;
  void **v6;

  v2 = *((_DWORD *)this + 8);
  if (v2)
    notify_cancel(v2);
  v3 = *((_DWORD *)this + 9);
  if (v3)
    notify_cancel(v3);
  v4 = *((_DWORD *)this + 10);
  if (v4)
    notify_cancel(v4);
  v6 = (void **)((char *)this + 168);
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&v6);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 120);
  std::__hash_table<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>>>::~__hash_table((uint64_t)this + 80);
  v6 = (void **)((char *)this + 48);
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&v6);

  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
}

void sub_1DBCE8A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  std::__shared_weak_count *v12;

  a10 = (void **)(v10 + 168);
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&a10);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v10 + 120);
  std::__hash_table<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>>>::~__hash_table(v10 + 80);
  a10 = (void **)(v10 + 48);
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&a10);

  v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12)
    std::__shared_weak_count::__release_weak(v12);
  _Unwind_Resume(a1);
}

uint64_t SafeBrowsing::LookupContext::addDatabaseUpdateObserver(_QWORD *a1, uint64_t a2)
{
  unsigned int *v4;
  uint64_t v5;
  NSObject *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _QWORD *v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  _QWORD v30[3];
  _QWORD *v31;
  int v32;
  _QWORD block[5];
  std::__shared_weak_count *v34;
  _BYTE v35[24];
  _BYTE *v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = (unsigned int *)(a1 + 9);
  do
    v5 = __ldaxr(v4);
  while (__stlxr(v5 + 1, v4));
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v26, a1);
  v6 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext25addDatabaseUpdateObserverENSt3__18functionIFvN7Backend6Google21DatabaseConfigurationEEEE_block_invoke;
  block[3] = &__block_descriptor_88_ea8_32c131_ZTSKZN12SafeBrowsing13LookupContext25addDatabaseUpdateObserverENSt3__18functionIFvN7Backend6Google21DatabaseConfigurationEEEEE3__0_e5_v8__0l;
  v28 = v26;
  v29 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = v30;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v30, a2);
  v32 = v5;
  block[4] = v28;
  v34 = v29;
  if (v29)
  {
    v10 = (unint64_t *)&v29->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v12 = v35;
  v13 = (uint64_t)v31;
  if (!v31)
    goto LABEL_12;
  if (v31 != v30)
  {
    v13 = (*(uint64_t (**)(void))(*v31 + 16))();
LABEL_12:
    v36 = (_BYTE *)v13;
    goto LABEL_14;
  }
  v36 = v35;
  (*(void (**)(_QWORD *, _BYTE *))(v30[0] + 24))(v30, v35);
LABEL_14:
  v37 = v32;
  dispatch_async(v6, block);
  if (v31 == v30)
  {
    v14 = 4;
    goto LABEL_18;
  }
  if (v31)
  {
    v14 = 5;
    v9 = v31;
LABEL_18:
    (*(void (**)(_QWORD *))(*v9 + 8 * v14))(v9);
  }
  v15 = v29;
  if (v29)
  {
    v16 = (unint64_t *)&v29->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v36 == v35)
  {
    v18 = 4;
    goto LABEL_28;
  }
  if (v36)
  {
    v18 = 5;
    v12 = v36;
LABEL_28:
    (*(void (**)(_QWORD *))(*v12 + 8 * v18))(v12);
  }
  v19 = v34;
  if (v34)
  {
    v20 = (unint64_t *)&v34->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v27;
  if (v27)
  {
    v23 = (unint64_t *)&v27->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  return v5;
}

void sub_1DBCE8D1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c131_ZTSKZN12SafeBrowsing13LookupContext25addDatabaseUpdateObserverENSt3__18functionIFvN7Backend6Google21DatabaseConfigurationEEEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t result;

  v4 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  result = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  return result;
}

void sub_1DBCE8E18(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c131_ZTSKZN12SafeBrowsing13LookupContext25addDatabaseUpdateObserverENSt3__18functionIFvN7Backend6Google21DatabaseConfigurationEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

uint64_t SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 16);
  v3 = *(_QWORD **)(a1 + 40);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1);
}

void SafeBrowsing::LookupContext::removeDatabaseUpdateObserver(SafeBrowsing::LookupContext *this, int a2)
{
  NSObject *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD block[4];
  uint64_t v18;
  std::__shared_weak_count *v19;
  int v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v21, this);
  v4 = *((_QWORD *)this + 2);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext28removeDatabaseUpdateObserverEj_block_invoke;
  block[3] = &__block_descriptor_56_ea8_32c73_ZTSKZN12SafeBrowsing13LookupContext28removeDatabaseUpdateObserverEjE3__0_e5_v8__0l;
  v5 = v21;
  v6 = v22;
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v18 = v5;
    v19 = v6;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    v20 = a2;
    dispatch_async(v4, block);
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    v18 = v21;
    v19 = 0;
    v20 = a2;
    dispatch_async(v4, block);
  }
  v11 = v19;
  if (v19)
  {
    v12 = (unint64_t *)&v19->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v22;
  if (v22)
  {
    v15 = (unint64_t *)&v22->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

uint64_t __copy_helper_block_ea8_32c73_ZTSKZN12SafeBrowsing13LookupContext28removeDatabaseUpdateObserverEjE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

uint64_t __destroy_helper_block_ea8_32c73_ZTSKZN12SafeBrowsing13LookupContext28removeDatabaseUpdateObserverEjE3__0(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::forceDatabaseUpdate(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD v27[3];
  _QWORD *v28;
  _QWORD block[5];
  std::__shared_weak_count *v30;
  _BYTE v31[24];
  _BYTE *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v23, a1);
  v4 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext19forceDatabaseUpdateENSt3__18functionIFvNS1_10error_codeEEEE_block_invoke;
  block[3] = &__block_descriptor_80_ea8_32c102_ZTSKZN12SafeBrowsing13LookupContext19forceDatabaseUpdateENSt3__18functionIFvNS1_10error_codeEEEEE3__0_e5_v8__0l;
  v25 = v23;
  v26 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = v27;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v27, a2);
  block[4] = v25;
  v30 = v26;
  if (v26)
  {
    v8 = (unint64_t *)&v26->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = v31;
  v11 = (uint64_t)v28;
  if (!v28)
    goto LABEL_10;
  if (v28 != v27)
  {
    v11 = (*(uint64_t (**)(void))(*v28 + 16))();
LABEL_10:
    v32 = (_BYTE *)v11;
    goto LABEL_12;
  }
  v32 = v31;
  (*(void (**)(_QWORD *, _BYTE *))(v27[0] + 24))(v27, v31);
LABEL_12:
  dispatch_async(v4, block);
  if (v28 == v27)
  {
    v12 = 4;
    goto LABEL_16;
  }
  if (v28)
  {
    v12 = 5;
    v7 = v28;
LABEL_16:
    (*(void (**)(_QWORD *))(*v7 + 8 * v12))(v7);
  }
  v13 = v26;
  if (v26)
  {
    v14 = (unint64_t *)&v26->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v32 == v31)
  {
    v16 = 4;
    goto LABEL_26;
  }
  if (v32)
  {
    v16 = 5;
    v10 = v32;
LABEL_26:
    (*(void (**)(_QWORD *))(*v10 + 8 * v16))(v10);
  }
  v17 = v30;
  if (v30)
  {
    v18 = (unint64_t *)&v30->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1DBCE92A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing13LookupContext19forceDatabaseUpdateENSt3__18functionIFvNS1_10error_codeEEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  char *v5;
  id v6;

  SafeBrowsing::LookupContext::ensureConnection(*(SafeBrowsing::LookupContext **)(a1 + 32));
  SafeBrowsing::createMessage(1u);
  v6 = (id)objc_claimAutoreleasedReturnValue();
  xpc_connection_send_message(*(xpc_connection_t *)(*(_QWORD *)(a1 + 32) + 24), v6);
  v2 = *(uint64_t **)(a1 + 32);
  v3 = a1 + 48;
  v4 = v2[7];
  if (v4 >= v2[8])
  {
    v5 = std::vector<std::function<void ()(std::error_code)>>::__push_back_slow_path<std::function<void ()(std::error_code)> const&>(v2 + 6, v3);
    goto LABEL_5;
  }
  if (v4)
  {
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](v2[7], v3);
    v5 = (char *)(v4 + 32);
    v2[7] = v4 + 32;
LABEL_5:
    v2[7] = (uint64_t)v5;

    return;
  }
  __break(1u);
}

void sub_1DBCE9370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = v11;
  *(_QWORD *)(v12 + 56) = v10;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c102_ZTSKZN12SafeBrowsing13LookupContext19forceDatabaseUpdateENSt3__18functionIFvNS1_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCE93DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c102_ZTSKZN12SafeBrowsing13LookupContext19forceDatabaseUpdateENSt3__18functionIFvNS1_10error_codeEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::forceDeviceIdentificationTokenUpdate(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD v27[3];
  _QWORD *v28;
  _QWORD block[5];
  std::__shared_weak_count *v30;
  _BYTE v31[24];
  _BYTE *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v23, a1);
  v4 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext36forceDeviceIdentificationTokenUpdateENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke;
  block[3] = &__block_descriptor_80_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext36forceDeviceIdentificationTokenUpdateENSt3__18functionIFvbNS1_10error_codeEEEEE3__0_e5_v8__0l;
  v25 = v23;
  v26 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = v27;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v27, a2);
  block[4] = v25;
  v30 = v26;
  if (v26)
  {
    v8 = (unint64_t *)&v26->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = v31;
  v11 = (uint64_t)v28;
  if (!v28)
    goto LABEL_10;
  if (v28 != v27)
  {
    v11 = (*(uint64_t (**)(void))(*v28 + 16))();
LABEL_10:
    v32 = (_BYTE *)v11;
    goto LABEL_12;
  }
  v32 = v31;
  (*(void (**)(_QWORD *, _BYTE *))(v27[0] + 24))(v27, v31);
LABEL_12:
  dispatch_async(v4, block);
  if (v28 == v27)
  {
    v12 = 4;
    goto LABEL_16;
  }
  if (v28)
  {
    v12 = 5;
    v7 = v28;
LABEL_16:
    (*(void (**)(_QWORD *))(*v7 + 8 * v12))(v7);
  }
  v13 = v26;
  if (v26)
  {
    v14 = (unint64_t *)&v26->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v32 == v31)
  {
    v16 = 4;
    goto LABEL_26;
  }
  if (v32)
  {
    v16 = 5;
    v10 = v32;
LABEL_26:
    (*(void (**)(_QWORD *))(*v10 + 8 * v16))(v10);
  }
  v17 = v30;
  if (v30)
  {
    v18 = (unint64_t *)&v30->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1DBCE968C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing13LookupContext36forceDeviceIdentificationTokenUpdateENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  void *v3;
  uint64_t v4;
  _xpc_connection_s *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  _QWORD v24[3];
  _QWORD *v25;
  _QWORD handler[5];
  std::__shared_weak_count *v27;
  _BYTE v28[24];
  _BYTE *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)(a1 + 32);
  SafeBrowsing::LookupContext::ensureConnection(*(SafeBrowsing::LookupContext **)(a1 + 32));
  SafeBrowsing::createMessage(0xBu);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = *v2;
  v6 = *(NSObject **)(*v2 + 16);
  v5 = *(_xpc_connection_s **)(*v2 + 24);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZZN12SafeBrowsing13LookupContext36forceDeviceIdentificationTokenUpdateENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEv_block_invoke;
  handler[3] = &__block_descriptor_80_ea8_32c169_ZTSKZZN12SafeBrowsing13LookupContext36forceDeviceIdentificationTokenUpdateENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE__e33_v16__0__NSObject_OS_xpc_object__8l;
  v7 = *(std::__shared_weak_count **)(a1 + 40);
  v22 = v4;
  v23 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = v24;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v24, a1 + 48);
  handler[4] = v22;
  v27 = v23;
  if (v23)
  {
    v11 = (unint64_t *)&v23->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = v28;
  v14 = (uint64_t)v25;
  if (!v25)
    goto LABEL_10;
  if (v25 != v24)
  {
    v14 = (*(uint64_t (**)(void))(*v25 + 16))();
LABEL_10:
    v29 = (_BYTE *)v14;
    goto LABEL_12;
  }
  v29 = v28;
  (*(void (**)(_QWORD *, _BYTE *))(v24[0] + 24))(v24, v28);
LABEL_12:
  xpc_connection_send_message_with_reply(v5, v3, v6, handler);
  if (v25 == v24)
  {
    v15 = 4;
    goto LABEL_16;
  }
  if (v25)
  {
    v15 = 5;
    v10 = v25;
LABEL_16:
    (*(void (**)(_QWORD *))(*v10 + 8 * v15))(v10);
  }
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  if (v29 == v28)
  {
    v18 = 4;
    goto LABEL_26;
  }
  if (v29)
  {
    v18 = 5;
    v13 = v29;
LABEL_26:
    (*(void (**)(_QWORD *))(*v13 + 8 * v18))(v13);
  }
  v19 = v27;
  if (v27)
  {
    v20 = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

}

void sub_1DBCE98F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, _QWORD *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  void *v21;
  _QWORD *v22;
  unint64_t *p_shared_owners;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;

  if (a21)
  {
    p_shared_owners = (unint64_t *)&a21->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))a21->__on_zero_shared)(a21);
      std::__shared_weak_count::__release_weak(a21);
    }
  }
  if (a15 == v22)
  {
    v26 = 4;
  }
  else
  {
    if (!a15)
      goto LABEL_11;
    v26 = 5;
    v22 = a15;
  }
  (*(void (**)(_QWORD *))(*v22 + 8 * v26))(v22);
LABEL_11:
  if (a11)
  {
    v27 = (unint64_t *)&a11->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
      std::__shared_weak_count::__release_weak(a11);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext36forceDeviceIdentificationTokenUpdateENSt3__18functionIFvbNS1_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCE9A74(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext36forceDeviceIdentificationTokenUpdateENSt3__18functionIFvbNS1_10error_codeEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::handleForceDeviceIdentificationTokenUpdateReply(uint64_t a1, void *a2, uint64_t a3)
{
  id v4;
  char v5;
  const std::error_category *v6;
  uint64_t v7;
  const std::error_category *v8;
  const std::error_category *cat;
  NSObject *v10;
  std::string v11;
  std::error_code v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (MEMORY[0x1DF0B91F0]() == MEMORY[0x1E0C81310])
  {
    v7 = Platform::xpcErrorCode(v4);
    cat = v8;
    *(_QWORD *)&v12.__val_ = v7;
    v12.__cat_ = v8;
    if ((_DWORD)v7)
    {
      v10 = (id)SSBOSLogDatabase();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        std::error_code::message(&v11, &v12);
        SafeBrowsing::LookupContext::handleForceDeviceIdentificationTokenUpdateReply();
      }

      v7 = *(_QWORD *)&v12.__val_;
      cat = v12.__cat_;
    }
    std::function<void ()(BOOL,std::error_code)>::operator()(a3, 0, v7, (uint64_t)cat);
  }
  else
  {
    v5 = xpc_dictionary_get_BOOL(v4, "forceDeviceIdentificationTokenUpdateKey");
    v6 = std::system_category();
    std::function<void ()(BOOL,std::error_code)>::operator()(a3, v5, 0, (uint64_t)v6);
  }

}

void sub_1DBCE9BE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(BOOL,std::error_code)>::operator()(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  std::string *v6;
  char v7;
  _QWORD v8[2];

  v8[0] = a3;
  v8[1] = a4;
  v7 = a2;
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
    return (*(uint64_t (**)(uint64_t, char *, _QWORD *))(*(_QWORD *)v4 + 48))(v4, &v7, v8);
  v6 = std::__throw_bad_function_call[abi:sn180100]();
  return SafeBrowsing::LookupContext::getDatabaseStatus(v6);
}

void SafeBrowsing::LookupContext::getDatabaseStatus(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  __int128 v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  NSObject *v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  _QWORD *v15;
  char *v16;
  _BYTE *v17;
  NSObject *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  NSObject *v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  _QWORD v54[4];
  __int128 v55;
  __int128 v56;
  __int128 v57;
  _QWORD v58[3];
  _QWORD *v59;
  _QWORD block[4];
  __int128 v61;
  _BYTE v62[24];
  _BYTE *v63;
  __int128 v64;
  NSObject *v65;
  _QWORD v66[3];
  _QWORD *v67;
  _BYTE v68[24];
  _BYTE *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v56, a1);
  v4 = a1[2];
  v5 = MEMORY[0x1E0C809B0];
  v54[0] = MEMORY[0x1E0C809B0];
  v54[1] = 3321888768;
  v54[2] = ___ZN12SafeBrowsing13LookupContext17getDatabaseStatusENSt3__18functionIFvNS_14DatabaseStatusENS1_10error_codeEEEE_block_invoke;
  v54[3] = &__block_descriptor_48_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext17getDatabaseStatusENSt3__18functionIFvNS_14DatabaseStatusENS1_10error_codeEEEEE3__0_e5_v8__0l;
  v6 = v56;
  if (*((_QWORD *)&v56 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v55 = v6;
    do
      v9 = __ldxr(v7);
    while (__stxr(v9 + 1, v7));
    dispatch_async(v4, v54);
    do
      v10 = __ldaxr(v7);
    while (__stlxr(v10 - 1, v7));
    if (!v10)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v6 + 1) + 16))(*((_QWORD *)&v6 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v6 + 1));
    }
  }
  else
  {
    v55 = (unint64_t)v56;
    dispatch_async(v4, v54);
  }
  v11 = dispatch_group_create();
  dispatch_group_enter(v11);
  v64 = v56;
  if (*((_QWORD *)&v56 + 1))
  {
    v12 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = v11;
  v65 = v14;
  v15 = v66;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v66, a2);
  v69 = 0;
  v16 = (char *)operator new(0x40uLL);
  v17 = v16;
  *(_QWORD *)v16 = off_1EA3E9E28;
  *(_OWORD *)(v16 + 8) = v64;
  v64 = 0uLL;
  v18 = v65;
  v19 = v67;
  v65 = 0;
  *((_QWORD *)v16 + 3) = v18;
  if (v19)
  {
    if (v19 == v66)
    {
      *((_QWORD *)v16 + 7) = v16 + 32;
      (*(void (**)(_QWORD *))(v66[0] + 24))(v66);
    }
    else
    {
      *((_QWORD *)v16 + 7) = v19;
      v67 = 0;
    }
  }
  else
  {
    *((_QWORD *)v16 + 7) = 0;
  }
  v69 = v17;
  SafeBrowsing::LookupContext::dispatchWhenDatabasesAreAvailable(a1, 1, (uint64_t)v68);
  v23 = v69;
  if (v69 == v68)
  {
    v24 = 4;
    v23 = v68;
  }
  else
  {
    if (!v69)
      goto LABEL_24;
    v24 = 5;
  }
  (*(void (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v23 + 8 * v24))(v23, v20, v21, v22);
LABEL_24:
  if (v67 == v66)
  {
    v25 = 4;
    goto LABEL_28;
  }
  if (v67)
  {
    v25 = 5;
    v15 = v67;
LABEL_28:
    (*(void (**)(_QWORD *))(*v15 + 8 * v25))(v15);
  }

  v26 = (std::__shared_weak_count *)*((_QWORD *)&v64 + 1);
  if (*((_QWORD *)&v64 + 1))
  {
    v27 = (unint64_t *)(*((_QWORD *)&v64 + 1) + 8);
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = a1[2];
  block[0] = v5;
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext17getDatabaseStatusENSt3__18functionIFvNS_14DatabaseStatusENS1_10error_codeEEEE_block_invoke_7;
  block[3] = &__block_descriptor_80_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext17getDatabaseStatusENSt3__18functionIFvNS_14DatabaseStatusENS1_10error_codeEEEEE3__2_e5_v8__0l;
  v57 = v56;
  if (*((_QWORD *)&v56 + 1))
  {
    v30 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v32 = v58;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v58, a2);
  v61 = v57;
  if (*((_QWORD *)&v57 + 1))
  {
    v36 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v37 = __ldxr(v36);
    while (__stxr(v37 + 1, v36));
  }
  v38 = v62;
  v39 = (uint64_t)v59;
  if (!v59)
    goto LABEL_43;
  if (v59 != v58)
  {
    v39 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v59 + 16))(v59, v33, v34, v35);
LABEL_43:
    v63 = (_BYTE *)v39;
    goto LABEL_45;
  }
  v63 = v62;
  (*(void (**)(_QWORD *, _BYTE *))(v58[0] + 24))(v58, v62);
LABEL_45:
  dispatch_group_notify(v14, v29, block);
  if (v59 == v58)
  {
    v40 = 4;
    goto LABEL_49;
  }
  if (v59)
  {
    v40 = 5;
    v32 = v59;
LABEL_49:
    (*(void (**)(_QWORD *))(*v32 + 8 * v40))(v32);
  }
  v41 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  if (*((_QWORD *)&v57 + 1))
  {
    v42 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }
  if (v63 == v62)
  {
    v44 = 4;
    goto LABEL_59;
  }
  if (v63)
  {
    v44 = 5;
    v38 = v63;
LABEL_59:
    (*(void (**)(_QWORD *))(*v38 + 8 * v44))(v38);
  }
  v45 = (std::__shared_weak_count *)*((_QWORD *)&v61 + 1);
  if (*((_QWORD *)&v61 + 1))
  {
    v46 = (unint64_t *)(*((_QWORD *)&v61 + 1) + 8);
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }

  v48 = (std::__shared_weak_count *)*((_QWORD *)&v55 + 1);
  if (*((_QWORD *)&v55 + 1))
  {
    v49 = (unint64_t *)(*((_QWORD *)&v55 + 1) + 8);
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
  v51 = (std::__shared_weak_count *)*((_QWORD *)&v56 + 1);
  if (*((_QWORD *)&v56 + 1))
  {
    v52 = (unint64_t *)(*((_QWORD *)&v56 + 1) + 8);
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
}

void sub_1DBCEA0F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  uint64_t v6;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  va_list va1;
  uint64_t v13;
  va_list va2;

  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v11 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v6);
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va2);

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext17getDatabaseStatusENSt3__18functionIFvNS_14DatabaseStatusENS1_10error_codeEEEEE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext17getDatabaseStatusENSt3__18functionIFvNS_14DatabaseStatusENS1_10error_codeEEEEE3__0(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::dispatchWhenDatabasesAreAvailable(_QWORD *a1, int a2, uint64_t a3)
{
  NSObject *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _QWORD *v9;
  unint64_t *v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  int v29;
  _QWORD v30[3];
  _QWORD *v31;
  _QWORD block[5];
  std::__shared_weak_count *v33;
  int v34;
  _BYTE v35[24];
  _BYTE *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v25, a1);
  v6 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext33dispatchWhenDatabasesAreAvailableEN7Backend6Google14ProtectionTypeENSt3__18functionIFvNS4_10error_codeEEEE_block_invoke;
  block[3] = &__block_descriptor_88_ea8_32c149_ZTSKZN12SafeBrowsing13LookupContext33dispatchWhenDatabasesAreAvailableEN7Backend6Google14ProtectionTypeENSt3__18functionIFvNS4_10error_codeEEEEE3__0_e5_v8__0l;
  v27 = v25;
  v28 = v26;
  if (v26)
  {
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v29 = a2;
  v9 = v30;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v30, a3);
  block[4] = v27;
  v33 = v28;
  if (v28)
  {
    v10 = (unint64_t *)&v28->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  v34 = v29;
  v12 = v35;
  v13 = (uint64_t)v31;
  if (!v31)
    goto LABEL_10;
  if (v31 != v30)
  {
    v13 = (*(uint64_t (**)(void))(*v31 + 16))();
LABEL_10:
    v36 = (_BYTE *)v13;
    goto LABEL_12;
  }
  v36 = v35;
  (*(void (**)(_QWORD *, _BYTE *))(v30[0] + 24))(v30, v35);
LABEL_12:
  dispatch_async(v6, block);
  if (v31 == v30)
  {
    v14 = 4;
    goto LABEL_16;
  }
  if (v31)
  {
    v14 = 5;
    v9 = v31;
LABEL_16:
    (*(void (**)(_QWORD *))(*v9 + 8 * v14))(v9);
  }
  v15 = v28;
  if (v28)
  {
    v16 = (unint64_t *)&v28->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v36 == v35)
  {
    v18 = 4;
    goto LABEL_26;
  }
  if (v36)
  {
    v18 = 5;
    v12 = v36;
LABEL_26:
    (*(void (**)(_QWORD *))(*v12 + 8 * v18))(v12);
  }
  v19 = v33;
  if (v33)
  {
    v20 = (unint64_t *)&v33->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v22 = v26;
  if (v26)
  {
    v23 = (unint64_t *)&v26->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
}

void sub_1DBCEA44C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  SafeBrowsing::LookupContext::dispatchWhenDatabasesAreAvailable(Backend::Google::ProtectionType,std::function<void ()(std::error_code)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1::~$_1(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 24);
  v3 = *(_QWORD **)(a1 + 48);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1);
}

void ___ZN12SafeBrowsing13LookupContext17getDatabaseStatusENSt3__18functionIFvNS_14DatabaseStatusENS1_10error_codeEEEE_block_invoke_7(uint64_t a1)
{
  SafeBrowsing::LookupContext *v2;
  void **v3;
  const std::error_category *v4;
  uint64_t v5;
  const std::error_category *v6;
  _QWORD v7[3];
  void **v8;
  const std::error_category *v9;

  v2 = *(SafeBrowsing::LookupContext **)(a1 + 32);
  v3 = (void **)*((_QWORD *)v2 + 17);
  if ((_DWORD)v3)
  {
    v4 = (const std::error_category *)*((_QWORD *)v2 + 18);
    memset(v7, 0, sizeof(v7));
    v8 = v3;
    v9 = v4;
    v5 = *(_QWORD *)(a1 + 72);
    if (v5)
      goto LABEL_5;
    std::__throw_bad_function_call[abi:sn180100]();
  }
  else
  {
    SafeBrowsing::LookupContext::databaseStatus(v2, (uint64_t)v7);
    v6 = std::system_category();
    v8 = 0;
    v9 = v6;
    v5 = *(_QWORD *)(a1 + 72);
    if (v5)
    {
LABEL_5:
      (*(void (**)(uint64_t, _QWORD *, void ***))(*(_QWORD *)v5 + 48))(v5, v7, &v8);
      v8 = (void **)v7;
      std::vector<SafeBrowsing::DatabaseStatus::Database>::__destroy_vector::operator()[abi:sn180100](&v8);
      return;
    }
    std::__throw_bad_function_call[abi:sn180100]();
  }
  __break(1u);
}

void sub_1DBCEA590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  *(_QWORD *)(v9 - 24) = &a9;
  std::vector<SafeBrowsing::DatabaseStatus::Database>::__destroy_vector::operator()[abi:sn180100]((void ***)(v9 - 24));
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext17getDatabaseStatusENSt3__18functionIFvNS_14DatabaseStatusENS1_10error_codeEEEEE3__2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCEA5F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext17getDatabaseStatusENSt3__18functionIFvNS_14DatabaseStatusENS1_10error_codeEEEEE3__2(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::getServiceStatus(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD v27[3];
  _QWORD *v28;
  _QWORD block[5];
  std::__shared_weak_count *v30;
  _BYTE v31[24];
  _BYTE *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v23, a1);
  v4 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext16getServiceStatusENSt3__18functionIFvNS_13ServiceStatusENS1_10error_codeEEEE_block_invoke;
  block[3] = &__block_descriptor_80_ea8_32c118_ZTSKZN12SafeBrowsing13LookupContext16getServiceStatusENSt3__18functionIFvNS_13ServiceStatusENS1_10error_codeEEEEE3__0_e5_v8__0l;
  v25 = v23;
  v26 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = v27;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v27, a2);
  block[4] = v25;
  v30 = v26;
  if (v26)
  {
    v8 = (unint64_t *)&v26->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = v31;
  v11 = (uint64_t)v28;
  if (!v28)
    goto LABEL_10;
  if (v28 != v27)
  {
    v11 = (*(uint64_t (**)(void))(*v28 + 16))();
LABEL_10:
    v32 = (_BYTE *)v11;
    goto LABEL_12;
  }
  v32 = v31;
  (*(void (**)(_QWORD *, _BYTE *))(v27[0] + 24))(v27, v31);
LABEL_12:
  dispatch_async(v4, block);
  if (v28 == v27)
  {
    v12 = 4;
    goto LABEL_16;
  }
  if (v28)
  {
    v12 = 5;
    v7 = v28;
LABEL_16:
    (*(void (**)(_QWORD *))(*v7 + 8 * v12))(v7);
  }
  v13 = v26;
  if (v26)
  {
    v14 = (unint64_t *)&v26->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v32 == v31)
  {
    v16 = 4;
    goto LABEL_26;
  }
  if (v32)
  {
    v16 = 5;
    v10 = v32;
LABEL_26:
    (*(void (**)(_QWORD *))(*v10 + 8 * v16))(v10);
  }
  v17 = v30;
  if (v30)
  {
    v18 = (unint64_t *)&v30->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1DBCEA8A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing13LookupContext16getServiceStatusENSt3__18functionIFvNS_13ServiceStatusENS1_10error_codeEEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  void *v3;
  uint64_t v4;
  _xpc_connection_s *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  _QWORD v24[3];
  _QWORD *v25;
  _QWORD handler[5];
  std::__shared_weak_count *v27;
  _BYTE v28[24];
  _BYTE *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)(a1 + 32);
  SafeBrowsing::LookupContext::ensureConnection(*(SafeBrowsing::LookupContext **)(a1 + 32));
  SafeBrowsing::createMessage(3u);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = *v2;
  v6 = *(NSObject **)(*v2 + 16);
  v5 = *(_xpc_connection_s **)(*v2 + 24);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZZN12SafeBrowsing13LookupContext16getServiceStatusENSt3__18functionIFvNS_13ServiceStatusENS1_10error_codeEEEEENK3__0clEv_block_invoke;
  handler[3] = &__block_descriptor_80_ea8_32c167_ZTSKZZN12SafeBrowsing13LookupContext16getServiceStatusENSt3__18functionIFvNS_13ServiceStatusENS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE__e33_v16__0__NSObject_OS_xpc_object__8l;
  v7 = *(std::__shared_weak_count **)(a1 + 40);
  v22 = v4;
  v23 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = v24;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v24, a1 + 48);
  handler[4] = v22;
  v27 = v23;
  if (v23)
  {
    v11 = (unint64_t *)&v23->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = v28;
  v14 = (uint64_t)v25;
  if (!v25)
    goto LABEL_10;
  if (v25 != v24)
  {
    v14 = (*(uint64_t (**)(void))(*v25 + 16))();
LABEL_10:
    v29 = (_BYTE *)v14;
    goto LABEL_12;
  }
  v29 = v28;
  (*(void (**)(_QWORD *, _BYTE *))(v24[0] + 24))(v24, v28);
LABEL_12:
  xpc_connection_send_message_with_reply(v5, v3, v6, handler);
  if (v25 == v24)
  {
    v15 = 4;
    goto LABEL_16;
  }
  if (v25)
  {
    v15 = 5;
    v10 = v25;
LABEL_16:
    (*(void (**)(_QWORD *))(*v10 + 8 * v15))(v10);
  }
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  if (v29 == v28)
  {
    v18 = 4;
    goto LABEL_26;
  }
  if (v29)
  {
    v18 = 5;
    v13 = v29;
LABEL_26:
    (*(void (**)(_QWORD *))(*v13 + 8 * v18))(v13);
  }
  v19 = v27;
  if (v27)
  {
    v20 = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

}

void sub_1DBCEAB14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, _QWORD *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  void *v21;
  _QWORD *v22;
  unint64_t *p_shared_owners;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;

  if (a21)
  {
    p_shared_owners = (unint64_t *)&a21->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))a21->__on_zero_shared)(a21);
      std::__shared_weak_count::__release_weak(a21);
    }
  }
  if (a15 == v22)
  {
    v26 = 4;
  }
  else
  {
    if (!a15)
      goto LABEL_11;
    v26 = 5;
    v22 = a15;
  }
  (*(void (**)(_QWORD *))(*v22 + 8 * v26))(v22);
LABEL_11:
  if (a11)
  {
    v27 = (unint64_t *)&a11->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
      std::__shared_weak_count::__release_weak(a11);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c118_ZTSKZN12SafeBrowsing13LookupContext16getServiceStatusENSt3__18functionIFvNS_13ServiceStatusENS1_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCEAC90(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c118_ZTSKZN12SafeBrowsing13LookupContext16getServiceStatusENSt3__18functionIFvNS_13ServiceStatusENS1_10error_codeEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::lookUpURL(_QWORD *a1, void *a2, int a3, uint64_t a4)
{
  id v7;
  NSObject *v8;
  NSObject *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD *v15;
  char *v16;
  _BYTE *v17;
  id v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  __int128 v34;
  __int128 v35;
  id v36;
  _QWORD v37[3];
  _QWORD *v38;
  _BYTE v39[24];
  _BYTE *v40;
  _BYTE v41[24];
  _BYTE *v42;
  _QWORD v43[3];
  _QWORD *v44;
  _QWORD block[4];
  _BYTE v46[24];
  _BYTE *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v34, a1);
  if (!objc_msgSend(v7, "ssb_isSafeURL"))
  {
    v12 = (_QWORD *)v34;
    if (!a3)
    {
      std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v41, a4);
      SafeBrowsing::LookupContext::performURLLookup(v12, v7, (uint64_t)v41);
      v20 = v42;
      if (v42 == v41)
      {
        v21 = 4;
        v20 = v41;
      }
      else
      {
        if (!v42)
          goto LABEL_48;
        v21 = 5;
      }
      (*(void (**)(_QWORD *))(*v20 + 8 * v21))(v20);
      goto LABEL_48;
    }
    v35 = v34;
    if (*((_QWORD *)&v34 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v34 + 1) + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    v36 = v7;
    v15 = v37;
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v37, a4);
    v40 = 0;
    v16 = (char *)operator new(0x40uLL);
    v17 = v16;
    *(_QWORD *)v16 = off_1EA3E9E70;
    *(_OWORD *)(v16 + 8) = v35;
    v35 = 0uLL;
    v18 = v36;
    v19 = v38;
    v36 = 0;
    *((_QWORD *)v16 + 3) = v18;
    if (v19)
    {
      if (v19 == v37)
      {
        *((_QWORD *)v16 + 7) = v16 + 32;
        (*(void (**)(_QWORD *))(v37[0] + 24))(v37);
      }
      else
      {
        *((_QWORD *)v16 + 7) = v19;
        v38 = 0;
      }
    }
    else
    {
      *((_QWORD *)v16 + 7) = 0;
    }
    v40 = v17;
    SafeBrowsing::LookupContext::getSafeBrowsingEnabledState(a1, (uint64_t)v39);
    v25 = v40;
    if (v40 == v39)
    {
      v26 = 4;
      v25 = v39;
    }
    else
    {
      if (!v40)
        goto LABEL_36;
      v26 = 5;
    }
    (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_36:
    if (v38 == v37)
    {
      v27 = 4;
    }
    else
    {
      if (!v38)
      {
LABEL_41:

        v28 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
        if (*((_QWORD *)&v35 + 1))
        {
          v29 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
        goto LABEL_48;
      }
      v27 = 5;
      v15 = v38;
    }
    (*(void (**)(_QWORD *))(*v15 + 8 * v27))(v15);
    goto LABEL_41;
  }
  v8 = SSBOSLogLookup();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    SafeBrowsing::LookupContext::lookUpURL((uint64_t)v7, v8);
  v9 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext9lookUpURLEP5NSURLNS_17IgnoreEnableStateENSt3__18functionIFvNS4_6vectorIN7Backend12LookupResultENS4_9allocatorIS8_EEEENS4_10error_codeEEEE_block_invoke;
  block[3] = &__block_descriptor_64_ea8_32c179_ZTSKZN12SafeBrowsing13LookupContext9lookUpURLEP5NSURLNS_17IgnoreEnableStateENSt3__18functionIFvNS4_6vectorIN7Backend12LookupResultENS4_9allocatorIS8_EEEENS4_10error_codeEEEEE3__0_e5_v8__0l;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v43, a4);
  v10 = v46;
  v11 = (uint64_t)v44;
  if (!v44)
    goto LABEL_7;
  if (v44 != v43)
  {
    v11 = (*(uint64_t (**)(void))(*v44 + 16))();
LABEL_7:
    v47 = (_BYTE *)v11;
    goto LABEL_20;
  }
  v47 = v46;
  (*(void (**)(_QWORD *, _BYTE *))(v43[0] + 24))(v43, v46);
LABEL_20:
  dispatch_async(v9, block);
  v22 = v44;
  if (v44 == v43)
  {
    v23 = 4;
    v22 = v43;
    goto LABEL_24;
  }
  if (v44)
  {
    v23 = 5;
LABEL_24:
    (*(void (**)(void))(*v22 + 8 * v23))();
  }
  if (v47 == v46)
  {
    v24 = 4;
    goto LABEL_29;
  }
  if (v47)
  {
    v24 = 5;
    v10 = v47;
LABEL_29:
    (*(void (**)(_QWORD *))(*v10 + 8 * v24))(v10);
  }
LABEL_48:
  v31 = (std::__shared_weak_count *)*((_QWORD *)&v34 + 1);
  if (*((_QWORD *)&v34 + 1))
  {
    v32 = (unint64_t *)(*((_QWORD *)&v34 + 1) + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }

}

void sub_1DBCEB07C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,char *a25)
{
  void *v25;
  char *v26;
  char *v28;
  uint64_t v29;

  v28 = a25;
  if (a25 == v26)
  {
    v29 = 4;
    v28 = &a22;
  }
  else
  {
    if (!a25)
      goto LABEL_6;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_6:
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing13LookupContext9lookUpURLEP5NSURLNS_17IgnoreEnableStateENSt3__18functionIFvNS4_6vectorIN7Backend12LookupResultENS4_9allocatorIS8_EEEENS4_10error_codeEEEE_block_invoke(uint64_t a1)
{
  char *v2;
  char *v3;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  int64_t v16;
  char *v17;
  const std::error_category *v18;
  uint64_t v19;
  void *v20;
  void *__dst;
  uint64_t v22;
  void *__p;
  char *v24;
  char *v25;
  _QWORD v26[2];

  v2 = (char *)operator new(8uLL);
  *(_QWORD *)v2 = 0x100000000;
  v3 = v2 + 8;
  v24 = v2 + 8;
  v25 = v2 + 8;
  __p = v2;
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent((Backend::Google::SSBUtilities *)v2);
  if ((_DWORD)shouldConsultWithTencent)
  {
    v5 = (char *)operator new(0x10uLL);
    v3 = v5 + 16;
    *(_QWORD *)v5 = *(_QWORD *)v2;
    *((_QWORD *)v5 + 1) = 0x200000000;
    __p = v5;
    v25 = v5 + 16;
    operator delete(v2);
    v24 = v5 + 16;
    v2 = v5;
  }
  if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
  {
    v6 = v3 - v2;
    v7 = (v3 - v2) >> 3;
    v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) >> 61)
      abort();
    if (v6 >> 2 > v8)
      v8 = v6 >> 2;
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8)
      v9 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v9 = v8;
    if (!v9)
      goto LABEL_28;
    v10 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>((uint64_t)&v25, v9);
    if (!v10)
      goto LABEL_28;
    v12 = &v10[8 * v11];
    v2 = &v10[8 * v7];
    *(_QWORD *)v2 = 0x400000000;
    v3 = v2 + 8;
    v14 = (char *)__p;
    v13 = v24;
    if (v24 != __p)
    {
      do
      {
        v15 = *((_QWORD *)v13 - 1);
        v13 -= 8;
        *((_QWORD *)v2 - 1) = v15;
        v2 -= 8;
      }
      while (v13 != v14);
      v13 = (char *)__p;
    }
    __p = v2;
    v24 = v3;
    v25 = v12;
    if (v13)
    {
      operator delete(v13);
      v2 = (char *)__p;
    }
    v24 = v3;
  }
  v20 = 0;
  __dst = 0;
  v22 = 0;
  v16 = v3 - v2;
  if (v3 != v2)
  {
    std::vector<Backend::LookupResult>::__vallocate[abi:sn180100](&v20, v16 >> 3);
    v17 = (char *)__dst;
    memmove(__dst, v2, v16);
    __dst = &v17[8 * (v16 >> 3)];
  }
  v18 = std::system_category();
  v26[0] = 0;
  v26[1] = v18;
  v19 = *(_QWORD *)(a1 + 56);
  if (!v19)
  {
    std::__throw_bad_function_call[abi:sn180100]();
LABEL_28:
    __break(1u);
    return;
  }
  (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)v19 + 48))(v19, &v20, v26);
  if (v20)
  {
    __dst = v20;
    operator delete(v20);
  }
  if (__p)
  {
    v24 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1DBCEB314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_ea8_32c179_ZTSKZN12SafeBrowsing13LookupContext9lookUpURLEP5NSURLNS_17IgnoreEnableStateENSt3__18functionIFvNS4_6vectorIN7Backend12LookupResultENS4_9allocatorIS8_EEEENS4_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 32, a2 + 32);
}

_QWORD *__destroy_helper_block_ea8_32c179_ZTSKZN12SafeBrowsing13LookupContext9lookUpURLEP5NSURLNS_17IgnoreEnableStateENSt3__18functionIFvNS4_6vectorIN7Backend12LookupResultENS4_9allocatorIS8_EEEENS4_10error_codeEEEEE3__0(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 32);
  result = *(_QWORD **)(a1 + 56);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void SafeBrowsing::LookupContext::performURLLookup(_QWORD *a1, void *a2, uint64_t a3)
{
  id v5;
  unint64_t *v6;
  unint64_t v7;
  id v8;
  _QWORD *v9;
  char *v10;
  _BYTE *v11;
  id v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  __int128 v23;
  __int128 v24;
  id v25;
  _QWORD v26[3];
  _QWORD *v27;
  _BYTE v28[24];
  _BYTE *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v23, a1);
  v24 = v23;
  if (*((_QWORD *)&v23 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = v5;
  v25 = v8;
  v9 = v26;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v26, a3);
  v29 = 0;
  v10 = (char *)operator new(0x40uLL);
  v11 = v10;
  *(_QWORD *)v10 = off_1EA3E9DE0;
  *(_OWORD *)(v10 + 8) = v24;
  v24 = 0uLL;
  v12 = v25;
  v13 = v27;
  v25 = 0;
  *((_QWORD *)v10 + 3) = v12;
  if (v13)
  {
    if (v13 == v26)
    {
      *((_QWORD *)v10 + 7) = v10 + 32;
      (*(void (**)(_QWORD *))(v26[0] + 24))(v26);
    }
    else
    {
      *((_QWORD *)v10 + 7) = v13;
      v27 = 0;
    }
  }
  else
  {
    *((_QWORD *)v10 + 7) = 0;
  }
  v29 = v11;
  SafeBrowsing::LookupContext::dispatchWhenDatabasesAreAvailable(a1, 1, (uint64_t)v28);
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_14;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_14:
  if (v27 == v26)
  {
    v16 = 4;
    goto LABEL_18;
  }
  if (v27)
  {
    v16 = 5;
    v9 = v27;
LABEL_18:
    (*(void (**)(_QWORD *))(*v9 + 8 * v16))(v9);
  }

  v17 = (std::__shared_weak_count *)*((_QWORD *)&v24 + 1);
  if (*((_QWORD *)&v24 + 1))
  {
    v18 = (unint64_t *)(*((_QWORD *)&v24 + 1) + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = (std::__shared_weak_count *)*((_QWORD *)&v23 + 1);
  if (*((_QWORD *)&v23 + 1))
  {
    v21 = (unint64_t *)(*((_QWORD *)&v23 + 1) + 8);
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

}

void sub_1DBCEB5A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char *a21)
{
  void *v21;
  char *v22;
  char *v24;
  uint64_t v25;

  v24 = a21;
  if (a21 == v22)
  {
    v25 = 4;
    v24 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1::~$_1((uint64_t)&a11);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::getSafeBrowsingEnabledState(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD v27[3];
  _QWORD *v28;
  _QWORD block[5];
  std::__shared_weak_count *v30;
  _BYTE v31[24];
  _BYTE *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v23, a1);
  v4 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke;
  block[3] = &__block_descriptor_80_ea8_32c111_ZTSKZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEEE3__0_e5_v8__0l;
  v25 = v23;
  v26 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = v27;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v27, a2);
  block[4] = v25;
  v30 = v26;
  if (v26)
  {
    v8 = (unint64_t *)&v26->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = v31;
  v11 = (uint64_t)v28;
  if (!v28)
    goto LABEL_10;
  if (v28 != v27)
  {
    v11 = (*(uint64_t (**)(void))(*v28 + 16))();
LABEL_10:
    v32 = (_BYTE *)v11;
    goto LABEL_12;
  }
  v32 = v31;
  (*(void (**)(_QWORD *, _BYTE *))(v27[0] + 24))(v27, v31);
LABEL_12:
  dispatch_async(v4, block);
  if (v28 == v27)
  {
    v12 = 4;
    goto LABEL_16;
  }
  if (v28)
  {
    v12 = 5;
    v7 = v28;
LABEL_16:
    (*(void (**)(_QWORD *))(*v7 + 8 * v12))(v7);
  }
  v13 = v26;
  if (v26)
  {
    v14 = (unint64_t *)&v26->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v32 == v31)
  {
    v16 = 4;
    goto LABEL_26;
  }
  if (v32)
  {
    v16 = 5;
    v10 = v32;
LABEL_26:
    (*(void (**)(_QWORD *))(*v10 + 8 * v16))(v10);
  }
  v17 = v30;
  if (v30)
  {
    v18 = (unint64_t *)&v30->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1DBCEB870(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::getLastDatabaseUpdateTime(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v11, a1);
  v4 = a1[15];
  v5 = v11;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v13, a2);
  (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v4 + 48))(v4, v5, v13);
  v6 = v14;
  if (v14 == v13)
  {
    v7 = 4;
    v6 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_6;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_6:
  v8 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_1DBCEB9A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a15;
  if (a15 == v15)
  {
    v18 = 4;
    v17 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::ensureConnection(SafeBrowsing::LookupContext *this)
{
  xpc_connection_t mach_service;
  void *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _xpc_connection_s *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(uint64_t, void *);
  void *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;

  if (!*((_QWORD *)this + 3))
  {
    mach_service = xpc_connection_create_mach_service("com.apple.Safari.SafeBrowsing.Service", *((dispatch_queue_t *)this + 2), 0);
    v3 = (void *)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = mach_service;

    std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v19, this);
    v5 = v19;
    v4 = v20;
    if (v20)
    {
      p_shared_weak_owners = (unint64_t *)&v20->__shared_weak_owners_;
      do
        v7 = __ldxr(p_shared_weak_owners);
      while (__stxr(v7 + 1, p_shared_weak_owners));
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
      v10 = (_xpc_connection_s *)*((_QWORD *)this + 3);
      v13 = MEMORY[0x1E0C809B0];
      v14 = 3321888768;
      v15 = ___ZN12SafeBrowsing13LookupContext16ensureConnectionEv_block_invoke;
      v16 = &__block_descriptor_48_ea8_32c61_ZTSKZN12SafeBrowsing13LookupContext16ensureConnectionEvE3__0_e33_v16__0__NSObject_OS_xpc_object__8l;
      do
        v11 = __ldxr(p_shared_weak_owners);
      while (__stxr(v11 + 1, p_shared_weak_owners));
      v17 = v5;
      v18 = v4;
      do
        v12 = __ldxr(p_shared_weak_owners);
      while (__stxr(v12 + 1, p_shared_weak_owners));
    }
    else
    {
      v10 = (_xpc_connection_s *)*((_QWORD *)this + 3);
      v13 = MEMORY[0x1E0C809B0];
      v14 = 3321888768;
      v15 = ___ZN12SafeBrowsing13LookupContext16ensureConnectionEv_block_invoke;
      v16 = &__block_descriptor_48_ea8_32c61_ZTSKZN12SafeBrowsing13LookupContext16ensureConnectionEvE3__0_e33_v16__0__NSObject_OS_xpc_object__8l;
      v17 = v19;
      v18 = 0;
    }
    xpc_connection_set_event_handler(v10, &v13);
    if (v4)
      std::__shared_weak_count::__release_weak(v4);
    xpc_connection_resume(*((xpc_connection_t *)this + 3));
    SafeBrowsing::LookupContext::registerForUpdateNotifications(this);
    if (v18)
      std::__shared_weak_count::__release_weak(v18);
    if (v4)
      std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_1DBCEBB6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  std::__shared_weak_count *v14;

  if (a14)
    std::__shared_weak_count::__release_weak(a14);
  if (v14)
  {
    std::__shared_weak_count::__release_weak(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN12SafeBrowsing13LookupContext16ensureConnectionEv_block_invoke(uint64_t a1, void *a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  id v9;

  v9 = a2;
  v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)(a1 + 32);
      if (v6)
        SafeBrowsing::LookupContext::handleConnectionEvent(v6, v9);
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }

}

void sub_1DBCEBC48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11)
{
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a11);

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c61_ZTSKZN12SafeBrowsing13LookupContext16ensureConnectionEvE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_ea8_32c61_ZTSKZN12SafeBrowsing13LookupContext16ensureConnectionEvE3__0(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void SafeBrowsing::LookupContext::registerForUpdateNotifications(SafeBrowsing::LookupContext *this)
{
  Backend::Google::SSBUtilities *v2;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;

  SafeBrowsing::LookupContext::registerForUpdateNotificationsForProvider(this, "com.apple.Safari.SafeBrowsing.DidFinishGoogleDatabaseUpdate", *((_DWORD *)this + 8), 1);
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(v2);
  if ((_DWORD)shouldConsultWithTencent)
    SafeBrowsing::LookupContext::registerForUpdateNotificationsForProvider(this, "com.apple.Safari.SafeBrowsing.DidFinishTencentDatabaseUpdate", *((_DWORD *)this + 9), 2);
  if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
    SafeBrowsing::LookupContext::registerForUpdateNotificationsForProvider(this, "com.apple.Safari.SafeBrowsing.DidFinishAppleDatabaseUpdate", *((_DWORD *)this + 10), 3);
}

void SafeBrowsing::LookupContext::registerForUpdateNotificationsForProvider(_QWORD *a1, const char *a2, int a3, int a4)
{
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  NSObject *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(uint64_t);
  void *v19;
  int v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  int out_token;

  out_token = a3;
  if (!a3)
  {
    std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v23, a1);
    v8 = v23;
    v7 = v24;
    if (v24)
    {
      p_shared_weak_owners = (unint64_t *)&v24->__shared_weak_owners_;
      do
        v10 = __ldxr(p_shared_weak_owners);
      while (__stxr(v10 + 1, p_shared_weak_owners));
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      v13 = a1[2];
      v16 = MEMORY[0x1E0C809B0];
      v17 = 3321888768;
      v18 = ___ZN12SafeBrowsing13LookupContext41registerForUpdateNotificationsForProviderEPKciN7Backend6Google20SafeBrowsingProviderE_block_invoke;
      v19 = &__block_descriptor_56_ea8_32c128_ZTSKZN12SafeBrowsing13LookupContext41registerForUpdateNotificationsForProviderEPKciN7Backend6Google20SafeBrowsingProviderEE3__0_e8_v12__0i8l;
      do
        v14 = __ldxr(p_shared_weak_owners);
      while (__stxr(v14 + 1, p_shared_weak_owners));
      v20 = a4;
      v21 = v8;
      v22 = v7;
      do
        v15 = __ldxr(p_shared_weak_owners);
      while (__stxr(v15 + 1, p_shared_weak_owners));
    }
    else
    {
      v13 = a1[2];
      v16 = MEMORY[0x1E0C809B0];
      v17 = 3321888768;
      v18 = ___ZN12SafeBrowsing13LookupContext41registerForUpdateNotificationsForProviderEPKciN7Backend6Google20SafeBrowsingProviderE_block_invoke;
      v19 = &__block_descriptor_56_ea8_32c128_ZTSKZN12SafeBrowsing13LookupContext41registerForUpdateNotificationsForProviderEPKciN7Backend6Google20SafeBrowsingProviderEE3__0_e8_v12__0i8l;
      v20 = a4;
      v21 = v23;
      v22 = 0;
    }
    notify_register_dispatch(a2, &out_token, v13, &v16);
    if (v7)
      std::__shared_weak_count::__release_weak(v7);
    if (v22)
      std::__shared_weak_count::__release_weak(v22);
    if (v7)
      std::__shared_weak_count::__release_weak(v7);
  }
}

void sub_1DBCEBE7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  std::__shared_weak_count *v15;

  if (a15)
    std::__shared_weak_count::__release_weak(a15);
  if (v15)
  {
    std::__shared_weak_count::__release_weak(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN12SafeBrowsing13LookupContext41registerForUpdateNotificationsForProviderEPKciN7Backend6Google20SafeBrowsingProviderE_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 40);
      if (v5)
        SafeBrowsing::LookupContext::serviceDidFinishDatabaseUpdate(v5, (void **)(((unint64_t)*(unsigned int *)(a1 + 32) << 32) | 1));
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1DBCEBF28(_Unwind_Exception *exception_object)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v4;

  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
    ___ZN7Backend6Google13FullHashCache21updateExpirationTimerEv_block_invoke_cold_1(v1);
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_ea8_32c128_ZTSKZN12SafeBrowsing13LookupContext41registerForUpdateNotificationsForProviderEPKciN7Backend6Google20SafeBrowsingProviderEE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 32);
  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_ea8_32c128_ZTSKZN12SafeBrowsing13LookupContext41registerForUpdateNotificationsForProviderEPKciN7Backend6Google20SafeBrowsingProviderEE3__0(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void SafeBrowsing::LookupContext::handleConnectionEvent(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;

  v3 = a2;
  if (MEMORY[0x1DF0B91F0]() == MEMORY[0x1E0C81310])
  {
    SafeBrowsing::LookupContext::handleConnectionError(a1, v3);
  }
  else
  {
    v4 = SSBOSLogXPC();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      SafeBrowsing::LookupContext::handleConnectionEvent(v4);
  }

}

void sub_1DBCEBFF8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::handleConnectionError(uint64_t a1, void *a2)
{
  id v3;
  const std::error_category *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  std::string v12;
  std::error_code v13;
  _OWORD v14[2];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  *(_QWORD *)&v13.__val_ = Platform::xpcErrorCode(v3);
  v13.__cat_ = v4;
  v5 = (id)SSBOSLogXPC();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    std::error_code::message(&v12, &v13);
    SafeBrowsing::LookupContext::handleConnectionError();
  }

  v6 = *(_QWORD *)(a1 + 48);
  v10 = v6;
  v11 = *(_OWORD *)(a1 + 56);
  v7 = v11;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v8 = v7;
  while (v6 != v8)
  {
    v14[0] = v13;
    v9 = *(_QWORD *)(v6 + 24);
    if (!v9)
    {
      std::__throw_bad_function_call[abi:sn180100]();
      __break(1u);
    }
    (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v9 + 48))(v9, v14);
    v6 += 32;
  }
  *(_QWORD *)&v14[0] = &v10;
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100]((void ***)v14);

}

void sub_1DBCEC114(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::serviceDidFinishDatabaseUpdate(uint64_t a1, void **a2)
{
  unint64_t v4;
  NSObject *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const std::error_category *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  void **v24[3];
  uint8_t buf[8];
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v4 = (unint64_t)a2 >> 32;
  v5 = SSBOSLogDatabase();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = (_DWORD)a2;
    LOWORD(v26) = 1024;
    *(_DWORD *)((char *)&v26 + 2) = v4;
    _os_log_impl(&dword_1DBCBE000, v5, OS_LOG_TYPE_DEFAULT, "Service did finish database update with protection type %d and provider %d", buf, 0xEu);
  }
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v22, (_QWORD *)a1);
  v6 = *(_QWORD *)(a1 + 120);
  v7 = *(std::__shared_weak_count **)(a1 + 128);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(_QWORD *)v6 + 32))(v6, v22, v4);
  v10 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)buf = v10;
  v26 = *(_OWORD *)(a1 + 56);
  v11 = v26;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v12 = v11;
  while (v10 != v12)
  {
    v13 = std::system_category();
    v24[0] = 0;
    v24[1] = (void **)&v13->__vftable;
    v14 = *(_QWORD *)(v10 + 24);
    if (!v14)
      goto LABEL_24;
    (*(void (**)(uint64_t, void ***))(*(_QWORD *)v14 + 48))(v14, v24);
    v10 += 32;
  }
  v15 = *(_QWORD **)(a1 + 96);
  if (v15)
  {
    while (1)
    {
      v24[0] = a2;
      v16 = v15[6];
      if (!v16)
        break;
      (*(void (**)(uint64_t, void ***))(*(_QWORD *)v16 + 48))(v16, v24);
      v15 = (_QWORD *)*v15;
      if (!v15)
        goto LABEL_13;
    }
LABEL_24:
    std::__throw_bad_function_call[abi:sn180100]();
    __break(1u);
  }
LABEL_13:
  v24[0] = (void **)buf;
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](v24);
  if (v7)
  {
    v17 = (unint64_t *)&v7->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v19 = v23;
  if (v23)
  {
    v20 = (unint64_t *)&v23->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_1DBCEC358(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t SafeBrowsing::LookupContext::databaseCoordinatorFromProtectionType@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(result + 128);
  *a2 = *(_QWORD *)(result + 120);
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void ___ZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  NSObject *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  _xpc_connection_s *v7;
  NSObject *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t v11;
  char v12;
  const std::error_category *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  _QWORD v22[4];
  uint64_t v23;
  std::__shared_weak_count *v24;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 162))
  {
    v12 = *(_BYTE *)(v2 + 161);
    v13 = std::system_category();
    std::function<void ()(BOOL,std::error_code)>::operator()(a1 + 48, v12, 0, (uint64_t)v13);
    return;
  }
  if (!*(_BYTE *)(v2 + 163))
  {
    SafeBrowsing::LookupContext::ensureConnection(*(SafeBrowsing::LookupContext **)(a1 + 32));
    SafeBrowsing::createMessage(0xAu);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = SSBOSLogXPC();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      LOWORD(v22[0]) = 0;
      _os_log_impl(&dword_1DBCBE000, v4, OS_LOG_TYPE_INFO, "Send GetSafeBrowsingEnabledState message to safe browsing service", (uint8_t *)v22, 2u);
    }
    v5 = *(_QWORD *)(a1 + 32);
    v6 = *(std::__shared_weak_count **)(a1 + 40);
    v8 = *(NSObject **)(v5 + 16);
    v7 = *(_xpc_connection_s **)(v5 + 24);
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3321888768;
    v22[2] = ___ZZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEv_block_invoke;
    v22[3] = &__block_descriptor_48_ea8_32c160_ZTSKZZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE__e33_v16__0__NSObject_OS_xpc_object__8l;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
      v23 = v5;
      v24 = v6;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    else
    {
      v23 = v5;
      v24 = 0;
    }
    xpc_connection_send_message_with_reply(v7, v3, v8, v22);
    if (v6)
    {
      v14 = (unint64_t *)&v6->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 163) = 1;
    v16 = v24;
    if (v24)
    {
      v17 = (unint64_t *)&v24->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    v2 = *(_QWORD *)(a1 + 32);
  }
  v19 = a1 + 48;
  v20 = *(_QWORD *)(v2 + 176);
  if (v20 >= *(_QWORD *)(v2 + 184))
  {
    v21 = std::vector<std::function<void ()(BOOL,std::error_code)>>::__push_back_slow_path<std::function<void ()(BOOL,std::error_code)> const&>((uint64_t *)(v2 + 168), v19);
    goto LABEL_28;
  }
  if (v20)
  {
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](*(_QWORD *)(v2 + 176), v19);
    v21 = (char *)(v20 + 32);
    *(_QWORD *)(v2 + 176) = v20 + 32;
LABEL_28:
    *(_QWORD *)(v2 + 176) = v21;
    return;
  }
  __break(1u);
}

void sub_1DBCEC5B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  void *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v18;

  if (a14)
    ___ZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke_cold_1(a14);
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c111_ZTSKZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCEC660(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c111_ZTSKZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::setSafeBrowsingEnabledState(SafeBrowsing::LookupContext *this, char a2)
{
  NSObject *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD block[4];
  uint64_t v18;
  std::__shared_weak_count *v19;
  char v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v21, this);
  v4 = *((_QWORD *)this + 2);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext27setSafeBrowsingEnabledStateEb_block_invoke;
  block[3] = &__block_descriptor_56_ea8_32c72_ZTSKZN12SafeBrowsing13LookupContext27setSafeBrowsingEnabledStateEbE3__0_e5_v8__0l;
  v5 = v21;
  v6 = v22;
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    v18 = v5;
    v19 = v6;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    v20 = a2;
    dispatch_async(v4, block);
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    v18 = v21;
    v19 = 0;
    v20 = a2;
    dispatch_async(v4, block);
  }
  v11 = v19;
  if (v19)
  {
    v12 = (unint64_t *)&v19->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  v14 = v22;
  if (v22)
  {
    v15 = (unint64_t *)&v22->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

uint64_t ___ZN12SafeBrowsing13LookupContext27setSafeBrowsingEnabledStateEb_block_invoke(uint64_t result)
{
  *(_WORD *)(*(_QWORD *)(result + 32) + 161) = *(unsigned __int8 *)(result + 48);
  return result;
}

uint64_t __copy_helper_block_ea8_32c72_ZTSKZN12SafeBrowsing13LookupContext27setSafeBrowsingEnabledStateEbE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_BYTE *)(result + 48) = *(_BYTE *)(a2 + 48);
  return result;
}

uint64_t __destroy_helper_block_ea8_32c72_ZTSKZN12SafeBrowsing13LookupContext27setSafeBrowsingEnabledStateEbE3__0(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::setSafeBrowsingEnabledStateNeedsUpdate(SafeBrowsing::LookupContext *this)
{
  NSObject *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[4];
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;

  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v18, this);
  v2 = *((_QWORD *)this + 2);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3321888768;
  v15[2] = ___ZN12SafeBrowsing13LookupContext38setSafeBrowsingEnabledStateNeedsUpdateEv_block_invoke;
  v15[3] = &__block_descriptor_48_ea8_32c83_ZTSKZN12SafeBrowsing13LookupContext38setSafeBrowsingEnabledStateNeedsUpdateEvE3__0_e5_v8__0l;
  v3 = v18;
  v4 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    v16 = v3;
    v17 = v4;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    dispatch_async(v2, v15);
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  else
  {
    v16 = v18;
    v17 = 0;
    dispatch_async(v2, v15);
  }
  v9 = v17;
  if (v17)
  {
    v10 = (unint64_t *)&v17->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v19;
  if (v19)
  {
    v13 = (unint64_t *)&v19->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

uint64_t ___ZN12SafeBrowsing13LookupContext38setSafeBrowsingEnabledStateNeedsUpdateEv_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 162) = 1;
  return result;
}

uint64_t __copy_helper_block_ea8_32c83_ZTSKZN12SafeBrowsing13LookupContext38setSafeBrowsingEnabledStateNeedsUpdateEvE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c83_ZTSKZN12SafeBrowsing13LookupContext38setSafeBrowsingEnabledStateNeedsUpdateEvE3__0(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void ___ZN12SafeBrowsing13LookupContext33dispatchWhenDatabasesAreAvailableEN7Backend6Google14ProtectionTypeENSt3__18functionIFvNS4_10error_codeEEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  void *v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  _xpc_connection_s *v12;
  NSObject *v13;
  unint64_t *v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  NSObject *v18;
  int v19;
  const std::error_category *v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  NSObject *v27;
  int v28;
  _QWORD *v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  _DWORD v33[6];
  _DWORD *v34;
  uint8_t buf[8];
  uint64_t v36;
  void (*v37)(uint64_t, void *);
  void *v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(v2 + 120);
  v3 = *(std::__shared_weak_count **)(v2 + 128);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    v2 = *(_QWORD *)(a1 + 32);
  }
  if (((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 16))(v4, v2) & 1) != 0)
  {
    if (!*(_BYTE *)(v4 + 24))
    {
      SafeBrowsing::LookupContext::ensureConnection(*(SafeBrowsing::LookupContext **)(a1 + 32));
      SafeBrowsing::createMessage(2u);
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      xpc_dictionary_set_int64(v7, "protectionType", *(int *)(a1 + 48));
      v8 = SSBOSLogDatabase();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        v9 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v9;
        _os_log_impl(&dword_1DBCBE000, v8, OS_LOG_TYPE_INFO, "Send GetDatabases message to safe browsing service with protection type %d", buf, 8u);
      }
      v10 = *(_QWORD *)(a1 + 32);
      v11 = *(std::__shared_weak_count **)(a1 + 40);
      v13 = *(NSObject **)(v10 + 16);
      v12 = *(_xpc_connection_s **)(v10 + 24);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      v36 = 3321888768;
      v37 = ___ZZN12SafeBrowsing13LookupContext33dispatchWhenDatabasesAreAvailableEN7Backend6Google14ProtectionTypeENSt3__18functionIFvNS4_10error_codeEEEEENK3__0clEv_block_invoke;
      v38 = &__block_descriptor_56_ea8_32c198_ZTSKZZN12SafeBrowsing13LookupContext33dispatchWhenDatabasesAreAvailableEN7Backend6Google14ProtectionTypeENSt3__18functionIFvNS4_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE__e33_v16__0__NSObject_OS_xpc_object__8l;
      if (v11)
      {
        v14 = (unint64_t *)&v11->__shared_owners_;
        do
          v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
        v16 = *(_DWORD *)(a1 + 48);
        v39 = v10;
        v40 = v11;
        do
          v17 = __ldxr(v14);
        while (__stxr(v17 + 1, v14));
      }
      else
      {
        v16 = *(_DWORD *)(a1 + 48);
        v39 = v10;
        v40 = 0;
      }
      v41 = v16;
      xpc_connection_send_message_with_reply(v12, v7, v13, buf);
      if (v11)
      {
        v22 = (unint64_t *)&v11->__shared_owners_;
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      *(_BYTE *)(v4 + 24) = 1;
      v24 = v40;
      if (v40)
      {
        v25 = (unint64_t *)&v40->__shared_owners_;
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

    }
    v27 = SSBOSLogDatabase();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
    {
      v28 = *(_DWORD *)(a1 + 48);
      v33[0] = 67109120;
      v33[1] = v28;
      _os_log_impl(&dword_1DBCBE000, v27, OS_LOG_TYPE_INFO, "Already waiting for GetDatabases response with protection type %d", (uint8_t *)v33, 8u);
    }
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v33, a1 + 56);
    std::vector<std::function<void ()(std::error_code)>>::push_back[abi:sn180100]((uint64_t *)(v4 + 32), (uint64_t)v33);
    v29 = v34;
    if (v34 == v33)
    {
      v30 = 4;
      v29 = v33;
    }
    else
    {
      if (!v34)
        goto LABEL_38;
      v30 = 5;
    }
    (*(void (**)(void))(*v29 + 8 * v30))();
  }
  else
  {
    v18 = SSBOSLogDatabase();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      v19 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v19;
      _os_log_impl(&dword_1DBCBE000, v18, OS_LOG_TYPE_INFO, "Databases are not empty with protection type %d", buf, 8u);
    }
    v20 = std::system_category();
    *(_QWORD *)buf = 0;
    v36 = (uint64_t)v20;
    v21 = *(_QWORD *)(a1 + 80);
    if (!v21)
    {
      std::__throw_bad_function_call[abi:sn180100]();
      __break(1u);
      return;
    }
    (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v21 + 48))(v21, buf);
  }
LABEL_38:
  if (v3)
  {
    v31 = (unint64_t *)&v3->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1DBCECD30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  std::__shared_weak_count *v18;
  void *v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;

  if (a18)
    ___ZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke_cold_1(a18);
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  if (v18)
  {
    v24 = (unint64_t *)&v18->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c149_ZTSKZN12SafeBrowsing13LookupContext33dispatchWhenDatabasesAreAvailableEN7Backend6Google14ProtectionTypeENSt3__18functionIFvNS4_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 56, a2 + 56);
}

void sub_1DBCECE60(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c149_ZTSKZN12SafeBrowsing13LookupContext33dispatchWhenDatabasesAreAvailableEN7Backend6Google14ProtectionTypeENSt3__18functionIFvNS4_10error_codeEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 56);
  v3 = *(_QWORD **)(a1 + 80);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

uint64_t SafeBrowsing::LookupContext::dispatchWhenDatabasesAreAvailable(Backend::Google::ProtectionType,std::function<void ()(std::error_code)>)::$_0::~$_0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 24);
  v3 = *(_QWORD **)(a1 + 48);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1);
}

void SafeBrowsing::LookupContext::databaseStatus(SafeBrowsing::LookupContext *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  __int128 v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _QWORD v9[3];
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  void **v14;

  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v12, this);
  v10 = 0uLL;
  v11 = 0;
  (*(void (**)(_QWORD, uint64_t, __int128 *))(**((_QWORD **)this + 15) + 24))(*((_QWORD *)this + 15), v12, &v10);
  v4 = v11;
  v5 = v10;
  v11 = 0;
  v9[2] = 0;
  v10 = 0uLL;
  *(_OWORD *)a2 = v5;
  *(_QWORD *)(a2 + 16) = v4;
  v9[0] = 0;
  v9[1] = 0;
  v14 = (void **)v9;
  std::vector<SafeBrowsing::DatabaseStatus::Database>::__destroy_vector::operator()[abi:sn180100](&v14);
  v14 = (void **)&v10;
  std::vector<SafeBrowsing::DatabaseStatus::Database>::__destroy_vector::operator()[abi:sn180100](&v14);
  v6 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1DBCECFDC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = v1;
  std::vector<SafeBrowsing::DatabaseStatus::Database>::__destroy_vector::operator()[abi:sn180100]((void ***)(v2 - 24));
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2 - 40);
  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::handleGetDatabasesReply(_QWORD *a1, int a2, void *a3)
{
  id v5;
  NSObject *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint8_t buf[8];
  std::__shared_weak_count *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = SSBOSLogDatabase();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = a2;
    _os_log_impl(&dword_1DBCBE000, v6, OS_LOG_TYPE_INFO, "Receive GetDatabases response from safe browsing service with protection type: %d", buf, 8u);
  }
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(buf, a1);
  v7 = a1[15];
  v8 = (std::__shared_weak_count *)a1[16];
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t, _QWORD, id))(*(_QWORD *)v7 + 40))(v7, *(_QWORD *)buf, v5);
  if (v8)
  {
    v11 = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v13 = v17;
  if (v17)
  {
    v14 = (unint64_t *)&v17->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

}

void sub_1DBCED158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v11;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a9);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)&a11);

  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::handleGetServiceStatusReply(uint64_t a1, void *a2, uint64_t a3)
{
  id v4;
  _xpc_connection_s *v5;
  char *name;
  pid_t pid;
  void *v8;
  uint64_t v9;
  void *v10;
  uint64_t *v11;
  char *shouldConsultWithTencent;
  unsigned int v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  uint64_t *v24;
  char *v25;
  uint64_t v26;
  unsigned int int64;
  unsigned int v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  char *v36;
  uint64_t *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void *v41;
  char v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  __int128 v46;
  void *v47;
  uint64_t *v48;
  const std::error_category *v49;
  uint64_t v50;
  _QWORD v51[3];
  void *v52[3];
  void *v53;
  _BYTE v54[15];
  char v55;
  pid_t v56;
  __int128 v57;
  uint64_t v58;
  __int128 v59;
  uint64_t v60;
  void *v61;
  void *v62;
  uint64_t *v63;
  void *__p;
  uint64_t *v65;
  uint64_t *v66;
  _QWORD v67[5];
  __int128 v68;
  uint64_t v69;
  _QWORD applier[5];
  __int128 v71;
  uint64_t v72;
  void *v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  _OWORD v77[3];
  __int128 v78;
  uint64_t v79;
  void **v80[3];
  _QWORD v81[3];

  v81[2] = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (MEMORY[0x1DF0B91F0]() == MEMORY[0x1E0C81310])
  {
    v75 = 0u;
    v76 = 0u;
    DWORD2(v76) = -1;
    memset(v77, 0, sizeof(v77));
    v78 = 0u;
    v79 = 0;
    v73 = (void *)Platform::xpcErrorCode(v4);
    *(_QWORD *)&v74 = v16;
    v17 = *(_QWORD *)(a3 + 24);
    if (v17)
    {
      (*(void (**)(uint64_t, __int128 *, void **))(*(_QWORD *)v17 + 48))(v17, &v75, &v73);
      if ((_QWORD)v78)
      {
        *((_QWORD *)&v78 + 1) = v78;
        operator delete((void *)v78);
      }
      v73 = (char *)&v77[1] + 8;
      std::vector<SafeBrowsing::ServiceStatus::Connection>::__destroy_vector::operator()[abi:sn180100]((void ***)&v73);
      v73 = v77;
      std::vector<std::string>::__destroy_vector::operator()[abi:sn180100]((void ***)&v73);
      if (SBYTE7(v76) < 0)
        operator delete((void *)v75);
      goto LABEL_53;
    }
    std::__throw_bad_function_call[abi:sn180100]();
  }
  else
  {
    xpc_dictionary_get_remote_connection(v4);
    v5 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
    name = (char *)xpc_connection_get_name(v5);
    std::string::basic_string[abi:sn180100]<0>((char **)&v73, name);
    pid = xpc_connection_get_pid(v5);
    v71 = 0uLL;
    v72 = 0;
    xpc_dictionary_get_value(v4, "activeTransactions");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = MEMORY[0x1E0C809B0];
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3321888768;
    applier[2] = ___ZN12SafeBrowsing13LookupContext27handleGetServiceStatusReplyEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS_13ServiceStatusENS4_10error_codeEEEE_block_invoke;
    applier[3] = &__block_descriptor_40_ea8_32c166_ZTSKZN12SafeBrowsing13LookupContext27handleGetServiceStatusReplyEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS_13ServiceStatusENS4_10error_codeEEEEE3__0_e36_B24__0Q8__NSObject_OS_xpc_object__16l;
    applier[4] = &v71;
    xpc_array_apply(v8, applier);

    v68 = 0uLL;
    v69 = 0;
    xpc_dictionary_get_value(v4, "connections");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v67[0] = v9;
    v67[1] = 3321888768;
    v67[2] = ___ZN12SafeBrowsing13LookupContext27handleGetServiceStatusReplyEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS_13ServiceStatusENS4_10error_codeEEEE_block_invoke_27;
    v67[3] = &__block_descriptor_40_ea8_32c166_ZTSKZN12SafeBrowsing13LookupContext27handleGetServiceStatusReplyEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS_13ServiceStatusENS4_10error_codeEEEEE3__1_e36_B24__0Q8__NSObject_OS_xpc_object__16l;
    v67[4] = &v68;
    xpc_array_apply(v10, v67);

    LODWORD(v10) = xpc_dictionary_get_int64(v4, "googleDatabaseUpdaterState");
    v11 = (uint64_t *)operator new(8uLL);
    __p = v11;
    *v11 = v10 | 0x100000000;
    v65 = v11 + 1;
    v66 = v11 + 1;
    shouldConsultWithTencent = (char *)Backend::Google::SSBUtilities::shouldConsultWithTencent((Backend::Google::SSBUtilities *)(v11 + 1));
    if ((_DWORD)shouldConsultWithTencent)
    {
      shouldConsultWithTencent = (char *)xpc_dictionary_get_int64(v4, "tencentDatabaseUpdaterState");
      v13 = shouldConsultWithTencent;
      v14 = v65;
      if (v65 >= v66)
      {
        v18 = ((char *)v65 - (_BYTE *)__p) >> 3;
        if ((unint64_t)(v18 + 1) >> 61)
          abort();
        v19 = ((char *)v66 - (_BYTE *)__p) >> 2;
        if (v19 <= v18 + 1)
          v19 = v18 + 1;
        if ((unint64_t)((char *)v66 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
          v20 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v20 = v19;
        if (!v20)
          goto LABEL_58;
        v21 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>((uint64_t)&v66, v20);
        if (!v21)
          goto LABEL_58;
        v23 = &v21[8 * v22];
        v24 = (uint64_t *)&v21[8 * v18];
        *v24 = v13 | 0x200000000;
        v15 = v24 + 1;
        v25 = (char *)__p;
        shouldConsultWithTencent = (char *)v65;
        if (v65 != __p)
        {
          do
          {
            v26 = *((_QWORD *)shouldConsultWithTencent - 1);
            shouldConsultWithTencent -= 8;
            *--v24 = v26;
          }
          while (shouldConsultWithTencent != v25);
          shouldConsultWithTencent = (char *)__p;
        }
        __p = v24;
        v65 = v15;
        v66 = (uint64_t *)v23;
        if (shouldConsultWithTencent)
          operator delete(shouldConsultWithTencent);
      }
      else
      {
        if (!v65)
          goto LABEL_58;
        *v65 = shouldConsultWithTencent | 0x200000000;
        v15 = v14 + 1;
      }
      v65 = v15;
    }
    if ((Backend::Google::SSBUtilities::shouldConsultWithApple((Backend::Google::SSBUtilities *)shouldConsultWithTencent) & 1) != 0)
    {
      int64 = xpc_dictionary_get_int64(v4, "appleDatabaseUpdaterState");
      v28 = int64;
      v29 = v65;
      if (v65 >= v66)
      {
        v31 = ((char *)v65 - (_BYTE *)__p) >> 3;
        if ((unint64_t)(v31 + 1) >> 61)
          abort();
        v32 = ((char *)v66 - (_BYTE *)__p) >> 2;
        if (v32 <= v31 + 1)
          v32 = v31 + 1;
        if ((unint64_t)((char *)v66 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
          v33 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v33 = v32;
        if (!v33)
          goto LABEL_58;
        v34 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>((uint64_t)&v66, v33);
        if (!v34)
          goto LABEL_58;
        v36 = &v34[8 * v35];
        v37 = (uint64_t *)&v34[8 * v31];
        *v37 = v28 | 0x300000000;
        v30 = v37 + 1;
        v39 = (char *)__p;
        v38 = (char *)v65;
        if (v65 != __p)
        {
          do
          {
            v40 = *((_QWORD *)v38 - 1);
            v38 -= 8;
            *--v37 = v40;
          }
          while (v38 != v39);
          v38 = (char *)__p;
        }
        __p = v37;
        v65 = v30;
        v66 = (uint64_t *)v36;
        if (v38)
          operator delete(v38);
      }
      else
      {
        if (!v65)
          goto LABEL_58;
        *v65 = int64 | 0x300000000;
        v30 = v29 + 1;
      }
    }
    else
    {
      v30 = v65;
    }
    v41 = v73;
    v81[0] = v74;
    *(_QWORD *)((char *)v81 + 7) = *(_QWORD *)((char *)&v74 + 7);
    v42 = HIBYTE(v74);
    v74 = 0uLL;
    v43 = v72;
    v44 = v71;
    v72 = 0;
    v73 = 0;
    v71 = 0uLL;
    v45 = v69;
    v46 = v68;
    v68 = 0uLL;
    v69 = 0;
    v47 = __p;
    v48 = v66;
    __p = 0;
    v65 = 0;
    v66 = 0;
    *(_QWORD *)&v54[7] = *(_QWORD *)((char *)v81 + 7);
    v53 = v41;
    *(_QWORD *)v54 = v81[0];
    v55 = v42;
    v56 = pid;
    v57 = v44;
    v58 = v43;
    memset(v52, 0, sizeof(v52));
    v59 = v46;
    memset(v51, 0, sizeof(v51));
    v60 = v45;
    v61 = v47;
    v62 = v30;
    v63 = v48;
    v49 = std::system_category();
    v80[0] = 0;
    v80[1] = (void **)&v49->__vftable;
    v50 = *(_QWORD *)(a3 + 24);
    if (v50)
    {
      (*(void (**)(uint64_t, void **, void ***))(*(_QWORD *)v50 + 48))(v50, &v53, v80);
      if (v61)
      {
        v62 = v61;
        operator delete(v61);
      }
      v80[0] = (void **)&v59;
      std::vector<SafeBrowsing::ServiceStatus::Connection>::__destroy_vector::operator()[abi:sn180100](v80);
      v80[0] = (void **)&v57;
      std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](v80);
      if (v55 < 0)
        operator delete(v53);
      v80[0] = (void **)v51;
      std::vector<SafeBrowsing::ServiceStatus::Connection>::__destroy_vector::operator()[abi:sn180100](v80);
      v80[0] = v52;
      std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](v80);
      if (__p)
      {
        v65 = (uint64_t *)__p;
        operator delete(__p);
      }
      __p = &v68;
      std::vector<SafeBrowsing::ServiceStatus::Connection>::__destroy_vector::operator()[abi:sn180100]((void ***)&__p);
      *(_QWORD *)&v68 = &v71;
      std::vector<std::string>::__destroy_vector::operator()[abi:sn180100]((void ***)&v68);
      if (SHIBYTE(v74) < 0)
        operator delete(v73);

LABEL_53:
      return;
    }
    std::__throw_bad_function_call[abi:sn180100]();
  }
LABEL_58:
  __break(1u);
}

void sub_1DBCED6E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char **__p,char **a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  void *v53;
  void *v54;

  if (__p)
  {
    a30 = __p;
    operator delete(__p);
  }
  __p = &a37;
  std::vector<SafeBrowsing::ServiceStatus::Connection>::__destroy_vector::operator()[abi:sn180100]((void ***)&__p);
  a37 = &a45;
  std::vector<std::string>::__destroy_vector::operator()[abi:sn180100]((void ***)&a37);
  if (a53 < 0)
    operator delete(a48);

  _Unwind_Resume(a1);
}

void SafeBrowsing::ServiceStatus::~ServiceStatus(SafeBrowsing::ServiceStatus *this)
{
  void *v2;
  void **v3;

  v2 = (void *)*((_QWORD *)this + 10);
  if (v2)
  {
    *((_QWORD *)this + 11) = v2;
    operator delete(v2);
  }
  v3 = (void **)((char *)this + 56);
  std::vector<SafeBrowsing::ServiceStatus::Connection>::__destroy_vector::operator()[abi:sn180100](&v3);
  v3 = (void **)((char *)this + 32);
  std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](&v3);
  if (*((char *)this + 23) < 0)
    operator delete(*(void **)this);
}

uint64_t ___ZN12SafeBrowsing13LookupContext27handleGetServiceStatusReplyEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS_13ServiceStatusENS4_10error_codeEEEE_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  char *string_ptr;
  size_t length;
  uint64_t v7;
  uint64_t result;
  unint64_t v9;
  unint64_t v10;
  __int128 v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  __int128 v18;
  std::string *v19;
  std::string *v20;
  unint64_t v21;
  __int128 v22;
  std::string *v23;
  unint64_t v24;
  std::string *v25;
  int v26;
  void *__p[2];
  uint64_t v28;
  std::__split_buffer<std::string> v29;

  v4 = a3;
  string_ptr = (char *)xpc_string_get_string_ptr(v4);
  length = xpc_string_get_length(v4);
  v7 = *(_QWORD *)(a1 + 32);
  std::string::basic_string[abi:sn180100](__p, string_ptr, length);
  result = v7 + 16;
  v9 = *(_QWORD *)(v7 + 16);
  v10 = *(_QWORD *)(v7 + 8);
  if (v10 >= v9)
  {
    v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *(_QWORD *)v7) >> 3);
    v13 = v12 + 1;
    if (v12 + 1 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - *(_QWORD *)v7) >> 3);
    if (2 * v14 > v13)
      v13 = 2 * v14;
    if (v14 >= 0x555555555555555)
      v15 = 0xAAAAAAAAAAAAAAALL;
    else
      v15 = v13;
    v29.__end_cap_.__value_ = (std::allocator<std::string> *)(v7 + 16);
    if (v15)
    {
      result = (uint64_t)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::LexicographicallyOrderedHashEnumerator::Position>>(result, v15);
      if (result)
      {
        v17 = result + 24 * v12;
        v18 = *(_OWORD *)__p;
        *(_QWORD *)(v17 + 16) = v28;
        *(_OWORD *)v17 = v18;
        __p[1] = 0;
        v28 = 0;
        __p[0] = 0;
        v20 = *(std::string **)v7;
        v19 = *(std::string **)(v7 + 8);
        if (v19 == *(std::string **)v7)
        {
          v23 = *(std::string **)(v7 + 8);
          v21 = result + 24 * v12;
        }
        else
        {
          v21 = result + 24 * v12;
          do
          {
            v22 = *(_OWORD *)&v19[-1].__r_.__value_.__l.__data_;
            *(_QWORD *)(v21 - 8) = *((_QWORD *)&v19[-1].__r_.__value_.__l + 2);
            *(_OWORD *)(v21 - 24) = v22;
            v21 -= 24;
            v19[-1].__r_.__value_.__l.__size_ = 0;
            v19[-1].__r_.__value_.__r.__words[2] = 0;
            v19[-1].__r_.__value_.__r.__words[0] = 0;
            --v19;
          }
          while (v19 != v20);
          v23 = *(std::string **)v7;
          v19 = *(std::string **)(v7 + 8);
        }
        v24 = v17 + 24;
        *(_QWORD *)v7 = v21;
        v29.__first_ = v23;
        v29.__begin_ = v23;
        *(_QWORD *)(v7 + 8) = v17 + 24;
        v29.__end_ = v19;
        v25 = *(std::string **)(v7 + 16);
        *(_QWORD *)(v7 + 16) = result + 24 * v16;
        v29.__end_cap_.__value_ = v25;
        std::__split_buffer<std::string>::~__split_buffer(&v29);
        v26 = SHIBYTE(v28);
        *(_QWORD *)(v7 + 8) = v24;
        if (v26 < 0)
          operator delete(__p[0]);
        goto LABEL_19;
      }
    }
  }
  else if (v10)
  {
    v11 = *(_OWORD *)__p;
    *(_QWORD *)(v10 + 16) = v28;
    *(_OWORD *)v10 = v11;
    *(_QWORD *)(v7 + 8) = v10 + 24;
LABEL_19:

    return 1;
  }
  __break(1u);
  return result;
}

void sub_1DBCED9F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;

  if (a14 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c166_ZTSKZN12SafeBrowsing13LookupContext27handleGetServiceStatusReplyEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS_13ServiceStatusENS4_10error_codeEEEEE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

uint64_t ___ZN12SafeBrowsing13LookupContext27handleGetServiceStatusReplyEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS_13ServiceStatusENS4_10error_codeEEEE_block_invoke_27(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  int int64;
  char *string;
  char **v7;
  int v9;
  void *__p[2];
  uint64_t v11;

  v4 = a3;
  int64 = xpc_dictionary_get_int64(v4, "pid");
  string = (char *)xpc_dictionary_get_string(v4, "bundleIdentifier");
  v7 = *(char ***)(a1 + 32);
  v9 = int64;
  if (string)
  {
    std::string::basic_string[abi:sn180100]<0>((char **)__p, string);
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    v11 = 0;
  }
  std::vector<SafeBrowsing::ServiceStatus::Connection>::push_back[abi:sn180100](v7, (uint64_t)&v9);
  if (SHIBYTE(v11) < 0)
    operator delete(__p[0]);

  return 1;
}

void sub_1DBCEDADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c166_ZTSKZN12SafeBrowsing13LookupContext27handleGetServiceStatusReplyEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS_13ServiceStatusENS4_10error_codeEEEEE3__1(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void SafeBrowsing::LookupContext::checkFullHashes(SafeBrowsing::LookupContext *a1, int a2, const Backend::Google::FullHashRequest **a3, uint64_t a4)
{
  void *v8;
  xpc_object_t v9;
  const Backend::Google::FullHashRequest *v10;
  const Backend::Google::FullHashRequest *v11;
  void *v12;
  NSObject *v13;
  NSObject *v14;
  _xpc_connection_s *v15;
  _QWORD *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  _QWORD *v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  _QWORD handler[5];
  std::__shared_weak_count *v38;
  int v39;
  _BYTE v40[24];
  _BYTE *v41;
  uint8_t buf[8];
  std::__shared_weak_count *v43;
  int v44;
  _QWORD v45[3];
  _QWORD *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  SafeBrowsing::LookupContext::ensureConnection(a1);
  SafeBrowsing::createMessage(4u);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = xpc_array_create(0, 0);
  v10 = *a3;
  v11 = a3[1];
  while (v10 != v11)
  {
    Backend::Google::FullHashRequest::FullHashRequest((Backend::Google::FullHashRequest *)buf, v10);
    Backend::Google::FullHashRequest::toXPC((Backend::Google::FullHashRequest *)buf);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    xpc_array_append_value(v9, v12);

    Backend::Google::FullHashRequest::~FullHashRequest((Backend::Google::FullHashRequest *)buf);
    v10 = (const Backend::Google::FullHashRequest *)((char *)v10 + 72);
  }
  xpc_dictionary_set_value(v8, "requests", v9);

  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v35, a1);
  v13 = SSBOSLogFullHash();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = a2;
    _os_log_impl(&dword_1DBCBE000, v13, OS_LOG_TYPE_INFO, "Send CheckFullHashes message to safe browsing service with protection type %d", buf, 8u);
  }
  v16 = (_QWORD *)((char *)a1 + 16);
  v14 = *((_QWORD *)a1 + 2);
  v15 = (_xpc_connection_s *)v16[1];
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZN12SafeBrowsing13LookupContext15checkFullHashesEN7Backend6Google14ProtectionTypeENSt3__16vectorINS2_15FullHashRequestENS4_9allocatorIS6_EEEENS4_8functionIFvNS5_INS1_12LookupResultENS7_ISB_EEEENS4_10error_codeEEEE_block_invoke;
  handler[3] = &__block_descriptor_88_ea8_32c223_ZTSKZN12SafeBrowsing13LookupContext15checkFullHashesEN7Backend6Google14ProtectionTypeENSt3__16vectorINS2_15FullHashRequestENS4_9allocatorIS6_EEEENS4_8functionIFvNS5_INS1_12LookupResultENS7_ISB_EEEENS4_10error_codeEEEEE3__1_e33_v16__0__NSObject_OS_xpc_object__8l;
  *(_QWORD *)buf = v35;
  v43 = v36;
  if (v36)
  {
    p_shared_owners = (unint64_t *)&v36->__shared_owners_;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
  }
  v44 = a2;
  v19 = v45;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v45, a4);
  handler[4] = *(_QWORD *)buf;
  v38 = v43;
  if (v43)
  {
    v20 = (unint64_t *)&v43->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v39 = v44;
  v22 = v40;
  v23 = (uint64_t)v46;
  if (!v46)
    goto LABEL_15;
  if (v46 != v45)
  {
    v23 = (*(uint64_t (**)(void))(*v46 + 16))();
LABEL_15:
    v41 = (_BYTE *)v23;
    goto LABEL_17;
  }
  v41 = v40;
  (*(void (**)(_QWORD *, _BYTE *))(v45[0] + 24))(v45, v40);
LABEL_17:
  xpc_connection_send_message_with_reply(v15, v8, v14, handler);
  if (v46 == v45)
  {
    v24 = 4;
    goto LABEL_21;
  }
  if (v46)
  {
    v24 = 5;
    v19 = v46;
LABEL_21:
    (*(void (**)(_QWORD *))(*v19 + 8 * v24))(v19);
  }
  v25 = v43;
  if (v43)
  {
    v26 = (unint64_t *)&v43->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  if (v41 == v40)
  {
    v28 = 4;
    goto LABEL_31;
  }
  if (v41)
  {
    v28 = 5;
    v22 = v41;
LABEL_31:
    (*(void (**)(_QWORD *))(*v22 + 8 * v28))(v22);
  }
  v29 = v38;
  if (v38)
  {
    v30 = (unint64_t *)&v38->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = v36;
  if (v36)
  {
    v33 = (unint64_t *)&v36->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }

}

void sub_1DBCEDE6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v3);
  SafeBrowsing::LookupContext::dispatchWhenDatabasesAreAvailable(Backend::Google::ProtectionType,std::function<void ()(std::error_code)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

id SafeBrowsing::createMessage(unsigned int a1)
{
  xpc_object_t v2;
  unint64_t v3;
  char v5;
  char **v6;
  char *v7;

  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v2, "message", a1);
  v3 = atomic_load(&SafeBrowsing::allowGoogleSafeBrowsing(void)::once);
  if (v3 != -1)
  {
    v7 = &v5;
    v6 = &v7;
    std::__call_once(&SafeBrowsing::allowGoogleSafeBrowsing(void)::once, &v6, (void (__cdecl *)(void *))std::__call_once_proxy[abi:sn180100]<std::tuple<SafeBrowsing::allowGoogleSafeBrowsing(void)::$_0 &&>>);
  }
  xpc_dictionary_set_BOOL(v2, "allowGoogle", SafeBrowsing::allowGoogleSafeBrowsing(void)::result);
  return v2;
}

void sub_1DBCEDFA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing13LookupContext15checkFullHashesEN7Backend6Google14ProtectionTypeENSt3__16vectorINS2_15FullHashRequestENS4_9allocatorIS6_EEEENS4_8functionIFvNS5_INS1_12LookupResultENS7_ISB_EEEENS4_10error_codeEEEE_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *v4;
  int v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = *(_QWORD **)(a1 + 32);
  v5 = *(_DWORD *)(a1 + 48);
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v8, a1 + 56);
  SafeBrowsing::LookupContext::handleCheckFullHashesReply(v4, v5, v3, v8);
  v6 = v9;
  if (v9 == v8)
  {
    v7 = 4;
    v6 = v8;
    goto LABEL_5;
  }
  if (v9)
  {
    v7 = 5;
LABEL_5:
    (*(void (**)(void))(*v6 + 8 * v7))();
  }

}

void sub_1DBCEE078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  void *v13;
  char *v14;
  char *v16;
  uint64_t v17;

  v16 = a13;
  if (a13 == v14)
  {
    v17 = 4;
    v16 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v16 + 8 * v17))();
LABEL_6:

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c223_ZTSKZN12SafeBrowsing13LookupContext15checkFullHashesEN7Backend6Google14ProtectionTypeENSt3__16vectorINS2_15FullHashRequestENS4_9allocatorIS6_EEEENS4_8functionIFvNS5_INS1_12LookupResultENS7_ISB_EEEENS4_10error_codeEEEEE3__1(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 56, a2 + 56);
}

void sub_1DBCEE118(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c223_ZTSKZN12SafeBrowsing13LookupContext15checkFullHashesEN7Backend6Google14ProtectionTypeENSt3__16vectorINS2_15FullHashRequestENS4_9allocatorIS6_EEEENS4_8functionIFvNS5_INS1_12LookupResultENS7_ISB_EEEENS4_10error_codeEEEEE3__1(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 56);
  v3 = *(_QWORD **)(a1 + 80);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::handleCheckFullHashesReply(_QWORD *a1, int a2, void *a3, _QWORD *a4)
{
  id v7;
  NSObject *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::string::size_type v13;
  _QWORD *v14;
  uint64_t v15;
  const std::error_category *cat;
  NSObject *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *size;
  unint64_t *v24;
  unint64_t v25;
  void *__p;
  void *v27;
  uint64_t v28;
  std::error_code v29;
  uint64_t v30;
  void *v31;
  _BYTE v32[24];
  _BYTE *v33;
  std::string buf;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v7 = a3;
  v8 = SSBOSLogFullHash();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = a2;
    _os_log_impl(&dword_1DBCBE000, v8, OS_LOG_TYPE_INFO, "Receive CheckFullHashes reply with protection type %d", (uint8_t *)&buf, 8u);
  }
  if (MEMORY[0x1DF0B91F0](v7) != MEMORY[0x1E0C81310])
  {
    std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&buf, a1);
    v10 = a1[15];
    v9 = (std::__shared_weak_count *)a1[16];
    v30 = v10;
    v31 = v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    v13 = buf.__r_.__value_.__r.__words[0];
    v14 = (_QWORD *)a4[3];
    if (v14)
    {
      if (v14 == a4)
      {
        v33 = v32;
        (*(void (**)(_QWORD *, _BYTE *))(*a4 + 24))(a4, v32);
      }
      else
      {
        v33 = (_BYTE *)a4[3];
        a4[3] = 0;
      }
    }
    else
    {
      v33 = 0;
    }
    (*(void (**)(uint64_t, std::string::size_type, id, _BYTE *))(*(_QWORD *)v10 + 56))(v10, v13, v7, v32);
    v19 = v33;
    if (v33 == v32)
    {
      v20 = 4;
      v19 = v32;
    }
    else
    {
      if (!v33)
        goto LABEL_24;
      v20 = 5;
    }
    (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_24:
    if (v9)
    {
      v21 = (unint64_t *)&v9->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    size = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
    if (buf.__r_.__value_.__l.__size_)
    {
      v24 = (unint64_t *)(buf.__r_.__value_.__l.__size_ + 8);
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
    }
LABEL_34:

    return;
  }
  v15 = Platform::xpcErrorCode(v7);
  *(_QWORD *)&v29.__val_ = v15;
  v29.__cat_ = cat;
  if ((_DWORD)v15)
  {
    v17 = (id)SSBOSLogFullHash();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      std::error_code::message(&buf, &v29);
      SafeBrowsing::LookupContext::handleCheckFullHashesReply();
    }

    v15 = *(_QWORD *)&v29.__val_;
    cat = v29.__cat_;
  }
  __p = 0;
  v27 = 0;
  v28 = 0;
  v30 = v15;
  v31 = (void *)cat;
  v18 = a4[3];
  if (v18)
  {
    (*(void (**)(uint64_t, void **, uint64_t *))(*(_QWORD *)v18 + 48))(v18, &__p, &v30);
    if (__p)
    {
      v27 = __p;
      operator delete(__p);
    }
    goto LABEL_34;
  }
  std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
}

void sub_1DBCEE408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::forceLoadRemoteConfigurationFromDisk(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD v27[3];
  _QWORD *v28;
  _QWORD block[5];
  std::__shared_weak_count *v30;
  _BYTE v31[24];
  _BYTE *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v23, a1);
  v4 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext36forceLoadRemoteConfigurationFromDiskENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke;
  block[3] = &__block_descriptor_80_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext36forceLoadRemoteConfigurationFromDiskENSt3__18functionIFvbNS1_10error_codeEEEEE3__0_e5_v8__0l;
  v25 = v23;
  v26 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = v27;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v27, a2);
  block[4] = v25;
  v30 = v26;
  if (v26)
  {
    v8 = (unint64_t *)&v26->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = v31;
  v11 = (uint64_t)v28;
  if (!v28)
    goto LABEL_10;
  if (v28 != v27)
  {
    v11 = (*(uint64_t (**)(void))(*v28 + 16))();
LABEL_10:
    v32 = (_BYTE *)v11;
    goto LABEL_12;
  }
  v32 = v31;
  (*(void (**)(_QWORD *, _BYTE *))(v27[0] + 24))(v27, v31);
LABEL_12:
  dispatch_async(v4, block);
  if (v28 == v27)
  {
    v12 = 4;
    goto LABEL_16;
  }
  if (v28)
  {
    v12 = 5;
    v7 = v28;
LABEL_16:
    (*(void (**)(_QWORD *))(*v7 + 8 * v12))(v7);
  }
  v13 = v26;
  if (v26)
  {
    v14 = (unint64_t *)&v26->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v32 == v31)
  {
    v16 = 4;
    goto LABEL_26;
  }
  if (v32)
  {
    v16 = 5;
    v10 = v32;
LABEL_26:
    (*(void (**)(_QWORD *))(*v10 + 8 * v16))(v10);
  }
  v17 = v30;
  if (v30)
  {
    v18 = (unint64_t *)&v30->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1DBCEE6E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing13LookupContext36forceLoadRemoteConfigurationFromDiskENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  void *v3;
  uint64_t v4;
  _xpc_connection_s *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  _QWORD v24[3];
  _QWORD *v25;
  _QWORD handler[5];
  std::__shared_weak_count *v27;
  _BYTE v28[24];
  _BYTE *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)(a1 + 32);
  SafeBrowsing::LookupContext::ensureConnection(*(SafeBrowsing::LookupContext **)(a1 + 32));
  SafeBrowsing::createMessage(5u);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = *v2;
  v6 = *(NSObject **)(*v2 + 16);
  v5 = *(_xpc_connection_s **)(*v2 + 24);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZZN12SafeBrowsing13LookupContext36forceLoadRemoteConfigurationFromDiskENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEv_block_invoke;
  handler[3] = &__block_descriptor_80_ea8_32c169_ZTSKZZN12SafeBrowsing13LookupContext36forceLoadRemoteConfigurationFromDiskENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE__e33_v16__0__NSObject_OS_xpc_object__8l;
  v7 = *(std::__shared_weak_count **)(a1 + 40);
  v22 = v4;
  v23 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = v24;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v24, a1 + 48);
  handler[4] = v22;
  v27 = v23;
  if (v23)
  {
    v11 = (unint64_t *)&v23->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = v28;
  v14 = (uint64_t)v25;
  if (!v25)
    goto LABEL_10;
  if (v25 != v24)
  {
    v14 = (*(uint64_t (**)(void))(*v25 + 16))();
LABEL_10:
    v29 = (_BYTE *)v14;
    goto LABEL_12;
  }
  v29 = v28;
  (*(void (**)(_QWORD *, _BYTE *))(v24[0] + 24))(v24, v28);
LABEL_12:
  xpc_connection_send_message_with_reply(v5, v3, v6, handler);
  if (v25 == v24)
  {
    v15 = 4;
    goto LABEL_16;
  }
  if (v25)
  {
    v15 = 5;
    v10 = v25;
LABEL_16:
    (*(void (**)(_QWORD *))(*v10 + 8 * v15))(v10);
  }
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  if (v29 == v28)
  {
    v18 = 4;
    goto LABEL_26;
  }
  if (v29)
  {
    v18 = 5;
    v13 = v29;
LABEL_26:
    (*(void (**)(_QWORD *))(*v13 + 8 * v18))(v13);
  }
  v19 = v27;
  if (v27)
  {
    v20 = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

}

void sub_1DBCEE954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, _QWORD *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  void *v21;
  _QWORD *v22;
  unint64_t *p_shared_owners;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;

  if (a21)
  {
    p_shared_owners = (unint64_t *)&a21->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))a21->__on_zero_shared)(a21);
      std::__shared_weak_count::__release_weak(a21);
    }
  }
  if (a15 == v22)
  {
    v26 = 4;
  }
  else
  {
    if (!a15)
      goto LABEL_11;
    v26 = 5;
    v22 = a15;
  }
  (*(void (**)(_QWORD *))(*v22 + 8 * v26))(v22);
LABEL_11:
  if (a11)
  {
    v27 = (unint64_t *)&a11->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
      std::__shared_weak_count::__release_weak(a11);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext36forceLoadRemoteConfigurationFromDiskENSt3__18functionIFvbNS1_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCEEAD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c120_ZTSKZN12SafeBrowsing13LookupContext36forceLoadRemoteConfigurationFromDiskENSt3__18functionIFvbNS1_10error_codeEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::handleForceLoadRemoteConfigurationFromDiskReply(uint64_t a1, void *a2, uint64_t a3)
{
  id v4;
  char v5;
  const std::error_category *v6;
  uint64_t v7;
  const std::error_category *v8;
  const std::error_category *cat;
  NSObject *v10;
  std::string v11;
  std::error_code v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (MEMORY[0x1DF0B91F0]() == MEMORY[0x1E0C81310])
  {
    v7 = Platform::xpcErrorCode(v4);
    cat = v8;
    *(_QWORD *)&v12.__val_ = v7;
    v12.__cat_ = v8;
    if ((_DWORD)v7)
    {
      v10 = (id)SSBOSLogRemoteConfiguration();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        std::error_code::message(&v11, &v12);
        SafeBrowsing::LookupContext::handleForceLoadRemoteConfigurationFromDiskReply();
      }

      v7 = *(_QWORD *)&v12.__val_;
      cat = v12.__cat_;
    }
    std::function<void ()(BOOL,std::error_code)>::operator()(a3, 0, v7, (uint64_t)cat);
  }
  else
  {
    v5 = xpc_dictionary_get_BOOL(v4, "loadRemoteConfigurationState");
    v6 = std::system_category();
    std::function<void ()(BOOL,std::error_code)>::operator()(a3, v5, 0, (uint64_t)v6);
  }

}

void sub_1DBCEEC3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::forceUpdateRemoteConfigurationFromServer(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD v27[3];
  _QWORD *v28;
  _QWORD block[5];
  std::__shared_weak_count *v30;
  _BYTE v31[24];
  _BYTE *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v23, a1);
  v4 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext40forceUpdateRemoteConfigurationFromServerENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke;
  block[3] = &__block_descriptor_80_ea8_32c124_ZTSKZN12SafeBrowsing13LookupContext40forceUpdateRemoteConfigurationFromServerENSt3__18functionIFvbNS1_10error_codeEEEEE3__0_e5_v8__0l;
  v25 = v23;
  v26 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = v27;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v27, a2);
  block[4] = v25;
  v30 = v26;
  if (v26)
  {
    v8 = (unint64_t *)&v26->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = v31;
  v11 = (uint64_t)v28;
  if (!v28)
    goto LABEL_10;
  if (v28 != v27)
  {
    v11 = (*(uint64_t (**)(void))(*v28 + 16))();
LABEL_10:
    v32 = (_BYTE *)v11;
    goto LABEL_12;
  }
  v32 = v31;
  (*(void (**)(_QWORD *, _BYTE *))(v27[0] + 24))(v27, v31);
LABEL_12:
  dispatch_async(v4, block);
  if (v28 == v27)
  {
    v12 = 4;
    goto LABEL_16;
  }
  if (v28)
  {
    v12 = 5;
    v7 = v28;
LABEL_16:
    (*(void (**)(_QWORD *))(*v7 + 8 * v12))(v7);
  }
  v13 = v26;
  if (v26)
  {
    v14 = (unint64_t *)&v26->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v32 == v31)
  {
    v16 = 4;
    goto LABEL_26;
  }
  if (v32)
  {
    v16 = 5;
    v10 = v32;
LABEL_26:
    (*(void (**)(_QWORD *))(*v10 + 8 * v16))(v10);
  }
  v17 = v30;
  if (v30)
  {
    v18 = (unint64_t *)&v30->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1DBCEEEB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing13LookupContext40forceUpdateRemoteConfigurationFromServerENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  void *v3;
  uint64_t v4;
  _xpc_connection_s *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  _QWORD v24[3];
  _QWORD *v25;
  _QWORD handler[5];
  std::__shared_weak_count *v27;
  _BYTE v28[24];
  _BYTE *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)(a1 + 32);
  SafeBrowsing::LookupContext::ensureConnection(*(SafeBrowsing::LookupContext **)(a1 + 32));
  SafeBrowsing::createMessage(6u);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = *v2;
  v6 = *(NSObject **)(*v2 + 16);
  v5 = *(_xpc_connection_s **)(*v2 + 24);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZZN12SafeBrowsing13LookupContext40forceUpdateRemoteConfigurationFromServerENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEv_block_invoke;
  handler[3] = &__block_descriptor_80_ea8_32c173_ZTSKZZN12SafeBrowsing13LookupContext40forceUpdateRemoteConfigurationFromServerENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE__e33_v16__0__NSObject_OS_xpc_object__8l;
  v7 = *(std::__shared_weak_count **)(a1 + 40);
  v22 = v4;
  v23 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = v24;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v24, a1 + 48);
  handler[4] = v22;
  v27 = v23;
  if (v23)
  {
    v11 = (unint64_t *)&v23->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = v28;
  v14 = (uint64_t)v25;
  if (!v25)
    goto LABEL_10;
  if (v25 != v24)
  {
    v14 = (*(uint64_t (**)(void))(*v25 + 16))();
LABEL_10:
    v29 = (_BYTE *)v14;
    goto LABEL_12;
  }
  v29 = v28;
  (*(void (**)(_QWORD *, _BYTE *))(v24[0] + 24))(v24, v28);
LABEL_12:
  xpc_connection_send_message_with_reply(v5, v3, v6, handler);
  if (v25 == v24)
  {
    v15 = 4;
    goto LABEL_16;
  }
  if (v25)
  {
    v15 = 5;
    v10 = v25;
LABEL_16:
    (*(void (**)(_QWORD *))(*v10 + 8 * v15))(v10);
  }
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  if (v29 == v28)
  {
    v18 = 4;
    goto LABEL_26;
  }
  if (v29)
  {
    v18 = 5;
    v13 = v29;
LABEL_26:
    (*(void (**)(_QWORD *))(*v13 + 8 * v18))(v13);
  }
  v19 = v27;
  if (v27)
  {
    v20 = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

}

void sub_1DBCEF124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, _QWORD *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  void *v21;
  _QWORD *v22;
  unint64_t *p_shared_owners;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;

  if (a21)
  {
    p_shared_owners = (unint64_t *)&a21->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))a21->__on_zero_shared)(a21);
      std::__shared_weak_count::__release_weak(a21);
    }
  }
  if (a15 == v22)
  {
    v26 = 4;
  }
  else
  {
    if (!a15)
      goto LABEL_11;
    v26 = 5;
    v22 = a15;
  }
  (*(void (**)(_QWORD *))(*v22 + 8 * v26))(v22);
LABEL_11:
  if (a11)
  {
    v27 = (unint64_t *)&a11->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
      std::__shared_weak_count::__release_weak(a11);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c124_ZTSKZN12SafeBrowsing13LookupContext40forceUpdateRemoteConfigurationFromServerENSt3__18functionIFvbNS1_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCEF2A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c124_ZTSKZN12SafeBrowsing13LookupContext40forceUpdateRemoteConfigurationFromServerENSt3__18functionIFvbNS1_10error_codeEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::handleForceUpdateRemoteConfigurationFromServerReply(uint64_t a1, void *a2, uint64_t a3)
{
  id v4;
  char v5;
  const std::error_category *v6;
  uint64_t v7;
  const std::error_category *v8;
  const std::error_category *cat;
  NSObject *v10;
  std::string v11;
  std::error_code v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (MEMORY[0x1DF0B91F0]() == MEMORY[0x1E0C81310])
  {
    v7 = Platform::xpcErrorCode(v4);
    cat = v8;
    *(_QWORD *)&v12.__val_ = v7;
    v12.__cat_ = v8;
    if ((_DWORD)v7)
    {
      v10 = (id)SSBOSLogRemoteConfiguration();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        std::error_code::message(&v11, &v12);
        SafeBrowsing::LookupContext::handleForceUpdateRemoteConfigurationFromServerReply();
      }

      v7 = *(_QWORD *)&v12.__val_;
      cat = v12.__cat_;
    }
    std::function<void ()(BOOL,std::error_code)>::operator()(a3, 0, v7, (uint64_t)cat);
  }
  else
  {
    v5 = xpc_dictionary_get_BOOL(v4, "updateRemoteConfigurationState");
    v6 = std::system_category();
    std::function<void ()(BOOL,std::error_code)>::operator()(a3, v5, 0, (uint64_t)v6);
  }

}

void sub_1DBCEF40C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::deleteAllDatabases(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD v27[3];
  _QWORD *v28;
  _QWORD block[5];
  std::__shared_weak_count *v30;
  _BYTE v31[24];
  _BYTE *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v23, a1);
  v4 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext18deleteAllDatabasesENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke;
  block[3] = &__block_descriptor_80_ea8_32c102_ZTSKZN12SafeBrowsing13LookupContext18deleteAllDatabasesENSt3__18functionIFvbNS1_10error_codeEEEEE3__0_e5_v8__0l;
  v25 = v23;
  v26 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = v27;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v27, a2);
  block[4] = v25;
  v30 = v26;
  if (v26)
  {
    v8 = (unint64_t *)&v26->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = v31;
  v11 = (uint64_t)v28;
  if (!v28)
    goto LABEL_10;
  if (v28 != v27)
  {
    v11 = (*(uint64_t (**)(void))(*v28 + 16))();
LABEL_10:
    v32 = (_BYTE *)v11;
    goto LABEL_12;
  }
  v32 = v31;
  (*(void (**)(_QWORD *, _BYTE *))(v27[0] + 24))(v27, v31);
LABEL_12:
  dispatch_async(v4, block);
  if (v28 == v27)
  {
    v12 = 4;
    goto LABEL_16;
  }
  if (v28)
  {
    v12 = 5;
    v7 = v28;
LABEL_16:
    (*(void (**)(_QWORD *))(*v7 + 8 * v12))(v7);
  }
  v13 = v26;
  if (v26)
  {
    v14 = (unint64_t *)&v26->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v32 == v31)
  {
    v16 = 4;
    goto LABEL_26;
  }
  if (v32)
  {
    v16 = 5;
    v10 = v32;
LABEL_26:
    (*(void (**)(_QWORD *))(*v10 + 8 * v16))(v10);
  }
  v17 = v30;
  if (v30)
  {
    v18 = (unint64_t *)&v30->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1DBCEF688(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing13LookupContext18deleteAllDatabasesENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  void *v3;
  uint64_t v4;
  _xpc_connection_s *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  _QWORD v24[3];
  _QWORD *v25;
  _QWORD handler[5];
  std::__shared_weak_count *v27;
  _BYTE v28[24];
  _BYTE *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)(a1 + 32);
  SafeBrowsing::LookupContext::ensureConnection(*(SafeBrowsing::LookupContext **)(a1 + 32));
  SafeBrowsing::createMessage(7u);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = *v2;
  v6 = *(NSObject **)(*v2 + 16);
  v5 = *(_xpc_connection_s **)(*v2 + 24);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZZN12SafeBrowsing13LookupContext18deleteAllDatabasesENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEv_block_invoke;
  handler[3] = &__block_descriptor_80_ea8_32c151_ZTSKZZN12SafeBrowsing13LookupContext18deleteAllDatabasesENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE__e33_v16__0__NSObject_OS_xpc_object__8l;
  v7 = *(std::__shared_weak_count **)(a1 + 40);
  v22 = v4;
  v23 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = v24;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v24, a1 + 48);
  handler[4] = v22;
  v27 = v23;
  if (v23)
  {
    v11 = (unint64_t *)&v23->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = v28;
  v14 = (uint64_t)v25;
  if (!v25)
    goto LABEL_10;
  if (v25 != v24)
  {
    v14 = (*(uint64_t (**)(void))(*v25 + 16))();
LABEL_10:
    v29 = (_BYTE *)v14;
    goto LABEL_12;
  }
  v29 = v28;
  (*(void (**)(_QWORD *, _BYTE *))(v24[0] + 24))(v24, v28);
LABEL_12:
  xpc_connection_send_message_with_reply(v5, v3, v6, handler);
  if (v25 == v24)
  {
    v15 = 4;
    goto LABEL_16;
  }
  if (v25)
  {
    v15 = 5;
    v10 = v25;
LABEL_16:
    (*(void (**)(_QWORD *))(*v10 + 8 * v15))(v10);
  }
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  if (v29 == v28)
  {
    v18 = 4;
    goto LABEL_26;
  }
  if (v29)
  {
    v18 = 5;
    v13 = v29;
LABEL_26:
    (*(void (**)(_QWORD *))(*v13 + 8 * v18))(v13);
  }
  v19 = v27;
  if (v27)
  {
    v20 = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

}

void sub_1DBCEF8F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, _QWORD *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  void *v21;
  _QWORD *v22;
  unint64_t *p_shared_owners;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;

  if (a21)
  {
    p_shared_owners = (unint64_t *)&a21->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))a21->__on_zero_shared)(a21);
      std::__shared_weak_count::__release_weak(a21);
    }
  }
  if (a15 == v22)
  {
    v26 = 4;
  }
  else
  {
    if (!a15)
      goto LABEL_11;
    v26 = 5;
    v22 = a15;
  }
  (*(void (**)(_QWORD *))(*v22 + 8 * v26))(v22);
LABEL_11:
  if (a11)
  {
    v27 = (unint64_t *)&a11->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
      std::__shared_weak_count::__release_weak(a11);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c102_ZTSKZN12SafeBrowsing13LookupContext18deleteAllDatabasesENSt3__18functionIFvbNS1_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCEFA70(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c102_ZTSKZN12SafeBrowsing13LookupContext18deleteAllDatabasesENSt3__18functionIFvbNS1_10error_codeEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::handleDeleteAllDatabasesReply(uint64_t a1, void *a2, uint64_t a3)
{
  id v4;
  char v5;
  const std::error_category *v6;
  uint64_t v7;
  const std::error_category *v8;
  const std::error_category *cat;
  NSObject *v10;
  std::string v11;
  std::error_code v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (MEMORY[0x1DF0B91F0]() == MEMORY[0x1E0C81310])
  {
    v7 = Platform::xpcErrorCode(v4);
    cat = v8;
    *(_QWORD *)&v12.__val_ = v7;
    v12.__cat_ = v8;
    if ((_DWORD)v7)
    {
      v10 = (id)SSBOSLogDatabase();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        std::error_code::message(&v11, &v12);
        SafeBrowsing::LookupContext::handleDeleteAllDatabasesReply();
      }

      v7 = *(_QWORD *)&v12.__val_;
      cat = v12.__cat_;
    }
    std::function<void ()(BOOL,std::error_code)>::operator()(a3, 0, v7, (uint64_t)cat);
  }
  else
  {
    v5 = xpc_dictionary_get_BOOL(v4, "deleteAllDatabasesState");
    v6 = std::system_category();
    std::function<void ()(BOOL,std::error_code)>::operator()(a3, v5, 0, (uint64_t)v6);
  }

}

void sub_1DBCEFBDC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::setClientIsInUse(SafeBrowsing::LookupContext *this)
{
  NSObject *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[4];
  uint64_t v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;

  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v18, this);
  v2 = *((_QWORD *)this + 2);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3321888768;
  v15[2] = ___ZN12SafeBrowsing13LookupContext16setClientIsInUseEv_block_invoke;
  v15[3] = &__block_descriptor_48_ea8_32c61_ZTSKZN12SafeBrowsing13LookupContext16setClientIsInUseEvE3__0_e5_v8__0l;
  v3 = v18;
  v4 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    v16 = v3;
    v17 = v4;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    dispatch_async(v2, v15);
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  else
  {
    v16 = v18;
    v17 = 0;
    dispatch_async(v2, v15);
  }
  v9 = v17;
  if (v17)
  {
    v10 = (unint64_t *)&v17->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v19;
  if (v19)
  {
    v13 = (unint64_t *)&v19->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void ___ZN12SafeBrowsing13LookupContext16setClientIsInUseEv_block_invoke(uint64_t a1)
{
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  _xpc_connection_s *v7;
  NSObject *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD v17[4];
  uint64_t v18;
  std::__shared_weak_count *v19;

  if (!*(_BYTE *)(*(_QWORD *)(a1 + 32) + 160))
  {
    v2 = std::chrono::system_clock::now().__d_.__rep_ / 1000000;
    v3 = *(_QWORD *)(a1 + 32);
    if (*(_QWORD *)(v3 + 152) < v2)
    {
      *(_BYTE *)(v3 + 160) = 1;
      SafeBrowsing::LookupContext::ensureConnection((SafeBrowsing::LookupContext *)v3);
      SafeBrowsing::createMessage(8u);
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      v5 = *(_QWORD *)(a1 + 32);
      v6 = *(std::__shared_weak_count **)(a1 + 40);
      v8 = *(NSObject **)(v5 + 16);
      v7 = *(_xpc_connection_s **)(v5 + 24);
      v17[0] = MEMORY[0x1E0C809B0];
      v17[1] = 3321888768;
      v17[2] = ___ZZN12SafeBrowsing13LookupContext16setClientIsInUseEvENK3__0clEv_block_invoke;
      v17[3] = &__block_descriptor_48_ea8_32c110_ZTSKZZN12SafeBrowsing13LookupContext16setClientIsInUseEvENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE__e33_v16__0__NSObject_OS_xpc_object__8l;
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v10 = __ldxr(p_shared_owners);
        while (__stxr(v10 + 1, p_shared_owners));
        v18 = v5;
        v19 = v6;
        do
          v11 = __ldxr(p_shared_owners);
        while (__stxr(v11 + 1, p_shared_owners));
      }
      else
      {
        v18 = v5;
        v19 = 0;
      }
      xpc_connection_send_message_with_reply(v7, v4, v8, v17);
      if (v6)
      {
        v12 = (unint64_t *)&v6->__shared_owners_;
        do
          v13 = __ldaxr(v12);
        while (__stlxr(v13 - 1, v12));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
      v14 = v19;
      if (v19)
      {
        v15 = (unint64_t *)&v19->__shared_owners_;
        do
          v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }

    }
  }
}

void sub_1DBCEFEB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  void *v14;
  uint64_t v15;

  if (a14)
    ___ZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke_cold_1(a14);
  ___ZN12SafeBrowsing13LookupContext16setClientIsInUseEv_block_invoke_cold_1(v15 == 0, v15);

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c61_ZTSKZN12SafeBrowsing13LookupContext16setClientIsInUseEvE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c61_ZTSKZN12SafeBrowsing13LookupContext16setClientIsInUseEvE3__0(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::handleClientInUseReply(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  const std::error_category *v5;
  NSObject *v6;
  std::string v7;
  std::error_code v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = SSBOSLogDatabase();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    LOWORD(v7.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1DBCBE000, v4, OS_LOG_TYPE_INFO, "Received ClientInUse reply", (uint8_t *)&v7, 2u);
  }
  if (MEMORY[0x1DF0B91F0](v3) == MEMORY[0x1E0C81310])
  {
    *(_QWORD *)&v8.__val_ = Platform::xpcErrorCode(v3);
    v8.__cat_ = v5;
    v6 = (id)SSBOSLogDatabase();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      std::error_code::message(&v7, &v8);
      SafeBrowsing::LookupContext::handleClientInUseReply();
    }

  }
  else
  {
    *(_QWORD *)(a1 + 152) = xpc_dictionary_get_int64(v3, "nextMessageTime");
  }
  *(_BYTE *)(a1 + 160) = 0;

}

void sub_1DBCF0028(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void SafeBrowsing::LookupContext::fetchCellularDataPlan(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  _QWORD v27[3];
  _QWORD *v28;
  _QWORD block[5];
  std::__shared_weak_count *v30;
  _BYTE v31[24];
  _BYTE *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v23, a1);
  v4 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing13LookupContext21fetchCellularDataPlanENSt3__18functionIFvPKcNS1_10error_codeEEEE_block_invoke;
  block[3] = &__block_descriptor_80_ea8_32c107_ZTSKZN12SafeBrowsing13LookupContext21fetchCellularDataPlanENSt3__18functionIFvPKcNS1_10error_codeEEEEE3__0_e5_v8__0l;
  v25 = v23;
  v26 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = v27;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v27, a2);
  block[4] = v25;
  v30 = v26;
  if (v26)
  {
    v8 = (unint64_t *)&v26->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  v10 = v31;
  v11 = (uint64_t)v28;
  if (!v28)
    goto LABEL_10;
  if (v28 != v27)
  {
    v11 = (*(uint64_t (**)(void))(*v28 + 16))();
LABEL_10:
    v32 = (_BYTE *)v11;
    goto LABEL_12;
  }
  v32 = v31;
  (*(void (**)(_QWORD *, _BYTE *))(v27[0] + 24))(v27, v31);
LABEL_12:
  dispatch_async(v4, block);
  if (v28 == v27)
  {
    v12 = 4;
    goto LABEL_16;
  }
  if (v28)
  {
    v12 = 5;
    v7 = v28;
LABEL_16:
    (*(void (**)(_QWORD *))(*v7 + 8 * v12))(v7);
  }
  v13 = v26;
  if (v26)
  {
    v14 = (unint64_t *)&v26->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v32 == v31)
  {
    v16 = 4;
    goto LABEL_26;
  }
  if (v32)
  {
    v16 = 5;
    v10 = v32;
LABEL_26:
    (*(void (**)(_QWORD *))(*v10 + 8 * v16))(v10);
  }
  v17 = v30;
  if (v30)
  {
    v18 = (unint64_t *)&v30->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1DBCF02A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing13LookupContext21fetchCellularDataPlanENSt3__18functionIFvPKcNS1_10error_codeEEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  void *v3;
  uint64_t v4;
  _xpc_connection_s *v5;
  NSObject *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  _QWORD v24[3];
  _QWORD *v25;
  _QWORD handler[5];
  std::__shared_weak_count *v27;
  _BYTE v28[24];
  _BYTE *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)(a1 + 32);
  SafeBrowsing::LookupContext::ensureConnection(*(SafeBrowsing::LookupContext **)(a1 + 32));
  SafeBrowsing::createMessage(9u);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = *v2;
  v6 = *(NSObject **)(*v2 + 16);
  v5 = *(_xpc_connection_s **)(*v2 + 24);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZZN12SafeBrowsing13LookupContext21fetchCellularDataPlanENSt3__18functionIFvPKcNS1_10error_codeEEEEENK3__0clEv_block_invoke;
  handler[3] = &__block_descriptor_80_ea8_32c156_ZTSKZZN12SafeBrowsing13LookupContext21fetchCellularDataPlanENSt3__18functionIFvPKcNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE__e33_v16__0__NSObject_OS_xpc_object__8l;
  v7 = *(std::__shared_weak_count **)(a1 + 40);
  v22 = v4;
  v23 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = v24;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v24, a1 + 48);
  handler[4] = v22;
  v27 = v23;
  if (v23)
  {
    v11 = (unint64_t *)&v23->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  v13 = v28;
  v14 = (uint64_t)v25;
  if (!v25)
    goto LABEL_10;
  if (v25 != v24)
  {
    v14 = (*(uint64_t (**)(void))(*v25 + 16))();
LABEL_10:
    v29 = (_BYTE *)v14;
    goto LABEL_12;
  }
  v29 = v28;
  (*(void (**)(_QWORD *, _BYTE *))(v24[0] + 24))(v24, v28);
LABEL_12:
  xpc_connection_send_message_with_reply(v5, v3, v6, handler);
  if (v25 == v24)
  {
    v15 = 4;
    goto LABEL_16;
  }
  if (v25)
  {
    v15 = 5;
    v10 = v25;
LABEL_16:
    (*(void (**)(_QWORD *))(*v10 + 8 * v15))(v10);
  }
  if (v23)
  {
    v16 = (unint64_t *)&v23->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  if (v29 == v28)
  {
    v18 = 4;
    goto LABEL_26;
  }
  if (v29)
  {
    v18 = 5;
    v13 = v29;
LABEL_26:
    (*(void (**)(_QWORD *))(*v13 + 8 * v18))(v13);
  }
  v19 = v27;
  if (v27)
  {
    v20 = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

}

void sub_1DBCF0514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, _QWORD *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  void *v21;
  _QWORD *v22;
  unint64_t *p_shared_owners;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;

  if (a21)
  {
    p_shared_owners = (unint64_t *)&a21->__shared_owners_;
    do
      v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))a21->__on_zero_shared)(a21);
      std::__shared_weak_count::__release_weak(a21);
    }
  }
  if (a15 == v22)
  {
    v26 = 4;
  }
  else
  {
    if (!a15)
      goto LABEL_11;
    v26 = 5;
    v22 = a15;
  }
  (*(void (**)(_QWORD *))(*v22 + 8 * v26))(v22);
LABEL_11:
  if (a11)
  {
    v27 = (unint64_t *)&a11->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
      std::__shared_weak_count::__release_weak(a11);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c107_ZTSKZN12SafeBrowsing13LookupContext21fetchCellularDataPlanENSt3__18functionIFvPKcNS1_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCF0690(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c107_ZTSKZN12SafeBrowsing13LookupContext21fetchCellularDataPlanENSt3__18functionIFvPKcNS1_10error_codeEEEEE3__0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void SafeBrowsing::LookupContext::handleFetchCellularDataPlanReply(uint64_t a1, void *a2, uint64_t a3)
{
  id v4;
  const char *string;
  const std::error_category *v6;
  uint64_t v7;
  const std::error_category *v8;
  const std::error_category *cat;
  NSObject *v10;
  std::string v11;
  std::error_code v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  if (MEMORY[0x1DF0B91F0]() == MEMORY[0x1E0C81310])
  {
    v7 = Platform::xpcErrorCode(v4);
    cat = v8;
    *(_QWORD *)&v12.__val_ = v7;
    v12.__cat_ = v8;
    if ((_DWORD)v7)
    {
      v10 = (id)SSBOSLogDatabase();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        std::error_code::message(&v11, &v12);
        SafeBrowsing::LookupContext::handleFetchCellularDataPlanReply();
      }

      v7 = *(_QWORD *)&v12.__val_;
      cat = v12.__cat_;
    }
    std::function<void ()(char const*,std::error_code)>::operator()(a3, 0, v7, (uint64_t)cat);
  }
  else
  {
    string = xpc_dictionary_get_string(v4, "cellularDataPlan");
    v6 = std::system_category();
    std::function<void ()(char const*,std::error_code)>::operator()(a3, (uint64_t)string, 0, (uint64_t)v6);
  }

}

void sub_1DBCF07FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::function<void ()(char const*,std::error_code)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  std::string *v5;
  void *v6;
  uint64_t v7;
  _QWORD v8[2];

  v8[0] = a3;
  v8[1] = a4;
  v7 = a2;
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
  {
    (*(void (**)(uint64_t, uint64_t *, _QWORD *))(*(_QWORD *)v4 + 48))(v4, &v7, v8);
  }
  else
  {
    v5 = std::__throw_bad_function_call[abi:sn180100]();
    SafeBrowsing::LookupContext::handleGetSafeBrowsingEnabledStateReply((uint64_t)v5, v6);
  }
}

void SafeBrowsing::LookupContext::handleGetSafeBrowsingEnabledStateReply(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  std::string::size_type size;
  std::string::size_type v7;
  char v8;
  const std::error_category *v9;
  void ***p_p_buf;
  const std::error_category *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  std::string *p_buf;
  __int128 v17;
  std::string buf;
  std::error_code v19;
  _QWORD v20[5];

  v20[4] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = SSBOSLogXPC();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1DBCBE000, v4, OS_LOG_TYPE_INFO, "Receive GetSafeBrowsingEnabledState response from safe browsing service", (uint8_t *)&buf, 2u);
  }
  *(_BYTE *)(a1 + 163) = 0;
  if (MEMORY[0x1DF0B91F0](v3) == MEMORY[0x1E0C81310])
  {
    *(_QWORD *)&v19.__val_ = Platform::xpcErrorCode(v3);
    v19.__cat_ = v11;
    if (v19.__val_)
    {
      v12 = (id)SSBOSLogXPC();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        std::error_code::message(&buf, &v19);
        SafeBrowsing::LookupContext::handleGetSafeBrowsingEnabledStateReply();
      }

    }
    v13 = *(_QWORD *)(a1 + 168);
    p_buf = (std::string *)v13;
    v17 = *(_OWORD *)(a1 + 176);
    v14 = v17;
    *(_QWORD *)(a1 + 176) = 0;
    *(_QWORD *)(a1 + 184) = 0;
    *(_QWORD *)(a1 + 168) = 0;
    v15 = v14;
    while (v13 != v15)
    {
      std::function<void ()(BOOL,std::error_code)>::operator()(v13, 1, *(uint64_t *)&v19.__val_, (uint64_t)v19.__cat_);
      v13 += 32;
    }
    v20[0] = &p_buf;
    p_p_buf = (void ***)v20;
  }
  else
  {
    *(_BYTE *)(a1 + 161) = xpc_dictionary_get_BOOL(v3, "safeBrowsingEnabled");
    *(_BYTE *)(a1 + 162) = 0;
    v5 = *(_QWORD *)(a1 + 168);
    buf.__r_.__value_.__r.__words[0] = v5;
    *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = *(_OWORD *)(a1 + 176);
    size = buf.__r_.__value_.__l.__size_;
    *(_QWORD *)(a1 + 176) = 0;
    *(_QWORD *)(a1 + 184) = 0;
    *(_QWORD *)(a1 + 168) = 0;
    v7 = size;
    while (v5 != v7)
    {
      v8 = *(_BYTE *)(a1 + 161);
      v9 = std::system_category();
      std::function<void ()(BOOL,std::error_code)>::operator()(v5, v8, 0, (uint64_t)v9);
      v5 += 32;
    }
    p_buf = &buf;
    p_p_buf = (void ***)&p_buf;
  }
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](p_p_buf);

}

void sub_1DBCF0A34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  uint64_t v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (!v2)
    return;
  v4 = (char *)v1[1];
  v5 = **a1;
  if (v4 == v2)
    goto LABEL_10;
  do
  {
    v6 = v4 - 32;
    v7 = (char *)*((_QWORD *)v4 - 1);
    if (v4 - 32 == v7)
    {
      v7 = v4 - 32;
      v8 = 4;
    }
    else
    {
      if (!v7)
        goto LABEL_8;
      v8 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_8:
    v4 = v6;
  }
  while (v6 != v2);
  v5 = **a1;
LABEL_10:
  v1[1] = v2;
  operator delete(v5);
}

_QWORD *std::function<void ()(Backend::Google::DatabaseConfiguration)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v6, a2);
  std::__function::__value_func<void ()(Backend::Google::DatabaseConfiguration)>::swap[abi:sn180100](v6, a1);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD *v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = ((_DWORD)v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v13 = (_QWORD *)(a1 + 16);
  v11 = operator new(0x38uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  v11[6] = 0;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    v16 = 1;
    if (v8 >= 3)
      v16 = (v8 & (v8 - 1)) != 0;
    v17 = v16 | (2 * v8);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::__rehash<true>(a1, v19);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = ((_DWORD)v8 - 1) & v7;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *v11 = *v21;
LABEL_38:
    *v21 = v11;
    goto LABEL_39;
  }
  *v11 = *v13;
  *v13 = v11;
  *(_QWORD *)(v20 + 8 * v4) = v13;
  if (*v11)
  {
    v22 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8)
        v22 %= v8;
    }
    else
    {
      v22 &= v8 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_1DBCF0DF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,void *>>>::operator()[abi:sn180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,void *>>>::operator()[abi:sn180100](uint64_t a1, _QWORD *__p)
{
  _QWORD *v3;
  uint64_t v4;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = (_QWORD *)__p[6];
    if (v3 == __p + 3)
    {
      v4 = 4;
      v3 = __p + 3;
      goto LABEL_8;
    }
    if (v3)
    {
      v4 = 5;
LABEL_8:
      (*(void (**)(void))(*v3 + 8 * v4))();
    }
LABEL_9:
    operator delete(__p);
    return;
  }
  if (__p)
    goto LABEL_9;
}

_QWORD *std::__function::__value_func<void ()(Backend::Google::DatabaseConfiguration)>::swap[abi:sn180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

char *std::vector<std::function<void ()(std::error_code)>>::__push_back_slow_path<std::function<void ()(std::error_code)> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  char *result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14[2];
  char *v15;
  char *v16;
  char *v17;

  v2 = *a1;
  v3 = (a1[1] - *a1) >> 5;
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59)
    abort();
  v8 = a1[2];
  result = (char *)(a1 + 2);
  v9 = v8 - v2;
  if (v9 >> 4 > v4)
    v4 = v9 >> 4;
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0)
    v10 = 0x7FFFFFFFFFFFFFFLL;
  else
    v10 = v4;
  v17 = result;
  if (v10
    && (v11 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<std::array<unsigned char,32ul>>>((uint64_t)result, v10), result = &v11[32 * v3], v14[0] = v11, v14[1] = result, v15 = result, v16 = &v11[32 * v12], v11))
  {
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)result, a2);
    v15 += 32;
    std::vector<std::function<void ()(std::error_code)>>::__swap_out_circular_buffer(a1, v14);
    v13 = a1[1];
    std::__split_buffer<std::function<void ()(std::error_code)>>::~__split_buffer(v14);
    return (char *)v13;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_1DBCF10AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::function<void ()(std::error_code)>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<std::function<void ()(std::error_code)>>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  if (v4 == *result)
  {
    v7 = a2[1];
  }
  else
  {
    do
    {
      v7 = v6 - 32;
      v8 = v4 - 32;
      v9 = *(_QWORD *)(v4 - 8);
      if (v9)
      {
        if (v8 == v9)
        {
          *(_QWORD *)(v6 - 8) = v7;
          result = (uint64_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 - 8) + 24))(*(_QWORD *)(v4 - 8), v6 - 32);
        }
        else
        {
          *(_QWORD *)(v6 - 8) = v9;
          *(_QWORD *)(v4 - 8) = 0;
        }
      }
      else
      {
        *(_QWORD *)(v6 - 8) = 0;
      }
      v4 = v8;
      v6 = v7;
    }
    while (v8 != v5);
  }
  a2[1] = v7;
  v10 = *v3;
  *v3 = v7;
  a2[1] = v10;
  v11 = v3[1];
  v3[1] = a2[2];
  a2[2] = v11;
  v12 = v3[2];
  v3[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

uint64_t std::construct_at[abi:sn180100]<std::function<void ()(std::error_code)>,std::function<void ()(std::error_code)>,std::function<void ()(std::error_code)>*>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v2 = result;
    v3 = *(_QWORD *)(a2 + 24);
    if (v3)
    {
      if (v3 == a2)
      {
        *(_QWORD *)(result + 24) = result;
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), result);
      }
      else
      {
        *(_QWORD *)(result + 24) = v3;
        *(_QWORD *)(a2 + 24) = 0;
      }
    }
    else
    {
      *(_QWORD *)(result + 24) = 0;
    }
    return v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void **std::__split_buffer<std::function<void ()(std::error_code)>>::~__split_buffer(void **a1)
{
  std::__split_buffer<std::function<void ()(std::error_code)>>::clear[abi:sn180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

_QWORD *std::__split_buffer<std::function<void ()(std::error_code)>>::clear[abi:sn180100](_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  v2 = (_QWORD *)result[1];
  v1 = (_QWORD *)result[2];
  if (v1 != v2)
  {
    v3 = result;
    while (1)
    {
      result = v1 - 4;
      v3[2] = v1 - 4;
      v4 = (_QWORD *)*(v1 - 1);
      if (v4 == result)
        break;
      if (v4)
      {
        result = v4;
        v5 = 5;
LABEL_7:
        (*(void (**)(void))(*result + 8 * v5))();
        result = (_QWORD *)v3[2];
      }
      v1 = result;
      if (result == v2)
        return result;
    }
    v5 = 4;
    goto LABEL_7;
  }
  return result;
}

void ___ZZN12SafeBrowsing13LookupContext36forceDeviceIdentificationTokenUpdateENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _BYTE v7[24];
  _BYTE *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v7, a1 + 48);
  SafeBrowsing::LookupContext::handleForceDeviceIdentificationTokenUpdateReply(v4, v3, (uint64_t)v7);
  v5 = v8;
  if (v8 == v7)
  {
    v6 = 4;
    v5 = v7;
    goto LABEL_5;
  }
  if (v8)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

}

void sub_1DBCF1340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  void *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == &a10)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c169_ZTSKZZN12SafeBrowsing13LookupContext36forceDeviceIdentificationTokenUpdateENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCF13DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c169_ZTSKZZN12SafeBrowsing13LookupContext36forceDeviceIdentificationTokenUpdateENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void ___ZZN12SafeBrowsing13LookupContext16getServiceStatusENSt3__18functionIFvNS_13ServiceStatusENS1_10error_codeEEEEENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _BYTE v7[24];
  _BYTE *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v7, a1 + 48);
  SafeBrowsing::LookupContext::handleGetServiceStatusReply(v4, v3, (uint64_t)v7);
  v5 = v8;
  if (v8 == v7)
  {
    v6 = 4;
    v5 = v7;
    goto LABEL_5;
  }
  if (v8)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

}

void sub_1DBCF14EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  void *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == &a10)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c167_ZTSKZZN12SafeBrowsing13LookupContext16getServiceStatusENSt3__18functionIFvNS_13ServiceStatusENS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCF1588(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c167_ZTSKZZN12SafeBrowsing13LookupContext16getServiceStatusENSt3__18functionIFvNS_13ServiceStatusENS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

char *std::vector<Backend::LookupResult>::__vallocate[abi:sn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    abort();
  result = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:sn180100]();
  return operator new(8 * a2);
}

void ___ZZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  SafeBrowsing::LookupContext::handleGetSafeBrowsingEnabledStateReply(*(_QWORD *)(a1 + 32), a2);
}

uint64_t __copy_helper_block_ea8_32c160_ZTSKZZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c160_ZTSKZZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

char *std::vector<std::function<void ()(BOOL,std::error_code)>>::__push_back_slow_path<std::function<void ()(BOOL,std::error_code)> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  char *result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14[2];
  char *v15;
  char *v16;
  char *v17;

  v2 = *a1;
  v3 = (a1[1] - *a1) >> 5;
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59)
    abort();
  v8 = a1[2];
  result = (char *)(a1 + 2);
  v9 = v8 - v2;
  if (v9 >> 4 > v4)
    v4 = v9 >> 4;
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0)
    v10 = 0x7FFFFFFFFFFFFFFLL;
  else
    v10 = v4;
  v17 = result;
  if (v10
    && (v11 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<std::array<unsigned char,32ul>>>((uint64_t)result, v10), result = &v11[32 * v3], v14[0] = v11, v14[1] = result, v15 = result, v16 = &v11[32 * v12], v11))
  {
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)result, a2);
    v15 += 32;
    std::vector<std::function<void ()(std::error_code)>>::__swap_out_circular_buffer(a1, v14);
    v13 = a1[1];
    std::__split_buffer<std::function<void ()(std::error_code)>>::~__split_buffer(v14);
    return (char *)v13;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_1DBCF1758(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::function<void ()(std::error_code)>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void ___ZZN12SafeBrowsing13LookupContext33dispatchWhenDatabasesAreAvailableEN7Backend6Google14ProtectionTypeENSt3__18functionIFvNS4_10error_codeEEEEENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  SafeBrowsing::LookupContext::handleGetDatabasesReply(*(_QWORD **)(a1 + 32), *(_DWORD *)(a1 + 48), a2);
}

uint64_t __copy_helper_block_ea8_32c198_ZTSKZZN12SafeBrowsing13LookupContext33dispatchWhenDatabasesAreAvailableEN7Backend6Google14ProtectionTypeENSt3__18functionIFvNS4_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

uint64_t __destroy_helper_block_ea8_32c198_ZTSKZZN12SafeBrowsing13LookupContext33dispatchWhenDatabasesAreAvailableEN7Backend6Google14ProtectionTypeENSt3__18functionIFvNS4_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

uint64_t std::vector<std::function<void ()(std::error_code)>>::push_back[abi:sn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *a1) >> 5;
    if ((unint64_t)(v10 + 1) >> 59)
      abort();
    v11 = v5 - *a1;
    v12 = v11 >> 4;
    if (v11 >> 4 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v13 = 0x7FFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<std::array<unsigned char,32ul>>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[32 * v10];
    v18 = &v14[32 * v13];
    std::construct_at[abi:sn180100]<std::function<void ()(std::error_code)>,std::function<void ()(std::error_code)>,std::function<void ()(std::error_code)>*>((uint64_t)v16, a2);
    v17 = v16 + 32;
    std::vector<std::function<void ()(std::error_code)>>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = (uint64_t)std::__split_buffer<std::function<void ()(std::error_code)>>::~__split_buffer(&v15);
  }
  else
  {
    result = std::construct_at[abi:sn180100]<std::function<void ()(std::error_code)>,std::function<void ()(std::error_code)>,std::function<void ()(std::error_code)>*>(*(_QWORD *)(v4 - 8), a2);
    v9 = v7 + 32;
    a1[1] = v7 + 32;
  }
  a1[1] = v9;
  return result;
}

void sub_1DBCF189C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::function<void ()(std::error_code)>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:sn180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

_QWORD *std::string::basic_string[abi:sn180100](_BYTE *a1, _BYTE *__src, size_t __len)
{
  _QWORD *v5;
  size_t v6;
  size_t v7;
  _BYTE *v8;

  v5 = a1;
  if (!__src && __len)
    goto LABEL_16;
  if (__len >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_17;
  if (__len > 0x16)
  {
    v6 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v6 = __len | 7;
    v7 = v6 + 1;
    a1 = operator new(v6 + 1);
    v5[1] = __len;
    v5[2] = v7 | 0x8000000000000000;
    *v5 = a1;
  }
  else
  {
    a1[23] = __len;
  }
  v8 = &a1[__len];
  if (a1 <= __src && v8 > __src)
  {
LABEL_16:
    __break(1u);
LABEL_17:
    abort();
  }
  if (__len)
    memmove(a1, __src, __len);
  *v8 = 0;
  return v5;
}

uint64_t std::vector<SafeBrowsing::ServiceStatus::Connection>::push_back[abi:sn180100](char **a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  __int128 v17;
  unint64_t v18;
  char *v19;
  char *v20;
  int v21;
  __int128 v22;
  int64x2_t v23;
  char *v24;
  uint64_t v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (v7 < v6)
  {
    if (v7)
    {
      *(_DWORD *)v7 = *(_DWORD *)a2;
      v8 = *(_OWORD *)(a2 + 8);
      *(_QWORD *)(v7 + 24) = *(_QWORD *)(a2 + 24);
      *(_OWORD *)(v7 + 8) = v8;
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 24) = 0;
      *(_QWORD *)(a2 + 8) = 0;
      v9 = (char *)(v7 + 32);
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v10 = (uint64_t)(v7 - (_QWORD)*a1) >> 5;
  v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 59)
    goto LABEL_20;
  v12 = v5 - (_QWORD)*a1;
  if (v12 >> 4 > v11)
    v11 = v12 >> 4;
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFE0)
    v13 = 0x7FFFFFFFFFFFFFFLL;
  else
    v13 = v11;
  v28 = result;
  if (!v13
    || (v14 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<std::array<unsigned char,32ul>>>(result, v13)) == 0)
  {
LABEL_19:
    __break(1u);
LABEL_20:
    abort();
  }
  v16 = &v14[32 * v10];
  *(_DWORD *)v16 = *(_DWORD *)a2;
  v17 = *(_OWORD *)(a2 + 8);
  *((_QWORD *)v16 + 3) = *(_QWORD *)(a2 + 24);
  *(_OWORD *)(v16 + 8) = v17;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v19 = *a1;
  v18 = (unint64_t)a1[1];
  if ((char *)v18 == *a1)
  {
    v23 = vdupq_n_s64(v18);
    v20 = &v14[32 * v10];
  }
  else
  {
    v20 = &v14[32 * v10];
    do
    {
      v21 = *(_DWORD *)(v18 - 32);
      v18 -= 32;
      *((_DWORD *)v20 - 8) = v21;
      v20 -= 32;
      v22 = *(_OWORD *)(v18 + 8);
      *((_QWORD *)v20 + 3) = *(_QWORD *)(v18 + 24);
      *(_OWORD *)(v20 + 8) = v22;
      *(_QWORD *)(v18 + 16) = 0;
      *(_QWORD *)(v18 + 24) = 0;
      *(_QWORD *)(v18 + 8) = 0;
    }
    while ((char *)v18 != v19);
    v23 = *(int64x2_t *)a1;
  }
  v9 = v16 + 32;
  *a1 = v20;
  a1[1] = v16 + 32;
  v26 = v23;
  v24 = a1[2];
  a1[2] = &v14[32 * v15];
  v27 = v24;
  v25 = v23.i64[0];
  result = std::__split_buffer<SafeBrowsing::ServiceStatus::Connection>::~__split_buffer((uint64_t)&v25);
LABEL_18:
  a1[1] = v9;
  return result;
}

uint64_t std::__split_buffer<SafeBrowsing::ServiceStatus::Connection>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<SafeBrowsing::ServiceStatus::Connection>::__destruct_at_end[abi:sn180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<SafeBrowsing::ServiceStatus::Connection>::__destruct_at_end[abi:sn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 32;
      *(_QWORD *)(a1 + 16) = v2 - 32;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        v5 = *(_QWORD *)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

uint64_t std::__call_once_proxy[abi:sn180100]<std::tuple<SafeBrowsing::allowGoogleSafeBrowsing(void)::$_0 &&>>()
{
  uint64_t result;

  result = dyld_program_sdk_at_least();
  SafeBrowsing::allowGoogleSafeBrowsing(void)::result = result;
  return result;
}

void ___ZZN12SafeBrowsing13LookupContext36forceLoadRemoteConfigurationFromDiskENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _BYTE v7[24];
  _BYTE *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v7, a1 + 48);
  SafeBrowsing::LookupContext::handleForceLoadRemoteConfigurationFromDiskReply(v4, v3, (uint64_t)v7);
  v5 = v8;
  if (v8 == v7)
  {
    v6 = 4;
    v5 = v7;
    goto LABEL_5;
  }
  if (v8)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

}

void sub_1DBCF1C60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  void *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == &a10)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c169_ZTSKZZN12SafeBrowsing13LookupContext36forceLoadRemoteConfigurationFromDiskENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCF1CFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c169_ZTSKZZN12SafeBrowsing13LookupContext36forceLoadRemoteConfigurationFromDiskENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void ___ZZN12SafeBrowsing13LookupContext40forceUpdateRemoteConfigurationFromServerENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _BYTE v7[24];
  _BYTE *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v7, a1 + 48);
  SafeBrowsing::LookupContext::handleForceUpdateRemoteConfigurationFromServerReply(v4, v3, (uint64_t)v7);
  v5 = v8;
  if (v8 == v7)
  {
    v6 = 4;
    v5 = v7;
    goto LABEL_5;
  }
  if (v8)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

}

void sub_1DBCF1E0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  void *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == &a10)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c173_ZTSKZZN12SafeBrowsing13LookupContext40forceUpdateRemoteConfigurationFromServerENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCF1EA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c173_ZTSKZZN12SafeBrowsing13LookupContext40forceUpdateRemoteConfigurationFromServerENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void ___ZZN12SafeBrowsing13LookupContext18deleteAllDatabasesENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _BYTE v7[24];
  _BYTE *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v7, a1 + 48);
  SafeBrowsing::LookupContext::handleDeleteAllDatabasesReply(v4, v3, (uint64_t)v7);
  v5 = v8;
  if (v8 == v7)
  {
    v6 = 4;
    v5 = v7;
    goto LABEL_5;
  }
  if (v8)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

}

void sub_1DBCF1FB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  void *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == &a10)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c151_ZTSKZZN12SafeBrowsing13LookupContext18deleteAllDatabasesENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCF2054(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c151_ZTSKZZN12SafeBrowsing13LookupContext18deleteAllDatabasesENSt3__18functionIFvbNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void ___ZZN12SafeBrowsing13LookupContext16setClientIsInUseEvENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  SafeBrowsing::LookupContext::handleClientInUseReply(*(_QWORD *)(a1 + 32), a2);
}

uint64_t __copy_helper_block_ea8_32c110_ZTSKZZN12SafeBrowsing13LookupContext16setClientIsInUseEvENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c110_ZTSKZZN12SafeBrowsing13LookupContext16setClientIsInUseEvENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void ___ZZN12SafeBrowsing13LookupContext21fetchCellularDataPlanENSt3__18functionIFvPKcNS1_10error_codeEEEEENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _BYTE v7[24];
  _BYTE *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v7, a1 + 48);
  SafeBrowsing::LookupContext::handleFetchCellularDataPlanReply(v4, v3, (uint64_t)v7);
  v5 = v8;
  if (v8 == v7)
  {
    v6 = 4;
    v5 = v7;
    goto LABEL_5;
  }
  if (v8)
  {
    v6 = 5;
LABEL_5:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

}

void sub_1DBCF2198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  void *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == &a10)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c156_ZTSKZZN12SafeBrowsing13LookupContext21fetchCellularDataPlanENSt3__18functionIFvPKcNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100](a1 + 48, a2 + 48);
}

void sub_1DBCF2234(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_32c156_ZTSKZZN12SafeBrowsing13LookupContext21fetchCellularDataPlanENSt3__18functionIFvPKcNS1_10error_codeEEEEENK3__0clEvEUlPU24objcproto13OS_xpc_object8NSObjectE_(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 48);
  v3 = *(_QWORD **)(a1 + 72);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 32);
}

void _ZNSt3__115allocate_sharedB8sn180100IN12SafeBrowsing27BrowsingDatabaseCoordinatorENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(_QWORD *a1@<X8>)
{
  _QWORD *v2;

  v2 = operator new(0x98uLL);
  _ZNSt3__120__shared_ptr_emplaceIN12SafeBrowsing27BrowsingDatabaseCoordinatorENS_9allocatorIS2_EEEC2B8sn180100IJES4_Li0EEES4_DpOT_((uint64_t)v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  std::shared_ptr<ByteProvider>::__enable_weak_this[abi:sn180100]<ByteProvider,ByteProvider,void>((uint64_t)a1, v2 + 4, (uint64_t)(v2 + 3));
}

void sub_1DBCF22D4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__120__shared_ptr_emplaceIN12SafeBrowsing27BrowsingDatabaseCoordinatorENS_9allocatorIS2_EEEC2B8sn180100IJES4_Li0EEES4_DpOT_(uint64_t a1)
{
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_1EA3EB920;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  SafeBrowsing::DatabaseCoordinator::DatabaseCoordinator(a1 + 24);
  *(_QWORD *)(a1 + 24) = off_1EA3EADE8;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_QWORD *)(a1 + 144) = 0;
  return a1;
}

void sub_1DBCF2360(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<SafeBrowsing::BrowsingDatabaseCoordinator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB920;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SafeBrowsing::BrowsingDatabaseCoordinator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB920;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<SafeBrowsing::BrowsingDatabaseCoordinator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::function<void ()(Backend::Google::DatabaseConfiguration)>>>>::__deallocate_node(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  if (__p)
  {
    v2 = __p;
    while (1)
    {
      v3 = (_QWORD *)*v2;
      v4 = (_QWORD *)v2[6];
      if (v4 == v2 + 3)
        break;
      if (v4)
      {
        v5 = 5;
LABEL_7:
        (*(void (**)(void))(*v4 + 8 * v5))();
      }
      operator delete(v2);
      v2 = v3;
      if (!v3)
        return;
    }
    v4 = v2 + 3;
    v5 = 4;
    goto LABEL_7;
  }
}

uint64_t std::__function::__func<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1>,void ()(std::error_code)>::~__func(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_1EA3E9E28;
  v2 = (_QWORD *)(a1 + 32);
  v3 = *(_QWORD **)(a1 + 56);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 8);
  return a1;
}

void std::__function::__func<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1>,void ()(std::error_code)>::~__func(char *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_1EA3E9E28;
  v2 = a1 + 32;
  v3 = (_QWORD *)*((_QWORD *)a1 + 7);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 8));
  operator delete(a1);
}

_QWORD *std::__function::__func<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1>,void ()(std::error_code)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x40uLL);
  *v2 = off_1EA3E9E28;
  std::__compressed_pair_elem<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1 const&,0ul>(v2 + 1, v1);
  return v2;
}

void sub_1DBCF2570(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1>,void ()(std::error_code)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1EA3E9E28;
  return std::__compressed_pair_elem<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1 const&,0ul>(a2 + 1, a1 + 8);
}

uint64_t std::__function::__func<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1>,void ()(std::error_code)>::destroy(uint64_t a1)
{
  return SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1::~$_1(a1 + 8);
}

void std::__function::__func<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1>,void ()(std::error_code)>::destroy_deallocate(void *a1)
{
  SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1::~$_1((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1>,void ()(std::error_code)>::operator()(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  if (*a2)
  {
    v2 = a2[1];
    v3 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(v3 + 136) = *a2;
    *(_QWORD *)(v3 + 144) = v2;
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 24));
}

_QWORD *std::__compressed_pair_elem<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1 const&,0ul>(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v4 = *(_QWORD *)(a2 + 8);
  *a1 = *(_QWORD *)a2;
  a1[1] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[2] = *(id *)(a2 + 16);
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(a1 + 3), a2 + 24);
  return a1;
}

void sub_1DBCF2648(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1>,void ()(BOOL,std::error_code)>::~__func(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_1EA3E9E70;
  v2 = (_QWORD *)(a1 + 32);
  v3 = *(_QWORD **)(a1 + 56);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 8);
  return a1;
}

void std::__function::__func<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1>,void ()(BOOL,std::error_code)>::~__func(char *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_1EA3E9E70;
  v2 = a1 + 32;
  v3 = (_QWORD *)*((_QWORD *)a1 + 7);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 8));
  operator delete(a1);
}

_QWORD *std::__function::__func<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1>,void ()(BOOL,std::error_code)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x40uLL);
  *v2 = off_1EA3E9E70;
  std::__compressed_pair_elem<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1 const&,0ul>(v2 + 1, v1);
  return v2;
}

void sub_1DBCF2784(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1>,void ()(BOOL,std::error_code)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1EA3E9E70;
  return std::__compressed_pair_elem<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1 const&,0ul>(a2 + 1, a1 + 8);
}

uint64_t std::__function::__func<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1>,void ()(BOOL,std::error_code)>::destroy(uint64_t a1)
{
  return SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1::~$_1(a1 + 8);
}

void std::__function::__func<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1>,void ()(BOOL,std::error_code)>::destroy_deallocate(void *a1)
{
  SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1::~$_1((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1>,void ()(BOOL,std::error_code)>::operator()(_QWORD *a1, unsigned __int8 *a2, uint64_t *a3)
{
  int v4;
  uint64_t v5;
  const std::error_category *cat;
  _QWORD *v7;
  void *v8;
  std::string *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  void *__p;
  void *v14;
  uint64_t v15;
  std::error_code v16;
  _QWORD v17[2];
  std::string v18;
  std::string *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  v5 = *a3;
  cat = (const std::error_category *)a3[1];
  *(_QWORD *)&v16.__val_ = *a3;
  v16.__cat_ = cat;
  if (v4)
  {
    v7 = (_QWORD *)a1[1];
    v8 = (void *)a1[3];
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)&v18, (uint64_t)(a1 + 4));
    SafeBrowsing::LookupContext::performURLLookup(v7, v8, (uint64_t)&v18);
    v9 = v19;
    if (v19 == &v18)
    {
      v10 = 4;
      v9 = &v18;
    }
    else
    {
      if (!v19)
        return;
      v10 = 5;
    }
    (*(void (**)(void))(v9->__r_.__value_.__r.__words[0] + 8 * v10))();
  }
  else
  {
    if ((_DWORD)v5)
    {
      v11 = (id)SSBOSLogXPC();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        std::error_code::message(&v18, &v16);
        std::__function::__func<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1>,void ()(BOOL,std::error_code)>::operator()();
      }

      v5 = *(_QWORD *)&v16.__val_;
      cat = v16.__cat_;
    }
    __p = 0;
    v14 = 0;
    v15 = 0;
    v17[0] = v5;
    v17[1] = cat;
    v12 = a1[7];
    if (v12)
    {
      (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)v12 + 48))(v12, &__p, v17);
      if (__p)
      {
        v14 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__throw_bad_function_call[abi:sn180100]();
      __break(1u);
    }
  }
}

void sub_1DBCF2924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  void *v20;

  _Unwind_Resume(a1);
}

_QWORD *std::__compressed_pair_elem<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1 const&,0ul>(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v4 = *(_QWORD *)(a2 + 8);
  *a1 = *(_QWORD *)a2;
  a1[1] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[2] = *(id *)(a2 + 16);
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(a1 + 3), a2 + 24);
  return a1;
}

void sub_1DBCF29E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0>,void ()(std::error_code)>::~__func(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_1EA3E9DE0;
  v2 = (_QWORD *)(a1 + 32);
  v3 = *(_QWORD **)(a1 + 56);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 8);
  return a1;
}

void std::__function::__func<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0>,void ()(std::error_code)>::~__func(char *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_1EA3E9DE0;
  v2 = a1 + 32;
  v3 = (_QWORD *)*((_QWORD *)a1 + 7);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 8));
  operator delete(a1);
}

_QWORD *std::__function::__func<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0>,void ()(std::error_code)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x40uLL);
  *v2 = off_1EA3E9DE0;
  std::__compressed_pair_elem<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0 const&,0ul>(v2 + 1, v1);
  return v2;
}

void sub_1DBCF2B24(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0>,void ()(std::error_code)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1EA3E9DE0;
  return std::__compressed_pair_elem<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0 const&,0ul>(a2 + 1, a1 + 8);
}

uint64_t std::__function::__func<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0>,void ()(std::error_code)>::destroy(uint64_t a1)
{
  return SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1::~$_1(a1 + 8);
}

void std::__function::__func<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0>,void ()(std::error_code)>::destroy_deallocate(void *a1)
{
  SafeBrowsing::LookupContext::getDatabaseStatus(std::function<void ()(SafeBrowsing::DatabaseStatus,std::error_code)>)::$_1::~$_1((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0>,void ()(std::error_code)>::operator()(uint64_t a1, std::error_code *a2)
{
  NSObject *v3;
  uint64_t v4;
  SafeBrowsing::LookupContext *v5;
  uint64_t *v6;
  void *v7;
  std::string *v8;
  uint64_t v9;
  void *__p;
  void *v11;
  uint64_t v12;
  std::error_code v13;
  std::error_code v14;
  std::string v15;
  std::string *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = *a2;
  if (v13.__val_)
  {
    v3 = (id)SSBOSLogDatabase();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      std::error_code::message(&v15, &v13);
      std::__function::__func<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0>,void ()(std::error_code)>::operator()();
    }

    __p = 0;
    v11 = 0;
    v12 = 0;
    v14 = v13;
    v4 = *(_QWORD *)(a1 + 56);
    if (v4)
    {
      (*(void (**)(uint64_t, void **, std::error_code *))(*(_QWORD *)v4 + 48))(v4, &__p, &v14);
      if (__p)
      {
        v11 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::__throw_bad_function_call[abi:sn180100]();
      __break(1u);
    }
  }
  else
  {
    SafeBrowsing::LookupContext::setClientIsInUse(*(SafeBrowsing::LookupContext **)(a1 + 8));
    v5 = *(SafeBrowsing::LookupContext **)(a1 + 8);
    v6 = (uint64_t *)*((_QWORD *)v5 + 15);
    v7 = *(void **)(a1 + 24);
    std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)&v15, a1 + 32);
    SafeBrowsing::BrowsingDatabaseCoordinator::performURLLookup(v6, v5, v7, &v15);
    v8 = v16;
    if (v16 == &v15)
    {
      v9 = 4;
      v8 = &v15;
    }
    else
    {
      if (!v16)
        return;
      v9 = 5;
    }
    (*(void (**)(void))(v8->__r_.__value_.__r.__words[0] + 8 * v9))();
  }
}

void sub_1DBCF2CD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  void *v20;

  _Unwind_Resume(a1);
}

_QWORD *std::__compressed_pair_elem<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0 const&,0ul>(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v4 = *(_QWORD *)(a2 + 8);
  *a1 = *(_QWORD *)a2;
  a1[1] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[2] = *(id *)(a2 + 16);
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(a1 + 3), a2 + 24);
  return a1;
}

void sub_1DBCF2D94(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_7_0()
{
  std::__shared_weak_count *v0;

  std::__shared_weak_count::__release_weak(v0);
}

uint64_t Backend::Google::unescapePercentEscapes(char **a1)
{
  char *v1;
  char *v2;
  uint64_t v4;
  char *v5;
  char *v6;
  unsigned __int8 *v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  char v12;
  char v13;
  char v14;
  char v15;
  char v16;
  char *v17;
  void *v18;
  unint64_t v19;
  int64_t v20;
  int64_t v21;
  unint64_t v22;
  size_t v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  char v28;
  char *v29;
  uint64_t result;
  void *__p[2];
  char *v32;

  __p[0] = 0;
  __p[1] = 0;
  v32 = 0;
  v2 = *a1;
  v1 = a1[1];
  if (*a1 == v1)
    goto LABEL_44;
  v4 = MEMORY[0x1E0C80978];
  v5 = *a1;
  do
  {
    v6 = v5;
    while (*v6 != 37)
    {
      if (++v6 == v1)
      {
        v6 = v1;
        break;
      }
    }
    if (v6 == v1)
      break;
    v5 = v6 + 1;
    v7 = (unsigned __int8 *)(v6 + 2);
    if (v6 + 2 < v1)
    {
      v8 = *v5;
      v9 = *v5;
      if (*v5 < 0)
      {
        if (!__maskrune(*v5, 0x10000uLL))
          continue;
      }
      else if ((*(_DWORD *)(v4 + 4 * v9 + 60) & 0x10000) == 0)
      {
        continue;
      }
      v10 = (char)*v7;
      v11 = *v7;
      v12 = v10;
      if (v10 < 0)
      {
        if (__maskrune(v11, 0x10000uLL))
        {
LABEL_17:
          if (v8 >= 0x41)
            v13 = 9;
          else
            v13 = 0;
          v14 = v13 + v9;
          v15 = v11 - 48;
          if (v11 >= 0x41)
            v15 = (v12 + 9) & 0xF;
          v16 = v15 | (16 * v14);
          std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)__p, (char *)__p[1], v2, v6, v6 - v2);
          v17 = (char *)__p[1];
          if (__p[1] >= v32)
          {
            v19 = (unint64_t)__p[0];
            v20 = (char *)__p[1] - (char *)__p[0];
            v21 = (char *)__p[1] - (char *)__p[0] + 1;
            if (v21 < 0)
              goto LABEL_48;
            v22 = v32 - (char *)__p[0];
            if (2 * (v32 - (char *)__p[0]) > (unint64_t)v21)
              v21 = 2 * v22;
            if (v22 >= 0x3FFFFFFFFFFFFFFFLL)
              v23 = 0x7FFFFFFFFFFFFFFFLL;
            else
              v23 = v21;
            if (!v23)
            {
LABEL_47:
              __break(1u);
LABEL_48:
              abort();
            }
            v24 = (char *)operator new(v23);
            v25 = &v24[v20];
            v26 = &v24[v20];
            *v26 = v16;
            v18 = v26 + 1;
            if (v17 != (char *)v19)
            {
              v27 = &v17[~v19];
              do
              {
                v28 = *--v17;
                (v27--)[(_QWORD)v24] = v28;
              }
              while (v17 != (char *)v19);
              v17 = (char *)v19;
              v25 = v24;
            }
            __p[0] = v25;
            __p[1] = v18;
            v32 = &v24[v23];
            if (v17)
              operator delete(v17);
          }
          else
          {
            if (!__p[1])
              goto LABEL_47;
            *(_BYTE *)__p[1] = v16;
            v18 = v17 + 1;
          }
          v5 = v6 + 3;
          __p[1] = v18;
          v2 = v6 + 3;
        }
      }
      else if ((*(_DWORD *)(v4 + 4 * v10 + 60) & 0x10000) != 0)
      {
        goto LABEL_17;
      }
    }
  }
  while (v5 != v1);
  if (v2 != *a1)
  {
    std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)__p, (char *)__p[1], v2, v1, v1 - v2);
    v29 = *a1;
    if (*a1)
    {
      a1[1] = v29;
      operator delete(v29);
    }
    *(_OWORD *)a1 = *(_OWORD *)__p;
    a1[2] = v32;
    return 1;
  }
LABEL_44:
  result = (uint64_t)__p[0];
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
    return 0;
  }
  return result;
}

uint64_t Backend::Google::repeatedlyUnescapePercentEscapes(char **a1)
{
  uint64_t result;

  do
    result = Backend::Google::unescapePercentEscapes(a1);
  while ((result & 1) != 0);
  return result;
}

uint64_t Backend::Google::percentEscape(uint64_t a1)
{
  char *v1;
  char *v2;
  char *v3;
  char *v4;
  unsigned __int8 v5;
  char *v6;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  size_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char v17;
  char v18;
  char v19;
  char *v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  size_t v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  char v30;
  char v31;
  char v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  size_t v37;
  void *v38;
  char *v39;
  char *v40;
  char *v41;
  char v42;
  char *v43;
  uint64_t result;
  __int128 v46;
  char *v47;

  v46 = 0uLL;
  v47 = 0;
  v1 = *(char **)a1;
  v2 = *(char **)(a1 + 8);
  if (*(char **)a1 == v2)
    return 0;
  v3 = 0;
  v4 = *(char **)a1;
  do
  {
    v5 = *v4;
    if ((*v4 - 127) < 0xA2u || *v4 == 37 || *v4 == 35)
    {
      std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)&v46, v3, v1, v4, v4 - v1);
      v6 = (char *)*((_QWORD *)&v46 + 1);
      if (*((_QWORD *)&v46 + 1) >= (unint64_t)v47)
      {
        v8 = v46;
        v9 = *((_QWORD *)&v46 + 1) - v46;
        v10 = *((_QWORD *)&v46 + 1) - v46 + 1;
        if (v10 < 0)
          goto LABEL_71;
        v11 = (unint64_t)&v47[-v46];
        if (2 * (uint64_t)&v47[-v46] > (unint64_t)v10)
          v10 = 2 * v11;
        if (v11 >= 0x3FFFFFFFFFFFFFFFLL)
          v12 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v12 = v10;
        if (!v12)
          goto LABEL_70;
        v13 = (char *)operator new(v12);
        v14 = &v13[v9];
        v15 = &v13[v9];
        *v15 = 37;
        v7 = v15 + 1;
        if (v6 != (char *)v8)
        {
          v16 = &v6[~v8];
          do
          {
            v17 = *--v6;
            (v16--)[(_QWORD)v13] = v17;
          }
          while (v6 != (char *)v8);
          v6 = (char *)v8;
          v14 = v13;
        }
        *(_QWORD *)&v46 = v14;
        *((_QWORD *)&v46 + 1) = v7;
        v47 = &v13[v12];
        if (v6)
          operator delete(v6);
      }
      else
      {
        if (!*((_QWORD *)&v46 + 1))
          goto LABEL_70;
        **((_BYTE **)&v46 + 1) = 37;
        v7 = v6 + 1;
      }
      *((_QWORD *)&v46 + 1) = v7;
      if (v5 >= 0xA0u)
        v18 = 55;
      else
        v18 = 48;
      v19 = v18 + (v5 >> 4);
      if (v7 >= v47)
      {
        v21 = v46;
        v22 = &v7[-v46];
        v23 = (uint64_t)&v7[-v46 + 1];
        if (v23 < 0)
          goto LABEL_71;
        v24 = (unint64_t)&v47[-v46];
        if (2 * (uint64_t)&v47[-v46] > (unint64_t)v23)
          v23 = 2 * v24;
        if (v24 >= 0x3FFFFFFFFFFFFFFFLL)
          v25 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v25 = v23;
        if (!v25)
          goto LABEL_70;
        v26 = operator new(v25);
        v27 = &v22[(_QWORD)v26];
        v28 = &v22[(_QWORD)v26];
        *v28 = v19;
        v20 = v28 + 1;
        if (v7 == (char *)v21)
        {
          *(_QWORD *)&v46 = v27;
          *((_QWORD *)&v46 + 1) = v20;
          v21 = (unint64_t)v7;
          v47 = (char *)v26 + v25;
        }
        else
        {
          v29 = &v7[~v21];
          do
          {
            v30 = *--v7;
            (v29--)[(_QWORD)v26] = v30;
          }
          while (v7 != (char *)v21);
          *(_QWORD *)&v46 = v26;
          *((_QWORD *)&v46 + 1) = v20;
          v47 = (char *)v26 + v25;
          if (!v21)
            goto LABEL_41;
        }
        operator delete((void *)v21);
      }
      else
      {
        *v7 = v19;
        v20 = v7 + 1;
      }
LABEL_41:
      *((_QWORD *)&v46 + 1) = v20;
      if ((v5 & 0xFu) >= 0xA)
        v31 = 55;
      else
        v31 = 48;
      v32 = v31 + (v5 & 0xF);
      if (v20 >= v47)
      {
        v33 = v46;
        v34 = &v20[-v46];
        v35 = (uint64_t)&v20[-v46 + 1];
        if (v35 < 0)
          goto LABEL_71;
        v36 = (unint64_t)&v47[-v46];
        if (2 * (uint64_t)&v47[-v46] > (unint64_t)v35)
          v35 = 2 * v36;
        if (v36 >= 0x3FFFFFFFFFFFFFFFLL)
          v37 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v37 = v35;
        if (!v37)
        {
LABEL_70:
          __break(1u);
LABEL_71:
          abort();
        }
        v38 = operator new(v37);
        v39 = &v34[(_QWORD)v38];
        v40 = &v34[(_QWORD)v38];
        *v40 = v32;
        v3 = v40 + 1;
        if (v20 == (char *)v33)
        {
          *(_QWORD *)&v46 = v39;
          *((_QWORD *)&v46 + 1) = v3;
          v33 = (unint64_t)v20;
          v47 = (char *)v38 + v37;
        }
        else
        {
          v41 = &v20[~v33];
          do
          {
            v42 = *--v20;
            (v41--)[(_QWORD)v38] = v42;
          }
          while (v20 != (char *)v33);
          *(_QWORD *)&v46 = v38;
          *((_QWORD *)&v46 + 1) = v3;
          v47 = (char *)v38 + v37;
          if (!v33)
            goto LABEL_60;
        }
        operator delete((void *)v33);
      }
      else
      {
        *v20 = v32;
        v3 = v20 + 1;
      }
LABEL_60:
      v1 = v4 + 1;
      *((_QWORD *)&v46 + 1) = v3;
    }
    ++v4;
  }
  while (v4 != v2);
  if (v1 == *(char **)a1)
  {
    result = v46;
    if ((_QWORD)v46)
    {
      *((_QWORD *)&v46 + 1) = v46;
      operator delete((void *)v46);
      return 0;
    }
  }
  else
  {
    std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)&v46, v3, v1, *(char **)(a1 + 8), *(_QWORD *)(a1 + 8) - (_QWORD)v1);
    v43 = *(char **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v43;
      operator delete(v43);
    }
    *(_OWORD *)a1 = v46;
    *(_QWORD *)(a1 + 16) = v47;
    return 1;
  }
  return result;
}

uint64_t Backend::Google::canonicalizeIPAddress(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  const char *v4;
  char *v5;
  size_t v6;
  char *v7;
  void *__p[2];
  uint64_t v10;
  in_addr v11;
  char v12[16];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  std::string::__init_with_size[abi:sn180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(__p, *(char **)a1, *(char **)(a1 + 8), *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  if (v10 >= 0)
    v2 = __p;
  else
    v2 = (void **)__p[0];
  v3 = inet_aton((const char *)v2, &v11);
  if (SHIBYTE(v10) < 0)
    operator delete(__p[0]);
  if ((_DWORD)v3)
  {
    v4 = inet_ntop(2, &v11, v12, 0x10u);
    v3 = v4 != 0;
    if (v4)
    {
      v5 = (char *)v4;
      v6 = strlen(v4);
      __p[1] = 0;
      v10 = 0;
      __p[0] = 0;
      std::vector<unsigned char>::__init_with_size[abi:sn180100]<char const*,char const*>((char *)__p, v5, &v5[v6], v6);
      v7 = *(char **)a1;
      if (*(_QWORD *)a1)
      {
        *(_QWORD *)(a1 + 8) = v7;
        operator delete(v7);
      }
      *(_OWORD *)a1 = *(_OWORD *)__p;
      *(_QWORD *)(a1 + 16) = v10;
    }
  }
  return v3;
}

uint64_t Backend::Google::canonicalizeHostName(uint64_t a1, _BYTE *a2)
{
  char *v4;
  char *v5;
  BOOL v6;
  uint64_t v7;
  uint64_t result;
  char *v9;
  BOOL v10;
  int64_t v11;
  int v12;
  char v13;

  while ((Backend::Google::unescapePercentEscapes((char **)a1) & 1) != 0)
    ;
  v5 = *(char **)a1;
  v4 = *(char **)(a1 + 8);
  if (*(char **)a1 != v4)
  {
    v6 = 1;
    v7 = MEMORY[0x1E0C80978];
    while (1)
    {
      result = *v5;
      if ((_DWORD)result == 46)
      {
        v9 = v5 + 1;
        v10 = v5 == *(char **)a1 || v9 == v4;
        if (v10 || *v9 == 46)
        {
          if (v4 == v5)
          {
            __break(1u);
            return result;
          }
          v11 = v4 - (v5 + 1);
          if (v4 != v5 + 1)
            memmove(v5, v5 + 1, v4 - (v5 + 1));
          v4 = &v5[v11];
          *(_QWORD *)(a1 + 8) = &v5[v11];
          goto LABEL_21;
        }
      }
      else
      {
        if ((result & 0xFFFFFFDF) != 88 && v6)
        {
          if ((result & 0x80) != 0)
          {
            v12 = __maskrune(result, 0x10000uLL);
            LODWORD(result) = *v5;
          }
          else
          {
            v12 = *(_DWORD *)(v7 + 4 * result + 60) & 0x10000;
          }
          v6 = v12 != 0;
        }
        *v5 = __tolower(result);
        v4 = *(char **)(a1 + 8);
      }
      ++v5;
LABEL_21:
      if (v5 == v4)
      {
        if (v6)
          break;
        v13 = 0;
        goto LABEL_25;
      }
    }
  }
  v13 = Backend::Google::canonicalizeIPAddress(a1);
LABEL_25:
  *a2 = v13;
  return Backend::Google::percentEscape(a1);
}

double Backend::Google::canonicalizePath(char **a1)
{
  unsigned __int8 *v2;
  char *v3;
  unsigned __int8 *v4;
  int v5;
  int v6;
  int v7;
  BOOL v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  _BYTE *v14;
  char *v15;
  uint64_t v16;
  unsigned __int8 *v17;
  int v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  size_t v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  char v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  size_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char v41;
  char *v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  _BYTE *v46;
  unint64_t v47;
  size_t v48;
  _BYTE *v49;
  unsigned __int8 *v50;
  double result;
  __int128 v52;
  unsigned __int8 *v53;

  v3 = *a1;
  v2 = (unsigned __int8 *)a1[1];
  v4 = (unsigned __int8 *)(*a1 + 1);
  v5 = **a1;
  while (1)
  {
    if (v4 == v2)
      return result;
    v7 = *v4++;
    v6 = v7;
    v8 = v5 == 47;
    v5 = v7;
    if (v8)
    {
      v5 = v6;
      if ((v6 & 0xFE) == 0x2E)
        break;
    }
  }
  v52 = 0uLL;
  v53 = 0;
  if (v3 == (char *)v2)
    goto LABEL_80;
  do
  {
    v9 = v3;
    v10 = v3 + 1;
    v11 = (char *)v2;
    if (v3 + 1 != (char *)v2)
    {
      v11 = v3 + 1;
      while (*v11 != 47)
      {
        if (++v11 == (char *)v2)
        {
          v11 = (char *)v2;
          break;
        }
      }
    }
    v12 = v11 - v10;
    v3 = v11;
    if (v11 != v10)
    {
      if (v12 == 2)
      {
        if (*v10 == 46 && v9[2] == 46)
        {
          v15 = (char *)*((_QWORD *)&v52 + 1);
          v16 = *((_QWORD *)&v52 + 1);
          v17 = (unsigned __int8 *)v52;
          while (v16 != (_QWORD)v52)
          {
            v18 = *(unsigned __int8 *)--v16;
            if (v18 == 47)
            {
              v19 = v16 + 1;
              goto LABEL_60;
            }
          }
          v19 = v52;
LABEL_60:
          if (v19 != (_QWORD)v52)
          {
            v42 = (char *)(v19 - 1);
            v43 = *((_QWORD *)&v52 + 1) >= (unint64_t)(v19 - 1);
            v44 = *((_QWORD *)&v52 + 1) - (v19 - 1);
            if (!v43)
              goto LABEL_84;
            if (v42 != *((char **)&v52 + 1))
            {
              v45 = *((_QWORD *)&v52 + 1) - (_QWORD)&v42[v44];
              if (*((char **)&v52 + 1) != &v42[v44])
              {
                memmove(v42, &v42[v44], *((_QWORD *)&v52 + 1) - (_QWORD)&v42[v44]);
                v17 = (unsigned __int8 *)v52;
                v2 = (unsigned __int8 *)a1[1];
              }
              v15 = &v42[v45];
              *((_QWORD *)&v52 + 1) = &v42[v45];
            }
          }
          if (v17 == (unsigned __int8 *)v15 && v3 == (char *)v2)
          {
            if (v17 >= v53)
            {
              v47 = 2 * (v53 - v17);
              if (v47 <= 1)
                v47 = 1;
              if ((unint64_t)(v53 - v17) >= 0x3FFFFFFFFFFFFFFFLL)
                v48 = 0x7FFFFFFFFFFFFFFFLL;
              else
                v48 = v47;
              v49 = operator new(v48);
              v50 = &v49[v48];
              *v49 = 47;
              v46 = v49 + 1;
              *(_QWORD *)&v52 = v49;
              *((_QWORD *)&v52 + 1) = v49 + 1;
              v53 = v50;
              if (v17)
                operator delete(v17);
            }
            else
            {
              if (!v17)
                goto LABEL_84;
              *v17 = 47;
              v46 = v17 + 1;
            }
            *((_QWORD *)&v52 + 1) = v46;
          }
          goto LABEL_57;
        }
LABEL_26:
        v20 = (char *)*((_QWORD *)&v52 + 1);
        if (*((_QWORD *)&v52 + 1) >= (unint64_t)v53)
        {
          v22 = (char *)v52;
          v23 = *((_QWORD *)&v52 + 1) - v52;
          v24 = *((_QWORD *)&v52 + 1) - v52 + 1;
          if (v24 < 0)
            goto LABEL_85;
          v25 = (unint64_t)&v53[-v52];
          if (2 * (uint64_t)&v53[-v52] > (unint64_t)v24)
            v24 = 2 * v25;
          if (v25 >= 0x3FFFFFFFFFFFFFFFLL)
            v26 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v26 = v24;
          if (!v26)
            goto LABEL_84;
          v27 = (char *)operator new(v26);
          v28 = &v27[v23];
          v29 = &v27[v23];
          *v29 = 47;
          v21 = v29 + 1;
          if (v20 != v22)
          {
            v30 = &v20[~(unint64_t)v22];
            do
            {
              v31 = *--v20;
              (v30--)[(_QWORD)v27] = v31;
            }
            while (v20 != v22);
            v20 = v22;
            v28 = v27;
          }
          *(_QWORD *)&v52 = v28;
          *((_QWORD *)&v52 + 1) = v21;
          v53 = (unsigned __int8 *)&v27[v26];
          if (v20)
            operator delete(v20);
        }
        else
        {
          if (!*((_QWORD *)&v52 + 1))
            goto LABEL_84;
          **((_BYTE **)&v52 + 1) = 47;
          v21 = v20 + 1;
        }
        *((_QWORD *)&v52 + 1) = v21;
        std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)&v52, v21, v10, v3, v12);
        goto LABEL_57;
      }
      if (v12 != 1 || *v10 != 46)
        goto LABEL_26;
    }
    if (v11 == (char *)v2)
    {
      v13 = (char *)*((_QWORD *)&v52 + 1);
      if (*((_QWORD *)&v52 + 1) >= (unint64_t)v53)
      {
        v32 = v52;
        v33 = *((_QWORD *)&v52 + 1) - v52;
        v34 = *((_QWORD *)&v52 + 1) - v52 + 1;
        if (v34 < 0)
          goto LABEL_85;
        v35 = (unint64_t)&v53[-v52];
        if (2 * (uint64_t)&v53[-v52] > (unint64_t)v34)
          v34 = 2 * v35;
        if (v35 >= 0x3FFFFFFFFFFFFFFFLL)
          v36 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v36 = v34;
        if (!v36)
        {
LABEL_84:
          __break(1u);
LABEL_85:
          abort();
        }
        v37 = (char *)operator new(v36);
        v38 = &v37[v33];
        v39 = &v37[v33];
        *v39 = 47;
        v14 = v39 + 1;
        if (v13 != (char *)v32)
        {
          v40 = &v13[~v32];
          do
          {
            v41 = *--v13;
            (v40--)[(_QWORD)v37] = v41;
          }
          while (v13 != (char *)v32);
          v13 = (char *)v32;
          v38 = v37;
        }
        *(_QWORD *)&v52 = v38;
        *((_QWORD *)&v52 + 1) = v14;
        v53 = (unsigned __int8 *)&v37[v36];
        if (v13)
          operator delete(v13);
      }
      else
      {
        if (!*((_QWORD *)&v52 + 1))
          goto LABEL_84;
        **((_BYTE **)&v52 + 1) = 47;
        v14 = v13 + 1;
      }
      *((_QWORD *)&v52 + 1) = v14;
    }
LABEL_57:
    v2 = (unsigned __int8 *)a1[1];
  }
  while (v3 != (char *)v2);
  v3 = *a1;
LABEL_80:
  if (v3)
  {
    a1[1] = v3;
    operator delete(v3);
  }
  result = *(double *)&v52;
  *(_OWORD *)a1 = v52;
  a1[2] = (char *)v53;
  return result;
}

void Backend::Google::computeHostNameParts(char *a1@<X0>, char *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  int v6;
  void **v7;
  void **v8;
  int v9;
  char *v10;
  int v11;
  unint64_t v12;
  void **v13;
  unint64_t v14;
  unint64_t v15;
  __int128 v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  __int128 v24;
  unint64_t v25;
  std::string *v26;
  char *v27;
  __int128 v28;
  int64x2_t v29;
  char *v30;
  std::string *v31;
  int v32;
  std::string *v33;
  uint64_t v34;
  unint64_t v35;
  std::string *v37;
  std::string::size_type v38;
  __int128 v39;
  std::string::size_type v40;
  void *__p[2];
  uint64_t v43;
  void *v44[2];
  unsigned __int8 v45;
  std::__split_buffer<std::string> v46;

  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  std::string::__init_with_size[abi:sn180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(v44, a1, a2, a2 - a1);
  if (a3)
  {
    std::vector<std::string>::push_back[abi:sn180100]((std::string **)a4, (__int128 *)v44);
    goto LABEL_45;
  }
  v6 = 0;
  v7 = (void **)((char *)v44 + v45);
  if ((v45 & 0x80u) == 0)
  {
    v8 = v44;
  }
  else
  {
    v7 = (void **)((char *)v44[0] + (unint64_t)v44[1]);
    v8 = (void **)v44[0];
  }
  while (1)
  {
    do
    {
      if (v7 == v8)
      {
        v10 = (char *)v8;
        goto LABEL_10;
      }
      v9 = *((unsigned __int8 *)v7 - 1);
      v7 = (void **)((char *)v7 - 1);
    }
    while (v9 != 46);
    v10 = (char *)v7 + 1;
LABEL_10:
    if (v10 == (char *)v8)
      break;
    v11 = v6 + 1;
    if (v6 == 5)
      break;
    if (v6)
    {
      v12 = v45;
      if ((v45 & 0x80u) == 0)
        v13 = v44;
      else
        v13 = (void **)v44[0];
      if ((v45 & 0x80u) != 0)
        v12 = (unint64_t)v44[1];
      std::string::__init_with_size[abi:sn180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(__p, v10, (char *)v13 + v12, (char *)v13 + v12 - v10);
      v14 = *(_QWORD *)(a4 + 8);
      v15 = *(_QWORD *)(a4 + 16);
      if (v14 >= v15)
      {
        v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - *(_QWORD *)a4) >> 3);
        v18 = v17 + 1;
        if (v17 + 1 > 0xAAAAAAAAAAAAAAALL)
          goto LABEL_49;
        v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - *(_QWORD *)a4) >> 3);
        if (2 * v19 > v18)
          v18 = 2 * v19;
        if (v19 >= 0x555555555555555)
          v20 = 0xAAAAAAAAAAAAAAALL;
        else
          v20 = v18;
        v46.__end_cap_.__value_ = (std::allocator<std::string> *)(a4 + 16);
        if (!v20
          || (v21 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::LexicographicallyOrderedHashEnumerator::Position>>(a4 + 16, v20)) == 0)
        {
LABEL_48:
          __break(1u);
LABEL_49:
          abort();
        }
        v23 = &v21[24 * v17];
        v24 = *(_OWORD *)__p;
        *((_QWORD *)v23 + 2) = v43;
        *(_OWORD *)v23 = v24;
        __p[1] = 0;
        v43 = 0;
        __p[0] = 0;
        v26 = *(std::string **)a4;
        v25 = *(_QWORD *)(a4 + 8);
        if (v25 == *(_QWORD *)a4)
        {
          v29 = vdupq_n_s64(v25);
          v27 = &v21[24 * v17];
        }
        else
        {
          v27 = &v21[24 * v17];
          do
          {
            v28 = *(_OWORD *)(v25 - 24);
            *((_QWORD *)v27 - 1) = *(_QWORD *)(v25 - 8);
            *(_OWORD *)(v27 - 24) = v28;
            v27 -= 24;
            *(_QWORD *)(v25 - 16) = 0;
            *(_QWORD *)(v25 - 8) = 0;
            *(_QWORD *)(v25 - 24) = 0;
            v25 -= 24;
          }
          while ((std::string *)v25 != v26);
          v29 = *(int64x2_t *)a4;
        }
        v30 = v23 + 24;
        *(_QWORD *)a4 = v27;
        *(_QWORD *)(a4 + 8) = v23 + 24;
        *(int64x2_t *)&v46.__begin_ = v29;
        v31 = *(std::string **)(a4 + 16);
        *(_QWORD *)(a4 + 16) = &v21[24 * v22];
        v46.__end_cap_.__value_ = v31;
        v46.__first_ = (std::__split_buffer<std::string>::pointer)v29.i64[0];
        std::__split_buffer<std::string>::~__split_buffer(&v46);
        v32 = SHIBYTE(v43);
        *(_QWORD *)(a4 + 8) = v30;
        if (v32 < 0)
          operator delete(__p[0]);
      }
      else
      {
        if (!v14)
          goto LABEL_48;
        v16 = *(_OWORD *)__p;
        *(_QWORD *)(v14 + 16) = v43;
        *(_OWORD *)v14 = v16;
        *(_QWORD *)(a4 + 8) = v14 + 24;
      }
    }
    v7 = (void **)(v10 - 1);
    v6 = v11;
  }
  std::vector<std::string>::push_back[abi:sn180100]((std::string **)a4, (__int128 *)v44);
  v33 = *(std::string **)a4;
  v34 = *(_QWORD *)(a4 + 8);
  v35 = v34 - 24;
  if (*(_QWORD *)a4 != v34 && v35 > (unint64_t)v33)
  {
    v37 = v33 + 1;
    do
    {
      v38 = v37[-1].__r_.__value_.__r.__words[2];
      v39 = *(_OWORD *)&v37[-1].__r_.__value_.__l.__data_;
      v40 = *(_QWORD *)(v35 + 16);
      *(_OWORD *)&v37[-1].__r_.__value_.__l.__data_ = *(_OWORD *)v35;
      v37[-1].__r_.__value_.__r.__words[2] = v40;
      *(_OWORD *)v35 = v39;
      *(_QWORD *)(v35 + 16) = v38;
      v35 -= 24;
    }
    while ((unint64_t)v37++ < v35);
  }
LABEL_45:
  if ((char)v45 < 0)
    operator delete(v44[0]);
}

void std::vector<std::string>::push_back[abi:sn180100](std::string **a1, __int128 *a2)
{
  std::allocator<std::string> *v4;
  std::string *v5;
  std::string *v6;
  std::string *v7;
  std::string *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  std::string *v16;
  unint64_t v17;
  std::string *v18;
  std::string *v19;
  __int128 v20;
  int64x2_t v21;
  std::string *v22;
  std::__split_buffer<std::string> v23;

  v6 = a1[2];
  v4 = (std::allocator<std::string> *)(a1 + 2);
  v5 = v6;
  v7 = (std::string *)*((_QWORD *)v4 - 1);
  if (v7 >= v6)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (char *)*a1) >> 3);
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)*a1) >> 3);
    v11 = 2 * v10;
    if (2 * v10 <= v9 + 1)
      v11 = v9 + 1;
    if (v10 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v11;
    v23.__end_cap_.__value_ = v4;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::LexicographicallyOrderedHashEnumerator::Position>>((uint64_t)v4, v12);
      v15 = v14;
    }
    else
    {
      v13 = 0;
      v15 = 0;
    }
    v16 = (std::string *)&v13[24 * v9];
    std::construct_at[abi:sn180100]<std::string,std::string const&,std::string*>(v16, a2);
    v18 = *a1;
    v17 = (unint64_t)a1[1];
    if ((std::string *)v17 == *a1)
    {
      v21 = vdupq_n_s64(v17);
      v19 = v16;
    }
    else
    {
      v19 = v16;
      do
      {
        v20 = *(_OWORD *)(v17 - 24);
        v19[-1].__r_.__value_.__r.__words[2] = *(_QWORD *)(v17 - 8);
        *(_OWORD *)&v19[-1].__r_.__value_.__l.__data_ = v20;
        --v19;
        *(_QWORD *)(v17 - 16) = 0;
        *(_QWORD *)(v17 - 8) = 0;
        *(_QWORD *)(v17 - 24) = 0;
        v17 -= 24;
      }
      while ((std::string *)v17 != v18);
      v21 = *(int64x2_t *)a1;
    }
    v8 = v16 + 1;
    *a1 = v19;
    a1[1] = v16 + 1;
    *(int64x2_t *)&v23.__begin_ = v21;
    v22 = a1[2];
    a1[2] = (std::string *)&v13[24 * v15];
    v23.__end_cap_.__value_ = v22;
    v23.__first_ = (std::__split_buffer<std::string>::pointer)v21.i64[0];
    std::__split_buffer<std::string>::~__split_buffer(&v23);
  }
  else
  {
    std::construct_at[abi:sn180100]<std::string,std::string const&,std::string*>(*((std::string **)v4 - 1), a2);
    v8 = v7 + 1;
  }
  a1[1] = v8;
}

void Backend::Google::computePathParts(char *a1@<X0>, char *a2@<X1>, char *a3@<X2>, char *a4@<X3>, char **a5@<X8>)
{
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  __int128 v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  __int128 v21;
  unint64_t v22;
  char *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  char *v27;
  std::string *v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  __int128 v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  char *v39;
  __int128 v40;
  unint64_t v41;
  char *v42;
  char *v43;
  __int128 v44;
  int64x2_t v45;
  char *v46;
  std::string *v47;
  int v48;
  unint64_t v49;
  char *v50;
  unint64_t v51;
  unint64_t v52;
  __int128 v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  __int128 v61;
  unint64_t v62;
  char *v63;
  char *v64;
  __int128 v65;
  int64x2_t v66;
  char *v67;
  std::string *v68;
  int v69;
  std::string __p;
  std::__split_buffer<std::string> v72;

  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  if (a3 == a4)
  {
    v10 = a2 - a1;
  }
  else
  {
    v10 = a2 - a1;
    std::string::__init_with_size[abi:sn180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(&__p, a1, a2, a2 - a1);
    std::string::append[abi:sn180100]<std::__wrap_iter<unsigned char const*>,0>(&__p, a3, a4);
    v11 = (unint64_t)a5[2];
    v12 = (unint64_t)a5[1];
    if (v12 >= v11)
    {
      v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - (_QWORD)*a5) >> 3);
      v15 = v14 + 1;
      if (v14 + 1 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_68;
      v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (_QWORD)*a5) >> 3);
      if (2 * v16 > v15)
        v15 = 2 * v16;
      if (v16 >= 0x555555555555555)
        v17 = 0xAAAAAAAAAAAAAAALL;
      else
        v17 = v15;
      v72.__end_cap_.__value_ = (std::allocator<std::string> *)(a5 + 2);
      if (!v17)
        goto LABEL_67;
      v18 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::LexicographicallyOrderedHashEnumerator::Position>>((uint64_t)(a5 + 2), v17);
      if (!v18)
        goto LABEL_67;
      v20 = &v18[24 * v14];
      v21 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((_QWORD *)v20 + 2) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v20 = v21;
      memset(&__p, 0, sizeof(__p));
      v23 = *a5;
      v22 = (unint64_t)a5[1];
      if ((char *)v22 == *a5)
      {
        v26 = vdupq_n_s64(v22);
        v24 = &v18[24 * v14];
      }
      else
      {
        v24 = &v18[24 * v14];
        do
        {
          v25 = *(_OWORD *)(v22 - 24);
          *((_QWORD *)v24 - 1) = *(_QWORD *)(v22 - 8);
          *(_OWORD *)(v24 - 24) = v25;
          v24 -= 24;
          *(_QWORD *)(v22 - 16) = 0;
          *(_QWORD *)(v22 - 8) = 0;
          *(_QWORD *)(v22 - 24) = 0;
          v22 -= 24;
        }
        while ((char *)v22 != v23);
        v26 = *(int64x2_t *)a5;
      }
      v27 = v20 + 24;
      *a5 = v24;
      a5[1] = v20 + 24;
      *(int64x2_t *)&v72.__begin_ = v26;
      v28 = (std::string *)a5[2];
      a5[2] = &v18[24 * v19];
      v72.__end_cap_.__value_ = v28;
      v72.__first_ = (std::__split_buffer<std::string>::pointer)v26.i64[0];
      std::__split_buffer<std::string>::~__split_buffer(&v72);
      v29 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      a5[1] = v27;
      if (v29 < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    else
    {
      if (!v12)
        goto LABEL_67;
      v13 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_QWORD *)(v12 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v12 = v13;
      a5[1] = (char *)(v12 + 24);
    }
  }
  std::string::__init_with_size[abi:sn180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(&__p, a1, a2, v10);
  v30 = (unint64_t)a5[2];
  v31 = (unint64_t)a5[1];
  if (v31 < v30)
  {
    if (v31)
    {
      v32 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_QWORD *)(v31 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v31 = v32;
      a5[1] = (char *)(v31 + 24);
      goto LABEL_39;
    }
    goto LABEL_67;
  }
  v33 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v31 - (_QWORD)*a5) >> 3);
  v34 = v33 + 1;
  if (v33 + 1 > 0xAAAAAAAAAAAAAAALL)
    goto LABEL_68;
  v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - (_QWORD)*a5) >> 3);
  if (2 * v35 > v34)
    v34 = 2 * v35;
  if (v35 >= 0x555555555555555)
    v36 = 0xAAAAAAAAAAAAAAALL;
  else
    v36 = v34;
  v72.__end_cap_.__value_ = (std::allocator<std::string> *)(a5 + 2);
  if (!v36
    || (v37 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::LexicographicallyOrderedHashEnumerator::Position>>((uint64_t)(a5 + 2), v36)) == 0)
  {
LABEL_67:
    __break(1u);
LABEL_68:
    abort();
  }
  v39 = &v37[24 * v33];
  v40 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *((_QWORD *)v39 + 2) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
  *(_OWORD *)v39 = v40;
  memset(&__p, 0, sizeof(__p));
  v42 = *a5;
  v41 = (unint64_t)a5[1];
  if ((char *)v41 == *a5)
  {
    v45 = vdupq_n_s64(v41);
    v43 = &v37[24 * v33];
  }
  else
  {
    v43 = &v37[24 * v33];
    do
    {
      v44 = *(_OWORD *)(v41 - 24);
      *((_QWORD *)v43 - 1) = *(_QWORD *)(v41 - 8);
      *(_OWORD *)(v43 - 24) = v44;
      v43 -= 24;
      *(_QWORD *)(v41 - 16) = 0;
      *(_QWORD *)(v41 - 8) = 0;
      *(_QWORD *)(v41 - 24) = 0;
      v41 -= 24;
    }
    while ((char *)v41 != v42);
    v45 = *(int64x2_t *)a5;
  }
  v46 = v39 + 24;
  *a5 = v43;
  a5[1] = v39 + 24;
  *(int64x2_t *)&v72.__begin_ = v45;
  v47 = (std::string *)a5[2];
  a5[2] = &v37[24 * v38];
  v72.__end_cap_.__value_ = v47;
  v72.__first_ = (std::__split_buffer<std::string>::pointer)v45.i64[0];
  std::__split_buffer<std::string>::~__split_buffer(&v72);
  v48 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  a5[1] = v46;
  if (v48 < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_39:
  if (a1 != a2)
  {
    v49 = 0;
    v50 = a1;
    while (1)
    {
      while (*v50 == 47)
      {
LABEL_44:
        if (v50 == a2)
          return;
        if (++v50 == a2)
          return;
        std::string::__init_with_size[abi:sn180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(&__p, a1, v50, v50 - a1);
        v51 = (unint64_t)a5[1];
        v52 = (unint64_t)a5[2];
        if (v51 >= v52)
        {
          v54 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v51 - (_QWORD)*a5) >> 3);
          v55 = v54 + 1;
          if (v54 + 1 > 0xAAAAAAAAAAAAAAALL)
            goto LABEL_68;
          v56 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v52 - (_QWORD)*a5) >> 3);
          if (2 * v56 > v55)
            v55 = 2 * v56;
          if (v56 >= 0x555555555555555)
            v57 = 0xAAAAAAAAAAAAAAALL;
          else
            v57 = v55;
          v72.__end_cap_.__value_ = (std::allocator<std::string> *)(a5 + 2);
          if (!v57)
            goto LABEL_67;
          v58 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::LexicographicallyOrderedHashEnumerator::Position>>((uint64_t)(a5 + 2), v57);
          if (!v58)
            goto LABEL_67;
          v60 = &v58[24 * v54];
          v61 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((_QWORD *)v60 + 2) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)v60 = v61;
          memset(&__p, 0, sizeof(__p));
          v63 = *a5;
          v62 = (unint64_t)a5[1];
          if ((char *)v62 == *a5)
          {
            v66 = vdupq_n_s64(v62);
            v64 = &v58[24 * v54];
          }
          else
          {
            v64 = &v58[24 * v54];
            do
            {
              v65 = *(_OWORD *)(v62 - 24);
              *((_QWORD *)v64 - 1) = *(_QWORD *)(v62 - 8);
              *(_OWORD *)(v64 - 24) = v65;
              v64 -= 24;
              *(_QWORD *)(v62 - 16) = 0;
              *(_QWORD *)(v62 - 8) = 0;
              *(_QWORD *)(v62 - 24) = 0;
              v62 -= 24;
            }
            while ((char *)v62 != v63);
            v66 = *(int64x2_t *)a5;
          }
          v67 = v60 + 24;
          *a5 = v64;
          a5[1] = v60 + 24;
          *(int64x2_t *)&v72.__begin_ = v66;
          v68 = (std::string *)a5[2];
          a5[2] = &v58[24 * v59];
          v72.__end_cap_.__value_ = v68;
          v72.__first_ = (std::__split_buffer<std::string>::pointer)v66.i64[0];
          std::__split_buffer<std::string>::~__split_buffer(&v72);
          v69 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
          a5[1] = v67;
          if (v69 < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
        }
        else
        {
          if (!v51)
            goto LABEL_67;
          v53 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(_QWORD *)(v51 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)v51 = v53;
          a5[1] = (char *)(v51 + 24);
        }
        if (v49++ >= 3)
          return;
      }
      if (++v50 == a2)
      {
        v50 = a2;
        goto LABEL_44;
      }
    }
  }
}

std::string *std::string::append[abi:sn180100]<std::__wrap_iter<unsigned char const*>,0>(std::string *this, char *a2, char *a3)
{
  char *v4;
  unint64_t v6;
  unint64_t v7;
  std::string::size_type size;
  std::string::size_type v9;
  std::string *v10;
  unint64_t v11;
  void **v12;
  std::string::size_type v13;
  std::string *v14;
  _BYTE *v15;
  char v16;
  std::string::size_type v17;
  void *__p[2];
  unsigned __int8 v20;

  v4 = a2;
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  v7 = a3 - a2;
  if ((v6 & 0x80000000) != 0)
  {
    if (a3 == a2)
      return this;
    size = this->__r_.__value_.__l.__size_;
    v11 = this->__r_.__value_.__r.__words[2];
    v9 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    v10 = (std::string *)this->__r_.__value_.__r.__words[0];
    v6 = HIBYTE(v11);
  }
  else
  {
    if (a3 == a2)
      return this;
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v9 = 22;
    v10 = this;
  }
  if (v10 > (std::string *)v4 || (char *)&v10->__r_.__value_.__l.__data_ + size + 1 <= v4)
  {
    if (v9 - size < v7)
    {
      std::string::__grow_by(this, v9, size - v9 + v7, size, size, 0, 0);
      this->__r_.__value_.__l.__size_ = size;
      LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
    }
    v14 = this;
    if ((v6 & 0x80) != 0)
      v14 = (std::string *)this->__r_.__value_.__r.__words[0];
    v15 = (char *)v14 + size;
    while (v4 != a3)
    {
      v16 = *v4++;
      *v15++ = v16;
    }
    *v15 = 0;
    v17 = v7 + size;
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
      this->__r_.__value_.__l.__size_ = v17;
    else
      *((_BYTE *)&this->__r_.__value_.__s + 23) = v17 & 0x7F;
  }
  else
  {
    std::string::__init_with_size[abi:sn180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(__p, v4, a3, v7);
    if ((v20 & 0x80u) == 0)
      v12 = __p;
    else
      v12 = (void **)__p[0];
    if ((v20 & 0x80u) == 0)
      v13 = v20;
    else
      v13 = (std::string::size_type)__p[1];
    std::string::append(this, (const std::string::value_type *)v12, v13);
    if ((char)v20 < 0)
      operator delete(__p[0]);
  }
  return this;
}

void Backend::Google::CanonicalURL::canonicalizeURL(Backend::Google::CanonicalURL *this@<X0>, uint64_t a2@<X8>)
{
  UInt8 *v5;
  _BYTE *v6;
  void *__p[2];
  uint64_t v8;
  void *v9[2];
  uint64_t v10;

  v9[0] = 0;
  v9[1] = 0;
  v10 = 0;
  v5 = (UInt8 *)CFURLGetBytes(this, 0, -1);
  if (v5)
  {
    std::vector<unsigned char>::__append(v9, (unint64_t)v5);
    v5 = (UInt8 *)v9[0];
    v6 = v9[1];
  }
  else
  {
    v6 = 0;
  }
  CFURLGetBytes(this, v5, v6 - v5);
  *(_OWORD *)__p = *(_OWORD *)v9;
  v8 = v10;
  v9[0] = 0;
  v9[1] = 0;
  v10 = 0;
  Backend::Google::CanonicalURL::canonicalizeURL((uint64_t)__p, a2);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v9[0])
  {
    v9[1] = v9[0];
    operator delete(v9[0]);
  }
}

void Backend::Google::CanonicalURL::canonicalizeURL(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  char *v4;
  char *v5;
  unsigned int v6;
  BOOL v7;
  int v8;
  unsigned __int8 *v10;
  unsigned int v11;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  int64_t v17;
  char *v18;
  char *v19;
  char *v20;
  int v21;
  char *v22;
  char *v23;
  int64_t v24;
  char *v25;
  char *v26;
  const __CFAllocator *v27;
  const __CFURL *v28;
  CFRange v29;
  CFIndex length;
  CFIndex v31;
  const void *v32;
  unsigned __int8 *v33;
  uint64_t v34;
  char *v35;
  char *v36;
  CFRange v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  CFRange v42;
  char *v43;
  int64_t v44;
  const char *v45;
  unsigned __int8 *v46;
  const char *v47;
  uint64_t v48;
  unsigned __int8 *v49;
  CFURLRef v50;
  const __CFURL *v51;
  const __CFURL *v52;
  const char *v53;
  unsigned __int8 *v54;
  const char *v55;
  uint64_t v56;
  unsigned __int8 *v57;
  const char *v58;
  unsigned __int8 *v59;
  const char *v60;
  uint64_t v61;
  unsigned __int8 *v62;
  char *v63;
  char *v64;
  unint64_t v65;
  int64_t v66;
  int64_t v67;
  unint64_t v68;
  size_t v69;
  void *v70;
  char *v71;
  char *v72;
  char v73;
  CFRange v74;
  const void *v75;
  void *v76;
  CFIndex v77;
  void *location;
  char *v79;
  char *v80;
  unint64_t v81;
  int64_t v82;
  int64_t v83;
  unint64_t v84;
  size_t v85;
  void *v86;
  char *v87;
  char *v88;
  char v89;
  _BYTE *v90;
  __int128 v91;
  _BYTE *v92;
  CFRange v93;
  CFRange v94;
  CFIndex v95;
  char v96;
  void *__p;
  char *v98;
  char *v99;
  CFRange rangeIncludingSeparators;
  void *__dst[12];

  v5 = *(char **)a1;
  v4 = *(char **)(a1 + 8);
  if (*(char **)a1 == v4)
  {
    v14 = *(char **)a1;
    v13 = *(char **)a1;
  }
  else
  {
    while (1)
    {
      v6 = *v5;
      v7 = v6 > 0xD;
      v8 = (1 << v6) & 0x2600;
      if (!v7 && v8 != 0)
        break;
      if (++v5 == v4)
      {
        v5 = *(char **)(a1 + 8);
        break;
      }
    }
    if (v5 != v4)
    {
      v10 = (unsigned __int8 *)(v5 + 1);
      if (v5 + 1 != v4)
      {
        do
        {
          v11 = *v10;
          if (v11 > 0xD || ((1 << v11) & 0x2600) == 0)
            *v5++ = v11;
          ++v10;
        }
        while (v10 != (unsigned __int8 *)v4);
        v4 = *(char **)(a1 + 8);
      }
    }
    if (v4 < v5)
      goto LABEL_163;
    v13 = *(char **)a1;
    if (v5 == v4)
    {
      v5 = v4;
      v14 = *(char **)a1;
    }
    else
    {
      v14 = *(char **)a1;
      *(_QWORD *)(a1 + 8) = v5;
    }
  }
  if (v13 == v5)
  {
    v14 = v5;
    v13 = v5;
  }
  else
  {
    v15 = v13;
    while (*v15 == 32)
    {
      if (++v15 == v5)
      {
        v15 = &v13[v5 - v14];
        break;
      }
    }
    if (v15 < v13)
      goto LABEL_163;
    if (v13 != v15)
    {
      v16 = &v13[v15 - v14];
      v17 = v5 - v16;
      v18 = v13;
      if (v5 != v16)
      {
        memmove(v13, v16, v5 - v16);
        v14 = *(char **)a1;
        v18 = *(char **)a1;
      }
      v5 = &v13[v17];
      *(_QWORD *)(a1 + 8) = &v13[v17];
      v13 = v18;
    }
  }
  v19 = v14;
  v20 = v5;
  while (v20 != v13)
  {
    v21 = *--v20;
    if (v21 != 32)
    {
      v19 = v20 + 1;
      break;
    }
  }
  if (v5 < v19)
    goto LABEL_163;
  if (v19 != v5)
  {
    v22 = &v13[v19 - v14];
    v23 = &v5[v13 - v14];
    v24 = v14 - v13;
    if (v5 != v23)
    {
      memmove(&v13[v19 - v14], v23, v14 - v13);
      v14 = *(char **)a1;
      v13 = *(char **)a1;
    }
    v5 = &v22[v24];
    *(_QWORD *)(a1 + 8) = &v22[v24];
  }
  v25 = v5;
  if (v13 != v5)
  {
    v25 = v13;
    while (*v25 != 35)
    {
      if (++v25 == v5)
      {
        v25 = &v13[v5 - v14];
        break;
      }
    }
  }
  v26 = &v13[v25 - v14];
  if (v26 != v5)
  {
    if (v5 < v26)
      goto LABEL_163;
    *(_QWORD *)(a1 + 8) = v26;
  }
  while ((Backend::Google::unescapePercentEscapes((char **)a1) & 1) != 0)
    ;
  Backend::Google::percentEscape(a1);
  v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v28 = CFURLCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(const UInt8 **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1, 0x600u, 0);
  if (!CFURLCanBeDecomposed(v28) || !CFURLGetBytes(v28, 0, -1))
  {
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    goto LABEL_160;
  }
  memset(__dst, 0, 41);
  memset(&__dst[6], 0, 32);
  v29 = CFURLGetByteRangeForComponent(v28, kCFURLComponentScheme, &rangeIncludingSeparators);
  length = rangeIncludingSeparators.length;
  if (rangeIncludingSeparators.length)
  {
    v31 = v29.length;
    goto LABEL_57;
  }
  std::vector<unsigned char>::__insert_with_size[abi:sn180100]<char const*,char const*>((char **)a1, *(char **)a1, "http://", "", 7);
  v50 = CFURLCreateWithBytes(v27, *(const UInt8 **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1, 0x600u, 0);
  if (v28 == v50)
    v51 = 0;
  else
    v51 = v50;
  if (v28)
  {
    v52 = v50;
    CFRelease(v28);
    v28 = v52;
  }
  else
  {
    v28 = v51;
  }
  if (CFURLCanBeDecomposed(v28) && CFURLGetBytes(v28, 0, -1))
  {
    v31 = CFURLGetByteRangeForComponent(v28, kCFURLComponentScheme, &rangeIncludingSeparators).length;
    length = rangeIncludingSeparators.length;
    if (!rangeIncludingSeparators.length)
    {
      v36 = 0;
      v33 = 0;
      v35 = 0;
LABEL_61:
      std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)__dst, (char *)__dst[1], v36, v35, v35 - v36);
      v37 = CFURLGetByteRangeForComponent(v28, kCFURLComponentHost, 0);
      if (v37.location == -1)
      {
        *(_OWORD *)(a2 + 48) = 0u;
        *(_OWORD *)(a2 + 64) = 0u;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
LABEL_156:
        if (v33)
          operator delete(v33);
        goto LABEL_158;
      }
      v38 = *(char **)a1;
      v98 = 0;
      v99 = 0;
      __p = 0;
      if (v37.length)
      {
        if (v37.length < 0)
          goto LABEL_164;
        v39 = &v38[v37.location];
        v40 = (char *)operator new(v37.length);
        v41 = &v40[v37.length];
        __p = v40;
        v99 = &v40[v37.length];
        memmove(v40, v39, v37.length);
        v98 = v41;
      }
      v96 = 0;
      Backend::Google::canonicalizeHostName((uint64_t)&__p, &v96);
      __dst[3] = (void *)((char *)__dst[1] - (char *)__dst[0]);
      std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)__dst, (char *)__dst[1], (char *)__p, v98, v98 - (_BYTE *)__p);
      __dst[4] = (void *)((char *)__dst[1] - (char *)__dst[0]);
      LOBYTE(__dst[5]) = v96;
      v42 = CFURLGetByteRangeForComponent(v28, kCFURLComponentPort, 0);
      if (v42.location != -1)
      {
        v43 = (char *)(*(_QWORD *)a1 + v42.location);
        v44 = &v33[v31] - (unsigned __int8 *)v36;
        switch(v44)
        {
          case 3:
            if (v31)
            {
              v53 = "ftp";
              v54 = v33;
              while (*v54 == *v53)
              {
                ++v54;
                ++v53;
                if (!--v31)
                  goto LABEL_95;
              }
            }
            else
            {
LABEL_95:
              if (v42.length == 2)
              {
                v55 = "21";
                v56 = 2;
                v57 = (unsigned __int8 *)(*(_QWORD *)a1 + v42.location);
                while (*v57 == *v55)
                {
                  ++v57;
                  ++v55;
                  if (!--v56)
                    goto LABEL_127;
                }
              }
            }
            break;
          case 5:
            if (v31)
            {
              v58 = "https";
              v59 = v33;
              while (*v59 == *v58)
              {
                ++v59;
                ++v58;
                if (!--v31)
                  goto LABEL_104;
              }
            }
            else
            {
LABEL_104:
              if (v42.length == 3)
              {
                v60 = "443";
                v61 = 3;
                v62 = (unsigned __int8 *)(*(_QWORD *)a1 + v42.location);
                while (*v62 == *v60)
                {
                  ++v62;
                  ++v60;
                  if (!--v61)
                    goto LABEL_127;
                }
              }
            }
            break;
          case 4:
            if (v31)
            {
              v45 = "http";
              v46 = v33;
              while (*v46 == *v45)
              {
                ++v46;
                ++v45;
                if (!--v31)
                  goto LABEL_73;
              }
            }
            else
            {
LABEL_73:
              if (v42.length == 2)
              {
                v47 = "80";
                v48 = 2;
                v49 = (unsigned __int8 *)(*(_QWORD *)a1 + v42.location);
                while (*v49 == *v47)
                {
                  ++v49;
                  ++v47;
                  if (!--v48)
                    goto LABEL_127;
                }
              }
            }
            break;
        }
        v63 = (char *)__dst[1];
        if (__dst[1] >= __dst[2])
        {
          v65 = (unint64_t)__dst[0];
          v66 = (char *)__dst[1] - (char *)__dst[0];
          v67 = (char *)__dst[1] - (char *)__dst[0] + 1;
          if (v67 < 0)
            goto LABEL_164;
          v68 = (char *)__dst[2] - (char *)__dst[0];
          if (2 * ((char *)__dst[2] - (char *)__dst[0]) > (unint64_t)v67)
            v67 = 2 * v68;
          if (v68 >= 0x3FFFFFFFFFFFFFFFLL)
            v69 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v69 = v67;
          if (!v69)
            goto LABEL_163;
          v70 = operator new(v69);
          v71 = (char *)v70 + v69;
          *((_BYTE *)v70 + v66) = 58;
          v64 = (char *)v70 + v66 + 1;
          if (v63 == (char *)v65)
          {
            v70 = (char *)v70 + v66;
          }
          else
          {
            v72 = &v63[~v65];
            do
            {
              v73 = *--v63;
              (v72--)[(_QWORD)v70] = v73;
            }
            while (v63 != (char *)v65);
            v63 = (char *)v65;
          }
          __dst[0] = v70;
          __dst[1] = v64;
          __dst[2] = v71;
          if (v63)
            operator delete(v63);
        }
        else
        {
          if (!__dst[1])
            goto LABEL_163;
          *(_BYTE *)__dst[1] = 58;
          v64 = v63 + 1;
        }
        __dst[1] = v64;
        std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)__dst, v64, v43, &v43[v42.length], v42.length);
      }
LABEL_127:
      __dst[6] = (void *)((char *)__dst[1] - (char *)__dst[0]);
      v74 = CFURLGetByteRangeForComponent(v28, kCFURLComponentPath, 0);
      if (v74.length)
      {
        if ((v74.length & 0x8000000000000000) == 0)
        {
          v75 = (const void *)(*(_QWORD *)a1 + v74.location);
          v76 = operator new(v74.length);
          v77 = (CFIndex)v76 + v74.length;
          v94.location = (CFIndex)v76;
          v95 = (CFIndex)v76 + v74.length;
          memmove(v76, v75, v74.length);
          v94.length = v77;
          Backend::Google::canonicalizePath((char **)&v94);
          location = (void *)v94.location;
          std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)__dst, (char *)__dst[1], (char *)v94.location, (char *)v94.length, v94.length - v94.location);
          if (location)
            operator delete(location);
          v79 = (char *)__dst[1];
          goto LABEL_150;
        }
LABEL_164:
        abort();
      }
      v80 = (char *)__dst[1];
      if (__dst[1] >= __dst[2])
      {
        v81 = (unint64_t)__dst[0];
        v82 = (char *)__dst[1] - (char *)__dst[0];
        v83 = (char *)__dst[1] - (char *)__dst[0] + 1;
        if (v83 < 0)
          goto LABEL_164;
        v84 = (char *)__dst[2] - (char *)__dst[0];
        if (2 * ((char *)__dst[2] - (char *)__dst[0]) > (unint64_t)v83)
          v83 = 2 * v84;
        if (v84 >= 0x3FFFFFFFFFFFFFFFLL)
          v85 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v85 = v83;
        if (v85)
        {
          v86 = operator new(v85);
          v87 = (char *)v86 + v85;
          *((_BYTE *)v86 + v82) = 47;
          v79 = (char *)v86 + v82 + 1;
          if (v80 == (char *)v81)
          {
            v86 = (char *)v86 + v82;
          }
          else
          {
            v88 = &v80[~v81];
            do
            {
              v89 = *--v80;
              (v88--)[(_QWORD)v86] = v89;
            }
            while (v80 != (char *)v81);
            v80 = (char *)v81;
          }
          __dst[0] = v86;
          __dst[1] = v79;
          __dst[2] = v87;
          if (v80)
            operator delete(v80);
          goto LABEL_149;
        }
      }
      else if (__dst[1])
      {
        *(_BYTE *)__dst[1] = 47;
        v79 = v80 + 1;
LABEL_149:
        __dst[1] = v79;
LABEL_150:
        __dst[7] = (void *)(v79 - (char *)__dst[0]);
        CFURLGetByteRangeForComponent(v28, kCFURLComponentParameterString, &v94);
        if (v94.length)
          std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)__dst, (char *)__dst[1], (char *)(*(_QWORD *)a1 + v94.location), (char *)(*(_QWORD *)a1 + v94.location + v94.length), v94.length);
        __dst[8] = (void *)((char *)__dst[1] - (char *)__dst[0]);
        CFURLGetByteRangeForComponent(v28, kCFURLComponentQuery, &v93);
        if (v93.length)
          std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)__dst, (char *)__dst[1], (char *)(*(_QWORD *)a1 + v93.location), (char *)(*(_QWORD *)a1 + v93.location + v93.length), v93.length);
        v90 = __dst[1];
        *(_OWORD *)(a2 + 8) = *(_OWORD *)&__dst[1];
        v91 = *(_OWORD *)&__dst[5];
        *(_OWORD *)(a2 + 24) = *(_OWORD *)&__dst[3];
        v92 = __dst[0];
        *(void **)a2 = __dst[0];
        __dst[9] = (void *)(v90 - v92);
        memset(__dst, 0, 24);
        *(_OWORD *)(a2 + 40) = v91;
        *(_OWORD *)(a2 + 56) = *(_OWORD *)&__dst[7];
        *(void **)(a2 + 72) = __dst[9];
        if (__p)
          operator delete(__p);
        goto LABEL_156;
      }
LABEL_163:
      __break(1u);
      goto LABEL_164;
    }
LABEL_57:
    v32 = (const void *)(*(_QWORD *)a1 + rangeIncludingSeparators.location);
    if (length < 0)
      goto LABEL_164;
    v33 = (unsigned __int8 *)operator new(length);
    memmove(v33, v32, length);
    v34 = 0;
    v35 = (char *)&v33[length];
    do
    {
      v33[v34] = __tolower(v33[v34]);
      ++v34;
    }
    while (length != v34);
    v36 = (char *)v33;
    goto LABEL_61;
  }
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
LABEL_158:
  if (__dst[0])
  {
    __dst[1] = __dst[0];
    operator delete(__dst[0]);
  }
LABEL_160:
  if (v28)
    CFRelease(v28);
}

void Backend::Google::CanonicalURL::computeHashes(Backend::Google::CanonicalURL *this@<X0>, char **a2@<X8>)
{
  void ***v4;
  void ***i;
  char *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  __int128 v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  void *__p[2];
  char v25;
  char *v26;
  char *v27;
  void ***v28;
  void ***v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  Backend::Google::computeHostNameParts((char *)(*(_QWORD *)this + *((_QWORD *)this + 3)), (char *)(*(_QWORD *)this + *((_QWORD *)this + 4)), *((unsigned __int8 *)this + 40), (uint64_t)&v28);
  Backend::Google::computePathParts((char *)(*(_QWORD *)this + *((_QWORD *)this + 6)), (char *)(*(_QWORD *)this + *((_QWORD *)this + 7)), (char *)(*(_QWORD *)this + *((_QWORD *)this + 8)), (char *)(*(_QWORD *)this + *((_QWORD *)this + 9)), &v26);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::vector<std::array<unsigned char,32ul>>::reserve((void **)a2, 0x8E38E38E38E38E39 * (v29 - v28) * ((v27 - v26) >> 3));
  v4 = v28;
  for (i = v29; v4 != i; v4 += 3)
  {
    v6 = v26;
    v7 = v27;
    while (v6 != v7)
    {
      std::operator+[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v4, (uint64_t)v6, (uint64_t)__p);
      Platform::computeSHA256(__p, (unsigned __int8 *)&v30);
      v8 = a2[1];
      v9 = (unint64_t)a2[2];
      if ((unint64_t)v8 >= v9)
      {
        v12 = (v8 - *a2) >> 5;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 59)
          goto LABEL_26;
        v14 = v9 - (_QWORD)*a2;
        if (v14 >> 4 > v13)
          v13 = v14 >> 4;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFE0)
          v15 = 0x7FFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (!v15
          || (v16 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<std::array<unsigned char,32ul>>>((uint64_t)(a2 + 2), v15)) == 0)
        {
LABEL_25:
          __break(1u);
LABEL_26:
          abort();
        }
        v18 = &v16[32 * v12];
        v19 = v31;
        *(_OWORD *)v18 = v30;
        *((_OWORD *)v18 + 1) = v19;
        v21 = *a2;
        v20 = a2[1];
        v22 = v18;
        if (v20 != *a2)
        {
          do
          {
            v23 = *((_OWORD *)v20 - 1);
            *((_OWORD *)v22 - 2) = *((_OWORD *)v20 - 2);
            *((_OWORD *)v22 - 1) = v23;
            v22 -= 32;
            v20 -= 32;
          }
          while (v20 != v21);
          v20 = v21;
        }
        v11 = v18 + 32;
        *a2 = v22;
        a2[1] = v18 + 32;
        a2[2] = &v16[32 * v17];
        if (v20)
          operator delete(v20);
      }
      else
      {
        if (!v8)
          goto LABEL_25;
        v10 = v31;
        *(_OWORD *)v8 = v30;
        *((_OWORD *)v8 + 1) = v10;
        v11 = v8 + 32;
      }
      a2[1] = v11;
      if (v25 < 0)
        operator delete(__p[0]);
      v6 += 24;
    }
  }
  *(_QWORD *)&v30 = &v26;
  std::vector<std::string>::__destroy_vector::operator()[abi:sn180100]((void ***)&v30);
  *(_QWORD *)&v30 = &v28;
  std::vector<std::string>::__destroy_vector::operator()[abi:sn180100]((void ***)&v30);
}

void std::vector<std::array<unsigned char,32ul>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 5)
  {
    if (a2 >> 59)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<std::array<unsigned char,32ul>>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFE0];
    v9 = &v6[32 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void **std::operator+[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>@<X0>(void ***a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  size_t v5;
  size_t v6;
  void **result;
  void **v8;
  char *v9;
  char *v11;
  char *v12;

  if (*((char *)a1 + 23) >= 0)
    v5 = *((unsigned __int8 *)a1 + 23);
  else
    v5 = (size_t)a1[1];
  if (*(char *)(a2 + 23) >= 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_QWORD *)(a2 + 8);
  result = (void **)std::string::basic_string[abi:sn180100](a3, v6 + v5);
  if (*((char *)result + 23) < 0)
    result = (void **)*result;
  if (*((char *)a1 + 23) >= 0)
    v8 = (void **)a1;
  else
    v8 = *a1;
  v9 = (char *)result + v5;
  if (v8 >= result && v9 > (char *)v8)
    goto LABEL_28;
  if (v5)
    result = (void **)memmove(result, v8, v5);
  v11 = *(char *)(a2 + 23) >= 0 ? (char *)a2 : *(char **)a2;
  v12 = &v9[v6];
  if (v11 >= v9 && v12 > v11)
  {
LABEL_28:
    __break(1u);
  }
  else
  {
    if (v6)
      result = (void **)memmove(v9, v11, v6);
    *v12 = 0;
  }
  return result;
}

char *std::vector<unsigned char>::__init_with_size[abi:sn180100]<char const*,char const*>(char *result, char *a2, char *a3, size_t __sz)
{
  char *v6;
  _BYTE *i;
  char v8;

  if (__sz)
  {
    v6 = result;
    result = std::vector<unsigned char>::__vallocate[abi:sn180100](result, __sz);
    for (i = (_BYTE *)*((_QWORD *)v6 + 1); ; ++i)
    {
      if (a2 == a3)
      {
        *((_QWORD *)v6 + 1) = i;
        return result;
      }
      if (!i)
        break;
      v8 = *a2++;
      *i = v8;
    }
    __break(1u);
  }
  return result;
}

void std::vector<unsigned char>::__append(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  unint64_t v7;
  unint64_t v8;
  size_t v9;
  void *v10;
  _BYTE *v11;
  char *v12;
  char *v13;
  _BYTE *v14;
  _BYTE *v15;
  char v16;

  v2 = a2;
  v5 = (_BYTE *)a1[1];
  v4 = a1[2];
  if (v4 - (uint64_t)v5 < a2)
  {
    v6 = &v5[-*a1];
    v7 = (unint64_t)&v6[a2];
    if ((uint64_t)&v6[a2] >= 0)
    {
      v8 = v4 - *a1;
      if (2 * v8 > v7)
        v7 = 2 * v8;
      if (v8 >= 0x3FFFFFFFFFFFFFFFLL)
        v9 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v9 = v7;
      if (v9)
        v10 = operator new(v9);
      else
        v10 = 0;
      v12 = &v6[(_QWORD)v10];
      v13 = &v6[(_QWORD)v10 + v2];
      v14 = &v6[(_QWORD)v10];
      do
      {
        if (!v14)
          goto LABEL_26;
        *v14++ = 0;
        --v2;
      }
      while (v2);
      v15 = (_BYTE *)*a1;
      if (v5 != (_BYTE *)*a1)
      {
        do
        {
          v16 = *--v5;
          *--v12 = v16;
        }
        while (v5 != v15);
        v5 = (_BYTE *)*a1;
      }
      *a1 = v12;
      a1[1] = v13;
      a1[2] = (char *)v10 + v9;
      if (v5)
        operator delete(v5);
      return;
    }
LABEL_27:
    abort();
  }
  if (!a2)
    goto LABEL_15;
  v11 = &v5[a2];
  do
  {
    if (!v5)
    {
LABEL_26:
      __break(1u);
      goto LABEL_27;
    }
    *v5++ = 0;
    --v2;
  }
  while (v2);
  v5 = v11;
LABEL_15:
  a1[1] = v5;
}

char *std::vector<unsigned char>::__insert_with_size[abi:sn180100]<char const*,char const*>(char **a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  uint64_t v6;
  char *v7;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  char *v18;
  int64_t v19;
  char *v20;
  _BYTE *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  char v26;
  char *v27;
  char *v28;
  char *v29;
  char v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  char v35;

  v5 = __dst;
  if (a5 < 1)
    return v5;
  v6 = a5;
  v7 = __src;
  v10 = a1[1];
  v9 = a1[2];
  if (v9 - v10 < a5)
  {
    v11 = *a1;
    v12 = v10 - *a1 + a5;
    if (v12 >= 0)
    {
      v13 = (char *)(__dst - v11);
      v14 = v9 - v11;
      if (2 * v14 > v12)
        v12 = 2 * v14;
      if (v14 >= 0x3FFFFFFFFFFFFFFFLL)
        v15 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v15 = v12;
      if (v15)
        v16 = operator new(v15);
      else
        v16 = 0;
      v22 = &v13[(_QWORD)v16];
      v23 = (char *)v16 + v15;
      v24 = &v22[v6];
      v25 = v22;
      do
      {
        if (!v25)
          goto LABEL_43;
        v26 = *v7++;
        *v25++ = v26;
        --v6;
      }
      while (v6);
      v27 = *a1;
      if (*a1 == v5)
      {
        v29 = v22;
      }
      else
      {
        v28 = v5;
        v29 = v22;
        do
        {
          v30 = *--v28;
          *--v29 = v30;
        }
        while (v28 != v27);
        v10 = a1[1];
      }
      if (v10 != v5)
        memmove(v24, v5, v10 - v5);
      v31 = *a1;
      *a1 = v29;
      a1[1] = &v24[v10 - v5];
      a1[2] = v23;
      if (v31)
        operator delete(v31);
      return v22;
    }
LABEL_44:
    abort();
  }
  v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    v18 = &__src[a5];
    v20 = a1[1];
    goto LABEL_34;
  }
  v18 = &__src[v17];
  if (&__src[v17] != a4)
  {
    v19 = __src - __dst;
    v20 = a1[1];
    v21 = v20;
    while (v21)
    {
      *v21++ = (v20++)[v19];
      if (&v20[v19] == a4)
        goto LABEL_33;
    }
LABEL_43:
    __break(1u);
    goto LABEL_44;
  }
  v20 = a1[1];
LABEL_33:
  a1[1] = v20;
  if (v17 >= 1)
  {
LABEL_34:
    v32 = &v20[-a5];
    v33 = v20;
    if (&v20[-a5] >= v10)
    {
LABEL_38:
      a1[1] = v33;
      if (v20 != &__dst[a5])
        memmove(&__dst[a5], __dst, v20 - &__dst[a5]);
      if (v18 != v7)
        memmove(v5, v7, v18 - v7);
      return v5;
    }
    v34 = &v10[a5] - v20;
    v33 = v20;
    while (v33)
    {
      v35 = *v32++;
      *v33++ = v35;
      if (!--v34)
        goto LABEL_38;
    }
    goto LABEL_43;
  }
  return v5;
}

uint64_t Platform::OutputStream::writeUInt8(Platform::OutputStream *this, char a2)
{
  char v3;

  v3 = a2;
  return (*(uint64_t (**)(Platform::OutputStream *, char *, uint64_t))(*(_QWORD *)this + 24))(this, &v3, 1);
}

uint64_t Platform::OutputStream::writeUInt32(Platform::OutputStream *this, unsigned int a2)
{
  unsigned int v3;

  v3 = bswap32(a2);
  return (*(uint64_t (**)(Platform::OutputStream *, unsigned int *, uint64_t))(*(_QWORD *)this + 24))(this, &v3, 4);
}

uint64_t Platform::OutputStream::writeUInt64(Platform::OutputStream *this, unint64_t a2)
{
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v3[0] = bswap64(a2);
  return (*(uint64_t (**)(Platform::OutputStream *, _QWORD *, uint64_t))(*(_QWORD *)this + 24))(this, v3, 8);
}

unint64_t Platform::OutputStream::getOffset32(Platform::OutputStream *this, unsigned int *a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unint64_t v7;

  v7 = 0;
  v3 = (*(uint64_t (**)(Platform::OutputStream *, unint64_t *))(*(_QWORD *)this + 32))(this, &v7);
  v4 = v3;
  if ((_DWORD)v3)
  {
    v5 = v3;
  }
  else if (HIDWORD(v7))
  {
    v4 = 34;
    std::generic_category();
    v5 = 34;
  }
  else
  {
    *a2 = v7;
    std::system_category();
    v5 = 0;
  }
  return v4 & 0xFFFFFFFF00000000 | v5;
}

const std::string::value_type *Platform::getUserCacheDirectory(std::string *a1)
{
  void *v2;
  void *v3;
  void *v4;
  const std::string::value_type *result;
  uint64_t v6;

  NSSearchPathForDirectoriesInDomains(NSCachesDirectory, 1uLL, 1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "lastObject");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v3;
  if (!v3)
  {
    v6 = 2;
    std::generic_category();
    goto LABEL_5;
  }
  result = (const std::string::value_type *)objc_msgSend(objc_retainAutorelease(v3), "fileSystemRepresentation");
  if (result)
  {
    std::string::__assign_external(a1, result);
    std::system_category();
    v6 = 0;
LABEL_5:

    return (const std::string::value_type *)v6;
  }
  __break(1u);
  return result;
}

void sub_1DBCF56C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

std::string *Platform::stringByAppendingPathComponent@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t *v4;
  uint64_t v6;
  int v7;
  const std::string::value_type *v8;
  std::string::size_type v9;

  v4 = a1;
  if (*((char *)a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a3, (const std::string::value_type *)*a1, a1[1]);
    if (*((char *)v4 + 23) < 0)
    {
      v6 = v4[1];
      if (!v6)
        goto LABEL_9;
      v4 = (uint64_t *)*v4;
      goto LABEL_7;
    }
    LODWORD(v6) = *((unsigned __int8 *)v4 + 23);
    if (!*((_BYTE *)v4 + 23))
      goto LABEL_9;
  }
  else
  {
    LODWORD(v6) = *((unsigned __int8 *)a1 + 23);
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    a3->__r_.__value_.__r.__words[2] = a1[2];
    if (!(_DWORD)v6)
      goto LABEL_9;
  }
  v6 = v6;
LABEL_7:
  if (*((_BYTE *)v4 + v6 - 1) != 47)
    std::string::append(a3, "/", 1uLL);
LABEL_9:
  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = (const std::string::value_type *)a2;
  else
    v8 = *(const std::string::value_type **)a2;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a2 + 23);
  else
    v9 = *(_QWORD *)(a2 + 8);
  return std::string::append(a3, v8, v9);
}

void sub_1DBCF57A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t Platform::createDirectoryWithIntermediateDirectories(const std::string *a1)
{
  unsigned int v1;
  const std::string *v2;
  int v3;
  std::string::size_type v4;
  std::string::size_type v5;
  std::string *v6;
  std::string *v7;
  int v8;
  const char *v9;
  std::string v11;
  stat v12;

  v2 = a1;
  if ((SHIBYTE(a1->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (*((_BYTE *)&a1->__r_.__value_.__s + 23))
    {
      v3 = a1->__r_.__value_.__s.__data_[0];
      goto LABEL_6;
    }
LABEL_32:
    v1 = 45;
LABEL_33:
    std::generic_category();
    return v1;
  }
  if (!a1->__r_.__value_.__l.__size_)
    goto LABEL_32;
  a1 = (const std::string *)a1->__r_.__value_.__r.__words[0];
  v3 = *(unsigned __int8 *)v2->__r_.__value_.__l.__data_;
LABEL_6:
  if (v3 != 47)
    goto LABEL_32;
  if (!access((const char *)a1, 7))
  {
    if ((v2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v9 = (const char *)v2;
    else
      v9 = (const char *)v2->__r_.__value_.__r.__words[0];
    if (stat(v9, &v12) == -1)
    {
      v1 = *__error();
    }
    else
    {
      if ((v12.st_mode & 0xF000) == 0x4000)
        goto LABEL_39;
      v1 = 20;
    }
    goto LABEL_33;
  }
  v4 = 1;
  do
  {
    while (1)
    {
      v5 = std::string::find(v2, 47, v4);
      std::string::basic_string(&v11, v2, 0, v5, (std::allocator<char> *)&v12);
      v6 = (v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &v11
         : (std::string *)v11.__r_.__value_.__r.__words[0];
      if (stat((const char *)v6, &v12))
      {
        if (*__error() != 2
          || ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? (v7 = &v11)
            : (v7 = (std::string *)v11.__r_.__value_.__r.__words[0]),
              mkdir((const char *)v7, 0x1C0u) == -1))
        {
          v1 = *__error();
          v8 = 1;
LABEL_25:
          std::generic_category();
          goto LABEL_26;
        }
      }
      else if ((v12.st_mode & 0xF000) != 0x4000)
      {
        v8 = 1;
        v1 = 20;
        goto LABEL_25;
      }
      if (v5 == -1)
      {
        v8 = 3;
      }
      else
      {
        v4 = v5 + 1;
        v8 = 0;
      }
LABEL_26:
      if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
        break;
      if (v8)
        goto LABEL_30;
    }
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  while (!v8);
LABEL_30:
  if (v8 != 3)
    return v1;
LABEL_39:
  std::system_category();
  return 0;
}

void sub_1DBCF5998(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  unint64_t v6;
  std::string *v7;
  std::string::size_type size;
  unint64_t v9;
  unint64_t v10;

  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    v10 = this->__r_.__value_.__r.__words[2];
    v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    v6 = HIBYTE(v10);
    v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    v7 = this;
    if (__n > 0x16)
    {
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0)
    this->__r_.__value_.__l.__size_ = __n;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

uint64_t Backend::Google::ProtocolBuffers::wireType(int a1)
{
  return 2 * (a1 != 0);
}

void sub_1DBCF5DCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

BOOL EnumTraits::isValidEnum<Backend::Google::CompressionType>(int a1)
{
  return (a1 - 1) < 2;
}

BOOL EnumTraits::isValidEnum<Backend::Google::PlatformType>(int a1)
{
  return (a1 - 1) < 7;
}

BOOL EnumTraits::isValidEnum<Backend::Google::ThreatEntryType>(int a1)
{
  return (a1 - 1) < 3;
}

BOOL EnumTraits::isValidEnum<Backend::Google::ThreatType>(int a1)
{
  return (a1 - 1) < 4;
}

BOOL EnumTraits::isValidEnum<Backend::Google::ProtectionType>(int a1)
{
  return a1 == 1;
}

const __CFString *EnumTraits::toNSStringFromEnum<Backend::Google::CompressionType>(int a1)
{
  if (a1 == 1)
    return CFSTR("RAW");
  else
    return CFSTR("RICE");
}

const __CFString *EnumTraits::toNSStringFromEnum<Backend::Google::ThreatType>(int a1)
{
  if ((a1 - 2) > 2)
    return CFSTR("MALWARE");
  else
    return off_1EA3EC248[a1 - 2];
}

const __CFString *EnumTraits::toNSStringFromEnum<Backend::Google::PlatformType>(int a1)
{
  if ((a1 - 2) > 5)
    return CFSTR("WINDOWS");
  else
    return off_1EA3EC260[a1 - 2];
}

const __CFString *EnumTraits::toNSStringFromEnum<Backend::Google::ThreatEntryType>(int a1)
{
  const __CFString *v1;

  v1 = CFSTR("URL");
  if (a1 == 2)
    v1 = CFSTR("BINARY_DIGEST");
  if (a1 == 3)
    return CFSTR("IP_RANGE");
  else
    return v1;
}

uint64_t EnumTraits::toEnumFromNSString<Backend::Google::ThreatType>(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  int v4;

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", CFSTR("MALWARE")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 1;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("SOCIAL_ENGINEERING")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 2;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("UNWANTED_SOFTWARE")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 3;
  }
  else
  {
    v4 = objc_msgSend(v1, "isEqualToString:", CFSTR("POTENTIALLY_HARMFUL_APPLICATION"));
    if (v4)
      v2 = 0x100000000;
    else
      v2 = 0;
    if (v4)
      v3 = 4;
    else
      v3 = 0;
  }

  return v3 | v2;
}

void sub_1DBCF5FE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t EnumTraits::toEnumFromNSString<Backend::Google::ThreatEntryType>(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  int v4;

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", CFSTR("URL")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 1;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("BINARY_DIGEST")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 2;
  }
  else
  {
    v4 = objc_msgSend(v1, "isEqualToString:", CFSTR("IP_RANGE"));
    if (v4)
      v2 = 0x100000000;
    else
      v2 = 0;
    if (v4)
      v3 = 3;
    else
      v3 = 0;
  }

  return v3 | v2;
}

void sub_1DBCF6084(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t EnumTraits::toEnumFromNSString<Backend::Google::PlatformType>(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  int v4;

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", CFSTR("WINDOWS")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 1;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("LINUX")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 2;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("ANDROID")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 3;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("OSX")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 4;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("IOS")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 5;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("ANY_PLATFORM")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 6;
  }
  else
  {
    v4 = objc_msgSend(v1, "isEqualToString:", CFSTR("ALL_PLATFORMS"));
    if (v4)
      v2 = 0x100000000;
    else
      v2 = 0;
    if (v4)
      v3 = 7;
    else
      v3 = 0;
  }

  return v3 | v2;
}

void sub_1DBCF61A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t EnumTraits::toEnumFromNSString<Backend::Google::ResponseType>(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  int v4;

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", CFSTR("PARTIAL_UPDATE")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 1;
  }
  else
  {
    v4 = objc_msgSend(v1, "isEqualToString:", CFSTR("FULL_UPDATE"));
    if (v4)
      v2 = 0x100000000;
    else
      v2 = 0;
    if (v4)
      v3 = 2;
    else
      v3 = 0;
  }

  return v3 | v2;
}

void sub_1DBCF6224(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t EnumTraits::toEnumFromNSString<Backend::Google::CompressionType>(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  int v4;

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", CFSTR("RAW")) & 1) != 0)
  {
    v2 = 0x100000000;
    v3 = 1;
  }
  else
  {
    v4 = objc_msgSend(v1, "isEqualToString:", CFSTR("RICE"));
    if (v4)
      v2 = 0x100000000;
    else
      v2 = 0;
    if (v4)
      v3 = 2;
    else
      v3 = 0;
  }

  return v3 | v2;
}

void sub_1DBCF62A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *Backend::Google::ProtocolMessageReader::nextField@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x98uLL);
  *result = Backend::Google::ProtocolMessageReader::nextField;
  result[1] = Backend::Google::ProtocolMessageReader::nextField;
  result[17] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 144) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::skipField@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x2B8uLL);
  *result = Backend::Google::ProtocolMessageReader::skipField;
  result[1] = Backend::Google::ProtocolMessageReader::skipField;
  result[85] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 688) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::skipField@<X0>(uint64_t a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  _QWORD *result;

  result = operator new(0x280uLL);
  *result = Backend::Google::ProtocolMessageReader::skipField;
  result[1] = Backend::Google::ProtocolMessageReader::skipField;
  *((_DWORD *)result + 158) = a2;
  result[77] = a1;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a3 = result;
  *((_BYTE *)result + 636) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::readRepeatedPackedInt32@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x178uLL);
  *result = Backend::Google::ProtocolMessageReader::readRepeatedPackedInt32;
  result[1] = Backend::Google::ProtocolMessageReader::readRepeatedPackedInt32;
  result[42] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 368) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::byteReader@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0xF8uLL);
  *result = Backend::Google::ProtocolMessageReader::byteReader;
  result[1] = Backend::Google::ProtocolMessageReader::byteReader;
  result[29] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 240) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::readLengthDelimitedField@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x140uLL);
  *result = Backend::Google::ProtocolMessageReader::readLengthDelimitedField;
  result[1] = Backend::Google::ProtocolMessageReader::readLengthDelimitedField;
  result[30] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 312) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::byteReaderAndLength@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0xB0uLL);
  *result = Backend::Google::ProtocolMessageReader::byteReaderAndLength;
  result[1] = Backend::Google::ProtocolMessageReader::byteReaderAndLength;
  result[20] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 168) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::readVarintField@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0xA0uLL);
  *result = Backend::Google::ProtocolMessageReader::readVarintField;
  result[1] = Backend::Google::ProtocolMessageReader::readVarintField;
  result[18] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 152) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::riceDecompressor@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, int a2@<W1>, int a3@<W2>, _QWORD *a4@<X8>)
{
  _QWORD *result;

  result = operator new(0x148uLL);
  *result = Backend::Google::ProtocolMessageReader::riceDecompressor;
  result[1] = Backend::Google::ProtocolMessageReader::riceDecompressor;
  result[38] = this;
  *((_DWORD *)result + 78) = a2;
  *((_DWORD *)result + 79) = a3;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a4 = result;
  *((_BYTE *)result + 320) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::readString@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x190uLL);
  *result = Backend::Google::ProtocolMessageReader::readString;
  result[1] = Backend::Google::ProtocolMessageReader::readString;
  result[48] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 392) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::fieldType@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x98uLL);
  *result = Backend::Google::ProtocolMessageReader::fieldType;
  result[1] = Backend::Google::ProtocolMessageReader::fieldType;
  result[17] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 144) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::skipVarintField@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x98uLL);
  *result = Backend::Google::ProtocolMessageReader::skipVarintField;
  result[1] = Backend::Google::ProtocolMessageReader::skipVarintField;
  result[17] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 144) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::skip64BitField@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x48uLL);
  *result = Backend::Google::ProtocolMessageReader::skip64BitField;
  result[1] = Backend::Google::ProtocolMessageReader::skip64BitField;
  result[5] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 64) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::skipLengthDelimitedField@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x110uLL);
  *result = Backend::Google::ProtocolMessageReader::skipLengthDelimitedField;
  result[1] = Backend::Google::ProtocolMessageReader::skipLengthDelimitedField;
  result[27] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 264) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::skipGroup@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x50uLL);
  *result = Backend::Google::ProtocolMessageReader::skipGroup;
  result[1] = Backend::Google::ProtocolMessageReader::skipGroup;
  result[6] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 76) = 0;
  return result;
}

_QWORD *Backend::Google::ProtocolMessageReader::skip32BitField@<X0>(Backend::Google::ProtocolMessageReader *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  result = operator new(0x48uLL);
  *result = Backend::Google::ProtocolMessageReader::skip32BitField;
  result[1] = Backend::Google::ProtocolMessageReader::skip32BitField;
  result[5] = this;
  result[2] = 0;
  *((_DWORD *)result + 6) = 0;
  *a2 = result;
  *((_BYTE *)result + 64) = 0;
  return result;
}

uint64_t detail::lazy_promise<ReadResult<unsigned long long>>::result(uint64_t a1)
{
  std::exception_ptr v2;
  int v3;
  std::exception_ptr v4;

  if (*(_DWORD *)(a1 + 8) != 2)
    return a1 + 16;
  std::exception_ptr::exception_ptr(&v4, (const std::exception_ptr *)(a1 + 16));
  v2.__ptr_ = &v4;
  std::rethrow_exception(v2);
  return std::__optional_move_base<std::vector<unsigned char>,false>::__optional_move_base[abi:sn180100](v3);
}

uint64_t std::__optional_move_base<std::vector<unsigned char>,false>::__optional_move_base[abi:sn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  size_t v5;
  char *v6;

  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 24) = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    v4 = *(const void **)a2;
    v3 = *(_QWORD *)(a2 + 8);
    v5 = v3 - *(_QWORD *)a2;
    if (v3 != *(_QWORD *)a2)
    {
      std::vector<unsigned char>::__vallocate[abi:sn180100]((_QWORD *)a1, v3 - *(_QWORD *)a2);
      v6 = *(char **)(a1 + 8);
      memmove(v6, v4, v5);
      *(_QWORD *)(a1 + 8) = &v6[v5];
    }
    *(_BYTE *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t detail::lazy_promise<std::optional<std::pair<std::shared_ptr<ReadStream>,unsigned long>>>::~lazy_promise(uint64_t a1)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1 && *(_BYTE *)(a1 + 40))
  {
    std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 16);
  }
  return a1;
}

uint64_t *std::construct_at[abi:sn180100]<ReadStream,std::shared_ptr<ReadStream> &,unsigned long long &,ReadStream*>(uint64_t *result, uint64_t a2, uint64_t *a3)
{
  uint64_t *v3;
  uint64_t *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;

  if (result)
  {
    v3 = result;
    v4 = *(uint64_t **)a2;
    v5 = *(std::__shared_weak_count **)(a2 + 8);
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    v8 = *a3;
    v10 = *v4;
    v9 = v4[1];
    *result = v10;
    result[1] = v9;
    if (v9)
    {
      v11 = (unint64_t *)(v9 + 8);
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      v10 = *result;
    }
    result[2] = *(_QWORD *)(v10 + 64) + v8;
    *((_BYTE *)result + 24) = 1;
    if (v5)
    {
      v13 = (unint64_t *)&v5->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    return v3;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::~lazy_promise(uint64_t a1)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1 && *(_BYTE *)(a1 + 32))
  {
    std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 16);
  }
  return a1;
}

void std::__shared_ptr_emplace<BitProvider>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB840;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<BitProvider>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB840;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<BitProvider>::__on_zero_shared(uint64_t a1)
{
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 24);
}

uint64_t std::construct_at[abi:sn180100]<BitProvider,std::shared_ptr<ReadStream> &,BitProvider*>(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  if (result)
  {
    v2 = result;
    v3 = *a2;
    v4 = (std::__shared_weak_count *)a2[1];
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
      *(_QWORD *)result = v3;
      *(_QWORD *)(result + 8) = v4;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
      *(_WORD *)(result + 16) = 0;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    else
    {
      *(_QWORD *)result = v3;
      *(_QWORD *)(result + 8) = 0;
      *(_WORD *)(result + 16) = 0;
    }
    return v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t std::construct_at[abi:sn180100]<RiceDecompressor,unsigned int &,unsigned int &,std::shared_ptr<BitProvider>,RiceDecompressor*>(uint64_t result, int *a2, int *a3, uint64_t *a4)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t v11;

  if (result)
  {
    v4 = result;
    v5 = *a2;
    v6 = *a3;
    v7 = *a4;
    v8 = (std::__shared_weak_count *)a4[1];
    *a4 = 0;
    a4[1] = 0;
    *(_DWORD *)result = v6;
    *(_DWORD *)(result + 4) = v5;
    *(_QWORD *)(result + 8) = v7;
    *(_QWORD *)(result + 16) = v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    return v4;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t detail::lazy_promise<std::optional<std::string>>::~lazy_promise(uint64_t a1)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 2)
  {
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  }
  else if (v2 == 1 && *(_BYTE *)(a1 + 40) && *(char *)(a1 + 39) < 0)
  {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void ReadStream::readByte(std::exception_ptr *__p)
{
  std::__shared_weak_count *ptr;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;

  if (__p->__ptr_ && LOBYTE(__p[9].__ptr_))
  {
    if (LOBYTE(__p[9].__ptr_) == 1)
    {
      ptr = (std::__shared_weak_count *)__p[6].__ptr_;
      if (!ptr)
        goto LABEL_13;
      p_shared_owners = (unint64_t *)&ptr->__shared_owners_;
      do
        v4 = __ldaxr(p_shared_owners);
      while (__stlxr(v4 - 1, p_shared_owners));
    }
    else
    {
      ptr = (std::__shared_weak_count *)__p[6].__ptr_;
      if (!ptr)
        goto LABEL_13;
      v5 = (unint64_t *)&ptr->__shared_owners_;
      do
        v4 = __ldaxr(v5);
      while (__stlxr(v4 - 1, v5));
    }
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))ptr->__on_zero_shared)(ptr);
      std::__shared_weak_count::__release_weak(ptr);
    }
  }
LABEL_13:
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

_QWORD *Backend::Google::readVarint(uint64_t a1)
{
  std::exception_ptr *v2;
  uint64_t *v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  void *v16;

  if (!*(_BYTE *)(a1 + 88))
  {
    v11 = 0;
    v12 = 0;
    goto LABEL_6;
  }
  v2 = *(std::exception_ptr **)(a1 + 80);
  detail::lazy_promise<ReadResult<unsigned char>>::result((uint64_t)&v2[2]);
  v4 = *v3;
  v5 = (char)*v3;
  v6 = HIDWORD(*v3);
  ReadStream::readByte(v2);
  if ((_DWORD)v6 == 1)
  {
    v7 = *(_QWORD *)(a1 + 64);
    v8 = *(_QWORD *)(a1 + 72);
    v9 = 7 * v7;
    if ((v5 & 0x80000000) == 0)
    {
      *(_QWORD *)(a1 + 32) = ((unint64_t)v4 << v9) | v8;
      v10 = 1;
LABEL_12:
      *(_DWORD *)(a1 + 40) = v10;
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
    }
    v11 = v7 + 1;
    if (v11 == 10)
    {
LABEL_11:
      v10 = 0;
      *(_BYTE *)(a1 + 32) = 0;
      goto LABEL_12;
    }
    v12 = ((unint64_t)(v4 & 0x7F) << v9) | v8;
LABEL_6:
    *(_QWORD *)(a1 + 64) = v11;
    *(_QWORD *)(a1 + 72) = v12;
    v13 = operator new(0x50uLL);
    v14 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 80) = v13;
    *v13 = ReadStream::readByte;
    v13[1] = ReadStream::readByte;
    v13[8] = v14;
    *((_DWORD *)v13 + 6) = 0;
    *((_BYTE *)v13 + 72) = 0;
    *(_BYTE *)(a1 + 88) = 1;
    v13[2] = a1;
    return ReadStream::readByte((uint64_t)v13);
  }
  if (*(_QWORD *)(a1 + 64))
    goto LABEL_11;
  if (!(_DWORD)v6)
  {
    v10 = 0;
    *(_BYTE *)(a1 + 32) = v5 != 0;
    goto LABEL_12;
  }
  v16 = (void *)std::__throw_bad_variant_access[abi:sn180100]();
  return (_QWORD *)Backend::Google::readVarint(v16);
}

void Backend::Google::readVarint(void *__p)
{
  BOOL v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;

  if (*(_QWORD *)__p)
    v2 = *((_BYTE *)__p + 88) == 0;
  else
    v2 = 1;
  if (!v2)
    (*(void (**)(void))(*((_QWORD *)__p + 10) + 8))();
  if (*((_DWORD *)__p + 6) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)__p + 4);
  v3 = *((_QWORD *)__p + 7);
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      v6 = (std::__shared_weak_count *)*((_QWORD *)__p + 7);
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  operator delete(__p);
}

void Backend::Google::readVarint(uint64_t a1)
{
  BOOL v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;

  if (*(_QWORD *)a1)
    v2 = *(_BYTE *)(a1 + 88) == 0;
  else
    v2 = 1;
  if (!v2)
    (*(void (**)(void))(*(_QWORD *)(a1 + 80) + 8))();
  if (*(_DWORD *)(a1 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 32));
  v3 = *(_QWORD *)(a1 + 56);
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      v6 = *(std::__shared_weak_count **)(a1 + 56);
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

_QWORD *Backend::Google::ProtocolMessageReader::nextField(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  void *v13;

  v2 = a1 + 40;
  if (*(_BYTE *)(a1 + 144))
  {
    v3 = detail::lazy_promise<ReadResult<unsigned long long>>::result(a1 + 56);
    v4 = *(_QWORD *)v3;
    v5 = *(_DWORD *)(v3 + 8);
    Backend::Google::readVarint(v2);
    if (!v5)
    {
      *(_QWORD *)(a1 + 32) = v4 != 0;
LABEL_17:
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
    }
    if (v5 == 1)
    {
      v6 = 1;
      switch(v4 & 7)
      {
        case 0:
          goto LABEL_16;
        case 1:
          v6 = 2;
          goto LABEL_16;
        case 2:
          v6 = 3;
          goto LABEL_16;
        case 3:
          v6 = 4;
          goto LABEL_16;
        case 4:
          **(_DWORD **)(a1 + 136) = 5;
          goto LABEL_14;
        case 5:
          v6 = 6;
LABEL_16:
          **(_DWORD **)(a1 + 136) = v6;
          *(_DWORD *)(a1 + 32) = v4 >> 3;
          *(_DWORD *)(a1 + 36) = 1;
          break;
        default:
LABEL_14:
          *(_QWORD *)(a1 + 32) = 0;
          break;
      }
      goto LABEL_17;
    }
    v13 = (void *)std::__throw_bad_variant_access[abi:sn180100]();
    return (_QWORD *)Backend::Google::ProtocolMessageReader::nextField(v13);
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 136);
    v9 = *(_QWORD *)(v7 + 8);
    v8 = *(_QWORD *)(v7 + 16);
    if (v8)
    {
      v10 = (unint64_t *)(v8 + 8);
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    *(_QWORD *)(a1 + 40) = Backend::Google::readVarint;
    *(_QWORD *)(a1 + 48) = Backend::Google::readVarint;
    *(_QWORD *)(a1 + 88) = v9;
    *(_QWORD *)(a1 + 96) = v8;
    *(_DWORD *)(a1 + 64) = 0;
    *(_BYTE *)(a1 + 128) = 0;
    *(_BYTE *)(a1 + 144) = 1;
    *(_QWORD *)(a1 + 56) = a1;
    return Backend::Google::readVarint(a1 + 40);
  }
}

void Backend::Google::ProtocolMessageReader::nextField(void *__p)
{
  BOOL v2;

  if (*(_QWORD *)__p)
    v2 = *((_BYTE *)__p + 144) == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::readVarint((uint64_t)__p + 40);
  if (*((_DWORD *)__p + 6) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)__p + 4);
  operator delete(__p);
}

_QWORD *Backend::Google::ProtocolMessageReader::skipVarintField(uint64_t a1)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v2 = a1 + 40;
  if (*(_BYTE *)(a1 + 144))
  {
    *(_BYTE *)(a1 + 32) = *(_DWORD *)(detail::lazy_promise<ReadResult<unsigned long long>>::result(a1 + 56) + 8) == 1;
    *(_DWORD *)(a1 + 24) = 1;
    Backend::Google::readVarint(v2);
    *(_QWORD *)a1 = 0;
    return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 136);
    v6 = *(_QWORD *)(v4 + 8);
    v5 = *(_QWORD *)(v4 + 16);
    if (v5)
    {
      v7 = (unint64_t *)(v5 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    *(_QWORD *)(a1 + 40) = Backend::Google::readVarint;
    *(_QWORD *)(a1 + 48) = Backend::Google::readVarint;
    *(_QWORD *)(a1 + 88) = v6;
    *(_QWORD *)(a1 + 96) = v5;
    *(_DWORD *)(a1 + 64) = 0;
    *(_BYTE *)(a1 + 128) = 0;
    *(_BYTE *)(a1 + 144) = 1;
    *(_QWORD *)(a1 + 56) = a1;
    return Backend::Google::readVarint(a1 + 40);
  }
}

void Backend::Google::ProtocolMessageReader::skipVarintField(void *__p)
{
  BOOL v2;

  if (*(_QWORD *)__p)
    v2 = *((_BYTE *)__p + 144) == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::readVarint((uint64_t)__p + 40);
  if (*((_DWORD *)__p + 6) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)__p + 4);
  operator delete(__p);
}

void Backend::Google::ProtocolMessageReader::skipVarintField(uint64_t a1)
{
  BOOL v2;

  if (*(_QWORD *)a1)
    v2 = *(_BYTE *)(a1 + 144) == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::readVarint(a1 + 40);
  if (*(_DWORD *)(a1 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 32));
}

_QWORD *Backend::Google::ProtocolMessageReader::skip64BitField(uint64_t a1)
{
  std::exception_ptr *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  _QWORD *v8;

  if (!*(_BYTE *)(a1 + 64))
  {
    v5 = 0;
    goto LABEL_6;
  }
  v2 = *(std::exception_ptr **)(a1 + 56);
  detail::lazy_promise<ReadResult<unsigned char>>::result((uint64_t)&v2[2]);
  v4 = *(unsigned int *)(v3 + 4);
  ReadStream::readByte(v2);
  if (v4 != 1)
  {
    v6 = 0;
    goto LABEL_8;
  }
  v5 = *(_QWORD *)(a1 + 48) + 1;
  if (*(_QWORD *)(a1 + 48) != 7)
  {
LABEL_6:
    *(_QWORD *)(a1 + 48) = v5;
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v8 = operator new(0x50uLL);
    *(_QWORD *)(a1 + 56) = v8;
    *v8 = ReadStream::readByte;
    v8[1] = ReadStream::readByte;
    v8[8] = v7;
    *((_DWORD *)v8 + 6) = 0;
    *((_BYTE *)v8 + 72) = 0;
    *(_BYTE *)(a1 + 64) = 1;
    v8[2] = a1;
    return ReadStream::readByte((uint64_t)v8);
  }
  v6 = 1;
LABEL_8:
  *(_BYTE *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 24) = 1;
  *(_QWORD *)a1 = 0;
  return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
}

void Backend::Google::ProtocolMessageReader::skip64BitField(void *__p)
{
  BOOL v2;

  if (*(_QWORD *)__p)
    v2 = *((_BYTE *)__p + 64) == 0;
  else
    v2 = 1;
  if (!v2)
    (*(void (**)(void))(*((_QWORD *)__p + 7) + 8))();
  if (*((_DWORD *)__p + 6) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)__p + 4);
  operator delete(__p);
}

void Backend::Google::ProtocolMessageReader::skip64BitField(uint64_t a1)
{
  BOOL v2;

  if (*(_QWORD *)a1)
    v2 = *(_BYTE *)(a1 + 64) == 0;
  else
    v2 = 1;
  if (!v2)
    (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 8))();
  if (*(_DWORD *)(a1 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 32));
}

_QWORD *Backend::Google::ProtocolMessageReader::byteReaderAndLength(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v13;
  __int128 v14;

  v2 = a1 + 64;
  if (*(_BYTE *)(a1 + 168))
  {
    v14 = *(_OWORD *)detail::lazy_promise<ReadResult<unsigned long long>>::result(a1 + 80);
    Backend::Google::readVarint(v2);
    if (DWORD2(v14) != 1)
    {
      v6 = 0;
      *(_BYTE *)(a1 + 32) = 0;
      goto LABEL_11;
    }
    v3 = *(_DWORD **)(a1 + 160);
    *v3 = 0;
    v4 = operator new(0x38uLL);
    v4[1] = 0;
    v4[2] = 0;
    *v4 = off_1EA3EB808;
    std::construct_at[abi:sn180100]<ReadStream,std::shared_ptr<ReadStream> &,unsigned long long &,ReadStream*>(v4 + 3, (uint64_t)(v3 + 2), (uint64_t *)&v14);
    if (DWORD2(v14) == 1)
    {
      v5 = v14;
      *(_QWORD *)(a1 + 32) = v4 + 3;
      *(_QWORD *)(a1 + 40) = v4;
      *(_QWORD *)(a1 + 48) = v5;
      v6 = 1;
LABEL_11:
      *(_BYTE *)(a1 + 56) = v6;
LABEL_13:
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
    }
    v13 = std::__throw_bad_variant_access[abi:sn180100]();
    return (_QWORD *)Backend::Google::ProtocolMessageReader::byteReaderAndLength(v13);
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 160);
    if (*(_DWORD *)v7 != 3)
    {
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 56) = 0;
      goto LABEL_13;
    }
    v9 = *(_QWORD *)(v7 + 8);
    v8 = *(_QWORD *)(v7 + 16);
    if (v8)
    {
      v10 = (unint64_t *)(v8 + 8);
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
    *(_QWORD *)(a1 + 64) = Backend::Google::readVarint;
    *(_QWORD *)(a1 + 72) = Backend::Google::readVarint;
    *(_QWORD *)(a1 + 112) = v9;
    *(_QWORD *)(a1 + 120) = v8;
    *(_DWORD *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 152) = 0;
    *(_BYTE *)(a1 + 168) = 1;
    *(_QWORD *)(a1 + 80) = a1;
    return Backend::Google::readVarint(a1 + 64);
  }
}

void Backend::Google::ProtocolMessageReader::byteReaderAndLength(_BYTE *a1)
{
  BOOL v2;

  if (*(_QWORD *)a1)
    v2 = a1[168] == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::readVarint((uint64_t)(a1 + 64));
  detail::lazy_promise<std::optional<std::pair<std::shared_ptr<ReadStream>,unsigned long>>>::~lazy_promise((uint64_t)(a1 + 16));
  operator delete(a1);
}

uint64_t Backend::Google::ProtocolMessageReader::byteReaderAndLength(uint64_t a1)
{
  BOOL v2;

  if (*(_QWORD *)a1)
    v2 = *(_BYTE *)(a1 + 168) == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::readVarint(a1 + 64);
  return detail::lazy_promise<std::optional<std::pair<std::shared_ptr<ReadStream>,unsigned long>>>::~lazy_promise(a1 + 16);
}

_QWORD *Backend::Google::ProtocolMessageReader::skipLengthDelimitedField(uint64_t a1)
{
  _BYTE *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::exception_ptr *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;

  v2 = (_BYTE *)(a1 + 264);
  v3 = *(unsigned __int8 *)(a1 + 264);
  if (v3 == 2)
  {
    v10 = *(std::exception_ptr **)(a1 + 256);
    detail::lazy_promise<ReadResult<unsigned char>>::result((uint64_t)&v10[2]);
    v12 = *(unsigned int *)(v11 + 4);
    ReadStream::readByte(v10);
    if (v12 != 1)
    {
      v13 = 0;
LABEL_15:
      *(_BYTE *)(a1 + 32) = v13;
      *(_DWORD *)(a1 + 24) = 1;
      v18 = *(_QWORD *)(a1 + 232);
      if (v18)
      {
        v19 = (unint64_t *)(v18 + 8);
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          v21 = *(std::__shared_weak_count **)(a1 + 232);
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      goto LABEL_21;
    }
    v9 = *(_QWORD *)(a1 + 248) + 1;
    if (v9 != *(_QWORD *)(a1 + 240))
      goto LABEL_13;
LABEL_11:
    v13 = 1;
    goto LABEL_15;
  }
  if (v3 != 1)
  {
    v14 = *(_QWORD *)(a1 + 216);
    *(_QWORD *)(a1 + 40) = Backend::Google::ProtocolMessageReader::byteReaderAndLength;
    *(_QWORD *)(a1 + 48) = Backend::Google::ProtocolMessageReader::byteReaderAndLength;
    *(_QWORD *)(a1 + 200) = v14;
    *(_DWORD *)(a1 + 64) = 0;
    *(_BYTE *)(a1 + 208) = 0;
    *v2 = 1;
    *(_QWORD *)(a1 + 56) = a1;
    return Backend::Google::ProtocolMessageReader::byteReaderAndLength(a1 + 40);
  }
  detail::lazy_promise<std::optional<std::pair<std::shared_ptr<ReadStream>,unsigned long>>>::result(a1 + 56);
  if (*(_BYTE *)(v4 + 24))
  {
    *(_QWORD *)(a1 + 224) = *(_QWORD *)v4;
    v5 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(a1 + 232) = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
    v8 = *(_QWORD *)(v4 + 16);
    *(_QWORD *)(a1 + 240) = v8;
    Backend::Google::ProtocolMessageReader::byteReaderAndLength(a1 + 40);
    if (v8)
    {
      v9 = 0;
LABEL_13:
      *(_QWORD *)(a1 + 248) = v9;
      v16 = operator new(0x50uLL);
      v17 = *(_QWORD *)(a1 + 224);
      *(_QWORD *)(a1 + 256) = v16;
      *v16 = ReadStream::readByte;
      v16[1] = ReadStream::readByte;
      v16[8] = v17;
      *((_DWORD *)v16 + 6) = 0;
      *((_BYTE *)v16 + 72) = 0;
      *v2 = 2;
      v16[2] = a1;
      return ReadStream::readByte((uint64_t)v16);
    }
    goto LABEL_11;
  }
  Backend::Google::ProtocolMessageReader::byteReaderAndLength(a1 + 40);
  *(_BYTE *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 24) = 1;
LABEL_21:
  *(_QWORD *)a1 = 0;
  return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
}

void Backend::Google::ProtocolMessageReader::skipLengthDelimitedField(std::exception_ptr *__p)
{
  std::exception_ptr *v2;
  void *ptr;
  char *v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;

  ptr = __p->__ptr_;
  v2 = __p + 5;
  if (ptr && LOBYTE(__p[33].__ptr_))
  {
    if (LOBYTE(__p[33].__ptr_) == 1)
    {
      Backend::Google::ProtocolMessageReader::byteReaderAndLength((uint64_t)v2);
    }
    else
    {
      (*((void (**)(void))__p[32].__ptr_ + 1))();
      v4 = (char *)__p[29].__ptr_;
      if (v4)
      {
        v5 = (unint64_t *)(v4 + 8);
        do
          v6 = __ldaxr(v5);
        while (__stlxr(v6 - 1, v5));
        if (!v6)
        {
          v7 = (std::__shared_weak_count *)__p[29].__ptr_;
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
  }
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

void Backend::Google::ProtocolMessageReader::skipLengthDelimitedField(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;

  v3 = *a1;
  v2 = (uint64_t)(a1 + 5);
  if (v3 && *((_BYTE *)a1 + 264))
  {
    if (*((_BYTE *)a1 + 264) == 1)
    {
      Backend::Google::ProtocolMessageReader::byteReaderAndLength(v2);
    }
    else
    {
      (*(void (**)(void))(a1[32] + 8))();
      v4 = a1[29];
      if (v4)
      {
        v5 = (unint64_t *)(v4 + 8);
        do
          v6 = __ldaxr(v5);
        while (__stlxr(v6 - 1, v5));
        if (!v6)
        {
          v7 = (std::__shared_weak_count *)a1[29];
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
  }
  if (*((_DWORD *)a1 + 6) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)a1 + 4);
}

_QWORD *Backend::Google::ProtocolMessageReader::fieldType(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  char v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;

  v2 = a1 + 40;
  if (*(_BYTE *)(a1 + 144))
  {
    v3 = detail::lazy_promise<ReadResult<unsigned long long>>::result(a1 + 56);
    v4 = *(_QWORD *)v3;
    v5 = *(_DWORD *)(v3 + 8);
    Backend::Google::readVarint(v2);
    if (v5 == 1 && (v4 & 7u) < 6uLL)
    {
      *(_DWORD *)(a1 + 32) = (v4 & 7) + 1;
      v6 = 1;
    }
    else
    {
      v6 = 0;
      *(_BYTE *)(a1 + 32) = 0;
    }
    *(_BYTE *)(a1 + 36) = v6;
    *(_DWORD *)(a1 + 24) = 1;
    *(_QWORD *)a1 = 0;
    return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 136);
    v10 = *(_QWORD *)(v8 + 8);
    v9 = *(_QWORD *)(v8 + 16);
    if (v9)
    {
      v11 = (unint64_t *)(v9 + 8);
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    *(_QWORD *)(a1 + 40) = Backend::Google::readVarint;
    *(_QWORD *)(a1 + 48) = Backend::Google::readVarint;
    *(_QWORD *)(a1 + 88) = v10;
    *(_QWORD *)(a1 + 96) = v9;
    *(_DWORD *)(a1 + 64) = 0;
    *(_BYTE *)(a1 + 128) = 0;
    *(_BYTE *)(a1 + 144) = 1;
    *(_QWORD *)(a1 + 56) = a1;
    return Backend::Google::readVarint(a1 + 40);
  }
}

void Backend::Google::ProtocolMessageReader::fieldType(void *__p)
{
  BOOL v2;

  if (*(_QWORD *)__p)
    v2 = *((_BYTE *)__p + 144) == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::readVarint((uint64_t)__p + 40);
  if (*((_DWORD *)__p + 6) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)__p + 4);
  operator delete(__p);
}

_QWORD *Backend::Google::ProtocolMessageReader::skip32BitField(uint64_t a1)
{
  std::exception_ptr *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  _QWORD *v8;

  if (!*(_BYTE *)(a1 + 64))
  {
    v5 = 0;
    goto LABEL_6;
  }
  v2 = *(std::exception_ptr **)(a1 + 56);
  detail::lazy_promise<ReadResult<unsigned char>>::result((uint64_t)&v2[2]);
  v4 = *(unsigned int *)(v3 + 4);
  ReadStream::readByte(v2);
  if (v4 != 1)
  {
    v6 = 0;
    goto LABEL_8;
  }
  v5 = *(_QWORD *)(a1 + 48) + 1;
  if (*(_QWORD *)(a1 + 48) != 3)
  {
LABEL_6:
    *(_QWORD *)(a1 + 48) = v5;
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v8 = operator new(0x50uLL);
    *(_QWORD *)(a1 + 56) = v8;
    *v8 = ReadStream::readByte;
    v8[1] = ReadStream::readByte;
    v8[8] = v7;
    *((_DWORD *)v8 + 6) = 0;
    *((_BYTE *)v8 + 72) = 0;
    *(_BYTE *)(a1 + 64) = 1;
    v8[2] = a1;
    return ReadStream::readByte((uint64_t)v8);
  }
  v6 = 1;
LABEL_8:
  *(_BYTE *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 24) = 1;
  *(_QWORD *)a1 = 0;
  return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
}

void Backend::Google::ProtocolMessageReader::skip32BitField(void *__p)
{
  BOOL v2;

  if (*(_QWORD *)__p)
    v2 = *((_BYTE *)__p + 64) == 0;
  else
    v2 = 1;
  if (!v2)
    (*(void (**)(void))(*((_QWORD *)__p + 7) + 8))();
  if (*((_DWORD *)__p + 6) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)__p + 4);
  operator delete(__p);
}

void Backend::Google::ProtocolMessageReader::skip32BitField(uint64_t a1)
{
  BOOL v2;

  if (*(_QWORD *)a1)
    v2 = *(_BYTE *)(a1 + 64) == 0;
  else
    v2 = 1;
  if (!v2)
    (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 8))();
  if (*(_DWORD *)(a1 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 32));
}

void Backend::Google::ProtocolMessageReader::skipField(uint64_t a1)
{
  __asm { BR              X11 }
}

{
  if (*(_QWORD *)a1)
    __asm { BR              X13 }
  if (*(_DWORD *)(a1 + 24) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 32));
}

{
  uint64_t v2;
  unsigned __int8 *v3;
  int v4;
  char v5;
  int *v6;
  int v7;

  v2 = a1 + 40;
  if (*(_BYTE *)(a1 + 688))
  {
    detail::lazy_promise<BOOL>::result(a1 + 56);
    v4 = *v3;
    Backend::Google::ProtocolMessageReader::skipField(v2);
    if (v4)
    {
      **(_DWORD **)(a1 + 680) = 0;
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
    *(_BYTE *)(a1 + 32) = v5;
    *(_DWORD *)(a1 + 24) = 1;
    *(_QWORD *)a1 = 0;
    (**(void (***)(void))(a1 + 16))();
  }
  else
  {
    v6 = *(int **)(a1 + 680);
    v7 = *v6;
    *(_QWORD *)(a1 + 40) = Backend::Google::ProtocolMessageReader::skipField;
    *(_QWORD *)(a1 + 48) = Backend::Google::ProtocolMessageReader::skipField;
    *(_DWORD *)(a1 + 672) = v7;
    *(_QWORD *)(a1 + 656) = v6;
    *(_DWORD *)(a1 + 64) = 0;
    *(_BYTE *)(a1 + 676) = 0;
    *(_BYTE *)(a1 + 688) = 1;
    *(_QWORD *)(a1 + 56) = a1;
    Backend::Google::ProtocolMessageReader::skipField(a1 + 40);
  }
}

_QWORD *sub_1DBCF7C74@<X0>(_BYTE *a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  _QWORD *result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;

  switch(*(_DWORD *)(v1 + 632))
  {
    case 0:
    case 5:
      *(_BYTE *)(v1 + 32) = 0;
      *(_DWORD *)(v1 + 24) = 1;
      goto LABEL_3;
    case 1:
      v8 = *(_QWORD *)(v1 + 616);
      *(_QWORD *)(v1 + 312) = Backend::Google::ProtocolMessageReader::skipVarintField;
      *(_QWORD *)(v1 + 320) = Backend::Google::ProtocolMessageReader::skipVarintField;
      *(_QWORD *)(v1 + 448) = v8;
      *(_DWORD *)(v1 + 336) = 0;
      a1[152] = 0;
      *v6 = 1;
      *(_QWORD *)(v1 + 328) = v1;
      result = Backend::Google::ProtocolMessageReader::skipVarintField(v3);
      break;
    case 2:
      v9 = *(_QWORD *)(v1 + 616);
      *(_QWORD *)(v1 + 464) = Backend::Google::ProtocolMessageReader::skip64BitField;
      *(_QWORD *)(v1 + 472) = Backend::Google::ProtocolMessageReader::skip64BitField;
      *(_QWORD *)(v1 + 504) = v9;
      *(_DWORD *)(v1 + 488) = 0;
      a1[224] = 0;
      *v6 = 2;
      *(_QWORD *)(v1 + 480) = v1;
      result = Backend::Google::ProtocolMessageReader::skip64BitField(v4);
      break;
    case 3:
      v10 = *(_QWORD *)(v1 + 616);
      *(_QWORD *)(v1 + 40) = Backend::Google::ProtocolMessageReader::skipLengthDelimitedField;
      *(_QWORD *)(v1 + 48) = Backend::Google::ProtocolMessageReader::skipLengthDelimitedField;
      *(_QWORD *)(v1 + 256) = v10;
      *(_DWORD *)(v1 + 64) = 0;
      *a1 = 0;
      *v6 = 3;
      *(_QWORD *)(v1 + 56) = v1;
      result = Backend::Google::ProtocolMessageReader::skipLengthDelimitedField(v2);
      break;
    case 4:
      v11 = *(_QWORD *)(v1 + 616);
      v12 = operator new(0x50uLL);
      *v12 = Backend::Google::ProtocolMessageReader::skipGroup;
      v12[1] = Backend::Google::ProtocolMessageReader::skipGroup;
      v12[6] = v11;
      *((_DWORD *)v12 + 6) = 0;
      *(_QWORD *)(v1 + 608) = v12;
      *((_BYTE *)v12 + 76) = 0;
      *(_QWORD *)(v1 + 624) = v12;
      *v6 = 4;
      v12[2] = v1;
      result = Backend::Google::ProtocolMessageReader::skipGroup((uint64_t)v12);
      break;
    case 6:
      v13 = *(_QWORD *)(v1 + 616);
      *(_QWORD *)(v1 + 536) = Backend::Google::ProtocolMessageReader::skip32BitField;
      *(_QWORD *)(v1 + 544) = Backend::Google::ProtocolMessageReader::skip32BitField;
      *(_QWORD *)(v1 + 576) = v13;
      *(_DWORD *)(v1 + 560) = 0;
      a1[296] = 0;
      *v6 = 5;
      *(_QWORD *)(v1 + 552) = v1;
      result = Backend::Google::ProtocolMessageReader::skip32BitField(v5);
      break;
    default:
LABEL_3:
      *(_QWORD *)v1 = 0;
      result = (_QWORD *)(**(uint64_t (***)(void))(v1 + 16))();
      break;
  }
  return result;
}

void Backend::Google::ProtocolMessageReader::skipField(std::exception_ptr *__p)
{
  if (__p->__ptr_)
    __asm { BR              X13 }
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

_QWORD *Backend::Google::ProtocolMessageReader::skipGroup(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  int v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t v7;
  char v8;
  char v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v13;
  _QWORD *v14;

  if (!*(_BYTE *)(a1 + 76))
  {
    *(_DWORD *)(a1 + 72) = 1;
LABEL_16:
    v10 = operator new(0x98uLL);
    v11 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 56) = v10;
    *v10 = Backend::Google::ProtocolMessageReader::fieldType;
    v10[1] = Backend::Google::ProtocolMessageReader::fieldType;
    v10[17] = v11;
    *((_DWORD *)v10 + 6) = 0;
    *((_BYTE *)v10 + 144) = 0;
    *(_BYTE *)(a1 + 76) = 1;
    v10[2] = a1;
    return Backend::Google::ProtocolMessageReader::fieldType((uint64_t)v10);
  }
  if (*(_BYTE *)(a1 + 76) != 1)
  {
    detail::lazy_promise<BOOL>::result(*(_QWORD *)(a1 + 64) + 16);
    v6 = *v5;
    v7 = *(_QWORD *)(a1 + 40);
    if (v7)
      (*(void (**)(void))(v7 + 8))();
    if (v6)
    {
      v8 = 0;
      v4 = *(_DWORD *)(a1 + 72);
LABEL_15:
      *(_DWORD *)(a1 + 72) = v4;
      *(_BYTE *)(a1 + 77) = v8;
      if (v4)
        goto LABEL_16;
      **(_DWORD **)(a1 + 48) = 0;
      v9 = 1;
      goto LABEL_18;
    }
LABEL_12:
    v9 = 0;
LABEL_18:
    *(_BYTE *)(a1 + 32) = v9;
    *(_DWORD *)(a1 + 24) = 1;
    *(_QWORD *)a1 = 0;
    return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
  }
  v2 = *(void **)(a1 + 56);
  v3 = *(_QWORD *)detail::lazy_promise<ReadResult<unsigned long long>>::result((uint64_t)v2 + 16);
  Backend::Google::ProtocolMessageReader::fieldType(v2);
  if ((v3 & 0xFF00000000) == 0)
    goto LABEL_12;
  if ((_DWORD)v3 == 5)
  {
    v4 = *(_DWORD *)(a1 + 72) - 1;
    goto LABEL_14;
  }
  if ((_DWORD)v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 72) + 1;
LABEL_14:
    v8 = *(_BYTE *)(a1 + 77);
    goto LABEL_15;
  }
  v13 = *(_QWORD *)(a1 + 48);
  v14 = operator new(0x280uLL);
  *v14 = Backend::Google::ProtocolMessageReader::skipField;
  v14[1] = Backend::Google::ProtocolMessageReader::skipField;
  *((_DWORD *)v14 + 158) = v3;
  v14[77] = v13;
  *((_DWORD *)v14 + 6) = 0;
  *(_QWORD *)(a1 + 40) = v14;
  *((_BYTE *)v14 + 636) = 0;
  *(_QWORD *)(a1 + 64) = v14;
  *(_BYTE *)(a1 + 76) = 2;
  v14[2] = a1;
  return (_QWORD *)Backend::Google::ProtocolMessageReader::skipField();
}

void Backend::Google::ProtocolMessageReader::skipGroup(std::exception_ptr *__p)
{
  void (**ptr)(void);

  if (__p->__ptr_ && BYTE4(__p[9].__ptr_))
  {
    if (BYTE4(__p[9].__ptr_) == 1)
    {
      ptr = (void (**)(void))__p[7].__ptr_;
    }
    else
    {
      ptr = (void (**)(void))__p[5].__ptr_;
      if (!ptr)
        goto LABEL_7;
    }
    ptr[1]();
  }
LABEL_7:
  if (LODWORD(__p[3].__ptr_) == 2)
    std::exception_ptr::~exception_ptr(__p + 4);
  operator delete(__p);
}

void Backend::Google::ProtocolMessageReader::skipField(void *__p)
{
  BOOL v2;

  if (*(_QWORD *)__p)
    v2 = *((_BYTE *)__p + 688) == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::ProtocolMessageReader::skipField((uint64_t)__p + 40);
  if (*((_DWORD *)__p + 6) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)__p + 4);
  operator delete(__p);
}

_QWORD *Backend::Google::ProtocolMessageReader::byteReader(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v2 = a1 + 56;
  if (!*(_BYTE *)(a1 + 240))
  {
    v10 = *(_QWORD *)(a1 + 232);
    *(_QWORD *)(a1 + 56) = Backend::Google::ProtocolMessageReader::byteReaderAndLength;
    *(_QWORD *)(a1 + 64) = Backend::Google::ProtocolMessageReader::byteReaderAndLength;
    *(_QWORD *)(a1 + 216) = v10;
    *(_DWORD *)(a1 + 80) = 0;
    *(_BYTE *)(a1 + 224) = 0;
    *(_BYTE *)(a1 + 240) = 1;
    *(_QWORD *)(a1 + 72) = a1;
    return Backend::Google::ProtocolMessageReader::byteReaderAndLength(a1 + 56);
  }
  detail::lazy_promise<std::optional<std::pair<std::shared_ptr<ReadStream>,unsigned long>>>::result(a1 + 72);
  if (*((_BYTE *)v3 + 24))
  {
    v5 = *v3;
    v4 = (std::__shared_weak_count *)v3[1];
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
      Backend::Google::ProtocolMessageReader::byteReaderAndLength(v2);
      *(_QWORD *)(a1 + 32) = v5;
      *(_QWORD *)(a1 + 40) = v4;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
      *(_BYTE *)(a1 + 48) = 1;
      *(_DWORD *)(a1 + 24) = 1;
      do
        v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
      goto LABEL_16;
    }
    Backend::Google::ProtocolMessageReader::byteReaderAndLength(v2);
    *(_QWORD *)(a1 + 32) = v5;
    *(_QWORD *)(a1 + 40) = 0;
    *(_BYTE *)(a1 + 48) = 1;
  }
  else
  {
    Backend::Google::ProtocolMessageReader::byteReaderAndLength(v2);
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 48) = 0;
  }
  *(_DWORD *)(a1 + 24) = 1;
LABEL_16:
  *(_QWORD *)a1 = 0;
  return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
}

void Backend::Google::ProtocolMessageReader::byteReader(_BYTE *a1)
{
  BOOL v2;

  if (*(_QWORD *)a1)
    v2 = a1[240] == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::ProtocolMessageReader::byteReaderAndLength((uint64_t)(a1 + 56));
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::~lazy_promise((uint64_t)(a1 + 16));
  operator delete(a1);
}

uint64_t Backend::Google::ProtocolMessageReader::byteReader(uint64_t a1)
{
  BOOL v2;

  if (*(_QWORD *)a1)
    v2 = *(_BYTE *)(a1 + 240) == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::ProtocolMessageReader::byteReaderAndLength(a1 + 56);
  return detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::~lazy_promise(a1 + 16);
}

_QWORD *Backend::Google::ProtocolMessageReader::readRepeatedPackedInt32(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  _DWORD *v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  char *i;
  int v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;

  v2 = a1 + 304;
  v3 = (_QWORD *)(a1 + 312);
  v4 = *(unsigned __int8 *)(a1 + 368);
  if (v4 != 2)
  {
    if (v4 == 1)
    {
      detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(a1 + 80);
      if (*(_BYTE *)(v5 + 16))
      {
        *(_QWORD *)(a1 + 344) = *(_QWORD *)v5;
        v6 = *(_QWORD *)(v5 + 8);
        *(_QWORD *)(a1 + 352) = v6;
        if (v6)
        {
          v7 = (unint64_t *)(v6 + 8);
          do
            v8 = __ldxr(v7);
          while (__stxr(v8 + 1, v7));
        }
        Backend::Google::ProtocolMessageReader::byteReader(a1 + 64);
        *v3 = 0;
        v3[1] = 0;
        v3[2] = 0;
        goto LABEL_34;
      }
      Backend::Google::ProtocolMessageReader::byteReader(a1 + 64);
    }
    else
    {
      v16 = *(_DWORD **)(a1 + 336);
      if (*v16 == 3)
      {
        *(_QWORD *)(a1 + 64) = Backend::Google::ProtocolMessageReader::byteReader;
        *(_QWORD *)(a1 + 72) = Backend::Google::ProtocolMessageReader::byteReader;
        *(_QWORD *)(a1 + 296) = v16;
        *(_DWORD *)(a1 + 88) = 0;
        *(_BYTE *)v2 = 0;
        *(_BYTE *)(a1 + 368) = 1;
        *(_QWORD *)(a1 + 80) = a1;
        return Backend::Google::ProtocolMessageReader::byteReader(a1 + 64);
      }
    }
    *(_BYTE *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_19:
    *(_QWORD *)a1 = 0;
    return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
  }
  v9 = *(void **)(a1 + 360);
  v10 = detail::lazy_promise<ReadResult<unsigned long long>>::result((uint64_t)v9 + 16);
  v11 = *(_QWORD *)v10;
  v12 = *(_DWORD *)(v10 + 8);
  Backend::Google::readVarint(v9);
  if (!v12)
  {
    if ((_BYTE)v11)
    {
      *(_OWORD *)(a1 + 32) = *(_OWORD *)v3;
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 328);
      *(_BYTE *)(a1 + 56) = 1;
      *(_DWORD *)(a1 + 24) = 1;
    }
    else
    {
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 56) = 0;
      *(_DWORD *)(a1 + 24) = 1;
      v33 = *(void **)(a1 + 312);
      if (v33)
      {
        *(_QWORD *)(a1 + 320) = v33;
        operator delete(v33);
      }
    }
    v34 = *(_QWORD *)(a1 + 352);
    if (v34)
    {
      v35 = (unint64_t *)(v34 + 8);
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        v37 = *(std::__shared_weak_count **)(a1 + 352);
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    goto LABEL_19;
  }
  if (v12 != 1)
    goto LABEL_46;
  v14 = *(_DWORD **)(a1 + 320);
  v13 = *(_QWORD *)(a1 + 328);
  if ((unint64_t)v14 >= v13)
  {
    v18 = ((uint64_t)v14 - *v3) >> 2;
    if ((unint64_t)(v18 + 1) >> 62)
      goto LABEL_47;
    v19 = v13 - *v3;
    v20 = v19 >> 1;
    if (v19 >> 1 <= (unint64_t)(v18 + 1))
      v20 = v18 + 1;
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL)
      v21 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v21 = v20;
    if (v21)
    {
      v22 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::CompressionType>>(a1 + 328, v21);
      if (v22)
      {
        v24 = &v22[4 * v23];
        v25 = &v22[4 * v18];
        *(_DWORD *)v25 = v11;
        v15 = v25 + 4;
        v26 = *(char **)(a1 + 312);
        for (i = *(char **)(a1 + 320); i != v26; i -= 4)
        {
          v28 = *((_DWORD *)i - 1);
          *((_DWORD *)v25 - 1) = v28;
          v25 -= 4;
        }
        *(_QWORD *)(a1 + 312) = v25;
        *(_QWORD *)(a1 + 320) = v15;
        *(_QWORD *)(a1 + 328) = v24;
        if (v26)
          operator delete(v26);
        goto LABEL_33;
      }
    }
    goto LABEL_45;
  }
  if (!v14)
  {
LABEL_45:
    __break(1u);
LABEL_46:
    std::__throw_bad_variant_access[abi:sn180100]();
LABEL_47:
    abort();
  }
  *v14 = v11;
  v15 = v14 + 1;
LABEL_33:
  *(_QWORD *)(a1 + 320) = v15;
LABEL_34:
  v29 = *(_QWORD *)(a1 + 352);
  if (v29)
  {
    v30 = (unint64_t *)(v29 + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v32 = operator new(0x60uLL);
  *(_QWORD *)(a1 + 360) = v32;
  *v32 = Backend::Google::readVarint;
  v32[1] = Backend::Google::readVarint;
  *((_OWORD *)v32 + 3) = *(_OWORD *)(v2 + 40);
  *((_DWORD *)v32 + 6) = 0;
  *((_BYTE *)v32 + 88) = 0;
  *(_BYTE *)(v2 + 64) = 2;
  v32[2] = a1;
  return Backend::Google::readVarint((uint64_t)v32);
}

void Backend::Google::ProtocolMessageReader::readRepeatedPackedInt32(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;

  v3 = *a1;
  v2 = (uint64_t)(a1 + 8);
  if (v3 && *((_BYTE *)a1 + 368))
  {
    if (*((_BYTE *)a1 + 368) == 1)
    {
      Backend::Google::ProtocolMessageReader::byteReader(v2);
    }
    else
    {
      (*(void (**)(void))(a1[45] + 8))();
      v4 = (void *)a1[39];
      if (v4)
      {
        a1[40] = (uint64_t)v4;
        operator delete(v4);
      }
      v5 = a1[44];
      if (v5)
      {
        v6 = (unint64_t *)(v5 + 8);
        do
          v7 = __ldaxr(v6);
        while (__stlxr(v7 - 1, v6));
        if (!v7)
        {
          v8 = (std::__shared_weak_count *)a1[44];
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
  }
  detail::lazy_promise<std::optional<std::vector<unsigned int>>>::~lazy_promise((uint64_t)(a1 + 2));
  operator delete(a1);
}

_QWORD *Backend::Google::ProtocolMessageReader::readLengthDelimitedField(uint64_t a1)
{
  _BYTE *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;
  char *v12;
  _QWORD *v13;
  uint64_t v14;
  std::exception_ptr *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  _BYTE *v20;
  _BYTE *v21;
  uint64_t v22;
  void *v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  size_t v27;
  _BYTE *v28;
  _BYTE *v29;
  char v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;

  v2 = (_BYTE *)(a1 + 312);
  v3 = *(unsigned __int8 *)(a1 + 312);
  if (v3 == 2)
  {
    v16 = *(std::exception_ptr **)(a1 + 304);
    detail::lazy_promise<ReadResult<unsigned char>>::result((uint64_t)&v16[2]);
    v18 = *v17;
    ReadStream::readByte(v16);
    if (HIDWORD(v18) != 1)
    {
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 56) = 0;
      *(_DWORD *)(a1 + 24) = 1;
      v23 = *(void **)(a1 + 280);
      if (v23)
        operator delete(v23);
      goto LABEL_32;
    }
    v20 = *(_BYTE **)(a1 + 288);
    v19 = *(_QWORD *)(a1 + 296);
    if ((unint64_t)v20 >= v19)
    {
      v24 = *(_QWORD *)(a1 + 280);
      v25 = (uint64_t)&v20[-v24 + 1];
      if (v25 < 0)
        goto LABEL_39;
      v26 = v19 - v24;
      if (2 * v26 > v25)
        v25 = 2 * v26;
      if (v26 >= 0x3FFFFFFFFFFFFFFFLL)
        v27 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v27 = v25;
      if (v27)
      {
        v28 = operator new(v27);
        v12 = &v28[v27];
        v21 = &v20[(_QWORD)v28 - v24];
        *v21 = v18;
        v10 = v21;
        if (v20 != (_BYTE *)v24)
        {
          v29 = &v20[~v24];
          do
          {
            v30 = *--v20;
            (v29--)[(_QWORD)v28] = v30;
          }
          while (v20 != (_BYTE *)v24);
          v10 = v28;
        }
        if (v24)
          operator delete((void *)v24);
LABEL_30:
        v11 = v21 + 1;
        v9 = *(_QWORD *)(a1 + 272) + 1;
        if (v9 != *(_QWORD *)(a1 + 264))
        {
LABEL_8:
          *(_QWORD *)(a1 + 288) = v11;
          *(_QWORD *)(a1 + 296) = v12;
          *(_QWORD *)(a1 + 272) = v9;
          *(_QWORD *)(a1 + 280) = v10;
          v13 = operator new(0x50uLL);
          v14 = *(_QWORD *)(a1 + 248);
          *(_QWORD *)(a1 + 304) = v13;
          *v13 = ReadStream::readByte;
          v13[1] = ReadStream::readByte;
          v13[8] = v14;
          *((_DWORD *)v13 + 6) = 0;
          *((_BYTE *)v13 + 72) = 0;
          *v2 = 2;
          v13[2] = a1;
          return ReadStream::readByte((uint64_t)v13);
        }
        goto LABEL_31;
      }
    }
    else if (v20)
    {
      *v20 = v18;
      v21 = *(_BYTE **)(a1 + 288);
      v12 = *(char **)(a1 + 296);
      v10 = *(_BYTE **)(a1 + 280);
      goto LABEL_30;
    }
    __break(1u);
LABEL_39:
    abort();
  }
  if (v3 != 1)
  {
    v22 = *(_QWORD *)(a1 + 240);
    *(_QWORD *)(a1 + 64) = Backend::Google::ProtocolMessageReader::byteReaderAndLength;
    *(_QWORD *)(a1 + 72) = Backend::Google::ProtocolMessageReader::byteReaderAndLength;
    *(_QWORD *)(a1 + 224) = v22;
    *(_DWORD *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 232) = 0;
    *v2 = 1;
    *(_QWORD *)(a1 + 80) = a1;
    return Backend::Google::ProtocolMessageReader::byteReaderAndLength(a1 + 64);
  }
  detail::lazy_promise<std::optional<std::pair<std::shared_ptr<ReadStream>,unsigned long>>>::result(a1 + 80);
  if (*(_BYTE *)(v4 + 24))
  {
    *(_QWORD *)(a1 + 248) = *(_QWORD *)v4;
    v5 = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(a1 + 256) = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
    v8 = *(_QWORD *)(v4 + 16);
    *(_QWORD *)(a1 + 264) = v8;
    Backend::Google::ProtocolMessageReader::byteReaderAndLength(a1 + 64);
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    if (v8)
      goto LABEL_8;
LABEL_31:
    *(_QWORD *)(a1 + 32) = v10;
    *(_QWORD *)(a1 + 40) = v11;
    *(_QWORD *)(a1 + 48) = v12;
    *(_BYTE *)(a1 + 56) = 1;
    *(_DWORD *)(a1 + 24) = 1;
LABEL_32:
    v31 = *(_QWORD *)(a1 + 256);
    if (v31)
    {
      v32 = (unint64_t *)(v31 + 8);
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        v34 = *(std::__shared_weak_count **)(a1 + 256);
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }
    goto LABEL_37;
  }
  Backend::Google::ProtocolMessageReader::byteReaderAndLength(a1 + 64);
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 24) = 1;
LABEL_37:
  *(_QWORD *)a1 = 0;
  return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
}

void Backend::Google::ProtocolMessageReader::readLengthDelimitedField(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;

  v3 = *a1;
  v2 = (uint64_t)(a1 + 8);
  if (v3 && *((_BYTE *)a1 + 312))
  {
    if (*((_BYTE *)a1 + 312) == 1)
    {
      Backend::Google::ProtocolMessageReader::byteReaderAndLength(v2);
    }
    else
    {
      (*(void (**)(void))(a1[38] + 8))();
      v4 = (void *)a1[35];
      if (v4)
        operator delete(v4);
      v5 = a1[32];
      if (v5)
      {
        v6 = (unint64_t *)(v5 + 8);
        do
          v7 = __ldaxr(v6);
        while (__stlxr(v7 - 1, v6));
        if (!v7)
        {
          v8 = (std::__shared_weak_count *)a1[32];
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
  }
  detail::lazy_promise<std::optional<std::vector<unsigned int>>>::~lazy_promise((uint64_t)(a1 + 2));
  operator delete(a1);
}

uint64_t Backend::Google::ProtocolMessageReader::readLengthDelimitedField(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;

  v3 = *a1;
  v2 = (uint64_t)(a1 + 8);
  if (v3 && *((_BYTE *)a1 + 312))
  {
    if (*((_BYTE *)a1 + 312) == 1)
    {
      Backend::Google::ProtocolMessageReader::byteReaderAndLength(v2);
    }
    else
    {
      (*(void (**)(void))(a1[38] + 8))();
      v4 = (void *)a1[35];
      if (v4)
        operator delete(v4);
      v5 = a1[32];
      if (v5)
      {
        v6 = (unint64_t *)(v5 + 8);
        do
          v7 = __ldaxr(v6);
        while (__stlxr(v7 - 1, v6));
        if (!v7)
        {
          v8 = (std::__shared_weak_count *)a1[32];
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
  }
  return detail::lazy_promise<std::optional<std::vector<unsigned int>>>::~lazy_promise((uint64_t)(a1 + 2));
}

_QWORD *Backend::Google::ProtocolMessageReader::readVarintField(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  v2 = a1 + 48;
  if (*(_BYTE *)(a1 + 152))
  {
    v3 = detail::lazy_promise<ReadResult<unsigned long long>>::result(a1 + 64);
    v4 = *(_QWORD *)v3;
    v5 = *(_DWORD *)(v3 + 8);
    Backend::Google::readVarint(v2);
    if (v5 == 1)
    {
      **(_DWORD **)(a1 + 144) = 0;
      *(_QWORD *)(a1 + 32) = v4;
      v6 = 1;
LABEL_10:
      *(_BYTE *)(a1 + 40) = v6;
      *(_DWORD *)(a1 + 24) = 1;
      *(_QWORD *)a1 = 0;
      return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
    }
LABEL_9:
    v6 = 0;
    *(_BYTE *)(a1 + 32) = 0;
    goto LABEL_10;
  }
  v7 = *(_QWORD *)(a1 + 144);
  if (*(_DWORD *)v7 != 1)
    goto LABEL_9;
  v9 = *(_QWORD *)(v7 + 8);
  v8 = *(_QWORD *)(v7 + 16);
  if (v8)
  {
    v10 = (unint64_t *)(v8 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  *(_QWORD *)(a1 + 48) = Backend::Google::readVarint;
  *(_QWORD *)(a1 + 56) = Backend::Google::readVarint;
  *(_QWORD *)(a1 + 96) = v9;
  *(_QWORD *)(a1 + 104) = v8;
  *(_DWORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  *(_BYTE *)(a1 + 152) = 1;
  *(_QWORD *)(a1 + 64) = a1;
  return Backend::Google::readVarint(a1 + 48);
}

void Backend::Google::ProtocolMessageReader::readVarintField(void *__p)
{
  BOOL v2;

  if (*(_QWORD *)__p)
    v2 = *((_BYTE *)__p + 152) == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::readVarint((uint64_t)__p + 48);
  if (*((_DWORD *)__p + 6) == 2)
    std::exception_ptr::~exception_ptr((std::exception_ptr *)__p + 4);
  operator delete(__p);
}

_QWORD *Backend::Google::ProtocolMessageReader::riceDecompressor(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v17;
  std::__shared_weak_count *v18;
  char v19;
  _QWORD *v20;
  std::__shared_weak_count *v21;

  v2 = a1 + 56;
  if (*(_BYTE *)(a1 + 320))
  {
    detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::result(a1 + 72);
    if (*(_BYTE *)(v3 + 16))
    {
      v4 = *(std::__shared_weak_count **)(v3 + 8);
      v17 = *(_QWORD *)v3;
      v18 = v4;
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
      }
      v19 = 1;
      Backend::Google::ProtocolMessageReader::byteReader(v2);
      v7 = (std::__shared_weak_count *)operator new(0x30uLL);
      v7->__shared_owners_ = 0;
      v7->__shared_weak_owners_ = 0;
      v7->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB840;
      std::construct_at[abi:sn180100]<BitProvider,std::shared_ptr<ReadStream> &,BitProvider*>((uint64_t)&v7[1], &v17);
      v20 = &v7[1].__vftable;
      v21 = v7;
      v8 = operator new(0x30uLL);
      v8[1] = 0;
      v8[2] = 0;
      *v8 = off_1EA3EB8B0;
      std::construct_at[abi:sn180100]<RiceDecompressor,unsigned int &,unsigned int &,std::shared_ptr<BitProvider>,RiceDecompressor*>((uint64_t)(v8 + 3), (int *)(a1 + 312), (int *)(a1 + 316), (uint64_t *)&v20);
      *(_QWORD *)(a1 + 32) = v8 + 3;
      *(_QWORD *)(a1 + 40) = v8;
      *(_BYTE *)(a1 + 48) = 1;
      *(_DWORD *)(a1 + 24) = 1;
      v9 = v21;
      if (v21)
      {
        v10 = (unint64_t *)&v21->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      if (v19)
      {
        v12 = v18;
        if (v18)
        {
          v13 = (unint64_t *)&v18->__shared_owners_;
          do
            v14 = __ldaxr(v13);
          while (__stlxr(v14 - 1, v13));
          if (!v14)
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
        }
      }
    }
    else
    {
      Backend::Google::ProtocolMessageReader::byteReader(v2);
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 48) = 0;
      *(_DWORD *)(a1 + 24) = 1;
    }
    *(_QWORD *)a1 = 0;
    return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
  }
  else
  {
    v15 = *(_QWORD *)(a1 + 304);
    *(_QWORD *)(a1 + 56) = Backend::Google::ProtocolMessageReader::byteReader;
    *(_QWORD *)(a1 + 64) = Backend::Google::ProtocolMessageReader::byteReader;
    *(_QWORD *)(a1 + 288) = v15;
    *(_DWORD *)(a1 + 80) = 0;
    *(_BYTE *)(a1 + 296) = 0;
    *(_BYTE *)(a1 + 320) = 1;
    *(_QWORD *)(a1 + 72) = a1;
    return Backend::Google::ProtocolMessageReader::byteReader(a1 + 56);
  }
}

void Backend::Google::ProtocolMessageReader::riceDecompressor(_BYTE *a1)
{
  BOOL v2;

  if (*(_QWORD *)a1)
    v2 = a1[320] == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::ProtocolMessageReader::byteReader((uint64_t)(a1 + 56));
  detail::lazy_promise<std::optional<std::shared_ptr<ReadStream>>>::~lazy_promise((uint64_t)(a1 + 16));
  operator delete(a1);
}

_QWORD *Backend::Google::ProtocolMessageReader::readString(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  void *__p;
  char *v7;
  char v8;
  __int128 v9;
  uint64_t v10;

  v2 = (uint64_t *)(a1 + 64);
  if (*(_BYTE *)(a1 + 392))
  {
    detail::lazy_promise<std::optional<std::vector<unsigned char>>>::result(a1 + 80);
    std::__optional_move_base<std::vector<unsigned char>,false>::__optional_move_base[abi:sn180100]((uint64_t)&__p, v3);
    Backend::Google::ProtocolMessageReader::readLengthDelimitedField(v2);
    if (v8)
    {
      std::string::__init_with_size[abi:sn180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(&v9, (char *)__p, v7, v7 - (_BYTE *)__p);
      *(_OWORD *)(a1 + 32) = v9;
      *(_QWORD *)(a1 + 48) = v10;
      *(_BYTE *)(a1 + 56) = 1;
      *(_DWORD *)(a1 + 24) = 1;
      if (v8)
      {
        if (__p)
        {
          v7 = (char *)__p;
          operator delete(__p);
        }
      }
    }
    else
    {
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 56) = 0;
      *(_DWORD *)(a1 + 24) = 1;
    }
    *(_QWORD *)a1 = 0;
    return (_QWORD *)(**(uint64_t (***)(void))(a1 + 16))();
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 384);
    *(_QWORD *)(a1 + 64) = Backend::Google::ProtocolMessageReader::readLengthDelimitedField;
    *(_QWORD *)(a1 + 72) = Backend::Google::ProtocolMessageReader::readLengthDelimitedField;
    *(_QWORD *)(a1 + 304) = v4;
    *(_DWORD *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 376) = 0;
    *(_BYTE *)(a1 + 392) = 1;
    *(_QWORD *)(a1 + 80) = a1;
    return Backend::Google::ProtocolMessageReader::readLengthDelimitedField(a1 + 64);
  }
}

void Backend::Google::ProtocolMessageReader::readString(void *a1)
{
  BOOL v2;

  if (*(_QWORD *)a1)
    v2 = *((_BYTE *)a1 + 392) == 0;
  else
    v2 = 1;
  if (!v2)
    Backend::Google::ProtocolMessageReader::readLengthDelimitedField((uint64_t *)a1 + 8);
  detail::lazy_promise<std::optional<std::string>>::~lazy_promise((uint64_t)a1 + 16);
  operator delete(a1);
}

_QWORD *Backend::Google::ProtocolMessageWriter::ProtocolMessageWriter(_QWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

void Backend::Google::ProtocolMessageWriter::writeUInt32Field(Backend::Google::ProtocolMessageWriter *this, int a2, unsigned int a3)
{
  int v6;

  v6 = Backend::Google::ProtocolBuffers::wireType(0);
  Backend::Google::ProtocolMessageWriter::writeVarint(this, v6 | (8 * a2));
  Backend::Google::ProtocolMessageWriter::writeVarint(this, a3);
}

void Backend::Google::ProtocolMessageWriter::writeTag(Backend::Google::ProtocolMessageWriter *a1, int a2, int a3)
{
  unsigned int v4;

  v4 = Backend::Google::ProtocolBuffers::wireType(a3) | (8 * a2);
  Backend::Google::ProtocolMessageWriter::writeVarint(a1, v4);
}

void Backend::Google::ProtocolMessageWriter::writeVarint(Backend::Google::ProtocolMessageWriter *this, unsigned int a2)
{
  unsigned int v2;
  _BYTE *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  unint64_t v8;
  unint64_t v9;
  _BYTE *v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  char *v14;
  char *v15;
  _BYTE *v16;
  _BYTE *v17;
  char v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  _BYTE *v23;
  unint64_t v24;
  unint64_t v25;
  size_t v26;
  _BYTE *v27;
  char *v28;
  _BYTE *v29;
  char v30;

  LOBYTE(v2) = a2;
  if (a2 > 0x7F)
  {
    v5 = (_BYTE *)*((_QWORD *)this + 1);
    v6 = a2;
    while (1)
    {
      v7 = v6 | 0x80;
      v8 = *((_QWORD *)this + 2);
      if ((unint64_t)v5 >= v8)
      {
        v9 = *(_QWORD *)this;
        v10 = &v5[-*(_QWORD *)this];
        v11 = (unint64_t)(v10 + 1);
        if ((uint64_t)(v10 + 1) < 0)
          goto LABEL_40;
        v12 = v8 - v9;
        if (2 * v12 > v11)
          v11 = 2 * v12;
        if (v12 >= 0x3FFFFFFFFFFFFFFFLL)
          v13 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v13 = v11;
        if (!v13)
          goto LABEL_39;
        v14 = (char *)operator new(v13);
        v15 = &v10[(_QWORD)v14];
        v16 = &v10[(_QWORD)v14];
        *v16 = v7;
        v4 = v16 + 1;
        if (v5 != (_BYTE *)v9)
        {
          v17 = &v5[~v9];
          do
          {
            v18 = *--v5;
            (v17--)[(_QWORD)v14] = v18;
          }
          while (v5 != (_BYTE *)v9);
          v5 = (_BYTE *)v9;
          v15 = v14;
        }
        *(_QWORD *)this = v15;
        *((_QWORD *)this + 1) = v4;
        *((_QWORD *)this + 2) = &v14[v13];
        if (v5)
          operator delete(v5);
      }
      else
      {
        if (!v5)
          goto LABEL_39;
        *v5 = v7;
        v4 = v5 + 1;
      }
      *((_QWORD *)this + 1) = v4;
      v2 = v6 >> 7;
      v19 = v6 >> 14;
      v5 = v4;
      v6 >>= 7;
      if (!v19)
        goto LABEL_21;
    }
  }
  v4 = (_BYTE *)*((_QWORD *)this + 1);
LABEL_21:
  v20 = *((_QWORD *)this + 2);
  if ((unint64_t)v4 < v20)
  {
    if (v4)
    {
      *v4 = v2;
      v21 = (uint64_t)(v4 + 1);
      goto LABEL_38;
    }
    goto LABEL_39;
  }
  v22 = *(_QWORD *)this;
  v23 = &v4[-*(_QWORD *)this];
  v24 = (unint64_t)(v23 + 1);
  if ((uint64_t)(v23 + 1) < 0)
    goto LABEL_40;
  v25 = v20 - v22;
  if (2 * v25 > v24)
    v24 = 2 * v25;
  if (v25 >= 0x3FFFFFFFFFFFFFFFLL)
    v26 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v26 = v24;
  if (!v26)
  {
LABEL_39:
    __break(1u);
LABEL_40:
    abort();
  }
  v27 = operator new(v26);
  v28 = &v27[v26];
  v23[(_QWORD)v27] = v2;
  v21 = (uint64_t)&v23[(_QWORD)v27 + 1];
  if (v4 == (_BYTE *)v22)
  {
    v27 = &v23[(_QWORD)v27];
  }
  else
  {
    v29 = &v4[~v22];
    do
    {
      v30 = *--v4;
      (v29--)[(_QWORD)v27] = v30;
    }
    while (v4 != (_BYTE *)v22);
    v4 = (_BYTE *)v22;
  }
  *(_QWORD *)this = v27;
  *((_QWORD *)this + 1) = v21;
  *((_QWORD *)this + 2) = v28;
  if (v4)
    operator delete(v4);
LABEL_38:
  *((_QWORD *)this + 1) = v21;
}

void Backend::Google::ProtocolMessageWriter::writeUInt64Field(Backend::Google::ProtocolMessageWriter *this, int a2, unint64_t a3)
{
  int v6;

  v6 = Backend::Google::ProtocolBuffers::wireType(0);
  Backend::Google::ProtocolMessageWriter::writeVarint(this, v6 | (8 * a2));
  Backend::Google::ProtocolMessageWriter::writeVarint(this, a3);
}

void Backend::Google::ProtocolMessageWriter::writeVarint(Backend::Google::ProtocolMessageWriter *this, unint64_t a2)
{
  unint64_t v2;
  _BYTE *v4;
  _BYTE *v5;
  unint64_t v6;
  char v7;
  unint64_t v8;
  unint64_t v9;
  _BYTE *v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  char *v14;
  char *v15;
  _BYTE *v16;
  _BYTE *v17;
  char v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  _BYTE *v23;
  unint64_t v24;
  unint64_t v25;
  size_t v26;
  _BYTE *v27;
  char *v28;
  _BYTE *v29;
  char v30;

  LOBYTE(v2) = a2;
  if (a2 > 0x7F)
  {
    v5 = (_BYTE *)*((_QWORD *)this + 1);
    v6 = a2;
    while (1)
    {
      v7 = v6 | 0x80;
      v8 = *((_QWORD *)this + 2);
      if ((unint64_t)v5 >= v8)
      {
        v9 = *(_QWORD *)this;
        v10 = &v5[-*(_QWORD *)this];
        v11 = (unint64_t)(v10 + 1);
        if ((uint64_t)(v10 + 1) < 0)
          goto LABEL_40;
        v12 = v8 - v9;
        if (2 * v12 > v11)
          v11 = 2 * v12;
        if (v12 >= 0x3FFFFFFFFFFFFFFFLL)
          v13 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v13 = v11;
        if (!v13)
          goto LABEL_39;
        v14 = (char *)operator new(v13);
        v15 = &v10[(_QWORD)v14];
        v16 = &v10[(_QWORD)v14];
        *v16 = v7;
        v4 = v16 + 1;
        if (v5 != (_BYTE *)v9)
        {
          v17 = &v5[~v9];
          do
          {
            v18 = *--v5;
            (v17--)[(_QWORD)v14] = v18;
          }
          while (v5 != (_BYTE *)v9);
          v5 = (_BYTE *)v9;
          v15 = v14;
        }
        *(_QWORD *)this = v15;
        *((_QWORD *)this + 1) = v4;
        *((_QWORD *)this + 2) = &v14[v13];
        if (v5)
          operator delete(v5);
      }
      else
      {
        if (!v5)
          goto LABEL_39;
        *v5 = v7;
        v4 = v5 + 1;
      }
      *((_QWORD *)this + 1) = v4;
      v2 = v6 >> 7;
      v19 = v6 >> 14;
      v5 = v4;
      v6 >>= 7;
      if (!v19)
        goto LABEL_21;
    }
  }
  v4 = (_BYTE *)*((_QWORD *)this + 1);
LABEL_21:
  v20 = *((_QWORD *)this + 2);
  if ((unint64_t)v4 < v20)
  {
    if (v4)
    {
      *v4 = v2;
      v21 = (uint64_t)(v4 + 1);
      goto LABEL_38;
    }
    goto LABEL_39;
  }
  v22 = *(_QWORD *)this;
  v23 = &v4[-*(_QWORD *)this];
  v24 = (unint64_t)(v23 + 1);
  if ((uint64_t)(v23 + 1) < 0)
    goto LABEL_40;
  v25 = v20 - v22;
  if (2 * v25 > v24)
    v24 = 2 * v25;
  if (v25 >= 0x3FFFFFFFFFFFFFFFLL)
    v26 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v26 = v24;
  if (!v26)
  {
LABEL_39:
    __break(1u);
LABEL_40:
    abort();
  }
  v27 = operator new(v26);
  v28 = &v27[v26];
  v23[(_QWORD)v27] = v2;
  v21 = (uint64_t)&v23[(_QWORD)v27 + 1];
  if (v4 == (_BYTE *)v22)
  {
    v27 = &v23[(_QWORD)v27];
  }
  else
  {
    v29 = &v4[~v22];
    do
    {
      v30 = *--v4;
      (v29--)[(_QWORD)v27] = v30;
    }
    while (v4 != (_BYTE *)v22);
    v4 = (_BYTE *)v22;
  }
  *(_QWORD *)this = v27;
  *((_QWORD *)this + 1) = v21;
  *((_QWORD *)this + 2) = v28;
  if (v4)
    operator delete(v4);
LABEL_38:
  *((_QWORD *)this + 1) = v21;
}

char *Backend::Google::ProtocolMessageWriter::writeBytes(char **this, int a2, char *a3, char *a4)
{
  int v8;

  v8 = Backend::Google::ProtocolBuffers::wireType(1);
  Backend::Google::ProtocolMessageWriter::writeVarint((Backend::Google::ProtocolMessageWriter *)this, v8 | (8 * a2));
  Backend::Google::ProtocolMessageWriter::writeVarint((Backend::Google::ProtocolMessageWriter *)this, a4 - a3);
  return std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)this, this[1], a3, a4, a4 - a3);
}

char *Backend::Google::ProtocolMessageWriter::writeStringField(char **a1, int a2, uint64_t a3)
{
  int v6;
  unint64_t v7;
  int v8;
  char *v9;
  uint64_t v10;

  v6 = Backend::Google::ProtocolBuffers::wireType(1);
  Backend::Google::ProtocolMessageWriter::writeVarint((Backend::Google::ProtocolMessageWriter *)a1, v6 | (8 * a2));
  if (*(char *)(a3 + 23) >= 0)
    v7 = *(unsigned __int8 *)(a3 + 23);
  else
    v7 = *(_QWORD *)(a3 + 8);
  Backend::Google::ProtocolMessageWriter::writeVarint((Backend::Google::ProtocolMessageWriter *)a1, v7);
  v8 = *(char *)(a3 + 23);
  if (v8 >= 0)
    v9 = (char *)a3;
  else
    v9 = *(char **)a3;
  if (v8 >= 0)
    v10 = *(unsigned __int8 *)(a3 + 23);
  else
    v10 = *(_QWORD *)(a3 + 8);
  return std::vector<unsigned char>::__insert_with_size[abi:sn180100]<char const*,char const*>(a1, a1[1], v9, &v9[v10], v10);
}

double Backend::Google::ProtocolMessageWriter::writeEmbeddedMessageField(char **a1, int a2, uint64_t a3)
{
  uint64_t v4;
  char *v6;
  char *v7;
  int v8;
  double result;
  std::string *v10;
  uint64_t v11;
  void *__p;
  char *v13;
  uint64_t v14;

  __p = 0;
  v13 = 0;
  v14 = 0;
  v4 = *(_QWORD *)(a3 + 24);
  if (v4)
  {
    (*(void (**)(uint64_t, void **))(*(_QWORD *)v4 + 48))(v4, &__p);
    v6 = (char *)__p;
    v7 = v13;
    v13 = 0;
    v14 = 0;
    __p = 0;
    v8 = Backend::Google::ProtocolBuffers::wireType(1);
    Backend::Google::ProtocolMessageWriter::writeVarint((Backend::Google::ProtocolMessageWriter *)a1, v8 | (8 * a2));
    Backend::Google::ProtocolMessageWriter::writeVarint((Backend::Google::ProtocolMessageWriter *)a1, v7 - v6);
    std::vector<unsigned char>::__insert_with_size[abi:sn180100]<unsigned char const*,unsigned char const*>((uint64_t)a1, a1[1], v6, v7, v7 - v6);
    if (v6)
      operator delete(v6);
    if (__p)
    {
      v13 = (char *)__p;
      operator delete(__p);
    }
  }
  else
  {
    v10 = std::__throw_bad_function_call[abi:sn180100]();
    *(_QWORD *)&result = Backend::Google::ProtocolMessageWriter::finish((Backend::Google::ProtocolMessageWriter *)v10, v11).n128_u64[0];
  }
  return result;
}

__n128 Backend::Google::ProtocolMessageWriter::finish@<Q0>(Backend::Google::ProtocolMessageWriter *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result;

  result = *(__n128 *)this;
  *(_OWORD *)a2 = *(_OWORD *)this;
  *(_QWORD *)(a2 + 16) = *((_QWORD *)this + 2);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = 0;
  return result;
}

void sub_1DBCF9804(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBCF9A60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1DBCF9B0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBCF9C70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBCF9DF0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBCFA920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30)
{

  _Unwind_Resume(a1);
}

void sub_1DBCFACF0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1DBCFAE98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBCFAFD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1DBCFB144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBCFB2C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1DBCFB314()
{
  JUMPOUT(0x1DBCFB308);
}

id configurationBaseURL(void)
{
  void *v0;
  void *v1;
  int v2;
  uint64_t v3;

  objc_msgSend(MEMORY[0x1E0C99E98], "URLWithString:", CFSTR("https://configuration.apple.com/configurations/internetservices/safari/"));
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  if (Backend::Google::SSBUtilities::isInternalInstall((Backend::Google::SSBUtilities *)v0))
  {
    objc_msgSend(MEMORY[0x1E0C99EA0], "standardUserDefaults");
    v1 = (void *)objc_claimAutoreleasedReturnValue();
    v2 = objc_msgSend(v1, "BOOLForKey:", CFSTR("DebugSafeBrowsingShouldUseTestConfigurationURL"));

    if (v2)
    {
      objc_msgSend(MEMORY[0x1E0C99E98], "URLWithString:", CFSTR("https://test-safari.apple.com/safebrowsing/"));
      v3 = objc_claimAutoreleasedReturnValue();

      v0 = (void *)v3;
    }
  }
  return v0;
}

void sub_1DBCFB3B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBCFB4B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1DBCFB5AC(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1DBCFB6B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBCFB7BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1DBCFB8A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1DBCFB958(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBCFB9D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1DBCFBBD8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBCFBC70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBCFBE38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBCFC00C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1DBCFC068()
{
  JUMPOUT(0x1DBCFC04CLL);
}

void sub_1DBCFC070()
{
  JUMPOUT(0x1DBCFC050);
}

void sub_1DBCFC1EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBCFC2BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

id mergeConfigurationArrayIfBothNotNil(NSArray *a1, NSArray *a2)
{
  NSArray *v3;
  NSArray *v4;
  NSArray *v5;
  void *v6;

  v3 = a1;
  v4 = a2;
  v5 = v4;
  v6 = 0;
  if (v3 && v4)
  {
    mergeConfigurationArray(v3, v4);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v6;
}

void sub_1DBCFC3B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id mergeConfigurationArray(NSArray *a1, NSArray *a2)
{
  NSArray *v3;
  NSArray *v4;
  id v5;
  void *v6;
  void *v7;

  v3 = a1;
  v4 = a2;
  v5 = objc_alloc_init(MEMORY[0x1E0C99E20]);
  objc_msgSend(v5, "addObjectsFromArray:", v3);
  objc_msgSend(v5, "addObjectsFromArray:", v4);
  objc_msgSend(v5, "allObjects");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "sortedArrayUsingSelector:", sel_compare_);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  return v7;
}

void sub_1DBCFC45C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

double SafeBrowsing::SafeHashCache::SafeHashCache(SafeBrowsing::SafeHashCache *this, uint64_t a2)
{
  double result;

  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = 850045863;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = (char *)this + 72;
  *((_QWORD *)this + 10) = (char *)this + 72;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 12) = (char *)this + 104;
  return result;
}

void SafeBrowsing::SafeHashCache::~SafeHashCache(SafeBrowsing::SafeHashCache *this)
{
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)this + 96, *((_QWORD **)this + 13));
  std::__list_imp<std::array<unsigned char,32ul>>::clear((_QWORD *)this + 9);
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
}

void SafeBrowsing::SafeHashCache::add(uint64_t a1, __int128 *a2)
{
  std::mutex *v4;

  v4 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  SafeBrowsing::SafeHashCache::addUnlocked(a1, a2);
  std::mutex::unlock(v4);
}

void sub_1DBCFC548(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void SafeBrowsing::SafeHashCache::addUnlocked(uint64_t a1, __int128 *a2)
{
  uint64_t **v4;
  __int128 v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t v8;
  char v9;
  _OWORD *v10;
  __int128 v11;
  _QWORD *v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = (uint64_t **)(a1 + 96);
  v5 = a2[1];
  v15 = *a2;
  v16 = v5;
  v17 = 0;
  v6 = (uint64_t **)std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::__emplace_unique_key_args<std::array<unsigned char,32ul>,std::pair<std::array<unsigned char,32ul> const,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>((uint64_t **)(a1 + 96), (uint64_t)&v15, (uint64_t)&v15);
  v7 = v6;
  v8 = a1 + 72;
  if (v9)
  {
    v10 = operator new(0x30uLL);
    v11 = a2[1];
    v10[1] = *a2;
    v10[2] = v11;
    v12 = *(_QWORD **)(a1 + 80);
    *(_QWORD *)v10 = v8;
    *((_QWORD *)v10 + 1) = v12;
    *v12 = v10;
    v13 = *(_QWORD *)(a1 + 88) + 1;
    *(_QWORD *)(a1 + 80) = v10;
    *(_QWORD *)(a1 + 88) = v13;
    v7[8] = (uint64_t *)v10;
    if (*(_QWORD *)(a1 + 112) > *(_QWORD *)a1)
    {
      if (!v13)
        __break(1u);
      v14 = *(_OWORD *)(*(_QWORD *)v8 + 32);
      v15 = *(_OWORD *)(*(_QWORD *)v8 + 16);
      v16 = v14;
      std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::__erase_unique<std::array<unsigned char,32ul>>(v4, (uint64_t)&v15);
      std::list<std::array<unsigned char,32ul>>::pop_back((uint64_t **)(a1 + 72));
    }
  }
  else
  {
    std::list<std::array<unsigned char,32ul>>::splice(v8, *(uint64_t **)(a1 + 80), v8, v6[8]);
    v7[8] = *(uint64_t **)(a1 + 80);
  }
}

void SafeBrowsing::SafeHashCache::add(uint64_t a1, __int128 **a2)
{
  std::mutex *v4;
  __int128 *v5;
  __int128 *v6;

  v4 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  v5 = *a2;
  v6 = a2[1];
  while (v5 != v6)
  {
    SafeBrowsing::SafeHashCache::addUnlocked(a1, v5);
    v5 += 2;
  }
  std::mutex::unlock(v4);
}

void sub_1DBCFC6D0(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

BOOL SafeBrowsing::SafeHashCache::contains(uint64_t a1, uint64_t a2)
{
  std::mutex *v4;
  _BOOL8 v5;

  v4 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  v5 = std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::__count_unique<std::array<unsigned char,32ul>>(a1 + 96, a2) != 0;
  std::mutex::unlock(v4);
  return v5;
}

void sub_1DBCFC738(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

BOOL SafeBrowsing::SafeHashCache::containsUnlocked(uint64_t a1, uint64_t a2)
{
  return std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::__count_unique<std::array<unsigned char,32ul>>(a1 + 96, a2) != 0;
}

BOOL SafeBrowsing::SafeHashCache::containsAll(uint64_t a1, uint64_t *a2)
{
  std::mutex *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;

  v4 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  v5 = *a2;
  v6 = a2[1];
  if (*a2 == v6)
  {
    v9 = 1;
  }
  else
  {
    v7 = a1 + 96;
    do
    {
      v8 = std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::__count_unique<std::array<unsigned char,32ul>>(v7, v5);
      v9 = v8 != 0;
      if (!v8)
        break;
      v5 += 32;
    }
    while (v5 != v6);
  }
  std::mutex::unlock(v4);
  return v9;
}

void sub_1DBCFC7F0(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void SafeBrowsing::SafeHashCache::empty(SafeBrowsing::SafeHashCache *this)
{
  SafeBrowsing::SafeHashCache *v1;
  std::mutex *v2;
  _QWORD *v3;

  v1 = this;
  v2 = (std::mutex *)((char *)this + 8);
  std::mutex::lock((std::mutex *)((char *)this + 8));
  std::__list_imp<std::array<unsigned char,32ul>>::clear((_QWORD *)v1 + 9);
  v3 = (_QWORD *)*((_QWORD *)v1 + 13);
  v1 = (SafeBrowsing::SafeHashCache *)((char *)v1 + 104);
  std::__tree<Backend::Google::HashView>::destroy((uint64_t)v1 - 8, v3);
  *((_QWORD *)v1 - 1) = v1;
  *(_QWORD *)v1 = 0;
  *((_QWORD *)v1 + 1) = 0;
  std::mutex::unlock(v2);
}

uint64_t std::list<std::array<unsigned char,32ul>>::splice(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  if (a2 != a4)
  {
    v4 = (uint64_t *)a4[1];
    if (v4 != a2)
    {
      v5 = *a4;
      *(_QWORD *)(v5 + 8) = v4;
      *(_QWORD *)a4[1] = v5;
      v6 = *a2;
      *(_QWORD *)(v6 + 8) = a4;
      *a4 = v6;
      *a2 = (uint64_t)a4;
      a4[1] = (uint64_t)a2;
      --*(_QWORD *)(a3 + 16);
      ++*(_QWORD *)(result + 16);
    }
  }
  return result;
}

void std::list<std::array<unsigned char,32ul>>::pop_back(uint64_t **a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;

  v1 = a1[2];
  if (v1)
  {
    v2 = *a1;
    v3 = **a1;
    *(_QWORD *)(v3 + 8) = (*a1)[1];
    *(_QWORD *)v2[1] = v3;
    a1[2] = (uint64_t *)((char *)v1 - 1);
    operator delete(v2);
  }
  else
  {
    __break(1u);
  }
}

_QWORD *std::__list_imp<std::array<unsigned char,32ul>>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (result[2])
  {
    v1 = result;
    result = (_QWORD *)result[1];
    v2 = *v1;
    v3 = *result;
    *(_QWORD *)(v3 + 8) = *(_QWORD *)(*v1 + 8);
    **(_QWORD **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        v4 = (_QWORD *)result[1];
        operator delete(result);
        result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

_OWORD *std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::__emplace_unique_key_args<std::array<unsigned char,32ul>,std::pair<std::array<unsigned char,32ul> const,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  void **v5;
  _OWORD *v6;
  uint64_t **v7;
  __int128 v8;
  uint64_t v10;

  v5 = (void **)std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::__find_equal<std::array<unsigned char,32ul>>((uint64_t)a1, &v10, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = operator new(0x48uLL);
    v8 = *(_OWORD *)(a3 + 16);
    v6[2] = *(_OWORD *)a3;
    v6[3] = v8;
    *((_QWORD *)v6 + 8) = *(_QWORD *)(a3 + 32);
    std::__tree<Backend::Google::HashView>::__insert_node_at(a1, v10, v7, (uint64_t *)v6);
  }
  return v6;
}

_QWORD *std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::__find_equal<std::array<unsigned char,32ul>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;

  v5 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    while (2)
    {
      while (2)
      {
        v6 = 0;
        v7 = v4;
        while (1)
        {
          v8 = *(unsigned __int8 *)(a3 + v6);
          v9 = *((unsigned __int8 *)v7 + v6 + 32);
          if (v8 != v9)
            break;
          if (++v6 == 32)
            goto LABEL_9;
        }
        if (v8 < v9)
        {
          v4 = (_QWORD *)*v7;
          result = v7;
          if (*v7)
            continue;
          goto LABEL_17;
        }
        break;
      }
LABEL_9:
      v10 = 0;
      while (1)
      {
        v11 = *((unsigned __int8 *)v7 + v10 + 32);
        v12 = *(unsigned __int8 *)(a3 + v10);
        if (v11 != v12)
          break;
        if (++v10 == 32)
          goto LABEL_17;
      }
      if (v11 < v12)
      {
        result = v7 + 1;
        v4 = (_QWORD *)v7[1];
        if (v4)
          continue;
      }
      break;
    }
  }
  else
  {
    v7 = result;
  }
LABEL_17:
  *a2 = v7;
  return result;
}

uint64_t std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::__erase_unique<std::array<unsigned char,32ul>>(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;

  v3 = std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::find<std::array<unsigned char,32ul>>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  v4 = v3;
  std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::__remove_node_pointer(a1, v3);
  operator delete(v4);
  return 1;
}

_QWORD *std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::find<std::array<unsigned char,32ul>>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t i;
  unsigned int v10;
  unsigned int v11;

  v4 = *(_QWORD **)(a1 + 8);
  v2 = (_QWORD *)(a1 + 8);
  v3 = v4;
  if (!v4)
    return v2;
  v5 = v2;
  do
  {
    v6 = 0;
    while (1)
    {
      v7 = *((unsigned __int8 *)v3 + v6 + 32);
      v8 = *(unsigned __int8 *)(a2 + v6);
      if (v7 != v8)
        break;
      if (++v6 == 32)
      {
        v5 = v3;
        goto LABEL_10;
      }
    }
    if (v7 < v8)
      ++v3;
    else
      v5 = v3;
LABEL_10:
    v3 = (_QWORD *)*v3;
  }
  while (v3);
  if (v5 == v2)
    return v2;
  for (i = 0; i != 32; ++i)
  {
    v10 = *(unsigned __int8 *)(a2 + i);
    v11 = *((unsigned __int8 *)v5 + i + 32);
    if (v10 != v11)
      break;
  }
  if (v10 < v11)
    return v2;
  return v5;
}

uint64_t std::__tree<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::__map_value_compare<std::array<unsigned char,32ul>,std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>,std::less<std::array<unsigned char,32ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,32ul>,std::__list_iterator<std::array<unsigned char,32ul>,void *>>>>::__count_unique<std::array<unsigned char,32ul>>(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t result;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;

  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    result = 1;
    while (2)
    {
      v4 = 0;
      while (1)
      {
        v5 = *(unsigned __int8 *)(a2 + v4);
        v6 = *((unsigned __int8 *)v2 + v4 + 32);
        if (v5 != v6)
          break;
        if (++v4 == 32)
          goto LABEL_8;
      }
      if (v5 < v6)
        goto LABEL_14;
LABEL_8:
      v7 = 0;
      while (1)
      {
        v8 = *((unsigned __int8 *)v2 + v7 + 32);
        v9 = *(unsigned __int8 *)(a2 + v7);
        if (v8 != v9)
          break;
        if (++v7 == 32)
          return result;
      }
      if (v8 >= v9)
        return result;
      ++v2;
LABEL_14:
      v2 = (_QWORD *)*v2;
      if (v2)
        continue;
      break;
    }
  }
  return 0;
}

SafeBrowsing::Service *SafeBrowsing::Service::Service(SafeBrowsing::Service *this)
{
  void *v2;
  id v3;
  SafeBrowsing::Service *v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v8[5];
  void *__p[2];
  char v10;
  void *v11[2];
  char v12;

  *(_QWORD *)this = off_1EA3EAE38;
  *((_QWORD *)this + 1) = dispatch_queue_create("com.apple.Safari.SafeBrowsing.Service", 0);
  *((_QWORD *)this + 2) = dispatch_group_create();
  std::string::basic_string[abi:sn180100]<0>((char **)v11, "Safari");
  objc_msgSend(MEMORY[0x1E0CB34D0], "bundleForClass:", objc_opt_class());
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForInfoDictionaryKey:", *MEMORY[0x1E0C9AE90]);
  v3 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  std::string::basic_string[abi:sn180100]<0>((char **)__p, (char *)objc_msgSend(v3, "UTF8String"));

  Backend::Google::Configuration::Configuration((char *)this + 24, v11, __p);
  if (v10 < 0)
    operator delete(__p[0]);
  if (v12 < 0)
    operator delete(v11[0]);
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = (char *)this + 128;
  *((_QWORD *)this + 17) = 0;
  *((_OWORD *)this + 11) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_QWORD *)this + 66) = 0;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  SafeBrowsing::Service::initialize(this);
  if (SafeBrowsing::Service::isEnabled(v4))
  {
    v6 = *((_QWORD *)this + 1);
    v5 = *((_QWORD *)this + 2);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___ZN12SafeBrowsing7ServiceC2Ev_block_invoke;
    v8[3] = &__block_descriptor_40_e5_v8__0l;
    v8[4] = this;
    dispatch_group_notify(v5, v6, v8);
  }
  return this;
}

void sub_1DBCFCD68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26)
{
  uint64_t v26;

  if (a19 < 0)
    operator delete(__p);
  if (a25 < 0)
    operator delete(a20);

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::initialize(SafeBrowsing::Service *this)
{
  char *v2;
  uint64_t v3;
  uint64_t i;
  std::string::size_type v5;
  NSObject *v6;
  Backend::Google::SSBUtilities *v7;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  SSBDatabaseUpdateSupport *v13;
  void *v14;
  _QWORD v15[5];
  _QWORD v16[5];
  _QWORD v17[5];
  _QWORD handler[5];
  void *__p;
  char *v20;
  char *v21;
  std::string v22;
  void *v23[2];
  char v24;
  char v25;
  void **p_p;
  std::string block;
  char *v28[3];
  char *v29[4];

  v29[3] = *(char **)MEMORY[0x1E0C80C00];
  SafeBrowsing::Service::databaseBaseDirectory((uint64_t)v23);
  if (!v25)
    return;
  std::string::basic_string[abi:sn180100]<0>(&block.__r_.__value_.__l.__data_, "Google");
  Platform::stringByAppendingPathComponent((uint64_t *)v23, (uint64_t)&block, &v22);
  if (SHIBYTE(block.__r_.__value_.__r.__words[2]) < 0)
    operator delete(block.__r_.__value_.__l.__data_);
  std::string::basic_string[abi:sn180100]<0>(&block.__r_.__value_.__l.__data_, "goog-malware-shavar");
  std::string::basic_string[abi:sn180100]<0>(v28, "goog-phish-shavar");
  std::string::basic_string[abi:sn180100]<0>(v29, "goog-unwanted-shavar");
  v2 = (char *)operator new(0x48uLL);
  v3 = 0;
  __p = v2;
  v20 = v2;
  v21 = v2 + 72;
  do
  {
    std::construct_at[abi:sn180100]<std::string,std::string const&,std::string*>((std::string *)&v2[v3], (__int128 *)((char *)&block + v3));
    v3 += 24;
  }
  while (v3 != 72);
  v20 = v2 + 72;
  SafeBrowsing::Service::initializeDatabaseManager((uint64_t)this, &v22, (__int128 **)&__p, 0x100000001uLL);
  p_p = &__p;
  std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](&p_p);
  for (i = 0; i != -9; i -= 3)
  {
    if (SHIBYTE(v29[i + 2]) < 0)
      operator delete(v29[i]);
  }
  v5 = MEMORY[0x1E0C809B0];
  v6 = *((_QWORD *)this + 1);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZN12SafeBrowsing7Service10initializeEv_block_invoke;
  handler[3] = &__block_descriptor_40_ea8_32c48_ZTSKZN12SafeBrowsing7Service10initializeEvE3__0_e8_v12__0i8l;
  handler[4] = this;
  v7 = (Backend::Google::SSBUtilities *)notify_register_dispatch("com.apple.Safari.SafeBrowsing.GoogleRemoteConfigurationDidChange", (int *)this + 68, v6, handler);
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(v7);
  if ((_DWORD)shouldConsultWithTencent)
  {
    if (!v25)
      goto LABEL_28;
    std::string::basic_string[abi:sn180100]<0>((char **)&__p, "Tencent");
    Platform::stringByAppendingPathComponent((uint64_t *)v23, (uint64_t)&__p, &block);
    if (SHIBYTE(v21) < 0)
      operator delete(__p);
    __p = 0;
    v20 = 0;
    v21 = 0;
    SafeBrowsing::Service::initializeDatabaseManager((uint64_t)this, &block, (__int128 **)&__p, 0x200000001uLL);
    p_p = &__p;
    std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](&p_p);
    v9 = *((_QWORD *)this + 1);
    v17[0] = v5;
    v17[1] = 3321888768;
    v17[2] = ___ZN12SafeBrowsing7Service10initializeEv_block_invoke_20;
    v17[3] = &__block_descriptor_40_ea8_32c48_ZTSKZN12SafeBrowsing7Service10initializeEvE3__1_e8_v12__0i8l;
    v17[4] = this;
    shouldConsultWithTencent = (Backend::Google::SSBUtilities *)notify_register_dispatch("com.apple.Safari.SafeBrowsing.TencentRemoteConfigurationDidChange", (int *)this + 94, v9, v17);
    if (SHIBYTE(block.__r_.__value_.__r.__words[2]) < 0)
      operator delete(block.__r_.__value_.__l.__data_);
  }
  if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
  {
    if (v25)
    {
      std::string::basic_string[abi:sn180100]<0>((char **)&__p, "Apple");
      Platform::stringByAppendingPathComponent((uint64_t *)v23, (uint64_t)&__p, &block);
      if (SHIBYTE(v21) < 0)
        operator delete(__p);
      __p = 0;
      v20 = 0;
      v21 = 0;
      SafeBrowsing::Service::initializeDatabaseManager((uint64_t)this, &block, (__int128 **)&__p, 0x300000001uLL);
      p_p = &__p;
      std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](&p_p);
      v10 = *((_QWORD *)this + 1);
      v16[0] = v5;
      v16[1] = 3321888768;
      v16[2] = ___ZN12SafeBrowsing7Service10initializeEv_block_invoke_24;
      v16[3] = &__block_descriptor_40_ea8_32c48_ZTSKZN12SafeBrowsing7Service10initializeEvE3__2_e8_v12__0i8l;
      v16[4] = this;
      notify_register_dispatch("com.apple.Safari.SafeBrowsing.AppleRemoteConfigurationDidChange", (int *)this + 120, v10, v16);
      if (SHIBYTE(block.__r_.__value_.__r.__words[2]) < 0)
        operator delete(block.__r_.__value_.__l.__data_);
      goto LABEL_22;
    }
LABEL_28:
    __break(1u);
  }
LABEL_22:
  v11 = *((_QWORD *)this + 1);
  block.__r_.__value_.__r.__words[0] = v5;
  block.__r_.__value_.__l.__size_ = 3321888768;
  block.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN12SafeBrowsing7Service41registerDatabaseLoadingDispatchGroupBlockEv_block_invoke;
  v28[0] = (char *)&__block_descriptor_40_ea8_32c79_ZTSKZN12SafeBrowsing7Service41registerDatabaseLoadingDispatchGroupBlockEvE3__0_e5_v8__0l;
  v28[1] = (char *)this;
  dispatch_async(v11, &block);
  v12 = *((_QWORD *)this + 1);
  v15[0] = v5;
  v15[1] = 3321888768;
  v15[2] = ___ZN12SafeBrowsing7Service10initializeEv_block_invoke_27;
  v15[3] = &__block_descriptor_40_ea8_32c48_ZTSKZN12SafeBrowsing7Service10initializeEvE3__3_e8_v12__0i8l;
  v15[4] = this;
  notify_register_dispatch("com.apple.Safari.SafeBrowsing.RegionCodeDidChange", (int *)this + 122, v12, v15);
  v13 = objc_alloc_init(SSBDatabaseUpdateSupport);
  v14 = (void *)*((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = v13;

  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if (v25)
  {
    if (v24 < 0)
      operator delete(v23[0]);
  }
}

void sub_1DBCFD214(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  uint64_t v41;

  if (*(char *)(v41 - 121) < 0)
    operator delete(*(void **)(v41 - 144));
  if (a41 < 0)
    operator delete(__p);
  if (*(_BYTE *)(v41 - 160))
  {
    if (*(char *)(v41 - 161) < 0)
      operator delete(*(void **)(v41 - 184));
  }
  _Unwind_Resume(exception_object);
}

uint64_t SafeBrowsing::Service::isEnabled(SafeBrowsing::Service *this)
{
  void *v1;
  uint64_t v2;
  void *v3;
  void *v4;

  objc_msgSend(MEMORY[0x1E0C99EA0], "standardUserDefaults");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  if (+[SSBManagedConfigurationManager isSafeBrowsingEnabledStateLockedDownByRestrictions](SSBManagedConfigurationManager, "isSafeBrowsingEnabledStateLockedDownByRestrictions"))
  {
    v2 = +[SSBManagedConfigurationManager restrictedBoolValueForSafeBrowsing](SSBManagedConfigurationManager, "restrictedBoolValueForSafeBrowsing");
  }
  else
  {
    objc_msgSend(v1, "objectForKey:", CFSTR("SafeBrowsingEnabled"));
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = v3;
    if (v3)
      v2 = objc_msgSend(v3, "BOOLValue");
    else
      v2 = 1;

  }
  return v2;
}

void sub_1DBCFD3D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing7ServiceC2Ev_block_invoke(uint64_t a1)
{
  SafeBrowsing::Service::checkInOrRegisterUpdateActivity(*(__int128 ***)(a1 + 32), "com.apple.Safari.SafeBrowsing.BrowsingDatabases.Update");
}

void SafeBrowsing::Service::checkInOrRegisterUpdateActivity(__int128 **this, const char *a2)
{
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep PollingTimeAndDatabaseConfiguration;
  void *v5;
  uint64_t v6;
  _QWORD handler[7];

  if (SafeBrowsing::Service::isEnabled((SafeBrowsing::Service *)this))
  {
    PollingTimeAndDatabaseConfiguration = SafeBrowsing::Service::nextPollingTimeAndDatabaseConfiguration(this);
    v5 = (void *)*MEMORY[0x1E0C80748];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3321888768;
    handler[2] = ___ZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKc_block_invoke;
    handler[3] = &__block_descriptor_56_ea8_32c71_ZTSKZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKcE3__0_e33_v16__0__NSObject_OS_xpc_object__8l;
    handler[4] = this;
    handler[5] = PollingTimeAndDatabaseConfiguration;
    handler[6] = v6;
    xpc_activity_register(a2, v5, handler);
  }
}

void SafeBrowsing::Service::DatabaseManager::~DatabaseManager(Platform::Transaction **this)
{
  void **v2;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(this + 10));
  v2 = (void **)(this + 7);
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&v2);
  v2 = (void **)(this + 4);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v2);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(this + 2));
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100](this + 1, 0);
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100](this, 0);
}

void *SafeBrowsing::Service::shared(SafeBrowsing::Service *this)
{
  {
    Platform::OnceConstructedNeverDestroyed<SafeBrowsing::Service>::OnceConstructedNeverDestroyed(&SafeBrowsing::Service::shared(void)::service);
  }
  return &unk_1ED04E960;
}

void SafeBrowsing::Service::databaseBaseDirectory(uint64_t a1@<X8>)
{
  const std::error_category *v3;
  const std::string::value_type *UserCacheDirectory;
  const std::error_category *v5;
  void *v6;
  char v7;
  NSObject *v8;
  uint64_t v9;
  std::error_code v10;
  void *__p[2];
  char v12;
  std::string v13;
  _QWORD v14[2];
  std::string v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  memset(v14, 0, 15);
  memset(&v13, 0, sizeof(v13));
  UserCacheDirectory = Platform::getUserCacheDirectory(&v13);
  if ((_DWORD)UserCacheDirectory)
  {
    v5 = v3;
    v6 = 0;
    v7 = 0;
  }
  else
  {
    std::string::basic_string[abi:sn180100]<0>((char **)__p, "com.apple.Safari.SafeBrowsing");
    Platform::stringByAppendingPathComponent((uint64_t *)&v13, (uint64_t)__p, &v15);
    v14[0] = v15.__r_.__value_.__l.__size_;
    v6 = (void *)v15.__r_.__value_.__r.__words[0];
    *(_QWORD *)((char *)v14 + 7) = *(std::string::size_type *)((char *)&v15.__r_.__value_.__r.__words[1] + 7);
    v7 = HIBYTE(v15.__r_.__value_.__r.__words[2]);
    *((_BYTE *)&v15.__r_.__value_.__s + 23) = 0;
    v15.__r_.__value_.__s.__data_[0] = 0;
    if (v12 < 0)
      operator delete(__p[0]);
    v5 = std::system_category();
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v13.__r_.__value_.__l.__data_);
  *(_QWORD *)&v10.__val_ = UserCacheDirectory;
  v10.__cat_ = v5;
  if ((_DWORD)UserCacheDirectory)
  {
    v8 = (id)SSBOSLogService();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      std::error_code::message(&v13, &v10);
      SafeBrowsing::Service::databaseBaseDirectory();
    }

    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 24) = 0;
    if (v7 < 0)
      operator delete(v6);
  }
  else
  {
    v9 = v14[0];
    *(_QWORD *)a1 = v6;
    *(_QWORD *)(a1 + 8) = v9;
    *(_QWORD *)(a1 + 15) = *(_QWORD *)((char *)v14 + 7);
    *(_BYTE *)(a1 + 23) = v7;
    *(_BYTE *)(a1 + 24) = 1;
  }
}

void sub_1DBCFD6B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;
  void *v23;
  char v24;

  if (v24 < 0)
    operator delete(v22);
  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::initializeDatabaseManager(uint64_t a1, std::string *a2, __int128 **a3, unint64_t a4)
{
  std::string::size_type v7;
  NSObject *v8;
  __int128 *v9;
  __int128 *v10;
  __int128 v11;
  std::string *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  Platform::Transaction *v19;
  NSObject *v20;
  _QWORD *v21;
  std::__shared_weak_count *size;
  unint64_t *v23;
  unint64_t v24;
  Platform::Transaction *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  Platform::Transaction *v29;
  _QWORD v30[5];
  _QWORD block[5];
  _QWORD v32[5];
  std::string v33;
  unint64_t v34;
  std::string v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v34 = a4;
  v33.__r_.__value_.__r.__words[0] = Platform::createDirectoryWithIntermediateDirectories(a2);
  v33.__r_.__value_.__l.__size_ = v7;
  if (LODWORD(v33.__r_.__value_.__l.__data_))
  {
    v8 = (id)SSBOSLogService();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      std::error_code::message(&v35, (const std::error_code *)&v33);
      SafeBrowsing::Service::initializeDatabaseManager();
    }

  }
  else
  {
    v10 = *a3;
    v9 = a3[1];
    if (v10 != v9)
    {
      while (1)
      {
        if (*((char *)v10 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&v35, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
        }
        else
        {
          v11 = *v10;
          v35.__r_.__value_.__r.__words[2] = *((_QWORD *)v10 + 2);
          *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v11;
        }
        Platform::stringByAppendingPathComponent((uint64_t *)a2, (uint64_t)&v35, &v33);
        v12 = (v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v33
            : (std::string *)v33.__r_.__value_.__r.__words[0];
        if (unlink((const char *)v12) == -1 && *__error() == 2)
          break;
        if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v33.__r_.__value_.__l.__data_);
        if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v35.__r_.__value_.__l.__data_);
        v10 = (__int128 *)((char *)v10 + 24);
        if (v10 == v9)
          goto LABEL_19;
      }
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v33.__r_.__value_.__l.__data_);
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v35.__r_.__value_.__l.__data_);
    }
LABEL_19:
    if ((_DWORD)v34 == 1)
    {
      switch(HIDWORD(v34))
      {
        case 3:
          SafeBrowsing::Service::threatListDescriptorsFromConfiguration(v34, (void **)&v33.__r_.__value_.__l.__data_);
          std::allocate_shared[abi:sn180100]<Backend::Google::DatabaseUpdater,std::allocator<Backend::Google::DatabaseUpdater>,SafeBrowsing::Service &,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::Configuration &,std::string const,std::vector<Backend::Google::ThreatListDescriptor>,Backend::Google::DatabaseConfiguration &,void>(a1, (uint64_t *)(a1 + 8), (Backend::Google::Configuration *)(a1 + 24), (uint64_t)a2, (uint64_t)&v33, &v34, &v35);
          std::shared_ptr<ByteProvider>::operator=[abi:sn180100](a1 + 400, (__int128 *)&v35);
          size = (std::__shared_weak_count *)v35.__r_.__value_.__l.__size_;
          if (v35.__r_.__value_.__l.__size_)
          {
            v23 = (unint64_t *)(v35.__r_.__value_.__l.__size_ + 8);
            do
              v24 = __ldaxr(v23);
            while (__stlxr(v24 - 1, v23));
            if (!v24)
            {
              ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
              std::__shared_weak_count::__release_weak(size);
            }
          }
          v25 = (Platform::Transaction *)operator new(0x18uLL);
          std::string::basic_string[abi:sn180100]<0>(&v35.__r_.__value_.__l.__data_, "Loading Apple Databases");
          Platform::Transaction::Transaction(v25, &v35);
          if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v35.__r_.__value_.__l.__data_);
          std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)(a1 + 384), v25);
          v20 = *(NSObject **)(a1 + 8);
          v30[0] = MEMORY[0x1E0C809B0];
          v30[1] = 3321888768;
          v30[2] = ___ZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationE_block_invoke_9;
          v30[3] = &__block_descriptor_40_ea8_32c197_ZTSKZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationEE3__2_e5_v8__0l;
          v30[4] = a1;
          v21 = v30;
          break;
        case 2:
          SafeBrowsing::Service::threatListDescriptorsFromConfiguration(v34, (void **)&v33.__r_.__value_.__l.__data_);
          std::allocate_shared[abi:sn180100]<Backend::Google::DatabaseUpdater,std::allocator<Backend::Google::DatabaseUpdater>,SafeBrowsing::Service &,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::Configuration &,std::string const,std::vector<Backend::Google::ThreatListDescriptor>,Backend::Google::DatabaseConfiguration &,void>(a1, (uint64_t *)(a1 + 8), (Backend::Google::Configuration *)(a1 + 24), (uint64_t)a2, (uint64_t)&v33, &v34, &v35);
          std::shared_ptr<ByteProvider>::operator=[abi:sn180100](a1 + 296, (__int128 *)&v35);
          v26 = (std::__shared_weak_count *)v35.__r_.__value_.__l.__size_;
          if (v35.__r_.__value_.__l.__size_)
          {
            v27 = (unint64_t *)(v35.__r_.__value_.__l.__size_ + 8);
            do
              v28 = __ldaxr(v27);
            while (__stlxr(v28 - 1, v27));
            if (!v28)
            {
              ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
              std::__shared_weak_count::__release_weak(v26);
            }
          }
          v29 = (Platform::Transaction *)operator new(0x18uLL);
          std::string::basic_string[abi:sn180100]<0>(&v35.__r_.__value_.__l.__data_, "Loading Tencent Databases");
          Platform::Transaction::Transaction(v29, &v35);
          if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v35.__r_.__value_.__l.__data_);
          std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)(a1 + 280), v29);
          v20 = *(NSObject **)(a1 + 8);
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3321888768;
          block[2] = ___ZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationE_block_invoke_6;
          block[3] = &__block_descriptor_40_ea8_32c197_ZTSKZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationEE3__1_e5_v8__0l;
          block[4] = a1;
          v21 = block;
          break;
        case 1:
          SafeBrowsing::Service::threatListDescriptorsFromConfiguration(v34, (void **)&v33.__r_.__value_.__l.__data_);
          std::allocate_shared[abi:sn180100]<Backend::Google::DeviceIdentificationTokenFetcher,std::allocator<Backend::Google::DeviceIdentificationTokenFetcher>,Backend::Google::Configuration &,Backend::Google::SafeBrowsingProvider &,void>(a1 + 24, (unsigned int *)&v34 + 1, &v35);
          std::shared_ptr<ByteProvider>::operator=[abi:sn180100](a1 + 256, (__int128 *)&v35);
          v13 = (std::__shared_weak_count *)v35.__r_.__value_.__l.__size_;
          if (v35.__r_.__value_.__l.__size_)
          {
            v14 = (unint64_t *)(v35.__r_.__value_.__l.__size_ + 8);
            do
              v15 = __ldaxr(v14);
            while (__stlxr(v15 - 1, v14));
            if (!v15)
            {
              ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
              std::__shared_weak_count::__release_weak(v13);
            }
          }
          std::allocate_shared[abi:sn180100]<Backend::Google::DatabaseUpdater,std::allocator<Backend::Google::DatabaseUpdater>,SafeBrowsing::Service &,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::Configuration &,std::string const,std::vector<Backend::Google::ThreatListDescriptor>,Backend::Google::DatabaseConfiguration &,void>(a1, (uint64_t *)(a1 + 8), (Backend::Google::Configuration *)(a1 + 24), (uint64_t)a2, (uint64_t)&v33, &v34, &v35);
          std::shared_ptr<ByteProvider>::operator=[abi:sn180100](a1 + 192, (__int128 *)&v35);
          v16 = (std::__shared_weak_count *)v35.__r_.__value_.__l.__size_;
          if (v35.__r_.__value_.__l.__size_)
          {
            v17 = (unint64_t *)(v35.__r_.__value_.__l.__size_ + 8);
            do
              v18 = __ldaxr(v17);
            while (__stlxr(v18 - 1, v17));
            if (!v18)
            {
              ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
              std::__shared_weak_count::__release_weak(v16);
            }
          }
          v19 = (Platform::Transaction *)operator new(0x18uLL);
          std::string::basic_string[abi:sn180100]<0>(&v35.__r_.__value_.__l.__data_, "Loading Google Databases");
          Platform::Transaction::Transaction(v19, &v35);
          if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v35.__r_.__value_.__l.__data_);
          std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)(a1 + 176), v19);
          v20 = *(NSObject **)(a1 + 8);
          v32[0] = MEMORY[0x1E0C809B0];
          v32[1] = 3321888768;
          v32[2] = ___ZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationE_block_invoke;
          v32[3] = &__block_descriptor_40_ea8_32c197_ZTSKZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationEE3__0_e5_v8__0l;
          v32[4] = a1;
          v21 = v32;
          break;
        default:
          return;
      }
      dispatch_async(v20, v21);
      if (v33.__r_.__value_.__r.__words[0])
      {
        v33.__r_.__value_.__l.__size_ = v33.__r_.__value_.__r.__words[0];
        operator delete(v33.__r_.__value_.__l.__data_);
      }
    }
  }
}

void sub_1DBCFDC04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  void *v30;
  uint64_t v31;

  if (*(char *)(v31 - 89) < 0)
    operator delete(*(void **)(v31 - 112));
  operator delete(v30);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::threatListDescriptorsFromConfiguration(unint64_t a1@<X1>, void **a2@<X8>)
{
  int v2;
  unint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  unint64_t v8;
  _OWORD *v9;
  _OWORD *v10;
  void *v11;
  char v12;
  unint64_t v13;
  __int128 *v14;
  __int128 v15;
  void *v16;
  char v17;
  unint64_t v18;
  _OWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  _OWORD *v31;
  _OWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  uint64_t v58;
  char *v59;
  void *v60;
  void *v61;

  v2 = a1;
  v4 = HIDWORD(a1);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  +[RemoteConfigurationController sharedController](RemoteConfigurationController, "sharedController");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v5;
  if (v2 != 1 || (_DWORD)v4 != 1)
  {
    if (v2 == 1 && (_DWORD)v4 == 2)
    {
      v61 = v5;
      objc_msgSend(v5, "tencentProviderConfiguration");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      v12 = objc_msgSend(v11, "socialEngineeringThreatTypeOff");

      v6 = v61;
      if ((v12 & 1) != 0)
      {
LABEL_79:

        return;
      }
      v13 = (unint64_t)a2[2];
      v14 = (__int128 *)a2[1];
      if ((unint64_t)v14 < v13)
      {
        if (!v14)
          goto LABEL_84;
        v15 = xmmword_1DBD17BF0;
        goto LABEL_19;
      }
      v43 = ((char *)v14 - (_BYTE *)*a2) >> 4;
      if ((unint64_t)(v43 + 1) >> 60)
        abort();
      v44 = v13 - (_QWORD)*a2;
      v45 = v44 >> 3;
      if (v44 >> 3 <= (unint64_t)(v43 + 1))
        v45 = v43 + 1;
      if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF0)
        v46 = 0xFFFFFFFFFFFFFFFLL;
      else
        v46 = v45;
      if (!v46)
        goto LABEL_84;
      v47 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::Database::HashSizeBucket>>((uint64_t)(a2 + 2), v46);
      if (!v47)
        goto LABEL_84;
      v49 = &v47[16 * v48];
      v50 = &v47[16 * v43];
      *(_OWORD *)v50 = xmmword_1DBD17BF0;
      v19 = v50 + 16;
      v52 = (char *)*a2;
      v51 = (char *)a2[1];
      if (v51 != *a2)
      {
        do
        {
          *((_OWORD *)v50 - 1) = *((_OWORD *)v51 - 1);
          v50 -= 16;
          v51 -= 16;
        }
        while (v51 != v52);
LABEL_74:
        v51 = (char *)*a2;
      }
    }
    else
    {
      if (v2 != 1)
        goto LABEL_79;
      if ((_DWORD)v4 != 3)
        goto LABEL_79;
      v61 = v5;
      objc_msgSend(v5, "appleProviderConfiguration");
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      v17 = objc_msgSend(v16, "socialEngineeringThreatTypeOff");

      v6 = v61;
      if ((v17 & 1) != 0)
        goto LABEL_79;
      v18 = (unint64_t)a2[2];
      v14 = (__int128 *)a2[1];
      if ((unint64_t)v14 < v18)
      {
        if (!v14)
          goto LABEL_84;
        v15 = xmmword_1DBD17BE0;
LABEL_19:
        *v14 = v15;
        v19 = v14 + 1;
LABEL_78:
        a2[1] = v19;
        goto LABEL_79;
      }
      v53 = ((char *)v14 - (_BYTE *)*a2) >> 4;
      if ((unint64_t)(v53 + 1) >> 60)
        abort();
      v54 = v18 - (_QWORD)*a2;
      v55 = v54 >> 3;
      if (v54 >> 3 <= (unint64_t)(v53 + 1))
        v55 = v53 + 1;
      if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF0)
        v56 = 0xFFFFFFFFFFFFFFFLL;
      else
        v56 = v55;
      if (!v56)
        goto LABEL_84;
      v57 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::Database::HashSizeBucket>>((uint64_t)(a2 + 2), v56);
      if (!v57)
        goto LABEL_84;
      v49 = &v57[16 * v58];
      v50 = &v57[16 * v53];
      *(_OWORD *)v50 = xmmword_1DBD17BE0;
      v19 = v50 + 16;
      v59 = (char *)*a2;
      v51 = (char *)a2[1];
      if (v51 != *a2)
      {
        do
        {
          *((_OWORD *)v50 - 1) = *((_OWORD *)v51 - 1);
          v50 -= 16;
          v51 -= 16;
        }
        while (v51 != v59);
        goto LABEL_74;
      }
    }
    *a2 = v50;
    a2[1] = v19;
    a2[2] = v49;
    if (v51)
      operator delete(v51);
    v6 = v61;
    goto LABEL_78;
  }
  v60 = v5;
  objc_msgSend(v5, "googleProviderConfiguration");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v7, "malwareThreatTypeOff") & 1) == 0)
  {
    v8 = (unint64_t)a2[2];
    v9 = a2[1];
    if ((unint64_t)v9 >= v8)
    {
      v20 = ((char *)v9 - (_BYTE *)*a2) >> 4;
      if ((unint64_t)(v20 + 1) >> 60)
        abort();
      v21 = v8 - (_QWORD)*a2;
      v22 = v21 >> 3;
      if (v21 >> 3 <= (unint64_t)(v20 + 1))
        v22 = v20 + 1;
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0)
        v23 = 0xFFFFFFFFFFFFFFFLL;
      else
        v23 = v22;
      if (!v23)
        goto LABEL_84;
      v24 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::Database::HashSizeBucket>>((uint64_t)(a2 + 2), v23);
      if (!v24)
        goto LABEL_84;
      v26 = &v24[16 * v25];
      v27 = &v24[16 * v20];
      *(_OWORD *)v27 = xmmword_1DBD17C00;
      v10 = v27 + 16;
      v29 = (char *)*a2;
      v28 = (char *)a2[1];
      if (v28 != *a2)
      {
        do
        {
          *((_OWORD *)v27 - 1) = *((_OWORD *)v28 - 1);
          v27 -= 16;
          v28 -= 16;
        }
        while (v28 != v29);
        v28 = (char *)*a2;
      }
      *a2 = v27;
      a2[1] = v10;
      a2[2] = v26;
      if (v28)
        operator delete(v28);
    }
    else
    {
      if (!v9)
        goto LABEL_84;
      *v9 = xmmword_1DBD17C00;
      v10 = v9 + 1;
    }
    a2[1] = v10;
  }
  if ((objc_msgSend(v7, "socialEngineeringThreatTypeOff") & 1) != 0)
  {
LABEL_52:

    v6 = v60;
    goto LABEL_79;
  }
  v30 = (unint64_t)a2[2];
  v31 = a2[1];
  if ((unint64_t)v31 >= v30)
  {
    v33 = ((char *)v31 - (_BYTE *)*a2) >> 4;
    if ((unint64_t)(v33 + 1) >> 60)
      abort();
    v34 = v30 - (_QWORD)*a2;
    v35 = v34 >> 3;
    if (v34 >> 3 <= (unint64_t)(v33 + 1))
      v35 = v33 + 1;
    if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0)
      v36 = 0xFFFFFFFFFFFFFFFLL;
    else
      v36 = v35;
    if (v36)
    {
      v37 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::Google::Database::HashSizeBucket>>((uint64_t)(a2 + 2), v36);
      if (v37)
      {
        v39 = &v37[16 * v38];
        v40 = &v37[16 * v33];
        *(_OWORD *)v40 = xmmword_1DBD17C10;
        v32 = v40 + 16;
        v42 = (char *)*a2;
        v41 = (char *)a2[1];
        if (v41 != *a2)
        {
          do
          {
            *((_OWORD *)v40 - 1) = *((_OWORD *)v41 - 1);
            v40 -= 16;
            v41 -= 16;
          }
          while (v41 != v42);
          v41 = (char *)*a2;
        }
        *a2 = v40;
        a2[1] = v32;
        a2[2] = v39;
        if (v41)
          operator delete(v41);
        goto LABEL_51;
      }
    }
  }
  else if (v31)
  {
    *v31 = xmmword_1DBD17C10;
    v32 = v31 + 1;
LABEL_51:
    a2[1] = v32;
    goto LABEL_52;
  }
LABEL_84:
  __break(1u);
}

void sub_1DBCFE0D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v10;
  void *v12;

  v12 = *(void **)v10;
  if (*(_QWORD *)v10)
  {
    *(_QWORD *)(v10 + 8) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationE_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  dispatch_group_enter(*(dispatch_group_t *)(v1 + 16));
  Backend::Google::DatabaseUpdater::initialize(*(Backend::Google::DatabaseUpdater **)(v1 + 192));
}

uint64_t __copy_helper_block_ea8_32c197_ZTSKZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationEE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void ___ZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationE_block_invoke_6(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  dispatch_group_enter(*(dispatch_group_t *)(v1 + 16));
  Backend::Google::DatabaseUpdater::initialize(*(Backend::Google::DatabaseUpdater **)(v1 + 296));
}

uint64_t __copy_helper_block_ea8_32c197_ZTSKZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationEE3__1(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void ___ZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationE_block_invoke_9(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  dispatch_group_enter(*(dispatch_group_t *)(v1 + 16));
  Backend::Google::DatabaseUpdater::initialize(*(Backend::Google::DatabaseUpdater **)(v1 + 400));
}

uint64_t __copy_helper_block_ea8_32c197_ZTSKZN12SafeBrowsing7Service25initializeDatabaseManagerERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_6vectorIS7_NS5_IS7_EEEEN7Backend6Google21DatabaseConfigurationEE3__2(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void ___ZN12SafeBrowsing7Service10initializeEv_block_invoke(uint64_t a1)
{
  SafeBrowsing::Service::remoteConfigurationDidChange(*(uint64_t **)(a1 + 32), 1);
}

uint64_t __copy_helper_block_ea8_32c48_ZTSKZN12SafeBrowsing7Service10initializeEvE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void ___ZN12SafeBrowsing7Service10initializeEv_block_invoke_20(uint64_t a1)
{
  SafeBrowsing::Service::remoteConfigurationDidChange(*(uint64_t **)(a1 + 32), 2);
}

uint64_t __copy_helper_block_ea8_32c48_ZTSKZN12SafeBrowsing7Service10initializeEvE3__1(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void ___ZN12SafeBrowsing7Service10initializeEv_block_invoke_24(uint64_t a1)
{
  SafeBrowsing::Service::remoteConfigurationDidChange(*(uint64_t **)(a1 + 32), 3);
}

uint64_t __copy_helper_block_ea8_32c48_ZTSKZN12SafeBrowsing7Service10initializeEvE3__2(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void SafeBrowsing::Service::registerDatabaseLoadingDispatchGroupBlock(SafeBrowsing::Service *this)
{
  NSObject *v1;
  _QWORD block[5];

  v1 = *((_QWORD *)this + 1);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZN12SafeBrowsing7Service41registerDatabaseLoadingDispatchGroupBlockEv_block_invoke;
  block[3] = &__block_descriptor_40_ea8_32c79_ZTSKZN12SafeBrowsing7Service41registerDatabaseLoadingDispatchGroupBlockEvE3__0_e5_v8__0l;
  block[4] = this;
  dispatch_async(v1, block);
}

void ___ZN12SafeBrowsing7Service10initializeEv_block_invoke_27(uint64_t a1)
{
  SafeBrowsing::Service::regionCodeDidChange(*(SafeBrowsing::Service **)(a1 + 32));
}

uint64_t __copy_helper_block_ea8_32c48_ZTSKZN12SafeBrowsing7Service10initializeEvE3__3(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void SafeBrowsing::Service::regionCodeDidChange(SafeBrowsing::Service *this)
{
  NSObject *v2;
  std::string v3;
  void *v4[2];
  char v5;
  char v6;
  void *__p;
  uint64_t v8;
  void (*v9)(uint64_t);
  void *v10;
  SafeBrowsing::Service *v11;
  void **p_p;

  if ((Backend::Google::SSBUtilities::shouldConsultWithTencent(this) & 1) != 0)
  {
    SafeBrowsing::Service::databaseBaseDirectory((uint64_t)v4);
    if (v6)
    {
      std::string::basic_string[abi:sn180100]<0>((char **)&__p, "Tencent");
      Platform::stringByAppendingPathComponent((uint64_t *)v4, (uint64_t)&__p, &v3);
      if (SHIBYTE(v9) < 0)
        operator delete(__p);
      __p = 0;
      v8 = 0;
      v9 = 0;
      SafeBrowsing::Service::initializeDatabaseManager((uint64_t)this, &v3, (__int128 **)&__p, 0x200000001uLL);
      p_p = &__p;
      std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](&p_p);
      v2 = *((_QWORD *)this + 1);
      __p = (void *)MEMORY[0x1E0C809B0];
      v8 = 3321888768;
      v9 = ___ZN12SafeBrowsing7Service41registerDatabaseLoadingDispatchGroupBlockEv_block_invoke;
      v10 = &__block_descriptor_40_ea8_32c79_ZTSKZN12SafeBrowsing7Service41registerDatabaseLoadingDispatchGroupBlockEvE3__0_e5_v8__0l;
      v11 = this;
      dispatch_async(v2, &__p);
      notify_post("com.apple.Safari.SafeBrowsing.DidFinishTencentDatabaseUpdate");
      if (SHIBYTE(v3.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v3.__r_.__value_.__l.__data_);
      if (v6)
      {
        if (v5 < 0)
          operator delete(v4[0]);
      }
    }
  }
  else
  {
    notify_post("com.apple.Safari.SafeBrowsing.DidFinishTencentDatabaseUpdate");
  }
}

void sub_1DBCFE398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a15 < 0)
    operator delete(__p);
  if (a22)
  {
    if (a21 < 0)
      operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void SafeBrowsing::Service::remoteConfigurationDidChange(uint64_t *a1, int a2)
{
  char v2;
  std::string *v5;
  uint64_t v6;
  int v7;
  void *v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  void *v15;
  uint64_t *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  std::string *v20;
  uint64_t v21;
  int v22;
  void *v23;
  uint64_t *v24;
  _QWORD *v25;
  uint64_t v26;
  std::string::__raw *v27;
  uint64_t v28;
  uint64_t *v29;
  std::string __p;
  unsigned __int8 v31;
  void *v32[2];
  char v33;
  char v34;
  _QWORD v35[2];
  _QWORD v36[2];
  _QWORD v37[2];
  _BYTE v38[24];
  std::string *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  SafeBrowsing::Service::databaseBaseDirectory((uint64_t)v32);
  if (v34)
  {
    if (a2 == 3)
      goto LABEL_44;
    if (a2 == 2)
    {
LABEL_24:
      if ((Backend::Google::SSBUtilities::shouldConsultWithTencent((Backend::Google::SSBUtilities *)v5) & 1) == 0)
        goto LABEL_64;
      v29 = a1;
      v5 = std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100](&__p, (uint64_t)v32);
      v13 = a1[37];
      if (!v13)
        goto LABEL_41;
      if (!*(_DWORD *)(v13 + 240))
      {
        SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1::operator()((uint64_t)&v29);
LABEL_41:
        if (v31 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
LABEL_44:
        if ((Backend::Google::SSBUtilities::shouldConsultWithApple((Backend::Google::SSBUtilities *)v5) & 1) == 0)
          goto LABEL_64;
        v29 = a1;
        v20 = std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100](&__p, (uint64_t)v32);
        v21 = a1[50];
        if (v21)
        {
          if (*(_DWORD *)(v21 + 240))
          {
            v22 = v31;
            if (v31)
            {
              v35[0] = __p.__r_.__value_.__l.__size_;
              v23 = (void *)__p.__r_.__value_.__r.__words[0];
              *(_QWORD *)((char *)v35 + 7) = *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7);
              v2 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
              v20->__r_.__value_.__l.__size_ = 0;
              v20->__r_.__value_.__r.__words[2] = 0;
              v20->__r_.__value_.__r.__words[0] = 0;
            }
            else
            {
              v23 = 0;
            }
            v24 = v29;
            v39 = 0;
            v25 = operator new(0x30uLL);
            *v25 = &off_1EA3E9F90;
            v25[1] = v24;
            *((_BYTE *)v25 + 16) = 0;
            *((_BYTE *)v25 + 40) = 0;
            if (v22)
            {
              v26 = v35[0];
              v25[2] = v23;
              v25[3] = v26;
              *(_QWORD *)((char *)v25 + 31) = *(_QWORD *)((char *)v35 + 7);
              *((_BYTE *)v25 + 39) = v2;
              v35[0] = 0;
              *(_QWORD *)((char *)v35 + 7) = 0;
              *((_BYTE *)v25 + 40) = 1;
              v23 = 0;
              v2 = 0;
            }
            v39 = (std::string *)v25;
            std::vector<std::function<void ()(void)>>::push_back[abi:sn180100](a1 + 55, (uint64_t)v38);
            v27 = (std::string::__raw *)v39;
            if (v39 == (std::string *)v38)
            {
              v28 = 4;
              v27 = (std::string::__raw *)v38;
            }
            else
            {
              if (!v39)
              {
LABEL_58:
                if (v22 && v2 < 0)
                  operator delete(v23);
                goto LABEL_61;
              }
              v28 = 5;
            }
            (*(void (**)(void))(v27->__words[0] + 8 * v28))();
            goto LABEL_58;
          }
          SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2::operator()((uint64_t)&v29);
        }
LABEL_61:
        if (v31 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
LABEL_64:
        if (!v34)
          return;
        goto LABEL_65;
      }
      v14 = v31;
      if (v31)
      {
        v36[0] = __p.__r_.__value_.__l.__size_;
        v15 = (void *)__p.__r_.__value_.__r.__words[0];
        *(_QWORD *)((char *)v36 + 7) = *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7);
        v2 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        v5->__r_.__value_.__l.__size_ = 0;
        v5->__r_.__value_.__r.__words[2] = 0;
        v5->__r_.__value_.__r.__words[0] = 0;
      }
      else
      {
        v15 = 0;
      }
      v16 = v29;
      v39 = 0;
      v17 = operator new(0x30uLL);
      *v17 = &off_1EA3E9F48;
      v17[1] = v16;
      *((_BYTE *)v17 + 16) = 0;
      *((_BYTE *)v17 + 40) = 0;
      if (v14)
      {
        v18 = v36[0];
        v17[2] = v15;
        v17[3] = v18;
        *(_QWORD *)((char *)v17 + 31) = *(_QWORD *)((char *)v36 + 7);
        *((_BYTE *)v17 + 39) = v2;
        v36[0] = 0;
        *(_QWORD *)((char *)v36 + 7) = 0;
        *((_BYTE *)v17 + 40) = 1;
        v15 = 0;
        v2 = 0;
      }
      v39 = (std::string *)v17;
      std::vector<std::function<void ()(void)>>::push_back[abi:sn180100](a1 + 42, (uint64_t)v38);
      v5 = v39;
      if (v39 == (std::string *)v38)
      {
        v19 = 4;
        v5 = (std::string *)v38;
      }
      else
      {
        if (!v39)
        {
LABEL_38:
          if (v14 && v2 < 0)
            operator delete(v15);
          goto LABEL_41;
        }
        v19 = 5;
      }
      v5 = (std::string *)(*(uint64_t (**)(void))(v5->__r_.__value_.__r.__words[0] + 8 * v19))();
      goto LABEL_38;
    }
    if (a2 != 1)
    {
LABEL_65:
      if (v33 < 0)
        operator delete(v32[0]);
      return;
    }
    v29 = a1;
    v5 = std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100](&__p, (uint64_t)v32);
    v6 = a1[24];
    if (v6)
    {
      if (*(_DWORD *)(v6 + 240))
      {
        v7 = v31;
        if (v31)
        {
          v37[0] = __p.__r_.__value_.__l.__size_;
          v8 = (void *)__p.__r_.__value_.__r.__words[0];
          *(_QWORD *)((char *)v37 + 7) = *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7);
          v2 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          v5->__r_.__value_.__l.__size_ = 0;
          v5->__r_.__value_.__r.__words[2] = 0;
          v5->__r_.__value_.__r.__words[0] = 0;
        }
        else
        {
          v8 = 0;
        }
        v9 = v29;
        v39 = 0;
        v10 = operator new(0x30uLL);
        *v10 = &off_1EA3E9F00;
        v10[1] = v9;
        *((_BYTE *)v10 + 16) = 0;
        *((_BYTE *)v10 + 40) = 0;
        if (v7)
        {
          v11 = v37[0];
          v10[2] = v8;
          v10[3] = v11;
          *(_QWORD *)((char *)v10 + 31) = *(_QWORD *)((char *)v37 + 7);
          *((_BYTE *)v10 + 39) = v2;
          v37[0] = 0;
          *(_QWORD *)((char *)v37 + 7) = 0;
          *((_BYTE *)v10 + 40) = 1;
          v2 = 0;
          v8 = 0;
        }
        v39 = (std::string *)v10;
        std::vector<std::function<void ()(void)>>::push_back[abi:sn180100](a1 + 29, (uint64_t)v38);
        v5 = v39;
        if (v39 == (std::string *)v38)
        {
          v12 = 4;
          v5 = (std::string *)v38;
        }
        else
        {
          if (!v39)
          {
LABEL_18:
            if (v7 && v2 < 0)
              operator delete(v8);
            goto LABEL_21;
          }
          v12 = 5;
        }
        v5 = (std::string *)(*(uint64_t (**)(void))(v5->__r_.__value_.__r.__words[0] + 8 * v12))();
        goto LABEL_18;
      }
      SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0::operator()((uint64_t)&v29);
    }
LABEL_21:
    if (v31 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_24;
  }
}

void sub_1DBCFE7F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  if (a16 && a15 < 0)
    operator delete(__p);
  if (a23)
  {
    if (a22 < 0)
      operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::function<void ()(void)>>::push_back[abi:sn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *a1) >> 5;
    if ((unint64_t)(v10 + 1) >> 59)
      abort();
    v11 = v5 - *a1;
    v12 = v11 >> 4;
    if (v11 >> 4 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v13 = 0x7FFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<std::array<unsigned char,32ul>>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[32 * v10];
    v18 = &v14[32 * v13];
    std::construct_at[abi:sn180100]<std::function<void ()(std::error_code)>,std::function<void ()(std::error_code)>,std::function<void ()(std::error_code)>*>((uint64_t)v16, a2);
    v17 = v16 + 32;
    std::vector<std::function<void ()(std::error_code)>>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = (uint64_t)std::__split_buffer<std::function<void ()(std::error_code)>>::~__split_buffer(&v15);
  }
  else
  {
    result = std::construct_at[abi:sn180100]<std::function<void ()(std::error_code)>,std::function<void ()(std::error_code)>,std::function<void ()(std::error_code)>*>(*(_QWORD *)(v4 - 8), a2);
    v9 = v7 + 32;
    a1[1] = v7 + 32;
  }
  a1[1] = v9;
  return result;
}

void sub_1DBCFE99C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::function<void ()(std::error_code)>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  void *__p[2];
  uint64_t v4;
  std::string v5;
  void **v6;

  if (*(_BYTE *)(a1 + 32))
  {
    v1 = *(_QWORD *)a1;
    v2 = (uint64_t *)(a1 + 8);
    std::string::basic_string[abi:sn180100]<0>((char **)__p, "Google");
    Platform::stringByAppendingPathComponent(v2, (uint64_t)__p, &v5);
    if (SHIBYTE(v4) < 0)
      operator delete(__p[0]);
    __p[0] = 0;
    __p[1] = 0;
    v4 = 0;
    SafeBrowsing::Service::initializeDatabaseManager(v1, &v5, (__int128 **)__p, 0x100000001uLL);
    v6 = __p;
    std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](&v6);
    notify_post("com.apple.Safari.SafeBrowsing.DidFinishGoogleDatabaseUpdate");
    if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v5.__r_.__value_.__l.__data_);
  }
  else
  {
    __break(1u);
  }
}

void sub_1DBCFEA5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  void *__p[2];
  uint64_t v4;
  std::string v5;
  void **v6;

  if (*(_BYTE *)(a1 + 32))
  {
    v1 = *(_QWORD *)a1;
    v2 = (uint64_t *)(a1 + 8);
    std::string::basic_string[abi:sn180100]<0>((char **)__p, "Tencent");
    Platform::stringByAppendingPathComponent(v2, (uint64_t)__p, &v5);
    if (SHIBYTE(v4) < 0)
      operator delete(__p[0]);
    __p[0] = 0;
    __p[1] = 0;
    v4 = 0;
    SafeBrowsing::Service::initializeDatabaseManager(v1, &v5, (__int128 **)__p, 0x200000001uLL);
    v6 = __p;
    std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](&v6);
    notify_post("com.apple.Safari.SafeBrowsing.DidFinishTencentDatabaseUpdate");
    if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v5.__r_.__value_.__l.__data_);
  }
  else
  {
    __break(1u);
  }
}

void sub_1DBCFEB50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  void *__p[2];
  uint64_t v4;
  std::string v5;
  void **v6;

  if (*(_BYTE *)(a1 + 32))
  {
    v1 = *(_QWORD *)a1;
    v2 = (uint64_t *)(a1 + 8);
    std::string::basic_string[abi:sn180100]<0>((char **)__p, "Apple");
    Platform::stringByAppendingPathComponent(v2, (uint64_t)__p, &v5);
    if (SHIBYTE(v4) < 0)
      operator delete(__p[0]);
    __p[0] = 0;
    __p[1] = 0;
    v4 = 0;
    SafeBrowsing::Service::initializeDatabaseManager(v1, &v5, (__int128 **)__p, 0x300000001uLL);
    v6 = __p;
    std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](&v6);
    notify_post("com.apple.Safari.SafeBrowsing.DidFinishAppleDatabaseUpdate");
    if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v5.__r_.__value_.__l.__data_);
  }
  else
  {
    __break(1u);
  }
}

void sub_1DBCFEC44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SafeBrowsing::Service::didLoadDatabases(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  int v6;
  NSObject *v7;
  Platform::Transaction **v8;
  _DWORD v9[2];
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v5 = *(_DWORD *)(a2 + 256);
  v6 = *(_DWORD *)(a2 + 260);
  v7 = SSBOSLogDatabase();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v9[0] = 67109376;
    v9[1] = v5;
    v10 = 1024;
    v11 = v6;
    _os_log_impl(&dword_1DBCBE000, v7, OS_LOG_TYPE_INFO, "Databases loaded for protection type %d and provider %d", (uint8_t *)v9, 0xEu);
  }
  if (v5 == 1)
  {
    switch(v6)
    {
      case 3:
        v8 = (Platform::Transaction **)(a1 + 384);
        std::vector<Backend::Google::DatabaseInfo>::__vdeallocate((void **)(a1 + 416));
        *(_OWORD *)(a1 + 416) = *(_OWORD *)a3;
        *(_QWORD *)(a1 + 432) = *(_QWORD *)(a3 + 16);
        goto LABEL_10;
      case 2:
        v8 = (Platform::Transaction **)(a1 + 280);
        std::vector<Backend::Google::DatabaseInfo>::__vdeallocate((void **)(a1 + 312));
        *(_OWORD *)(a1 + 312) = *(_OWORD *)a3;
        *(_QWORD *)(a1 + 328) = *(_QWORD *)(a3 + 16);
        goto LABEL_10;
      case 1:
        v8 = (Platform::Transaction **)(a1 + 176);
        std::vector<Backend::Google::DatabaseInfo>::__vdeallocate((void **)(a1 + 208));
        *(_OWORD *)(a1 + 208) = *(_OWORD *)a3;
        *(_QWORD *)(a1 + 224) = *(_QWORD *)(a3 + 16);
LABEL_10:
        *(_QWORD *)a3 = 0;
        *(_QWORD *)(a3 + 8) = 0;
        *(_QWORD *)(a3 + 16) = 0;
        dispatch_group_leave(*(dispatch_group_t *)(a1 + 16));
        std::unique_ptr<Platform::Transaction>::reset[abi:sn180100](v8, 0);
        return;
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 16));
  }
}

void SafeBrowsing::Service::didBeginUpdate(SafeBrowsing::Service *this, Backend::Google::DatabaseUpdater *a2)
{
  int v3;
  int v4;
  NSObject *v5;
  Platform::Transaction *v6;
  Platform::Transaction **v7;
  void *__p;
  __int16 v9;
  int v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *((_DWORD *)a2 + 64);
  v4 = *((_DWORD *)a2 + 65);
  v5 = SSBOSLogDatabase();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    LODWORD(__p) = 67109376;
    HIDWORD(__p) = v3;
    v9 = 1024;
    v10 = v4;
    _os_log_impl(&dword_1DBCBE000, v5, OS_LOG_TYPE_INFO, "Begin database update for protection type %d and provider %d", (uint8_t *)&__p, 0xEu);
  }
  if (v3 == 1)
  {
    switch(v4)
    {
      case 3:
        v6 = (Platform::Transaction *)operator new(0x18uLL);
        std::string::basic_string[abi:sn180100]<0>((char **)&__p, "Updating Apple Databases");
        Platform::Transaction::Transaction(v6, &__p);
        if (v11 < 0)
          operator delete(__p);
        v7 = (Platform::Transaction **)((char *)this + 392);
        break;
      case 2:
        v6 = (Platform::Transaction *)operator new(0x18uLL);
        std::string::basic_string[abi:sn180100]<0>((char **)&__p, "Updating Tencent Databases");
        Platform::Transaction::Transaction(v6, &__p);
        if (v11 < 0)
          operator delete(__p);
        v7 = (Platform::Transaction **)((char *)this + 288);
        break;
      case 1:
        v6 = (Platform::Transaction *)operator new(0x18uLL);
        std::string::basic_string[abi:sn180100]<0>((char **)&__p, "Updating Google Databases");
        Platform::Transaction::Transaction(v6, &__p);
        if (v11 < 0)
          operator delete(__p);
        v7 = (Platform::Transaction **)((char *)this + 184);
        break;
      default:
        return;
    }
    std::unique_ptr<Platform::Transaction>::reset[abi:sn180100](v7, v6);
  }
}

void sub_1DBCFEF84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;

  if (a14 < 0)
    operator delete(__p);
  operator delete(v14);
  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::didFinishUpdate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v6;
  const char *v7;
  _xpc_activity_s *v8;
  NSObject *v9;
  void *v10;
  _DWORD v11[2];
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a2 + 256);
  v6 = SSBOSLogDatabase();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v11[0] = 67109376;
    v11[1] = v5;
    v12 = 1024;
    v13 = HIDWORD(v5);
    _os_log_impl(&dword_1DBCBE000, v6, OS_LOG_TYPE_DEFAULT, "Finished database update for protection type %d and provider %d", (uint8_t *)v11, 0xEu);
  }
  if ((_DWORD)v5 == 1)
  {
    switch(HIDWORD(v5))
    {
      case 3:
        std::vector<Backend::Google::DatabaseInfo>::__vdeallocate((void **)(a1 + 416));
        *(_OWORD *)(a1 + 416) = *(_OWORD *)a3;
        *(_QWORD *)(a1 + 432) = *(_QWORD *)(a3 + 16);
        v7 = "com.apple.Safari.SafeBrowsing.DidFinishAppleDatabaseUpdate";
        break;
      case 2:
        std::vector<Backend::Google::DatabaseInfo>::__vdeallocate((void **)(a1 + 312));
        *(_OWORD *)(a1 + 312) = *(_OWORD *)a3;
        *(_QWORD *)(a1 + 328) = *(_QWORD *)(a3 + 16);
        v7 = "com.apple.Safari.SafeBrowsing.DidFinishTencentDatabaseUpdate";
        break;
      case 1:
        std::vector<Backend::Google::DatabaseInfo>::__vdeallocate((void **)(a1 + 208));
        *(_OWORD *)(a1 + 208) = *(_OWORD *)a3;
        *(_QWORD *)(a1 + 224) = *(_QWORD *)(a3 + 16);
        v7 = "com.apple.Safari.SafeBrowsing.DidFinishGoogleDatabaseUpdate";
        break;
      default:
LABEL_11:
        v8 = *(_xpc_activity_s **)(a1 + 112);
        if (v8)
        {
          if (!xpc_activity_set_state(v8, 5))
          {
            v9 = SSBOSLogService();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
              SafeBrowsing::Service::didFinishUpdate();
          }
          v10 = *(void **)(a1 + 112);
          *(_QWORD *)(a1 + 112) = 0;

        }
        SafeBrowsing::Service::registerUpdateActivity((__int128 **)a1, "com.apple.Safari.SafeBrowsing.BrowsingDatabases.Update");
        goto LABEL_17;
    }
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    notify_post(v7);
    goto LABEL_11;
  }
LABEL_17:
  SafeBrowsing::Service::didAttemptUpdate(a1, v5);
}

void SafeBrowsing::Service::registerUpdateActivity(__int128 **this, const char *a2)
{
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep PollingTimeAndDatabaseConfiguration;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL4 v8;
  void *v9;
  _QWORD v10[6];

  if (SafeBrowsing::Service::isEnabled((SafeBrowsing::Service *)this))
  {
    PollingTimeAndDatabaseConfiguration = SafeBrowsing::Service::nextPollingTimeAndDatabaseConfiguration(this);
    v6 = v5;
    v7 = PollingTimeAndDatabaseConfiguration - std::chrono::system_clock::now().__d_.__rep_;
    v8 = this[64] != this[65];
    SafeBrowsing::Service::dispatchPendingClientInUseMessages((uint64_t)this, PollingTimeAndDatabaseConfiguration);
    SafeBrowsing::createActivityCriteria(v7, v8);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3321888768;
    v10[2] = ___ZN12SafeBrowsing7Service22registerUpdateActivityEPKc_block_invoke;
    v10[3] = &__block_descriptor_48_ea8_32c62_ZTSKZN12SafeBrowsing7Service22registerUpdateActivityEPKcE3__0_e33_v16__0__NSObject_OS_xpc_object__8l;
    v10[4] = v6;
    v10[5] = this;
    xpc_activity_register(a2, v9, v10);

  }
}

void sub_1DBCFF248(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::didAttemptUpdate(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if ((_DWORD)a2 == 1)
  {
    switch(HIDWORD(a2))
    {
      case 3:
        v2 = a1 + 384;
        goto LABEL_6;
      case 2:
        v2 = a1 + 280;
        goto LABEL_6;
      case 1:
        v2 = a1 + 176;
LABEL_6:
        ___ZN12SafeBrowsing7Service16didAttemptUpdateEN7Backend6Google21DatabaseConfigurationE_block_invoke(a1, v2);
        break;
    }
  }
}

void SafeBrowsing::Service::didFailUpdate(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  _xpc_activity_s *v5;
  NSObject *v6;
  void *v7;

  v3 = *(_QWORD *)(a2 + 256);
  v4 = SSBOSLogDatabase();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    SafeBrowsing::Service::didFailUpdate(v3, v3, v4);
  if ((_DWORD)v3 == 1)
  {
    v5 = *(_xpc_activity_s **)(a1 + 112);
    if (v5)
    {
      if (!xpc_activity_set_state(v5, 5))
      {
        v6 = SSBOSLogService();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          SafeBrowsing::Service::didFinishUpdate();
      }
      v7 = *(void **)(a1 + 112);
      *(_QWORD *)(a1 + 112) = 0;

    }
    SafeBrowsing::Service::registerUpdateActivity((__int128 **)a1, "com.apple.Safari.SafeBrowsing.BrowsingDatabases.Update");
  }
  SafeBrowsing::Service::didAttemptUpdate(a1, v3);
}

void ___ZN12SafeBrowsing7Service16didAttemptUpdateEN7Backend6Google21DatabaseConfigurationE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  void **v9;

  v3 = *(_QWORD *)(a2 + 56);
  v7 = v3;
  v8 = *(_OWORD *)(a2 + 64);
  v4 = v8;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  v5 = v4;
  while (1)
  {
    if (v3 == v5)
    {
      std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)(a2 + 8), 0);
      v9 = (void **)&v7;
      std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&v9);
      return;
    }
    v6 = *(_QWORD *)(v3 + 24);
    if (!v6)
      break;
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
    v3 += 32;
  }
  std::__throw_bad_function_call[abi:sn180100]();
  __break(1u);
}

void sub_1DBCFF3DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&a12);
  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::runUpdateActivityOperations(uint64_t a1, void *a2, uint64_t a3)
{
  id v6;
  int v7;
  int v8;
  void *v9;
  void *v10;
  void *v11;
  char v12;
  _QWORD **v13;
  void *v14;
  char v15;
  uint64_t v16;
  void *v17;
  void *v18;
  char v19;
  ProxyConfiguration *v20;
  void *v21;
  ProxyConfiguration *v22;
  _QWORD v23[5];
  int v24;

  v6 = a2;
  v7 = objc_msgSend(*(id *)(a1 + 144), "onHighCellularDataPlan");
  if ((_DWORD)a3 == 1)
  {
    v8 = v7;
    objc_storeStrong((id *)(a1 + 112), a2);
    +[RemoteConfigurationController sharedController](RemoteConfigurationController, "sharedController");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = v9;
    switch(HIDWORD(a3))
    {
      case 1:
        objc_msgSend(v9, "googleProviderConfiguration");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        v15 = objc_msgSend(v14, "providerOff");

        if ((v15 & 1) == 0)
        {
          if (Backend::Google::DeviceIdentificationTokenFetcher::shouldFetchDeviceIdentificationToken(*(Backend::Google::DeviceIdentificationTokenFetcher **)(a1 + 256)))
          {
            v16 = *(_QWORD *)(a1 + 256);
            v17 = *(void **)(a1 + 8);
            v23[0] = MEMORY[0x1E0C809B0];
            v23[1] = 3221225472;
            v23[2] = ___ZN12SafeBrowsing7Service27runUpdateActivityOperationsEPU24objcproto13OS_xpc_object8NSObjectN7Backend6Google21DatabaseConfigurationE_block_invoke;
            v23[3] = &__block_descriptor_44_e5_v8__0l;
            v23[4] = a1;
            v24 = v8;
            Backend::Google::DeviceIdentificationTokenFetcher::fetchDeviceIdentificationToken(v16, v17, v23);
          }
          else
          {
            v20 = [ProxyConfiguration alloc];
            Backend::Google::DeviceIdentificationTokenFetcher::getCurrentDeviceIdentificationToken(*(id **)(a1 + 256));
            v21 = (void *)objc_claimAutoreleasedReturnValue();
            v22 = -[ProxyConfiguration initWithDeviceIdentificationToken:](v20, "initWithDeviceIdentificationToken:", v21);

            Backend::Google::DatabaseUpdater::update(*(_QWORD **)(a1 + 192), v8, v22);
          }
        }
        goto LABEL_13;
      case 2:
        objc_msgSend(v9, "tencentProviderConfiguration");
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        v19 = objc_msgSend(v18, "providerOff");

        if ((v19 & 1) != 0)
        {
LABEL_13:

          goto LABEL_14;
        }
        v13 = (_QWORD **)(a1 + 296);
        break;
      case 3:
        objc_msgSend(v9, "appleProviderConfiguration");
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        v12 = objc_msgSend(v11, "providerOff");

        if ((v12 & 1) != 0)
          goto LABEL_13;
        v13 = (_QWORD **)(a1 + 400);
        break;
      default:
        goto LABEL_13;
    }
    Backend::Google::DatabaseUpdater::update(*v13, v8, 0);
    goto LABEL_13;
  }
LABEL_14:

}

void sub_1DBCFF5B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing7Service27runUpdateActivityOperationsEPU24objcproto13OS_xpc_object8NSObjectN7Backend6Google21DatabaseConfigurationE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  ProxyConfiguration *v3;
  void *v4;
  ProxyConfiguration *v5;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = [ProxyConfiguration alloc];
  Backend::Google::DeviceIdentificationTokenFetcher::getCurrentDeviceIdentificationToken(*(id **)(v2 + 256));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = -[ProxyConfiguration initWithDeviceIdentificationToken:](v3, "initWithDeviceIdentificationToken:", v4);

  Backend::Google::DatabaseUpdater::update(*(_QWORD **)(v2 + 192), *(_DWORD *)(a1 + 40), v5);
}

void sub_1DBCFF674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

std::chrono::duration<long long, std::ratio<1, 1000000>>::rep SafeBrowsing::Service::nextPollingTimeAndDatabaseConfiguration(__int128 **this)
{
  Backend::Google::SSBUtilities *PollingTimeFromDatabases;
  char v3;
  Backend::Google::SSBUtilities *v4;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  char v6;
  uint64_t v7;
  char v8;

  PollingTimeFromDatabases = (Backend::Google::SSBUtilities *)SafeBrowsing::nextPollingTimeFromDatabases(this + 26);
  if (!v3)
    PollingTimeFromDatabases = (Backend::Google::SSBUtilities *)std::chrono::system_clock::now().__d_.__rep_;
  v4 = PollingTimeFromDatabases;
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(PollingTimeFromDatabases);
  if ((_DWORD)shouldConsultWithTencent)
  {
    shouldConsultWithTencent = (Backend::Google::SSBUtilities *)SafeBrowsing::nextPollingTimeFromDatabases(this + 39);
    if (v6)
    {
      if ((uint64_t)shouldConsultWithTencent >= (uint64_t)v4)
        goto LABEL_9;
    }
    else
    {
      shouldConsultWithTencent = (Backend::Google::SSBUtilities *)std::chrono::system_clock::now().__d_.__rep_;
    }
    v4 = shouldConsultWithTencent;
  }
LABEL_9:
  if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
  {
    v7 = SafeBrowsing::nextPollingTimeFromDatabases(this + 52);
    if (!v8)
      return std::chrono::system_clock::now().__d_.__rep_;
    if (v7 >= (uint64_t)v4)
      return (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)v4;
    return v7;
  }
  return (std::chrono::duration<long long, std::ratio<1, 1000000>>::rep)v4;
}

uint64_t SafeBrowsing::nextPollingTimeFromDatabases(__int128 **a1)
{
  __int128 *v1;
  __int128 *v2;
  __int128 *i;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  char v18;
  _QWORD v19[3];

  v1 = *a1;
  v2 = a1[1];
  if (*a1 == v2)
    return 0;
  for (i = v1 + 7; i != v2; i += 7)
  {
    if (*((_QWORD *)v1 + 6) < *((_QWORD *)i + 6))
      v1 = i;
  }
  v12 = *v1;
  v4 = *((_QWORD *)v1 + 3);
  v13 = *((_QWORD *)v1 + 2);
  v14 = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = v1[2];
  v8 = v1[3];
  v9 = v1[4];
  v18 = *((_BYTE *)v1 + 80);
  v16 = v8;
  v17 = v9;
  v15 = v7;
  std::vector<Backend::Google::Database::HashSizeBucket>::vector(v19, (uint64_t)v1 + 88);
  v10 = *((_QWORD *)&v16 + 1);
  Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)&v12);
  return v10;
}

void sub_1DBCFF800(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKc_block_invoke(_QWORD *a1, void *a2)
{
  _xpc_activity_s *v3;
  uint64_t v4;
  xpc_activity_state_t state;
  xpc_activity_state_t v6;
  NSObject *v7;
  NSObject *v8;
  _xpc_activity_s *v9;
  uint64_t v10;
  xpc_object_t v11;
  std::chrono::system_clock::time_point v12;
  void *v13;
  NSObject *v14;
  __int128 v15;
  void (*v16)(uint64_t);
  void *v17;
  _xpc_activity_s *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = a1[4];
  state = xpc_activity_get_state(v3);
  v6 = state;
  if (state)
  {
    if (state == 2)
    {
      if (!xpc_activity_set_state(v3, 4))
      {
        v7 = SSBOSLogService();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          ___ZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKc_block_invoke_cold_1();
      }
      v8 = *(NSObject **)(v4 + 8);
      *(_QWORD *)&v15 = MEMORY[0x1E0C809B0];
      *((_QWORD *)&v15 + 1) = 3321888768;
      v16 = ___ZZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKcENK3__0clEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
      v17 = &__block_descriptor_56_ea8_32c120_ZTSKZZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKcENK3__0clEPU24objcproto13OS_xpc_object8NSObjectEUlvE__e5_v8__0l;
      v9 = v3;
      v10 = a1[6];
      v18 = v9;
      v19 = v10;
      v20 = v4;
      dispatch_async(v8, &v15);

    }
    else
    {
      v14 = SSBOSLogService();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v15) = 134217984;
        *(_QWORD *)((char *)&v15 + 4) = v6;
        _os_log_impl(&dword_1DBCBE000, v14, OS_LOG_TYPE_DEFAULT, "Unhandled activity state %li", (uint8_t *)&v15, 0xCu);
      }
    }
  }
  else
  {
    v11 = xpc_activity_copy_criteria(v3);

    if (!v11)
    {
      v12.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      SafeBrowsing::createActivityCriteria(a1[5] - v12.__d_.__rep_, 0);
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      xpc_activity_set_criteria(v3, v13);

    }
  }

}

void sub_1DBCFF9A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c71_ZTSKZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKcE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[3].n128_u64[0] = a2[3].n128_u64[0];
  a1[2] = result;
  return result;
}

void SafeBrowsing::Service::dispatchPendingClientInUseMessages(uint64_t a1, uint64_t a2)
{
  void **v3;
  void **v4;
  void *v6;
  void **v7;
  void *v8;

  v3 = *(void ***)(a1 + 512);
  v4 = *(void ***)(a1 + 520);
  if (v3 != v4)
  {
    do
    {
      v6 = *v3++;
      SafeBrowsing::Service::sendClientInUseReply(a1, v6, a2);
    }
    while (v3 != v4);
    v7 = *(void ***)(a1 + 520);
    v3 = *(void ***)(a1 + 512);
    while (v7 != v3)
    {
      v8 = *--v7;

    }
  }
  *(_QWORD *)(a1 + 520) = v3;
}

id SafeBrowsing::createActivityCriteria(uint64_t a1, int a2)
{
  xpc_object_t v4;
  uint32_t v5;

  v4 = xpc_dictionary_create(0, 0, 0);
  v5 = arc4random_uniform(0x3Cu);
  xpc_dictionary_set_int64(v4, (const char *)*MEMORY[0x1E0C80760], ((a1 & ~(a1 >> 63)) + 1000000 * (unint64_t)v5) / 0xF4240);
  xpc_dictionary_set_string(v4, (const char *)*MEMORY[0x1E0C80878], (const char *)*MEMORY[0x1E0C80888]);
  xpc_dictionary_set_BOOL(v4, (const char *)*MEMORY[0x1E0C80868], 1);
  xpc_dictionary_set_BOOL(v4, (const char *)*MEMORY[0x1E0C80898], 0);
  xpc_dictionary_set_BOOL(v4, (const char *)*MEMORY[0x1E0C808D0], 1);
  xpc_dictionary_set_BOOL(v4, (const char *)*MEMORY[0x1E0C80738], a2 == 1);
  xpc_dictionary_set_BOOL(v4, (const char *)*MEMORY[0x1E0C808D8], 0);
  xpc_dictionary_set_int64(v4, (const char *)*MEMORY[0x1E0C80790], 0);
  return v4;
}

void sub_1DBCFFB94(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing7Service22registerUpdateActivityEPKc_block_invoke(uint64_t a1, void *a2)
{
  _xpc_activity_s *v3;
  uint64_t v4;
  xpc_activity_state_t state;
  NSObject *v6;
  NSObject *v7;
  _xpc_activity_s *v8;
  uint64_t v9;
  NSObject *v10;
  __int128 v11;
  void (*v12)(uint64_t);
  void *v13;
  _xpc_activity_s *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 40);
  state = xpc_activity_get_state(v3);
  if (state == 2)
  {
    if (!xpc_activity_set_state(v3, 4))
    {
      v6 = SSBOSLogService();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        ___ZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKc_block_invoke_cold_1();
    }
    v7 = *(NSObject **)(v4 + 8);
    *(_QWORD *)&v11 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v11 + 1) = 3321888768;
    v12 = ___ZZN12SafeBrowsing7Service22registerUpdateActivityEPKcENK3__0clEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
    v13 = &__block_descriptor_56_ea8_32c111_ZTSKZZN12SafeBrowsing7Service22registerUpdateActivityEPKcENK3__0clEPU24objcproto13OS_xpc_object8NSObjectEUlvE__e5_v8__0l;
    v8 = v3;
    v9 = *(_QWORD *)(a1 + 32);
    v14 = v8;
    v15 = v9;
    v16 = v4;
    dispatch_async(v7, &v11);

  }
  else
  {
    v10 = SSBOSLogService();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v11) = 134217984;
      *(_QWORD *)((char *)&v11 + 4) = state;
      _os_log_impl(&dword_1DBCBE000, v10, OS_LOG_TYPE_DEFAULT, "Unhandled activity state %li", (uint8_t *)&v11, 0xCu);
    }
  }

}

void sub_1DBCFFCF8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c62_ZTSKZN12SafeBrowsing7Service22registerUpdateActivityEPKcE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[2] = result;
  return result;
}

void ___ZN12SafeBrowsing7Service41registerDatabaseLoadingDispatchGroupBlockEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  NSObject *v3;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v1 + 8);
  v2 = *(NSObject **)(v1 + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZZN12SafeBrowsing7Service41registerDatabaseLoadingDispatchGroupBlockEvENK3__0clEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = v1;
  dispatch_group_notify(v2, v3, block);
}

uint64_t __copy_helper_block_ea8_32c79_ZTSKZN12SafeBrowsing7Service41registerDatabaseLoadingDispatchGroupBlockEvE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void SafeBrowsing::Service::handleForceDeviceIdentificationTokenUpdate(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  char v6;
  xpc_object_t reply;
  _xpc_connection_s *v8;
  uint64_t v9;
  void *v10;
  _QWORD v11[4];
  id v12;

  v3 = a2;
  +[RemoteConfigurationController sharedController](RemoteConfigurationController, "sharedController");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "googleProviderConfiguration");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "proxyOff");

  if ((v6 & 1) != 0)
  {
    reply = xpc_dictionary_create_reply(v3);
    xpc_dictionary_set_BOOL(reply, "forceDeviceIdentificationTokenUpdateKey", 0);
    xpc_dictionary_get_remote_connection(v3);
    v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
    xpc_connection_send_message(v8, reply);

  }
  else
  {
    v9 = *(_QWORD *)(a1 + 256);
    v10 = *(void **)(a1 + 8);
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3321888768;
    v11[2] = ___ZN12SafeBrowsing7Service42handleForceDeviceIdentificationTokenUpdateEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
    v11[3] = &__block_descriptor_40_ea8_32c116_ZTSKZN12SafeBrowsing7Service42handleForceDeviceIdentificationTokenUpdateEPU24objcproto13OS_xpc_object8NSObjectE3__0_e5_v8__0l;
    v12 = v3;
    Backend::Google::DeviceIdentificationTokenFetcher::fetchDeviceIdentificationToken(v9, v10, v11);

  }
}

void sub_1DBCFFE94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1DBCFFEE8()
{
  JUMPOUT(0x1DBCFFEDCLL);
}

void ___ZN12SafeBrowsing7Service42handleForceDeviceIdentificationTokenUpdateEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  _xpc_connection_s *v2;
  xpc_object_t message;

  message = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 32));
  xpc_dictionary_set_BOOL(message, "forceDeviceIdentificationTokenUpdateKey", 1);
  xpc_dictionary_get_remote_connection(*(xpc_object_t *)(a1 + 32));
  v2 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
  xpc_connection_send_message(v2, message);

}

void sub_1DBCFFF50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c116_ZTSKZN12SafeBrowsing7Service42handleForceDeviceIdentificationTokenUpdateEPU24objcproto13OS_xpc_object8NSObjectE3__0(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c116_ZTSKZN12SafeBrowsing7Service42handleForceDeviceIdentificationTokenUpdateEPU24objcproto13OS_xpc_object8NSObjectE3__0(uint64_t a1)
{

}

void SafeBrowsing::Service::enabledStateDidChange(SafeBrowsing::Service *this)
{
  char isEnabled;
  NSObject *v3;
  _BOOL4 v4;
  uint8_t v5[16];
  uint8_t buf[16];

  isEnabled = SafeBrowsing::Service::isEnabled(this);
  v3 = SSBOSLogService();
  v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if ((isEnabled & 1) != 0)
  {
    if (v4)
    {
      *(_WORD *)v5 = 0;
      _os_log_impl(&dword_1DBCBE000, v3, OS_LOG_TYPE_DEFAULT, "Safe Browsing was enabled", v5, 2u);
    }
    SafeBrowsing::Service::registerUpdateActivity((__int128 **)this, "com.apple.Safari.SafeBrowsing.BrowsingDatabases.Update");
  }
  else
  {
    if (v4)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1DBCBE000, v3, OS_LOG_TYPE_DEFAULT, "Safe Browsing was disabled", buf, 2u);
    }
    xpc_activity_unregister("com.apple.Safari.SafeBrowsing.BrowsingDatabases.Update");
  }
}

void SafeBrowsing::Service::enabledStateDidChange(SafeBrowsing::Service *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  {
    Platform::OnceConstructedNeverDestroyed<SafeBrowsing::Service>::OnceConstructedNeverDestroyed(&SafeBrowsing::Service::shared(void)::service);
  }
  SafeBrowsing::Service::enabledStateDidChange((SafeBrowsing::Service *)&unk_1ED04E960);
}

void SafeBrowsing::Service::main(SafeBrowsing::Service *this)
{
  _xpc_connection_s *mach_service;
  __CFNotificationCenter *DarwinNotifyCenter;
  _QWORD handler[5];

  {
    Platform::OnceConstructedNeverDestroyed<SafeBrowsing::Service>::OnceConstructedNeverDestroyed(&SafeBrowsing::Service::shared(void)::service);
  }
  mach_service = xpc_connection_create_mach_service("com.apple.Safari.SafeBrowsing.Service", MEMORY[0x1E0C80D38], 1uLL);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZN12SafeBrowsing7Service4mainEv_block_invoke;
  handler[3] = &__block_descriptor_40_ea8_32c41_ZTSKZN12SafeBrowsing7Service4mainEvE3__0_e33_v16__0__NSObject_OS_xpc_object__8l;
  handler[4] = &unk_1ED04E960;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_resume(mach_service);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(DarwinNotifyCenter, 0, (CFNotificationCallback)SafeBrowsing::Service::enabledStateDidChange, CFSTR("SafeBrowsingEnabledStateDidChangeNotification"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  dispatch_main();
}

void sub_1DBD00170(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing7Service4mainEv_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[4];
  id v8;
  uint64_t v9;

  v3 = a2;
  if (MEMORY[0x1DF0B91F0]() == MEMORY[0x1E0C812E0])
  {
    v4 = v3;
    v5 = *(_QWORD *)(a1 + 32);
    v6 = *(NSObject **)(v5 + 8);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3321888768;
    v7[2] = ___ZZN12SafeBrowsing7Service4mainEvENK3__0clEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
    v7[3] = &__block_descriptor_48_ea8_32c90_ZTSKZZN12SafeBrowsing7Service4mainEvENK3__0clEPU24objcproto13OS_xpc_object8NSObjectEUlvE__e5_v8__0l;
    v8 = v4;
    v9 = v5;
    dispatch_async(v6, v7);

  }
}

void sub_1DBD00220(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c41_ZTSKZN12SafeBrowsing7Service4mainEvE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void SafeBrowsing::Service::handleNewConnection(uint64_t a1, void *a2)
{
  id v3;
  _QWORD handler[5];
  id v5;
  id v6;

  v6 = a2;
  std::__tree<NSObject  {objcproto13OS_xpc_object}* {__strong}>::__emplace_unique_key_args<NSObject  {objcproto13OS_xpc_object}* {__strong},NSObject  {objcproto13OS_xpc_object}* const {__strong}&>((uint64_t **)(a1 + 120), (unint64_t *)&v6, &v6);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3321888768;
  handler[2] = ___ZN12SafeBrowsing7Service19handleNewConnectionEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
  handler[3] = &__block_descriptor_48_ea8_32c93_ZTSKZN12SafeBrowsing7Service19handleNewConnectionEPU24objcproto13OS_xpc_object8NSObjectE3__0_e33_v16__0__NSObject_OS_xpc_object__8l;
  handler[4] = a1;
  v3 = v6;
  v5 = v3;
  xpc_connection_set_event_handler((xpc_connection_t)v3, handler);

  xpc_connection_resume((xpc_connection_t)v6);
}

void sub_1DBD002E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  uint64_t v15;

  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing7Service19handleNewConnectionEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  id v6;
  id v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  id v12;
  id v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  _QWORD block[5];
  id v24;
  id v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;

  v3 = a2;
  v4 = *(_QWORD *)(a1 + 32);
  std::allocate_shared[abi:sn180100]<Platform::Transaction,std::allocator<Platform::Transaction>,char const(&)[17],void>("Handling Message", &v28);
  v5 = *(NSObject **)(v4 + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZZN12SafeBrowsing7Service19handleNewConnectionEPU24objcproto13OS_xpc_object8NSObjectENK3__0clES3__block_invoke;
  block[3] = &__block_descriptor_72_ea8_32c108_ZTSKZZN12SafeBrowsing7Service19handleNewConnectionEPU24objcproto13OS_xpc_object8NSObjectENK3__0clES3_EUlvE__e5_v8__0l;
  v6 = *(id *)(a1 + 40);
  v7 = v3;
  v9 = v28;
  v8 = v29;
  if (v29)
  {
    p_shared_owners = (unint64_t *)&v29->__shared_owners_;
    do
      v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }
  block[4] = v4;
  v12 = v6;
  v24 = v12;
  v13 = v7;
  v25 = v13;
  v26 = v9;
  v27 = v8;
  if (v8)
  {
    v14 = (unint64_t *)&v8->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    dispatch_async(v5, block);
    do
      v16 = __ldaxr(v14);
    while (__stlxr(v16 - 1, v14));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  else
  {
    dispatch_async(v5, block);
  }

  v17 = v27;
  if (v27)
  {
    v18 = (unint64_t *)&v27->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  v20 = v29;
  if (v29)
  {
    v21 = (unint64_t *)&v29->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

}

void sub_1DBD004E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c93_ZTSKZN12SafeBrowsing7Service19handleNewConnectionEPU24objcproto13OS_xpc_object8NSObjectE3__0(uint64_t a1, uint64_t a2)
{
  void *v3;
  id result;

  v3 = *(void **)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  result = v3;
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_ea8_32c93_ZTSKZN12SafeBrowsing7Service19handleNewConnectionEPU24objcproto13OS_xpc_object8NSObjectE3__0(uint64_t a1)
{

}

void SafeBrowsing::Service::handleConnectionEvent(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  id v6;

  v6 = a2;
  v5 = a3;
  if (MEMORY[0x1DF0B91F0]() == MEMORY[0x1E0C81310])
    SafeBrowsing::Service::handleConnectionError((uint64_t)a1, v6);
  else
    SafeBrowsing::Service::handleConnectionMessage(a1, v5);

}

void sub_1DBD005A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleConnectionError(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  std::__tree<NSObject  {objcproto13OS_xpc_object}* {__strong}>::__erase_unique<NSObject  {objcproto13OS_xpc_object}* {__strong}>(a1 + 120, (unint64_t *)&v3);

}

void sub_1DBD005F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleConnectionMessage(_QWORD *a1, void *a2)
{
  id v3;
  uint64_t uint64;
  NSObject *v5;
  _xpc_connection_s *v6;

  v3 = a2;
  uint64 = xpc_dictionary_get_uint64(v3, "message");
  switch((int)uint64)
  {
    case 1:
      SafeBrowsing::Service::handleForceDatabaseUpdate((uint64_t)a1);
      break;
    case 2:
      SafeBrowsing::Service::handleGetDatabases((uint64_t)a1, v3);
      break;
    case 3:
      SafeBrowsing::Service::handleGetServiceStatus(a1, v3);
      break;
    case 4:
      SafeBrowsing::Service::handleCheckFullHashes((uint64_t)a1, v3);
      break;
    case 5:
      SafeBrowsing::Service::handleForceLoadRemoteConfigurationFromDisk(uint64, v3);
      break;
    case 6:
      SafeBrowsing::Service::handleForceUpdateRemoteConfigurationFromServer(uint64, v3);
      break;
    case 7:
      SafeBrowsing::Service::handleDeleteAllDatabases(uint64, v3);
      break;
    case 8:
      SafeBrowsing::Service::handleClientInUse((uint64_t)a1, v3);
      break;
    case 9:
      SafeBrowsing::Service::handleFetchCellularDataPlan((uint64_t)a1, v3);
      break;
    case 10:
      SafeBrowsing::Service::handleGetSafeBrowsingEnabledState(uint64, v3);
      break;
    case 11:
      SafeBrowsing::Service::handleForceDeviceIdentificationTokenUpdate((uint64_t)a1, v3);
      break;
    default:
      v5 = SSBOSLogXPC();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
        SafeBrowsing::Service::handleConnectionMessage();
      xpc_dictionary_get_remote_connection(v3);
      v6 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      xpc_connection_cancel(v6);

      break;
  }

}

void sub_1DBD00738(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleForceDatabaseUpdate(uint64_t a1)
{
  void *v2;
  void *v3;
  char v4;
  Backend::Google::SSBUtilities *v5;
  uint64_t v6;
  void *v7;
  ProxyConfiguration *v8;
  void *v9;
  ProxyConfiguration *v10;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  void *v12;
  char v13;
  void *v14;
  char v15;
  _QWORD v16[5];

  +[RemoteConfigurationController sharedController](RemoteConfigurationController, "sharedController");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "googleProviderConfiguration");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(v3, "providerOff");

  if ((v4 & 1) == 0)
  {
    if (Backend::Google::DeviceIdentificationTokenFetcher::shouldFetchDeviceIdentificationToken(*(Backend::Google::DeviceIdentificationTokenFetcher **)(a1 + 256)))
    {
      v6 = *(_QWORD *)(a1 + 256);
      v7 = *(void **)(a1 + 8);
      v16[0] = MEMORY[0x1E0C809B0];
      v16[1] = 3221225472;
      v16[2] = ___ZN12SafeBrowsing7Service25handleForceDatabaseUpdateEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
      v16[3] = &__block_descriptor_40_e5_v8__0l;
      v16[4] = a1;
      Backend::Google::DeviceIdentificationTokenFetcher::fetchDeviceIdentificationToken(v6, v7, v16);
    }
    else
    {
      v8 = [ProxyConfiguration alloc];
      Backend::Google::DeviceIdentificationTokenFetcher::getCurrentDeviceIdentificationToken(*(id **)(a1 + 256));
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v10 = -[ProxyConfiguration initWithDeviceIdentificationToken:](v8, "initWithDeviceIdentificationToken:", v9);

      Backend::Google::DatabaseUpdater::update(*(_QWORD **)(a1 + 192), 2, v10);
    }
  }
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(v5);
  if ((_DWORD)shouldConsultWithTencent)
  {
    objc_msgSend(v2, "tencentProviderConfiguration");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = objc_msgSend(v12, "providerOff");

    if ((v13 & 1) == 0)
      Backend::Google::DatabaseUpdater::update(*(_QWORD **)(a1 + 296), 2, 0);
  }
  if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
  {
    objc_msgSend(v2, "appleProviderConfiguration");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = objc_msgSend(v14, "providerOff");

    if ((v15 & 1) == 0)
      Backend::Google::DatabaseUpdater::update(*(_QWORD **)(a1 + 400), 2, 0);
  }

}

void sub_1DBD008C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleGetDatabases(uint64_t a1, void *a2)
{
  id v3;
  int int64;
  int v5;
  NSObject *v6;
  void *v7;
  void *v8;
  char v9;
  _BOOL8 DeviceIdentificationToken;
  int v11;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  void *v13;
  int v14;
  void *v15;
  int v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  int64x2_t v32;
  uint64_t v33;
  uint64_t v34;
  int64x2_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  int64 = xpc_dictionary_get_int64(v3, "protectionType");
  if (EnumTraits::isValidEnum<Backend::Google::ProtectionType>(int64))
    v5 = int64;
  else
    v5 = 1;
  v6 = SSBOSLogDatabase();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    LODWORD(v34) = 67109120;
    HIDWORD(v34) = v5;
    _os_log_impl(&dword_1DBCBE000, v6, OS_LOG_TYPE_INFO, "Received GetDatabases message with protection type %d", (uint8_t *)&v34, 8u);
  }
  if (v5 != 1)
    goto LABEL_40;
  +[RemoteConfigurationController sharedController](RemoteConfigurationController, "sharedController");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "googleProviderConfiguration");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = objc_msgSend(v8, "providerOff");

  if ((v9 & 1) != 0)
  {
    v11 = 0;
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 208) == *(_QWORD *)(a1 + 216);
    DeviceIdentificationToken = Backend::Google::DeviceIdentificationTokenFetcher::shouldFetchDeviceIdentificationToken(*(Backend::Google::DeviceIdentificationTokenFetcher **)(a1 + 256));
    if (DeviceIdentificationToken)
      Backend::Google::DeviceIdentificationTokenFetcher::fetchDeviceIdentificationToken(*(_QWORD *)(a1 + 256), *(void **)(a1 + 8), &__block_literal_global_47);
  }
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent((Backend::Google::SSBUtilities *)DeviceIdentificationToken);
  if ((_DWORD)shouldConsultWithTencent)
  {
    objc_msgSend(v7, "tencentProviderConfiguration");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v14 = objc_msgSend(v13, "providerOff");

    if (((v14 | v11) & 1) != 0)
      v11 |= v14 ^ 1;
    else
      v11 = *(_QWORD *)(a1 + 312) == *(_QWORD *)(a1 + 320);
  }
  if ((Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent) & 1) == 0)
  {
    if ((v11 & 1) != 0)
      goto LABEL_20;
    goto LABEL_24;
  }
  objc_msgSend(v7, "appleProviderConfiguration");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = objc_msgSend(v15, "providerOff");

  if (((v16 | v11) & 1) == 0)
  {
    if (*(_QWORD *)(a1 + 416) == *(_QWORD *)(a1 + 424))
      goto LABEL_20;
LABEL_24:
    SafeBrowsing::Service::sendGetDatabasesReply((_QWORD *)a1, v3, 1);
LABEL_39:

LABEL_40:
    return;
  }
  if ((v16 ^ 1 | v11) != 1)
    goto LABEL_24;
LABEL_20:
  v17 = *(_QWORD *)(a1 + 168);
  v18 = *(_QWORD **)(a1 + 160);
  if ((unint64_t)v18 >= v17)
  {
    v20 = *(_QWORD *)(a1 + 152);
    v21 = ((uint64_t)v18 - v20) >> 3;
    if ((unint64_t)(v21 + 1) >> 61)
      abort();
    v22 = v17 - v20;
    v23 = v22 >> 2;
    if (v22 >> 2 <= (unint64_t)(v21 + 1))
      v23 = v21 + 1;
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8)
      v24 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v24 = v23;
    v37 = a1 + 168;
    if (v24)
    {
      v25 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>(a1 + 168, v24);
      if (v25)
      {
        v27 = &v25[8 * v26];
        v28 = &v25[8 * v21];
        *(_QWORD *)v28 = v3;
        v19 = v28 + 8;
        v30 = *(_QWORD **)(a1 + 152);
        v29 = *(_QWORD **)(a1 + 160);
        if (v29 == v30)
        {
          v32 = vdupq_n_s64((unint64_t)v29);
        }
        else
        {
          do
          {
            v31 = *--v29;
            *v29 = 0;
            *((_QWORD *)v28 - 1) = v31;
            v28 -= 8;
          }
          while (v29 != v30);
          v32 = *(int64x2_t *)(a1 + 152);
        }
        *(_QWORD *)(a1 + 152) = v28;
        *(_QWORD *)(a1 + 160) = v19;
        v35 = v32;
        v33 = *(_QWORD *)(a1 + 168);
        *(_QWORD *)(a1 + 168) = v27;
        v36 = v33;
        v34 = v32.i64[0];
        std::__split_buffer<NSObject  {objcproto13OS_xpc_object}* {__strong}>::~__split_buffer((uint64_t)&v34);
        goto LABEL_38;
      }
    }
  }
  else if (v18)
  {
    *v18 = v3;
    v19 = v18 + 1;
LABEL_38:
    *(_QWORD *)(a1 + 160) = v19;
    goto LABEL_39;
  }
  __break(1u);
}

void sub_1DBD00BBC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleGetServiceStatus(_QWORD *a1, void *a2)
{
  xpc_object_t reply;
  xpc_object_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  xpc_object_t v8;
  xpc_object_t v9;
  _QWORD *v10;
  xpc_object_t v11;
  pid_t pid;
  char *v13;
  _QWORD *v14;
  _QWORD *v15;
  BOOL v16;
  Backend::Google::SSBUtilities *v17;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  _xpc_connection_s *v19;
  xpc_object_t xdict;
  _QWORD v21[3];
  void **v22;

  xdict = a2;
  reply = xpc_dictionary_create_reply(xdict);
  v4 = xpc_array_create(0, 0);
  Platform::Transaction::activeTransactionDescriptions((uint64_t)v21);
  v5 = v21[0];
  v6 = v21[1];
  while (v5 != v6)
  {
    v7 = (const char *)v5;
    if (*(char *)(v5 + 23) < 0)
      v7 = *(const char **)v5;
    v8 = xpc_string_create(v7);
    xpc_array_append_value(v4, v8);

    v5 += 24;
  }
  xpc_dictionary_set_value(reply, "activeTransactions", v4);
  v9 = xpc_array_create(0, 0);
  v10 = (_QWORD *)a1[15];
  if (v10 != a1 + 16)
  {
    do
    {
      v11 = xpc_dictionary_create(0, 0, 0);
      pid = xpc_connection_get_pid((xpc_connection_t)v10[4]);
      xpc_dictionary_set_int64(v11, "pid", pid);
      v13 = (char *)xpc_connection_copy_bundle_id();
      if (v13)
      {
        xpc_dictionary_set_string(v11, "bundleIdentifier", v13);
        free(v13);
      }
      xpc_array_append_value(v9, v11);

      v14 = (_QWORD *)v10[1];
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v15 = (_QWORD *)v10[2];
          v16 = *v15 == (_QWORD)v10;
          v10 = v15;
        }
        while (!v16);
      }
      v10 = v15;
    }
    while (v15 != a1 + 16);
  }
  xpc_dictionary_set_value(reply, "connections", v9);
  xpc_dictionary_set_int64(reply, "googleDatabaseUpdaterState", *(int *)(a1[24] + 240));
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(v17);
  if ((_DWORD)shouldConsultWithTencent)
    xpc_dictionary_set_int64(reply, "tencentDatabaseUpdaterState", *(int *)(a1[37] + 240));
  if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
    xpc_dictionary_set_int64(reply, "appleDatabaseUpdaterState", *(int *)(a1[50] + 240));
  xpc_dictionary_get_remote_connection(xdict);
  v19 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
  xpc_connection_send_message(v19, reply);

  v22 = (void **)v21;
  std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](&v22);

}

void sub_1DBD00E40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  a14 = (void **)&a11;
  std::vector<std::string>::__destroy_vector::operator()[abi:sn180100](&a14);

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleCheckFullHashes(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  id v5;
  void *v6;
  char v7;
  xpc_object_t reply;
  void *v9;
  ProxyConfiguration *v10;
  void *v11;
  ProxyConfiguration *v12;
  _QWORD *v13;
  void *v14;
  char v15;
  id v16;
  _xpc_connection_s *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  NSObject *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  char v30;
  __int128 buf;
  BOOL (*v32)(uint64_t, uint64_t, void *);
  void *v33;
  __int128 *v34;
  __int128 v35;
  uint64_t v36;
  void **v37;
  _QWORD v38[3];
  _QWORD *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = SSBOSLogFullHash();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_1DBCBE000, v4, OS_LOG_TYPE_INFO, "Received CheckFullHashes message", (uint8_t *)&buf, 2u);
  }
  xpc_dictionary_get_value(v3, "requests");
  v5 = (id)objc_claimAutoreleasedReturnValue();
  v6 = v5;
  if (v5 && MEMORY[0x1DF0B91F0](v5) == MEMORY[0x1E0C812C8])
  {
    v35 = 0uLL;
    v36 = 0;
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 3321888768;
    v32 = ___ZN12SafeBrowsingL15requestsFromXPCEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
    v33 = &__block_descriptor_40_ea8_32c82_ZTSKZN12SafeBrowsingL15requestsFromXPCEPU24objcproto13OS_xpc_object8NSObjectE3__0_e36_B24__0Q8__NSObject_OS_xpc_object__16l;
    v34 = &v35;
    if (xpc_array_apply(v6, &buf))
    {
      v28 = v35;
      v29 = v36;
      v36 = 0;
      v35 = 0uLL;
      v7 = 1;
    }
    else
    {
      v7 = 0;
      LOBYTE(v28) = 0;
    }
    v30 = v7;
    v37 = (void **)&v35;
    std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v37);
  }
  else
  {
    LOBYTE(v28) = 0;
    v30 = 0;
  }

  if (v30)
  {
    reply = xpc_dictionary_create_reply(v3);
    xpc_dictionary_get_remote_connection(v3);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    if (!*(_QWORD *)(a1 + 496))
    {
      std::allocate_shared[abi:sn180100]<Backend::Google::FullHashChecker,std::allocator<Backend::Google::FullHashChecker>,Backend::Google::Configuration &,void>((const Backend::Google::Configuration *)(a1 + 24), &buf);
      std::shared_ptr<ByteProvider>::operator=[abi:sn180100](a1 + 496, &buf);
      v23 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
      if (*((_QWORD *)&buf + 1))
      {
        v24 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
    }
    v10 = [ProxyConfiguration alloc];
    Backend::Google::DeviceIdentificationTokenFetcher::getCurrentDeviceIdentificationToken(*(id **)(a1 + 256));
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = -[ProxyConfiguration initWithDeviceIdentificationToken:](v10, "initWithDeviceIdentificationToken:", v11);

    v13 = *(_QWORD **)(a1 + 496);
    v26 = v28;
    v27 = v29;
    v29 = 0;
    v28 = 0uLL;
    v14 = *(void **)(a1 + 8);
    v15 = xpc_dictionary_get_BOOL(v3, "allowGoogle");
    v16 = v9;
    v17 = reply;
    v38[0] = off_1EA3E9EB8;
    v38[1] = v16;
    v38[2] = v17;
    v39 = v38;
    Backend::Google::FullHashChecker::checkHashes(v13, (uint64_t)&v26, v16, v12, v14, v15, (uint64_t)v38);
    v20 = v39;
    if (v39 == v38)
    {
      v21 = 4;
      v20 = v38;
    }
    else
    {
      if (!v39)
      {
LABEL_25:
        *(_QWORD *)&buf = &v26;
        std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)&buf);

        goto LABEL_26;
      }
      v21 = 5;
    }
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v20 + 8 * v21))(v20, v18, v19);
    goto LABEL_25;
  }
  v22 = SSBOSLogFullHash();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_1DBCBE000, v22, OS_LOG_TYPE_INFO, "Cancel xpc connection because there are no requests", (uint8_t *)&buf, 2u);
  }
  xpc_dictionary_get_remote_connection(v3);
  v17 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
  xpc_connection_cancel(v17);
LABEL_26:

  if (v30)
  {
    *(_QWORD *)&buf = &v28;
    std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)&buf);
  }

}

void sub_1DBD01240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, void **a17)
{
  void *v17;
  void *v18;
  void *v19;

  if (a16)
  {
    a17 = (void **)&a13;
    std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&a17);
  }

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleForceLoadRemoteConfigurationFromDisk(uint64_t a1, void *a2)
{
  void *v2;
  char v3;
  xpc_object_t reply;
  _xpc_connection_s *v5;
  xpc_object_t original;

  original = a2;
  +[RemoteConfigurationController sharedController](RemoteConfigurationController, "sharedController");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "forceLoadConfigurationFromDisk");

  reply = xpc_dictionary_create_reply(original);
  xpc_dictionary_set_BOOL(reply, "loadRemoteConfigurationState", v3);
  xpc_dictionary_get_remote_connection(original);
  v5 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
  xpc_connection_send_message(v5, reply);

}

void sub_1DBD013B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleForceUpdateRemoteConfigurationFromServer(uint64_t a1, void *a2)
{
  void *v2;
  char v3;
  xpc_object_t reply;
  _xpc_connection_s *v5;
  xpc_object_t original;

  original = a2;
  +[RemoteConfigurationController sharedController](RemoteConfigurationController, "sharedController");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "forceUpdateConfigurationFromServer");

  reply = xpc_dictionary_create_reply(original);
  xpc_dictionary_set_BOOL(reply, "updateRemoteConfigurationState", v3);
  xpc_dictionary_get_remote_connection(original);
  v5 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
  xpc_connection_send_message(v5, reply);

}

void sub_1DBD01478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleDeleteAllDatabases(uint64_t a1, void *a2)
{
  id v2;
  void *v3;
  void **v4;
  void *v5;
  char v6;
  id v7;
  NSObject *v8;
  void *v9;
  NSObject *v10;
  xpc_object_t reply;
  _xpc_connection_s *v12;
  id v13;
  void *__p[2];
  char v15;
  char v16;
  _BYTE v17[24];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = a2;
  SafeBrowsing::Service::databaseBaseDirectory((uint64_t)__p);
  if (v16)
  {
    objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    if (v15 >= 0)
      v4 = __p;
    else
      v4 = (void **)__p[0];
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v4);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = 0;
    v6 = objc_msgSend(v3, "removeItemAtPath:error:", v5, &v13);
    v7 = v13;

    if ((v6 & 1) == 0)
    {
      v8 = (id)SSBOSLogDatabase();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(v7, "ssb_privacyPreservingDescription");
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        SafeBrowsing::Service::handleDeleteAllDatabases(v9, (uint64_t)v17, v8);
      }

    }
  }
  else
  {
    v10 = SSBOSLogDatabase();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      SafeBrowsing::Service::handleDeleteAllDatabases();
    v6 = 0;
  }
  reply = xpc_dictionary_create_reply(v2);
  xpc_dictionary_set_BOOL(reply, "deleteAllDatabasesState", v6);
  xpc_dictionary_get_remote_connection(v2);
  v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
  xpc_connection_send_message(v12, reply);

  if (v16 && v15 < 0)
    operator delete(__p[0]);

}

void sub_1DBD01648(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  void *v17;
  void *v18;
  void *v19;

  if (a17)
  {
    if (a16 < 0)
      operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleClientInUse(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  _BOOL8 v5;
  NSObject *v6;
  NSObject *v7;
  std::chrono::system_clock::time_point v8;
  _QWORD v9[4];
  id v10;
  uint64_t v11;
  uint8_t buf[16];

  v3 = a2;
  v4 = SSBOSLogDatabase();
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_INFO);
  if (v5)
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1DBCBE000, v4, OS_LOG_TYPE_INFO, "Received ClientInUse message", buf, 2u);
  }
  if ((SafeBrowsing::Service::isEnabled((SafeBrowsing::Service *)v5) & 1) != 0)
  {
    v7 = *(NSObject **)(a1 + 8);
    v6 = *(NSObject **)(a1 + 16);
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = ___ZN12SafeBrowsing7Service17handleClientInUseEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
    v9[3] = &unk_1EA3EC480;
    v11 = a1;
    v10 = v3;
    dispatch_group_notify(v6, v7, v9);

  }
  else
  {
    v8.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    SafeBrowsing::Service::sendClientInUseReply(v8.__d_.__rep_, v3, v8.__d_.__rep_ + 3600000000);
  }

}

void sub_1DBD017C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleFetchCellularDataPlan(uint64_t a1, void *a2)
{
  void *v3;
  xpc_object_t reply;
  _xpc_connection_s *v5;
  xpc_object_t original;

  original = a2;
  objc_msgSend(*(id *)(a1 + 144), "fetchCellularDataPlanSynchronously");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  reply = xpc_dictionary_create_reply(original);
  if (objc_msgSend(v3, "length"))
    xpc_dictionary_set_string(reply, "cellularDataPlan", (const char *)objc_msgSend(objc_retainAutorelease(v3), "UTF8String"));
  xpc_dictionary_get_remote_connection(original);
  v5 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
  xpc_connection_send_message(v5, reply);

}

void sub_1DBD01880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v13 = v12;

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::handleGetSafeBrowsingEnabledState(uint64_t a1, void *a2)
{
  SafeBrowsing::Service *reply;
  char isEnabled;
  _xpc_connection_s *v4;
  xpc_object_t xdict;

  xdict = a2;
  reply = (SafeBrowsing::Service *)xpc_dictionary_create_reply(xdict);
  isEnabled = SafeBrowsing::Service::isEnabled(reply);
  xpc_dictionary_set_BOOL(reply, "safeBrowsingEnabled", isEnabled);
  xpc_dictionary_get_remote_connection(xdict);
  v4 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
  xpc_connection_send_message(v4, reply);

}

void sub_1DBD0192C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing7Service25handleForceDatabaseUpdateEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v1;
  ProxyConfiguration *v2;
  void *v3;
  ProxyConfiguration *v4;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = [ProxyConfiguration alloc];
  Backend::Google::DeviceIdentificationTokenFetcher::getCurrentDeviceIdentificationToken(*(id **)(v1 + 256));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = -[ProxyConfiguration initWithDeviceIdentificationToken:](v2, "initWithDeviceIdentificationToken:", v3);

  Backend::Google::DatabaseUpdater::update(*(_QWORD **)(v1 + 192), 2, v4);
}

void sub_1DBD019D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::sendGetDatabasesReply(_QWORD *a1, void *a2, int a3)
{
  id v5;
  xpc_object_t v6;
  _xpc_connection_s *v7;
  _BOOL8 v8;
  const Backend::Google::DatabaseInfo *v9;
  SafeBrowsing *v10;
  SafeBrowsing *v11;
  void *v12;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  const Backend::Google::DatabaseInfo *v14;
  SafeBrowsing *v15;
  SafeBrowsing *v16;
  void *v17;
  const Backend::Google::DatabaseInfo *v18;
  SafeBrowsing *v19;
  SafeBrowsing *v20;
  void *v21;
  xpc_object_t reply;
  NSObject *v23;
  _DWORD v24[2];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = xpc_array_create(0, 0);
  xpc_dictionary_get_remote_connection(v5);
  v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
  if (a3 == 1)
  {
    v8 = xpc_dictionary_get_BOOL(v5, "allowGoogle");
    if (v8)
    {
      v10 = (SafeBrowsing *)a1[26];
      v11 = (SafeBrowsing *)a1[27];
      while (v10 != v11)
      {
        SafeBrowsing::databaseDictionary(v10, v9);
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        xpc_array_append_value(v6, v12);

        v10 = (SafeBrowsing *)((char *)v10 + 112);
      }
    }
    shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent((Backend::Google::SSBUtilities *)v8);
    if ((_DWORD)shouldConsultWithTencent)
    {
      v15 = (SafeBrowsing *)a1[39];
      v16 = (SafeBrowsing *)a1[40];
      while (v15 != v16)
      {
        SafeBrowsing::databaseDictionary(v15, v14);
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        xpc_array_append_value(v6, v17);

        v15 = (SafeBrowsing *)((char *)v15 + 112);
      }
    }
    if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
    {
      v19 = (SafeBrowsing *)a1[52];
      v20 = (SafeBrowsing *)a1[53];
      while (v19 != v20)
      {
        SafeBrowsing::databaseDictionary(v19, v18);
        v21 = (void *)objc_claimAutoreleasedReturnValue();
        xpc_array_append_value(v6, v21);

        v19 = (SafeBrowsing *)((char *)v19 + 112);
      }
    }
  }
  reply = xpc_dictionary_create_reply(v5);
  xpc_dictionary_set_value(reply, "databases", v6);
  v23 = SSBOSLogDatabase();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    v24[0] = 67109120;
    v24[1] = a3;
    _os_log_impl(&dword_1DBCBE000, v23, OS_LOG_TYPE_INFO, "Send GetDatabases reply with protection type %d", (uint8_t *)v24, 8u);
  }
  xpc_connection_send_message(v7, reply);

}

void sub_1DBD01BD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

BOOL SafeBrowsing::Service::xpcConnectionClientFromConnection()
{
  uint64_t v0;
  void *v1;
  _BOOL8 v2;
  const char *string_ptr;

  v0 = xpc_connection_copy_entitlement_value();
  v1 = (void *)v0;
  v2 = 0;
  if (v0)
  {
    if (MEMORY[0x1DF0B91F0](v0) == MEMORY[0x1E0C81390])
    {
      string_ptr = xpc_string_get_string_ptr(v1);
      if (!strcmp(string_ptr, "com.apple.mobilesafari") || !strcmp(string_ptr, "com.apple.ssbutil"))
        v2 = 1;
    }
  }

  return v2;
}

void sub_1DBD01CC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id SafeBrowsing::databaseDictionary(SafeBrowsing *this, const Backend::Google::DatabaseInfo *a2)
{
  xpc_object_t v3;
  void **v4;
  void *v5;
  uint64_t v6;
  xpc_object_t v7;
  void *__p[2];
  char v10;

  v3 = xpc_dictionary_create(0, 0, 0);
  Backend::Google::ThreatListDescriptor::toString(this, __p);
  if (v10 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  xpc_dictionary_set_string(v3, "name", (const char *)v4);
  if (v10 < 0)
    operator delete(__p[0]);
  Backend::Google::ThreatListDescriptor::toXPC(this);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  xpc_dictionary_set_value(v3, "threatListDescriptor", v5);

  v6 = *((_QWORD *)this + 2);
  if (v6)
  {
    v7 = xpc_shmem_create(*(void **)v6, *(_QWORD *)(v6 + 8));
    xpc_dictionary_set_value(v3, "shmem", v7);

  }
  return v3;
}

void sub_1DBD01DB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void SafeBrowsing::Service::sendClientInUseReply(uint64_t a1, void *a2, uint64_t a3)
{
  id v4;
  xpc_object_t reply;
  _xpc_connection_s *v6;
  NSObject *v7;
  uint8_t v8[16];

  v4 = a2;
  reply = xpc_dictionary_create_reply(v4);
  xpc_dictionary_set_int64(reply, "nextMessageTime", a3 / 1000000);
  xpc_dictionary_get_remote_connection(v4);
  v6 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
  v7 = SSBOSLogDatabase();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v8 = 0;
    _os_log_impl(&dword_1DBCBE000, v7, OS_LOG_TYPE_INFO, "Send ClientInUse reply", v8, 2u);
  }
  xpc_connection_send_message(v6, reply);

}

void sub_1DBD01EBC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing7Service17handleClientInUseEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  SafeBrowsing::Service::checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUse(*(_QWORD *)(a1 + 40), *(void **)(a1 + 32), "com.apple.Safari.SafeBrowsing.BrowsingDatabases.Update");
}

void SafeBrowsing::Service::checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUse(uint64_t a1, void *a2, const char *a3)
{
  Backend::Google::SSBUtilities *v5;
  int v6;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep PollingTimeAndDatabaseConfiguration;
  uint64_t v12;
  uint64_t v13;
  std::chrono::system_clock::time_point v14;
  void *v15;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  char *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  int64x2_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  char *v40;
  char *v41;
  _QWORD *v42;
  _QWORD *v43;
  uint64_t v44;
  int64x2_t v45;
  uint64_t v46;
  _QWORD handler[6];
  uint64_t v48;
  int64x2_t v49;
  uint64_t v50;
  uint64_t v51;

  v5 = a2;
  v6 = *(_DWORD *)(*(_QWORD *)(a1 + 192) + 240);
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(v5);
  if ((_DWORD)shouldConsultWithTencent)
    v6 = (*(_DWORD *)(*(_QWORD *)(a1 + 296) + 240) | v6) != 0;
  if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
    v6 |= *(_DWORD *)(*(_QWORD *)(a1 + 400) + 240);
  if (!v6)
  {
    PollingTimeAndDatabaseConfiguration = SafeBrowsing::Service::nextPollingTimeAndDatabaseConfiguration((__int128 **)a1);
    v13 = v12;
    v14.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    if (PollingTimeAndDatabaseConfiguration >= v14.__d_.__rep_)
    {
      SafeBrowsing::Service::sendClientInUseReply(v14.__d_.__rep_, v5, PollingTimeAndDatabaseConfiguration);
LABEL_42:

      return;
    }
    v15 = (void *)*MEMORY[0x1E0C80748];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3321888768;
    handler[2] = ___ZN12SafeBrowsing7Service58checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUseEPU24objcproto13OS_xpc_object8NSObjectPKcN7Backend6Google14ProtectionTypeE_block_invoke;
    handler[3] = &__block_descriptor_48_ea8_32c168_ZTSKZN12SafeBrowsing7Service58checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUseEPU24objcproto13OS_xpc_object8NSObjectPKcN7Backend6Google14ProtectionTypeEE3__0_e33_v16__0__NSObject_OS_xpc_object__8l;
    handler[4] = v13;
    handler[5] = a1;
    xpc_activity_register(a3, v15, handler);
    v16 = *(_QWORD **)(a1 + 520);
    v17 = *(_QWORD *)(a1 + 528);
    if ((unint64_t)v16 >= v17)
    {
      v33 = *(_QWORD *)(a1 + 512);
      v34 = ((uint64_t)v16 - v33) >> 3;
      if ((unint64_t)(v34 + 1) >> 61)
        abort();
      v35 = v17 - v33;
      v36 = v35 >> 2;
      if (v35 >> 2 <= (unint64_t)(v34 + 1))
        v36 = v34 + 1;
      if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
        v37 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v37 = v36;
      v51 = a1 + 528;
      if (!v37)
        goto LABEL_45;
      v38 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>(a1 + 528, v37);
      if (!v38)
        goto LABEL_45;
      v40 = &v38[8 * v39];
      v41 = &v38[8 * v34];
      *(_QWORD *)v41 = v5;
      v18 = v41 + 8;
      v42 = *(_QWORD **)(a1 + 520);
      v43 = *(_QWORD **)(a1 + 512);
      if (v42 == v43)
      {
        v45 = vdupq_n_s64((unint64_t)v42);
      }
      else
      {
        do
        {
          v44 = *--v42;
          *v42 = 0;
          *((_QWORD *)v41 - 1) = v44;
          v41 -= 8;
        }
        while (v42 != v43);
        v45 = *(int64x2_t *)(a1 + 512);
      }
      *(_QWORD *)(a1 + 512) = v41;
      *(_QWORD *)(a1 + 520) = v18;
      v49 = v45;
      v46 = *(_QWORD *)(a1 + 528);
      *(_QWORD *)(a1 + 528) = v40;
      v50 = v46;
      v48 = v45.i64[0];
      std::__split_buffer<NSObject  {objcproto13OS_xpc_object}* {__strong}>::~__split_buffer((uint64_t)&v48);
    }
    else
    {
      if (!v16)
        goto LABEL_45;
      *v16 = v5;
      v18 = v16 + 1;
    }
    *(_QWORD *)(a1 + 520) = v18;
    goto LABEL_42;
  }
  v8 = *(_QWORD *)(a1 + 168);
  v9 = *(_QWORD **)(a1 + 160);
  if ((unint64_t)v9 >= v8)
  {
    v19 = *(_QWORD *)(a1 + 152);
    v20 = ((uint64_t)v9 - v19) >> 3;
    if ((unint64_t)(v20 + 1) >> 61)
      abort();
    v21 = v8 - v19;
    v22 = v21 >> 2;
    if (v21 >> 2 <= (unint64_t)(v20 + 1))
      v22 = v20 + 1;
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
      v23 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v23 = v22;
    v51 = a1 + 168;
    if (v23)
    {
      v24 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>(a1 + 168, v23);
      if (v24)
      {
        v26 = &v24[8 * v25];
        v27 = &v24[8 * v20];
        *(_QWORD *)v27 = v5;
        v10 = v27 + 8;
        v29 = *(_QWORD **)(a1 + 152);
        v28 = *(_QWORD **)(a1 + 160);
        if (v28 == v29)
        {
          v31 = vdupq_n_s64((unint64_t)v28);
        }
        else
        {
          do
          {
            v30 = *--v28;
            *v28 = 0;
            *((_QWORD *)v27 - 1) = v30;
            v27 -= 8;
          }
          while (v28 != v29);
          v31 = *(int64x2_t *)(a1 + 152);
        }
        *(_QWORD *)(a1 + 152) = v27;
        *(_QWORD *)(a1 + 160) = v10;
        v49 = v31;
        v32 = *(_QWORD *)(a1 + 168);
        *(_QWORD *)(a1 + 168) = v26;
        v50 = v32;
        v48 = v31.i64[0];
        std::__split_buffer<NSObject  {objcproto13OS_xpc_object}* {__strong}>::~__split_buffer((uint64_t)&v48);
        goto LABEL_27;
      }
    }
  }
  else if (v9)
  {
    *v9 = v5;
    v10 = v9 + 1;
LABEL_27:
    *(_QWORD *)(a1 + 160) = v10;
    goto LABEL_42;
  }
LABEL_45:
  __break(1u);
}

void sub_1DBD021B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN12SafeBrowsing7Service58checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUseEPU24objcproto13OS_xpc_object8NSObjectPKcN7Backend6Google14ProtectionTypeE_block_invoke(uint64_t a1, void *a2)
{
  _xpc_activity_s *v3;
  uint64_t v4;
  xpc_activity_state_t state;
  xpc_activity_state_t v6;
  NSObject *v7;
  NSObject *v8;
  _xpc_activity_s *v9;
  uint64_t v10;
  xpc_object_t v11;
  void *v12;
  void *v13;
  NSObject *v14;
  __int128 v15;
  void (*v16)(uint64_t);
  void *v17;
  _xpc_activity_s *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 40);
  state = xpc_activity_get_state(v3);
  v6 = state;
  if (state)
  {
    if (state == 2)
    {
      if (!xpc_activity_set_state(v3, 4))
      {
        v7 = SSBOSLogService();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          ___ZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKc_block_invoke_cold_1();
      }
      v8 = *(NSObject **)(v4 + 8);
      *(_QWORD *)&v15 = MEMORY[0x1E0C809B0];
      *((_QWORD *)&v15 + 1) = 3321888768;
      v16 = ___ZZN12SafeBrowsing7Service58checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUseEPU24objcproto13OS_xpc_object8NSObjectPKcN7Backend6Google14ProtectionTypeEENK3__0clES3__block_invoke;
      v17 = &__block_descriptor_56_ea8_32c183_ZTSKZZN12SafeBrowsing7Service58checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUseEPU24objcproto13OS_xpc_object8NSObjectPKcN7Backend6Google14ProtectionTypeEENK3__0clES3_EUlvE__e5_v8__0l;
      v9 = v3;
      v10 = *(_QWORD *)(a1 + 32);
      v18 = v9;
      v19 = v10;
      v20 = v4;
      dispatch_async(v8, &v15);

    }
    else
    {
      v14 = SSBOSLogService();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v15) = 134217984;
        *(_QWORD *)((char *)&v15 + 4) = v6;
        _os_log_impl(&dword_1DBCBE000, v14, OS_LOG_TYPE_DEFAULT, "Unhandled activity state %li", (uint8_t *)&v15, 0xCu);
      }
    }
  }
  else
  {
    v11 = xpc_activity_copy_criteria(v3);
    v12 = v11;
    if (!v11 || !xpc_dictionary_get_BOOL(v11, (const char *)*MEMORY[0x1E0C80738]))
    {
      SafeBrowsing::createActivityCriteria(0, 1);
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      xpc_activity_set_criteria(v3, v13);

    }
  }

}

void sub_1DBD02370(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c168_ZTSKZN12SafeBrowsing7Service58checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUseEPU24objcproto13OS_xpc_object8NSObjectPKcN7Backend6Google14ProtectionTypeEE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[2] = result;
  return result;
}

void SafeBrowsing::Service::~Service(SafeBrowsing::Service *this)
{
  void *v1;

  SafeBrowsing::Service::~Service(this);
  operator delete(v1);
}

{
  void **v2;

  *(_QWORD *)this = off_1EA3EAE38;
  v2 = (void **)((char *)this + 512);
  std::vector<NSObject  {objcproto13OS_xpc_object}* {__strong}>::__destroy_vector::operator()[abi:sn180100](&v2);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 496);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 464);
  v2 = (void **)((char *)this + 440);
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&v2);
  v2 = (void **)((char *)this + 416);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v2);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 400);
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 49, 0);
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 48, 0);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 360);
  v2 = (void **)((char *)this + 336);
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&v2);
  v2 = (void **)((char *)this + 312);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v2);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 296);
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 36, 0);
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 35, 0);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 256);
  v2 = (void **)((char *)this + 232);
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&v2);
  v2 = (void **)((char *)this + 208);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v2);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)this + 192);
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 23, 0);
  std::unique_ptr<Platform::Transaction>::reset[abi:sn180100]((Platform::Transaction **)this + 22, 0);
  v2 = (void **)((char *)this + 152);
  std::vector<NSObject  {objcproto13OS_xpc_object}* {__strong}>::__destroy_vector::operator()[abi:sn180100](&v2);

  std::__tree<NSObject  {objcproto13OS_xpc_object}* {__strong}>::destroy((uint64_t)this + 120, *((_QWORD **)this + 16));
  Backend::Google::Configuration::~Configuration((SafeBrowsing::Service *)((char *)this + 24));

}

void std::vector<NSObject  {objcproto13OS_xpc_object}* {__strong}>::__destroy_vector::operator()[abi:sn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 1);
        v4 -= 8;

      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<Backend::Google::DatabaseInfo>::__vdeallocate(void **a1)
{
  char *v1;
  char *v3;
  void *v4;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = v1;
    if (v3 != v1)
    {
      do
        Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)(v3 - 112));
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void ___ZZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKcENK3__0clEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  SafeBrowsing::Service::runUpdateActivityOperations(*(_QWORD *)(a1 + 48), *(void **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

__n128 __copy_helper_block_ea8_32c120_ZTSKZZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKcENK3__0clEPU24objcproto13OS_xpc_object8NSObjectEUlvE_(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)(a1 + 32) = *(id *)(a2 + 32);
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_ea8_32c120_ZTSKZZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKcENK3__0clEPU24objcproto13OS_xpc_object8NSObjectEUlvE_(uint64_t a1)
{

}

void ___ZZN12SafeBrowsing7Service22registerUpdateActivityEPKcENK3__0clEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  SafeBrowsing::Service::runUpdateActivityOperations(*(_QWORD *)(a1 + 48), *(void **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

__n128 __copy_helper_block_ea8_32c111_ZTSKZZN12SafeBrowsing7Service22registerUpdateActivityEPKcENK3__0clEPU24objcproto13OS_xpc_object8NSObjectEUlvE_(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)(a1 + 32) = *(id *)(a2 + 32);
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_ea8_32c111_ZTSKZZN12SafeBrowsing7Service22registerUpdateActivityEPKcENK3__0clEPU24objcproto13OS_xpc_object8NSObjectEUlvE_(uint64_t a1)
{

}

void ___ZZN12SafeBrowsing7Service41registerDatabaseLoadingDispatchGroupBlockEvENK3__0clEv_block_invoke(uint64_t a1)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void *v4;
  void **i;
  void *v6;

  v1 = *(_QWORD **)(a1 + 32);
  v2 = (void **)v1[19];
  v3 = (void **)v1[20];
  if (v2 != v3)
  {
    do
    {
      v4 = *v2++;
      SafeBrowsing::Service::sendGetDatabasesReply(v1, v4, 1);
    }
    while (v2 != v3);
    v2 = (void **)v1[19];
    for (i = (void **)v1[20]; i != v2; --i)
    {
      v6 = *(i - 1);

    }
  }
  v1[20] = v2;
}

void ___ZZN12SafeBrowsing7Service4mainEvENK3__0clEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  SafeBrowsing::Service::handleNewConnection(*(_QWORD *)(a1 + 40), *(void **)(a1 + 32));
}

id __copy_helper_block_ea8_32c90_ZTSKZZN12SafeBrowsing7Service4mainEvENK3__0clEPU24objcproto13OS_xpc_object8NSObjectEUlvE_(uint64_t a1, uint64_t a2)
{
  id result;
  uint64_t v5;

  result = *(id *)(a2 + 32);
  v5 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = result;
  *(_QWORD *)(a1 + 40) = v5;
  return result;
}

void __destroy_helper_block_ea8_32c90_ZTSKZZN12SafeBrowsing7Service4mainEvENK3__0clEPU24objcproto13OS_xpc_object8NSObjectEUlvE_(uint64_t a1)
{

}

void ___ZZN12SafeBrowsing7Service19handleNewConnectionEPU24objcproto13OS_xpc_object8NSObjectENK3__0clES3__block_invoke(uint64_t a1)
{
  SafeBrowsing::Service::handleConnectionEvent(*(_QWORD **)(a1 + 32), *(void **)(a1 + 40), *(void **)(a1 + 48));
}

id __copy_helper_block_ea8_32c108_ZTSKZZN12SafeBrowsing7Service19handleNewConnectionEPU24objcproto13OS_xpc_object8NSObjectENK3__0clES3_EUlvE_(_QWORD *a1, uint64_t a2)
{
  void *v4;
  id result;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v4 = *(void **)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v4;
  result = *(id *)(a2 + 48);
  v7 = *(_QWORD *)(a2 + 56);
  v6 = *(_QWORD *)(a2 + 64);
  a1[6] = result;
  a1[7] = v7;
  a1[8] = v6;
  if (v6)
  {
    v8 = (unint64_t *)(v6 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  return result;
}

void __destroy_helper_block_ea8_32c108_ZTSKZZN12SafeBrowsing7Service19handleNewConnectionEPU24objcproto13OS_xpc_object8NSObjectENK3__0clES3_EUlvE_(uint64_t a1)
{
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 56);

}

_QWORD *std::allocate_shared[abi:sn180100]<Platform::Transaction,std::allocator<Platform::Transaction>,char const(&)[17],void>@<X0>(char *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x30uLL);
  result = std::__shared_ptr_emplace<Platform::Transaction>::__shared_ptr_emplace[abi:sn180100]<char const(&)[17],std::allocator<Platform::Transaction>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1DBD026C4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<Platform::Transaction>::__shared_ptr_emplace[abi:sn180100]<char const(&)[17],std::allocator<Platform::Transaction>,0>(_QWORD *a1, char *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1EA3EBAE0;
  std::construct_at[abi:sn180100]<Platform::Transaction,char const(&)[17],Platform::Transaction*>((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1DBD0270C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Platform::Transaction>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBAE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Platform::Transaction>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBAE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<Platform::Transaction>::__on_zero_shared(uint64_t a1)
{
  Platform::Transaction::~Transaction((Platform::Transaction *)(a1 + 24));
}

uint64_t std::construct_at[abi:sn180100]<Platform::Transaction,char const(&)[17],Platform::Transaction*>(uint64_t result, char *a2)
{
  uint64_t v2;
  void *__p[2];
  char v4;

  if (result)
  {
    v2 = result;
    std::string::basic_string[abi:sn180100]<0>((char **)__p, a2);
    Platform::Transaction::Transaction(v2, __p);
    if (v4 < 0)
      operator delete(__p[0]);
    return v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_1DBD027B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<NSObject  {objcproto13OS_xpc_object}* {__strong}>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;

  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

BOOL ___ZN12SafeBrowsingL15requestsFromXPCEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _BYTE v10[72];
  unsigned __int8 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  Backend::Google::FullHashRequest::fromXPC(v4, (uint64_t)v10);
  v5 = v11;
  if (v11)
  {
    v6 = *(_QWORD *)(a1 + 32);
    v7 = *(_QWORD *)(v6 + 8);
    if (v7 >= *(_QWORD *)(v6 + 16))
    {
      v8 = std::vector<Backend::Google::FullHashRequest>::__push_back_slow_path<Backend::Google::FullHashRequest>(v6, (const Backend::Google::FullHashRequest *)v10);
    }
    else
    {
      if (!v7)
        __break(1u);
      Backend::Google::FullHashRequest::FullHashRequest(*(Backend::Google::FullHashRequest **)(v6 + 8), (const Backend::Google::FullHashRequest *)v10);
      v8 = v7 + 72;
      *(_QWORD *)(v6 + 8) = v7 + 72;
    }
    *(_QWORD *)(v6 + 8) = v8;
    if (v11)
      Backend::Google::FullHashRequest::~FullHashRequest((Backend::Google::FullHashRequest *)v10);
  }

  return v5 != 0;
}

void sub_1DBD028F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  void *v19;

  if (a19)
    Backend::Google::FullHashRequest::~FullHashRequest((Backend::Google::FullHashRequest *)&a10);

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c82_ZTSKZN12SafeBrowsingL15requestsFromXPCEPU24objcproto13OS_xpc_object8NSObjectE3__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void ___ZZN12SafeBrowsing7Service58checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUseEPU24objcproto13OS_xpc_object8NSObjectPKcN7Backend6Google14ProtectionTypeEENK3__0clES3__block_invoke(uint64_t a1)
{
  SafeBrowsing::Service::runUpdateActivityOperations(*(_QWORD *)(a1 + 48), *(void **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

__n128 __copy_helper_block_ea8_32c183_ZTSKZZN12SafeBrowsing7Service58checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUseEPU24objcproto13OS_xpc_object8NSObjectPKcN7Backend6Google14ProtectionTypeEENK3__0clES3_EUlvE_(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)(a1 + 32) = *(id *)(a2 + 32);
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_ea8_32c183_ZTSKZZN12SafeBrowsing7Service58checkInOrRegisterUpdateActivityIfNecessaryDueToClientInUseEPU24objcproto13OS_xpc_object8NSObjectPKcN7Backend6Google14ProtectionTypeEENK3__0clES3_EUlvE_(uint64_t a1)
{

}

void std::__tree<NSObject  {objcproto13OS_xpc_object}* {__strong}>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<NSObject  {objcproto13OS_xpc_object}* {__strong}>::destroy(a1, *a2);
    std::__tree<NSObject  {objcproto13OS_xpc_object}* {__strong}>::destroy(a1, a2[1]);

    operator delete(a2);
  }
}

std::once_flag::_State_type *Platform::OnceConstructedNeverDestroyed<SafeBrowsing::Service>::OnceConstructedNeverDestroyed(std::once_flag::_State_type *a1)
{
  unint64_t v2;
  std::once_flag::_State_type *v4;
  std::once_flag::_State_type ***v5;
  std::once_flag::_State_type **v6;

  *a1 = 0;
  v4 = a1;
  v2 = atomic_load(a1);
  if (v2 != -1)
  {
    v6 = &v4;
    v5 = &v6;
    std::__call_once(a1, &v5, (void (__cdecl *)(void *))std::__call_once_proxy[abi:sn180100]<std::tuple<Platform::OnceConstructedNeverDestroyed<SafeBrowsing::Service>::OnceConstructedNeverDestroyed(void)::{lambda(void)#1} &&>>);
  }
  return a1;
}

SafeBrowsing::Service *std::__call_once_proxy[abi:sn180100]<std::tuple<Platform::OnceConstructedNeverDestroyed<SafeBrowsing::Service>::OnceConstructedNeverDestroyed(void)::{lambda(void)#1} &&>>(uint64_t a1)
{
  return SafeBrowsing::Service::Service((SafeBrowsing::Service *)(***(_QWORD ***)a1 + 8));
}

void std::allocate_shared[abi:sn180100]<Backend::Google::DeviceIdentificationTokenFetcher,std::allocator<Backend::Google::DeviceIdentificationTokenFetcher>,Backend::Google::Configuration &,Backend::Google::SafeBrowsingProvider &,void>(uint64_t a1@<X1>, unsigned int *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;

  v6 = operator new(0xE8uLL);
  std::__shared_ptr_emplace<Backend::Google::DeviceIdentificationTokenFetcher>::__shared_ptr_emplace[abi:sn180100]<Backend::Google::Configuration &,Backend::Google::SafeBrowsingProvider &,std::allocator<Backend::Google::DeviceIdentificationTokenFetcher>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<ByteProvider>::__enable_weak_this[abi:sn180100]<ByteProvider,ByteProvider,void>((uint64_t)a3, v6 + 3, (uint64_t)(v6 + 3));
}

void sub_1DBD02C14(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<Backend::Google::DeviceIdentificationTokenFetcher>::__shared_ptr_emplace[abi:sn180100]<Backend::Google::Configuration &,Backend::Google::SafeBrowsingProvider &,std::allocator<Backend::Google::DeviceIdentificationTokenFetcher>,0>(_QWORD *a1, uint64_t a2, unsigned int *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1EA3EBAA8;
  Backend::Google::DeviceIdentificationTokenFetcher::DeviceIdentificationTokenFetcher(a1 + 3, a2, *a3);
  return a1;
}

void sub_1DBD02C60(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Backend::Google::DeviceIdentificationTokenFetcher>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBAA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Backend::Google::DeviceIdentificationTokenFetcher>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBAA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<Backend::Google::DeviceIdentificationTokenFetcher>::__on_zero_shared(uint64_t a1)
{
  Backend::Google::DeviceIdentificationTokenFetcher::~DeviceIdentificationTokenFetcher((Backend::Google::DeviceIdentificationTokenFetcher *)(a1 + 24));
}

void std::allocate_shared[abi:sn180100]<Backend::Google::DatabaseUpdater,std::allocator<Backend::Google::DatabaseUpdater>,SafeBrowsing::Service &,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::Configuration &,std::string const,std::vector<Backend::Google::ThreatListDescriptor>,Backend::Google::DatabaseConfiguration &,void>(uint64_t a1@<X1>, uint64_t *a2@<X2>, Backend::Google::Configuration *a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, _QWORD *a6@<X6>, _QWORD *a7@<X8>)
{
  _QWORD *v14;

  v14 = operator new(0x120uLL);
  std::__shared_ptr_emplace<Backend::Google::DatabaseUpdater>::__shared_ptr_emplace[abi:sn180100]<SafeBrowsing::Service &,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::Configuration &,std::string const,std::vector<Backend::Google::ThreatListDescriptor>,Backend::Google::DatabaseConfiguration &,std::allocator<Backend::Google::DatabaseUpdater>,0>(v14, a1, a2, a3, a4, a5, a6);
  *a7 = v14 + 3;
  a7[1] = v14;
  std::shared_ptr<ByteProvider>::__enable_weak_this[abi:sn180100]<ByteProvider,ByteProvider,void>((uint64_t)a7, v14 + 3, (uint64_t)(v14 + 3));
}

void sub_1DBD02D34(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<Backend::Google::DatabaseUpdater>::__shared_ptr_emplace[abi:sn180100]<SafeBrowsing::Service &,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::Configuration &,std::string const,std::vector<Backend::Google::ThreatListDescriptor>,Backend::Google::DatabaseConfiguration &,std::allocator<Backend::Google::DatabaseUpdater>,0>(_QWORD *a1, uint64_t a2, uint64_t *a3, Backend::Google::Configuration *a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1EA3EB990;
  std::construct_at[abi:sn180100]<Backend::Google::DatabaseUpdater,SafeBrowsing::Service &,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::Configuration &,std::string const,std::vector<Backend::Google::ThreatListDescriptor>,Backend::Google::DatabaseConfiguration &,Backend::Google::DatabaseUpdater*>((uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7);
  return a1;
}

void sub_1DBD02D7C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Backend::Google::DatabaseUpdater>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB990;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Backend::Google::DatabaseUpdater>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB990;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<Backend::Google::DatabaseUpdater>::__on_zero_shared(uint64_t a1)
{
  Backend::Google::DatabaseUpdater::~DatabaseUpdater((Backend::Google::DatabaseUpdater *)(a1 + 24));
}

uint64_t std::construct_at[abi:sn180100]<Backend::Google::DatabaseUpdater,SafeBrowsing::Service &,NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,Backend::Google::Configuration &,std::string const,std::vector<Backend::Google::ThreatListDescriptor>,Backend::Google::DatabaseConfiguration &,Backend::Google::DatabaseUpdater*>(uint64_t result, uint64_t a2, uint64_t *a3, Backend::Google::Configuration *a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v11;
  uint64_t v12;
  std::string __p;
  std::string v14;

  if (result)
  {
    v11 = result;
    v12 = *a3;
    Backend::Google::Configuration::Configuration(&v14, a4);
    if (*(char *)(a5 + 23) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a5, *(_QWORD *)(a5 + 8));
    else
      __p = *(std::string *)a5;
    Backend::Google::DatabaseUpdater::DatabaseUpdater(v11, a2, v12, &v14, &__p, a6, *a7);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    Backend::Google::Configuration::~Configuration((Backend::Google::Configuration *)&v14);
    return v11;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_1DBD02E8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  Backend::Google::Configuration::~Configuration((Backend::Google::Configuration *)&a15);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA3E9F00;
  if (*(_BYTE *)(a1 + 40) && *(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0>,void ()(void)>::~__func(void **__p)
{
  *__p = &off_1EA3E9F00;
  if (*((_BYTE *)__p + 40) && *((char *)__p + 39) < 0)
    operator delete(__p[2]);
  operator delete(__p);
}

char *std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  uint64_t v3;

  v2 = (char *)operator new(0x30uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)v2 = &off_1EA3E9F00;
  *((_QWORD *)v2 + 1) = v3;
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100]((std::string *)(v2 + 16), a1 + 16);
  return v2;
}

void sub_1DBD02F84(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

std::string *std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_1EA3E9F00;
  *(_QWORD *)(a2 + 8) = v2;
  return std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100]((std::string *)(a2 + 16), a1 + 16);
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40))
  {
    if (*(char *)(a1 + 39) < 0)
      operator delete(*(void **)(a1 + 16));
  }
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0>,void ()(void)>::destroy_deallocate(void **__p)
{
  if (*((_BYTE *)__p + 40) && *((char *)__p + 39) < 0)
    operator delete(__p[2]);
  operator delete(__p);
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_0::operator()(a1 + 8);
}

uint64_t std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA3E9F48;
  if (*(_BYTE *)(a1 + 40) && *(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1>,void ()(void)>::~__func(void **__p)
{
  *__p = &off_1EA3E9F48;
  if (*((_BYTE *)__p + 40) && *((char *)__p + 39) < 0)
    operator delete(__p[2]);
  operator delete(__p);
}

char *std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  uint64_t v3;

  v2 = (char *)operator new(0x30uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)v2 = &off_1EA3E9F48;
  *((_QWORD *)v2 + 1) = v3;
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100]((std::string *)(v2 + 16), a1 + 16);
  return v2;
}

void sub_1DBD030E0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

std::string *std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_1EA3E9F48;
  *(_QWORD *)(a2 + 8) = v2;
  return std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100]((std::string *)(a2 + 16), a1 + 16);
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1>,void ()(void)>::destroy(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40))
  {
    if (*(char *)(a1 + 39) < 0)
      operator delete(*(void **)(a1 + 16));
  }
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1>,void ()(void)>::destroy_deallocate(void **__p)
{
  if (*((_BYTE *)__p + 40) && *((char *)__p + 39) < 0)
    operator delete(__p[2]);
  operator delete(__p);
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_1::operator()(a1 + 8);
}

uint64_t std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2>,void ()(void)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1EA3E9F90;
  if (*(_BYTE *)(a1 + 40) && *(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2>,void ()(void)>::~__func(void **__p)
{
  *__p = &off_1EA3E9F90;
  if (*((_BYTE *)__p + 40) && *((char *)__p + 39) < 0)
    operator delete(__p[2]);
  operator delete(__p);
}

char *std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  uint64_t v3;

  v2 = (char *)operator new(0x30uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)v2 = &off_1EA3E9F90;
  *((_QWORD *)v2 + 1) = v3;
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100]((std::string *)(v2 + 16), a1 + 16);
  return v2;
}

void sub_1DBD0323C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

std::string *std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_1EA3E9F90;
  *(_QWORD *)(a2 + 8) = v2;
  return std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100]((std::string *)(a2 + 16), a1 + 16);
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2>,void ()(void)>::destroy(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40))
  {
    if (*(char *)(a1 + 39) < 0)
      operator delete(*(void **)(a1 + 16));
  }
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2>,void ()(void)>::destroy_deallocate(void **__p)
{
  if (*((_BYTE *)__p + 40) && *((char *)__p + 39) < 0)
    operator delete(__p[2]);
  operator delete(__p);
}

void std::__function::__func<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2,std::allocator<SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2>,void ()(void)>::operator()(uint64_t a1)
{
  SafeBrowsing::Service::remoteConfigurationDidChange(Backend::Google::SafeBrowsingProvider)::$_2::operator()(a1 + 8);
}

uint64_t *std::__tree<NSObject  {objcproto13OS_xpc_object}* {__strong}>::__emplace_unique_key_args<NSObject  {objcproto13OS_xpc_object}* {__strong},NSObject  {objcproto13OS_xpc_object}* const {__strong}&>(uint64_t **a1, unint64_t *a2, id *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = (uint64_t)*a3;
    std::__tree<Backend::Google::HashView>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

uint64_t std::__tree<NSObject  {objcproto13OS_xpc_object}* {__strong}>::__erase_unique<NSObject  {objcproto13OS_xpc_object}* {__strong}>(uint64_t a1, unint64_t *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  BOOL v6;
  _QWORD *v7;

  v2 = *(_QWORD **)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = a1 + 8;
  do
  {
    v5 = v2[4];
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = v2;
    else
      v7 = v2 + 1;
    if (v6)
      v4 = (uint64_t)v2;
    v2 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_QWORD *)(v4 + 32))
    return 0;
  std::__tree<NSObject  {objcproto13OS_xpc_object}* {__strong}>::erase((uint64_t **)a1, v4);
  return 1;
}

uint64_t *std::__tree<NSObject  {objcproto13OS_xpc_object}* {__strong}>::erase(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;

  v3 = std::__tree<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::__map_value_compare<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>,std::less<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>>,true>,std::allocator<std::__value_type<std::pair<Backend::Google::ThreatListDescriptor,Backend::Google::Hash>,Backend::Google::FullHashCache::Value>>>::__remove_node_pointer(a1, (uint64_t *)a2);

  operator delete((void *)a2);
  return v3;
}

void std::allocate_shared[abi:sn180100]<Backend::Google::FullHashChecker,std::allocator<Backend::Google::FullHashChecker>,Backend::Google::Configuration &,void>(const Backend::Google::Configuration *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;

  v4 = operator new(0xB0uLL);
  std::__shared_ptr_emplace<Backend::Google::FullHashChecker>::__shared_ptr_emplace[abi:sn180100]<Backend::Google::Configuration &,std::allocator<Backend::Google::FullHashChecker>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  std::shared_ptr<ByteProvider>::__enable_weak_this[abi:sn180100]<ByteProvider,ByteProvider,void>((uint64_t)a2, v4 + 3, (uint64_t)(v4 + 3));
}

void sub_1DBD03470(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<Backend::Google::FullHashChecker>::__shared_ptr_emplace[abi:sn180100]<Backend::Google::Configuration &,std::allocator<Backend::Google::FullHashChecker>,0>(_QWORD *a1, const Backend::Google::Configuration *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1EA3EBA38;
  Backend::Google::FullHashChecker::FullHashChecker((Backend::Google::FullHashChecker *)(a1 + 3), a2);
  return a1;
}

void sub_1DBD034B8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashChecker>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBA38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashChecker>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBA38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<Backend::Google::FullHashChecker>::__on_zero_shared(uint64_t a1)
{
  Backend::Google::FullHashChecker::~FullHashChecker((Backend::Google::FullHashChecker *)(a1 + 24));
}

uint64_t std::__function::__func<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0,std::allocator<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0>,void ()(std::vector<Backend::Google::ThreatListDescriptor>)>::~__func(uint64_t a1)
{

  return a1;
}

void std::__function::__func<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0,std::allocator<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0>,void ()(std::vector<Backend::Google::ThreatListDescriptor>)>::~__func(id *a1)
{

  operator delete(a1);
}

_QWORD *std::__function::__func<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0,std::allocator<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0>,void ()(std::vector<Backend::Google::ThreatListDescriptor>)>::__clone(uint64_t a1)
{
  _QWORD *v2;

  v2 = operator new(0x18uLL);
  *v2 = off_1EA3E9EB8;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = *(id *)(a1 + 16);
  return v2;
}

id std::__function::__func<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0,std::allocator<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0>,void ()(std::vector<Backend::Google::ThreatListDescriptor>)>::__clone(uint64_t a1, _QWORD *a2)
{
  id result;

  *a2 = off_1EA3E9EB8;
  a2[1] = *(id *)(a1 + 8);
  result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void std::__function::__func<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0,std::allocator<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0>,void ()(std::vector<Backend::Google::ThreatListDescriptor>)>::destroy(uint64_t a1)
{

}

void std::__function::__func<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0,std::allocator<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0>,void ()(std::vector<Backend::Google::ThreatListDescriptor>)>::destroy_deallocate(id *a1)
{

  operator delete(a1);
}

void std::__function::__func<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0,std::allocator<SafeBrowsing::Service::handleCheckFullHashes(NSObject  {objcproto13OS_xpc_object}*)::$_0>,void ()(std::vector<Backend::Google::ThreatListDescriptor>)>::operator()(uint64_t a1, uint64_t a2)
{
  __int128 *v3;
  __int128 *v4;
  void *v5;
  xpc_object_t v6;
  __int128 *v7;
  void *v8;
  NSObject *v9;
  __int128 v10;

  v3 = *(__int128 **)a2;
  v4 = *(__int128 **)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v5 = *(void **)(a1 + 16);
  v6 = xpc_array_create(0, 0);
  if (v3 != v4)
  {
    v7 = v3;
    do
    {
      v10 = *v7;
      Backend::Google::ThreatListDescriptor::toXPC((Backend::Google::ThreatListDescriptor *)&v10);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      xpc_array_append_value(v6, v8);

      ++v7;
    }
    while (v7 != v4);
  }
  xpc_dictionary_set_value(v5, "threatListDescriptors", v6);

  v9 = SSBOSLogFullHash();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    LOWORD(v10) = 0;
    _os_log_impl(&dword_1DBCBE000, v9, OS_LOG_TYPE_INFO, "Send CheckFullHashes reply", (uint8_t *)&v10, 2u);
  }
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 8), *(xpc_object_t *)(a1 + 16));
  if (v3)
    operator delete(v3);
}

void sub_1DBD03758(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *Platform::computeSHA256@<X0>(_DWORD *a1@<X0>, unsigned __int8 *a2@<X8>)
{
  int v3;
  CC_LONG v4;
  CC_LONG v5;

  v3 = *((char *)a1 + 23);
  v4 = a1[2];
  if (v3 >= 0)
  {
    v5 = v3;
  }
  else
  {
    a1 = *(_DWORD **)a1;
    v5 = v4;
  }
  return CC_SHA256(a1, v5, a2);
}

void Platform::SharedMemory::createFileMapping(int *a1@<X0>, _QWORD *a2@<X8>)
{
  NSObject *v4;
  int v5;
  int *v6;
  void *v7;
  _QWORD *v8;
  off_t st_size;
  int v10;
  int *v11;
  stat v12;
  _BYTE v13[24];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (fstat(*a1, &v12))
  {
    v4 = (id)SSBOSLogPlatform();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *a1;
      v6 = __error();
      Platform::SharedMemory::createFileMapping((uint64_t)v6, (uint64_t)v13, v5);
    }
LABEL_4:

    *a2 = 0;
    a2[1] = 0;
    return;
  }
  v7 = mmap(0, v12.st_size, 1, 1, *a1, 0);
  if (v7 == (void *)-1)
  {
    v4 = (id)SSBOSLogPlatform();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v10 = *a1;
      v11 = __error();
      Platform::SharedMemory::createFileMapping((uint64_t)v11, (uint64_t)v13, v10);
    }
    goto LABEL_4;
  }
  v8 = operator new(0x28uLL);
  v8[1] = 0;
  v8[2] = 0;
  *v8 = off_1EA3EBB18;
  st_size = v12.st_size;
  v8[3] = v7;
  v8[4] = st_size;
  *a2 = v8 + 3;
  a2[1] = v8;
}

void sub_1DBD038E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *Platform::SharedMemory::SharedMemory(_QWORD *this, void *a2, uint64_t a3)
{
  *this = a2;
  this[1] = a3;
  return this;
}

void Platform::SharedMemory::~SharedMemory(Platform::SharedMemory *this)
{
  munmap(*(void **)this, *((_QWORD *)this + 1));
}

void std::__shared_ptr_emplace<Platform::SharedMemory>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBB18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Platform::SharedMemory>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EBB18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<Platform::SharedMemory>::__on_zero_shared(uint64_t a1)
{
  return munmap(*(void **)(a1 + 24), *(_QWORD *)(a1 + 32));
}

void sub_1DBD03BC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id location, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  void *v19;
  void *v20;
  void *v21;

  v21 = v20;

  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void safeBrowsingEnabledStateChanged(__CFNotificationCenter *a1, void *a2, const __CFString *a3, const void *a4, const __CFDictionary *a5)
{
  id v5;

  +[SSBLookupContext sharedLookupContext](SSBLookupContext, "sharedLookupContext", a3, a4, a5);
  v5 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "_setSafeBrowsingEnabledStateNeedsUpdate");

}

void sub_1DBD03C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBD03D08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;

  a9.super_class = (Class)SSBLookupContext;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void sub_1DBD03EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  void *v13;
  void *v14;
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a13;
  if (a13 == v15)
  {
    v18 = 4;
    v17 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:

  _Unwind_Resume(a1);
}

void sub_1DBD03FB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1DBD0408C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1DBD04168(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1DBD04244(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1DBD04320(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1DBD043FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1DBD044D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1DBD045B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1DBD04690(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1DBD04728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1DBD04854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void _ZNSt3__115allocate_sharedB8sn180100IN12SafeBrowsing13LookupContextENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(_QWORD *a1@<X8>)
{
  _QWORD *v2;

  v2 = operator new(0xD8uLL);
  _ZNSt3__120__shared_ptr_emplaceIN12SafeBrowsing13LookupContextENS_9allocatorIS2_EEEC2B8sn180100IJES4_Li0EEES4_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  std::shared_ptr<ByteProvider>::__enable_weak_this[abi:sn180100]<ByteProvider,ByteProvider,void>((uint64_t)a1, v2 + 3, (uint64_t)(v2 + 3));
}

void sub_1DBD048D4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceIN12SafeBrowsing13LookupContextENS_9allocatorIS2_EEEC2B8sn180100IJES4_Li0EEES4_DpOT_(_QWORD *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1EA3EB8E8;
  SafeBrowsing::LookupContext::LookupContext((SafeBrowsing::LookupContext *)(a1 + 3));
  return a1;
}

void sub_1DBD0491C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<SafeBrowsing::LookupContext>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB8E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SafeBrowsing::LookupContext>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1EA3EB8E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<SafeBrowsing::LookupContext>::__on_zero_shared(uint64_t a1)
{
  SafeBrowsing::LookupContext::~LookupContext((SafeBrowsing::LookupContext *)(a1 + 24));
}

void ___ZZ24__SSBLookupContext_init_ENK3__1clEN7Backend6Google21DatabaseConfigurationE_block_invoke(uint64_t a1)
{
  id WeakRetained;
  __CFString *v3;
  void *v4;
  void *v5;
  const __CFString *v6;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x1E0C80C00];
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v3 = (__CFString *)*(unsigned int *)(a1 + 36);
    objc_msgSend(MEMORY[0x1E0CB37D0], "defaultCenter");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = CFSTR("SSBLookupContextDatabasesDidUpdateNotificationUserInfoProvider");
    if (((_DWORD)v3 - 1) <= 2)
      v3 = *off_1EA3EC4B0[(int)v3 - 1];
    v7[0] = v3;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v7, &v6, 1);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "postNotificationName:object:userInfo:", CFSTR("SSBLookupContextDatabasesDidUpdateNotification"), WeakRetained, v5);

  }
}

void sub_1DBD04BEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c89_ZTSKZZ24__SSBLookupContext_init_ENK3__1clEN7Backend6Google21DatabaseConfigurationEEUlvE_(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  objc_copyWeak((id *)(a1 + 40), (id *)(a2 + 40));
}

void __destroy_helper_block_ea8_32c89_ZTSKZZ24__SSBLookupContext_init_ENK3__1clEN7Backend6Google21DatabaseConfigurationEEUlvE_(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 40));
}

void sub_1DBD04EB0(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

id nsErrorFromReplyErrorCode(std::error_code a1)
{
  void *v1;
  std::string *p_p;
  void *v3;
  void *v4;
  uint64_t v5;
  std::string __p;
  std::error_code v8;
  uint64_t v9;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x1E0C80C00];
  v8 = a1;
  Platform::xpcErrorCategory();
  v9 = *MEMORY[0x1E0CB2D50];
  v1 = (void *)MEMORY[0x1E0CB3940];
  std::error_code::message(&__p, &v8);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v1, "stringWithUTF8String:", p_p);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v10[0] = v3;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v10, &v9, 1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v8.__val_ == 1)
  {
    v5 = 4097;
    goto LABEL_10;
  }
  if (v8.__val_ == 2)
  {
    v5 = 4099;
LABEL_10:
    objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", *MEMORY[0x1E0CB28A8], v5, v4);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v3;
}

void sub_1DBD05014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1DBD051C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v10;

  if (v10)

  _Unwind_Resume(exception_object);
}

void sub_1DBD05334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBD05520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;
  uint64_t v10;

  *(_QWORD *)(v10 - 40) = &a9;
  std::vector<SafeBrowsing::DatabaseStatus::Database>::__destroy_vector::operator()[abi:sn180100]((void ***)(v10 - 40));
  _Unwind_Resume(a1);
}

void sub_1DBD05850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40)
{
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  if (__p)
    operator delete(__p);
  *(_QWORD *)(v43 - 72) = v42;
  std::vector<SafeBrowsing::ServiceStatus::Connection>::__destroy_vector::operator()[abi:sn180100]((void ***)(v43 - 72));
  *(_QWORD *)(v43 - 72) = v41;
  std::vector<std::string>::__destroy_vector::operator()[abi:sn180100]((void ***)(v43 - 72));
  if (a14 < 0)
    operator delete(a9);
  _Unwind_Resume(a1);
}

void sub_1DBD05A40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBD05BB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBD05D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBD05EB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBD06068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBD061E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBD06278(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBD063A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1DBD06448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBD06554(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBD0666C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBD06784(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBD0689C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void SafeBrowsing::BrowsingDatabaseCoordinator::addToDatabases(uint64_t *a1, uint64_t a2, char **a3)
{
  Backend::Google::SSBUtilities *v5;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;

  SafeBrowsing::DatabaseCoordinator::addDatabaseInfoToDatabases((uint64_t)a1, a1 + 7, a3);
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(v5);
  if ((_DWORD)shouldConsultWithTencent)
    SafeBrowsing::DatabaseCoordinator::addDatabaseInfoToDatabases((uint64_t)a1, a1 + 10, a3);
  if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
    SafeBrowsing::DatabaseCoordinator::addDatabaseInfoToDatabases((uint64_t)a1, a1 + 13, a3);
}

uint64_t SafeBrowsing::BrowsingDatabaseCoordinator::databasesAreEmpty(SafeBrowsing::BrowsingDatabaseCoordinator *this, SafeBrowsing::LookupContext *a2)
{
  uint64_t v3;
  uint64_t v4;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  BOOL v6;
  _BOOL4 v7;
  int shouldConsultWithApple;
  uint64_t result;

  v3 = *((_QWORD *)this + 7);
  v4 = *((_QWORD *)this + 8);
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(this);
  v6 = v3 == v4;
  if (v3 == v4)
    v7 = 1;
  else
    v7 = (int)shouldConsultWithTencent;
  if ((_DWORD)shouldConsultWithTencent && !v6)
    v7 = *((_QWORD *)this + 10) == *((_QWORD *)this + 11);
  shouldConsultWithApple = Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent);
  result = shouldConsultWithApple | v7;
  if (shouldConsultWithApple)
  {
    if (!v7)
      return *((_QWORD *)this + 13) == *((_QWORD *)this + 14);
  }
  return result;
}

void SafeBrowsing::BrowsingDatabaseCoordinator::clearDatabases(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t k;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t j;
  uint64_t v9;

  switch(a3)
  {
    case 3:
      v7 = a1[13];
      for (i = a1[14]; i != v7; Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)(i - 112)))
        ;
      a1[14] = v7;
      break;
    case 2:
      v9 = a1[10];
      for (j = a1[11]; j != v9; Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)(j - 112)))
        ;
      a1[11] = v9;
      break;
    case 1:
      v5 = a1[7];
      for (k = a1[8]; k != v5; Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)(k - 112)))
        ;
      a1[8] = v5;
      break;
  }
}

void SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  char *v8;
  _BYTE *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _QWORD v22[3];
  _QWORD *v23;
  _BYTE v24[24];
  _BYTE *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v19, (_QWORD *)(a1 + 8));
  v20 = v19;
  v21 = v19;
  if (*((_QWORD *)&v19 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = v22;
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)v22, a3);
  v25 = 0;
  v8 = (char *)operator new(0x38uLL);
  v9 = v8;
  *(_QWORD *)v8 = off_1EA3EB5C8;
  *(_OWORD *)(v8 + 8) = v21;
  v21 = 0uLL;
  if (v23)
  {
    if (v23 == v22)
    {
      *((_QWORD *)v8 + 6) = v8 + 24;
      (*(void (**)(_QWORD *))(v22[0] + 24))(v22);
    }
    else
    {
      *((_QWORD *)v8 + 6) = v23;
      v23 = 0;
    }
  }
  else
  {
    *((_QWORD *)v8 + 6) = 0;
  }
  v25 = v9;
  SafeBrowsing::LookupContext::dispatchWhenDatabasesAreAvailable(a2, 1, (uint64_t)v24);
  v10 = v25;
  if (v25 == v24)
  {
    v11 = 4;
    v10 = v24;
  }
  else
  {
    if (!v25)
      goto LABEL_14;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_14:
  if (v23 == v22)
  {
    v12 = 4;
    goto LABEL_18;
  }
  if (v23)
  {
    v12 = 5;
    v7 = v23;
LABEL_18:
    (*(void (**)(_QWORD *))(*v7 + 8 * v12))(v7);
  }
  v13 = (std::__shared_weak_count *)*((_QWORD *)&v21 + 1);
  if (*((_QWORD *)&v21 + 1))
  {
    v14 = (unint64_t *)(*((_QWORD *)&v21 + 1) + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = (std::__shared_weak_count *)*((_QWORD *)&v20 + 1);
  if (*((_QWORD *)&v20 + 1))
  {
    v17 = (unint64_t *)(*((_QWORD *)&v20 + 1) + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void sub_1DBD06DD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v6 = *(_QWORD **)(v4 - 48);
  if (v6 == v3)
  {
    v7 = 4;
    v6 = (_QWORD *)(v4 - 72);
  }
  else
  {
    if (!v6)
      goto LABEL_6;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_6:
  SafeBrowsing::LookupContext::addDatabaseUpdateObserver(std::function<void ()(Backend::Google::DatabaseConfiguration)>)::$_0::~$_0((uint64_t)va1);
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void SafeBrowsing::BrowsingDatabaseCoordinator::handleGetDatabasesReply(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  NSObject *v5;
  Backend::Google::SSBUtilities *v6;
  void *v7;
  void *v8;
  size_t count;
  size_t v10;
  void *v11;
  Backend::Google::SSBUtilities *v12;
  uint64_t v13;
  int v14;
  const std::error_category *v15;
  uint64_t v16;
  const std::error_category *cat;
  const std::error_category *v18;
  std::string::size_type v19;
  std::string::size_type size;
  std::string::size_type v21;
  const std::error_category *v22;
  uint64_t v23;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  const std::error_category *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  std::string::size_type v32;
  std::string::size_type v33;
  std::string::size_type v34;
  const std::error_category *v35;
  uint64_t v36;
  std::string v37[4];
  char v38;
  std::error_code v39;
  const std::error_category *v40;
  std::error_code v41;
  const std::error_category *v42;
  _OWORD v43[2];
  uint8_t buf[8];
  const std::error_category *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  v5 = SSBOSLogDatabase();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    LOWORD(v37[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1DBCBE000, v5, OS_LOG_TYPE_INFO, "Receive GetDatabases response from safe browsing service", (uint8_t *)v37, 2u);
  }
  *(_BYTE *)(a1 + 24) = 0;
  v6 = (Backend::Google::SSBUtilities *)MEMORY[0x1DF0B91F0](v4);
  if (v6 == (Backend::Google::SSBUtilities *)MEMORY[0x1E0C81310])
  {
    shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent(v6);
    Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent);
    *(_QWORD *)&v39.__val_ = Platform::xpcErrorCode(v4);
    v39.__cat_ = v25;
    if (v39.__val_)
    {
      v26 = (id)SSBOSLogDatabase();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        std::error_code::message(v37, &v39);
        SafeBrowsing::BrowsingDatabaseCoordinator::handleGetDatabasesReply((char *)v37, buf, v26);
      }

    }
    v27 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)&v43[0] = v27;
    *(_OWORD *)((char *)v43 + 8) = *(_OWORD *)(a1 + 40);
    v28 = *((_QWORD *)&v43[0] + 1);
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    v29 = v28;
    while (v27 != v29)
    {
      v41 = v39;
      v30 = *(_QWORD *)(v27 + 24);
      if (!v30)
      {
LABEL_52:
        std::__throw_bad_function_call[abi:sn180100]();
LABEL_53:
        __break(1u);
      }
      (*(void (**)(uint64_t, std::error_code *))(*(_QWORD *)v30 + 48))(v30, &v41);
      v27 += 32;
    }
    *(_QWORD *)&v41.__val_ = v43;
    std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100]((void ***)&v41);
  }
  else
  {
    xpc_dictionary_get_value(v4, "databases");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = v7;
    if (v7)
    {
      memset(v43, 0, 24);
      v41 = (std::error_code)0;
      v42 = 0;
      *(_QWORD *)&v39.__val_ = 0;
      v39.__cat_ = 0;
      v40 = 0;
      count = xpc_array_get_count(v7);
      if (count)
      {
        v10 = 0;
        while (1)
        {
          xpc_array_get_value(v8, v10);
          v11 = (void *)objc_claimAutoreleasedReturnValue();
          SafeBrowsing::DatabaseCoordinator::databaseInfo(v11, v37);

          if (v38)
            break;
LABEL_28:
          if (count == ++v10)
            goto LABEL_29;
        }
        if (HIDWORD(v37[0].__r_.__value_.__r.__words[1]) == 1)
        {
          v13 = *((_QWORD *)&v43[0] + 1);
          if (*((_QWORD *)&v43[0] + 1) >= *(_QWORD *)&v43[1])
          {
            v12 = (Backend::Google::SSBUtilities *)std::vector<Backend::Google::DatabaseInfo>::__push_back_slow_path<Backend::Google::DatabaseInfo>((uint64_t *)v43, (uint64_t)v37);
          }
          else
          {
            std::construct_at[abi:sn180100]<Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo*>(*((uint64_t *)&v43[0] + 1), (uint64_t)v37);
            v12 = (Backend::Google::SSBUtilities *)(v13 + 112);
          }
          *((_QWORD *)&v43[0] + 1) = v12;
        }
        if (Backend::Google::SSBUtilities::shouldConsultWithTencent(v12))
        {
          if (!v38)
            goto LABEL_53;
          v14 = HIDWORD(v37[0].__r_.__value_.__r.__words[1]);
          if (HIDWORD(v37[0].__r_.__value_.__r.__words[1]) != 2)
          {
LABEL_22:
            if (v14 != 3
              || ((cat = v39.__cat_, v39.__cat_ >= v40)
                ? (v18 = (const std::error_category *)std::vector<Backend::Google::DatabaseInfo>::__push_back_slow_path<Backend::Google::DatabaseInfo>((uint64_t *)&v39.__val_, (uint64_t)v37)): (std::construct_at[abi:sn180100]<Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo*>((uint64_t)v39.__cat_, (uint64_t)v37), v18 = cat + 14), v39.__cat_ = v18, v38))
            {
              Backend::Google::DatabaseInfo::~DatabaseInfo((Backend::Google::DatabaseInfo *)v37);
            }
            goto LABEL_28;
          }
          v15 = v41.__cat_;
          if (v41.__cat_ >= v42)
          {
            v16 = std::vector<Backend::Google::DatabaseInfo>::__push_back_slow_path<Backend::Google::DatabaseInfo>((uint64_t *)&v41.__val_, (uint64_t)v37);
          }
          else
          {
            std::construct_at[abi:sn180100]<Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo,Backend::Google::DatabaseInfo*>((uint64_t)v41.__cat_, (uint64_t)v37);
            v16 = (uint64_t)&v15[14];
          }
          v41.__cat_ = (const std::error_category *)v16;
        }
        if (!v38)
          goto LABEL_53;
        v14 = HIDWORD(v37[0].__r_.__value_.__r.__words[1]);
        goto LABEL_22;
      }
LABEL_29:
      std::vector<Backend::Google::DatabaseInfo>::__vdeallocate((void **)(a1 + 56));
      *(_OWORD *)(a1 + 56) = v43[0];
      *(_QWORD *)(a1 + 72) = *(_QWORD *)&v43[1];
      memset(v43, 0, 24);
      std::vector<Backend::Google::DatabaseInfo>::__vdeallocate((void **)(a1 + 80));
      *(std::error_code *)(a1 + 80) = v41;
      *(_QWORD *)(a1 + 96) = v42;
      v42 = 0;
      v41 = (std::error_code)0;
      std::vector<Backend::Google::DatabaseInfo>::__vdeallocate((void **)(a1 + 104));
      *(std::error_code *)(a1 + 104) = v39;
      *(_QWORD *)(a1 + 120) = v40;
      v39.__cat_ = 0;
      v40 = 0;
      *(_QWORD *)&v39.__val_ = 0;
      v19 = *(_QWORD *)(a1 + 32);
      *(_OWORD *)&v37[0].__r_.__value_.__r.__words[1] = *(_OWORD *)(a1 + 40);
      size = v37[0].__r_.__value_.__l.__size_;
      *(_QWORD *)(a1 + 40) = 0;
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 32) = 0;
      v21 = size;
      v37[0].__r_.__value_.__r.__words[0] = v19;
      while (v19 != v21)
      {
        v22 = std::system_category();
        *(_QWORD *)buf = 0;
        v45 = v22;
        v23 = *(_QWORD *)(v19 + 24);
        if (!v23)
          goto LABEL_52;
        (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v23 + 48))(v23, buf);
        v19 += 32;
      }
      *(_QWORD *)buf = v37;
      std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100]((void ***)buf);
      v37[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v39;
      std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100]((void ***)v37);
      v37[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v41;
      std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100]((void ***)v37);
      v37[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v43;
      std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100]((void ***)v37);
    }
    else
    {
      v31 = SSBOSLogDatabase();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        LOWORD(v37[0].__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_1DBCBE000, v31, OS_LOG_TYPE_INFO, "Database array obtained from safe browsing service is empty", (uint8_t *)v37, 2u);
      }
      v32 = *(_QWORD *)(a1 + 32);
      v37[0].__r_.__value_.__r.__words[0] = v32;
      *(_OWORD *)&v37[0].__r_.__value_.__r.__words[1] = *(_OWORD *)(a1 + 40);
      v33 = v37[0].__r_.__value_.__l.__size_;
      *(_QWORD *)(a1 + 40) = 0;
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 32) = 0;
      v34 = v33;
      while (v32 != v34)
      {
        v35 = std::system_category();
        *(_QWORD *)&v43[0] = 0;
        *((_QWORD *)&v43[0] + 1) = v35;
        v36 = *(_QWORD *)(v32 + 24);
        if (!v36)
          goto LABEL_52;
        (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v36 + 48))(v36, v43);
        v32 += 32;
      }
      *(_QWORD *)&v43[0] = v37;
      std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100]((void ***)v43);
    }

  }
}

void sub_1DBD072BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void SafeBrowsing::BrowsingDatabaseCoordinator::handleCheckFullHashesReply(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  char *shouldConsultWithTencent;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  uint64_t *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  void *v34;
  int64_t v35;
  char *v36;
  const std::error_category *v37;
  uint64_t v38;
  void *v39;
  void *__dst;
  uint64_t v41;
  void *__p;
  uint64_t *v43;
  uint64_t *v44;
  _QWORD applier[8];
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD v49[2];

  v6 = a3;
  v47 = 0x200000000;
  v48 = 0x100000000;
  v46 = 0x400000000;
  xpc_dictionary_get_array(v6, "threatListDescriptors");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = v7;
  if (v7)
  {
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3321888768;
    applier[2] = ___ZN12SafeBrowsing27BrowsingDatabaseCoordinator26handleCheckFullHashesReplyERNS_13LookupContextEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS6_6vectorIN7Backend12LookupResultENS6_9allocatorISA_EEEENS6_10error_codeEEEE_block_invoke;
    applier[3] = &__block_descriptor_64_ea8_32c238_ZTSKZN12SafeBrowsing27BrowsingDatabaseCoordinator26handleCheckFullHashesReplyERNS_13LookupContextEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS6_6vectorIN7Backend12LookupResultENS6_9allocatorISA_EEEENS6_10error_codeEEEEE3__0_e36_B24__0Q8__NSObject_OS_xpc_object__16l;
    applier[4] = &v48;
    applier[5] = a1;
    applier[6] = &v47;
    applier[7] = &v46;
    xpc_array_apply(v7, applier);
  }

  v9 = v48;
  v10 = (uint64_t *)operator new(8uLL);
  __p = v10;
  *v10 = v9;
  v43 = v10 + 1;
  v44 = v10 + 1;
  shouldConsultWithTencent = (char *)Backend::Google::SSBUtilities::shouldConsultWithTencent((Backend::Google::SSBUtilities *)(v10 + 1));
  if ((_DWORD)shouldConsultWithTencent)
  {
    v12 = v43;
    if (v43 >= v44)
    {
      v14 = ((char *)v43 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v14 + 1) >> 61)
        goto LABEL_48;
      v15 = ((char *)v44 - (_BYTE *)__p) >> 2;
      if (v15 <= v14 + 1)
        v15 = v14 + 1;
      if ((unint64_t)((char *)v44 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (!v16)
        goto LABEL_49;
      v17 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>((uint64_t)&v44, v16);
      if (!v17)
        goto LABEL_49;
      v19 = &v17[8 * v18];
      v20 = (uint64_t *)&v17[8 * v14];
      *v20 = v47;
      v13 = v20 + 1;
      v21 = (char *)__p;
      shouldConsultWithTencent = (char *)v43;
      if (v43 != __p)
      {
        do
        {
          v22 = *((_QWORD *)shouldConsultWithTencent - 1);
          shouldConsultWithTencent -= 8;
          *--v20 = v22;
        }
        while (shouldConsultWithTencent != v21);
        shouldConsultWithTencent = (char *)__p;
      }
      __p = v20;
      v43 = v13;
      v44 = (uint64_t *)v19;
      if (shouldConsultWithTencent)
        operator delete(shouldConsultWithTencent);
    }
    else
    {
      if (!v43)
      {
LABEL_49:
        __break(1u);
        return;
      }
      *v43 = v47;
      v13 = v12 + 1;
    }
    v43 = v13;
  }
  v23 = v43;
  if (!Backend::Google::SSBUtilities::shouldConsultWithApple((Backend::Google::SSBUtilities *)shouldConsultWithTencent))
    goto LABEL_39;
  if (v43 >= v44)
  {
    v24 = ((char *)v43 - (_BYTE *)__p) >> 3;
    if (!((unint64_t)(v24 + 1) >> 61))
    {
      v25 = ((char *)v44 - (_BYTE *)__p) >> 2;
      if (v25 <= v24 + 1)
        v25 = v24 + 1;
      if ((unint64_t)((char *)v44 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v26 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v26 = v25;
      if (!v26)
        goto LABEL_49;
      v27 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>((uint64_t)&v44, v26);
      if (!v27)
        goto LABEL_49;
      v29 = &v27[8 * v28];
      v30 = (uint64_t *)&v27[8 * v24];
      *v30 = v46;
      v23 = v30 + 1;
      v32 = (char *)__p;
      v31 = (char *)v43;
      if (v43 != __p)
      {
        do
        {
          v33 = *((_QWORD *)v31 - 1);
          v31 -= 8;
          *--v30 = v33;
        }
        while (v31 != v32);
        v31 = (char *)__p;
      }
      __p = v30;
      v43 = v23;
      v44 = (uint64_t *)v29;
      if (v31)
        operator delete(v31);
      goto LABEL_38;
    }
LABEL_48:
    abort();
  }
  if (!v43)
    goto LABEL_49;
  *v43 = v46;
  ++v23;
LABEL_38:
  v43 = v23;
LABEL_39:
  v39 = 0;
  __dst = 0;
  v41 = 0;
  v34 = __p;
  v35 = (char *)v23 - (_BYTE *)__p;
  if (v35)
  {
    std::vector<Backend::LookupResult>::__vallocate[abi:sn180100](&v39, v35 >> 3);
    v36 = (char *)__dst;
    memmove(__dst, v34, v35);
    __dst = &v36[8 * (v35 >> 3)];
  }
  v37 = std::system_category();
  v49[0] = 0;
  v49[1] = v37;
  v38 = *(_QWORD *)(a4 + 24);
  if (!v38)
  {
    std::__throw_bad_function_call[abi:sn180100]();
    goto LABEL_49;
  }
  (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)v38 + 48))(v38, &v39, v49);
  if (v39)
  {
    __dst = v39;
    operator delete(v39);
  }
  if (__p)
  {
    v43 = (uint64_t *)__p;
    operator delete(__p);
  }

}

void sub_1DBD076C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t ___ZN12SafeBrowsing27BrowsingDatabaseCoordinator26handleCheckFullHashesReplyERNS_13LookupContextEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS6_6vectorIN7Backend12LookupResultENS6_9allocatorISA_EEEENS6_10error_codeEEEE_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  _DWORD v8[3];
  int v9;
  char v10;

  v4 = a3;
  v5 = *(_QWORD *)(a1 + 40);
  Backend::Google::ThreatListDescriptor::fromXPC(v4, v8);
  if (!v10)
    goto LABEL_12;
  if (v9 == 1)
  {
    v6 = SafeBrowsing::DatabaseCoordinator::fromThreatListDescriptor(v5, v8);
    **(_DWORD **)(a1 + 32) |= v6;
  }
  result = Backend::Google::SSBUtilities::shouldConsultWithTencent((Backend::Google::SSBUtilities *)v6);
  if ((_DWORD)result)
  {
    if (!v10)
      goto LABEL_13;
    if (v9 == 2)
    {
      result = SafeBrowsing::DatabaseCoordinator::fromThreatListDescriptor(v5, v8);
      **(_DWORD **)(a1 + 48) |= result;
    }
  }
  result = Backend::Google::SSBUtilities::shouldConsultWithApple((Backend::Google::SSBUtilities *)result);
  if (!(_DWORD)result)
  {
LABEL_12:

    return 1;
  }
  if (v10)
  {
    if (v9 == 3)
      **(_DWORD **)(a1 + 56) |= SafeBrowsing::DatabaseCoordinator::fromThreatListDescriptor(v5, v8);
    goto LABEL_12;
  }
LABEL_13:
  __break(1u);
  return result;
}

void sub_1DBD07808(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c238_ZTSKZN12SafeBrowsing27BrowsingDatabaseCoordinator26handleCheckFullHashesReplyERNS_13LookupContextEPU24objcproto13OS_xpc_object8NSObjectNSt3__18functionIFvNS6_6vectorIN7Backend12LookupResultENS6_9allocatorISA_EEEENS6_10error_codeEEEEE3__0(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 32);
  v3 = *(_OWORD *)(a2 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

void SafeBrowsing::BrowsingDatabaseCoordinator::performURLLookup(uint64_t *a1, SafeBrowsing::LookupContext *a2, void *a3, _QWORD *a4)
{
  Backend::Google::CanonicalURL *v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  Backend::Google::SSBUtilities *shouldConsultWithTencent;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  char *v46;
  uint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  _QWORD *v53;
  NSObject *v54;
  NSObject *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void *v62;
  int64_t v63;
  char *v64;
  const std::error_category *v65;
  uint64_t v66;
  _QWORD *v67;
  uint64_t v68;
  __int128 v69;
  uint64_t v70;
  void *v71;
  void *__dst;
  uint64_t v73;
  uint64_t v74[3];
  uint64_t v75[3];
  uint64_t v76[3];
  uint8_t v77[16];
  uint64_t v78;
  void *__p;
  char *v80;
  unint64_t v81;
  __int128 v82;
  uint64_t v83;
  void *v84[3];
  uint8_t buf[8];
  void *v86;
  void **v87;
  _BYTE v88[24];
  _BYTE *v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  v7 = a3;
  v8 = SSBOSLogDatabase();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1DBCBE000, v8, OS_LOG_TYPE_INFO, "Perform url lookup in the database", buf, 2u);
  }
  v9 = SSBOSLogDatabase();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    SafeBrowsing::BrowsingDatabaseCoordinator::performURLLookup((uint64_t)v7, v9, v10, v11, v12, v13, v14, v15);
  Backend::Google::CanonicalURL::canonicalizeURL(v7, (uint64_t)buf);
  Backend::Google::CanonicalURL::computeHashes((Backend::Google::CanonicalURL *)buf, (char **)v84);
  v82 = 0uLL;
  v83 = 0;
  __p = 0;
  v80 = 0;
  v81 = 0;
  memset(v76, 0, sizeof(v76));
  std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(v76, a1[7], a1[8], 0x6DB6DB6DB6DB6DB7 * ((a1[8] - a1[7]) >> 4));
  SafeBrowsing::DatabaseCoordinator::lookupHashes((char **)v84, v76, (uint64_t)v77);
  std::vector<Backend::Google::FullHashRequest>::__vdeallocate((void **)&v82);
  v82 = *(_OWORD *)v77;
  v83 = v78;
  v78 = 0;
  memset(v77, 0, sizeof(v77));
  v87 = (void **)v77;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v87);
  v87 = (void **)v76;
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v87);
  v17 = v80;
  if ((unint64_t)v80 >= v81)
  {
    v19 = (v80 - (_BYTE *)__p) >> 3;
    if ((unint64_t)(v19 + 1) >> 61)
      abort();
    v20 = (uint64_t)(v81 - (_QWORD)__p) >> 2;
    if (v20 <= v19 + 1)
      v20 = v19 + 1;
    if (v81 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8)
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v21 = v20;
    if (!v21)
      goto LABEL_89;
    v22 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>((uint64_t)&v81, v21);
    if (!v22)
      goto LABEL_89;
    v24 = &v22[8 * v23];
    v25 = &v22[8 * v19];
    *(_QWORD *)v25 = 0x100000000;
    v18 = v25 + 8;
    v26 = (char *)__p;
    v16 = v80;
    if (v80 != __p)
    {
      do
      {
        v27 = *((_QWORD *)v16 - 1);
        v16 -= 8;
        *((_QWORD *)v25 - 1) = v27;
        v25 -= 8;
      }
      while (v16 != v26);
      v16 = (char *)__p;
    }
    __p = v25;
    v80 = v18;
    v81 = (unint64_t)v24;
    if (v16)
      operator delete(v16);
  }
  else
  {
    if (!v80)
      goto LABEL_89;
    *(_QWORD *)v80 = 0x100000000;
    v18 = v17 + 8;
  }
  v80 = v18;
  shouldConsultWithTencent = (Backend::Google::SSBUtilities *)Backend::Google::SSBUtilities::shouldConsultWithTencent((Backend::Google::SSBUtilities *)v16);
  if ((_DWORD)shouldConsultWithTencent)
  {
    memset(v75, 0, sizeof(v75));
    std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(v75, a1[10], a1[11], 0x6DB6DB6DB6DB6DB7 * ((a1[11] - a1[10]) >> 4));
    SafeBrowsing::DatabaseCoordinator::lookupHashes((char **)v84, v75, (uint64_t)v77);
    v87 = (void **)v75;
    std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v87);
    std::__unwrap_and_dispatch[abi:sn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__wrap_iter<Backend::Google::FullHashRequest *>,std::__wrap_iter<Backend::Google::FullHashRequest *>,std::back_insert_iterator<std::vector<Backend::Google::FullHashRequest>>,0>(*(const Backend::Google::FullHashRequest **)v77, *(const Backend::Google::FullHashRequest **)&v77[8], (uint64_t)&v82);
    v29 = v80;
    if ((unint64_t)v80 >= v81)
    {
      v31 = (v80 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v31 + 1) >> 61)
        abort();
      v32 = (uint64_t)(v81 - (_QWORD)__p) >> 2;
      if (v32 <= v31 + 1)
        v32 = v31 + 1;
      if (v81 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8)
        v33 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v33 = v32;
      if (!v33)
        goto LABEL_89;
      v34 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>((uint64_t)&v81, v33);
      if (!v34)
        goto LABEL_89;
      v36 = &v34[8 * v35];
      v37 = &v34[8 * v31];
      *(_QWORD *)v37 = 0x200000000;
      v30 = v37 + 8;
      v39 = (char *)__p;
      v38 = v80;
      if (v80 != __p)
      {
        do
        {
          v40 = *((_QWORD *)v38 - 1);
          v38 -= 8;
          *((_QWORD *)v37 - 1) = v40;
          v37 -= 8;
        }
        while (v38 != v39);
        v38 = (char *)__p;
      }
      __p = v37;
      v80 = v30;
      v81 = (unint64_t)v36;
      if (v38)
        operator delete(v38);
    }
    else
    {
      if (!v80)
        goto LABEL_89;
      *(_QWORD *)v80 = 0x200000000;
      v30 = v29 + 8;
    }
    v80 = v30;
    v87 = (void **)v77;
    std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v87);
  }
  if (Backend::Google::SSBUtilities::shouldConsultWithApple(shouldConsultWithTencent))
  {
    memset(v74, 0, sizeof(v74));
    std::vector<Backend::Google::DatabaseInfo>::__init_with_size[abi:sn180100]<Backend::Google::DatabaseInfo*,Backend::Google::DatabaseInfo*>(v74, a1[13], a1[14], 0x6DB6DB6DB6DB6DB7 * ((a1[14] - a1[13]) >> 4));
    SafeBrowsing::DatabaseCoordinator::lookupHashes((char **)v84, v74, (uint64_t)v77);
    v87 = (void **)v74;
    std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v87);
    std::__unwrap_and_dispatch[abi:sn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__wrap_iter<Backend::Google::FullHashRequest *>,std::__wrap_iter<Backend::Google::FullHashRequest *>,std::back_insert_iterator<std::vector<Backend::Google::FullHashRequest>>,0>(*(const Backend::Google::FullHashRequest **)v77, *(const Backend::Google::FullHashRequest **)&v77[8], (uint64_t)&v82);
    v41 = v80;
    if ((unint64_t)v80 >= v81)
    {
      v43 = (v80 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v43 + 1) >> 61)
        abort();
      v44 = (uint64_t)(v81 - (_QWORD)__p) >> 2;
      if (v44 <= v43 + 1)
        v44 = v43 + 1;
      if (v81 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8)
        v45 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v45 = v44;
      if (!v45)
        goto LABEL_89;
      v46 = (char *)std::__allocate_at_least[abi:sn180100]<std::allocator<Backend::LookupResult>>((uint64_t)&v81, v45);
      if (!v46)
        goto LABEL_89;
      v48 = &v46[8 * v47];
      v49 = &v46[8 * v43];
      *(_QWORD *)v49 = 0x400000000;
      v42 = v49 + 8;
      v51 = (char *)__p;
      v50 = v80;
      if (v80 != __p)
      {
        do
        {
          v52 = *((_QWORD *)v50 - 1);
          v50 -= 8;
          *((_QWORD *)v49 - 1) = v52;
          v49 -= 8;
        }
        while (v50 != v51);
        v50 = (char *)__p;
      }
      __p = v49;
      v80 = v42;
      v81 = (unint64_t)v48;
      if (v50)
        operator delete(v50);
    }
    else
    {
      if (!v80)
        goto LABEL_89;
      *(_QWORD *)v80 = 0x400000000;
      v42 = v41 + 8;
    }
    v80 = v42;
    v87 = (void **)v77;
    std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100](&v87);
  }
  if ((_QWORD)v82 == *((_QWORD *)&v82 + 1))
  {
    v54 = SSBOSLogDatabase();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v77 = 0;
      _os_log_impl(&dword_1DBCBE000, v54, OS_LOG_TYPE_INFO, "There are no matches in databases with given url", v77, 2u);
    }
    v55 = SSBOSLogDatabase();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
      SafeBrowsing::BrowsingDatabaseCoordinator::performURLLookup((uint64_t)v7, v55, v56, v57, v58, v59, v60, v61);
    v71 = 0;
    __dst = 0;
    v73 = 0;
    v62 = __p;
    v63 = v80 - (_BYTE *)__p;
    if (v80 != __p)
    {
      std::vector<Backend::LookupResult>::__vallocate[abi:sn180100](&v71, v63 >> 3);
      v64 = (char *)__dst;
      memmove(__dst, v62, v63);
      __dst = &v64[8 * (v63 >> 3)];
    }
    v65 = std::system_category();
    *(_QWORD *)v77 = 0;
    *(_QWORD *)&v77[8] = v65;
    v66 = a4[3];
    if (v66)
    {
      (*(void (**)(uint64_t, void **, uint8_t *))(*(_QWORD *)v66 + 48))(v66, &v71, v77);
      if (v71)
      {
        __dst = v71;
        operator delete(v71);
      }
      goto LABEL_78;
    }
    std::__throw_bad_function_call[abi:sn180100]();
LABEL_89:
    __break(1u);
    return;
  }
  v69 = v82;
  v70 = v83;
  v83 = 0;
  v82 = 0uLL;
  v53 = (_QWORD *)a4[3];
  if (v53)
  {
    if (v53 == a4)
    {
      v89 = v88;
      (*(void (**)(_QWORD *, _BYTE *))(*a4 + 24))(a4, v88);
    }
    else
    {
      v89 = (_BYTE *)a4[3];
      a4[3] = 0;
    }
  }
  else
  {
    v89 = 0;
  }
  SafeBrowsing::LookupContext::checkFullHashes(a2, 1, (const Backend::Google::FullHashRequest **)&v69, (uint64_t)v88);
  v67 = v89;
  if (v89 == v88)
  {
    v68 = 4;
    v67 = v88;
    goto LABEL_76;
  }
  if (v89)
  {
    v68 = 5;
LABEL_76:
    (*(void (**)(void))(*v67 + 8 * v68))();
  }
  *(_QWORD *)v77 = &v69;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)v77);
LABEL_78:
  if (__p)
  {
    v80 = (char *)__p;
    operator delete(__p);
  }
  __p = &v82;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)&__p);
  if (v84[0])
  {
    v84[1] = v84[0];
    operator delete(v84[0]);
  }
  if (*(_QWORD *)buf)
  {
    v86 = *(void **)buf;
    operator delete(*(void **)buf);
  }

}

void sub_1DBD07E94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char *__p,char *a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35)
{
  void *v35;
  uint64_t v36;
  void *v38;

  if (__p)
  {
    a29 = __p;
    operator delete(__p);
  }
  __p = &a31;
  std::vector<Backend::Google::FullHashRequest>::__destroy_vector::operator()[abi:sn180100]((void ***)&__p);
  if (a34)
  {
    a35 = (uint64_t)a34;
    operator delete(a34);
  }
  v38 = *(void **)(v36 - 192);
  if (v38)
  {
    *(_QWORD *)(v36 - 184) = v38;
    operator delete(v38);
  }

  _Unwind_Resume(a1);
}

void SafeBrowsing::BrowsingDatabaseCoordinator::~BrowsingDatabaseCoordinator(SafeBrowsing::BrowsingDatabaseCoordinator *this)
{
  void **v2;
  void **v3;

  *(_QWORD *)this = off_1EA3EADE8;
  v2 = (void **)((char *)this + 56);
  v3 = (void **)((char *)this + 104);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v3);
  v3 = (void **)((char *)this + 80);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v3);
  v3 = v2;
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v3);
  SafeBrowsing::DatabaseCoordinator::~DatabaseCoordinator(this);
}

{
  void **v2;
  void *v3;
  void **v4;

  *(_QWORD *)this = off_1EA3EADE8;
  v2 = (void **)((char *)this + 56);
  v4 = (void **)((char *)this + 104);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v4);
  v4 = (void **)((char *)this + 80);
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v4);
  v4 = v2;
  std::vector<Backend::Google::DatabaseInfo>::__destroy_vector::operator()[abi:sn180100](&v4);
  SafeBrowsing::DatabaseCoordinator::~DatabaseCoordinator(this);
  operator delete(v3);
}

const Backend::Google::FullHashRequest *std::__unwrap_and_dispatch[abi:sn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::__wrap_iter<Backend::Google::FullHashRequest *>,std::__wrap_iter<Backend::Google::FullHashRequest *>,std::back_insert_iterator<std::vector<Backend::Google::FullHashRequest>>,0>(const Backend::Google::FullHashRequest *a1, const Backend::Google::FullHashRequest *a2, uint64_t a3)
{
  const Backend::Google::FullHashRequest *v3;
  const Backend::Google::FullHashRequest *v4;
  uint64_t v6;

  v3 = a1;
  v6 = a3;
  if (a1 == a2)
    return a1;
  v4 = a2;
  do
  {
    std::back_insert_iterator<std::vector<Backend::Google::FullHashRequest>>::operator=[abi:sn180100](&v6, v3);
    v3 = (const Backend::Google::FullHashRequest *)((char *)v3 + 72);
  }
  while (v3 != v4);
  return v4;
}

void sub_1DBD08150(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void SafeBrowsing::DatabaseCoordinator::~DatabaseCoordinator(SafeBrowsing::DatabaseCoordinator *this)
{
  std::__shared_weak_count *v2;
  void **v3;

  *(_QWORD *)this = off_1EA3EAD98;
  v3 = (void **)((char *)this + 32);
  std::vector<std::function<void ()(std::error_code)>>::__destroy_vector::operator()[abi:sn180100](&v3);
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

_QWORD *std::__function::__func<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0>,void ()(std::error_code)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = off_1EA3EB5C8;
  v2 = a1 + 3;
  v3 = (_QWORD *)a1[6];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 1));
  return a1;
}

void std::__function::__func<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0>,void ()(std::error_code)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = off_1EA3EB5C8;
  v2 = a1 + 3;
  v3 = (_QWORD *)a1[6];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 1));
  operator delete(a1);
}

_QWORD *std::__function::__func<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0>,void ()(std::error_code)>::__clone(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)(a1 + 8);
  v2 = operator new(0x38uLL);
  *v2 = off_1EA3EB5C8;
  std::__compressed_pair_elem<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0 const&,0ul>(v2 + 1, v1);
  return v2;
}

void sub_1DBD082B4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0>,void ()(std::error_code)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1EA3EB5C8;
  return std::__compressed_pair_elem<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0 const&,0ul>(a2 + 1, (_QWORD *)(a1 + 8));
}

uint64_t std::__function::__func<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0>,void ()(std::error_code)>::destroy(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 24);
  v3 = *(_QWORD **)(a1 + 48);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](a1 + 8);
}

void std::__function::__func<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0>,void ()(std::error_code)>::destroy_deallocate(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = a1 + 3;
  v3 = (_QWORD *)a1[6];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100]((uint64_t)(a1 + 1));
  operator delete(a1);
}

uint64_t std::__function::__func<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0>,void ()(std::error_code)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  const std::error_category *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;

  v2 = *a2;
  if (*a2)
  {
    v3 = (const std::error_category *)a2[1];
    v4 = a1 + 24;
    v5 = 0;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(_QWORD *)(v6 + 56);
    v8 = *(_QWORD *)(v6 + 64);
    v9 = v7 + 112;
    if (v7 != v8 && v9 != v8)
    {
      do
      {
        if (*(_QWORD *)(v9 + 48) < *(_QWORD *)(v7 + 48))
          v7 = v9;
        v9 += 112;
      }
      while (v9 != v8);
    }
    if (v7 == v8)
      v11 = 0;
    else
      v11 = *(_QWORD *)(v7 + 48);
    v12 = a1 + 24;
    v3 = std::system_category();
    v4 = v12;
    v5 = v11;
    v2 = 0;
  }
  return std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>::operator()(v4, v5, v2, (uint64_t)v3);
}

_QWORD *std::__compressed_pair_elem<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0,0,false>::__compressed_pair_elem[abi:sn180100]<SafeBrowsing::BrowsingDatabaseCoordinator::getLastDatabaseUpdateTime(SafeBrowsing::LookupContext &,std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>)::$_0 const&,0ul>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  std::__function::__value_func<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&,NSError *)>::__value_func[abi:sn180100]((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_1DBD08468(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<long long,std::ratio<1l,1000000l>>>,std::error_code)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  std::string *v6;
  _QWORD v7[2];
  uint64_t v8;

  v8 = a2;
  v7[0] = a3;
  v7[1] = a4;
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
    return (*(uint64_t (**)(uint64_t, uint64_t *, _QWORD *))(*(_QWORD *)v4 + 48))(v4, &v8, v7);
  v6 = std::__throw_bad_function_call[abi:sn180100]();
  return -[NSURL(SSBExtras) ssb_hasUserInfo](v6);
}

void sub_1DBD08540(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBD085A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBD0860C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1DBD086F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  _Unwind_Resume(exception_object);
}

void sub_1DBD0882C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1DBD088AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1DBD08AE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBD08B7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1DBD08C1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1DBD08D2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1DBD08F3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t Backend::Google::SSBUtilities::isKindOfNSNumber(Backend::Google::SSBUtilities *this, objc_object *a2)
{
  Backend::Google::SSBUtilities *v2;
  char isKindOfClass;

  v2 = this;
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  return isKindOfClass & 1;
}

void sub_1DBD09024(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t Backend::Google::SSBUtilities::isKindOfNSString(Backend::Google::SSBUtilities *this, objc_object *a2)
{
  Backend::Google::SSBUtilities *v2;
  char isKindOfClass;

  v2 = this;
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  return isKindOfClass & 1;
}

void sub_1DBD09078(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t Backend::Google::SSBUtilities::isKindOfNSArray(Backend::Google::SSBUtilities *this, objc_object *a2)
{
  Backend::Google::SSBUtilities *v2;
  char isKindOfClass;

  v2 = this;
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  return isKindOfClass & 1;
}

void sub_1DBD090CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t Backend::Google::SSBUtilities::isKindOfNSDictionary(Backend::Google::SSBUtilities *this, objc_object *a2)
{
  Backend::Google::SSBUtilities *v2;
  char isKindOfClass;

  v2 = this;
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();

  return isKindOfClass & 1;
}

void sub_1DBD09120(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id Backend::Google::SSBUtilities::hexStringAsNSData(Backend::Google::SSBUtilities *this, NSString *a2)
{
  Backend::Google::SSBUtilities *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  id v8;
  void *v9;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v2 = this;
  v3 = -[Backend::Google::SSBUtilities length](v2, "length");
  v4 = v3;
  if ((v3 & 1) != 0)
  {
    v9 = 0;
  }
  else
  {
    v5 = v3 >> 1;
    MEMORY[0x1E0C80A78]();
    if (v4)
    {
      v6 = 0;
      v7 = (char *)v11 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
      do
      {
        -[Backend::Google::SSBUtilities substringWithRange:](v2, "substringWithRange:", v6, 2);
        v8 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        *v7++ = strtoul((const char *)objc_msgSend(v8, "UTF8String"), 0, 16);

        v6 += 2;
      }
      while (v6 < v4);
    }
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", (char *)v11 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v4 >> 1);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v9;
}

void sub_1DBD09250(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t Backend::Google::SSBUtilities::isInternalInstall(Backend::Google::SSBUtilities *this)
{
  if (Backend::Google::SSBUtilities::isInternalInstall(void)::onceToken != -1)
    dispatch_once(&Backend::Google::SSBUtilities::isInternalInstall(void)::onceToken, &__block_literal_global_2);
  return Backend::Google::SSBUtilities::isInternalInstall(void)::isInternalInstall;
}

uint64_t ___ZN7Backend6Google12SSBUtilities17isInternalInstallEv_block_invoke()
{
  uint64_t result;

  result = os_variant_allows_internal_security_policies();
  Backend::Google::SSBUtilities::isInternalInstall(void)::isInternalInstall = result;
  return result;
}

id Backend::Google::SSBUtilities::currentCountryCode(Backend::Google::SSBUtilities *this)
{
  void *v1;
  uint64_t v2;
  void *v3;
  NSObject *v4;
  uint64_t v5;
  uint8_t v7[24];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v1 = (void *)CFPreferencesCopyValue(CFSTR("AppleLocale"), (CFStringRef)*MEMORY[0x1E0C9B228], CFSTR("mobile"), (CFStringRef)*MEMORY[0x1E0C9B230]);
  if (v1 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    v4 = (id)SSBOSLogPlatform();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = objc_opt_class();
      Backend::Google::SSBUtilities::currentCountryCode(v5, v7, v4);
    }

    v3 = 0;
  }
  else
  {
    if (objc_msgSend(v1, "length") == 2)
      v2 = 0;
    else
      v2 = objc_msgSend(v1, "length") - 2;
    objc_msgSend(v1, "substringFromIndex:", v2);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v3;
}

void sub_1DBD093F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t Backend::Google::SSBUtilities::shouldConsultWithTencent(Backend::Google::SSBUtilities *this)
{
  if (Backend::Google::SSBUtilities::shouldConsultWithTencent(void)::onceToken != -1)
    dispatch_once(&Backend::Google::SSBUtilities::shouldConsultWithTencent(void)::onceToken, &__block_literal_global_11_0);
  return Backend::Google::SSBUtilities::shouldConsultWithTencent(void)::shouldConsultWithTencent;
}

void ___ZN7Backend6Google12SSBUtilities24shouldConsultWithTencentEv_block_invoke(Backend::Google::SSBUtilities *a1)
{
  void *v1;
  uint64_t v2;
  id v3;
  _QWORD v4[4];
  id v5;

  Backend::Google::SSBUtilities::shouldConsultWithTencent(void)::shouldConsultWithTencent = ___ZN7Backend6Google12SSBUtilities24shouldConsultWithTencentEv_block_invoke_2(a1);
  objc_msgSend(MEMORY[0x1E0CB37D0], "defaultCenter");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = *MEMORY[0x1E0C99720];
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZN7Backend6Google12SSBUtilities24shouldConsultWithTencentEv_block_invoke_3;
  v4[3] = &unk_1EA3EC690;
  v5 = &__block_literal_global_13_0;
  v3 = (id)objc_msgSend(v1, "addObserverForName:object:queue:usingBlock:", v2, 0, 0, v4);

}

void sub_1DBD09508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

uint64_t ___ZN7Backend6Google12SSBUtilities24shouldConsultWithTencentEv_block_invoke_2(Backend::Google::SSBUtilities *a1)
{
  void *v1;
  char v2;
  uint64_t v3;
  void *v4;

  if (Backend::Google::SSBUtilities::isInternalInstall(void)::onceToken != -1)
    dispatch_once(&Backend::Google::SSBUtilities::isInternalInstall(void)::onceToken, &__block_literal_global_2);
  if (Backend::Google::SSBUtilities::isInternalInstall(void)::isInternalInstall)
  {
    objc_msgSend(MEMORY[0x1E0C99EA0], "standardUserDefaults");
    v1 = (void *)objc_claimAutoreleasedReturnValue();
    v2 = objc_msgSend(v1, "BOOLForKey:", CFSTR("DebugSafeBrowsingShouldConsultWithTencent"));

    if ((v2 & 1) != 0)
      return 1;
  }
  Backend::Google::SSBUtilities::currentCountryCode(a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v4, "isEqualToString:", CFSTR("CN")) & 1) != 0)
    v3 = 1;
  else
    v3 = objc_msgSend(v4, "isEqualToString:", CFSTR("HK"));

  return v3;
}

void sub_1DBD095E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZN7Backend6Google12SSBUtilities24shouldConsultWithTencentEv_block_invoke_3(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (Backend::Google::SSBUtilities::shouldConsultWithTencent(void)::shouldConsultWithTencent != (_DWORD)result)
  {
    Backend::Google::SSBUtilities::shouldConsultWithTencent(void)::shouldConsultWithTencent = result;
    return notify_post("com.apple.Safari.SafeBrowsing.RegionCodeDidChange");
  }
  return result;
}

uint64_t Backend::Google::SSBUtilities::shouldConsultWithApple(Backend::Google::SSBUtilities *this)
{
  return 1;
}

void Backend::Google::SSBUtilities::reportActivity(Backend::Google::SSBUtilities *this)
{
  id v1;

  v1 = (id)nw_activity_create();
  nw_activity_activate();
  nw_activity_complete_with_reason();

}

void sub_1DBD09680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t Backend::Google::ThreatListDescriptor::toString@<X0>(Backend::Google::ThreatListDescriptor *this@<X0>, _QWORD *a2@<X8>)
{
  unsigned int v4;
  const char *v5;
  size_t v6;
  unsigned int v7;
  const char *v8;
  size_t v9;
  int v10;
  const char *v11;
  const char *v12;
  size_t v13;
  uint64_t v15;
  _QWORD v16[10];
  char v17;
  uint64_t v18;
  char v19;

  std::ostringstream::basic_ostringstream[abi:sn180100]((uint64_t)&v15);
  v4 = *(_DWORD *)this - 2;
  if (v4 > 2)
    v5 = "malware";
  else
    v5 = off_1EA3EC6B0[v4];
  v6 = strlen(v5);
  std::__put_character_sequence[abi:sn180100]<char,std::char_traits<char>>(&v15, (uint64_t)v5, v6);
  v19 = 44;
  std::__put_character_sequence[abi:sn180100]<char,std::char_traits<char>>(&v15, (uint64_t)&v19, 1);
  v7 = *((_DWORD *)this + 1) - 2;
  if (v7 > 5)
    v8 = "windows";
  else
    v8 = off_1EA3EC6C8[v7];
  v9 = strlen(v8);
  std::__put_character_sequence[abi:sn180100]<char,std::char_traits<char>>(&v15, (uint64_t)v8, v9);
  v19 = 44;
  std::__put_character_sequence[abi:sn180100]<char,std::char_traits<char>>(&v15, (uint64_t)&v19, 1);
  v10 = *((_DWORD *)this + 2);
  v11 = "url_expression";
  if (v10 == 2)
    v11 = "binary_digest";
  if (v10 == 3)
    v12 = "ip_range";
  else
    v12 = v11;
  v13 = strlen(v12);
  std::__put_character_sequence[abi:sn180100]<char,std::char_traits<char>>(&v15, (uint64_t)v12, v13);
  std::stringbuf::str[abi:sn180100]<std::allocator<char>>((uint64_t)v16, a2);
  v15 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v16[-1] + *(_QWORD *)(v15 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v16[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v17 < 0)
    operator delete((void *)v16[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1DF0B89D4](&v18);
}

void sub_1DBD09834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::basic_ostringstream[abi:sn180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x1E0DE4FE0];
  v3 = MEMORY[0x1E0DE4FE0] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x1E0DE4FE0] + 64;
  v4 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1DBD09918(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1DF0B89D4](v1);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F60];
  v3 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1DF0B89D4](a1 + 112);
  return a1;
}

uint64_t Backend::Google::operator<(int *a1, int *a2)
{
  int *v3[3];
  int *v4[3];

  v4[0] = a1;
  v4[1] = a1 + 1;
  v4[2] = a1 + 2;
  v3[0] = a2;
  v3[1] = a2 + 1;
  v3[2] = a2 + 2;
  return (std::__tuple_compare_three_way[abi:sn180100]<Backend::Google::ThreatType const&,Backend::Google::PlatformType const&,Backend::Google::ThreatEntryType const&,Backend::Google::ThreatType const&,Backend::Google::PlatformType const&,Backend::Google::ThreatEntryType const&,0ul,1ul,2ul>(v4, v3) >> 7) & 1;
}

BOOL Backend::Google::operator==(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)a1 == *(_QWORD *)a2 && *(_DWORD *)(a1 + 8) == (unint64_t)*(unsigned int *)(a2 + 8);
}

BOOL Backend::Google::operator!=(_DWORD *a1, _DWORD *a2)
{
  return *a1 != *a2 || a1[1] != a2[1] || a1[2] != a2[2];
}

id Backend::Google::ThreatListDescriptor::toXPC(Backend::Google::ThreatListDescriptor *this)
{
  xpc_object_t v2;

  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v2, "threatType", *(int *)this);
  xpc_dictionary_set_uint64(v2, "platformType", *((int *)this + 1));
  xpc_dictionary_set_uint64(v2, "threatEntryType", *((int *)this + 2));
  xpc_dictionary_set_uint64(v2, "safeBrowsingProvider", *((int *)this + 3));
  return v2;
}

void sub_1DBD09AE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void Backend::Google::ThreatListDescriptor::fromXPC(void *a1@<X0>, _BYTE *a2@<X8>)
{
  id v3;
  void *v4;
  void *v5;
  char v6;
  __int128 v7;

  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    *a2 = 0;
    a2[16] = 0;
    goto LABEL_10;
  }
  if (!Backend::Google::getEnumValue<Backend::Google::ThreatType>(v3, "threatType", (int *)&v7)
    || !Backend::Google::getEnumValue<Backend::Google::PlatformType>(v4, "platformType", (int *)&v7 + 1)
    || !Backend::Google::getEnumValue<Backend::Google::ThreatEntryType>(v4, "threatEntryType", (int *)&v7 + 2))
  {
    goto LABEL_7;
  }
  xpc_dictionary_get_value(v4, "safeBrowsingProvider");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v5)
  {
    HIDWORD(v7) = 1;
    goto LABEL_12;
  }
  if (Backend::Google::getEnumValue<Backend::Google::SafeBrowsingProvider>(v4, "safeBrowsingProvider", (int *)&v7 + 3))
  {
LABEL_12:
    *(_OWORD *)a2 = v7;
    v6 = 1;
    goto LABEL_8;
  }
LABEL_7:
  v6 = 0;
  *a2 = 0;
LABEL_8:
  a2[16] = v6;
LABEL_10:

}

void sub_1DBD09BF0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL Backend::Google::getEnumValue<Backend::Google::ThreatType>(void *a1, const char *a2, int *a3)
{
  uint64_t v4;
  void *v5;
  _BOOL8 v6;
  int value;

  xpc_dictionary_get_value(a1, a2);
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)v4;
  if (v4 && MEMORY[0x1DF0B91F0](v4) == MEMORY[0x1E0C81398])
  {
    value = xpc_uint64_get_value(v5);
    *a3 = value;
    v6 = EnumTraits::isValidEnum<Backend::Google::ThreatType>(value);
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_1DBD09C68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL Backend::Google::getEnumValue<Backend::Google::PlatformType>(void *a1, const char *a2, int *a3)
{
  uint64_t v4;
  void *v5;
  _BOOL8 v6;
  int value;

  xpc_dictionary_get_value(a1, a2);
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)v4;
  if (v4 && MEMORY[0x1DF0B91F0](v4) == MEMORY[0x1E0C81398])
  {
    value = xpc_uint64_get_value(v5);
    *a3 = value;
    v6 = EnumTraits::isValidEnum<Backend::Google::PlatformType>(value);
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_1DBD09CE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL Backend::Google::getEnumValue<Backend::Google::ThreatEntryType>(void *a1, const char *a2, int *a3)
{
  uint64_t v4;
  void *v5;
  _BOOL8 v6;
  int value;

  xpc_dictionary_get_value(a1, a2);
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)v4;
  if (v4 && MEMORY[0x1DF0B91F0](v4) == MEMORY[0x1E0C81398])
  {
    value = xpc_uint64_get_value(v5);
    *a3 = value;
    v6 = EnumTraits::isValidEnum<Backend::Google::ThreatEntryType>(value);
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_1DBD09D58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL Backend::Google::getEnumValue<Backend::Google::SafeBrowsingProvider>(void *a1, const char *a2, int *a3)
{
  uint64_t v4;
  void *v5;
  _BOOL8 v6;
  int value;

  xpc_dictionary_get_value(a1, a2);
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)v4;
  if (v4 && MEMORY[0x1DF0B91F0](v4) == MEMORY[0x1E0C81398])
  {
    value = xpc_uint64_get_value(v5);
    *a3 = value;
    v6 = EnumTraits::isValidEnum<Backend::Google::ThreatEntryType>(value);
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_1DBD09DD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__tuple_compare_three_way[abi:sn180100]<Backend::Google::ThreatType const&,Backend::Google::PlatformType const&,Backend::Google::ThreatEntryType const&,Backend::Google::ThreatType const&,Backend::Google::PlatformType const&,Backend::Google::ThreatEntryType const&,0ul,1ul,2ul>(int **a1, int **a2)
{
  int v2;
  int v3;
  BOOL v4;
  uint64_t v5;
  int v6;
  int v7;
  BOOL v8;
  int v9;
  int v10;
  BOOL v11;

  v2 = **a1;
  v3 = **a2;
  v4 = v2 == v3;
  if (v2 < v3)
    v5 = 0xFFFFFFFFLL;
  else
    v5 = 1;
  if (v4)
  {
    v6 = *a1[1];
    v7 = *a2[1];
    v8 = v6 == v7;
    v5 = v6 < v7 ? 0xFFFFFFFFLL : 1;
    if (v8)
    {
      v9 = *a1[2];
      v10 = *a2[2];
      v11 = v9 == v10;
      if (v9 < v10)
        LODWORD(v5) = -1;
      else
        LODWORD(v5) = 1;
      if (v11)
        return 0;
      else
        return v5;
    }
  }
  return v5;
}

_QWORD *std::__put_character_sequence[abi:sn180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x1DF0B88C0](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x1E0DE4A90]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:sn180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x1DF0B88CC](v13);
  return a1;
}

void sub_1DBD09F4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x1DF0B88CC](&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:sn180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:sn180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_1DBD0A094(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:sn180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

uint64_t std::stringbuf::str[abi:sn180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  unint64_t v4;
  _QWORD *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;

  result = std::stringbuf::view[abi:sn180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
LABEL_15:
    abort();
  v5 = (_QWORD *)result;
  v6 = v4;
  if (v4 > 0x16)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    result = (uint64_t)operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = result;
    a2 = (_QWORD *)result;
  }
  else
  {
    *((_BYTE *)a2 + 23) = v4;
  }
  v9 = (char *)a2 + v6;
  if (a2 <= v5 && v9 > (_BYTE *)v5)
  {
    __break(1u);
    goto LABEL_15;
  }
  if (v6)
    result = (uint64_t)memmove(a2, v5, v6);
  *v9 = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:sn180100](uint64_t a1)
{
  int v2;
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  v2 = *(_DWORD *)(a1 + 96);
  if ((v2 & 0x10) != 0)
  {
    v4 = *(_QWORD *)(a1 + 88);
    v5 = *(_QWORD *)(a1 + 48);
    if (v4 < v5)
    {
      *(_QWORD *)(a1 + 88) = v5;
      v4 = v5;
    }
    result = *(_QWORD *)(a1 + 40);
    if ((uint64_t)(v4 - result) < 0)
LABEL_9:
      __break(1u);
  }
  else
  {
    if ((v2 & 8) == 0)
      return 0;
    result = *(_QWORD *)(a1 + 16);
    if (*(_QWORD *)(a1 + 32) - result < 0)
      goto LABEL_9;
  }
  return result;
}

void Backend::xpcConnectionClientIdentifierFromConnection(_QWORD *a1@<X8>)
{
  _BYTE *v2;
  char *string_ptr;
  size_t length;
  xpc_object_t xstring;

  xstring = (xpc_object_t)xpc_connection_copy_entitlement_value();
  if (xstring && MEMORY[0x1DF0B91F0]() == MEMORY[0x1E0C81390])
  {
    string_ptr = (char *)xpc_string_get_string_ptr(xstring);
    length = xpc_string_get_length(xstring);
    v2 = operator new(0x18uLL);
    std::string::basic_string[abi:sn180100](v2, string_ptr, length);
  }
  else
  {
    v2 = 0;
  }
  *a1 = v2;

}

void sub_1DBD0A2EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  operator delete(v10);

  _Unwind_Resume(a1);
}

char **Backend::xpcConnectionClientStringFromIdentifier@<X0>(char **result@<X0>, char **a2@<X8>)
{
  char *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  BOOL v12;
  char *v13;
  uint64_t v14;
  int v15;
  BOOL v16;
  char *v18;

  v2 = *result;
  if (!*result)
  {
LABEL_30:
    v18 = "ThirdParty";
    return std::string::basic_string[abi:sn180100]<0>(a2, v18);
  }
  v3 = v2[23];
  v4 = (uint64_t *)*result;
  v5 = v3;
  if ((v2[23] & 0x80000000) == 0
    || (v5 = *((_QWORD *)v2 + 1), (v5 & 0x8000000000000000) == 0)
    && ((v4 = *(uint64_t **)v2, v5) ? (v6 = v4 == 0) : (v6 = 0), !v6))
  {
    if (v5 == 22)
    {
      v7 = *v4;
      v8 = v4[1];
      v9 = *(uint64_t *)((char *)v4 + 14);
      v10 = v7 == 0x6C7070612E6D6F63 && v8 == 0x656C69626F6D2E65;
      if (v10 && v9 == 0x697261666173656CLL)
        goto LABEL_31;
    }
    if ((v3 & 0x80) == 0
      || (v3 = *((_QWORD *)v2 + 1), (v3 & 0x8000000000000000) == 0)
      && ((v2 = *(char **)v2, v3) ? (v12 = v2 == 0) : (v12 = 0), !v12))
    {
      if (v3 != 17)
        goto LABEL_30;
      v13 = *(char **)v2;
      v14 = *((_QWORD *)v2 + 1);
      v15 = v2[16];
      v16 = v13 == (char *)0x6C7070612E6D6F63 && v14 == 0x6974756273732E65;
      if (!v16 || v15 != 108)
        goto LABEL_30;
LABEL_31:
      v18 = "Safari";
      return std::string::basic_string[abi:sn180100]<0>(a2, v18);
    }
  }
  __break(1u);
  return result;
}

uint64_t Backend::xpcConnectionClientIsSafari(uint64_t result)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  BOOL v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;

  v1 = *(uint64_t **)result;
  if (!*(_QWORD *)result)
    return 0;
  v2 = *((unsigned __int8 *)v1 + 23);
  v3 = *(uint64_t **)result;
  v4 = v2;
  if (*((char *)v1 + 23) < 0)
  {
    v4 = v1[1];
    if (v4 < 0)
      goto LABEL_34;
    v3 = (uint64_t *)*v1;
    if (v4 && v3 == 0)
      goto LABEL_34;
  }
  if (v4 == 22)
  {
    v6 = *v3;
    v7 = v3[1];
    v8 = *(uint64_t *)((char *)v3 + 14);
    v9 = v6 == 0x6C7070612E6D6F63 && v7 == 0x656C69626F6D2E65;
    if (v9 && v8 == 0x697261666173656CLL)
      return 1;
  }
  if ((v2 & 0x80) != 0)
  {
    v2 = v1[1];
    if (v2 < 0 || ((v1 = (uint64_t *)*v1, v2) ? (v11 = v1 == 0) : (v11 = 0), v11))
    {
LABEL_34:
      __break(1u);
      return result;
    }
  }
  if (v2 != 17)
    return 0;
  v12 = (uint64_t *)*v1;
  v13 = v1[1];
  v14 = *((unsigned __int8 *)v1 + 16);
  return v12 == (uint64_t *)0x6C7070612E6D6F63 && v13 == 0x6974756273732E65 && v14 == 108;
}

id Backend::xpcConnectionClientAuditTokenDataFromConnection(void *a1)
{
  id v1;
  void *v2;
  uint64_t v4;

  v1 = a1;
  xpc_connection_get_audit_token();
  objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v4, 32);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

void sub_1DBD0A56C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t Platform::Transaction::Transaction(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  uint64_t v5;

  v3 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v3;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  MEMORY[0x1DF0B9238]();
  {
    Platform::OnceConstructedNeverDestroyed<Platform::SynchronizedValue<std::unordered_set<Platform::Transaction *>>>::OnceConstructedNeverDestroyed(&Platform::activeTransactions(void)::activeTransactions);
  }
  std::mutex::lock(&stru_1ED04EB80);
  v5 = a1;
  std::__hash_table<Platform::Transaction *,std::hash<Platform::Transaction *>,std::equal_to<Platform::Transaction *>,std::allocator<Platform::Transaction *>>::__emplace_unique_key_args<Platform::Transaction *,Platform::Transaction *>((uint64_t)&unk_1ED04EBC0, &v5, &v5);
  std::mutex::unlock(&stru_1ED04EB80);
  return a1;
}

void Platform::Transaction::~Transaction(void **this)
{
  void **v2;

  {
    Platform::OnceConstructedNeverDestroyed<Platform::SynchronizedValue<std::unordered_set<Platform::Transaction *>>>::OnceConstructedNeverDestroyed(&Platform::activeTransactions(void)::activeTransactions);
  }
  std::mutex::lock(&stru_1ED04EB80);
  v2 = this;
  std::__hash_table<Platform::Transaction *,std::hash<Platform::Transaction *>,std::equal_to<Platform::Transaction *>,std::allocator<Platform::Transaction *>>::__erase_unique<Platform::Transaction *>(qword_1ED04EBC0, &v2);
  std::mutex::unlock(&stru_1ED04EB80);
  MEMORY[0x1DF0B9244]();
  if (*((char *)this + 23) < 0)
    operator delete(*this);
}

void Platform::Transaction::activeTransactionDescriptions(uint64_t a1@<X8>)
{
  uint64_t i;
  char *v4;
  unint64_t v5;
  uint64_t v6;
  char v7;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  {
    Platform::OnceConstructedNeverDestroyed<Platform::SynchronizedValue<std::unordered_set<Platform::Transaction *>>>::OnceConstructedNeverDestroyed(&Platform::activeTransactions(void)::activeTransactions);
  }
  std::mutex::lock(&stru_1ED04EB80);
  for (i = qword_1ED04EBD0; i; i = *(_QWORD *)i)
    std::vector<std::string>::push_back[abi:sn180100]((std::string **)a1, *(__int128 **)(i + 16));
  std::mutex::unlock(&stru_1ED04EB80);
  v4 = *(char **)(a1 + 8);
  v5 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v4[-*(_QWORD *)a1] >> 3));
  if (v4 == *(char **)a1)
    v6 = 0;
  else
    v6 = v5;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>(*(void ***)a1, v4, (uint64_t)&v7, v6, 1);
}

std::once_flag::_State_type *Platform::OnceConstructedNeverDestroyed<Platform::SynchronizedValue<std::unordered_set<Platform::Transaction *>>>::OnceConstructedNeverDestroyed(std::once_flag::_State_type *a1)
{
  unint64_t v2;
  std::once_flag::_State_type *v4;
  std::once_flag::_State_type ***v5;
  std::once_flag::_State_type **v6;

  *a1 = 0;
  v4 = a1;
  v2 = atomic_load(a1);
  if (v2 != -1)
  {
    v6 = &v4;
    v5 = &v6;
    std::__call_once(a1, &v5, (void (__cdecl *)(void *))std::__call_once_proxy[abi:sn180100]<std::tuple<Platform::OnceConstructedNeverDestroyed<Platform::SynchronizedValue<std::unordered_set<Platform::Transaction *>>>::OnceConstructedNeverDestroyed(void)::{lambda(void)#1} &&>>);
  }
  return a1;
}

double std::__call_once_proxy[abi:sn180100]<std::tuple<Platform::OnceConstructedNeverDestroyed<Platform::SynchronizedValue<std::unordered_set<Platform::Transaction *>>>::OnceConstructedNeverDestroyed(void)::{lambda(void)#1} &&>>(uint64_t ***a1)
{
  uint64_t v1;
  double result;

  v1 = ***a1;
  *(_QWORD *)(v1 + 8) = 850045863;
  result = 0.0;
  *(_OWORD *)(v1 + 16) = 0u;
  *(_OWORD *)(v1 + 32) = 0u;
  *(_OWORD *)(v1 + 48) = 0u;
  *(_OWORD *)(v1 + 64) = 0u;
  *(_OWORD *)(v1 + 80) = 0u;
  *(_QWORD *)(v1 + 96) = 0;
  *(_DWORD *)(v1 + 104) = 1065353216;
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>(void **a1, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  char *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  void **v16;
  uint64_t v17;
  void **v18;
  void **v19;
  void **v20;
  __int128 v21;
  char *v22;
  char v23;
  BOOL v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  void *v28;
  void *v29;

LABEL_1:
  v9 = a2 - 24;
  v10 = a1;
LABEL_2:
  v11 = 1 - a4;
  while (2)
  {
    a1 = v10;
    v12 = v11;
    v13 = a2 - (char *)v10;
    v14 = 0xAAAAAAAAAAAAAAABLL * ((a2 - (char *)v10) >> 3);
    switch(v14)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)a2 - 3, v10) & 0x80) != 0)
        {
          v29 = v10[2];
          v27 = *(_OWORD *)v10;
          v25 = *(_OWORD *)v9;
          v10[2] = (void *)*((_QWORD *)a2 - 1);
          *(_OWORD *)v10 = v25;
          *(_OWORD *)v9 = v27;
          *((_QWORD *)a2 - 1) = v29;
        }
        return;
      case 3uLL:
        std::__sort3[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v10, v10 + 3, (_QWORD *)a2 - 3);
        return;
      case 4uLL:
        std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((uint64_t)v10, v10 + 3, v10 + 6, (_QWORD *)a2 - 3);
        return;
      case 5uLL:
        std::__sort5[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((uint64_t)v10, v10 + 3, v10 + 6, v10 + 9, (_QWORD *)a2 - 3);
        return;
      default:
        if (v13 <= 575)
        {
          if ((a5 & 1) != 0)
            std::__insertion_sort[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((char *)v10, a2);
          else
            std::__insertion_sort_unguarded[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v10, a2);
          return;
        }
        if (v12 != 1)
        {
          v15 = v14 >> 1;
          v16 = &v10[3 * (v14 >> 1)];
          if ((unint64_t)v13 < 0xC01)
          {
            std::__sort3[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(&v10[3 * v15], v10, (_QWORD *)a2 - 3);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          else
          {
            std::__sort3[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v10, &v10[3 * v15], (_QWORD *)a2 - 3);
            v17 = 3 * v15;
            v18 = &v10[3 * v15 - 3];
            std::__sort3[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v10 + 3, v18, (_QWORD *)a2 - 6);
            v19 = v10 + 6;
            v20 = &v10[v17 + 3];
            std::__sort3[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v19, v20, (_QWORD *)a2 - 9);
            std::__sort3[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v18, v16, v20);
            v28 = a1[2];
            v26 = *(_OWORD *)a1;
            v21 = *(_OWORD *)v16;
            a1[2] = v16[2];
            *(_OWORD *)a1 = v21;
            v16[2] = v28;
            *(_OWORD *)v16 = v26;
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a1 - 3, a1) & 0x80) == 0)
          {
            v10 = std::__partition_with_equals_on_left[abi:sn180100]<std::_ClassicAlgPolicy,std::string *,std::__less<void,void> &>(a1, (unint64_t)a2);
            goto LABEL_16;
          }
LABEL_11:
          v22 = (char *)std::__partition_with_equals_on_right[abi:sn180100]<std::_ClassicAlgPolicy,std::string *,std::__less<void,void> &>((__int128 *)a1, (__int128 *)a2);
          if ((v23 & 1) == 0)
            goto LABEL_14;
          v24 = std::__insertion_sort_incomplete[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((char *)a1, v22);
          v10 = (void **)(v22 + 24);
          if (!std::__insertion_sort_incomplete[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v22 + 24, a2))
          {
            v11 = v12 + 1;
            if (v24)
              continue;
LABEL_14:
            std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>(a1, v22, a3, -v12, a5 & 1);
            v10 = (void **)(v22 + 24);
LABEL_16:
            a5 = 0;
            a4 = -v12;
            goto LABEL_2;
          }
          a4 = -v12;
          a2 = v22;
          if (v24)
            return;
          goto LABEL_1;
        }
        if (v10 != (void **)a2)
          std::__partial_sort_impl[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,std::string *>((uint64_t)v10, a2, a2, a3);
        return;
    }
  }
}

void std::__insertion_sort[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(char *__s2, char *a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v6;
  uint64_t v7;
  char *v8;
  void **v9;
  uint64_t v10;
  char *v11;
  void **v12;
  int v13;
  char *v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (__s2 != a2)
  {
    v17 = v2;
    v18 = v3;
    v6 = __s2 + 24;
    if (__s2 + 24 != a2)
    {
      v7 = 0;
      v8 = __s2;
      do
      {
        v9 = (void **)v8;
        v8 = v6;
        if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v6, v9) & 0x80) != 0)
        {
          v15 = *(_OWORD *)v8;
          v16 = *((_QWORD *)v8 + 2);
          *((_QWORD *)v8 + 1) = 0;
          *((_QWORD *)v8 + 2) = 0;
          *(_QWORD *)v8 = 0;
          v10 = v7;
          do
          {
            v11 = &__s2[v10];
            v12 = (void **)&__s2[v10 + 24];
            if (__s2[v10 + 47] < 0)
              operator delete(*v12);
            *(_OWORD *)v12 = *(_OWORD *)v11;
            *(_QWORD *)&__s2[v10 + 40] = *((_QWORD *)v11 + 2);
            v11[23] = 0;
            *v11 = 0;
            if (!v10)
            {
              v14 = __s2;
              goto LABEL_13;
            }
            v10 -= 24;
          }
          while ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(&v15, (void **)&__s2[v10]) & 0x80) != 0);
          v13 = __s2[v10 + 47];
          v14 = &__s2[v10 + 24];
          if (v13 < 0)
            operator delete(*(void **)v14);
LABEL_13:
          *(_OWORD *)v14 = v15;
          *((_QWORD *)v14 + 2) = v16;
        }
        v6 = v8 + 24;
        v7 += 24;
      }
      while (v8 + 24 != a2);
    }
  }
}

void std::__insertion_sort_unguarded[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;
  _QWORD *v10;
  uint64_t v11;
  void **v12;
  _QWORD *v14;
  unsigned __int8 v15;
  void **v16;
  __int128 v17;
  uint64_t v18;

  if (a1 != a2)
  {
    v4 = a1 + 3;
    if (a1 + 3 != a2)
    {
      v5 = 0;
      v6 = a1 - 3;
      v7 = -2;
      v8 = 1;
      do
      {
        v9 = (void **)&a1[3 * v5];
        v5 = v8;
        if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v4, v9) & 0x80) != 0)
        {
          v17 = *(_OWORD *)v4;
          v18 = v4[2];
          v4[1] = 0;
          v4[2] = 0;
          *v4 = 0;
          v10 = v6;
          v11 = v7;
          do
          {
            v12 = (void **)(v10 + 6);
            if (*((char *)v10 + 71) < 0)
              operator delete(*v12);
            *(_OWORD *)v12 = *(_OWORD *)(v10 + 3);
            v10[8] = v10[5];
            *((_BYTE *)v10 + 47) = 0;
            *((_BYTE *)v10 + 24) = 0;
            if (__CFADD__(v11++, 1))
            {
              __break(1u);
              return;
            }
            v14 = v10 - 3;
            v15 = std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(&v17, (void **)v10);
            v10 -= 3;
          }
          while ((v15 & 0x80) != 0);
          v16 = (void **)(v14 + 6);
          if (*((char *)v14 + 71) < 0)
            operator delete(*v16);
          *(_OWORD *)v16 = v17;
          v14[8] = v18;
        }
        v8 = v5 + 1;
        v4 = &a1[3 * v5 + 3];
        --v7;
        v6 += 3;
      }
      while (v4 != a2);
    }
  }
}

uint64_t std::__sort3[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(void **__s2, void **a2, _QWORD *a3)
{
  unsigned __int8 v6;
  int v7;
  void *v9;
  __int128 v10;
  void *v11;
  void *v12;
  __int128 v13;
  void *v14;
  void *v15;
  __int128 v16;
  void *v17;
  void *v18;
  __int128 v19;
  void *v20;
  void *v21;
  __int128 v22;
  void *v23;

  v6 = std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a2, __s2);
  v7 = (char)std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, a2);
  if ((v6 & 0x80) != 0)
  {
    if (v7 < 0)
    {
      v21 = __s2[2];
      v22 = *(_OWORD *)__s2;
      v23 = (void *)a3[2];
      *(_OWORD *)__s2 = *(_OWORD *)a3;
      __s2[2] = v23;
      *(_OWORD *)a3 = v22;
      a3[2] = v21;
    }
    else
    {
      v9 = __s2[2];
      v10 = *(_OWORD *)__s2;
      v11 = a2[2];
      *(_OWORD *)__s2 = *(_OWORD *)a2;
      __s2[2] = v11;
      *(_OWORD *)a2 = v10;
      a2[2] = v9;
      if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, a2) & 0x80) != 0)
      {
        v12 = a2[2];
        v13 = *(_OWORD *)a2;
        v14 = (void *)a3[2];
        *(_OWORD *)a2 = *(_OWORD *)a3;
        a2[2] = v14;
        *(_OWORD *)a3 = v13;
        a3[2] = v12;
        return 2;
      }
    }
  }
  else
  {
    if ((v7 & 0x80000000) == 0)
      return 0;
    v15 = a2[2];
    v16 = *(_OWORD *)a2;
    v17 = (void *)a3[2];
    *(_OWORD *)a2 = *(_OWORD *)a3;
    a2[2] = v17;
    *(_OWORD *)a3 = v16;
    a3[2] = v15;
    if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a2, __s2) & 0x80) != 0)
    {
      v18 = __s2[2];
      v19 = *(_OWORD *)__s2;
      v20 = a2[2];
      *(_OWORD *)__s2 = *(_OWORD *)a2;
      __s2[2] = v20;
      *(_OWORD *)a2 = v19;
      a2[2] = v18;
      return 2;
    }
  }
  return 1;
}

void **std::__partition_with_equals_on_left[abi:sn180100]<std::_ClassicAlgPolicy,std::string *,std::__less<void,void> &>(void **a1, unint64_t a2)
{
  void **result;
  void **v5;
  void **v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  void **v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  void *v15;
  __int128 v16;
  void *v17;

  v14 = *(_OWORD *)a1;
  v15 = a1[2];
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  result = (void **)std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(&v14, (void **)(a2 - 24));
  if ((result & 0x80) != 0)
  {
    v6 = a1;
    while (1)
    {
      v6 += 3;
      if (v6 == (void **)a2)
        goto LABEL_27;
      result = (void **)std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(&v14, v6);
      if ((result & 0x80) != 0)
        goto LABEL_9;
    }
  }
  v5 = a1 + 3;
  do
  {
    v6 = v5;
    if ((unint64_t)v5 >= a2)
      break;
    result = (void **)std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(&v14, v5);
    v5 = v6 + 3;
  }
  while ((result & 0x80) == 0);
LABEL_9:
  v7 = a2;
  if ((unint64_t)v6 < a2)
  {
    v7 = a2;
    while ((void **)v7 != a1)
    {
      v7 -= 24;
      result = (void **)std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(&v14, (void **)v7);
      if ((result & 0x80) == 0)
        goto LABEL_19;
    }
    goto LABEL_27;
  }
LABEL_19:
  if ((unint64_t)v6 < v7)
  {
    v8 = *(_OWORD *)v6;
    v17 = v6[2];
    v16 = v8;
    v9 = *(_OWORD *)v7;
    v6[2] = *(void **)(v7 + 16);
    *(_OWORD *)v6 = v9;
    v10 = v16;
    *(_QWORD *)(v7 + 16) = v17;
    *(_OWORD *)v7 = v10;
    while (1)
    {
      v6 += 3;
      if (v6 == (void **)a2)
        break;
      result = (void **)std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(&v14, v6);
      if ((result & 0x80) != 0)
      {
        while ((void **)v7 != a1)
        {
          v7 -= 24;
          result = (void **)std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(&v14, (void **)v7);
          if ((result & 0x80) == 0)
            goto LABEL_19;
        }
        break;
      }
    }
LABEL_27:
    __break(1u);
    return result;
  }
  v11 = v6 - 3;
  if (v6 - 3 == a1)
  {
    if (*((char *)v6 - 1) < 0)
      operator delete(*v11);
  }
  else
  {
    if (*((char *)a1 + 23) < 0)
      operator delete(*a1);
    v12 = *(_OWORD *)v11;
    a1[2] = *(v6 - 1);
    *(_OWORD *)a1 = v12;
    *((_BYTE *)v6 - 1) = 0;
    *((_BYTE *)v6 - 24) = 0;
  }
  v13 = v14;
  *(v6 - 1) = v15;
  *(_OWORD *)v11 = v13;
  return v6;
}

__int128 *std::__partition_with_equals_on_right[abi:sn180100]<std::_ClassicAlgPolicy,std::string *,std::__less<void,void> &>(__int128 *a1, __int128 *a2)
{
  __int128 *v2;
  uint64_t v5;
  __int128 *v6;
  __int128 *v7;
  __int128 *v8;
  __int128 *v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;

  v5 = 0;
  v16 = *a1;
  v17 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  *(_QWORD *)a1 = 0;
  do
  {
    v6 = (__int128 *)((char *)a1 + v5 + 24);
    if (v6 == a2)
      goto LABEL_24;
    v5 += 24;
  }
  while ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v6, (void **)&v16) & 0x80) != 0);
  v7 = (__int128 *)((char *)a1 + v5);
  if (v5 != 24)
  {
    v8 = a2;
    while (v8 != a1)
    {
      v8 = (__int128 *)((char *)v8 - 24);
      if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v8, (void **)&v16) & 0x80) != 0)goto LABEL_12;
    }
    goto LABEL_24;
  }
  v8 = a2;
  do
  {
    if (v7 >= v8)
      break;
    v8 = (__int128 *)((char *)v8 - 24);
  }
  while ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v8, (void **)&v16) & 0x80) == 0);
LABEL_12:
  v2 = v7;
  if (v7 < v8)
  {
    v9 = v8;
LABEL_14:
    v18 = *v2;
    v10 = v18;
    v19 = *((_QWORD *)v2 + 2);
    v11 = v19;
    v12 = *((_QWORD *)v9 + 2);
    *v2 = *v9;
    *((_QWORD *)v2 + 2) = v12;
    *((_QWORD *)v9 + 2) = v11;
    *v9 = v10;
    while (1)
    {
      v2 = (__int128 *)((char *)v2 + 24);
      if (v2 == a2)
        break;
      if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v2, (void **)&v16) & 0x80) == 0)
      {
        while (v9 != a1)
        {
          v9 = (__int128 *)((char *)v9 - 24);
          if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v9, (void **)&v16) & 0x80) != 0)
          {
            if (v2 < v9)
              goto LABEL_14;
            goto LABEL_20;
          }
        }
        break;
      }
    }
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
LABEL_20:
  a2 = (__int128 *)((char *)v2 - 24);
  if ((__int128 *)((char *)v2 - 24) != a1)
  {
    if (*((char *)a1 + 23) < 0)
      operator delete(*(void **)a1);
    v13 = *a2;
    *((_QWORD *)a1 + 2) = *((_QWORD *)v2 - 1);
    *a1 = v13;
    *((_BYTE *)v2 - 1) = 0;
    *((_BYTE *)v2 - 24) = 0;
    goto LABEL_27;
  }
LABEL_25:
  if (*((char *)v2 - 1) < 0)
    operator delete(*(void **)a2);
LABEL_27:
  v14 = v16;
  *((_QWORD *)a2 + 2) = v17;
  *a2 = v14;
  return a2;
}

BOOL std::__insertion_sort_incomplete[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(char *__s2, char *a2)
{
  unint64_t v4;
  _BOOL8 result;
  char *v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  void **v10;
  void **v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  char *v15;
  void **v16;
  unsigned __int8 v17;
  int v18;
  char *v19;
  __int128 v20;
  void *v21;

  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - __s2) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = a2 - 24;
      if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)a2 - 3, (void **)__s2) & 0x80) != 0)
      {
        v7 = *((_QWORD *)__s2 + 2);
        v8 = *(_OWORD *)__s2;
        v9 = *((_QWORD *)v6 + 2);
        *(_OWORD *)__s2 = *(_OWORD *)v6;
        *((_QWORD *)__s2 + 2) = v9;
        *(_OWORD *)v6 = v8;
        *((_QWORD *)v6 + 2) = v7;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((void **)__s2, (void **)__s2 + 3, (_QWORD *)a2 - 3);
      return 1;
    case 4uLL:
      std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((uint64_t)__s2, (void **)__s2 + 3, (void **)__s2 + 6, (_QWORD *)a2 - 3);
      return 1;
    case 5uLL:
      std::__sort5[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((uint64_t)__s2, (void **)__s2 + 3, (void **)__s2 + 6, (void **)__s2 + 9, (_QWORD *)a2 - 3);
      return 1;
    default:
      v10 = (void **)(__s2 + 48);
      std::__sort3[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((void **)__s2, (void **)__s2 + 3, (_QWORD *)__s2 + 6);
      v11 = (void **)(__s2 + 72);
      if (__s2 + 72 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v11, v10) & 0x80) != 0)
    {
      v20 = *(_OWORD *)v11;
      v21 = v11[2];
      v11[1] = 0;
      v11[2] = 0;
      *v11 = 0;
      v14 = v12;
      do
      {
        v15 = &__s2[v14];
        v16 = (void **)&__s2[v14 + 72];
        if (__s2[v14 + 95] < 0)
          operator delete(*v16);
        *(_OWORD *)v16 = *((_OWORD *)v15 + 3);
        *(_QWORD *)&__s2[v14 + 88] = *((_QWORD *)v15 + 8);
        v15[71] = 0;
        v15[48] = 0;
        if (v14 == -48)
        {
          v19 = __s2;
          goto LABEL_15;
        }
        v17 = std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(&v20, (void **)&__s2[v14 + 24]);
        v14 -= 24;
      }
      while ((v17 & 0x80) != 0);
      v18 = __s2[v14 + 95];
      v19 = &__s2[v14 + 72];
      if (v18 < 0)
        operator delete(*(void **)v19);
LABEL_15:
      *(_OWORD *)v19 = v20;
      *((_QWORD *)v19 + 2) = v21;
      if (++v13 == 8)
        return v11 + 3 == (void **)a2;
    }
    v10 = v11;
    v12 += 24;
    v11 += 3;
    if (v11 == (void **)a2)
      return 1;
  }
}

_QWORD *std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *result, void **__s2)
{
  size_t v3;
  size_t v5;

  if (*((char *)result + 23) < 0)
  {
    v3 = result[1];
    if ((v3 & 0x8000000000000000) != 0)
      goto LABEL_15;
    result = (_QWORD *)*result;
    if (v3 && result == 0)
      goto LABEL_15;
  }
  else
  {
    v3 = *((unsigned __int8 *)result + 23);
  }
  if ((*((char *)__s2 + 23) & 0x80000000) == 0)
  {
    v5 = *((unsigned __int8 *)__s2 + 23);
    return (_QWORD *)std::operator<=>[abi:sn180100]<char,std::char_traits<char>>(result, v3, __s2, v5);
  }
  v5 = (size_t)__s2[1];
  if ((v5 & 0x8000000000000000) == 0)
  {
    __s2 = (void **)*__s2;
    if (!v5 || __s2)
      return (_QWORD *)std::operator<=>[abi:sn180100]<char,std::char_traits<char>>(result, v3, __s2, v5);
  }
LABEL_15:
  __break(1u);
  return result;
}

uint64_t std::operator<=>[abi:sn180100]<char,std::char_traits<char>>(const void *a1, size_t a2, void *__s2, size_t a4)
{
  size_t v7;
  int v8;

  if (a4 >= a2)
    v7 = a2;
  else
    v7 = a4;
  v8 = memcmp(a1, __s2, v7);
  if (v8)
  {
    if ((v8 & 0x80000000) == 0)
      return 1;
  }
  else
  {
    if (a2 == a4)
      return 0;
    if (a2 >= a4)
      return 1;
  }
  return 255;
}

__n128 std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, void **a2, void **a3, _QWORD *a4)
{
  __n128 result;
  void *v9;
  __int128 v10;
  void *v11;
  void *v12;
  __int128 v13;
  void *v14;
  void *v15;
  void *v16;

  std::__sort3[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((void **)a1, a2, a3);
  if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a4, a3) & 0x80) != 0)
  {
    v9 = a3[2];
    v10 = *(_OWORD *)a3;
    v11 = (void *)a4[2];
    *(_OWORD *)a3 = *(_OWORD *)a4;
    a3[2] = v11;
    *(_OWORD *)a4 = v10;
    a4[2] = v9;
    if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, a2) & 0x80) != 0)
    {
      v12 = a2[2];
      v13 = *(_OWORD *)a2;
      v14 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v14;
      *(_OWORD *)a3 = v13;
      a3[2] = v12;
      if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a2, (void **)a1) & 0x80) != 0)
      {
        v15 = *(void **)(a1 + 16);
        result = *(__n128 *)a1;
        v16 = a2[2];
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_QWORD *)(a1 + 16) = v16;
        *(__n128 *)a2 = result;
        a2[2] = v15;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, void **a2, void **a3, void **a4, _QWORD *a5)
{
  __n128 result;
  void *v11;
  __int128 v12;
  void *v13;
  void *v14;
  __int128 v15;
  void *v16;
  void *v17;
  __int128 v18;
  void *v19;
  void *v20;
  void *v21;

  std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a2, a3, a4);
  if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a5, a4) & 0x80) != 0)
  {
    v11 = a4[2];
    v12 = *(_OWORD *)a4;
    v13 = (void *)a5[2];
    *(_OWORD *)a4 = *(_OWORD *)a5;
    a4[2] = v13;
    *(_OWORD *)a5 = v12;
    a5[2] = v11;
    if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a4, a3) & 0x80) != 0)
    {
      v14 = a3[2];
      v15 = *(_OWORD *)a3;
      v16 = a4[2];
      *(_OWORD *)a3 = *(_OWORD *)a4;
      a3[2] = v16;
      *(_OWORD *)a4 = v15;
      a4[2] = v14;
      if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, a2) & 0x80) != 0)
      {
        v17 = a2[2];
        v18 = *(_OWORD *)a2;
        v19 = a3[2];
        *(_OWORD *)a2 = *(_OWORD *)a3;
        a2[2] = v19;
        *(_OWORD *)a3 = v18;
        a3[2] = v17;
        if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(a2, (void **)a1) & 0x80) != 0)
        {
          v20 = *(void **)(a1 + 16);
          result = *(__n128 *)a1;
          v21 = a2[2];
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_QWORD *)(a1 + 16) = v21;
          *(__n128 *)a2 = result;
          a2[2] = v20;
        }
      }
    }
  }
  return result;
}

_QWORD *std::__partial_sort_impl[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,std::string *>(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  int64_t v18;
  _QWORD *v19;
  void *v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  __int128 v25;
  _BYTE v28[15];

  if ((_QWORD *)a1 != a2)
  {
    v8 = (uint64_t)a2 - a1;
    v9 = ((uint64_t)a2 - a1) / 24;
    if ((uint64_t)a2 - a1 >= 25)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = a1 + 24 * v10;
      do
      {
        std::__sift_down[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a4, v9, v12);
        v12 -= 24;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v14, (void **)a1) & 0x80) != 0)
        {
          v15 = v14[2];
          v16 = *(_OWORD *)v14;
          v17 = *(_QWORD *)(a1 + 16);
          *(_OWORD *)v14 = *(_OWORD *)a1;
          v14[2] = v17;
          *(_OWORD *)a1 = v16;
          *(_QWORD *)(a1 + 16) = v15;
          std::__sift_down[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a4, v9, a1);
        }
        v14 += 3;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 25)
    {
      v18 = v8 / 0x18uLL;
      v19 = a2 - 3;
      do
      {
        v20 = *(void **)a1;
        *(_QWORD *)v28 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)&v28[7] = *(_QWORD *)(a1 + 15);
        v21 = *(_BYTE *)(a1 + 23);
        *(_QWORD *)(a1 + 8) = 0;
        *(_QWORD *)(a1 + 16) = 0;
        *(_QWORD *)a1 = 0;
        v22 = std::__floyd_sift_down[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a4, v18);
        v23 = v22;
        v24 = *(char *)(v22 + 23);
        if (v19 == (_QWORD *)v22)
        {
          if (v24 < 0)
            operator delete(*(void **)v22);
          *(_QWORD *)v23 = v20;
          *(_QWORD *)(v23 + 8) = *(_QWORD *)v28;
          *(_QWORD *)(v23 + 15) = *(_QWORD *)&v28[7];
          *(_BYTE *)(v23 + 23) = v21;
        }
        else
        {
          if (v24 < 0)
            operator delete(*(void **)v22);
          v25 = *(_OWORD *)v19;
          *(_QWORD *)(v23 + 16) = v19[2];
          *(_OWORD *)v23 = v25;
          *v19 = v20;
          v19[1] = *(_QWORD *)v28;
          *(_QWORD *)((char *)v19 + 15) = *(_QWORD *)&v28[7];
          *((_BYTE *)v19 + 23) = v21;
          std::__sift_up[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, v23 + 24, a4, 0xAAAAAAAAAAAAAAABLL * ((v23 + 24 - a1) >> 3));
        }
        v19 -= 3;
      }
      while (v18-- > 2);
    }
    return v13;
  }
  return a3;
}

__n128 std::__sift_down[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, int a2, uint64_t a3, uint64_t __s2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  __n128 *v7;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __n128 result;
  void **v15;
  __n128 v16;
  uint64_t v17;
  uint64_t v18;
  __n128 v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;

  v6 = a3 - 2;
  if (a3 >= 2)
  {
    v21 = v4;
    v22 = v5;
    v7 = (__n128 *)__s2;
    v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((__s2 - a1) >> 3)))
    {
      v11 = (0x5555555555555556 * ((__s2 - a1) >> 3)) | 1;
      v12 = a1 + 24 * v11;
      v13 = 0x5555555555555556 * ((__s2 - a1) >> 3) + 2;
      if (v13 < a3
        && (char)std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)(a1 + 24 * v11), (void **)(v12 + 24)) < 0)
      {
        v12 += 24;
        v11 = v13;
      }
      if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)v12, (void **)v7) & 0x80) == 0)
      {
        v19 = *v7;
        v20 = (void *)v7[1].n128_u64[0];
        v7->n128_u64[1] = 0;
        v7[1].n128_u64[0] = 0;
        v7->n128_u64[0] = 0;
        while (1)
        {
          v15 = (void **)v12;
          if (v7[1].n128_i8[7] < 0)
            operator delete((void *)v7->n128_u64[0]);
          v16 = *(__n128 *)v12;
          v7[1].n128_u64[0] = *(_QWORD *)(v12 + 16);
          *v7 = v16;
          *(_BYTE *)(v12 + 23) = 0;
          *(_BYTE *)v12 = 0;
          if (v9 < v11)
            break;
          v17 = (2 * v11) | 1;
          v12 = a1 + 24 * v17;
          v18 = 2 * v11 + 2;
          if (v18 < a3
            && (char)std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)(a1 + 24 * v17), (void **)(v12 + 24)) < 0)
          {
            v12 += 24;
            v17 = v18;
          }
          v7 = (__n128 *)v15;
          v11 = v17;
          if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)v12, (void **)&v19) & 0x80) != 0)
          {
            if (*((char *)v15 + 23) < 0)
              operator delete(*v15);
            break;
          }
        }
        result = v19;
        v15[2] = v20;
        *(__n128 *)v15 = result;
      }
    }
  }
  return result;
}

uint64_t std::__floyd_sift_down[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;

  v5 = 0;
  v6 = a3 - 2;
  if (a3 < 2)
    v6 = a3 - 1;
  v7 = v6 >> 1;
  do
  {
    v8 = a1 + 24 * v5 + 24;
    v9 = 2 * v5;
    v5 = (2 * v5) | 1;
    v10 = v9 + 2;
    if (v9 + 2 < a3
      && (char)std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)v8, (void **)(v8 + 24)) < 0)
    {
      v8 += 24;
      v5 = v10;
    }
    if (*(char *)(a1 + 23) < 0)
      operator delete(*(void **)a1);
    v11 = *(_OWORD *)v8;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(v8 + 16);
    *(_OWORD *)a1 = v11;
    *(_BYTE *)(v8 + 23) = 0;
    *(_BYTE *)v8 = 0;
    a1 = v8;
  }
  while (v5 <= v7);
  return v8;
}

double std::__sift_up[abi:sn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v7;
  __int128 *v8;
  __int128 *v9;
  double result;
  __int128 *v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a4 >= 2)
  {
    v15 = v4;
    v16 = v5;
    v7 = (unint64_t)(a4 - 2) >> 1;
    v8 = (__int128 *)(a1 + 24 * v7);
    v9 = (__int128 *)(a2 - 24);
    if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v8, (void **)(a2 - 24)) & 0x80) != 0)
    {
      v13 = *v9;
      v14 = *((_QWORD *)v9 + 2);
      *((_QWORD *)v9 + 1) = 0;
      *((_QWORD *)v9 + 2) = 0;
      *(_QWORD *)v9 = 0;
      while (1)
      {
        v11 = v8;
        if (*((char *)v9 + 23) < 0)
          operator delete(*(void **)v9);
        v12 = *v8;
        *((_QWORD *)v9 + 2) = *((_QWORD *)v8 + 2);
        *v9 = v12;
        *((_BYTE *)v8 + 23) = 0;
        *(_BYTE *)v8 = 0;
        if (!v7)
          break;
        v7 = (v7 - 1) >> 1;
        v8 = (__int128 *)(a1 + 24 * v7);
        v9 = v11;
        if ((std::operator<=>[abi:sn180100]<char,std::char_traits<char>,std::allocator<char>>(v8, (void **)&v13) & 0x80) == 0)
        {
          if (*((char *)v11 + 23) < 0)
            operator delete(*(void **)v11);
          break;
        }
      }
      result = *(double *)&v13;
      *v11 = v13;
      *((_QWORD *)v11 + 2) = v14;
    }
  }
  return result;
}

_QWORD *std::__hash_table<Platform::Transaction *,std::hash<Platform::Transaction *>,std::equal_to<Platform::Transaction *>,std::allocator<Platform::Transaction *>>::__emplace_unique_key_args<Platform::Transaction *,Platform::Transaction *>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<unsigned char>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<unsigned char>>>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_38:
    *v21 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

uint64_t *std::__hash_table<Platform::Transaction *,std::hash<Platform::Transaction *>,std::equal_to<Platform::Transaction *>,std::allocator<Platform::Transaction *>>::__erase_unique<Platform::Transaction *>(_QWORD *a1, _QWORD *a2)
{
  uint64_t *result;

  result = std::__hash_table<Platform::Transaction *,std::hash<Platform::Transaction *>,std::equal_to<Platform::Transaction *>,std::allocator<Platform::Transaction *>>::find<Platform::Transaction *>(a1, a2);
  if (result)
  {
    std::__hash_table<Platform::Transaction *,std::hash<Platform::Transaction *>,std::equal_to<Platform::Transaction *>,std::allocator<Platform::Transaction *>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

_QWORD *std::__hash_table<Platform::Transaction *,std::hash<Platform::Transaction *>,std::equal_to<Platform::Transaction *>,std::allocator<Platform::Transaction *>>::find<Platform::Transaction *>(_QWORD *a1, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::__hash_table<Platform::Transaction *,std::hash<Platform::Transaction *>,std::equal_to<Platform::Transaction *>,std::allocator<Platform::Transaction *>>::erase(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;
  void *v3;
  void *__p;

  if (a2)
  {
    v2 = *a2;
    std::__hash_table<Platform::Transaction *,std::hash<Platform::Transaction *>,std::equal_to<Platform::Transaction *>,std::allocator<Platform::Transaction *>>::remove(result, a2, (uint64_t)&__p);
    v3 = __p;
    __p = 0;
    if (v3)
      operator delete(v3);
    return (_QWORD *)v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

_QWORD *std::__hash_table<Platform::Transaction *,std::hash<Platform::Transaction *>,std::equal_to<Platform::Transaction *>,std::allocator<Platform::Transaction *>>::remove@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

_QWORD *Platform::URLConnection::URLConnection(_QWORD *a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  const void *v10;
  const void *v11;

  v7 = a3;
  v8 = a4;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = a2;
  a1[3] = 0;
  v9 = objc_retainAutorelease(v8);
  objc_msgSend(v9, "_CFURLRequest");
  v10 = (const void *)CFURLConnectionCreate();
  v11 = (const void *)a1[3];
  if (v11 == v10)
  {
    if (v10)
      CFRelease(v10);
  }
  else
  {
    if (v11)
    {
      CFRelease(v11);
      a1[3] = 0;
    }
    a1[3] = v10;
  }
  CFURLConnectionSetDelegateDispatchQueue();

  return a1;
}

void sub_1DBD0C250(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  const void *v4;
  const void *v5;
  const void *v7;
  std::__shared_weak_count *v8;

  v5 = v4;
  if (v5)
    CFRelease(v5);
  v7 = *(const void **)(v2 + 24);
  if (v7)
    CFRelease(v7);
  v8 = *(std::__shared_weak_count **)(v2 + 8);
  if (v8)
    std::__shared_weak_count::__release_weak(v8);

  _Unwind_Resume(a1);
}

void Platform::URLConnection::~URLConnection(Platform::URLConnection *this)
{
  const void *v2;
  std::__shared_weak_count *v3;

  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

uint64_t Platform::URLConnection::start(Platform::URLConnection *this)
{
  return CFURLConnectionStart();
}

void Platform::URLConnection::cancel(Platform::URLConnection *this)
{
  const void *v2;

  if (*((_QWORD *)this + 3))
  {
    CFURLConnectionCancel();
    v2 = (const void *)*((_QWORD *)this + 3);
    if (v2)
    {
      CFRelease(v2);
      *((_QWORD *)this + 3) = 0;
    }
  }
}

uint64_t Platform::URLConnection::URLConnection(Platform::URLConnection::Client &,NSObject  {objcproto17OS_dispatch_queue}*,NSURLRequest *)::$_0::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __CFHTTPMessage *HTTPResponse;
  CFIndex ResponseStatusCode;

  HTTPResponse = (__CFHTTPMessage *)CFURLResponseGetHTTPResponse();
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(HTTPResponse);
  return (*(uint64_t (**)(_QWORD, uint64_t, CFIndex))(**(_QWORD **)(a3 + 16) + 16))(*(_QWORD *)(a3 + 16), a3, ResponseStatusCode);
}

uint64_t Platform::URLConnection::URLConnection(Platform::URLConnection::Client &,NSObject  {objcproto17OS_dispatch_queue}*,NSURLRequest *)::$_1::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a4 + 16) + 24))(*(_QWORD *)(a4 + 16), a4, a2);
}

uint64_t Platform::URLConnection::URLConnection(Platform::URLConnection::Client &,NSObject  {objcproto17OS_dispatch_queue}*,NSURLRequest *)::$_2::__invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  v3 = *(const void **)(a2 + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a2 + 24) = 0;
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 16) + 32))(*(_QWORD *)(a2 + 16), a2);
}

uint64_t Platform::URLConnection::URLConnection(Platform::URLConnection::Client &,NSObject  {objcproto17OS_dispatch_queue}*,NSURLRequest *)::$_3::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v5;

  v5 = *(const void **)(a3 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a3 + 24) = 0;
  }
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a3 + 16) + 40))(*(_QWORD *)(a3 + 16), a3, a2);
}

void Platform::mapSharedMemory(void *a1@<X0>, _QWORD *a2@<X8>)
{
  id v3;
  void *v4;
  size_t v5;
  void *region;

  v3 = a1;
  v4 = v3;
  if (v3 && (region = 0, (v5 = xpc_shmem_map(v3, &region)) != 0))
  {
    std::allocate_shared[abi:sn180100]<Platform::SharedMemory,std::allocator<Platform::SharedMemory>,void *&,unsigned long &,void>(&region, (uint64_t *)&v5, a2);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }

}

void sub_1DBD0C454(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void *Platform::xpcErrorCategory(void)
{
  {
    Platform::OnceConstructedNeverDestroyed<Platform::xpcErrorCategory(void)::XPCErrorCategory>::OnceConstructedNeverDestroyed();
  }
  return &unk_1ED04EC00;
}

void Platform::OnceConstructedNeverDestroyed<Platform::xpcErrorCategory(void)::XPCErrorCategory>::OnceConstructedNeverDestroyed()
{
  unint64_t v0;
  uint64_t *v1;
  uint64_t ***v2;
  uint64_t **v3;

  Platform::xpcErrorCategory(void)::xpcErrorCategory = 0;
  v1 = &Platform::xpcErrorCategory(void)::xpcErrorCategory;
  v0 = atomic_load((unint64_t *)&Platform::xpcErrorCategory(void)::xpcErrorCategory);
  if (v0 != -1)
  {
    v3 = &v1;
    v2 = &v3;
    std::__call_once((std::once_flag::_State_type *)&Platform::xpcErrorCategory(void)::xpcErrorCategory, &v2, (void (__cdecl *)(void *))std::__call_once_proxy[abi:sn180100]<std::tuple<Platform::OnceConstructedNeverDestroyed<Platform::xpcErrorCategory(void)::XPCErrorCategory>::OnceConstructedNeverDestroyed(void)::{lambda(void)#1} &&>>);
  }
}

uint64_t Platform::xpcErrorCode(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;

  v1 = a1;
  v2 = v1;
  if (v1 == (id)MEMORY[0x1E0C81258])
  {
    {
      v3 = 1;
      goto LABEL_9;
    }
    Platform::OnceConstructedNeverDestroyed<Platform::xpcErrorCategory(void)::XPCErrorCategory>::OnceConstructedNeverDestroyed();
    v3 = 1;
LABEL_13:
    goto LABEL_9;
  }
  if (v1 == (id)MEMORY[0x1E0C81260])
  {
    {
      v3 = 2;
      goto LABEL_9;
    }
    Platform::OnceConstructedNeverDestroyed<Platform::xpcErrorCategory(void)::XPCErrorCategory>::OnceConstructedNeverDestroyed();
    v3 = 2;
    goto LABEL_13;
  }
  {
    Platform::OnceConstructedNeverDestroyed<Platform::xpcErrorCategory(void)::XPCErrorCategory>::OnceConstructedNeverDestroyed();
    v3 = 3;
    goto LABEL_13;
  }
  v3 = 3;
LABEL_9:

  return v3;
}

void sub_1DBD0C5EC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *std::allocate_shared[abi:sn180100]<Platform::SharedMemory,std::allocator<Platform::SharedMemory>,void *&,unsigned long &,void>@<X0>(void **a1@<X1>, uint64_t *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0x28uLL);
  result = std::__shared_ptr_emplace<Platform::SharedMemory>::__shared_ptr_emplace[abi:sn180100]<void *&,unsigned long &,std::allocator<Platform::SharedMemory>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1DBD0C648(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<Platform::SharedMemory>::__shared_ptr_emplace[abi:sn180100]<void *&,unsigned long &,std::allocator<Platform::SharedMemory>,0>(_QWORD *a1, void **a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1EA3EBB18;
  Platform::SharedMemory::SharedMemory(a1 + 3, *a2, *a3);
  return a1;
}

void sub_1DBD0C698(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__call_once_proxy[abi:sn180100]<std::tuple<Platform::OnceConstructedNeverDestroyed<Platform::xpcErrorCategory(void)::XPCErrorCategory>::OnceConstructedNeverDestroyed(void)::{lambda(void)#1} &&>>(uint64_t result)
{
  *(_QWORD *)(***(_QWORD ***)result + 8) = off_1EA3EBB50;
  return result;
}

void Platform::xpcErrorCategory(void)::XPCErrorCategory::~XPCErrorCategory(std::error_category *a1)
{
  void *v1;

  std::error_category::~error_category(a1);
  operator delete(v1);
}

const char *Platform::xpcErrorCategory(void)::XPCErrorCategory::name()
{
  return "xpc";
}

void Platform::xpcErrorCategory(void)::XPCErrorCategory::message(int a1@<W1>, uint64_t a2@<X8>)
{
  int v3;
  id v4;
  char *string;
  void *v6;
  xpc_object_t xdict;

  v3 = a1 - 1;
  if ((a1 - 1) >= 3)
  {
    v6 = 0;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    xdict = (xpc_object_t)qword_1EA3EC710[v3];
    v4 = qword_1EA3EC6F8[v3];
    string = (char *)xpc_dictionary_get_string(xdict, (const char *)*MEMORY[0x1E0C81270]);
    std::string::basic_string[abi:sn180100]<0>((char **)a2, string);
    v6 = xdict;
  }

}

void sub_1DBD0C770(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t Backend::Google::DeviceIdentificationTokenFetcher::DeviceIdentificationTokenFetcher(uint64_t a1, const Backend::Google::Configuration *a2, int a3)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  Backend::Google::Configuration::Configuration((std::string *)(a1 + 16), a2);
  *(_QWORD *)(a1 + 112) = dispatch_queue_create("com.apple.Safari.SafeBrowsing.DeviceIdentificationTokenFetcher", 0);
  *(_QWORD *)(a1 + 120) = 850045863;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_QWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 200) = a3;
  *(_BYTE *)(a1 + 104) = 0;
  return a1;
}

void sub_1DBD0C7E4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  std::__shared_weak_count *v3;

  v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(exception_object);
}

void Backend::Google::DeviceIdentificationTokenFetcher::~DeviceIdentificationTokenFetcher(Backend::Google::DeviceIdentificationTokenFetcher *this)
{
  std::__shared_weak_count *v2;

  std::mutex::~mutex((std::mutex *)((char *)this + 120));
  Backend::Google::Configuration::~Configuration((Backend::Google::DeviceIdentificationTokenFetcher *)((char *)this + 16));
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void Backend::Google::DeviceIdentificationTokenFetcher::fetchDeviceIdentificationToken(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  std::mutex *v7;
  NSObject *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  id v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  _QWORD v22[5];
  std::__shared_weak_count *v23;
  id v24;
  id v25;
  uint64_t v26;
  std::__shared_weak_count *v27;

  v5 = a2;
  v6 = a3;
  v7 = (std::mutex *)(a1 + 120);
  std::mutex::lock((std::mutex *)(a1 + 120));
  std::shared_ptr<Backend::Google::DatabaseUpdater>::shared_ptr[abi:sn180100]<Backend::Google::DatabaseUpdater,void>(&v26, (_QWORD *)a1);
  *(_BYTE *)(a1 + 104) = 1;
  v8 = *(NSObject **)(a1 + 112);
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 3321888768;
  v22[2] = ___ZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  v22[3] = &__block_descriptor_64_ea8_32c155_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__0_e5_v8__0l;
  v9 = v26;
  v10 = v27;
  v26 = 0;
  v27 = 0;
  v22[4] = v9;
  v23 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v24 = v5;
  v13 = v5;
  v25 = (id)MEMORY[0x1DF0B8E90](v6);
  dispatch_async(v8, v22);

  if (v10)
  {
    v14 = (unint64_t *)&v10->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  v16 = v23;
  if (v23)
  {
    v17 = (unint64_t *)&v23->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = v27;
  if (v27)
  {
    v20 = (unint64_t *)&v27->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  std::mutex::unlock(v7);
}

void sub_1DBD0C9F4(_Unwind_Exception *a1)
{
  std::mutex *v1;
  void *v2;
  void *v3;

  std::mutex::unlock(v1);

  _Unwind_Resume(a1);
}

void ___ZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  NSObject *v4;
  int v5;
  id v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  id v11;
  void *v12;
  unint64_t *v13;
  unint64_t v14;
  id v15;
  void *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, void *, void *, void *);
  void *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  id v28;
  id v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v1 + 200) == 1)
  {
    Backend::Google::Configuration::getDeviceIdentificationTokenRequestURLRequest((Backend::Google::Configuration *)(v1 + 16));
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    if (v3)
    {
      v4 = SSBOSLogDeviceIdentificationToken();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        v5 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 200);
        LODWORD(v22) = 67109120;
        HIDWORD(v22) = v5;
        _os_log_impl(&dword_1DBCBE000, v4, OS_LOG_TYPE_INFO, "Initiate device identification token request for %d server", (uint8_t *)&v22, 8u);
      }
      v6 = *(id *)(*(_QWORD *)(a1 + 32) + 96);
      v22 = MEMORY[0x1E0C809B0];
      v23 = 3321888768;
      v24 = ___ZZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEENK3__0clEv_block_invoke;
      v25 = &__block_descriptor_64_ea8_32c200_ZTSKZZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEENK3__0clEvEUlP6NSDataP13NSURLResponseP7NSErrorE__e46_v32__0__NSData_8__NSURLResponse_16__NSError_24l;
      v8 = *(_QWORD *)(a1 + 32);
      v7 = *(std::__shared_weak_count **)(a1 + 40);
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v10 = __ldxr(p_shared_owners);
        while (__stxr(v10 + 1, p_shared_owners));
      }
      v11 = *(id *)(a1 + 48);
      v12 = (void *)MEMORY[0x1DF0B8E90](*(_QWORD *)(a1 + 56));
      v26 = v8;
      v27 = v7;
      if (v7)
      {
        v13 = (unint64_t *)&v7->__shared_owners_;
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      v15 = v11;
      v28 = v15;
      v29 = (id)MEMORY[0x1DF0B8E90](v12);
      objc_msgSend(v6, "dataTaskWithRequest:completionHandler:", v3, &v22);
      v16 = (void *)objc_claimAutoreleasedReturnValue();

      if (v7)
      {
        v17 = (unint64_t *)&v7->__shared_owners_;
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      objc_msgSend(v16, "resume", v22, v23, v24, v25, v26);

      v19 = v27;
      if (v27)
      {
        v20 = (unint64_t *)&v27->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }

    }
  }
}

void sub_1DBD0CC5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  unint64_t *p_shared_owners;
  unint64_t v22;

  v19 = v18;

  if (a14)
  {
    p_shared_owners = (unint64_t *)&a14->__shared_owners_;
    do
      v22 = __ldaxr(p_shared_owners);
    while (__stlxr(v22 - 1, p_shared_owners));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))a14->__on_zero_shared)(a14);
      std::__shared_weak_count::__release_weak(a14);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c155_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__0(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t result;

  v4 = *(_QWORD *)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[6] = *(id *)(a2 + 48);
  result = MEMORY[0x1DF0B8E90](*(_QWORD *)(a2 + 56));
  a1[7] = result;
  return result;
}

uint64_t __destroy_helper_block_ea8_32c155_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__0(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 32;

  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
}

void Backend::Google::DeviceIdentificationTokenFetcher::didFetchDeviceIdentificationToken(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11;
  id v12;
  id v13;
  NSObject *v14;
  id v15;
  std::mutex *v16;
  void *v17;
  id v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  id *v22;
  NSObject *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t *v30;
  _QWORD v31[5];
  _QWORD v32[5];
  id v33;
  _QWORD block[4];
  uint64_t v35;
  uint8_t buf[4];
  id v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  v16 = (std::mutex *)(a1 + 120);
  std::mutex::lock((std::mutex *)(a1 + 120));
  if (v13 || objc_msgSend(v12, "statusCode") != 200)
  {
    v23 = (id)SSBOSLogDeviceIdentificationToken();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v28 = objc_msgSend(v12, "statusCode");
      v29 = *(_DWORD *)(a1 + 200);
      *(_DWORD *)buf = 138412802;
      v37 = v13;
      v38 = 1024;
      v39 = v28;
      v40 = 1024;
      v41 = v29;
      _os_log_error_impl(&dword_1DBCBE000, v23, OS_LOG_TYPE_ERROR, "Encountered error %@ / status %d when requesting device identification token for %d server", buf, 0x18u);
    }

    v24 = *(void **)(a1 + 184);
    *(_QWORD *)(a1 + 184) = 0;

    *(_BYTE *)(a1 + 104) = 0;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3321888768;
    block[2] = ___ZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
    block[3] = &__block_descriptor_40_ea8_32c195_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__0_e5_v8__0l;
    v35 = MEMORY[0x1DF0B8E90](v15);
    dispatch_async(v14, block);

    v18 = (id)v35;
  }
  else
  {
    v33 = 0;
    objc_msgSend(MEMORY[0x1E0CB36D8], "JSONObjectWithData:options:error:", v11, 0, &v33);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    v18 = v33;
    if (v18 || !v17)
    {
      v25 = SSBOSLogDeviceIdentificationToken();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        Backend::Google::DeviceIdentificationTokenFetcher::didFetchDeviceIdentificationToken((uint64_t)v18, a1, v25);
      v26 = *(void **)(a1 + 184);
      *(_QWORD *)(a1 + 184) = 0;

      v27 = MEMORY[0x1E0C809B0];
      *(_BYTE *)(a1 + 104) = 0;
      v32[0] = v27;
      v32[1] = 3321888768;
      v32[2] = ___ZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_2;
      v32[3] = &__block_descriptor_40_ea8_32c195_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__1_e5_v8__0l;
      v22 = (id *)v32;
    }
    else
    {
      v30 = (uint64_t *)(a1 + 184);
      objc_storeStrong((id *)(a1 + 184), v17);
      *(std::chrono::steady_clock::time_point *)(a1 + 192) = std::chrono::steady_clock::now();
      *(_BYTE *)(a1 + 104) = 0;
      v19 = SSBOSLogDeviceIdentificationToken();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        v20 = *(_DWORD *)(a1 + 200);
        *(_DWORD *)buf = 67109120;
        LODWORD(v37) = v20;
        _os_log_impl(&dword_1DBCBE000, v19, OS_LOG_TYPE_INFO, "Received device identification token dictionary for %d server", buf, 8u);
      }
      v21 = SSBOSLogDeviceIdentificationToken();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        Backend::Google::DeviceIdentificationTokenFetcher::didFetchDeviceIdentificationToken(v30, v21);
      v31[0] = MEMORY[0x1E0C809B0];
      v31[1] = 3321888768;
      v31[2] = ___ZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_3;
      v31[3] = &__block_descriptor_40_ea8_32c195_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__2_e5_v8__0l;
      v22 = (id *)v31;
    }
    v22[4] = (id)MEMORY[0x1DF0B8E90](v15);
    dispatch_async(v14, v22);

  }
  std::mutex::unlock(v16);

}

void sub_1DBD0D0F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  std::mutex *v5;
  void *v6;
  void *v7;
  void *v8;

  std::mutex::unlock(v5);
  _Unwind_Resume(a1);
}

uint64_t ___ZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __copy_helper_block_ea8_32c195_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = MEMORY[0x1DF0B8E90](*(_QWORD *)(a2 + 32));
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c195_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__0(uint64_t a1)
{

}

uint64_t ___ZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __copy_helper_block_ea8_32c195_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__1(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = MEMORY[0x1DF0B8E90](*(_QWORD *)(a2 + 32));
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c195_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__1(uint64_t a1)
{

}

uint64_t ___ZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __copy_helper_block_ea8_32c195_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__2(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = MEMORY[0x1DF0B8E90](*(_QWORD *)(a2 + 32));
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c195_ZTSKZN7Backend6Google32DeviceIdentificationTokenFetcher33didFetchDeviceIdentificationTokenEP6NSDataP17NSHTTPURLResponseP7NSErrorPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEE3__2(uint64_t a1)
{

}

BOOL Backend::Google::DeviceIdentificationTokenFetcher::shouldFetchDeviceIdentificationToken(Backend::Google::DeviceIdentificationTokenFetcher *this)
{
  std::mutex *v2;
  Backend::Google::SSBUtilities *v3;
  _BOOL8 v4;
  void *v5;
  void *v6;
  char v7;

  v2 = (std::mutex *)((char *)this + 120);
  std::mutex::lock((std::mutex *)((char *)this + 120));
  if ((Backend::Google::SSBUtilities::shouldConsultWithTencent(v3) & 1) != 0)
  {
    v4 = 0;
  }
  else
  {
    +[RemoteConfigurationController sharedController](RemoteConfigurationController, "sharedController");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "googleProviderConfiguration");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = objc_msgSend(v6, "proxyOff");

    if ((v7 & 1) != 0 || *((_BYTE *)this + 104))
    {
      v4 = 0;
    }
    else if (*((_QWORD *)this + 23))
    {
      v4 = std::chrono::steady_clock::now().__d_.__rep_ - *((_QWORD *)this + 24) > 0x105EF39B1FFFLL;
    }
    else
    {
      v4 = 1;
    }

  }
  std::mutex::unlock(v2);
  return v4;
}

void sub_1DBD0D2D0(_Unwind_Exception *a1)
{
  std::mutex *v1;
  void *v2;
  void *v3;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

id Backend::Google::DeviceIdentificationTokenFetcher::getCurrentDeviceIdentificationToken(id *this)
{
  std::mutex *v2;
  id v3;

  v2 = (std::mutex *)(this + 15);
  std::mutex::lock((std::mutex *)(this + 15));
  v3 = this[23];
  std::mutex::unlock(v2);
  return v3;
}

void ___ZZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEENK3__0clEv_block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  NSObject *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  id v18;
  void *v19;
  id v20;
  id v21;
  id v22;
  unint64_t *v23;
  unint64_t v24;
  id v25;
  id v26;
  id v27;
  id v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  _QWORD block[5];
  std::__shared_weak_count *v35;
  id v36;
  id v37;
  id v38;
  id v39;
  id v40;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = v7;
  v11 = v8;
  v12 = v9;
  v14 = *(_QWORD *)(a1 + 32);
  v13 = *(std::__shared_weak_count **)(a1 + 40);
  v15 = *(NSObject **)(v14 + 112);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = ___ZZZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clES9_SB_SD__block_invoke;
  block[3] = &__block_descriptor_88_ea8_32c221_ZTSKZZZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clES9_SB_SD_EUlvE__e5_v8__0l;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }
  v18 = *(id *)(a1 + 48);
  v19 = (void *)MEMORY[0x1DF0B8E90](*(_QWORD *)(a1 + 56));
  v20 = v10;
  v21 = v11;
  v22 = v12;
  block[4] = v14;
  v35 = v13;
  if (v13)
  {
    v23 = (unint64_t *)&v13->__shared_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }
  v36 = v18;
  v25 = v18;
  v37 = (id)MEMORY[0x1DF0B8E90](v19);
  v38 = v20;
  v39 = v21;
  v40 = v22;
  v26 = v20;
  v27 = v21;
  v28 = v22;
  dispatch_async(v15, block);

  if (v13)
  {
    v29 = (unint64_t *)&v13->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  v31 = v35;
  if (v35)
  {
    v32 = (unint64_t *)&v35->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }

}

uint64_t __copy_helper_block_ea8_32c200_ZTSKZZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEENK3__0clEvEUlP6NSDataP13NSURLResponseP7NSErrorE_(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t result;

  v4 = *(_QWORD *)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[6] = *(id *)(a2 + 48);
  result = MEMORY[0x1DF0B8E90](*(_QWORD *)(a2 + 56));
  a1[7] = result;
  return result;
}

uint64_t __destroy_helper_block_ea8_32c200_ZTSKZZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEENK3__0clEvEUlP6NSDataP13NSURLResponseP7NSErrorE_(uint64_t a1)
{
  uint64_t v2;

  v2 = a1 + 32;

  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
}

void ___ZZZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clES9_SB_SD__block_invoke(uint64_t a1)
{
  Backend::Google::DeviceIdentificationTokenFetcher::didFetchDeviceIdentificationToken(*(_QWORD *)(a1 + 32), *(void **)(a1 + 64), *(void **)(a1 + 72), *(void **)(a1 + 80), *(void **)(a1 + 48), *(void **)(a1 + 56));
}

id __copy_helper_block_ea8_32c221_ZTSKZZZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clES9_SB_SD_EUlvE_(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  id result;

  v4 = *(_QWORD *)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[6] = *(id *)(a2 + 48);
  a1[7] = MEMORY[0x1DF0B8E90](*(_QWORD *)(a2 + 56));
  a1[8] = *(id *)(a2 + 64);
  a1[9] = *(id *)(a2 + 72);
  result = *(id *)(a2 + 80);
  a1[10] = result;
  return result;
}

uint64_t __destroy_helper_block_ea8_32c221_ZTSKZZZN7Backend6Google32DeviceIdentificationTokenFetcher30fetchDeviceIdentificationTokenEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clES9_SB_SD_EUlvE_(id *a1)
{
  uint64_t v2;

  v2 = (uint64_t)(a1 + 4);

  return std::shared_ptr<Platform::SharedMemory>::~shared_ptr[abi:sn180100](v2);
}

void ___ZN7Backend6Google15DatabaseUpdater10initializeEv_block_invoke_110_cold_1(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  unint64_t v3;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    v3 = __ldaxr(p_shared_owners);
  while (__stlxr(v3 - 1, p_shared_owners));
  if (!v3)
  {
    OUTLINED_FUNCTION_2();
    std::__shared_weak_count::__release_weak(a1);
  }
  OUTLINED_FUNCTION_0();
}

void Backend::Google::DatabaseUpdater::mapDatabaseIntoMemory()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;

  OUTLINED_FUNCTION_1_0();
  if (v6 != v7)
    v8 = v5;
  else
    v8 = v1;
  *(_DWORD *)v2 = 136446210;
  *(_QWORD *)(v2 + 4) = v8;
  _os_log_error_impl(&dword_1DBCBE000, v3, OS_LOG_TYPE_ERROR, "Failed to initialize database '%{public}s'", v4, 0xCu);
  if (*(char *)(v0 + 23) < 0)
    operator delete(*(void **)v0);
  OUTLINED_FUNCTION_0();
}

void ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke_cold_1(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  unint64_t v3;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    v3 = __ldaxr(p_shared_owners);
  while (__stlxr(v3 - 1, p_shared_owners));
  if (v3)
  {
    OUTLINED_FUNCTION_0();
  }
  else
  {
    OUTLINED_FUNCTION_2();
    std::__shared_weak_count::__release_weak(a1);
  }
}

void ___ZN7Backend6Google15DatabaseUpdater19fetchEncodedUpdatesENS0_19DatabaseUpdateStyleEP18ProxyConfiguration_block_invoke_2_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, a1, a3, "Encountered error connecting to proxy, retrying without proxy", a5, a6, a7, a8, 0);
}

void Backend::Google::DatabaseUpdater::writeUpdatedDatabase()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;

  OUTLINED_FUNCTION_1_0();
  if (v6 != v7)
    v8 = v5;
  else
    v8 = v1;
  *(_DWORD *)v2 = 136446210;
  *(_QWORD *)(v2 + 4) = v8;
  _os_log_fault_impl(&dword_1DBCBE000, v3, OS_LOG_TYPE_FAULT, "Checksum for database '%{public}s' is invalid", v4, 0xCu);
  if (*(char *)(v0 + 23) < 0)
    operator delete(*(void **)v0);
  OUTLINED_FUNCTION_0();
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::finish(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Expected to receive a dictionary from server. Got %{public}@", v3);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Response doesn't contain a listUpdateResponses key", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v0, v1, "Failed to parse minimum wait duration: %{public}@", v2);
  OUTLINED_FUNCTION_4();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Failed to parse an entry from the listUpdatesResponses dictionary", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Invalid minimum wait duration. Expected a string. Got %{public}@", v3);
}

{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Response is incorrectly formatted. listUpdatesResponses can only contain dictionaries. Contained a %{public}@", v3);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseFetchThreatListUpdatesResponse(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a1 = 134217984;
  *(_QWORD *)(a1 + 4) = a2;
  OUTLINED_FUNCTION_7(&dword_1DBCBE000, a2, a3, "Parsing %zu updates", (uint8_t *)a1);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Invalid new client state string", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Invalid checksum dictionary key", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Failed to parse checksum dictionary", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Failed to parse addition", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v0, v1, "Response type key is invalid: %{public}@", v2);
  OUTLINED_FUNCTION_4();
}

{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v0, v1, "Platform type key is invalid: %{public}@", v2);
  OUTLINED_FUNCTION_4();
}

{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v0, v1, "Threat entry type key is invalid: %{public}@", v2);
  OUTLINED_FUNCTION_4();
}

{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v0, v1, "Threat type key is invalid: %{public}@", v2);
  OUTLINED_FUNCTION_4();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Missing response type key", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Missing platform type key", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Missing threat entry type key", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Missing threat type key", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Removal is incorrectly formatted. Expected an dictionary. Got %{public}@", v3);
}

{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Removals are incorrectly formatted. Expected an array. Got %{public}@", v3);
}

{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Addition is incorrectly formatted. Expected an dictionary. Got %{public}@", v3);
}

{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Additions are incorrectly formatted. Expected an array. Got %{public}@", v3);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a1 = 134217984;
  *(_QWORD *)(a1 + 4) = a2;
  OUTLINED_FUNCTION_7(&dword_1DBCBE000, a2, a3, "Parsing %zu removals", (uint8_t *)a1);
}

{
  *(_DWORD *)a1 = 134217984;
  *(_QWORD *)(a1 + 4) = a2;
  OUTLINED_FUNCTION_7(&dword_1DBCBE000, a2, a3, "Parsing %zu additions", (uint8_t *)a1);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseListUpdateResponse(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl(&dword_1DBCBE000, log, OS_LOG_TYPE_ERROR, "Failed to parse addition", buf, 2u);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseDuration()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v0, v1, "Invalid duration: %{public}@", v2);
  OUTLINED_FUNCTION_4();
}

{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v0, v1, "Missing data type suffix from %{public}@", v2);
  OUTLINED_FUNCTION_4();
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseChecksum()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Missing SHA256 key", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Failed to parse SHA256", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseAddition()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Missing compession type in addition record", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v0, v1, "Unsupported compression type: %{public}@", v2);
  OUTLINED_FUNCTION_4();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Failed to parse hashes", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v0, v1, "Unsupported compession type: %{public}@", v2);
  OUTLINED_FUNCTION_4();
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseAddition(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Raw hashes are incorrectly formatted. Expected an dictionary. Got %{public}@", v3);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRemoval()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Missing compession type in removal record", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Failed to parse raw indices", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRemoval(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Raw indices are incorrectly formatted. Expected an dictionary. Got %{public}@", v3);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawHashes(int a1, NSObject *a2)
{
  _DWORD v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_1DBCBE000, a2, OS_LOG_TYPE_ERROR, "Invalid prefix size. Got %i", (uint8_t *)v2, 8u);
  OUTLINED_FUNCTION_2_0();
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawHashes()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Missing raw hashes key", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Failed to parse the raw hashes", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Extra data detected at the end of the hashes binary list", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawIndices(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Indice is incorrectly formatted. Expected a number. Got %{public}@", v3);
}

{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_6(a1, a2, 5.8381e-34);
  OUTLINED_FUNCTION_1_2(&dword_1DBCBE000, v2, (uint64_t)v2, "Indices are incorrectly formatted. Expected an array. Got %{public}@", v3);
}

void Backend::Google::FetchThreatListUpdatesResponseJSONParser::parseRawIndices(_QWORD *a1, NSObject *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t)(a1[1] - *a1) >> 2;
  v3 = 134217984;
  v4 = v2;
  _os_log_debug_impl(&dword_1DBCBE000, a2, OS_LOG_TYPE_DEBUG, "Parsing %zu indices", (uint8_t *)&v3, 0xCu);
  OUTLINED_FUNCTION_4();
}

void std::__optional_copy_base<std::vector<unsigned int>,false>::__optional_copy_base[abi:sn180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

void std::__optional_copy_base<Backend::Google::RawHashes,false>::__optional_copy_base[abi:sn180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void std::__function::__func<Backend::Google::FetchThreatListUpdatesResponseParser::FetchThreatListUpdatesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>)::$_0,std::allocator<std::function<void ()(std::optional<Backend::Google::FetchThreatListUpdatesResponse> &&)>>,Task ()(std::shared_ptr<ReadStream>)>::operator()(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  uint64_t v3;
  int v4;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    OUTLINED_FUNCTION_1(p_shared_owners);
  while (v4);
  if (v3)
  {
    OUTLINED_FUNCTION_0();
  }
  else
  {
    OUTLINED_FUNCTION_2();
    std::__shared_weak_count::__release_weak(a1);
  }
}

void std::__invoke_void_return_wrapper<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>>,false>::__call[abi:sn180100]<Lazy<std::optional<Backend::Google::ListUpdateResponse::Addition>> (*&)(std::shared_ptr<RiceDecompressor>,unsigned int),std::shared_ptr<RiceDecompressor>,unsigned int>(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  uint64_t v3;
  int v4;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    OUTLINED_FUNCTION_1(p_shared_owners);
  while (v4);
  if (!v3)
  {
    OUTLINED_FUNCTION_2();
    std::__shared_weak_count::__release_weak(a1);
  }
  OUTLINED_FUNCTION_0();
}

void std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:sn180100](uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::__function::__func<Backend::Google::FindFullHashesResponseParser::FindFullHashesResponseParser(std::shared_ptr<ReadStream>,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &&)::$_0,std::allocator<std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse> &&)> &>,Task ()(std::shared_ptr<ReadStream>)>::operator()(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  unint64_t v3;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    v3 = __ldaxr(p_shared_owners);
  while (__stlxr(v3 - 1, p_shared_owners));
  if (!v3)
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void ___ZN7Backend6Google13FullHashCache21updateExpirationTimerEv_block_invoke_cold_1(std::__shared_weak_count *a1)
{
  ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
  std::__shared_weak_count::__release_weak(a1);
}

void ___ZN7Backend6Google15FullHashChecker11checkHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_bNS2_8functionIFvNS3_INS0_20ThreatListDescriptorENS5_ISG_EEEEEEE_block_invoke_cold_1(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  unint64_t v3;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    v3 = __ldaxr(p_shared_owners);
  while (__stlxr(v3 - 1, p_shared_owners));
  if (!v3)
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void std::__function::__func<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0,std::allocator<Backend::Google::FullHashChecker::fetchHashes(Backend::Google::FullHashFetcher &,std::vector<Backend::Google::FullHashRequest> const&,std::shared_ptr<Backend::Google::FullHashChecker>,std::shared_ptr<Backend::Google::FullHashChecker::FetchRequest>,NSObject  {objcproto13OS_xpc_object}*,ProxyConfiguration *)::$_0>,void ()(std::optional<Backend::Google::FindFullHashesResponse>)>::operator()(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl(&dword_1DBCBE000, log, OS_LOG_TYPE_ERROR, "Full hash fetch failed", v1, 2u);
}

void ___ZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEE_block_invoke_cold_1(uint64_t a1)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  OUTLINED_FUNCTION_0_0(a1);
  v5 = *(std::__shared_weak_count **)(v4 + 40);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      OUTLINED_FUNCTION_2_1();
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  *(_QWORD *)v1 = v3;
  *(_DWORD *)(v1 + 8) = v2;
  OUTLINED_FUNCTION_4_0();
}

void Backend::Google::FullHashFetcher::didFetchFullHashes(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1_3(&dword_1DBCBE000, a2, a3, "Encountered error when requesting from %d server", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_2_0();
}

void Backend::Google::FullHashFetcher::didFetchFullHashes(NSData *,NSHTTPURLResponse *,NSObject  {objcproto14OS_nw_activity}*,NSError *,NSObject {objcproto17OS_dispatch_queue}*,std::function<void ()(std::optional<Backend::Google::FindFullHashesResponse>)>)::$_1::operator()(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1_3(&dword_1DBCBE000, a2, a3, "Encountered error when parsing response from %d server", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_2_0();
}

void ___ZZZN7Backend6Google15FullHashFetcher11fetchHashesENSt3__16vectorINS0_15FullHashRequestENS2_9allocatorIS4_EEEEPU24objcproto13OS_xpc_object8NSObjectP18ProxyConfigurationPU28objcproto17OS_dispatch_queueS8_NS2_8functionIFvNS2_8optionalINS0_22FindFullHashesResponseEEEEEEENK3__0clEvENKUlP6NSDataP13NSURLResponseP7NSErrorE_clESN_SP_SR__block_invoke_cold_1(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl(&dword_1DBCBE000, log, OS_LOG_TYPE_ERROR, "Encountered error connecting to proxy, retrying without proxy", v1, 2u);
  OUTLINED_FUNCTION_2_0();
}

void SafeBrowsing::LookupContext::handleForceDeviceIdentificationTokenUpdateReply()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Encountered xpc error for ForceDeviceIdentificationTokenUpdate response with error: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void SafeBrowsing::LookupContext::lookUpURL(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = 138412290;
  v3 = a1;
  _os_log_debug_impl(&dword_1DBCBE000, a2, OS_LOG_TYPE_DEBUG, "URL %@ is safe", (uint8_t *)&v2, 0xCu);
}

void SafeBrowsing::LookupContext::handleConnectionEvent(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_fault_impl(&dword_1DBCBE000, log, OS_LOG_TYPE_FAULT, "Unexpected message from the connection, will be ignored", v1, 2u);
}

void SafeBrowsing::LookupContext::handleConnectionError()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Handle connection with error: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void ___ZN12SafeBrowsing13LookupContext27getSafeBrowsingEnabledStateENSt3__18functionIFvbNS1_10error_codeEEEE_block_invoke_cold_1(uint64_t a1)
{
  unint64_t *v1;
  uint64_t v2;
  int v3;

  v1 = (unint64_t *)(a1 + 8);
  do
    OUTLINED_FUNCTION_1(v1);
  while (v3);
  if (!v2)
  {
    OUTLINED_FUNCTION_2();
    OUTLINED_FUNCTION_7_0();
  }
  OUTLINED_FUNCTION_0();
}

void SafeBrowsing::LookupContext::handleCheckFullHashesReply()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Encountered xpc error for CheckFullHashes response with error: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void SafeBrowsing::LookupContext::handleForceLoadRemoteConfigurationFromDiskReply()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Encountered xpc error for ForceLoadRemoteConfigurationFromDisk response with error: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void SafeBrowsing::LookupContext::handleForceUpdateRemoteConfigurationFromServerReply()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Encountered xpc error for ForceUpdateRemoteConfigurationFromServer response with error: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void SafeBrowsing::LookupContext::handleDeleteAllDatabasesReply()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Encountered xpc error for DeleteAllDatabases response with error: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void ___ZN12SafeBrowsing13LookupContext16setClientIsInUseEv_block_invoke_cold_1(char a1, uint64_t a2)
{
  unint64_t *v2;
  uint64_t v3;
  int v4;

  if ((a1 & 1) == 0)
  {
    v2 = (unint64_t *)(a2 + 8);
    do
      OUTLINED_FUNCTION_1(v2);
    while (v4);
    if (!v3)
    {
      OUTLINED_FUNCTION_2();
      OUTLINED_FUNCTION_7_0();
    }
  }
}

void SafeBrowsing::LookupContext::handleClientInUseReply()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Encountered xpc error for ClientInUse response with error: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void SafeBrowsing::LookupContext::handleFetchCellularDataPlanReply()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Encountered xpc error for FetchCellularDataPlan response with error: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void SafeBrowsing::LookupContext::handleGetSafeBrowsingEnabledStateReply()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Encountered xpc error for GetSafeBrowsingEnabledState response with error: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void std::__function::__func<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1,std::allocator<SafeBrowsing::LookupContext::lookUpURL(NSURL *,SafeBrowsing::IgnoreEnableState,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_1>,void ()(BOOL,std::error_code)>::operator()()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Encountered error when trying to get safe browsing enabled state: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void std::__function::__func<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0,std::allocator<SafeBrowsing::LookupContext::performURLLookup(NSURL *,std::function<void ()(std::vector<Backend::LookupResult>,std::error_code)>)::$_0>,void ()(std::error_code)>::operator()()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  OUTLINED_FUNCTION_1_0();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  OUTLINED_FUNCTION_4_1(v2, v6, 4.8751e-34);
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v7, v8, "Encountered error when trying to get databases: %{public}s", v9);
  if (*(char *)(v0 + 23) < 0)
    OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_0();
}

void SafeBrowsing::Service::databaseBaseDirectory()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;

  OUTLINED_FUNCTION_1_0();
  if (v6 != v7)
    v8 = v5;
  else
    v8 = v1;
  *(_DWORD *)v2 = 136446210;
  *(_QWORD *)(v2 + 4) = v8;
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v2, v3, "Failed to get user cache directory: %{public}s", v4);
  if (*(char *)(v0 + 23) < 0)
    operator delete(*(void **)v0);
  OUTLINED_FUNCTION_0();
}

void SafeBrowsing::Service::initializeDatabaseManager()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;

  OUTLINED_FUNCTION_1_0();
  if (v6 != v7)
    v8 = v5;
  else
    v8 = v1;
  *(_DWORD *)v2 = 136446210;
  *(_QWORD *)(v2 + 4) = v8;
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, v2, v3, "Failed to create database directory: %{public}s", v4);
  if (*(char *)(v0 + 23) < 0)
    operator delete(*(void **)v0);
  OUTLINED_FUNCTION_0();
}

void SafeBrowsing::Service::didFinishUpdate()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Failed to set activity state to XPC_ACTIVITY_STATE_DONE", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

void SafeBrowsing::Service::didFailUpdate(uint64_t a1, int a2, os_log_t log)
{
  _DWORD v3[2];
  __int16 v4;
  int v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3[0] = 67109376;
  v3[1] = a2;
  v4 = 1024;
  v5 = HIDWORD(a1);
  _os_log_error_impl(&dword_1DBCBE000, log, OS_LOG_TYPE_ERROR, "Service: Database update failed for protection type %d and provider %d", (uint8_t *)v3, 0xEu);
}

void ___ZN12SafeBrowsing7Service31checkInOrRegisterUpdateActivityEPKc_block_invoke_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Failed to set activity state to XPC_ACTIVITY_STATE_CONTINUE", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

void SafeBrowsing::Service::handleConnectionMessage()
{
  os_log_t v0;
  uint8_t v1[16];

  OUTLINED_FUNCTION_3_0();
  _os_log_fault_impl(&dword_1DBCBE000, v0, OS_LOG_TYPE_FAULT, "Received unknown message", v1, 2u);
  OUTLINED_FUNCTION_2_0();
}

void SafeBrowsing::Service::handleDeleteAllDatabases()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3(&dword_1DBCBE000, v0, v1, "Database directory does not exist", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_0();
}

void SafeBrowsing::Service::handleDeleteAllDatabases(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138543362;
  *(_QWORD *)(a2 + 4) = a1;
  OUTLINED_FUNCTION_1_1(&dword_1DBCBE000, a2, a3, "Failed to delete all databases: %{public}@", (uint8_t *)a2);

  OUTLINED_FUNCTION_0();
}

void Platform::SharedMemory::createFileMapping(uint64_t a1, uint64_t a2, int a3)
{
  uint8_t *v3;
  NSObject *v4;

  OUTLINED_FUNCTION_1_4(1.5047e-36, a1, a2, a3);
  OUTLINED_FUNCTION_0_1(&dword_1DBCBE000, "Failed to mmap file descriptor %i: %{errno}i", v3, v4);
}

{
  uint8_t *v3;
  NSObject *v4;

  OUTLINED_FUNCTION_1_4(1.5047e-36, a1, a2, a3);
  OUTLINED_FUNCTION_0_1(&dword_1DBCBE000, "Failed to fstat file descriptor %i: %{errno}i", v3, v4);
}

void SafeBrowsing::BrowsingDatabaseCoordinator::handleGetDatabasesReply(char *a1, uint8_t *buf, os_log_t log)
{
  char *v4;

  if (a1[23] >= 0)
    v4 = a1;
  else
    v4 = *(char **)a1;
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)(buf + 4) = v4;
  _os_log_error_impl(&dword_1DBCBE000, log, OS_LOG_TYPE_ERROR, "Encountered xpc error for GetDatabases response with error: %{public}s", buf, 0xCu);
  if (a1[23] < 0)
    operator delete(*(void **)a1);
}

void SafeBrowsing::BrowsingDatabaseCoordinator::performURLLookup(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_2(&dword_1DBCBE000, a2, a3, "There are no matches in databases with given url: %@", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_0_2(&dword_1DBCBE000, a2, a3, "Perform url lookup in the database: %@", a5, a6, a7, a8, 2u);
}

void Backend::Google::SSBUtilities::currentCountryCode(uint64_t a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)buf = 138412290;
  *(_QWORD *)(buf + 4) = a1;
  _os_log_error_impl(&dword_1DBCBE000, log, OS_LOG_TYPE_ERROR, "AppleLocale preferences is a %@ but expected a string", buf, 0xCu);
}

void Backend::Google::DeviceIdentificationTokenFetcher::didFetchDeviceIdentificationToken(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = *(_DWORD *)(a2 + 200);
  v4 = 138412546;
  v5 = a1;
  v6 = 1024;
  v7 = v3;
  _os_log_error_impl(&dword_1DBCBE000, log, OS_LOG_TYPE_ERROR, "Device identification token parse error %@ for %d server", (uint8_t *)&v4, 0x12u);
}

void Backend::Google::DeviceIdentificationTokenFetcher::didFetchDeviceIdentificationToken(uint64_t *a1, NSObject *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = 138412290;
  v4 = v2;
  _os_log_debug_impl(&dword_1DBCBE000, a2, OS_LOG_TYPE_DEBUG, "Token dictionary keys %@", (uint8_t *)&v3, 0xCu);
}

unsigned __int8 *__cdecl CC_SHA256(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1E0C80368](data, *(_QWORD *)&len, md);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x1E0C80370](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x1E0C80378](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1E0C80380](c, data, *(_QWORD *)&len);
}

CFIndex CFHTTPMessageGetResponseStatusCode(CFHTTPMessageRef response)
{
  return MEMORY[0x1E0C92848](response);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x1E0C988B0](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988B8]();
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  MEMORY[0x1E0C98900](center, observer, name, object);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A60](key, applicationID, userName, hostName);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

Boolean CFURLCanBeDecomposed(CFURLRef anURL)
{
  return MEMORY[0x1E0C992B0](anURL);
}

uint64_t CFURLConnectionCancel()
{
  return MEMORY[0x1E0C92928]();
}

uint64_t CFURLConnectionCreate()
{
  return MEMORY[0x1E0C92930]();
}

uint64_t CFURLConnectionSetDelegateDispatchQueue()
{
  return MEMORY[0x1E0C92950]();
}

uint64_t CFURLConnectionStart()
{
  return MEMORY[0x1E0C92958]();
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99418](allocator, URLBytes, length, *(_QWORD *)&encoding, baseURL);
}

CFRange CFURLGetByteRangeForComponent(CFURLRef url, CFURLComponentType component, CFRange *rangeIncludingSeparators)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99480](url, component, rangeIncludingSeparators);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFURLGetBytes(CFURLRef url, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1E0C99488](url, buffer, bufferLength);
}

uint64_t CFURLRequestCreateMutable()
{
  return MEMORY[0x1E0C929C0]();
}

uint64_t CFURLRequestSetProxySettings()
{
  return MEMORY[0x1E0C92A10]();
}

uint64_t CFURLResponseGetHTTPResponse()
{
  return MEMORY[0x1E0C92A68]();
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return (NSArray *)MEMORY[0x1E0CB3178](directory, domainMask, expandTilde);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1E0CB3200](aClass);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x1E0CB3230](aSelector);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

std::string *__cdecl std::error_code::message(std::string *__return_ptr retstr, const std::error_code *this)
{
  return (std::string *)MEMORY[0x1E0DE41A0](retstr, this);
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x1E0DE41C8](this, __c, __pos);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1E0DE4248](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1E0DE4258](this);
}

std::exception_ptr *__cdecl std::exception_ptr::exception_ptr(std::exception_ptr *this, const std::exception_ptr *a2)
{
  return (std::exception_ptr *)MEMORY[0x1E0DE42F0](this, a2);
}

void std::exception_ptr::~exception_ptr(std::exception_ptr *this)
{
  MEMORY[0x1E0DE42F8](this);
}

void std::__call_once(std::once_flag::_State_type *a1, void *a2, void (__cdecl *a3)(void *))
{
  MEMORY[0x1E0DE43A8](a1, a2, a3);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1E0DE43E8](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
  MEMORY[0x1E0DE43F8](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add, __p_new_stuff);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4420](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4428](this, __s, __n);
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
  MEMORY[0x1E0DE44A8](this, __requested_capacity);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
  MEMORY[0x1E0DE44B0](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add);
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1E0DE44C8](this, __str, __pos, __n, __a);
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1E0DE46B0]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1E0DE46B8]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1E0DE46C8]();
}

std::random_device *__cdecl std::random_device::random_device(std::random_device *this, const std::string *__token)
{
  return (std::random_device *)MEMORY[0x1E0DE4770](this, __token);
}

void std::random_device::~random_device(std::random_device *this)
{
  MEMORY[0x1E0DE4778](this);
}

std::random_device::result_type std::random_device::operator()(std::random_device *this)
{
  return MEMORY[0x1E0DE4780](this);
}

void std::error_category::~error_category(std::error_category *this)
{
  MEMORY[0x1E0DE47C0](this);
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

const std::error_category *std::system_category(void)
{
  return (const std::error_category *)MEMORY[0x1E0DE4848]();
}

const std::error_category *std::generic_category(void)
{
  return (const std::error_category *)MEMORY[0x1E0DE4858]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1E0DE48F8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
  MEMORY[0x1E0DE4930](__format);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA0](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA8](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x1E0DE4AB8](this);
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x1E0DE4B38]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x1E0DE4B48]();
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x1E0DE4B98](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x1E0DE4C80](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

void std::rethrow_exception(std::exception_ptr a1)
{
  MEMORY[0x1E0DE4DF8](a1.__ptr_);
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

void operator delete[](void *__p)
{
  off_1EA3E9770(__p);
}

void operator delete(void *__p)
{
  off_1EA3E9778(__p);
}

void *__cdecl operator new[](size_t __sz)
{
  return (void *)off_1EA3E9780(__sz);
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1EA3E9788(__sz);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1E0C80B50](*(_QWORD *)&a1, a2);
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C70](*(_QWORD *)&a1);
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81020](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81040](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1E0C813D0](a1, *(_QWORD *)&a2);
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1E0C81588](*(_QWORD *)&__upper_bound);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BE8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1E0C82D20]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x1E0C82D28](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x1E0C82D30](group);
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82D38](group, queue, block);
}

void dispatch_main(void)
{
  MEMORY[0x1E0C82DF0]();
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E38](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x1E0C82F78](source, start, interval, leeway);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return MEMORY[0x1E0C82FC8](when, delta);
}

uint64_t dyld_image_header_containing_address()
{
  return MEMORY[0x1E0C830F8]();
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1E0C83158]();
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

int ferror(FILE *a1)
{
  return MEMORY[0x1E0C83348](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x1E0C83530](a1, a2, *(_QWORD *)&a3);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1E0C83560](*(_QWORD *)&a1, a2);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x1E0C83580](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

uid_t geteuid(void)
{
  return MEMORY[0x1E0C83668]();
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return (passwd *)MEMORY[0x1E0C837A0](*(_QWORD *)&a1);
}

uid_t getuid(void)
{
  return MEMORY[0x1E0C83828]();
}

int inet_aton(const char *a1, in_addr *a2)
{
  return MEMORY[0x1E0C83958](a1, a2);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return (const char *)MEMORY[0x1E0C83968](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C84160](a1, a2);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1E0C841D8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1E0C84220](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1E0C843D8](*(_QWORD *)&token);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1E0C843F8](name);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

uint64_t nw_activity_activate()
{
  return MEMORY[0x1E0CCEDE0]();
}

uint64_t nw_activity_complete_with_reason()
{
  return MEMORY[0x1E0CCEDE8]();
}

uint64_t nw_activity_create()
{
  return MEMORY[0x1E0CCEE00]();
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7BE8](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1E0DE7BF8]();
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7C38](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x1E0DE7C60](location);
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1E0DE7CE0](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1E0DE7D08](location);
}

void objc_moveWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7D18](to, from);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7E58](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E60](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1E0DE7E70](a1);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x1E0DE7FB0](location, obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7FE0](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1E0C84480](a1, *(_QWORD *)&a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

uint64_t os_variant_allows_internal_security_policies()
{
  return MEMORY[0x1E0C849D8]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x1E0C84F88](__base, __nel, __width, __compar);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x1E0C85100](__from, __to, __ec);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85698](__str, __endptr, *(_QWORD *)&__base);
}

int unlink(const char *a1)
{
  return MEMORY[0x1E0C859B8](a1);
}

xpc_object_t xpc_activity_copy_criteria(xpc_activity_t activity)
{
  return (xpc_object_t)MEMORY[0x1E0C85D80](activity);
}

xpc_activity_state_t xpc_activity_get_state(xpc_activity_t activity)
{
  return MEMORY[0x1E0C85D90](activity);
}

void xpc_activity_register(const char *identifier, xpc_object_t criteria, xpc_activity_handler_t handler)
{
  MEMORY[0x1E0C85D98](identifier, criteria, handler);
}

void xpc_activity_set_criteria(xpc_activity_t activity, xpc_object_t criteria)
{
  MEMORY[0x1E0C85DB0](activity, criteria);
}

BOOL xpc_activity_set_state(xpc_activity_t activity, xpc_activity_state_t state)
{
  return MEMORY[0x1E0C85DB8](activity, state);
}

void xpc_activity_unregister(const char *identifier)
{
  MEMORY[0x1E0C85DD0](identifier);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
  MEMORY[0x1E0C85DE0](xarray, value);
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return MEMORY[0x1E0C85DF8](xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C85E00](objects, count);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x1E0C85E30](xarray);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1E0C85E90](xarray, index);
}

void xpc_connection_cancel(xpc_connection_t connection)
{
  MEMORY[0x1E0C85F68](connection);
}

uint64_t xpc_connection_copy_bundle_id()
{
  return MEMORY[0x1E0C85F70]();
}

uint64_t xpc_connection_copy_entitlement_value()
{
  return MEMORY[0x1E0C85F78]();
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1E0C85FB0](name, targetq, flags);
}

uint64_t xpc_connection_get_audit_token()
{
  return MEMORY[0x1E0C85FD0]();
}

const char *__cdecl xpc_connection_get_name(xpc_connection_t connection)
{
  return (const char *)MEMORY[0x1E0C86000](connection);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return MEMORY[0x1E0C86008](connection);
}

void xpc_connection_resume(xpc_connection_t connection)
{
  MEMORY[0x1E0C86018](connection);
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
  MEMORY[0x1E0C86030](connection, message);
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
  MEMORY[0x1E0C86038](connection, message, replyq, handler);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
  MEMORY[0x1E0C86080](connection, handler);
}

size_t xpc_data_get_bytes(xpc_object_t xdata, void *buffer, size_t off, size_t length)
{
  return MEMORY[0x1E0C86190](xdata, buffer, off, length);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return (const void *)MEMORY[0x1E0C86198](xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return MEMORY[0x1E0C861A8](xdata);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C86208](keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return (xpc_object_t)MEMORY[0x1E0C86228](original);
}

xpc_object_t xpc_dictionary_get_array(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C86248](xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C86260](xdict, key);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862A0](xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return (xpc_connection_t)MEMORY[0x1E0C862B0](xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1E0C862C8](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862D0](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C862E0](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
  MEMORY[0x1E0C86310](xdict, key, value);
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
  MEMORY[0x1E0C86330](xdict, key, bytes, length);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
  MEMORY[0x1E0C86360](xdict, key, value);
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x1E0C86390](xdict, key, string);
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
  MEMORY[0x1E0C86398](xdict, key, value);
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
  MEMORY[0x1E0C863B8](xdict, key, value);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1E0C86520](object);
}

xpc_object_t xpc_shmem_create(void *region, size_t length)
{
  return (xpc_object_t)MEMORY[0x1E0C866F0](region, length);
}

size_t xpc_shmem_map(xpc_object_t xshmem, void **region)
{
  return MEMORY[0x1E0C86700](xshmem, region);
}

xpc_object_t xpc_string_create(const char *string)
{
  return (xpc_object_t)MEMORY[0x1E0C86720](string);
}

size_t xpc_string_get_length(xpc_object_t xstring)
{
  return MEMORY[0x1E0C86748](xstring);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return (const char *)MEMORY[0x1E0C86758](xstring);
}

void xpc_transaction_begin(void)
{
  MEMORY[0x1E0C86768]();
}

void xpc_transaction_end(void)
{
  MEMORY[0x1E0C86770]();
}

uint64_t xpc_uint64_get_value(xpc_object_t xuint)
{
  return MEMORY[0x1E0C867B8](xuint);
}

